- en: 2 The Series object
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 系列对象
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Instantiating `Series` objects from lists, dictionaries, tuples, and more
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表、字典、元组等实例化 `Series` 对象
- en: Setting a custom index on a `Series`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Series`上设置自定义索引
- en: Accessing attributes and invoking methods on a `Series`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`Series`对象的属性和调用其方法
- en: Performing mathematical operations on one or more `Series`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对一个或多个 `序列` 执行数学运算
- en: Passing the `Series` to Python’s built-in functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Series` 传递给 Python 的内置函数
- en: One of pandas’ core data structures, the `Series` is a one-dimensional labeled
    array for homogeneous data. An *array* is an ordered collection of values comparable
    to a Python list. The term *homogeneous* means that the values are of the same
    data type (all integers or all Booleans, for example).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas的核心数据结构之一，`Series`是一个用于同质数据的单维标签数组。*数组*是有序值集合，类似于Python列表。术语*同质*意味着值具有相同的数据类型（例如，所有整数或所有布尔值）。
- en: 'Pandas assigns each `Series` value a *label*—an identifier we can use to locate
    the value. The library also assigns each `Series` value an *order*—a position
    in line. The order starts counting from 0; the first `Series` value occupies position
    0, the second value occupies position 1, and so on. The `Series` is a one-dimensional
    data structure because we need one reference point to access a value: either a
    label or a position.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 为每个 `Series` 值分配一个 *标签*——一个我们可以用来定位值的标识符。该库还为每个 `Series` 值分配一个 *顺序*——一个在行中的位置。顺序从
    0 开始计数；第一个 `Series` 值占据位置 0，第二个值占据位置 1，以此类推。`Series` 是一个一维数据结构，因为我们需要一个参考点来访问一个值：要么是一个标签，要么是一个位置。
- en: A `Series` combines and expands the best features of Python’s native data structures.
    Like a list, it holds its values in a sequenced order. Like a dictionary, it assigns
    a key/label to each value. We gain the benefits of both of those objects plus
    more than 180 methods for data manipulation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`系列`结合并扩展了Python原生数据结构的最佳特性。就像列表一样，它以有序的方式存储其值。就像字典一样，它为每个值分配一个键/标签。我们获得了这两个对象的好处，以及超过180种数据操作方法。'
- en: In this chapter, we’ll familiarize ourselves with the mechanics of a `Series`
    object, learn how to calculate the sum and average of `Series` values, apply mathematical
    operations to each `Series` value, and more. As a building block of pandas, the
    `Series` is a perfect starting point for our exploration of the library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将熟悉`Series`对象的机制，学习如何计算`Series`值的总和和平均值，对每个`Series`值应用数学运算，以及更多内容。作为pandas的基石，`Series`是探索该库的完美起点。
- en: 2.1 Overview of a Series
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 系列概述
- en: 'Let’s create some `Series` objects, shall we? We’ll begin by importing the
    pandas and NumPy packages with the `import` keyword; we’ll use the latter library
    in section 2.1.4\. The popular community aliases for `pandas` and `numpy` are
    `pd` and `np`. We can assign an alias to an import with the `as` keyword:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些 `Series` 对象，好吗？我们将从使用 `import` 关键字导入 pandas 和 NumPy 包开始；我们将在 2.1.4 节中使用后者库。`pandas`
    和 `numpy` 的流行社区别名是 `pd` 和 `np`。我们可以使用 `as` 关键字给导入项指定别名：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `pd` namespace holds the top-level exports of the `pandas` package, a bundle
    of more than 100 classes, functions, exceptions, constants, and more. For more
    information on these concepts, see appendix B.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd` 命名空间包含 `pandas` 包的顶级导出，这是一个包含超过 100 个类、函数、异常、常量等功能的集合。有关这些概念的信息，请参阅附录
    B。'
- en: 'Think of `pd` as being the lobby to the library—an entrance room where we can
    access pandas’ available features. The library’s exports are available as attributes
    on `pd`. We can access an attribute with dot syntax:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将`pd`视为图书馆的大厅——一个我们可以访问pandas可用功能的入口房间。图书馆的导出项作为`pd`的属性可用。我们可以使用点符号来访问一个属性：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Jupyter Notebook provides a convenient autocomplete feature for use in searching
    for attributes. Enter the library’s name, add a dot, and press the Tab key to
    reveal a modal of the package’s exports. As you type additional characters, the
    Notebook filters the results to those that match your search term.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Notebook 提供了一个方便的自动补全功能，用于搜索属性。输入库的名称，添加一个点，然后按 Tab 键以显示包的导出模态。随着你输入更多字符，笔记本会过滤结果以匹配你的搜索词。
- en: '![](../Images/CH02_F01_Paskhaver.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Paskhaver.png)'
- en: Figure 2.1 Using Jupyter Notebook’s autocomplete features to show pandas exports
    that start with `S`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 使用Jupyter Notebook的自动完成功能来显示以`S`开头的pandas导出
- en: 'Figure 2.1 shows the autocomplete feature in action. After entering the capital
    letter `S`, we can press Tab to reveal all `pd` exports starting with that character.
    Note that the search is case-sensitive. If the autocomplete feature is not working,
    add the following code to a cell in your Notebook, execute it, and try searching
    again:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 展示了自动完成功能在作用。在输入大写字母 `S` 后，我们可以按 Tab 键来显示所有以该字符开头的 `pd` 导出。请注意，搜索是区分大小写的。如果自动完成功能不起作用，请将以下代码添加到笔记本中的一个单元格中，执行它，然后再次尝试搜索：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can use our keyboard’s up- and down-arrow keys to navigate the modal’s search
    results. Luckily, the `Series` class is our first search result. Press the Enter
    key to autocomplete its name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用键盘的上箭头和下箭头键在模式搜索结果中导航。幸运的是，`Series` 类是我们的第一个搜索结果。按 Enter 键来自动完成其名称。
- en: 2.1.1 Classes and instances
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 类和实例
- en: 'A *class* is a blueprint for a Python object. The `pd.Series` class is a template,
    and the next step is to create a concrete instance of it. We instantiate an object
    from a class with a pair of opening and closing parentheses. Let’s create a `Series`
    object from the `Series` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *类* 是一个 Python 对象的蓝图。`pd.Series` 类是一个模板，下一步是创建它的具体实例。我们通过一对括号从类中实例化一个对象。让我们从
    `Series` 类创建一个 `Series` 对象：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A warning might appear in a red box alongside the output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会在输出旁边出现一个红色框中的警告：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because we did not provide any values to store, pandas could not infer the data
    type that the `Series` should hold. No need to worry; the warning is expected
    behavior.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有提供任何要存储的值，pandas 无法推断 `Series` 应该持有的数据类型。无需担心；警告是预期行为。
- en: We’ve successfully created our first `Series` object! Unfortunately, it stores
    no data. Let’s populate our `Series` with some values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了我们的第一个 `Series` 对象！不幸的是，它没有存储任何数据。让我们用一些值填充我们的 `Series`。
- en: 2.1.2 Populating the Series with values
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 用值填充 Series
- en: A *constructor* is a method that builds an object from a class. When we wrote
    `pd.Series()` in section 2.1.1, we used the `Series` constructor to create a new
    `Series` object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *构造函数* 是一个从类中构建对象的方法。当我们在第 2.1.1 节中写下 `pd.Series()` 时，我们使用了 `Series` 构造函数来创建一个新的
    `Series` 对象。
- en: When we create an object, we’ll often want to define its starting state. We
    can think of an object’s starting state as being its initial configuration—its
    “settings.” We can often set state by passing arguments to the constructor that
    we use to create the object. An *argument* is an input we pass to a method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个对象时，我们通常会想要定义其初始状态。我们可以将对象的初始状态视为其初始配置——其“设置”。我们通常可以通过传递给创建对象的构造函数的参数来设置状态。一个
    *参数* 是我们传递给方法的输入。
- en: Let’s practice creating some `Series` from manual data. The goal is to get comfortable
    with the look and feel of the data structure. In the future, we’ll use an imported
    data set to populate our `Series`’ values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习从手动数据创建一些 `Series`。目标是熟悉数据结构的外观和感觉。在未来，我们将使用导入的数据集来填充我们的 `Series` 的值。
- en: The first argument to the `Series` constructor is an iterable object whose values
    will populate the `Series`. We can pass various inputs, including lists, dictionaries,
    tuples, and NumPy `ndarray`s`.`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 构造函数的第一个参数是一个可迭代对象，其值将填充 `Series`。我们可以传递各种输入，包括列表、字典、元组和 NumPy `ndarray`s。`'
- en: 'Let’s create a `Series` object with data from a Python list. The next example
    declares a list of four strings, assigns the list to an `ice_cream_flavors` variable,
    and then passes the list to the `Series` constructor:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Python 列表中的数据创建一个 `Series` 对象。下一个示例声明了一个包含四个字符串的列表，将列表赋值给 `ice_cream_flavors`
    变量，然后将列表传递给 `Series` 构造函数：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Excellent—we’ve created a new `Series` with the four values from our `ice_cream_
    flavors` list. Notice that pandas preserves the order of the strings from the
    input list. We’ll come back to the numbers on the left of the `Series` in a moment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 极好——我们已经使用来自我们的 `ice_cream_ flavors` 列表的四个值创建了一个新的 `Series`。注意，pandas 保留了输入列表中字符串的顺序。我们稍后会回到
    `Series` 左侧的数字。
- en: A *parameter* is a name given to an expected input to a function or method.
    Behind the scenes, Python matches every argument we pass to a constructor with
    a parameter. We can view a constructor’s parameters directly in Jupyter Notebook.
    Enter `pd.Series``()` in a new cell, place the mouse cursor between the parentheses,
    and press Shift+Tab. Figure 2.2 shows the documentation modal that appears.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *参数* 是指给函数或方法的一个预期输入的名称。在幕后，Python 会将我们传递给构造函数的每个参数与一个参数匹配。我们可以在 Jupyter
    Notebook 中直接查看构造函数的参数。在一个新单元格中输入 `pd.Series()`，将鼠标光标放在括号之间，然后按 Shift+Tab。图 2.2
    展示了出现的文档模式。
- en: '![](../Images/CH02_F02_Paskhaver.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Paskhaver.png)'
- en: Figure 2.2 A documentation modal with the parameters and default arguments for
    a `Series` constructor
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 一个带有 `Series` 构造函数参数和默认值的文档模式
- en: Press Shift+Tab repeatedly to reveal more information. Eventually, Jupyter will
    fix the documentation panel to the bottom of the screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重复按 Shift+Tab 键以显示更多信息。最终，Jupyter 将将文档面板固定在屏幕底部。
- en: 'The `Series` constructor defines six parameters: `data`, `index`, `dtype`,
    `name`, `copy`, and `fastpath`. We can use these parameters to set the object’s
    initial state. We can think of the parameters as being configuration options for
    the `Series`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 构造函数定义了六个参数：`data`、`index`、`dtype`、`name`、`copy` 和 `fastpath`。我们可以使用这些参数来设置对象的初始状态。我们可以将参数视为
    `Series` 的配置选项。'
- en: The documentation displays each parameter alongside its default argument. A
    *default argument* is a fallback value that Python uses if we do not provide an
    argument for the parameter. If we do not pass a value for the `name` parameter,
    for example, Python will use `None`. A parameter with a default argument is inherently
    optional. It will always have some argument, either explicitly from its invocation
    or implicitly from its definition. We were able to instantiate a `Series` without
    arguments earlier because all six of its constructor’s parameters are optional.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文档显示每个参数及其默认值。*默认值* 是 Python 在我们没有为参数提供参数时使用的回退值。例如，如果我们不为 `name` 参数传递值，Python
    将使用 `None`。具有默认值的参数本质上是可选的。它始终会有一些参数，无论是从其调用还是从其定义中隐式地获得。我们之前能够不带参数实例化一个 `Series`，因为其构造函数的所有六个参数都是可选的。
- en: The `Series` constructor’s first parameter, `data`, expects the object whose
    values will populate the `Series`. If we pass arguments to the constructor without
    parameter names, Python will assume that we are passing them sequentially. In
    the preceding code example, we passed the `ice_cream_flavors` list as the first
    argument to the constructor; thus, Python matched it with `data`, the first constructor
    parameter. Python also fell back to default arguments of `None` for the `index`,
    `dtype`, and `name` parameters and `False` for the `copy` and `fastpath` parameters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 构造函数的第一个参数 `data` 期望的是一个对象，其值将填充到 `Series` 中。如果我们向构造函数传递参数而没有参数名称，Python
    将假设我们是按顺序传递它们的。在先前的代码示例中，我们将 `ice_cream_flavors` 列表作为构造函数的第一个参数传递；因此，Python 将其与第一个构造函数参数
    `data` 匹配。Python 还将 `index`、`dtype` 和 `name` 参数的默认值设置为 `None`，以及将 `copy` 和 `fastpath`
    参数的默认值设置为 `False`。'
- en: 'We can connect parameters and arguments explicitly with keyword arguments (see
    appendix B). Enter the parameter, followed by an equal sign and its argument.
    In the following example, the first line uses positional arguments, and the second
    one uses keyword arguments, but the result is the same:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用关键字参数明确地将参数和参数连接起来（参见附录 B）。输入参数，后跟一个等号和其参数。在以下示例中，第一行使用位置参数，第二行使用关键字参数，但结果相同：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keyword arguments are advantageous because they provide context for what each
    constructor argument represents. The second line in the example better communicates
    that `ice_cream_flavors` represents the `data` for the `Series`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数是有优势的，因为它们为每个构造函数参数提供了上下文。示例中的第二行更好地传达了 `ice_cream_flavors` 代表 `Series`
    的 `data`。
- en: 2.1.3 Customizing the Series index
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 自定义 `Series` 索引
- en: 'Let’s take a closer look at our `Series`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的 `Series`：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Earlier, we mentioned that pandas assigns a position in line to each `Series`
    value. The collection of incrementing integers on the left side of the output
    is called the index. Each number signifies a value’s order within the `Series`.
    The index starts counting from 0\. The string `"Chocolate"` occupies index 0,
    the string `"Vanilla"` occupies index 1, and so on. In graphical spreadsheet applications,
    the first row of data starts counting at 1—an important difference between pandas
    and Excel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，pandas 为每个 `Series` 值分配一个行位置。输出左侧的递增整数集合被称为索引。每个数字表示一个值在 `Series` 中的顺序。索引从
    0 开始计数。字符串 `"Chocolate"` 占据索引 0，字符串 `"Vanilla"` 占据索引 1，以此类推。在图形电子表格应用程序中，数据的第一行从
    1 开始计数——这是 pandas 和 Excel 之间的重要区别。
- en: 'The term *index* describes both the collection of identifiers and an individual
    identifier. Both of these two expressions are valid: “The index of the `Series`
    consists of integers” and “The value `''Strawberry''` is found at index `2` in
    the `Series`.”'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *index* 既可以指代标识符的集合，也可以指代单个标识符。这两个表达都是有效的：“`Series` 的索引由整数组成”和“值 `'Strawberry'`
    在 `Series` 中的索引位置是 `2`。”
- en: The last index position will always be 1 less than the total number of values.
    The current `Series` has four ice cream flavors, so the index counts up to 3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个索引位置总是比值的总数少 1。当前的 `Series` 有四种冰淇淋口味，因此索引计数到 3。
- en: 'In addition to an index position, we can assign each `Series` value an index
    label. Index labels can be of any immutable data type: strings, tuples, datetimes,
    and more. This flexibility makes a `Series` powerful: we can reference a value
    by its order or by a key/label. In a sense, each value has two identifiers.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了索引位置之外，我们还可以为每个 `Series` 值分配一个索引标签。索引标签可以是任何不可变的数据类型：字符串、元组、日期时间等。这种灵活性使 `Series`
    非常强大：我们可以通过其顺序或键/标签来引用值。从某种意义上说，每个值都有两个标识符。
- en: The `Series` constructor’s second parameter, `index`, sets the index labels
    of the `Series`. If we do not pass an argument to the parameter, pandas defaults
    to a numeric index starting from 0\. With this type of index, the label and the
    position identifiers are one and the same.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 构造函数的第二个参数 `index` 用于设置 `Series` 的索引标签。如果我们不向该参数传递任何参数，pandas 默认使用从
    0 开始的数值索引。这种类型的索引中，标签和位置标识符是相同的。'
- en: 'Let’s construct a `Series` with a custom index. We can pass objects of different
    data types to the `data` and `index` parameters, but they must have the same length
    so that pandas can associate their values. The next example passes a list of strings
    for the `data` parameter and a tuple of strings to the `index` parameter. Both
    the list and the tuple have a length of `4`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个具有自定义索引的 `Series`。我们可以向 `data` 和 `index` 参数传递不同数据类型的对象，但它们的长度必须相同，这样
    pandas 才能关联它们的值。下一个示例将字符串列表传递给 `data` 参数，并将字符串元组传递给 `index` 参数。列表和元组的长度都是 `4`：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pandas uses shared index positions to associate the values from the `ice_cream_
    flavors` list and the `days_of_week` tuple. The library sees `"Rum` `Raisin"`
    and `"Saturday"` at index position `3` in their respective objects, for example;
    thus, it ties them together in the `Series`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 使用共享索引位置将 `ice_cream_flavors` 列表和 `days_of_week` 元组中的值关联起来。例如，库在各自的对象中将
    `"Rum Raisin"` 和 `"Saturday"` 视为索引位置 `3`；因此，它在 `Series` 中将它们关联起来。
- en: Even though the index consists of string labels, pandas still assigns each `Series`
    value an index position. In other words, we can access the value `"Vanilla"` either
    by the index label `"Wednesday"` or by index position 1\. We’ll explore how to
    access `Series` elements by row and label in chapter 4.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使索引由字符串标签组成，pandas 仍然为每个 `Series` 值分配一个索引位置。换句话说，我们可以通过索引标签 `"Wednesday"` 或索引位置
    1 来访问值 `"Vanilla"`。我们将在第 4 章探讨如何通过行和标签访问 `Series` 元素。
- en: 'The index permits duplicates, a detail that distinguishes a `Series` from a
    Python dictionary. In the next example, the string `"Wednesday"` appears twice
    in the `Series`’ index labels:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 索引允许重复，这是 `Series` 与 Python 字典区别的一个细节。在下一个示例中，字符串 `"Wednesday"` 在 `Series` 的索引标签中出现了两次：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although pandas permits duplicates, it is ideal to avoid them whenever possible,
    because a unique index allows the library to locate index labels more quickly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管pandas 允许重复，但尽可能避免重复是理想的，因为唯一的索引允许库更快地定位索引标签。
- en: 'One additional advantage of keyword arguments is that they permit us to pass
    parameters in any order. By comparison, sequential/positional arguments require
    us to pass arguments in the order in which the constructor expects them. The next
    example swaps the order of the `index` and `data` keyword parameters. Pandas creates
    the same `Series`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数的一个额外优点是它们允许我们以任何顺序传递参数。相比之下，顺序/位置参数要求我们按照构造函数期望的顺序传递参数。下一个示例交换了 `index`
    和 `data` 关键字参数的顺序。Pandas 创建了相同的 `Series`：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There’s one piece of the output that we haven’t discussed yet: the `dtype`
    statement at the bottom reflects the data type of the values in the `Series`.
    For most data types, pandas will display a predictable type (such as `bool`, `float`,
    or `int`). For strings and more-complex objects (such as nested data structures),
    pandas will show `dtype: object`. [¹](#pgfId-1082705)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还没有讨论输出中的一个部分：底部的 `dtype` 语句反映了 `Series` 中值的类型。对于大多数数据类型，pandas 将显示一个可预测的类型（例如
    `bool`、`float` 或 `int`）。对于字符串和更复杂的对象（例如嵌套数据结构），pandas 将显示 `dtype: object`。[¹](#pgfId-1082705)'
- en: 'The next examples create `Series` objects from lists of Boolean, integer, and
    floating-point values. Observe the similarities and differences in the `Series`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例从布尔值、整数和浮点数值的列表中创建 `Series` 对象。观察 `Series` 中的相似之处和不同之处：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `float64` and `int64` data types indicate that each floating-point/integer
    value in the `Series` occupies 64 bits (8 bytes) of your computer’s RAM. Bits
    and bytes are storage units for memory. We don’t need to dive extensively into
    these computer science concepts right now to work effectively with pandas.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`float64` 和 `int64` 数据类型表明，`Series` 中的每个浮点数/整数值在您的计算机 RAM 中占用 64 位（8 字节）。位和字节是内存的存储单位。我们不需要深入探讨这些计算机科学概念，就可以有效地使用
    pandas。'
- en: 'Pandas does its best to infer an appropriate data type for the `Series` from
    the `data` parameter’s values. We can force coercion to a different type via the
    constructor’s `dtype` parameter. The next example passes an integer list to the
    constructor but asks for a floating-point `Series`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 会尽力从 `data` 参数的值推断出适合 `Series` 的数据类型。我们可以通过构造函数的 `dtype` 参数强制转换到不同的类型。下一个示例将整数列表传递给构造函数，但要求一个浮点数
    `Series`：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous example used both positional arguments and keyword arguments. We
    passed the `lucky_numbers` list sequentially to the `data` parameter. We also
    passed the `dtype` parameter explicitly with keyword arguments. The `Series` constructor
    expects the `dtype` parameter to be third in line, so we cannot pass it directly
    after `lucky_numbers`; we have to use keyword arguments.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例同时使用了位置参数和关键字参数。我们按顺序将 `lucky_numbers` 列表传递给 `data` 参数。我们还通过关键字参数显式地传递了
    `dtype` 参数。`Series` 构造函数期望 `dtype` 参数是第三个参数，因此我们不能直接在 `lucky_numbers` 之后传递它；我们必须使用关键字参数。
- en: 2.1.4 Creating a Series with missing values
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 创建带有缺失值的 Series
- en: So far, so good. Our `Series` so far have been simple and complete. It’s easy
    to have perfect data when we’re crafting our own data sets. In the real world,
    data is a lot messier. Perhaps the most frequent problem that analysts encounter
    is missing values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们到目前为止的 `Series` 都很简单且完整。当我们自己构建数据集时，拥有完美的数据很容易。在现实世界中，数据要复杂得多。分析师遇到的最常见问题可能是缺失值。
- en: When pandas sees a missing value during a file import, the library substitutes
    NumPy’s `nan` object. The acronym `nan` is short for *not a number* and is a catch-all
    term for an undefined value. In other words, `nan` is a placeholder object that
    represents nullness or absence.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pandas 在文件导入期间看到缺失值时，库会替换 NumPy 的 `nan` 对象。`nan` 的缩写是 *not a number*，是一个用于未定义值的通用术语。换句话说，`nan`
    是一个表示空缺或缺失的占位符对象。
- en: 'Let’s sneak a missing value into a `Series`. We assigned the NumPy library
    to the alias `np` when we imported it earlier. The `nan` attribute is available
    as a top-level export of the library. The next example nestles a `np.nan` inside
    a list of temperatures that we pass to the `Series` constructor. Notice the `NaN`
    at index position 2 in the output. Get used to this trio of letters; we’re going
    to be seeing them a lot throughout the book:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Series` 中偷偷加入一个缺失值。当我们之前导入时，我们将 NumPy 库分配给别名 `np`。库的顶层导出中可用 `nan` 属性。下一个示例将
    `np.nan` 嵌入我们传递给 `Series` 构造函数的温度列表中。注意输出中索引位置 2 的 `NaN`。习惯这三个字母的组合；我们将在整本书中经常看到它们：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the `Series` `dtype` is `float64`. Pandas automatically converts
    numeric values from integers to floating-points when it spots a `nan` value; this
    internal technical requirement allows the library to store numeric values and
    missing values in the same homogeneous `Series`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Series` 的 `dtype` 是 `float64`。当 Pandas 发现 `nan` 值时，会自动将数值从整数转换为浮点数；这个内部技术要求使得库能够将数值和缺失值存储在同一个同质的
    `Series` 中。
- en: 2.2 Creating a Series from Python objects
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 从 Python 对象创建 Series
- en: The `Series` constructor’s `data` parameter accepts various inputs, including
    native Python data structures and objects from other libraries. In this section,
    we’ll explore how the `Series` constructor deals with dictionaries, tuples, sets,
    and NumPy arrays. The `Series` object that pandas returns operates the same way
    irrespective of its data source.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 构造函数的 `data` 参数接受各种输入，包括原生 Python 数据结构和来自其他库的对象。在本节中，我们将探讨 `Series`
    构造函数如何处理字典、元组、集合和 NumPy 数组。pandas 返回的 `Series` 对象无论其数据源如何，操作方式都是相同的。'
- en: 'A *dictionary* is a collection of key-value pairs (see appendix B). When passed
    a dictionary, the constructor sets each key as a corresponding index label in
    the `Series`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *字典* 是一组键值对（参见附录B）。当传递一个字典给构造函数时，它会将每个键设置为 `Series` 中相应的索引标签：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A *tuple* is an immutable list. We cannot add, remove, or replace elements
    in a tuple after creating it (see appendix B). When passed a tuple, the constructor
    populates the `Series` in an expected manner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *元组* 是一个不可变列表。在创建元组之后，我们无法添加、删除或替换其中的元素（参见附录B）。当传递一个元组给构造函数时，它会以预期的方式填充 `Series`：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a `Series` that stores tuples, wrap the tuples in a list. Tuples
    work well for row values that consist of multiple parts or components, such as
    an address:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个存储元组的 `Series`，请将元组包裹在一个列表中。元组非常适合由多个部分或组件组成的行值，例如地址：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A *set* is an unordered collection of unique values. We can declare it with
    a pair of curly braces, exactly like a dictionary. Python uses the presence of
    key-value pairs to distinguish between the two data structures (see appendix B).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *集合* 是一个无序的唯一值集合。我们可以用一对花括号来声明它，就像字典一样。Python 使用键值对的存在来区分这两种数据结构（参见附录B）。
- en: 'If we pass a set to the `Series` constructor, pandas raises a `TypeError` exception.
    A set has neither the concept of order (such as a list) nor the concept of association
    (such as a dictionary). Thus, the library cannot assume an order in which to store
    the set’s values: [²](#pgfId-1082807)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个集合传递给 `Series` 构造函数，pandas 会引发一个 `TypeError` 异常。集合既没有顺序的概念（如列表）也没有关联的概念（如字典）。因此，库无法假设一个存储集合值的顺序：[²](#pgfId-1082807)
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If your program involves a set, transform it to an ordered data structure before
    passing it to the `Series` constructor. The next example converts `my_set` to
    a list by using Python’s built-in `list` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序涉及一个集合，在将其传递给 `Series` 构造函数之前，将其转换为有序数据结构。下一个示例通过使用 Python 的内置 `list`
    函数将 `my_set` 转换为列表：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because a set is unordered, we cannot guarantee the order of list elements (or
    the `Series` elements).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是无序的，我们无法保证列表元素（或 `Series` 元素）的顺序。
- en: 'The `Series` constructor’s `data` parameter also accepts a NumPy `ndarray`
    object. Many data science libraries use NumPy arrays, which are common storage
    formats for moving data around. The next example feeds the `Series` constructor
    an `ndarray` generated by NumPy’s `randint` function (see appendix C):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 构造函数的 `data` 参数也接受一个 NumPy `ndarray` 对象。许多数据科学库使用 NumPy 数组，这是移动数据时的常见存储格式。下一个示例通过
    NumPy 的 `randint` 函数生成的 `ndarray` 来向 `Series` 构造函数提供数据（参见附录C）：'
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As with all other inputs, pandas preserves the order of the `ndarray`’s values
    in the `Series`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他输入一样，pandas 保留 `ndarray` 的值在 `Series` 中的顺序。
- en: 2.3 Series attributes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 `Series` 属性
- en: An *attribute* is a piece of data belonging to an object. Attributes reveal
    information about the object’s internal state. An attribute’s value may be another
    object. See appendix B for an in-depth overview.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *属性* 是属于一个对象的数据片段。属性揭示了关于对象内部状态的信息。一个属性的值可能是一个对象。参见附录B以获取深入了解。
- en: 'A `Series` is composed of several smaller objects. Think of these objects as
    being puzzle pieces that join to make a greater whole. Consider the `calorie_info`
    `Series` from section 2.2:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 由几个更小的对象组成。将这些对象想象成拼图碎片，它们组合在一起形成一个更大的整体。考虑第2.2节中的 `calorie_info`
    `Series`：'
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This `Series` uses the NumPy library’s `ndarray` object to store the calorie
    counts and the pandas library’s `Index` object to store the food names in the
    index. We can access these nested objects through `Series` attributes. The `values`
    attribute, for example, exposes the `ndarray` object that stores the values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Series` 使用 NumPy 库的 `ndarray` 对象来存储卡路里计数，以及 pandas 库的 `Index` 对象来存储食品名称作为索引。我们可以通过
    `Series` 属性访问这些嵌套对象。例如，`values` 属性暴露了存储值的 `ndarray` 对象：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we’re ever uncertain what type an object is or what library it comes from,
    we can pass the object to Python’s built-in `type` function. The function will
    return the class from which the object was instantiated:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不确定对象的类型或它来自哪个库，我们可以将对象传递给Python的内置`type`函数。该函数将返回对象实例化的类：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s pause here to reflect for a second. Pandas delegates the responsibility
    of storing `Series` values to an object from a different library. That’s why NumPy
    is a dependency of pandas. The `ndarray` object optimizes for speed and efficiency
    by relying on the lower-level C programming language for many of its calculations.
    In many ways, the `Series` is a wrapper—an additional layer of functionality around
    a core NumPy library object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里暂停一下，稍作思考。Pandas将存储`Series`值的责任委托给来自不同库的对象。这就是为什么NumPy是pandas的依赖项。`ndarray`对象通过依赖底层C编程语言进行许多计算，从而优化速度和效率。在许多方面，`Series`是一个包装器——围绕核心NumPy库对象的额外功能层。
- en: 'Pandas has its own objects, of course. The `index` attribute, for example,
    returns the `Index` object that stores the `Series` labels:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Pandas有其自己的对象。例如，`index`属性返回存储`Series`标签的`Index`对象：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Index objects such as `Index` are built into pandas:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 索引对象，例如`Index`，是内置到pandas中的：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Some attributes reveal helpful details about the object. `dtype`, for example,
    returns the data type of the `Series`’ values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性揭示了关于对象的有用细节。例如，`dtype`返回`Series`值的类型：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `size` attribute returns the number of values in the `Series`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`属性返回`Series`中的值数：'
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The complementary `shape` attribute returns a tuple with the dimensions of
    a pandas data structure. For the one-dimensional `Series`, the tuple’s only value
    will be the `Series`’ size. The comma after the `3` is a standard visual output
    for one-element tuples in Python:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的`shape`属性返回一个元组，包含pandas数据结构的维度。对于一维`Series`，元组的唯一值将是`Series`的大小。Python中一个元素元组的逗号后是一个标准的视觉输出：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `is_unique` attribute returns `True` if all `Series` values are unique:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_unique`属性在所有`Series`值都是唯一的时返回`True`：'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `is_unique` attribute returns `False` if the `Series` contains duplicates:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_unique`属性在`Series`包含重复项时返回`False`：'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `is_monotonic` attribute returns `True` if each `Series` value is greater
    than the previous one. The increments between values do not have to be equal:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_monotonic`属性在`Series`的每个值都大于前一个值时返回`True`。值之间的增量不必相等：'
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `is_monotonic` attribute returns `False` if any element is smaller than
    the previous one:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_monotonic`属性在任意元素小于前一个元素时返回`False`：'
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In summary, attributes ask an object for information on its internal state.
    Attributes reveal nested objects, which can have their own functionalities. In
    Python, everything is an object, including integers, strings, and Booleans. Thus,
    an attribute that returns a number is no technically different from one that returns
    a complex object such as an `ndarray`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，属性询问对象关于其内部状态的信息。属性揭示了嵌套对象，它们可以有自己的功能。在Python中，一切都是对象，包括整数、字符串和布尔值。因此，返回数字的属性在技术上与返回复杂对象（如`ndarray`）的属性没有区别。
- en: 2.4 Retrieving the first and last rows
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 获取第一行和最后一行
- en: By now, you should feel comfortable creating `Series` objects. It’s OK if the
    technical terminology is a bit overwhelming; we’ve presented a lot of information
    up front, and we’ll review it many times throughout the book. In this section,
    we’ll start exploring what we can do with `Series` objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经能够舒适地创建`Series`对象。如果技术术语有点令人不知所措，那也无可厚非；我们在一开始就提供了大量信息，并在整本书中多次回顾。在本节中，我们将开始探索我们可以用`Series`对象做什么。
- en: A Python object has both attributes and methods. An *attribute* is a piece of
    data belonging to an object—a characteristic or detail that the data structure
    can reveal about itself. In section 2.3, we accessed `Series` attributes such
    as `size`, `shape`, `values`, and `index`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python对象既有属性也有方法。一个*属性*是属于对象的数据片段——数据结构可以揭示的关于自身的特征或细节。在第2.3节中，我们访问了`Series`的属性，如`size`、`shape`、`values`和`index`。
- en: By comparison, a *method* is a function that belongs to an object—an action
    or command that we ask the object to perform. Methods typically involve some analysis,
    calculation, or manipulation of the object’s attributes. Attributes define an
    object’s *state*, and methods define an object’s *behavior*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个*方法*是属于对象的功能——我们要求对象执行的动作或命令。方法通常涉及对对象属性的分析、计算或操作。属性定义了对象的*状态*，而方法定义了对象的*行为*。
- en: Let’s create our largest `Series` yet. We’ll use Python’s built-in `range` function
    to generate a sequence of all numbers between a starting point and an endpoint.
    The `range` function’s three arguments are a lower bound, the upper bound, and
    a step sequence (the interval between every two numbers).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们迄今为止最大的`Series`。我们将使用Python的内置`range`函数生成一个从起点到终点的所有数字的序列。`range`函数的三个参数是下限、上限和步进序列（每两个数字之间的间隔）。
- en: 'The next example generates a 100-value range of numbers between 0 and 500 in
    increments of 5 and then pass the range object into the `Series` constructor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例生成一个介于0到500之间，增量为5的100个值的范围，然后将范围对象传递给`Series`构造函数：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we have a `Series` with 100 values. Fancy! Take note of the ellipses (the
    three dots) that appear in the middle of the output. Pandas is telling us that
    it condensed the output by hiding some rows. The library conveniently truncates
    the `Series` to show only the first five and the last five rows. Too many rows
    of printed data can slow Jupyter Notebook.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含100个值的`Series`。真棒！注意输出中间出现的省略号（三个点）。Pandas正在告诉我们它通过隐藏一些行来压缩了输出。这个库方便地截断了`Series`，只显示前五行和后五行。打印过多的数据行可能会减慢Jupyter
    Notebook。
- en: 'We invoke a method with a pair of parentheses after its name. Let’s invoke
    some simple `Series` methods. We’ll start with the `head` method, which returns
    rows from the beginning or top of the data set. It accepts a single argument `n,`
    which sets the number of rows to extract:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法名称后面调用一对括号。让我们调用一些简单的`Series`方法。我们将从`head`方法开始，它返回数据集的开始或顶部的行。它接受一个参数`n`，该参数设置要提取的行数：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can pass keyword arguments in method calls, as in constructors and functions.
    The following code produces the same result as the preceding code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方法调用中传递关键字参数，就像在构造函数和函数中一样。以下代码产生与前面代码相同的结果：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Like functions, methods can declare default arguments for their parameters.
    The `head` method’s `n` parameter has a default argument of `5`. If we do not
    pass an explicit argument for `n`, pandas returns five rows (a design decision
    of the pandas development team):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 和函数一样，方法可以为它们的参数声明默认参数。`head`方法的`n`参数有一个默认参数为`5`。如果我们没有为`n`传递显式参数，pandas将返回五行（这是pandas开发团队的设计决策）：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The complementary `tail` method returns rows from the bottom or end of a `Series`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的`tail`方法返回`Series`的底部或末尾的行：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `tail` method’s `n` parameter also has a default argument of `5`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`方法的`n`参数也有一个默认参数为`5`：'
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`head` and `tail` are the two methods I use most frequently; we can use them
    to preview the beginning and end of a data set quickly. Next, let’s dive into
    some more-advanced `Series` methods.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`和`tail`是我最常用的两个方法；我们可以使用它们快速预览数据集的开始和结束。接下来，让我们深入了解一些更高级的`Series`方法。'
- en: 2.5 Mathematical operations
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 数学运算
- en: A `Series` object includes plenty of statistical and mathematical methods. Let’s
    see a few of these methods in action. Feel free to breeze through this section
    and revisit it when you need to track down a specific function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`对象包含大量的统计和数学方法。让我们看看这些方法在实际中的应用。您可以随意快速浏览这一节，并在需要查找特定函数时再回来。'
- en: 2.5.1 Statistical operations
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 统计操作
- en: 'We’ll begin by creating a `Series` from a list of ascending numbers, sneaking
    in an `np.nan` value in the middle. Remember that if a data source has even a
    single missing value, pandas will coerce the integers to floating-point values:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个升序数字列表开始创建一个`Series`，在中间偷偷加入一个`np.nan`值。记住，如果一个数据源有缺失值，pandas会将整数强制转换为浮点值：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `count` method counts the number of non-null values:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`方法计算非空值的数量：'
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `sum` method adds the `Series`’ values together:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`方法将`Series`的值相加：'
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Most mathematical methods ignore missing values by default. We can pass an argument
    of `False` to the `skipna` parameter to force the inclusion of missing values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，大多数数学方法忽略缺失值。我们可以通过将`skipna`参数的值设置为`False`来强制包含缺失值。
- en: 'The next example invokes the `sum` method with the parameter. Pandas returns
    a `nan` because it cannot add the unknown `nan` value at index `3` to the cumulative
    sum:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用带有参数的`sum`方法。Pandas返回一个`nan`，因为它无法将索引`3`处的未知`nan`值加到累积和中：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `sum` method’s `min_count` parameter sets the minimum number of valid values
    a `Series` must hold for pandas to calculate its sum. Our six-element `numbers`
    `Series` contains five present values and one `nan` value
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum` 方法的 `min_count` 参数设置了一个 `序列` 必须持有的有效值的最小数量，以便 pandas 计算其总和。我们的六个元素 `numbers`
    `序列` 包含五个有效值和一个 `nan` 值'
- en: 'In the next example, the `Series` meets the threshold of three present values,
    so pandas returns the sum:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，`序列` 达到了三个有效值的阈值，因此 pandas 返回总和：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By comparison, the next invocation demands a minimum of six values for pandas
    to calculate the sum. The threshold is unmet, so the `sum` method returns `nan`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，下一个调用要求 pandas 计算总和至少有六个值。阈值未满足，因此 `sum` 方法返回 `nan`：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: TIP If you’re ever curious about a method’s parameters, press Shift+Tab between
    a method’s parentheses to bring up the documentation in Jupyter Notebook.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您对某个方法的参数感到好奇，请在 Jupyter Notebook 中方法括号之间按 Shift+Tab 键，以显示文档。
- en: 'The `product` method multiplies all `Series` values together:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`product` 方法将所有 `序列` 值相乘：'
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The method also accepts `skipna` and `min_count` parameters. Here, we ask pandas
    to include `nan` values in the calculation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法还接受 `skipna` 和 `min_count` 参数。在这里，我们要求 pandas 将 `nan` 值包含在计算中：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next example asks for the product of all `Series` values if it has at least
    three present ones:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，如果 `序列` 至少有三个有效值，则请求所有 `序列` 值的乘积：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `cumsum` (cumulative sum) method returns a new `Series` with a rolling
    sum of values. Each index position holds the sum of values up to and including
    the value at that index. A cumulative sum helps determine which values contribute
    most to the total:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`cumsum`（累积和）方法返回一个新的 `序列`，其中包含值的滚动总和。每个索引位置都包含从该索引开始并包括该索引的值的总和。累积和有助于确定哪些值对总和的贡献最大：'
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s walk through some of the calculations in the result:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看结果中的一些计算：
- en: The cumulative sum at index 0 is 1.0, the first value in the `numbers` `Series`.
    There is nothing to add yet.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引 0 的累积和为 1.0，这是 `numbers` `序列` 中的第一个值。目前还没有任何值可以相加。
- en: The cumulative sum at index 1 is 3.0, the sum of 1.0 at index 0 and 2.0 at index
    position 1.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引 1 的累积和为 3.0，是索引 0 的 1.0 和索引位置 1 的 2.0 的总和。
- en: The cumulative sum at index 2 is 6.0, the sum of 1.0, 2.0, and 3.0.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引 2 的累积和为 6.0，是 1.0、2.0 和 3.0 的总和。
- en: The `numbers` `Series` has a `nan` at index 3\. Pandas cannot add a missing
    value to the cumulative sum, so it places a `nan` at the same index in the returned
    `Series`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbers` `序列` 在索引 3 处有一个 `nan`。Pandas 无法将缺失值添加到累积和中，因此在返回的 `序列` 中相同索引处放置一个
    `nan`。'
- en: The cumulative sum at index 4 is 10.0\. Pandas adds the previous cumulative
    sum with the current index’s value (1.0 + 2.0 + 3.0 + 4.0).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引 4 的累积和为 10.0。Pandas 将前一个累积和与当前索引的值（1.0 + 2.0 + 3.0 + 4.0）相加。
- en: 'If we pass the `skipna` an argument of `False`, the `Series` will list the
    cumulative sum up to the index with the first missing value and then `NaN` for
    the remaining values:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递 `skipna` 的参数为 `False`，则 `序列` 将列出直到第一个缺失值的累积和，然后对于剩余的值使用 `NaN`：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `pct_change` (percent change) method returns the percentage difference from
    one `Series` value to the next. At each index, pandas adds the last index’s value
    and the current index’s value and then divides the sum by the last index’s value.
    Pandas can calculate a percentage difference only if both indexes have valid values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`pct_change`（百分比变化）方法返回一个 `序列` 中一个值与下一个值之间的百分比差异。在每个索引处，pandas 将最后一个索引的值和当前索引的值相加，然后将总和除以最后一个索引的值。Pandas
    只能在两个索引都有有效值的情况下计算百分比差异。'
- en: 'The `pct_change` method defaults to a *forward-fill* strategy for missing values.
    With this strategy, pandas replaces a `nan` with the last valid value it encountered.
    Let’s invoke the method and then walk through the calculations:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`pct_change` 方法默认使用 *前向填充* 策略处理缺失值。使用此策略，pandas 将最后一个有效值替换为 `nan`。让我们调用该方法，然后了解计算过程：'
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here’s how pandas operates:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 pandas 的工作方式：
- en: At index 0, pandas cannot compare the value 1.0 in the `numbers` `Series` with
    any previous value. Thus, index 0 in the returned `Series` has a `NaN` value.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引 0 处，pandas 无法将 `numbers` `序列` 中的值 1.0 与任何先前值进行比较。因此，返回 `序列` 中的索引 0 有一个 `NaN`
    值。
- en: At index 1, pandas compares index 1’s value of 2.0 with index 0’s value of 1.0\.
    The percentage change between 2.0 and 1.0 is 100 (double), which translates to
    1.00000 at index 1 in the returned `Series`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引 1 处，pandas 将索引 1 的值 2.0 与索引 0 的值 1.0 进行比较。2.0 和 1.0 之间的百分比变化是 100（翻倍），这在返回的
    `序列` 中转换为索引 1 的 1.00000。
- en: At index 2, pandas repeats the same operation.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引 2 处，pandas 重复相同的操作。
- en: At index 3, the `numbers` `Series` has a `NaN` missing value. Pandas substitutes
    the last encountered value (3.0 from index 2) in its place. The percentage change
    between the substituted 3.0 at index 3 and the 3.0 at index 2 is 0.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引3处，`numbers` `Series`有一个缺失的`NaN`值。Pandas用最后遇到的值（索引2处的3.0）来替代它。替代的3.0在索引3处和索引2处的3.0之间的百分比变化是0。
- en: At index 4, pandas compares index 4’s value of 4.0 with the previous row’s value.
    It again substitutes the `nan` with the last valid value it saw, 3.0\. The percentage
    change between 4 and 3 is 0.333333 (a 33 percent increase).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引4处，pandas将索引4的值4.0与前一行的值进行比较。它再次用它看到的最后一个有效值3.0来替代`nan`。4和3之间的百分比变化是0.333333（增加了33%）。
- en: Figure 2.3 shows a visual representation of a forward-fill percentage-change
    calculation. The `Series` on the left is the starting point. The `Series` in the
    middle shows the intermediate calculations that pandas performs. The `Series`
    on the right is the final result.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3展示了前向填充百分比变化计算的视觉表示。左侧的`Series`是起点。中间的`Series`显示了pandas执行的中间计算。右侧的`Series`是最终结果。
- en: '![](../Images/CH02_F03_Paskhaver.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Paskhaver的图片](../Images/CH02_F03_Paskhaver.png)'
- en: Figure 2.3 A walkthrough of how the `pct_change` method calculates values with
    a forward-fill solution
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：`pct_change`方法如何使用前向填充解决方案计算值的过程
- en: 'The `fill_method` parameter customizes the protocol by which `pct_change` substitutes
    `NaN` values. This parameter is available across many methods, so it’s worth taking
    the time to familiarize yourself with it. As mentioned earlier, with the default
    forward-fill strategy, pandas replaces a `nan` value with the *last* valid observation.
    We can pass the `fill_method` parameter an explicit argument of `"pad"` or `"ffill"`
    to achieve the same result:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill_method`参数自定义了`pct_change`用何种协议来替代`NaN`值。此参数在许多方法中都可用，因此花时间熟悉它是值得的。如前所述，使用默认的前向填充策略，pandas用最后一个有效的观察值来替代`nan`值。我们可以传递一个显式的参数`"pad"`或`"ffill"`给`fill_method`参数以实现相同的结果：'
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'An alternative strategy for dealing with missing values is a *backfill* solution.
    With this option, pandas replaces a `nan` value with the next valid observation.
    Let’s pass the `fill_method` parameter a value of `"bfill"` to see the results
    and then walk through them step by step:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 处理缺失值的另一种策略是*后向填充*解决方案。使用此选项，pandas用下一个有效的观察值来替代`nan`值。让我们传递一个值为`"bfill"`的`fill_method`参数来查看结果，然后逐步进行说明：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that the values at index positions 3 and 4 differ between the forward-fill
    and backfill solutions. Here’s how pandas arrives at the previous calculations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在索引位置3和4之间，前向填充和后向填充解决方案的值不同。以下是pandas如何得出先前计算的方法：
- en: At index 0, pandas cannot compare the value 1.0 in the `numbers` `Series` with
    any previous value. Thus, index 0 in the returned `Series` has a `NaN` value.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引0处，pandas无法将`numbers` `Series`中的值1.0与任何先前值进行比较。因此，返回的`Series`中的索引0有一个`NaN`值。
- en: At index 3, pandas runs into a `NaN` in the `numbers` `Series`. Pandas substitutes
    the next valid value (4.0 at index 4) in its place. The percentage change between
    4.0 at index 3 and 3.0 at index 2 in `numbers` is 0.33333.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引3处，pandas在`numbers` `Series`中遇到了一个`NaN`。Pandas用下一个有效值（索引4处的4.0）来替代它。`numbers`中索引3处的4.0和索引2处的3.0之间的百分比变化是0.33333。
- en: At index 4, pandas compares 4.0 with index 3’s value. It again replaces the
    `NaN` at index 3 with 4.0, the next valid value available in the `numbers` `Series`.
    The percentage change between 4 and 4 is 0.0.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引4处，pandas将4.0与索引3的值进行比较。它再次用`numbers` `Series`中下一个有效的值4.0来替代索引3处的`NaN`。4和4之间的百分比变化是0.0。
- en: Figure 2.4 shows a visual representation of a backfill percentage-change calculation.
    The `Series` on the left is the starting point. The `Series` in the middle shows
    the intermediate calculations that pandas performs. The `Series` on the right
    is the final result.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4展示了后向填充百分比变化计算的视觉表示。左侧的`Series`是起点。中间的`Series`显示了pandas执行的中间计算。右侧的`Series`是最终结果。
- en: '![](../Images/CH02_F04_Paskhaver.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Paskhaver的图片](../Images/CH02_F04_Paskhaver.png)'
- en: Figure 2.4 A walkthrough of how the `pct_change` method calculates values with
    a backfill solution
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：`pct_change`方法如何使用后向填充解决方案计算值的过程
- en: 'The `mean` method returns the average of the values in the `Series`. An average
    is the result of dividing the sum of values by the count of values:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean`方法返回`Series`中值的平均值。平均值是值总和除以值计数的结果：'
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `median` method returns the middle number in a sorted `Series` of values.
    Half of the `Series` values will be below the median, and half of the values will
    be above the median:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`median` 方法返回排序后的 `Series` 值中的中间数。`Series` 值中有一半会低于中位数，另一半会高于中位数：'
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `std` method returns the *standard deviation*, a measure of the variation
    in the data:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`std` 方法返回 *标准差*，这是衡量数据变异程度的指标：'
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `max` and `min` methods retrieve the largest and smallest value from the
    `Series`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`max` 和 `min` 方法从 `Series` 中检索最大和最小值：'
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Pandas sorts a string `Series` alphabetically. The “smallest” string is the
    one closest to the start of the alphabet, and the “largest” string is the one
    closest to the end of the alphabet. Here’s a simple example with a small `Series`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 按字母顺序对字符串 `Series` 进行排序。最小的字符串是接近字母表开头的字符串，最大的字符串是接近字母表末尾的字符串。以下是一个简单的示例，使用了一个小的
    `Series`：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you’re looking for a single method to summarize a `Series` effectively,
    the powerful `describe` method does the trick. It returns a `Series` of statistical
    evaluations, including count, mean, and standard deviation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个可以有效地总结 `Series` 的单一方法，强大的 `describe` 方法可以做到这一点。它返回一个包含计数、平均值和标准差的统计评估
    `Series`：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `sample` method selects a random assortment of values from the `Series`.
    It is possible for the order of values to differ between the new `Series` and
    the original `Series`. In the next example, notice that the lack of `NaN` values
    from the random selection allows pandas to return a `Series` of integers. If `NaN`
    was even one of the values, pandas would return a `Series` of floats instead:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample` 方法从 `Series` 中选择一组随机的值。新 `Series` 和原始 `Series` 中的值顺序可能不同。在下一个示例中，请注意，随机选择中没有
    `NaN` 值允许 pandas 返回一个整数的 `Series`。如果 `NaN` 是其中的任何一个值，pandas 将返回一个浮点数的 `Series`。'
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `unique` method returns a NumPy `ndarray` of unique values from the `Series`.
    In the next example, the string `"Orwell"` appears twice in the `authors` `Series`
    but only once in the returned `ndarray`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique` 方法返回 `Series` 中唯一值的 NumPy `ndarray`。在下一个示例中，字符串 `"Orwell"` 在 `authors`
    `Series` 中出现两次，但在返回的 `ndarray` 中只出现一次：'
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The complementary `nunique` method returns the number of unique values in the
    `Series`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的 `nunique` 方法返回 `Series` 中唯一值的数量：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `nunique` method’s return value will be equal to the length of the array
    that the `unique` method returns.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`nunique` 方法的返回值将等于 `unique` 方法返回的数组的长度。'
- en: 2.5.2 Arithmetic operations
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 算术运算
- en: 'In section 2.5.1, we practiced invoking numerous mathematical methods on our
    `Series` objects. Pandas gives us additional ways to perform arithmetic calculations
    with a `Series`. Let’s start by creating a `Series` of integers with one missing
    value:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.5.1 节中，我们练习了在 `Series` 对象上调用多个数学方法。Pandas 给我们提供了执行算术计算的其他方法。让我们首先创建一个包含一个缺失值的整数
    `Series`：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can perform arithmetic on a `Series` with Python’s standard mathematical
    operators:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的标准数学运算符对 `Series` 进行算术运算：
- en: '`+` for addition'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 用于加法'
- en: '`-` for subtraction'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` 用于减法'
- en: '`*` for multiplication'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 用于乘法'
- en: '`/` for division'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` 用于除法'
- en: 'The syntax is intuitive: treat the `Series` as a regular operand on one side
    of a mathematical operator. Place the complementary value on the other side of
    the operator. Note that any mathematical operation with a `nan` yields another
    `nan`. The next example adds `3` to each value in the `s1` `Series`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 语法直观：将 `Series` 视为数学运算符一侧的常规操作数。将补充值放在运算符的另一侧。请注意，任何涉及 `nan` 的数学运算都会产生另一个 `nan`。下一个示例将
    `3` 添加到 `s1` `Series` 中的每个值：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Some software developers might find the result surprising. How can we add an
    integer to a data structure? The types are seemingly incompatible. Behind the
    scenes, pandas is smart enough to parse our syntax and understand that we’d like
    to add an integer to every value in the `Series`, not to the `Series` object itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件开发人员可能会对结果感到惊讶。我们如何将一个整数添加到数据结构中？看起来这些类型是不兼容的。在幕后，pandas 足够智能，能够解析我们的语法，并理解我们想要将整数添加到
    `Series` 中的每个值，而不是添加到 `Series` 对象本身。
- en: 'If you prefer a method-based approach, the `add` method achieves the same result:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢基于方法的方法，`add` 方法可以达到相同的结果：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The next three examples show the complementary syntax options for subtraction
    (`-`), multiplication (`*`), and division (`/`). Often, there are multiple ways
    to accomplish the same operation in pandas:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三个示例展示了减法（`-`）、乘法（`*`）和除法（`/`）的补充语法选项。在 pandas 中，通常有多种方式可以完成相同的操作：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The floor division operator (`//`) performs a division and removes any digits
    after the decimal point in the result. The regular division of 15 by 4, for example,
    yields 3.75\. By comparison, the floor division of 15 by 4 yields 3\. We can apply
    the operator to a `Series`; the alternative is to invoke the `floordiv` method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 向下取整除法运算符 (`//`) 执行除法并从结果中移除小数点后的任何数字。例如，15 除以 4 的常规除法得到 3.75，而向下取整除法得到 3。我们可以将此运算符应用于
    `Series`；另一种选择是调用 `floordiv` 方法：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The modulo operator (`%`) returns the remainder of a division. Here’s an example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 取模运算符 (`%`) 返回除法的余数。以下是一个例子：
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the previous example,
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，
- en: Pandas divides the value of 5.0 at index label A by 3 and leaves a remainder
    of 2.0.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 将索引标签 A 上的值 5.0 除以 3，余数为 2.0。
- en: Pandas cannot divide the `NaN` at index label B.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 不能将索引标签 B 上的 `NaN` 进行除法。
- en: Pandas divides the value of 15.0 at index label C by 3 and leaves a reminder
    of 0.0.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 将索引标签 C 上的值 15.0 除以 3，余数为 0.0。
- en: 2.5.3 Broadcasting
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 广播
- en: Recall that pandas stores its `Series` values in a NumPy `ndarray` under the
    hood. When we use syntax such as `s1` `+` `3` or `s1` `-` `5`, pandas delegates
    the mathematical calculations to NumPy.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，pandas 在底层使用 NumPy `ndarray` 存储其 `Series` 值。当我们使用 `s1 + 3` 或 `s1 - 5` 这样的语法时，pandas
    将数学计算委托给 NumPy。
- en: The NumPy documentation uses the term *broadcasting* to describe the derivation
    of one array of values from another. Without diving too much into the technical
    details (you don’t need to understand NumPy’s complexities to work effectively
    with pandas), the term *broadcasting* comes from a radio broadcast tower, which
    transmits the same signal to all recipients listening in. Syntax like `s1` `+`
    `3` means “Apply the same operation (add 3) to each value in the `Series`.” Each
    `Series` value gets the same message, much as every person listening to the same
    radio station at the same time hears the same song.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 文档使用术语 *广播* 来描述从一个数组派生另一个数组的过程。不深入技术细节（您不需要理解 NumPy 的复杂性就能有效地使用 pandas），术语
    *广播* 来自一个广播塔，它向所有收听的人发送相同的信号。像 `s1 + 3` 这样的语法意味着“将相同的操作（加 3）应用于 `Series` 中的每个值。”每个
    `Series` 值都收到相同的信息，就像同时收听同一电台的每个人都能听到相同的歌曲一样。
- en: 'Broadcasting also describes mathematical operations between multiple `Series`
    objects. As a rule of thumb, pandas uses shared index labels to align values across
    different data structures. Let’s demonstrate this concept through an example.
    Let’s instantiate two `Series` with the same three-element index:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 广播还描述了多个 `Series` 对象之间的数学运算。作为一个经验法则，pandas 使用共享索引标签在不同数据结构之间对齐值。让我们通过一个例子来演示这个概念。让我们实例化两个具有相同三个元素索引的
    `Series`：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When we use the `+` operator with the two `Series` as operands, pandas adds
    the values at the same index positions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `+` 运算符并将两个 `Series` 作为操作数时，pandas 会将相同索引位置的值相加：
- en: At index A, pandas adds the values 1 and 4 to arrive at 5.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引 A 处，pandas 将值 1 和 4 相加得到 5。
- en: At index B, pandas adds the values 2 and 5 to arrive at 7.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引 B 处，pandas 将值 2 和 5 相加得到 7。
- en: At index C, pandas adds the values 3 and 6 to arrive at 9.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在索引 C 处，pandas 将值 3 和 6 相加得到 9。
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Figure 2.5 offers a visualization of how pandas aligns the two `Series`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 展示了 pandas 如何对齐两个 `Series`。
- en: '![](../Images/CH02_F05_Paskhaver.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F05_Paskhaver.png)'
- en: Figure 2.5 Pandas aligns `Series` by shared index labels when performing a mathematical
    operation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 展示了 pandas 在执行数学运算时通过共享索引标签对齐 `Series`。
- en: 'Here’s another example of how pandas uses shared index labels to align data.
    Let’s create another two `Series` with the standard numeric index. We’ll add a
    missing value to each collection:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 pandas 使用共享索引标签对齐数据的另一个例子。让我们创建另外两个具有标准数值索引的 `Series`。我们将在每个集合中添加一个缺失值：
- en: '[PRE69]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Python’s equality operator (`==`) compares the equality of two objects. We
    can use this operator to compare values across two `Series`, as in the following
    example. Note that pandas considers a `nan` value to be unequal to another `nan`;
    it cannot assume that an absent value is equal to another absent value. The method
    equivalent for the equality operator is `eq`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的等号运算符 (`==`) 用于比较两个对象的相等性。我们可以使用这个运算符来比较两个 `Series` 中的值，如下例所示。请注意，pandas
    认为 `nan` 值与另一个 `nan` 不相等；它不能假设缺失的值与另一个缺失的值相等。等号运算符的等效方法是 `eq`：
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The inequality operator (`!=`) confirms whether two values are unequal. Its
    method equivalent is `ne`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 不等号运算符 (`!=`) 确认两个值是否不相等。它的等效方法是 `ne`：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Comparison operations between `Series` become trickier when the indices differ.
    One index may have a greater or smaller number of labels, or there may be a mismatch
    between the labels themselves.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引不同时，`Series`之间的比较操作会变得复杂。一个索引可能包含更多或更少的标签，或者标签本身可能存在不匹配。
- en: 'The next example creates two `Series` that share only two index labels, B and
    C:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例创建了两个只共享两个索引标签B和C的`Series`：
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'What happens when we try to add `s1` and `s2`? Pandas adds the values at the
    B and C labels and returns `NaN` values for the remaining indices (A, D, and E).
    As a reminder, any arithmetic operation with a `NaN` value always results in a
    `NaN`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将`s1`和`s2`相加时会发生什么？Pandas会在B和C标签处添加值，并在剩余的索引（A、D和E）处返回`NaN`值。提醒一下，任何与`NaN`值进行的算术运算总是结果为`NaN`：
- en: '[PRE73]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Figure 2.6 shows how pandas aligns the `s1` and `s2` `Series` and then adds
    their associated index values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6显示了pandas如何对齐`s1`和`s2` `Series`，然后添加它们相关的索引值。
- en: '![](../Images/CH02_F06_Paskhaver.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F06_Paskhaver.png)'
- en: Figure 2.6 Pandas returns `NaN` whenever the `Series` do not share an index
    label.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 Pandas在`Series`不共享索引标签时返回`NaN`。
- en: In summary, pandas aligns data by shared index labels across two `Series`, substituting
    `NaN`s where needed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，pandas通过在两个`Series`之间共享索引标签来对齐数据，并在需要的地方用`NaN`替换。
- en: 2.6 Passing the Series to Python’s built-in functions
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 将`Series`传递给Python的内置函数
- en: 'Python’s developer community likes to rally around certain design principles
    to ensure consistency across codebases. One example is seamless integration between
    library objects and Python’s built-in functions. Pandas is no exception. We can
    pass a `Series` to any of Python’s built-in functions and yield a predictable
    result. Let’s create a small `Series` of cities in the United States:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Python的开发者社区喜欢围绕某些设计原则进行团结，以确保代码库之间的连贯性。一个例子是库对象与Python内置函数的无缝集成。Pandas也不例外。我们可以将`Series`传递给Python的任何内置函数，并得到可预测的结果。让我们创建一个包含美国城市的`Series`：
- en: '[PRE74]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `len` function returns the number of rows in a `Series`. The count includes
    missing values (`NaN`s):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`函数返回`Series`中的行数。计数包括缺失值（`NaN`s）：'
- en: '[PRE75]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As we saw earlier, the `type` function returns the class of an object. Use
    this function when you’re uncertain about the data structure you’re working with
    or the library it’s coming from:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前看到的，`type`函数返回对象的类。当你不确定你正在处理的数据结构或其来源的库时，请使用此函数：
- en: '[PRE76]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `dir` function returns a list of an object’s attributes and methods as
    strings. Note that the next example displays an abbreviated version of the output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir`函数返回一个对象属性和方法作为字符串的列表。注意，下一个示例显示了输出的简略版本：'
- en: '[PRE77]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'A `Series`’ values can populate a native Python data structure. The next example
    creates a list from our `cities` `Series` by using Python’s `list` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`的值可以填充一个原生的Python数据结构。下一个示例通过使用Python的`list`函数从我们的`cities` `Series`创建一个列表：'
- en: '[PRE78]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can pass the `Series` to Python’s built-in `dict` function to create a dictionary.
    Pandas maps the `Series`’ index labels and values to the dictionary’s keys and
    values:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`Series`传递给Python的内置`dict`函数来创建一个字典。Pandas将`Series`的索引标签和值映射到字典的键和值：
- en: '[PRE79]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In Python, we use the `in` keyword to check for inclusion. In pandas, we can
    use the `in` keyword to check whether a given value exists in the `Series`’ index.
    Here’s a reminder of what `cities` looks like:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用`in`关键字来检查包含。在pandas中，我们可以使用`in`关键字来检查给定值是否存在于`Series`的索引中。这里是一个关于`cities`的提醒：
- en: '[PRE80]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The next two examples query for `"Las` `Vegas"` and `2` in the `Series`’ index:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个示例在`Series`的索引中查询`"Las Vegas"`和`2`：
- en: '[PRE81]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To check for inclusion among the `Series`’ values, we can pair the `in` keyword
    with the `values` attribute. Remember that `values` exposes the `ndarray` object
    that holds the data itself:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`Series`值中的包含情况，我们可以将`in`关键字与`values`属性配对。记住，`values`暴露了包含实际数据的`ndarray`对象：
- en: '[PRE82]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can use the inverse `not in` operator to check for exclusion. The operator
    returns `True` if pandas cannot find the value in the `Series`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用逆`not in`运算符来检查排除。如果pandas在`Series`中找不到该值，则该运算符返回`True`：
- en: '[PRE83]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: A pandas object will often integrate with Python’s built-in functions and offer
    its own attribute/method to return the same data. Choose the syntax option that
    works best for you.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: pandas对象通常会与Python的内置函数集成，并提供自己的属性/方法来返回相同的数据。选择最适合你的语法选项。
- en: 2.7 Coding challenge
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 编程挑战
- en: Welcome to the book’s first coding challenge! The goal of these exercises is
    to help you apply and review the concepts introduced throughout the chapter. You’ll
    find the solutions immediately after the questions. Good luck!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第一个编码挑战！这些练习的目的是帮助你应用和复习本章中介绍的概念。你将在问题之后立即找到解决方案。祝你好运！
- en: 2.7.1 Problems
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.1 问题
- en: 'Suppose that you’re given these two data structures:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被给出了这两个数据结构：
- en: '[PRE84]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here are your challenges:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你的挑战：
- en: Use the list of superheroes to populate a new `Series` object.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用超级英雄列表填充一个新的`Series`对象。
- en: Use the tuple of strengths to populate a new `Series` object.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用力量值的元组填充一个新的`Series`对象。
- en: Create a `Series` with the superheroes as index labels and the strength levels
    as the values. Assign the `Series` to a `heroes` variable.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个以超级英雄为索引标签，力量等级为值的`Series`。将`Series`赋值给`heroes`变量。
- en: Extract the first two rows of the `heroes` `Series`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取`heroes` `Series`的前两行。
- en: Extract the last four rows of the `heroes` `Series`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取`heroes` `Series`的最后四行。
- en: Determine the number of unique values in your `heroes` `Series`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定你的`heroes` `Series`中唯一值的数量。
- en: Calculate the average strength of the superheroes in `heroes`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`heroes`中超级英雄的平均力量。
- en: Calculate the maximum and minimum strengths in `heroes`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`heroes`中的最大力量和最小力量。
- en: Calculate what each superhero’s strength level would be if it doubled.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算如果力量等级翻倍，每个超级英雄的力量等级会是多少。
- en: Convert the `heroes` `Series` to a Python dictionary.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`heroes` `Series`转换为Python字典。
- en: 2.7.2 Solutions
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.2 解决方案
- en: 'Let’s explore the solutions to the problems in section 2.7.1:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索2.7.1节中问题的解决方案：
- en: 'To create a new `Series` object, we can use the `Series` constructor at the
    top level of the pandas library. Pass in the source of data as the first positional
    argument:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的`Series`对象，我们可以在pandas库的顶层使用`Series`构造函数。将数据源作为第一个位置参数传入：
- en: '[PRE85]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The solution to this problem is identical to the previous one; we only have
    to pass in our tuple of strengths to the `Series` constructor. This time around,
    let’s write out the `data` keyword parameter explicitly:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个问题的解决方案与上一个相同；我们只需要将我们的力量值元组传递给`Series`构造函数。这次，让我们明确写出`data`关键字参数：
- en: '[PRE86]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To create a `Series` with a custom index, we can pass the `index` parameter
    to the constructor. Here, we set the strength levels as the `Series`’ values and
    the superhero names as the index labels:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建具有自定义索引的`Series`，我们可以将`index`参数传递给构造函数。在这里，我们将力量等级设置为`Series`的值，将超级英雄名称设置为索引标签：
- en: '[PRE87]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As a reminder, a *method* is an action or a command we can give to an object.
    We can use the `head` method to extract rows from the top of a pandas data structure.
    The method’s only parameter, `n`, sets the number of rows to pull out. The `head`
    method returns a new `Series`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为提醒，*方法*是我们可以向对象发出的动作或命令。我们可以使用`head`方法从pandas数据结构的顶部提取行。方法的唯一参数`n`设置了要提取的行数。`head`方法返回一个新的`Series`：
- en: '[PRE88]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The complementary `tail` method extracts rows from the end of a pandas data
    structure. To target the last four rows, we’ll pass in an argument of `4`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 补充的`tail`方法从pandas数据结构的末尾提取行。为了定位最后四行，我们将传递一个参数`4`：
- en: '[PRE89]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To identify the number of unique values in a `Series`, we can invoke the `nunique`
    method. The `heroes` `Series` has six total values and five unique values; the
    value `120` appears twice:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要识别`Series`中的唯一值数量，我们可以调用`nunique`方法。`heroes` `Series`总共有六个值，其中五个是唯一的；值`120`出现了两次：
- en: '[PRE90]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To calculate the average of a `Series`’ values, we can invoke the `mean` method:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算`Series`值的平均值，我们可以调用`mean`方法：
- en: '[PRE91]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The next challenge is to identify the largest and smallest values in the `Series`.
    The `max` and `min` methods do the trick:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个挑战是确定`Series`中的最大值和最小值。`max`和`min`方法可以解决这个问题：
- en: '[PRE92]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'How can we double each superhero’s strength level? We can multiply each `Series`
    value by 2\. The following solution uses the multiplication operator, but the
    `mul` and `multiply` methods are also suitable options:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将每个超级英雄的力量等级翻倍呢？我们可以将每个`Series`值乘以2。以下解决方案使用了乘法运算符，但`mul`和`multiply`方法也是合适的选择：
- en: '[PRE93]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The last challenge is to convert the `heroes` `Series` to a Python dictionary.
    To solve this problem, we can pass the data structure into Python’s `dict` constructor/function.
    Pandas sets the index labels as the dictionary keys and the `Series` values as
    the dictionary values:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的挑战是将`heroes` `Series`转换为Python字典。为了解决这个问题，我们可以将数据结构传递给Python的`dict`构造函数/函数。Pandas将索引标签设置为字典键，将`Series`值设置为字典值：
- en: '[PRE94]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Congratulations on completing your first coding challenge!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成了您的第一个编码挑战！
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A `Series` is a one-dimensional homogeneous labeled array that holds values
    and an index.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series` 是一个一维同构标签数组，用于存储值和索引。'
- en: A `Series`’ values can be of any data type. The index labels can be of any immutable
    data type.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series` 的值可以是任何数据类型。索引标签可以是任何不可变的数据类型。'
- en: Pandas assigns both an index *position* and an index *label* to each `Series`
    value.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 为每个 `Series` 值分配一个索引 *位置* 和一个索引 *标签*。
- en: We can populate a `Series` with data from lists, dictionaries, tuples, NumPy
    arrays, and more.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用列表、字典、元组、NumPy 数组等数据源填充 `Series`。
- en: The `head` method retrieves the first rows of a `Series`.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head` 方法用于检索 `Series` 的第一行。'
- en: The `tail` method retrieves the last rows of a `Series`.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tail` 方法用于检索 `Series` 的最后几行。'
- en: A `Series` supports common statistical operations such as sum, mean, median,
    and standard deviation.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series` 支持常见的统计操作，如总和、平均值、中位数和标准差。'
- en: Pandas uses shared index labels to apply arithmetic operations across multiple
    `Series`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 使用共享索引标签在多个 `Series` 上应用算术运算。
- en: A `Series` plays friendly with Python’s built-in functions, including `dict`,
    `list`, and `len`.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series` 与 Python 的内置函数（包括 `dict`、`list` 和 `len`）友好地协同工作。'
- en: '* * *'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ See [http://mng.bz/7j6v](http://mng.bz/7j6v) for a discussion of why pandas
    lists “object” as the `dtype` for strings.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 请参阅[http://mng.bz/7j6v](http://mng.bz/7j6v)以了解为什么 pandas 将字符串的 `dtype` 列为“object”的讨论。
- en: ² See “Constructing a Series with a set returns a set and not a Series,” [https://github.com/pandas-dev/pandas/issues/1913](https://github.com/pandas-dev/pandas/issues/1913).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ² 请参阅“使用集合构造序列返回集合而不是序列”，[https://github.com/pandas-dev/pandas/issues/1913](https://github.com/pandas-dev/pandas/issues/1913)。
