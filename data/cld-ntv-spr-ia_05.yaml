- en: 3 Getting started with cloud native development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 开始云原生开发
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Bootstrapping a cloud native project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动云原生项目
- en: Working with embedded servers and Tomcat
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与嵌入式服务器和Tomcat一起工作
- en: Building a RESTful application with Spring MVC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring MVC构建RESTful应用程序
- en: Testing a RESTful application with Spring Test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Test测试RESTful应用程序
- en: Automating the build and tests with GitHub Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub Actions自动化构建和测试
- en: The cloud native landscape is so broad that getting started can be overwhelming.
    In part 1 of this book, you got a theoretical introduction to cloud native applications
    and the processes supporting them, and you had a first hands-on experience building
    a minimal Spring Boot application and deploying it to Kubernetes as a container.
    All of that will help you better understand the overall cloud native picture and
    correctly place the topics I’ll be covering in the rest of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生领域如此广泛，以至于开始时可能会感到不知所措。本书的第一部分，你得到了云原生应用程序及其支持过程的理论介绍，并有了构建最小Spring Boot应用程序并将其作为容器部署到Kubernetes的第一次动手实践。所有这些都将帮助你更好地理解整体云原生图景，并正确地定位本书其余部分将要涉及的主题。
- en: 'The cloud opened up endless possibilities for what we can achieve with many
    types of applications. In this chapter, I’ll start with one of the most common
    types: a web application that exposes its functionality over HTTP through a REST
    API. I’ll guide you through the development process you’ll follow in all the subsequent
    chapters, addressing the significant differences between traditional and cloud
    native web applications, consolidating some necessary aspects of Spring Boot and
    Spring MVC, and highlighting essential testing and production considerations.
    I’ll also explain some of the guidelines recommended by the 15-Factor methodology,
    including dependency management, concurrency, and API first.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算为我们使用各种应用程序所能实现的目标打开了无限可能。在本章中，我将从一个最常见类型开始：一个通过REST API在HTTP上暴露其功能的Web应用程序。我将引导你通过后续章节中将要遵循的开发过程，讨论传统Web应用程序和云原生Web应用程序之间的显著差异，整合Spring
    Boot和Spring MVC的一些必要方面，并强调重要的测试和生产考虑因素。我还会解释15-Factor方法中推荐的一些指南，包括依赖管理、并发性和API优先。
- en: Along the way, you’ll implement the Catalog Service application you initialized
    in the previous chapter. It will be responsible for managing the catalog of books
    in the Polar Bookshop system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你将实现上一章中初始化的目录服务应用程序。它将负责管理Polar Bookshop系统中的图书目录。
- en: Note The source code for the examples in this chapter is available in the Chapter03/03-begin
    and Chapter03/03-end folders, which contain the initial and final states of the
    project ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在Chapter03/03-begin和Chapter03/03-end文件夹中找到，其中包含项目的初始状态和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 3.1 Bootstrapping a cloud native project
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 启动云原生项目
- en: Starting a new development project is always exciting. The 15-Factor methodology
    contains some practical guidelines for bootstrapping a cloud native application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的开发项目总是令人兴奋的。15-Factor方法包含了一些启动云原生应用程序的实用指南。
- en: '*One codebase, one application*—Cloud native applications should consist of
    a single codebase tracked in a version control system.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个代码库，一个应用程序*—云原生应用程序应由一个版本控制系统跟踪的单个代码库组成。'
- en: '*Dependency management*—Cloud native applications should use a tool that manages
    dependencies explicitly and shouldn’t rely on implicit dependencies from the environment
    where they are deployed.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖管理*—云原生应用程序应使用一个显式管理依赖关系的工具，不应依赖于它们部署的环境中的隐式依赖。'
- en: In this section, I’ll provide a few more details about those two principles
    and explain how to apply them to Catalog Service, the first cloud native application
    in the Polar Bookshop system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将提供关于这两个原则的更多细节，并解释如何将它们应用于目录服务，这是Polar Bookshop系统中的第一个云原生应用程序。
- en: 3.1.1 One codebase, one application
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 一个代码库，一个应用程序
- en: A cloud native application should consist of a single codebase tracked in a
    version control system like Git. Each codebase must produce immutable artifacts,
    called *builds*, that can be deployed to multiple environments. Figure 3.1 shows
    the relationship between codebase, build, and deployments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序应由一个在版本控制系统（如Git）中跟踪的单一代码库组成。每个代码库必须产生不可变的工件，称为*构建*，这些构建可以部署到多个环境。图3.1显示了代码库、构建和部署之间的关系。
- en: '![03-01](../Images/03-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![03-01](../Images/03-01.png)'
- en: Figure 3.1 Each application has its codebase, from which immutable builds are
    produced and then deployed to the appropriate environments without changes to
    the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 每个应用程序都有自己的代码库，从中产生不可变的构建，然后部署到适当的环境，而无需更改代码。
- en: As you’ll see in the next chapter, anything environment-specific like configuration
    must be outside of the application codebase. In case of code that’s needed by
    more than one application, you should either turn it into an independent service
    or into a library that you can import into the project as a dependency. You should
    carefully evaluate the latter option to prevent the system from becoming a *distributed
    monolith*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下一章中将要看到的，任何特定于环境的配置，如配置，都必须在应用程序代码库之外。如果代码被多个应用程序需要，你应该将其转换为独立的服务，或者将其转换为可以作为一个依赖项导入项目的库。你应该仔细评估后者，以防止系统成为一个*分布式单体*。
- en: Note Thinking about how your code is organized into codebases and repositories
    can help you focus more on the system architecture and identify those parts that
    might actually stand on their own as independent services. If this is done correctly,
    the codebase’s organization can favor modularity and loose coupling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：思考你的代码是如何组织到代码库和仓库中的，可以帮助你更多地关注系统架构，并识别那些可能实际上可以独立作为服务存在的部分。如果这样做正确，代码库的组织可以有利于模块化和松散耦合。
- en: According to the 15-Factor methodology, each codebase should be mapped to an
    application, but nothing is said about repositories. You can decide to track each
    codebase in a separate repository or in the same one. Both options are used in
    the cloud native business. Throughout the book, you’ll build several applications,
    and I recommend you track each codebase in its own Git repository because it’ll
    improve maintainability and deployability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据十五要素方法，每个代码库都应该映射到一个应用程序，但关于仓库没有提及。你可以选择在单独的仓库中跟踪每个代码库，或者在同一个仓库中。这两种选项在云原生业务中都得到了应用。在整个书中，你将构建几个应用程序，我建议你在自己的Git仓库中跟踪每个代码库，因为这将提高可维护性和可部署性。
- en: In the previous chapter, you initialized the first application in the Polar
    Bookshop system, Catalog Service, and placed it in a catalog-service Git repository.
    I recommend you use GitHub for storing your repositories because later we’re going
    to use GitHub Actions as the workflow engine to define deployment pipelines in
    support of continuous delivery.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你初始化了Polar Bookshop系统中的第一个应用程序，目录服务，并将其放置在catalog-service Git仓库中。我建议你使用GitHub来存储你的仓库，因为稍后我们将使用GitHub
    Actions作为工作流引擎来定义支持持续交付的部署管道。
- en: 3.1.2 Dependency management with Gradle and Maven
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 使用Gradle和Maven进行依赖项管理
- en: How you manage dependencies for your applications is relevant because it affects
    their reliability and portability. In the Java ecosystem, the two most used tools
    for dependency management are Gradle and Maven. Both provide the functionality
    to declare dependencies in a manifest and download them from a central repository.
    The reason for listing all the dependencies your project needs is to ensure that
    you do not depend on any implicit library leaking from the surrounding environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何管理应用程序的依赖项是相关的，因为它会影响它们的可靠性和可移植性。在Java生态系统中，用于依赖项管理的两个最常用的工具是Gradle和Maven。两者都提供了在清单中声明依赖项并从中央仓库下载它们的功能。列出项目所需的所有依赖项的原因是确保你不会依赖于任何从周围环境中泄露的隐式库。
- en: Note Apart from dependency management, Gradle and Maven offer additional features
    for building, testing, and configuring a Java project, which are fundamental for
    application development. All the examples in the book will use Gradle, but feel
    free to use Maven instead.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：除了依赖项管理之外，Gradle和Maven还为构建、测试和配置Java项目提供了额外的功能，这对于应用程序开发是基本的。本书中的所有示例都将使用Gradle，但你可以自由地使用Maven。
- en: Even though you have a dependency manifest in place, you’ll still need to provide
    the dependency manager itself. Both Gradle and Maven offer a feature to run the
    tool from a *wrapper script* named gradlew or mvnw that you can include in your
    codebase. For example, rather than running a Gradle command like gradle build
    (which assumes you have Gradle installed on your machine), you can run ./gradlew
    build. The script invokes the specific version of the build tool defined in the
    project. If the build tool is not present yet, the wrapper script will download
    it first and then run the command. Using the wrapper, you can ensure that all
    team members and automated tools building the project use the same Gradle or Maven
    version. When you’re generating a new project from Spring Initializr, you’ll also
    get a wrapper script that’s ready to use, so you don’t need to download or configure
    anything.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经有了依赖项清单，你仍然需要提供依赖管理器本身。Gradle 和 Maven 都提供了一种从名为 gradlew 或 mvnw 的 *包装脚本*
    运行工具的功能，你可以将其包含在你的代码库中。例如，你不必运行 gradle build 这样的 Gradle 命令（这假设你在你的机器上安装了 Gradle），你可以运行
    ./gradlew build。该脚本调用项目中定义的特定版本的构建工具。如果构建工具尚未存在，包装脚本将首先下载它，然后运行命令。使用包装脚本，你可以确保所有团队成员和构建项目的自动化工具使用相同的
    Gradle 或 Maven 版本。当你从 Spring Initializr 生成新项目时，你也会得到一个可用的包装脚本，因此你不需要下载或配置任何内容。
- en: 'Note No matter what, you’ll usually have at least one external dependency:
    the runtime. In our case, that’s the Java Runtime Environment (JRE). If you package
    your application as a container image, the Java runtime will be included in the
    image itself, granting you more control over it. On the other hand, the final
    application artifact will depend on the container runtime required to run the
    image. You’ll learn more about the containerization process in chapter 6.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：无论如何，你通常至少有一个外部依赖项：运行时。在我们的例子中，那就是 Java 运行时环境（JRE）。如果你将应用程序打包成容器镜像，Java 运行时将包含在镜像本身中，这让你对其有更多的控制权。另一方面，最终的应用程序工件将依赖于运行镜像所需的容器运行时。你将在第
    6 章中了解更多关于容器化过程的信息。
- en: Now, on to the code. The Polar Bookshop system has a Catalog Service application
    that’s responsible for managing the books available in the catalog. In the previous
    chapter, we initialized the project. The architecture of the system is shown again
    in figure 3.2.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码。Polar Bookshop 系统有一个负责管理目录中书籍的 Catalog Service 应用程序。在前一章中，我们初始化了项目。系统的架构再次在图
    3.2 中展示。
- en: '![03-02](../Images/03-02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![03-02](../Images/03-02.png)'
- en: Figure 3.2 The architecture of the Polar Bookshop system, currently consisting
    of only one application service
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 Polar Bookshop 系统的架构，目前仅由一个应用服务组成
- en: All the dependencies required by the application are listed in the autogenerated
    build.gradle file (catalog-service/build.gradle).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序所需的所有依赖项都列在自动生成的 build.gradle 文件中（catalog-service/build.gradle）。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are the main dependencies:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要的依赖项：
- en: Spring Web (org.springframework.boot:spring-boot-starter-web) provides the necessary
    libraries for building web applications with Spring MVC and includes Tomcat as
    the default embedded server.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Web (org.springframework.boot:spring-boot-starter-web) 提供了构建使用 Spring
    MVC 的 Web 应用程序所需的库，包括默认的嵌入服务器 Tomcat。
- en: Spring Boot Test (org.springframework.boot:spring-boot-starter-test) provides
    several libraries and utilities for testing applications, including Spring Test,
    JUnit, AssertJ, and Mockito. It’s automatically included in every Spring Boot
    project.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot Test (org.springframework.boot:spring-boot-starter-test) 提供了用于测试应用程序的多个库和实用工具，包括
    Spring Test、JUnit、AssertJ 和 Mockito。它自动包含在每一个 Spring Boot 项目中。
- en: One of the great features of Spring Boot is the way it handles dependency management.
    Starter dependencies like spring-boot-starter-web relieve you of managing many
    more dependencies and verifying that the particular versions you import are compatible
    with each other. It’s yet another Spring Boot feature that will get you started
    in a simple and productive way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 的一个重要特性是它处理依赖管理的方式。例如，spring-boot-starter-web 这样的启动依赖项可以减轻你管理更多依赖项和验证导入的特定版本之间兼容性的负担。这又是
    Spring Boot 的一个特性，它将以简单且高效的方式帮助你开始。
- en: In the next section, you’ll learn more about how the server embedded in Spring
    Boot works and how to configure it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解嵌入在 Spring Boot 中的服务器是如何工作的，以及如何对其进行配置。
- en: 3.2 Working with embedded servers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 与嵌入服务器一起工作
- en: 'With Spring Boot, you can build different types of applications (e.g., web,
    event-driven, serverless, batch, and task applications) characterized by various
    use cases and patterns. In a cloud native context, they all share some common
    aspects:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring Boot，你可以构建不同类型的应用程序（例如，Web、事件驱动、无服务器、批处理和任务应用程序），这些应用程序具有各种用例和模式。在云原生环境中，它们都共享一些共同方面：
- en: They are entirely self-contained, with no external dependencies other than the
    runtime.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们完全是自包含的，除了运行时之外没有其他外部依赖。
- en: They are packaged as standard, executable artifacts.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被打包为标准的可执行工件。
- en: Consider a web application. Traditionally, you would package it as a WAR or
    EAR file (archive formats used to package Java applications) and deploy it to
    a web server like Tomcat or an application server like WildFly. The external dependency
    on a server would limit the portability and evolution of the application itself
    and increase the maintenance costs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个 Web 应用程序。传统上，你会将其打包为 WAR 或 EAR 文件（用于打包 Java 应用程序的存档格式）并部署到像 Tomcat 或 WildFly
    这样的 Web 服务器或应用程序服务器。对外部服务器的依赖会限制应用程序本身的可移植性和进化，并增加维护成本。
- en: 'In this section, you’ll see how to solve those problems in a cloud native web
    application with Spring Boot, Spring MVC, and an embedded server, but similar
    principles apply to other types of applications as well. You’ll learn the differences
    between traditional and cloud native applications, how an embedded server like
    Tomcat works, and how you can configure it. I’ll also elaborate on a few guidelines
    from the 15-Factor methodology regarding servers, port binding, and concurrency:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何使用 Spring Boot、Spring MVC 和嵌入式服务器在云原生 Web 应用程序中解决这些问题，但类似的原则也适用于其他类型的应用程序。你将学习传统应用程序和云原生应用程序之间的区别，嵌入式服务器（如
    Tomcat）的工作方式，以及如何配置它。我还会详细说明 15-Factor 方法论中关于服务器、端口绑定和并发的几个指南：
- en: '*Port binding*—Unlike traditional applications that depend on an external server
    being available in the execution environment, cloud native applications are self-contained
    and export their services by binding to a port that can be configured depending
    on the environment.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*端口绑定*—与依赖于执行环境中外部服务器可用的传统应用程序不同，云原生应用程序是自包含的，并通过绑定到一个可配置的端口来导出其服务，该端口取决于环境。'
- en: '*Concurrency*—In JVM applications, we handle concurrency through multiple threads
    available as thread pools. When the concurrency limit is hit, we favor horizontal
    over vertical scaling. Instead of adding more computational resources to the application,
    we prefer to deploy more instances and distribute the workload among them.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并发*—在 JVM 应用程序中，我们通过多个线程（作为线程池可用）来处理并发。当达到并发限制时，我们倾向于水平扩展而不是垂直扩展。我们不是向应用程序添加更多的计算资源，而是更倾向于部署更多实例并将工作负载在他们之间分配。'
- en: Following those principles, we’ll continue working on Catalog Service to ensure
    it’s self-contained and packaged as an executable JAR.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 依据这些原则，我们将继续在目录服务上工作，以确保它是自包含的，并打包为一个可执行 JAR。
- en: Servers! Servers everywhere!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器！到处都是服务器！
- en: So far I’ve used the terms *application servers* and *web servers*. Later, I
    will also mention *Servlet containers*. What’s the difference?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我使用了 *应用程序服务器* 和 *Web 服务器* 这些术语。稍后，我还会提到 *Servlet 容器*。它们之间的区别是什么？
- en: '*Web server*—A server that handles HTTP requests coming from a client and replies
    with HTTP responses, such as Apache HTTPD.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Web 服务器*—一个处理来自客户端的 HTTP 请求并回复 HTTP 响应的服务器，例如 Apache HTTPD。'
- en: '*Servlet container*—A component, part of a web server, that provides an execution
    context for web applications using the Java Servlet API (like Spring MVC apps).
    Tomcat (Catalina) is one example.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Servlet 容器*—一个组件，是 Web 服务器的一部分，为使用 Java Servlet API 的 Web 应用程序提供执行上下文（如 Spring
    MVC 应用程序）。Tomcat（Catalina）是一个例子。'
- en: '*Application server*—A server that provides a complete execution environment
    (like Jakarta EE) for different types of applications and supports several protocols,
    such as WildFly.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序服务器*—一个为不同类型的应用程序提供完整执行环境（如 Jakarta EE）并支持多个协议的服务器，例如 WildFly。'
- en: 3.2.1 Executable JARs and embedded servers
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 可执行 JAR 和嵌入式服务器
- en: One of the differences between a traditional approach and a cloud native one
    is how you package and deploy applications. Traditionally, we used to have application
    servers or standalone web servers. They were expensive to set up and maintain
    in production, so they were used to deploy several applications, packaged as EAR
    or WAR artifacts for the sake of efficiency. Such a scenario created coupling
    among the applications. If any of them wanted to change something at the server
    level, the change would have to be coordinated with other teams and applied to
    all the applications, limiting agility and application evolution. Besides that,
    the deployment of an application depended on a server being available on the machine,
    limiting the application’s portability across different environments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方法与云原生方法之间的一个区别在于如何打包和部署应用程序。传统上，我们通常使用应用服务器或独立的Web服务器。在生产环境中，它们设置和维护成本高昂，因此它们被用来部署多个应用程序，这些应用程序打包成EAR或WAR工件以提高效率。这种场景在应用程序之间创建了耦合。如果其中任何一个想要在服务器级别进行更改，那么更改必须与其他团队协调并应用于所有应用程序，这限制了敏捷性和应用程序的演变。此外，应用程序的部署依赖于机器上可用的服务器，限制了应用程序在不同环境中的可移植性。
- en: When you go cloud native, things are different. Cloud native applications should
    be self-contained and not dependent on a server being available in the execution
    environment. Instead, the necessary server capabilities are included in the application
    itself. Spring Boot offers built-in server functionality that helps you remove
    the external dependency and make the application standalone. Spring Boot comes
    bundled with a preconfigured Tomcat server, but it’s possible to replace it with
    Undertow, Jetty, or Netty.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你转向云原生时，事情就不同了。云原生应用程序应该是自包含的，并且不依赖于执行环境中可用的服务器。相反，必要的服务器功能包含在应用程序本身中。Spring
    Boot提供了内置的服务器功能，可以帮助你去除外部依赖，使应用程序独立。Spring Boot附带了一个预配置的Tomcat服务器，但也可以将其替换为Undertow、Jetty或Netty。
- en: Having solved the server dependency problem, we need to change how we package
    the application accordingly. In the JVM ecosystem, cloud native applications are
    packaged as JAR artifacts. Since they are self-contained, they can run as standalone
    Java applications with no external dependency apart from the JVM. Spring Boot
    is flexible enough to allow both JAR and WAR types of packaging. Still, for cloud
    native applications, you’ll want to use self-contained JARs, also called *fat-JARs*
    or *uber-JARs*, since they contain the application itself, the dependencies, and
    the embedded server. Figure 3.3 compares the traditional and cloud native ways
    of packaging and running web applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了服务器依赖问题后，我们需要相应地改变打包应用程序的方式。在JVM生态系统中，云原生应用程序被打包成JAR工件。由于它们是自包含的，它们可以作为独立的Java应用程序运行，除了JVM之外没有外部依赖。Spring
    Boot足够灵活，允许JAR和WAR类型的打包。然而，对于云原生应用程序，你将希望使用自包含的JAR文件，也称为*胖JAR*或*uber-JAR*，因为它们包含了应用程序本身、依赖项和嵌入式服务器。图3.3比较了传统和云原生打包和运行Web应用程序的方式。
- en: '![03-03](../Images/03-03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![03-03](../Images/03-03.png)'
- en: Figure 3.3 Traditionally, applications are packaged as WARs and require a server
    to be available in the execution environment to run. Cloud native applications
    are packaged as JARs, are self-contained, and use an embedded server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 传统上，应用程序被打包成WAR文件，需要在执行环境中有一个可用的服务器来运行。云原生应用程序被打包成JAR文件，是自包含的，并使用嵌入式服务器。
- en: The embedded servers used for cloud native applications usually comprise a web
    server component and an execution context to make a Java web application interact
    with the web server. For example, Tomcat contains a web server component (Coyote)
    and an execution context based on the Java Servlet API, usually called the Servlet
    container (Catalina). I will use *web server* and *Servlet container* interchangeably.
    On the other hand, application servers are not recommended for cloud native applications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用于云原生应用程序的嵌入式服务器通常包括一个Web服务器组件和一个执行上下文，以便Java Web应用程序能够与Web服务器交互。例如，Tomcat包含一个Web服务器组件（Coyote）和一个基于Java
    Servlet API的执行上下文，通常称为Servlet容器（Catalina）。我将交替使用*Web服务器*和*Servlet容器*。另一方面，不建议在云原生应用程序中使用应用服务器。
- en: In the previous chapter, when generating the Catalog Service project, we chose
    the JAR packaging option. We then ran the application using the bootRun Gradle
    task. That is a convenient way to build a project and run it as a standalone application
    during development. But now that you know more about the embedded server and JAR
    packaging, I’ll show you another way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当生成目录服务项目时，我们选择了 JAR 打包选项。然后我们使用 bootRun Gradle 任务运行了应用程序。这是一个在开发期间构建项目并作为独立应用程序运行的好方法。但现在你对我们关于嵌入式服务器和
    JAR 打包的了解更多了，我将向你展示另一种方法。
- en: First, let’s package the application as a JAR file. Open a Terminal window,
    navigate to the root folder of the Catalog Service project (catalog-service),
    and run the following command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将应用程序打包成一个 JAR 文件。打开一个终端窗口，导航到目录服务项目（catalog-service）的根文件夹，并运行以下命令。
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The bootJar Gradle task compiles the code and packages the application as a
    JAR file. By default, the JAR is generated in the build/libs folder. You should
    get an executable JAR file named catalog-service-0.0.1-SNAPSHOT.jar. Once you
    get the JAR artifact, you can go ahead and run it like any standard Java application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: bootJar Gradle 任务编译代码并将应用程序打包成一个 JAR 文件。默认情况下，JAR 文件生成在 build/libs 文件夹中。你应该得到一个名为
    catalog-service-0.0.1-SNAPSHOT.jar 的可执行 JAR 文件。一旦你得到 JAR 艺术品，你就可以像任何标准 Java 应用程序一样运行它。
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note Another practical Gradle task is build, which combines the operations of
    the bootJar and test tasks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：另一个实用的 Gradle 任务是 build，它结合了 bootJar 和 test 任务的操作。
- en: Since the project contains the spring-boot-starter-web dependency, Spring Boot
    automatically configures an embedded Tomcat server. By looking at the logs in
    figure 3.4, you can see that one of the first execution steps is initializing
    a Tomcat server instance embedded in the application itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目包含 spring-boot-starter-web 依赖项，Spring Boot 自动配置了一个嵌入的 Tomcat 服务器。通过查看图 3.4
    中的日志，你可以看到第一个执行步骤之一是初始化应用程序本身嵌入的 Tomcat 服务器实例。
- en: '![03-04](../Images/03-04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![03-04](../Images/03-04.png)'
- en: Figure 3.4 The startup logs from the Catalog Service application
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 目录服务应用程序的启动日志
- en: In the next section, you’ll learn more about how the embedded server works in
    Spring Boot. Before moving on, though, you can stop the application with Ctrl-C.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解 Spring Boot 中嵌入式服务器的工作方式。在继续之前，你可以使用 Ctrl-C 停止应用程序。
- en: 3.2.2 Understanding the thread-per-request model
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 理解 thread-per-request 模型
- en: Let’s consider the request/response pattern commonly used in web applications
    to establish synchronous interactions over HTTP. A client sends an HTTP request
    to a server that performs some computation, and it then replies with an HTTP response.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在 Web 应用程序中常用的一种请求/响应模式，以在 HTTP 上建立同步交互。客户端向服务器发送 HTTP 请求，服务器执行一些计算，然后以
    HTTP 响应的形式回复。
- en: In web applications running in a Servlet container like Tomcat, requests are
    processed based on a model called *thread-per-request*. For each request, the
    application dedicates a thread exclusively to handling that specific request;
    the thread will not be used for anything else until a response is returned to
    the client. When the request-handling involves intensive operations like I/O,
    the thread will block until the operations are completed. For example, if a database
    read is required, the thread will wait until data is returned from the database.
    That’s why we say that this type of processing is *synchronous* and *blocking*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Tomcat 这样的 Servlet 容器中运行的 Web 应用程序中，请求是基于名为 *thread-per-request* 的模型处理的。对于每个请求，应用程序专门分配一个线程来处理该特定请求；该线程在返回响应给客户端之前不会用于其他任何事情。当请求处理涉及像
    I/O 这样的密集型操作时，线程将阻塞直到操作完成。例如，如果需要数据库读取，线程将等待直到从数据库返回数据。这就是为什么我们说这种处理方式是 *同步* 和
    *阻塞* 的。
- en: Tomcat is initialized with a thread pool that’s used to manage all incoming
    HTTP requests. New requests will be queued when all threads are in use, waiting
    for a thread to become free. In other words, the number of threads in Tomcat defines
    an upper limit to how many requests are supported concurrently. This is very useful
    to remember when debugging performance issues. If the thread concurrency limit
    is hit continuously, you can always tune the thread pool configuration to accept
    more workload. With traditional applications we would add more computational resources
    to a specific instance. For cloud native applications, we rely on horizontal scaling
    and deploying more replicas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat 使用一个线程池来初始化，该线程池用于管理所有传入的 HTTP 请求。当所有线程都在使用时，新请求将被排队，等待一个线程变得空闲。换句话说，Tomcat
    中的线程数量定义了可以同时支持多少个请求的上限。在调试性能问题时记住这一点非常有用。如果连续遇到线程并发限制，您始终可以调整线程池配置以接受更多的负载。对于传统应用程序，我们会向特定实例添加更多的计算资源。对于云原生应用程序，我们依赖于水平扩展和部署更多的副本。
- en: Note In some applications that have to respond to high demands, the thread-per-request
    model might not be ideal, because it doesn’t use the available computational resources
    in the most efficient way due to the blocking. In chapter 8, I’ll introduce an
    *asynchronous* and *non-blocking* alternative with Spring WebFlux and Project
    Reactor, adopting the reactive programming paradigm.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在某些必须响应高需求的应用程序中，按请求分配线程的模型可能不是理想的，因为它由于阻塞而没有最有效地使用可用的计算资源。在第 8 章中，我将介绍一个基于
    Spring WebFlux 和 Project Reactor 的 *异步* 和 *非阻塞* 的替代方案，采用反应式编程范式。
- en: Spring MVC is the library included in the Spring Framework to implement web
    applications, either full MVC or REST-based. Either way, the functionality is
    based on a server like Tomcat that provides a Servlet container compliant with
    the Java Servlet API. Figure 3.5 shows how the REST-based request/response interaction
    works in a Spring web application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 是 Spring 框架中包含的库，用于实现网络应用程序，无论是完整的 MVC 还是基于 REST 的。无论如何，其功能基于像 Tomcat
    这样的服务器，它提供了一个符合 Java Servlet API 的 Servlet 容器。图 3.5 展示了在 Spring 网络应用程序中基于 REST
    的请求/响应交互是如何工作的。
- en: '![03-05](../Images/03-05.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![03-05](../Images/03-05.png)'
- en: Figure 3.5 The DispatcherServlet component is the entry point to the Servlet
    container (Tomcat). It delegates the actual HTTP request processing to a controller
    identified by HandlerMapping as the one responsible for a given endpoint.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 DispatcherServlet 组件是 Servlet 容器（Tomcat）的入口点。它将实际的 HTTP 请求处理委托给 HandlerMapping
    识别的控制器，该控制器负责特定的端点。
- en: The DispatcherServlet component provides a central entry point for request processing.
    When a client sends a new HTTP request for a specific URL pattern, DispatcherServlet
    asks the HandlerMapping component for the controller responsible for that endpoint,
    and it finally delegates the actual processing of the request to the specified
    controller. The controller processes the request, possibly by calling some other
    services, and then returns a response to DispatcherServlet, which finally replies
    to the client with an HTTP response.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: DispatcherServlet 组件提供了请求处理的中心入口点。当客户端发送一个针对特定 URL 模式的新的 HTTP 请求时，DispatcherServlet
    会请求 HandlerMapping 组件以获取负责该端点的控制器，并最终将请求的实际处理委托给指定的控制器。控制器处理请求，可能通过调用其他服务，然后向
    DispatcherServlet 返回一个响应，最后 DispatcherServlet 以 HTTP 响应的形式回复客户端。
- en: Notice how the Tomcat server is embedded in the Spring Boot application. Spring
    MVC relies on the web server to accomplish its functionality. The same is true
    for any web server implementing the Servlet API, but since we are explicitly using
    Tomcat, let’s go ahead and explore some options for configuring it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Tomcat 服务器是如何嵌入到 Spring Boot 应用程序中的。Spring MVC 依赖于网络服务器来完成其功能。对于实现 Servlet
    API 的任何网络服务器也是如此，但由于我们明确使用 Tomcat，让我们继续探索一些配置它的选项。
- en: 3.2.3 Configuring the embedded Tomcat
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 配置嵌入式 Tomcat
- en: Tomcat is the default server that comes preconfigured with any Spring Boot web
    application. Sometimes the default configuration might be enough, but for applications
    in production, you’ll likely need to customize its behavior to meet the specific
    requirements.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat 是任何 Spring Boot 网络应用程序预配置的默认服务器。有时默认配置可能足够，但对于生产中的应用程序，您可能需要自定义其行为以满足特定的要求。
- en: 'Note In a traditional Spring application, you would configure a server like
    Tomcat in dedicated files such as server.xml and context.xml. With Spring Boot,
    you can configure an embedded web server in two ways: through properties or in
    a WebServerFactoryCustomizer bean.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在传统的Spring应用程序中，你会在专门的文件中配置服务器，例如server.xml和context.xml。使用Spring Boot，你可以通过两种方式配置嵌入式Web服务器：通过属性或通过WebServerFactoryCustomizer
    bean。
- en: 'This section will show you how to configure Tomcat through properties. You’ll
    learn more about configuring applications in the next chapter. For now, it’s enough
    to know that you can define properties in an application.properties or application.yml
    file located in the src/main/resources folder of your project. You’re free to
    choose which format to use: .properties files rely on key/value pairs while .yml
    files use the YAML format. In this book, I’ll define properties using YAML. Spring
    Initializr generates an empty application.properties file by default, so remember
    to change its extension from .properties to .yml before moving on.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何通过属性配置Tomcat。您将在下一章中了解更多关于配置应用程序的内容。现在，只需知道您可以在项目的src/main/resources文件夹中的application.properties或application.yml文件中定义属性即可。您可以选择使用哪种格式：.properties文件依赖于键/值对，而.yml文件使用YAML格式。在这本书中，我将使用YAML定义属性。Spring
    Initializr默认生成一个空的application.properties文件，所以记得在继续之前将其扩展名从.properties更改为.yml。
- en: Let’s go ahead and configure the embedded server for the Catalog Service application
    (catalog-service). All the configuration properties will go in the application.yml
    file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续配置Catalog Service应用程序（catalog-service）的嵌入式服务器。所有配置属性都将放入application.yml文件中。
- en: HTTP port
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP端口
- en: By default, the embedded server is listening on port 8080\. That is fine as
    long as you are working with only one application. If you run more Spring applications
    during development, which is usually the case with cloud native systems, you’ll
    want to specify a different port number for each application using the server.port
    property.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，嵌入式服务器正在监听8080端口。只要您只使用一个应用程序，这就可以了。如果您在开发期间运行多个Spring应用程序，这在云原生系统中通常是情况，您将希望使用server.port属性为每个应用程序指定不同的端口号。
- en: Listing 3.1 Configuring the web server port
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 配置Web服务器端口
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Connection timeout
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 连接超时
- en: The server.tomcat.connection-timeout property defines a limit for how much time
    Tomcat should wait between accepting a TCP connection from a client and actually
    receiving the HTTP request. It helps prevent denial-of-service (DoS) attacks where
    a connection is established, Tomcat reserves a thread to handle the request, and
    the request never comes. The same timeout is used to limit the time spent reading
    the HTTP request body when there is one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: server.tomcat.connection-timeout属性定义了Tomcat在从客户端接受TCP连接和实际接收HTTP请求之间应该等待多长时间的限制。它有助于防止拒绝服务（DoS）攻击，在这种攻击中，连接被建立，Tomcat保留一个线程来处理请求，但请求从未到来。相同的超时时间也用于限制在存在HTTP请求体时读取HTTP请求体的时间。
- en: The default value is 20s (20 seconds), which is probably too much for a standard
    cloud native application. In the context of highly distributed systems in the
    cloud, we probably don’t want to wait more than a couple of seconds and risk a
    cascading failure due to a Tomcat instance hanging for too long. Something like
    2s would be better. You can also use the server.tomcat.keep-alive-timeout property
    to configure how long to keep a connection open while waiting for new HTTP requests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是20秒（20秒），这可能对于标准云原生应用程序来说太多了。在云中高度分布的系统背景下，我们可能不想等待超过几秒钟，以免因为Tomcat实例挂起时间过长而导致级联故障。大约2秒会更好。您还可以使用server.tomcat.keep-alive-timeout属性来配置在等待新的HTTP请求时保持连接打开的时间。
- en: Listing 3.2 Configuring timeouts for Tomcat
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 配置Tomcat的超时
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Thread pool
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池
- en: Tomcat has a pool of threads that process requests, following the thread-per-request
    model. The number of available threads will determine how many requests can be
    handled simultaneously. You can configure the maximum number of request processing
    threads through the server.tomcat.threads.max property. You can also define the
    minimum number of threads that should always be kept running (server.tomcat .threads.min-spare),
    which is also how many threads are created at startup.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat有一组线程池来处理请求，遵循每个请求一个线程的模型。可用的线程数将决定可以同时处理多少个请求。你可以通过server.tomcat.threads.max属性配置请求处理线程的最大数量。你也可以定义应该始终运行的最小线程数（server.tomcat.threads.min-spare），这也是启动时创建的线程数。
- en: Determining the best configuration for a thread pool is complicated, and there’s
    no magic formula for computing it. Resource analysis, monitoring, and many trials
    are usually necessary to find a suitable configuration. The default thread pool
    can grow up to 200 threads and has 10 worker threads always running, which are
    good starting values in production. In your local environment, you might want
    to lower those values to optimize resource consumption, since it increases linearly
    with the number of threads.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确定线程池的最佳配置很复杂，没有计算它的魔法公式。资源分析、监控和多次试验通常是找到合适配置所必需的。默认线程池可以增长到200个线程，并且始终有10个工作线程在运行，这在生产中是良好的起始值。在您的本地环境中，您可能希望降低这些值以优化资源消耗，因为随着线程数量的增加，它呈线性增长。
- en: Listing 3.3 Configuring the Tomcat thread pool
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 配置Tomcat线程池
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So far, you’ve seen that cloud native applications with Spring Boot are packaged
    as JAR files and rely on an embedded server to remove extra dependencies on the
    execution environment and enable agility. You learned how the thread-per-request
    model works, familiarized yourself with the request processing flow with Tomcat
    and Spring MVC, and configured Tomcat. In the next section, we’ll move on to the
    business logic of Catalog Service and the implementation of a REST API with Spring
    MVC.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到，使用Spring Boot的云原生应用程序被打包成JAR文件，并依赖于嵌入式服务器以去除对执行环境的额外依赖，并实现敏捷性。您学习了线程请求模型的工作原理，熟悉了使用Tomcat和Spring
    MVC的请求处理流程，并配置了Tomcat。在下一节中，我们将继续探讨目录服务的业务逻辑以及使用Spring MVC实现REST API。
- en: 3.3 Building a RESTful application with Spring MVC
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 使用Spring MVC构建RESTful应用程序
- en: 'If you’re building cloud native applications, chances are that you are working
    on a distributed system composed of several services, such as microservices, interacting
    with each other to accomplish the overall functionality of the product. Your application
    might be consumed by a service developed by another team in your organization,
    or you might be exposing its functionality to third parties. Either way, there’s
    an essential element in any inter-service communication: the API.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建云原生应用程序，那么您很可能会在一个由多个服务组成的分布式系统中工作，这些服务（如微服务）相互交互以完成产品的整体功能。您的应用程序可能被您组织中的另一个团队开发的服务所消费，或者您可能正在将其功能暴露给第三方。无论哪种方式，任何跨服务通信中都有一个基本元素：API。
- en: The 15-Factor methodology promotes the *API first* pattern. It encourages you
    to establish the service interface first and work on the implementation later.
    The API represents a public contract between your application and its consumers,
    and it’s in your best interests to define it first thing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 15-Factor方法提倡“API优先”模式。它鼓励您首先建立服务接口，然后进行实现。API代表您应用程序与其消费者之间的公共合同，因此最好首先定义它。
- en: Suppose you agree on a contract and define the API first. In that case, other
    teams can start working on their solutions and develop against your API to implement
    their integration with your application. If you don’t develop the API first, there
    will be a bottleneck, and other teams will have to wait until you’re done with
    your application. Discussing the API up front also enables productive discussions
    with stakeholders, which can lead to you clarifying the scope of the application
    and even defining user stories to implement.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您同意一个合同并首先定义API。在这种情况下，其他团队可以开始工作并针对您的API开发解决方案，以实现与您的应用程序的集成。如果您不首先开发API，那么将出现瓶颈，其他团队将不得不等待您完成应用程序。提前讨论API还可以与利益相关者进行富有成效的讨论，这可能有助于您明确应用程序的范围，甚至定义要实现的用户故事。
- en: In the cloud, any application can be a backing service for another one. Adopting
    an API first mentality will help you evolve your applications and adapt them to
    future requirements.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中，任何应用程序都可以成为另一个应用程序的后端服务。采用API优先的心态将帮助您演进您的应用程序并适应未来的需求。
- en: This section will guide you by defining a contract for Catalog Service as a
    REST API, the most used service interface model for cloud native applications.
    You’ll use Spring MVC to implement the REST API, validate it, and test it. I’ll
    also outline some considerations for evolving an API for future requirements,
    a common issue in highly distributed systems like cloud native applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将通过定义一个作为REST API的目录服务合同来引导您，这是云原生应用中最常用的服务接口模型。您将使用Spring MVC来实现REST API，验证它，并对其进行测试。我还会概述一些考虑因素，以适应未来需求对API进行演变，这在高度分布式的系统（如云原生应用）中是一个常见问题。
- en: 3.3.1 REST API first, business logic later
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 首先设计 REST API，然后是业务逻辑
- en: 'Designing the API first assumes you have already defined the requirements,
    so let’s start with those. Catalog Service will be responsible for supporting
    the following use cases:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先设计 API 假设您已经定义了需求，因此让我们从这些开始。目录服务将负责支持以下用例：
- en: View the list of books in the catalog.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看目录中的书籍列表。
- en: Search books by their International Standard Book Number (ISBN).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过国际标准书号（ISBN）搜索书籍。
- en: Add a new book to the catalog.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新书籍添加到目录中。
- en: Edit information for an existing book.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑现有书籍的信息。
- en: Remove a book from the catalog.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从目录中删除书籍。
- en: In other words, we can say the application should provide an API to perform
    CRUD operations on books. The format will follow the REST style applied to HTTP.
    There are several ways to design an API to fulfill those use cases. In this chapter,
    we’ll use the approach described in table 3.1.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以这样说，应用程序应该提供 API 来执行书籍的 CRUD 操作。格式将遵循应用于 HTTP 的 REST 风格。有几种方法可以设计 API
    来满足这些用例。在本章中，我们将使用表 3.1 中描述的方法。
- en: Table 3.1 Specifications for the REST API that will be exposed by Catalog Service
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 目录服务将公开的 REST API 规范
- en: '| Endpoint | HTTP method | Request body | Status | Response body | Description
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 端点 | HTTP 方法 | 请求体 | 状态 | 响应体 | 描述 |'
- en: '| /books | GET |  | 200 | Book[] | Get all the books in the catalog. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| /books | GET |  | 200 | 书籍数组 | 获取目录中的所有书籍。 |'
- en: '| /books | POST | Book | 201 | Book | Add a new book to the catalog. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| /books | POST | 书籍 | 201 | 书籍 | 将新书籍添加到目录中。 |'
- en: '|  |  |  | 422 |  | A book with the same ISBN already exists. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | 422 |  | 已存在具有相同 ISBN 的书籍。 |'
- en: '| /books/{isbn} | GET |  | 200 | Book | Get the book with the given ISBN. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| /books/{isbn} | GET |  | 200 | 书籍 | 获取给定 ISBN 的书籍。 |'
- en: '|  |  |  | 404 |  | No book with the given ISBN exists. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | 404 |  | 没有找到给定 ISBN 的书籍。 |'
- en: '| /books/{isbn} | PUT | Book | 200 | Book | Update the book with the given
    ISBN. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| /books/{isbn} | PUT | 书籍 | 200 | 书籍 | 更新给定 ISBN 的书籍。 |'
- en: '|  |  |  | 201 | Book | Create a book with the given ISBN. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  | 201 | 书籍 | 使用给定的 ISBN 创建书籍。 |'
- en: '| /books/{isbn} | DELETE |  | 204 |  | Delete the book with the given ISBN.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| /books/{isbn} | DELETE |  | 204 |  | 删除给定 ISBN 的书籍。 |'
- en: Documenting APIs
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记录 API
- en: 'Documenting APIs is an essential task when you’re following the API-first approach.
    In the Spring ecosystem, there are two main options:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循 API 首先的方法时，记录 API 是一项基本任务。在 Spring 生态系统中，有两个主要选项：
- en: Spring provides a Spring REST Docs project ([https://spring.io/projects/spring-restdocs](https://spring.io/projects/spring-restdocs))
    that helps you document REST APIs via test-driven development (TDD), resulting
    in high-quality and maintainable documentation. The resulting documentation is
    aimed at people, relying on formats like Asciidoc or Markdown. If you’d like to
    obtain an OpenAPI representation as well, you can check the restdocs-api-spec
    community-driven project to add OpenAPI support to Spring REST Docs ([https://github.com/ePages-de/restdocs-api-spec](https://github.com/ePages-de/restdocs-api-spec)).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 提供了 Spring REST Docs 项目 ([https://spring.io/projects/spring-restdocs](https://spring.io/projects/spring-restdocs))，它通过测试驱动开发（TDD）帮助您记录
    REST API，从而生成高质量且易于维护的文档。生成的文档面向人员，依赖于 Asciidoc 或 Markdown 等格式。如果您还想获得 OpenAPI
    表示，可以查看 restdocs-api-spec 社区驱动的项目，以将 OpenAPI 支持添加到 Spring REST Docs ([https://github.com/ePages-de/restdocs-api-spec](https://github.com/ePages-de/restdocs-api-spec))。
- en: The springdoc-openapi community-driven project helps automate the generation
    of API documentation according to the OpenAPI 3 format ([https:// springdoc.org](https://springdoc.org)).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: springdoc-openapi 社区驱动的项目帮助根据 OpenAPI 3 格式自动生成 API 文档 ([https://springdoc.org](https://springdoc.org))。
- en: 'The contract is established through the REST API, so let’s move on and look
    at the business logic. The solution is centered around three concepts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 REST API 建立合同，因此让我们继续并查看业务逻辑。解决方案围绕三个概念展开：
- en: '*Entity*—An entity represents the noun in a domain, such as “book.”'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实体*—实体代表域中的名词，例如“书籍。”'
- en: '*Service*—A service defines the use cases for the domain. For example, “adding
    a book to the catalog.”'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务*—服务定义了域的使用案例。例如，“将一本书添加到目录中。”'
- en: '*Repository*—A repository is an abstraction to let the domain layer access
    data independently from its source.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仓库*—仓库是一个抽象，允许域层独立于其来源访问数据。'
- en: Let’s start with the domain entity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从域实体开始。
- en: Defining the domain entity
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 定义域实体
- en: The REST API defined in table 3.1 should make it possible to operate on books.
    That’s the *domain entity*. In the Catalog Service project, create a new com.polarbookshop.catalogservice.domain
    package for the business logic, and create a Book Java record to represent the
    domain entity.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1中定义的REST API应该能够对书籍进行操作。这是*领域实体*。在Catalog Service项目中，为业务逻辑创建一个新的com.polarbookshop.catalogservice.domain包，并创建一个Book
    Java记录来表示领域实体。
- en: Listing 3.4 Using the Book record to define a domain entity for the application
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 使用Book记录定义应用程序的领域实体
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The domain model is implemented as a record, an immutable object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 领域模型实现为一个记录，一个不可变对象。
- en: ❷ Uniquely identifies a book
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 唯一标识一本书
- en: Implementing the use cases
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实现使用案例
- en: The use cases enumerated by the application requirements can be implemented
    in a @Service class. In the com.polarbookshop.catalogservice.domain package, create
    a BookService class, as shown in the following listing. The service relies on
    some classes that you’ll create in a minute.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需求列举的使用案例可以在一个@Service类中实现。在com.polarbookshop.catalogservice.domain包中创建一个BookService类，如下所示。该服务依赖于你将在下一分钟创建的一些类。
- en: Listing 3.5 Implementing the use cases for the application
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 实现应用程序的使用案例
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Stereotype annotation that marks a class to be a service managed by Spring
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标记一个类为Spring管理的服务泛型注解
- en: ❷ BookRepository is provided through constructor autowiring.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ BookRepository通过构造函数自动装配提供。
- en: ❸ When trying to view a book that doesn’t exist, a dedicated exception is thrown.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当尝试查看一个不存在的书籍时，会抛出一个专门的异常。
- en: ❹ When adding the same book to the catalog multiple times, a dedicated exception
    is thrown.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当多次将同一本书添加到目录中时，会抛出一个专门的异常。
- en: ❺ When editing the book, all the Book fields can be updated except the ISBN
    code, because it’s the entity identifier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在编辑书籍时，可以更新除ISBN代码之外的所有Book字段，因为它是实体标识符。
- en: ❻ When changing the details for a book not in the catalog yet, create a new
    book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当更改尚未在目录中的书籍的详细信息时，创建一个新的书籍。
- en: 'Note The Spring Framework provides two flavors of dependency injection: *constructor-based*
    and *setter-based*. We’ll use constructor-based dependency injection in any production
    code, as advocated by the Spring team, because it ensures that the required dependencies
    are always returned fully initialized and never null. Furthermore, it encourages
    building immutable objects and improves their testability. For more information,
    refer to the Spring Framework documentation ([https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Spring框架提供了两种依赖注入方式：*基于构造函数*和*基于setter*。我们将遵循Spring团队的建议，在任何生产代码中使用基于构造函数的依赖注入，因为它确保所需的依赖项始终以完全初始化的状态返回，并且永远不会为null。此外，它鼓励构建不可变对象，并提高它们的可测试性。有关更多信息，请参阅Spring框架文档([https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework))。
- en: Using the repository abstraction for data access
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储库抽象进行数据访问
- en: The BookService class relies on a BookRepository object to retrieve and save
    books. The domain layer should be unaware of how data is persisted, so BookRepository
    should be an interface to decouple the abstraction from the actual implementation.
    Create a BookRepository interface in the com.polarbookshop.catalogservice.domain
    package to define the abstraction for accessing book data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: BookService类依赖于BookRepository对象来检索和保存书籍。领域层应该不知道数据是如何持久化的，因此BookRepository应该是一个接口，用于将抽象与实际实现解耦。在com.polarbookshop.catalogservice.domain包中创建一个BookRepository接口，以定义访问书籍数据的抽象。
- en: Listing 3.6 The abstraction used by the domain layer to access data
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 领域层用于访问数据使用的抽象
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While the repository interface belongs to the domain, its implementation is
    part of the persistence layer. We’ll add a data persistence layer using a relational
    database in chapter 5\. For now, it’s enough to add a simple in-memory map to
    retrieve and save books. You can define the implementation in an InMemoryBookRepository
    class, located in a new com.polarbookshop.catalogservice.persistence package.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存储库接口属于领域层，但其实现是持久化层的一部分。我们将在第5章中使用关系数据库添加数据持久化层。现在，添加一个简单的内存映射来检索和保存书籍就足够了。你可以在位于新com.polarbookshop.catalogservice.persistence包中的InMemoryBookRepository类中定义实现。
- en: Listing 3.7 In-memory implementation of the BookRepository interface
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 BookRepository接口的内存实现
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Stereotype annotation that marks a class to be a repository managed by Spring
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标记一个类为Spring管理的存储库的泛型注解
- en: ❷ In-memory map to store books for testing purposes
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于测试的内存映射表，用于存储书籍
- en: Using exceptions to signal errors in the domain
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常来指示领域中的错误
- en: Let’s complete the business logic for Catalog Service by implementing the two
    exceptions we used in listing 3.5.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现列表 3.5 中使用的两个异常来完成目录服务的业务逻辑。
- en: BookAlreadyExistsException is a runtime exception thrown when we try to add
    a book to the catalog that is already there. It prevents duplicate entries in
    the catalog.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: BookAlreadyExistsException 是在尝试向目录中添加已存在的书籍时抛出的运行时异常。它防止目录中出现重复条目。
- en: Listing 3.8 Exception thrown when adding a book that already exists
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 添加已存在的书籍时抛出的异常
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: BookNotFoundException is a runtime exception thrown when we try to fetch a book
    that is not in the catalog.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: BookNotFoundException 是在尝试获取目录中不存在的书籍时抛出的运行时异常。
- en: Listing 3.9 Exception thrown when a book cannot be found
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 当找不到书籍时抛出的异常
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That completes the business logic for the Catalog Service. It’s relatively simple,
    but it’s recommended not to be influenced by how data is persisted or exchanged
    with clients. The business logic should be independent of anything else, including
    the API. If you’re interested in this topic, I suggest exploring the concepts
    of *domain-driven design* and *hexagonal architecture*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了目录服务的业务逻辑。它相对简单，但建议不要受数据持久化或与客户端交换方式的影响。业务逻辑应该独立于其他任何事物，包括 API。如果您对这个主题感兴趣，我建议探索
    *领域驱动设计* 和 *六边形架构* 的概念。
- en: 3.3.2 Implementing a REST API with Spring MVC
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 使用 Spring MVC 实现REST API
- en: After implementing the business logic, we can expose the use cases through a
    REST API. Spring MVC provides @RestController classes to define methods that handle
    incoming HTTP requests for specific HTTP methods and resource endpoints.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现业务逻辑后，我们可以通过 REST API 公开用例。Spring MVC 提供了 @RestController 类来定义处理特定 HTTP 方法和服务端点的传入
    HTTP 请求的方法。
- en: As you saw in the previous section, the DispatcherServlet component will invoke
    the right controller for each request. Figure 3.6 shows the scenario where a client
    sends an HTTP GET request to view the details of a specific book.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，DispatcherServlet 组件将为每个请求调用正确的控制器。图 3.6 显示了客户端发送 HTTP GET 请求以查看特定书籍详情的场景。
- en: '![03-06](../Images/03-06.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![03-06](../Images/03-06.png)'
- en: Figure 3.6 The processing flow for an HTTP GET request arriving at the /books/<isbn>
    endpoint
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 HTTP GET 请求到达 /books/<isbn> 端点的处理流程
- en: We want to implement a method handler for each use case defined in the application
    requirements, since we want to make all of them available to clients. Create a
    package for the web layer (com.polarbookshop.catalogservice.web) and add a BookController
    class responsible for handling HTTP requests sent to the /books base endpoint.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为应用程序要求中定义的每个用例实现一个方法处理程序，因为我们希望将它们全部提供给客户端。为网络层（com.polarbookshop.catalogservice.web）创建一个包，并添加一个
    BookController 类，该类负责处理发送到 /books 基础端点的 HTTP 请求。
- en: Listing 3.10 Defining handlers for REST endpoints
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 定义 REST 端点的处理程序
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Stereotype annotation marking a class as a Spring component and a source of
    handlers for REST endpoints
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标记类为 Spring 组件和 REST 端点处理程序源的构造型注解
- en: ❷ Identifies the root path mapping URI for which the class provides handlers
    ("/books")
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 识别类提供的处理程序根路径映射 URI（"/books"）
- en: ❸ Maps HTTP GET requests to the specific handler method
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 HTTP GET 请求映射到特定的处理程序方法
- en: ❹ A URI template variable appended to the root path mapping URI ("/books/{isbn}")
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 添加到根路径映射 URI（"/books/{isbn}"）的 URI 模板变量
- en: ❺ @PathVariable binds a method parameter to a URI template variable ({isbn}).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ @PathVariable 将方法参数绑定到 URI 模板变量（{isbn}）。
- en: ❻ Maps HTTP POST requests to the specific handler method
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将 HTTP POST 请求映射到特定的处理程序方法
- en: ❼ Returns a 201 status if the book is created successfully
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果书籍创建成功，则返回 201 状态
- en: ❽ @RequestBody binds a method parameter to the body of a web request.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ @RequestBody 将方法参数绑定到网络请求的主体。
- en: ❾ Maps HTTP DELETE requests to the specific handler method
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将 HTTP DELETE 请求映射到特定的处理程序方法
- en: ❿ Returns a 204 status if the book is deleted successfully
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 如果书籍成功删除，则返回 204 状态
- en: ⓫ Maps HTTP PUT requests to the specific handler method
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 将 HTTP PUT 请求映射到特定的处理程序方法
- en: Go ahead and run the application (./gradlew bootRun). When verifying HTTP interactions
    with an application, you can either use a command-line tool like curl or software
    with a graphical user interface like Insomnia. I’m going to use a convenient command-line
    tool called HTTPie ([https://httpie.org](https://httpie.org)). You can find information
    about how to install it in section A.4 of appendix A.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行应用程序（./gradlew bootRun）。在验证应用程序的HTTP交互时，你可以使用命令行工具如curl或具有图形用户界面的软件如Insomnia。我将使用一个方便的命令行工具HTTPie
    ([https://httpie.org](https://httpie.org))。你可以在附录A的A.4节中找到有关如何安装它的信息。
- en: 'Open a Terminal window and perform an HTTP POST request to add a book to the
    catalog:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，执行一个HTTP POST请求以将一本书添加到目录中：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The result should be an HTTP response with the 201 code, meaning that the book
    has been created successfully. Let’s double-check by submitting an HTTP GET request
    to fetch the book with the ISBN code we used on creation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个带有201代码的HTTP响应，这意味着书籍已成功创建。让我们通过提交一个HTTP GET请求来获取我们创建时使用的ISBN代码的书来再次检查。
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you’re done trying the application, stop its execution with Ctrl-C.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成尝试应用程序后，使用Ctrl-C停止其执行。
- en: About content negotiation
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内容协商
- en: All handler methods in BookController work on Book Java objects. And yet, when
    you perform a request, you get back a JSON object. How is that possible?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: BookController中的所有处理器方法都针对Book Java对象工作。然而，当你执行一个请求时，你却得到了一个JSON对象。这是怎么可能的？
- en: Spring MVC relies on an HttpMessageConverter bean to convert the returned object
    into a specific representation the client supports. The decision about the content
    type is driven by a process called *content negotiation*, during which the client
    and the server agree on a representation that both can understand. The client
    can inform the server about which content types it supports through the Accept
    header in the HTTP request.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC依赖于一个HttpMessageConverter bean将返回的对象转换为客户端支持的具体表示形式。关于内容类型的决定是由一个称为*内容协商*的过程驱动的，在这个过程中，客户端和服务器就双方都能理解的一种表示形式达成一致。客户端可以通过HTTP请求中的Accept头通知服务器它支持哪些内容类型。
- en: By default, Spring Boot configures a set of HttpMessageConverter beans to return
    objects represented as JSON, and the HTTPie tool is configured to accept any content
    type by default. The result is that both client and server support the JSON content
    type, so they agree on using that to communicate
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot配置了一组HttpMessageConverter bean，以JSON表示形式返回对象，HTTPie工具默认配置为接受任何内容类型。结果是客户端和服务器都支持JSON内容类型，因此它们同意使用该类型进行通信。
- en: The application we have implemented so far is still not complete. For example,
    nothing prevents you from posting a new book with an ISBN in the wrong format
    or without specifying a title. We need to validate the input.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止实现的应用程序仍然不完整。例如，没有任何东西可以阻止你以错误的格式或未指定标题的方式发布一本新书。我们需要验证输入。
- en: 3.3.3 Data validation and error handling
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 数据验证和错误处理
- en: As a general rule, before saving any data, you should always validate the content,
    both for data consistency and security reasons. A book with no title will be of
    no use in our application, and it would probably make it fail.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，在保存任何数据之前，你应该始终验证内容，无论是为了数据一致性还是出于安全原因。在我们的应用程序中，没有标题的书将毫无用处，它可能会使应用程序失败。
- en: 'For the Book class, we might think of using these validation constraints:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Book类，我们可能会考虑使用以下验证约束：
- en: The ISBN must be defined and in the correct format (ISBN-10 or ISBN-13).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISBN必须定义，并且格式正确（ISBN-10或ISBN-13）。
- en: The title must be defined.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题必须定义。
- en: The author must be defined.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者必须定义。
- en: The price must be defined and be greater than zero.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格必须定义，并且必须大于零。
- en: Java Bean Validation is a popular specification for expressing constraints and
    validation rules on Java objects via annotations. Spring Boot provides a convenient
    starter dependency containing the Java Bean Validation API and its implementation.
    Add the new dependency in the build.gradle file for your Catalog Service project.
    Remember to refresh or reimport the Gradle dependencies after the new addition.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Java Bean Validation是一个流行的规范，用于通过注解在Java对象上表达约束和验证规则。Spring Boot提供了一个方便的启动依赖项，包含Java
    Bean Validation API及其实现。在您的目录服务项目构建.gradle文件中添加新的依赖项。记住，在添加新项后，刷新或重新导入Gradle依赖项。
- en: Listing 3.11 Adding dependency for Spring Boot Validation
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 为Spring Boot Validation添加依赖项
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now use the Java Bean Validation API to define validation constraints
    as annotations directly on the Book record fields.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用Java Bean Validation API直接在Book记录字段上定义验证约束作为注释。
- en: Listing 3.12 Validation constraints defined for each field
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 为每个字段定义的验证约束
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The annotated element must match the specified regular expression (standard
    ISBN format).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注释的元素必须匹配指定的正则表达式（标准ISBN格式）。
- en: ❷ The annotated element must not be null and must contain at least one non-whitespace
    character.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注释的元素不能为空，并且必须包含至少一个非空白字符。
- en: ❸ The annotated element must not be null and must be greater than zero.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注释的元素不能为空，并且必须大于零。
- en: Note Books are uniquely identified by their ISBN (International Standard Book
    Number). ISBNs used to be composed of 10 digits, but they now consist of 13\.
    For simplicity, we’ll limit ourselves to checking for their length and whether
    all the elements are digits by using a regular expression.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：书籍通过其ISBN（国际标准书号）唯一标识。ISBN过去由10位数字组成，但现在由13位组成。为了简单起见，我们将限制自己通过使用正则表达式检查它们的长度以及所有元素是否都是数字。
- en: The annotations from the Java Bean Validation API define the constraints, but
    they are not enforced yet. We can instruct Spring to validate the Book object
    in the BookController class by using the @Valid annotation whenever a @RequestBody
    is specified as a method argument. In this way, whenever we create or update a
    book, Spring will run the validation and throw an error if any constraint is violated.
    We can update the post() and put() methods in the BookController class as follows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Java Bean Validation API中的注释定义了约束，但它们尚未强制执行。我们可以通过在BookController类中使用@Valid注释来指示Spring在指定@RequestBody作为方法参数时验证Book对象。这样，每次我们创建或更新一本书时，Spring都会运行验证，如果任何约束被违反，则会抛出错误。我们可以按如下方式更新BookController类中的post()和put()方法。
- en: Listing 3.13 Validating books passed in a request body
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 验证请求体中传入的书籍
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Spring lets you handle error messages in different ways. When building an API,
    it’s good to consider which types of errors it can throw, since they are just
    as important as the domain data. When it’s a REST API, you want to ensure that
    the HTTP response uses a status code that best fits the purpose and includes a
    meaningful message to help the client identify the problem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Spring允许您以不同的方式处理错误消息。当构建API时，考虑它可以抛出哪些类型的错误是个好主意，因为它们与领域数据一样重要。当它是REST API时，您想确保HTTP响应使用最适合目的的状态码，并包含一个有意义的消息来帮助客户端识别问题。
- en: When the validation constraints we have just defined are not met, a MethodArgumentNotValidException
    is thrown. What if we try to fetch a book that doesn’t exist? The business logic
    we previously implemented throws dedicated exceptions (BookAlreadyExistsException
    and BookNotFoundException). All those exceptions should be handled in the REST
    API context to return the error codes defined in the original specification.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义的验证约束未满足时，会抛出MethodArgumentNotValidException。如果我们尝试获取一个不存在的书籍会发生什么？我们之前实现的业务逻辑会抛出专门的异常（BookAlreadyExistsException和BookNotFoundException）。所有这些异常都应该在REST
    API上下文中处理，以返回原始规范中定义的错误代码。
- en: To handle errors for a REST API, we can use the standard Java exceptions and
    rely on a @RestControllerAdvice class to define what to do when a given exception
    is thrown. It’s a centralized approach that allows us to decouple the exception
    handling from the code throwing the exception. In the com.polarbookshop.catalogservice
    .web package, create a BookControllerAdvice class as follows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理REST API的错误，我们可以使用标准的Java异常，并依赖于一个@RestControllerAdvice类来定义当抛出给定异常时要执行的操作。这是一个集中式方法，允许我们将异常处理与抛出异常的代码解耦。在com.polarbookshop.catalogservice.web包中，创建一个BookControllerAdvice类，如下所示。
- en: Listing 3.14 The advice class defining how to handle exceptions
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 定义如何处理异常的咨询类
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Marks the class as a centralized exception handler
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将类标记为集中式异常处理程序。
- en: ❷ Defines the exception for which the handler must be executed
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义了处理程序必须执行的异常。
- en: ❸ The message that will be included in the HTTP response body
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将包含在HTTP响应体中的消息。
- en: ❹ Defines the status code for the HTTP response created when the exception is
    thrown
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义当抛出异常时创建的HTTP响应的状态码。
- en: ❺ Handles the exception thrown when the Book validation fails
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 处理Book验证失败时抛出的异常。
- en: ❻ Collects meaningful error messages about which Book fields were invalid instead
    of returning an empty message
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 收集有关哪些Book字段无效的有意义的错误消息，而不是返回空消息。
- en: The mapping provided in the @RestControllerAdvice class makes it possible to
    obtain an HTTP response with status 422 (unprocessable entity) when we try to
    create a book that already exists in the catalog, a response with status 404 (not
    found) when we try to read a book that doesn’t exist, and a response with status
    400 (bad request) when one or more fields in a Book object are invalid. Each response
    will contain a meaningful message that we defined as part of the validation constraint
    or custom exception.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在@RestControllerAdvice类中提供的映射使得在尝试创建目录中已存在的书籍时，能够获得状态为422（不可处理的实体）的HTTP响应，在尝试读取不存在的书籍时，获得状态为404（未找到）的响应，以及在Book对象的一个或多个字段无效时，获得状态为400（请求错误）的响应。每个响应都将包含一个有意义的消息，这是我们作为验证约束或自定义异常的一部分定义的。
- en: 'Build and rerun the application (./gradlew bootRun): if you now try to create
    a book without a title and with a wrongly formatted ISBN, the request will fail.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并重新运行应用程序（./gradlew bootRun）：如果你现在尝试创建一个没有标题且ISBN格式错误的书籍，请求将失败。
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result will be an error message with a “400 Bad Request” status, meaning
    that the server couldn’t process the HTTP request because it was incorrect. The
    response body contains a detailed message about which part of the request was
    incorrect and how to fix it, just as we defined in listing 3.12.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个带有“400 Bad Request”状态的错误消息，这意味着服务器无法处理HTTP请求，因为它是不正确的。响应体包含有关请求哪个部分不正确以及如何修复它的详细消息，正如我们在列表3.12中定义的那样。
- en: '[PRE20]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you’re done trying the application, stop its execution with Ctrl-C.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成尝试应用程序后，使用Ctrl-C停止其执行。
- en: That concludes our implementation of the REST API that exposes the Catalog Service’s
    book-management functionality. Next I’ll discuss a few aspects of how we can evolve
    APIs to adapt to new requirements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们实现REST API的工作，该API公开了目录服务的书籍管理功能。接下来，我将讨论我们如何演进API以适应新需求的几个方面。
- en: 3.3.4 Evolving APIs for future requirements
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 为未来需求演进API
- en: In a distributed system, we need a plan to evolve APIs so we don’t break the
    functionality of other applications. This is a challenging task because we want
    independent applications, but they probably exist to provide services to other
    applications, so we are somewhat limited in the number of changes we can make
    independently of the clients.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，我们需要一个计划来演进API，以避免破坏其他应用的功能。这是一个具有挑战性的任务，因为我们希望应用程序独立，但它们可能存在是为了向其他应用提供服务，因此我们在独立于客户端进行更改的数量上有所限制。
- en: The best approach is to make backward-compatible changes to the API. For example,
    we can add an optional field to the Book object without affecting the clients
    of the Catalog Service application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳做法是对API进行向后兼容的更改。例如，我们可以在不影响目录服务应用客户端的情况下向Book对象添加一个可选字段。
- en: Sometimes, breaking changes are necessary. In this situation, you can use *API
    versioning*. For example, should you decide to make a breaking change to the REST
    API for the Catalog Service application, you might introduce a versioning system
    for the endpoints. The version might be part of the endpoint itself, like /v2/books.
    Or it might be specified as an HTTP header. This system helps prevent existing
    clients from breaking, but they will have to update their interface to match the
    new API version sooner or later, meaning that coordination is needed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，进行破坏性更改是必要的。在这种情况下，你可以使用 *API版本控制*。例如，如果你决定对目录服务应用的REST API进行破坏性更改，你可能需要为端点引入一个版本控制系统。版本号可能是端点本身的一部分，例如
    /v2/books。或者它可能被指定为HTTP头。这个系统有助于防止现有客户端崩溃，但它们迟早需要更新其接口以匹配新的API版本，这意味着需要协调。
- en: A different approach focuses on making the REST API client as resilient to API
    changes as possible. The solution is to use the *hypermedia* aspect of the REST
    architecture, as described by Dr. Roy Fielding in his doctorate dissertation,
    “Architectural Styles and the Design of Network-based Software Architectures”
    ([www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)).
    REST APIs can return the object requested along with information about *where*
    to go next and *links* to perform related operations. The beauty of this feature
    is that the links are only shown when it makes sense to follow them, providing
    information about *when* to go.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法侧重于使REST API客户端尽可能对API更改具有弹性。解决方案是使用REST架构的*超媒体*方面，正如Roy Fielding博士在其博士论文“架构风格和网络化软件架构的设计”（[www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)）中所描述的。REST
    API可以返回请求的对象，以及关于*如何*继续下一步的信息和执行相关操作的*链接*。这个特性的美妙之处在于，只有在有道理跟随时才会显示链接，从而提供关于*何时*继续的信息。
- en: This hypermedia aspect is also called *HATEOAS* (Hypermedia as the Engine of
    Application State), and it represents the highest level of API maturity according
    to Richardson’s Maturity Model. Spring provides the Spring HATEOAS project to
    add hypermedia support to a REST API. I will not use it in this book, but I encourage
    you to check the project’s online documentation at [https://spring.io/projects/spring-hateoas](https://spring.io/projects/spring-hateoas).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个超媒体方面也被称为*HATEOAS*（超媒体作为应用程序状态引擎），根据Richardson成熟度模型，它代表了API成熟度的最高水平。Spring提供了Spring
    HATEOAS项目，以向REST API添加超媒体支持。我不会在本书中使用它，但我鼓励您查看该项目的在线文档[https://spring.io/projects/spring-hateoas](https://spring.io/projects/spring-hateoas)。
- en: These considerations conclude our discussion of building a RESTful application
    with Spring. In the next section you’ll see how to write automated tests to verify
    the behavior of your application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑因素结束了我们对使用Spring构建RESTful应用程序的讨论。在下一节中，您将看到如何编写自动化测试来验证应用程序的行为。
- en: 3.4 Testing a RESTful application with Spring
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用Spring测试RESTful应用程序
- en: Automated tests are paramount to producing high-quality software. One of the
    goals for adopting a cloud native approach is speed. It’s impossible to move quickly
    if the code is not adequately tested in an automated fashion, let alone to implement
    a continuous delivery process.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试对于生产高质量的软件至关重要。采用云原生方法的一个目标就是速度。如果代码没有经过充分的自动化测试，那么快速移动是不可能的，更不用说实施持续交付流程了。
- en: As a developer, you’ll usually implement a feature, deliver it, and then move
    on to a new one, possibly refactoring the existing code. Refactoring code is risky,
    since you might break some existing functionality. Automated tests reduce the
    risk and encourage refactoring, because you know that a test will fail, should
    you break something. You’ll probably also want to reduce the feedback cycle so
    you’ll know if you made any mistakes as soon as possible. That will lead you to
    design tests in a way that maximizes their usefulness and efficiency. You shouldn’t
    aim to reach maximum test coverage but rather to write meaningful tests. For example,
    writing tests for standard getters and setters doesn’t make sense.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，您通常会实现一个功能，交付它，然后转向新的一个，可能还会重构现有代码。重构代码是有风险的，因为您可能会破坏一些现有功能。自动化测试可以降低风险并鼓励重构，因为您知道如果破坏了某些东西，测试将会失败。您可能还希望减少反馈周期，以便您能尽快知道是否犯了错误。这将导致您以最大化测试有用性和效率的方式设计测试。您不应该旨在达到最大的测试覆盖率，而应该编写有意义的测试。例如，为标准的getter和setter编写测试是没有意义的。
- en: An essential practice of continuous delivery is *test-driven development* (TDD),
    which helps achieve the goal of delivering software quickly, reliably, and safely.
    The idea is to drive software development by writing tests before implementing
    the production code. I recommend adopting TDD in real-world scenarios. However,
    it’s not very suitable when teaching new technologies and frameworks in a book,
    so I won’t follow its principles here.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付的一个基本实践是*测试驱动开发*（TDD），它有助于实现快速、可靠和安全地交付软件的目标。其理念是在实现生产代码之前先编写测试来驱动软件开发。我建议在实际场景中采用TDD。然而，当在书中教授新技术和框架时，它并不非常适用，因此在这里我不会遵循其原则。
- en: Automated tests assert that new features work as intended and that you haven’t
    broken any existing functionality. This means that automated tests work as *regression
    tests*. You should write tests to protect your colleagues and yourself from making
    mistakes. What to test and how in-depth to test is driven by the risk associated
    with a specific piece of code. Writing tests is also a learning experience and
    will improve your skills, especially if you’re beginning your software development
    journey.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试断言新功能按预期工作，并且你没有破坏任何现有功能。这意味着自动化测试作为*回归测试*工作。你应该编写测试来保护你和你的同事免犯错误。要测试什么以及测试的深度由特定代码片段的风险驱动。编写测试也是一种学习经历，并将提高你的技能，尤其是如果你刚开始你的软件开发之旅。
- en: One way of classifying software tests is defined by the Agile Testing Quadrants
    model originally introduced by Brian Marick, and later described and expanded
    on by Lisa Crispin and Janet Gregory in their books *Agile Testing* (Addison-Wesley
    Professional, 2008), *More Agile Testing* (Addison-Wesley Professional, 2014),
    and *Agile Testing Condensed* (Library and Archives Canada, 2019). Their model
    was also embraced by Jez Humble and Dave Farley in *Continuous Delivery* (Addison-Wesley
    Professional, 2010). The quadrants classify software tests based on whether they
    are technology or business-facing and whether they support development teams or
    are used to critique the product. Figure 3.7 shows some examples of testing types
    I’ll mention throughout the book, based on the model presented in *Agile Testing
    Condensed*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的一种分类方法是由 Brian Marick 首先提出的 Agile 测试象限模型，后来在 Lisa Crispin 和 Janet Gregory
    的书籍 *Agile Testing*（Addison-Wesley Professional，2008）、*More Agile Testing*（Addison-Wesley
    Professional，2014）和 *Agile Testing Condensed*（Library and Archives Canada，2019）中描述和扩展。他们的模型也被
    Jez Humble 和 Dave Farley 在 *Continuous Delivery*（Addison-Wesley Professional，2010）中采用。象限根据它们是否面向技术或业务以及它们是否支持开发团队或用于评估产品来分类软件测试。图
    3.7 显示了我将在本书中提到的测试类型的一些示例，这些示例基于 *Agile Testing Condensed* 中提出的模型。
- en: '![03-07](../Images/03-07.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![03-07](../Images/03-07.png)'
- en: Figure 3.7 The Agile Testing Quadrants model is helpful in planning a software
    testing strategy.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 Agile 测试象限模型有助于规划软件测试策略。
- en: Following continuous delivery practices, we should aim at achieving fully automated
    tests in three out of four quadrants, as shown in figure 3.7\. Throughout the
    book, we’ll mainly focus on the bottom-left quadrant. In this section, we’ll work
    with unit tests and integration tests (sometimes called *component tests*). We
    write *unit tests* to verify the behavior of single application components in
    isolation, whereas *integration tests* assert the overall functioning of different
    parts of an application interacting with each other.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循持续交付实践，我们应该力争在四个象限中的三个实现完全自动化测试，如图 3.7 所示。在本书中，我们将主要关注左下象限。在本节中，我们将使用单元测试和集成测试（有时称为*组件测试*）。我们编写*单元测试*来验证单个应用程序组件在隔离状态下的行为，而*集成测试*则断言应用程序不同部分相互交互的整体功能。
- en: In a Gradle or Maven project, test classes are usually placed in a src/test/java
    folder. In Spring, unit tests aren’t required to load the Spring application context,
    and they don’t rely on any Spring library. On the other hand, integration tests
    need a Spring application context to run. This section will show you how to test
    a RESTful application like Catalog Service with unit and integration tests.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 或 Maven 项目中，测试类通常放在 src/test/java 文件夹中。在 Spring 中，单元测试不需要加载 Spring
    应用程序上下文，也不依赖于任何 Spring 库。另一方面，集成测试需要 Spring 应用程序上下文才能运行。本节将向您展示如何使用单元测试和集成测试测试
    RESTful 应用程序，如目录服务。
- en: 3.4.1 Unit tests with JUnit 5
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 使用 JUnit 5 的单元测试
- en: Unit tests are not aware of Spring and don’t rely on any Spring library. They
    are intended to test the behavior of single components as isolated units. Any
    dependency at the edge of the unit is mocked to keep the test shielded from external
    components.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不了解 Spring，也不依赖于任何 Spring 库。它们旨在测试单个组件作为独立单元的行为。单元边缘的任何依赖都被模拟，以保持测试不受外部组件的影响。
- en: Writing unit tests for Spring applications is no different from writing them
    for any other Java application, so I won’t go into detail about them. By default,
    any Spring project created from Spring Initializr contains the spring-boot-starter-test
    dependency, which imports testing libraries like JUnit 5, Mockito, and AssertJ
    into the project. So we’re all set for writing unit tests.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Spring 应用程序编写单元测试与为任何其他 Java 应用程序编写单元测试没有区别，所以我就不详细介绍了。默认情况下，从 Spring Initializr
    创建的任何 Spring 项目都包含 spring-boot-starter-test 依赖项，该依赖项将测试库（如 JUnit 5、Mockito 和 AssertJ）导入到项目中。因此，我们已经准备好编写单元测试了。
- en: The business logic of an application is usually a sensible area to cover with
    unit tests. In the Catalog Service application, a good candidate for unit testing
    might be the validation logic for the Book class. The validation constraints are
    defined using the Java Validation API annotations, and we are interested in testing
    that they are applied correctly to the Book class. We can check that in a new
    BookValidationTests class, as shown in the following listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的业务逻辑通常是单元测试的一个合理区域。在 Catalog Service 应用程序中，单元测试的一个良好候选可能是 Book 类的验证逻辑。验证约束是通过
    Java Validation API 注解定义的，我们感兴趣的是测试它们是否正确应用于 Book 类。我们可以在新的 BookValidationTests
    类中检查这一点，如下所示。
- en: Listing 3.15 Unit tests to verify book validation constraints
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 验证书籍约束的单元测试
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Identifies a block of code executed before all tests in the class
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别在类中所有测试之前执行的代码块
- en: ❷ Identifies a test case
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 识别一个测试用例
- en: ❸ Creates a book with a valid ISBN
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个具有有效 ISBN 的书籍
- en: ❹ Asserts that there is no validation error
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言没有验证错误
- en: ❺ Creates a book with a non-valid ISBN code
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建一个具有非有效 ISBN 代码的书籍
- en: ❻ Asserts that the violated validation constraint is about the incorrect ISBN
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 断言违反的验证约束是关于错误的 ISBN
- en: 'Then we can run the tests with the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令运行测试：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 3.4.2 Integration tests with @SpringBootTest
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 使用 @SpringBootTest 的集成测试
- en: Integration tests cover the interactions among software components, and in Spring
    they require an application context to be defined. The spring-boot-starter-test
    dependency also imports the test utilities from Spring Framework and Spring Boot.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试覆盖软件组件之间的交互，在 Spring 中，它们需要一个定义了的应用程序上下文。spring-boot-starter-test 依赖项还导入了来自
    Spring 框架和 Spring Boot 的测试实用工具。
- en: Spring Boot offers a powerful @SpringBootTest annotation that you can use on
    a test class to bootstrap an application context automatically when running tests.
    The configuration used to create the context can be customized if needed. Otherwise,
    the class annotated with @SpringBootApplication will become the configuration
    source for component scanning and properties, including the usual auto-configuration
    provided by Spring Boot.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 提供了一个强大的 @SpringBootTest 注解，你可以在测试类上使用它，在运行测试时自动引导应用程序上下文。如果需要，可以自定义用于创建上下文的配置。否则，带有
    @SpringBootApplication 注解的类将成为组件扫描和属性的配置源，包括 Spring Boot 提供的常规自动配置。
- en: When working with web applications, you can run tests on a mock web environment
    or a running server. You can configure that by defining a value for the webEnvironment
    attribute that the @SpringBootTest annotation provides, as shown in table 3.2.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Web 应用程序一起工作时，你可以在模拟 Web 环境或运行中的服务器上运行测试。你可以通过定义 @SpringBootTest 注解提供的 webEnvironment
    属性的值来配置它，如表 3.2 所示。
- en: When using a mock web environment, you can rely on the MockMvc object to send
    HTTP requests to the application and check their results. For environments with
    a running server, the TestRestTemplate utility lets you perform REST calls to
    an application running on an actual server. By inspecting the HTTP responses,
    you can verify that the API works as intended.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用模拟 Web 环境时，你可以依赖 MockMvc 对象向应用程序发送 HTTP 请求并检查其结果。对于具有运行服务器的环境，TestRestTemplate
    实用工具允许你对运行在实际服务器上的应用程序执行 REST 调用。通过检查 HTTP 响应，你可以验证 API 是否按预期工作。
- en: Table 3.2 A Spring Boot integration test can be initialized with a mock web
    environment or a running server.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 一个 Spring Boot 集成测试可以用模拟 Web 环境或运行中的服务器初始化。
- en: '| Web environment option | Description |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| Web environment option | 描述 |'
- en: '| MOCK | Creates a web application context with a mock Servlet container. This
    is the default option. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| MOCK | 使用模拟 Servlet 容器创建 Web 应用程序上下文。这是默认选项。|'
- en: '| RANDOM_PORT | Creates a web application context with a Servlet container
    listening on a random port. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| RANDOM_PORT | 使用 Servlet 容器监听随机端口的 Web 应用程序上下文创建。|'
- en: '| DEFINED_PORT | Creates a web application context with a Servlet container
    listening on the port defined through the server.port property. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 定义端口 | 使用通过 server.port 属性定义的端口创建一个带有 Servlet 容器的 Web 应用程序上下文。 |'
- en: '| NONE | Creates an application context without a Servlet container. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 创建一个不带 Servlet 容器的应用程序上下文。 |'
- en: Recent versions of Spring Framework and Spring Boot have extended the features
    for testing web applications. You can now use the WebTestClient class to test
    REST APIs both on mock environments and running servers. Compared to MockMvc and
    TestRestTemplate, WebTestClient provides a modern and fluent API and additional
    features. Furthermore, you can use it for both imperative (e.g., Catalog Service)
    and reactive applications, optimizing learning and productivity.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 和 Spring Boot 的最新版本扩展了测试 Web 应用程序的功能。现在，您可以使用 WebTestClient
    类在模拟环境和运行服务器上测试 REST API。与 MockMvc 和 TestRestTemplate 相比，WebTestClient 提供了一个现代且流畅的
    API 以及额外的功能。此外，您可以使用它来测试命令式（例如，目录服务）和响应式应用程序，优化学习和生产力。
- en: Since WebTestClient is part of the Spring WebFlux project, you’ll need to add
    a new dependency in your Catalog Service project (build.gradle). Remember to refresh
    or reimport the Gradle dependencies after the new addition.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WebTestClient 是 Spring WebFlux 项目的一部分，您需要在目录服务项目中添加一个新的依赖项（build.gradle）。请记住，在添加新依赖项后，刷新或重新导入
    Gradle 依赖项。
- en: Listing 3.16 Adding test dependency for Spring Reactive Web
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 为 Spring Reactive Web 添加测试依赖
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Chapter 8 will cover Spring WebFlux and reactive applications. For now we’re
    only interested in using the WebTestClient object to test the API exposed by Catalog
    Service.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章将涵盖 Spring WebFlux 和响应式应用程序。目前，我们只对使用 WebTestClient 对象测试目录服务公开的 API 感兴趣。
- en: In the previous chapter you saw that Spring Initializr generated an empty CatalogServiceApplicationTests
    class. Let’s populate it with integration tests. For this setup, we’ll use the
    @SpringBootTest annotation configured to provide a full Spring application context,
    including a running server that exposes its services through a random port (because
    it doesn’t matter which one).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您看到 Spring Initializr 生成了一个空的 CatalogServiceApplicationTests 类。让我们用集成测试来填充它。为此设置，我们将使用配置为提供完整
    Spring 应用程序上下文的 @SpringBootTest 注解，包括一个运行的服务器，该服务器通过随机端口公开其服务（因为哪个端口都无关紧要）。
- en: Listing 3.17 Integration tests for Catalog Service
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 目录服务的集成测试
- en: '[PRE24]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Loads a full Spring web application context and a Servlet container listening
    on a random port
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载完整的 Spring Web 应用程序上下文和一个监听随机端口的 Servlet 容器
- en: ❷ Utility to perform REST calls for testing
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于执行测试 REST 调用的实用工具
- en: ❸ Sends an HTTP POST request
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发送 HTTP POST 请求
- en: ❹ Sends the request to the "/books" endpoint
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将请求发送到 "/books" 端点
- en: ❺ Adds the book in the request body
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在请求体中添加书籍
- en: ❻ Sends the request
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 发送请求
- en: ❼ Verifies that the HTTP response has status “201 Created”
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 验证 HTTP 响应状态为“201 已创建”
- en: ❽ Verifies that the HTTP response has a non-null body
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 验证 HTTP 响应体非空
- en: ❾ Verifies that the created object is as expected
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 验证创建的对象符合预期
- en: Note You might be wondering why I didn’t use constructor-based dependency injection
    in listing 3.17, considering that I previously stated that’s the recommended option.
    Using field-based dependency injection in production code has been deprecated
    and is strongly discouraged, but it’s still acceptable to autowire dependencies
    in a test class. In every other scenario, I recommend sticking with constructor-based
    dependency injection for the reasons I explained earlier. For more information,
    you can refer to the official Spring Framework documentation ([https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能想知道为什么我没有在列表 3.17 中使用基于构造函数的依赖注入，尽管我之前提到这是推荐选项。在生产代码中使用基于字段的依赖注入已被弃用，并且强烈不建议使用，但在测试类中自动装配依赖项仍然是可接受的。在其他所有情况下，我建议坚持使用基于构造函数的依赖注入，原因我在前面已经解释过了。有关更多信息，您可以参考官方
    Spring Framework 文档（[https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)）。
- en: 'Then you can run the tests with the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令运行测试：
- en: '[PRE25]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Depending on the application’s size, loading a full application context with
    auto-configuration for all integration tests might be too much. Spring Boot has
    a convenient feature (enabled by default) to cache the context, so that it’s re-used
    in all test classes that are annotated with @SpringBootTest and the same configuration.
    Sometimes that’s not enough.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的大小，加载包含所有集成测试自动配置的全应用程序上下文可能太多。Spring Boot 有一个方便的功能（默认启用），可以缓存上下文，以便在所有带有@SpringBootTest注解且配置相同的测试类中重用。有时这还不够。
- en: Test execution time matters, so Spring Boot is fully equipped to run integration
    tests by loading only the parts of the application that are needed. Let’s see
    how that works.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行时间很重要，因此 Spring Boot 完全准备好通过仅加载应用程序所需的部分来运行集成测试。让我们看看它是如何工作的。
- en: 3.4.3 Testing REST controllers with @WebMvcTest
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 使用 @WebMvcTest 测试 REST 控制器
- en: Some integration tests might not need a fully initialized application context.
    For example, there’s no need to load the web components when you’re testing the
    data persistence layer. If you’re testing the web components, you don’t need to
    load the data persistence layer.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一些集成测试可能不需要完全初始化的应用程序上下文。例如，当你测试数据持久层时，不需要加载网络组件。如果你正在测试网络组件，你不需要加载数据持久层。
- en: 'Spring Boot allows you to use contexts initialized only with a subgroup of
    components (beans), targeting a specific application slice. *Slice tests* don’t
    use the @SpringBootTest annotation, but one of a set of annotations dedicated
    to particular parts of an application: Web MVC, Web Flux, REST client, JDBC, JPA,
    Mongo, Redis, JSON, and others. Each of those annotations initializes an application
    context, filtering out all the beans outside that slice.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 允许你使用仅初始化了一组组件（bean）的上下文，针对特定的应用程序切片。*切片测试*不使用@SpringBootTest注解，而是使用一系列针对应用程序特定部分的注解：Web
    MVC、Web Flux、REST 客户端、JDBC、JPA、Mongo、Redis、JSON 等。每个这样的注解都会初始化一个应用程序上下文，过滤掉该切片之外的所有
    bean。
- en: We can test that Spring MVC controllers work as intended by using the @WebMvcTest
    annotation, which loads a Spring application context in a mock web environment
    (no running server), configures the Spring MVC infrastructure, and includes only
    the beans used by the MVC layer, like @RestController and @RestControllerAdvice.
    It’s also a good idea to limit the context to the beans used by the specific controller
    under test. We can do so by providing the controller class as an argument to the
    @WebMvcTest annotation in a new BookControllerMvcTests class.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用@WebMvcTest注解来测试 Spring MVC 控制器是否按预期工作，该注解在模拟网络环境中加载 Spring 应用程序上下文（没有运行的服务器），配置
    Spring MVC 基础设施，并仅包含 MVC 层使用的 bean，如@RestController和@RestControllerAdvice。限制上下文到特定控制器使用的
    bean 也是一个好主意。我们可以在新的BookControllerMvcTests类中通过将控制器类作为参数传递给@WebMvcTest注解来实现这一点。
- en: Listing 3.18 Integration tests for the web MVC slice
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 Web MVC 切片集成测试
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Identifies a test class that focuses on Spring MVC components, explicitly
    targeting BookController
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别一个专注于 Spring MVC 组件的测试类，明确针对 BookController
- en: ❷ Utility class to test the web layer in a mock environment
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于在模拟环境中测试网络层的实用工具类
- en: ❸ Adds a mock of BookService to the Spring application context
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 BookService 的模拟添加到 Spring 应用程序上下文
- en: ❹ Defines the expected behavior for the BookService mock bean
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义 BookService 模拟 bean 的预期行为
- en: ❺ MockMvc is used to perform an HTTP GET request and verify the result.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 MockMvc 执行 HTTP GET 请求并验证结果。
- en: ❻ Expects the response to have a “404 Not Found” status
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 预期响应状态为“404 未找到”
- en: Warning If you use IntelliJ IDEA, you might get a warning that MockMvc cannot
    be autowired. Don’t worry. It’s a false positive. You can get rid of the warning
    by annotating the field with @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection").
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果你使用 IntelliJ IDEA，可能会收到 MockMvc 无法自动装配的警告。不要担心，这是一个假阳性。你可以通过在字段上注解@SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection")来消除警告。
- en: 'Then you can run the tests with the following command:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下命令运行测试：
- en: '[PRE27]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: MockMvc is a utility class that lets you test web endpoints without loading
    a server like Tomcat. Such a test is naturally lighter than the one we wrote in
    the previous section, where an embedded server was needed to run the test.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: MockMvc 是一个实用工具类，允许你在不加载服务器（如 Tomcat）的情况下测试网络端点。这种测试比我们在上一节中编写的需要嵌入服务器的测试要轻量得多。
- en: Slice tests run against an application context containing only the parts of
    the configuration requested by that application slice. In the case of collaborating
    beans outside the slice, such as the BookService class, we use mocks.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 切片测试针对只包含该应用程序切片请求的配置部分的上下文运行。在切片外部的协作 Bean（如 BookService 类）的情况下，我们使用模拟。
- en: Mocks created with the @MockBean annotation are different from standard mocks
    (for example, those created with Mockito) since the class is not only mocked,
    but the mock is also included in the application context. Whenever the context
    is asked to autowire that bean, it automatically injects the mock rather than
    the actual implementation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @MockBean 注解创建的模拟与标准模拟（例如，使用 Mockito 创建的模拟）不同，因为类不仅被模拟，模拟也被包含在应用程序上下文中。每当上下文被要求自动装配该
    Bean 时，它会自动注入模拟而不是实际实现。
- en: 3.4.4 Testing the JSON serialization with @JsonTest
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 使用 @JsonTest 测试 JSON 序列化
- en: The Book objects returned by the methods in BookController are parsed into JSON
    objects. By default, Spring Boot automatically configures the Jackson library
    to parse Java objects into JSON (*serialization*) and vice versa (*deserialization*).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: BookController 方法返回的 Book 对象被解析为 JSON 对象。默认情况下，Spring Boot 自动配置 Jackson 库将 Java
    对象解析为 JSON（*序列化*）以及相反（*反序列化*）。
- en: Using the @JsonTest annotation, you can test JSON serialization and deserialization
    for your domain objects. @JsonTest loads a Spring application context and auto-configures
    the JSON mappers for the specific library in use (by default, it’s Jackson). Furthermore,
    it configures the JacksonTester utility, which you can use to check that the JSON
    mapping works as expected, relying on the JsonPath and JSONAssert libraries.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @JsonTest 注解，你可以测试你的领域对象的 JSON 序列化和反序列化。@JsonTest 加载一个 Spring 应用程序上下文，并自动配置特定库（默认为
    Jackson）的 JSON 映射器。此外，它配置了 JacksonTester 实用工具，你可以使用它来检查 JSON 映射是否按预期工作，依赖于 JsonPath
    和 JSONAssert 库。
- en: 'Note JsonPath provides expressions you can use to navigate a JSON object and
    extract data from it. For example, if I wanted to get the isbn field from the
    Book object’s JSON representation, I could use the following JsonPath expression:
    @.isbn. For more information on the JsonPath library, you can refer to the project
    documentation: [https://github.com/json-path/JsonPath](https://github.com/json-path/JsonPath).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 JsonPath 提供了你可以用来导航 JSON 对象并从中提取数据的表达式。例如，如果我想从 Book 对象的 JSON 表示中获取 isbn
    字段，我可以使用以下 JsonPath 表达式：@.isbn。有关 JsonPath 库的更多信息，你可以参考项目文档：[https://github.com/json-path/JsonPath](https://github.com/json-path/JsonPath)。
- en: The following listing shows an example of both serialization and deserialization
    tests implemented in a new BookJsonTests class.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了在新的 BookJsonTests 类中实现的序列化和反序列化测试的示例。
- en: Listing 3.19 Integration tests for the JSON slice
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 JSON 切片集成测试
- en: '[PRE28]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Identifies a test class that focuses on JSON serialization
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别一个专注于 JSON 序列化的测试类
- en: ❷ Utility class to assert JSON serialization and deserialization
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于断言 JSON 序列化和反序列化的实用类
- en: ❸ Verifying the parsing from Java to JSON, using the JsonPath format to navigate
    the JSON object
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 JsonPath 格式验证从 Java 到 JSON 的解析
- en: ❹ Defines a JSON object using the Java text block feature
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 Java 文本块功能定义一个 JSON 对象
- en: ❺ Verifies the parsing from JSON to Java
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 验证从 JSON 到 Java 的解析
- en: Warning If you use IntelliJ IDEA, you might get a warning that JacksonTester
    cannot be autowired. Don’t worry. It’s a false positive. You can get rid of the
    warning by annotating the field with @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection").
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果你使用 IntelliJ IDEA，可能会收到 JacksonTester 无法自动装配的警告。不要担心，这是一个假阳性。你可以通过在字段上注解
    @SuppressWarnings("SpringJavaInjectionPointsAutowiringInspection") 来消除警告。
- en: 'You can run the tests with the following command:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令运行测试：
- en: '[PRE29]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the code repository accompanying the book, you can find more examples of
    unit and integration tests for the Catalog Service project.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在与本书配套的代码仓库中，你可以找到 Catalog Service 项目单元和集成测试的更多示例。
- en: 'After automating the tests for your application, it’s time to automate its
    execution whenever a new feature or bug fix is delivered. The following section
    will introduce the key pattern of continuous delivery: the deployment pipeline.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化应用程序的测试之后，当有新的功能或错误修复交付时，就需要自动化其执行。接下来的部分将介绍持续交付的关键模式：部署管道。
- en: '3.5 Deployment pipeline: Build and test'
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 部署管道：构建和测试
- en: Continuous delivery is a holistic approach for quickly, reliably, and safely
    delivering high-quality software, as I explained in chapter 1\. The primary pattern
    for adopting such an approach is the deployment pipeline, which goes from code
    commit to releasable software. It should be automated as much as possible, and
    it should represent the only path to production.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是一种全面的方法，用于快速、可靠和安全地交付高质量的软件，正如我在第一章中解释的那样。采用这种方法的主体模式是部署管道，它从代码提交到可发布软件。它应该尽可能地自动化，并且应该代表通向生产的唯一路径。
- en: 'Based on the concepts described by Jez Humble and Dave Farley in their *Continuous
    Delivery* book (Addison-Wesley Professional, 2010) and by Dave Farley in his *Continuous
    Delivery Pipelines* book (2021), we can identify a few key stages in a deployment
    pipeline:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Jez Humble 和 Dave Farley 在他们2010年出版的《持续交付》（Addison-Wesley Professional）一书中以及
    Dave Farley 在他2021年出版的《持续交付管道》一书中描述的概念，我们可以在部署管道中识别出几个关键阶段：
- en: '*Commit stage*—After a developer commits new code to the mainline, this stage
    goes through build, unit tests, integration tests, static code analysis, and packaging.
    At the end of this stage, an executable application artifact is published to an
    artifact repository. It is a *release candidate*. For example, it can be a JAR
    artifact published to a Maven repository or a container image published to a container
    registry. This stage supports the continuous integration practice. It’s supposed
    to be fast, possibly under five minutes, to provide developers with fast feedback
    about their changes and allow them to move on to the next task.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提交阶段*——开发者在主线提交新代码后，这一阶段将经历构建、单元测试、集成测试、静态代码分析和打包。在这个阶段结束时，一个可执行的应用程序工件被发布到一个工件仓库。它是一个*发布候选版本*。例如，它可以是发布到Maven仓库的JAR工件或发布到容器注册表的容器镜像。这一阶段支持持续集成实践。它应该很快，可能不到五分钟，以便为开发者提供关于他们更改的快速反馈，并允许他们继续进行下一项任务。'
- en: '*Acceptance stage*—The publication of a new release candidate to the artifact
    repository triggers this stage, which consists of deploying the application to
    production-like environments and running additional tests to increase the confidence
    about its releasability. The tests that run in the acceptance stage are usually
    slow, but we should strive to keep the whole deployment pipeline execution to
    under one hour. Examples of tests included in this stage are functional acceptance
    tests and non-functional acceptance tests, such as performance tests, security
    tests, and compliance tests. If necessary, this stage can also include manual
    tasks like exploratory and usability tests. At the end of this stage, the release
    candidate is ready to be deployed to production at any time. If we are still not
    confident about it, this stage is missing some tests.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验收阶段*——将新的发布候选版本发布到工件仓库会触发这一阶段，该阶段包括将应用程序部署到类似生产环境并运行额外的测试，以增加对其可发布性的信心。在验收阶段运行的测试通常很慢，但我们应努力将整个部署管道执行时间控制在不到一小时。这一阶段包括的测试示例有功能验收测试和非功能验收测试，如性能测试、安全测试和合规性测试。如果需要，这一阶段还可以包括手动任务，如探索性和可用性测试。在这一阶段结束时，发布候选版本随时可以部署到生产环境。如果我们仍然对其没有信心，这一阶段就缺少一些测试。'
- en: '*Production stage*—After a release candidate has gone through the commit and
    acceptance stages, we are confident enough to deploy it to production. This stage
    is triggered manually or automatically, depending on whether the organization
    has decided to adopt a continuous deployment practice. The new release candidate
    is deployed to a production environment using the same deployment scripts employed
    (and tested) in the acceptance stage. Optionally, some final automated tests can
    be run to verify that the deployment was successful.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生产阶段*——在发布候选版本经过提交和验收阶段后，我们对其信心足够，可以将其部署到生产环境。这一阶段可以是手动或自动触发的，具体取决于组织是否决定采用持续部署实践。新的发布候选版本使用在验收阶段使用（并测试）的相同部署脚本部署到生产环境。可选地，可以运行一些最终自动化测试来验证部署是否成功。'
- en: This section will guide you through bootstrapping a deployment pipeline for
    Catalog Service and defining the first steps in the commit stage. Then I’ll show
    you how to automate those steps using GitHub Actions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您启动目录服务的部署管道，并定义提交阶段的初步步骤。然后我将向您展示如何使用GitHub Actions自动化这些步骤。
- en: 3.5.1 Understanding the commit stage of the deployment pipeline
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 理解部署管道的提交阶段
- en: Continuous integration is a foundational practice of continuous delivery. When
    adopted successfully, developers work in small steps and commit to the mainline
    (the main branch) multiple times a day. After each code commit, the commit stage
    of the deployment pipeline takes care of building and testing the application
    with the new changes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是持续交付的基础实践。当成功采用时，开发者会以小步前进，并每天多次向主线（主分支）提交。每次代码提交后，部署管道的提交阶段会负责使用新更改构建和测试应用程序。
- en: This stage should be fast, because a developer will wait until it completes
    successfully before moving on to their next task. That’s a critical point. If
    the commit stage fails, the developer responsible for it should immediately deliver
    a fix or revert their changes so as not to leave the mainline in a broken state
    and prevent all other developers from integrating their code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段应该快速，因为开发者会在它成功完成后才继续进行下一个任务。这是一个关键点。如果提交阶段失败，负责该阶段的开发者应立即提供修复或撤销他们的更改，以免将主线置于损坏状态，并防止其他开发者集成他们的代码。
- en: Let’s start designing a deployment pipeline for a cloud native application like
    Catalog Service. For now, we’ll focus on the first few steps in the commit stage
    (figure 3.8).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设计一个用于类似目录服务这样的云原生应用程序的部署管道。现在，我们将专注于提交阶段的前几个步骤（图 3.8）。
- en: '![03-08](../Images/03-08.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![03-08](../Images/03-08.png)'
- en: Figure 3.8 The first part of the commit stage in a deployment pipeline
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 部署管道中提交阶段的第一部分
- en: After a developer pushes new code to the mainline, the commit stage starts by
    checking out the source code from the repository. The starting point is always
    a commit to the main branch. Following continuous integration practices, we’ll
    aim to work in small steps and integrate our changes with the main branch multiple
    times a day (*continuously*).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者将新代码推送到主线后，提交阶段开始通过从仓库检出源代码。起点始终是主分支的一个提交。遵循持续集成实践，我们将力求以小步前进，并每天多次将我们的更改与主分支集成（*持续集成*）。
- en: Next, the pipeline can perform several types of static code analysis. For this
    example, we’ll focus on vulnerability scanning. In a real-world project, you would
    probably want to include additional steps, such as running static code analysis
    to identify security issues and check compliance with specific coding standards
    (*code linting*).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，管道可以执行多种类型的静态代码分析。对于这个例子，我们将专注于漏洞扫描。在实际项目中，您可能希望包括额外的步骤，例如运行静态代码分析以识别安全问题并检查是否符合特定的编码标准（*代码审查*）。
- en: Finally, the pipeline builds the application and runs automated tests. In the
    commit stage, we include technically focused tests that don’t require deploying
    the entire application. These are unit tests and often integration tests. If the
    integration tests take too long, it’s better to move them to the acceptance stage
    to keep the commit stage fast.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，管道构建应用程序并运行自动化测试。在提交阶段，我们包括技术性测试，这些测试不需要部署整个应用程序。这些是单元测试，通常是集成测试。如果集成测试耗时过长，最好将它们移至验收阶段，以保持提交阶段快速。
- en: The vulnerability scanner we’ll use in the Polar Bookshop project is grype ([https://github.com/anchore/grype](https://github.com/anchore/grype)),
    a powerful open source tool that’s increasingly used in the cloud native world.
    For example, it’s part of the supply chain security solution provided by the VMware
    Tanzu Application Platform. You can find instructions on how to install it in
    section A.4 of appendix A.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Polar Bookshop 项目中使用的漏洞扫描器是 grype ([https://github.com/anchore/grype](https://github.com/anchore/grype))，这是一个在云原生世界中越来越受欢迎的强大开源工具。例如，它是
    VMware Tanzu 应用平台提供的供应链安全解决方案的一部分。您可以在附录 A 的 A.4 节中找到如何安装它的说明。
- en: Let’s see how grype works. Open a Terminal window, navigate to the root folder
    of your Catalog Service project (catalog-service), and build the application with
    ./gradlew build. Then use grype to scan your Java codebase for vulnerabilities.
    The tool will download a list of known vulnerabilities (a *vulnerability database*)
    and scan your project against them. The scanning happens locally on your machine,
    which means none of your files or artifacts is sent to an external service. That
    makes it a good fit for more regulated environments or air-gapped scenarios.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看grype是如何工作的。打开一个终端窗口，导航到你的目录服务项目（catalog-service）的根文件夹，并使用 ./gradlew build
    构建应用程序。然后使用grype扫描你的Java代码库中的漏洞。该工具将下载已知漏洞列表（一个 *漏洞数据库*）并将你的项目与之进行扫描。扫描是在你的机器上本地进行的，这意味着你的任何文件或工件都没有发送到外部服务。这使得它在更受监管的环境或断网场景中是一个很好的选择。
- en: '[PRE30]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note Remember that security is not a static property of a system. At the time
    of writing, the dependencies used by Catalog Service have no known vulnerabilities,
    but that doesn’t mean this will be true forever. You should scan your projects
    continuously and apply security patches as soon as they are released, to fix newly
    discovered vulnerabilities.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请记住，安全性不是系统的一个静态属性。在撰写本文时，目录服务使用的依赖项没有已知的漏洞，但这并不意味着这将是永远如此。你应该持续扫描你的项目，并在发布后立即应用安全补丁，以修复新发现的漏洞。
- en: Chapters 6 and 7 will cover the remaining steps in the commit stage. For now,
    let’s see how we can automate a deployment pipeline with GitHub Actions. That’s
    the subject of the following section.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章和第7章将涵盖提交阶段剩余的步骤。目前，让我们看看如何使用GitHub Actions自动化部署管道。这就是下一节的主题。
- en: 3.5.2 Implementing the commit stage with GitHub Actions
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 使用GitHub Actions实现提交阶段
- en: When it comes to automating deployment pipelines, there are many solutions from
    which you can choose. In this book, I’m going to use GitHub Actions ([https://github.com/features/actions](https://github.com/features/actions)).
    It’s a managed solution, it provides all the features we need for our project,
    and it’s conveniently already configured for all GitHub repositories. I’m introducing
    this topic early in this book so that you can use the deployment pipeline to verify
    your changes while working on the project throughout the book.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到自动化部署管道时，有许多解决方案可供选择。在这本书中，我将使用GitHub Actions ([https://github.com/features/actions](https://github.com/features/actions))。这是一个托管解决方案，它为我们提供了项目所需的所有功能，并且已经方便地配置了所有GitHub仓库。我在本书的早期就介绍这个主题，这样你就可以在阅读本书的过程中使用部署管道来验证你的更改。
- en: Note In the cloud native ecosystem, Tekton ([https://tekton.dev](https://tekton.dev))
    is a popular choice for defining deployment pipelines and other software workflows.
    It’s an open source and Kubernetes-native solution hosted at the Continuous Delivery
    Foundation ([https://cd.foundation](https://cd.foundation)). It runs directly
    on a cluster and lets you declare pipelines and tasks as Kubernetes custom resources.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在云原生生态系统中，Tekton ([https://tekton.dev](https://tekton.dev)) 是定义部署管道和其他软件工作流程的流行选择。它是一个开源的、Kubernetes原生解决方案，托管在持续交付基金会
    ([https://cd.foundation](https://cd.foundation))。它直接在集群上运行，并允许你声明管道和任务作为Kubernetes自定义资源。
- en: GitHub Actions is a platform built into GitHub that lets you automate software
    workflows directly from your code repositories. A *workflow* is an automated process.
    We’ll use workflows to model the commit stage of our deployment pipeline. Each
    workflow listens to specific *events* that trigger its execution.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是一个内置在GitHub中的平台，允许你直接从你的代码仓库自动化软件工作流程。*工作流程*是一个自动化的过程。我们将使用工作流程来模拟我们的部署管道的提交阶段。每个工作流程都监听特定的
    *事件* 来触发其执行。
- en: Workflows should be defined in a .github/workflows folder in a GitHub repository
    root, and they should be described following the YAML format provided by GitHub
    Actions. In your Catalog Service project (catalog-service), create a commit-stage.yml
    file under a new .github/workflows folder. This workflow will be triggered whenever
    new code is pushed to the repository.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程应该在GitHub仓库根目录下的 .github/workflows 文件夹中定义，并且应该按照GitHub Actions提供的YAML格式进行描述。在你的目录服务项目（catalog-service）中，在新的
    .github/workflows 文件夹下创建一个 commit-stage.yml 文件。这个工作流程将在新代码推送到仓库时被触发。
- en: Listing 3.20 Defining a workflow name and trigger
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.20 定义工作流程名称和触发器
- en: '[PRE31]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ The name of the workflow
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 工作流程的名称
- en: ❷ The workflow is triggered when new code is pushed to the repository.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当新代码推送到仓库时，工作流程将被触发。
- en: Each workflow is organized into *jobs* that run in parallel. For now, we’ll
    define a single job to collect the steps described previously in figure 3.8\.
    Each job is executed on a *runner* instance, which is a server provided by GitHub.
    You can choose between Ubuntu, Windows, and macOS. For Catalog Service, we’ll
    run everything on Ubuntu runners provided by GitHub. We’ll also want to be specific
    regarding which *permissions* each job should have. The “Build and Test” job will
    need read access to the Git repository and write access to the security events
    when submitting a vulnerability report to GitHub.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作流程都组织成并行运行的 *作业*。目前，我们将定义一个单独的作业来收集图 3.8 中描述的先前步骤。每个作业都在一个 *运行器* 实例上执行，这是一个由
    GitHub 提供的服务器。您可以选择 Ubuntu、Windows 和 macOS。对于目录服务，我们将在 GitHub 提供的 Ubuntu 运行器上运行所有内容。我们还将具体说明每个作业应具有哪些
    *权限*。构建和测试作业将需要读取 Git 仓库的访问权限，并在提交漏洞报告到 GitHub 时写入安全事件的访问权限。
- en: Listing 3.21 Configuring a job for building and testing the application
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.21 配置用于构建和测试应用程序的作业
- en: '[PRE32]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ The job’s unique identifier
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作业的唯一标识符
- en: ❷ The type of machine where the job should be run
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应运行作业的机器类型
- en: ❸ A human-friendly name for the job
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为作业指定一个便于理解的名字
- en: ❹ The permissions granted to the job
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 授予作业的权限
- en: ❺ Permission to check out the current Git repository
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检出当前 Git 仓库的权限
- en: ❻ Permission to submit security events to GitHub
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 提交安全事件到 GitHub 的权限
- en: Each job is composed of *steps*, which are executed sequentially. A step could
    be either a shell command or an *action*. Actions are custom applications used
    to perform complex tasks in a more structured and reproducible way. For example,
    you could have actions for packaging an application into an executable, running
    tests, creating a container image, or pushing an image to a container registry.
    The GitHub organization provides a basic set of actions, but there’s also a marketplace
    with many more actions developed by the community.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 每个作业由 *步骤* 组成，这些步骤按顺序执行。一个步骤可以是 shell 命令或 *操作*。操作是用于以更结构化和可重复的方式执行复杂任务的定制应用程序。例如，您可以为打包应用程序为可执行文件、运行测试、创建容器镜像或将镜像推送到容器注册表创建操作。GitHub
    组织提供了一套基本操作，但还有由社区开发的大量更多操作的市场。
- en: Warning When using actions from the GitHub marketplace, handle them like any
    other third-party application and manage the security risks accordingly. Prefer
    using trusted actions provided by GitHub or verified organizations over other
    third-party options.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 当使用 GitHub 市场中的操作时，像处理任何其他第三方应用程序一样处理它们，并相应地管理安全风险。优先使用 GitHub 或经过验证的组织提供的受信任操作，而不是其他第三方选项。
- en: Let’s complete this first part of the commit stage by describing what steps
    the “Build and Test” job should run. The final result is shown in the following
    listing.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过描述“构建和测试”作业应运行的步骤来完成提交阶段的这一部分。最终结果如下所示。
- en: Listing 3.22 Implementing the steps to build and test the application
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.22 实现构建和测试应用程序的步骤
- en: '[PRE33]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Checks out the current Git repository (catalog-service)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检出当前 Git 仓库（catalog-service）
- en: ❷ Installs and configures a Java runtime
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安装和配置 Java 运行时
- en: ❸ Defines which version, distribution, and cache type to use
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义要使用的版本、发行版和缓存类型
- en: ❹ Scans the codebase for vulnerabilities using grype
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 grype 扫描代码库中的漏洞
- en: ❺ Assigns an identifier to the current step so that it can be referenced from
    subsequent steps
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为当前步骤分配一个标识符，以便可以从后续步骤中引用
- en: ❻ The path to the checked-out repository
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检出仓库的路径
- en: ❼ Whether to fail the build in the event of security vulnerabilities
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在发生安全漏洞时是否使构建失败
- en: ❽ The minimum security category to be considered as an error (low, medium, high,
    critical)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 被视为错误的最小安全类别（低、中、高、严重）
- en: ❾ Whether to enable the generation of a report after the scan is completed
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 是否在扫描完成后启用生成报告
- en: ❿ Uploads the security vulnerability report to GitHub (SARIF format)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 将安全漏洞报告上传到 GitHub（SARIF 格式）
- en: ⓫ Uploads the report even if the previous step fails
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 即使前一个步骤失败，也上传报告
- en: ⓬ Fetches the report from the output of the previous step
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 从前一个步骤的输出中获取报告
- en: ⓭ Ensures the Gradle wrapper is executable, solving Windows incompatibilities
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 确保 Gradle 包装器可执行，解决 Windows 兼容性问题
- en: ⓮ Runs the Gradle build task, which compiles the codebase and runs unit and
    integration tests
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ⓮ 运行 Gradle 构建任务，编译代码库并运行单元和集成测试
- en: Warning The action that uploads the vulnerability report requires the GitHub
    repository to be public. It works for private repositories only if you have an
    enterprise subscription. If you prefer keeping your repository private, you’ll
    need to skip the “Upload vulnerability report” step. Throughout the book, I’ll
    assume all the repositories we create on GitHub for the Polar Bookshop project
    are public.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：上传漏洞报告的操作需要GitHub仓库是公开的。如果你有企业订阅，它仅适用于私有仓库。如果你更喜欢保持你的仓库私有，你需要跳过“上传漏洞报告”步骤。在本书中，我将假设我们为Polar
    Bookshop项目在GitHub上创建的所有仓库都是公开的。
- en: After completing the declaration of the initial commit stage for the deployment
    pipeline, commit your changes and push them to the remote GitHub repository. The
    newly created workflow will be immediately triggered. You can see the execution
    results on your GitHub repository page on the Actions tab. Figure 3.9 shows an
    example of the results after running the workflow in listing 3.22\. By keeping
    the result of the commit stage green, you can be quite sure that you haven’t broken
    anything or introduced new regressions (assuming that you have proper tests in
    place).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成部署管道初始提交阶段的声明后，提交你的更改并将它们推送到远程GitHub仓库。新创建的工作流程将立即触发。你可以在GitHub仓库页面的操作标签页中看到执行结果。图3.9显示了在列表3.22中运行工作流程后的结果示例。通过保持提交阶段的绿色结果，你可以相当确信你没有破坏任何东西或引入新的回归（假设你有适当的测试）。
- en: '![03-09](../Images/03-09.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![03-09](../Images/03-09.png)'
- en: Figure 3.9 The commit stage workflow is executed after you push new changes
    to the remote repository.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 在你向远程仓库推送新更改后，提交阶段的工作流程被执行。
- en: The step for running the vulnerability scan is based on an action provided by
    Anchore, the company behind grype. In listing 3.22, we do not fail the workflow
    if serious vulnerabilities are discovered. However, you can find the scanning
    results in the Security section of your catalog-service GitHub repository.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 运行漏洞扫描的步骤基于由grype背后的公司Anchore提供的一个操作。在列表3.22中，我们不会在发现严重漏洞时使工作流程失败。然而，你可以在catalog-service
    GitHub仓库的安全部分找到扫描结果。
- en: At the time of writing, there is no high or critical vulnerability in the Catalog
    Service project, but things might be different in the future. If that’s the case,
    consider using the latest available security patches for the affected dependencies.
    For the sake of the example, and because I don’t want to disrupt your learning
    journey, I decided not to make the build fail on finding vulnerabilities. In a
    real-world scenario, however, I recommend you configure and tune grype carefully
    and according to your company policies regarding supply chain security, and make
    the workflow fail if the result is not compliant (setting the fail-build property
    to true). For more information, refer to the official grype documentation ([https://github.com/anchore/grype](https://github.com/anchore/grype)).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，目录服务项目中没有发现高或关键漏洞，但未来情况可能会有所不同。如果出现这种情况，请考虑使用受影响依赖项的最新安全补丁。为了举例说明，并且因为我不想打断你的学习之旅，我决定在发现漏洞时不使构建失败。然而，在实际场景中，我建议你根据公司关于供应链安全的规定仔细配置和调整grype，并在结果不符合规范时使工作流程失败（将fail-build属性设置为true）。有关更多信息，请参阅官方grype文档([https://github.com/anchore/grype](https://github.com/anchore/grype))。
- en: After scanning the Java project for vulnerabilities, we also included a step
    to fetch the security report generated by grype and upload it to GitHub, independently
    of whether the build succeeds or not. If any security vulnerability is found,
    you can see the results in the Security tab of your GitHub repository page (figure
    3.10).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描Java项目的漏洞之后，我们还包括了一个步骤，用于获取由grype生成的安全报告并将其独立于构建是否成功上传到GitHub。如果发现任何安全漏洞，你可以在GitHub仓库页面的安全标签页中看到结果（图3.10）。
- en: '![03-10](../Images/03-10.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![03-10](../Images/03-10.png)'
- en: Figure 3.10 A security vulnerability report generated by grype and published
    to GitHub
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 由grype生成并发布到GitHub的安全漏洞报告
- en: Note At the time of writing, grype doesn’t find any vulnerabilities in the codebase
    provided with this book. To show you an example of a vulnerability report, figure
    3.10 shows the results of grype scanning a different version of the project, purposely
    full of known vulnerabilities.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在撰写本文时，grype没有在本书提供的代码库中找到任何漏洞。为了展示一个漏洞报告的例子，图3.10显示了grype扫描项目不同版本的结果，该版本故意充满了已知的漏洞。
- en: 'That’s it for this chapter. Next, I’ll cover one of the main cloud native development
    practices: externalized configuration.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束。接下来，我将介绍主要的云原生开发实践之一：外部化配置。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Each cloud native application should be tracked in its own codebase, and all
    its dependencies should be declared in a manifest using tools like Gradle or Maven.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个云原生应用程序都应该在其自己的代码库中进行跟踪，并且所有依赖项都应该使用 Gradle 或 Maven 等工具在清单中声明。
- en: Cloud native applications don’t depend on servers being injected into the environment.
    Instead, they use an embedded server and are self-contained.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用程序不依赖于注入到环境中的服务器。相反，它们使用嵌入式服务器并且是自包含的。
- en: Tomcat is the default embedded server for Spring Boot applications, and it can
    be configured through properties to customize the ports it listens on, connections,
    timeouts, and threads.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat 是 Spring Boot 应用程序的默认嵌入式服务器，并且可以通过属性进行配置，以自定义其监听的端口、连接、超时和线程。
- en: The request/response interaction provided by a Servlet container like Tomcat
    is both synchronous and blocking. Each thread handles an HTTP request until a
    response is returned.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet 容器（如 Tomcat）提供的请求/响应交互既同步又阻塞。每个线程处理一个 HTTP 请求，直到返回响应。
- en: The API first principle recommends designing the API before implementing the
    business logic to establish a contract. In this way, other teams can develop their
    services to consume your application based on the contract itself, without waiting
    for the application to be finished.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 的第一原则建议在实现业务逻辑之前设计 API，以建立合同。这样，其他团队可以根据合同本身开发他们的服务来消费您的应用程序，而无需等待应用程序完成。
- en: In Spring MVC, REST APIs are implemented in @RestController classes.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring MVC 中，REST API 在 `@RestController` 类中实现。
- en: Each REST controller method handles an incoming request with a specific method
    (GET, POST, PUT, DELETE) and endpoint (e.g., /books).
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 REST 控制器方法都通过特定的方法（GET、POST、PUT、DELETE）和端点（例如，/books）处理传入的请求。
- en: Controller methods can declare which endpoints and operations they handle through
    the annotations @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, and @RequestMapping.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器方法可以通过 `@GetMapping`、`@PostMapping`、`@PutMapping`、`@DeleteMapping` 和 `@RequestMapping`
    等注解声明它们处理哪些端点和操作。
- en: Methods of a @RestController class can validate the HTTP request body before
    the processing happens by applying the @Valid annotation.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RestController` 类的方法可以通过应用 `@Valid` 注解在处理之前验证 HTTP 请求体。'
- en: The validation constraints for a given Java object are defined using annotations
    from the Java Bean Validation API on the fields (for example, @NotBlank, @Pattern,
    @Positive).
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的 Java 对象，使用 Java Bean 验证 API 的注解在字段上定义验证约束（例如，@NotBlank、@Pattern、@Positive）。
- en: Java exceptions thrown during the processing of an HTTP request can be mapped
    to an HTTP status code and body in a centralized @RestControllerAdvice class,
    decoupling the exception handling for the REST API from the code throwing the
    exception.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理 HTTP 请求期间抛出的 Java 异常可以映射到一个集中式的 `@RestControllerAdvice` 类中的 HTTP 状态码和正文，从而将
    REST API 的异常处理与抛出异常的代码解耦。
- en: Unit tests are not aware of the Spring configuration but can be written as standard
    Java tests using familiar tools like JUnit, Mockito, and AssertJ.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试不了解 Spring 配置，但可以使用 JUnit、Mockito 和 AssertJ 等熟悉的工具编写为标准 Java 测试。
- en: Integration tests need a Spring application context to run. A full application
    context, including an optional embedded server, can be initialized for testing
    using the @SpringBootTest annotation.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试需要一个 Spring 应用程序上下文来运行。可以使用 `@SpringBootTest` 注解初始化一个完整的应用程序上下文，包括可选的嵌入式服务器，以进行测试。
- en: When tests are focused only on a “slice” of the application and only need a
    part of the configuration, Spring Boot provides several annotations for more targeted
    integration tests. When you use those annotations, a Spring application context
    is initialized, but only the components and configuration parts used by the specific
    functionality slice are loaded.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试仅关注应用程序的“切片”并且只需要部分配置时，Spring Boot 提供了几个注解以进行更精确的集成测试。当使用这些注解时，会初始化一个 Spring
    应用程序上下文，但只加载特定功能切片使用的组件和配置部分。
- en: '@WebMvcTest is for testing Spring MVC components.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebMvcTest` 用于测试 Spring MVC 组件。'
- en: '@JsonTest is for testing JSON serialization and deserialization.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@JsonTest` 用于测试 JSON 序列化和反序列化。'
- en: GitHub Actions is a tool provided by GitHub to declare pipelines (or workflows)
    for automating tasks. It can be used to build a deployment pipeline.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions 是 GitHub 提供的一个工具，用于声明用于自动化任务的管道（或工作流程）。它可以用来构建部署管道。
