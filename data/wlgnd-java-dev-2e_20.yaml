- en: 15 Advanced functional programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 高级函数式编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Functional programming concepts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程概念
- en: Limits of functional programming in Java
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 中函数式编程的局限性
- en: Kotlin advanced functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 高级函数式编程
- en: Clojure advanced functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 高级函数式编程
- en: We have already met functional programming concepts earlier in the book, but
    in this chapter we want to draw together the threads and step it up. There is
    a lot of talk about *functional programming* in the industry, but it remains a
    rather ill-defined concept. The sole point that is agreed upon is that in a functional
    programming (FP) language, code is representable as a first-class data item, that
    is, that it should be possible to represent a piece of deferred computation as
    a value that can be assigned to a variable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的早期已经遇到了函数式编程概念，但在这章中，我们希望将这些线索汇总并提升到一个新的层次。在业界，关于 *函数式编程* 的讨论很多，但它仍然是一个相当不明确的概念。唯一达成共识的是，在函数式编程（FP）语言中，代码可以表示为第一类数据项，也就是说，应该能够将一个延迟计算的片段表示为一个可以分配给变量的值。
- en: This definition is, of course, ludicrously broad—for all practical purposes,
    every mainstream language (with very few exceptions) in the last 30 years meets
    this definition. So, when different groups of programmers discuss FP, they are
    talking about different things. Each tribe has a different, tacit understanding
    of what other language properties are implicitly understood to *also* be included
    under the term “FP.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个定义过于宽泛——在所有实际应用中，过去 30 年中几乎所有的主流语言（除了极少数例外）都符合这个定义。因此，当不同的程序员群体讨论 FP 时，他们谈论的是不同的事情。每个群体对“FP”这个术语下隐含的其他语言属性都有不同的、不言而喻的理解。
- en: In other words—just as with OO—there is no fundamentally agreed-upon definition
    of what a “functional programming language” is. Alternatively, if everything is
    a FP language, then nothing is.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说——就像面向对象（OO）一样——对“函数式编程语言”的定义并没有根本上的共识。或者，如果一切都是 FP 语言，那么就没有什么是了。
- en: The well-grounded developer is well advised to visualize programming languages
    upon an axis (or, better yet, as a point in a multidimensional space of possible
    language characteristics). Languages are simply more or less functional than other
    languages—there is not some absolute scale that they are weighed against. Let’s
    meet some of the concepts of the common toolbox of functional programming languages
    that go beyond the somewhat facile “code is data” notion.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 稳健的开发者最好在一条轴（或者，更好的是，作为一个可能的语言特征的多维空间中的点）上可视化编程语言。语言只是比其他语言更函数式或更少函数式——没有某种绝对尺度来衡量它们。让我们来认识一些超越“代码是数据”这种简单概念的函数式编程语言常见工具箱中的概念。
- en: 15.1 Introduction to functional programming concepts
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 函数式编程概念简介
- en: In what follows, we will frequently speak of *functions*, but neither the Java
    language nor the JVM has any such thing—all executable code must be expressed
    as a *method*, which is defined, linked, and loaded within a *class*. Other, non-JVM
    languages, however, have a different conception of executable code, so when we
    refer to a function in this chapter, it should be understood that we mean a piece
    of executable code that roughly corresponds to a Java method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将经常提到 *函数*，但 neither Java 语言 nor JVM 并没有这样的东西——所有可执行代码都必须以 *方法* 的形式表达，该方法在
    *类* 中定义、链接和加载。然而，其他非 JVM 语言对可执行代码有不同的理解，因此当我们在本章中提到函数时，应理解为与 Java 方法大致对应的可执行代码片段。
- en: 15.1.1 Pure functions
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.1 纯函数
- en: 'A *pure function* is a function that does not alter the state of any other
    entity. It is sometimes said to be *side-effect free*, which is intended to mean
    that the function behaves like an ideation of a mathematical function: it takes
    in arguments, does not affect them in any way, and returns a result that is dependent
    only on the values that have been passed.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *纯函数* 是一个不会改变任何其他实体状态的函数。有时人们说它是 *无副作用的*，这意味着函数的行为像一个数学函数的构想：它接受参数，以任何方式都不影响它们，并返回一个仅依赖于传递的值的输出。
- en: Related to the concept of purity is the idea of *referential transparency*.
    This is somewhat unfortunately named—it has nothing to do with references as a
    Java programmer would understand them. Instead, it means that a function call
    can be replaced with the result of any previous call to the same function with
    the same arguments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与纯度概念相关的是*引用透明性*的概念。这个名称有些不幸——它与Java程序员理解的引用无关。相反，这意味着一个函数调用可以用任何之前对相同函数使用相同参数的调用结果来替换。
- en: It is obvious that all pure functions are referentially transparent, but there
    may also exist functions that are not pure and yet are also referentially transparent.
    To allow a non-pure function to be considered in this way would require a formal
    proof based on code analysis. Purity is about code, but immutability is about
    data, and that’s the next FP concept we will look at.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，所有纯函数都是引用透明的，但也可能存在既不纯又是引用透明的函数。要允许非纯函数以这种方式被考虑，需要基于代码分析的形式证明。纯度关乎代码，但不可变性关乎数据，这是我们接下来要探讨的下一个FP概念。
- en: 15.1.2 Immutability
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.2 不可变性
- en: '*Immutability* means that after an object has been created, its state cannot
    be altered. The default in Java is for objects to be mutable. The keyword `final`
    is used in various ways in Java, but the one that concerns us here is to prevent
    modification of fields after creation. Other languages may favor immutability
    and indicate that preference in various ways—such as Rust, which requires programmers
    to explicitly make variables mutable with the `mut` modifier.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变性*意味着一旦一个对象被创建，其状态就不能被改变。在Java中，对象的默认状态是可变的。Java中关键字`final`被用于多种方式，但在这里我们关注的是防止在创建后修改字段。其他语言可能更倾向于不可变性，并以各种方式表明这种偏好——例如Rust，它要求程序员使用`mut`修饰符显式地使变量可变。'
- en: 'Immutability makes code easier to reason about: objects have a trivial state
    model, simply because they are constructed in the only state they will ever exist
    in. Among other benefits, this means that they can be copied and shared safely,
    even between threads.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性使得代码更容易推理：对象具有简单的状态模型，仅仅因为它们只以它们将永远存在的唯一状态被构建。其他好处包括，这意味着它们可以在线程之间安全地复制和共享。
- en: Note We might ask whether any “almost immutable” approaches to data exist that
    still maintain some (or most) of the attractive properties of immutability. In
    fact, the Java `CompletableFuture` class that we have already met is one such
    example. We’ll have more to say about this in the next chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们可能会问是否存在任何“几乎不可变”的数据方法，同时仍然保持不可变性的一些（或大多数）吸引人的属性。实际上，我们之前遇到的Java `CompletableFuture`类就是这样的一个例子。我们将在下一章中对此有更多讨论。
- en: One consequence is that, because immutable objects cannot be altered, the only
    way that state change can be expressed in a system is by starting from an immutable
    value and constructing a completely new immutable value that is more or less the
    same but with some fields altered—possibly by the use of *withers* (aka `with*()`
    methods).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个后果是，由于不可变对象不能被改变，系统中表达状态变化唯一的方法是从一个不可变值开始，构建一个完全新的、或多或少相同但某些字段已更改的不可变值——可能通过使用*withers*（也称为`with*()`方法）。
- en: 'For example, the `java.time` API makes very extensive use of immutable data,
    and new instances can be created by the use of withers like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`java.time` API非常广泛地使用了不可变数据，可以通过使用类似这样的withers来创建新实例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The immutable approach has consequences—specifically a potentially large impact
    on the memory subsystem, because the components of the old value have to be copied
    as part of the creation of the modified value. This means that in-place mutation
    is often much cheaper from a performance perspective.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变方法有后果——特别是对内存子系统可能产生重大影响，因为旧值的组件必须作为创建修改后值的一部分被复制。这意味着从性能角度来看，就地修改通常要便宜得多。
- en: 15.1.3 Higher-order functions
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.3 高阶函数
- en: 'Higher-order functions are actually a very simple concept, described by the
    following insight: if a function can be represented as a data item, then it should
    be able to be treated as though it was any other value.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数实际上是一个非常简单的概念，由以下洞察来描述：如果一个函数可以被表示为一个数据项，那么它应该能够被当作任何其他值来处理。
- en: 'We can define a *higher-order function* as a function value that does one or
    both of the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将*高阶函数*定义为一种函数值，它执行以下一个或两个操作：
- en: Takes a function value as a parameter
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数值作为参数
- en: Returns a function value
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数值
- en: 'Consider, for example, a static method that takes in a Java `String` and generates
    a function object from it, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个静态方法，它接受一个Java `String`并从中生成一个函数对象，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This provides a straightforward way to make function objects. Let’s now combine
    it with another static method, shown next, that this time accepts a function object
    as input:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种直接创建函数对象的方法。现在让我们结合另一个静态方法，如下所示，这次它接受一个函数对象作为输入：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This provides us with the following simple example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个简单的例子：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a function object
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个函数对象
- en: ❷ Passes the function object as a parameter to another method
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将函数对象作为参数传递给另一个方法
- en: However, this is not quite the whole story for Java, as we will see in the next
    section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于Java来说，这并不是全部的故事，我们将在下一节中看到。
- en: 15.1.4 Recursion
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.4 递归
- en: 'A *recursive* function is one that calls itself on at least some of the code
    paths through the function. This leads to one of the oldest jokes in programming:
    “in order to understand recursion, one must first understand recursion.”'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*递归*函数是指在函数的至少一些代码路径上调用自身的函数。这导致了编程中最古老的笑话之一：“为了理解递归，一个人必须首先理解递归。”
- en: 'However, to be more strictly accurate, we might write it as follows: in order
    to understand recursion, one must first understand'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了更加严格地准确，我们可能可以这样写：为了理解递归，一个人必须首先理解
- en: recursion, and
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归，以及
- en: that in a physically realizable system, every chain of recursive calls must
    eventually terminate and return a value.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个物理可实现系统中，每个递归调用链最终都必须终止并返回一个值。
- en: 'The second point is important: programming languages use call stacks to allow
    functions to call other functions, and this occupies space in memory. Recursion,
    therefore, has the problem that deep recursive calls may potentially use up too
    much memory and crash.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点很重要：编程语言使用调用栈来允许函数调用其他函数，这会占用内存空间。因此，递归的问题在于深度递归调用可能会消耗过多的内存并导致崩溃。
- en: In terms of theoretical computer science, recursion is interesting and important
    for many different reasons. One of the most important is that recursion can be
    used as a basis to explore theories of computation and ideas such as *Turing completeness*,
    which is loosely the idea that all nontrivial computation systems have the same
    theoretical capability to perform calculations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论计算机科学中，递归因其许多不同的原因而有趣且重要。其中最重要的原因是递归可以用作探索计算理论和如*图灵完备性*等想法的基础，这大致是指所有非平凡的计算系统都具有相同的理论能力来执行计算。
- en: 15.1.5 Closures
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.5 闭包
- en: A *closure* is usually defined as a lambda expression that “captures” some state
    from the surrounding context. However, for this definition to make sense, we need
    to explain the meaning of the capturing concept.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*闭包*通常被定义为“捕获”周围上下文中一些状态的lambda表达式。然而，为了使这个定义有意义，我们需要解释捕获概念的含义。
- en: When we create a value and assign (or bind) it to a local variable, the variable
    will exist and can be used until some later point in the code. This later point
    may well be the end of the function or block where the variable was declared.
    The area of code where the variable exists and can be used is the *scope* of the
    variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个值并将其分配（或绑定）给一个局部变量时，该变量将存在并且可以在代码的某个后续点被使用。这个后续点可能是声明变量的函数或块的末尾。变量存在并可被使用的代码区域是变量的*作用域*。
- en: When we create a function value, the local variables declared within the function
    body will still be in scope during the invocation of the function value, which
    will occur later than the point where the function value is declared. If, in the
    declaration of the function value, we mention a variable (or other state, such
    as a field) that is declared outside the scope of the function body, then the
    function value is said to have *closed over* the state, and the function value
    is known as a closure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个函数值时，函数体内部声明的局部变量在函数值的调用期间仍然在作用域内，这个调用将发生在函数值声明之后。如果在函数值的声明中提到了在函数体作用域之外声明的变量（或其他状态，如字段），那么函数值就说是对状态进行了*封闭*，并且这个函数值被称为闭包。
- en: When the closure is later invoked, it has full access to the captured variables,
    even if the invocation happens in a different scope to that in which the capture
    was declared.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包稍后调用时，它对捕获的变量有完全的访问权限，即使调用发生在捕获声明的作用域之外。
- en: 'For example, in Java:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Java中：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This static method is a higher-order function that returns a Java closure because
    it returns a lambda expression that references `atomic`, which was declared as
    a local variable inside the method, that is, in the scope where the lambda was
    itself declared. The closure returned from `closure()` can be called repeatedly,
    and it will aggregate state on each call.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个静态方法是一个高阶函数，它返回一个Java闭包，因为它返回了一个引用`atomic`的lambda表达式，`atomic`是在方法内部声明的局部变量，即在lambda本身声明的范围内。从`closure()`返回的闭包可以被重复调用，并且它会在每次调用中聚合状态。
- en: 15.1.6 Laziness
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.6 懒惰
- en: We briefly mentioned the concept of *laziness* in chapter 10\. Essentially,
    *lazy evaluation* allows the computation of the value of an expression to be deferred
    until the value is actually required. By contrast, the immediate evaluation of
    an expression is known as *eager evaluation* (or *strict evaluation*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第10章中简要提到了*懒惰*的概念。本质上，*惰性评估*允许将表达式的值计算推迟到实际需要时。相比之下，表达式的即时评估被称为*即时评估*（或*严格评估*）。
- en: 'The idea of laziness is simple: if you don’t need to do work, don’t do it!
    It sounds simple but has deep ramifications for how you write your programs and
    how they perform. A key part of this additional complexity is that your program
    needs to track what work has and hasn’t been completed already.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰的概念很简单：如果你不需要做工作，那就不要做！这听起来很简单，但对你编写程序以及程序的性能有着深远的影响。这个额外复杂性的一个关键部分是，你的程序需要跟踪哪些工作已经完成，哪些还没有完成。
- en: Not every language supports lazy evaluation, and many programmers may have encountered
    only eager evaluation at this point in their journey—and that’s completely OK.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每种语言都支持惰性评估，许多程序员可能在这个旅程中只遇到过即时评估——这是完全可以接受的。
- en: For example, there is no general language-level support for laziness in Java,
    so it’s difficult to give a clear example of the feature. We’ll have to wait until
    we talk about Kotlin to make it concrete.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Java在语言级别上没有对懒惰的一般支持，所以很难给出一个清晰的例子。我们得等到我们谈到Kotlin时才能具体化。
- en: However, although laziness is not necessarily a natural concept for a Java programmer,
    laziness is an extremely useful and powerful technique in FP. In fact, for some
    FP languages, such as Haskell, lazy evaluation is the default.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管懒惰对于Java程序员来说可能不是一个自然的概念，但在函数式编程（FP）中，懒惰是一个非常有用且强大的技术。事实上，对于某些FP语言，如Haskell，惰性评估是默认的。
- en: 15.1.7 Currying and partial application
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.7 柯里化和部分应用
- en: Currying, unfortunately, has nothing to do with food. Instead, it is a programming
    technique named after Haskell Curry (who also gave his name to the Haskell programming
    language). To explain it, let’s start with a concrete example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化不幸的是，与食物无关。相反，它是一种以Haskell Curry（他的名字也给了Haskell编程语言）命名的编程技术。为了解释它，让我们从一个具体的例子开始。
- en: Consider an eagerly-evaluated, pure function that takes two arguments. If we
    supply both arguments, we will get a value, and the function call can be replaced
    everywhere by the resulting value (this is referential transparency). But what
    happens if we supply not both but only one of the two arguments?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个即时评估的纯函数，它接受两个参数。如果我们提供两个参数，我们将得到一个值，函数调用可以在任何地方被结果值替换（这就是引用透明性）。但如果我们只提供两个参数中的一个会发生什么呢？
- en: Intuitively, we can think of this as creating a new function, but one that needs
    only a single argument to calculate a result. This new function is called a *curried
    function* (or *partially-applied function*). Java does not have direct support
    for currying, so we will again defer making a concrete example until later in
    the chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，我们可以将其视为创建一个新的函数，但这个函数只需要一个参数来计算结果。这个新函数被称为*柯里化函数*（或*部分应用函数*）。Java没有直接支持柯里化的功能，所以我们再次将具体的例子推迟到本章的后面部分。
- en: Looking farther afield, some programming languages support the notion of functions
    with multiple argument lists (or have syntax that allows the programmer to fake
    them). In this case, another way to think about currying is as a transformation
    of functions. In mathematical notation, we are translating a multiple-argument
    function that is called as `f(a, b)` into one callable as `(g(a))(b)`, where `g(a)`
    is the partially applied function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从更广泛的角度来看，一些编程语言支持具有多个参数列表的函数概念（或者有语法允许程序员伪造它们）。在这种情况下，我们可以将柯里化视为函数的一种转换。在数学符号中，我们将一个作为
    `f(a, b)` 调用的多参数函数转换为可以调用为 `(g(a))(b)` 的形式，其中 `g(a)` 是部分应用函数。
- en: As should be obvious now, the different languages we’ve met so far have different
    levels of support for functional programming—for example, Clojure has very good
    support for many of the concepts that we have discussed in this section. Java,
    on the other hand, is a very different story, as we’ll see in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很明显，我们迄今为止遇到的不同语言对函数式编程的支持程度不同——例如，Clojure对我们在本节中讨论的许多概念有非常好的支持。另一方面，Java的情况则完全不同，我们将在下一节中看到。
- en: 15.2 Limitations of Java as a FP language
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 Java作为函数式编程语言的局限性
- en: 'Let’s start with the good news, such as it is: Java definitely clears the rather
    low bar of “represent code as data” via the types in `java.util.function` and
    also via the extensive introspective support the runtime provides (such as Reflection
    and Method Handles).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从好消息开始，尽管如此：Java确实通过`java.util.function`中的类型以及运行时提供的广泛内省支持（如反射和方法句柄）清除了“将代码表示为数据”的相对较低门槛。
- en: Note The use of inner classes to simulate function objects as a technique predates
    Java 8 and was present in libraries like Google Guava, so strictly speaking, Java’s
    ability to represent code as data is not tied to that version.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用内部类来模拟函数对象作为技术早于Java 8，并且存在于像Google Guava这样的库中，所以严格来说，Java将代码表示为数据的能力并不局限于那个版本。
- en: Since version 8, the Java language goes somewhat further than the bare minimum
    with the introduction of streams and, with them, a heavily restricted domain of
    lazy operations. However, despite the arrival of streams, Java is not a naturally
    functional environment. Some of this is due to the history of the platform and
    what are—by now—decades-old design decisions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自从第8版以来，Java语言通过引入流以及与之相关的严格受限的延迟操作领域，在最低限度上有所超越。然而，尽管有了流，Java并不是一个自然的功能环境。这其中的部分原因是平台的历史以及现在已经几十年前的设计决策。
- en: Note It is worth remembering that Java is a 25-year-old imperative language
    that has been iterated upon extensively. Some of its APIs are amenable to FP,
    immutable data, and so on, and some are not. This is the reality of working in
    a language that has survived, and thrived, yet still remains backward compatible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：值得记住的是，Java是一种已经迭代了25年的命令式语言，它已经进行了广泛的迭代。其中一些API适合函数式编程、不可变数据等，而另一些则不适合。这是在一种已经生存并繁荣的语言中工作的现实，同时仍然保持向后兼容性。
- en: So, overall, Java is perhaps best described as a “slightly functional programming
    language.” It has the basic features needed to support FP and provides developers
    with access to basic patterns like filter-map-reduce via the Streams API, but
    most advanced functional features are either incomplete or missing entirely. Let’s
    take a detailed look.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，Java可能最好被描述为一种“稍微有点函数式编程语言”。它拥有支持函数式编程所需的基本特性，并通过Streams API为开发者提供访问基本模式（如filter-map-reduce）的途径，但大多数高级函数式特性要么是不完整的，要么完全缺失。让我们详细看看。
- en: 15.2.1 Pure functions
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1 纯函数
- en: 'As we saw in chapter 4, Java’s bytecodes do many different sorts of things,
    including arithmetic, stack manipulation, flow control, and especially invocation
    and data storage and retrieval. For well-grounded developers who already understand
    JVM bytecode, this means that we can express purity of methods by thinking about
    the effect of bytecodes. Specifically, a pure method in a JVM language is one
    that does the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第4章中看到的，Java的字节码执行许多不同类型的事情，包括算术、堆栈操作、流程控制，特别是调用和数据存储和检索。对于已经熟悉JVM字节码的扎实开发者来说，这意味着我们可以通过考虑字节码的效果来表达方法的纯度。具体来说，JVM语言中的纯方法是指以下方法：
- en: Does not modify object or static state (does not contain `putfield` or `putstatic`)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不修改对象或静态状态（不包含`putfield`或`putstatic`）
- en: Does not depend upon external mutable object or static state
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不依赖于外部可变对象或静态状态
- en: Does not call any non pure method
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不调用任何非纯方法
- en: This is a pretty restrictive set of conditions and underlines the difficulty
    of using the JVM as a basis for pure functional programming.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当限制性的条件集，并强调了使用JVM作为纯函数式编程基础时的困难。
- en: 'There is also a question about the semantics—that is, the intent—of the different
    interfaces present in the JDK. For example, `Callable` (in `java.util.concurrent`)
    and `Supplier` (in `java.util.function`) both do basically the same thing: they
    perform some calculation and return a value, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JDK中不同接口的语义——即意图——也存在疑问。例如，`Callable`（在`java.util.concurrent`中）和`Supplier`（在`java.util.function`中）基本上做的是同一件事：它们执行一些计算并返回一个值，如下所示：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: They are both `@FunctionalInterface` and are both routinely used as the target
    type for a lambda. The signatures of the interfaces are the same, apart from different
    approaches to handling exceptions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是`@FunctionalInterface`，并且通常被用作lambda表达式的目标类型。接口的签名是相同的，除了处理异常的方法不同。
- en: 'However, they can be seen as having different roles: a `Callable` implies potentially
    nontrivial amounts of work in the called code to create the value that will be
    returned. On the other hand, the name `Supplier` seems to imply less work—perhaps
    just returning a cached value.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们可以被视为具有不同的角色：`Callable`暗示在调用代码中可能需要进行一些非平凡的工作来创建将要返回的值。另一方面，`Supplier`这个名字似乎暗示工作量较少——可能只是返回一个缓存的值。
- en: 15.2.2 Mutability
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2 可变性
- en: Java is a mutable language—mutability is baked into its design from the earliest
    days. Partly this is an accident of history—the machines of the late 1990s (from
    when Java hails) were very restricted (by modern standards) in terms of memory.
    An immutable data model would have greatly increased stress on the memory management
    subsystem, and caused much more frequent GC events, leading to far worse throughput.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种可变语言——可变性从其设计之初就内置其中。部分原因是历史的偶然——20世纪90年代末的机器（Java的起源）在内存方面非常受限（按现代标准）。不可变的数据模型将大大增加内存管理子系统的压力，并导致更频繁的GC事件，从而导致更差的吞吐量。
- en: Java’s design, therefore, favors mutation over the creation of modified copies.
    So in-place mutation can be seen as a design choice caused by performance trade-offs
    from 25 years ago.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java的设计倾向于修改而不是创建修改后的副本。所以原地修改可以看作是25年前由于性能权衡而做出的设计选择。
- en: The situation, however, is even worse than that. Java refers to all composite
    data by reference, and the `final` keyword applies to the reference, *not* to
    the data. For instance, when applied to fields, the field can be assigned to only
    once.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况甚至比这更糟。Java通过引用来引用所有复合数据，`final`关键字应用于引用，*而不是*数据。例如，当应用于字段时，字段只能被分配一次。
- en: This means that even if a object has all final fields, the composite state can
    still be mutable because the object can hold a `final` reference to another object
    that has some nonfinal fields. This leads to the problem of shallow immutability,
    as we discussed in chapter 5.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使一个对象的所有字段都是final的，组合状态仍然可能是可变的，因为对象可以持有对另一个具有一些非final字段的`final`引用。这导致了我们在第5章讨论的浅层不可变性问题。
- en: 'Note For C++ programmers: Java has no concept of `const`, although it does
    have it as an (unused) keyword.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于C++程序员来说：Java没有`const`的概念，尽管它确实有一个（未使用）关键字。
- en: 'For example, here is a slightly enhanced version of the immutable `Deposit`
    class that we met in chapter 5:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个我们在第5章遇到的不可变`Deposit`类的略微增强版本：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The immutability of this class rests upon the assumption that `Account` and
    all of its transitive dependencies are also immutable. This means there are limits
    to what can be done—fundamentally the data model of Java and the JVM is not naturally
    friendly to immutability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的不可变性基于假设`Account`及其所有传递依赖也是不可变的。这意味着有一些限制——从根本上讲，Java和JVM的数据模型并不自然地支持不可变性。
- en: 'In the bytecode, we can see that finality fields shows up as a piece of field
    metadata as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在字节码中，我们可以看到final字段作为以下字段元数据出现：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Trying to use immutable approaches to state in Java is bailing out a leaking
    boat. Every single reference has to be checked for mutability, and if even one
    is missed, then the entire object graph is mutable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在Java中使用不可变状态的方法就像是在救一个正在漏水的船。必须检查每个引用的可变性，如果遗漏任何一个，那么整个对象图都是可变的。
- en: 'Worse still, the JVM’s reflection and other subsystems also provide ways to
    circumvent immutability, as shown next:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，JVM的反射和其他子系统也提供了绕过不可变性的方法，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Taken together, all of this means that neither Java nor the JVM is an environment
    that provides any particular support for programming with immutable data. Languages
    like Clojure, which have stronger requirements, end up having to do a lot of the
    work in their language-specific runtime.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这意味着Java和JVM都不是提供任何特定支持以使用不可变数据的编程环境。像Clojure这样的语言，由于有更严格的要求，最终不得不在其语言特定的运行时中做大量工作。
- en: 15.2.3 Higher-order functions
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3 高阶函数
- en: 'The concept of a higher-order function should not be surprising to a Java programmer.
    We have already seen an example of a static method, `makePrefixer()`, that takes
    in a prefix string and returns a function object. Let’s rewrite the code and change
    the static factory into another function object like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数的概念对Java程序员来说不应该令人惊讶。我们已经看到了一个静态方法`makePrefixer()`的例子，它接受一个前缀字符串并返回一个函数对象。让我们重写代码并将静态工厂改为另一个函数对象，如下所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can be a little hard to read at first glance, so let’s include some extra
    bits of syntax that we don’t actually need, to make what’s going on clearer:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始看起来有点难以阅读，所以让我们包括一些实际上不需要的额外语法，以使正在发生的事情更清晰：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this expanded view, we can see that `prefix` is the argument to the function
    and the returned value is a lambda (actually a Java closure) that implements `Function
    <String, String>`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个扩展视图中，我们可以看到`prefix`是函数的参数，返回值是一个lambda（实际上是一个Java闭包），它实现了`Function <String,
    String>`。
- en: 'Notice the appearance of the function type `Function<String, Function<String,
    String>>`—it has two type parameters that define the input and output types. The
    second (output) type parameter is just another type—in this case, it is another
    function type. This is one way to recognize a higher-order function type in Java:
    a `Function` (or other functional type) that has `Function` as one of its type
    parameters.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数类型`Function<String, Function<String, String>>`的出现——它有两个类型参数定义了输入和输出类型。第二个（输出）类型参数只是另一个类型——在这种情况下，它是一个函数类型。这是在Java中识别高阶函数类型的一种方法：一个`Function`（或其他函数类型），其中`Function`是其类型参数之一。
- en: 'Finally, we should point out that language syntax does matter—after all, function
    objects can be created as anonymous implementations, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该指出，语言语法确实很重要——毕竟，函数对象可以作为匿名实现来创建，如下所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code would even have been legal as far back as Java 5, if the `Function`
    type had existed back then (and as far back as Java 1.1, if we remove the annotations
    and generics). But it’s a total eyesore. It’s very hard to see the structure,
    which is why many programmers think of functional programming as arriving only
    with Java 8\.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当时存在`Function`类型（以及如果我们删除注解和泛型，那么至少从Java 1.1开始），这段代码甚至会是合法的。但它非常难看。很难看到结构，这也是为什么许多程序员认为函数式编程只有在Java
    8中才出现。
- en: 15.2.4 Recursion
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4 递归
- en: 'The `javac` compiler provides a straightforward translation of Java source
    code into bytecode. As we can see here, this applies to recursive calls:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`javac`编译器提供了将Java源代码直接转换为字节码的简单翻译。正如我们所见，这适用于递归调用：'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'which compiles to the following bytecode:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下字节码：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This, of course, has some major limitations. In this case, making a call like
    `simpleFactorial(100000)` will result in a `StackOverflowError` because of the
    `invokestatic` call at byte 12, which will cause an additional interpreter frame
    to be placed on the stack for each recursive call.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这有一些主要的限制。在这种情况下，调用`simpleFactorial(100000)`将由于字节12处的`invokestatic`调用而导致`StackOverflowError`，这将为每个递归调用在栈上放置一个额外的解释器帧。
- en: Note A *recursive* method is one that calls itself. A *tail-recursive* method
    is one where the self-call is the last thing that the method does.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一个*递归*方法是指调用自身的方法。一个*尾递归*方法是指自我调用是该方法的最后一件事。
- en: 'Let’s try to find a way to see whether the recursive call could be avoided.
    One approach is to rewrite the factorial code into a tail-recursive form, which
    in Java we can do most easily with a private helper method, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试找到一种方法来查看是否可以避免递归调用。一种方法是将阶乘代码重写为尾递归形式，在Java中，我们可以通过一个私有辅助方法最简单地做到这一点，如下所示：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The entry method, `tailrecFactorial()`, does not do any recursion; it merely
    sets up the tail-recursive call and hides the details of the more complex signature
    from the user. The bytecode for the method is basically trivial, but let’s include
    it for completeness:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 入口方法`tailrecFactorial()`不执行任何递归；它只是设置尾递归调用并隐藏更复杂签名细节。该方法的字节码基本上是微不足道的，但为了完整性，让我们包括它：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, there are no loops and only a single branching `if` at bytecode
    3\. The real action (and the recursion) happens in `helpFact()`. This is still
    compiled by `javac` into bytecode, which contains a recursive call, as we can
    see:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里没有循环，只有字节码3处的单个分支`if`。真正的动作（以及递归）发生在`helpFact()`中。这仍然由`javac`编译成字节码，其中包含递归调用，如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Longs are 8 bytes, so they need two local variable slots each
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 长整型是8字节，因此每个都需要两个局部变量槽
- en: ❷ Returns from the i == 0 path
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从i == 0路径返回
- en: ❸ Tail-recursive call
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 尾递归调用
- en: In this form, however, we can now see that there are two paths through this
    method. The simple `i == 0` path starts at bytecode 0, falls through the `if`
    condition at 3 and returns `j` at bytecode 7\. The more general case is 0 to 3,
    then 8 to 14, which triggers a recursive call.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以这种形式，我们现在可以看到，这个方法中有两条路径。简单的`i == 0`路径从字节码0开始，通过3号字节码处的`if`条件，并在7号字节码处返回`j`。更一般的情况是从0到3，然后从8到14，这会触发一个递归调用。
- en: 'So, on the only path that has a method call on it, the call is recursive and
    always the last thing that happens before the `return`—that is, the call is in
    *tail position*. However, it *could* be compiled into the following bytecode instead,
    which avoids the call:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在只有方法调用的路径上，调用是递归的，并且总是发生在`return`之前最后发生的事情——也就是说，调用处于*尾位置*。然而，它*可以*被编译成以下字节码，从而避免了调用：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Longs are 8 bytes, so they need two local variable slots each
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 长整型是8字节，因此每个都需要两个局部变量槽
- en: ❷ Returns from the i == 0 path
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从i == 0路径返回
- en: ❸ Resets the local variables
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 重置局部变量
- en: ❹ Jumps to the top of the method
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 跳转到方法顶部
- en: 'Now for the bad news: `javac` does not perform this operation automatically,
    despite it being possible. This is yet another example of how the compiler tries
    to translate Java source into bytecode as exactly as possible.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是坏消息的时候了：`javac`不会自动执行这个操作，尽管这是可能的。这又是编译器试图尽可能精确地将Java源代码转换为字节码的另一个例子。
- en: Note In the Resources project that accompanies this book is an example of how
    to use the ASM library to generate a class that implements the previous bytecode
    sequence because `javac` will not emit it from recursive code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本书附带的资源项目中，有一个如何使用ASM库生成实现先前字节码序列的类的示例，因为`javac`不会从递归代码中生成它。
- en: 'For completeness, we should say that, in practice, implementing a factorial
    function that handles longs with recursive calls rather than overwriting frames
    is not actually going to cause a problem, because the factorial increases so quickly
    that it will overflow the available space in a `long` well before any stack size
    limits are reached, as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们应该说，在实践中，实现一个使用递归调用而不是覆盖栈帧来处理长整型的阶乘函数实际上并不会引起问题，因为阶乘增长得如此之快，以至于在达到任何栈大小限制之前，它就会溢出`long`类型可用的空间，如下所示：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So `factorial(21)` is already larger than the largest positive `long` that the
    JVM can express. However, although this specific trivial example is reasonably
    safe, it does not alter the difficult fact that all recursive algorithms in Java
    are potentially vulnerable to stack overflow.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`factorial(21)`已经大于JVM可以表示的最大正`long`值。然而，尽管这个特定的简单例子相对安全，但它并没有改变这样一个困难的事实：Java中所有的递归算法都潜在地容易受到栈溢出的影响。
- en: This specific flaw is one of the Java language—and not of the JVM. Other languages
    on the JVM can, and do, handle this differently, for example, by use of an annotation
    or a keyword. We will see examples of this when we discuss how Kotlin and Clojure
    handle recursion later in the chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的缺陷是Java语言的问题——而不是JVM的问题。JVM上的其他语言可以，并且确实以不同的方式处理这个问题，例如，通过使用注解或关键字。当我们讨论本章后面如何使用Kotlin和Clojure处理递归时，我们将看到这方面的例子。
- en: 15.2.5 Closures
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.5 闭包
- en: 'As we’ve already seen, a closure is essentially a lambda expression that captures
    some visible state from the scope in which the lambda is declared, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，闭包本质上是一个捕获了lambda表达式声明作用域中一些可见状态的lambda表达式，如下所示：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When this runs, it produces, as expected: `Hello 42`. However, if we uncomment
    the line that reassigns the value of `i`, then something different happens: the
    code stops compiling at all.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，它会产生预期的结果：`Hello 42`。然而，如果我们取消注释重新分配`i`值的行，那么会发生不同的事情：代码根本无法编译。
- en: 'To understand why this happens, let’s take a look at the bytecode that the
    code is compiled into. As we’ll see in chapter 17, the bodies of lambda expressions
    in Java are turned into private static methods. In this case, the lambda body
    turns into this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么会发生这种情况，让我们看看代码编译成的字节码。正如我们将在第17章中看到的，Java中lambda表达式的主体被转换为私有静态方法。在这种情况下，lambda体变成了这样：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The clue is in the signature of `lambda$main$0()`. It takes *two* parameters,
    not one. The first parameter is the value of `i` that is passed in—which is 42
    at the time that the closure is created (the second is the `String` parameter
    that the lambda takes when executed). Java closures contain copies of *values*,
    which are bit patterns (whether of primitives or object references) and not *variables*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于`lambda$main$0()`的签名。它接受**两个**参数，而不是一个。第一个参数是传递给闭包的`i`的值——在创建闭包时是42（第二个是当lambda执行时lambda接受的`String`参数）。Java闭包包含值的副本，这些值是位模式（无论是原始类型还是对象引用），而不是**变量**。
- en: Note Java is strictly a *pass-by-value* language—there is no way in the core
    language to *pass-by-reference* or *pass-by-name*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Java是严格**按值传递**的语言——在核心语言中没有方法可以**按引用传递**或**按名称传递**。
- en: 'To see the effect of changes to captured state outside the scope of the closure
    body (or to effect things in other scopes), the captured state must be a mutable
    object, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到在闭包体外部作用域内对捕获状态的变化的影响（或在其他作用域中产生影响），捕获状态必须是一个可变对象，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Reassigning a value to mutable object state works.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将值重新分配给可变对象状态是可行的。
- en: ❷ This would fail to compile.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这将无法编译。
- en: In fact, in earlier versions of Java, only variables that were explicitly marked
    as `final` could have their value captured by Java closures. However, from Java
    8 onward, that restriction was changed to variables that are *effectively final*—variables
    that are used as though they were final, even if they don’t actually have the
    keyword attached to their declaration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在Java的早期版本中，只有显式标记为`final`的变量才能被Java闭包捕获其值。然而，从Java 8开始，这个限制被改为*实际上是final*的变量——即使用起来像final变量一样使用的变量，即使它们实际上没有在声明中附加关键字。
- en: This is actually symptomatic of a deeper problem. The JVM has a shared heap,
    method-private local variables, and a method-private evaluation stack, and that’s
    it. As compared to other languages, neither the JVM nor the Java language has
    the concept of an *environment* or a symbol table, or the ability to pass a reference
    to an entry in one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是更深层次问题的症状。JVM有一个共享的堆、方法私有的局部变量和方法私有的评估栈，仅此而已。与其他语言相比，JVM和Java语言都没有“环境”或符号表的概念，也没有传递一个条目引用的能力。
- en: Non-Java languages on the JVM that do have those concepts are required to support
    them in their language runtime because the JVM does not provide any intrinsic
    support for them. Some programming language theorists, therefore, reach the conclusion
    that what Java provides are not actually true closures, because of the additional
    level of indirection required. A Java programmer must mutate the state of an object
    value, rather than being able to change the captured variable directly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM上运行的非Java语言必须在其语言运行时中支持这些概念，因为JVM不提供对这些概念的任何固有支持。因此，一些编程语言理论家得出结论，Java提供的不完全是真正的闭包，因为需要额外的间接层。Java程序员必须修改对象值的内部状态，而不是能够直接更改捕获的变量。
- en: 15.2.6 Laziness
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.6 懒惰
- en: Java does not provide first-class support for lazy evaluation in the core language
    for ordinary values. However, one interesting place where we can see lazy evaluation
    in use is within the Java Streams API. Appendix B has a refresher on aspects of
    streams, should you require one.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Java在核心语言中不提供对普通值的懒惰评估的一级支持。然而，我们可以看到懒惰评估在Java Streams API中使用的有趣地方。如果你需要的话，附录B有关于流方面的复习内容。
- en: Note Laziness does play a role in some parts of the JVM and its programming
    environment (e.g., aspects of class loading are lazy).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：懒惰确实在JVM及其编程环境的一些部分中扮演着角色（例如，类加载的一些方面是懒惰的）。
- en: Calling `stream()` on a Java collection produces a `Stream` object, which is
    effectively a lazy representation of an ensemble of elements. Some streams can
    also be represented as a Java collection; however, streams are more general and
    not every stream can be represented as a collection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java集合上调用`stream()`会产生一个`Stream`对象，这实际上是一组元素的懒惰表示。一些流也可以表示为Java集合；然而，流更通用，并不是每个流都可以表示为集合。
- en: 'Let’s look again at a typical Java `filter()` and `map()` pipeline:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看典型的Java `filter()`和`map()`管道：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `stream()` method returns a `Stream` object. The `map()` and `filter()`
    methods (like almost all of the operations on `Stream`) are lazy. At the other
    end of the pipeline, we have a `collect()` operation, which *materializes* the
    contents of the remaining `Stream` back into a `Collection`. This *terminal* method
    is eager, so the complete pipeline behaves like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream()` 方法返回一个 `Stream` 对象。`map()` 和 `filter()` 方法（以及几乎所有的 `Stream` 操作）都是懒加载的。在管道的另一端，我们有一个
    `collect()` 操作，它将剩余的 `Stream` 的内容 *实体化* 回一个 `Collection`。这个 *终端* 方法是急切的，因此整个管道的行为如下：'
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Apart from the materialization back into the collection, the platform has complete
    control over how much of the stream to evaluate. This opens the door to a range
    of optimizations that are not available in purely eager approaches.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将数据实体化回集合之外，该平台完全控制着可以评估多少流数据。这为一系列在纯急切方法中不可用的优化打开了大门。
- en: It can sometimes be helpful to think of the lazy, functional mode of Java streams
    as being analogous to hyperspace travel in a science-fiction movie. Calling `stream()`
    is the equivalent of jumping from “normal space” into a hyperspace realm where
    the rules are different (functional and lazy, rather than OO and eager).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将 Java 流的懒加载、函数式模式想象成科幻电影中的超空间旅行可能会有所帮助。调用 `stream()` 等同于从“正常空间”跳入一个规则不同的超空间领域（函数式和懒加载，而不是面向对象和急切）。
- en: At the end of the operational pipeline, a terminal stream operation jumps us
    back from the lazy functional world into “normal space,” either by re-materializing
    the stream into a `Collection` (e.g., via `toList()`) or by aggregating the stream,
    via a `reduce()` or other operation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作管道的末端，一个终端流操作将我们从懒加载的函数式世界跳回到“正常空间”，要么通过将流重新实体化回一个 `Collection`（例如，通过 `toList()`），要么通过
    `reduce()` 或其他操作聚合流。
- en: Use of lazy evaluation does require more care from the programmer, but this
    burden largely falls upon library writers, such as the JDK developers. However,
    a Java developer should be aware of and respect the rules of some aspects of the
    lazy nature of streams. For example, implementations of some of the `java.util.function`
    interfaces (e.g., `Predicate`, `Function`) should not mutate internal state or
    cause side effects. Violating this assumption can cause major problems if developers
    write implementations or lambdas that do.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用懒加载确实需要程序员更加小心，但这种负担在很大程度上落在库编写者，如 JDK 开发者的身上。然而，Java 开发者应该了解并尊重流的一些懒加载特性的规则。例如，一些
    `java.util.function` 接口的实现（例如，`Predicate`、`Function`）不应该改变内部状态或产生副作用。违反这个假设可能会导致开发者编写的实现或
    lambda 表达式出现重大问题。
- en: Another important aspect of streams is that the stream objects themselves (the
    instances of `Stream` that are seen as intermediate objects within a pipeline
    of stream calls) are single shot. Once they have been traversed, they should be
    considered invalid. In other words, developers should not attempt to store or
    reuse a stream object, because the results of doing so are almost certainly incorrect
    and attempts may throw an error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 流的另一个重要方面是流对象本身（在流调用管道中被视为中间对象的 `Stream` 实例）是单次使用的。一旦它们被遍历，就应该认为它们是无效的。换句话说，开发者不应该尝试存储或重用流对象，因为这样做几乎肯定会导致错误，并且可能会抛出异常。
- en: Note Placing a stream object into a temporary variable is almost always a code
    smell, although doing so during development when debugging a complex generics
    issue with a stream is acceptable, provided the use of stream temporaries is removed
    when the code is completed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：将流对象放入临时变量几乎总是代码的坏味道，尽管在开发过程中，当调试与流相关的复杂泛型问题时这样做是可以接受的，前提是在代码完成后移除对流临时变量的使用。
- en: 'One other aspect of the laziness of streams is the ability to model more general
    data than collections. For example, it is possible to construct an infinite stream
    by use of `Stream.generate()` combined with a generating function. Let’s take
    a look:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 流的另一个懒加载特性是能够模拟比集合更通用的数据。例如，可以通过使用 `Stream.generate()` 结合生成函数来构建一个无限流。让我们看一下：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This produces a stream of days that is infinite (or as large as is needed, if
    you prefer). This would be impossible to represent as a collection without running
    out of space, thus showing that streams are more general.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个无限（或者如果你更喜欢，是所需大小）的日数据流。如果没有耗尽空间，这将是无法表示为集合的，从而表明流更加通用。
- en: This example also shows that Java’s restrictions, such as pass by value, restrict
    the design space somewhat. The `LocalDate` class is immutable, and so we are required
    to have a class containing a mutable field `current` and then to mutate `current`
    within the `get()` method to provide a stateful method that can generate a sequence
    of `LocalDate` objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还表明，Java 的限制，例如按值传递，在一定程度上限制了设计空间。`LocalDate` 类是不可变的，因此我们需要有一个包含可变字段 `current`
    的类，然后在 `get()` 方法中修改 `current` 以提供一个具有状态的、可以生成一系列 `LocalDate` 对象的方法。
- en: In a language that supported pass by reference, the type `DaySupplier` would
    have been unnecessary, because `current` could have been a local variable declared
    in the same scope as `tomorrow`, which could then have been a lambda.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持按引用传递的语言中，`DaySupplier` 类型是不必要的，因为 `current` 可以是一个与 `tomorrow` 同作用域的局部变量，而
    `tomorrow` 可以是一个 lambda 表达式。
- en: 15.2.7 Currying and partial application
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.7 柯里化和部分应用
- en: 'We already know that Java does not have any language-level support for currying,
    but we can take a quick look at how something could have been added. For example,
    here is the declaration for the `BiFunction` interface in `java.util.function`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 Java 没有任何语言级别的支持用于柯里化，但我们可以快速看一下如何添加它。例如，以下是 `java.util.function` 中 `BiFunction`
    接口的声明：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice how the default methods feature of interfaces is used to define `andThen()`—an
    additional method, beyond the standard `apply()` method for the `BiFunction`.
    This same technique could have been used to provide some support for currying,
    for example, by defining two new default methods as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意接口的默认方法特性是如何用来定义 `andThen()` 的——一个超出标准 `apply()` 方法的额外方法。同样的技术可以用来提供一些对柯里化的支持，例如，通过定义以下两个新的默认方法：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These define two ways to produce Java `Function` objects, that is, functions
    of one argument from our original `BiFunction`. Notice that they are implemented
    as closures. We’re simply capturing the supplied value and storing it for later,
    when we actually apply the function. We could then use these additional default
    methods like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义了两种生成 Java `Function` 对象的方法，即从我们原始的 `BiFunction` 中产生一个只有一个参数的函数。请注意，它们被实现为闭包。我们只是捕获提供的值并存储起来，以便在真正应用函数时使用。然后我们可以像这样使用这些额外的默认方法：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, the syntax is somewhat clunky: it requires two different methods for
    the two possible currys, and they must have different names due to type erasure.
    Even after all that, the resulting feature is arguably of only limited use, so
    this approach was never implemented, and, as discussed, Java does not support
    currying out of the box.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，语法有些笨拙：它需要两个不同的方法来处理两种可能的柯里化，并且由于类型擦除，它们必须有不同的名称。即使如此，最终的功能可能也只有有限的用途，因此这种方法从未被实现，正如讨论的那样，Java
    并不支持开箱即用的柯里化。
- en: 15.2.8 Java’s type system and collections
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.8 Java 的类型系统和集合
- en: 'To conclude our unfortunate tale about Java’s less-than-great affinity to functional
    programming, let’s talk about Java’s type system and collections. The following
    three main issues with these parts of the Java language contribute to the somewhat
    poor fit to the functional programming style:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们对 Java 对函数式编程不太友好倾向的不幸故事，让我们谈谈 Java 的类型系统和集合。Java 语言这些部分的以下三个主要问题导致了它们与函数式编程风格的某种不匹配：
- en: Non-single-rooted type system
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非单根类型系统
- en: '`void`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`'
- en: Design of the Java Collections
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 集合的设计
- en: First of all, Java has a non-single-rooted type system (i.e., there is no common
    supertype of `Object` and `int`). This makes it impossible to write `List<int>`
    in Java and, as a result, leads to autoboxing and the attendant problems.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Java 有一个非单根类型系统（即没有 `Object` 和 `int` 的公共超类型）。这使得在 Java 中无法编写 `List<int>`，结果导致了自动装箱及其相关问题。
- en: Note Lots of developers complain about the erasure of type parameters of generic
    types during compilation, but in reality, it is more often the non-single-rooted
    type system that really causes problems with generics in the collections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意许多开发者抱怨在编译过程中泛型类型参数的擦除，但事实上，非单根类型系统才是泛型在集合中真正引起问题的原因。
- en: 'Java has another problem, connected to the non-single-rooted type system: `void`.
    This keyword indicates that a method does not return a value (or, looked at another
    way, that the evaluation stack of the method is empty when the method returns).
    The keyword therefore carries the semantics that whatever the method does, it
    is acting purely by side effect—it’s the opposite of “pure” in some sense.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还有一个问题，与非单根类型系统有关：`void`。这个关键字表示方法不返回值（或者从另一个角度来看，当方法返回时，方法的评估栈为空）。因此，这个关键字携带的语义是，无论方法做什么，它都是纯粹通过副作用来执行的——在某种程度上与“纯”相反。
- en: The existence of `void` means that Java has both statements and expressions
    and that it is impossible to implement the design principle, “everything is an
    expression,” which some functional programming traditions are very keen on.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`void` 的存在意味着 Java 既有语句也有表达式，因此不可能实现设计原则，“一切皆表达式”，这是某些函数式编程传统非常热衷的。'
- en: Note In chapter 18, we will discuss Project Valhalla, which provides an opportunity
    for the Java language designers to potentially revisit the non-single-rooted nature
    of Java’s type system (among other goals).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第 18 章中，我们将讨论瓦尔哈拉项目，该项目为 Java 语言设计者提供了一个机会，可能重新审视 Java 类型系统的非单根特性（以及其他目标）。
- en: Another problem is related to the shape and nature of the Java Collections interfaces.
    They were added to the Java language with version 1.2 (aka Java 2), which was
    released in December 1998\. They were not designed with functional programming
    in mind.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题与 Java 集合接口的形状和本质有关。它们是在 Java 1.2 版本（也称为 Java 2）中添加到 Java 语言的，该版本于 1998
    年 12 月发布。它们并不是以函数式编程为设计初衷。
- en: 'A major problem for doing FP with the Java Collections is that an assumption
    of mutability is built in everywhere. The Collections interfaces are large and
    explicitly contain methods like these from `List<E>`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Java 集合进行函数式编程时，一个主要问题是到处都内置了可变性的假设。集合接口很大，并且明确包含来自 `List<E>` 的这些方法：
- en: '`boolean add(E e)`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean add(E e)`'
- en: '`E remove(int index)`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E remove(int index)`'
- en: These are mutation methods—the signature of them implies that the Collection
    object itself has been modified in place.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是修改方法——它们的签名暗示了集合对象本身在原地被修改。
- en: The corresponding methods on an immutable list would have signatures such as
    `List<E> add(E e)` that return a new, modified copy of the list. The case of `remove()`
    would be difficult to implement, because Java doesn’t have the ability to return
    multiple values from a method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可变列表的相应方法会有这样的签名：`List<E> add(E e)`，它们返回一个新的、修改后的列表副本。`remove()` 的情况很难实现，因为
    Java 没有从方法中返回多个值的能力。
- en: Note The real problem is that `remove()` is incorrectly factored for FP, a very
    similar case to that of the `Iterator` that we discussed in section 10.4.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：真正的问题是 `remove()` 方法在函数式编程（FP）中的实现是错误的，这与我们在第 10.4 节中讨论的 `Iterator` 的情况非常相似。
- en: All of this therefore implies that *any* implementation of the Collections is
    implicitly expected to be mutable. There does exist the horrible hack of using
    `UnsupportedOperationException`, which we discussed in section 6.5.3, but this
    is not something that a well-grounded Java developer should use.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有这些都暗示了 *任何* 集合的实现都隐式地期望是可变的。确实存在使用 `UnsupportedOperationException` 的可怕技巧，我们在第
    6.5.3 节中讨论过，但这不是一位扎实的 Java 开发者应该使用的东西。
- en: Other, non-Java languages separate out the concept of the collection type from
    mutability, for example, by representing them as different interfaces (or different
    *traits* in languages that support that concept). This enables implementations
    to specify whether or not they are mutable at type level, by choosing to implement—or
    not—the separate interfaces.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其他非 Java 语言将集合类型的概念与可变性分开，例如，通过将它们表示为不同的接口（或在支持该概念的语言中将它们表示为不同的 *特质*）。这使得实现可以指定它们是否在类型级别上是可变的，通过选择实现或不实现这些单独的接口。
- en: Lurking behind all of this is that one of Java’s main virtues and most important
    design principles is backward compatibility. This makes it difficult, or impossible,
    to change some of these aspects to make the language more functional. For example,
    in the case of the Collections, rather than try to add additional, functional
    methods directly onto the Collections interfaces, a clean break was made and `Stream`
    was introduced, to act as a new container type that did not have the implicit
    semantics of the Collections.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些背后，Java的主要优点和最重要的设计原则之一是向后兼容性。这使得改变这些方面以使语言更具函数性变得困难，甚至不可能。例如，在集合的案例中，而不是直接尝试在集合接口上添加额外的函数式方法，我们采取了彻底的突破，引入了`Stream`，作为一种新的容器类型，它不具有集合的隐式语义。
- en: Of course, just introducing a new container type and API does nothing to change
    the millions upon millions of lines of existing code that use the collections.
    Nor does it help in the slightest for the common case where an API is already
    expressed in terms of a collection type.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅引入一个新的容器类型和API并不能改变数百万行使用集合的现有代码。对于API已经以集合类型表达的情况，这也没有丝毫帮助。
- en: Note This problem is not unique to the stream/collection divide. For example,
    Java Reflection was introduced in Java 1.1 and predates the arrival of the Collections.
    As a result, the API is annoyingly difficult to use, because it relies upon arrays
    as element containers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这个问题并不仅限于流/集合的划分。例如，Java反射是在Java 1.1中引入的，早于集合的出现。因此，API的使用非常令人烦恼，因为它依赖于数组作为元素容器。
- en: This section has shown some rather depressing facts about the state of support
    for functional programming in Java. The takeaway message is that simple functional
    patterns (such as filter-map-reduce) are available. These are very useful for
    all sorts of applications as well as generalizing well to concurrent (and even
    distributed) applications, but they are about the limit of what Java is able to
    do. Let’s move on to look at our non-Java languages and see if the news is any
    better.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了关于Java中函数式编程支持状态的几个相当令人沮丧的事实。主要信息是，简单的函数式模式（如filter-map-reduce）是可用的。这些模式对于各种应用以及很好地推广到并发（甚至分布式）应用都非常有用，但它们几乎就是Java能够做到的极限。让我们继续看看我们的非Java语言，看看情况是否有所改善。
- en: 15.3 Kotlin FP
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 Kotlin FP
- en: We’ve already demonstrated how modern Java handles some basic, common patterns
    in the functional programming paradigm. It probably comes as no surprise that
    Kotlin brings conciseness and a few additional ideas to the table for the functionally
    inclined.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了现代Java如何处理函数式编程范式中的某些基本、常见模式。对于倾向于函数式编程的人来说，Kotlin带来了简洁性和一些额外的想法，这或许并不令人意外。
- en: This section will hit the high points, but take a look at *Functional Programming
    in Kotlin* by Marco Vermeulen, Rúnar Bjarnason, and Paul Chiusano (Manning, 2021,
    [http://mng.bz/o2Wr](http://mng.bz/o2Wr)) if you want to go even deeper.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将概述要点，但如果你想要更深入地了解，可以查阅Marco Vermeulen、Rúnar Bjarnason和Paul Chiusano合著的《Kotlin函数式编程》（Manning,
    2021，[http://mng.bz/o2Wr](http://mng.bz/o2Wr)）。
- en: 15.3.1 Pure and higher-order functions
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 纯函数和高级函数
- en: Back in section 9.2.4, we introduced Kotlin’s functions. In Kotlin, functions
    are part of the type system, expressed with syntax like `(Int) -> Int`, where
    the contents of the parenthesized list are the argument types and to the right
    of the arrow is the return type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在9.2.4节中，我们介绍了Kotlin的函数。在Kotlin中，函数是类型系统的一部分，使用如`(Int) -> Int`这样的语法表示，其中括号列表的内容是参数类型，箭头右边是返回类型。
- en: By using this notation, we can easily write signatures for functions that accept
    other functions as arguments or return a function—that is, *higher-order functions*.
    Kotlin naturally encourages the use of such higher-order functions. Much of the
    API around working with collections such as `map` and `filter` are in fact built
    off these higher-order functions, just as we see in the Java (and Clojure) APIs
    that provide the equivalent language feature.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种表示法，我们可以轻松地为接受其他函数作为参数或返回函数的函数编写签名——即*高级函数*。Kotlin自然鼓励使用这样的高级函数。实际上，围绕`map`和`filter`等处理集合的API的大部分API都是基于这些高级函数构建的，正如我们在提供等效语言特征的Java（和Clojure）API中所看到的那样。
- en: 'But higher-order functions aren’t restricted to collections and streams. For
    instance, here’s a classic functional programming function called `compose`. `compose`
    will return a function that calls each of the functions passed as arguments to
    it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但高阶函数不仅限于集合和流。例如，这里有一个经典的函数式编程函数称为`compose`。`compose`将返回一个函数，该函数将调用传递给它作为参数的每个函数：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ compose returns a function, so callFirst and callSecond aren’t called when
    this line executes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ compose返回一个函数，所以当此行执行时，callFirst和callSecond不会被调用。
- en: ❷ We pass two lambdas, using the it shorthand described in chapter 9 to avoid
    explicitly listing the single argument to the lambdas.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们传递两个lambda，使用第9章中描述的it简写来避免显式列出lambda的单个参数。
- en: ❸ We invoke and run the function returned by compose, which returns 30.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们调用并运行由compose返回的函数，该函数返回30。
- en: 'Kotlin provides a number of ways to get a handle to a function, depending on
    your needs. You can declare lambda expressions as shown earlier (and with many
    other flavors and features discussed in chapter 9). Alternatively, we can refer
    to a named function via the `::` syntax as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin提供了多种方式来获取函数的引用，具体取决于你的需求。你可以像之前那样声明lambda表达式（以及第9章中讨论的许多其他风味和功能）。或者，我们可以通过以下方式通过`::`语法引用命名函数：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Same result as our prior example
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与我们之前的示例结果相同
- en: '`::` knows more than just top-level functions. It can also refer to a function
    belonging to a specific object instance like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`::`不仅知道顶级函数。它还可以引用属于特定对象实例的函数，如下所示：'
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ References the apply method on the Multiply class bound specifically to our
    instance m.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 引用Multiply类上绑定到特定实例m的apply方法。
- en: Sadly, much like Java, Kotlin provides no built-in way of guaranteeing the purity
    of a given function. Although defining functions at the top level (outside of
    any class) and using `val` to ensure immutable data can take you a long way, they
    don’t ensure the referential transparency of your functions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，与Java类似，Kotlin没有提供内置的方式来保证给定函数的纯度。虽然定义顶级函数（任何类之外）并使用`val`确保不可变数据可以让你走得很远，但它们并不确保函数的引用透明性。
- en: 15.3.2 Closures
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2 闭包
- en: 'An aspect of lambda expressions that may not be obvious on the surface is how
    they interact with the surrounding code. For instance, the following code works,
    even though `local` isn’t declared within our lambda:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式的一个可能表面上不明显方面是它们与周围代码的交互。例如，以下代码可以正常工作，即使`local`没有在我们的lambda中声明：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Prints 0
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印0
- en: 'This is referred to as *closure* (as in, the lambda *closes over* the values
    it can see). Importantly, and unlike Java, it is not just the value of the variables
    the lambda can access—under the covers, it actually keeps a reference to the variables
    themselves, as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*闭包*（即，lambda *捕获*它可以看到的值）。重要的是，与Java不同，它不仅仅是lambda可以访问的变量的值——在幕后，它实际上保留了变量的引用，如下所示：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Prints 0
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印0
- en: ❷ Prints 10, the updated value of local at the time lambda is invoked
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印10，lambda被调用时local的更新值
- en: 'This closure over variables remains even if the variables themselves would
    otherwise have gone out of scope. Here we return a lambda from a function, keeping
    a reference to a variable that normally would be inaccessible:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 即使变量本身在其他情况下已经超出作用域，这种对变量的闭包仍然存在。在这里，我们从函数中返回一个lambda，保持对通常无法访问的变量的引用：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Because our lambda expression closes over inFunction, it is still available
    here—but only inside our lambda.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为我们的lambda表达式捕获了inFunction，所以它在这里仍然可用——但仅限于我们的lambda内部。
- en: ❷ inFunction would normally go out of scope when makeLambda is done.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当makeLambda完成后，inFunction通常会超出作用域。
- en: Note Lambdas carrying references outside their typical scope can be a source
    for unexpected object leaks!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：将引用携带到其典型作用域之外的lambda可能是不期望的对象泄漏的来源！
- en: 'The location of a lambda expression’s declaration determines what it may capture
    in its closure. For instance, if declared within a class, then the lambda can
    close over properties in the object as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式声明的位置决定了它在其闭包中可以捕获的内容。例如，如果在一个类内部声明，那么lambda可以像这样捕获对象中的属性：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ A lambda saved into check closes over the private property amount.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将lambda保存到check中会捕获私有属性amount。
- en: ❷ This function returns that lambda, which keeps a reference to amount. This
    keeps the instance closed alive when normally it wouldn’t exist after the function
    completes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此函数返回该lambda，它保持对amount的引用。这使实例在函数完成后通常不会存在时仍然保持活跃。
- en: ❸ Prints 100 when called. When the check variable exits scope, the closed instance
    will also finally be eligible for garbage collection.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当被调用时打印100。当检查变量退出作用域时，关闭的实例也将最终有资格进行垃圾回收。
- en: Closures with higher-order functions provide a rich basis for building new functions
    from old ones.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数的闭包为从旧函数构建新函数提供了丰富的基础。
- en: 15.3.3 Currying and partial application
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3 Currying和部分应用
- en: 'The currying story for Kotlin is very similar to that in Java. Let’s look at
    an example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的currying故事与Java中的非常相似。让我们看看一个例子：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is really just a syntactic trick that works because the `()` operator desugars
    to a call to the `apply()` method. At bytecode level, this is really just the
    same as the Java example. We could imagine some helper syntax for automatically
    creating curries, perhaps something like
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只是一个语法技巧，因为它的工作原理是`()`运算符将转换为对`apply()`方法的调用。在字节码级别，这实际上与Java示例完全相同。我们可以想象一些辅助语法来自动创建curries，可能类似于
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, the core language does not directly support this. Various third-party
    libraries can provide similar, slightly more verbose abilities, often via an extension
    method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，核心语言并不直接支持这一点。各种第三方库可以提供类似但稍微冗长的功能，通常通过扩展方法来实现。
- en: 15.3.4 Immutability
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.4 不可变性
- en: Section 15.1.2 framed immutability as a key technique for success in functional
    programming. If a pure function returns data that is meant to be identical for
    a given input, allowing an object to change after the fact breaks the guarantees
    that purity bought us.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 15.1.2节将不可变性描述为函数式编程成功的关键技术。如果一个纯函数返回的数据对于给定的输入应该是相同的，那么允许对象事后改变就破坏了纯度为我们带来的保证。
- en: A primary feature of Kotlin that aids in our quest for immutability is the `val`
    declaration. `val` ensures a property may be written only during object construction,
    much like Java’s `final`. In fact, `val` is effectively the same as Java’s `final
    var` combination, but is also applicable to properties and much less awkward to
    write.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin帮助我们追求不可变性的一个主要特性是`val`声明。`val`确保属性只能在对象构造期间写入，就像Java的`final`一样。事实上，`val`实际上是Java的`final
    var`组合，但也可以应用于属性，并且编写起来不那么笨拙。
- en: 'Chapter 9 covers the many locations where Kotlin supports use of `val`/`var`,
    but to succeed in functional programming, it’s recommended to embrace immutability
    and favor `val` over `var`. Kotlin’s built-in support for properties also sweeps
    away the getter boilerplate required in Java, as shown next:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章涵盖了Kotlin支持使用`val`/`var`的许多位置，但要在函数式编程中取得成功，建议拥抱不可变性，并优先使用`val`而不是`var`。Kotlin对属性的内置支持也消除了Java中所需的getter样板代码，如下所示：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A major hangup with immutable objects, though, is the difficulty when you actually
    want to change something. To retain our immutability, we must create entirely
    new instances, but this can be tedious and error prone. In Java, this is often
    tackled with static factory methods, builder objects, or wither methods to cut
    down on the noise.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不可变对象有一个主要的问题，那就是当你实际上想要更改某事时的困难。为了保持我们的不可变性，我们必须创建全新的实例，但这可能既繁琐又容易出错。在Java中，这通常通过静态工厂方法、构建器对象或wither方法来解决，以减少噪音。
- en: 'Kotlin’s `data class` construct gives us a nice alternative to those approaches.
    In addition to the constructor and equality operations we covered in section 9.3.1,
    a data class also gets a `copy` method. Pairing `copy` with Kotlin’s named arguments,
    you can generate the new instance we want, writing out only the changes you actually
    want, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的`data class`结构为我们提供了对这些方法的良好替代方案。除了我们在9.3.1节中提到的构造函数和相等性操作之外，data类还获得了一个`copy`方法。将`copy`与Kotlin的命名参数配对，你可以生成我们想要的新的实例，只写出你实际想要更改的部分，如下所示：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`copy` does come with a couple important caveats. First, it is a shallow copy.
    If one of our fields is an object, we copy the reference to that object, not the
    full object itself. Like in Java, if any of the chain of objects allows mutation,
    then our guarantees are broken. For true immutability, all the objects involved
    need to play along, but the language will not enforce it for you.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`确实有几个重要的注意事项。首先，它是一个浅拷贝。如果我们的字段之一是一个对象，我们复制的是对该对象的引用，而不是整个对象本身。就像在Java中，如果对象链中的任何一个允许修改，那么我们的保证就会被打破。为了实现真正的不可变性，所有涉及的对象都需要配合，但语言不会为你强制执行。'
- en: 'Another point of caution is that `copy` is generated from the constructor of
    the class alone. If we bend our rules and put `var` fields elsewhere on our objects,
    `copy` doesn’t know about these additional fields, and they get default values
    only in any copy, as shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的问题是，`copy` 仅从类的构造函数生成。如果我们改变规则，在对象的其他地方放置 `var` 字段，`copy` 就不知道这些额外的字段，它们在复制时只会获得默认值，如下所示：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Outputs false, because the non constructor fields aren’t touched by copy
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 输出为 false，因为非构造函数字段没有被复制操作触及
- en: But we’d never let a mutable field sneak into our nice immutable objects to
    begin with, right?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们一开始就绝不允许可变字段悄悄地进入我们美好的不可变对象中，对吧？
- en: Controlling the mutability of our objects is an important first step, but most
    nontrivial code will involve collections of objects, not just individual instances.
    We saw in chapter 9 that Kotlin’s functions for constructing collections (e.g.,
    `listOf`, `mapOf`) return interfaces such as `kotlin.collections.List` and `kotlin.collections.Map`,
    which, unlike their counterparts in `java.util`, are read-only. Sadly, although
    this is a good start, it doesn’t provide us the guarantees we want.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 控制我们对象的可变性是一个重要的第一步，但大多数非平凡代码将涉及对象集合，而不仅仅是单个实例。在第 9 章中，我们了解到 Kotlin 构建集合的函数（例如，`listOf`、`mapOf`）返回接口，如
    `kotlin.collections.List` 和 `kotlin.collections.Map`，与 `java.util` 中的对应物不同，它们是只读的。遗憾的是，尽管这是一个好的开始，但它并没有提供我们想要的保证。
- en: 'We can’t trust the immutability of these objects because the mutable interfaces
    extend the read-only flavors. Anywhere you can pass a `List`, you can pass a `MutableList`
    as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法信任这些对象的不可变性，因为可变接口扩展了只读特性。任何可以传递 `List` 的地方，你都可以按照以下方式传递 `MutableList`：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`takesList` receives the same object in both invocations, but the result of
    the call is different. Our functionality purity is shattered!'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`takesList` 在两次调用中都接收了相同的对象，但调用结果却不同。我们的功能纯净性被破坏了！'
- en: Note The read-only helpers like `listOf` use underlying JDK collections and
    return objects that are read-only. For instance, `listOf` defaults to an array-backed
    list implementation that cannot be added to. It’s just the mix of Kotlin’s mutable
    interfaces with the standard read-only interfaces that spoil the party.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：只读辅助工具如 `listOf` 使用底层的 JDK 集合，并返回只读的对象。例如，`listOf` 默认使用数组支持的列表实现，无法添加元素。正是
    Kotlin 的可变接口与标准只读接口的混合，破坏了整个局面。
- en: 'Implementing these collections via JDK classes also leaves some sharp edges
    if you cast between interfaces. Kotlin’s aim for clean interoperation with Java
    Collections means the result from `listOf()` can be cast to both Kotlin’s mutable
    interfaces and the classic `java.util.List<T>` where we can attempt to modify
    the collection! The following code compiles without a complaint but fails at runtime:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 JDK 类实现这些集合也会在接口之间进行类型转换时留下一些锋利的边缘。Kotlin 与 Java 集合的干净交互目标是，`listOf()` 的结果可以转换为
    Kotlin 的可变接口和经典的 `java.util.List<T>`，在那里我们可以尝试修改集合！以下代码在编译时没有问题，但在运行时失败：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ This call will throw a java.lang.UnsupportedOperationException.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此调用将抛出 `java.lang.UnsupportedOperationException`。
- en: This lack of real immutability becomes problematic especially when we’re talking
    about concurrency. As we saw in chapter 6, making mutable collections safe between
    multiple threads takes quite an effort. If we had a collection instance that was
    truly immutable, though, that could be freely distributed among different threads
    of execution, assured that everyone is getting an identical picture of the world.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这种真正的不可变性缺失在讨论并发时变得尤为成问题。正如我们在第 6 章中看到的，在多个线程之间使可变集合安全需要相当大的努力。如果我们有一个真正不可变的集合实例，那么它可以自由地在不同的执行线程之间分发，确保每个人都能得到一个相同的世界图景。
- en: Although Kotlin doesn’t have them in the standard library, the `kotlinx.collections
    .immutable` library (see [http://mng.bz/nNjg](http://mng.bz/nNjg)) provides a
    variety of immutable and *persistent* data structures. Frequently seen libraries
    such as Guava and Apache Commons also have many similar options.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kotlin标准库中没有这些，但 `kotlinx.collections.immutable` 库（见 [http://mng.bz/nNjg](http://mng.bz/nNjg)）提供了各种不可变和
    *持久* 数据结构。常见的库如 Guava 和 Apache Commons 也提供了许多类似选项。
- en: 'What does it mean for a collection to be persistent? As we’ve discussed multiple
    times, immutability means that when you need to “change” an object, you instead
    create a new instance of it. For large collections, this could be really inefficient.
    Persistent collections lean on immutability to lower that cost of modification—they
    are built to safely share immutable parts of their internal storage. Though you
    still create a new object to effect any change, those new objects can be much
    smaller than a full copy, as shown next:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个集合来说，持久性意味着什么？正如我们多次讨论的那样，不可变性意味着当你需要“更改”一个对象时，你实际上创建了一个新的实例。对于大型集合，这可能会非常低效。持久集合依赖于不可变性来降低修改的成本——它们被构建为安全地共享其内部存储的不可变部分。尽管你仍然创建一个新的对象来实施任何更改，但这些新对象可以比完整复制小得多，如下所示：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Prints [1, 2, 3]
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印 [1, 2, 3]
- en: ❷ Prints [1, 2, 3, 4]
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印 [1, 2, 3, 4]
- en: The core of the library implements two groups of interfaces typified by `ImmutableList`
    and `PersistentList`. Matching pairs exist for maps, sets, and general collections
    as well. `ImmutableList` extends `List`, but unlike its base interface, it guarantees
    any instance is immutable. `ImmutableList` can then be used in any locations where
    you’re passing lists and want to enforce immutability. `PersistentList` builds
    off of `ImmutableList` to provide us with the “modify and return” methods.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆的核心实现了两组接口，分别以 `ImmutableList` 和 `PersistentList` 为代表。对于映射、集合和通用集合也存在匹配对。`ImmutableList`
    扩展了 `List`，但与它的基接口不同，它保证任何实例都是不可变的。`ImmutableList` 可以在任何需要传递列表并强制不可变性的地方使用。`PersistentList`
    建立在 `ImmutableList` 之上，为我们提供了“修改并返回”的方法。
- en: 'The library also includes the following familiar extensions for converting
    other collections into persistent versions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 该库还包括以下熟悉的扩展，用于将其他集合转换为持久版本：
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At this point, you might be wondering why we don’t change every `listOf` to
    `persistentListOf` “just in case.” But these aren’t the default implementation
    for a reason. Although persistent data structures lower the cost of copies, they
    still can’t touch the speed of classic mutable data structures. Less copying *does
    not* equal no copying! How much does this cost?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会想知道为什么我们不将每个 `listOf` 改为 `persistentListOf` 以防万一。但它们并不是默认实现的原因。尽管持久数据结构降低了复制的成本，但它们仍然无法触及经典可变数据结构的速度。更少的复制*并不等于没有复制！这要付出多少代价？
- en: As chapter 7 has hopefully convinced you, the only way to know is to measure
    in your own use cases. But if you need concurrent access to a collection across
    threads, it’s worth comparing how these persistent structures perform versus more
    standard copying with synchronization. Now that we have Kotlin’s toolkit for making
    data immutable in hand, let’s look at a feature it brings to the world of recursive
    functions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如同第7章所希望说服你的那样，唯一的方法是在你自己的用例中进行测量。但如果你需要在多个线程之间对集合进行并发访问，那么比较这些持久结构与更标准的带有同步的复制性能是值得的。现在我们已经有了Kotlin的工具包，可以用来使数据不可变，让我们看看它为递归函数世界带来的一个特性。
- en: 15.3.5 Tail recursion
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.5 尾递归
- en: 'In section 15.2.4, we examined recursive functions in Java. They have a major
    limitation because each successive recursive function call adds a stack frame,
    which eventually exhausts the available space. Kotlin has the same limitation
    with basic recursion, as we can see from the translation of our `simpleFactorial`
    function to Kotlin (note the use of a Kotlin `if` expression as the return value):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15.2.4节中，我们探讨了Java中的递归函数。它们有一个主要的限制，因为每个连续的递归函数调用都会添加一个栈帧，最终耗尽可用空间。从我们将 `simpleFactorial`
    函数翻译成Kotlin（注意Kotlin `if` 表达式作为返回值的使用）中可以看出，Kotlin也有同样的限制：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This yields the following bytecode, which is equivalent to what `javac` emitted
    for our Java function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下字节码，这与 `javac` 为我们的Java函数生成的字节码等效：
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Apart from a little additional validation (byte 12) and the use of a `goto`
    instead of multiple `lreturn` instructions, this is fundamentally the same. The
    recursive call at byte 18 where we `invokevirtual` on `simpleFactorial` will eventually
    blow the stack, as shown here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了额外的验证（字节12）和用 `goto` 代替多个 `lreturn` 指令之外，这基本上是相同的。在字节18处的递归调用，我们在 `simpleFactorial`
    上调用 `invokevirtual`，最终会崩溃，如下所示：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Although this problem is unavoidable in the general case, Kotlin can help us
    out if our function is tail-recursive. Remember that a tail-recursive function
    is one where the recursion is the last operation in the entire function. Earlier,
    we showed how at the bytecode level we could reset state and `goto` the top of
    the function instead of adding a stack frame. This transforms our recursive call
    into a loop, with no danger of overflowing the stack. Java didn’t provide us any
    way to do this, but Kotlin does.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在一般情况下这个问题是不可避免的，但如果我们的函数是尾递归的，Kotlin 可以帮助我们解决问题。记住，一个尾递归函数是指递归是整个函数中的最后一个操作。之前，我们展示了如何在字节码级别重置状态并`goto`函数的顶部，而不是添加一个栈帧。这把我们的递归调用转换成了一个循环，没有任何栈溢出的风险。Java
    没有提供任何方法来做这件事，但 Kotlin 可以。
- en: Note Any recursive function can be rewritten to be tail-recursive. It may require
    additional parameters, variables, and tricks to do the transformation, but it
    is always possible. Given that tail-recursive functions can be transformed into
    simple looping, this shows that any recursive function can also be implemented
    iteratively using only loop constructs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：任何递归函数都可以重写为尾递归。这可能需要额外的参数、变量和技巧来完成转换，但总是可能的。鉴于尾递归函数可以被转换为简单的循环，这表明任何递归函数也可以仅使用循环结构迭代实现。
- en: 'Getting our factorial recursive call into the final position takes a little
    shuffling. As in Java, we split the function to retain the nice single-argument
    form for users and put the more complicated recursive function—which now needs
    multiple arguments—into a separate function like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的阶乘递归调用放到最终位置需要一点调整。就像 Java 一样，我们拆分了函数，以保留对用户友好的单参数形式，并将更复杂的递归函数——现在需要多个参数——放入一个单独的函数中，如下所示：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Our helper is marked tailrec so Kotlin knows to look for tail recursion.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的帮助函数被标记为 `tailrec`，这样 Kotlin 就知道要寻找尾递归。
- en: 'The entry function `tailrecFactorial` doesn’t hide any surprises in the bytecode.
    It does our beginning range check and then hands off to our tail-recursive helper
    as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 入口函数 `tailrecFactorial` 在字节码中没有任何惊喜。它执行了我们的起始范围检查，然后按照以下方式将任务转交给我们的尾递归辅助函数：
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Bytes 0–3 check for an early return implemented by bytes 6–7\. If we need to
    make the recursive call, then it loads up the values needed to `invokevirtual`
    for `helpFact` at byte 16.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 字节 0–3 检查通过字节 6–7 实现的早期返回。如果我们需要执行递归调用，那么它会在字节 16 加载执行 `invokevirtual` 对 `helpFact`
    所需的值。
- en: 'The important difference the `tailrec` keyword introduces shows up in the bytecode
    for `helpFact`, shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`tailrec` 关键字引入的重要区别在 `helpFact` 的字节码中体现出来：'
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The majority of this method is doing the logical checks and arithmetic of our
    factorial, but the key is at byte 23\. Instead of doing an `invokevirtual` for
    `helpFact` to recurse, instead we simply `goto 0` and start the function again.
    With no invoke instructions present, we have no danger of stack overflows, which
    is great news. Who says `goto` is always hazardous?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的大部分工作是在进行阶乘的逻辑检查和算术运算，但关键在于字节 23。我们不是通过 `invokevirtual` 对 `helpFact` 进行递归调用，而是简单地
    `goto 0` 并重新开始函数。由于没有调用指令，我们没有任何栈溢出的风险，这是一个好消息。谁说 `goto` 总是危险的？
- en: 'Tail recursion is an elegant solution when your function can be rewritten in
    the proper form. But what if you ask for it on a function that isn’t tail-recursive,
    as shown next:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的函数可以被重写为适当的形式时，尾递归是一个优雅的解决方案。但如果你要求一个不是尾递归的函数具有尾递归，情况会怎样呢？如下所示：
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Inappropriately asking for tailrec when our final call isn’t ourselves—in
    this case, the final operation is the * on the result of the recursive call.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当我们的最终调用不是我们自己时，不恰当地请求 `tailrec`——在这种情况下，最终操作是递归调用结果上的 `*`。
- en: 'Kotlin spots the problem and warns us that it can’t transform the bytecode
    to take advantage of tail recursion, pointing us straight to our incorrect, not-at-the-end
    call like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 发现了问题，并警告我们它无法将字节码转换为利用尾递归的优势，直接指向我们的错误调用，如下所示：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Issuing a warning is not an especially strong behavior for the compiler because
    it’s possible that after a tail-recursive implementation has been created, it
    can be subsequently subtly modified to *not* be tail-recursive. Unless the build
    process flags the warning, this code can escape into production and cause a `StackOverflowError`
    at runtime. Arguably, it would be better if declaring a non-tail-recursive function
    as `tailrec` caused a compilation error, as is done in some other languages (e.g.,
    Scala).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器来说，发出警告并不是一种特别强烈的行为，因为可能在一个尾递归实现创建之后，它可以被随后微妙地修改为**不是**尾递归。除非构建过程标记了警告，否则这段代码可能会逃逸到生产环境中，并在运行时引发
    `StackOverflowError`。可以说，如果像某些其他语言（例如 Scala）那样，将非尾递归函数声明为 `tailrec` 导致编译错误会更好。
- en: 15.3.6 Lazy evaluation
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.6 懒评估
- en: As we mentioned earlier in the chapter, many functional languages (such as Haskell)
    rely heavily on *lazy evaluation*. As a language on the JVM, Kotlin doesn’t center
    lazy evaluation in its core execution model. But it does bring first-class support
    for laziness where you want it via the `Lazy<T>` interface. This provides a standard
    structure for when you want to delay—or potentially skip entirely—a bit of processing.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面提到的，许多函数式语言（如 Haskell）严重依赖于**懒评估**。作为 JVM 上的语言，Kotlin 并没有在其核心执行模型中将懒评估作为中心。但它确实通过
    `Lazy<T>` 接口提供了对懒性的第一级支持。这为当你想要延迟——或者可能完全跳过——一些处理时提供了一个标准结构。
- en: 'Typically you don’t implement `Lazy<T>` yourself, but instead use the `lazy()`
    function to construct instances. In the simplest form, `lazy()` takes a lambda,
    the return type of which determines the type `T` of the returned interface. The
    lambda is not executed until `value` is explicitly requested. We can also check
    whether we’ve calculated the value already as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不会自己实现 `Lazy<T>`，而是使用 `lazy()` 函数来构建实例。在最简单的形式中，`lazy()` 接受一个 lambda，其返回类型决定了返回接口的类型
    `T`。lambda 不会执行，直到显式请求 `value`。我们还可以检查是否已经计算了值，如下所示：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ Checks whether we’re initialized; will report false
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查我们是否已初始化；将报告为假
- en: ❷ Access to value will force our lambda to execute and save the result.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问值将强制我们的 lambda 执行并保存结果。
- en: ❸ Checks whether we’re initialized; will report true
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查我们是否已初始化；将报告为真
- en: 'Our desire to put off unneeded computation may overlap with the need to execute
    across multiple threads. When that happens, `lazy()` takes a `LazyThreadSafetyMode`
    enumeration to help control how that happens. The enum values are `SYNCHRONIZED`
    (the default for `lazy()`), `PUBLICATION`, and `NONE`, described here:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推迟不必要的计算的需求可能与在多个线程上执行的需求重叠。当这种情况发生时，`lazy()` 接受一个 `LazyThreadSafetyMode`
    枚举值来帮助控制这种情况。枚举值包括 `SYNCHRONIZED`（`lazy()` 的默认值）、`PUBLICATION` 和 `NONE`，如下所述：
- en: '`SYNCHRONIZED` uses the `Lazy<T>` instance itself to synchronize execution
    of the initializing lambda.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYNCHRONIZED` 使用 `Lazy<T>` 实例本身来同步初始化 lambda 的执行。'
- en: '`PUBLICATION` instead allows multiple concurrent executions of the initialization
    lambda but saves only the first value seen.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLICATION` 允许多个初始化 lambda 的并发执行，但只保存第一个看到的值。'
- en: '`NONE` skips synchronization, with undefined behavior if accessed concurrently.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NONE` 跳过同步，如果并发访问则行为未定义。'
- en: Note `LazyThreadSafetyMode.NONE` should be used only if you’ve 1) measured that
    synchronization in your lazy instances is an actual performance problem and 2)
    can somehow guarantee you’ll never access the object from multiple threads. The
    other options, `SYNCHRONIZED` and `PUBLICATION`, can be chosen between based on
    whether your use case is sensitive to the initialization lambda running multiple
    times concurrently.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`LazyThreadSafetyMode.NONE` 应该仅在满足以下条件时使用：1) 你已经测量过你的懒实例中的同步确实是一个性能问题，2)
    你能以某种方式保证你永远不会从多个线程访问该对象。其他选项 `SYNCHRONIZED` 和 `PUBLICATION` 可以根据你的用例是否对初始化 lambda
    并发运行多次敏感来选择。
- en: 'The `Lazy<T>` interface is designed to work with another advanced Kotlin feature
    called *delegated properties*. When defining a property on a class, instead of
    providing the value or a custom getter/setter, you can instead provide an object
    with the `by` keyword. That object must have an implementation of `getValue()`
    and (for `var` properties) `setValue()`. `Lazy<T>` fits this specification, as
    shown next, so we can easily put off initializing properties in our classes without
    repeating boilerplate or veering away from natural Kotlin syntax:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy<T>` 接口是为了与另一个高级Kotlin特性配合使用，即 *委托属性*。当在类上定义属性时，我们不仅可以提供值或自定义的getter/setter，还可以提供一个带有
    `by` 关键字的对象。该对象必须实现 `getValue()` 和（对于 `var` 属性）`setValue()`。`Lazy<T>` 符合这一规范，如下所示，因此我们可以轻松地将类的属性初始化推迟，而无需重复样板代码或偏离自然的Kotlin语法：'
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Diagnostic message to make it easier to prove everything works
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 诊断信息，以便更容易证明一切正常工作
- en: ❷ The first call to theWork will run the lambda and print the working message.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一次调用 theWork 将运行lambda并打印工作信息。
- en: ❸ Further calls to theWork, as seen on the two concluding lines, will just return
    the same, already-calculated value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如最后两行所示，后续对 theWork 的调用将只返回相同的、已经计算出的值。
- en: Much like immutability, laziness is excellent for our own objects but leaves
    us wondering about collections and iteration. Next we’ll look at how Kotlin allows
    us to better control the flow of execution when streaming through collections
    with the `Sequence<T>` interface.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与不可变性一样，惰性非常适合我们自己的对象，但让我们对集合和迭代感到困惑。接下来，我们将看看Kotlin如何通过 `Sequence<T>` 接口允许我们更好地控制通过集合流式传输时的执行流程。
- en: 15.3.7 Sequences
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.7 序列
- en: 'Although Kotlin’s collection functions are frequently convenient, they assume
    we will eagerly apply the function to the entire collection. An intermediate collection
    is created for each step in our chain of functions, as shown next—potentially
    a waste if we don’t actually need the whole result:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kotlin的集合函数通常很方便，但它们假设我们会急切地对整个集合应用该函数。在我们的函数链中的每一步都会创建一个中间集合，如下所示——如果我们实际上不需要整个结果，这可能会造成浪费：
- en: '[PRE54]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ Generates an intermediate collection with [“1”, “2”, “3”]
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成包含 [“1”，“2”，“3”] 的中间集合
- en: ❷ Generates an intermediate collection with [“11”, “22”, “33”]
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成包含 [“11”，“22”，“33”] 的中间集合
- en: ❸ Generates our final result of [11, 22, 33]
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成我们的最终结果 [11, 22, 33]
- en: If we follow the execution via figure 15.1, we can see each step of our chain
    of `map` calls happens on the full list before the next `map` runs.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过图15.1跟踪执行过程，我们可以看到我们的 `map` 调用链中的每一步都是在下一个 `map` 运行之前对整个列表进行的。
- en: '![](../Images/CH15_F01_Evans2.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH15_F01_Evans2.png)'
- en: Figure 15.1 Standard iteration through collections
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 标准集合迭代
- en: 'This results in the following output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下输出：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Beyond the possibility for wasted resources, there are also use cases where
    our inputs are potentially infinite. What if we wanted to continue this mapping
    across as many numbers as we can until the user tells us to stop? We can’t create
    the list ahead of time and process the full thing step by step.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可能浪费资源的情况外，还有一些用例中我们的输入可能是无限的。如果我们想继续映射尽可能多的数字，直到用户告诉我们停止，我们无法提前创建列表并逐步处理整个内容。
- en: To handle this, Kotlin has *sequences*. At the core of sequences is the interface
    `Sequence<T>`, which looks similar to `Iterable<T>` but under the covers gives
    us a whole new set of capabilities.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，Kotlin有 *序列*。序列的核心是 `Sequence<T>` 接口，它看起来与 `Iterable<T>` 类似，但在底层提供了全新的功能集。
- en: 'We can create a new sequence using the `sequenceOf()` function and then start
    applying functions just like the collections we’re used to. In the following example,
    we’ve turned our list into a sequence and kept the diagnostic prints so we can
    see what’s going on:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `sequenceOf()` 函数创建一个新的序列，然后开始应用我们熟悉的函数。在以下示例中，我们将列表转换为序列，并保留了诊断打印，以便我们可以看到正在发生什么：
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Note that + here is string concatenation, not numeric addition.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意，这里的 + 表示字符串连接，而不是数值相加。
- en: 'When we run this short program we’ll find that nothing prints. The primary
    feature of sequences is that they are lazy in their evaluation. Nothing in this
    program actually requires the return of our `map` calls, so Kotlin just doesn’t
    run them! If we turn the sequence into a list using the following code, though,
    the program will be forced to evaluate everything and we can see how the control
    flow of the sequence runs:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个简短的程序时，我们会发现没有任何打印输出。序列的主要特性是它们在评估上是惰性的。这个程序中实际上没有任何内容需要返回我们的 `map` 调用，所以
    Kotlin 不会运行它们！不过，如果我们使用以下代码将序列转换为列表，程序将被迫评估一切，我们可以看到序列的控制流是如何运行的：
- en: '[PRE57]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can see in figure 15.2 that each element of the sequence goes through the
    `map` chain individually, first `1`, then `2`, and so on, before the next element
    is processed.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图15.2中看到序列的每个元素都单独经过 `map` 链，首先是 `1`，然后是 `2`，依此类推，在处理下一个元素之前。
- en: '![](../Images/CH15_F02_Evans2.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH15_F02_Evans2.png)'
- en: Figure 15.2 Sequence execution
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 序列执行
- en: 'This will have the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is interesting, but on relatively small, static lists, probably not that
    compelling—proper measurement is deserved, but the bookkeeping that sequences
    require may well drown out the wins for not allocating intermediate collections.
    The power of sequences becomes clearer with the alternative ways of creating sequences.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，但在相对较小、静态的列表上，可能并不那么吸引人——适当的测量是应得的，但序列所需的簿记可能会抵消不分配中间集合的收益。序列的力量在创建序列的替代方法中变得更加明显。
- en: Our first stop is the `asSequence()` function. This will, unsurprisingly, turn
    things that are iterable into a sequence. The function works with more than just
    the lists and collections you might expect, though, and may be called on *ranges*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一站是 `asSequence()` 函数。不出所料，这个函数会将可迭代的对象转换为序列。然而，这个函数不仅与你可能期望的列表和集合一起工作，还可以对
    *范围* 进行调用。
- en: 'We met Kotlin’s numeric ranges back in section 9.2.6 where they were used to
    check inclusion with `when` expressions. But ranges may be iterated across, too.
    We can combine this with `asSequence()` to create long numeric lists without bothersome
    typing or over allocating, as shown next:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在9.2.6节中遇到了 Kotlin 的数字范围，当时它们被用来与 `when` 表达式一起检查包含性。但是范围也可以迭代。我们可以将此与 `asSequence()`
    结合起来创建长数字列表，而无需繁琐的输入或过度分配，如下所示：
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Range tracks only its begin and end, so we don’t create a billion elements.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 范围只跟踪其开始和结束，所以我们不会创建数十亿个元素。
- en: 'But what if even the large-but-still-bounded nature of ranges feels too restrictive?
    `generateSequence()` from `kotlin.sequences` in the standard library has you covered.
    This function creates a new general sequence object with an optional starting
    value. Each time it needs the next element, it runs the provided lambda, passing
    in the prior value, like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果即使是范围的大但仍然有限的本性感觉过于限制性，怎么办呢？标准库中的 `kotlin.sequences` 的 `generateSequence()`
    函数可以满足你的需求。这个函数创建了一个新的通用序列对象，并可选地包含一个起始值。每次它需要下一个元素时，它会运行提供的lambda表达式，并传入前一个值，如下所示：
- en: '[PRE60]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ An infinite sequence of even numbers
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个无限序列的偶数
- en: 'An infinite `Iterable<T>` would be impossible to chain methods with because
    the first call on it would never return. `Sequence<T>` will just get what it needs
    and leave the rest for later. This pairs nicely with the `take()` function, where
    we can ask for a specific number of elements to be retrieved as a new, bounded
    sequence like so:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无限的 `Iterable<T>` 将无法链式调用方法，因为对它的第一次调用永远不会返回。`Sequence<T>` 将只获取它需要的，并将其余的留到以后。这与
    `take()` 函数很好地搭配，我们可以请求获取特定数量的元素，作为一个新的、有界的序列，如下所示：
- en: '[PRE61]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Creates a sequence with the first three elements in it
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含前三个元素的序列
- en: ❷ Forces evaluation through the sequence and prints what we received
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过序列强制评估并打印我们收到的结果
- en: '`forEach()` on sequences is what’s referred to as *terminal*, because it ends
    the sequence’s laziness and evaluates everything it has. We’ve seen another terminal
    already with `toList()`, which necessarily steps through every element to construct
    a list.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 序列上的 `forEach()` 被称为 *终端*，因为它结束了序列的惰性并评估了所有内容。我们已经看到了另一个终端，即 `toList()`，它必然要遍历每个元素来构建一个列表。
- en: 'Kotlin offers another option for creating a sequence if, for some reason, it’s
    difficult to work from just the prior element in the sequence. The pairing of
    `sequence()` with `yield()` lets us construct completely arbitrary sequences as
    follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，仅从序列中的前一个元素工作很困难，Kotlin 提供了另一种创建序列的选项。`sequence()` 与 `yield()` 的组合允许我们构建完全任意的序列，如下所示：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ yieldAll() takes an iterable of the same type we’re yielding and will yield
    each element in turn when asked.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `yieldAll()` 接受一个与我们要 `yield` 的相同类型的可迭代对象，并在请求时依次产生每个元素。
- en: As we’d expect with sequences, the lambda is lazily executed to determine the
    next element. What’s unique here, though, is that for each call for the next element,
    the lambda runs only until the next `yield` and then pauses. A subsequent request
    for another element will resume the lambda where it had paused and run until the
    next `yield` again, as shown in figure 15.3.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，与序列一样，lambda 是惰性执行的，以确定下一个元素。然而，这里独特的是，对于每个对下一个元素的调用，lambda 只会运行到下一个
    `yield` 并暂停。随后的对另一个元素的请求将恢复 lambda 在暂停的地方，并再次运行到下一个 `yield`，如图 15.3 所示。
- en: '![](../Images/CH15_F03_Evans2.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH15_F03_Evans2.png)'
- en: Figure 15.3 Timeline view of yield execution
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 `yield` 执行的时间线视图
- en: '`yield` uses a Kotlin feature known as *suspend* functions. As the name suggests,
    these are functions where Kotlin recognizes points in code execution that can
    stop and resume. In this case, Kotlin sees that each time we `yield` a value,
    execution of our `sequence` lambda should pause until the next value is requested.
    Though our code looks like a simple lambda, the Kotlin compiler is actually doing
    a lot of additional work for us behind the scenes.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` 使用 Kotlin 中的一个称为 *suspend* 函数的特性。正如其名所示，这些函数是 Kotlin 能够识别代码执行中可以暂停和恢复的点。在这种情况下，Kotlin
    会看到每次我们 `yield` 一个值时，我们的 `sequence` lambda 的执行应该暂停，直到请求下一个值。尽管我们的代码看起来像是一个简单的
    lambda，但实际上 Kotlin 编译器在幕后为我们做了很多额外的工作。'
- en: Suspend functions are deeply related to Kotlin’s alternative concurrency model,
    coroutines, which we introduced in section 9.4 and will discuss in more detail
    in chapter 16\. It’s an interesting point to note, though, that a feature that
    we often consider in light of concurrency also unlocks unique ways of functional
    programming as well.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 悬挂函数与 Kotlin 的替代并发模型——协程密切相关，我们在第 9.4 节中介绍了协程，将在第 16 章中更详细地讨论。然而，值得注意的是，我们经常从并发角度考虑的功能特性，也解锁了独特的函数式编程方式。
- en: 15.4 Clojure FP
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4 Clojure FP
- en: We met the basics of functional programming in Clojure in chapter 10 with forms
    like `(map)`. We also had early introductions to concepts like immutability and
    higher-order functions because those ideas and capabilities are very close to
    the core of the Clojure programming model.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 10 章中遇到了 Clojure 函数式编程的基础，例如 `(map)` 形式。我们还对不变性和高阶函数等概念有了早期的介绍，因为这些想法和能力与
    Clojure 编程模型的核心非常接近。
- en: So, in this section, rather than introducing the Clojure take on the features
    we discussed for Java and Kotlin, we will go beyond those foundations and show
    how some of Clojure’s more advanced functional features work, starting with a
    note on list comprehensions.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们不会介绍 Clojure 对 Java 和 Kotlin 中讨论的功能特性的看法，而是超越这些基础，展示 Clojure 一些更高级的函数式特性是如何工作的，从对列表理解的一个注释开始。
- en: 15.4.1 Comprehensions
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4.1 理解
- en: 'An important idea in functional programming is the concept of a *comprehension*,
    where the word means a “complete description” of a set or other data structure.
    This concept is derived from mathematics, where we often see set-theoretic notation
    used to describe sets, like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个重要概念是 *comprehension* 的概念，这里的词意味着集合或其他数据结构的“完整描述”。这个概念源于数学，我们经常看到集合论符号用来描述集合，如下所示：
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this notation, ∈ means “is a member of,” ℕ is the infinite set of all *natural
    numbers* (or counting numbers), which are the numbers we would use to count objects
    (so 1, 2, 3, and so on), and the `:` defines a condition or a *restriction*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个符号中，∈ 表示“是……的成员”，ℕ 是所有 *自然数*（或计数数）的无限集合，这些是我们用来计数对象（如 1、2、3 等等）的数，而 `:` 定义了一个条件或
    *限制*。
- en: 'So this comprehension is describing a set of counting numbers that have a special
    property: every number in the set, when divided by two, yields a number that is
    also a counting number. Of course, we already know this set by another name—it
    is the set of even numbers.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种理解描述了一组具有特殊属性的计数数字：集合中的每个数字，当除以二时，都会得到一个也是计数数字的数。当然，我们早已通过另一个名字知道这个集合——它是偶数集合。
- en: The key point is that we did not specify the set of even numbers by listing
    out the elements (that would be impossible—there are an infinite number of them).
    Instead, we defined “even numbers” by starting from the natural numbers and specifying
    an additional condition that had to hold for each element to be included in the
    new set.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于我们没有通过列出元素来指定偶数的集合（那是不可能的——有无限多个）。相反，我们通过从自然数开始并指定一个附加条件来定义“偶数”，这个条件必须对每个要包含在新集合中的元素成立。
- en: If that sounds a bit like the use of functional techniques, such as `filter`,
    then it should—they are very closely related concepts. However, functional languages
    often offer both comprehensions and `filter-map` because each approach turns out
    to be conceptually easier to use in different circumstances.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来有点像函数技术（如`filter`）的使用，那么它应该是——它们是非常相关的概念。然而，函数语言通常提供推导和`filter-map`，因为每种方法在不同的环境中都更容易使用。
- en: 'Clojure implements *list comprehensions* using the `(for)` form to return either
    a list (or an iterator, in some cases). This is why, when we met Clojure loops
    in chapter 10, we didn’t introduce `(for)`—it isn’t really a loop. Let’s see it
    in action:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure使用`(for)`形式来实现*列表推导*，以返回列表（或在某些情况下迭代器）。这就是为什么当我们遇到第10章中的Clojure循环时，我们没有介绍`(for)`——它实际上不是一个循环。让我们看看它是如何工作的：
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `(for)` form takes two arguments: an argument vector, and a form that will
    represent the values to *yield* as part of the overall list that `(for)` will
    return.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`(for)`形式接受两个参数：一个参数向量和将代表`(for)`将返回的整体列表中要*生成*的值的表达式。'
- en: 'The argument vector contains a pair (or multiple pairs) of elements: a temporary
    that will be used in the definition of the yielded values and a seq to provide
    the inputs. We can think of the temporary as being used to bind each of the values,
    in turn. This could, of course, easily be written as a map like this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 参数向量包含一对（或多个对）元素：一个临时变量，它将在生成的值的定义中使用，以及一个序列来提供输入。我们可以将临时变量视为依次绑定每个值。当然，这可以很容易地写成如下映射：
- en: '[PRE65]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So, where would we want to use `(for)`? It comes into its own when we have
    more complex structures to build up, for example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们想在何处使用`(for)`？当我们要构建更复杂结构时，它就派上用场，例如：
- en: '[PRE66]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We could also do this with a map, but the construction would potentially be
    more complex and cumbersome, whereas with `(for)` it is clear and straightforward.
    To get the effect of a filter, we can also use an additional qualifier on the
    `(for)` that can act as a restriction, as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用映射来做这件事，但构造可能会更复杂和繁琐，而使用`(for)`则清晰直接。为了得到过滤的效果，我们还可以在`(for)`上使用一个额外的限定符，它可以作为一个限制，如下所示：
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let’s move on to look at how Clojure implements laziness, especially as applied
    to sequences.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看Clojure是如何实现懒加载的，特别是当应用于序列时。
- en: 15.4.2 Lazy sequences
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4.2 懒序列
- en: In Clojure, laziness is mostly commonly seen when working with sequences rather
    than lazy evaluation of a single value. For sequences, laziness means that instead
    of having a complete list of every value that’s in a sequence, values can instead
    be obtained when they’re required (such as by calling a function to generate them
    on demand).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，懒加载通常在处理序列而不是单个值的懒加载时最常见。对于序列，懒加载意味着我们不必有一个包含序列中所有值的完整列表，而是在需要时（例如，通过调用一个函数按需生成它们）才能获得值。
- en: 'In the Java Collections, such an idea would require something like a custom
    implementation of `List`, and there would be no convenient way to write it without
    large amounts of boilerplate code. Using an implementation of `ISeq`, on the other
    hand, would allow us to write something like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java集合中，这样的想法可能需要类似自定义实现`List`的东西，而且没有方便的方法来编写它而不需要大量样板代码。另一方面，使用`ISeq`的实现将允许我们编写如下内容：
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There is no storage of values, and instead, each new element of the sequence
    is generated on demand. This allows us to model infinite sequences. Or consider
    this example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 没有存储值，相反，序列的每个新元素都是按需生成的。这使我们能够模拟无限序列。或者考虑这个例子：
- en: '[PRE69]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This code sample uses the result of applying the function to provide the seed
    of the next sequence. This is fine, provided that the generator function is pure,
    but, of course, nothing guarantees that in Java. Let’s move on and take a look
    at some powerful Clojure macros designed to help you create lazy seqs with only
    a small amount of effort.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例使用函数应用的结果来提供下一个序列的种子。这是可以的，前提是生成函数是纯的，但在Java中，当然没有任何保证。让我们继续前进，看看一些强大的Clojure宏，这些宏旨在帮助您只需付出少量努力就能创建懒序列。
- en: 'Consider how you could represent a lazy, potentially infinite sequence. One
    obvious choice would be to use a function to generate items in the sequence. The
    function should do two things:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何表示一个懒的、可能无限的序列。一个明显的选择是使用一个函数来生成序列中的项。该函数应该做两件事：
- en: Return the next item in a sequence
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回序列中的下一个项
- en: Take a fixed, finite number of arguments
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采取固定、有限数量的参数
- en: Mathematicians would say that such a function defines a *recurrence relation*,
    and the theory of such relations immediately suggests that recursion is an appropriate
    way to proceed.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家会说，这样的函数定义了一个*递归关系*，而这种关系的理论立即表明递归是进行操作的一种适当方式。
- en: 'Imagine you have a machine in which stack space and other constraints aren’t
    present, and suppose that you can set up two threads of execution: one will prepare
    the infinite sequence, and the other will use it. Then you could use recursion
    to define the lazy seq in the generation thread with something like the following
    snippet of pseudocode:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个机器，其中没有堆栈空间和其他限制，并且假设你可以设置两个执行线程：一个将准备无限序列，另一个将使用它。然后你可以使用递归在生成线程中定义懒序列，如下面的伪代码片段所示：
- en: '[PRE70]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ❶ This doesn’t actually work, because the recursive call to (infinite-seq) blows
    up the stack.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这实际上不起作用，因为对(infinite-seq)的递归调用会耗尽堆栈。
- en: 'The solution is to add a construct that tells Clojure to optimize the recursion
    away and only proceed as needed: the `(lazy-seq)` macro. Let’s look at a quick
    example in the next listing that defines the lazy sequence `k`, `k+1`, `k+2`,
    ... for some number k.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是添加一个结构，告诉Clojure优化递归并仅在需要时进行操作：`(lazy-seq)`宏。让我们看看下一个列表中的快速示例，它定义了懒序列`k`，`k+1`，`k+2`，...，对于某个数字k。
- en: Listing 15.1 Lazy sequence example
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.1 懒序列示例
- en: '[PRE71]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ❶ lazy-seq marker
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 懒序列标记
- en: ❷ Infinite recursion
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 无限递归
- en: ❸ concat constrains recursion.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ concat限制了递归。
- en: The key points are the form `(lazy-seq)`, which marks a point where an infinite
    recursion could occur, and the `(concat)` form, which handles it safely. You can
    then use the `(take)` form to pull the required number of elements from the lazy
    sequence. Lazy sequences are an extremely powerful feature, and with practice,
    you’ll find them a very useful tool in your Clojure arsenal.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是`(lazy-seq)`形式，它标记了一个可能发生无限递归的点，以及`(concat)`形式，它安全地处理它。然后你可以使用`(take)`形式从懒序列中提取所需数量的元素。懒序列是一个非常强大的功能，通过实践，你会发现它们是Clojure工具箱中非常有用的工具。
- en: 15.4.3 Currying in Clojure
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4.3 Clojure中的柯里化
- en: Currying functions in Clojure has an additional complexity compared to other
    languages. This is caused by the fact that many Clojure forms are variadic, as
    we discussed in chapter 10.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言相比，Clojure中的柯里化函数具有额外的复杂性。这是由于我们第10章讨论的事实，即许多Clojure形式是可变参数的。
- en: 'Variadic functions are a complication because they raise questions like: “Does
    the user mean to curry the two-argument form or evaluate the one-argument form?”—especially
    because Clojure uses eager evaluation of functions.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数是一个复杂因素，因为它们提出了像“用户是否打算柯里化两个参数形式还是评估一个参数形式？”这样的问题——尤其是在Clojure使用函数的贪婪求值的情况下。
- en: 'The solution is the `(partial)` form, which, by the way, is a genuine Clojure
    function, not a macro. Let’s see it in action:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是`(partial)`形式，顺便说一下，这是一个真正的Clojure函数，而不是宏。让我们看看它在实际中的应用：
- en: '[PRE72]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The function `=` takes 1 or more arguments, and so `(= :b)` would eagerly evaluate
    to `true`, but the use of `(partial)` turns it into a curried function. Its use
    in a `(filter)` call causes it to be recognized as a function of one argument
    (effectively, the one-argument overload), and then it is used to test each element
    in the following vector.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`=`接受1个或多个参数，因此`(= :b)`会贪婪地求值到`true`，但`(partial)`的使用将其转换为柯里化函数。它在`(filter)`调用中的使用使其被识别为一个单参数函数（实际上，是单参数重载），然后它被用来测试以下向量中的每个元素。
- en: Note `(partial)` by itself will curry only the first parameter of a form. If
    we wanted to curry some other parameter, we would need to combine `(partial)`
    with another form—one that permuted the argument list before function application.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `(partial)` 本身只会对形式的前一个参数进行柯里化。如果我们想对其他参数进行柯里化，我们需要将 `(partial)` 与另一个形式结合——这个形式在函数应用之前会重新排列参数列表。
- en: Clojure is by far the most functional of the three languages we have looked
    at, and if the treatment here has whetted your appetite, you have a great deal
    more that you can explore. What we have covered so far is only the beginning,
    but it does help to demonstrate that the JVM itself can be a good home for functional
    programming—it’s more the Java language that encumbers programming in a functional
    style.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨的三种语言中，Clojure 的函数式特性最为突出。如果这里的介绍已经激起了你的兴趣，你还有更多可以探索的内容。我们到目前为止所涵盖的只是冰山一角，但它确实有助于证明
    JVM 本身可以是一个良好的函数式编程家园——更多的是 Java 语言阻碍了以函数式风格进行编程。
- en: In this chapter, we have delved far deeper into functional programming than
    just the traditional filter-map-reduce paradigm of Java Streams. We have largely
    done so by moving outside of Java to other JVM languages.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了函数式编程，远不止 Java Streams 的传统 filter-map-reduce 范式。我们主要通过跳出 Java，转向其他
    JVM 语言来实现这一点。
- en: 'It is, of course, possible to go even further than this. Two major schools
    of functional programming exist: the dynamically typed school, as represented
    by Clojure (and languages like Erlang outside of the JVM), and the statically
    typed school, which includes Kotlin but is perhaps better represented by Scala
    (and Haskell for non-JVM languages).'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以更进一步。存在两个主要的函数式编程学派：动态类型学派，以 Clojure（以及 JVM 之外的 Erlang 等语言）为代表，以及静态类型学派，包括
    Kotlin，但可能更由 Scala（以及非 JVM 语言的 Haskell）代表。
- en: However, one of Java’s major design virtues—backward compatibility—can also
    be seen as a potential weakness. Java code that was compiled for version 1.0 (more
    than 25 years ago) will still run without modification on modern JVMs. However,
    this remarkable achievement does not come without a price tag. Java’s APIs and
    even the design of the bytecode and JVM have to live with design decisions that
    are difficult or impossible to change now and that are not especially friendly
    to FP. This is one major reason developers who want to use functional styles frequently
    find themselves moving to non-Java JVM languages.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java 的一项主要设计优点——向后兼容性——也可以被视为一种潜在的弱点。为 1.0 版本（超过 25 年前）编译的 Java 代码仍然可以在现代
    JVM 上运行而无需修改。然而，这一显著的成就并非没有代价。Java 的 API 以及字节码和 JVM 的设计不得不忍受现在难以或无法更改的设计决策，而这些决策并不特别有利于函数式编程。这是开发者想要频繁使用函数式风格时，常常发现自己转向非
    Java JVM 语言的一个主要原因。
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Filter-map-reduce is the starting point, not the end point, of functional programming.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Filter-map-reduce 是函数式编程的起点，而非终点。
- en: Java is not a language that is especially suited to a functional style, because
    it lacks built-in features like lazy evaluation, currying, and tail-recursion
    optimization.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 并非特别适合函数式风格的编程语言，因为它缺少像惰性求值、柯里化和尾递归优化这样的内置特性。
- en: Other languages on the JVM can do a better job of supporting FP, with features
    such as Kotlin’s `Lazy<T>` and Clojure’s lazy sequences.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 上的其他语言可以更好地支持函数式编程，例如 Kotlin 的 `Lazy<T>` 和 Clojure 的惰性序列。
- en: Issues still exist at the JVM level, such as default mutability of data, that
    changing the choice of programming language cannot fundamentally fix.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 层面仍然存在一些问题，例如数据的默认可变性，改变编程语言的选择并不能从根本上解决这个问题。
