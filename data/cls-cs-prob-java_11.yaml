- en: 10 Interview with Brian Goetz
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 访谈布莱恩·戈茨
- en: Brian Goetz is one of the leading figures in the Java world. As Java Language
    Architect at Oracle, he helps steer the direction of the language’s evolution
    and its supporting libraries. He has led the language through several important
    modernizations, including Project Lambda. Brian has a long career in software
    engineering and is the author of the best-selling book *Java Concurrency in Practice*
    (Addison-Wesley Professional, 2006).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 布莱恩·戈茨是Java界的重要人物之一。作为Oracle的Java语言架构师，他帮助引导语言的发展方向及其支持库。他领导语言经历了多次重要的现代化，包括Lambda项目。布莱恩在软件工程领域有着漫长的职业生涯，并且是畅销书《Java并发实践》（Addison-Wesley
    Professional，2006年）的作者。
- en: This interview was conducted on August 25, 2020, at Brian’s home in Williston,
    Vermont. The transcript has been edited and condensed for clarity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这次访谈是在2020年8月25日，在佛蒙特州威利斯顿布莱恩的家中进行的。为了清晰起见，访谈记录已被编辑和缩减。
- en: How did you first get started in computing?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你是如何开始接触计算机的？
- en: I started as a hobbyist around 1978, when I was 13 or 14\. I had access to a
    timeshare computing system through the local school, and my older brother who
    had been through the same program ahead of me brought me books and stuff to read,
    and I was just absolutely hooked. I was completely fascinated by this system that
    was governed by a complex but understandable set of rules. And so, I spent as
    much time as I could after school in the computer room, at school, learning everything
    I could. And at the time, it was a very polyglot time for programming. There wasn’t
    a dominant language the way there has been for probably the last 25 years. Everybody
    was expected to know multiple programming languages. I taught myself BASIC, Fortran,
    COBOL, APL, and assembly language. I saw how each of these was a different tool
    for a different problem. I was completely self-taught because there wasn’t really
    any formal education available at the time. My degree is not in computer science,
    it’s in mathematics, because at the time a lot of schools didn’t even have a computer
    science department. And I think that mathematical orientation has stood me in
    very good stead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我大约在1978年开始作为爱好者接触计算机，当时我13或14岁。我通过当地学校可以访问到分时计算系统，我比我大几岁的哥哥在我之前参加了同样的项目，他给我带来了书和其他阅读材料，我完全着迷了。我对这个由复杂但可理解的规则所支配的系统感到无比着迷。因此，我尽可能地利用放学后的时间在学校计算机房学习我能学到的所有东西。当时，编程是一个多语言的时代。并没有像过去25年那样有一个主导的语言。每个人都期望知道多种编程语言。我自学了BASIC、Fortran、COBOL、APL和汇编语言。我看到了每种语言都是解决不同问题的不同工具。我完全是自学成才，因为当时并没有真正的正规教育。我的学位不是计算机科学，而是数学，因为当时很多学校甚至没有计算机科学系。我认为这种数学倾向对我非常有帮助。
- en: Was there one programming language when you were first learning that had a very
    big influence on you?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在你最初学习编程时，有没有一种编程语言对你产生了非常大的影响？
- en: When I was first learning, there wasn’t really. I was just swapping it all in.
    The dominant languages at the time were Fortran, COBOL, and BASIC for different
    categories of problems. But later, when I was a graduate student, I had the opportunity
    to take the Structure and Interpretation of Computer Programs class at MIT where
    I learned Scheme, and this was where all the light bulbs came on. At that point,
    I had already been programming for almost 10 years, and I had already encountered
    a lot of interesting problems. This was the first time I saw that there was an
    overarching theory that could connect a lot of the observations I had made. For
    me, I was very lucky to take that class as a graduate student rather than as a
    freshman, because the freshmen were just completely overwhelmed by the volume
    of material being thrown at them. Having more experience allowed me to see the
    underlying beauty and structure, without being distracted by the details. If I
    had to pick a moment where the beauty of computing really became obvious to me,
    it was that class.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初学习时，并没有特别突出的语言。我只是交换着学习。当时占主导地位的语言是Fortran、COBOL和BASIC，用于解决不同类别的问题。但后来，当我成为研究生时，我有机会在麻省理工学院修读《计算机程序的结构与解释》课程，在那里我学习了Scheme语言，这也是我所有灵光一现的地方。那时，我已经编程近10年了，已经遇到了很多有趣的问题。这是我第一次看到有一个贯穿的理论可以连接我观察到的很多现象。对我来说，我很幸运能作为研究生而不是新生上这门课，因为新生们完全被抛向他们的材料量压倒了。更多的经验让我能够看到背后的美丽和结构，而没有被细节所分散。如果我要选择一个让我真正意识到计算机之美的时候，那就是那门课。
- en: How did you develop your software engineering and computer science skill sets
    after college?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你是如何在大学之后发展你的软件工程和计算机科学技能集的？
- en: I think the same way almost everyone else does--mostly by doing. In typical
    professional engineering situations, more often than not you get thrown in the
    deep end of the pool with a problem to solve, and you have to figure it out on
    your own. You have an array of tools at your disposal, but it’s not always obvious
    what the right one to use is, and there’s a process of trial and error where you
    try things. You see what works--and what stops working when the problem reaches
    a certain threshold of complexity. Hopefully, there’s some inductive reasoning
    process that’s going on alongside that, by which you can figure out why something
    worked, and when it might work again, or might not. Earlier in my career, I had
    a number of fairly typical software engineering jobs; I worked for a research
    laboratory, I worked for a small software company that made networking software.
    I learned by doing and experimenting, like most developers do today.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我几乎和所有人一样思考——主要是通过实践。在典型的专业工程情况下，你往往会被直接扔进深水区，面对一个需要解决的问题，你必须自己解决它。你有一系列工具可供使用，但并不总是明显知道应该使用哪个，而且有一个试错的过程，你尝试各种方法。你看到哪些方法是有效的——以及当问题达到一定复杂度阈值时，哪些方法不再有效。希望在这个过程中，有一些归纳推理的过程在进行，通过它你可以弄清楚为什么某些方法有效，以及它们何时可能再次有效，或者可能不会有效。在我职业生涯的早期，我有一些相当典型的软件工程工作；我在一个研究实验室工作过，也在一个制作网络软件的小型软件公司工作过。我通过实践和实验学习，就像今天的大多数开发者一样。
- en: How did your career lead you to become the Java Language Architect?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的职业生涯是如何引导你成为Java语言架构师的？
- en: By a fairly strange and circuitous path! For the first half of my career, I
    was mostly an ordinary programmer. At some point, I made this transition to being
    sort of halfway between programming and education, giving presentations and writing
    articles and eventually a book. I always tried to choose topics that had been
    confusing to me on the theory that they might also be confusing to others--and
    I tried to present them in an understandable light. I discovered I had a talent
    for bridging the gap between the technical details and the intuitive mental models,
    and that culminated in writing *Java Concurrency in Practice*, which at this point
    was almost 15 years ago! And from there I went to work at Sun in a role that was
    more about technology evangelism than development, explaining to people, “How
    does the JVM work?” “What does a dynamic compiler do?” “Why is dynamic compilation
    potentially better than static compilation?” I was trying to demystify the technology
    and debunk the myths surrounding it. Once I was in there, I got to see how the
    engineering process worked on the Java team, and at some point the opportunity
    to contribute in a more substantial way arose. If I had to give people a road
    map for how to get there, I don’t know how I would draw it. It was definitely
    not a straight line.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一条相当奇怪且曲折的道路！在我职业生涯的前半段，我主要是一名普通程序员。在某个时候，我过渡到了介于编程和教育之间的一种状态，做演讲、写文章，最终写了一本书。我总是试图选择那些曾经让我感到困惑的主题——基于它们可能也会让其他人感到困惑的理论——并且我试图以一个可理解的方式呈现它们。我发现我有一种将技术细节和直观心理模型之间的差距连接起来的天赋，这最终导致了《Java并发实践》一书的写作，这本书到现在已经快15年了！从那里，我去了Sun公司工作，这个角色更多地关于技术布道，而不是开发，向人们解释“JVM是如何工作的？”“动态编译器做什么？”“为什么动态编译可能比静态编译更好？”我试图消除技术的神秘感，并驳斥围绕它的神话。一旦我进入其中，我就有机会以更实质性的方式做出贡献。如果我要为人们提供一条通往那里的路线图，我不知道该如何绘制它。这绝对不是一条直线。
- en: What does it mean to be the Java Language Architect?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 成为Java语言架构师意味着什么？
- en: 'In the simplest terms, I have to decide in what direction the Java programming
    model moves. And there are, of course, many, many options here--and many people
    who would happily give me advice! I’m sure each of the nine million Java developers
    has an idea or two for a language feature. And of course we can’t do all of them,
    or even many of them. So we have to pick very, very carefully. My job is to balance
    the need to keep moving forward, so Java stays relevant, with the need for Java
    to stay “Java.” And relevance has many dimensions: relevant to the problems that
    we want to solve; relevant to the hardware we run on; relevant to the interests,
    orientations, and even fashions of programmers. We have to evolve, but we also
    can’t move so quickly that we lose people. If we were to make a radical overnight
    change, people would say, “This isn’t the Java I know,” and they would go do something
    else. And so, we have to pick both the direction and a rate to move forward, such
    that we’re able to stay relevant to the problems people want to solve without
    making people feel uncomfortable.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我必须决定Java编程模型的发展方向。当然，这里有很多很多选择——很多人都会乐意给我提建议！我相信这九百万Java开发者中每个人都有一个或两个关于语言特性的想法。当然，我们不可能做所有这些，甚至很多。所以我们必须非常谨慎地选择。我的工作是平衡继续前进的需要，使Java保持相关性，以及Java保持“Java”特性的需要。相关性有很多维度：与我们想要解决的问题相关；与我们在其上运行的硬件相关；与程序员的兴趣、取向甚至时尚相关。我们必须发展，但我们也不能走得如此之快，以至于失去了人们。如果我们一夜之间进行彻底的改变，人们会说：“这不是我认识的Java了，”然后他们会去做其他事情。因此，我们必须选择前进的方向和速度，这样我们才能保持与人们想要解决的问题的相关性，同时又不让人们感到不舒服。
- en: 'For me, that means getting into the shoes of Java developers and understanding
    where their pain points are. Then we try to move the language in a way that works
    with them and obviates the pain points that they’re experiencing, but not necessarily
    in the same way they imagined they needed. There’s an old saying attributed to
    Henry Ford: “If I asked my customers what they wanted, they would tell me ‘faster
    horses.’” Programmers are very much prone to say “you should add this feature,”
    and the art is in listening to that suggestion and understanding the kind of pain
    they are in that leads them to think that this would be the right solution. By
    comparing that to the things we’ve heard from other developers, perhaps we can
    see what’s really missing that will actually address people’s pain, make them
    more productive, make programs safer, and more efficient.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这意味着要站在Java开发者的角度，了解他们的痛点。然后我们尝试以与他们合作的方式推动语言的发展，消除他们正在经历的不便，但并不一定是他们想象中需要的那种方式。有一个古老的谚语归功于亨利·福特：“如果我问我的客户他们想要什么，他们会告诉我‘更快的马’。”程序员非常倾向于说“你应该添加这个功能”，而艺术在于倾听这个建议，理解他们为什么认为这是正确的解决方案。通过将这一点与其他开发者听到的事情进行比较，我们可能可以看到真正缺失的东西，这实际上会解决人们的痛点，提高他们的生产力，使程序更安全，更高效。
- en: How does the process of evolving the Java language work? How is it decided that
    new features should be added to the language?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言的演变过程是如何工作的？是如何决定向语言中添加新功能的？
- en: It’s actually fairly rare that a feature is invented out of whole cloth. The
    reality is, almost every “new” idea has been kicking around the programming world
    for decades. Invariably, when someone comes to me with a feature idea, I can see
    a connection to something that was done in some other language long ago. A big
    part of the process is waiting for the right time to expose a new concept, and
    fitting it in a way that is consistent with the rest of the language. There’s
    no shortage of feature ideas, and in every language you find lots of features
    that people in those communities like. The real game is to get underneath them
    and ask, “What does having this feature enable you to do that you can’t do otherwise?
    How does it make your programs safer? How would it permit better type checking?
    How does it make your programs less error prone, more expressive, and so on?”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，完全从头发明一个功能是非常罕见的。现实是，几乎每一个“新”想法在编程界已经存在了几十年。当有人向我提出一个功能想法时，我总能看到它与很久以前在某种其他语言中做过的事情有关联。这个过程的一个重要部分是等待合适的时机来展示一个新概念，并以与语言其他部分一致的方式融入其中。功能想法并不缺乏，在每种语言中你都能找到许多社区中人们喜欢的功能。真正的挑战是深入挖掘这些功能，问自己，“拥有这个功能能让你做什么，而其他方式做不到？它是如何使你的程序更安全的？它如何允许更好的类型检查？它是如何使你的程序更少出错、更易于表达等等？”
- en: 'It’s a fairly subjective process; if we’re looking to alleviate people’s pain,
    we have to make subjective calls about which kinds of pain are more important
    to alleviate now. You can look at the big features that have been added to Java
    in the past: In the mid-2000s, we saw generics, and that was an obvious gap. At
    that time the language screamed out for parametric polymorphism. They wanted to
    have it in 1995, but they didn’t know how to do it in a way that made sense for
    the language. And they didn’t want to graft C++ templates onto Java, which would’ve
    been terrible. It took almost another 10 years to figure out how to add parametric
    polymorphism and data abstraction to Java in a way that feels natural. And I think
    they did a fantastic job. We did the same thing with behavioral abstraction when
    we did lambdas more recently. Again, all the hard work there was not in the theory.
    The theory of lambda expressions has been well understood since the 1930s. The
    hard part was, how do you make it fit into Java so that it doesn’t look nailed
    on the side? The ultimate measure of success is when you finally deliver something
    after three or five or seven years, and people say, “What took you so long? That’s
    so obvious.” Well, the version we had in the first year would not look so easy
    or obvious. We don’t want to inflict that on people, so we have to take our time.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当主观的过程；如果我们想减轻人们的痛苦，我们必须对哪些类型的痛苦现在需要缓解做出主观的判断。你可以看看过去添加到Java中的大型特性：在2000年代中期，我们看到了泛型，那是一个明显的差距。当时语言迫切需要参数多态性。他们想在1995年就有，但他们不知道如何以一种对语言有意义的方式实现它。他们也不想将C++模板嫁接到Java上，那会非常糟糕。又花了近10年时间才想出如何在Java中自然地添加参数多态性和数据抽象。我认为他们做得非常出色。当我们最近做lambda表达式时，我们也做了同样的行为抽象。同样，那里的困难工作并不在理论。lambda表达式的理论自1930年代以来就已经被很好地理解了。困难的部分是如何让它适合Java，让它看起来不是随意添加的？成功的最终衡量标准是当你最终在三年、五年或七年后交付某物时，人们会说：“你们为什么花这么长时间？这太明显了。”嗯，我们第一年的版本看起来不会那么容易或明显。我们不想把这种东西强加于人，所以我们必须花时间。
- en: How do you know, when considering a feature, that it’s not just fashion and
    it’s something important that developers really need?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑一个特性时，你如何知道它不仅仅是时尚，而是开发者真正需要的重要特性？
- en: That is a really good question, because there have been some real near misses.
    In the early 2000s, there was a big call to add XML literals to the Java language,
    and I consider that to be a bullet that was dodged. Not all languages dodged that
    bullet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的问题，因为有一些真正的险些失之交臂。在2000年代初，有人强烈呼吁将XML字面量添加到Java语言中，我认为这是一个避开的子弹。并不是所有语言都避开了这个子弹。
- en: I can’t give you an algorithm for it; often, you just have to sit and think
    about it for a long time and see what the connections to the rest of the language
    look like. We’ve all seen languages that bolt a feature on the side to solve a
    particular problem, but that problem may not be a problem for all time. If you’re
    willing to sit and be patient and think about it over and over again before you
    make a decision, very often you can get a sense of when something is just the
    flavor of the week.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能给你一个算法；通常，你只需要坐下来长时间地思考，看看它与语言其他部分的联系是什么。我们都见过一些语言在旁边添加一个特性来解决特定问题，但那个问题可能不是永恒的问题。如果你愿意坐下来耐心地反复思考，在做出决定之前，你通常可以感觉到什么时候某件事只是本周的风味。
- en: What additions to Java are you most proud of during your tenure as Java Language
    Architect?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你担任Java语言架构师期间，你最自豪的Java语言添加了哪些特性？
- en: I was the specifications lead for adding lambdas to Java. Not only was that
    an enormous change, but it signaled a change for how the language would be evolved
    going forward. It was, in some sense, a make or break thing, because in the time
    leading up to that, Sun was fairly distracted by slowly going out of business,
    and we had not been able to evolve the platform at the rate that we would have
    liked. It was pretty clear at the time that Java was falling behind, and this
    was our big chance to prove to the world that it was possible for Java to remain
    relevant and fun to program in; that we could continue to teach this old dog some
    fancy new tricks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾是负责将lambda表达式添加到Java中的规格制定负责人。这不仅是一个巨大的变化，而且标志着语言未来发展的一个转折点。在某种程度上，这是一个成败攸关的事情，因为在那时，Sun公司正忙于缓慢地走向破产，而我们并没有能够以我们希望的速度发展平台。当时很明显，Java正在落后，这是我们向世界证明Java仍然具有相关性和编程乐趣的大好机会；我们可以继续教会这只老狗一些新奇的技巧。
- en: The main challenge of adding lambdas to Java was making it not look like it
    was tacked on the side, but integrated into the whole as if it had always been
    there. There were no shortage of suggestions for how to do it--nearly all of which
    were “do it like this other language does it.” All of these would have been unsatisfying.
    We might have gotten there a year or two faster, but we would not have gotten
    a result that worked as well, and we’d be stuck with it for a long time. What
    I’m really proud of is how we managed to figure out how to integrate it into the
    language at multiple levels so that it looked like it belonged there. It works
    very cleanly with the generic type system. We had to overhaul a number of other
    aspects of the language in order to make it work--we had to overhaul type inference
    and its interaction with overload selection. If you ask people what features were
    added in Java 8, that would never be on anybody’s list. But that was a huge part
    of the work--it was under the waterline, but it was the foundation that was needed
    to make it so that you could write the code that you wanted to write, and it just
    naturally worked.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将lambda表达式添加到Java中的主要挑战是让它看起来不是随意添加的，而是像它一直就在那里一样，完美地融入整体。关于如何实现这一点有很多建议——几乎所有的建议都是“像其他语言那样做。”所有这些都会让人不满意。我们可能会快一两年到达那里，但结果可能不会那么好，而且我们可能会长期受制于它。我真正自豪的是我们如何设法在多个层面上将其整合到语言中，使其看起来就像它属于那里一样。它与泛型类型系统结合得非常干净利落。为了使其工作，我们必须对语言的许多其他方面进行彻底改革——我们必须改革类型推断及其与重载选择的关系。如果你问人们Java
    8中添加了哪些特性，这绝对不会出现在任何人的列表上。但这是工作的巨大一部分——它是在水下进行的，但它是使您能够编写您想要编写的代码并自然工作的基础。
- en: We also had to start to address the problem of compatible API evolution. One
    of the huge risks we faced in Java 8 was that the way you would write a library
    with lambdas is very different from how you would in a language without lambdas.
    We didn’t want to make the language better and then be in the situation where,
    all of a sudden, all our libraries look 20 years older. We had to address the
    question of how we were going to evolve the libraries in a compatible way so they
    could take advantage of these new library design idioms. That led to the ability
    to compatibly add methods to interfaces, which was an essential part to keeping
    the libraries we had relevant, so that on day one, the language and the libraries
    were ready for a newer style of programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须开始解决兼容API进化的问题。我们在Java 8中面临的一个巨大风险是，使用lambda表达式编写库的方式与在无lambda表达式的语言中编写的方式非常不同。我们不想让语言变得更好，然后突然间，我们所有的库看起来都像20年前的一样。我们必须解决如何以兼容的方式进化库的问题，以便它们可以利用这些新的库设计惯例。这导致了向接口中兼容地添加方法的能力，这对于保持我们已有的库的相关性是至关重要的，这样在第一天，语言和库就为一种新的编程风格做好了准备。
- en: A question I get asked by a lot of students is how much should they use lambdas?
    Can they overuse them in their code?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常被很多学生问到的问题是他们应该使用lambda表达式到什么程度？他们是否会在代码中过度使用它们？
- en: I come at this perhaps from a different perspective than a lot of students,
    because most of the code that I write are libraries that are intended to be used
    by a lot of people. The bar for writing a library like that, like the streams
    API, is very high because you have to get it right the first time. The compatibility
    bar for changing it is very high. The way I tend to think about abstracting over
    behavior is when you’re crossing a boundary between user code and library code,
    the main thing that lambdas allow you to do is to design APIs that could be parameterized
    not just with data, but with behavior, because lambdas let us treat behavior as
    data. So I am focused on the interaction between the client and this library and
    the natural flow of control. When does it make sense for the client to be pulling
    all the strings, versus when does it make sense for the client to hand some behavior
    to the library that it will call at the appropriate time? I’m not sure my experiences
    translate directly to the experience of your students. But one thing that will
    surely be a key to success here is being able to recognize where the boundaries
    are in your code, and where the divisions of responsibility lie. Whether those
    are strictly demarcated in separately compiled modules or carefully documented
    APIs, or whether they’re just conventions for how we organize our code, this is
    something we want to stay aware of.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能比很多学生看待这个问题有不同视角，因为大部分我写的代码都是打算供很多人使用的库。编写这样一个库，比如流API，门槛非常高，因为你必须第一次就做对。改变它的兼容性门槛也非常高。我倾向于思考如何通过抽象行为跨越用户代码和库代码之间的边界，lambda的主要作用是设计出可以参数化不仅数据，还可以行为的API，因为lambda让我们可以将行为视为数据。所以，我专注于客户端与这个库之间的交互以及控制流的自然流动。什么时候客户端拉所有弦是有意义的，而什么时候客户端将一些行为交给库，在适当的时候调用它是有意义的？我不确定我的经验是否可以直接转化为你学生的经验。但在这里，成功的关键肯定是一旦能够识别出代码中的边界，以及责任划分在哪里。这些边界是否严格地划分在单独编译的模块中，或者是否是精心文档化的API，或者它们只是我们组织代码的惯例，这是我们希望保持意识到的。
- en: We use these boundaries in our code for a reason--so that we can manage the
    complexity through divide-and-conquer. Every time you’re designing one of these
    boundaries, you’re designing a little protocol interaction, and you should be
    thinking about the roles of the participants on each side, what information they
    are exchanging, and what that interchange looks like.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用这些边界是有原因的——这样我们才能通过分而治之来管理复杂性。每次你设计这些边界时，你就是在设计一个小型的协议交互，你应该在思考参与者的角色，他们交换的信息，以及这种交换看起来像什么。
- en: You spoke earlier about a period of stagnation for Java. When was that, and
    why did it happen?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前提到过Java的一段停滞期。那是在什么时候，为什么会发生这种情况？
- en: I would say the Java 6-7 timeframe was the dark ages for Java. Not coincidentally,
    this was the time at which Scala started to gain some traction, in part because
    I think the ecosystem was saying, “Well, we may need to find another horse to
    back if Java doesn’t get up and run.” Thankfully, it did get up and run, and it’s
    been running ever since.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说Java 6-7时期是Java的黑暗时代。不是巧合的是，这也是Scala开始获得一些影响力的时期，部分原因是因为我认为生态系统在说，“好吧，如果Java不能站起来并奔跑，我们可能需要找到另一匹马去支持。”幸运的是，它站起来了，并且一直奔跑到现在。
- en: And now we’re seeing a pretty rapid evolution of the language. How has the philosophy
    changed?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到语言正在迅速进化。哲学是如何变化的？
- en: In the big picture, it hasn’t changed that much, but in the details, it’s changed
    quite a lot. Starting after Java 9, we moved to a six-month time-boxed release
    cadence rather than a multiyear feature-boxed cadence. And there were all kinds
    of good reasons for doing that, but one of them was that there were a lot of good,
    smaller ideas that always got crowded out when we were planning multiyear releases
    with big release drivers. The shorter release cadence has allowed us to have a
    better mix of big and small features. In these six-month releases, a lot of them
    have smaller language features, like local variable type inference. They didn’t
    necessarily only take six months to do; they may still have taken a year or two,
    but we now have more opportunities to deliver something once it’s ready. In addition
    to smaller features, you’ll also see bigger feature arcs like pattern matching
    that may play out in increments over a multiyear period. The earlier parts can
    give us a sense of the direction of where the language is going.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从大局来看，它并没有发生太大的变化，但在细节上，它发生了相当大的变化。从Java 9开始，我们转向了六个月的时间框发布节奏，而不是多年的特性框发布节奏。这样做有很多很好的理由，但其中之一是，当我们在规划多年发布时，总是有很多好的、较小的想法被大的发布驱动因素所淹没。较短的发布节奏使我们能够更好地混合大特性和小特性。在这些六个月发布的版本中，很多都有较小的语言特性，比如局部变量类型推断。它们不一定只花了六个月来完成；它们可能仍然花了整整一年或两年，但现在我们有了更多机会，一旦准备好就可以交付。除了较小的特性外，你还会看到像模式匹配这样的大特性弧，这些特性可能在一个多年度的时期内逐步实现。早期部分可以让我们了解语言的发展方向。
- en: There are also clusters of related features which may be delivered individually.
    For example, pattern matching, records, and sealed types work together to support
    a more data-oriented model of programming. And that’s not an accident. That’s
    based on observing what kind of pain people are having using Java’s static type
    system to model the data that they’re working with. And how have programs changed
    in the last 10 years? They’ve gotten smaller. People are writing smaller units
    of functionality and deploying them as (say) microservices. So more of the code
    is closer to the boundary where it’s going to be getting data in from some partner,
    whether it’s JSON or XML or YAML over a socket connection, that it’s then going
    to turn into some Java data model, operate on, and then do the reverse. We wanted
    to make it easier to model data as data, since people are doing it more. So this
    cluster of features is designed to work together in that way. And you can see
    similar clusters of features in a lot of other languages, just with different
    names. In ML you would call them algebraic data types because records are product
    types and sealed classes are sum types, and you do polymorphism over algebraic
    data types with pattern matching. These are individual features that maybe Java
    developers haven’t seen before because they haven’t programmed in Scala or ML
    or Haskell. They may be new to Java, but they are not new concepts, and they have
    been proven to work together to enable a style of programming that’s relevant
    to the problems people are solving today.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样也存在一些相关的功能簇，这些功能可以单独提供。例如，模式匹配、记录和密封类型共同作用，以支持更面向数据的编程模型。这并非偶然。这是基于观察人们在使用Java的静态类型系统来建模他们正在处理的数据时所遇到的痛苦。在过去10年里，程序又发生了怎样的变化呢？它们变得更小了。人们正在编写更小的功能单元，并将它们作为（比如说）微服务部署。因此，更多的代码更接近边界，将从某个合作伙伴那里获取数据，无论是通过套接字连接的JSON、XML还是YAML，然后将其转换为某种Java数据模型，进行操作，然后再进行反向操作。由于人们越来越多地这样做，我们希望使数据建模更容易。因此，这个功能簇被设计成以这种方式协同工作。你可以在许多其他语言中看到类似的功能簇，只是名称不同。在机器学习（ML）中，你会称它们为代数数据类型，因为记录是积类型，密封类是和类型，你通过模式匹配在代数数据类型上实现多态。这些是Java开发者可能之前没有见过的单个功能，因为他们没有在Scala、ML或Haskell中编程。它们可能对Java来说是新的，但它们并不是新概念，并且已经被证明可以协同工作，以实现与人们今天解决的问题相关的编程风格。
- en: I’m wondering if there’s one upcoming feature in Java that you are most excited
    about.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我想知道在即将推出的Java特性中，你最兴奋的是哪一个。
- en: 'I’m really excited about the bigger picture for pattern matching because, as
    I’ve worked on it, I realized that it has been a missing piece of the object model
    from Java all along, and we just hadn’t noticed. Java offers good tools for encapsulation,
    but it only goes one way: you invoke a constructor with some data and that gives
    you an object, which then is very cagey about giving up its state. And the ways
    in which it gives up its state are generally via some ad hoc API that’s hard to
    reason about programmatically. But there is a large category of classes that are
    just modeling plain old data. The notion of a deconstruction pattern is really
    just the dual of a concept that we’ve had from day one, which is the constructor.
    The constructor takes state and turns it into an object. What’s the reverse of
    that? How do you deconstruct an object into the state that you started with (or
    could restart with)? That’s exactly what pattern matching lets you do. It turns
    out that there are an awful lot of problems for which the solution with pattern
    matching is just much more straightforward, elegant, and most importantly composable,
    than doing it the ad hoc way.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我对模式匹配的更大图景感到非常兴奋，因为随着我对它的研究，我意识到这一直是Java对象模型中缺失的一块，而我们之前并没有注意到。Java提供了很好的封装工具，但它只走了一步：你用一些数据调用构造函数，这样就得到了一个对象，然后这个对象在放弃其状态方面非常谨慎。而且它放弃状态的方式通常是通过一些难以程序化推理的特定API。但是，存在一大类仅仅模拟普通数据的类。解构模式的观念实际上是我们从第一天起就有的一个概念的对立面，那就是构造函数。构造函数接受状态并将其转换为对象。那么它的反面是什么呢？你如何将对象解构为最初（或可以重新启动）的状态？这正是模式匹配让你做到的。结果发现，有很多问题，使用模式匹配的解决方案比临时解决方案要简单、优雅得多，最重要的是可组合性更强。
- en: I bring that up because despite all we’ve learned about advances in programming
    language theory in the last 50 years, my one-sentence summary of the history of
    programming languages is, “We have one good trick that works.” And that trick
    is composition. That’s the only thing that works to manage complexity. And so,
    as a language designer, you want to be looking for techniques that allow developers
    to work with composition rather than against it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到这一点是因为尽管我们在过去50年中学习了关于编程语言理论的所有进步，但我对编程语言历史的总结只有一句话：“我们有一个有效的技巧。”这个技巧就是组合。这是唯一能够管理复杂性的方法。因此，作为一个语言设计者，你希望寻找允许开发者与组合而不是与之对抗的技术。
- en: Why is it important to know problem-solving techniques from the realm of computer
    science?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么了解来自计算机科学领域的解决问题的技巧很重要？
- en: To stand on the shoulders of giants! There are so many problems that have already
    been solved by someone else, often at great effort and expense and with many false
    starts. If you don’t know how to recognize that you’re staring at a problem that
    has probably been solved by somebody before, you’re going to be tempted to reinvent
    their solution--and you’re probably not going to do it as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 站在巨人的肩膀上！有那么多问题已经被别人解决了，通常需要巨大的努力和费用，并且伴随着许多尝试。如果你不知道如何识别你面前的问题可能已经被某人解决过，你可能会倾向于重新发明他们的解决方案——而且你很可能做得不如他们好。
- en: I saw a funny comic the other day about how mathematics works. When something
    new is being discovered, at first no one believes that it’s even true, and it
    takes years to figure out the details. It may take years more to get the rest
    of the mathematical community to agree that this actually makes sense. And then
    at the other end, you spend 45 minutes on it in a lecture, and when a student
    doesn’t understand it, the professor asks, “We spent all class on that yesterday,
    how could you not get it?” A lot of the concepts that we see as lecture-sized
    units of understanding in class are the result of years of someone bashing their
    head against the problem. The problems that we solve are hard enough that we need
    every bit of help we can get. If we can decompose the problem so that some part
    can be solved by an existing technique, that is hugely freeing. It means you don’t
    have to reinvent a solution, and especially not a bad solution. You don’t have
    to rediscover all the ways in which the obvious solution isn’t quite right. You
    can just lean on an existing solution and focus on the part of your problem that
    is unique.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我前几天看到了一个有趣的漫画，讲述数学是如何工作的。当有新发现时，起初没有人相信它是真的，需要多年时间来弄清楚细节。可能还需要更多年才能让数学界的其他成员同意这实际上是有意义的。然后在另一端，你在一个讲座上花45分钟讲解，当一个学生不理解时，教授会问，“我们昨天整个课都在讲那个，你怎么可能不懂？”我们在课堂上看到的大部分概念，作为理解的大单元，都是有人在多年时间里不断努力解决问题的结果。我们解决的问题足够困难，以至于我们需要得到我们能得到的每一分帮助。如果我们能将问题分解，使得某些部分可以通过现有技术解决，那将是非常解放的。这意味着你不必重新发明解决方案，尤其是不要发明一个糟糕的解决方案。你不必重新发现所有那些显而易见的解决方案并不完全正确的方式。你只需依靠现有的解决方案，专注于你问题中独特的那部分。
- en: Sometimes students have trouble envisioning how the data structure and algorithm
    problems they learn will actually come up in real-world software development.
    Can you tell us how often computer science problems actually come up in software
    engineering?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，学生们会遇到困难，难以想象他们所学的数据结构和算法问题在实际软件开发中会如何出现。你能告诉我们计算机科学问题在软件工程中实际出现的频率是多少吗？
- en: This reminds me of a conversation I had when I went back to visit my thesis
    advisor some 10-15 years after graduation. He asked me two questions. The first
    was, “Do you use the math that you learned in your work here?” And I said, “Well,
    to be honest, not very often.” The second was, “But do you use the thinking and
    analysis skills that you learned when studying math?” And I said, “Absolutely,
    every day.” And he smiled with the pride of a job well done.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了我毕业后大约10-15年回访我的论文导师时的一次对话。他问我两个问题。第一个问题是，“你在工作中是否使用了你在学校学到的数学？”我说，“嗯，说实话，不太经常。”第二个问题是，“但是你使用你在学习数学时学到的思维和分析技能了吗？”我说，“绝对如此，每天都是。”他带着完成工作的自豪微笑。
- en: For example, take red-black trees. How do they work? Most of the time, I shouldn’t
    have to care. If you need one, every language has an excellent prewritten, well
    tested, high-performance library that you can just use. The important skill is
    not being able to recreate this library, but knowing how to spot when you can
    use it profitably to solve a bigger problem, whether it is the right tool, how
    this will fit into the time or space complexity of your overall solution, and
    so on. These are skills that you use all the time. It can be hard, when you’re
    in the middle of a data structures class, to see the forest through the trees.
    You can spend a lot of time in class working through the mechanics of a red-black
    tree, and this might be important, but it’s something you’ll likely never have
    to do again. And hopefully you won’t get asked to do it in an interview, because
    I think that’s a terrible interview question! But you should know what the time
    complexity of a tree lookup could be, what the conditions on the key distribution
    would have to be in order to achieve that complexity, and so on. That’s the kind
    of thinking that real-world developers are called on to apply every day.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以红黑树为例。它们是如何工作的？大多数时候，我并不需要关心。如果你需要，每种语言都有优秀的预写、经过良好测试、高性能的库，你可以直接使用。重要的技能不是能够重新创建这个库，而是知道何时能够有利地使用它来解决更大的问题，无论是选择合适的工具，还是考虑它将如何融入你整体解决方案的时间或空间复杂度，等等。这些是你经常使用的技能。当你身处数据结构课程中时，很难透过现象看到本质。你可能会在课堂上花费大量时间研究红黑树的机制，这可能是重要的，但你很可能永远不需要再次做这件事。而且希望你在面试中不会被要求这样做，因为我认为这是一个糟糕的面试问题！但你应该知道树查找的时间复杂度可能是什么，为了达到这种复杂度，键分布的条件应该是什么，等等。这就是现实世界开发者每天都需要应用的那种思维方式。
- en: Can you give us an example of a time in which you or another engineer were able
    to parlay knowledge from computer science to better attack an engineering problem?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你能给我们举一个例子，说明你或另一位工程师如何能够将计算机科学的知识应用到解决工程问题中吗？
- en: In my own work, it’s kind of funny, because the theory is a very important underpinning
    to a lot of what we do. But the theory also stops short of being able to solve
    the problem for you in real-world language design. For example, Java is not a
    pure language, so in theory there’s nothing to be learned from monads. But of
    course there’s a lot to be learned from monads. So when I’m looking at a possible
    feature, there is a lot of theory I can lean on. That gives me an intuition, but
    I’m going to have to fill in the last mile myself. The same thing with type systems.
    Most of type theory doesn’t deal with effects like throwing exceptions. Well,
    Java has exceptions. That doesn’t mean that type theory is useless. There’s a
    lot of type theory I can lean on in evolving the Java language. But I have to
    recognize that the theory is going to get me only so far, and I’m going to need
    to pave the last mile on my own.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的工作中，这有点好笑，因为理论是我们所做很多事情的重要基础。但理论也未能解决现实世界语言设计中的问题。例如，Java 不是一个纯语言，所以在理论上，从单子（monads）那里学不到什么。但当然，从单子那里可以学到很多东西。所以当我审视一个可能的功能时，我可以依赖很多理论。这给了我直觉，但最后的一公里我必须自己填补。同样，对于类型系统也是如此。大多数类型理论不涉及像抛出异常这样的效果。嗯，Java
    有异常。这并不意味着类型理论没有用。在发展 Java 语言的过程中，我可以依赖很多类型理论。但我必须认识到，理论只能带我去那么远，我必须自己铺平最后的一公里。
- en: Finding that balance is hard. But it’s critical, because it’s all too easy to
    say, “Oh, the theory won’t help me,” and then you’re reinventing wheels.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这种平衡是困难的。但这是至关重要的，因为很容易说，“哦，理论对我没有帮助，”然后你就重新发明了轮子。
- en: What areas of computer science are important in language development?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的哪些领域在语言开发中很重要？
- en: Type theory is the obvious one. Most languages have a type system, and some
    of them have more than one. Java, for example, has one type system at static compilation
    time, and a different type system at run time. There is even a third type system
    for verification time. These type systems have to be consistent, of course, but
    they have different degrees of precision and granularity. So type theory is, of
    course, important. There is a lot of formal work on program semantics that is
    useful to be aware of, but not necessarily something that gets applied in everyday
    language design. But I don’t think any reasonable project goes by without opening
    the type theory books and reading dozens of papers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类型理论是显而易见的。大多数语言都有类型系统，其中一些甚至有多个。例如，Java在静态编译时有一个类型系统，在运行时有一个不同的类型系统。甚至还有一个用于验证时间的第三个类型系统。当然，这些类型系统必须是一致的，但它们的精确度和粒度不同。因此，类型理论当然是重要的。有很多关于程序语义的正式工作值得了解，但并不一定在日常语言设计中得到应用。但我不认为任何合理的项目可以不打开类型理论书籍并阅读数十篇论文。
- en: If somebody out there is interested in eventually getting involved in language
    design, is there something you recommend they study or that they do in their career
    so that they could be in a position like yours someday?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人对最终参与语言设计感兴趣，你推荐他们学习或在其职业生涯中做些什么，以便他们有一天能处于你的位置？
- en: 'Obviously, in order to be involved in language design, you have to understand
    the tools that language developers use. You have to understand compilers, and
    type systems, and all the details from computational theory: finite automata,
    context-free grammars, and so on. It is a prerequisite to understand all of that
    stuff. It’s also really important to have programmed in a number of different
    languages, and specifically different kinds of languages, to see the different
    ways in which they approach problems, the different assumptions they make, the
    different tools that they reserve for the language versus what they put in the
    user’s hands, and so on. I think you have to have a pretty broad perspective on
    programming in order to be able to succeed in language design. You also need to
    have a “systems thinking” perspective. When you add a feature to a language, it
    changes how people will program in that language, and it changes the set of directions
    you can go in the future. You have to be able to see not only how a feature will
    be used, but also abused, and whether the new equilibrium is actually better than
    the old, or whether it just moves the problem to a different place.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为了参与语言设计，你必须理解语言开发者使用的工具。你必须理解编译器、类型系统以及计算理论的所有细节：有限自动机、上下文无关文法等等。这些都是理解所有这些内容的先决条件。同时，拥有多种不同语言的编程经验也非常重要，特别是不同类型的语言，这样你可以看到它们以不同的方式处理问题，它们做出的不同假设，它们为语言保留的不同工具，以及等等。我认为，你必须对编程有一个相当广阔的视角，才能在语言设计方面取得成功。你还需要有一个“系统思维”的视角。当你向一种语言添加一个特性时，它会改变人们使用该语言的方式，并改变你未来可以走的道路。你必须能够看到特性将被如何使用，以及如何被滥用，新的平衡是否实际上比旧的更好，或者它只是将问题转移到另一个地方。
- en: In fact, I’d give some of that advice--specifically, to go out and learn different
    kinds of programming languages--to everyone, regardless of whether they are interested
    in programming languages or not. Learning more than one programming paradigm will
    make them better programmers; when they approach a problem, they’ll more easily
    see multiple ways to attack it. I’d especially recommend learning a functional
    language, because it will give you a different and useful perspective on how to
    construct programs and will stretch your brain (in good ways).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我会给所有人提供一些建议——特别是，走出去学习不同类型的编程语言——无论他们是否对编程语言感兴趣。学习多种编程范式会使他们成为更好的程序员；当他们面对问题时，他们会更容易看到多种攻击方式。我特别推荐学习一种函数式语言，因为它会给你一个不同的、有用的视角来构建程序，并让你的大脑（以好的方式）得到锻炼。
- en: What mistakes do you often see Java programmers make, that they could perhaps
    avoid by better exploiting the language’s features?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常看到Java程序员犯哪些错误，他们或许可以通过更好地利用语言特性来避免这些错误？
- en: I think the biggest one is not doing the work to understand how generics work.
    There are a few non-obvious concepts in generics, but not that many, and they’re
    not all that hard once you set yourself to it. And generics are the underpinnings
    of other features, such as lambdas, as well as the key to understanding a lot
    of libraries. But a lot of developers treat it as an exercise in “What do I have
    to do to make the red squiggles go away?” rather than as leverage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最大的变化可能是不去努力理解泛型的工作原理。泛型中存在一些不那么明显的概念，但并不多，一旦你下定决心，它们并不难理解。泛型是其他特性（如lambda表达式）的基础，也是理解许多库的关键。但是，许多开发者将其视为一个“我需要做什么才能让红色波浪线消失？”的练习，而不是作为一种杠杆。
- en: What do you think is one of the biggest shifts that is going to happen in the
    next 5 to 10 years for working programmers?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为在接下来的5到10年内，对于在职程序员来说，最大的转变将是什么？
- en: I suspect it will be the integration of traditional computational problem solving
    with machine learning. Right now, programming and machine learning are completely
    separate areas. The current techniques for machine learning have been sort of
    lying dormant for 40 years. All the work on neural networks was done in the ’60s
    and ’70s. But we didn’t have the computational power or the data to train them
    until now. We have those things now, and all of a sudden it’s become relevant.
    You’re seeing machine learning applied to things like handwriting recognition,
    speech recognition, fraud detection, and all of these things that we used to try
    to solve (not very well) with rule-based systems or heuristics. But the problem
    is that the tools we use for machine learning and the styles of thinking we apply
    for machine learning are completely different from the way we write traditional
    programs. I think this is going to be a big challenge for the programmers of the
    next 20 years. How are they going to bridge these two different types of thinking
    in these two different tool sets in order to solve problems that will increasingly
    require both sets of skills?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑它将是传统计算问题解决方法与机器学习的结合。目前，编程和机器学习是完全不同的领域。机器学习的当前技术似乎已经沉睡40年了。所有关于神经网络的工作都是在60年代和70年代完成的。但是，直到现在我们才拥有训练它们的计算能力和数据。现在我们有了这些，突然之间它变得相关了。你看到机器学习被应用于手写识别、语音识别、欺诈检测等所有这些我们以前试图用基于规则的系统或启发式方法解决的问题（效果并不很好）。但是问题是，我们用于机器学习的工具和我们应用于机器学习的思维方式与传统程序设计的完全不同。我认为这将是对未来20年程序员的一个重大挑战。他们将如何在这两种不同的工具集中架起这两类不同思维之间的桥梁，以解决越来越需要这两套技能的问题？
- en: What do you think some of the largest evolutionary changes in programming languages
    over the next decade will be?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为在接下来的十年中，编程语言将经历哪些最大的进化变化？
- en: I think we’re seeing the broad shape of a trend now, which is the convergence
    between object-oriented and functional languages. Twenty years ago, languages
    were strictly separated into functional languages, procedural languages, and object-oriented
    languages, and they each had their own philosophy of how to model the world. But
    each of those models was deficient in some way because it was only modeling part
    of the world. What we’ve seen over the last decade or so, starting with languages
    like Scala and F#, and now languages like C# and Java, is that many of the concepts
    that originally took root in functional programming are finding their way into
    the more broad-spectrum languages, and I think that trend will only continue.
    Some people like to joke that all the languages are converging to $MY_FAVORITE_LANGUAGE.
    There’s some truth to that joke, in that functional languages are acquiring more
    tools for data encapsulation, and object-oriented languages are acquiring more
    tools for functional composition. And there’s an obvious reason, which is that
    these are both useful sets of tools. Each excels at one kind of problem or another,
    and we are called on to solve problems that have both aspects. So I think what
    we’re going to see over the next 10 years is an increased convergence of concepts
    that were traditionally considered object-oriented and concepts that were traditionally
    considered functional.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们现在看到的是一个趋势的大致轮廓，那就是面向对象和函数式语言的融合。二十年前，语言被严格地分为函数式语言、过程式语言和面向对象语言，每种语言都有自己的世界观建模哲学。但是，由于这些模型只模拟了世界的一部分，所以每个模型都有其不足之处。在过去十年左右的时间里，从像Scala和F#这样的语言开始，现在到C#和Java这样的语言，我们看到许多最初在函数式编程中生根发芽的概念正在逐渐融入更广泛的语言范畴，我认为这种趋势只会继续下去。有些人喜欢开玩笑说，所有语言都在趋同于$MY_FAVORITE_LANGUAGE。这个笑话中确实有一些真实性，因为函数式语言正在获得更多数据封装的工具，而面向对象语言正在获得更多函数式组合的工具。这有一个明显的理由，那就是这些工具集都是很有用的。每种语言在解决某一类问题时都表现出色，而我们被要求解决既有面向对象又有函数式特点的问题。因此，我认为在接下来的十年里，我们将看到传统上被认为是面向对象的概念和传统上被认为是函数式概念之间的概念融合将更加紧密。
- en: I think there are many examples of influences from the functional programming
    world on Java. Can you give us a few of those?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为有很多例子可以说明函数式编程世界对Java的影响。你能给我们举几个例子吗？
- en: The most obvious one is lambda expressions. And, you know, it’s not really fair
    to call them a functional programming concept because the lambda calculus predates
    computers by several decades. It is a natural model for describing and composing
    behavior. It makes just as much sense in a language like Java or C# as it does
    in Haskell or ML. So that’s clearly one. Another similar one is pattern matching,
    which again most people associate with functional languages, because that’s probably
    the first place they saw it, but actually, pattern matching goes way back to languages
    like SNOBOL from the ’70s, which was a text-processing language. Pattern matching
    actually fits into the object model very cleanly. It’s not a pure functional concept.
    It just happens that the functional languages noticed that it was useful a little
    bit before we did. A lot of these concepts that we associate with functional languages
    make perfect sense in object-oriented languages as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的一个是lambda表达式。你知道，称它们为函数式编程概念并不公平，因为lambda演算在计算机出现之前就已经存在了几十年。它是描述和组合行为的一个自然模型。它在Java或C#这样的语言中与在Haskell或ML这样的语言中一样合理。所以这显然是一个。另一个类似的概念是模式匹配，大多数人会将它与函数式语言联系起来，因为那可能是他们第一次看到它的地方，但实际上，模式匹配可以追溯到20世纪70年代的SNOBOL语言，它是一种文本处理语言。模式匹配在面向对象模型中非常干净利落。它不是一个纯粹的函数式概念。只是恰好函数式语言在我们之前注意到它是有用的。我们与函数式语言相关联的许多概念在面向对象语言中同样适用。
- en: Java is by many measures one of the most popular programming languages in the
    world. What do you think has caused it to be so successful, and why do you think
    it will continue to be successful going forward?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Java在许多衡量标准上都是世界上最受欢迎的编程语言之一。你认为是什么让它如此成功，你认为它为什么会在未来继续成功？
- en: As with any success, there’s a little bit of luck, and I think you should always
    acknowledge the role that luck has played in your success, because to do otherwise
    is not being honest. I think in many ways Java came around at just about the right
    time. At that time, the world was on the cusp of deciding whether to leap from
    C to C++. C was the dominant language at the time, for better or worse, and C++
    offered on the one hand better abstractive power than C, and on the other hand
    ungodly complexity. So you can imagine that the world was poised on a cliff, saying,
    “Do we really want to make this jump?” And Java came along and said, “I can give
    you most of what C++ is promising you without nearly as much complexity.” And
    everyone said, “Yes, please, we want that!” It was the right thing at the right
    time. It picked up on a number of old ideas that had been kicking around the computing
    world for years, including garbage collection and building concurrency into the
    programming model, that had not been used before in serious commercial languages.
    All of these things were relevant to the problems people were solving in the ’90s.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何成功一样，都有一点运气，我认为你应该始终承认运气在你成功中所起的作用，因为否则就不是诚实的。我认为在许多方面，Java 正好赶上了合适的时间。当时，世界正处于决定是否从
    C 跳跃到 C++ 的边缘。C 是当时的主导语言，无论是好是坏，而 C++ 一方面提供了比 C 更好的抽象能力，另一方面又具有难以置信的复杂性。所以你可以想象，世界正站在悬崖上，说：“我们真的想跳这个吗？”然后
    Java 出现了，说：“我可以给你提供 C++ 承诺的大部分东西，但复杂性却少得多。”每个人都说了：“是的，请，我们想要那个！”这是正确的时间做正确的事情。它采纳了许多在计算机世界中流传多年的旧想法，包括垃圾回收和将并发构建到编程模型中，这在之前的严肃商业语言中尚未使用过。所有这些都与人们在
    90 年代解决的问题相关。
- en: James Gosling has a quote where he describes Java as the “wolf in sheep’s clothing.”
    People needed garbage collection, they needed an integrated concurrency model
    that was better than pthreads, but they didn’t want the languages that these things
    traditionally came with because they came with all sorts of other things that
    scared the heck out of them. Java, on the other hand, looked like C. In fact,
    they went out of their way to make the syntax look like C. It was familiar, and
    then they could sneak some cool stuff along with it that you only noticed much
    later. One of the things that the creators of Java did was design the entire language
    runtime with the anticipation that just-in-time compilation was coming but wasn’t
    quite there. The first version of Java in 1995 was strictly interpreted. It was
    slow, but every design decision about the language and the class file format and
    the runtime structure was made with the know-how to make this fast. Eventually
    it became fast enough, and in some cases, even faster than C (though some people
    still don’t believe this is possible). So there was some right-place, right-time
    luck, and a lot of brilliant vision for where the technology was going and what
    people really needed, that got Java going. But that’s just what happened at the
    start--to keep Java number one, with competitors itching to eat Java’s lunch,
    we needed something more. And I think the thing that has kept us going, even through
    the dark times we discussed, is the relentless commitment to compatibility.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: James Gosling 有一个关于 Java 的引用，他把 Java 形容为“披着羊皮的狼”。人们需要垃圾回收，需要比 pthreads 更好的集成并发模型，但他们不想使用那些传统上带有这些功能的语言，因为这些语言带来了各种让他们感到恐惧的东西。另一方面，Java
    看起来像 C。事实上，他们特意让语法看起来像 C。它很熟悉，然后他们可以偷偷地加入一些酷炫的东西，你只有在很久以后才会注意到。Java 的创造者做的一件事是，在设计整个语言运行时，他们预期即时编译即将到来，但还没有完全实现。1995
    年的 Java 第一个版本是严格解释的。它很慢，但关于语言、类文件格式和运行时结构的每一个设计决策都是基于如何使其快速的知识。最终它变得足够快，在某些情况下，甚至比
    C 还快（尽管有些人仍然不相信这是可能的）。所以，这有一些恰到好处的运气，以及对技术发展方向和人们真正需要的许多精彩洞察，这些都让 Java 起步。但那只是开始时发生的事情——为了保持
    Java 的领先地位，面对渴望吃掉 Java 早餐的竞争对手，我们需要更多。我认为，即使在讨论的黑暗时期，我们也能坚持下去的原因是对兼容性的不懈承诺。
- en: Making incompatible changes is breaking your promises. It invalidates the investment
    that your customers have made in their code. Whenever you break someone’s code,
    you’re almost handing them an opportunity to go rewrite it in some other language,
    and Java has never done that. The Java code that you wrote 5, 10, 15, 20, 25 years
    ago still works. That means that we evolve a little bit more slowly. But it means
    that the investment you’ve made not only in code but in your understanding of
    how the language works is preserved. We don’t break our promises, and we don’t
    hurt our users in that way. The challenge is how to balance moving forward with
    that kind of commitment to compatibility. And I think that’s our secret weapon.
    We figured out how to do that in the last 25 years, and we’ve gotten pretty good
    at it. That’s what enables us to add generics, and lambda expressions, and modules,
    and pattern matching, and other things that may seem foreign to Java without making
    them look bolted on--because we figured out how to do this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 进行不兼容的更改就是打破你的承诺。它使你的客户在代码上的投资失效。每次你打破某人的代码时，你几乎是在给他们一个机会去用其他语言重写它，而Java从未这样做过。你5年前、10年前、15年前、20年前、25年前编写的Java代码仍然有效。这意味着我们发展得稍微慢一些。但这意味着你在代码以及你对语言工作方式的理解上所做的投资得到了保留。我们不打破我们的承诺，也不以这种方式伤害我们的用户。挑战是如何在前进的同时保持对兼容性的这种承诺。我认为这是我们秘密武器。我们在过去25年中找到了如何做到这一点的方法，并且我们在这方面做得相当不错。这就是我们能够添加泛型、lambda表达式、模块、模式匹配以及其他可能对Java来说显得陌生的东西，而不会使它们看起来像是附加的——因为我们找到了如何做到这一点的方法。
- en: Go gets a lot of credit for its integrated concurrency model, but Java already
    had synchronization primitives, keywords, and a threading model built into the
    language back in 1995\. Why do you think it doesn’t get more credit for this?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Go因其集成的并发模型而获得了许多赞誉，但Java在1995年就已经在语言中内置了同步原语、关键字和线程模型。你认为为什么它没有因此获得更多的赞誉呢？
- en: I think part of it is that a lot of the real cleverness is under the waterline
    where people don’t see it. When something just works, it often doesn’t get the
    credit. So that might be part of it. I’m not a big fan of Go for a couple of reasons.
    Everyone thinks that the concurrency model is Go’s secret weapon, but I think
    their concurrency model is actually quite error prone. That is, you have coroutines
    with a very basic message-passing mechanism (channels). But in almost all cases,
    the things on one side or the other of the channel are going to have some shared
    mutable state guarded with locks. And that means that you have the union of the
    mistakes you can make with message passing and the mistakes you can make with
    shared-state concurrency, combined with the fact that Go’s concurrency primitives
    for shared-state concurrency are dramatically weaker than those in Java. (For
    example, their locks aren’t reentrant, which means that you can’t compose any
    behaviors that use locks. It means that you often have to write two versions of
    the same thing--one to be called with lock held, one not to be called with the
    lock held.) I think what people will discover is that Go’s concurrency model,
    not unlike Reactive, is going to be a transitional technology that looked attractive
    for a while, but something better is going to come along, and I think people will
    desert it quite quickly. (Of course, that might just be my bias showing.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为部分原因在于，很多真正的巧妙之处都隐藏在水线下，人们看不到。当某件事只是正常工作时，它往往不会得到应有的赞誉。所以这可能就是其中的一部分。我不太喜欢Go，有几个原因。每个人都认为并发模型是Go的秘密武器，但我认为他们的并发模型实际上非常容易出错。也就是说，在通道的一侧或另一侧的东西都将有一些共享的可变状态，这些状态被锁所保护。这意味着你将消息传递中可能犯的错误和共享状态并发中可能犯的错误结合起来，再加上Go的共享状态并发原语在Java中明显较弱的事实。（例如，他们的锁不是可重入的，这意味着你不能组合任何使用锁的行为。这意味着你通常不得不写两个版本的同一样东西——一个是在持有锁的情况下调用，另一个是在不持有锁的情况下调用。）我认为人们会发现，Go的并发模型，就像响应式编程一样，将是一种过渡技术，它在一段时间内看起来很有吸引力，但更好的东西将会出现，我认为人们会很快放弃它。（当然，这可能是我的偏见在作祟。）
- en: What does your work look like on a day-to-day basis as the Java Language Architect?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java语言架构师，你日常工作中的工作内容是什么样的？
- en: 'It’s actually all over the map. Any given day, I could be doing pure research
    on language evolution and how far-off features will connect up. I could be prototyping
    the implementation of something to see how the moving parts fit together. I could
    be writing up a direction statement for the team: “Here’s where I think we are
    in the process of solving this problem, here’s what I think we have figured out,
    here are the problems that are left.” I might be speaking at conferences, talking
    to users, trying to understand what their pain points are, and to some degree,
    selling the message of where we’re going in the future. Any given day could be
    any of those things. Some of those things are very much in the moment, some are
    forward looking, some are backward looking, some are community facing, some are
    internal facing. Every day is different!'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，事情遍布各个方向。在任何一个给定的一天，我可能会进行关于语言演变和遥远特性如何连接的纯研究。我可能会原型化某个实现的实施，看看各个部分是如何配合的。我可能会为团队撰写一个方向声明：“这是我认为我们在解决这个问题的过程中所处的位置，这是我认为我们已经弄清楚的事情，这是剩下的问题。”我可能会在会议上发言，与用户交谈，试图了解他们的痛点，并在一定程度上，推广我们未来走向的信息。任何一个给定的一天都可能是那些事情中的任何一个。其中一些事情非常贴近当下，一些是前瞻性的，一些是回顾性的，一些是面向社区的，一些是面向内部的。每一天都是不同的！
- en: Right now, one of the projects that I’m involved in, that we’ve been working
    on for several years, is an upgrade to the generic type system to support primitives
    and primitive-like aggregates. This is something that touches the language, the
    compiler, the translation strategy, the class file format, and the JVM. In order
    to be able to credibly say that we have a story here, all of those pieces have
    to line up. So on any given day I might be working at the intersection of two
    of those things to see if the story is lining up properly or not. This is a process
    that can take years!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我参与的一个项目，我们已经投入了几年时间，是对通用类型系统进行升级，以支持原语和类似原语的聚合。这是涉及到语言、编译器、翻译策略、类文件格式和JVM的某个方面。为了能够有信心地说我们在这里有一个故事，所有这些部分都必须对齐。所以，在任何一个给定的一天，我可能会在两件事的交叉点上工作，看看故事是否正确对齐。这是一个可能需要数年才能完成的过程！
- en: What words of advice do you have for self-taught programmers trying to improve
    their skill set, students, or experienced developers going back and reviewing
    material to improve their computer science skills?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些试图提升技能集的自学者、学生，或者经验丰富的开发者，他们正在回顾材料以提升他们的计算机科学技能，你有什么建议？
- en: One of the most valuable ways to understand a technology is to put it in historical
    context. Ask, “How does this technology relate to whatever came before it for
    solving the same problem?” Because most developers don’t always get to pick what
    technology they’re using to solve a problem. If you were a developer in 2000 and
    you took a job, they would tell you, “We use this database, we use this application
    container, we use this IDE, we use this language. Now go program.” All of these
    choices were already made for you, and you might be overwhelmed by the complexity
    of how they all fit together. But every one of those pieces that you’re working
    with exists in a historical context, and it is the product of somebody’s better
    idea for solving a problem we solved in a different way yesterday. Very often
    you can get a better understanding of how a given piece of technology works by
    understanding what didn’t work about the previous iteration of the technology,
    what made someone say, “Let’s not do it that way. Let’s do it this way.” Because
    the history of computing is so compressed, most of that material is still available,
    and you can go back and read what was written about in the version 1.0 release.
    The designers will tell you why they invented it and what problems they were frustrated
    by that they couldn’t solve with yesterday’s technology. That technique is tremendously
    useful for understanding both what it’s for and the limitations that you’re going
    to run into.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一项技术的最有价值的方法之一是将它置于历史背景中。问自己，“这项技术与之前解决同样问题的技术有何关联？”因为大多数开发者并不总是能选择他们用来解决问题的技术。如果你是2000年的开发者，你接受了一份工作，他们会对你说，“我们使用这个数据库，我们使用这个应用容器，我们使用这个IDE，我们使用这种语言。现在去编程。”所有这些选择都是为你预先做好的，你可能会被它们如何相互配合的复杂性所淹没。但你所使用的每一个组件都存在于一个历史背景中，它是某人为了解决我们昨天以不同方式解决的问题而提出的更好想法的产物。通常，通过了解之前技术迭代中哪些没有工作，是什么让某人说出“我们不要那样做。让我们这样做。”，你可以更好地理解特定技术的工作原理。因为计算机的历史非常紧凑，大部分材料仍然可用，你可以回过头去阅读关于1.0版本发布时写下的内容。设计师会告诉你他们为什么发明它，以及他们无法用昨天的技术解决的问题让他们感到沮丧。这种技术对于理解它的用途以及你将要遇到的局限性非常有用。
- en: Brian can be followed on Twitter [@BrianGoetz](https://twitter.com/BrianGoetz).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Twitter上关注Brian [@BrianGoetz](https://twitter.com/BrianGoetz)。
