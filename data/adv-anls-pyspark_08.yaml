- en: Chapter 8\. Estimating Financial Risk
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。估计金融风险
- en: 'Is there a way to approximate how much you can expect to lose when investing
    in financial markets? This is the quantity that the financial statistic *value
    at risk* (VaR) seeks to measure. VaR is a simple measure of investment risk that
    tries to provide a reasonable estimate of the maximum probable loss in value of
    an investment portfolio over a particular time period. A VaR statistic depends
    on three parameters: a portfolio, a time period, and a probability. For example,
    a VaR value of $1 million with a 5% probability and two weeks indicates the belief
    that the portfolio stands only a 5% chance of losing more than $1 million over
    two weeks.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在投资金融市场时，是否有一种方法可以近似预期损失的量？这就是金融统计量*风险价值*（VaR）试图衡量的内容。VaR是一种简单的投资风险度量，试图提供投资组合在特定时间段内可能的最大损失的合理估计。VaR统计量依赖于三个参数：一个投资组合，一个时间段和一个概率。例如，VaR值为$1
    million，概率为5%，时间为两周，则表明投资组合只有5%的概率在两周内损失超过$1 million。
- en: Since its development soon after the stock market crash of 1987, VaR has seen
    widespread use across financial services organizations. The statistic plays a
    vital role in the management of these institutions by helping to determine the
    risk characteristics of their strategies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自1987年股市崩盘后不久，VaR在金融服务组织中广泛使用。该统计量通过帮助确定策略的风险特征，在这些机构的管理中发挥着至关重要的作用。
- en: Many of the most sophisticated approaches to estimating this statistic rely
    on computationally intensive simulations of markets under random conditions. The
    technique behind these approaches, called the Monte Carlo simulation, involves
    posing thousands or millions of random market scenarios and observing how they
    tend to affect a portfolio. These scenarios are referred to as *trials*. PySpark
    is an ideal tool for Monte Carlo simulations. PySpark can leverage thousands of
    cores to run random trials and aggregate their results. As a general-purpose data
    transformation engine, it is also adept at performing the pre- and postprocessing
    steps that surround the simulations. It can transform raw financial data into
    the model parameters needed to carry out the simulations, as well as support ad
    hoc analysis of the results. Its simple programming model can drastically reduce
    development time compared to more traditional approaches that use HPC environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多估计这一统计量的最复杂方法依赖于在随机条件下市场的计算密集型模拟。这些方法背后的技术被称为蒙特卡洛模拟，涉及提出数千甚至数百万个随机市场场景，并观察它们如何影响投资组合。这些场景被称为*试验*。PySpark是进行蒙特卡洛模拟的理想工具。PySpark可以利用数千个核心运行随机试验并汇总它们的结果。作为通用数据转换引擎，它还擅长执行围绕模拟的预处理和后处理步骤。它可以将原始金融数据转换为执行模拟所需的模型参数，并支持对结果的临时分析。与使用HPC环境的更传统方法相比，其简单的编程模型可以大大减少开发时间。
- en: We’ll also discuss how to compute a related statistic called *conditional value
    at risk* (CVaR), sometimes known as *expected shortfall*, which the Basel Committee
    on Banking Supervision proposed as a better risk measure than VaR a few years
    back. A CVaR statistic has the same three parameters as a VaR statistic but considers
    the expected average loss instead of providing a probable loss value. A CVaR of
    $5 million with a 5% *q-value* and two weeks indicates the belief that the average
    loss in the worst 5% of outcomes is $5 million.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何计算一个相关的统计量称为*条件风险价值*（CVaR），有时也称为*预期损失*，这是几年前巴塞尔银行监督委员会提出的比VaR更好的风险度量。CVaR统计量与VaR统计量具有相同的三个参数，但考虑的是预期平均损失，而不是提供可能损失的值。例如，CVaR为$5
    million，概率为5%，时间为两周，则表明最差的5%结果中平均损失为$5 million。
- en: In the process of modeling VaR, we’ll introduce a few different concepts, approaches,
    and packages. We’ll start by going over basic financial terminology that will
    be used throughout the chapter and then learn about the methods used to calculate
    VaR, including the Monte Carlo simulation technique. After that, we will download
    and prepare our dataset using PySpark and pandas. We’ll be using stock market
    data from late 2000s and early 2010s, including market indicators such as treasury
    bond prices along with stock values of various companies. Once done with preprocessing,
    we will create a linear regression model to calculate change in value for stocks
    over a time period. We’ll also come up with a way to generate sample market indicator
    values for use in trials when performing a Monte Carlo simulation. Finally, we’ll
    perform the simulation using PySpark and go over our results.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模VaR的过程中，我们将介绍一些不同的概念、方法和工具包。我们将从介绍贯穿整章使用的基本金融术语开始，然后学习计算VaR的方法，包括蒙特卡洛模拟技术。之后，我们将使用PySpark和pandas下载和准备我们的数据集。我们将使用2000年代末和2010年代初的股市数据，包括国债价格和各种公司的股票价值等市场指标。在预处理完成后，我们将创建一个线性回归模型，以计算股票在一段时间内的价值变化。我们还将想出一种方法，在执行蒙特卡洛模拟时生成样本市场指标值。最后，我们将使用PySpark执行模拟，并检查我们的结果。
- en: Let’s start by defining basic financial terms that we will use.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义我们将使用的基本金融术语。
- en: Terminology
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: 'This chapter makes use of a set of terms specific to the finance domain:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了金融领域特定术语的集合：
- en: Instrument
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 工具
- en: A tradable asset, such as a bond, loan, option, or stock investment. At any
    particular time, an instrument is considered to have a *value*, which is the price
    for which it could be sold.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可交易资产，例如债券、贷款、期权或股票投资。任何特定时间，工具都被认为具有*价值*，即其可售出价格。
- en: Portfolio
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 投资组合
- en: A collection of instruments owned by a financial institution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 金融机构拥有的一系列工具。
- en: Return
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 收益
- en: The change in an instrument or portfolio’s value over a time period.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间内工具或投资组合价值的变化。
- en: Loss
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 损失
- en: A negative return.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 负回报。
- en: Index
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 指数
- en: An imaginary portfolio of instruments. For example, the NASDAQ Composite Index
    includes about 3,000 stocks and similar instruments for major US and international
    companies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一种虚构的工具组合。例如，纳斯达克综合指数包括约3000只主要美国和国际公司的股票及类似工具。
- en: Market factor
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 市场因素
- en: A value that can be used as an indicator of macro aspects of the financial climate
    at a particular time—for example, the value of an index, the gross domestic product
    of the United States, or the exchange rate between the dollar and the euro. We
    will often refer to market factors as just *factors*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用作特定时间金融环境宏观方面指标的值——例如，一个指数的价值，美国的国内生产总值，或美元与欧元之间的汇率。我们通常将市场因素简称为*因素*。
- en: Methods for Calculating VaR
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算VaR的方法
- en: So far, our definition of VaR has been fairly open ended. Estimating this statistic
    requires proposing a model for how a portfolio functions and choosing the probability
    distribution its returns are likely to take. Institutions employ a variety of
    approaches for calculating VaR, all of which tend to fall under a few general
    methods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对风险价值（VaR）的定义一直比较开放。估计这一统计量需要提出一个关于投资组合运作方式的模型，并选择其收益可能服从的概率分布。机构采用各种方法来计算VaR，这些方法通常可以归纳为几种一般方法之下。
- en: Variance-Covariance
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方差-协方差
- en: '*Variance-covariance* is by far the simplest and least computationally intensive
    method. Its model assumes that the return of each instrument is normally distributed,
    which allows deriving an estimate analytically.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*方差-协方差*方法是最简单且计算强度最低的方法。其模型假设每种工具的收益服从正态分布，这使得可以通过解析推导出一个估计值。'
- en: Historical Simulation
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史模拟
- en: '*Historical simulation* extrapolates risk from historical data by using its
    distribution directly instead of relying on summary statistics. For example, to
    determine a 95% VaR for a portfolio, we might look at that portfolio’s performance
    for the last 100 days and estimate the statistic as its value on the fifth-worst
    day. A drawback of this method is that historical data can be limited and fails
    to include what-ifs. For example, what if the history we have for the instruments
    in our portfolio lacks market collapses, and we want to model what happens to
    our portfolio in these situations? Techniques exist for making historical simulation
    robust to these issues, such as introducing “shocks” into the data, but we won’t
    cover them here.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*历史模拟*通过直接使用其分布而不依赖于摘要统计数据，从历史数据中推断风险。例如，为了确定一个投资组合的95% VaR，我们可能会查看该投资组合过去100天的表现，并将该统计数据估计为第五差的一天的值。这种方法的一个缺点是，历史数据可能有限，并且未包含假设情况。例如，如果我们投资组合中的工具的历史缺乏市场崩盘，我们想要模拟在这些情况下我们的投资组合会发生什么？存在技术可以使历史模拟能够应对这些问题，例如向数据引入“冲击”，但我们在这里不会详细介绍这些技术。'
- en: Monte Carlo Simulation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟
- en: '*Monte Carlo simulation*, which the rest of this chapter will focus on, tries
    to weaken the assumptions in the previous methods by simulating the portfolio
    under random conditions. When we can’t derive a closed form for a probability
    distribution analytically, we can often estimate its probability density function
    by repeatedly sampling simpler random variables that it depends on and seeing
    how it plays out in aggregate. In its most general form, this method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*蒙特卡洛模拟*，本章的其余部分将重点介绍，试图通过在随机条件下模拟投资组合来减弱前述方法中的假设。当我们无法从解析上导出一个概率分布的闭合形式时，我们通常可以通过重复抽样它所依赖的更简单的随机变量来估计其概率密度函数，并观察其在总体上的表现。在其最一般的形式中，该方法：'
- en: Defines a relationship between market conditions and each instrument’s returns.
    This relationship takes the form of a model fitted to historical data.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定市场条件与每种工具收益之间的关系。该关系采用根据历史数据拟合的模型形式。
- en: Defines distributions for the market conditions that are straightforward to
    sample from. These distributions are fitted to historical data.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为市场条件定义分布，可以方便地从中进行抽样。这些分布是根据历史数据拟合的。
- en: Poses trials consisting of random market conditions.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出由随机市场条件组成的试验。
- en: Calculates the total portfolio loss for each trial and uses these losses to
    define an empirical distribution over losses. This means that if we run 100 trials
    and want to estimate the 5% VaR, we would choose it as the loss from the trial
    with the fifth-greatest loss. To calculate the 5% CVaR, we would find the average
    loss over the five worst trials.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每次试验的总投资组合损失，并使用这些损失来定义损失的经验分布。这意味着如果我们进行100次试验，并希望估计5%的VaR，则会选择第五大损失的试验。要计算5%的CVaR，则会找到五个最差试验的平均损失。
- en: Of course, the Monte Carlo method isn’t perfect either. It relies on models
    for generating trial conditions and for inferring instrument performance, and
    these models must make simplifying assumptions. If these assumptions don’t correspond
    to reality, then neither will the final probability distribution that comes out.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，蒙特卡洛方法也并非完美无缺。它依赖于用于生成试验条件和推断仪器性能的模型，而这些模型必须做出简化的假设。如果这些假设与现实不符，那么最终得出的概率分布也将不符合实际情况。
- en: Our Model
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的模型
- en: 'A Monte Carlo risk model typically phrases each instrument’s return in terms
    of a set of market factors. Common market factors might be the value of indexes
    like the S&P 500, the US GDP, or currency exchange rates. We then need a model
    that predicts the return of each instrument based on these market conditions.
    In our simulation, we’ll use a simple linear model. By our previous definition
    of return, a *factor return* is a change in the value of a market factor over
    a particular time. For example, if the value of the S&P 500 moves from 2,000 to
    2,100 over a time interval, its return would be 100\. We’ll derive a set of features
    from simple transformations of the factor returns. That is, the market factor
    vector *m[t]* for a trial *t* is transformed by some function ϕ to produce a feature
    vector of possible different length *f[t]*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛风险模型通常将每个工具的回报表述为一组市场因素。常见的市场因素可能是诸如标准普尔500指数、美国GDP或货币汇率等的指数值。然后，我们需要一个模型，根据这些市场条件预测每个工具的回报。在我们的模拟中，我们将使用一个简单的线性模型。按照我们之前对回报的定义，*因子回报*是市场因素在特定时间内的价值变化。例如，如果标准普尔500指数的值从2000变到2100，在一个时间间隔内，其回报将是100。我们将从因子回报的简单转换中派生一组特征。也就是说，对于试验*t*，市场因素向量*m[t]*通过某些函数ϕ转换为可能具有不同长度*f[t]*的特征向量：
- en: '*f[t] = ϕ(m[t])*'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f[t] = ϕ(m[t])*'
- en: 'For each instrument, we’ll train a model that assigns a weight to each feature.
    To calculate *r[it]*, the return of instrument *i* in trial *t*, we use *c[i]*,
    the intercept term for the instrument; *w[ij]*, the regression weight for feature
    *j* on instrument *i*; and *f[tj]*, the randomly generated value of feature *j*
    in trial *t*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个工具，我们将训练一个模型，为每个特征分配一个权重。为了计算试验*t*中工具*i*的回报*r[it]*，我们使用*c[i]*，工具*i*的截距项；*w[ij]*，工具*i*在特征*j*上的回归权重；以及*f[tj]*，试验*t*中特征*j*的随机生成值：
- en: <math alttext="r Subscript i t Baseline equals c Subscript i Baseline plus sigma-summation
    Underscript j equals 1 Overscript StartAbsoluteValue w Subscript i Baseline EndAbsoluteValue
    Endscripts w Subscript i j Baseline asterisk f Subscript t j" display="block"><mrow><msub><mi>r</mi>
    <mrow><mi>i</mi><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>c</mi> <mi>i</mi></msub>
    <mo>+</mo> <munderover><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mrow><mrow><mo>|</mo></mrow><msub><mi>w</mi> <mi>i</mi></msub> <mrow><mo>|</mo></mrow></mrow></munderover>
    <msub><mi>w</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub> <mo>*</mo> <msub><mi>f</mi>
    <mrow><mi>t</mi><mi>j</mi></mrow></msub></mrow></math>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="r Subscript i t Baseline equals c Subscript i Baseline plus sigma-summation
    Underscript j equals 1 Overscript StartAbsoluteValue w Subscript i Baseline EndAbsoluteValue
    Endscripts w Subscript i j Baseline asterisk f Subscript t j" display="block"><mrow><msub><mi>r</mi>
    <mrow><mi>i</mi><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>c</mi> <mi>i</mi></msub>
    <mo>+</mo> <munderover><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mrow><mrow><mo>|</mo></mrow><msub><mi>w</mi> <mi>i</mi></msub> <mrow><mo>|</mo></mrow></mrow></munderover>
    <msub><mi>w</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub> <mo>*</mo> <msub><mi>f</mi>
    <mrow><mi>t</mi><mi>j</mi></mrow></msub></mrow></math>
- en: This means that the return of each instrument is calculated as the sum of the
    returns of the market factor features multiplied by their weights for that instrument.
    We can fit the linear model for each instrument using historical data (also known
    as doing linear regression). If the horizon of the VaR calculation is two weeks,
    the regression treats every (overlapping) two-week interval in history as a labeled
    point.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个工具的回报被计算为市场因素特征的回报乘以它们在该工具上的权重的总和。我们可以使用历史数据（也称为进行线性回归）为每个工具拟合线性模型。如果VaR计算的视野是两周，则回归将历史上的每个（重叠的）两周间隔视为一个标记点。
- en: 'It’s also worth mentioning that we could have chosen a more complicated model.
    For example, the model need not be linear: it could be a regression tree or explicitly
    incorporate domain-specific knowledge.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们也可以选择更复杂的模型。例如，模型不一定是线性的：它可以是回归树或明确地结合领域特定知识。
- en: 'Now that we have our model for calculating instrument losses from market factors,
    we need a process for simulating the behavior of market factors. A simple assumption
    is that each market factor return follows a normal distribution. To capture the
    fact that market factors are often correlated—when the NASDAQ is down, the Dow
    is likely to be suffering as well—we can use a multivariate normal distribution
    with a nondiagonal covariance matrix:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了计算市场因素造成的工具损失的模型，我们需要一个模拟市场因素行为的过程。一个简单的假设是每个市场因素回报都遵循正态分布。为了捕捉市场因素通常相关的事实——当纳斯达克下跌时，道琼斯也可能在遭受损失——我们可以使用具有非对角协方差矩阵的多元正态分布：
- en: <math alttext="m Subscript t Baseline tilde script upper N left-parenthesis
    mu comma normal upper Sigma right-parenthesis" display="block"><mrow><msub><mi>m</mi>
    <mi>t</mi></msub> <mo>∼</mo> <mi>𝒩</mi> <mrow><mo>(</mo> <mi>μ</mi> <mo>,</mo>
    <mi>Σ</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="m Subscript t Baseline tilde script upper N left-parenthesis
    mu comma normal upper Sigma right-parenthesis" display="block"><mrow><msub><mi>m</mi>
    <mi>t</mi></msub> <mo>∼</mo> <mi>𝒩</mi> <mrow><mo>(</mo> <mi>μ</mi> <mo>,</mo>
    <mi>Σ</mi> <mo>)</mo></mrow></mrow></math>
- en: where μ is a vector of the empirical means of the returns of the factors and
    Σ is the empirical covariance matrix of the returns of the factors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，μ是因素回报的经验均值向量，Σ是因素回报的经验协方差矩阵。
- en: As before, we could have chosen a more complicated method of simulating the
    market or assumed a different type of distribution for each market factor, perhaps
    using distributions with fatter tails.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们可以选择更复杂的模拟市场的方法，或者假设每个市场因素的不同类型分布，也许使用尾部更厚的分布。
- en: Getting the Data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'Download the historical stock price dataset and place it in a *data/stocks/*
    directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下载历史股价数据集并将其放置在*data/stocks/*目录中：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It can be difficult to find large volumes of nicely formatted historical price
    data. The dataset used in this chapter was downloaded from Yahoo!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 找到大量格式良好的历史价格数据可能很困难。本章使用的数据集是从Yahoo!下载的。
- en: 'We also need historical data for risk factors. For our factors, we’ll use the
    values of:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要风险因素的历史数据。对于我们的因素，我们将使用以下值：
- en: 'iShares 20 Plus Year Treasury Bond ETF (NASDAQ: TLT)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iShares 20 Plus Year Treasury Bond ETF (纳斯达克：TLT)
- en: 'iShares US Credit Bond ETF (NYSEArca: CRED)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'iShares 美国信用债券ETF（NYSEArca: CRED）'
- en: 'SPDR Gold Trust (NYSEArca: GLD)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '黄金ETF信托基金（NYSEArca: GLD）'
- en: 'Download and place the factors data:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并放置因子数据：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s have a look at one of our factors:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其中一个因子：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With our dataset downloaded, we will now prepare it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下载了我们的数据集后，我们现在将对其进行准备。
- en: Preparing the Data
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'The first few rows of the Yahoo!-formatted data for GOOGL look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 雅虎格式化数据中 GOOGL 的前几行如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s fire up the PySpark shell:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 PySpark shell：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Read in the instruments dataset as a DataFrame:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 DataFrame 读取工具数据集：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The DataFrame is missing the instrument symbol. Let’s add that using the input
    filenames corresponding to each row:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 缺少工具符号。 让我们使用对应每一行的输入文件名添加它：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will read in and process the factors dataset in a similar manner:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以类似的方式读取并处理因子数据集：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We filter out instruments with less than five years of history:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过滤掉历史不足五年的工具：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Different types of instruments may trade on different days, or the data may
    have missing values for other reasons, so it is important to make sure that our
    different histories align. First, we need to trim all of our time series to the
    same period in time. To do that, we’ll first convert the `Date` column’s type
    from string to date:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的工具可能在不同的日期交易，或者数据可能由于其他原因缺少值，因此确保我们不同历史记录对齐非常重要。 首先，我们需要将所有时间序列修剪到同一时间段内。
    为此，我们首先将`Date`列的类型从字符串转换为日期：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s trim the time periods of instruments to align:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修剪工具的时间段以对齐：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will convert the `Date` column’s type and trim the time period in our factors
    DataFrame too:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转换`Date`列的类型，并在因子DataFrame中也修剪时间段：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The histories of a few thousand instruments and three factors are small enough
    to read and process locally. This remains the case even for larger simulations
    with hundreds of thousands of instruments and thousands of factors. Even though
    we have used PySpark for preprocessing our data so far, the need arises for a
    distributed system such as PySpark when we’re actually running the simulations,
    which can require massive amounts of computation on each instrument. We can convert
    our PySpark DataFrame into a pandas DataFrame and still continue working with
    it easily by performing in-memory operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 几千个工具和三个因子的历史数据足够小，可以在本地读取和处理。 即使在具有数十万个工具和数千个因子的更大模拟中，情况也是如此。 尽管到目前为止我们使用 PySpark
    对数据进行预处理，但在实际运行模拟时，例如可以需要大量计算的分布式系统（如 PySpark）。 我们可以将 PySpark DataFrame 转换为 pandas
    DataFrame，并继续通过执行内存操作轻松地处理它。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will use these pandas DataFrames in the next section as we try to fit a linear
    regression model to predict instrument returns based on factor returns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中使用这些 pandas DataFrame，尝试将线性回归模型拟合到基于因子回报的工具回报上。
- en: Determining the Factor Weights
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定因子权重
- en: 'Recall that VaR deals with losses *over a particular time horizon*. We are
    not concerned with the absolute prices of instruments, but with how those prices
    move over a given length of time. In our calculation, we will set that length
    to two weeks. The following function makes use of the pandas `rolling` method
    to transform a time series of prices into an overlapping sequence of price movements
    over two-week intervals. Note that we use 10 instead of 14 to define the window
    because financial data does not include weekends:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾VaR处理*特定时间段内*的损失。 我们关心的不是工具的绝对价格，而是这些价格在给定时间长度内的变动情况。 在我们的计算中，我们将该长度设定为两周。
    以下功能利用 pandas 的`rolling`方法，将价格时间序列转换为重叠的两周价格变动序列。 请注意，我们使用10而不是14来定义窗口，因为金融数据不包括周末：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With these return histories in hand, we can turn to our goal of training predictive
    models for the instrument returns. For each instrument, we want a model that predicts
    its two-week return based on the returns of the factors over the same time period.
    For simplicity, we will use a linear regression model.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 手头有了这些回报历史数据，我们可以着手训练用于工具回报预测的预测模型。 对于每个工具，我们希望有一个模型，根据相同时间段内因子的回报来预测其两周回报。
    为简单起见，我们将使用线性回归模型。
- en: 'To model the fact that instrument returns may be nonlinear functions of the
    factor returns, we can include some additional features in our model that we derive
    from nonlinear transformations of the factor returns. As an example, we will add
    one additional feature for each factor return: square. Our model is still a linear
    model in the sense that the response variable is a linear function of the features.
    Some of the features just happen to be determined by nonlinear functions of the
    factor returns. Keep in mind that this particular feature transformation is meant
    to demonstrate some of the options available—it shouldn’t be perceived as a state-of-the-art
    practice in predictive financial modeling.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建模工具回报可能是因子回报的非线性函数，我们可以在模型中包含一些额外的特征，这些特征是从因子回报的非线性变换中导出的。例如，我们将为每个因子回报添加一个额外的特征：平方。从特征的角度来看，我们的模型仍然是线性模型。某些特征只是碰巧由因子回报的非线性函数确定。请记住，这种特定的特征变换旨在展示可用选项中的一些内容，不应被视为预测金融建模中的最先进实践。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_estimating_financial_risk_CO1-1)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_estimating_financial_risk_CO1-1)'
- en: Convert factors dataframe from long to wide format so that all factors for a
    period are in one row
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将因子数据框从长格式转换为宽格式，以便每个周期的所有因子都在一行中
- en: '[![2](assets/2.png)](#co_estimating_financial_risk_CO1-2)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_estimating_financial_risk_CO1-2)'
- en: Flatten multi-index dataframe and fix column names
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 展平多级索引数据框并修复列名
- en: 'Even though we will be carrying out many regressions—one for each instrument—the
    number of features and data points in each regression is small, meaning that we
    don’t need to make use of PySpark’s distributed linear modeling capabilities.
    Instead, we’ll use the ordinary least squares regression offered by the scikit-learn
    package:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将执行许多回归分析——每个工具一个——每个回归中的特征数和数据点数都很小，这意味着我们不需要利用PySpark的分布式线性建模能力。相反，我们将使用scikit-learn包提供的普通最小二乘回归：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We now have a dataframe where each row is the set of model parameters (coefficients,
    weights, covariants, regressors, or whatever you wish to call them) for an instrument.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个数据框，其中每一行都是一个工具的模型参数（系数、权重、协变量、回归器或者你想称呼它们的任何东西）。
- en: At this point in any real-world pipeline it would be useful to understand how
    well these models fit the data. Because the data points are drawn from time series,
    and especially because the time intervals are overlapping, it is very likely that
    the samples are autocorrelated. This means that common measures like *R*² are
    likely to overestimate how well the models fit the data. The [Breusch-Godfrey
    test](https://oreil.ly/9cwg6) is a standard test for assessing these effects.
    One quick way to evaluate a model is to separate a time series into two sets,
    leaving out enough data points in the middle so that the last points in the earlier
    set are not autocorrelated with the first points in the later set. Then train
    the model on one set and look at its error on the other.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何实际的流程中，理解这些模型如何与数据拟合是很有用的。由于数据点来自时间序列，特别是因为时间间隔重叠，很可能样本是自相关的。这意味着常见的测量如*R*²很可能会高估模型拟合数据的效果。[布鲁舍-戈德弗雷检验](https://oreil.ly/9cwg6)是评估这些效应的标准检验方法。评估模型的一个快速方法是将时间序列分为两组，中间留出足够的数据点，使得前一组的最后点与后一组的第一点不自相关。然后在一组上训练模型，并查看其在另一组上的误差。
- en: With our models that map factor returns to instrument returns in hand, we now
    need a procedure for simulating market conditions by generating random factor
    returns. That’s what we’ll do next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们手头有将因子回报映射到工具回报的模型，接下来我们需要一个过程来通过生成随机因子回报来模拟市场条件。这就是我们接下来要做的。
- en: Sampling
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采样
- en: To come up with a way for generating random factor returns, we need to decide
    on a probability distribution over factor return vectors and sample from it. What
    distribution does the data actually take? It can often be useful to start answering
    this kind of question visually.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要想出一个生成随机因子回报的方法，我们需要决定一个因子回报向量上的概率分布，并从中进行采样。数据实际上取什么分布？通常可以从视觉上开始回答这类问题是有用的。
- en: A nice way to visualize a probability distribution over continuous data is a
    density plot that plots the distribution’s domain versus its probability density
    function. Because we don’t know the distribution that governs the data, we don’t
    have an equation that can give us its density at an arbitrary point, but we can
    approximate it through a technique called *kernel density estimation* (KDE). In
    a loose way, kernel density estimation is a way of smoothing out a histogram.
    It centers a probability distribution (usually a normal distribution) at each
    data point. So a set of two-week-return samples would result in multiple normal
    distributions, each with a different mean. To estimate the probability density
    at a given point, it evaluates the PDFs of all the normal distributions at that
    point and takes their average. The smoothness of a kernel density plot depends
    on its *bandwidth*, the standard deviation of each of the normal distributions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一种很好的方法来可视化连续数据上的概率分布是密度图，它将分布的定义域与其概率密度函数进行绘制。因为我们不知道控制数据的分布，所以我们没有能够在任意点给出其密度的方程，但是我们可以通过一种称为*核密度估计*（KDE）的技术来近似它。以一种宽松的方式，核密度估计是平滑直方图的一种方法。它在每个数据点处都会居中一个概率分布（通常是正态分布）。因此，一个两周回报样本集将产生多个正态分布，每个都有不同的均值。为了估计给定点处的概率密度，它评估所有正态分布在该点的概率密度函数，并取它们的平均值。核密度图的平滑程度取决于其*带宽*，即每个正态分布的标准差。
- en: 'We’ll use one of pandas DataFrame’s built-in methods to calculate and draw
    a KDE plot. The following snippet creates a density plot for one of our factors:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 pandas DataFrame 的内置方法之一来计算并绘制 KDE 图。以下代码片段创建了一个因子的密度图：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Figure 8-1](#figure8-1) shows the distribution (probability density function)
    of two-week returns for the 20+ Year Treasury Bond ETF in our history.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](#figure8-1) 显示了我们历史中两周期国库债券 ETF 的回报分布（概率密度函数）。'
- en: '![Two-week 20+ Year Treasury Bond ETF distribution](assets/aaps_0801.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![两周 20+ 年期国库债券 ETF 分布](assets/aaps_0801.png)'
- en: Figure 8-1\. Two-week 20+ Year Treasury Bond ETF distribution
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 两周 20+ 年期国库债券 ETF 回报分布
- en: '[Figure 8-2](#figure8-2) shows the same for two-week returns of US Credit Bonds.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](#figure8-2) 展示了美国信用债的两周回报情况。'
- en: '![aaps 0802](assets/aaps_0802.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![aaps 0802](assets/aaps_0802.png)'
- en: Figure 8-2\. Two-week US Credit Bond ETF returns distribution
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. 美国信用债 ETF 两周回报分布
- en: We will fit a normal distribution to the returns of each factor. Looking for
    a more exotic distribution, perhaps with fatter tails, that more closely fits
    the data is often worthwhile. However, for the sake of simplicity, we’ll avoid
    tuning our simulation in this way.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对每个因子的回报拟合一个正态分布。寻找更接近数据的、可能具有更胖尾巴的更奇特分布通常是值得的。然而，为了简单起见，我们将避免以这种方式调整我们的模拟。
- en: 'The simplest way to sample factors’ returns would be to fit a normal distribution
    to each of the factors and sample from these distributions independently. However,
    this ignores the fact that market factors are often correlated. If the Treasury
    Bond ETF is down, the Credit Bond ETF is likely to be down as well. Failing to
    take these correlations into account can give us a much rosier picture of our
    risk profile than its reality. Are the returns of our factors correlated? The
    Pearson’s correlation implementation in pandas can help us find out:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对因子的回报进行抽样的最简单方法是对每个因子拟合一个正态分布，并从这些分布中独立抽样。然而，这忽视了市场因子通常存在相关性的事实。如果国库债券 ETF
    下跌，信用债券 ETF 也可能下跌。未能考虑这些相关性可能使我们对风险配置的实际情况持有过于乐观的看法。我们的因子回报是否相关？pandas 中的 Pearson
    相关性实现可以帮助我们找出答案：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because we have nonzero elements off the diagonals, it doesn’t look like it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的非对角元素是非零的，所以它看起来并不像它。
- en: The Multivariate Normal Distribution
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多元正态分布
- en: The multivariate normal distribution can help here by taking the correlation
    information between the factors into account. Each sample from a multivariate
    normal is a vector. Given values for all of the dimensions but one, the distribution
    of values along that dimension is normal. But, in their joint distribution, the
    variables are not independent.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 多元正态分布在这里有助于考虑因子之间的相关信息。来自多元正态分布的每个样本都是一个向量。对于所有维度中除一维之外的给定值，该维度上的值分布是正态的。但是，在它们的联合分布中，变量并不是独立的。
- en: The multivariate normal is parameterized with a mean along each dimension and
    a matrix describing the covariances between each pair of dimensions. With *N*
    dimensions, the covariance matrix is *N* by *N* because we want to capture the
    covariances between each pair of dimensions. When the covariance matrix is diagonal,
    the multivariate normal reduces to sampling along each dimension independently,
    but placing nonzero values in the off-diagonals helps capture the relationships
    between variables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多元正态分布是用每个维度的均值和描述每对维度之间的协方差的矩阵来参数化的。对于*N*个维度，协方差矩阵是*N*乘*N*的，因为我们想要捕获每对维度之间的协方差。当协方差矩阵是对角线时，多元正态分布将减少到沿着每个维度独立采样，但在对角线上放置非零值有助于捕获变量之间的关系。
- en: The VaR literature often describes a step in which the factor weights are transformed
    (decorrelated) so that sampling can proceed. This is normally accomplished with
    a Cholesky decomposition or eigendecomposition. NumPy package’s `M⁠u⁠l⁠t⁠i⁠v⁠a⁠r⁠i⁠a⁠t⁠e​N⁠o⁠r⁠m⁠a⁠l⁠Distribution`
    takes care of this step for us under the covers using an eigendecomposition.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: VaR文献通常描述了一种在因子权重被转换（去相关）的步骤，以便可以进行采样。这通常通过Cholesky分解或特征分解来完成。NumPy软件包的`MultivariateNormalDistribution`在底层使用特征分解为我们处理了这一步。
- en: 'To fit a multivariate normal distribution to our data, first we need to find
    its sample means and covariances:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要将多元正态分布拟合到我们的数据中，首先我们需要找到其样本均值和协方差：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we can simply create a distribution parameterized with them and sample
    a set of market conditions from it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以简单地创建一个以它们为参数的分布，并从中采样一组市场条件：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the per-instrument models and a procedure for sampling factor returns,
    we now have the pieces we need to run the actual trials. Let’s start working on
    our simulation and run the trials.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了每个仪器模型和采样因子收益的过程，我们现在有了运行实际试验所需的部件。让我们开始着手进行我们的模拟并运行试验。
- en: Running the Trials
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行试验
- en: Because running the trials is computationally intensive, we’ll turn to PySpark
    to help us parallelize them. In each trial, we want to sample a set of risk factors,
    use them to predict the return of each instrument, and sum all those returns to
    find the full trial loss. To achieve a representative distribution, we want to
    run thousands or millions of these trials.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运行试验是计算密集型的，我们将求助于PySpark来帮助我们并行化它们。在每个试验中，我们希望采样一组风险因素，用它们来预测每个仪器的收益，并将所有这些收益相加以找到完整的试验损失。为了获得代表性的分布，我们希望运行数千或数百万次这样的试验。
- en: We have a few choices for how to parallelize the simulation. We can parallelize
    along trials, instruments, or both. To parallelize along both, we would create
    a dataset of instruments and a dataset of trial parameters and then use the `crossJoin`
    transformation to generate a dataset of all the pairs. This is the most general
    approach, but it has a couple of disadvantages. First, it requires explicitly
    creating a DataFrame of trial parameters, which we can avoid by using some tricks
    with random seeds. Second, it requires a shuffle operation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种选择来并行化模拟。我们可以沿试验、仪器或两者一起并行化。要沿两者一起并行化，我们将创建一个仪器数据集和一个试验参数数据集，然后使用`crossJoin`转换来生成所有配对的数据集。这是最一般的方法，但它有一些缺点。首先，它需要明确创建一个试验参数的DataFrame，我们可以通过一些随机种子的技巧来避免这种情况。其次，它需要一个洗牌操作。
- en: 'Partitioning along instruments would look something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 沿仪器分区的情况如下所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this approach, the data is partitioned across a DataFrame of instruments,
    and for each instrument a `flatMap` transformation computes and yields the loss
    against every trial. Using the same random seed across all tasks means that we
    will generate the same sequence of trials. `reduceByKey` sums together all the
    losses corresponding to the same trials. A disadvantage of this approach is that
    it still requires shuffling *O*(|instruments| * |trials|) data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，数据被分区到一个仪器DataFrame中，并且对于每个仪器，`flatMap`转换计算并产生了针对每个试验的损失。在所有任务中使用相同的随机种子意味着我们将生成相同的试验序列。`reduceByKey`将所有与相同试验对应的损失相加在一起。这种方法的一个缺点是它仍然需要对*O*(|instruments|
    * |trials|)数据进行洗牌。
- en: Our model data for our few thousand instruments is small enough to fit in memory
    on every executor, and some back-of-the-envelope calculations reveal that this
    is probably still the case even with a million or so instruments and hundreds
    of factors. A million instruments times 500 factors times the 8 bytes needed for
    the double that stores each factor weight equals roughly 4 GB, small enough to
    fit in each executor on most modern-day cluster machines. This means that a good
    option is to distribute the instrument data in a broadcast variable. The advantage
    of each executor having a full copy of the instrument data is that total loss
    for each trial can be computed on a single machine. No aggregation is necessary.
    We also broadcast some other data required for trial return calculation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们少量工具的模型数据足够小，可以在每个执行器的内存中容纳，并且一些粗略的计算显示，即使是数百万工具和数百个因素，这可能仍然适用。百万工具乘以500因素乘以存储每个因素权重所需的8字节，大约相当于4
    GB，足够小，可以在大多数现代集群机器的每个执行器上容纳。这意味着一个好的选择是在广播变量中分发工具数据。每个执行器拥有工具数据的完整副本的优势在于可以在单台机器上计算每个试验的总损失。不需要聚合。我们还广播了一些其他用于计算试验回报所需的数据。
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the partition-by-trials approach (which we will use), we start out with
    a DataFrame of seeds. We want a different seed in each partition so that each
    partition generates different trials:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用按试验分区的方法（我们将使用它），我们从种子的DataFrame开始。我们希望每个分区中有一个不同的种子，以便每个分区生成不同的试验：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Random number generation is a time-consuming and CPU-intensive process. While
    we don’t employ this trick here, it can often be useful to generate a set of random
    numbers in advance and use it across multiple jobs. The same random numbers should
    *not* be used within a single job, because this would violate the Monte Carlo
    assumption that the random values are independently distributed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成是一个耗时且CPU密集型的过程。虽然我们在这里没有使用这个技巧，但通常可以预先生成一组随机数，并在多个作业中使用它。不应在单个作业内使用相同的随机数，因为这将违反蒙特卡洛假设，即随机值是独立分布的。
- en: 'For each seed, we want to generate a set of trial parameters and observe the
    effects of these parameters on all the instruments. We will write a function that
    calculates the full return of instruments for multiple trials. We start by simply
    applying the linear model that we trained earlier for each instrument. Then we
    average over the returns of all the instruments. This assumes that we’re holding
    an equal value of each instrument in the portfolio. A weighted average would be
    used if we held different amounts of each stock. Lastly, we need to generate a
    bunch of trials in each task. Because choosing random numbers is a big part of
    the process, it is important to use a strong random number generator. Python’s
    in-built `random` library includes a Mersenne Twister implementation that is good
    for this. We use it to sample from a multivariate normal distribution as described
    previously:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个种子，我们希望生成一组试验参数，并观察这些参数对所有仪器的影响。我们将编写一个函数来计算多个试验的所有仪器的全面回报。我们首先简单地应用我们之前为每个仪器训练的线性模型。然后我们对所有仪器的回报取平均值。这假设我们在投资组合中持有每种仪器相等的价值。如果我们持有不同数量的每只股票，则将使用加权平均。最后，在每个任务中我们需要生成一堆试验。因为选择随机数是该过程的一个重要部分，所以使用强随机数生成器非常重要。Python内置的`random`库包括一个梅森旋转实现，非常适合这个任务。我们用它来从先前描述的多变量正态分布中抽样：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With our scaffolding complete, we can use it to compute a DataFrame where each
    element is the total return from a single trial:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的支架完成，我们可以用它来计算一个DataFrame，其中每个元素是单个试验的总回报：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_estimating_financial_risk_CO2-1)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_estimating_financial_risk_CO2-1)'
- en: Split array of trial returns into individual DataFrame rows
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将试验回报的分割数组拆分为单独的DataFrame行
- en: 'If you recall, the whole reason we’ve been messing around with all these numbers
    is to calculate VaR. `trials` now forms an empirical distribution over portfolio
    returns. To calculate 5% VaR, we need to find a return that we expect to underperform
    5% of the time, and a return that we expect to outperform 5% of the time. With
    our empirical distribution, this is as simple as finding the value that 5% of
    trials are worse than and 95% of trials are better than. We can accomplish this
    by pulling the worst 5% of trials into the driver. Our VaR is the return of the
    best trial in this subset:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们一直在处理所有这些数字的整个原因是为了计算 VaR。现在，`trials` 形成了投资组合收益的经验分布。为了计算 5% VaR，我们需要找到预计会低于
    5% 时间的收益和预计会超过 5% 时间的收益。通过我们的经验分布，这就像找到比率中最差的 5% 和比率中最好的 95% 一样简单。我们可以通过把最差的 5%
    的试验拉到驾驶中来实现这一点。我们的 VaR 是这个子集中最佳试验的收益：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can find the CVaR with a nearly identical approach. Instead of taking the
    best trial return from the worst 5% of trials, we take the average return from
    that set of trials:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用几乎相同的方法找到 CVaR。不同于从最差的 5% 试验中取最佳试验收益，我们从这些试验的集合中取平均收益：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Visualizing the Distribution of Returns
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化收益分布
- en: 'In addition to calculating VaR at a particular confidence level, it can be
    useful to look at a fuller picture of the distribution of returns. Are they normally
    distributed? Do they spike at the extremities? As we did for the individual factors,
    we can plot an estimate of the probability density function for the joint probability
    distribution using kernel density estimation (see [Figure 8-3](#figure9-3)):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在特定置信水平计算 VaR 外，查看收益分布的更完整图像也很有用。它们是否正态分布？它们在极端时是否会突然上升？就像我们为个别因素所做的那样，我们可以使用核密度估计绘制联合概率分布的概率密度函数的估计（见
    [图 8-3](#figure9-3)）。
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![aaps 0803](assets/aaps_0803.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![aaps 0803](assets/aaps_0803.png)'
- en: Figure 8-3\. Two-week returns distribution
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 两周收益分布
- en: Where to Go from Here
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来的步骤
- en: The model laid out in this exercise is a very rough first cut of what would
    be used in an actual financial institution. In building an accurate VaR model,
    we glossed over a few very important steps. Curating the set of market factors
    can make or break a model, and it is not uncommon for financial institutions to
    incorporate hundreds of factors in their simulations. Picking these factors requires
    both running numerous experiments on historical data and a heavy dose of creativity.
    Choosing the predictive model that maps market factors to instrument returns is
    also important. Although we used a simple linear model, many calculations use
    nonlinear functions or simulate the path over time with Brownian motion.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中提出的模型是在实际金融机构中使用的第一次粗略尝试。在构建准确的 VaR 模型时，我们忽略了一些非常重要的步骤。筛选市场因素的集合可能是模型的成败关键，金融机构在其模拟中通常会融合数百种因素。选择这些因素既需要在历史数据上运行多次实验，又需要大量的创造力。选择将市场因素映射到工具收益的预测模型也很重要。虽然我们使用了简单的线性模型，但许多计算使用非线性函数或模拟时间路径使用布朗运动。
- en: Lastly, it is worth putting care into the distribution used to simulate the
    factor returns. Kolmogorov-Smirnov tests and chi-squared tests are useful for
    testing an empirical distribution’s normality. Q-Q plots are useful for comparing
    distributions visually. Usually, financial risk is better mirrored by a distribution
    with fatter tails than the normal distribution that we used. Mixtures of normal
    distributions are one good way to achieve these fatter tails. [“Financial Economics,
    Fat-tailed Distributions”](https://oreil.ly/XSxhB), an article by Markus Haas
    and Christian Pigorsch, provides a nice reference on some of the other fat-tailed
    distributions out there.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们值得关注用于模拟因子收益的分布。科尔莫哥洛夫-斯米尔诺夫检验和卡方检验对于测试经验分布的正态性非常有用。Q-Q 图用于直观比较分布。通常，金融风险更好地通过具有比我们使用的正态分布更胖尾部的分布来反映。正态分布的混合是实现这些胖尾部的一种好方法。Markus
    Haas 和 Christian Pigorsch 的文章[《金融经济学，胖尾分布》](https://oreil.ly/XSxhB)提供了一些其他胖尾分布的良好参考。
- en: Banks use PySpark and large-scale data processing frameworks for calculating
    VaR with historical methods as well. [“Evaluation of Value-at-Risk Models Using
    Historical Data”](https://oreil.ly/0JoXu), by Darryll Hendricks, provides a good
    overview and performance comparison of historical VaR methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 银行使用 PySpark 和大规模数据处理框架计算历史方法的 VaR。[“使用历史数据评估风险价值模型”](https://oreil.ly/0JoXu)，由
    Darryll Hendricks 编写，提供了对历史 VaR 方法的概述和性能比较。
- en: Monte Carlo risk simulations can be used for more than calculating a single
    statistic. The results can be used to proactively reduce the risk of a portfolio
    by shaping investment decisions. For example, if in the trials with the poorest
    returns, a particular set of instruments tends to come up losing money repeatedly,
    we might consider dropping those instruments from the portfolio or adding instruments
    that tend to move in the opposite direction from them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛风险模拟不仅可以用于计算单一统计量。其结果可以用于通过塑造投资决策来积极降低投资组合的风险。例如，在那些回报最差的试验中，特定的一组工具可能会反复亏损，我们可能考虑从投资组合中剔除这些工具，或者添加那些倾向于与它们相反方向移动的工具。
