- en: 15 Working with many objects, one at a time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 逐个处理多个对象
- en: 'The whole point of PowerShell is to automate administration, and that often
    means you’ll want to perform some tasks with multiple targets. You might want
    to start several VMs, push to several blob storages, modify permissions of several
    users, and so on. In this chapter, you’ll learn two distinct techniques for accomplishing
    these and other multiple-target tasks: batch cmdlets and object enumeration. The
    concepts and techniques here are the same regardless of the OS you’re using.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的全部目的是自动化管理，这通常意味着你可能想要对多个目标执行一些任务。你可能想要启动几个虚拟机，向几个 blob 存储推送，修改多个用户的权限，等等。在本章中，你将学习两种不同的技术来完成这些和其他多个目标任务：批处理
    cmdlet 和对象枚举。这里的概念和技术无论你使用什么操作系统都是相同的。
- en: Note This is an extremely difficult chapter and will probably frustrate you.
    Please be patient—with yourself and us—and trust that we do explain everything
    by the end.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这是一章极其困难的章节，可能会让你感到沮丧。请对自己和我们保持耐心，并相信我们最终会解释清楚所有内容。
- en: '15.1 The preferred way: “Batch” cmdlets'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 优先方法：“批处理”cmdlet
- en: 'As you’ve learned in several previous chapters, many PowerShell cmdlets can
    accept batches, or *collections*, of objects to work with. In chapter 6, for example,
    you learned that objects can be piped from one cmdlet to another, like this (please
    don’t run this on any system, unless you really want to have a bad day):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面几个章节中学到的，许多 PowerShell cmdlet 可以接受批处理，或 *集合*，的对象来处理。例如，在第 6 章中，你学习了对象可以被从一个
    cmdlet 传递到另一个 cmdlet，如下所示（请勿在任何系统上运行此命令，除非你真的想有一个糟糕的一天）：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an example of batch management using a cmdlet. In this case, `Stop-Process`
    is specifically designed to accept one process object from the pipeline, and then
    stop it. `Set-Service`, `Start-Process`, `Move-Item`, and `Move-AdObject` are
    all examples of cmdlets that accept one or more input objects and then perform
    a task or action with each of them. PowerShell knows how to work with batches
    of objects and can handle them for you with a relatively simple syntax.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 cmdlet 进行批处理管理的例子。在这种情况下，`Stop-Process` 是专门设计用来从管道接受一个进程对象，然后停止它。`Set-Service`、`Start-Process`、`Move-Item`
    和 `Move-AdObject` 都是接受一个或多个输入对象并针对每个对象执行任务或操作的 cmdlet 的例子。PowerShell 知道如何处理对象批处理，并且可以使用相对简单的语法为你处理它们。
- en: 'These *batch cmdlets* (that’s our name for them—it’s not an official term)
    are our preferred way of performing tasks. For example, let’s suppose we need
    to change the startup type for multiple services:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 *批处理 cmdlet*（这是我们给它们的名称——它不是一个官方术语）是我们执行任务的首选方式。例如，假设我们需要更改多个服务的启动类型：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'One potential downside of this approach is that cmdlets that perform an action
    often don’t produce any output indicating that they’ve done their job. You won’t
    have any visual output from either of the preceding commands, which can be disconcerting.
    But those cmdlets often have a `-PassThru` parameter, which tells them to output
    whatever objects they accepted as input. You could have `Set-Service` output the
    same services it modified so you can verify that they have been modified. Here’s
    an example of using `-passThru` with a different cmdlet:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的潜在缺点是，执行操作的 cmdlet 往往不会产生任何输出，以表明它们已经完成了工作。你将不会从前面提到的任何命令中获得任何可视输出，这可能会让人感到不安。但那些
    cmdlet 通常有一个 `-PassThru` 参数，它告诉它们输出它们接受的任何输入对象。你可以让 `Set-Service` 输出它修改过的相同服务，这样你可以验证它们已经被修改。以下是一个使用
    `-passThru` 的不同 cmdlet 的例子：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command retrieves all of the items in the current directory. These objects
    are then piped to `Copy-Item`, which will then copy the items to the directory
    C:\Drivers. Because we put the `-PassThru` parameter at the end, it will display
    on the screen what it did. If we didn’t do this, then once it completed it would
    simply go back to our PowerShell prompt.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令检索当前目录中的所有项目。然后这些对象被传递到 `Copy-Item`，然后它会将项目复制到 C:\Drivers 目录。因为我们把 `-PassThru`
    参数放在了最后，所以它会在屏幕上显示它所做的工作。如果我们没有这样做，那么一旦它完成，它就会简单地回到我们的 PowerShell 提示符。
- en: Try it now Copy a few files or folders from one directory to another. Try it
    both with and without the `-PassThru` parameter and note the difference.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试：从一个目录复制几个文件或文件夹到另一个目录。尝试使用和未使用 `-PassThru` 参数的情况，并注意区别。
- en: '15.2 The CIM way: Invoking methods'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 CIM 方法：调用方法
- en: 'Before we begin, there are two things you must know:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，有两件事你必须知道：
- en: Windows Management Instrumentation (WMI) does not work with PowerShell 7\. You
    must use the Common Information Model (CIM) commands, which work mostly in the
    same manner.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Management Instrumentation (WMI) 与 PowerShell 7 不兼容。您必须使用通用信息模型 (CIM)
    命令，它们的工作方式大致相同。
- en: Section 15.2 is only for those using Windows. We try our best to make sure everything
    we are doing in this book is cross-platform. But there are some instances where
    that isn’t possible, and this is one of them.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15.2 节仅适用于使用 Windows 的用户。我们尽力确保本书中我们做的所有事情都是跨平台的。但有些情况下这是不可能的，这就是其中之一。
- en: Unfortunately, we don’t always have cmdlets that can take whatever action we
    need, and that’s true when it comes to the items we can manipulate through CIM.
    For example, consider the `Win32_NetworkAdapterConfiguration` CIM class. This
    class represents the configuration bound to a network adapter (adapters can have
    multiple configurations, but for now let’s assume they have only one configuration
    apiece, which is common on client computers). Let’s say that our goal is to enable
    DHCP on all of our computers’ Intel network adapters—we don’t want to enable any
    of the RAS or other virtual adapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我们并不总是拥有能够执行所需任何操作的 cmdlet，这在通过 CIM 操作的项目中尤为如此。例如，考虑一下 `Win32_NetworkAdapterConfiguration`
    CIM 类。这个类代表绑定到网络适配器的配置（适配器可以有多个配置，但为了简单起见，现在让我们假设每个适配器只有一个配置，这在客户端计算机上很常见）。假设我们的目标是启用所有计算机的英特尔网络适配器的
    DHCP——我们不想启用任何 RAS 或其他虚拟适配器。
- en: Note We’ll walk you through a brief story line meant to help you experience
    how folks use PowerShell. Some things may seem redundant, but bear with us—the
    experience itself is valuable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将向您展示一个简短的故事线，旨在帮助您体验人们如何使用 PowerShell。有些事情可能看起来有些重复，但请耐心等待——体验本身是有价值的。
- en: 'We might start by trying to query the desired adapter configurations, which
    would allow us to get something like the following as output:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能首先尝试查询所需的适配器配置，这将允许我们得到如下输出：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To achieve this output, we’d need to query the appropriate CIM object and filter
    it to include only configurations with *Intel* in their descriptions. The following
    command does that (notice that the `%` acts as a wildcard within the WMI filter
    syntax):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种输出，我们需要查询适当的 CIM 对象，并过滤它以仅包括描述中包含 *Intel* 的配置。以下命令做到了这一点（注意，在 WMI 过滤器语法中，`%`
    作为通配符使用）：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Try it Now You’re welcome to follow along with the commands we’re running in
    this section. You may need to tweak the commands slightly to make them work. For
    example, if your computer doesn’t have any Intel-made network adapters, you need
    to change the filter criteria appropriately.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试：您欢迎跟随本节中运行的命令。您可能需要稍微调整命令才能使其工作。例如，如果您的计算机没有英特尔制造的任何网络适配器，您需要相应地更改过滤标准。
- en: Once we have those configuration objects in the pipeline, we want to enable
    DHCP on them (you can see that one of our adapters doesn’t have DHCP enabled).
    We might start by looking for a cmdlet named something like *Enable-DHCP*. Unfortunately,
    we won’t find it, because there’s no such thing. There aren’t any cmdlets that
    are capable of dealing directly with CIM objects in batches.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些配置对象在管道中，我们希望在它们上启用 DHCP（您可以看到我们的适配器之一还没有启用 DHCP）。我们可能首先寻找一个名为 *Enable-DHCP*
    的 cmdlet。不幸的是，我们找不到它，因为没有这样的东西。没有能够直接批量处理 CIM 对象的 cmdlet。
- en: Try it Now Based on what you have learned so far, what command would you use
    to search for a cmdlet that has DHCP in its name?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试：基于您到目前为止所学的内容，您会使用什么命令来搜索名称中包含 DHCP 的 cmdlet？
- en: 'Our next step is to see whether the object itself has a method that’s capable
    of enabling DHCP. To find out, we run the command `Get-CimClass` and expand into
    the `CimClassMethods` property:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是查看对象本身是否有能够启用 DHCP 的方法。为了找出，我们运行 `Get-CimClass` 命令并展开到 `CimClassMethods`
    属性：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At the top we will see a method called `EnableDHCP` (figure 15.1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们将看到一个名为 `EnableDHCP` 的方法（图 15.1）。
- en: '![](Images/CH15_F01_Plunk.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH15_F01_Plunk.png)'
- en: Figure 15.1 Showing the methods available
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 显示了可用的方法
- en: 'The next step, which a lot of PowerShell newcomers try, is to pipe the configuration
    objects to the method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个步骤，许多 PowerShell 新手都会尝试，是将配置对象通过管道传递到方法：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Sadly, that won’t work. You can’t pipe objects to a method; you can pipe only
    to a cmdlet. `EnableDHCP` isn’t a PowerShell cmdlet. Rather, it’s an action that’s
    directly attached to the configuration object itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这不会起作用。你不能将对象管道传输到方法中；只能传输到cmdlet中。`EnableDHCP`不是一个PowerShell cmdlet。相反，它是一个直接附加到配置对象本身的行为。
- en: 'Although there’s no “batch” cmdlet called `Enable-DHCP`, you can use a generic
    cmdlet called `Invoke-CimMethod`. This cmdlet is specially designed to accept
    a batch of CIM objects, such as our `Win32_NetworkAdapterConfiguration` objects,
    and to invoke one of the methods attached to those objects. Here’s the command
    we run:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有名为`Enable-DHCP`的“批量”cmdlet，但你可以使用一个名为`Invoke-CimMethod`的通用cmdlet。这个cmdlet专门设计用来接受一批CIM对象，例如我们的`Win32_NetworkAdapterConfiguration`对象，并调用这些对象上附加的方法。以下是我们要运行的命令：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You have a few things to keep in mind:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几件事情需要记住：
- en: The method name isn’t followed by parentheses.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称后面不跟括号。
- en: The method name isn’t case sensitive.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称不区分大小写。
- en: '`Invoke-CimMethod` can accept only one kind of WMI object at a time. In this
    case, we’re sending it only `Win32_NetworkAdapterConfiguration` objects, which
    means it’ll work as expected. It’s okay to send it more than one object (that’s
    the whole point, in fact), but all of the objects have to be of the same type.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke-CimMethod`一次只能接受一种WMI对象。在这种情况下，我们只发送`Win32_NetworkAdapterConfiguration`对象，这意味着它将按预期工作。发送多个对象是可以的（实际上这正是目的所在），但所有对象都必须是同一类型。'
- en: You can use `-WhatIf` and `-Confirm` with `Invoke-CimMethod`. But you can’t
    use those when calling a method directly from an object.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`-WhatIf`和`-Confirm`与`Invoke-CimMethod`一起使用。但是，当你直接从对象调用方法时，不能使用这些选项。
- en: 'The output of `Invoke-CimMethod` is very simple to understand. It gives you
    two things: a return value and the computer it ran on (if the computer name is
    blank, it ran on `localhost`).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-CimMethod`的输出非常简单易懂。它给你两样东西：一个返回值和它在哪台计算机上运行（如果计算机名称为空，则表示在`localhost`上运行）。'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `ReturnValue` number tells us the result of the operation. A quick search
    from your favorite search engine for *Win32_NetworkAdapterConfiguration* turns
    up the documentation page, and we can then click through to the `EnableDHCP` method
    to see the possible return values and their meanings. Figure 15.2 shows what we
    discover.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReturnValue`数字告诉我们操作的结果。通过你最喜欢的搜索引擎对*Win32_NetworkAdapterConfiguration*进行快速搜索，可以找到文档页面，然后我们可以点击进入`EnableDHCP`方法，查看可能的返回值及其含义。图15.2显示了我们的发现。'
- en: '![](Images/CH15_F02_Plunk.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH15_F02_Plunk.png)'
- en: Figure 15.2 Looking up return values for a WMI method’s results
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 查找WMI方法结果的返回值
- en: A value of `0` means success, whereas `84` means that the IP isn’t enabled on
    that adapter configuration and DHCP can’t be enabled. But which bit of the output
    goes with which of our two network adapter configurations? It’s difficult to tell,
    because the output doesn’t tell you which specific configuration object produces
    it. That’s unfortunate, but it’s the way CIM works.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 值为`0`表示成功，而`84`表示该适配器配置上未启用IP，DHCP无法启用。但是输出中的哪个位与我们的两个网络适配器配置中的哪一个相对应呢？很难判断，因为输出没有告诉你哪个具体的配置对象产生了它。这是不幸的，但这就是CIM的工作方式。
- en: '`Invoke-CimMethod` works for most situations in which you have a CIM object
    that has a method that you want to execute. It works well when querying CIM objects
    from remote computers too. Our basic rule is, “If you can get to something by
    using `Get-CIMInstance`, then `Invoke-CimMethod` can execute its methods.”'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-CimMethod`适用于大多数你有CIM对象并且想要执行其方法的情况。当从远程计算机查询CIM对象时，它也工作得很好。我们的基本规则是，“如果你可以通过`Get-CIMInstance`访问到某个东西，那么`Invoke-CimMethod`就可以执行其方法。”'
- en: '15.3 The backup plan: Enumerating objects'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 备份计划：枚举对象
- en: 'Unfortunately, we’ve run into situations where we have a cmdlet that can produce
    objects, but we know of no batch cmdlet to which we can pipe those objects to
    take some kind of action. We’ve also run into situations where a cmdlet doesn’t
    take any input from the pipeline. In either case, you can still perform whatever
    task you want to perform, but you’ll have to fall back to a more verbose-style
    approach of instructing the computer to enumerate the objects and perform your
    task against one object at a time. PowerShell offers two ways to accomplish this:
    one is using a cmdlet, and the other is using a scripting construct. We focus
    on the first technique in this chapter because it is the easiest. *You should
    always try to use a cmdlet over trying to script it yourself.* We save the second
    approach for chapter 19, which dives into PowerShell’s built-in scripting language.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们遇到了一些情况，其中我们有一个可以生成对象的 cmdlet，但我们不知道可以将这些对象管道化到哪个批处理 cmdlet 中以执行某种操作。我们也遇到过
    cmdlet 不从管道中获取任何输入的情况。在两种情况下，你仍然可以执行你想要执行的任何任务，但你将不得不退回到一种更冗长的风格，即指示计算机枚举对象，并逐个对象执行你的任务。PowerShell
    提供了两种实现此目的的方法：一种是通过 cmdlet，另一种是通过脚本结构。我们在这章中关注第一种技术，因为它是最简单的。*你应该始终尝试使用 cmdlet
    而不是自己尝试脚本化它。* 我们将第二种方法留到第 19 章，该章深入探讨了 PowerShell 的内置脚本语言。
- en: 'For our example, since we’ve been talking about processes in this chapter,
    we’ll be talking about the cmdlet. Let’s look at the syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，因为我们一直在本章中讨论进程，所以我们将讨论 cmdlet。让我们看看语法：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Which gets us everything . . . but skim through the section called “Id.” You’ll
    notice that some of the parameters say they accept pipeline input, but in parentheses,
    it says `ByPropertyName`. This means that if we pipe an object into this cmdlet
    and it has a property name called `Id`, for example, this cmdlet will use that:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们带来以下所有内容……但是快速浏览一下名为“Id.”的部分。你会注意到一些参数说明它们接受管道输入，但在括号中写着 `ByPropertyName`。这意味着如果我们向这个
    cmdlet 管道一个对象，并且它有一个名为 `Id` 的属性，例如，这个 cmdlet 将使用那个：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, what if we just want to pipe in a list of strings that are names of
    the processes that we want to create? We wouldn’t be able to do that because the
    `Name` parameter doesn’t support the other type of piping: `ByValue`. Go ahead
    and try it. Let’s take a look at the command `New-AzKeyVault`. We will put our
    values in an array and pipe that to the `New-AzKeyVault` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只想管道输入一个字符串列表，这些字符串是我们想要创建的进程的名称呢？我们无法做到这一点，因为 `Name` 参数不支持其他类型的管道：`ByValue`。试试看。让我们看看
    `New-AzKeyVault` 命令。我们将把我们的值放入一个数组中，并将其管道化到 `New-AzKeyVault` 命令中：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This gives us the following less-than-ideal red text:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致出现以下不太理想的红色文本：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s take a deeper look into how we can still achieve our goal even when the
    cmdlet can’t support what we are trying to do.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨一下，即使 cmdlet 无法支持我们想要执行的操作，我们仍然如何实现我们的目标。
- en: 15.3.1 Making the cmdlets work for you
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 使 cmdlet 为您服务
- en: At this point, we have to make a decision. It’s possible that we’re running
    the command incorrectly, so we have to decide whether we want to spend a lot of
    time figuring it out. It’s also possible that `New-AzKeyVault` just doesn’t support
    what we want to do, in which case we could be spending a lot of time trying to
    fix something we have no control over.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们必须做出决定。有可能我们运行命令的方式不正确，所以我们必须决定我们是否愿意花大量时间来解决这个问题。也有可能 `New-AzKeyVault`
    实际上不支持我们想要做的事情，在这种情况下，我们可能会花大量时间尝试修复我们无法控制的事情。
- en: 'We need to create a text file with a list of vault names we want to create.
    Our vaultsToCreate.txt looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个包含我们想要创建的保险库名称的文本文件。我们的 vaultsToCreate.txt 看起来像这样：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our usual choice in these situations is to try a different approach. We’re
    going to ask the computer (well, the shell) to enumerate the objects (in our case,
    strings) one at a time, since the `New-AzKeyVault` command accepts only one object
    at a time, and execute `New-AzKeyVault` on the objects. To do this, we use the
    `ForEach-Object` cmdlet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通常的选择是尝试不同的方法。我们将要求计算机（好吧，是外壳）逐个枚举对象（在我们的情况下，是字符串），因为 `New-AzKeyVault`
    命令一次只能接受一个对象，并在对象上执行 `New-AzKeyVault`。为此，我们使用 `ForEach-Object` cmdlet：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For the four resources we created, we get four results that look like this
    (only part of the output is shown here, as the results can be quite long):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们创建的四个资源，我们得到四个看起来像这样的结果（这里只显示了部分输出，因为结果可能相当长）：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the documentation, we found that if we got back a response like this, it
    meant success, which means we’ve achieved our goal. But let’s look at that command
    in more detail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中，我们发现如果得到这样的响应，这意味着成功，这意味着我们已经实现了我们的目标。但让我们更详细地看看那个命令。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This command has a lot going on. The first line should make sense: we’re using
    `Get-Content` to retrieve the names of the vaults that we put in a text file.
    We’re piping those `string` objects to the `ForEach-Object` cmdlet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令有很多功能。第一行应该是合理的：我们使用 `Get-Content` 来检索我们放入文本文件中的保险库名称。我们将这些 `string` 对象通过管道传递给
    `ForEach-Object` cmdlet：
- en: 'First, you see the cmdlet name: `ForEach-Object`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你看到的是 cmdlet 名称：`ForEach-Object`。
- en: Next, we use the `-Process` parameter to specify a script block. We didn’t originally
    type the `-Process` parameter name, because it’s a positional parameter. But that
    script block—everything contained within the curly braces—is the value for the
    `-Process` parameter. We went ahead and included the parameter name when we reformatted
    the command for easier reading.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `-Process` 参数指定一个脚本块。我们最初没有输入 `-Process` 参数名称，因为它是一个位置参数。但那个脚本块——大括号内包含的所有内容——是
    `-Process` 参数的值。我们在重新格式化命令以方便阅读时包括了参数名称。
- en: '`ForEach-Object` executes its script block once for each object that was piped
    into `ForEach-Object`. Each time the script block executes, the next piped-in
    object is placed into the special `$_` placeholder, which you see getting passed
    in as the `Name` parameter in `New-AzKeyVault`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForEach-Object` 对每个被传递到 `ForEach-Object` 的对象执行其脚本块一次。每次脚本块执行时，下一个被传递的对象将被放置到特殊的
    `$_` 占位符中，你可以在 `New-AzKeyVault` 中的 `Name` 参数中看到它被传递。'
- en: 15.4 Let’s speed things up
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4 让我们加快速度
- en: 'In previous chapters, we’ve talked about using PowerShell jobs to run commands
    in parallel so that you save time. To streamline this time-saving ability, PowerShell
    7 introduces a new parameter on `ForEach-Object`: `-Parallel`. It’s best understood
    with an example using the ever-famous `Measure-Command` cmdlet that allows you
    to measure all sorts of things, but we’ll be using it to time how long a script
    block runs. It looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了使用 PowerShell 作业并行运行命令以节省时间。为了简化这种节省时间的功能，PowerShell 7 在 `ForEach-Object`
    上引入了一个新参数：`-Parallel`。通过一个例子可以更好地理解它，那就是著名的 `Measure-Command` cmdlet，它允许你测量各种事物，但我们将用它来测量脚本块运行的时间。它看起来是这样的：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So let’s give it a go. First we’ll try something simple using the regular `ForEach-Object`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们试试看。首先，我们将使用常规的 `ForEach-Object` 尝试做一些简单的事情：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All this is going to do is print out each of the lines in the file and then
    sleep for one second per line. If we have five lines in the file, you can probably
    guess how long this will take to run, but let’s use `Measure-Command`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这所有的一切只是将文件的每一行打印出来，然后每行睡眠一秒。如果我们文件中有五行，你可能能猜出这需要多长时间运行，但让我们使用 `Measure-Command`：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we run that, we get the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，我们得到以下输出：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s look specifically at the `Seconds` value, which is `5`. That makes sense,
    right? If we have five lines in our file, and we process each line one at a time,
    and we sleep for 1 second each, we expect that command to run in roughly 5 seconds.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体看看 `Seconds` 值，它是 `5`。这说得通，对吧？如果我们文件中有五行，我们逐行处理每一行，并且每行睡眠 1 秒，我们预计该命令将大约运行
    5 秒。
- en: 'Now let’s change that same command to use `Parallel` instead of `Process`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将相同的命令更改为使用 `Parallel` 而不是 `Process`：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Any guesses? Let’s run it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么猜测吗？让我们运行它：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One second! That’s because `Parallel` does as the name implies—it runs the
    script blocks in parallel rather than in sequence. Since we have five items in
    our file and we run all of them in parallel, and we sleep for 1 second each, the
    whole operation takes only about 1 second. This is very useful for tasks that
    are long-running or in scenarios where you have a lot of smaller tasks that you’d
    like to batch. We can even take our existing example and use `Parallel ForEach`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一秒钟！这是因为 `Parallel` 正如其名所示——它并行而不是顺序地运行脚本块。由于我们的文件中有五个项目，并且我们并行运行了所有这些项目，并且我们每次睡眠
    1 秒，整个操作只需大约 1 秒。这对于长时间运行的任务或在有很多较小任务需要批量处理的场景非常有用。我们甚至可以使用现有的示例并使用 `Parallel
    ForEach`：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Parallel` is a very strong parameter on `ForEach`, but it does have some limitations
    that you should be aware of. For starters, by default, `Parallel` `ForEach` will
    run only five script blocks in parallel. This is called the *throttle limit* and
    can be adjusted with the `ThrottleLimit` parameter. Go back to that file we’ve
    been using, and make sure it has a total of 10 lines. The difference is quite
    noticeable:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel` 是 `ForEach` 上的一个非常强大的参数，但它确实有一些你应该注意的限制。首先，默认情况下，`Parallel` `ForEach`
    只会并行运行五个脚本块。这被称为 *节流限制*，可以通过 `ThrottleLimit` 参数进行调整。回到我们一直在使用的那个文件，确保它总共有 10 行。这种差异非常明显：'
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Without the throttle limit set, we get 2 seconds:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 没有设置节流限制，我们得到 2 秒：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, if we up the throttle limit to 10, we get
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把节流限制提高到 10，我们会得到
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The command finishes in 1 second!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 命令在 1 秒内完成！
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Parallel ForEach` is a very powerful feature of PowerShell. You’ll save a
    lot of time if you take advantage of it in the right way.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel ForEach` 是 PowerShell 的一个非常强大的功能。如果你能正确利用它，你会节省很多时间。'
- en: 15.5 Common points of confusion
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5 常见混淆点
- en: The techniques in this chapter are among the most difficult in PowerShell, and
    they often cause the most confusion and frustration. Let’s look at some of the
    problems newcomers tend to run into. We provide some alternative explanations
    that will help you avoid the same issues.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的技术是 PowerShell 中最困难的之一，它们经常引起最多的困惑和挫折。让我们看看新来者容易遇到的一些问题。我们提供了一些替代解释，这将帮助你避免遇到相同的问题。
- en: 15.5.1 Which way is the right way?
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5.1 哪种方法是正确的？
- en: We use the terms *batch cmdlet* or *action cmdlet* to refer to any cmdlet that
    performs an action against a group, or collection, of objects all at once. Rather
    than having to instruct the computer to “go through this list of things, and perform
    this one action with each of those things,” you can send the whole group to a
    cmdlet, and the cmdlet handles it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语 *批处理 cmdlet* 或 *操作 cmdlet* 来指代任何对一组或集合中的对象执行操作的 cmdlet。你不需要指示计算机“遍历这个列表中的事物，并对每个事物执行这个操作”，你可以将整个组发送到
    cmdlet，然后由 cmdlet 处理。
- en: 'Microsoft is getting better about providing these kinds of cmdlets with its
    products, but its coverage isn’t 100% yet (and probably won’t be for many years
    because of the many complex Microsoft products that exist). But when a cmdlet
    does exist, we prefer to use it. That said, other PowerShell developers prefer
    alternate ways, depending on what they learned first and what they remember most
    easily. All of the following have the same result:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 微软正在努力在其产品中提供这类 cmdlet，但它的覆盖范围还不是 100%（可能因为存在许多复杂的微软产品，所以可能很多年都不会达到 100%）。但是，当
    cmdlet 存在时，我们更喜欢使用它。话虽如此，其他 PowerShell 开发者更喜欢根据他们最初学习的内容和最容易记住的内容选择其他方法。以下所有方法都有相同的结果：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Batch cmdlet
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 批处理 cmdlet
- en: ❷ ForEach-Object calling the Kill() method
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 Kill() 方法的 ForEach-Object
- en: ❸ ForEach-Object calling Stop-Process
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ForEach-Object 调用 Stop-Process
- en: 'Let’s look at how each approach works:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种方法是如何工作的：
- en: '*Batch cmdlet*. Here, we’re using `Get-Process` to retrieve all processes with
    a *B* in their name, and then stop them.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*批处理 cmdlet*。在这里，我们使用 `Get-Process` 来检索所有名称中带有 *B* 的进程，然后停止它们。'
- en: '`ForEach-Object` calling the `Kill()` method. This approach is similar to the
    batch cmdlet, but rather than using a batch cmdlet, we’re piping the processes
    to `ForEach-Object` and asking it to execute each service’s `Kill()`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForEach-Object` 调用 `Kill()` 方法。这种方法与批处理 cmdlet 类似，但不是使用批处理 cmdlet，而是将进程通过管道发送到
    `ForEach-Object`，并要求它执行每个服务的 `Kill()`'
- en: '`ForEach-Object` calling `Stop-Process` using `-Parallel`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-Parallel` 的 `ForEach-Object` 调用 `Stop-Process`。
- en: Heck, there’s even a fourth approach—using PowerShell’s scripting language to
    do the same thing. You’ll find lots of ways to accomplish almost anything in PowerShell,
    and none of them are wrong. Some are easier than others to learn, remember, and
    repeat, which is why we’ve focused on the techniques we have, in the order that
    we did. Which should you use? It doesn’t matter, because there’s no one right
    way. You may even end up using a mix of these, depending on the circumstances
    and the capabilities that the shell can offer you for the task at hand.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，甚至还有第四种方法——使用 PowerShell 的脚本语言来完成相同的事情。你会在 PowerShell 中找到很多方法来完成几乎所有的事情，而且没有哪一种是错误的。有些方法比其他方法更容易学习、记忆和重复，这就是为什么我们专注于我们已有的技术，按照我们使用的顺序。你应该使用哪种方法？这无关紧要，因为没有一种绝对正确的方法。你可能甚至最终会根据具体情况和
    shell 为你提供的任务能力，使用这些方法的混合。
- en: 15.5.2 Diminishing returns of Parallel ForEach
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5.2 Parallel ForEach 的递减回报
- en: 'Remember our `Parallel ForEach` example? It looked like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们的 `Parallel ForEach` 示例吗？它看起来是这样的：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let’s say vaultsToCreate.txt had 100 lines in it. Should we try to set
    the `ThrottleLimit` to `100` so the operation can complete in 1 second? Let’s
    try:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 vaultsToCreate.txt 有 100 行。我们应该尝试将 `ThrottleLimit` 设置为 `100` 以使操作在 1 秒内完成吗？让我们试试：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This gives us the output of 3 seconds. That’s odd:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了 3 秒的输出。这很奇怪：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Why so slow? Well, it turns out the bottleneck is your machine, which can run
    only so many things in parallel before it starts to slow down. This is like `Start-ThreadJob`
    that we saw in chapter 14\. A single process can only do so many things in parallel
    before it starts to run slower than running them serially.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这么慢？好吧，结果是瓶颈是你的机器，它在开始变慢之前只能并行运行这么多事情。这就像我们在第 14 章中看到的 `Start-ThreadJob`。单个进程在开始比串行运行慢之前只能并行做这么多事情。
- en: It’s a strange concept, but imagine if you were working on a bunch of tasks
    at the same time. You’d have to constantly context switch between each of those
    tasks to make progress on all of them at the same time. In some cases, you reach
    a point where you’d be more effective if you simply waited to start a task until
    after you were finished with other tasks that are already in progress. We typically
    call this phenomenon “diminishing returns,” meaning that as you attempt to do
    more in parallel, it becomes less worth it and could even impact results in a
    negative way if you’re not careful.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个奇怪的概念，但想象一下如果你同时处理一堆任务。你将不得不不断在各个任务之间进行上下文切换，以同时在这所有任务上取得进展。在某些情况下，如果你简单地等待完成其他正在进行的任务后再开始一个任务，你可能会更有效率。我们通常称这种现象为“收益递减”，意味着随着你尝试并行做更多的事情，它变得不那么值得，如果不小心，甚至可能以负面方式影响结果。
- en: 15.5.3 Method documentation
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5.3 方法文档
- en: 'Always remember that piping objects to `Get-Member` reveals methods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，将对象管道传输到 `Get-Member` 会显示方法：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'PowerShell’s built-in help system doesn’t document methods objects. For example,
    if you get a member list for a process object, you can see that methods named
    `Kill` and `Start` exist:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的内置帮助系统没有记录方法对象。例如，如果你为进程对象获取成员列表，你可以看到存在名为 `Kill` 和 `Start` 的方法：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To find the documentation for these, focus on the `TypeName`, which in this
    case is `System.Diagnostics.Process`. Search for that complete type name in a
    search engine, and you’ll usually come across the official developer documentation
    for that type, which will lead to the documentation for the specific method you’re
    after.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到这些文档，请关注 `TypeName`，在这个例子中是 `System.Diagnostics.Process`。在搜索引擎中搜索这个完整的类型名称，你通常会找到该类型的官方开发者文档，这将引导你找到你想要的特定方法的文档。
- en: 15.5.4 ForEach-Object confusion
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5.4 ForEach-Object 混淆
- en: 'The `ForEach-Object` cmdlet has a punctuation-heavy syntax, and adding in a
    method’s own syntax can create an ugly command line. We’ve compiled some tips
    for breaking any mental logjams:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForEach-Object` cmdlet 的语法中有很多标点符号，加上方法自己的语法可能会创建一个丑陋的命令行。我们整理了一些打破任何心理障碍的建议：'
- en: Try to use the full cmdlet name instead of its `%` or `ForEach` alias. The full
    name can be easier to read. If you’re using someone else’s example, replace aliases
    with the full cmdlet names.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使用完整的 cmdlet 名称，而不是它的 `%` 或 `ForEach` 别名。完整的名称可能更容易阅读。如果你在使用别人的示例，请将别名替换为完整的
    cmdlet 名称。
- en: The script block enclosed in curly braces executes once for each object that’s
    piped into the cmdlet.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号内的脚本块会为每个被管道传输到 cmdlet 的对象执行一次。
- en: Within the script block, the `$_` represents the current object in the pipeline.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本块内部，`$_` 代表管道中的当前对象。
- en: Use `$_` by itself to work with the entire object you piped in; follow `$_`
    with a period to work with individual methods or properties.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `$_` 自身来处理你管道传输的整个对象；在 `$_` 后面加一个点来处理单个方法或属性。
- en: Method names are always followed by parentheses, even if the method doesn’t
    require any parameters. When parameters are required, they’re delimited by commas
    and included within the parentheses.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称总是后面跟着括号，即使该方法不需要任何参数。当需要参数时，它们通过逗号分隔并包含在括号内。
- en: 15.6 Lab
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6 实验
- en: Note For this lab, you need a machine with PowerShell 7 or higher on it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验，你需要一台安装了 PowerShell 7 或更高版本的机器。
- en: 'Try to answer the following questions and complete the specified tasks. This
    is an important lab, because it draws on skills you’ve learned in many previous
    chapters, and you should be continuing to use and reinforce these skills as you
    progress through the remainder of this book:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答以下问题并完成指定的任务。这是一个重要的实验，因为它利用了你之前许多章节中学到的技能，你应该在阅读本书的剩余部分时继续使用和加强这些技能：
- en: What method of a `DirectoryInfo` object (produced by `Get-ChildItem`) will delete
    the directory?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DirectoryInfo` 对象（由 `Get-ChildItem` 产生）的哪种方法可以删除目录？'
- en: What method of a `Process` object (produced by `Get-Process`) would terminate
    a given process?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Process` 对象（由 `Get-Process` 产生）的哪种方法可以终止指定的进程？'
- en: Write three commands that could be used to delete all files and directories
    that have `deleteme` in the name, assuming that multiple files and directories
    have this in the name.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写三个命令，用于删除所有名称中包含 `deleteme` 的文件和目录，假设有多个文件和目录包含这个名称。
- en: Assume you have a text list of computer names but want to display them in all
    uppercase. What PowerShell expression could you use?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个包含计算机名称的文本列表，但你想将它们显示为大写。你可以使用什么 PowerShell 表达式？
- en: 15.7 Lab answers
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7 实验答案
- en: 'Find the methods like this:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到类似的方法：
- en: '`Get-ChildItem | Get-Member -MemberType Method`'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-ChildItem | Get-Member -MemberType Method`'
- en: You should see a `Delete()` method.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个 `Delete()` 方法。
- en: 'Find the methods like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到类似的方法：
- en: '`get-process | Get-Member -MemberType Method`'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`get-process | Get-Member -MemberType Method`'
- en: You should see a `Kill()` method. You could verify by checking the MSDN documentation
    for this process object type. Of course, you shouldn’t need to invoke the method
    because there is a cmdlet, `Stop-Process`, that will do the work for you.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个 `Kill()` 方法。你可以通过检查该进程对象的 MSDN 文档来验证这一点。当然，你不需要调用该方法，因为有一个 cmdlet，`Stop-Process`，可以为你完成这项工作。
- en: '`Get-ChildItem *deleteme* | Remove-Item -Recurse -Force`'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem *deleteme* | Remove-Item -Recurse -Force`'
- en: '`Remove-Item *deleteme* -Recurse -Force`'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Remove-Item *deleteme* -Recurse -Force`'
- en: '`Get-ChildItem *deleteme* | foreach {$_.Delete()}`'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-ChildItem *deleteme* | foreach {$_.Delete()}`'
- en: '`Get-content computers.txt | foreach {$_.ToUpper()}`'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-content computers.txt | foreach {$_.ToUpper()}`'
