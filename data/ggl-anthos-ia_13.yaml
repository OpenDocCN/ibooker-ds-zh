- en: 13 Security and policies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 安全与策略
- en: Scott Surovich
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Surovich
- en: This chapter covers
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Kubernetes security overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 安全概述
- en: Anthos security features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthos 安全功能
- en: Understanding root versus privileged containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解根容器与特权容器
- en: Using ACM to secure a cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ACM 保护集群
- en: Google has made deploying Anthos clusters an easy, automated process. Because
    the process is automated, administrators may not consider anything past the initial
    simple cluster creation. When you deploy a cluster without considering postinstallation
    tasks like security, the likelihood is high that an attacker will be able to take
    control of your cluster with little effort.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Google 已经使部署 Anthos 集群变得简单、自动化。由于过程是自动化的，管理员可能不会考虑初始简单集群创建之后的任务，如安全设置。当您在未考虑安装后任务（如安全）的情况下部署集群时，攻击者很可能只需付出很少的努力就能控制您的集群。
- en: Like many base installations of a product, a new Kubernetes cluster will include
    few, if any, enhanced security settings. For most enterprise systems, this setup
    is by design. Rather than force a rigid security model on an organization, potentially
    enabling features that may not be usable in some organizations, Kubernetes designers
    opt to make security a post-cluster-installation process that is designed and
    implemented by the organization.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多产品的初始安装一样，一个新的 Kubernetes 集群可能包含很少或没有增强的安全设置。对于大多数企业系统，这种设置是设计如此。Kubernetes
    设计者选择将安全作为一个集群安装后的过程，这个过程由组织设计和实施，而不是强迫组织采用一个可能不适合某些组织的严格安全模型。
- en: In today’s connected world, it seems that not a day goes by without news of
    a new hacking attack. Ransomware, botnets, distributed denial-of-service attacks,
    and countless others are becoming a daily cat-and-mouse game between organizations
    and hackers. Regardless of the placement of your cluster, on-prem or off-prem,
    you need to secure all areas that could be exploited. Failure to sufficiently
    plan for these attacks can lead to data leaks, service interruptions, fines, brand
    change, or loss of revenue.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天这个互联互通的世界里，似乎没有一天没有关于新的黑客攻击的新闻。勒索软件、僵尸网络、分布式拒绝服务攻击以及无数其他攻击正在成为组织与黑客之间每日的猫鼠游戏。无论您的集群位于本地还是远程，您都需要保护所有可能被利用的区域。对这些攻击缺乏充分的规划可能导致数据泄露、服务中断、罚款、品牌变更或收入损失。
- en: In this chapter, we will discuss the features that Anthos provides to secure
    your Kubernetes clusters. Utilities like Anthos Config Management (ACM) and the
    Anthos Service Mesh (ASM) offer features to secure a cluster, limiting or blocking
    the effects from bad actors and honest user mistakes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Anthos 提供的用于保护您的 Kubernetes 集群的功能。例如，Anthos 配置管理（ACM）和 Anthos 服务网格（ASM）等工具提供了保护集群的功能，限制或阻止恶意行为者和诚实用户错误的影响。
- en: 'For example, a default installation of Kubernetes may allow a user to deploy
    a container that mounts host volumes, uses the host PID and host networking, runs
    as root, or runs in privileged mode. All of these can lead to different problems,
    but let’s look at one of the most dangerous: privileged containers. A privileged
    container allows a user to mount the host’s root filesystem into a mount point
    in the running container. Once the filesystem is mounted, a user can get into
    the running container and browse the entire filesystem of the worker node. With
    the host filesystem mounted, the attacker could go one step further and remount
    the root filesystem, allowing them to halt a running container, start a new rogue
    container, or destroy the host operating system filesystem.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Kubernetes 的默认安装可能允许用户部署一个挂载主机卷、使用主机 PID 和主机网络、以 root 身份运行或以特权模式运行的容器。所有这些都可能引起不同的问题，但让我们看看其中最危险的一个：特权容器。特权容器允许用户将主机的根文件系统挂载到运行中的容器的挂载点上。一旦文件系统被挂载，用户就可以进入运行中的容器并浏览工作节点的整个文件系统。在挂载了主机文件系统的情况下，攻击者可以更进一步，重新挂载根文件系统，从而允许他们停止运行中的容器、启动新的恶意容器或破坏主机操作系统文件系统。
- en: Running a privileged container is a commonly used example that shows why you
    need to add additional security to a cluster. Although security policies are usually
    the first type of policy created for a cluster, you can’t forget about other settings
    that can have an effect on the cluster and your services. To secure a cluster,
    you need to understand what an attacker may do that will lead not only to a security
    breach but service interruptions and data loss as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行特权容器是一个常用的例子，说明了为什么您需要向集群添加额外的安全措施。尽管安全策略通常是集群创建的第一种策略类型，但您不能忘记其他可能影响集群和您服务的设置。为了保护集群，您需要了解攻击者可能采取的行动，这些行动不仅可能导致安全漏洞，还可能导致服务中断和数据丢失。
- en: 13.1 Technical requirements
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 技术要求
- en: The hands-on portion of this chapter will require you to have access to a Google
    Kubernetes Engine cluster running in GCP with ACM and Policy Controller enabled.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实践部分将要求您能够访问一个在GCP上运行的带有ACM和Policy Controller启用的Google Kubernetes Engine集群。
- en: 13.2 Hypervisors vs. container runtimes
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 虚拟机管理程序与容器运行时对比
- en: When a new technology is released, it’s commonly deployed without the appropriate
    knowledge required to run it securely. This often causes people to consider the
    new technology as less secure than a more mature technology, like containers versus
    virtual machines. Until recently, it was common for people to say that containers
    are not as secure as a virtual machine, with many pointing out that the containers
    sharing the host’s kernel is the primary security concern.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当一项新技术发布时，它通常在没有适当知识的情况下被部署，以安全地运行。这通常导致人们认为新技术不如更成熟的技术安全，例如容器与虚拟机相比。直到最近，人们普遍认为容器不如虚拟机安全，许多人指出，共享主机内核是主要的安全担忧。
- en: This shared kernel opens an avenue of attack for malicious actors, possibly
    allowing them to hack into a less-than-secure container and, from there, break
    out into the host itself. If an attacker breaks out of a container, they could,
    potentially, gain complete control of the host operating system. This is commonly
    contrasted with a virtual machine running on a hypervisor, where there’s no way
    a breakout could happen. Or could it?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个共享内核为恶意行为者开辟了攻击途径，可能允许他们黑入一个不够安全的容器，并从那里突破到主机本身。如果攻击者从容器中突破出来，他们可能，潜在地，完全控制主机操作系统。这与在虚拟机管理程序上运行的虚拟机形成对比，在那里突破是不可能发生的。或者，可能吗？
- en: Over the years, different hypervisors have had common vulnerabilities and exposures
    (CVEs) that have led to varying levels of security problems, including privileged
    escalations, allowing an attacker access to the hypervisor with administrative
    permissions. (More information about CVEs can be found at [https://cve.mitre.org/](https://cve.mitre.org/).)
    Once they have compromised the hypervisor, an attacker would have access to every
    virtual machine on the host, including the virtual disks used to run the virtual
    machine.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，不同的虚拟机管理程序都存在常见的漏洞和暴露（CVE），导致了不同程度的网络安全问题，包括特权提升，允许攻击者以管理员权限访问虚拟机管理程序。（有关CVE的更多信息，请参阅[https://cve.mitre.org/](https://cve.mitre.org/)。）一旦攻击者破坏了虚拟机管理程序，他们就会访问主机上的每个虚拟机，包括运行虚拟机的虚拟磁盘。
- en: This section is not intended to spark a debate about container security versus
    virtual machine security. Our intention is to call out that no system is completely
    secure, and when a system, like Kubernetes, is deployed without understanding
    basic security, you put yourself and your organization at risk.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的不是引发关于容器安全与虚拟机安全之间的辩论。我们的目的是指出，没有系统是完全安全的，当像Kubernetes这样的系统在没有理解基本安全的情况下部署时，您和您的组织都会面临风险。
- en: Let’s look at some common Kubernetes security concerns that need to be examined
    before a cluster should be considered “production ready.”
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在集群被认为是“生产就绪”之前需要检查的一些常见的Kubernetes安全关注点。
- en: 13.3 Kubernetes security overview
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 Kubernetes安全概述
- en: 'A basic Kubernetes cluster usually enables limited security settings, if any
    at all, which leaves organizations to address security on their own as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的Kubernetes集群通常只启用有限的安全设置，如果没有的话，这使组织必须自行解决安全问题，如下所述：
- en: Configuring any base Kubernetes security features
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置任何基本Kubernetes安全功能
- en: Finding add-on products to address any missing security not included with a
    base cluster
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找附加产品来解决基本集群中未包含的任何缺失安全功能
- en: Educating staff on the installation and support of each component
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每个组件的安装和支持进行培训
- en: Scanning images for vulnerabilities
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描镜像以查找漏洞
- en: Enabling network security to encrypt traffic between workloads
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用网络安全以加密工作负载之间的流量
- en: These tasks may not sound like large obstacles to overcome in some organizations.
    You may already know about various open source packages that add security to clusters,
    like admission controllers such as OPA (Open Policy Agent) or Gatekeeper ([https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)).
    An organization can decide to deploy Gatekeeper using the open source project
    release, but doing so would leave them to handle support internally or by submitting
    an issue on the GitHub repository for Gatekeeper. Problems with an admission controller
    can have detrimental effects on the cluster, potentially causing obstacles with
    every deployment request. Until you have been on the receiving end of an admission
    controller problem, you may not fully understand the effect and how having a support
    contact can be a cluster lifesaver.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务在某些组织中可能听起来并不是克服的大障碍。你可能已经了解了一些开源软件包，如OPA（Open Policy Agent）或Gatekeeper这样的准入控制器，它们可以为集群增加安全性。一个组织可以决定使用开源项目发布版部署Gatekeeper，但这样做将使他们需要内部处理支持或通过在GitHub仓库上提交Gatekeeper的问题来处理。准入控制器的问题可能会对集群产生有害影响，可能造成每个部署请求的障碍。在你成为准入控制器问题的接收者之前，你可能不会完全理解其影响，以及拥有一个支持联系人如何成为集群的救命稻草。
- en: Throughout this book, we have discussed how Anthos brings Kubernetes clusters
    to the next level by providing add-ons to a cluster backed by full Google support.
    Security is one of the key areas that Anthos excels in, as you read in chapter
    11, where you learned about some of the features of ACM, including configuration
    syncing and Config Connector. ACM can also be used to configure the base aspects
    of Kubernetes security, including Roles and RoleBindings, but also provides additional
    security by including the Gatekeeper policy engine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们讨论了Anthos如何通过提供由完整Google支持的后备集群的附加组件，将Kubernetes集群提升到新的水平。正如你在第11章所读到的，安全性是Anthos擅长的关键领域之一，其中你了解了一些ACM的功能，包括配置同步和Config
    Connector。ACM还可以用来配置Kubernetes安全的基础方面，包括角色和角色绑定，同时还通过包含Gatekeeper策略引擎提供额外的安全措施。
- en: Before taking a deeper look at Policy Controller and the policies that can be
    implemented with it, let’s quickly go over the security mechanisms that are provided
    as part of a base Kubernetes installation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨策略控制器及其可以实施的政策之前，让我们快速回顾一下作为基础Kubernetes安装的一部分提供的安全机制。
- en: 13.3.1 Understanding Kubernetes security objects
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 理解Kubernetes安全对象
- en: 'As a cluster administrator, you need to understand the included security options
    and how they address, or don’t address, your organization’s security policies.
    Fully covering the base security objects included with Kubernetes is beyond the
    scope of this chapter. They are presented here to provide an overview that you
    can further look into using the reference links provided. Some commonly used security
    objects follow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为集群管理员，你需要了解包含的安全选项以及它们如何解决或未解决你组织的网络安全策略。全面涵盖Kubernetes中包含的基础安全对象超出了本章的范围。它们在此处展示，以提供一个概述，你可以进一步使用提供的参考链接进行深入研究。以下是一些常用的安全对象：
- en: '*NetworkPolicies*—Defines conditions to control Ingress and egress traffic
    to services ([http://mng.bz/61vy](http://mng.bz/61vy))'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络策略*—定义了控制服务入站和出站流量的条件 ([http://mng.bz/61vy](http://mng.bz/61vy))'
- en: '*Role-based access control (RBAC**)*—Provides granular access to Kubernetes
    objects using user and group membership ([http://mng.bz/oJMM](http://mng.bz/oJMM))'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于角色的访问控制 (RBAC)*—通过用户和组成员资格提供对Kubernetes对象的细粒度访问 ([http://mng.bz/oJMM](http://mng.bz/oJMM))'
- en: A once common Kubernetes security concept, pod security policies (PSPs), is
    deprecated with the current release of Kubernetes. However, Policy Controller
    addresses the conditions previously provided by PSPs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一种曾经常见的Kubernetes安全概念，Pod安全策略（PSPs），在当前的Kubernetes版本中已被弃用。然而，策略控制器解决了PSPs之前提供的条件。
- en: Because this chapter and book are intended to highlight the advantages Anthos
    itself brings to your Kubernetes experience, we will not be covering RBAC policies
    or NetworkPolicies, which are explained in more detail on the kubernetes.io pages
    referred to earlier and in several other Kubernetes books. This chapter is not
    intended to provide an exhaustive tutorial for securing Kubernetes clusters and
    workloads. Rather, we will focus on the additional tooling that Anthos provides
    to streamline, implement, and monitor the solutions for common security concerns.
    We will use specific vulnerabilities to demonstrate solutions, but in no way is
    this coverage exhaustive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章和本书旨在强调Anthos本身为您带来的Kubernetes体验优势，我们将不会涵盖RBAC策略或NetworkPolicies，这些在之前提到的kubernetes.io页面上以及几本其他Kubernetes书籍中有更详细的解释。本章的目的不是提供关于保护Kubernetes集群和工作负载的详尽教程。相反，我们将专注于Anthos提供的额外工具，以简化、实施和监控针对常见安全问题的解决方案。我们将使用特定的漏洞来展示解决方案，但无论如何，这种覆盖都不是详尽的。
- en: 13.3.2 Types of security
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 安全类型
- en: 'Securing any digital service must include several avenues of attack: physical,
    internal (either malicious or accidental by employees or contractors), and external.
    In addition, the purpose of such attacks takes several forms. Is the intent to
    steal data or code, disrupt the service, or hold the system hostage? No solution
    is ever 100% secure—the very fact that it needs to be usable means it will always
    be susceptible to some form of attack. However, as an industry, we should work
    to make our services as difficult to disrupt as possible.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 保护任何数字服务必须包括几个攻击途径：物理的、内部的（无论是员工或承包商的恶意或意外）、外部的。此外，此类攻击的目的有多种形式。意图是窃取数据或代码、中断服务还是使系统成为人质？没有任何解决方案是100%安全的——它需要可用的这一事实意味着它始终会以某种形式受到攻击。然而，作为一个行业，我们应该努力使我们的服务尽可能难以中断。
- en: Part of the driving force behind Kubernetes is to reduce the barriers to deploying
    functional workloads. This reduces the support overhead on the team that runs
    the cluster itself, with the tradeoff that more people have access to deploy workloads
    and configurations that may cause service disruption. Therefore, from the cluster
    security perspective, we need to put specific policies in place to minimize the
    possibility of a vulnerability being exploited. Although some organizations can
    do this entirely with people-oriented policies, the best security policies are
    those where the enforcement mechanism is automatic and does not rely on manual
    intervention.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes背后的部分驱动力是降低部署功能性工作负载的障碍。这减少了运行集群本身的团队的支持开销，但代价是更多的人可以访问部署可能导致服务中断的工作负载和配置。因此，从集群安全的角度来看，我们需要实施具体政策以最大限度地减少漏洞被利用的可能性。尽管一些组织可以完全通过以人为本的政策来完成这项工作，但最佳的安全政策是那些执行机制是自动的，不依赖于人工干预的。
- en: As with any compute-abstraction platform, Kubernetes contains multiple avenues
    of attack, especially in the default configuration. Some of these will always
    be present, to one degree or another, to deliver the value of the workloads in
    the cluster. For example, a middleware service that stores and retrieves data
    from a database is always going to need access to the database server, leaving
    an opening between the two components.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何计算抽象平台一样，Kubernetes包含多个攻击途径，尤其是在默认配置下。其中一些始终以某种程度存在，以提供集群中工作负载的价值。例如，一个存储和检索数据库数据的中间件服务始终需要访问数据库服务器，从而在两个组件之间留下一个开口。
- en: Every organization should reduce the possible avenues of attack on their systems.
    However, no organization is exactly like another. Therefore, most Kubernetes flavors
    are distributed with intentionally less-restrictive security settings. The first
    task of a Kubernetes administrator should be to apply a more rigorous set of security
    policies, in keeping with their organization’s directives and needs. We can’t
    provide an exhaustive list of every possible policy for every organization.[¹](#pgfId-1076355)
    However, we will cover a couple of basic policies that apply to most clusters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组织都应该减少其系统可能的攻击途径。然而，没有两个组织是完全相同的。因此，大多数Kubernetes版本都附带了一些故意不那么限制性的安全设置。Kubernetes管理员的首要任务应该是应用一套更严格的安全政策，以符合其组织的指令和需求。我们无法为每个组织提供每个可能政策的详尽列表。[¹](#pgfId-1076355)
    然而，我们将介绍一些适用于大多数集群的基本政策。
- en: Privileged containers and the root user
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 特权容器和root用户
- en: One of the great advantages of container-based orchestration systems is the
    reduction of resource usage by sharing the system’s kernel (and typically, a portion
    of the filesystem) with the underlying containers; Kubernetes is no different.
    These orchestrators, including Kubernetes, include safeguards to prevent processes
    inside containers from accessing the host machine’s resources directly. However,
    certain components of the orchestration system may need access to specific portions
    of the host infrastructure, either as a user or root. Before the development of
    in-container image builders, this was a common way to build images while running
    in a clean environment within a container.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基于容器的编排系统的一个巨大优势是通过与底层容器共享系统内核（通常还包括文件系统的一部分）来减少资源使用；Kubernetes也不例外。这些编排器，包括Kubernetes，包括防止容器内进程直接访问主机机器资源的保护措施。然而，编排系统的某些组件可能需要以用户或root身份访问主机基础设施的特定部分。在容器内镜像构建器开发之前，这是在容器内干净环境中运行时构建镜像的常见方式。
- en: In Kubernetes, the ability for a container to “break out” and issue commands
    to the host system is governed through the privileged flag on a container or Pod
    spec. Running commands on the host system as an individual user may be of limited
    use in most cases, unless the container is running as a superuser or assumes the
    identity of one. For simplicity, many container images available publicly run
    internally as the root user, to avoid permissions issues within the container.
    However, if the privileged flag is set to true, this would allow processes inside
    the container to break out and affect the host system as the superuser.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，容器“突破”并向主机系统发出命令的能力是通过容器或Pod规范上的privileged标志来管理的。在主机系统上以单个用户身份运行命令在大多数情况下可能用途有限，除非容器以超级用户身份运行或假定了一个超级用户的身份。为了简单起见，许多公开可用的容器镜像内部以root用户身份运行，以避免容器内的权限问题。然而，如果privileged标志设置为true，这将允许容器内的进程突破并作为超级用户影响主机系统。
- en: 'Two safeguards must be put in place to prevent a container from running as
    a superuser account: force containers to prevent privilege escalation, and prevent
    images from running as the root user by default.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止容器以超级用户账户运行，必须采取两项安全措施：强制容器防止权限提升，并防止默认以root用户运行镜像。
- en: 'Previously, Kubernetes included the PodSecurityPolicy object type to enforce
    specific policies for deployed Pods. However, PSPs have been deprecated starting
    in Kubernetes 1.21 and will be removed, in their current form, in the 1.25 release.
    The Kubernetes SIG decided to deprecate PSPs for many reasons, including these:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，Kubernetes包括PodSecurityPolicy对象类型来强制实施针对已部署Pod的具体策略。然而，从Kubernetes 1.21开始，PSPs已被弃用，并在1.25版本中将以当前形式被移除。Kubernetes
    SIG决定弃用PSPs，原因有很多，包括以下这些：
- en: Difficulty in troubleshooting policies due to how they are applied. PSPs are
    bound to either the Pod’s Service Account or the user that submitted the request.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于策略的适用方式，故障排除策略存在困难。Pod安全策略（PSPs）绑定到Pod的服务账户或提交请求的用户。
- en: Cannot limit the type of PersistentVolumeClaims, which means a user could create
    a PersistentVolumeClaim using a HostPath.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法限制持久卷声明（PersistentVolumeClaims）的类型，这意味着用户可以使用HostPath创建持久卷声明。
- en: Failing closed, which means that if a policy has not been defined, the action
    will fail. Due to this behavior, you cannot enable PSPs at the start of rolling
    out a cluster—you need to have all your policies created before enabling PSPs
    for the entire cluster.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭失败，这意味着如果未定义策略，操作将失败。由于这种行为，你无法在集群滚动推出时启用PSPs——你需要在启用整个集群的PSPs之前创建所有策略。
- en: Even before the deprecation of PSPs, many organizations skipped using them due
    to the limitations mentioned. Instead, they decided to implement an admission
    controller like Gatekeeper (previously known as OPA, or Gatekeeper 1.0).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在PSPs弃用之前，许多组织也由于上述限制而跳过了使用它们。相反，他们决定实施一个准入控制器，如Gatekeeper（之前称为OPA或Gatekeeper
    1.0）。
- en: To secure a cluster, you need to think about what a malicious actor would attempt
    to execute before you can mitigate the risk. Let’s discuss some of the common
    security concerns that you need to consider before a new cluster goes live.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保集群的安全，你需要在降低风险之前考虑恶意行为者可能会尝试执行的操作。让我们讨论一些在新的集群上线前需要考虑的常见安全担忧。
- en: 13.4 Common security concerns
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 常见安全担忧
- en: The Kubernetes API and configuration design provides for a large amount of flexibility
    to support a wide range of deployment scenarios and applications. However, most
    organizations do not need, nor do they want, the more security-sensitive configuration
    options to be enabled. Some of these sensitive fields that are permitted by default
    are included in table 13.1.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API和配置设计提供了大量的灵活性，以支持广泛的部署场景和应用。然而，大多数组织不需要，也不希望启用更安全的配置选项。默认允许的一些敏感字段包含在表13.1中。
- en: Table 13.1 Manifest fields that may lead to a security incident
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.1 可能导致安全事件的安全事件字段
- en: '| pod.spec fields |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| pod.spec fields |'
- en: '| Field | Description |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Field | Description |'
- en: '| hostPID | Allows containers to share the host’s process namespace |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| hostPID | 允许容器共享宿主机的进程命名空间 |'
- en: '| hostIPC | Allows containers to share the host’s IPC namespace |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| hostIPC | 允许容器共享宿主机的IPC命名空间 |'
- en: '| hostNetwork | Allows container to share the host’s network namespace |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| hostNetwork | 允许容器共享宿主机的网络命名空间 |'
- en: '| pod.spec.containers.securityContext fields |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| pod.spec.containers.securityContext fields |'
- en: '| Field | Description |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Field | Description |'
- en: '| privileged | Allows containers to access all the host’s devices |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| privileged | 允许容器访问宿主机的所有设备 |'
- en: '| allowPrivilegeEscalation | Allows a process to have more access than its
    parent process |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| allowPrivilegeEscalation | 允许进程比其父进程有更多的访问权限 |'
- en: One vulnerability occurs in Kubernetes if containers are set to run as root
    and the privileged field is set to true. Many widely distributed images use the
    root user as the default user—developers and administrators can, and should, change
    this to use a nonroot user. However, just running as a root user does not give
    the container access to the host system, because the container daemon will prevent
    access. But, if users can set the privileged field to true, then a run-as-root
    container *will* be able to access the host system and make changes or extract
    data they should not have access to. To prevent this from occurring, we need to
    create a new Gatekeeper policy instance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器被设置为以root用户身份运行，并且privileged字段被设置为true，则在Kubernetes中会出现一个漏洞。许多广泛分布的镜像使用root用户作为默认用户——开发人员和管理员可以，并且应该将其更改为使用非root用户。然而，仅仅以root用户身份运行并不给容器访问宿主系统的权限，因为容器守护进程将阻止访问。但是，如果用户可以将privileged字段设置为true，那么以root用户身份运行的容器*将*能够访问宿主系统并做出或提取他们不应访问的更改或数据。为了防止这种情况发生，我们需要创建一个新的Gatekeeper策略实例。
- en: These fields represent only a small list of items that may be used to compromise
    a host. Later in the chapter, we will use these options to demonstrate how an
    attacker can use them to gain full access to a Kubernetes host in a cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段仅代表可能被用来危害宿主机的一小部分项目。在本章的后面部分，我们将使用这些选项来演示攻击者如何使用它们来获得对集群中Kubernetes宿主机的完全访问权限。
- en: Attackers don’t always want to take over a host system. They may be content
    simply disrupting services and causing general havoc. Unfortunately, this type
    of incident can also be triggered by an innocent user who may not have full knowledge
    of the system, leading to a system outage or degradation. Your security standards
    need to consider all actions that may lead to a service interruption initiated
    from outside entities, such as permitted but malicious users or potential misconfigurations
    from well-meaning users.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者并不总是想要接管宿主机系统。他们可能只是满足于破坏服务并造成一般混乱。不幸的是，这种类型的事件也可能由一个可能没有完全了解系统的无辜用户触发，导致系统故障或降级。您的安全标准需要考虑所有可能导致服务中断的行动，这些行动可能来自外部实体，例如允许但恶意用户或善意用户的潜在误配置。
- en: 'The following list outlines some often overlooked settings that, if not addressed,
    may have an effect that could lead to revenue losses, fines, service outages,
    or negative company brand consequence:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了一些经常被忽视的设置，如果不加以解决，可能会导致收入损失、罚款、服务中断或负面公司品牌后果：
- en: Duplicate Ingress controller URLs
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ingress控制器URL重复
- en: Could lead to service interruption for the Ingress rules that conflict
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能导致冲突的Ingress规则的服务中断
- en: An application, or namespace, that consumes all a node’s resources
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗一个节点所有资源的应用程序或命名空间
- en: Leads to host resource problems, affecting all applications on the host
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致宿主机资源问题，影响宿主机上的所有应用程序
- en: Rogue container images that have not been pulled from an approved registry
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未从已批准的注册表中拉取的恶意容器镜像
- en: May lead to malware or ransomware
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能导致恶意软件或勒索软件
- en: An Istio policy that uses “*”
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用“*”的Istio策略
- en: Leads to service interruption for all Istio services
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致所有Istio服务的服务中断
- en: Unencrypted traffic between Pods in a cluster
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群中Pod之间的未加密流量
- en: Could lead to data leaks
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能导致数据泄露
- en: This is just a small list of common concerns that need to be considered to increase
    the security and availability of a cluster. If you had to think about every scenario
    that could affect a Kubernetes application, it could take you months to create
    policies that address each task, and they would not cover scenarios you did not
    think of. Far too often, you will learn about an action that you didn’t consider
    only after an event has occurred.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个需要考虑以增加集群的安全性和可用性的常见问题列表。如果你必须考虑可能影响Kubernetes应用程序的每个场景，创建解决每个任务的策略可能需要数月时间，而且它们可能不会涵盖你没有想到的场景。过于频繁的是，你只有在事件发生后才会了解到你没有考虑到的动作。
- en: Anthos includes products that provide configuration management and enhanced
    security to your cluster, including a set of policies developed by the community
    and Google. But, before getting into the Anthos security and policy features,
    let’s review general container security, so we can understand the need for the
    tools Anthos provides.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Anthos包括提供配置管理和增强安全性的产品，这些产品包括社区和Google开发的一系列策略。但在深入了解Anthos的安全性和策略功能之前，让我们回顾一下通用的容器安全性，以便我们能够理解Anthos提供的工具的需求。
- en: 13.4.1 Understanding the Policy Controller
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 理解策略控制器
- en: The ACM Policy Controller provides an admission controller to a cluster. An
    admission controller is a component that validates or mutates requests to the
    Kubernetes API Server, executing the logic of the controller before allowing or
    denying the request.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ACM策略控制器为集群提供了一个准入控制器。准入控制器是一个组件，它验证或修改发送到Kubernetes API服务器的请求，在允许或拒绝请求之前执行控制器的逻辑。
- en: When you enable the policy engine, a ValidatingWebHook configuration is created,
    which registers the engine as an admission controller with the API server. Once
    registered, the API server will send object requests to the admission controller
    to be evaluated, as shown in figure 13.1.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启用策略引擎时，会创建一个ValidatingWebHook配置，该配置将引擎注册为API服务器的准入控制器。一旦注册，API服务器将发送对象请求到准入控制器进行评估，如图13.1所示。
- en: '![13-01](../../OEBPS/Images/13-01.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![13-01](../../OEBPS/Images/13-01.png)'
- en: Figure 13.1 Admission controller policy validation flow
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 准入控制器策略验证流程
- en: In the workflow shown in figure 13.1, the API server has received a request
    to create a new Pod. Because the cluster has ACM installed with the Policy Controller
    enabled, the request is sent to the Gatekeeper service. The service then forwards
    the request to the Gatekeeper Pod, which checks the configured policies for any
    violations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在图13.1所示的流程中，API服务器收到了创建新Pod的请求。由于集群已安装ACM并启用了策略控制器，请求被发送到Gatekeeper服务。然后该服务将请求转发到Gatekeeper
    Pod，该Pod检查配置的策略是否存在违规。
- en: At this point, you may be wondering what kind of latency or performance effects
    a cluster may experience once Gatekeeper has been deployed. On average, policy
    evaluation takes about one millisecond, even when larger policies are evaluated.
    Like any system that allows you to create your own objects, you can create a policy
    that will affect the performance of the policy engine, resulting in overall system
    latency. Creating policies is beyond the scope of this chapter. If you want to
    learn more about policies and performance, you can find additional details on
    the Open Policy Agent website at [http://mng.bz/v1GM](http://mng.bz/v1GM).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道一旦部署了Gatekeeper，集群可能会体验到什么样的延迟或性能影响。平均而言，策略评估大约需要一毫秒，即使评估较大的策略也是如此。像任何允许你创建自己的对象的系统一样，你可以创建一个会影响策略引擎性能的策略，从而导致整体系统延迟。创建策略超出了本章的范围。如果你想了解更多关于策略和性能的信息，你可以在Open
    Policy Agent网站上找到更多详细信息，网址为[http://mng.bz/v1GM](http://mng.bz/v1GM)。
- en: In the example shown in figure 13.1, a policy was found that denied the request,
    resulting in the admission controller sending the denial to the API server. Because
    the admission controller returned a denial, the API server will not create the
    object and will update the status of the object with the error provided by the
    policy engine.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在图13.1所示的示例中，发现了一个拒绝请求的策略，导致准入控制器将拒绝信息发送到API服务器。由于准入控制器返回了拒绝，API服务器将不会创建对象，并将使用策略引擎提供的错误更新对象的状况。
- en: A policy engine is a simple evaluation system that checks a request and decides
    whether the request will be allowed. Policy engines have an easy flow to them,
    but the real power in them is the policies themselves, which provide the logic
    for the decision process. In ACM we use constraint templates and constraints to
    implement security policies in our clusters. In the next sections, we will explain
    what constraint templates are and how they are implemented in a cluster by creating
    constraints.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 策略引擎是一个简单的评估系统，它检查请求并决定是否允许该请求。策略引擎有一个简单的流程，但其中的真正力量在于策略本身，它为决策过程提供逻辑。在ACM中，我们使用约束模板和约束在我们的集群中实现安全策略。在下一节中，我们将解释约束模板是什么以及它们是如何通过创建约束在集群中实现的。
- en: Introducing Gatekeeper constraint templates
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍门卫约束模板
- en: 'Think of constraint templates as the logic that is used by the policy engine
    to make decisions about requests. When Gatekeeper is enabled on a cluster, it
    will create a set of default policies that contain rules for common use cases.
    At the time of writing, ACM’s policy controller includes 32 templates, including
    these:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将约束模板视为策略引擎用于做出决策的逻辑。当在集群上启用门卫时，它将创建一组默认策略，包含常见用例的规则。在撰写本文时，ACM的策略控制器包括32个模板，包括以下这些：
- en: Allowed container registries
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的容器注册库
- en: Istio-specific policies
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio特定的策略
- en: Resource constraints
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源约束
- en: Alternative security that provides security similar to PSPs
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供类似于PSPs的安全性的替代方案
- en: Note You can find a complete list of each template and a description of what
    each does by visiting [http://mng.bz/41oV](http://mng.bz/41oV).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以通过访问[http://mng.bz/41oV](http://mng.bz/41oV)找到每个模板的完整列表及其描述。
- en: Each policy is a custom resource type known as a ConstraintTemplate. You can
    view all the templates in a cluster by executing kubectl get constrainttemplates.
    An abbreviated list is shown in figure 13.2.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个策略都是称为ConstraintTemplate的自定义资源类型。您可以通过执行kubectl get constrainttemplates来查看集群中的所有模板。简化的列表如图13.2所示。
- en: '![13-02](../../OEBPS/Images/13-02.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![13-02](../../OEBPS/Images/13-02.png)'
- en: Figure 13.2 Constraint template list
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 约束模板列表
- en: Constraint templates, by themselves, are only a definition of a policy—the logic
    that will be used for the evaluation. In the next section, we will explain how
    to use constraint templates to create a constraint, which will enable a selected
    policy on the cluster.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 约束模板本身仅是策略的定义——用于评估的逻辑。在下一节中，我们将解释如何使用约束模板创建约束，从而在集群上启用所选策略。
- en: Enabling a policy
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 启用策略
- en: 'To enable the enforcement of a policy, you need to create a YAML file that
    defines a constraint, which will be evaluated when a new object is created. This
    is a key behavior to remember: because the policy engine is an admission controller,
    it evaluates objects only when they are created or admitted to the cluster. It
    will not enforce the policy against any existing objects until they are recreated,
    but it will show violations of the policy running in the cluster. This aspect
    is often overlooked by users who are newer to Gatekeeper and is a key point to
    remember when you implement a new policy in your cluster.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用策略的执行，您需要创建一个YAML文件，该文件定义了一个约束，当创建新对象时将对其进行评估。这是一个需要记住的关键行为：因为策略引擎是一个准入控制器，它仅在对象创建或被集群接受时评估对象。它不会对任何现有对象执行策略，直到它们被重新创建，但它会显示集群中正在运行的策略违规。这一点常常被初学者忽视，当您在集群中实施新策略时，这是一个需要记住的关键点。
- en: 'Earlier we explained how a container that is started as a privileged container
    could be used to compromise the host and, ultimately, the cluster. Because of
    this potential, you may want to deny the creation of privileged Pods. Because
    this is a common use case, ACM includes a template to deny privileged containers.
    The example manifest that follows creates an object called deny-privileged, using
    the custom resource kind K8sPSPPrivilegedContainer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们解释了如何使用以特权容器启动的容器来损害主机，最终损害集群。由于这种潜在风险，您可能希望拒绝创建特权Pod。由于这是一个常见用例，ACM包括一个拒绝特权容器的模板。以下示例清单创建了一个名为deny-privileged的对象，使用自定义资源类型K8sPSPPrivilegedContainer：
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that, in the spec section of the manifest, we define a match parameter.
    This parameter defines which object(s) the policy engine will evaluate against
    the constraint. In the example, the policy will be evaluated against all apiGroups
    for the object type pod. This means that any time a Pod request is received, it
    will be checked to see whether it is attempting to start as a privileged container.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在清单的spec部分中，我们定义了一个匹配参数。此参数定义了策略引擎将如何评估约束的对象。在示例中，策略将针对对象类型pod的所有apiGroups进行评估。这意味着每次收到Pod请求时，都会检查它是否试图以特权容器的形式启动。
- en: You might be wondering why we are matching only Pods, and not Deployments or
    ReplicaSets. The Pods match will evaluate any attempts to create a Pod, which
    includes a manifest that uses a type of Pod, or when any other object like a Deployment
    tries to create a Pod. When a Deployment is submitted, the API server will create
    a Deployment object, which creates a ReplicaSet object, which creates the Pods.
    No matter how the Pod is created, it will be checked against the policy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们只匹配Pod，而不是Deployments或ReplicaSets。Pod匹配将评估任何创建Pod的尝试，包括使用Pod类型的清单，或者当其他对象如Deployment试图创建Pod时。当Deployment被提交时，API服务器将创建一个Deployment对象，它创建一个ReplicaSet对象，然后创建Pod。无论Pod如何创建，它都将与策略进行核对。
- en: By default, once a constraint has been created, it will be enforced for every
    object defined in the match list. This includes Anthos system namespaces like
    kube-system, gke-system, and gke-connect. If you were to add the constraint in
    the previous example, Pods like kube-proxy and CNI Pods like Calico or Cilium
    would be blocked from starting up. If CNI Pods are denied startup, the cluster
    nodes will not have any network connectivity, causing all Pods to fail. Because
    constraints have a clusterwide effect, you need to carefully plan and understand
    how the policy will affect the entire cluster, including existing objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一旦创建了一个约束，它将对匹配列表中定义的每个对象生效。这包括Anthos系统命名空间，如kube-system、gke-system和gke-connect。如果你在先前的示例中添加了约束，像kube-proxy和Calico或Cilium这样的CNI
    Pod将无法启动。如果CNI Pod被拒绝启动，集群节点将没有任何网络连接，导致所有Pod失败。由于约束具有集群级影响，你需要仔细规划和理解策略将如何影响整个集群，包括现有对象。
- en: 'It may seem that a policy will affect every namespace, and by default, that
    it is true of a new policy. Luckily, ACM allows you to exclude a namespace by
    adding a constraint that includes the namespace in the spec.match.excludedNamespaces,
    or you can configure the Policy Controller to have exemptableNamespaces as documented
    here: [http://mng.bz/Q84j](http://mng.bz/Q84j).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来策略会影响每个命名空间，并且默认情况下，对于新策略来说确实是如此。幸运的是，ACM允许你通过在spec.match.excludedNamespaces中添加包含命名空间的约束来排除命名空间，或者你可以根据此处记录的说明配置Policy
    Controller以具有exemptableNamespaces：[http://mng.bz/Q84j](http://mng.bz/Q84j)。
- en: Because policies can have unintended consequences, the Anthos policy manager
    has an option that allows you to audit the results of a constraint without actually
    enforcing it. In the next section, we’ll discuss auditing a constraint.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于策略可能产生意外的后果，Anthos策略管理器有一个选项允许你在不实际强制执行约束的情况下审计约束的结果。在下一个小节中，我们将讨论如何审计约束。
- en: Auditing a constraint
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 约束的审计
- en: 'Before enforcing a new constraint, you should test it against the cluster to
    avoid any unexpected results. As mentioned in the previous section, when you create
    a new constraint, it will be enforced by default. You can change this default
    behavior from enforcement to auditing by adding the enforcementAction: dryrun
    option to the constraint manifest. Using the psp-privileged-container example,
    we can add the dryrun option to change the default enforcement behavior from enforcement
    to auditing as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '在强制执行新的约束之前，你应该在集群上测试它以避免任何意外结果。如前一小节所述，当你创建一个新的约束时，它将默认生效。你可以通过将enforcementAction:
    dryrun选项添加到约束清单中，将此默认行为从强制执行更改为审计。使用psp-privileged-container示例，我们可以添加dryrun选项来将默认的强制执行行为更改为审计，如下所示：'
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that the enforcement has been changed to auditing, any Pod that violates
    the constraint will only be logged as a violation, but it will still be allowed
    to start up. Also, unlike the default enforcement behavior, setting the constraint
    to dryrun will evaluate not only new requests but all running Pods as well. This
    allows you to verify the effects of a constraint on every Pod, rather than just
    new requests, so you will know how it would affect any Pods that are restarted.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在强制执行已更改为审计，任何违反约束的Pod都只会被记录为违规，但它仍然可以启动。此外，与默认强制执行行为不同，将约束设置为dryrun将评估不仅新请求，还包括所有正在运行的Pod。这允许您验证约束对每个Pod的影响，而不仅仅是新请求，因此您将知道它将如何影响任何重新启动的Pod。
- en: 'Once set to dryrun, you can view the results of the audit using kubectl get
    <constraint kind> <constraint name> -o yaml. For our example, we can view the
    affected Pods by executing kubectl get K8sPSPPrivilegedContainer psp-privileged-container
    -o yaml. Depending on how many violations there are, you may receive a lengthy
    list of affected containers. The next output is an abbreviated list from a default
    cluster running Anthos on bare metal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置为dryrun，您可以使用kubectl get <约束类型> <约束名称> -o yaml查看审计结果。以我们的示例，我们可以通过执行kubectl
    get K8sPSPPrivilegedContainer psp-privileged-container -o yaml来查看受影响的Pod。根据违规的数量，您可能会收到一个受影响容器的长列表。以下是从默认集群中运行Anthos的简略列表：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output shows that if we were to enforce this policy, the kube-proxy and
    Cilium Pods would be denied startup. This presents a catch-22: we want to deny
    privileged containers from running, but we need to have privileged containers
    to allow the system container to run. It is not uncommon for certain containers
    to go against a policy that would deny the container starting. Because this is
    a common scenario, the policy engine allows you to exempt namespaces from being
    evaluated from either all policies or only certain policies.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，如果我们强制执行此策略，kube-proxy和Cilium Pod将被拒绝启动。这构成了一个两难境地：我们希望拒绝运行特权容器，但我们需要特权容器来允许系统容器运行。某些容器违反会拒绝容器启动的策略并不罕见。由于这是一个常见的场景，策略引擎允许您免除命名空间被评估，无论是所有策略还是仅某些策略。
- en: Creating a namespace exemption
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命名空间免除
- en: Once a constraint is created, it will affect every container that is started,
    without any regard for the type of Pod that is being started. Many common system
    containers, like networking or logging agents, require privileges that may be
    denied by a cluster policy. Because policies secure a cluster, they are enforced
    at the cluster level, across all namespaces. This may work for certain policies,
    but others may block a legitimate container from being scheduled. To allow exemptions,
    the admission controller includes controls that allow namespaces to be exempt
    from either all policies or just select policies.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建约束，它将影响每个启动的容器，而不考虑正在启动的Pod的类型。许多常见的系统容器，如网络或日志代理，可能需要被集群策略拒绝的权限。由于策略保护集群，它们在集群级别强制执行，跨越所有命名空间。这可能适用于某些策略，但其他策略可能会阻止合法容器被调度。为了允许免除，准入控制器包括允许命名空间免除所有策略或仅某些策略的控制。
- en: Exempting a namespace from specific processing
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 免除特定处理中的命名空间
- en: To exempt namespaces from all Gatekeeper policies, you can create a config object
    that contains the namespace(s) that you want to exempt. You can exempt each namespace
    from all Gatekeeper functions or only certain processes, like auditing, by adding
    one or more processing options. Table 13.2 shows the four processing options that
    can be set.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要免除命名空间的所有门卫策略，您可以创建一个包含您想要免除的命名空间的配置对象。您可以通过添加一个或多个处理选项来免除每个命名空间的所有门卫功能或仅某些过程，如审计。表13.2显示了可以设置的四个处理选项。
- en: Table 13.2 Namespace exemption options
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.2 命名空间免除选项
- en: '| Process option | Results of exemption |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 处理选项 | 免除结果 |'
- en: '| Audit | Namespace(s) will not report audit results but will still be part
    of the webhook and sync processes. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 审计 | 命名空间将不会报告审计结果，但仍将是webhook和同步流程的一部分。 |'
- en: '| Webhook | Namespace(s) will be exempt from the admission controller but will
    still be part of the audit and sync processes. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| Webhook | 命名空间将免于准入控制器，但仍将是审计和同步流程的一部分。 |'
- en: '| Sync | Namespace(s) resources will not be reported into Gatekeeper but will
    still be part of the audit and webhook processes. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 同步 | 命名空间资源将不会报告给门卫，但仍将是审计和webhook流程的一部分。 |'
- en: '| * | Exempts the namespace(s) from all Gatekeeper processes. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| * | 免除命名空间（s）从所有Gatekeeper进程。'
- en: 'For example, we may want to exempt a few namespaces from all Gatekeeper processing.
    To exempt all processes, we can create a new config that contains the namespaces,
    with an * in the processes field. The manifest shown next creates a config that
    exempts the kube-system *and* gatekeeper-system namespaces from *all* Gatekeeper
    processes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望免除一些命名空间的所有Gatekeeper处理。要免除所有进程，我们可以在包含命名空间的配置中创建一个新的配置，在进程字段中使用*。下面显示的清单创建了一个配置，该配置免除kube-system
    *和* gatekeeper-system命名空间的所有Gatekeeper进程：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can add different process exemptions for different namespaces by adding
    additional matches. For example, you can create a match that exempts a namespace
    only from the webhook process, whereas another namespace may be exempt only from
    Gatekeeper’s auditing process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加额外的匹配项为不同的命名空间添加不同的进程免除。例如，您可以创建一个仅免除命名空间从webhook进程的匹配项，而另一个命名空间可能仅免除Gatekeeper的审计进程。
- en: Exempting a namespace from all policies
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 免除所有策略的命名空间
- en: In some organizations, creating an exemption for all Gatekeeper policies might
    violate a security standard. Creating a namespace exemption is quick and easy,
    but it will exempt every deployment in that namespace from *all* Gatekeeper policies,
    without exception.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些组织中，为所有Gatekeeper策略创建免除可能会违反安全标准。创建命名空间免除既快又简单，但它将免除该命名空间中所有部署的所有Gatekeeper策略，无一例外。
- en: To exclude a namespace from all policies is a two-step process. The first step
    is to add a list of namespaces that the policy engine will allow to ignore policies,
    and the second is to label the namespace(s) that you want to exempt with admission.gatekeeper
    .sh/ignore=true.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将命名空间排除在所有策略之外是一个两步过程。第一步是添加一个策略引擎将允许忽略策略的命名空间列表，第二步是将您想要免除的命名空间（s）标记为admission.gatekeeper.sh/ignore=true。
- en: 'If you attempt to skip the first step and you only label a namespace to exempt
    it, you will receive the following error from the API server that only exempt
    namespaces can have the ignore label:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试跳过第一步，只标记一个命名空间来免除它，您将收到来自API服务器的以下错误，只有免除命名空间才能有ignore标签：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before labeling any namespaces, you must first add the namespaces by editing
    the installed configManagement object and adding a list of namespaces in the exemptableNamespaces
    field, which is added using the GCP console.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记任何命名空间之前，您必须首先通过编辑已安装的configManagement对象并在exemptableNamespaces字段中添加命名空间列表来添加命名空间。该列表是通过GCP控制台添加的。
- en: To allow a namespace to be added as an exemption using the Anthos console, you
    need to edit the config management settings for the cluster. In the GCP console,
    open Anthos > Config Management to see the list of clusters that are available.
    Select the button next to the cluster you want to configure and click Configure
    at the top of the GCP console page. If you expand the settings and scroll to the
    bottom, you will see the Policy Controller section. Click on the ACM settings
    for your clusters to open a list of exempt namespaces, as shown in figure 13.3.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Anthos控制台将命名空间添加为免除项，您需要编辑集群的配置管理设置。在GCP控制台中，打开Anthos > 配置管理以查看可用的集群列表。选择您想要配置的集群旁边的按钮，然后在GCP控制台页面顶部点击“配置”。如果您展开设置并滚动到页面底部，您将看到策略控制器部分。点击您集群的ACM设置以打开免除命名空间列表，如图13.3所示。
- en: Note You must be careful when adding a new namespace. The console does not verify
    whether a namespace already exists or if it is misspelled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在添加新命名空间时，您必须非常小心。控制台不会验证命名空间是否已存在或是否拼写错误。
- en: In figure 13.3, you can see that we have created the ability to exempt four
    namespaces. To add another namespace, you only need to click in the Exempt Namespaces
    box, type the name of the namespace, and click Done. Always double-check that
    the namespaces you enter are spelled correctly. The system does not validate the
    list against the cluster, so any errors in spelling will fail to add the namespace
    to the exemption list. Once the namespaces have been added to the exemption list,
    you must label the namespace with the admission.gatekeeper.sh/ignore=true label,
    exempting the namespace from all Gatekeeper policies.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在图13.3中，您可以看到我们已经创建了免除四个命名空间的能力。要添加另一个命名空间，您只需在“免除命名空间”框中点击，输入命名空间名称，然后点击“完成”。始终要检查您输入的命名空间拼写是否正确。系统不会将列表与集群进行验证，因此任何拼写错误都将导致无法将命名空间添加到免除列表中。一旦命名空间被添加到免除列表中，您必须使用admission.gatekeeper.sh/ignore=true标签标记该命名空间，使其免于所有Gatekeeper策略。
- en: '![13-03](../../OEBPS/Images/13-03.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![13-03](../../OEBPS/Images/13-03.png)'
- en: Figure 13.3 Adding an exemption using the GCP console
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 使用 GCP 控制台添加豁免
- en: Labeling the namespace to ignore Gatekeeper will cause the admission controller
    to ignore *every* policy for any object that is created in the namespace. Rather
    than exempting a namespace from every policy, you may want to consider exempting
    the namespace from individual policies, allowing you to enforce some policies,
    while exempting only the required policies for object creation in the namespace.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为命名空间标记以忽略 Gatekeeper 将导致准入控制器忽略该命名空间中创建的任何对象的 *所有* 策略。与其从每个策略中豁免命名空间，你可能会考虑从单个策略中豁免命名空间，这样你可以执行某些策略，同时仅豁免命名空间中对象创建所需的策略。
- en: Exempting a namespace from a constraint template
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从约束模板中豁免命名空间
- en: 'If you find yourself in a situation where you need to exempt a certain namespace
    from a policy, but you cannot exempt the namespace from *all* policies, you can
    add an exemption to the constraint itself. For example, suppose we have a policy
    that requires all namespaces to have a billing code assigned to them. However,
    we want to exempt the kube-system namespace and a new namespace that will be created
    called web-frontend. We can do this by adding the excludedNamespaces field to
    our constraint as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己处于需要从策略中豁免特定命名空间的情况，但你不能从 *所有* 策略中豁免该命名空间，你可以向约束本身添加豁免。例如，假设我们有一个要求所有命名空间都必须分配计费代码的策略。然而，我们希望豁免
    kube-system 命名空间以及将要创建的新命名空间 web-frontend。我们可以通过向我们的约束中添加 excludedNamespaces 字段来实现这一点，如下所示：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we attempt to create a new namespace called test-fail without a label, Gatekeeper
    will deny the request with the following error:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试创建一个名为 test-fail 的新命名空间，但没有标签，Gatekeeper 将会拒绝请求并显示以下错误：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, if we try to create the web-frontend namespace without a label, as
    shown next, Gatekeeper will allow it, because it is included in the excludedNamespaces
    for the constraint:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试创建没有标签的 web-frontend 命名空间，如以下所示，Gatekeeper 将允许这样做，因为它包含在约束的 excludedNamespaces
    中：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ACM provides granular controls to exempt namespaces by providing the ability
    to exempt a namespace from either all policies or only certain policies. You can
    use a mix of each type for different namespaces, exempting one namespace for all
    policies, whereas other namespaces may be exempt from only certain policies. Try
    to avoid exempting namespaces from all policies, unless you have strong justification
    to do so. Once exempt, no policies will ever be enforced for a fully exempted
    namespace.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ACM 通过提供从所有策略或仅某些策略中豁免命名空间的能力，提供了细粒度的控制。你可以为不同的命名空间混合使用这两种类型，为某个命名空间豁免所有策略，而其他命名空间可能仅豁免某些策略。尽量避免从所有策略中豁免命名空间，除非你有充分的理由这样做。一旦豁免，完全豁免的命名空间将永远不会执行任何策略。
- en: Although Anthos includes several constraint templates, some scenarios may exist
    where you need to create a custom constraint. In the next section, we will explain
    how to create a custom constraint template, allowing you to extend the included
    set of policies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Anthos包含几个约束模板，但可能存在一些场景，你需要创建自定义约束。在下一节中，我们将解释如何创建自定义约束模板，这样你可以扩展包含的策略集。
- en: Creating a constraint template
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建约束模板
- en: The default template library included with ACM has grown from a handful of policies
    in the early releases to more than 32 with the most current release. Google and
    the community continue to add policies to the default library, but you may have
    a unique policy requirement for your clusters that Google does not provide.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ACM 内置的默认模板库从早期版本中的少量策略增长到当前版本中的超过 32 个。Google 和社区继续向默认库添加策略，但你可能对你的集群有独特的策略需求，而
    Google 并不提供。
- en: If you find yourself needing to create a policy, you can create a custom constraint
    template by creating your own policy using a language called Rego. Covering Rego
    in depth is beyond the scope of this book, but you can read more about Rego and
    how to use it to create policies at [http://mng.bz/X5e6](http://mng.bz/X5e6).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要创建策略，你可以通过使用名为 Rego 的语言创建自己的策略来创建自定义约束模板。深入介绍 Rego 超出了本书的范围，但你可以在 [http://mng.bz/X5e6](http://mng.bz/X5e6)
    上了解更多关于 Rego 以及如何使用它来创建策略的信息。
- en: To create a new template, you need to create a new ConstraintTemplate object,
    which will contain the Rego code to evaluate the policy. Google offers documentation
    to assist you in creating a template at [http://mng.bz/ydKq](http://mng.bz/ydKq).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的模板，你需要创建一个新的ConstraintTemplate对象，该对象将包含用于评估策略的Rego代码。Google提供了文档来帮助你创建模板，请参阅[http://mng.bz/ydKq](http://mng.bz/ydKq)。
- en: 'The next example creates a new template that will check for an image digest
    when a new container is created:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例创建了一个新的模板，当创建新容器时将检查图像摘要：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It’s important to note that the Rego code contains multiple violation sections.
    At first glance, it may appear that the code is the same for each, but on closer
    inspection, you will notice one minor difference on the container := lines. The
    first violation block checks all containers for a digest, whereas the second violation
    block checks all initContainers for a digest, and the third checks any ephemeralContainers.
    Because they are all unique objects, we need to include each object in our code,
    or it will not be checked by the policy engine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Rego代码包含多个违规部分。乍一看，这些代码可能看起来是相同的，但仔细检查时，你会在container :=行上注意到一个细微的差异。第一个违规块检查所有容器是否有摘要，而第二个违规块检查所有initContainers是否有摘要，第三个检查任何ephemeralContainers。因为它们都是独特的对象，所以我们需要在我们的代码中包含每个对象，否则策略引擎将不会检查它们。
- en: 'Finally, to activate the constraint, we apply a manifest that uses the new
    custom resource created by the previous template, K8sImageDigests:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了激活约束，我们应用了一个使用之前模板创建的新自定义资源manifest，即K8sImageDigests：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once applied to the cluster, any new Pod request that does not supply a digest
    will be denied by the admission controller.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用到集群中，任何没有提供摘要的新Pod请求都将被准入控制器拒绝。
- en: 13.4.2 Using Binary Authorization to secure the supply chain
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 使用二进制授权来保护供应链
- en: Since the SolarWinds security breach, there has been a spotlight on how you
    need to secure your software supply chain. You should always consider and implement
    this, but it often takes an event like the SolarWinds breach to capture the attention
    of the public. Securing the supply chain is a large topic, and to give it the
    coverage it deserves would require a dedicated chapter, but we wanted to provide
    an overview of the tools Google provides to help you secure your supply chain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 自从SolarWinds安全漏洞以来，人们开始关注如何保护你的软件供应链。你应该始终考虑并实施这一点，但通常需要像SolarWinds漏洞这样的事件来吸引公众的注意。保护供应链是一个大话题，要给它应有的关注就需要一个专门的章节，但我们想提供一个概述，介绍Google提供的工具，以帮助你保护你的供应链。
- en: You may have recently heard the phrase “Shifting left on security.” This term
    refers to the practice of considering security earlier in the software development
    process. You should consider a number of topics when shifting left, and if you
    want to read an independent report sponsored by companies including Google, CloudBees,
    Deloitte, and more, read the State of DevOps from 2019, which covers key findings
    from multiple companies and their DevOps practices, located at [https://cloud.google.com/devops/state-of-devops](https://cloud.google.com/devops/state-of-devops).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能最近听说过“左移安全”这个短语。这个术语指的是在软件开发过程中更早地考虑安全性的做法。在左移时，你应该考虑多个主题；如果你想阅读由包括Google、CloudBees、德勤等公司赞助的独立报告，请阅读2019年的《DevOps状态》，它涵盖了多家公司的关键发现及其DevOps实践，请参阅[https://cloud.google.com/devops/state-of-devops](https://cloud.google.com/devops/state-of-devops)。
- en: 'Anthos includes a powerful tool that centralizes software supply chain security
    for workloads on both Anthos on GCP and Anthos on-prem, called Binary Authorization
    (BinAuth). At a high level, BinAuth adds security to your clusters by requiring
    a trusted authority signature on your deployed images, which is attested when
    a container is deployed. If the deployed container does not contain a signature
    that matches the trusted authority, it will be denied scheduling and fail to deploy.
    Google’s BinAuth provides you several features, including the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Anthos包括一个强大的工具，它将Anthos on GCP和Anthos on-prem上的工作负载的软件供应链安全性集中化，称为二进制授权（BinAuth）。从高层次来看，BinAuth通过要求部署的镜像上有受信任的权威签名来为你的集群增加安全性，这在容器部署时得到验证。如果部署的容器不包含与受信任的权威匹配的签名，它将被拒绝调度并失败部署。Google的BinAuth为你提供了几个功能，包括以下内容：
- en: Policy creation
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略创建
- en: Policy enforcement and verification
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略执行和验证
- en: Cloud security command center integration
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云安全命令中心集成
- en: Audit logging
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计日志
- en: Cloud KMS support
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云KMS支持
- en: Uses the open source tool, Kritis, for signature verification
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开源工具 Kritis 进行签名验证
- en: Dry-run support
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持模拟运行
- en: Break-glass support
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧急支持
- en: Third-party support, including support for Twistlock, Terraform, and CloudBees
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持第三方工具，包括Twistlock、Terraform和CloudBees的支持
- en: Along with the features provided, you can integrate BinAuth with Google’s Cloud
    Build and Container registry scanning, allowing you to secure your supply chain
    based on build metadata and vulnerability scans. Google has several integrations
    docs that will step you through integrating BinAuth with several systems like
    CircleCI, Black Duck, Terraform, and Cloud Build on the Binary Authorization page,
    located at [https://cloud.google.com/binary-authorization/](https://cloud.google.com/binary-authorization/).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供的功能外，您可以将BinAuth与Google的Cloud Build和容器注册库扫描集成，允许您根据构建元数据和漏洞扫描结果来保护您的供应链。Google在二进制授权页面提供了多个集成文档，该页面位于[https://cloud.google.com/binary-authorization/](https://cloud.google.com/binary-authorization/)，它将指导您如何将BinAuth与CircleCI、Black
    Duck、Terraform和Cloud Build等系统集成。
- en: 13.4.3 Using Gatekeeper to replace PSPs
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 使用 Gatekeeper 替代 PSPs
- en: As Kubernetes deprecates PSPs, you may want to start moving away from using
    PSPs to secure your clusters. One way to move away from PSPs as your main security
    mechanism is to migrate to using Gatekeeper policies instead. The Gatekeeper project
    has a GitHub repository dedicated to policies that are designed to replace PSPs
    at [http://mng.bz/Ml6n](http://mng.bz/Ml6n).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Kubernetes弃用PSPs，您可能希望开始逐步停止使用PSPs来保护您的集群。从PSPs作为主要安全机制中退出的一种方法是将使用Gatekeeper策略。Gatekeeper项目有一个GitHub存储库，专门用于设计用于替代PSPs的策略，该存储库位于[http://mng.bz/Ml6n](http://mng.bz/Ml6n)。
- en: In the next section, we will close out the chapter by learning about securing
    your images using Google container Scanning.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过了解如何使用Google容器扫描来保护镜像来结束本章。
- en: 13.5 Understanding container scanning
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 理解容器扫描
- en: Like any standard operating system or application, containers may contain binaries
    that have known vulnerabilities. To keep your cluster secure, you need to verify
    the integrity of your containers by continuously scanning each one.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何标准操作系统或应用程序一样，容器可能包含已知漏洞的二进制文件。为了确保您的集群安全，您需要通过持续扫描每个容器来验证其完整性。
- en: Many solutions on the market today, including Aqua Security, Twistlock, Harbor,
    and Google’s Container Registry, scan containers for vulnerabilities. Each of
    these tools offers different levels of scanning abilities—in most cases, for an
    additional cost. At a minimum, you will want to scan your images for any vulnerabilities
    from the common vulnerabilities and exposures (CVE) list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上许多解决方案，包括Aqua Security、Twistlock、Harbor和Google的容器注册库，都会扫描容器以查找漏洞。这些工具中的每一个都提供不同级别的扫描能力——在大多数情况下，需要额外付费。至少，您希望扫描您的镜像以查找来自常见漏洞和暴露（CVE）列表的任何漏洞。
- en: The CVE list ([http://cve.mitre.org/cve](http://cve.mitre.org/cve)) is a publicly
    disclosed list of security vulnerabilities for various software components, including
    operating systems and libraries. Entries in the list contain only a brief overview
    of the vulnerability—they do not contain any detailed information like consequences,
    risks, or how to remediate the problem. To retrieve the details for the CVE, each
    entry has a link that will take you to the National Vulnerability Database, which
    will provide additional details about the CVE, including a description, the severity,
    references, and a change history.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: CVE列表（[http://cve.mitre.org/cve](http://cve.mitre.org/cve)）是公开披露的各种软件组件（包括操作系统和库）的安全漏洞列表。列表中的条目仅包含漏洞的简要概述——它们不包含任何详细信息，如后果、风险或如何修复问题。要获取CVE的详细信息，每个条目都有一个链接，该链接将带您访问国家漏洞数据库，该数据库将提供有关CVE的额外详细信息，包括描述、严重性、引用和变更历史。
- en: Although Anthos does not include a vulnerability scanner, Google does provide
    scanning if you store your images in the Google Container Registry. In this section,
    we will explain how to enable scanning on your repository and how to view the
    scanning results.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Anthos不包含漏洞扫描器，但如果您将镜像存储在Google容器注册库中，Google会提供扫描服务。在本节中，我们将解释如何在您的存储库中启用扫描以及如何查看扫描结果。
- en: 13.5.1 Enabling container scanning
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.1 启用容器扫描
- en: 'The first requirement to enable scanning in your registry is to enable two
    APIs on your GCP project: the Container Analysis API and the Container Scanning
    API. The Container Analysis API enables metadata storage in your project and is
    free, whereas the Container Scanning API will enable vulnerability scanning and
    is charged per scanned image. You can view the pricing details for the scanning
    API a*t* [http://mng.bz/aMjB](http://mng.bz/aMjB)*.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的注册表中启用扫描的第一个要求是在您的 GCP 项目中启用两个 API：容器分析 API 和容器扫描 API。容器分析 API 允许在您的项目中存储元数据，并且是免费的，而容器扫描
    API 将启用漏洞扫描，并且按扫描的图像计费。您可以在扫描 API 的定价详情中查看 *[http://mng.bz/aMjB](http://mng.bz/aMjB)*.*
- en: 'To enable the required APIs using the gcloud CLI, use the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 gcloud CLI 启用所需的 API，请按照以下步骤操作：
- en: 'Set your default project as follows. Our example is using a project called
    test1-236415:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式设置您的默认项目。我们的示例使用了一个名为 test1-236415 的项目：
- en: '[PRE10]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, enable the Container Analysis API:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启用容器分析 API：
- en: '[PRE11]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, enable the Container Scanning API:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启用容器扫描 API：
- en: '[PRE12]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the APIs are enabled on the project, you will need to create a repository
    in which to store your images. The next example creates a Docker registry called
    docker-registry in the us-east4 location with a description of the registry:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在项目上启用了 API，您将需要创建一个存储图像的存储库。下一个示例在 us-east4 位置创建了一个名为 docker-registry 的 Docker
    注册表，并带有注册表的描述：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To push images to your repository, you need to configure Docker on your client
    to use your GCP credentials. Authentication to repositories in GCP is configured
    on a per-region basis. In the previous step, we created a registry in the us-east4
    zone, so to configure authentication, we would execute the gcloud command here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像推送到您的存储库，您需要在您的客户端上配置 Docker 以使用您的 GCP 凭据。GCP 中存储库的认证是按区域配置的。在上一个步骤中，我们在
    us-east4 区域创建了一个注册表，因此要配置认证，我们将在此处执行 gcloud 命令：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that your registry and Docker have been configured, you can start to use
    your registry to store images. In the next section, we will explain how to tag
    images and push them to your new repository.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的注册表和 Docker 已配置完毕，您可以使用注册表来存储图像。在下一节中，我们将解释如何标记图像并将它们推送到您的新存储库。
- en: 13.5.2 Adding images to your repository
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.2 将图像添加到您的存储库
- en: 'To add an image to a GCP registry, you follow the same steps that you would
    use for any other Docker registry, but the tag may be different from what you
    are used to:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像添加到 GCP 注册表，您将遵循与任何其他 Docker 注册表相同的步骤，但标记可能与您习惯的不同：
- en: If you do not have the image locally, you must either build a new image using
    Docker or pull the image from another registry.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有本地图像，您必须使用 Docker 构建新的图像或从另一个注册表拉取图像。
- en: Tag the image with your GCP registry.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的 GCP 注册表标记图像。
- en: Push the new image to the registry.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新图像推送到注册表。
- en: 'For example, to add a CentOS 8 image to a registry, follow these steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将 CentOS 8 图像添加到注册表，请按照以下步骤操作：
- en: 'Download the CentOS 8 image from Docker Hub:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Docker Hub 下载 CentOS 8 图像：
- en: '[PRE15]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, tag the newly pulled image with the Google registry information. When
    you tag an image that will be stored in a GCP registry, you must follow a specific
    naming convention. The image tag will use the convention LOCATIONdocker .pkg.dev/<project_ID>/<repository>/<image_name>.
    In the next example, the region is us-east4, the project is test-236415, and the
    registry is named docker-registry:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 Google 注册表信息标记新拉取的图像。当您标记一个将存储在 GCP 注册表中的图像时，您必须遵循特定的命名约定。图像标记将使用以下约定：LOCATIONdocker
    .pkg.dev/<project_ID>/<repository>/<image_name>。在下一个示例中，区域是 us-east4，项目是 test-236415，注册表名称为
    docker-registry：
- en: '[PRE16]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, push the new image to the registry:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将新图像推送到注册表：
- en: '[PRE17]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the next section, we will explain how to look at your images and any vulnerabilities
    that have been found in them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何查看您的图像以及其中发现的任何漏洞。
- en: 13.5.3 Reviewing image vulnerabilities
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.3 审查图像漏洞
- en: Because our project has the required APIs enabled, each image will be scanned
    when it is pushed to the registry. To review the vulnerabilities, open the GCP
    console and click Artifact Registry > Repositories, as shown in figure 13.4.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目已启用所需的 API，每次图像推送到注册表时都会进行扫描。要审查漏洞，请打开 GCP 控制台并点击“Artifact Registry”>“Repositories”，如图
    13.4 所示。
- en: '![13-04](../../OEBPS/Images/13-04.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![13-04](../../OEBPS/Images/13-04.png)'
- en: Figure 13.4 Navigating to your registries
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 导航到您的注册表
- en: This will bring up all the registries in your project. Continuing with our example,
    we created a registry called docker-registry, as shown in figure 13.5.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示您项目中的所有注册表。继续我们的示例，我们创建了一个名为docker-registry的注册表，如图13.5所示。
- en: '![13-05](../../OEBPS/Images/13-05.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![13-05](../../OEBPS/Images/13-05.png)'
- en: Figure 13.5 Project registries
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 项目注册表
- en: Open the repository that you pushed the image to and click the image to view
    it. Previously, we pushed the CentOS image to our registry, as shown in figure
    13.6.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您推送图像到的存储库，并点击图像以查看它。之前，我们已经将CentOS图像推送到我们的注册表，如图13.6所示。
- en: '![13-06](../../OEBPS/Images/13-06.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![13-06](../../OEBPS/Images/13-06.png)'
- en: Figure 13.6 Images list
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 图像列表
- en: Clicking the image displays the digests for the image and the number of vulnerabilities
    that the image contains. Our example is shown in figure 13.7.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 点击图像将显示图像的摘要和图像包含的漏洞数量。我们的示例如图13.7所示。
- en: '![13-07](../../OEBPS/Images/13-07.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![13-07](../../OEBPS/Images/13-07.png)'
- en: Figure 13.7 Image hash list
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 图像哈希列表
- en: To view each of the vulnerabilities, click the number in the Vulnerabilities
    column. A new window opens, listing all CVEs for the image. Depending on the image
    and the scan results, you may see different links or options for the CVEs. Using
    our CentOS image example, shown in figure 13.8, we can see that the results have
    a link to view fixes for each CVE.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个漏洞，请点击漏洞列中的数字。将打开一个新窗口，列出图像的所有CVE。根据图像和扫描结果，您可能看到不同的CVE链接或选项。以图13.8所示的CentOS图像示例，我们可以看到结果中有一个链接，可以查看每个CVE的修复方案。
- en: '![13-08](../../OEBPS/Images/13-08.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![13-08](../../OEBPS/Images/13-08.png)'
- en: Figure 13.8 CVE example list with fixes
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 带修复的CVE示例列表
- en: In another example, an Ubuntu image, no fixes are listed in the CVEs, so the
    results screen will contain different options, as shown in figure 13.9.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个示例中，Ubuntu图像的CVE中没有列出任何修复，因此结果屏幕将包含不同的选项，如图13.9所示。
- en: '![13-09](../../OEBPS/Images/13-09.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![13-09](../../OEBPS/Images/13-09.png)'
- en: Figure 13.9 CVE example without fixes
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 无修复的CVE示例
- en: You can view additional details for each CVE by clicking the CVE in the name
    column, or you can click View on the right-hand side. Clicking the CVE name will
    take you to the vendor’s site, whereas clicking View will provide additional details
    about the vulnerability.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击名称列中的CVE来查看每个CVE的详细信息，或者您也可以点击右侧的“查看”。点击CVE名称将带您到供应商的网站，而点击“查看”将提供有关漏洞的更多详细信息。
- en: In this section, we introduced Google’s container registry scanning, how to
    enable it, and how to view the scanning results. This was only an introduction
    to the service, but you can expand the functionality by integrating with Pub/Sub,
    adding access controls, and more. To see additional documentation, you can visit
    Google’s how-to guides at [http://mng.bz/gJ6E](http://mng.bz/gJ6E).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Google的容器注册表扫描，如何启用它以及如何查看扫描结果。这只是一个服务的介绍，但您可以通过与Pub/Sub集成、添加访问控制等功能来扩展其功能。要查看更多文档，您可以访问Google的如何操作指南，网址为[http://mng.bz/gJ6E](http://mng.bz/gJ6E)。
- en: 13.6 Understanding container security
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 理解容器安全
- en: 'You should consider two main concepts when you are creating a security policy:
    the user the container will run as and whether the container can run in privileged
    mode. Both ultimately decide what access, if any, a potential container breakout
    will have on the host.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建安全策略时，您应该考虑两个主要概念：容器将运行的用户以及容器是否可以以特权模式运行。这两个概念最终决定了潜在的容器突破对主机将有什么样的访问权限。
- en: When a container is started, it will run as the user that was set at the time
    of image creation, which is often the root user. However, even if you run a container
    as root, it doesn’t mean that the processes inside the container will have root
    access on the worker node because the Docker daemon itself will restrict host-level
    access, depending on the policy regarding privileged containers. To help explain
    this, table 13.3 shows each setting and the resulting permissions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，它将以在图像创建时设置的用户的身份运行，这通常是root用户。然而，即使您以root用户运行容器，这并不意味着容器内的进程将在工作节点上具有root访问权限，因为Docker守护进程本身将根据有关特权容器的策略限制主机级别的访问。为了帮助解释这一点，表13.3显示了每个设置及其产生的权限。
- en: Table 13.3 Root and privileged container permissions
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.3 根和特权容器权限
- en: '| Running container user | Privileged value | Host permissions |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 运行容器用户 | 特权值 | 主机权限 |'
- en: '| Running as root | False | None |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 以root用户运行 | False | None |'
- en: '| Running as root | True | Root access |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 以root用户运行 | True | Root access |'
- en: '| Running as nonroot | False | None |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 以非root用户运行 | False | None |'
- en: '| Running as nonroot | True | Limited; only permissions that have been granted
    to the same user on the host system |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 以非root身份运行 | True | 受限；只有授予主机系统上同一用户的权限 |'
- en: Both values determine what permissions a running container will be granted on
    the host. Simply running an image as root does not allow that container to run
    as root on the host itself. To explain the effect in greater detail, we will show
    what happens when you run a container as root and how allowing users to deploy
    privileged containers can enable someone to take over the host.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 两个值决定了运行容器在主机上将被授予的权限。仅仅以root身份运行镜像并不允许该容器在主机上以root身份运行。为了更详细地解释这种影响，我们将展示当你以root身份运行容器时会发生什么，以及允许用户部署特权容器如何使某人能够接管主机。
- en: 13.6.1 Running containers as root
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6.1 以root身份运行容器
- en: Over the years, container security has received a somewhat bad reputation. Many
    of the examples that have been used as evidence to support this are, in fact,
    not container problems but configuration problems on the cluster. Not too long
    ago, many developers created new images running as root, rather than creating
    a new user and running as the new user, which limited any security consequences.
    This is a good time to mention that if you commonly download images from third-party
    registries, you should always run them in a sandboxed environment before using
    them in production. You don’t know how the image was created, who it runs as,
    or whether it contains any malicious code. *Always inspect images before running
    them in production.* In the last section of this chapter, we will cover Google
    Container Scanning, which will scan your images for known security concerns.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，容器安全已经获得了一些不良声誉。许多被用作支持这一点的证据的例子实际上并不是容器问题，而是集群上的配置问题。不久前，许多开发者创建了以root身份运行的新镜像，而不是创建一个新用户并以新用户身份运行，这限制了任何安全后果。这是一个提到如果你经常从第三方注册库下载镜像，你应该在使用它们在生产环境中之前始终在沙盒环境中运行它们的好时机。你不知道镜像是如何创建的，它以什么身份运行，或者它是否包含任何恶意代码。*在将镜像用于生产之前，始终检查镜像。*在本章的最后部分，我们将介绍Google容器扫描，它将扫描你的镜像以查找已知的安全问题。
- en: You can use multiple tools to limit deployments of malicious containers, including
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多个工具来限制恶意容器的部署，包括
- en: '*Container scanning*—Included in the Google Container Registry with scanning'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器扫描*——包含在具有扫描功能的Google容器注册库中'
- en: '*Allowing only trusted container repositories*—Either internal or trusted partner
    registries'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仅允许受信任的容器仓库*——无论是内部仓库还是受信任的合作伙伴注册库'
- en: '*Requiring images to be signed*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*要求镜像签名*'
- en: 'One of the most dangerous, and commonly overlooked, security concerns is allowing
    a container to run as root. To explain why this is a bad practice, let’s use a
    virtual machine example: would you allow an application to run as root or as administrator?
    Of course you wouldn’t. If you had a web server running its processes as an administrator,
    any application breakout would be granted the permissions of the user that was
    running the process. In this case, that would be an account with root or administrator
    privileges, which would provide full access to the entire system.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险且常被忽视的安全问题之一是允许容器以root身份运行。为了解释为什么这是一个坏习惯，让我们用一个虚拟机示例来说明：你会允许应用程序以root或管理员身份运行吗？当然不会。如果你有一个以管理员身份运行其进程的Web服务器，任何应用程序突破都将授予运行该进程的用户权限。在这种情况下，那将是一个具有root或管理员权限的账户，这将提供对整个系统的完全访问权限。
- en: To mitigate any problems from a breakout, all applications should be run with
    their least-required set of permissions. Unfortunately, it is far too common for
    developers to run their container as root. If we ran a container as root, any
    container breakout would grant the intruder access to any resources on the host.
    Many images on Docker Hub and GitHub are distributed using root as the default
    user, including the common busybox image.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻任何突破带来的问题，所有应用程序都应该使用它们所需的最小权限集运行。不幸的是，开发者以root身份运行容器的情况非常普遍。如果我们以root身份运行容器，任何容器突破都将使入侵者获得对主机上任何资源的访问权限。Docker
    Hub和GitHub上许多镜像都是使用root作为默认用户分发的，包括常见的busybox镜像。
- en: To avoid running an image as root, you need to create and set a user account
    in your image or supply a user account when you start the container. Because busybox
    is normally pulled from Docker Hub, we can run it with a nonroot account by configuring
    a security context in the deployment.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免以root身份运行镜像，你需要在你的镜像中创建并设置一个用户账户，或者在你启动容器时提供一个用户账户。因为busybox通常是从Docker Hub拉取的，我们可以通过在部署中配置安全上下文来以非root账户运行它。
- en: 'As part of a Pod definition, the container can be forced to run as a user by
    adding the securityContext field, which allows you to set the context for the
    user, group, and fsGroup:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Pod定义的一部分，可以通过添加securityContext字段强制容器以用户身份运行，这允许您为用户、组和fsGroup设置上下文：
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Deploying the image with the additional securityContext will execute the container
    as user 1500. We also set the group to 1000 and the fsGroup to 1200. We can confirm
    all these values using the whoami and groups command, as shown in figure 13.10.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有additional securityContext的镜像部署将使容器以用户1500的身份执行。我们还设置了组为1000，fsGroup为1200。我们可以使用whoami和groups命令确认所有这些值，如图13.10所示。
- en: '![13-10](../../OEBPS/Images/13-10.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![13-10](../../OEBPS/Images/13-10.png)'
- en: Figure 13.10 A Pod running as the root user and using securityContext to change
    the defined user and user groups
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 以root用户运行并使用securityContext更改定义的用户和用户组的Pod
- en: The UID and group IDs that were used are unknown in the image because it was
    pulled from Docker Hub and it contains only the users and groups that were included
    when the image was created. In an image that you or someone in your organization
    created, you would have added the required groups during the Docker build and
    would not receive the unknown ID warnings.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像中使用的UID和组ID是未知的，因为它是从Docker Hub拉取的，并且它只包含在创建镜像时包含的用户和组。在您或您组织中的某人创建的镜像中，您会在Docker构建期间添加所需的组，并且不会收到未知ID警告。
- en: In this section, we explained how you can set a security context to run an image
    as a nonroot user or group at deployment time. This covers only the first half
    of securing our hosts from malicious containers. The next section will explain
    how privileged containers can affect our security and how they work together to
    provide access to the host.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了如何在部署时设置安全上下文以以非root用户或组运行镜像。这仅涵盖了保护我们的主机免受恶意容器侵害的第一部分。下一节将解释特权容器如何影响我们的安全以及它们如何协同工作以提供对主机的访问。
- en: 13.6.2 Running privileged containers
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6.2 运行特权容器
- en: By default, containers execute without any host privileges. Even when you start
    a container as root, any attempts to edit any host settings will be denied, as
    shown in figure 13.11.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器在没有主机权限的情况下执行。即使您以root用户启动容器，任何尝试编辑任何主机设置的尝试都将被拒绝，如图13.11所示。
- en: '![13-11](../../OEBPS/Images/13-11.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![13-11](../../OEBPS/Images/13-11.png)'
- en: Figure 13.11 A nonprivileged container running as root
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 以root身份运行的非特权容器
- en: For example, we can try to set a kernel value from a container that is running
    as root, but not as a privileged container, as illustrated in figure 13.12.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以尝试从作为root用户运行但不是特权容器的容器中设置内核值，如图13.12所示。
- en: '![13-12](../../OEBPS/Images/13-12.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![13-12](../../OEBPS/Images/13-12.png)'
- en: Figure 13.12 An attempted kernel change from a container without privileges
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 从没有权限的容器尝试的内核更改
- en: 'The kernel change is denied because the running image does not have elevated
    privileges on the host system. If there was a reason to allow this operation from
    a container, the image could be started as a privileged container. To run a privileged
    container, you need to allow it in the securityContext of the Pod:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 内核更改被拒绝，因为运行中的镜像在主机系统上没有提升的权限。如果有一个原因需要从容器允许此操作，则可以以特权容器启动镜像。要运行特权容器，您需要在Pod的securityContext中允许它：
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that the Pod has been allowed to run as a privileged container, and it is
    running as root, it will be allowed to change kernel parameters, as shown in figure
    13.13.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pod已被允许以特权容器运行，并且正在以root身份运行，它将被允许更改内核参数，如图13.13所示。
- en: '![13-13](../../OEBPS/Images/13-13.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![13-13](../../OEBPS/Images/13-13.png)'
- en: Figure 13.13 The privileged container running as root
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 以root身份运行的特权容器
- en: In figure 13.14, notice that the domain name change does not return an error,
    which verifies that the container can modify host-level settings.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在图13.14中，请注意域名更改没有返回错误，这验证了容器可以修改主机级别的设置。
- en: '![13-14](../../OEBPS/Images/13-14.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![13-14](../../OEBPS/Images/13-14.png)'
- en: Figure 13.14 The host kernel change allowed from a running container
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 从运行中的容器允许的主机内核更改
- en: 'This time, the kernel change worked for two reasons: the container is running
    as the *root* user, and the container was allowed to start up as a *privileged
    container*.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，内核更改成功有两个原因：容器正在以*root*用户身份运行，并且容器被允许以*特权容器*启动。
- en: 'For the last scenario, the manifest has been edited to run as user 1000, who
    does not have root privileges, and to start as a privileged container:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个场景，manifest 已被编辑为以用户 1000 运行，该用户没有 root 权限，并且以特权容器启动：
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even though the container is running as a privileged container, the user is
    a standard user, so any kernel changes will be denied, as shown in figure 13.15.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器以特权容器的身份运行，但用户是标准用户，因此任何内核更改都将被拒绝，如图 13.15 所示。
- en: '![13-15](../../OEBPS/Images/13-15.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![13-15](../../OEBPS/Images/13-15.png)'
- en: Figure 13.15 The privileged container running as nonroot
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 以非 root 身份运行的特权容器
- en: In summary, securing the actions that a container can take on the host is controlled
    by the user running in the container and whether the container is allowed to run
    as a privileged container. To secure a cluster, you need to create a policy that
    defines controls for each of these values.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，控制容器在主机上可以执行的操作是由容器中运行的用户以及容器是否被允许以特权容器身份运行来控制的。为了保护集群，您需要创建一个策略，该策略定义了每个这些值的控制措施。
- en: Right now, you know why containers should not be allowed to run as root and
    why you should limit Pods that are allowed to run as a privileged container, but
    we haven’t explained how to stop either of these actions from occurring on a cluster.
    This is an area that Anthos excels in! By providing Anthos Config Manager, Google
    has included all the tools you need to secure your cluster with these and many
    other common security settings.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你知道为什么不应该允许容器以 root 身份运行，以及为什么你应该限制允许以特权容器身份运行的 Pods，但我们还没有解释如何在集群上阻止这些操作之一的发生。这是
    Anthos 专长的一个领域！通过提供 Anthos Config Manager，Google 包含了您需要使用这些以及其他许多常见安全设置来保护您的集群的所有工具。
- en: In the next section, we will explain how to use ACM to secure a cluster using
    the included policy manager, Gatekeeper.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何使用包含的策略管理器 Gatekeeper 通过 ACM 来保护集群。
- en: 13.7 Using ACM to secure your service mesh
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 使用 ACM 保护您的服务网格
- en: As you have seen throughout this book, Anthos goes beyond simply providing a
    basic Kubernetes cluster. It also provides additional components like Anthos Service
    Mesh (ASM) to provide a service mesh, Binary Authorization, serverless workloads,
    and ACM to handle infrastructure as code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书的整个过程中所看到的，Anthos 不仅仅提供基本的 Kubernetes 集群。它还提供了额外的组件，如 Anthos Service Mesh
    (ASM) 以提供服务网格，二进制授权，无服务器工作负载，以及 ACM 来处理基础设施即代码。
- en: In chapter 11, you learned about designing and configuring ACM to enforce deployments
    and objects on an Anthos cluster. In this section, we will use ACM to secure communication
    between services in a cluster by using a policy. We will then move on to an additional
    component included with ACM, the Policy Controller, which provides an admission
    controller based on the open source project Gatekeeper.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 11 章中，你学习了如何设计和配置 ACM 以在 Anthos 集群上实施部署和对象。在本节中，我们将使用策略通过 ACM 保护集群中服务之间的通信。然后我们将继续介绍
    ACM 包含的另一个组件，即策略控制器，它提供了一个基于开源项目 Gatekeeper 的准入控制器。
- en: Note When enabling mTLS using an ACM policy, remember that the policy will be
    applied to all clusters that are managed by the external repository, unless you
    use a ClusterSelector to limit the clusters that will be configured.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当使用 ACM 策略启用 mTLS 时，请记住，该策略将应用于所有由外部存储库管理的集群，除非您使用 ClusterSelector 来限制将配置的集群。
- en: 13.7.1 Using ACM to enforce mutual TLS
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.7.1 使用 ACM 实施双向 TLS
- en: In chapter 4, you learned that ASM includes the ability to encrypt traffic between
    services using mutual TLS (mTLS). Mutual TLS is the process of verifying service
    identities before allowing communication between the services, via Istio’s sidecar.
    Once the identities have been verified, the communication between the services
    will be encrypted. However, by default, Istio is configured to use permissive
    mTLS. Permissive mTLS allows a workload that does not have a sidecar running to
    communicate with a sidecar-enabled service using HTTP (plaintext).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，你学习了 ASM 包括使用双向 TLS (mTLS) 加密服务之间流量的能力。双向 TLS 是在通过 Istio 的 sidecar 允许服务之间通信之前验证服务身份的过程。一旦身份得到验证，服务之间的通信将被加密。然而，默认情况下，Istio
    被配置为使用宽容的 mTLS。宽容的 mTLS 允许没有 sidecar 运行的作业使用 HTTP（明文）与启用 sidecar 的服务进行通信。
- en: Developers or administrators who are new to service meshes generally use the
    permissive setting. Although this is beneficial for learning Istio, allowing HTTP
    traffic into a service running a sidecar makes it insecure, nullifying the advantages
    of Istio and the sidecar. Once you are comfortable with Istio, you may want to
    consider changing the permissive policy to the more secure strict setting.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务网格新手来说，开发者或管理员通常使用宽容设置。虽然这对学习Istio有益，但允许HTTP流量进入运行sidecar的服务会使它不安全，从而抵消了Istio和sidecar的优势。一旦您对Istio感到舒适，您可能希望考虑将宽容策略更改为更安全的严格设置。
- en: You can force strict mTLS for the entire mesh or just certain namespaces by
    creating a Kubernetes object called PeerAuthentication. Deciding on the correct
    scope for mTLS is different for each organization and cluster. You should always
    test any mTLS policy changes in a development environment before implementing
    them in production, to avoid any unexpected application failures.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建一个名为PeerAuthentication的Kubernetes对象来强制整个网格或仅某些命名空间使用严格的mTLS。对于每个组织和集群来说，决定mTLS的正确作用域都是不同的。您应该在将任何mTLS策略更改部署到生产环境之前，始终在开发环境中进行测试，以避免任何意外应用故障。
- en: Because this is an important policy, it’s a perfect example to demonstrate the
    importance of using ACM as a configuration management tool. Remember that once
    an object is managed by ACM, the configuration manager will control it. This means
    that the manager will recreate any managed object that is edited or deleted for
    any reason. For the mTLS use case, you should see the importance of using ACM
    to make sure that the policy is set and, if edited, remediated to the configured
    strict value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个重要的策略，它是一个完美的例子，用以展示使用ACM作为配置管理工具的重要性。请记住，一旦对象被ACM管理，配置管理器将控制它。这意味着管理器将重新创建任何因任何原因编辑或删除的管理对象。对于mTLS用例，您应该看到使用ACM确保策略设置以及如果编辑，则修复到配置的严格值的重要性。
- en: 'To enable a strict mTLS meshwide policy, you need to create a new PeerAuthentication
    object that sets the mTLS mode to strict. An example manifest is shown next:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用全局严格的mTLS策略，您需要创建一个新的PeerAuthentication对象，并将mTLS模式设置为严格。下面是一个示例清单：
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The manifest assumes that Istio has been installed in the istio-system namespace.
    Because the namespace selector is the istio-system namespace, it will enforce
    a strict mTLS policy for all namespaces in the cluster.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 清单假设Istio已安装在istio-system命名空间中。因为命名空间选择器是istio-system命名空间，它将为集群中的所有命名空间强制执行严格的mTLS策略。
- en: Note To enforce a strict mTLS policy for every namespace in the cluster, the
    PeerAuthentication object must be created in the same namespace that Istio was
    installed in. By default, this is the istio-system namespace.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了强制执行集群中每个命名空间的严格mTLS策略，PeerAuthentication对象必须创建在Istio安装的相同命名空间中。默认情况下，这是istio-system命名空间。
- en: 'If you have decided to implement per-namespace enforcement, the manifest requires
    a single modification, the namespace value. For example, if we wanted to enable
    mTLS on a namespace called webfront, we would use the following manifest:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定实施按命名空间强制执行，清单需要单一修改，即命名空间值。例如，如果我们想在一个名为webfront的命名空间上启用mTLS，我们会使用以下清单：
- en: '[PRE22]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To use either of these manifests with ACM to enforce a strict mTLS mesh policy,
    you simply need to store it in your ACM repository. Because the policy is stored
    in the ACM repository, it will be managed by the controller, and any changes or
    deletion will result in the object being recreated using the strict setting. The
    mTLS policy is just an example of how we can use ACM and ASM together to enforce
    a security policy for a cluster.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些清单中的任何一个与ACM强制执行严格的mTLS网格策略，您只需将其存储在您的ACM存储库中。因为策略存储在ACM存储库中，它将由控制器管理，任何更改或删除都将导致使用严格设置重新创建对象。mTLS策略只是我们如何使用ACM和ASM一起强制执行集群安全策略的一个示例。
- en: 13.8 Conclusion
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.8 结论
- en: ACM’s policy engine is a powerful add-on included with all Anthos clusters.
    Gatekeeper allows an organization to create granular policies to secure a cluster
    against potential attackers by providing additional security and stability. Google
    provides a collection of default policies that address some of the most common
    security concerns that have been collected from the community and Google’s own
    experiences. If the included policy library doesn’t address a security problem
    in your organization, you can create your own policies by using Gatekeeper’s policy
    language, Rego.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ACM的策略引擎是所有Anthos集群中包含的一个强大附加组件。Gatekeeper允许组织创建细粒度的策略，通过提供额外的安全性和稳定性来保护集群免受潜在攻击者的影响。Google提供了一系列默认策略，这些策略解决了从社区和Google自身经验中收集的一些最常见的安全问题。如果包含的策略库没有解决你组织中的安全问题，你可以使用Gatekeeper的策略语言Rego创建自己的策略。
- en: 13.9 Examples and case study
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.9 示例和案例研究
- en: Using the knowledge from the chapter, address each of the requirements in the
    following case study.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章的知识，解决以下案例研究中的每个要求。
- en: 13.9.1 Evermore Industries
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.9.1 永恒工业
- en: 'Evermore Industries has asked you to evaluate the security of their Anthos
    Kubernetes cluster. The cluster has been configured as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 永恒工业要求你评估其Anthos Kubernetes集群的安全性。集群已按以下方式配置：
- en: Multiple control plane nodes
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个控制平面节点
- en: Multiple worker nodes
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个工作节点
- en: ASM to provide Istio, configured with permissive mTLS
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASM提供Istio，配置为宽容的mTLS
- en: ACM configured with the policy engine enabled, including the default template
    library
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACM配置了启用了策略引擎，包括默认模板库
- en: 'They have asked you to document any current security concerns and remediation
    steps to meet the following requirements:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 他们要求你记录任何当前的安全问题以及补救措施，以满足以下要求：
- en: Audit for any security concerns, and provide proof of any exploit covered by
    policies.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计任何安全问题，并提供任何由策略覆盖的利用的证明。
- en: 'All containers must only be allowed to pull from an approved list of registries,
    including these:'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有容器只允许从批准的注册表列表中拉取，包括以下这些：
- en: gcr.io
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcr.io
- en: hub.evermore.local
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: hub.evermore.local
- en: All policies, other than the approved registry policy, must be tested to assess
    their consequences before being enforced.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了批准的注册表策略之外，所有策略都必须在实施前进行测试，以评估其后果。
- en: 'Containers must deny any privilege escalation attempts, without affecting any
    Anthos namespaces, including these:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器必须拒绝任何权限提升尝试，而不影响任何Anthos命名空间，包括以下这些：
- en: kube-system
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-system
- en: gke-system
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: gke-system
- en: config-management-system
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: config-management-system
- en: gatekeeper-system
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: gatekeeper-system
- en: gke-connect
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: gke-connect
- en: Containers must not be able to use hostPID, hostNetwork, or hostIPC in any namespace
    other than the kube-system namespace.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器不得能够在除了kube-system命名空间之外的任何命名空间中使用hostPID、hostNetwork或hostIPC。
- en: All requirements must be addressed using only existing Anthos tools.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须仅使用现有的Anthos工具来满足所有要求。
- en: The next section contains the solution to address Evermore’s requirements. You
    can follow along with the solution or, if you are comfortable, configure your
    cluster to address the requirements and use the solution to verify your results.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分包含了解决永恒工业要求的解决方案。你可以跟随解决方案进行操作，或者如果你感到舒适，配置你的集群以满足要求并使用解决方案来验证你的结果。
- en: 'Evermore Industries solution: Testing the current security'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 永恒工业解决方案：测试当前安全性
- en: Meets requirement 1
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 满足要求1
- en: 'The first requirement necessitates you document any security concerns with
    the current cluster. To test the first three security requirements, you can deploy
    a manifest that attempts to elevate the privileges of a container. The test manifest
    should pull an image from a registry that is not on the approved list and set
    the fields to elevate privileges and the various host values. We have provided
    an example manifest here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求需要你记录当前集群中存在的任何安全问题。为了测试前三个安全要求，你可以部署一个尝试提升容器权限的清单。测试清单应从不在批准列表中的注册表中拉取镜像，并将字段设置为提升权限和不同的主机值。我们在此提供了一个示例清单：
- en: '[PRE23]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This manifest will test all the security requirements in a single deployment.
    The image tag that is being pulled is from docker.io, which is not on the approved
    registry list. It also maps the host’s root filesystem into the container at mount
    /host, and it is starting as a privileged container.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单将在单个部署中测试所有安全要求。正在拉取的镜像标签来自docker.io，它不在批准的注册表列表中。它还将主机的根文件系统映射到容器的/mount/host位置，并以特权容器的形式启动。
- en: Because the container started successfully, we can document that the cluster
    can pull images from registries that are not in the accepted list. A successful
    start also shows that the Pod started as a privileged container and that the mount
    to hostPath also succeeded. To document that the container does have access to
    the host filesystem, we can access the image and list the /host directory. Figure
    13.16 shows that we can successfully list the host’s root filesystem.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器启动成功，我们可以记录集群可以从不在接受列表中的注册表中拉取镜像。成功的启动还表明Pod以特权容器启动，并且对hostPath的挂载也成功了。为了记录容器确实可以访问主机文件系统，我们可以访问镜像并列出/host目录。图13.16显示我们可以成功列出主机的根文件系统。
- en: '![13-16](../../OEBPS/Images/13-16.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![13-16](../../OEBPS/Images/13-16.png)'
- en: Figure 13.16 Accessing the host filesystem in a container
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 在容器中访问主机文件系统
- en: After capturing the output and adding it to the documentation, you can delete
    the Pod because we will need to test the same deployment with the policies enabled
    in the next test. You can delete it by executing kubectl delete -f use-case1.yaml.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获输出并将其添加到文档后，您可以删除Pod，因为我们将在下一个测试中启用策略来测试相同的部署。您可以通过执行kubectl delete -f use-case1.yaml来删除它。
- en: 'Evermore Industries solution: Adding repo constraints'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Evermore Industries解决方案：添加仓库约束
- en: Meets requirement 2
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 满足要求2
- en: Evermore’s second requirement is that containers can be pulled only from trusted
    registries. In the requirements, only images pulled from gcr.io and hub.evermore.local
    are allowed to be deployed in the cluster.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Evermore的第二项要求是容器只能从受信任的注册表中拉取。在需求中，只有从gcr.io和hub.evermore.local拉取的镜像被允许在集群中部署。
- en: 'To limit images to only the two registries, we need to create a new ConstraintTemplate
    that uses the k8sallowedrepos.constraints.gatekeeper.sh object. An example ConstraintTemplate
    is provided next:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制镜像只从两个注册表拉取，我们需要创建一个新的ConstraintTemplate，该模板使用k8sallowedrepos.constraints.gatekeeper.sh对象。下面提供了一个ConstraintTemplate的示例：
- en: '[PRE24]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once this manifest is deployed, any attempts to pull an image from a registry
    other than gcr.io and hub.evermore.local will result in the admission controller
    denying the Pod creation with the following error that an invalid image repo was
    used:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署了此清单，任何尝试从除gcr.io和hub.evermore.local之外的注册表拉取镜像的尝试都将导致准入控制器拒绝Pod创建，并出现以下错误，即使用了无效的镜像仓库：
- en: '[PRE25]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have addressed requirement 2, we can move on to address requirements
    3 and 4.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了要求2，我们可以继续解决要求3和4。
- en: 'Evermore Industries Solution: Adding privileged constraints'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Evermore Industries解决方案：添加特权约束
- en: Meets requirements 3 and 4
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 满足要求3和4
- en: We need to address the security requirements for Evermore’s cluster. To secure
    the cluster from running privileged Pods in the cluster, but not affect Pods in
    any Anthos system namespaces, we need to enable a constraint with exemptions.
    However, before enabling a constraint, Evermore has required that all constraints
    be tested and the output of affected Pods be supplied as part of the documentation.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决Evermore集群的安全需求。为了保护集群免受运行特权Pod的影响，但不影响任何Anthos系统命名空间中的Pod，我们需要启用一个带有豁免的约束。然而，在启用约束之前，Evermore要求所有约束都必须经过测试，并且受影响Pod的输出作为文档的一部分提供。
- en: 'The first step is to create a manifest to create the constraint. The manifest
    shown next creates a constraint called privileged-containers in auditing mode
    only. It also excludes all of the system namespaces that Evermore has supplied
    in the requirements document:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个清单来创建约束。下面显示的清单仅创建一个名为privileged-containers的约束，处于审计模式。它还排除了Evermore在需求文档中提供的所有系统命名空间：
- en: '[PRE26]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To add the audit output to the documentation, you must describe the constraint
    and direct the output to a file by executing the following kubectl command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要将审计输出添加到文档中，您必须描述约束并将输出重定向到文件，通过执行以下kubectl命令：
- en: '[PRE27]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will create a file called privtest in the current folder, containing the
    audit results for the psp-privileged-container constraint. You should check the
    file to verify that it contains the expected audit results under the violations
    section. An abbreviated output from our audit follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前文件夹中创建一个名为privtest的文件，包含psp-privileged-container约束的审计结果。您应该检查该文件，以验证它是否包含在违规部分下的预期审计结果。以下是我们审计的简略输出：
- en: '[PRE28]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You may have noticed that the audit output contains Pods running in namespaces
    that were added as an exclusion. Remember that when you exclude a namespace in
    a constraint, the namespace will still be audited—the exclusion only stops the
    policy from being enforced.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，审计输出包含被添加为排除项的命名空间中运行的 Pods。请记住，当你在一个约束中排除一个命名空间时，该命名空间仍然会被审计——排除项只会阻止策略被强制执行。
- en: Because the output looks correct, we can enforce the policy to meet the security
    requirements to deny privileged containers. To remove the existing constraint,
    delete it using the manifest file executing kubectl delete -f <manifest file>.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出看起来正确，我们可以强制执行策略以满足安全要求，拒绝特权容器。要删除现有的约束，请使用清单文件执行 kubectl delete -f <清单文件>。
- en: 'Next, update the manifest file and remove the enforcementAction: dryrun line
    from the manifest and redeploy the constraint.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，更新清单文件，从清单中删除 enforcementAction: dryrun 行，并重新部署约束。'
- en: 'Evermore Industries solution: Adding host constraints'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Evermore Industries 解决方案：添加主机约束
- en: Meets requirement 5
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 满足要求 5
- en: The fifth requirement from Evermore is to deny hostPID, hostNetwork, and hostIPC
    in all namespaces, except kube-system. We also need to test the policy before
    implementation, as stated in the requirements.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Evermore 的第五个要求是在所有命名空间中拒绝 hostPID、hostNetwork 和 hostIPC，除了 kube-system。我们还需要在实施之前测试策略，如要求所述。
- en: To meet the set requirements, we need to implement two new policies. The first,
    k8spsphostnamespace, will block access to host namespaces including hostPID and
    hostIPC. Finally, to address blocking hostNetwork, we need to implement the k8spsphostnetworkingports
    policy.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足既定要求，我们需要实施两个新的策略。第一个是 k8spsphostnamespace，它将阻止对包括 hostPID 和 hostIPC 在内的主机命名空间的访问。最后，为了解决阻止
    hostNetwork 的问题，我们需要实施 k8spsphostnetworkingports 策略。
- en: 'To block access to host namespaces from all namespaces except kube-system,
    you need to create a new constraint that exempts kube-system. We also need to
    test the constraint before it’s implemented, so we need to set the enforcementAction
    to dryrun. An example manifest follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要阻止从所有命名空间（除了 kube-system）访问主机命名空间，您需要创建一个新的约束，该约束豁免 kube-system。我们还需要在实施之前测试约束，因此需要将
    enforcementAction 设置为 dryrun。以下是一个示例清单：
- en: '[PRE29]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After this manifest has been deployed, any attempts by a Pod to use a host
    namespace like hostPID will be denied startup by the admission controller. Setting
    the dryrun option will only audit the policy, without enforcing it. Once it’s
    tested, you can remove enforcementAction: dryrun from the manifest and deploy
    it to enforce the policy.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '在此清单部署之后，任何尝试使用主机命名空间（如 hostPID）的 Pod 都会被准入控制器拒绝启动。设置 dryrun 选项将仅审计策略，而不强制执行。一旦测试通过，您可以从清单中删除
    enforcementAction: dryrun 并部署它以强制执行策略。'
- en: 'To block hostNetworking, we will need to create another constraint that will
    use the k8spsphostnetworkingports policy:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要阻止主机网络，我们需要创建另一个约束，该约束将使用 k8spsphostnetworkingports 策略：
- en: '[PRE30]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just like the previous constraint, we have included the dryrun option to test
    the constraint before being enforced. Once tested and deployed, any Pod that attempts
    to set hostNetwork to true will be denied by the admission controller with the
    following error stating that only hostNetwork=false is allowed:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的约束一样，我们包括了 dryrun 选项，在强制执行之前测试约束。一旦测试并通过部署，任何尝试将 hostNetwork 设置为 true 的
    Pod 都会被准入控制器拒绝，并显示以下错误，指出只允许 hostNetwork=false：
- en: '[PRE31]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Congratulations! By deploying the last two constraints, we have met all Evermore’s
    requirements.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！通过部署最后两个约束，我们已经满足了 Evermore 的所有要求。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Root and privileged containers can be used to take over an unprotected host.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根和特权容器可以被用来接管未受保护的主机。
- en: Anthos can secure a cluster by deploying built-in policies or custom policies
    that are deployed using Anthos Configuration Management.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthos 可以通过部署内置策略或使用 Anthos Configuration Management 部署的自定义策略来保护集群。
- en: Virtual machines provide better security than containers. Both patterns have
    unique security concerns and must be deployed correctly, keeping security in mind
    from the beginning of their deployments.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机比容器提供更好的安全性。两种模式都有独特的安全关注点，并且必须正确部署，从它们部署的开始就要考虑安全性。
- en: We covered an overview of Kubernetes security and features included with Anthos
    to help remediate security concerns in clusters, including ACM and ASM.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们概述了 Kubernetes 的安全性和 Anthos 包含的功能，以帮助解决集群中的安全担忧，包括 ACM 和 ASM。
- en: Security problems with containers running as root or as a privileged container
    can be used to compromise a host.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 root 或特权容器运行容器的安全问题可能被用来危害主机。
- en: You can use ACM features to secure a cluster by using Gatekeeper and the included
    constraint template libraries provided by Anthos.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 ACM 功能通过 Gatekeeper 以及由 Anthos 提供的包含约束模板库来保护集群。
- en: Google’s container vulnerability scanning engine can identify container vulnerabilities.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌的容器漏洞扫描引擎可以识别容器漏洞。
- en: '* * *'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)Kubernetes.io does provide an initial set of recommendations: [http://mng.bz/nJyK](http://mng.bz/nJyK).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: (1.) Kubernetes.io 提供了一组初始推荐：[http://mng.bz/nJyK](http://mng.bz/nJyK)。
