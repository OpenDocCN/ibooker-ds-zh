- en: 9 Using classes beyond the basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 超越基础使用类
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating enumerations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建枚举
- en: Eliminating boilerplate of a custom class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除自定义类的样板代码
- en: Processing JSON data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 JSON 数据
- en: Creating lazy attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建懒属性
- en: Refactoring a cumbersome class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构繁琐的类
- en: Python is an object-oriented language at its core. The hallmark of an object-oriented
    language is using objects to preserve data and provide functionalities, which
    generally requires you to implement well-defined custom classes. In chapter 8,
    you learned the essential techniques for defining a class. But many other techniques
    can help us define more robust custom classes so that we can build a more maintainable
    codebase with well-defined data models.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在其核心是一个面向对象的语言。面向对象语言的标志是使用对象来保存数据和提供功能，这通常需要你实现定义良好的自定义类。在第8章中，你学习了定义类的必要技术。但还有很多其他技术可以帮助我们定义更健壮的自定义类，从而使我们能够构建一个具有良好定义的数据模型的更易于维护的代码库。
- en: Custom classes typically require implementation of several special methods,
    for example, including __init__ and __repr__. As you code more, you may find it
    tedious to write these methods, as they can be boilerplate. Did you know that
    you can use the dataclass decorator to remove boilerplate?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类通常需要实现几个特殊方法，例如包括 __init__ 和 __repr__。随着你编写更多的代码，你可能会发现编写这些方法很繁琐，因为它们可能是样板代码。你知道你可以使用
    dataclass 装饰器来移除样板代码吗？
- en: In this chapter, you’ll learn advanced techniques. Some of these techniques,
    such as creating enumerations, have a specific use case (when you need enumerations,
    for example, such as the task status in our task management application). Other
    techniques are more fundamental, such as refactoring a cumbersome class and creating
    lazy attributes, which you’ll find useful no matter what application you’re making.
    Please pay special attention to these project-agnostic techniques.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习高级技术。其中一些技术，如创建枚举，有特定的用例（例如，当你需要枚举时，比如在我们的任务管理应用程序中的任务状态）。其他技术更为基础，如重构繁琐的类和创建懒属性，无论你制作什么应用程序，你都会发现这些技术很有用。请特别注意这些与项目无关的技术。
- en: 9.1 How do I create enumerations?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 我该如何创建枚举？
- en: 'In our applications, some data is naturally connected within the same concept
    umbrella. Consider the four directions—north, east, south, and west—all of which
    belong to the direction category. When we represent this data in our application,
    the simplest way is to use strings: "north", "east", "south", and "west". When
    we write a function that expects a direction, however, it may be unclear to the
    users what data they should provide, even if we supply type hints to the function,
    as in this example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，一些数据自然地属于同一概念伞下的同一概念。考虑四个方向——北、东、南和西，它们都属于方向类别。当我们在我们应用程序中表示这些数据时，最简单的方法是使用字符串：“north”、“east”、“south”和“west”。然而，当我们编写一个期望方向的函数时，即使我们提供了类型提示，用户也可能不清楚他们应该提供什么数据，如下例所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because strings lack inherent semantics, when users call this function, they
    have no clue about what they should provide and may use a semantically meaningful
    string that is incompatible with the function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串缺乏固有的语义，当用户调用此函数时，他们没有任何线索关于他们应该提供什么，可能会使用一个与函数不兼容的语义上有意义的字符串：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you might expect, if we can provide more specific type information about
    the direction parameter, it’ll be clear to users what they should enter. Also,
    when you define a type that has discrete members, such as weekdays and seasons,
    you have a perfect use case for enumerations. This section explores that feature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，如果我们能提供更多关于方向参数的具体类型信息，用户就会清楚地知道他们应该输入什么。此外，当你定义一个具有离散成员的类型时，例如星期和季节，枚举就有一个完美的用例。本节将探讨这个特性。
- en: 9.1.1 Avoiding a regular class for enumerations
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 避免为枚举使用常规类
- en: 'Some people’s first thought about implementing enumerations may involve a regular
    custom class. As discussed in this section, however, you may encounter a few drawbacks
    if you use a regular class for enumerations. To begin, let’s see what a possible
    implementation looks like using a custom class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人关于实现枚举的第一想法可能是使用一个常规的自定义类。然而，正如本节所讨论的，如果你使用常规类来实现枚举，可能会遇到一些缺点。首先，让我们看看使用自定义类的一个可能的实现样子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the style perspective, two things are noteworthy:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从风格的角度来看，有两点是值得注意的：
- en: Because these four directions are constants, it’s common to use all capital
    letters.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为这四个方向是常量，所以通常使用全部大写字母。
- en: In most programming languages, enumerations use whole integers as the values
    of the enumerated members.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，枚举使用整数值作为枚举成员的值。
- en: 'Besides these two style notes, this implementation is a bit hacking by defining
    class attributes in the Direction class. You can use these “enumerations” (they’re
    not true enumerations, as you’ll see in section 9.1.3) by accessing these class
    attributes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两点风格说明之外，此实现通过在 Direction 类中定义类属性进行了一些“黑客式”操作。你可以通过访问这些类属性来使用这些“枚举”（正如你将在
    9.1.3 节中看到的，它们并不是真正的枚举）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may notice a couple of drawbacks. First, the type for these members isn’t
    Direction, which prevents you from using the members when you use Direction in
    a function (figure 9.1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到一些缺点。首先，这些成员的类型不是 Direction，这阻止了你在函数中使用 Direction 时使用这些成员（如图 9.1 所示）。
- en: '![CH09_F01_Cui](../Images/CH09_F01_Cui.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Cui](../Images/CH09_F01_Cui.png)'
- en: Figure 9.1 Incompatible type when class attributes in a class are used as enumerations.
    You can use a custom class as the type hint for the argument, but you can’t use
    a member in the function call.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 当类属性用作枚举时类型不兼容。你可以使用自定义类作为参数的类型提示，但不能在函数调用中使用成员。
- en: The value of the member Direction.North is 0, which is an integer instead of
    an instance of the Direction class. When you use enumerations, you should expect
    each member to be an instance of the enumeration class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 成员 Direction.North 的值为 0，这是一个整数，而不是 Direction 类的实例。当你使用枚举时，你应该期待每个成员都是枚举类的实例。
- en: The other drawback is that you can’t iterate the class to go over each member,
    as the “members” are class attributes; they don’t form a united entity and can’t
    represent the enumeration concept. By contrast, a true enumeration class should
    support iteration of each member. These drawbacks undermine a regular class for
    the purpose of enumerations, which is a non-Pythonic implementation. As revealed
    in the next section, we’ll use the enum module to address these drawbacks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，你不能迭代类来遍历每个成员，因为“成员”是类属性；它们不是一个统一的实体，也不能代表枚举概念。相比之下，真正的枚举类应该支持迭代每个成员。这些缺点削弱了常规类作为枚举的目的，这是一个非
    Pythonic 的实现。正如下一节所揭示的，我们将使用 enum 模块来解决这些缺点。
- en: 9.1.2 Creating an enumeration class
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 创建枚举类
- en: You learned about subclasses in section 8.5\. Creating an enumeration class
    is the process of creating a subclass of the built-in Enum class in the enum module.
    In this section, you’ll learn to implement an enumeration class for directions.
    The next listing shows the code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 8.5 节中学习了关于子类的内容。创建枚举类是创建 enum 模块中内置 Enum 类的子类的过程。在本节中，你将学习如何实现一个表示方向的枚举类。下面的列表显示了代码。
- en: Listing 9.1 Implementing an enumeration class
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 实现枚举类
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compared with a custom class implementation, a true enumeration class is a
    subclass of the Enum class. By subclassing Enum, the enumeration class converts
    the seemingly class attributes to discrete members. Within the body, we specify
    the members and their associated values. Notably, we can also create the enumeration
    class as a one-liner:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义类实现相比，真正的枚举类是 Enum 类的子类。通过继承 Enum，枚举类将看似类属性转换为离散成员。在类体内部，我们指定成员及其关联的值。值得注意的是，我们还可以将枚举类创建为一行代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although you can declare the members in the enumeration class by using semicolons
    to separate them on a single line, I recommend using the former style—defining
    each member on its own line—because it has better readability.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以通过在单行上使用分号分隔成员来在枚举类中声明成员，但我建议使用前者风格——为每个成员定义一行——因为它有更好的可读性。
- en: Readability Each member in an enumeration class should occupy one line so that
    it’s easier to see what the members are and to count the number of members.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 枚举类中的每个成员应占一行，这样更容易看到成员是什么，以及计算成员的数量。
- en: 'In many use cases, you don’t care about the raw values of the members. In our
    examples, we’ve been using small integers incrementally, but you can use any integers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多用例中，你不需要关心成员的原始值。在我们的示例中，我们一直在使用增量的小整数，但你也可以使用任何整数：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition, Python doesn’t restrict what data you use for the members’ raw
    values. You can also use strings instead of integers, as in this example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 并不限制成员原始值所使用的数据类型。你还可以使用字符串代替整数，如下例所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 9.1.3 Using enumerations
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 使用枚举
- en: After we define the enumeration class, it’s time to explore how we use enumerations
    from the class. This section covers that topic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义枚举类之后，是时候探索如何从类中使用枚举了。本节涵盖了这一主题。
- en: Checking an enumeration member's type
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 检查枚举成员的类型
- en: 'The first usage of enumerations pertains to checking the type of an enumerated
    member. From section 9.1.1, we know that when we use a regular class, the enumerations
    using class attributes don’t have the type of the class. Everything works differently
    in a true enumeration class, as shown in this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的第一个用途是检查枚举成员的类型。从9.1.1节中，我们知道当我们使用常规类时，使用类属性的枚举没有类的类型。在真正的枚举类中，一切工作方式都不同，如下例所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, the “attributes” of the enumeration class are of the type of
    the class: the north variable has the type of the Direction class. That is, each
    member represents a predefined instance of the class.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，枚举类的“属性”类型与类类型相同：北变量具有Direction类的类型。也就是说，每个成员代表类的一个预定义实例。
- en: Using an enumeration member's attributes
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用枚举成员的属性
- en: 'As the members are essentially the enumeration class’s instances, it’s no surprise
    that each member has instance attributes. Among those attributes, the most important
    are name and value, which are the enumerated member’s name and its associated
    value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成员本质上都是枚举类的实例，所以每个成员都有实例属性并不令人惊讶。在这些属性中，最重要的是名称和值，它们是枚举成员的名称及其关联的值：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The value of a member is useful in a variety of use cases. Suppose that we
    receive an application programming interface (API) response in which an integer
    number indicates the direction in which the user should go. The following code
    snippet shows this scenario:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 成员的值在多种用例中很有用。假设我们收到一个应用程序编程接口（API）响应，其中整数表示用户应前往的方向。以下代码片段展示了这一场景：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we construct the enumerated member by supplying an applicable
    value to the constructor. Because EAST has a value of 2 in the Direction class,
    calling the constructor with 2 creates the EAST direction. If you’re trying to
    create a member with a value that isn’t among the defined values, you encounter
    an exception:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过向构造函数提供适用值来构造枚举成员。因为EAST在Direction类中的值为2，所以使用2调用构造函数创建EAST方向。如果您尝试创建一个具有未定义值的成员，您会遇到异常：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Iterating all enumeration members
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代所有枚举成员
- en: The major reason that we define enumerations is to group related concepts in
    the form of members in the enumeration class. When users want to find out what
    these members are, they can iterate the enumeration class—a feature that isn’t
    available for a regular class. This section shows how to iterate the members of
    an enumeration class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义枚举的主要原因是为了将相关概念以枚举类成员的形式分组。当用户想要找出这些成员是什么时，他们可以迭代枚举类——这是常规类所不具备的功能。本节展示了如何迭代枚举类的成员。
- en: 'The enumeration class Direction, as a subclass of Enum, is by design an iterable
    that consists of its members. Thus, we can use the iteration techniques on the
    Direction class, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类Direction，作为Enum的子类，按设计是一个由其成员组成的可迭代对象。因此，我们可以对Direction类使用迭代技术，如下所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code shows how to create a list object containing all the directions.
    As discussed in section 5.1, we create the list by using the list constructor
    with the iterable: the Direction class. Because Direction is an iterable, you
    can also use it in a for loop:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了如何创建一个包含所有方向的列表对象。如5.1节所述，我们通过使用列表构造函数和可迭代对象：Direction类来创建列表。因为Direction是可迭代的，所以您也可以在for循环中使用它：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 9.1.4 Defining methods for the enumeration class
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 为枚举类定义方法
- en: 'At its core, an enumeration class is still a Python custom class, so we can
    define applicable methods to add more versatile functionalities to the class.
    We have learned how to create an enumeration and know that the enumeration class
    is an iterable. We’re ready to update the move_to function, as shown in this code
    snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，枚举类仍然是一个Python自定义类，因此我们可以定义适用方法来为类添加更多灵活的功能。我们已经学习了如何创建枚举，并且知道枚举类是一个可迭代的对象。我们现在准备好更新move_to函数，如下代码片段所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One significant thing to note is that we use direction in Direction to determine
    whether the supplied direction argument is appropriate. When we call this function,
    we get the desired type hints. The output doesn’t look perfect, however:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，我们在 Direction 中使用 direction 来确定提供的方向参数是否合适。当我们调用此函数时，我们得到期望的类型提示。然而，输出看起来并不完美：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output isn’t human-friendly, as the shown direction is "Direction.NORTH"
    instead of north, as you would expect. To solve this problem, we can define a
    custom instance method to show proper human-readable output for the members, as
    shown in the next listing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出并不友好，因为显示的方向是 "Direction.NORTH" 而不是你预期的 north。为了解决这个问题，我们可以定义一个自定义实例方法来为成员显示适当的人类可读输出，如下一列表所示。
- en: Listing 9.2 Adding a custom method
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 添加自定义方法
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In listing 9.2, two important things are noteworthy:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.2 中，有两件重要的事情值得关注：
- en: We overrode the __str__ method in the Direction class. As covered in section
    8.4, __str__ determines an instance’s string representation.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 Direction 类中重写了 __str__ 方法。如第 8.4 节所述，__str__ 决定了实例的字符串表示。
- en: In the f-string for the message, the curly braces enclose direction, which calls
    the __str__ method behind the scenes. From the printout, you see that we get the
    human-readable output for the direction argument.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息的 f-string 中，大括号包围着 direction，它在幕后调用 __str__ 方法。从打印输出中，你可以看到我们得到了方向参数的人类可读输出。
- en: The code snippet in listing 9.2 shows that you can override special methods
    in the enumeration class. You can also define other methods as you need them.
    You could define the move_to function as an instance method in the Direction class,
    for example; I’ll leave that task as a challenge for you in section 9.1.6.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 中的代码片段显示，你可以覆盖枚举类中的特殊方法。你还可以根据需要定义其他方法。例如，你可以在 Direction 类中将 move_to
    函数定义为实例方法；我将把这个任务留给你在第 9.1.6 节中挑战。
- en: 9.1.5 Discussion
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.5 讨论
- en: Enumeration is the most common technique to use when you have related concepts
    that fall into the same category. To use enumerations, create an enumeration class
    by subclassing the Enum class in the enum module. When you need to add customized
    behaviors to the enumeration class, you can define methods as you normally do
    with a regular class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是在你有一些相关概念属于同一类别时最常用的技术。要使用枚举，通过在 enum 模块中从 Enum 类派生创建一个枚举类。当你需要向枚举类添加自定义行为时，你可以像处理常规类一样定义方法。
- en: 9.1.6 Challenge
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.6 挑战
- en: Zoe is building a location-based application in which she defines a Direction
    class, as shown in the preceding sections. In listing 9.2, the move_to function
    is defined outside the Direction class, but she thinks that it makes more sense
    for this function to be an instance method. Can you help her make the conversion?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Zoe 正在构建一个基于位置的应用程序，其中她定义了一个 Direction 类，如前几节所示。在列表 9.2 中，move_to 函数是在 Direction
    类外部定义的，但她认为将此函数作为实例方法更合理。你能帮她完成转换吗？
- en: Hint Place the move_to function within the body of the Direction class. For
    an instance method, don’t forget that the first argument is self and that it refers
    to the instance object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：将 move_to 函数放置在 Direction 类体内部。对于实例方法，别忘了第一个参数是 self，它指的是实例对象。
- en: 9.2 How do I use data classes to eliminate boilerplate code?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 我如何使用数据类来消除样板代码？
- en: 'Data is the core element of any programming project. All programs have a place
    for data. In section 3.3, you learned about creating a lightweight data model
    by using named tuples. Named tuples, however, are best used as data holders because
    of their immutability. If you want data mutability and greater flexibility in
    data manipulation, you need to create a custom class, as discussed in chapter
    8\. In a custom class, best practices include the implementation of special methods
    such as __init__ and __repr__:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是任何编程项目的核心元素。所有程序都有一个数据的位置。在第 3.3 节中，你学习了如何通过使用命名元组创建轻量级的数据模型。然而，由于它们的不可变性，命名元组最好用作数据持有者。如果你想实现数据的可变性和在数据操作中的更大灵活性，你需要创建一个自定义类，如第
    8 章所讨论的。在自定义类中，最佳实践包括实现特殊方法，如 __init__ 和 __repr__：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the __init__ method, we assign all the arguments to each of the instance’s
    attributes, whereas in the __repr__ method, we create an f-string that mimics
    a string literal for instantiation. The code for these methods is boilerplate,
    which means that everything follows a predefined template. If you define many
    other classes, you’ll do pretty much the same thing for these methods. Why can’t
    we eliminate this boilerplate? In this section, we’re going to discover how to
    use data classes to create a class without all the boilerplate.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__ 方法中，我们将所有参数分配给实例的每个属性，而在 __repr__ 方法中，我们创建一个 f-string，它模仿字符串字面量以进行实例化。这些方法的代码是样板代码，这意味着一切都遵循预定义的模板。如果你定义了许多其他类，你将几乎为这些方法做同样的事情。为什么我们不能消除这种样板代码？在本节中，我们将发现如何使用数据类创建一个没有所有样板代码的类。
- en: Concept In programming, *boilerplate* means code that is used without any significant
    modification in places where highly similar (or identical) code is required. Boilerplate
    is a pattern of repetition, although at a higher level.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 在编程中，*样板代码* 指的是在需要高度相似（或相同）代码的地方未做任何重大修改的代码。样板代码是一种重复的模式，尽管它处于更高的层次。
- en: 9.2.1 Creating a data class using the dataclass decorator
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 使用 dataclass 装饰器创建数据类
- en: Section 7.3 introduced decorators, which provide additional functionalities
    to the decorated function without modifying the original function’s performance.
    Decorators can do more than decorate just functions, however; when they’re defined
    properly, they can also decorate classes. One such special decorator is dataclass,
    which addresses the boilerplate by decorating the class, as discussed in this
    section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7.3 节介绍了装饰器，它们在不修改原始函数性能的情况下为装饰的函数提供额外的功能。然而，装饰器不仅可以装饰函数，当它们被正确定义时，也可以装饰类。其中一种特殊的装饰器是
    dataclass，它通过装饰类来处理样板代码，正如本节所讨论的。
- en: The dataclass decorator is available in the dataclasses module. Before I discuss
    how to use this decorator, examine the code in the next listing, which creates
    a data class that models bill management for a restaurant.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: dataclass 装饰器在 dataclasses 模块中可用。在讨论如何使用这个装饰器之前，请检查下一列表中的代码，该代码创建了一个用于模拟餐厅账单管理的数据类。
- en: Listing 9.3 Creating a data class
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 创建数据类
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Observe three things in listing 9.3:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.3 中观察以下三点：
- en: '*We import the* dataclass *decorator* *from the* dataclasses *module**, which
    is part of the standard Python library.* If you install Python from the official
    Python website, the dataclasses module should already be on your computer.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们导入* dataclass *装饰器* 从* dataclasses *模块，该模块是标准 Python 库的一部分。* 如果你从官方 Python
    网站安装 Python，dataclasses 模块应该已经存在于你的计算机上。'
- en: '*As with using a decorator with a function, you place the decorator above the
    class’s head in the form of* @dataclass.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与使用函数装饰器类似，你将装饰器放置在类的头部上方，形式为* @dataclass。'
- en: '*In the body of the class, you specify the attributes with their respective
    types.* Note that specifying the types is required for a data class.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在类的主体中，你指定具有相应类型的属性。* 注意，指定类型对于数据类是必需的。'
- en: 'At the beginning of this section, I mentioned that we can use data classes
    to get rid of some boilerplate, including __init__ and __repr__. In other words,
    the dataclass decorator has taken care of the boilerplate:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我提到我们可以使用数据类来消除一些样板代码，包括 __init__ 和 __repr__。换句话说，dataclass 装饰器已经处理了样板代码：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we create an instance object of the Bill class, although the
    __init__ method is never explicitly defined in the class. In a similar fashion,
    without implementing the __repr__ method, we get the string representation for
    the instance in the correct form, which mimics the string for instantiation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个 Bill 类的实例对象，尽管在类中从未显式定义 __init__ 方法。以类似的方式，在不实现 __repr__ 方法的情况下，我们得到了实例的正确字符串表示形式，它模仿了实例化时的字符串。
- en: 9.2.2 Setting default values for the fields
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 为字段设置默认值
- en: Setting default values for some attributes in the initialization method keeps
    the code clean and saves users’ time. Data classes support default values for
    the attributes. In this section, you’ll learn the rules for setting default values
    in data classes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化方法中为某些属性设置默认值可以使代码更简洁并节省用户的时间。数据类支持为属性设置默认值。在本节中，你将学习在数据类中设置默认值的规则。
- en: 'Before I jump into the technicalities, I need to clarify one key concept. In
    a custom class, below the head, we list the class attributes. In a data class,
    the dataclass decorator converts these attributes to instance attributes, which
    are known as *fields**.* I mentioned that type annotations are required for these
    fields. Why? Mechanistically speaking, the dataclass decorator takes advantage
    of the class’s *annotations* to locate the fields:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入技术细节之前，我需要澄清一个关键概念。在自定义类中，在头部下方，我们列出类属性。在数据类中，dataclass装饰器将这些属性转换为实例属性，这些属性被称为*字段**。我提到这些字段需要类型注解。为什么？从机制上讲，dataclass装饰器利用类的*注解*来定位字段：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we retrieve all the fields of the class by accessing the __annotations__
    special attribute. Conversely, if you don’t annotate some attributes, they can’t
    be part of the __annotations__ attribute, preventing the dataclass decorator from
    locating these fields. Thus, the dataclass decorator can’t help construct the
    data class properly. Figure 9.2 summarizes the underlying process of creating
    a data class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过访问__annotations__特殊属性来检索类的所有字段。相反，如果你没有注解某些属性，它们就不能成为__annotations__属性的一部分，这阻止了dataclass装饰器定位这些字段。因此，dataclass装饰器无法正确构建数据类。图9.2总结了创建数据类的底层过程。
- en: '![CH09_F02_Cui](../Images/CH09_F02_Cui.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Cui](../Images/CH09_F02_Cui.png)'
- en: Figure 9.2 The underlying workflow of creating a data class using the dataclass
    decorator. The dataclass decorator takes advantage of the type annotations for
    the fields to create the boilerplate, including __init__ and __repr__.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 使用dataclass装饰器创建数据类的底层工作流程。dataclass装饰器利用字段的类型注解来创建样板代码，包括__init__和__repr__。
- en: 'In figure 9.2, using the annotated fields, the dataclass decorator creates
    the applicable __init__ method. When you set default values for the fields, they
    become part of the __init__ method too. Setting default values for the fields
    involves using the syntax described in chapter 6: you specify the default value
    after the type annotation, as the following listing shows.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在图9.2中，使用注解字段，dataclass装饰器创建了相应的__init__方法。当你为字段设置默认值时，它们也成为__init__方法的一部分。为字段设置默认值涉及到使用第6章中描述的语法：你指定默认值在类型注解之后，如下列所示。
- en: Listing 9.4 Setting a default value for fields
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 为字段设置默认值
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Because you specify the default value for the tip_amount field, when you create
    an instance object of the Bill class, you can omit this field, which will be filled
    with the default value instead:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在tip_amount字段中指定了默认值，当你创建Bill类的实例对象时，你可以省略这个字段，它将被默认值填充：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When I discussed setting default arguments for a function in section 6.1, I
    emphasized that an argument with a default value can’t precede arguments without
    default values. The same rule applies to a data class. When you set a field with
    a default value that precedes other fields that have no default values, you encounter
    a TypeError. If you use an integrated development environment (IDE) such as PyCharm,
    a warning is displayed when you do (figure 9.3).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6.1节中，我讨论了为函数设置默认参数时，强调带有默认值的参数不能在无默认值的参数之前。同样的规则也适用于数据类。当你设置一个带有默认值且在无默认值字段之前的字段时，你会遇到TypeError。如果你使用PyCharm等集成开发环境（IDE），当你这样做时，会显示警告（图9.3）。
- en: '![CH09_F03_Cui](../Images/CH09_F03_Cui.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Cui](../Images/CH09_F03_Cui.png)'
- en: Figure 9.3 Warning about placing a field with a default value before fields
    that have no default values in a data class definition
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 在数据类定义中将带有默认值的字段放置在无默认值字段之前时的警告
- en: 9.2.3 Making data classes immutable
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 使数据类不可变
- en: Compared with immutable named tuples, the fields of data classes can be modified
    for each instance; thus, data classes are mutable. Depending on the specific use
    case, however, mutability may be not desired for the data. In this section, you’ll
    learn to make data classes immutable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与不可变的命名元组相比，数据类的字段可以针对每个实例进行修改；因此，数据类是可变的。然而，根据具体的使用情况，数据的可变性可能不是所希望的。在本节中，你将学习如何使数据类不可变。
- en: 'The dataclass decorator cannot only be used by itself without any arguments,
    in the form of @dataclass, but it can also take additional arguments to provide
    customized decoration behaviors. Some notable arguments include init and repr,
    which are set to True by default, meaning that we request that the dataclass decorator
    implement __init__ and __repr__. Among other arguments, one pertains to mutability:
    frozen. When you want your data class to be immutable, you should set frozen to
    True. The following code snippet shows the usage:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类装饰器不仅可以单独使用，不带任何参数，形式为@dataclass，还可以接受额外的参数以提供自定义的装饰行为。一些值得注意的参数包括init和repr，它们默认设置为True，这意味着我们要求数据类装饰器实现__init__和__repr__。在其他参数中，有一个与可变性相关：frozen。当你想让你的数据类不可变时，你应该将frozen设置为True。以下代码片段显示了用法：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see for the data class ImmutableBill, after the instance is created,
    we can’t update its fields anymore. Such immutability protects you from unintended
    data changes—a feature that you can obtain from named tuples, which are defined
    to be immutable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对于数据类ImmutableBill，实例创建后，我们不能再更新其字段。这种不可变性可以保护你免受意外数据更改——这是你可以从定义为不可变的命名元组中获得的特性。
- en: Maintainability If you don’t want your data classes to change their data, consider
    making their fields frozen to prevent unintended changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 如果你不希望你的数据类更改其数据，考虑将它们的字段冻结以防止意外更改。
- en: 9.2.4 Creating a subclass of an existing data class
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 创建现有数据类的子类
- en: At its core, a data class has the same extensibility as other regular custom
    classes. As covered in section 8.5, we can create a class hierarchy. In terms
    of data classes, we can also create a subclass. But several aspects of the dataclass
    decorator make subclassing a data class different from subclassing regular classes
    (defined without a dataclass decorator), as discussed in this section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，数据类与其他常规自定义类具有相同的可扩展性。如8.5节所述，我们可以创建一个类层次结构。在数据类的术语中，我们也可以创建一个子类。但数据类装饰器的几个方面使得数据类的子类化与常规类的子类化（未使用数据类装饰器定义）不同，如本节所述。
- en: Inheriting the superclass's fields
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 继承超类的字段
- en: 'We know that in a data class, its attributes become data fields. When you create
    a subclass of an existing data class, all the fields of the superclass automatically
    become part of the subclass’s fields:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在数据类中，其属性成为数据字段。当你创建现有数据类的子类时，超类的所有字段自动成为子类字段的一部分：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: QUESTION Can you try subclassing a frozen dataclass?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：你能尝试对冻结的数据类进行子类化吗？
- en: 'As shown in this example, we created the TippedBill class as a subclass of
    BaseBill. Both classes should use the dataclass decorator to make them data classes.
    The subclass TippedBill’s constructor includes both the fields of the superclass
    and its own fields:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们创建了TippedBill类作为BaseBill的子类。这两个类都应该使用数据类装饰器来使它们成为数据类。子类TippedBill的构造函数包括超类的字段和它自己的字段：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When you create an instance of the subclass, remember that the superclass’s
    fields come first, followed by the subclass’s fields. The order matters!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建子类的实例时，请记住，超类的字段先于子类的字段，顺序很重要！
- en: Avoiding default values for the superclass
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 避免为超类使用默认值
- en: 'We have seen that a subclass of a data class uses all the fields from its superclass
    and its own fields, following the order superclass -> subclass. In section 9.2.2,
    however, you learned that fields with default values must come behind those that
    don’t have default values. This requirement has an important implication: if a
    superclass has fields with default values, you must specify default values for
    each subclass’s fields. Otherwise, your code won’t work, as shown in this example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，数据类的子类使用其超类和自己的所有字段，遵循超类 -> 子类的顺序。然而，在9.2.2节中，你了解到具有默认值的字段必须放在没有默认值的字段之后。这一要求有一个重要的含义：如果超类有具有默认值的字段，你必须为每个子类的字段指定默认值。否则，你的代码将无法工作，如下例所示：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Thus, in most cases, you may want to avoid setting default values for the superclass
    so that you’ll have more flexibility to implement your subclasses. If you do set
    default values for the superclass, you must specify default values for the subclasses
    too:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在大多数情况下，你可能想避免为超类设置默认值，这样你将会有更多的灵活性来实现你的子类。如果你为超类设置了默认值，你也必须为子类指定默认值：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 9.2.5 Discussion
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.5 讨论
- en: Using the dataclass decorator, you can easily convert a regular class to a data
    class, which helps eliminate a lot of boilerplate that you would have to write
    otherwise. Compared with named tuples, which are a lightweight data model, we
    use data classes because they’re mutable data models and because they support
    extensibility by defining customized functionalities, like regular custom classes.
    If necessary, we can freeze the attributes to prevent unwanted data changes—an
    advantage that named tuples also have.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 dataclass 装饰器，你可以轻松地将普通类转换为数据类，这有助于消除你否则必须编写的许多样板代码。与轻量级的数据模型命名元组相比，我们使用数据类，因为它们是可变的数据模型，并且因为它们通过定义自定义功能支持可扩展性，就像常规自定义类一样。如果需要，我们可以冻结属性以防止不希望的数据更改——这是命名元组也具有的优势。
- en: 9.2.6 Challenge
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.6 挑战
- en: Bradley works on the analysis team of a website company. He uses data classes
    in his project. He knows that when he sets default values for a mutable argument
    in a function (section 6.1), the convention is to use None as the default value.
    But he’s not sure what value he should use for a mutable data class’s field, such
    as list. Can you figure out what default value he should set?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 布拉德利在一家网站公司的分析团队工作。他在项目中使用数据类。他知道当他为一个函数中的可变参数设置默认值时（第 6.1 节），惯例是使用 None 作为默认值。但他不确定对于如列表这样的可变数据类字段，他应该使用什么值。你能想出他应该设置什么默认值吗？
- en: Hint The dataclass module has a function called field, which is designed to
    set a default value for a mutable field.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：dataclass 模块有一个名为 field 的函数，该函数旨在为可变字段设置默认值。
- en: 9.3 How do I prepare and process JSON data?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 如何准备和处理 JSON 数据？
- en: 'When your application has interactions with outside entities, such as other
    websites, there should be a mechanism for data exchange. You may need to download
    data from another server, for example, usually in the form of APIs. JavaScript
    Object Notation (JSON) is one of the most popular formats for data interchanges
    between different systems. Suppose that our task management application gets the
    following JSON data from a server using one API, which resembles a dict object
    in Python:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序与外部实体（如其他网站）交互时，应该有一个数据交换机制。你可能需要从另一个服务器下载数据，例如，通常以 API 的形式。JavaScript
    对象表示法（JSON）是不同系统之间数据交换中最受欢迎的格式之一。假设我们的任务管理应用程序使用一个 API 从服务器获取以下 JSON 数据，它类似于 Python
    中的字典对象：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For another API, we may get the following data, which resembles a list object
    consisting of two dict objects in Python. Please note that I’ve formatted the
    strings by using proper indentation to make them easier to read:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个 API，我们可能得到以下数据，它类似于 Python 中的由两个字典对象组成的列表对象。请注意，我已经通过使用适当的缩进来格式化字符串，使其更容易阅读：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you receive this data as strings, to further manipulate the data, you want
    to convert it to the proper classes (discussed in chapter 8). More generally,
    JSON’s remarkable readability and its object-like structure make it a universal
    data format in any application you may work on. In this section, you’ll learn
    about the essential techniques for processing JSON data in Python.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以字符串形式接收这些数据时，为了进一步操作数据，你希望将其转换为适当的类（第 8 章讨论）。更普遍地说，JSON 的出色可读性和其类似对象的架构使其成为任何你可能会工作的应用程序中的通用数据格式。在本节中，你将了解在
    Python 中处理 JSON 数据的基本技术。
- en: 9.3.1 Understanding JSON’s data structure
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 理解 JSON 的数据结构
- en: Before you learn to process JSON data, you need to know the structure of JSON
    data and its relationship with Python’s data types. This section is devoted to
    introducing JSON data. If you know the topic well, please feel free to skip to
    the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学习处理 JSON 数据之前，你需要了解 JSON 数据的结构及其与 Python 数据类型的关系。本节致力于介绍 JSON 数据。如果你对这个主题很熟悉，请随时跳到下一节。
- en: 'JSON data is structured as JSON objects in the form of key-value pairs scoped
    by a pair of curly braces, such as {"title": "Laundry", "desc": "Wash clothes",
    "urgency": 3}. JSON objects require their keys to be only strings>, and this requirement
    allows the standard communication between different systems. The values shown
    include strings and integers, but JSON supports other data types, including Boolean,
    arrays (like list in Python), and objects, as summarized in table 9.1.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'JSON 数据以键值对的形式组织在成对的花括号中，例如 {"title": "Laundry", "desc": "Wash clothes", "urgency":
    3}。JSON 对象要求它们的键只能是字符串，这一要求允许不同系统之间的标准通信。显示的值包括字符串和整数，但 JSON 支持其他数据类型，包括布尔值、数组（类似于
    Python 中的列表）和对象，如表 9.1 所总结。'
- en: Table 9.1 JSON data types
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 JSON 数据类型
- en: '| Data type | Data content |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 数据内容 |'
- en: '| String | String literals enclosed in double quotes |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| String | 双引号包围的字符串字面量|'
- en: '| Number | Number literals, including integers and decimals |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| Number | 数字字面量，包括整数和小数|'
- en: '| Boolean | Boolean values, true or false (all lowercase) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| Boolean | 布尔值，true 或 false（全部小写）|'
- en: '| Array | A list of supported data types wrapped in square brackets |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| Array | 包围在方括号中的支持数据类型列表|'
- en: '| Object | Key-value pairs surrounded by curly braces |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Object | 花括号包围的键值对|'
- en: '| Null | A special value (null) representing an empty value for any valid data
    type |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Null | 表示任何有效数据类型空值的特殊值（null）|'
- en: We know that we can use single or double quotes for Python strings. But JSON
    strings must be enclosed only in double quotes. The improper use of single quotes
    creates invalid JSON data that can’t be processed by a common JSON parser.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以使用单引号或双引号来表示 Python 字符串。但是 JSON 字符串必须仅用双引号包围。单引号的不当使用会创建无效的 JSON 数据，这些数据无法被常见的
    JSON 解析器处理。
- en: NOTE You can use only double quotes to enclose strings in JSON.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在 JSON 中，只能使用双引号来包围字符串。
- en: 'It’s important to know that JSON supports nested data structures. A JSON object
    can hold another JSON object, for example. An array can be a list of any supported
    data types, including objects. Following are some examples:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道 JSON 支持嵌套数据结构。一个 JSON 对象可以包含另一个 JSON 对象，例如。数组可以是任何支持的数据类型的列表，包括对象。以下是一些示例：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The flexibility of mixing different data types in JSON allows us to construct
    complicated data with clear structural information, all in the form of key-value
    pairs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 中混合不同数据类型的灵活性使我们能够以键值对的形式构建具有清晰结构信息复杂的数据。
- en: 9.3.2 Mapping data types between JSON and Python
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 在 JSON 和 Python 之间映射数据类型
- en: When you use Python to make applications, and your applications have interactions
    with other systems via JSON, you must know how to convert data between JSON and
    Python. At a high level, the conversion is about how different JSON data types
    are mapped to the corresponding Python data types.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Python 开发应用程序，并且你的应用程序通过 JSON 与其他系统交互时，你必须知道如何在不同数据类型之间进行转换。从高层次来看，转换涉及不同的
    JSON 数据类型如何映射到相应的 Python 数据类型。
- en: Because both JSON and Python are used for general purposes, it’s no surprise
    that JSON data types have corresponding native Python data structures. Figure
    9.4 shows these conversions. Most of the conversions are straightforward. But
    Python doesn’t have a native data type that matches numbers in JSON objects, which
    don’t differentiate integers from floating-point numbers and refer to them as
    numbers collectively. By contrast, Python uses int and float to represent JSON
    numbers when they’re integers or real numbers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSON 和 Python 都用于通用目的，因此 JSON 数据类型有对应的原生 Python 数据结构也就不足为奇了。图 9.4 展示了这些转换。大多数转换都很直接。但是
    Python 没有与 JSON 对象中的数字相对应的原生数据类型，这些数字不区分整数和浮点数，统称为数字。相比之下，当 JSON 中的数字是整数或实数时，Python
    使用 int 和 float 来表示。
- en: '![CH09_F04_Cui](../Images/CH09_F04_Cui.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F04_Cui](../Images/CH09_F04_Cui.png)'
- en: Figure 9.4 Data conversion between JSON and Python with supporting examples.
    Please note that these types have different names in JSON and Python, such as
    String vs. str, due to the different terminologies used by these two languages.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 JSON 和 Python 之间的数据转换以及支持示例。请注意，由于这两种语言使用不同的术语，这些类型在 JSON 和 Python 中的名称不同，例如
    String 与 str。
- en: 9.3.3 Deserializing JSON strings
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 反序列化 JSON 字符串
- en: When we read JSON data into data structures of other programming languages,
    such as Python, we *decode* or *deserialize* JSON data. A more formal term for
    the reading-and-decoding process is *deserialization.* In this section, you’ll
    learn how to read JSON data into Python.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 JSON 数据读取到其他编程语言的数据结构中，如 Python，我们进行 *解码* 或 *反序列化* JSON 数据。阅读和解码过程的更正式术语是
    *反序列化*。在本节中，你将学习如何将 JSON 数据读取到 Python 中。
- en: 'I’ve mentioned that it’s common for web services to use JSON objects as API
    responses and that these responses take the form of text to facilitate intersystem
    data exchange. Consider a response expressed as a Python string object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到，网络服务通常使用 JSON 对象作为 API 响应，并且这些响应以文本形式表示，以促进系统间数据交换。考虑以下以 Python 字符串对象表示的响应：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Uses triple quotes for multiline strings
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用三引号表示多行字符串
- en: 'The standard Python library contains the json module, which is specialized
    for deserializing JSON data. To read this JSON string, we use the loads method.
    As shown in the following code snippet, we obtain a list object that consists
    of two nicely formatted dict objects, which represent the two JSON objects originally
    saved in the JSON array:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Python库包含json模块，该模块专门用于反序列化JSON数据。为了读取这个JSON字符串，我们使用loads方法。如下面的代码片段所示，我们获得一个由两个格式良好的字典对象组成的列表对象，这些对象代表最初保存在JSON数组中的两个JSON对象：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can’t take advantage of the functionalities defined in the Task class, as
    discussed in chapter 9, if the data is in the form of dictionaries. Thus, we need
    to convert these dict objects to instances of the Task class. This conversion
    highlights a perfect use case for class methods, as shown in the following listing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据以字典的形式存在，我们无法利用第9章中讨论的Task类中定义的功能。因此，我们需要将这些字典对象转换为Task类的实例。这种转换突出了类方法的完美用例，如下面的列表所示。
- en: Listing 9.5 Converting dict objects to instances of a custom class
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 将字典对象转换为自定义类的实例
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In listing 9.5, we successfully converted the list of dict objects to a list
    of Task instance objects, as we planned. Notably, we used several techniques that
    we’ve learned so far. As mentioned in chapter 1 (section 1.4), we’re trying to
    synthesize a variety of techniques along the way. Here are the key takeaways:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表9.5中，我们成功地将字典对象列表转换为Task实例对象列表，正如我们计划的那样。值得注意的是，我们使用了迄今为止学到的几种技术。正如第1章（第1.4节）中提到的，我们在过程中尝试综合各种技术。以下是关键要点：
- en: We use the dataclass decorator (section 9.2) on the Task class so that we don’t
    have to implement the boilerplate for __init__ and __repr__.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在Task类上使用dataclass装饰器（第9.2节），这样我们就不必实现__init__和__repr__的样板代码。
- en: The cls argument in the class method (section 8.2.3) task_from_dict refers to
    the class Task.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法（第8.2.3节）task_from_dict中的cls参数指的是Task类。
- en: We know that **kwargs refers to the variable number of keyword arguments (section
    6.4) and is packed as a dict object. Conversely, to access the key-value pairs,
    the ** operator converts the dict object to keyword arguments, which the constructor
    uses to create a new instance of the Task class.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道**kwargs**指的是可变数量的关键字参数（第6.4节），并且被打包为一个字典对象。相反，为了访问键值对，**运算符**将字典对象转换为关键字参数，构造函数使用这些参数来创建Task类的新实例。
- en: 'We’ve seen how to convert a JSON array to a list object in Python. The loads
    method is flexible. The method does more than convert JSON arrays; it can also
    parse any JSON data types other than objects. Following are a few examples:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将JSON数组转换为Python中的列表对象。loads方法非常灵活。该方法不仅可以将JSON数组转换为列表，还可以解析除对象以外的任何JSON数据类型。以下是一些示例：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Boolean value
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 布尔值
- en: ❷ JSON null to Python None
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ JSON null转换为Python None
- en: These strings represent JSON data, including floating-point number, string,
    Boolean, and Null, and they’re all converted by loads without any customization.
    All the conversion happens automatically, which highlights Python’s power as a
    general-purpose language.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串代表JSON数据，包括浮点数、字符串、布尔值和Null，并且它们都通过loads方法进行转换，无需任何定制。所有的转换都是自动完成的，这突出了Python作为通用语言的力量。
- en: 9.3.4 Serializing Python data to JSON format
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 将Python数据序列化为JSON格式
- en: When you process JSON data from external entities, you’re building an incoming
    communication route. In the meantime, you may need to build an outgoing route
    so that your application can send applicable information to the outside world.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理来自外部实体的JSON数据时，你正在构建一个传入通信路由。同时，你可能需要构建一个传出路由，以便你的应用程序可以向外部世界发送适用的信息。
- en: As illustrated in figure 9.5, the opposite of deserializing JSON data is creating
    JSON data from other data, a process called *serialization.* Thus, when we convert
    Python data to JSON data, we serialize Python objects to JSON data. This section
    addresses JSON serialization.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如图9.5所示，反序列化JSON数据的相反过程是从其他数据创建JSON数据，这个过程称为*序列化*。因此，当我们把Python数据转换为JSON数据时，我们序列化Python对象为JSON数据。本节讨论JSON序列化。
- en: '![CH09_F05_Cui](../Images/CH09_F05_Cui.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F05_Cui](../Images/CH09_F05_Cui.png)'
- en: Figure 9.5 Data conversion between JSON and Python. When you convert JSON to
    Python, the process is *deserialization*; when you convert Python to JSON, the
    process is *serialization*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 JSON与Python之间的数据转换。当你将JSON转换为Python时，这个过程是*反序列化*；当你将Python转换为JSON时，这个过程是*序列化*。
- en: 'Like the loads method, the json module has the dumps method to handle JSON
    data serialization. For the basic built-in data types, the conversions are straightforward:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与 loads 方法一样，json 模块有 dumps 方法来处理 JSON 数据序列化。对于基本内置数据类型，转换是直接的：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ To show the quotes for a string, use repr.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要显示字符串的引号，请使用 repr。
- en: 'In this example, notice that the dumps method creates a JSON array that holds
    different kinds of JSON data. The most significant observation is that although
    the original list object uses native Python data structures, the generated JSON
    string has the respective JSON data structures. Note the following conversions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意，dumps 方法创建了一个包含不同类型 JSON 数据的 JSON 数组。最重要的观察结果是，尽管原始列表对象使用的是原生 Python
    数据结构，但生成的 JSON 字符串具有相应的 JSON 数据结构。注意以下转换：
- en: The string enclosed in single quotes ('text') now uses double quotes ("text").
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单引号（'text'）包围的字符串现在使用双引号（"text"）。
- en: The Python bool object False becomes false.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 bool 对象 False 变为 false。
- en: The object None becomes null.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象 None 变为 null。
- en: Because only strings can be JSON keys, the number 1 is automatically converted
    to its string counterpart, "1".
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为只有字符串可以是 JSON 键，所以数字 1 自动转换为它的字符串对应物，"1"。
- en: 'What happens if you try to serialize an instance object of a custom class,
    like Task? Here’s the result:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试序列化自定义类（如 Task）的实例对象会发生什么？以下是结果：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, we can’t serialize a custom class instance. The major reason
    is that for a custom class, an instance object may contain many attributes and
    other metadata, so without a proper instruction, Python can’t know what data should
    be serialized. Thus, to make a custom class serializable, we must provide instructions
    for serialization. Here is one possible solution (please note that alternative
    solutions exist):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们无法序列化自定义类实例。主要原因是一个自定义类实例可能包含许多属性和其他元数据，如果没有适当的指令，Python 就不知道应该序列化哪些数据。因此，为了使自定义类可序列化，我们必须提供序列化指令。以下是一个可能的解决方案（请注意，存在其他解决方案）：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The most significant change we made to the dumps function call uses the default
    argument. This argument instructs what object (as a fallback) the encoder (the
    underlying object that makes the encoding or serialization) should use when it
    can’t serialize the object. In this case, because we know that the encoder can’t
    serialize the Task class instance object, we instruct the encoder to use its dict
    representation instead. The encoder knows how to convert the built-in dict class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 dumps 函数调用所做的最重要的更改是使用默认参数。此参数指示编码器（进行编码或序列化的底层对象）在无法序列化对象时应使用哪个对象（作为后备）。在这种情况下，因为我们知道编码器无法序列化
    Task 类实例对象，所以我们指示编码器使用其字典表示形式。编码器知道如何转换内置的 dict 类。
- en: 'We often use two other features during conversion. First, to create JSON objects
    in a more readable format, we can set the indent argument to have proper indentation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换过程中，我们经常使用两个其他功能。首先，为了以更可读的格式创建 JSON 对象，我们可以设置 indent 参数以获得适当的缩进：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Every level is nicely indented to indicate the relative structure of JSON objects
    and their key-value pairs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别都进行了适当的缩进，以指示 JSON 对象及其键值对的相对结构。
- en: Readability Use proper indentation to improve the readability of JSON data.
    Readability is especially relevant if you’re creating a JSON string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 使用适当的缩进来提高 JSON 数据的可读性。可读性在创建 JSON 字符串时尤其相关。
- en: 'The other useful feature is setting the sort_keys argument. Because we set
    it to True, the created JSON string has its keys sorted alphabetically, making
    it easier for us to look up information, particularly for multiple items. Observe
    this feature:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是设置 sort_keys 参数。因为我们将其设置为 True，所以创建的 JSON 字符串的键按字母顺序排序，这使得我们更容易查找信息，尤其是对于多个项目。观察以下功能：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 9.3.5 Discussion
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5 讨论
- en: JSON is probably the most popular data format used in data exchange between
    different systems. You should know how to deserialize and serialize JSON data
    by using native Python objects. One important thing to note is that instances
    of custom classes in Python are not JSON-serializable by default, so you should
    specify custom encoding behavior. Besides working on JSON strings, the json module
    has the dump and load methods to process JSON files directly. The calling signatures
    of these methods are almost identical to those of dumps and loads, respectively.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: JSON可能是不同系统之间数据交换中最流行的数据格式。你应该知道如何使用原生Python对象来反序列化和序列化JSON数据。需要注意的是，Python中自定义类的实例默认情况下不是JSON可序列化的，因此你应该指定自定义编码行为。除了处理JSON字符串外，json模块还提供了dump和load方法来直接处理JSON文件。这些方法的调用签名几乎与dumps和loads的调用签名相同。
- en: 9.3.6 Challenge
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.6 挑战
- en: 'Lucas is building a social media web app as his summer intern project. In his
    app, he uses named tuples in the data models. Suppose that the project has the
    following named-tuples class:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 卢卡斯正在构建一个社交媒体网络应用作为他的暑期实习项目。在他的应用中，他使用命名元组作为数据模型。假设项目有以下命名元组类：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What happens if he tries to serialize the user object?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他尝试序列化用户对象会发生什么？
- en: Hint A tuple object is JSON-serializable and becomes a JSON array after serialization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：元组对象是JSON可序列化的，在序列化后成为JSON数组。
- en: 9.4 How do I create lazy attributes to improve performance?
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 如何创建延迟属性以提高性能？
- en: '*Lazy* *evaluation* is a general programming implementation paradigm that defers
    evaluating operations until it’s requested to do so. Usually, lazy evaluation
    is the preferred evaluation pattern when the operation is expensive, requiring
    extensive processing time or memory. Generators (section 7.4), for example, are
    applications of lazy evaluation, which delays retrieving and yielding the next
    item. Lazy evaluation is also a relevant topic in custom classes. Specifically,
    you can define lazy attributes for instance objects to save time or memory. In
    this section, you’ll learn about defining lazy attributes.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*延迟* *评估* 是一种通用的编程实现范式，它将评估操作推迟到需要执行时。通常，当操作昂贵，需要大量处理时间或内存时，延迟评估是首选的评估模式。例如，生成器（第7.4节）是延迟评估的应用，它延迟检索和产生下一个项。延迟评估也是自定义类中的一个相关主题。具体来说，你可以为实例对象定义延迟属性以节省时间或内存。在本节中，你将了解如何定义延迟属性。'
- en: 9.4.1 Identifying the use scenario
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 确定使用场景
- en: Let’s start by identifying a proper use scenario. Suppose that our task management
    app is a social media app in which a user can follow other users. One functionality
    is to view a user’s followers. In the app, we can further view a user’s detailed
    profile by tapping the user’s thumbnail image. Consider the implementation in
    the next listing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先确定一个合适的使用场景。假设我们的任务管理应用是一个社交媒体应用，用户可以关注其他用户。一个功能是查看用户的关注者。在应用中，我们可以通过点击用户的缩略图进一步查看用户的详细配置文件。考虑以下列表中的实现。
- en: Listing 9.6 Creating the User class
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 创建User类
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We define the User class to manage user-related data, and the get_followers
    function fetches the followers for a user. When we call this function, we observe
    the following output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义User类来管理用户相关数据，get_followers函数用于获取用户的关注者。当我们调用这个函数时，我们观察到以下输出：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, when we get a user’s followers, we’re creating multiple instance
    objects for each user. This process requires an expensive operation to get the
    profile data, as the application must connect to the remote server to download
    the data and load it into memory. The profile data isn’t needed, however, because
    we need to display only followers’ usernames unless a user taps a follower; then
    the follower’s profile data becomes relevant. It’s an unnecessary operation to
    load data for all users up front, so we should consider using the lazy evaluation
    technique to avoid the heavy lifting. The following sections explore two ways
    to implement lazy attributes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们获取用户的关注者时，我们为每个用户创建多个实例对象。这个过程需要昂贵的操作来获取配置文件数据，因为应用程序必须连接到远程服务器下载数据并将其加载到内存中。然而，配置文件数据并不需要，因为我们只需要显示关注者的用户名，除非用户点击关注者；然后关注者的配置文件数据才变得相关。预先为所有用户加载数据是一个不必要的操作，因此我们应该考虑使用延迟评估技术来避免繁重的操作。接下来的几节将探讨实现延迟属性的两个方法。
- en: 9.4.2 Overriding the __getattr_ special method to implement lazy attributes
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 覆盖 __getattr_ 特殊方法以实现延迟属性
- en: In a custom class, we can override several special methods other than __str__
    and __repr__ to define customized behaviors (section 8.3). One such method, __getattr__,
    pertains to retrieving an instance’s attributes. In this section, we’ll see how
    to implement lazy attributes by overriding __getattr__.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义类中，我们可以覆盖除 `__str__` 和 `__repr__` 之外的特殊方法来定义自定义行为（第 8.3 节）。其中一种方法，`__getattr__`，与检索实例属性相关。在本节中，我们将看到如何通过覆盖
    `__getattr__` 来实现懒属性。
- en: For custom classes, instance objects have their attributes saved in a dict object,
    which is accessible through the special attribute __dict__. This dict object uses
    the attribute names as the keys and the attribute values as the corresponding
    values. When you access an instance object’s attribute by using dot notation,
    if the dict object contains the attribute, it returns the value. If the dict object
    doesn’t contain the attribute, the special method __getattr__ gets called as a
    fallback mechanism and tries to provide a value for the requested attribute. Figure
    9.6 depicts the order of resolving an instance’s attribute that pertains to accessing
    __dict__ and __getattr__.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义类，实例对象的属性保存在一个字典对象中，可以通过特殊属性 `__dict__` 访问。这个字典对象使用属性名作为键，属性值作为相应的值。当你使用点符号访问实例对象的属性时，如果字典对象包含该属性，它将返回该值。如果字典对象不包含该属性，特殊方法
    `__getattr__` 将作为后备机制被调用，并尝试为请求的属性提供一个值。图 9.6 描述了与访问 `__dict__` 和 `__getattr__`
    相关的解决实例属性顺序。
- en: Note The attribute resolution order is more complicated than what’s shown in
    figure 9.6\. An instance’s attribute can also use the class’s attribute as a fallback,
    for example. Figure 9.6 is a simplified version that applies to common scenarios.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：属性解析顺序比图 9.6 所示的更复杂。实例的属性也可以使用类的属性作为后备，例如。图 9.6 是一个简化版本，适用于常见场景。
- en: '![CH09_F06_Cui](../Images/CH09_F06_Cui.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F06_Cui](../Images/CH09_F06_Cui.png)'
- en: Figure 9.6 The order of resolving an instance object’s attribute. Python first
    checks whether the dict object of the instance object contains the attribute.
    If the dict object doesn't contain the attribute, Python checks whether it can
    return a value by calling the __getattr__ special method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 展示了解决实例对象属性顺序。Python 首先检查实例对象的字典对象是否包含该属性。如果字典对象不包含该属性，Python 会检查是否可以通过调用
    `__getattr__` 特殊方法返回一个值。
- en: Now that we understand how __dict__ and __getattr__ work together to provide
    the needed attributes for an instance object, we’re ready to see the specific
    implementation of overriding __getattr__ for a lazy attribute, as shown in the
    next listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `__dict__` 和 `__getattr__` 如何协同工作以提供实例对象的所需属性，我们准备查看覆盖 `__getattr__`
    以实现懒属性的具体实现，如下所示。
- en: Listing 9.7 Overriding __getattr__ in a class
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 在类中覆盖 `__getattr__`
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Compared with listing 9.6, there are two significant changes in listing 9.7:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表 9.6 相比，列表 9.7 有两个显著的变化：
- en: '*The* __init__ *method removes setting the* profile_data *attribute**.* This
    removal is necessary because if it’s set, even with None, the profile_data attribute
    and its value are stored in the object’s __dict__ attribute. The special method
    __getattr__ can’t be called, defeating the purpose of implementing a lazy attribute
    with __getattr__.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`__init__` 方法移除了设置 *profile_data* 属性**。这种移除是必要的，因为如果设置了，即使设置为 None，profile_data
    属性及其值也会存储在对象的 `__dict__` 属性中。特殊方法 `__getattr__` 无法被调用，这违背了使用 `__getattr__` 实现懒属性的目的。'
- en: '*In the* __getattr__ *method**, we specify that when the* profile_data *attribute*
    *is accessed, we’ll run the expensive operation to get the profile data for the
    user.* It’s important to note that we also set the fetched data by using setattr;
    when the profile_data attribute is accessed again, it will become available immediately.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 *`__getattr__`* 方法中，我们指定当访问 *profile_data* 属性时，我们将运行昂贵的操作以获取用户的配置数据。重要的是要注意，我们还使用
    `setattr` 设置了获取的数据；当再次访问 profile_data 属性时，它将立即可用。'
- en: 'With these changes, we expect the following actions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改后，我们期望以下行为：
- en: '*Action 1*—When a user is created, there is no profile data, preventing the
    expensive operation up front.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*行动 1*—当创建用户时，没有配置文件数据，防止了前期进行昂贵的操作。'
- en: '*Action 2*—When we do access the attribute, the expensive operation can be
    triggered to provide the requested attribute.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*行动 2*—当我们访问属性时，可以触发昂贵的操作以提供所需的属性。'
- en: '*Action 3*—When we access the attribute for the second time, there’s no need
    to run the expensive operation again.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*行动 3*——当我们第二次访问属性时，没有必要再次运行昂贵的操作。'
- en: 'Let’s see whether our expectation is met:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的预期是否得到满足：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Action 1
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 行动 1
- en: ❷ Action 2
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动 2
- en: ❸ Action 3
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 行动 3
- en: For Action 1, when we get one user’s followers, the created User instance objects
    contain only usernames, which saves memory! For Action 2, when we access profile_data
    for the first time, the expensive operation runs to fetch the data. For Action
    3, when we access profile_data for the second time, we get the data without triggering
    the expensive operation, which saves time!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于行动 1，当我们获取一个用户的关注者时，创建的 User 实例对象只包含用户名，这节省了内存！对于行动 2，当我们第一次访问 profile_data
    时，会运行昂贵的操作来获取数据。对于行动 3，当我们第二次访问 profile_data 时，我们获取数据而不触发昂贵的操作，这节省了时间！
- en: 9.4.3 Implementing a property as a lazy attribute
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 将属性作为延迟属性实现
- en: In section 8.3, you learned to use the property decorator to create read-only
    properties as a finer access-control approach. Because the property decorator
    allows us to “intercept” how an attribute is accessed, we can use it to implement
    the lazy attribute feature, as discussed in this section. Please note that a property
    isn’t strictly an attribute, but properties and attributes are similar in terms
    of supporting dot notation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.3 节中，你学习了如何使用属性装饰器创建只读属性，作为一种更精细的访问控制方法。因为属性装饰器允许我们“拦截”属性是如何被访问的，我们可以用它来实现本节中讨论的延迟属性功能。请注意，属性并不是严格意义上的属性，但在支持点符号方面，属性和属性是相似的。
- en: By now, you should be familiar with using the property decorator. You can jump
    directly into the next listing to see how to create a lazy attribute involving
    @property.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该熟悉使用属性装饰器。你可以直接跳到下一个列表，看看如何创建涉及 @property 的延迟属性。
- en: Listing 9.8 Creating a decorator for a lazy attribute
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 创建延迟属性装饰器
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Compared with listing 9.6, there are two significant changes in listing 9.8:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表 9.6 相比，列表 9.8 有两个显著的变化：
- en: '*In the* __init*__ method**, we set the* _profile_data *attribute* *as* None.
    The _profile_ data is the internally managed counterpart of the profile_data property;
    setting it to None saves memory compared with getting the data during instantiation.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **__init__** 方法中，我们将 _profile_data_ 属性设置为 None。_profile_ 数据是 profile_data
    属性的内部管理对应物；将其设置为 None 相比于在实例化期间获取数据可以节省内存。
- en: '*We implement* profile_data *as a property.* In this method, we check whether
    _profile_data is set, and we run the expensive operation only when _profile_ data
    isn’t set. If it’s set, we return the value.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 _profile_data_ 实现为一个属性。在这个方法中，我们检查 _profile_data_ 是否已设置，并且只有在 _profile_
    数据未设置时才运行昂贵的操作。如果已设置，我们返回该值。
- en: 'As discussed in section 9.4.2, we expect the same three actions from the User
    class implemented in listing 9.8:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如 9.4.2 节所述，我们期望从 9.8 列表中实现的 User 类中获取相同的三种行为：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Consistent with our expected actions, users don’t have their profile data loaded
    when they’re created. Instead, the expensive operation is run when a user’s profile
    data is requested, which is exactly what lazy evaluation is all about—delaying
    evaluation until we must do it, thereby saving time (not running the time-consuming
    operation) and memory (not using any memory to store a large amount of data).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们预期的行为一致，当用户被创建时，他们的配置文件数据不会被加载。相反，当请求用户的配置文件数据时，会执行昂贵的操作，这正是延迟评估的核心——直到必须执行时才进行评估，从而节省时间（不运行耗时操作）和内存（不使用任何内存来存储大量数据）。
- en: 9.4.4 Discussion
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.4 讨论
- en: You can override __getattr__ or implement a property to provide lazily evaluated
    attributes to a custom class. I recommend using the property approach; it’s more
    straightforward, and all the implementations are explicit. By contrast, overriding
    __getattr__ requires knowledge of how a Python instance object’s attribute resolution
    order works.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过覆盖 __getattr__ 或实现一个属性为自定义类提供延迟评估的属性。我建议使用属性方法；它更直接，并且所有实现都是明确的。相比之下，覆盖
    __getattr__ 需要了解 Python 实例对象的属性解析顺序是如何工作的。
- en: 9.4.5 Challenge
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.5 挑战
- en: Tim is updating a Python package that his company has published. An API in the
    package accesses an object’s attribute, such as user.initials. With recent updates,
    he needs to have finer control of this attribute. How can he create a property
    to maintain the API?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Tim 正在更新他公司发布的 Python 包。包中的一个 API 访问对象的属性，例如 user.initials。随着最近的更新，他需要对这个属性有更精细的控制。他如何创建一个属性来维护
    API？
- en: Hint Both properties and attributes support dot notation. You can convert a
    previously defined attribute to a property in the updated codebase.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：属性和属性都支持点符号。你可以在更新的代码库中将先前定义的属性转换为属性。
- en: 9.5 How do I define classes to have distinct concerns?
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 我该如何定义具有不同关注点的类？
- en: As you develop your project, you’ll find that you must deal with more data.
    Suppose that you start with one class to manage the data. To accommodate the increasing
    data volumes, your class can become cumbersome if you’re sticking to a single
    class. One underlying cause of the problem is the fact that the class may have
    mixed concerns; a single class models different kinds of data, which can make
    your project hard to maintain.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你项目的开发，你会发现你必须处理更多的数据。假设你从一个类开始来管理数据。为了适应不断增长的数据量，如果你的类坚持使用单一类，它可能会变得笨拙。这个问题的潜在原因之一是类可能具有混合的关注点；一个类模型了不同类型的数据，这可能会使你的项目难以维护。
- en: Imagine the two scenarios shown in figure 9.7\. In the first scenario, one large
    box (your class) holds two kinds of objects (the data). In the second scenario,
    you have two smaller boxes (two separate classes), each of which holds only one
    kind of object. You can tell which scenario is better for managing the objects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下图9.7中显示的两个场景。在第一个场景中，一个大框（你的类）包含两种类型的对象（数据）。在第二个场景中，你有两个较小的框（两个独立的类），每个框只包含一种类型的对象。你可以判断哪种场景更适合管理对象。
- en: '![CH09_F07_Cui](../Images/CH09_F07_Cui.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F07_Cui](../Images/CH09_F07_Cui.png)'
- en: Figure 9.7 Better organization when objects are handled by their own type in
    separate boxes as opposed to a large box that stores mixed objects
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 当对象由其自身类型在单独的框中处理，而不是存储混合对象的较大框时，组织得更好
- en: In this section, I show you how to define classes that have distinct concerns,
    which is a vital form of refactoring your project. This topic is important for
    improving the long-term maintainability of your project, as it’s easier to move
    multiple lighter boxes than to move a gigantic heavy box. You’ll find it manageable
    to maintain and update the data models when each class focuses on one purpose.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示如何定义具有不同关注点的类，这是重构项目的重要形式。这个主题对于提高项目的长期可维护性很重要，因为移动多个较轻的框比移动一个巨大的重框更容易。你会发现，当每个类专注于一个目的时，维护和更新数据模型是可管理的。
- en: 9.5.1 Analyzing a class
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 分析一个类
- en: 'In an ideal project, we have an experienced leader who can design the perfect
    data structures for our project: our project has multiple small classes, each
    of which addresses a specific data model. Suppose, however, that you’re assigned
    to update and maintain a legacy project in your company. You find that the essential
    data model is a single gigantic class, making this project almost impossible to
    update. In this section, you’ll see what the cumbersome class might look like
    and how to analyze it.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的项目中，我们有一个经验丰富的领导者，可以为我们的项目设计完美的数据结构：我们的项目有多个小的类，每个类都针对特定的数据模型。然而，假设你被分配到更新和维护你公司的一个遗留项目。你会发现基本的数据模型是一个巨大的单一类，这使得这个项目几乎无法更新。在本节中，你将看到这种笨拙的类可能的样子以及如何分析它。
- en: Suppose that this project involves a program that a school district uses to
    manage data. One key class is Student, which stores all student-related data.
    This class has the structure shown in the following listing. Please note that
    for simplicity, I’m showing only part of the Student class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个项目涉及一个学区使用的用于管理数据的程序。一个关键类是Student，它存储所有与学生相关的数据。这个类的结构如下所示。请注意，为了简单起见，我只展示了Student类的一部分。
- en: Listing 9.9 A class with mixed purposes
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 具有混合目的的类
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Before you do anything with the existing class, it’s a good idea to generate
    a diagram to inspect its components. Although you can create such a diagram in
    different ways, the key is to view the structure at a high level. For this purpose,
    use the Unified Modeling Language (UML) diagram (figure 9.8).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对现有类进行任何操作之前，生成一个图表来检查其组件是个好主意。虽然你可以用不同的方式创建这样的图表，但关键是高层次的视图。为此，使用统一建模语言（UML）图（图9.8）。
- en: '![CH09_F08_Cui](../Images/CH09_F08_Cui.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F08_Cui](../Images/CH09_F08_Cui.png)'
- en: Figure 9.8 The UML diagram (version 0) of the Student class. In the diagram,
    we list all the attributes and the methods for the class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 学生类的UML图（版本0）。在图中，我们列出了类的所有属性和方法。
- en: Concept UML is a standard way to visualize a system’s design, showing a system’s
    components and their connections.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 概念UML是可视化系统设计的一种标准方式，显示了系统的组件及其连接。
- en: In version 0 of the UML diagram, you’re not judgmental and are listing only
    the structural components of the Student class. To help view the data, you list
    the names of the methods without any implementation details. After you obtain
    the class’s structural information, the next step is inspecting its functional
    components (figure 9.9).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UML 图的版本 0 中，你不会做出判断，只是列出 Student 类的结构组件。为了帮助查看数据，你列出方法的名称而不包含任何实现细节。在获得类的结构信息后，下一步是检查其功能组件（图
    9.9）。
- en: '![CH09_F09_Cui](../Images/CH09_F09_Cui.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F09_Cui](../Images/CH09_F09_Cui.png)'
- en: Figure 9.9 The UML diagram (version 1) of the Student class. In this diagram,
    we group the methods based on their functionalities.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 Student 类的 UML 图（版本 1）。在这个图中，我们根据功能将方法分组。
- en: 'In the UML diagram (version 1), the methods that collectively fulfill the same
    functionality are grouped together. Here, we have two functional components: one
    that handles a student’s lunch account and one that handles the student’s demographics.
    In addition, each functional component has related attributes.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UML 图（版本 1）中，共同实现相同功能的方法被分组在一起。这里，我们有两个功能组件：一个处理学生的午餐账户，另一个处理学生的人口统计信息。此外，每个功能组件都有相关的属性。
- en: 9.5.2 Creating additional classes to isolate the concerns
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 创建额外的类以隔离关注点
- en: Figure 9.9 shows part of the Student class. In an actual project, this class
    might contain many other functionalities, and functionalities such as lunch account
    and demographics might include other methods. The function for managing lunch
    accounts, for example, might have many additional operations, such as suspending
    a lost card and consolidating multiple accounts. Implementing these operations
    makes the Student class complicated. As discussed in this section, we should create
    additional classes that have separate concerns.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 展示了 Student 类的一部分。在实际项目中，这个类可能包含许多其他功能，例如午餐账户和人口统计信息可能包括其他方法。例如，管理午餐账户的功能可能有许多额外的操作，如挂失卡片和合并多个账户。实现这些操作会使
    Student 类变得复杂。正如本节所讨论的，我们应该创建具有单独关注点的额外类。
- en: 'When we analyzed the Student class, we recognized two major functional components:
    lunch account and demographics, which represent concerns distinct from the Student
    class. Thus, these two functional components can form their own classes. Before
    we write any code, we can continue to work on our UML diagram (figure 9.10), an
    updated version of which reflects the additional structural components of our
    application.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分析 Student 类时，我们识别出两个主要的功能组件：午餐账户和人口统计信息，它们代表了与 Student 类不同的关注点。因此，这两个功能组件可以形成它们自己的类。在我们编写任何代码之前，我们可以继续完善我们的
    UML 图（图 9.10），其更新版本反映了我们应用程序的额外结构组件。
- en: '![CH09_F10_Cui](../Images/CH09_F10_Cui.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F10_Cui](../Images/CH09_F10_Cui.png)'
- en: Figure 9.10 Isolate the functionalities of handling Account and Demographics
    to form separate classes (UML diagram version 2). Please note that I list some
    other attributes and methods that could exist in each class.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 将处理 Account 和 Demographics 的功能隔离成单独的类（UML 图版本 2）。请注意，我列出了每个类可能存在的其他属性和方法。
- en: 'The updated UML diagram depicts two additional classes: Account and Demographics.
    The Account class has the attributes and methods for managing a student’s lunch
    account, and the Demographics class has the attributes and methods to handle a
    student’s demographic information.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 UML 图展示了两个额外的类：Account 和 Demographics。Account 类具有管理学生午餐账户的属性和方法，而 Demographics
    类具有处理学生人口统计信息的属性和方法。
- en: 9.5.3 Connecting related classes
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 连接相关类
- en: When we created the Account and Demographics classes, the process was one-way;
    we extracted information from the existing Student class. These two classes are
    still standalone and don’t work with the Student class yet. In this section, we’ll
    connect them so that they work together in a neat way.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 Account 和 Demographics 类时，这个过程是单向的；我们从现有的 Student 类中提取信息。这两个类仍然是独立的，并且还没有与
    Student 类协同工作。在本节中，我们将连接它们，以便它们以整洁的方式协同工作。
- en: Connecting the data using attributes
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性连接数据
- en: One thing you may have noticed is that the Account and Demographics classes
    have the student_id attribute. Because of the uniqueness of student identification
    numbers, all the data of a specific student can be connected via the unique student_id.
    To create two-way traffic between Student and Account/Demographics, an instance
    object of the Student class should have access to account and demographic information
    via the student_id. The next listing connects the instance objects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Account 和 Demographics 类都有 student_id 属性。由于学生识别号码的唯一性，可以通过唯一的 student_id
    连接特定学生的所有数据。为了在 Student 和 Account/Demographics 之间建立双向交通，Student 类的实例对象应该能够通过 student_id
    访问账户和人口统计信息。接下来的列表展示了如何连接实例对象。
- en: Listing 9.10 Separating classes to have distinct concerns
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 分离类以具有不同的关注点
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In listing 9.10, we define Account and Demographics classes implementing only
    the initialization method. Notably, we update the Student class’s initialization
    method by adding two attributes: account and demographics, which are instance
    objects of the Account and Demographics classes, respectively. By doing so, we
    connect these three classes. We can now inspect the attributes of an instance
    of the Student class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.10 中，我们定义了 Account 和 Demographics 类，仅实现了初始化方法。值得注意的是，我们通过添加两个属性：account
    和 demographics，分别对应 Account 和 Demographics 类的实例对象，来更新 Student 类的初始化方法。这样做，我们连接了这三个类。现在我们可以检查
    Student 类实例的属性：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, the instance student has the correct account and demographic
    information because it has the instances of Account and Demographics as its attributes.
    Note that we can save student_id as an attribute for the instance objects of the
    Account and Demographics classes. We don’t have to do so, however, because an
    instance object of Student has attributes of account and demographics; the connections
    have been established.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实例 student 具有正确的账户和人口统计信息，因为它具有 Account 和 Demographics 的实例作为其属性。请注意，我们可以将
    student_id 作为 Account 和 Demographics 类实例对象的属性保存。然而，我们不必这样做，因为 Student 的实例对象具有账户和人口统计属性；连接已经建立。
- en: Connecting the methods
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 连接方法
- en: Connecting the data between these three classes is straightforward. The fun
    part is connecting the methods.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个类之间连接数据是直接的。有趣的部分是连接方法。
- en: The purpose of creating additional classes isn’t only about having them hold
    a specific attribute. The more important part is using these classes to provide
    the dedicated functionalities. Specifically, our plan is to move all the implementations
    of account management to the Account class and to move all the implementations
    of demographics to the Demographics class. The following listing shows updated
    versions of the Account and Demographics classes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 创建额外类别的目的不仅仅是让它们持有特定的属性。更重要的是使用这些类来提供专门的函数。具体来说，我们的计划是将所有账户管理的实现移动到 Account
    类，将所有人口统计的实现移动到 Demographics 类。下面的列表展示了 Account 和 Demographics 类的更新版本。
- en: Listing 9.11 The updated Account and Demographics classes
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 更新的 Account 和 Demographics 类
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: QUESTION If the database operations are expensive, such as hosting the database
    in the cloud, they may be implemented as lazy attributes. Can you recall how?
    See section 9.4.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：如果数据库操作成本高昂，例如在云端托管数据库，它们可以实施为延迟属性。你能回忆起如何做吗？请参阅第 9.4 节。
- en: 'In our application, whenever we want to show the student’s account information,
    we can take advantage of the Account class directly. We can show the student’s
    balance by running the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，每当我们要显示学生的账户信息时，我们可以直接利用 Account 类。我们可以通过运行以下代码来显示学生的余额：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In a similar manner, we can show the student’s demographics by running the
    following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以通过运行以下代码来展示学生的人口统计信息：
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that some users may prefer working with methods from fewer classes, so
    they might create some methods in the Student class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些用户可能更喜欢使用来自较少类的函数，因此他们可能会在 Student 类中创建一些方法：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can get the account balance and the demographics by calling the get_account_
    balance and get_demographics methods on the Student instance. I don’t recommend
    this pattern, however. It makes the connection between the Student and Account/Demographics
    classes too tight—a problem known as *tight coupling**.* When you update your
    Account class, you may also have to update the Student class because its functionality
    (get_account_balance) depends on Account.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 Student 实例上的 `get_account_balance` 和 `get_demographics` 方法来获取账户余额和人口统计信息。然而，我不推荐这种模式。它使得
    Student 和 Account/Demographics 类之间的联系过于紧密——这是一个被称为 *紧密耦合* 的问题。当你更新 Account 类时，你可能也必须更新
    Student 类，因为它的功能（获取账户余额）依赖于 Account。
- en: Maintainability Don’t introduce tight coupling between related classes. The
    classes should be in a loosely coupled state for best maintainability.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性：不要在相关类之间引入紧密耦合。为了最佳的可维护性，类应该处于松散耦合状态。
- en: 9.5.4 Discussion
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.4 讨论
- en: Before you start your project, it’s a good habit to use a UML diagram to lay
    out the necessary classes for data management. Don’t expect that work to be a
    one-time deal, however. As your project progresses, you may realize that some
    classes are becoming more complicated. It’s a great habit to think about your
    data models from time to time throughout the project’s development process. The
    single objective is to make the classes slim and loosely connected—that is, related
    classes work together but don’t depend heavily on one another, making refactoring
    hard in such a tight-coupling design.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始你的项目之前，使用 UML 图来规划数据管理所需的基本类是一个好习惯。然而，不要期望这项工作是一次性的。随着项目的进展，你可能会意识到某些类变得越来越复杂。在整个项目开发过程中不时地思考你的数据模型是一个很好的习惯。单一的目标是使类保持瘦小和松散连接——也就是说，相关的类可以一起工作，但不要过度依赖彼此，这样在紧密耦合的设计中重构会变得困难。
- en: 9.5.5 Challenge
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.5 挑战
- en: In this section’s code snippets, I intentionally made all the methods in the
    classes public. As discussed in section 8.3, however, it’s a best practice to
    make methods that users don’t need to access nonpublic. As a challenge, can you
    make the applicable methods in listing 9.11 nonpublic?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节代码片段中，我故意将类中的所有方法都设置为公开。然而，如第 8.3 节所述，将用户不需要访问的方法设置为非公开是一个最佳实践。作为一个挑战，你能将列表
    9.11 中的适用方法设置为非公开吗？
- en: Hint If you want to define a nonpublic method, prefix the method name with an
    underscore.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你想定义一个非公开方法，请使用下划线作为方法名的前缀。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Create an enumeration class by subclassing Enum when you need to group related
    concepts.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要将相关概念分组时，可以通过继承 Enum 类来创建枚举类。
- en: The enumeration class makes iteration over possible values and membership checking
    convenient.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类使得遍历可能值和成员检查变得方便。
- en: Use the dataclass decorator to create classes to avoid boilerplate, such as
    implementing __init__ and __repr__. When you use this decorator, remember to use
    the type annotations to create the applicable fields.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 dataclass 装饰器创建类以避免样板代码，例如实现 `__init__` 和 `__repr__`。当你使用这个装饰器时，请记住使用类型注解来创建适用的字段。
- en: JSON data is the universal data exchange format for different systems. We can
    use the json module to convert JSON to native Python data structures (JSON deserialization)
    and the other way around (JSON serialization).
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 数据是不同系统间通用的数据交换格式。我们可以使用 json 模块将 JSON 转换为原生 Python 数据结构（JSON 反序列化）以及相反的过程（JSON
    序列化）。
- en: An instance object of a custom class usually isn’t JSON-serializable. You should
    provide specific encoding instructions for JSON serialization of the class.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义类的实例通常不是 JSON 序列化的。你应该为类的 JSON 序列化提供特定的编码指令。
- en: You can use __getattr__ to implement lazy attributes, but you must understand
    that __getattr__ is a fallback mechanism when an attribute isn’t contained in
    the object’s __dict__ attribute.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `__getattr__` 来实现延迟属性，但必须理解 `__getattr__` 是当属性不包含在对象的 `__dict__` 属性中时的一个后备机制。
- en: Implementing a property allows you to have finer control of specific attributes.
    In the case of lazy attributes, you can set None to an internally managed counterpart.
    When the attribute is requested, you can set the counterpart attribute.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现属性允许你更精细地控制特定的属性。在延迟属性的情况下，你可以将 None 设置为内部管理的对应属性。当请求属性时，你可以设置对应属性。
- en: Classes should be kept for a single purpose. When your class grows in its scope
    and you realize that it has mixed purposes, you should refactor your class to
    create distinct classes, each of which addresses a specific need.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 课堂应该保持单一目的。当你的类在范围上增长，你意识到它具有多种目的时，你应该重构你的类以创建不同的类，每个类都针对特定的需求。
- en: Use a UML diagram to analyze a class’s structure, which allows you to have a
    clear understanding of the class at a high level.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UML 图来分析类的结构，这让你能够从高层次上清晰地理解类。
