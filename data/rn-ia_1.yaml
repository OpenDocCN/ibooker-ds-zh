- en: Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: Developing applications in React Native
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中开发应用程序
- en: With the basics covered, you can start adding features to your React Native
    app. The chapters in this part cover styling, navigation, animations, and elegant
    ways to handle data using data architectures (with a focus on Redux).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握基础知识之后，你就可以开始向你的 React Native 应用程序添加功能了。本部分中的章节涵盖了样式、导航、动画以及使用数据架构（重点关注 Redux）优雅地处理数据的方法。
- en: Chapters 4 and 5 teach how to apply styles either inline with components or
    in stylesheets that components can reference. And because React Native components
    are the main building blocks of your app’s UI, chapter 4 spends some time teaching
    useful things you can do with the `View` component. Chapter 5 builds on the skills
    taught in chapter 4\. It covers aspects of styling that are platform specific,
    as well as some advanced techniques, including using flexbox to make it easier
    to lay out an application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 章和第 5 章教授了如何将样式应用于组件内联或在其可以引用的样式表中。由于 React Native 组件是应用程序 UI 的主要构建块，第 4
    章花了一些时间教授你可以使用 `View` 组件做的有用事情。第 5 章在第 4 章教授的技能基础上进行扩展。它涵盖了特定于平台的样式方面，以及一些高级技术，包括使用
    flexbox 使布局更容易。
- en: Chapter 6 shows how to use the two most-recommended and most-used navigation
    libraries, React Navigation and React Native Navigation. We walk through creating
    the three main types of navigators—tabs, stack, and drawer—and how to control
    the navigation state.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章展示了如何使用两个最推荐和最常用的导航库，React Navigation 和 React Native Navigation。我们介绍了创建三种主要类型的导航器——标签、堆栈和抽屉，以及如何控制导航状态。
- en: Chapter 7 covers the four things you need to do to create animations, the four
    types of animatable components that ship with the Animated API, how to create
    custom animatable components, and several other useful skills.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章涵盖了创建动画需要做的四件事，与 Animated API 一起提供的四种可动画组件类型，如何创建自定义可动画组件，以及一些其他有用的技能。
- en: In chapter 8, we explore handling data with data architectures. Because Redux
    is the most widely adopted method of handling data in the React ecosystem, you
    use it to build an app, meanwhile learning data-handling skills. We show how to
    use the Context API and how to implement Redux with a React Native app by using
    reducers to hold the Redux state and delete items from the example app. We also
    cover how to use providers to pass global state to the rest of the app, how to
    use the `connect` function to access the example app from a child component, and
    how to use actions to add functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，我们探讨了使用数据架构处理数据。由于 Redux 是 React 生态系统中处理数据最广泛采用的方法，因此你使用它来构建应用程序，同时学习数据处理技能。我们展示了如何使用
    Context API，以及如何通过使用 reducer 来保存 Redux 状态和从示例应用程序中删除项目来实现 Redux。我们还涵盖了如何使用 providers
    将全局状态传递给应用程序的其余部分，如何使用 `connect` 函数从子组件访问示例应用程序，以及如何使用动作添加功能。
- en: '4'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Introduction to styling
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 样式介绍
- en: '*****This chapter*** ***covers*****'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章*****涵盖了'
- en: Styling using JavaScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 进行样式化
- en: Applying and organizing styles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用和组织样式
- en: Applying styles to `View` components
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式应用于 `View` 组件
- en: Applying styles to `Text` components
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式应用于 `Text` 组件
- en: It takes talent to build mobile applications, but it takes *style* to make them
    great. If you’re a graphic designer, you know this intuitively, deep in your bones.
    If you’re a developer, you’re probably groaning and rolling your eyes. In either
    case, understanding the fundamentals of styling Reactive Native components is
    critical to making an engaging application that others want to use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 建立移动应用程序需要才能，但要使它们出色则需要 *风格*。如果你是一位图形设计师，你对此有直觉性的认识，深入骨髓。如果你是一位开发者，你可能正在抱怨并翻着白眼。无论哪种情况，理解
    React Native 组件的基本样式原理对于制作一个吸引人且他人愿意使用的应用程序至关重要。
- en: 'In all likelihood, you have some experience with CSS, even if it’s nothing
    more than seeing the syntax. You can easily understand what a CSS rule like `background-color:
    ''red''` is meant to do. As you begin reading this chapter, it may appear as though
    styling components in React Native is as simple as using camelCase names for CSS
    rules. For instance, setting the background color on a React Native component
    uses almost the same syntax, `backgroundColor: ''red''`—but be forewarned, this
    is where the similarities end.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '很可能你已经有一些 CSS 经验，即使只是看到过其语法。你很容易理解像 `background-color: ''red''` 这样的 CSS 规则想要做什么。当你开始阅读这一章时，可能会觉得在
    React Native 中对组件进行样式化就像使用 CSS 规则的驼峰命名法一样简单。例如，设置 React Native 组件的背景颜色使用几乎相同的语法，`backgroundColor:
    ''red''`——但请提前警告，相似之处到此为止。'
- en: Try not to hang on to how you did things in CSS. Embrace the React Native way,
    and you’ll find that learning how to style components is a much more pleasant
    experience—even for a developer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要执着于你在 CSS 中做事情的方式。拥抱 React Native 的方式，你会发现学习如何样式化组件是一个更加愉快的体验——即使是对于开发者来说也是如此。
- en: The first section of this chapter provides an overview of styling components.
    We’ll make sure you understand the various ways to apply styles to components
    and discuss how to organize styles in an application. Forming good organizational
    habits now will make things easier to manage and will facilitate the use of more
    advanced techniques down the road.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分提供了样式组件的概述。我们将确保你理解将样式应用到组件的各种方法，并讨论如何在应用程序中组织样式。现在形成良好的组织习惯将使事情更容易管理，并有助于将来使用更高级的技术。
- en: Because React Native is styled using JavaScript, we’ll talk about how to start
    thinking of styles as code and how to take advantage of JavaScript features like
    variables and functions. The final two sections explore styling `View` components
    and `Text` components. In some cases, we’ll use short examples to explain a topic,
    but for the most part, we’ll walk through styling something real. You’ll take
    what you learn and apply it to the construction of a Profile Card.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 React Native 使用 JavaScript 进行样式设计，我们将讨论如何开始将样式视为代码，以及如何利用 JavaScript 的特性，如变量和函数。最后两个部分将探讨
    `View` 组件和 `Text` 组件的样式。在某些情况下，我们会用简短的例子来解释一个主题，但大部分时间，我们将通过实际样式的例子来讲解。你将所学应用到构建个人资料卡片的过程中。
- en: For all the example code in this chapter, you can start with the default generated
    app and replace the contents of App.js with the code from the individual listings.
    Complete source files can be found at [www.manning.com/books/react-native-in-action](http://www.manning.com/books/react-native-in-action)
    and in the book’s Git repository at https://github.com/dabit3/react-native-in-action
    under chapter-4.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例代码，你可以从默认生成的应用程序开始，用单独列表中的代码替换 `App.js` 中的内容。完整的源代码可以在 [www.manning.com/books/react-native-in-action](http://www.manning.com/books/react-native-in-action)
    找到，以及本书的 Git 仓库 https://github.com/dabit3/react-native-in-action 下的第 4 章。
- en: 4.1 Applying and organizing styles in React Native
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 在 React Native 中应用和组织样式
- en: React Native comes with many built-in components, and the community has built
    many more you can include with your projects. Components support a specific set
    of styles. Those styles may or may not be applicable to other types of components.
    For example, the `Text` component supports the `fontWeight` property (`fontWeight`
    refers to the thickness of the font), but the `View` component doesn’t. Conversely,
    the `View` component supports the `flex` property (`flex` refers to the layout
    of components within a view), but the `Text` component doesn’t.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 内置了许多组件，社区也构建了许多你可以包含到你的项目中的组件。组件支持特定的样式集。这些样式可能或可能不适用于其他类型的组件。例如，`Text`
    组件支持 `fontWeight` 属性（`fontWeight` 指的是字体的粗细），但 `View` 组件不支持。相反，`View` 组件支持 `flex`
    属性（`flex` 指的是视图内组件的布局），但 `Text` 组件不支持。
- en: Some styling elements are similar between components but not the same. For example,
    the `View` component supports the `shadowColor` property, whereas the `Text` component
    supports the `textShadowColor` property. Some styles, like `ShadowPropTypesIOS`,
    only apply to a specific platform (in this case, to iOS).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的组件之间有些样式元素是相似的，但并不完全相同。例如，`View` 组件支持 `shadowColor` 属性，而 `Text` 组件支持 `textShadowColor`
    属性。一些样式，如 `ShadowPropTypesIOS`，只适用于特定的平台（在这种情况下，是 iOS）。
- en: Learning the various styles and how to manipulate them takes time. That’s why
    it’s important to start with fundamentals like how to apply and organize styles.
    This section will focus on teaching those styling fundamentals, so you’ll have
    a good foundation from which to start exploring styles and building the example
    Profile Card component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 学习各种样式以及如何操作它们需要时间。这就是为什么从如何应用和组织样式等基础知识开始很重要。本节将专注于教授这些样式基础知识，这样你将有一个良好的基础，从那里开始探索样式并构建示例个人资料卡片组件。
- en: 4.1.1 Applying styles in applications
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 在应用程序中应用样式
- en: To compete in the marketplace, mobile applications must have a sense of style.
    You can develop a fully functional app, but if it looks terrible and isn’t engaging,
    people aren’t going to be interested. You don’t have to build the hottest-looking
    app in the world, but you do have to commit to creating a polished product. A
    polished, sharp-looking app greatly influences people’s perception of the app’s
    quality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在市场上竞争，移动应用程序必须有一种风格感。你可以开发一个功能齐全的应用程序，但如果它看起来很糟糕且不吸引人，人们是不会感兴趣的。你不必建造世界上看起来最酷的应用程序，但你确实需要致力于创建一个精致的产品。一个精致、外观锐利的应用程序会极大地影响人们对应用程序质量的看法。
- en: You can apply styles to elements in React Native in a number of ways. In chapters
    1 and 3, we went over inline styling (shown in the next listing) and styling using
    a `StyleSheet` ([listing 4.2](#listing4.2)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 React Native 中以多种方式应用样式。在第 1 章和第 3 章中，我们介绍了内联样式（如下所示）以及使用 `StyleSheet`
    的样式（[清单 4.2](#listing4.2)）。
- en: Listing 4.1 Using inline styles
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.1 使用内联样式
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it’s possible to specify multiple styles at once by supplying
    an object to the `styles` property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以通过向 `styles` 属性提供一个对象来一次性指定多个样式。
- en: Listing 4.2 Referencing styles defined in a `StyleSheet`
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.2 引用 `StyleSheet` 中定义的样式
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Functionally, there’s no difference between using an inline style versus referencing
    a style defined in a `StyleSheet`. With `StyleSheet`, you create a `style` object
    and refer to each style individually. Separating the styles from the `render`
    method makes the code easier to understand and promotes reuse of styles across
    components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能上，使用内联样式与引用在 `StyleSheet` 中定义的样式没有区别。使用 `StyleSheet`，你可以创建一个 `style` 对象并单独引用每个样式。将样式与
    `render` 方法分离使得代码更容易理解，并促进了样式在组件间的复用。
- en: 'When using a style name like `warning`, it’s easy to recognize the intent of
    the message. But the inline style `color: ''red''` offers no insight into why
    the message is red. Having styles specified in one place rather than inline on
    many components makes it easier to apply changes across the entire application.
    Imagine you wanted to change warning messages to yellow. All you have to do is
    change the style definition once in the stylesheet, `color: ''yellow''`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用像 `warning` 这样的样式名时，很容易识别消息的意图。但是内联样式 `color: ''red''` 并没有提供关于为什么消息是红色的任何见解。将样式指定在一个地方而不是在许多组件的内联中，使得在整个应用程序中应用更改变得更加容易。想象一下，如果你想将警告消息改为黄色，你只需要在样式表中更改一次样式定义，`color:
    ''yellow''`。'
- en: '[Listing 4.2](#listing4.2) also shows how to specify multiple styles by supplying
    an array of style properties. Remember when doing this that the last style passed
    in will override the previous style if there’s a duplicate property. For example,
    if an array of styles like this is supplied, the last value for `color` will override
    all the previous values:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4.2](#listing4.2) 还展示了如何通过提供一个包含样式属性的数组来指定多个样式。记住，当你这样做时，如果存在重复的属性，最后传入的样式将覆盖之前的样式。例如，如果提供了一个这样的样式数组，`color`
    的最后一个值将覆盖所有之前的值：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the color will be red.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，颜色将是红色。
- en: 'It’s also possible to combine the two methodologies by specifying an array
    of styling properties using inline styles and references to stylesheets:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用内联样式和样式表的引用来组合这两种方法，指定一个包含样式属性的数组：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'React Native is very flexible in this regard, which can be both good and bad.
    Specifying inline styles when you’re quickly trying to prototype something is
    extremely easy, but in the long haul, you’ll want to be careful how you organize
    your styles; otherwise your application can quickly become a mess and difficult
    to manage. By organizing your styles, you’ll make it easier to do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 在这方面非常灵活，这既有好的一面也有不好的一面。当你快速尝试原型设计时，指定内联样式非常容易，但从长远来看，你需要小心地组织你的样式；否则，你的应用程序可能会迅速变得混乱且难以管理。通过组织你的样式，你会使以下操作变得更加容易：
- en: Maintain your application’s codebase
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护你的应用程序代码库
- en: Reuse styles across components
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件间复用样式
- en: Experiment with styling changes during development
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中尝试样式变化
- en: 4.1.2 Organizing styles
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 组织样式
- en: 'As you might suspect from the previous section, using inline styles isn’t the
    recommended way to go: stylesheets are a much more effective way to manage styles.
    But what does that mean in practice?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，你可能已经猜到，使用内联样式并不是推荐的做法：样式表是管理样式的更有效方式。但在实际操作中这意味着什么呢？
- en: When styling websites, we use stylesheets all the time. Often we use tools like
    Sass, Less, and PostCSS to create monolithic stylesheets for the entire application.
    In the world of the web, styles are in essence global, but that isn’t the React
    Native way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计网站时，我们经常使用样式表。我们经常使用 Sass、Less 和 PostCSS 等工具来创建整个应用程序的单一代码样式表。在网页的世界里，样式本质上是全球的，但这不是
    React Native 的方式。
- en: React Native focuses on the component. The goal is to make components as reusable
    and standalone as possible. Having a component dependent on an application’s stylesheet
    is the antithesis of modularity. In React Native, styles are scoped to the component—not
    to the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 专注于组件。目标是使组件尽可能可重用和独立。使组件依赖于应用程序的样式表是模块化的对立面。在 React Native 中，样式是针对组件的——而不是针对应用程序。
- en: 'How to accomplish this encapsulation depends entirely on your team’s preference.
    There’s no right or wrong way, but in the React Native community, you’ll find
    two common approaches:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这种封装完全取决于你团队的偏好。没有对错之分，但在 React Native 社区中，你会发现两种常见的方法：
- en: Declaring stylesheets in the same file as the component
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件相同的文件中声明样式表
- en: Declaring stylesheets in a separate file, outside of the component
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件外部单独声明样式表
- en: Declaring stylesheets in the same file as the component
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在组件相同的文件中声明样式表
- en: As you’ve done so far in this book, a popular way to declare styles is within
    the component that will be using them. The major benefit of this approach is that
    the component and its styles are completely encapsulated in a single file. This
    component can then be moved or used anywhere in the app. This is a common approach
    to component design, one you’ll see often in the React Native community.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书中已经做的那样，声明样式的常见方法是在将使用它们的组件内部进行。这种方法的优点是组件及其样式完全封装在一个单独的文件中。然后，这个组件可以被移动或在任何地方使用。这是组件设计的一种常见方法，你会在
    React Native 社区中经常看到。
- en: '![c04_01.eps](Images/c04_01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![c04_01.eps](Images/c04_01.png)'
- en: Figure 4.1 An example file structure with styles separated from components in
    a single folder instead of a single file
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 一个示例文件结构，其中样式与组件分开保存在单个文件夹中而不是单个文件中
- en: When including the stylesheet definitions with the component, the typical convention
    is to specify the styles after the component. All the listings in this book have,
    so far, followed this convention.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当将样式定义与组件一起包含时，通常的约定是在组件之后指定样式。本书中迄今为止的所有列表都遵循了这一约定。
- en: Declaring stylesheets in a separate file
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在单独的文件中声明样式表
- en: If you’re used to writing CSS, putting your styles into a separate file might
    seem like a better approach and feel more familiar. The stylesheet definitions
    are created in a separate file. You can name it whatever you want (styles.js is
    typical), but be sure the extension is .js; it’s JavaScript, after all. The stylesheet
    file and component file are saved in the same folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于编写 CSS，将样式放入单独的文件可能看起来是一个更好的方法，并且感觉更熟悉。样式表定义是在一个单独的文件中创建的。你可以给它取任何你想要的名称（styles.js
    是典型的名称），但请确保扩展名是 .js；毕竟，它是 JavaScript。样式表文件和组件文件保存在同一个文件夹中。
- en: A file structure like that shown in [figure 4.1](#figure4.1) retains the close
    relationship between components and styles and affords a bit of clarity by not
    mixing style definitions with the functional aspects of the components. [Listing
    4.3](#listing4.3) corresponds to a styles.js file that would be used to style
    a component like `ComponentA` and `ComponentB` in the figure. Use meaningful names
    when defining your stylesheets, so it’s clear what part of a component is being
    styled.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 4.1](#figure4.1) 所示的文件结构保留了组件和样式之间的紧密关系，并通过不将样式定义与组件的功能方面混合而提供了一些清晰度。[列表
    4.3](#listing4.3) 对应于一个用于样式化图中的 `ComponentA` 和 `ComponentB` 的 `styles.js` 文件。在定义样式表时使用有意义的名称，以便清楚地了解正在样式化组件的哪个部分。
- en: Listing 4.3 Externalizing a component’s stylesheets
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 将组件的样式表外部化
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The component imports the external stylesheets and can reference any styles
    defined within them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 组件导入外部样式表并可以引用其中定义的任何样式。
- en: Listing 4.4 Importing external stylesheets
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 导入外部样式表
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 4.1.3 Styles are code
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 样式是代码
- en: You’ve already seen how JavaScript is used to define styles in React Native.
    Despite having a full scripting language with variables and functions, your styles
    have been rather static, but they certainly don’t have to be!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何在 React Native 中使用 JavaScript 定义样式。尽管拥有完整的脚本语言，包括变量和函数，但你的样式相当静态，但它们当然不必如此！
- en: Web developers have fought with CSS for years. New technologies like Sass, Less,
    and PostCSS were created to work around the many limitations of cascading stylesheets.
    Even a simple thing like defining a variable to store the primary color of a site
    was impossible without CSS preprocessors. The CSS Custom Properties for Cascading
    Variables Module Level 1 candidate recommendation in December 2015 introduced
    the concept of custom properties, which are akin to variables; but at the time
    of writing, fewer than 80% of browsers in use support this functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 网页开发者多年来一直在与 CSS 作斗争。为了克服层叠样式表的许多限制，创造了新的技术，如 Sass、Less 和 PostCSS。即使像定义一个变量来存储网站的主色这样的简单事情，没有
    CSS 预处理器也是不可能的。2015 年 12 月 CSS 变量级联模块 1 的候选推荐引入了自定义属性的概念，这些属性类似于变量；但在撰写本文时，使用中的不到
    80% 的浏览器支持此功能。
- en: Let’s take advantage of the fact that we’re using JavaScript and start thinking
    of styles as code. You’ll build a simple application that gives the user a button
    to change the theme from light to dark. But before you start coding, let’s walk
    through what you’re trying to build.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们正在使用 JavaScript 的这一事实，开始将样式视为代码。你将构建一个简单的应用程序，用户可以通过它从浅色主题切换到深色主题。但在你开始编码之前，让我们回顾一下你试图构建的内容。
- en: The application has a single button on the screen. That button is enclosed by
    a small square box. When the button is pressed, the themes will toggle. When the
    light theme is selected, the button label will say White, the background will
    be white, and the box around the button will be black. When the dark theme is
    selected, the button label will say Black, the background will be black, and the
    box around the button will be white. [Figure 4.2](#figure4.2) shows what the screen
    should look like when the themes are selected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在屏幕上有一个单独的按钮。该按钮被一个小正方形框包围。当按钮被按下时，主题将切换。当选择浅色主题时，按钮标签将显示为白色，背景将是白色，按钮周围的框将是黑色。当选择深色主题时，按钮标签将显示为黑色，背景将是黑色，按钮周围的框将是白色。[图
    4.2](#figure4.2) 展示了选择主题时屏幕应该看起来像什么。
- en: '![c04_02.eps](Images/c04_02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![c04_02.eps](Images/c04_02.png)'
- en: '[Figure 4.2](#figureanchor4.2) A simple application that supports two themes,
    white and black. Users can press the button to toggle between a white background
    and a black background.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.2](#figureanchor4.2) 一个支持两种主题（白色和黑色）的简单应用程序。用户可以按按钮在白色背景和黑色背景之间切换。'
- en: For this example, organize the styles in a separate file, styles.js. Then, create
    some constants to hold the color values, and create two stylesheets for the light
    and dark themes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，将样式组织在一个单独的文件 styles.js 中。然后，创建一些常量来保存颜色值，并为浅色和深色主题创建两个样式表。
- en: Listing 4.5 Dynamic stylesheets extracted from the main component file
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 从主组件文件中提取的动态样式表
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the styles have been configured, you can start building the component app
    in App.js. Because you only have light and dark themes, create a utility function,
    `getStyleSheet`, which takes a Boolean value. If `true` is supplied, the dark
    theme will be returned; otherwise the light theme will be returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了样式，你就可以开始在 App.js 中构建组件应用程序了。因为你只有浅色和深色主题，创建一个实用函数 `getStyleSheet`，它接受一个布尔值。如果提供
    `true`，则返回深色主题；否则返回浅色主题。
- en: Listing 4.6 Application that toggles between light and dark themes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 在浅色和深色主题之间切换的应用程序
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The application toggles themes: feel free to experiment and take it a bit further.
    Try changing the light theme to a different color. Notice how easy it is, because
    the colors are defined as constants in one place. Try changing the button label
    in the dark theme to be the same color as the background instead of always white.
    Try creating an entirely new theme, or modify the code to support many different
    themes instead of just two—have fun!'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序切换主题：请随意尝试并进一步探索。尝试将浅色主题改为不同的颜色。注意这有多么容易，因为颜色被定义为一个地方的可变常量。尝试将深色主题中的按钮标签改为与背景相同的颜色，而不是总是白色。尝试创建一个全新的主题，或者修改代码以支持许多不同的主题，而不是仅仅两个——享受乐趣！
- en: 4.2 Styling view components
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 样式化视图组件
- en: 'Now that you’ve had a proper overview of styling in React Native, let’s talk
    more about individual styles. This chapter covers many of the basic properties
    you’ll use all the time. In chapter 5, we’ll go into more depth and introduce
    styles you won’t see every day and styles that are platform specific. But for
    now, let’s focus on the basics: in this section, that’s the `View` components.
    The `View` component is the main building block of a UI and is one of the most
    important components to understand to get your styling right. Remember, a `View`
    element is similar to an HTML `div` tag in the sense that you can use it to wrap
    other elements and build blocks of UI code in it.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 React Native 中的样式有了全面的了解，让我们更多地讨论个别样式。本章涵盖了你会经常使用的许多基本属性。在第 5 章中，我们将更深入地探讨并介绍你不会每天看到的样式以及特定平台的样式。但就目前而言，让我们专注于基础知识：在本节中，那就是
    `View` 组件。`View` 组件是 UI 的主要构建块，也是理解以正确方式设置样式的重要组件之一。记住，`View` 元素在某种程度上类似于 HTML
    的 `div` 标签，因为你可以用它来包裹其他元素，并在其中构建 UI 代码块。
- en: 'As you progress through the chapter, you’ll use what you’ve learned to build
    a real component: a Profile Card. Building the Profile Card will show how to put
    everything together. [Figure 4.3](#figure4.3) shows what the component will look
    like at the end of this section. In the process of creating this component, you’ll
    learn how to do the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你通过本章的学习，你将使用所学知识来构建一个真实组件：配置文件组件。构建配置文件组件将展示如何将一切组合在一起。[图 4.3](#figure4.3)
    展示了本节结束时组件的外观。在创建此组件的过程中，你将学习以下内容：
- en: Create a border around the profile container using `borderWidth`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `borderWidth` 在配置文件容器周围创建边框
- en: Round the corners of that border with `borderRadius`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `borderRadius` 来圆滑那个边框的角落
- en: Create a border that looks like a circle by using a `borderRadius` half the
    size of the component’s width
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用组件宽度一半大小的 `borderRadius` 创建看起来像圆的边框
- en: Position everything using margin and padding properties
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用边距和填充属性来定位一切
- en: The next few sections will teach the styling techniques you’ll need to know
    to create the Profile Card component. We’ll start easy by talking about how to
    set a component’s background color. You’ll be able to use that same technique
    to set the background color of the Profile Card.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将教授你创建配置文件组件所需了解的样式技术。我们将从讨论如何设置组件的背景颜色开始。你将能够使用相同的技巧来设置配置文件组件的背景颜色。
- en: '![c04_03.eps](Images/c04_03.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![c04_03.eps](Images/c04_03.png)'
- en: '[Figure 4.3](#figureanchor4.3) The Profile Card component after the structural
    View components have been styled. The Profile Card is a rectangle with rounded
    corners and a circular section for a profile image.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.3](#figureanchor4.3) 在结构视图组件样式化之后，配置文件组件的外观。配置文件组件是一个圆角矩形，有一个圆形区域用于配置图像。'
- en: 4.2.1 Setting the background color
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 设置背景颜色
- en: Without a splash of color, a user interface (UI) looks boring and dull. You
    don’t need an explosion of color to make things look interesting, but you do need
    a bit. The `backgroundColor` property sets the background color of an element.
    This property takes a string of one of the properties shown in [table 4.1](#table4.1).
    The same colors are available when rendering text to the screen as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没有色彩的点缀，用户界面（UI）看起来会显得无聊和单调。你不需要色彩爆炸来使事物看起来有趣，但你确实需要一点。`backgroundColor` 属性设置元素的背景颜色。此属性接受一个字符串，可以是
    [表 4.1](#table4.1) 中显示的属性之一。在屏幕上渲染文本时也提供相同的颜色。
- en: Table 4.1 Supported color formats
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 支持的颜色格式
- en: '| **Supported color format** | **Example** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **支持的颜色格式** | **示例** |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `#rgb` | `''#06f''` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `#rgb` | `''#06f''` |'
- en: '| `#rgba` | `''#06fc''` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `#rgba` | `''#06fc''` |'
- en: '| `#rrggbb` | `''#0066ff''` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `#rrggbb` | `''#0066ff''` |'
- en: '| `#rrggbbaa` | `''#ff00ff00''` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `#rrggbbaa` | `''#ff00ff00''` |'
- en: '| `rgb(number, number, number)` | `''rgb(0, 102, 255)''` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `rgb(number, number, number)` | `''rgb(0, 102, 255)''` |'
- en: '| `rgb(number, number, number, alpha)` | `''rgba(0, 102, 255, .5)''` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `rgb(number, number, number, alpha)` | `''rgba(0, 102, 255, .5)''` |'
- en: '| `hsl(hue, saturation, lightness)` | `''hsl(216, 100%, 50%)''` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `hsl(hue, saturation, lightness)` | `''hsl(216, 100%, 50%)''` |'
- en: '| `hsla(hue, saturation, lightness, alpha)` | `''hsla(216, 100%, 50%, .5)''`
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `hsla(hue, saturation, lightness, alpha)` | `''hsla(216, 100%, 50%, .5)''`
    |'
- en: '| Transparent background | `''transparent''` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 透明背景 | `''transparent''` |'
- en: '| Any CSS3-specified named color (black, red, blue, and so on) | `''dodgerblue''`
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 任何 CSS3 指定的命名颜色（黑色、红色、蓝色等） | `''dodgerblue''` |'
- en: 'Fortunately, the supported color formats are the same ones supported by CSS.
    We won’t go into great detail, but because this may be the first time you’ve seen
    some of these formats, here’s a quick explanation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，支持的色彩格式与 CSS 支持的格式相同。我们不会深入细节，但鉴于这可能是您第一次看到这些格式中的某些格式，这里有一个简要的解释：
- en: '`rgb` stands for red, green, and blue. You can specify the values for red,
    green, and blue using a scale from 0–255 (or in hexadecimal 00–ff). Higher numbers
    mean more of each color.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rgb` 代表红色、绿色和蓝色。您可以使用 0–255（或十六进制 00–ff）的刻度来指定红色、绿色和蓝色的值。数值越高，每种颜色的含量越多。'
- en: '`alpha` is similar to opacity (0 is transparent, 1 is solid).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha` 与不透明度类似（0 是透明的，1 是实心的）。'
- en: '`hue` represents 1 degree on a 360-degree color wheel, where 0 is red, 120
    is green, and 240 is blue.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hue` 代表在 360 度色轮上的 1 度，其中 0 是红色，120 是绿色，240 是蓝色。'
- en: '`saturation` is the intensity of the color from a 0% shade of gray to 100%
    full color.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saturation` 是从 0% 灰度到 100% 全色的颜色强度。'
- en: '`lightness` is a percentage between 0% and 100%. 0% is darker (closer to black),
    and 100% is light (closer to white).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightness` 是 0% 到 100% 之间的百分比。0% 是较暗的（接近黑色），100% 是较亮的（接近白色）。'
- en: You’ve seen `backgroundColor` applied in previous examples, so let’s take things
    a step further in the next example. To use your new skills to create something
    real, let’s start building the Profile Card. Right now, it won’t look like much,
    as you can see in [figure 4.4](#figure4.4)—it’s just a 300 × 400 colored rectangle.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在之前的示例中看到了 `backgroundColor` 的应用，所以让我们在下一个示例中更进一步。为了使用您的新技能创建一些真实的东西，让我们开始构建
    Profile Card。目前，它看起来不会太多，就像您在 [图 4.4](#figure4.4) 中看到的那样——它只是一个 300 × 400 的彩色矩形。
- en: '![c04_04.tif](Images/c04_04.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![c04_04.tif](Images/c04_04.png)'
- en: '[Figure 4.4](#figureanchor4.4) A simple 300 × 400 colored rectangle that forms
    the base of the Profile Card component'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.4](#figureanchor4.4) 一个简单的 300 × 400 彩色矩形，它是 Profile Card 组件的基础'
- en: The following listing shows the initial code. Don’t worry about the fact that
    most of it has nothing to do with styling. We’ll walk through each piece, but
    you need a foundation from which to start.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了初始代码。不要担心其中大部分与样式无关的事实。我们将逐一讲解每个部分，但您需要有一个起点。
- en: Listing 4.7 Initial framework for the Profile Card component
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 Profile Card 组件的初始框架
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first `View` component is the outermost element. It acts as a container
    around everything else. Its sole purpose is to center child components on the
    device’s display. The second `View` component will be the container for the Profile
    Card. For now, it’s a 300 × 400 colored rectangle.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `View` 组件是最外层的元素。它充当围绕其他所有内容的容器。它的唯一目的是在设备显示上居中子组件。第二个 `View` 组件将是 Profile
    Card 的容器。目前，它是一个 300 × 400 的彩色矩形。
- en: 4.2.2 Setting border properties
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 设置边框属性
- en: Applying a background color to a component definitely makes it stand out, but
    without a crisp border line delineating the edge of the component, it looks like
    the component is floating in space. A clear delineation between components will
    help users understand how to interact with your mobile application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 给组件应用背景颜色确实可以使它脱颖而出，但如果没有清晰的边框线来界定组件的边缘，它看起来就像是在空间中漂浮。组件之间的清晰界定将帮助用户理解如何与您的移动应用程序交互。
- en: 'Adding a border around a component is the best way to give screen elements
    a concrete, real feeling. There are quite a few `border` properties, but conceptually
    there are only four: `borderColor`, `borderRadius`, `borderStyle`, and `borderWidth`.
    These properties apply to the component as a whole.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件周围添加边框是给屏幕元素一个具体、真实感觉的最佳方式。有很多 `border` 属性，但从概念上讲，只有四个：`borderColor`、`borderRadius`、`borderStyle`
    和 `borderWidth`。这些属性适用于组件整体。
- en: 'For the color and width, there are individual properties for each side of the
    border: `borderTopColor`, `borderRightColor`, `borderBottomColor`, `borderLeftColor`,
    `borderTopWidth`, `borderRightWidth`, `borderBottomWidth`, and `borderLeftWidth`.
    For the border radius, there are properties for each corner: `borderTopRightRadius`,
    `borderBottomRightRadius`, `borderBottomLeftRadius`, and `borderTopLeftRadius`.
    But there’s only one `borderStyle`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于颜色和宽度，每个边都有单独的属性：`borderTopColor`、`borderRightColor`、`borderBottomColor`、`borderLeftColor`、`borderTopWidth`、`borderRightWidth`、`borderBottomWidth`
    和 `borderLeftWidth`。对于边框半径，每个角落都有属性：`borderTopRightRadius`、`borderBottomRightRadius`、`borderBottomLeftRadius`
    和 `borderTopLeftRadius`。但只有一个 `borderStyle`。
- en: Creating borders with the color, width and style properties
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用颜色、宽度和样式属性创建边框
- en: To set a `border`, you must first set `borderWidth`. `borderWidth` is the size
    of the border, and it’s always a number. You can either set a `borderWidth` that
    applies to the entire component or choose which `borderWidth` you want to set
    specifically (top, right, bottom, or left). You can combine these properties in
    many different ways to get the effect you like. See [figure 4.5](#figure4.5) for
    some examples.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`border`，你必须首先设置`borderWidth`。`borderWidth`是边框的大小，它始终是一个数字。你可以设置一个适用于整个组件的`borderWidth`，或者选择你想要具体设置的`borderWidth`（顶部、右侧、底部或左侧）。你可以以许多不同的方式组合这些属性，以获得你喜欢的效果。查看[图4.5](#figure4.5)以获取一些示例。
- en: '![c04_05.png](Images/c04_05.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![c04_05.png](Images/c04_05.png)'
- en: '[Figure 4.5](#figureanchor4.5) Examples of various combinations of border style
    settings'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.5](#figureanchor4.5) 边框样式设置的多种组合示例'
- en: As you can see, you can combine border styles to create combinations of border
    effects. The next listing shows how easy this is to do.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以组合边框样式以创建边框效果的组合。下一个列表显示了这是多么容易做到。
- en: Listing 4.8 Setting various border combinations
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 设置各种边框组合
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When only `borderWidth` is specified, `borderColor` defaults to `'black'` and
    `borderStyle` defaults to `'solid'`. If `borderWidth` or `borderColor` is set
    at the component level, those properties can be overridden by using a more specific
    property like `borderWidthLeft`; specificity takes precedence over generality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当只指定`borderWidth`时，`borderColor`默认为`'black'`，而`borderStyle`默认为`'solid'`。如果`borderWidth`或`borderColor`在组件级别被设置，这些属性可以通过使用更具体的属性如`borderWidthLeft`来覆盖；具体性优先于一般性。
- en: Using border radius to create shapes
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用边框半径创建形状
- en: Another border property that can be used to great effect is `borderRadius`.
    A lot of objects in the real world have straight edges, but seldom does a straight
    line convey any sense of style. You wouldn’t buy an automobile that looked like
    a box. You want your car to have nice curved lines that look sleek. Using the
    `borderRadius` style gives you the ability to add a bit of style to your applications.
    You can make many different, interesting shapes by adding curves in the right
    spots.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以产生良好效果的边框属性是`borderRadius`。现实世界中的许多物体都有直边，但很少有直线能传达任何风格感。你不会买一辆看起来像箱子的汽车。你希望你的车有漂亮的曲线，看起来流畅。使用`borderRadius`样式可以让你在应用中添加一些风格。通过在正确的位置添加曲线，你可以制作出许多不同、有趣的外形。
- en: With `borderRadius`, you can define how rounded border corners appear on elements.
    As you may suspect, `borderRadius` applies to the entire component. If you set
    `borderRadius` and don’t set one of the more specific values, like `borderTopLeftRadius`,
    all four corners will be rounded. Look at [figure 4.6](#figure4.6) to see how
    to round different borders to create cool effects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`borderRadius`，你可以定义元素上圆角边框的形状。正如你可能猜到的，`borderRadius`适用于整个组件。如果你设置了`borderRadius`但没有设置更具体的值，如`borderTopLeftRadius`，则所有四个角都会被圆化。查看[图4.6](#figure4.6)了解如何将不同的边框圆化以创建酷炫效果。
- en: '![c04_06.png](Images/c04_06.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![c04_06.png](Images/c04_06.png)'
- en: '[Figure 4.6](#figureanchor4.6) Examples of various border radius combinations.
    Example 1: a square with four rounded corners. Example 2: a square with the right
    two corners rounded, making a D shape. Example 3: a square with the opposite corners
    rounded, which looks like a leaf. Example 4: a square with a border radius equal
    to half the length of a side, which results in a circle.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.6](#figureanchor4.6) 各种边框半径组合的示例。示例1：四个角都圆化的正方形。示例2：右下两个角圆化，形成D形状。示例3：相对的两个角圆化，看起来像树叶。示例4：边框半径等于边长的一半，结果形成一个圆。'
- en: Creating the shapes in [figure 4.6](#figure4.6) is relatively simple, as shown
    in [listing 4.9](#listing4.9). Honestly, the trickiest part about this code is
    making sure you don’t make the text too big or too long. I’ll show you what I
    mean shortly, in [listing 4.10](#listing4.10).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建[图4.6](#figure4.6)中的形状相对简单，如[列表4.9](#listing4.9)所示。说实话，这段代码中最棘手的部分是确保文本不要太大或太长。我很快就会在[列表4.10](#listing4.10)中展示我的意思。
- en: Listing 4.9 Setting various border radius combinations
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 设置各种边框半径组合
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Pay particular attention to the style that centers the text. You got lucky
    by using `margin: 10`. If you used `padding: 10`, the background of the text component
    would occlude the underlying border stroke of the `View` component (see [figure
    4.7](#figure4.7)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '特别注意居中文本的样式。你很幸运使用了`margin: 10`。如果你使用的是`padding: 10`，文本组件的背景会遮挡`View`组件下层的边框描边（见[图4.7](#figure4.7)）。'
- en: '![c04_07.png](Images/c04_07.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![c04_07.png](Images/c04_07.png)'
- en: '[Figure 4.7](#figureanchor4.7) This is what [figure 4.6](#figure4.6) would
    look like if the centeredText style used padding: 10 instead of margin: 10 to
    position the text. The small circles highlight the points at which the bounding
    box of the Text component overlaps the border of the View component.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.7](#figureanchor4.7) 如果`centeredText`样式使用`padding: 10`而不是`margin: 10`来定位文本，[图4.6](#figure4.6)将看起来像这样。小圆圈突出了文本组件的边界框与视图组件边框重叠的点。'
- en: 'By default, a `Text` component inherits the background color of its parent
    component. Because the bounding box of the `Text` component is a rectangle, the
    background overlaps the nice rounded corners. Obviously, using the `margin` property
    solves the problem, but it’s also possible to remedy the situation another way.
    You could add `backgroundColor: ''transparent''` to the `centeredText` style.
    Making the text component’s background transparent allows the underlying border
    to show through and look normal again, as in figure 4.6.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，`Text`组件继承其父组件的背景颜色。因为`Text`组件的边界框是一个矩形，所以背景会重叠在漂亮的圆角上。显然，使用`margin`属性可以解决这个问题，但也可以用另一种方法来补救。你可以在`centeredText`样式中添加`backgroundColor:
    ''transparent''`。使文本组件的背景透明可以让底层的边框显示出来，看起来恢复正常，如图4.6所示。'
- en: '![c04_08.eps](Images/c04_08.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![c04_08.eps](Images/c04_08.png)'
- en: '[Figure 4.8](#figureanchor4.8) Incorporating border properties into the Profile
    Card component transforms the 300 × 400 colored rectangle into something more
    akin to what you want for the final Profile Card component.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.8](#figureanchor4.8) 将边框属性整合到“个人资料卡”组件中，将300 × 400的彩色矩形转换成更接近你最终想要的“个人资料卡”组件的样子。'
- en: Adding borders to your Profile Card component
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为你的“个人资料卡”组件添加边框
- en: With your newfound knowledge of border properties, you can almost complete the
    initial layout of the Profile Card component. Using only the border properties
    from the last section, you can transform the 300 × 400 colored rectangle into
    something that more closely resembles what you want. [Figure 4.8](#figure4.8)
    shows how far you can get with an image and the techniques you’ve learned so far.
    It includes an image to use as a placeholder for a person’s photo; you’ll find
    it in the source code. But the circle is created by manipulating the border radius
    as described in the previous examples.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过你对边框属性的新认识，你几乎可以完成“个人资料卡”组件的初始布局。仅使用上一节中的边框属性，你就可以将300 × 400的彩色矩形转换成更接近你想要的样子。[图4.8](#figure4.8)展示了你可以通过图像和迄今为止学到的技术达到的程度。它包括一个用作个人照片占位符的图像；你可以在源代码中找到它。但圆圈是通过操纵边框半径来创建的，正如前例中所述。
- en: Clearly there are some layout issues with the Profile Card, but you’re almost
    there. We’ll discuss how to use the margin and padding styles in the next section
    to get everything aligned correctly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，“个人资料卡”有一些布局问题，但你几乎就要完成了。我们将在下一节讨论如何使用边距和填充样式来正确地对齐所有内容。
- en: Listing 4.10 Incorporating border properties into the Profile Card
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 将边框属性整合到“个人资料卡”
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The differences between [listing 4.10](#listing4.10) and the previous Profile
    Card code ([listing 4.7](#listing4.7)) have been bolded to highlight the incremental
    changes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4.10](#listing4.10) 与之前的“个人资料卡”代码([列表4.7](#listing4.7))之间的差异已被加粗，以突出增量更改。'
- en: 4.2.3 Specifying margins and padding
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 指定边距和填充
- en: '![c04_09.eps](Images/c04_09.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![c04_09.eps](Images/c04_09.png)'
- en: '[Figure 4.9](#figureanchor4.9) A common depiction of how margins, padding,
    and borders interrelate'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.9](#figureanchor4.9) 常见的边距、填充和边框相互关系图示'
- en: You could explicitly position every component on the screen and lay it out exactly
    like you want, but that would be extremely tedious if the layout needed to be
    responsive to user actions. It makes more sense to position items relative to
    one another, so if you move one component, the other components can move in response
    based on their relative positions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以明确地将每个组件放置在屏幕上，并按照你想要的布局排列，但如果布局需要响应用户操作，这将非常繁琐。将项目相对于彼此定位更有意义，这样如果你移动一个组件，其他组件可以根据它们的相对位置做出响应。
- en: The margin style allows you to define this relationship between components.
    The padding style lets you define the relative position of a component to its
    border. Using these properties together provides a great deal of flexibility when
    laying out components. You’ll use these properties every day, so it’s important
    to understand what they mean and do.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 边距样式允许您定义组件之间的关系。填充样式让您定义组件相对于其边框的相对位置。使用这些属性一起提供在布局组件时的很大灵活性。您将每天都会使用这些属性，因此理解它们的意义和作用非常重要。
- en: Conceptually, margins and padding work exactly the same as they do in CSS. The
    customary depiction of how margins and padding relate to borders and the content
    area still applies (see [figure 4.9](#figure4.9)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，边距和填充与CSS中的工作方式完全相同。边距和填充与边框和内容区域的关系的传统描述仍然适用（见[图4.9](#figure4.9)）。
- en: Functionally, you’re likely to run into bugs when dealing with margins and padding.
    You might be tempted to call them “quirks,” but either way they’re a pain. For
    the most part, margins on `View` components behave reasonably well and work across
    iOS and Android. Padding tends to work a little differently between OSs. At the
    time of writing, padding text components in an Android environment doesn’t work
    at all; I suspect that will change in an upcoming release.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理边距和填充时，您可能会遇到功能性的问题。您可能会倾向于称它们为“怪癖”，但无论如何它们都是麻烦的。就大多数情况而言，`View`组件上的边距表现良好，并在iOS和Android上工作。填充在操作系统之间的工作方式略有不同。在撰写本文时，在Android环境中填充文本组件根本不起作用；我怀疑这将在即将发布的版本中改变。
- en: Using the margin property
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用边距属性
- en: When laying out components, one of the first problems to solve is how far the
    components are from one another. To avoid specifying a distance for each component,
    you need a way to specify a relative position. The `margin` property allows you
    to define the perimeter of the component, which determines how far an element
    is from the previous or parent component. Articulating the layout this way allows
    the container to figure out where the components should be positioned with respect
    to one another rather than you having to calculate the position of every single
    component.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局组件时，首先要解决的问题之一是组件之间的距离。为了避免为每个组件指定一个距离，您需要一种指定相对位置的方法。`margin`属性允许您定义组件的周界，这决定了元素与上一个或父组件的距离。以这种方式阐述布局允许容器确定组件相对于彼此的位置，而不是您必须计算每个组件的位置。
- en: 'The available margin properties are `margin`, `marginTop`, `marginRight`, `marginBottom`,
    and `marginLeft`. If only the general `margin` property is set, without another,
    more-specific value such as `marginLeft` or `marginTop`, then that value applies
    to all sides of the component (top, right, bottom, and left). If both `margin`
    and a more-specific `margin` property are specified (for example, `marginLeft`),
    then the more-specific `margin` property takes precedence. It works exactly the
    same as the border properties. Let’s apply some of these styles: see [figure 4.10](#figure4.10).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的边距属性有`margin`、`marginTop`、`marginRight`、`marginBottom`和`marginLeft`。如果只设置了通用的`margin`属性，而没有其他更具体的值，如`marginLeft`或`marginTop`，则该值应用于组件的所有侧面（顶部、右侧、底部和左侧）。如果同时指定了`margin`和更具体的`margin`属性（例如`marginLeft`），则更具体的`margin`属性具有优先权。它的工作方式与边框属性完全相同。让我们应用一些这些样式：见[图4.10](#figure4.10)。
- en: '![c04_10.eps](Images/c04_10.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![c04_10.eps](Images/c04_10.png)'
- en: '[Figure 4.10](#figureanchor4.10) Examples of applying margins to components.
    In iOS, example A has no margins applied. Example B has a top margin applied.
    Example C has top and left margins. Example D has both negative top and negative
    left margins. In Android, negative margins behave a bit differently: the component
    is clipped by the parent container.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.10](#figureanchor4.10) 应用边距到组件的示例。在iOS中，示例A没有应用边距。示例B应用了顶部边距。示例C应用了顶部和左侧边距。示例D应用了负顶部和负左侧边距。在Android中，负边距的行为略有不同：组件被父容器裁剪。'
- en: The margins all position the components as expected, but notice how the Android
    device clips the component when negative margins are applied. If you plan to support
    both iOS and Android, test on each device from the beginning of your project.
    Don’t develop on iOS and think everything you styled will behave the same on Android.
    [Listing 4.11](#listing4.11) shows the code for the examples in figure 4.10.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有边距都按预期定位组件，但请注意，当应用负边距时，Android 设备会裁剪组件。如果你计划同时支持 iOS 和 Android，从项目开始就应在每个设备上进行测试。不要只在
    iOS 上开发，并认为你设计的样式在 Android 上会有相同的行为。[列表 4.11](#listing4.11) 展示了图 4.10 中示例的代码。
- en: Listing 4.11 Applying various margins to components
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 将各种边距应用于组件
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the padding property
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用填充属性
- en: You can think of margins as the distance between elements, but padding represents
    the space between the content of the element and the border of the same element.
    When padding is specified, it allows the content of the component to not be flush
    against the border. In [figure 4.9](#figure4.9), the `backgroundColor` property
    bleeds through the component’s edges up to the border, which is the space defined
    by `padding`. The available properties available for `padding` are `padding`,
    `paddingLeft`, `paddingRight`, `paddingTop`, and `paddingBottom`. If only the
    main `padding` property is set without another, more-specific value such as `paddingLeft`
    or `paddingTop`, then that value is passed to all sides of the component (top,
    right, bottom, and left). If both `padding` and a more-specific `padding` property
    are specified, such as `paddingLeft`, then the more-specific `padding` property
    takes precedence. This behavior is exactly like borders and margins.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将边距视为元素之间的距离，但填充表示元素内容与其边框之间的空间。当指定填充时，它允许组件的内容不与边框对齐。在 [图 4.9](#figure4.9)
    中，`backgroundColor` 属性从组件边缘渗透到边框，这是由 `padding` 定义的空隙。可用于 `padding` 的属性有 `padding`、`paddingLeft`、`paddingRight`、`paddingTop`
    和 `paddingBottom`。如果只设置了主要的 `padding` 属性而没有其他更具体的值，如 `paddingLeft` 或 `paddingTop`，则该值将传递到组件的所有侧面（顶部、右侧、底部和左侧）。如果同时指定了
    `padding` 和更具体的 `padding` 属性，如 `paddingLeft`，则更具体的 `padding` 属性具有优先级。这种行为与边框和边距完全相同。
- en: Rather than create a new example to show how padding is different than margins,
    let’s reuse the code from [listing 4.11](#listing4.11) and make a few tweaks.
    Change the `margin` styles on the example components to `padding` styles, and
    add a border around the `Text` components and change their background color. [Figure
    4.11](#figure4.11) shows what you’ll end up with.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不如创建一个新的示例来展示填充与边距的不同，而是重用 [列表 4.11](#listing4.11) 中的代码并进行一些调整。将示例组件上的 `margin`
    样式更改为 `padding` 样式，并在 `Text` 组件周围添加边框并更改它们的背景颜色。[图 4.11](#figure4.11) 展示了最终的结果。
- en: Listing 4.12 Modifying [listing 4.11](#listing4.11) to replace margins with
    padding
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 将 [列表 4.11](#listing4.11) 修改为用填充替换边距
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![c04_11.eps](Images/c04_11.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![c04_11.eps](Images/c04_11.png)'
- en: '[Figure 4.11](#figureanchor4.11) Changing the margin styles from the previous
    example to padding styles. Example A, with no padding, looks the same as when
    no margins are applied. Example B shows the component with paddingTop applied.
    Example C is the same, but it also applies paddingLeft. Example D applies negative
    padding values to paddingTop and paddingLeft, which are ignored.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.11](#figureanchor4.11) 将前一个示例中的边距样式更改为填充样式。示例 A 没有填充，看起来与没有应用边距时相同。示例
    B 显示了应用了 paddingTop 的组件。示例 C 与示例 B 相同，但它还应用了 paddingLeft。示例 D 将负填充值应用于 paddingTop
    和 paddingLeft，这些值将被忽略。'
- en: Unlike margins, which specify the space between the component and its parent
    component, padding applies from the border of the component to its children. In
    example B, padding is calculated from the top border, which *pushes* the `Text`
    component B down from the top border. Example C adds a `paddingLeft` value, which
    also *pushes* the `Text` component C inward from the left border. Example D applies
    negative padding values to `paddingTop` and `paddingLeft`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与指定组件与其父组件之间空间的不同，填充是从组件的边框应用到其子组件。在示例 B 中，填充是从顶部边框计算的，这会将 `Text` 组件 B 从顶部边框向下推。示例
    C 添加了一个 `paddingLeft` 值，这也会将 `Text` 组件 C 从左侧边框向内推。示例 D 将负填充值应用于 `paddingTop` 和
    `paddingLeft`。
- en: A few interesting observations can be made. Example B and example C are both
    clipped on the Android device. Example C’s `Text` component’s width is compressed,
    and the negative values for `padding` are ignored in example D.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以得出一些有趣的观察。示例 B 和示例 C 在 Android 设备上都被裁剪了。示例 C 的 `Text` 组件的宽度被压缩，示例 D 中的 `padding`
    的负值被忽略。
- en: 4.2.4 Using position to place components
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 使用位置放置组件
- en: So far, everything we’ve looked at has been positioned relative to another component,
    which is the default layout position. Sometimes it’s beneficial to take advantage
    of absolute positioning and place a component exactly where you want it. The implementation
    of the `position` style in React Native is similar to CSS, but there aren’t as
    many options. By default, all elements are laid out relative to one another. If
    `position` is set to `absolute`, then the element is laid out relative to its
    parent. The available properties for `position` are `relative` (the default position)
    and `absolute`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的一切都是相对于另一个组件定位的，这是默认的布局位置。有时利用绝对定位并将组件放置在您想要的确切位置是有益的。React Native
    中 `position` 样式的实现与 CSS 类似，但选项较少。默认情况下，所有元素都是相对于彼此布局的。如果 `position` 设置为 `absolute`，则元素相对于其父元素进行布局。`position`
    可用的属性是 `relative`（默认位置）和 `absolute`。
- en: 'CSS has other values, but those are the only two in React Native. When using
    `absolute` positioning, the following properties are also available: `top`, `right`,
    `bottom`, and `left`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 有其他值，但在 React Native 中只有这两个。当使用 `absolute` 定位时，以下属性也是可用的：`top`、`right`、`bottom`
    和 `left`。
- en: Let’s look at a simple example to demonstrate the difference between relative
    and absolute positioning. In CSS, positioning can get much more confusing, but
    in React Native the “everything has relative positioning by default” makes it
    much easier to position items. In [figure 4.12](#figure4.12), blocks A, B, and
    C are laid out relative to one another in a row. Without any margin or padding,
    they’re lined up one after another. Block D is a sibling to the ABC row of blocks,
    meaning the main container is the parent container for the ABC row and block D.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的示例来演示相对定位和绝对定位之间的区别。在 CSS 中，定位可能会变得非常复杂，但在 React Native 中，“默认情况下所有内容都具有相对定位”使得定位项目变得容易得多。在
    [图 4.12](#figure4.12) 中，块 A、B 和 C 在一行中相对彼此布局。没有任何边距或填充，它们一个接一个地排列。Block D 是 ABC
    行的兄弟，这意味着 ABC 行和 Block D 的父容器是主容器。
- en: 'Block D is set to `{position: ''absolute'', right: 0, bottom: 0}`, so it’s
    positioned in the lower-right corner of its container. Block E is also set to
    `{position: ''absolute'', right: 0, bottom: 0}`, but its parent container is block
    B, which means block E is positioned absolutely but with respect to block B. Block
    E appears in the lower-right corner of block B, instead. [Listing 4.13](#listing4.13)
    shows the code for this example.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'Block D 被设置为 `{position: ''absolute'', right: 0, bottom: 0}`, 因此它被定位在其容器右下角。Block
    E 也被设置为 `{position: ''absolute'', right: 0, bottom: 0}`, 但它的父容器是 block B，这意味着
    block E 是相对于 block B 绝对定位的。相反，Block E 出现在 block B 的右下角。[列表 4.13](#listing4.13)
    展示了这个示例的代码。'
- en: '![c04_12.png](Images/c04_12.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![c04_12.png](Images/c04_12.png)'
- en: '[Figure 4.12](#figureanchor4.12) An example showing blocks A, B, and C laid
    out relative to one another. Block D has an absolute position of right: 0 and
    bottom: 0\. Block E also has an absolute position of right: 0 and bottom: 0, but
    its parent is block B and not the main container, whereas D’s parent was the main
    container.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.12](#figureanchor4.12) 一个显示块 A、B 和 C 相对彼此布局的示例。Block D 有绝对位置 right: 0
    和 bottom: 0。Block E 也有绝对位置 right: 0 和 bottom: 0，但它的父容器是 block B 而不是主容器，而 D 的父容器是主容器。'
- en: Listing 4.13 Relative and absolute positioning comparison
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 相对和绝对定位比较
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’re finished with the fundamentals of styling `View` components. You’ve learned
    about some layout techniques: margins, padding, and position. Let’s revisit the
    Profile Card component and fix the pieces that aren’t yet laid out properly.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `View` 组件的基本样式。你已经了解了一些布局技术：边距、填充和位置。让我们回顾一下 Profile Card 组件，并修复那些还没有正确布局的部分。
- en: 4.2.5 Profile Card positioning
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 Profile Card 定位
- en: The following listing has the code changes that need to be made to [listing
    4.10](#listing4.10) to space the circle and user image properly and center everything.
    [Figure 4.13](#figure4.13) shows the result.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了需要修改 [列表 4.10](#listing4.10) 的代码，以正确地间隔圆圈和用户图像，并使一切居中。[图 4.13](#figure4.13)
    展示了结果。
- en: Listing 4.14 Modifying Profile Card styles to fix the layout
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 修改 Profile Card 样式以修复布局
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![c04_13.png](Images/c04_13.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![c04_13.png](Images/c04_13.png)'
- en: '[Figure 4.13](#figureanchor4.13) The Profile Card component after all the View
    components have been lined up properly'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.13](#figureanchor4.13) 在所有`View`组件正确排列后的个人资料卡组件'
- en: 'Now, the major `View` components for the Profile Card are in place. By using
    the techniques discussed so far, you’ve built a nice-looking foundation for the
    component, but you’re not finished. You need to add information about the person:
    name, occupation, and a brief profile description. All that information is text
    based, so the next thing you’ll learn is how to style `Text` components.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，个人资料卡的`View`组件已经就位。通过使用到目前为止讨论的技术，你已经为组件构建了一个不错的基座，但你还没有完成。你需要添加关于这个人的信息：姓名、职业和简短的个人简介。所有这些信息都是基于文本的，所以接下来你将学习如何对`Text`组件进行样式设计。
- en: 4.3 Styling Text components
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 文本组件的样式
- en: In this section, we’ll discuss how to style `Text` components. After you have
    a working knowledge of how to make text look great, we’ll take another look at
    the Profile Card and add some information about the user. [Figure 4.14](#figure4.14)
    is the finished Profile Card component with the user’s name and occupation and
    a brief profile description. But before we revisit the Profile Card, let’s look
    at the styling techniques that will enable you to finish building it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何对`Text`组件进行样式设计。在你掌握了如何使文本看起来很棒之后，我们将再次查看个人资料卡并添加一些关于用户的信息。[图4.14](#figure4.14)是带有用户姓名、职业和简短个人描述的完成后的个人资料卡组件。但在我们重新审视个人资料卡之前，让我们看看将使你能够完成构建它的样式技术。
- en: '![c04_14.png](Images/c04_14.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![c04_14.png](Images/c04_14.png)'
- en: '[Figure 4.14](#figureanchor4.14) The completed Profile Card with the user’s
    name and occupation and a brief profile description'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.14](#figureanchor4.14) 带有用户姓名、职业和简短个人描述的完成后的个人资料卡'
- en: 4.3.1 Text components vs. View components
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 文本组件与View组件对比
- en: With the exception of flex properties, which we have yet to cover, most of the
    styles applicable to `View` elements will also work as expected with `Text` elements.
    `Text` elements can have borders and backgrounds and are affected by layout properties
    like `margin`, `padding`, and `position`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们尚未涉及的弹性属性外，大多数适用于`View`元素的样式也可以在`Text`元素上按预期工作。`Text`元素可以有边框和背景，并且会受到布局属性如`margin`、`padding`和`position`的影响。
- en: The reverse can’t be said. Most of the styles `Text` elements can use won’t
    work for `View` elements, which makes perfect sense. If you’ve ever used a word
    processor, you know you can use different fonts for text and change the font color;
    that you can resize, bold, and italicize the text; and that you can apply decorations
    like underlines.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来则不然。大多数`Text`元素可以使用的样式对`View`元素不起作用，这是完全合理的。如果你曾经使用过文字处理器，你知道你可以为文本使用不同的字体并更改字体颜色；你可以调整文本大小、加粗和斜体；你还可以应用下划线等装饰。
- en: Before we get into text-specific styling, let’s talk about color, a style common
    to both `Text` and `View` components. Then you’ll use color along with everything
    you’ve learned thus far to start adding text to the Profile Card.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入文本特定样式之前，让我们谈谈颜色，这是`Text`和`View`组件共有的样式。然后你将使用颜色以及迄今为止所学的一切来开始向个人资料卡添加文本。
- en: Coloring text
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文本着色
- en: The `color` property applies to `Text` components in exactly the same way as
    it does to `View` components. As expected, this property specifies the color of
    the text in a `Text` element. All the color formats listed in [table 4.1](#table4.1)
    still apply—even `transparent`, although I can’t imagine how that’s of benefit.
    By default, the text color is black.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`color`属性以与`View`组件完全相同的方式应用于`Text`组件。正如预期的那样，此属性指定了`Text`元素中文本的颜色。所有在[表4.1](#table4.1)中列出的颜色格式仍然适用——甚至包括`transparent`，尽管我想象不出这有什么好处。默认情况下，文本颜色为黑色。'
- en: '[Figure 4.14](#figure4.14) showed three `Text` elements in the Profile Card:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.14](#figure4.14)展示了个人资料卡中的三个`Text`元素：'
- en: Name
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名
- en: Occupation
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 职业
- en: Profile description
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人简介
- en: Using what you’ve already learned, you can center and position the text, change
    the color of the name from black to white, and add a simple border to separate
    the occupation from the description. [Figure 4.15](#figure4.15) shows what you’ll
    end up with by applying techniques in your arsenal.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你已经学到的知识，你可以居中文本、定位文本，将姓名的颜色从黑色改为白色，并添加一个简单的边框来区分职业和描述。[图4.15](#figure4.15)展示了通过应用你的工具库中的技术你最终会得到什么。
- en: By this point, you should be able to follow along with [listing 4.15](#listing4.15)
    and understand everything that’s going on. Don’t feel bad if you don’t—if necessary,
    go back and re-read the appropriate sections.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够跟随[列表 4.15](#listing4.15) 并理解所有发生的事情。如果你没有跟上，不要感到难过——如果需要，可以回过头去重新阅读适当的章节。
- en: '![c04_15.png](Images/c04_15.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![c04_15.png](Images/c04_15.png)'
- en: '[Figure 4.15](#figureanchor4.15) The Profile Card with Text elements added
    using text styling defaults and the color property for the name set to white'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.15](#figureanchor4.15) 使用文本样式默认值和将名称的颜色属性设置为白色添加文本元素的个人资料卡'
- en: Listing 4.15 Adding text to the Profile Card
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 向个人资料卡添加文本
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, you have all the content for the Profile Card, but it’s pretty
    plain. In the next couple of sections, we’ll talk about how to set font properties
    and add decorative styles to text.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你已经拥有了个人资料卡的完整内容，但它看起来相当简单。在接下来的几节中，我们将讨论如何设置字体属性并为文本添加装饰样式。
- en: 4.3.2 Font styles
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 字体样式
- en: 'If you’ve ever used a word processor or written an email with rich text capabilities,
    you’ve been able to change fonts, increase or decrease the font size, bold or
    italicize the text, and so on. These are the same styles you’ll learn how to change
    in this section. By adjusting these styles, you can make text more compelling
    and attractive to the end user. We’ll discuss these properties: `fontFamily`,
    `fontSize`, `fontStyle`, and `fontWeight`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过文字处理软件或编写过具有丰富文本功能的电子邮件，你曾经能够更改字体、增加或减少字体大小、加粗或斜体化文本等。这些是你将在本节中学到的如何更改的样式。通过调整这些样式，你可以使文本对最终用户更具吸引力和吸引力。我们将讨论以下属性：`fontFamily`、`fontSize`、`fontStyle`
    和 `fontWeight`。
- en: Specifying a font family
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指定字体族
- en: The `fontFamily` property is deceptively simple. If you stick with the defaults,
    it’s easy; but if you want to use a specific font, you can run into trouble quickly.
    Both iOS and Android come with a default set of fonts. For iOS, a large number
    of available fonts can be implemented out of the box. For Android, there’s Roboto,
    a monospace font, and some simple serif and sans serif variants. For a full list
    of Android and iOS fonts available out of the box in React Native, go to [https://github.com/dabit3/react-native-fonts](https://github.com/dabit3/react-native-fonts).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`fontFamily` 属性看似简单。如果你坚持使用默认值，那么很容易；但如果你想使用特定的字体，你可能会很快遇到麻烦。iOS 和 Android
    都自带一组默认字体。对于 iOS，大量可用的字体可以开箱即用。对于 Android，有 Roboto，一个等宽字体，以及一些简单的衬线和无衬线变体。要获取
    React Native 中开箱即用的 Android 和 iOS 字体的完整列表，请访问 [https://github.com/dabit3/react-native-fonts](https://github.com/dabit3/react-native-fonts)。'
- en: 'If you wanted to use a monospaced font in an application, you couldn’t specify
    either of the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在应用程序中使用等宽字体，你不能指定以下任何一个：
- en: '`fontFamily: ''monospace''`—The `''monospace''` option isn’t supported on iOS,
    so on that platform you’ll get the error “Unrecognized font family `''`monospace`''`.”
    But on Android, the font will render correctly without any problems. Unlike CSS,
    you can’t supply multiple fonts to the `fontFamily` property.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fontFamily: ''monospace''`——iOS 上不支持 `''monospace''` 选项，因此在该平台上你会得到错误“未识别的字体族
    `''monospace''`。”但在 Android 上，字体将正确渲染而没有任何问题。与 CSS 不同，你不能向 `fontFamily` 属性提供多个字体。'
- en: '`fontFamily: ''American Typewriter, monospace''`—You’ll again get an error
    on iOS, “Unrecognized font family `''`American Typewriter, monospace`''`.” But
    on Android, when you supply a font it doesn’t support, it falls back to the default.
    That might not be true in every version of Android, but suffice it to say neither
    approach will work.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fontFamily: ''American Typewriter, monospace''`——你会在 iOS 上再次遇到错误，“未识别的字体族
    `''American Typewriter, monospace''`。”但在 Android 上，当你提供一个它不支持的字体时，它会回退到默认字体。这可能在
    Android 的每个版本中都不一定成立，但可以肯定的是，这两种方法都不会奏效。'
- en: If you want to use different fonts, you’ll have to use React Native’s `Platform`
    component. Well discuss `Platform` in more detail in chapter 10, but I want to
    introduce it, so you can see how to work around this dilemma. [Figure 4.16](#figure4.16)
    shows the American Typewriter font rendered on iOS and the generic monospace font
    used on Android.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用不同的字体，你将不得不使用 React Native 的 `Platform` 组件。我们将在第 10 章中更详细地讨论 `Platform`，但我想要介绍它，这样你就可以看到如何解决这个困境。[图
    4.16](#figure4.16) 显示了在 iOS 上渲染的 American Typewriter 字体和在 Android 上使用的通用等宽字体。
- en: The following listing shows the code that produced this example. Pay attention
    to how the `fontFamily` is set using `Platform.select`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了生成此示例的代码。请注意，`fontFamily` 是如何使用 `Platform.select` 设置的。
- en: '![c04_16.png](Images/c04_16.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![c04_16.png](Images/c04_16.png)'
- en: '[Figure 4.16](#figureanchor4.16) An example of rendering monospaced fonts on
    both iOS and Android'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.16](#figureanchor4.16) 在 iOS 和 Android 上渲染等宽字体的示例'
- en: Listing 4.16 Displaying monospaced fonts on iOS and Android
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 在 iOS 和 Android 上显示等宽字体
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example shows how to select fonts based on the OS, but the set of fonts
    at your disposal is still limited to what comes with React Native out of the box.
    You can add custom fonts to a project using font files (TTF, OTF, and so on) and
    linking them to your application as assets. In theory the process is simple, but
    success varies greatly depending on the OS and the font files being used. I want
    you to know it’s possible to do, but if you want to give it try, break out your
    search engine of choice and look into `react-native link`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何根据操作系统选择字体，但您可用的字体集合仍然仅限于 React Native 默认提供的字体。您可以使用字体文件（TTF、OTF 等）将自定义字体添加到项目中，并将它们作为资源链接到您的应用程序中。理论上这个过程很简单，但成功与否很大程度上取决于操作系统和所使用的字体文件。我想让您知道这是可行的，但如果您想尝试，请打开您选择的搜索引擎并查找
    `react-native link`。
- en: Adjusting text size with fontSize
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `fontSize` 调整文本大小
- en: '`fontSize` is pretty simple: it adjusts the size of the text in a `Text` element.
    You’ve used this quite a bit already, so we won’t go into much detail other than
    the fact that the default `fontSize` is 14.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`fontSize` 非常简单：它调整 `Text` 元素中文字的大小。您已经使用过很多次了，所以我们不会深入细节，除了默认的 `fontSize`
    是 14。'
- en: Changing font styles
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改字体样式
- en: You can use `fontStyle` to change the font style to italic. The default is `'normal'`.
    The only two options at this moment are `'normal'` and `'italic'`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `fontStyle` 将字体样式更改为斜体。默认值为 `'normal'`。目前只有两个选项：`'normal'` 和 `'italic'`。
- en: Specifying font weights
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指定字体粗细
- en: '`fontWeight` refers to the thickness of the font. The default is `''normal''`
    or `''400''`. The options for `fontWeight` are `''normal''`, `''bold''`, `''100''`,
    `''200''`, `''300''`, `''400''`, `''500''`, `''600''`, `''700''`, `''800''`, and
    `''900`''. The smaller the value, the lighter/thinner the text. The larger the
    value, the thicker/bolder the text.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`fontWeight` 指的是字体的粗细。默认值为 `''normal''` 或 `''400''`。`fontWeight` 的选项有 `''normal''`,
    `''bold''`, `''100''`, `''200''`, `''300''`, `''400''`, `''500''`, `''600''`,
    `''700''`, `''800''`, 和 `''900''`。数值越小，文字越细；数值越大，文字越粗。'
- en: Now that you know how to change the font styles, you can almost finish the Profile
    Card component. Let’s change some font styles and see how close you can get to
    the final product, as shown in [figure 4.17](#figure4.17). The next listing shows
    how to change the styles from [listing 4.16](#listing4.16) to achieve this look.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何更改字体样式，您几乎可以完成个人资料卡组件。让我们更改一些字体样式，看看您能接近最终产品到什么程度，如图 4.17 所示。下一列表将展示如何从
    [列表 4.16](#listing4.16) 更改样式以实现这种外观。
- en: Listing 4.17 Setting font styles for Text elements in the Profile Card
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 在个人资料卡中为文本元素设置字体样式
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![c04_17.png](Images/c04_17.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![c04_17.png](Images/c04_17.png)'
- en: '[Figure 4.17](#figureanchor4.17) The Profile Card with font styles applied
    to the Name, Occupation, and Description texts'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.17](#figureanchor4.17) 应用了字体样式的姓名、职业和描述文本的个人资料卡'
- en: Modifying the font styles for the name, occupation, and description text helps
    differentiate each of the sections, but the name still doesn’t stand out much.
    The next section covers some decorative ways to style text and how to use those
    techniques to make the name stand out in the Profile Card.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 修改姓名、职业和描述文本的字体样式有助于区分各个部分，但姓名仍然不够突出。下一节将介绍一些装饰性的文本样式以及如何使用这些技术使姓名在个人资料卡中更加突出。
- en: 4.3.3 Using decorative text styles
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 使用装饰性文本样式
- en: In this section, you’ll go beyond the basics of changing font styles and start
    applying decorative styles to text. I’ll show you how to do things like underline
    and strikethrough text and add drop shadows. These techniques can add a lot of
    visual variety to applications and help text elements stand out from one another.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将超越更改字体样式的基础，并开始将装饰性样式应用于文本。我将向您展示如何进行下划线和删除线文本，以及添加阴影等技术。这些技术可以为应用程序添加很多视觉多样性，并帮助文本元素彼此区分。
- en: 'Here are the properties we’ll cover in this section:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下属性：
- en: '*iOS and Android* —`lineHeight`, `textAlign`, `textDecorationLine`, `textShadowColor`,
    `textShadowOffset`, and `textShadowRadius`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*iOS 和 Android* —`lineHeight`, `textAlign`, `textDecorationLine`, `textShadowColor`,
    `textShadowOffset`, 和 `textShadowRadius`'
- en: '*Android only* —`textAlignVertical`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仅限 Android* —`textAlignVertical`'
- en: '*iOS only* —`letterSpacing`, `textDecorationColor`, `textDecorationStyle`,
    and `writingDirection`.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仅限 iOS* —`letterSpacing`, `textDecorationColor`, `textDecorationStyle`, 和
    `writingDirection`。'
- en: Notice that some of the properties only apply to one OS or another. Some values
    that can be assigned to the properties are also OS-specific. It’s important to
    keep this in mind, especially if you’re relying on a specific style to highlight
    a particular element of text on the screen.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些属性仅适用于一个操作系统或另一个。可以分配给属性的某些值也是操作系统特定的。这一点很重要，尤其是如果您依赖于特定的样式来突出屏幕上特定的文本元素。
- en: Specifying height of text elements
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指定文本元素的高度
- en: '`lineHeight` specifies the height of the `Text` element. [Figure 4.18](#figure4.18)
    and [listing 4.18](#listing4.18) show an example of how this behaves differently
    on iOS versus Android. A `lineHeight` of 100 is applied to the Text B element:
    the height of that line is significantly greater than the others. Also notice
    how iOS and Android position the text within the line differently. On Android,
    the text is positioned at the bottom of the line.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineHeight` 指定 `Text` 元素的高度。[图 4.18](#figure4.18) 和 [列表 4.18](#listing4.18)
    展示了在 iOS 和 Android 上这种行为的不同。将 100 的 `lineHeight` 应用到 Text B 元素：该行的长度明显大于其他行。同时请注意
    iOS 和 Android 在行内定位文本的不同方式。在 Android 上，文本位于行的底部。'
- en: '![c04_18.tif](Images/c04_18.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![c04_18.tif](Images/c04_18.png)'
- en: '[Figure 4.18](#figureanchor4.18) Example of using lineHeight on iOS and Android.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.18](#figureanchor4.18) 在 iOS 和 Android 中使用 lineHeight 的示例。'
- en: Listing 4.18 Applying `lineHeight` to a `Text` element in iOS and Android
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 在 iOS 和 Android 中将 `lineHeight` 应用到 `Text` 元素
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Aligning text horizontally
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 水平对齐文本
- en: '`textAlign` refers to how the text in the element will be horizontally aligned.
    The options for `textAlign` are `''auto''`, `''center''`, `''right''`, `''left''`,
    and `''justify''` (`''justify''` is iOS only).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`textAlign` 指的是元素中文本的水平对齐方式。`textAlign` 的选项有 `''auto''`、`''center''`、`''right''`、`''left''`
    和 `''justify''`（仅限 iOS）。'
- en: Underlining text or adding lines through text
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为文本添加下划线或贯穿线
- en: Use the `textDecorationLine` property to add either an underline or a line through
    the given text. The options for `textDecorationLine` are `'none'`, `'underline'`,
    `'line-through'`, and `'underline line-through'`. The default value is `'none'`.
    When you specify `'underline line-through'`, a single space separates the values
    in quotes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `textDecorationLine` 属性为给定文本添加下划线或贯穿线。`textDecorationLine` 的选项有 `'none'`、`'underline'`、`'line-through'`
    和 `'underline line-through'`。默认值是 `'none'`。当您指定 `'underline line-through'` 时，引号中的值由单个空格分隔。
- en: Text-decoration styles (iOS only)
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文本装饰样式（仅限iOS）
- en: iOS supports several text-decoration styles that Android doesn’t. The first
    is `textDecorationColor`, which allows you to set a color for `textDecorationLine`.
    iOS also supports styling the line itself. On Android, the line is always solid,
    but on iOS `textDecorationStyle` lets you specify `'solid'`, `'double'`, `'dotted'`,
    and `'dashed'`. Android will ignore these additional styles.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 支持一些 Android 不支持的文本装饰样式。第一个是 `textDecorationColor`，它允许您为 `textDecorationLine`
    设置颜色。iOS 还支持对线条本身进行样式化。在 Android 上，线条始终是实线，但在 iOS 上 `textDecorationStyle` 允许您指定
    `'solid'`、`'double'`、`'dotted'` 和 `'dashed'`。Android 将忽略这些额外的样式。
- en: 'To use the additional iOS decoration styles, specify them in conjunction with
    the primary `textDecorationLine` style. For example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用额外的 iOS 装饰样式，请与主要的 `textDecorationLine` 样式一起指定。例如：
- en: '[PRE21]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding shadows to text
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为文本添加阴影
- en: 'You can use the `textShadowColor`, `textShadowOffset`, and `textShadowRadius`
    properties to add a shadow to a `Text` element. To create a shadow, you need to
    specify three things:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `textShadowColor`、`textShadowOffset` 和 `textShadowRadius` 属性为 `Text` 元素添加阴影。要创建阴影，您需要指定三件事：
- en: The color
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色
- en: The offset
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量
- en: The radius
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半径
- en: 'The offset specifies the position of the shadow relative to the component casting
    the shadow. The radius basically defines how blurry the shadow appears. You can
    specify a text shadow like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量指定了阴影相对于投掷阴影的组件的位置。半径基本上定义了阴影的模糊程度。您可以指定一个文本阴影如下：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Controlling letter spacing (iOS only)
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制字母间距（仅限 iOS）
- en: '`letterSpacing` specifies the spacing between text characters. It’s not something
    you’ll use every day, but it can produce some interesting visual effects. Keep
    in mind that it’s iOS only, so use it if you need it.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`letterSpacing` 指定文本字符之间的间距。这不是您每天都会使用的东西，但它可以产生一些有趣的视觉效果。请注意，它仅限 iOS，因此如果您需要，请使用它。'
- en: Examples of text styles
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文本样式的示例
- en: We’ve gone through a lot of different styles in this section. [Figure 4.19](#figure4.19)
    shows various styles applied to `Text` components.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中介绍了很多不同的样式。[图 4.19](#figure4.19) 展示了应用于 `Text` 组件的各种样式。
- en: 'Here’s a quick rundown of the styles being used for each example in [figure
    4.19](#figure4.19):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 [图 4.19](#figure4.19) 中每个示例所使用的样式的快速概述：
- en: 'A is italic text using `{fontStyle: ''italic''}`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'A 使用 `{fontStyle: ''italic''}` 创建斜体文本。'
- en: 'B shows text decoration with an underline and a line through the text. The
    style for this is `{textDecorationLine: ''underline line-through''}`.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'B 显示带有下划线和贯穿文本的文本装饰。这种样式的代码是 `{textDecorationLine: ''underline line-through''}`。'
- en: 'C expands on example B by also applying some iOS-only text styles, `{textDecorationColor:
    ''red'', textDecorationStyle: ''dotted''}`. Notice how these styles have no effect
    in Android.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C 通过应用一些仅适用于 iOS 的文本样式 `{textDecorationColor: ''red'', textDecorationStyle:
    ''dotted''}` 扩展了示例 B。注意这些样式在 Android 中没有效果。'
- en: 'D applies a shadow using `{textShadowColor: ''red'', textShadowOffset: {width:
    -2, height: -2}, textShadowRadius: 4}`.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'D 使用 `{textShadowColor: ''red'', textShadowOffset: {width: -2, height: -2},
    textShadowRadius: 4}` 应用阴影。'
- en: 'E uses the iOS-only `{letterSpacing: 5}`, which doesn’t affect Android.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'E 使用仅适用于 iOS 的 `{letterSpacing: 5}`，这不会影响 Android。'
- en: 'The text *ios* and *android* is styled using `{textAlign: ''center'', fontWeight:
    ''bold''}`.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '文本 *ios* 和 *android* 使用 `{textAlign: ''center'', fontWeight: ''bold''}` 进行样式化。'
- en: '![c04_19.tif](Images/c04_19.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![c04_19.tif](Images/c04_19.png)'
- en: '[Figure 4.19](#figureanchor4.19) Various examples of styling text components'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.19](#figureanchor4.19) 文本组件样式的各种示例'
- en: Use [listing 4.19](#listing4.19) as a starting point, and see how modifying
    the styles affects the result.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以 [列表 4.19](#listing4.19) 为起点，看看修改样式如何影响结果。
- en: Listing 4.19 Examples of styling `Text` components
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 `Text` 组件的样式示例
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![c04_20.png](Images/c04_20.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![c04_20.png](Images/c04_20.png)'
- en: '[Figure 4.20](#figureanchor4.20) The completed Profile Card example. Textual
    information has been added about the person using the text styling techniques
    covered in this section.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.20](#figureanchor4.20) 完成的个人资料卡片示例。已添加有关使用本节中介绍的文本样式技术的人的文本信息。'
- en: Now that you know how to create a shadow effect, let’s add a shadow to the person’s
    name so it stands out from the other text. [Figure 4.20](#figure4.20) shows the
    desired result.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何创建阴影效果，让我们给人的名字添加阴影，使其从其他文本中突出出来。[图 4.20](#figure4.20) 显示了期望的结果。
- en: The completed code for the Profile Card is provided next. You only have to add
    a tiny snippet to set the text shadow for the name.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个提供的是个人资料卡片的完整代码。您只需添加一小段代码来设置名称的文本阴影。
- en: Listing 4.20 Completed Profile Card example
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 完成的个人资料卡片示例
- en: '[PRE24]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There’s a lot you could do to this basic example to make it even better, but
    the goal was to show how beneficial it is to understand styling concepts. You
    don’t have to be a fantastic graphic designer to make a nice-looking component—a
    few simple techniques can make your application look great.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对这个基本示例进行很多改进，但目标是展示理解样式概念的好处。您不必是一位出色的图形设计师就能制作出美观的组件——一些简单的技巧就能使您的应用程序看起来很棒。
- en: We covered a lot of ground in this chapter, but believe it or not, this has
    been a short introduction! We’ll explore some additional advanced topics in chapter
    5.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容，但信不信由你，这只是一个简短的介绍！我们将在第 5 章探索一些额外的先进主题。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Styles can be applied inline with components or by creating stylesheets that
    can be referenced by components.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式可以内联应用于组件，或者通过创建可以被组件引用的样式表来应用。
- en: Styles should be organized in the same file as the component after the component
    definition or externalized into a separate styles.js file.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式应该在组件定义之后或外部化到单独的 styles.js 文件中与组件组织在同一文件中。
- en: Styles are code. The fact that JavaScript is a complete language with variables
    and functions affords many advantages over traditional CSS.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式是代码。JavaScript 是一个完整的语言，具有变量和函数，这为传统 CSS 提供了许多优势。
- en: '`View` components are the main building blocks of a UI, and they have many
    styling properties.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View` 组件是 UI 的主要构建块，并且它们具有许多样式属性。'
- en: You can use borders in many ways to enhance the look of components. You can
    even use borders to create shapes, such as circles.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用边框以多种方式增强组件的外观。您甚至可以使用边框创建形状，例如圆形。
- en: You can use margins and padding to position components relative to one another.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用边距和填充将组件相对于彼此定位。
- en: Absolute positioning lets you place a component anywhere within the parent container.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对定位允许您将组件放置在父容器内的任何位置。
- en: Clipping can occur on Android devices, depending on how you set borders, margins,
    and padding.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您设置的边框、边距和填充方式，Android 设备上可能会发生裁剪。
- en: Specifying fonts other than the defaults can be tricky. Use the `Platform` component
    to select the appropriate font for the OS.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定除默认字体以外的字体可能很棘手。使用`Platform`组件选择适合操作系统的适当字体。
- en: Use general font styles like color, size, and weight to change the size and
    appearance of `Text` components.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用的字体样式，如颜色、大小和粗细，来改变`Text`组件的大小和外观。
- en: There are rendering differences between OSs, such as how the line height behaves
    differently between iOS and Android.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统之间存在渲染差异，例如iOS和Android之间行高的行为不同。
- en: Text-decorating styles can add underlines or drop shadows to text. The set of
    available styles differs from one OS to another.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本装饰样式可以为文本添加下划线或阴影效果。可用的样式集合因操作系统而异。
- en: '5'
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Styling in depth
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解样式
- en: '*****This chapter*** ***covers*****'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章*** ***涵盖*****'
- en: Platform-specific sizes and styles
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定平台的尺寸和样式
- en: Adding drop shadows to components
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组件添加阴影效果
- en: Moving and rotating components on the x- and y-axes
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在x轴和y轴上移动和旋转组件
- en: Scaling and skewing components
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放和倾斜组件
- en: Using flexbox for layout
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用flexbox进行布局
- en: Chapter 4 introduced styling React Native components. It showed how to style
    `View` and `Text` components, styles you’ll likely use every day and that mostly
    affect the look of a component. This chapter continues the discussion and goes
    into more depth with platform-specific styles; drop shadows; manipulating components
    with transformations such as translation, rotation, scaling, and skewing; and
    dynamically laying out components with flexbox.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章介绍了样式React Native组件。它展示了如何样式化`View`和`Text`组件，这些样式你可能会每天使用，并且主要影响组件的外观。本章继续讨论并深入探讨特定平台的样式；阴影效果；使用变换如平移、旋转、缩放和倾斜来操作组件；以及使用flexbox动态布局组件。
- en: Some of these topics may feel familiar. You used platform-specific styles and
    flexbox in several of the examples in chapter 4\. We didn’t cover them in detail,
    but you saw them in a few code listings.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些主题可能感觉熟悉。你在第四章的几个示例中使用了特定平台的样式和flexbox。我们没有详细讲解，但你已经在几个代码示例中看到了它们。
- en: This chapter expands on those topics. Transformations give you the power to
    manipulate components in two or three dimensions. You can translate components
    from one position to another, rotate components, scale components to different
    sizes, and skew components. Transforms are useful in their own right, but they
    will play a much bigger role in chapter 7, which discusses animation in detail.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章扩展了这些主题。变换使你能够在二维或三维中操作组件。你可以将组件从一处位置平移到另一处，旋转组件，将组件缩放到不同的大小，以及倾斜组件。变换本身很有用，但在第七章中，它将扮演一个更大的角色，第七章将详细讨论动画。
- en: We’ll continue talking about some of the differences between platforms and look
    more deeply at flexbox. Because flexbox is a fundamental concept, it’s important
    to properly understand it so you can create layouts and UIs in React Native. You’ll
    probably use flexbox in every application you create. You’ll use some of your
    new styling techniques to continue building new features into the `ProfileCard`
    example from the previous chapter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续讨论平台之间的差异，并更深入地探讨flexbox。因为flexbox是一个基本概念，正确理解它对于你能够在React Native中创建布局和UI很重要。你可能会在创建的每个应用程序中使用flexbox。你将使用一些新的样式技术来继续构建上一章中的`ProfileCard`示例的新功能。
- en: 5.1 Platform-specific sizes and styles
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 特定平台的尺寸和样式
- en: You’ve seen how to use the `Platform.select` utility function to choose fonts
    available only on iOS or Android. You used `Platform.select` to choose a monospaced
    font supported by each platform. You might not have thought much of that at the
    time, but it’s important to keep in mind that you’re developing for two different
    platforms. The styles you apply to a component may look or behave differently
    between the two OSs or even between different versions of iOS and Android.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用`Platform.select`实用函数来选择仅在iOS或Android上可用的字体。你使用`Platform.select`来选择每个平台支持的等宽字体。你可能当时并没有太在意，但记住你正在为两个不同的平台开发是很重要的。你应用于组件的样式在两个操作系统之间或甚至在iOS和Android的不同版本之间可能看起来或表现不同。
- en: You aren’t coding for a single device; you’re not even coding for a single OS.
    The beauty of React Native is that you’re using JavaScript to create applications
    that can run on both iOS and Android. If you look through the React Native documentation,
    you’ll see many components suffixed with IOS or Android, such as `ProgressBarAndroid`,
    `ProgressViewIOS`, and `ToolbarAndroid`, so it should come as no surprise that
    styles can be platform specific too.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是为单个设备编码；你甚至不是为单个操作系统编码。React Native的美丽之处在于你使用JavaScript创建可以在iOS和Android上运行的应用程序。如果你查看React
    Native文档，你会看到许多以IOS或Android结尾的组件，例如`ProgressBarAndroid`、`ProgressViewIOS`和`ToolbarAndroid`，因此样式也可以是平台特定的，这并不令人惊讶。
- en: 'You may not have noticed that you’ve never specified a size in pixels for anything,
    like `width: 300` vs `width: ''300px''`. That’s because even the concept of size
    is different between the iOS and Android operating systems.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能没有注意到，你从未为任何东西指定过像素大小，比如`width: 300`与`width: ''300px''`。这是因为iOS和Android操作系统之间的大小概念本身就不同。'
- en: 5.1.1 Pixels, points, and DPs
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 像素、点和DP
- en: Size can be a confusing topic, but it’s important to keep in mind if you need
    to be absolutely precise when positioning components on the screen. Even if you’re
    not trying to produce a high-fidelity layout, it will be useful to understand
    the concepts in case you encounter small discrepancies in your layouts from one
    device to another.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸可能是一个令人困惑的话题，但如果你需要绝对精确地定位屏幕上的组件时，这一点很重要。即使你不想制作高保真度的布局，了解这些概念也会很有用，以防你在不同设备上的布局中出现小的差异。
- en: 'Let’s start from the beginning and define a pixel. A *pixel* is the smallest
    unit of programmable color on a display. A pixel is typically made up of red,
    green, and blue (RGB) color components. By manipulating the intensity of each
    RGB value, the pixel emits a color you see. A pixel doesn’t tell you anything
    until you start looking at the physical properties of the display: screen size,
    resolution, and dots per inch.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始，定义一个像素。一个 *像素* 是显示上可编程颜色的最小单位。一个像素通常由红色、绿色和蓝色（RGB）颜色成分组成。通过操纵每个RGB值的强度，像素会发出你看到的颜色。直到你开始查看显示器的物理属性：屏幕尺寸、分辨率和每英寸点数，像素才告诉你任何信息。
- en: The *screen size* is the diagonal measurement of the screen, from one corner
    to another. For example, the original screen size of the iPhone was 3.5 inches,
    while the screen size of the iPhone X is 5.8 inches. Although the iPhone X is
    considerably bigger, the size doesn’t mean anything until you understand how many
    pixels fit within that screen size.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*屏幕尺寸* 是屏幕对角线的测量值，从一个角落到另一个角落。例如，iPhone的原始屏幕尺寸为3.5英寸，而iPhone X的屏幕尺寸为5.8英寸。尽管iPhone
    X的尺寸明显更大，但这个尺寸本身并没有什么意义，直到你了解有多少像素可以适应这个屏幕尺寸。'
- en: '*Resolution* is the number of pixels in the display, which is most typically
    expressed as the number of pixels along the width and height of the device. The
    original iPhone was 320 × 480, while the iPhone X is 1125 × 2436.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*分辨率* 是显示中的像素数，通常以设备宽度和高度的像素数来表示。原始iPhone的分辨率为320 × 480，而iPhone X的分辨率为1125
    × 2436。'
- en: 'Screen size and resolution can then be used to calculate the pixel density:
    *pixels per inch* (PPI). You’ll often see this expressed as *dots per inch* (DPI),
    which is a holdover term from the printing world, where a dot of color was printed
    on the page. PPI and DPI are often used interchangeably even though that’s not
    exactly correct, so if you see DPI used in reference to a screen, know that PPI
    is what’s truly being discussed.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕尺寸和分辨率可以用来计算像素密度：*每英寸像素数*（PPI）。你经常会看到这个值被表示为*每英寸点数*（DPI），这是一个来自印刷世界的遗留术语，其中在页面上打印了一个颜色点。PPI和DPI经常被互换使用，尽管这并不完全正确，所以如果你在屏幕的上下文中看到DPI，要知道PPI才是真正被讨论的内容。
- en: The PPI gives you a measure of image sharpness. Imagine if two screens had the
    same resolution, 320 × 480 (half VGA). What would the same image look like on
    the 3.5-inch iPhone display versus a 17-inch HVGA monitor display? The same image
    would look much sharper on the iPhone, because it has 163 PPI versus the CRT monitor,
    which has 34 PPI. You can fit nearly five times as much information in the same
    physical space on the original iPhone. [Table 5.1](#table5.1) compares the diagonal
    size, resolution, and PPI of the two devices.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: PPI给你一个图像清晰度的度量。想象一下，如果两个屏幕具有相同的分辨率，320 × 480（半VGA），相同的图像在3.5英寸的iPhone显示屏上与17英寸HVGA监视器显示屏上会有什么不同？相同的图像在iPhone上看起来会更清晰，因为它的PPI是163，而CRT监视器的PPI是34。你可以在原始iPhone的相同物理空间中放入近五倍的信息。[表5.1](#table5.1)比较了两个设备的对角线尺寸、分辨率和PPI。
- en: Table 5.1 Comparison of a 17-inch HVGA monitor’s PPI vs. the original iPhone’s
    PPI
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 17英寸HVGA监视器的PPI与原始iPhone的PPI比较
- en: '|  | **HVGA monitor** | **Original iPhone** |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|  | **HVGA监视器** | **原始iPhone** |'
- en: '| --- | --- | --- |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Diagonal size** | 17 inches | 3.5 inches |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **对角线尺寸** | 17英寸 | 3.5英寸 |'
- en: '| **Resolution** | 320 × 480 | 320 × 480 |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **分辨率** | 320 × 480 | 320 × 480 |'
- en: '| **PPI** | 34 | 163 |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **PPI** | 34 | 163 |'
- en: Why does this matter? Because neither iOS nor Android uses the actual physical
    measurements to render content to a device’s screen. iOS uses an abstract measurement
    of points, and Android uses a similar abstract measurement of density-independent
    pixels.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么关系呢？因为iOS和Android都不是使用实际的物理测量值来将内容渲染到设备的屏幕上。iOS使用一个抽象的点作为测量单位，而Android使用一个类似的抽象密度无关像素作为测量单位。
- en: When the iPhone 4 came on the scene, it had the same physical size as its predecessors;
    but it had a fancy new Retina screen with a resolution of 640 × 960, quadrupling
    the resolution of the original device. If the iPhone had rendered images from
    existing apps at a 1:1 scale, everything would be drawn at a quarter size on the
    new Retina display. It would have been an insane proposition for Apple to make
    such a change and break all the existing apps.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当iPhone 4出现时，它与前辈们具有相同的物理尺寸；但它有一个新潮的Retina屏幕，分辨率为640 × 960，是原始设备的四倍。如果iPhone以1:1的比例渲染现有应用程序的图像，那么所有内容在新的Retina显示屏上都会以四分之一的大小绘制。对于苹果来说，做出这样的改变并破坏所有现有应用程序是一个疯狂的建议。
- en: Instead, Apple introduced the logical concept of a *point*. A point is a unit
    of distance that can be scaled independently of a device’s resolution, so a 320
    × 480 image that took up the entire screen on an original iPhone could be scaled
    up 2x to fully fit within the Retina display. [Figure 5.1](#figure5.1) provides
    a visualization of pixel density for several iPhone models.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，苹果引入了逻辑概念上的“点”。点是一个可以独立于设备分辨率进行缩放的距离单位，因此一个320 × 480的图像，在原始iPhone上占据了整个屏幕，可以被放大2倍以完全适应Retina显示屏。[图5.1](#figure5.1)提供了几个iPhone型号的像素密度可视化。
- en: The original iPhone’s 163 PPI is the basis for the iOS point. An iOS point is
    1/163 of an inch. Without going into more detail, Android uses a similar measure
    called a *device-independent pixel* (DIP, often abbreviated DP). An Android DP
    is 1/160 of an inch.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 原始iPhone的163 PPI是iOS点的基准。iOS点是一英寸的1/163。不深入细节，Android使用一个类似的度量单位，称为“设备无关像素”（DIP，通常缩写为DP）。Android
    DP是一英寸的1/160。
- en: When defining styles in React Native, you use the logical concept of a pixel,
    a point on iOS, and a DP on Android. When working at the native level, you occasionally
    may need to work with device pixels by multiplying the logical pixels by the screen
    scale (for example, 2x, 3x).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当在React Native中定义样式时，你使用逻辑上的像素概念，iOS上的点，以及Android上的DP。当在本地级别工作时，你偶尔可能需要通过将逻辑像素乘以屏幕缩放（例如，2x，3x）来与设备像素一起工作。
- en: '![c05_01.eps](Images/c05_01.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![c05_01.eps](Images/c05_01.png)'
- en: '[Figure 5.1](#figureanchor5.1) A visualization of points compared to pixel
    density for iPhones. The original iPhone had a resolution of 320 × 480\. The iPhone
    4 had a resolution of 640 × 960, quadruple the resolution of the original device.
    The iPhone 4 has twice the PPI (326 vs. 163), so images are said to be scaled
    up 2x.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#figureanchor5.1) iPhone像素密度与点数比较的可视化。原始iPhone的分辨率为320 × 480。iPhone
    4的分辨率为640 × 960，是原始设备的四倍。iPhone 4的PPI（326比163）是双倍，因此说图像被放大了2倍。'
- en: 5.1.2 Creating drop shadows with ShadowPropTypesIOS and Elevation
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 使用ShadowPropTypesIOS和Elevation创建阴影
- en: In chapter 4, you used the text shadow properties to add a drop shadow to the
    `ProfileCard` title. Both iOS and Android support adding a drop shadow to a `Text`
    component. It would be nice to spruce up more of the `ProfileCard` by adding drop
    shadows to the card and circular image container, but there isn’t a common style
    property for `View` components to use between the two platforms.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，你使用了文本阴影属性为 `ProfileCard` 标题添加阴影。iOS 和 Android 都支持为 `Text` 组件添加阴影。通过为卡片和圆形图像容器添加阴影来美化
    `ProfileCard` 会很好，但两个平台之间没有用于 `View` 组件的通用样式属性。
- en: That doesn’t mean all is lost. The `ShadowPropTypesIOS` style can be used to
    add a drop shadow on iOS devices; it doesn’t affect the z-order of the component.
    On Android, you can use the `Elevation` style to simulate a drop shadow, but it
    *does* affect the z-order of the component.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着一切都失去了。`ShadowPropTypesIOS` 样式可以用于在 iOS 设备上添加阴影；它不会影响组件的 z 调序。在 Android
    上，你可以使用 `Elevation` 样式来模拟阴影，但它 *确实* 影响组件的 z 调序。
- en: Creating drop shadows in iOS with ShadowPropTypesIOS
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 ShadowPropTypesIOS 在 iOS 中创建阴影
- en: 'Let’s look at how to use `ShadowPropTypesIOS` styles to add drop shadows to
    a few view components. [Figure 5.2](#figure5.2) shows various shadow effects that
    can be achieved. [Table 5.2](#table5.2) lists the specific settings used to achieve
    each shadow effect. The important takeaways are as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `ShadowPropTypesIOS` 样式为几个视图组件添加阴影。 [图 5.2](#figure5.2) 展示了可以实现的多种阴影效果。[表
    5.2](#table5.2) 列出了实现每种阴影效果的具体设置。重要的要点如下：
- en: If you don’t supply a value for `shadowOpacity`, you won’t see a shadow.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有为 `shadowOpacity` 提供值，你将看不到阴影。
- en: Shadows offsets are expressed in terms of width and height, but you can think
    of this as moving the shadow in the x and y directions. You can even specify negative
    values for width and height.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴影偏移以宽度和高度来表示，但你可以将其视为在 x 和 y 方向上移动阴影。你甚至可以指定宽度和高度的负值。
- en: A `shadowOpacity` of 1 is completely solid, whereas a value of 0.2 is more transparent.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowOpacity` 的值为 1 时是完全不透明的，而值为 0.2 时则更加透明。'
- en: A value for `shadowRadius`effectively blurs the edges of the shadow. The shadow
    is more diffuse.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowRadius` 的值会有效地模糊阴影的边缘。阴影更加扩散。'
- en: '![c05_02.eps](Images/c05_02.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![c05_02.eps](Images/c05_02.png)'
- en: '[Figure 5.2](#figureanchor5.2) iOS-specific examples of how to apply ShadowPropTypesIOS
    styles to View components. Example 1 has a shadow applied but no opacity set,
    which causes the drop shadow to not be displayed. Example 2 has the same shadow
    effect but with opacity set to 1\. Example 3 has a slightly larger shadow, and
    example 4 has the same size shadow with a shadow radius. Example 5 has the same
    shadow size, but opacity is changed from 1 to 0.2\. Example 6 changes the color
    of the shadow. Example 7 shows the shadow applied in only one direction, and example
    8 shows the shadow applied in the opposite direction.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](#figureanchor5.2) iOS 特定的示例，展示如何将 ShadowPropTypesIOS 样式应用于 View 组件。示例
    1 应用了阴影但没有设置不透明度，导致阴影不显示。示例 2 具有相同的阴影效果，但设置了不透明度为 1。示例 3 具有稍大的阴影，示例 4 具有相同大小的阴影并设置了阴影半径。示例
    5 具有相同的阴影大小，但将不透明度从 1 更改为 0.2。示例 6 改变了阴影的颜色。示例 7 仅在一个方向上应用阴影，示例 8 在相反方向上应用阴影。'
- en: Table 5.2 Shadow properties used to create the examples in [figure 5.2](#figure5.2)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2 用于创建 [图 5.2](#figure5.2) 中示例的阴影属性
- en: '|  |  | ****shadowOffset**** |  |  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |  | ****shadowOffset**** |  |  |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Example** | ****shadowColor**** | ****width** (x)** | ****height** (y)**
    | ****shadowOpacity**** | ****shadowRadius**** |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | ****shadowColor**** | ****width** (x)** | ****height** (y)** | ****shadowOpacity****
    | ****shadowRadius**** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1 | Black | 10 | 10 |  |  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 黑色 | 10 | 10 |  |  |'
- en: '| 2 | Black | 10 | 10 | 1 |  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 黑色 | 10 | 10 | 1 |  |'
- en: '| 3 | Black | 20 | 20 | 1 |  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 黑色 | 20 | 20 | 1 |  |'
- en: '| 4 | Black | 20 | 20 | 1 | 20 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 黑色 | 20 | 20 | 1 | 20 |'
- en: '| 5 | Black | 20 | 20 | 0.2 |  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 黑色 | 20 | 20 | 0.2 |  |'
- en: '| 6 | Red | 20 | 20 | 1 |  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 红色 | 20 | 20 | 1 |  |'
- en: '| 7 | Black |  | 20 | 1 |  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 黑色 |  | 20 | 1 |  |'
- en: '| 8 | Black | -5 | -5 | 1 |  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 黑色 | -5 | -5 | 1 |  |'
- en: The code for this figure can be found in the git repository under chapter5/figures/Figure-5.2-ShadowPropTypesIOS.
    If you run the code for this example, remember to run it in the iOS simulator.
    On an Android device, you’ll just see eight boring squares with rounded corners.
    `ShadowPropTypesIOS` styles are ignored on Android.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此图的代码可以在 git 仓库的 chapter5/figures/Figure-5.2-ShadowPropTypesIOS 目录下找到。如果你要运行此示例的代码，请记住在
    iOS 模拟器中运行。在 Android 设备上，你将只看到八个无聊的、带圆角的正方形。`ShadowPropTypesIOS` 样式在 Android 上被忽略。
- en: Approximating drop shadows on Android devices with elevation
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Android 设备上近似实现具有高度的下阴影
- en: How do you get the same effect on Android devices? The truth is, you can’t.
    You *can* use Android’s `elevation` style to affect the z-order of components.
    If two or more components occupy the same space, you can decide which one should
    be in front by giving it the larger elevation and therefore the larger z-index,
    which will create a small drop shadow, but it isn’t nearly as striking as the
    shadow effects you can achieve on iOS. Note that this only applies to Android,
    because iOS doesn’t support the `elevation` style and will gladly ignore it if
    it’s specified.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在 Android 设备上获得相同的效果？事实是，你无法做到。你可以使用 Android 的 `elevation` 样式来影响组件的 z-顺序。如果有两个或更多组件占据相同的空间，你可以通过赋予它更大的高度（elevation）和因此更大的
    z-index 来决定哪个应该在前，这将创建一个小的下阴影，但它远不如在 iOS 上可以实现的阴影效果那么引人注目。请注意，这仅适用于 Android，因为
    iOS 不支持 `elevation` 样式，如果指定了它，iOS 会乐意忽略它。
- en: Nevertheless, let’s see `elevation` in action. To do so, you’ll create a `View`
    component with three boxes, each of which is positioned absolutely. You’ll give
    them three different elevations—1, 2, and 3—and then you’ll reverse the assignment
    of the elevations and see how that affects the layout. [Figure 5.3](#figure5.3)
    shows the results of these elevation adjustments.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们看看 `elevation` 的实际应用。为了做到这一点，你将创建一个包含三个盒子的 `View` 组件，每个盒子都绝对定位。你将赋予它们三个不同的高度——1、2
    和 3——然后你将反转高度分配，看看这如何影响布局。[图 5.3](#figure5.3) 展示了这些高度调整的结果。
- en: '[Table 5.3](#table5.3) shows the absolute positions and elevations used for
    each group of boxes. Notice that nothing has changed except the `elevation` assigned
    to each of the boxes. iOS ignores the style and always renders box C on top of
    box B, and box B on top of box A. But Android respects the style and flips the
    order in which it renders the boxes, so box A is now on top of box B, and box
    B is on top of box C.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5.3](#table5.3) 展示了用于每个盒子组的绝对位置和高度。请注意，除了分配给每个盒子的`高度`之外，没有其他任何变化。iOS 忽略样式，始终将盒子
    C 放在盒子 B 的上方，盒子 B 放在盒子 A 的上方。但 Android 尊重样式，并反转渲染盒子的顺序，因此盒子 A 现在位于盒子 B 的上方，盒子
    B 位于盒子 C 的上方。'
- en: '![c05_03.eps](Images/c05_03.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![c05_03.eps](Images/c05_03.png)'
- en: '[Figure 5.3](#figureanchor5.3) Examples of using the elevation style on iOS
    and Android. On iOS, elevation is ignored; all components retain the same z-order,
    so whatever component is last in the layout is on top. On Android, elevation is
    used, and the z-order is changed; in the second example, where the elevation assignments
    are reversed, A is on top.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.3](#figureanchor5.3) 在 iOS 和 Android 上使用 elevation 样式的示例。在 iOS 上，高度被忽略；所有组件保留相同的
    z-顺序，因此布局中最后出现的组件位于顶部。在 Android 上，使用高度，z-顺序被改变；在第二个示例中，高度分配被反转，A 位于顶部。'
- en: Table 5.3 Elevation settings for [figure 5.3](#figure5.3)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3 图 5.3 的高度设置
- en: '| **Example** | ****color**** | ****top**** | ****left**** | ****elevation****
    |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | ****颜色**** | ****顶部**** | ****左侧**** | ****高度**** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| A | Red | 0 | 0 | 1 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| A | 红色 | 0 | 0 | 1 |'
- en: '| B | Orange | 20 | 20 | 2 |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| B | 橙色 | 20 | 20 | 2 |'
- en: '| C | Blue | 40 | 40 | 3 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| C | 蓝色 | 40 | 40 | 3 |'
- en: '| A | Red | 0 | 0 | 3 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| A | 红色 | 0 | 0 | 3 |'
- en: '| B | Orange | 20 | 20 | 2 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| B | 橙色 | 20 | 20 | 2 |'
- en: '| C | Blue | 40 | 40 | 1 |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| C | 蓝色 | 40 | 40 | 1 |'
- en: '5.1.3 Putting it into practice: drop shadows in the ProfileCard'
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 实践应用：ProfileCard 中的下阴影
- en: Let’s go back to the `ProfileCard` example from the last chapter and add some
    drop shadows that will look great on iOS and not so great on Android. You’ll add
    a drop shadow to the entire `ProfileCard` container and to the circular image
    container. [Figure 5.4](#figure5.4) shows what you’re shooting for on iOS and
    what you’ll get on Android.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一章的 `ProfileCard` 示例，并添加一些在 iOS 上看起来很棒而在 Android 上不那么出色的下阴影。你将为整个 `ProfileCard`
    容器和圆形图像容器添加下阴影。[图 5.4](#figure5.4) 展示了在 iOS 上你追求的效果以及在 Android 上你将得到的结果。
- en: Notice that even with `elevation` applied on Android, you don’t see much of
    a shadow. The reality is, on Android you’ll never get close to the shadow effects
    that can be produced on iOS with React Native out of the box. If you really must
    have drop shadows on Android, then I suggest looking for a component on npm or
    yarn that does what you need. Experiment with different components, and see if
    you can get the Android version looking as sharp as the iOS version. I don’t have
    any recommendations; I stay away from drop shadows or accept the differences.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使在Android上应用了`elevation`，你也看不到很多阴影。实际上，在Android上，你永远无法接近React Native默认在iOS上产生的阴影效果。如果你真的需要在Android上实现阴影效果，那么我建议在npm或yarn上寻找一个可以满足你需求的组件。尝试不同的组件，看看你是否可以使Android版本看起来与iOS版本一样清晰。我没有任何推荐；我避免使用阴影效果或接受差异。
- en: '![c05_04.eps](Images/c05_04.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![c05_04.eps](Images/c05_04.png)'
- en: '[Figure 5.4](#figureanchor5.4) The `ProfileCard` on iOS and Android after drop
    shadows have been added to the card container and the circular image container.
    The drop shadows on iOS are created using the iOS-specific shadow properties:
    `shadowColor`, `shadowOffset`, and `shadowOpacity`. On Android, the `elevation`
    property is used to try to create depth. It produces only a minor shadow effect,
    far inferior to the shadows produced on iOS.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.4](#figureanchor5.4) 在iOS和Android上添加到卡片容器和圆形图像容器后的`ProfileCard`。iOS上的阴影是通过iOS特定的阴影属性创建的：`shadowColor`、`shadowOffset`和`shadowOpacity`。在Android上，使用`elevation`属性来尝试创建深度。它只产生微弱的阴影效果，远不如iOS上产生的阴影。'
- en: 'The code in this chapter begins with [listing 4.20](c04.xhtml#listing4.20):
    the completed `ProfileCard` example from chapter 4\. [Listing 5.1](#listing5.1)
    only shows the changes needed to apply the drop shadows to the component. You
    don’t need to add a lot of code to get the drop shadows on iOS. Look at the listing
    on an Android device, and see how the `elevation` setting causes the faintest
    of shadows.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码从[列表4.20](c04.xhtml#listing4.20)开始：第4章中完成的`ProfileCard`示例。[列表5.1](#listing5.1)仅显示了应用阴影效果到组件上所需更改的部分。你不需要添加很多代码就能在iOS上实现阴影效果。查看Android设备上的列表，看看`elevation`设置如何导致最微弱的阴影。
- en: Listing 5.1 Adding drop shadows to the `ProfileCard`
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 向`ProfileCard`添加阴影效果
- en: '[PRE25]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just as with font selection in chapter 4, you use the `Platform.select` function
    to apply different styles to components based on the platform: iOS or Android.
    In some cases, like the drop shadow, one platform may perform much better than
    the other; but in most cases the styles will behave the same on both platforms,
    which is an amazing benefit of React Native.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第4章中字体选择一样，你使用`Platform.select`函数根据平台（iOS或Android）应用不同的样式到组件上。在某些情况下，比如阴影效果，一个平台可能比另一个平台表现得好得多；但在大多数情况下，样式在两个平台上表现相同，这是React
    Native的一个惊人的好处。
- en: 5.2 Using transformations to move, rotate, scale, and skew components
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 使用变换来移动、旋转、缩放和倾斜组件
- en: Up to this point, the styles we’ve discussed have mostly affected the appearance
    of components. You learned how to set properties like the style, weight, size,
    and color of borders and fonts. You applied background colors and shadow effects,
    and you saw how to manipulate the appearance of components relative to one another
    by using margins and padding. But we haven’t explored how to manipulate a component’s
    position or orientation on the screen independent of everything else. How do you
    move a component on the screen, or rotate a component in a circle?
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的样式主要影响了组件的外观。你学习了如何设置样式、粗细、大小和颜色等属性，比如边框和字体的样式。你应用了背景颜色和阴影效果，并看到了如何通过使用边距和填充来操纵组件相对于彼此的外观。但我们还没有探讨如何独立于其他一切来操纵组件在屏幕上的位置或方向。你如何移动屏幕上的组件，或者如何使组件在圆周上旋转？
- en: The answer is *transformations*. React Native provides a number of useful transforms
    that allow you to modify the shape and position of a component in 3D space. You
    can move components from one position to another, rotate components about all
    three axes, and scale and skew components in the x and y directions. Alone, transformations
    can produce some interesting effects, but their true power comes from sequencing
    them together to form animations.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是**变换**。React Native提供了一系列有用的变换，允许你在3D空间中修改组件的形状和位置。你可以将组件从一个位置移动到另一个位置，围绕所有三个轴旋转组件，以及在x和y方向上缩放和倾斜组件。单独使用变换可以产生一些有趣的效果，但它们的真正力量来自于将它们按顺序组合起来形成动画。
- en: This section will give you a firm understanding of transforms and how they affect
    the components to which they’re applied. If you clearly understand what they do,
    you’ll be better able to link them together to create meaningful animations later.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助你牢固地理解变换以及它们如何影响所应用的组件。如果你清楚地理解了它们的作用，你将能够更好地将它们结合起来，以创建有意义的动画。
- en: 'The `transform` style takes an array of transform properties that define how
    to apply a transformation to a component. For example, to rotate a component 90
    degrees and shrink it by 50%, apply this transform to the component:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`样式接受一个变换属性的数组，该数组定义了如何将变换应用于组件。例如，要旋转组件90度并缩小50%，请将此变换应用于组件：'
- en: '[PRE26]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `transform` style supports the following properties:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`样式支持以下属性：'
- en: '`perspective`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perspective`'
- en: '`translateX` and `translateY`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateX`和`translateY`'
- en: '`rotateX`, `rotateY`, and `rotateZ` (`rotate`)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateX`、`rotateY`和`rotateZ`（`rotate`）'
- en: '`scale`, `scaleX`, and `scaleY`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`、`scaleX`和`scaleY`'
- en: '`skewX` and `skewY`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skewX`和`skewY`'
- en: 5.2.1 3D effects with perspective
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 具有透视效果的3D效果
- en: '`perspective` gives an element 3D space by affecting the distance between the
    z plane and the user. This is used with other properties to give a 3D effect.
    The larger the `perspective` value, the greater the z-index of a component, which
    makes it appear closer to the user. If the z-index is negative, the farther away
    the component appears.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`perspective`通过影响z平面与用户之间的距离为元素提供3D空间。这与其他属性一起使用以产生3D效果。`perspective`值越大，组件的z-index就越高，使其看起来更靠近用户。如果z-index为负，组件看起来就离用户更远。'
- en: 5.2.2 Moving elements along the x- and y-axes with translateX and translateY
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 使用translateX和translateY沿x轴和y轴移动元素
- en: The translation properties move an element along the x (`translateX`) or y (`translateY`)
    axis from the current position. This isn’t very useful in normal development because
    you already have `margin`, `padding`, and other position properties available.
    But this becomes useful for animations, to move a component across the screen
    from one position to another.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 平移属性将元素沿着x轴（`translateX`）或y轴（`translateY`）从当前位置移动。这在正常开发中并不非常实用，因为你已经有`margin`、`padding`和其他位置属性可用。但这对动画很有用，可以将组件从一个位置移动到屏幕上的另一个位置。
- en: 'Let’s look at how to move a square using the `translateX` and `translateY`
    style properties. In [figure 5.5](#figure5.5), a square is placed in the center
    of the display and then moved in each of the four cardinal and four ordinal directions:
    NW (upper left), N (top), NE (upper right), W (left), E (right), SW (bottom left),
    S (bottom), and SE (bottom right). In each case, the center of the square is moved
    by 1.5 times the square’s size in the x or y direction or in both directions.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`translateX`和`translateY`样式属性移动一个正方形。在[图5.5](#figure5.5)中，一个正方形放置在显示器的中心，然后向四个主要方向和四个次要方向之一移动：西北（左上），北（顶部），东北（右上），西（左侧），东（右侧），西南（左下），南（底部），和东南（右下）。在每种情况下，正方形的中心在x或y方向上移动1.5倍正方形的大小，或者同时在两个方向上移动。
- en: When studying geometry, you typically see the positive y-axis drawn going up
    instead of down. But on mobile devices, the convention is to have the positive
    y-axis go down the screen, which reflects the most common interaction of scrolling
    down the screen to view more content. Coupled with that bit of knowledge, it’s
    pretty easy to see how moving the center square in [figure 5.5](#figure5.5) in
    the positive x direction and in the positive y direction results in the square
    ending up in the bottom right corner. By combining `translateX` and `translateY`,
    you can move components in any direction in the Cartesian plane (x-y plane).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习几何时，你通常看到正y轴向上绘制而不是向下。但在移动设备上，惯例是正y轴向下穿过屏幕，这反映了最常见的滚动屏幕以查看更多内容的交互方式。结合这一点知识，很容易看出在[图5.5](#figure5.5)中将中心正方形沿正x方向和正y方向移动会导致正方形最终出现在右下角。通过组合`translateX`和`translateY`，你可以在笛卡尔平面（x-y平面）的任何方向上移动组件。
- en: '![c05_05.eps](Images/c05_05.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![c05_05.eps](Images/c05_05.png)'
- en: '[Figure 5.5](#figureanchor5.5) A depiction of a center square being moved in
    each of the four cardinal and four ordinal directions: NW (upper left), N (top),
    NE (upper right), W (left), E (right), SW (bottom left), S (bottom), and SE (bottom
    right)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.5](#figureanchor5.5) 展示了中心正方形在四个主要方向和四个次要方向上的移动：西北（左上），北（顶部），东北（右上），西（左侧），东（右侧），西南（左下），南（底部），和东南（右下）'
- en: There’s no corresponding translation for movement in the z plane. The z-axis
    is perpendicular to the face of the device, which means you’re looking straight
    at it. Moving a component forward or backward would be imperceptible without some
    corresponding size change. The `perspective` transform is intended to handle this
    type of visual effect.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在z平面上的移动没有相应的平移。z轴垂直于设备的表面，这意味着你正对着它。如果没有相应的大小变化，向前或向后移动组件将不明显。`perspective`变换旨在处理这种视觉效果。
- en: In the next section, we’ll use the same example and focus on the center row,
    where the center square was translated to the left and to the right. You’ll see
    what happens when you rotate components along each of the three axes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用相同的例子，并关注中心行，其中中心正方形被向左和向右平移。你会看到当你沿着每个轴旋转组件时会发生什么。
- en: 5.2.3 Rotating elements with rotateX, rotateY, and rotateZ (rotate)
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 使用rotateX、rotateY和rotateZ（rotate）旋转元素
- en: 'The rotation properties do exactly what it sounds like they would: they rotate
    elements. Rotation occurs along an axis: x, y, or z. The origin of the rotation
    is the center point of the element before any transformations are applied, so
    if you use `translateX` or `translateY`, keep in mind that the rotation will be
    around the axis at the original location. The amount of rotation can be specified
    in either degrees (deg) or radians (rad). The examples use degrees:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转属性确实如其名所示：它们旋转元素。旋转沿着一个轴发生：x、y或z。旋转的起点是在应用任何变换之前元素的中心点，所以如果你使用`translateX`或`translateY`，请记住旋转将围绕原始位置的轴进行。旋转量可以用度（deg）或弧度（rad）指定。示例使用度：
- en: '[PRE27]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Figure 5.6](#figure5.6) shows the positive and negative direction of rotation
    for each axis. The `rotate` transform does the same thing as the `rotateZ` transform.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.6](#figure5.6)显示了每个轴的旋转正负方向。`rotate`变换与`rotateZ`变换做的是同样的事情。'
- en: '![c05_06.eps](Images/c05_06.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![c05_06.eps](Images/c05_06.png)'
- en: '[Figure 5.6](#figureanchor5.6) The positive and negative direction of rotation
    for each axis'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.6](#figureanchor5.6) 每个轴的旋转正负方向'
- en: Let’s rotate a 100 × 100 square about the x-axis in increments of 35°, as shown
    in [figure 5.7](#figure5.7). A center line is drawn through each square, so it’s
    easier to see how the squares are rotating. You can visualize rotation about the
    x-axis in the positive direction as the square rotating from the top into the
    page. The bottom is coming closer to you as the top moves further away.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以35°的增量围绕x轴旋转100 × 100的正方形，如图[图5.7](#figure5.7)所示。每个正方形都画了一条中心线，这样更容易看到正方形是如何旋转的。你可以将x轴的正向旋转想象为正方形从顶部旋转到页面内。当顶部远离你时，底部会靠近你。
- en: '![c05_07.eps](Images/c05_07.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![c05_07.eps](Images/c05_07.png)'
- en: '[Figure 5.7](#figureanchor5.7) Rotating a 100 × 100 square about the x-axis
    in increments of 35°. After 90°, the “ROTATION” label can be seen through the
    element, upside down.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.7](#figureanchor5.7) 以35°的增量围绕x轴旋转100 × 100的正方形。在90°之后，“ROTATION”标签可以通过元素看到，是颠倒的。'
- en: At 90°, you’re looking at the square on its edge (because it doesn’t have any
    thickness, you don’t see a thing). After the square has rotated past the 90° mark,
    you start to see the back of the square. If you look closely in [figure 5.7](#figure5.7),
    you can see the “ROTATION” label is upside down, because you’re looking through
    what was the back of the square.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在90°时，你看到的是正方形的边缘（因为它没有厚度，你看不到任何东西）。当正方形旋转超过90°标记后，你开始看到正方形的背面。如果你仔细看[图5.7](#figure5.7)，你会看到“ROTATION”标签是颠倒的，因为你正在透过正方形的背面看。
- en: '![c05_09.eps](Images/c05_09.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![c05_09.eps](Images/c05_09.png)'
- en: '[Figure 5.9](#figureanchor5.9) Rotating a 100 × 100 square about the z-axis
    in increments of 35°. The positive rotation is clockwise, and the negative rotation
    is counterclockwise.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.9](#figureanchor5.9) 以35°的增量围绕z轴旋转100 × 100的正方形。正旋转是顺时针，负旋转是逆时针。'
- en: The next example will rotate the same 100 × 100 square about the y-axis, instead
    continuing to use increments of 35° to demonstrate the rotation (see [figure 5.8](#figure5.8)).
    Picture the right side of the square moving away from you, into the page. After
    the square has rotated beyond the 90° mark, you can see the “ROTATION” label through
    the component. Because you’re looking through the back of the component, the text
    appears backward.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子将围绕 y 轴旋转相同的 100 × 100 正方形，而不是继续使用 35° 的增量来展示旋转（见图 5.8）。想象正方形的右侧远离你，进入页面。当正方形旋转超过
    90° 标记后，你可以看到“旋转”标签穿过组件。因为你正在通过组件的背面看，所以文本看起来是反的。
- en: 'Compare [figure 5.8](#figure5.8) to [figure 5.7](#figure5.7). Fundamentally,
    rotation about the y-axis is no different than rotation about the x-axis. I aligned
    the squares in [figure 5.8](#figure5.8) vertically so you can easily see the axis
    of rotation. I like to visualize rotation in the y-axis by picturing a book opening
    and closing: if you’re opening a book, the cover is rotating in the negative direction.
    If you’re closing the book, then you’re rotating the cover in the positive direction.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [图 5.8](#figureanchor5.8) 与 [图 5.7](#figureanchor5.7) 进行比较。本质上，围绕 y 轴的旋转与围绕
    x 轴的旋转没有区别。我在 [图 5.8](#figureanchor5.8) 中垂直排列正方形，这样你可以很容易地看到旋转轴。我喜欢通过想象一本书的开合来可视化
    y 轴的旋转：如果你在打开一本书，封面是逆时针旋转的。如果你在合上书，那么你是在顺时针旋转封面。
- en: '![c05_08.eps](Images/c05_08.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![c05_08.eps](Images/c05_08.png)'
- en: '[Figure 5.8](#figureanchor5.8) Rotating a 100 × 100 square about the y-axis
    in increments of 35°. After 90°, the “ROTATION” label can be seen through the
    element, backward.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.8](#figureanchor5.8) 以 35° 的增量围绕 y 轴旋转 100 × 100 的正方形。在 90° 之后，可以看到“旋转”标签穿过元素，向后。'
- en: Rotation about the z-axis is the easiest to visualize. Rotation in the positive
    direction spins the object in a clockwise fashion, and rotation in the negative
    direction spins the square in a counterclockwise fashion. For this example, shown
    in [figure 5.9](#figure5.9), the axis of rotation is represented as a dot in the
    center of the square, because the z-axis is, basically, your line of sight; it
    goes straight into the screen.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 z 轴的旋转最容易可视化。正向旋转会使物体顺时针旋转，而负向旋转会使正方形逆时针旋转。在本例中，如图 5.9 所示，旋转轴用正方形中心的点表示，因为
    z 轴基本上是你的视线；它直接进入屏幕。
- en: '![c05_10.eps](Images/c05_10.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![c05_10.eps](Images/c05_10.png)'
- en: '[Figure 5.10](#figureanchor5.10) Applying transform: [{translateY: 50},{translateX:
    150},{rotate: ''45deg''}] to the original square'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.10](#figureanchor5.10) 应用变换：[{translateY: 50},{translateX: 150},{rotate:
    ''45deg''}] 到原始正方形'
- en: '![c05_11.eps](Images/c05_11.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![c05_11.eps](Images/c05_11.png)'
- en: '[Figure 5.11](#figureanchor5.11) Applying transform: [{translateY: 50},{rotate:
    ''45deg''},{translateX: 150}] to the original square. Rotating the square changes
    the orientation of the x- and y-axes, so when the square is translated 150 points
    in the +x direction, it’s moved diagonally down and out of the viewport.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.11](#figureanchor5.11) 应用变换：[{translateY: 50},{rotate: ''45deg''},{translateX:
    150}] 到原始正方形上。旋转正方形会改变 x 轴和 y 轴的方向，因此当正方形沿 +x 方向平移 150 个点时，它就会沿着对角线向下并移出视口。'
- en: Hopefully, it’s fairly obvious now how the rotation transforms work. Understanding
    the direction in which positive and negative rotations affect an object is probably
    the most complex part. But when you start combining other transforms in conjunction
    with rotation, you may be surprised by the results. Remember that the transform
    property is an array of transforms, so multiple transforms can be supplied at
    once, and order matters! Specifying a transform and switching the order of the
    elements in the array will yield different results.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，旋转变换的工作原理应该相当明显了。理解正负旋转对物体影响的方向可能是最复杂的部分。但是，当你开始将其他变换与旋转结合使用时，你可能会对结果感到惊讶。记住，变换属性是一个变换数组，因此可以一次性提供多个变换，顺序很重要！指定一个变换并改变数组中元素的顺序将产生不同的结果。
- en: 'Let’s investigate how altering the order in which the transforms are specified
    affects the final layout. Let’s apply three different transforms to a square:
    translate in the y direction 50 points, translate in the x direction 150 points,
    and rotate the square 45°. [Figure 5.10](#figure5.10) specifies the transform
    in the order just described. The original/previous position of the square has
    a dotted border and the new position of the square has a solid outline, so you
    can see how the transformation affects the position and orientation of the original
    square.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查改变变换指定顺序如何影响最终布局。让我们对一个正方形应用三个不同的变换：沿y方向平移50点，沿x方向平移150点，以及旋转正方形45°。[图5.10](#figure5.10)按照上述顺序指定了变换。正方形原始/之前的位置有虚线边框，而正方形的新位置有实线轮廓，这样你可以看到变换如何影响原始正方形的位置和方向。
- en: The result in [figure 5.10](#figure5.10) is pretty much as expected, but what
    will happen if you apply the rotation after moving the square in the y direction?
    Look at [figure 5.11](#figure5.11) and find out.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.10](#figure5.10)中的结果基本上符合预期，但如果你在将正方形沿y方向移动后再应用旋转，会发生什么？请看[图5.11](#figure5.11)并找出答案。'
- en: Whoa, what happened? The square is completely off the screen after the transformations
    are applied! It might not be immediately obvious what happened, which is why [figure
    5.11](#figure5.11) is annotated with the new axis orientation.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，发生了什么？变换应用后，正方形完全离开了屏幕！这可能不是立即显而易见的，这就是为什么[图5.11](#figure5.11)上标注了新的轴方向。
- en: 'After the rotation, the +x- and +y-axes are no longer oriented vertically and
    horizontally on the screen: they’re rotated by 45°. When the `translateX` transform
    is applied, the square is moved 150 points in the +x direction, but the +x direction
    is now at a 45° angle from the original x-axis.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转之后，+x-和+y-轴在屏幕上不再垂直和水平对齐：它们旋转了45°。当应用`translateX`变换时，正方形在+x方向上移动了150点，但现在+x方向与原始x轴成45°角。
- en: The next section shows another interesting aspect of rotational transforms.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分展示了旋转变换的另一个有趣方面。
- en: 5.2.4 Setting visibility when rotating an element more than 90°
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 在元素旋转超过90°时设置可见性
- en: If you look back at figures 5.7 and 5.8, when you rotate the square about the
    x- or y-axis and go beyond the 90° point, you can still see the text that was
    on the front face of the square. The*`backfaceVisibility`*property dictates whether
    an element is visible when the element is rotated more than 90°.*This property
    can be set to either `'visible'`*or*`'hidden'`*.* This property isn’t a transform,
    but it gives you the ability to hide or show elements when viewing the back face
    of an object.*****
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾图5.7和5.8，当你围绕x-或y-轴旋转正方形并超过90°点时，你仍然可以看到正方形前脸上的文本。*`backfaceVisibility`*属性决定了当元素旋转超过90°时元素是否可见。*此属性可以设置为`'visible'`或`'hidden'`。*此属性不是变换，但它让你能够在查看对象的背面时隐藏或显示元素。*****
- en: '**The `backfaceVisibility` property defaults to `''visible''`, but if you changed
    `backfaceVisibility` to `''hidden''`, you wouldn’t see the element at all once
    the component rotated more than 90° in either the x or y direction. In figures
    5.7 and 5.8, the squares corresponding to the 105° and 140° rotations would disappear.
    If that sounds confusing, look at [figure 5.12](#figure5.12).'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**`backfaceVisibility`属性默认为`''visible''`，但如果将`backfaceVisibility`更改为`''hidden''`，一旦组件在x或y方向旋转超过90°，你就完全看不到该元素。在图5.7和5.8中，对应105°和140°旋转的正方形将消失。如果这听起来很困惑，请看[图5.12](#figure5.12)**'
- en: '![c05_12.eps](Images/c05_12.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![c05_12.eps](Images/c05_12.png)'
- en: '[Figure 5.12](#figureanchor5.12) A demonstration of how setting the backfaceVisibility
    property to ''hidden'' hides elements that have rotated beyond 90°. The cube on
    the left shows faces 2, 4, and 5, all of which have rotated 180°. The cube on
    the right has hidden those faces.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.12](#figureanchor5.12) 展示了将`backfaceVisibility`属性设置为`''hidden''`如何隐藏旋转超过90°的元素。左边的立方体显示了2、4和5面，这些面都旋转了180°。右边的立方体隐藏了这些面。'
- en: In the figure, you can easily see the effect of setting `backfaceVisibility`
    to `'hidden'`. It’s also easy to see how this behavior might be beneficial during
    animations. When the faces of the cube rotate out of sight, you want them to be
    hidden.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，你可以很容易地看到将`backfaceVisibility`设置为`'hidden'`的效果。这也很容易看出这种行为在动画中可能是有益的。当立方体的面旋转出视线时，你希望它们被隐藏。
- en: 5.2.5 Scaling objects on the screen with scale, scaleX, and scaleY
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 使用scale、scaleX和scaleY在屏幕上缩放对象
- en: This section talks about scaling objects on the screen. There are many practical
    uses for scaling and many patterns that take advantage of its capabilities. For
    instance, scaling can be used to create thumbnails of objects. You’ve seen this
    in many applications; the user taps a thumbnail, and an animation gradually scales
    the object back up to full size. It’s a common transition technique that provides
    a nice visual effect.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了在屏幕上缩放对象。缩放有许多实际用途，许多模式也利用了其功能。例如，缩放可以用来创建对象的缩略图。你已经在许多应用中看到了这一点；用户轻触缩略图，动画逐渐将对象放大到全尺寸。这是一种常见的过渡技术，提供了良好的视觉效果。
- en: You’ll learn the basics of scaling objects and then use those skills to create
    a thumbnail of the `ProfileCard` that opens to full size when pressed. Later,
    this chapter discusses flexbox and how it can be used to manage a bunch of `ProfileCard`
    thumbnails in a gallery interface, from which you can press profiles to view them
    in more detail.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习缩放对象的基础知识，然后使用这些技能创建一个当按下时可以打开到全尺寸的`ProfileCard`缩略图。稍后，本章将讨论flexbox及其如何用于在画廊界面中管理多个`ProfileCard`缩略图，你可以从中按下个人资料以查看更多详细信息。
- en: '`scale` multiplies the size of the element by the number passed to it, the
    default being 1\. To make an element appear larger, pass a value larger than 1;
    to make it appear smaller, pass a value smaller than 1.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale`通过传递给它的数字乘以元素的大小，默认值为1。为了使元素看起来更大，传递一个大于1的值；为了使其看起来更小，传递一个小于1的值。'
- en: 'The element can also be scaled along a single axis using `scaleX` or `scaleY`.
    `scaleX` stretches the element horizontally along the x-axis, and `scaleY` stretches
    the element vertically along the y-axis. Let’s create a few squares to show the
    effects of scaling: see [figure 5.13](#figure5.13).'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 元素也可以使用`scaleX`或`scaleY`沿着单个轴进行缩放。`scaleX`沿着x轴水平拉伸元素，而`scaleY`沿着y轴垂直拉伸元素。让我们创建几个正方形来展示缩放的效果：参见[图5.13](#figure5.13)。
- en: '![c05_13.tif](Images/c05_13.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![c05_13.tif](Images/c05_13.png)'
- en: '[Figure 5.13](#figureanchor5.13) Examples of how scaling transforms the original
    square. All the squares start the same size and shape as A, which has the default
    scale of 1\. B scales the square by 0.5, shrinking it. C scales the square by
    2, enlarging it. D uses scaleX, transforming the square along the x-axis by 3x.
    E uses scaleY, transforming the square along the y-axis by 1.5x.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.13](#figureanchor5.13)展示了缩放变换如何改变原始正方形的例子。所有正方形都以与A相同的大小和形状开始，A具有默认的缩放比例1。B将正方形缩放为0.5，使其缩小。C将正方形缩放为2，使其放大。D使用`scaleX`，沿着x轴将正方形变换为3倍。E使用`scaleY`，沿着y轴将正方形变换为1.5倍。'
- en: Nothing unusual happens; scaling an object is pretty straightforward. [Listing
    5.2](#listing5.2) shows how simple it is.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么异常发生；缩放对象相当直接。[列表5.2](#listing5.2)展示了这有多么简单。
- en: Listing 5.2 Scaling squares using `scale`, `scaleX`, and `scaleY`
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 使用`scale`、`scaleX`和`scaleY`缩放正方形
- en: '[PRE28]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 5.2.6 Using the scale transform to create a thumbnail of the ProfileCard
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.6 使用缩放变换创建ProfileCard的缩略图
- en: Now that you’ve seen scaling in action, let’s use this technique to create a
    thumbnail of the `ProfileCard`. Normally you’d animate what I’m about to show
    you, to avoid flickering, but let’s see how to use scaling in a practical way.
    [Figure 5.14](#figure5.14) shows a small, scaled-down version of the `ProfileCard`
    component—a thumbnail. If you press the thumbnail, the component will return to
    full size. If you press the full-size component, it will collapse back down into
    a thumbnail view.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了缩放的实际应用，让我们使用这个技术来创建`ProfileCard`的缩略图。通常你会对即将展示的内容进行动画处理，以避免闪烁，但让我们看看如何以实际的方式使用缩放。图5.14([Figure
    5.14](#figure5.14))显示了`ProfileCard`组件的一个小型、缩小的版本——缩略图。如果你按下缩略图，组件将恢复到全尺寸。如果你按下全尺寸组件，它将折叠回缩略图视图。
- en: Begin with the code from [listing 5.1](#listing5.1). As far as styles go, you
    only need to add one new style to do the scaling transform from full size to thumbnail.
    The remainder of the code reorganizes the component’s pieces into a more reusable
    structure and provides the touch capabilities to handle the `onPress` events.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表5.1](#listing5.1)中的代码开始。就样式而言，你只需要添加一个新样式来执行从全尺寸到缩略图的缩放变换。代码的其余部分重新组织了组件的各个部分，使其成为一个更可重用的结构，并提供了处理`onPress`事件的触摸能力。
- en: '![c05_14.eps](Images/c05_14.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![c05_14.eps](Images/c05_14.png)'
- en: '[Figure 5.14](#figureanchor5.14) Scaling the full-sized ProfileCard down 80%
    into a thumbnail image. Pressing the thumbnail restores the ProfileCard to its
    original size, and pressing the full-sized component collapses the component into
    a thumbnail.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.14](#figureanchor5.14) 将全尺寸ProfileCard缩小80%为缩略图。按下缩略图将ProfileCard恢复到原始大小，按下全尺寸组件将组件折叠成缩略图。'
- en: Listing 5.3 Scaling `ProfileCard` from full size to thumbnail
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 将`ProfileCard`从全尺寸缩放到缩略图
- en: '[PRE29]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By reorganizing the structure of the component, you can better handle adding
    more `ProfileCard` components to the application. In section 5.3, you’ll add more
    `ProfileCard`s and see how to organize them into a gallery layout.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新组织组件的结构，你可以更好地处理向应用程序中添加更多`ProfileCard`组件。在第5.3节中，你将添加更多`ProfileCard`并了解如何将它们组织成画廊布局。
- en: 5.2.7 Skewing elements along the x- and y-axes with skewX and skewY
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.7 使用skewX和skewY沿x轴和y轴倾斜元素
- en: Before we leave transforms and talk about layout, let’s look at the `skewX`
    and `skewY` transformations. In the source code that produced the cubes for the
    `backfaceVisibility` example shown in [figure 5.12](#figure5.12) (github chapter5/figures/Figure-5.12-BackfaceVisibility),
    you can see that skewing the squares was essential to producing the three-dimensional
    affect for the cube faces. Let’s discuss what `skewX` and `skewY` do, so when
    you explore the source code in detail, you’ll understand what you’re seeing.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开变换并讨论布局之前，让我们看看`skewX`和`skewY`变换。在生成[图5.12](#figure5.12)（github chapter5/figures/Figure-5.12-BackfaceVisibility）中`backfaceVisibility`示例的立方体源代码中，你可以看到倾斜正方形对于产生立方体面的三维效果是至关重要的。让我们讨论`skewX`和`skewY`的作用，这样当你详细查看源代码时，你会明白你所看到的内容。
- en: 'The `skewX` property skews an element along the x-axis. Similarly, the `skewY`
    property skews an element along the y-axis. [Figure 5.15](#figure5.15) shows the
    results of skewing a square as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`skewX`属性沿x轴倾斜元素。同样，`skewY`属性沿y轴倾斜元素。[图5.15](#figure5.15) 展示了以下倾斜正方形的结果：'
- en: Square A has no transformation applied to it.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形A未应用任何变换。
- en: Square B is skewed along the x-axis by 45°.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形B沿x轴倾斜45°。
- en: Square C is skewed along the x-axis by –45°.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形C沿x轴倾斜-45°。
- en: Square D is skewed along the y-axis by 45°.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形D沿y轴倾斜45°。
- en: Square E is skewed along the y-axis by –45°.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形E沿y轴倾斜-45°。
- en: 'As with scaling, skewing an element is relatively simple: provide an angle,
    and specify the axis. The next listing gives all the details.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 与缩放类似，倾斜一个元素相对简单：提供一个角度，并指定轴。下一个列表提供了所有详细信息。
- en: '![c05_15.tif](Images/c05_15.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![c05_15.tif](Images/c05_15.png)'
- en: '[Figure 5.15](#figureanchor5.15) Examples of skewing a square along the x-
    and y-axes on iOS. Square A has no transformation applied. Square B is skewed
    along the x-axis by 45°. Square C is skewed along the x-axis by –45°. Square D
    is skewed along the y-axis by 45°, and square E is skewed along the y-axis by
    –45°.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.15](#figureanchor5.15) 在iOS上沿x轴和y轴倾斜正方形的示例。正方形A未应用任何变换。正方形B沿x轴倾斜45°。正方形C沿x轴倾斜-45°。正方形D沿y轴倾斜45°，正方形E沿y轴倾斜-45°。'
- en: Listing 5.4 Examples showing how skewing transforms a square
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 展示如何通过倾斜变换正方形
- en: '[PRE30]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 5.2.8 Transformation key points
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.8 变换关键点
- en: We’ve covered a lot of transformative ideas in this section! Some of them were
    relatively simple, while others may have been hard to visualize at first. I didn’t
    show many examples that combine transforms, so you could focus on what individual
    transforms do. I encourage you to take any of the examples and include additional
    transformations, to experiment and see what happens.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了许多变换思想！其中一些相对简单，而其他一些可能一开始难以可视化。我没有展示很多结合变换的例子，所以你可以专注于单个变换的作用。我鼓励你尝试任何例子，并添加额外的变换，以进行实验并看看会发生什么。
- en: 'In chapter 7, when we discuss animation, you’ll see how transformations can
    make things come alive. For now, take away these key points:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，当我们讨论动画时，你会看到变换如何使事物栩栩如生。现在，记住这些关键点：
- en: The origin of the x- and y-axes is at upper left, meaning the positive direction
    for y is down the screen. You saw this with absolute positioning in the previous
    chapter, but it’s likely the opposite of what you’re used to, which can make it
    hard to reason about what a transformation will do.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x轴和y轴的原点在左上角，这意味着y轴的正方向是向下屏幕。你在上一章的绝对定位中看到了这一点，但可能与你习惯的相反，这可能会使推理变换将做什么变得困难。
- en: The origin for rotations and translations is always at the element’s original
    location. You can’t translate an object in the x or y direction and then rotate
    it about a new center point.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转和变换的起点始终在元素的原始位置。你不能在x或y方向上平移一个对象，然后再围绕新的中心点旋转它。
- en: Transformations are a great way to move components around the screen, but you
    won’t use them on an everyday basis. Most often, you’ll use Yoga, a layout engine
    that implements much of the W3C’s flexbox web specification. In the next section,
    we’ll discuss Yoga’s flexbox implementation in detail.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 变换是移动组件在屏幕上的好方法，但你不会在日常基础上使用它们。最常见的是使用Yoga，这是一个实现了W3C的flexbox网络规范大部分内容的布局引擎。在下一节中，我们将详细讨论Yoga的flexbox实现。
- en: 5.3 Using flexbox to lay out components
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 使用flexbox布局组件
- en: '![c05_16.eps](Images/c05_16.png)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![c05_16.eps](Images/c05_16.png)'
- en: '[Figure 5.16](#figureanchor5.16) Three examples of layouts using the flex property.
    The top example is 1:1, with A = {flex: 1} and B = {flex: 1}, resulting in each
    taking up 50% of the space. The middle example is 1:2, with C = {flex: 1} and
    D = {flex: 2}, resulting in C taking up 33% of the space and D taking up 66%.
    The bottom example is 1:3, with E = {flex: 1} and F = {flex: 3}, resulting in
    E taking up 25% of the space and F taking up 75% of the space.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.16](#figureanchor5.16) 使用flex属性的三种布局示例。顶部示例是1:1，A = {flex: 1}和B = {flex:
    1}，结果每个都占用50%的空间。中间示例是1:2，C = {flex: 1}和D = {flex: 2}，结果C占用33%的空间，D占用66%。底部示例是1:3，E
    = {flex: 1}和F = {flex: 3}，结果E占用25%的空间，F占用75%的空间。'
- en: Flexbox is a layout implementation that React Native uses to provide an efficient
    way for users to create UIs and control positioning. The React Native flexbox
    implementation is based on the W3C flexbox web specification but doesn’t share
    100% of the API. It aims to give you an easy way to reason about, align, and distribute
    space among items in a layout, even when their size isn’t known or is dynamic.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox是React Native用来提供用户创建UI和控制定位的高效布局实现。React Native的flexbox实现基于W3C的flexbox网络规范，但并不完全共享100%的API。它的目标是提供一个简单的方法来推理、对齐和分配布局中项目之间的空间，即使它们的尺寸未知或动态。
- en: 'You’ve already seen flexbox used in many of the examples. It’s powerful and
    makes laying out items so much easier than alternative methods that it’s difficult
    *not* to use it. You’ll benefit greatly by taking time to understand the material
    in this section. Here are the alignment properties used to control the flexbox
    layout: `flex`, `flexDirection`, `justifyContent`, `alignItems`, `alignSelf`,
    and `flexWrap`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在前面的许多示例中看到了flexbox的使用。它功能强大，使得布局项目比其他方法更容易，以至于很难不使用它。花时间理解本节的内容将对你大有裨益。以下是用于控制flexbox布局的对齐属性：`flex`、`flexDirection`、`justifyContent`、`alignItems`、`alignSelf`和`flexWrap`。
- en: 5.3.1 Altering a component’s dimensions with flex
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 使用flex调整组件的尺寸
- en: The `flex` property specifies the ability of a component to alter its dimensions
    to fill the space of the container it’s in. This value is relative to the `flex`
    properties specified for the rest of the items in the same container.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex`属性指定了一个组件改变其尺寸以填充其所在容器空间的能力。这个值相对于同一容器中其他项目的`flex`属性是相对的。'
- en: 'If you have a `View` element with a height of 300 and a width of 300, and a
    child `View` element with a property of `flex: 1`, then the child view will completely
    fill the parent view. If you decide to add another child element with a `flex`
    property of `flex: 1`, each view will take up equal space in the parent container.
    The `flex` number is only important relative to the other `flex` items occupying
    the same space.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你有一个高度为300和宽度为300的`View`元素，并且一个子`View`元素具有`flex: 1`属性，那么子视图将完全填充父视图。如果你决定添加另一个具有`flex`属性为`flex:
    1`的子元素，每个视图将在父容器中占用相等的空间。`flex`数字仅相对于占用相同空间的其它`flex`项目而言是重要的。'
- en: Another way to look at this is to think of the `flex` properties as being percentages.
    For example, if you want the child components to take up 66.6% and 33.3%, respectively,
    you can use `flex:66` and `flex:33`. Rather than `flex:66` and `flex:33`, you
    can specify `flex:2` and `flex:1` and achieve the same layout effect.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是将`flex`属性视为百分比。例如，如果你想子组件分别占用66.6%和33.3%，你可以使用`flex:66`和`flex:33`。而不是`flex:66`和`flex:33`，你可以指定`flex:2`和`flex:1`，以达到相同的布局效果。
- en: To better understand how this works, let’s look at a few examples shown in [figure
    5.16](#figure5.16). These are easily achieved by setting the appropriate `flex`
    value on the individual elements. The following listing shows the steps necessary
    to create such a layout.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解其工作原理，让我们看看 [图 5.16](#figure5.16) 中展示的几个示例。这些可以通过在单个元素上设置适当的 `flex` 值轻松实现。以下列表显示了创建此类布局所需的步骤。
- en: Listing 5.5 Flex views with 1:1 ratio, 1:2, and 1:3 ratios
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 具有比例 1:1、1:2 和 1:3 的 flex 视图
- en: '[PRE31]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 5.3.2 Specifying the direction of the flex with flexDirection
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 使用 flexDirection 指定 flex 的方向
- en: In the previous examples, the items in flex containers are laid out in a column
    (y-axis), meaning top to bottom. A is stacked on B, C is stacked on D, and E is
    stacked on F. Using the `flexDirection` property, you can change the primary axis
    of the layout, and therefore change the direction of the layout. `flexDirection`
    is applied to the parent view that contains
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，flex 容器中的项目按列（y 轴）布局，意味着从上到下。A 堆叠在 B 上，C 堆叠在 D 上，E 堆叠在 F 上。使用 `flexDirection`
    属性，你可以更改布局的主轴，从而改变布局的方向。`flexDirection` 应用于包含示例组件的父视图中。
- en: 'All that’s needed to achieve the layout in [figure 5.17](#figure5.17) is to
    add a single line of code to the `flexContainer` style, which is the parent container
    for each of the example components. Changing `flexDirection` on this container
    affects the layout of all its flex children. Add `flexDirection: ''row''` to the
    style, and see how it changes the layout.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '实现图 5.17 中的布局只需在 `flexContainer` 样式中添加一行代码，这是每个示例组件的父容器。更改此容器的 `flexDirection`
    影响其所有 flex 子项的布局。向样式添加 `flexDirection: ''row''`，并查看它如何更改布局。'
- en: '![c05_17.eps](Images/c05_17.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![c05_17.eps](Images/c05_17.png)'
- en: '[Figure 5.17](#figureanchor5.17) The same example as in [figure 5.16](#figure5.16),
    but with flexDirection set to ''row''. Now the items take up space horizontally
    within the row rather than vertically within the column.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.17](#figureanchor5.17) 与 [图 5.16](#figure5.16) 相同的示例，但 flexDirection 设置为
    ''row''。现在项目在行内水平占用空间，而不是在列内垂直占用空间。'
- en: 'Listing 5.6 Adding `flexDirection: ''row''` to the parent container'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5.6 向父容器添加 `flexDirection: ''row''`'
- en: '[PRE32]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The child elements now appear left to right. There are two options for `flexDirection`:
    `''row''` and `''column''`. The default setting is `''column''`. If you don’t
    specify a `flexDirection` property, content will be laid out in a column. This
    property is something you’ll use a lot when developing apps in React Native, so
    it’s important to grasp it and understand how it works.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 子元素现在从左到右显示。`flexDirection` 有两个选项：`'row'` 和 `'column'`。默认设置是 `'column'`。如果你没有指定
    `flexDirection` 属性，内容将以列的形式布局。当你在 React Native 中开发应用程序时，你将大量使用此属性，因此理解它及其工作原理非常重要。
- en: 5.3.3 Defining how space is used around a component with justifyContent
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 使用 justifyContent 定义组件周围空间的使用方式
- en: Using the `flex` property, you can specify how much space each component takes
    up in its parent container; but what if you’re not trying to take up the entire
    space? How can you use flexbox to lay out components using their original size?
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flex` 属性，你可以指定每个组件在其父容器中占用的空间量；但如果你不是试图占用整个空间，怎么办？你如何使用 flexbox 使用组件的原始大小来布局组件？
- en: '`justifyContent` defines how space is distributed between and around flex items
    along the primary axis of the container (the flex direction). `justifyContent`
    is declared on the parent container. Five options are available:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`justifyContent` 定义了在容器的主轴（即 flex 方向）上如何分配和围绕 flex 项目之间的空间。`justifyContent`
    在父容器上声明。有五种选项可用：'
- en: '`center` causes the children to be centered within the parent container. The
    free space is distributed on both sides of the clustered group of children.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center` 使子元素在父容器内居中。空闲空间分布在子元素群集的两侧。'
- en: '`flex-start` groups the components at the beginning of the flex column or row,
    depending on what value is assigned to `flexDirection`. `flex-start` is the default
    value for `justifyContent`.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-start` 根据分配给 `flexDirection` 的值将组件分组在 flex 列或行的开始处。`flex-start` 是 `justifyContent`
    的默认值。'
- en: '`flex-end` acts in the opposite manner: it groups items together at the end
    of the container.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-end` 以相反的方式起作用：它将项目组合在容器的末尾。'
- en: '`space-around` attempts to evenly distribute space around each element. Don’t
    confuse this with distributing the elements evenly in the container; the space
    is distributed around the elements. If it were based on the elements, you’d expect'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space-around` 尝试在元素周围均匀分配空间。不要将其与在容器中均匀分布元素混淆；空间是围绕元素分配的。如果它是基于元素的，你会期望'
- en: '*space – element – space – element – space*'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*空间 – 元素 – 空间 – 元素 – 空间*'
- en: Instead, flexbox allocates the same amount of space on each side of the element,
    yielding
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，flexbox 在元素的每一侧分配相同数量的空间，从而得到
- en: '*space – element – space – space – element – space*'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '*空间 – 元素 – 空间 – 空间 – 元素 – 空间*'
- en: In both cases, the amount of whitespace is the same; but in the latter, the
    space between elements is greater.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，空白量的数量是相同的；但在后者中，元素之间的空间更大。
- en: '`space-between` doesn’t apply spacing at the start or end of the container.
    The space between any two consecutive elements is the same as the space between
    any other two consecutive elements.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space-between` 不会在容器的开始或结束处应用间距。任何两个连续元素之间的空间与任何其他两个连续元素之间的空间相同。'
- en: '[Figure 5.18](#figure5.18) demonstrates how each of the `justifyContent` properties
    distributes space between and around the flex elements. Every example uses two
    elements to help depict what is happening.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.18](#figure5.18) 展示了每个 `justifyContent` 属性如何在 flex 元素之间和周围分配空间。每个示例都使用两个元素来帮助描述正在发生的情况。'
- en: '[Listing 5.7](#listing5.7) shows the code used to generate [figure 5.18](#figure5.18).
    Look at it carefully, to understand how it works, and then try to do the following:
    add more elements to each example to see what happens as the number of items increases;
    and set `flexDirection` to `row` to see what happens when the items are laid out
    horizontally instead of vertically.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.7](#listing5.7) 展示了生成 [图 5.18](#figure5.18) 所使用的代码。仔细查看它，以了解其工作原理，然后尝试以下操作：向每个示例添加更多元素，以查看项目数量增加时会发生什么；将
    `flexDirection` 设置为 `row`，以查看项目水平布局而不是垂直布局时会发生什么。'
- en: Listing 5.7 Examples showing the `justifyContent` options
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 展示 `justifyContent` 选项的示例
- en: '[PRE33]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![c05_18.eps](Images/c05_18.png)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![c05_18.eps](Images/c05_18.png)'
- en: '[Figure 5.18](#figureanchor5.18) Examples of how justifyContent affects the
    distribution of space between flexible child elements for each of the supported
    options: center, flex-start, flex-end, space-around, and space-between.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.18](#figureanchor5.18) 展示了 justifyContent 如何影响每个支持选项（居中、flex-start、flex-end、space-around
    和 space-between）下弹性子元素之间的空间分布。'
- en: '![c05_19.eps](Images/c05_19.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![c05_19.eps](Images/c05_19.png)'
- en: '[Figure 5.19](#figureanchor5.19) Modified examples from [figure 5.16](#figure5.16),
    using the non-default alignItems properties: center, flex-start, and flex-end'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.19](#figureanchor5.19) 使用非默认的 `alignItems` 属性（居中、flex-start 和 flex-end）修改后的示例，来自
    [图 5.16](#figure5.16)'
- en: 5.3.4 Aligning children in a container with alignItems
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 在容器中使用 alignItems 对齐子元素
- en: '`alignItems` defines how to align children along the secondary axis of their
    container. This property is declared on the parent view and affects its flex children
    just as `flexDirection` did. There are four possible values for `alignItems`:
    `stretch`, `center`, `flex-start`, and `flex-end`.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignItems` 定义了如何沿其容器的次要轴对齐子元素。此属性在父视图中声明，并影响其弹性子元素，就像 `flexDirection` 一样。`alignItems`
    有四个可能的值：`stretch`、`center`、`flex-start` 和 `flex-end`。'
- en: '`stretch` is the default, used in figures 5.17 and 5.18\. Each example component
    is stretched to fill its parent container. [Figure 5.19](#figure5.19) revisits
    [figure 5.16](#figure5.16) and shows what happens with the other options: `center`,
    `flex-start`, and `flex-end`. Because a precise width isn’t specified for the
    example components, they only take up as much space horizontally as is necessary
    to render their contents rather than stretching to fill the space. In the first
    case, `alignItems` is set to `''center''`. In the second case, `alignItems` is
    set to `''flex-start''`. And last `alignItems` is set to `''flex-end''`. Use [listing
    5.8](#listing5.8) to change the alignments on each of the examples from [listing
    5.5](#listing5.5).'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretch` 是默认值，用于图 5.17 和 5.18。每个示例组件都被拉伸以填充其父容器。[图 5.19](#figure5.19) 回顾了
    [图 5.16](#figure5.16)，并展示了使用其他选项（`center`、`flex-start` 和 `flex-end`）会发生什么。因为示例组件没有指定精确的宽度，它们只占据渲染其内容所需的水平空间，而不是拉伸以填充空间。在第一种情况下，`alignItems`
    设置为 `''center''`。在第二种情况下，`alignItems` 设置为 `''flex-start''`。最后，`alignItems` 设置为
    `''flex-end''`。使用 [列表 5.8](#listing5.8) 来更改每个示例从 [列表 5.5](#listing5.5) 中的对齐方式。'
- en: Listing 5.8 Using non-default `alignItems` properties
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 使用非默认的 `alignItems` 属性
- en: '[PRE34]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that you’ve seen how to use the other `alignItems` properties and their
    effects on the default column layout, why don’t you set `flexDirection` to `'row'`
    and see what happens?
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了如何使用其他 `alignItems` 属性及其对默认列布局的影响，为什么不将 `flexDirection` 设置为 `'row'`
    并看看会发生什么？
- en: 5.3.5 Overriding the parent container’s alignment with alignSelf
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.5 使用 `alignSelf` 覆盖父容器的对齐方式
- en: '![c05_20.eps](Images/c05_20.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![c05_20.eps](Images/c05_20.png)'
- en: '[Figure 5.20](#figureanchor5.20) How each alignSelf property affects the layout
    when its parent container’s alignItems property is set to the default value of
    stretch'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.20](#figureanchor5.20) 当父容器中的 `alignItems` 属性设置为默认值 stretch 时，每个 `alignSelf`
    属性如何影响布局'
- en: So far, all the flex properties have been applied to the parent container. `alignSelf`
    is applied directly to an individual flex child.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有弹性属性都应用于父容器。`alignSelf` 直接应用于单个弹性子元素。
- en: With `alignSelf`, you can access the `alignItems` property for individual elements
    within the container. In essence, `alignSelf` gives you the ability to override
    whatever alignment was set on the parent container, so a child object can be aligned
    independently of its peers. The available options are `auto`, `stretch`, `center`,
    `flex-start`, and `flex-end`. The default value is `auto`, which takes the value
    from the parent container’s `alignItems` setting. The remaining properties affect
    the layout in the same way as their corresponding properties on `alignItems`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `alignSelf`，你可以访问容器内单个元素的 `alignItems` 属性。本质上，`alignSelf` 给你覆盖父容器上设置的任何对齐方式的能力，因此子对象可以独立于其同伴进行对齐。可用的选项有
    `auto`、`stretch`、`center`、`flex-start` 和 `flex-end`。默认值是 `auto`，它从父容器的 `alignItems`
    设置中获取值。其余属性以与 `alignItems` 上相应属性相同的方式影响布局。
- en: In [figure 5.20](#figure5.20), the parent container doesn’t have `alignItems`
    set, so it defaults to `stretch`. In the first example, the `auto` value inherits
    `stretch` from its parent container. The next four examples lay out exactly as
    you’d expect. The final example has no `alignSelf` property set, so it defaults
    to `auto` and is laid out the same as the first example.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5.20](#figure5.20) 中，父容器没有设置 `alignItems`，因此默认为 `stretch`。在第一个例子中，`auto`
    值从其父容器继承 `stretch`。接下来的四个例子布局正如你所期望的那样。最后一个例子没有设置 `alignSelf` 属性，因此默认为 `auto`
    并与第一个例子以相同的方式布局。
- en: '[Listing 5.9](#listing5.9) does something a little different. Rather than supply
    the style directly to the`Example` element, you create a new component property:
    `align`. It’s passed down to the `Example` component and used to set `alignSelf`.
    Otherwise, the example is the same as many others in this chapter; it explores
    the effects of each value applied to the style.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.9](#listing5.9) 做了一些不同的事情。它不是直接将样式应用到 `Example` 元素上，而是创建一个新的组件属性：`align`。这个属性被传递到
    `Example` 组件中，并用来设置 `alignSelf`。否则，这个例子与本章中的许多其他例子相同；它探讨了将每个值应用到样式上的效果。'
- en: Listing 5.9 Using `alignSelf` to override the parent’s `alignItems`
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 使用 `alignSelf` 覆盖父元素的 `alignItems`
- en: '[PRE35]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 5.3.6 Preventing clipped items with flexWrap
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.6 使用 `flexWrap` 防止项目被裁剪
- en: 'You learned earlier in this section that the `flexDirection` property takes
    two values: `column` (the default) and `row`. `column` lays out items vertically,
    and `row` lays out items horizontally. What you haven’t seen is a situation in
    which items flow off the screen because they don’t fit.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之前，你已经了解到 `flexDirection` 属性有两个值：`column`（默认值）和 `row`。`column` 水平排列项目，而 `row`
    垂直排列项目。但你还没有看到项目因为不合适而溢出屏幕的情况。
- en: '`flexWrap` takes two values: `nowrap` and `wrap`. The default value is `nowrap`,
    meaning items will flow off the screen if they don’t fit. The items are clipped,
    and the user can’t see them. To work around this problem, use the `wrap` value.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`flexWrap` 有两个值：`nowrap` 和 `wrap`。默认值是 `nowrap`，这意味着如果项目不合适，它们将溢出屏幕。项目将被裁剪，用户无法看到它们。为了解决这个问题，请使用
    `wrap` 值。'
- en: In [figure 5.21](#figure5.21), the first example uses `nowrap`, and the squares
    flow off the screen. The row of squares is chopped off at the right edge. The
    second example uses `wrap`, and the squares wrap around and start a new row. [Listing
    5.10](#listing5.10) shows the code.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5.21](#figure5.21) 中，第一个例子使用了 `nowrap`，正方形溢出屏幕。正方形行在右侧被截断。第二个例子使用了 `wrap`，正方形环绕并开始新的一行。[列表
    5.10](#listing5.10) 展示了代码。
- en: '![c05_21.eps](Images/c05_21.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![c05_21.eps](Images/c05_21.png)'
- en: '[Figure 5.21](#figureanchor5.21) An example of two overflowing containers:
    one with flexWrap set to nowrap and the other with flexWrap set to wrap'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.21](#figureanchor5.21) 两个溢出容器的示例：一个将 `flexWrap` 设置为 nowrap，另一个设置为 wrap'
- en: Listing 5.10 Example of how `flexWrap` values affect layout
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 `flexWrap` 值影响布局的示例
- en: '[PRE36]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It’s easy to see which behavior is preferable when laying out tiles, but you
    may come across a situation in which `nowrap` will serve you better. Either way,
    you should now have a clear understanding of flexbox and the many ways it can
    help you build responsive layouts in React Native.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局瓷砖时，很容易看出哪种行为更可取，但你可能会遇到一种情况，其中 `nowrap` 会更适合你。无论如何，你现在应该对弹性盒子及其在 React Native
    中构建响应式布局的多种方式有清晰的理解。
- en: Summary
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When sizing items for display, iOS uses points and Android uses density-independent
    pixels. The systems of measurement are different but should have little impact
    on development unless you need pixel-perfect graphics.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在为显示调整项目大小时，iOS 使用点，而 Android 使用密度无关像素。测量系统不同，但除非你需要像素完美的图形，否则应该对开发影响不大。
- en: Some styles are only available on one platform or another. `ShadowPropTypeIOS`
    is only available on iOS, and `elevation` is only recognized on Android.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些样式仅在某个平台上可用。`ShadowPropTypeIOS` 仅在 iOS 上可用，而 `elevation` 仅在 Android 上被识别。
- en: Components can be moved in the x and y directions using the `translateX` and
    `translateY` transforms.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `translateX` 和 `translateY` 变换在 x 和 y 方向上移动组件。
- en: Components can be rotated about the x-, y-, and z-axes using `rotateX`, `rotateY`,
    and `rotateZ`. The point of rotation is the original location of the object before
    any transforms have been applied.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `rotateX`、`rotateY` 和 `rotateZ` 在 x、y 和 z 轴上围绕组件旋转。旋转点是应用任何转换之前对象的原始位置。
- en: Components can be scaled in the x and y directions to make the components grow
    or shrink.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件可以在 x 和 y 方向上缩放，以使组件增长或缩小。
- en: Components can also be skewed in the x and y directions.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件也可以在 x 和 y 方向上倾斜。
- en: Several transformations can be applied at the same time, but the order in which
    they’re specified matters. Rotating a component changes the orientation of the
    component for subsequent transformations.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以同时应用多个转换，但它们指定的顺序很重要。旋转一个组件会改变该组件在后续转换中的方向。
- en: The `flexDirection` property defines the primary axis, the default being `column`
    (y-axis).
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flexDirection` 属性定义了主轴，默认为 `column`（y轴）。'
- en: The `justifyContent` property defines how items should be laid out along the
    primary axis.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`justifyContent` 属性定义了项目应该如何沿着主轴排列。'
- en: The `alignItems` property defines how items should be laid out along the secondary
    axis.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignItems` 属性定义了项目应该如何沿着次轴排列。'
- en: The `alignSelf` property can be used to override the `alignItems` property specified
    by a parent container.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `alignSelf` 属性来覆盖由父容器指定的 `alignItems` 属性。
- en: The `flexWrap` property tells flexbox how to handle items that would typically
    overflow off the screen.**  **# 6
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flexWrap` 属性告诉弹性盒子如何处理通常会溢出屏幕的项目。**  **# 6'
- en: Navigation
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 导航
- en: '*****This chapter*** ***covers*****'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章***** ***涵盖了*****'
- en: Navigation in React Native vs. the web
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 与网页中的导航
- en: Navigating using tabs, stacks, and drawers
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签、堆栈和抽屉进行导航
- en: Managing nested navigators
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理嵌套导航器
- en: Passing data and methods between routes
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由间传递数据和方法
- en: 'One of the core pieces of functionality in any mobile application is navigation.
    Before building an application, I recommend that you spend some time strategizing
    how you want the app to handle navigation and routing. This chapter covers the
    three main types of navigation typical to mobile applications: tab-based, stack-based,
    and drawer-based navigation.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 任何移动应用的核心功能之一是导航。在构建应用之前，我建议你花些时间策略性地考虑你希望应用如何处理导航和路由。本章涵盖了移动应用中典型的三种主要导航类型：基于标签、基于堆栈和基于抽屉的导航。
- en: Tab-based navigation typically has tabs either at the top or bottom of the screen;
    pressing a tab takes you to the screen that correlates with the tab. Many popular
    apps like Twitter, Instagram, and Facebook implement this type of navigation on
    their main screens.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 基于标签的导航通常标签位于屏幕的顶部或底部；按下标签会跳转到与标签相关的屏幕。许多流行的应用，如 Twitter、Instagram 和 Facebook，都在主屏幕上实现了这种类型的导航。
- en: 'Stack-based navigation transitions from one screen to another, replacing the
    current screen, and usually implements some sort of animated transition. You can
    then go backward or continue moving forward in the stack. You can think of stack-based
    navigation like an array of components: pushing a new component into the array
    takes you to the screen of the new component. To go back, you pop the last screen
    from the stack and are navigated to the previous screen. Most navigation libraries
    handle this popping and pushing for you.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 基于堆栈的导航从一个屏幕转换到另一个屏幕，替换当前屏幕，并通常实现某种形式的动画转换。然后你可以后退或继续向前移动堆栈。你可以将基于堆栈的导航想象成一个组件数组：将新的组件推入数组会带你到新组件的屏幕。要返回，你需要从堆栈中弹出最后一个屏幕，然后导航到上一个屏幕。大多数导航库都会为你处理弹出和推入。
- en: Drawer-based navigation is typically a side menu that pops out from either the
    left or right side of the screen and shows a list of options. When you press an
    option, the drawer closes, and you’re taken to the new screen.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 基于抽屉的导航通常是一个从屏幕的左侧或右侧弹出并显示选项列表的侧边菜单。当你按下某个选项时，抽屉关闭，你将被带到新的屏幕。
- en: The React Native framework doesn’t include a navigation library. When building
    navigation in a React Native app, you have to go with a third-party navigation
    library. A few good navigation libraries are available, but in this chapter, I
    use React Navigation as the navigation library of choice to build out the demo
    app. The React Navigation library is recommended by the React Native team and
    is maintained by many people in the React and React Native community.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: React Native框架不包含导航库。在构建React Native应用的导航时，你必须选择一个第三方导航库。有一些好的导航库可供选择，但在这个章节中，我选择使用React
    Navigation作为构建演示应用的导航库。React Navigation库由React Native团队推荐，并由React和React Native社区的许多人维护。
- en: 'React Navigation is a JavaScript-based navigation implementation. All the transitions
    and controls are handled by JavaScript. Some teams prefer a native solution for
    many reasons: for instance, they may be adding React Native to an existing native
    app and want navigation to be consistent throughout the app. If you’re interested
    in a native navigation solution, check out React Native Navigation, an open source
    React Native navigation library built and maintained by the engineers at Wix.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: React Navigation是一个基于JavaScript的导航实现。所有的转换和控制都由JavaScript处理。有些团队可能因为多种原因而偏好原生解决方案：例如，他们可能正在将React
    Native添加到现有的原生应用中，并希望整个应用中的导航保持一致。如果你对原生导航解决方案感兴趣，可以查看React Native Navigation，这是一个由Wix的工程师构建和维护的开源React
    Native导航库。
- en: 6.1 React Native navigation vs. web navigation
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 React Native导航与网络导航的比较
- en: Because the paradigm of navigation on the web is much different than that of
    React Native, navigation is a stumbling block for many developers new to React
    Native. On the web, we’re used to working with URLs. There are many ways to navigate
    to a new route, depending on the framework or environment, but typically you want
    to send the user to a new URL and maybe add some URL parameters if needed.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 因为网络导航的范式与React Native的范式大不相同，所以导航对于许多刚开始接触React Native的开发者来说是一个难题。在网络上，我们习惯于使用URL进行操作。根据框架或环境的不同，有多种方式可以导航到新的路由，但通常你希望将用户发送到新的URL，如果需要的话，还可以添加一些URL参数。
- en: In React Native, routes are based around components. You load or show a component
    using the navigator you’re working with. Depending on whether it’s tab based,
    stack based, drawer based, or a combination of these, the routing will also differ.
    We’ll walk through all this when you build the demo app in the next section.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中，路由是基于组件的。你使用你正在工作的导航器来加载或显示一个组件。根据它是基于标签、基于堆栈、基于抽屉还是这些的组合，路由也会有所不同。我们将在下一节构建演示应用时详细说明这些内容。
- en: You also need to keep up with the data and state throughout the routes and possibly
    access methods defined elsewhere in the app, so having a strategy around data
    and method sharing is important. You can manage data and methods either at the
    top level, where the navigation is defined, or using a state-management library
    such as Redux or MobX. In the example, you’ll manage data and methods in the class
    at the top level of the app.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在整个路由中跟踪数据和状态，并可能访问应用中其他地方定义的方法，因此围绕数据和方法的共享策略非常重要。你可以通过在定义导航的顶层管理数据和方法，或者使用如Redux或MobX这样的状态管理库来管理数据和方法。在示例中，你将在应用顶层的类中管理数据和方法的。
- en: 6.2 Building a navigation-based app
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 构建基于导航的应用
- en: In this chapter, you’ll learn how to implement navigation by building out an
    app that uses both tab-based and stack-based navigation. The app you’ll create
    is called Cities; it’s shown in [figure 6.1](#figure6.1). It’s a travel app that
    lets you keep up with all the cities you visit or want to visit. You can also
    add locations in each city you want to visit.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何通过构建一个同时使用基于标签页和基于堆栈的导航的应用来实施导航。你将创建的应用程序名为Cities；它在[图6.1](#figure6.1)中显示。它是一个旅行应用，让你能够跟踪你访问或想要访问的所有城市。你还可以在每个你想要访问的城市中添加位置。
- en: '![c06_01.tif](Images/c06_01.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![c06_01.tif](Images/c06_01.png)'
- en: '[Figure 6.1](#figureanchor6.1) Completed Cities app with screens for adding
    a city, listing cities, viewing city details, and viewing locations within the
    city'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.1](#figureanchor6.1) 完成的Cities应用，包含添加城市、列出城市、查看城市详情和查看城市内位置的功能界面'
- en: The main navigation is tab based, and one of the tabs includes a stack-based
    navigation. The left tab shows the list of cities you’ve created, and the right
    tab contains a form to create new cities. On the left tab, you can press an individual
    city to view it as well as view and create locations in the city.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 主要导航是基于标签页的，其中一个标签页包括基于堆栈的导航。左侧标签页显示你创建的城市列表，右侧标签页包含创建新城市的表单。在左侧标签页，你可以点击单个城市来查看它，以及查看和创建城市内的位置。
- en: 'To get started, create a new React Native application. In your terminal, navigate
    to an empty directory, and install the new React Native application using the
    React Native CLI:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个新的React Native应用。在你的终端中，导航到一个空目录，并使用React Native CLI安装新的React Native应用：
- en: '[PRE37]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, navigate into the new directory, and install two dependencies: React
    Navigation and uuid. React Navigation is the navigation library, and uuid will
    be used to create unique IDs for cities in order to identify them uniquely:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导航到新目录，并安装两个依赖项：React Navigation和uuid。React Navigation是导航库，uuid将被用于为城市创建唯一的ID，以便唯一地识别它们：
- en: '[PRE38]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let’s get to work creating components! Create a new main directory called
    src in the root of the application. This directory will hold most of the new code
    for the app. In this new directory, add three main subdirectories: Cities, AddCity,
    and components.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始创建组件！在应用的根目录下创建一个新的主目录，命名为src。这个目录将包含应用的大部分新代码。在这个新目录中，添加三个主要子目录：Cities、AddCity和components。
- en: 'Because the main navigation is tab based, you’ll separate the main application
    into two main components (`Cities` and `AddCity`), each having its own tab. The
    AddCity folder will only contain a single component, AddCity.js. The Cities folder
    will contain two components: Cities.js to view the list of cities, and City.js
    to view an individual city. The components folder will hold any reusable components;
    in this case, it will hold a single component.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主要导航是基于标签页的，所以你会将主要应用分为两个主要组件（`Cities`和`AddCity`），每个组件都有自己的标签页。AddCity文件夹将只包含一个组件，AddCity.js。Cities文件夹将包含两个组件：Cities.js用于查看城市列表，City.js用于查看单个城市。components文件夹将包含任何可重用组件；在这个例子中，它将包含一个组件。
- en: You’ll also have src/index.js and src/theme.js files. src/index.js will hold
    all the navigation configuration, and theme.js will be where you keep themeable
    configuration—in this case, a primary color configuration. [Figure 6.2](#figure6.2)
    shows the project’s complete folder structure.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将拥有src/index.js和src/theme.js文件。src/index.js将包含所有的导航配置，而theme.js将用于保存可主题化的配置——在这个例子中，是一个主色调配置。[图6.2](#figure6.2)显示了项目的完整文件夹结构。
- en: Now that you’ve created the folder structure and installed the necessary dependencies,
    let’s write some code. The first file you’ll work with is src/theme.js. Here,
    you’ll set the primary color and make it exportable for use in the app. The theme
    color I’ve chosen for the app is blue, but feel free to use any color you want;
    the app will work the same if you change the color value in this file.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了文件夹结构和安装了必要的依赖项，让我们开始编写代码。你将首先处理的是src/theme.js文件。在这里，你将设置主色调并使其可导出以在应用中使用。我为应用选择的主色调是蓝色，但你可以自由选择任何颜色；如果你更改这个文件中的颜色值，应用的工作方式将保持不变。
- en: '![c06_02.png](Images/c06_02.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![c06_02.png](Images/c06_02.png)'
- en: '[Figure 6.2](#figureanchor6.2) The complete src folder structure'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.2](#figureanchor6.2) 完整的src文件夹结构'
- en: Listing 6.1 Creating a theme file with a primary color
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 创建包含主色调的主题文件
- en: '[PRE39]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can import this primary color throughout the application if you wish, and
    change it in one place if you choose to do so.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以在整个应用中导入这个主色调，并且可以选择在一个地方更改它。
- en: 'Next, edit src/index.js to create the main navigation configuration. You’ll
    create both navigation instances here: the tab-based navigation and the stack-based
    navigation.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑 src/index.js 以创建主导航配置。你将在这里创建两个导航实例：基于标签的导航和基于堆栈的导航。
- en: Listing 6.2 Creating the navigation configuration
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 创建导航配置
- en: '[PRE40]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you create the `options` object, the stack navigator automatically places
    a header at the top of each route. The header is usually where you’ll have the
    title of the current route as well as buttons like a Back button. The `options`
    object also defines the background color and the tint color of the header.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 `options` 对象时，堆栈导航器会自动在每个路由的顶部放置一个标题。标题通常是放置当前路由标题以及像返回按钮这样的按钮的地方。`options`
    对象还定义了标题的背景颜色和色调颜色。
- en: 'For the first navigation instance, `createStackNavigator` takes two arguments:
    the route configuration and any configuration regarding things like styling to
    apply to the navigation. You pass in two routes as the first argument, and the
    `options` object as the second argument.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个导航实例，`createStackNavigator` 接受两个参数：路由配置以及有关应用导航的样式配置等。你将两个路由作为第一个参数传递，并将
    `options` 对象作为第二个参数传递。
- en: Next, update App.js to include the new navigation and render it as the main
    entry point. In addition to rendering the navigation component, App.js will contain
    and control any methods and data to be made available to the application.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 App.js 以包含新的导航并作为主入口点渲染。除了渲染导航组件外，App.js 还将包含并控制任何要提供给应用的方法和数据。
- en: Listing 6.3 Updating App.js to use the navigation configuration
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 更新 App.js 以使用导航配置
- en: '[PRE41]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'App.js has three main pieces of functionality. It creates the initial state
    of the app: an empty array called `cities`. Each city will be an object and will
    have a name, country, ID, and array of locations. The `addCity` method lets you
    add new cities to the `cities` array stored in the state. The `addLocation` method
    identifies the city you want to add a location to, updates the city, and resets
    the state with the new data.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: App.js 包含三个主要功能。它创建应用初始状态：一个名为 `cities` 的空数组。每个城市将是一个对象，包含名称、国家、ID 和位置数组。`addCity`
    方法允许你向状态中存储的 `cities` 数组添加新的城市。`addLocation` 方法识别你想要添加位置的特定城市，更新该城市，并使用新数据重置状态。
- en: React Navigation has a way to pass these methods and the state down to all the
    routes being used by the navigator. To do this, pass a prop called `screenProps`
    containing whatever you want access to. Then, from within any route, `this.props.screenProps`
    gives access to the data or methods.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: React Navigation 有一种方法可以将这些方法和状态传递给导航器使用的所有路由。为此，传递一个名为 `screenProps` 的属性，包含你想要访问的内容。然后，从任何路由内部，`this.props.screenProps`
    提供了对数据或方法的访问。
- en: Next, you’ll create a reusable component called `CenterMessage`, which is used
    in Cities.js and City.js (src/components/CenterMessage.js). It displays a message
    when the array is empty. For example, when the app first starts, it won’t have
    any cities to list; you can display a message as shown in [figure 6.3](#figure6.3),
    instead of just showing a blank screen.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个名为 `CenterMessage` 的可重用组件，它在 Cities.js 和 City.js（src/components/CenterMessage.js）中使用。当数组为空时，它将显示消息。例如，当应用首次启动时，它不会有任何城市要列出；你可以显示如图
    6.3 所示的消息，而不是只显示一个空白屏幕。
- en: Listing 6.4 `CenterMessage` component
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 `CenterMessage` 组件
- en: '[PRE42]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![c06_03.tif](Images/c06_03.png)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![c06_03.tif](Images/c06_03.png)'
- en: '[Figure 6.3](#figureanchor6.3) The reusable CenterMessage component displays
    a message centered within the display.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.3](#figureanchor6.3) 可重用的 CenterMessage 组件在显示区域中居中显示消息。'
- en: '![c06_04.tif](Images/c06_04.png)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![c06_04.tif](Images/c06_04.png)'
- en: '[Figure 6.4](#figureanchor6.4) AddCity tab allows the user to enter a new city
    name and the country name.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.4](#figureanchor6.4) AddCity 标签页允许用户输入新的城市名称和国家名称。'
- en: This component is straightforward. It’s a stateless component that receives
    only a message as a prop and displays the message along with some styling.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件很简单。它是一个无状态组件，仅接收一个消息作为属性，并显示该消息以及一些样式。
- en: 'Next, in src/AddCity/AddCity.js, create the `AddCity` component that will allow
    you to add new cities to the `cities` array (see [figure 6.4](#figure6.4)). This
    component will contain a form with two text inputs: one to hold the city name
    and one to hold the country name. In addition, a button will call the `addCity`
    method from App.js.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 src/AddCity/AddCity.js 中，创建 `AddCity` 组件，该组件将允许你向 `cities` 数组添加新城市（参见
    [图 6.4](#figure6.4)）。这个组件将包含一个表单，其中包含两个文本输入：一个用于保存城市名称，另一个用于保存国家名称。此外，一个按钮将调用
    App.js 中的 `addCity` 方法。
- en: Listing 6.5 AddCity tab (functionality)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 AddCity 选项卡（功能）
- en: '[PRE43]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, you check to make sure neither the city nor the country is an empty string.
    If either or both are empty, you return, because you don’t want to store the data
    unless both fields are filled out. Next, you create an object to hold the city
    being adding to the `cities` array. Take the existing city and country values
    stored on the state, and add an ID value using the `uuidV4` method and an empty
    locations array. Call `this.props.screenProps.addCity`, passing in the new city.
    Next, reset the state to clear out any values stored in the state. Finally, navigate
    the user to the Cities tab to show them their list of cities with the new city
    added, by calling `this.props.navigation.navigate` and passing in the string of
    the route to navigate to—in this case, `'Cities'`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你检查确保城市和国家都不是空字符串。如果任一或两个都是空的，你将返回，因为你不想在不填写两个字段的情况下存储数据。接下来，你创建一个对象来保存要添加到
    `cities` 数组中的城市。从状态中获取现有的城市和国家值，并使用 `uuidV4` 方法添加一个 ID 值以及一个空的位置数组。调用 `this.props.screenProps.addCity`，传入新的城市。然后重置状态以清除状态中存储的任何值。最后，通过调用
    `this.props.navigation.navigate` 并传入要导航到的路由字符串——在这种情况下，是 `'Cities'`——将用户导航到城市选项卡以显示他们添加了新城市后的城市列表。
- en: 'Every component that’s a screen in a navigator automatically has access to
    two props: `screenProps` and `navigation`. In [listing 6.3](#listing6.3), when
    you created the navigation component, you passed in three `screenProps`. In the
    `submit` method, you called `this.props.screenProps.addCity`, accessing and invoking
    this `screenProps` method. You also access the navigation prop by calling `this.props.navigation.navigate`.
    `navigate` is what you use to navigate between routes in React Navigation.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在导航器中作为屏幕的组件自动可以访问两个属性：`screenProps` 和 `navigation`。在 [列表 6.3](#listing6.3)
    中，当你创建导航组件时，你传递了三个 `screenProps`。在 `submit` 方法中，你调用了 `this.props.screenProps.addCity`，访问并调用这个
    `screenProps` 方法。你同样通过调用 `this.props.navigation.navigate` 来访问导航属性。`navigate` 是你在
    React Navigation 中用于在路由间导航的方法。
- en: Next, add the styles for this component. This code goes below the class definition
    in src/AddCity/AddCity.js.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为这个组件添加样式。这段代码位于 src/AddCity/AddCity.js 中的类定义下方。
- en: Listing 6.6 AddCity tab (styling)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 AddCity 选项卡（样式）
- en: '[PRE44]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, create src/Cities/Cities.js to list all the cities the app is storing and
    allow the user to navigate to an individual city (see [figure 6.5](#figure6.5)).
    The functionality is shown in the following listing, and the styling is in [listing
    6.8](#listing6.8).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建 src/Cities/Cities.js 以列出应用程序存储的所有城市并允许用户导航到单个城市（参见 [图 6.5](#figure6.5)）。功能在下面的列表中显示，样式在
    [列表 6.8](#listing6.8) 中。
- en: '![c06_05.png](Images/c06_05.png)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![c06_05.png](Images/c06_05.png)'
- en: '[Figure 6.5](#figureanchor6.5) Cities.js displays a list of cities that have
    been added to the application.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.5](#figureanchor6.5) Cities.js 显示了已添加到应用程序中的城市列表。'
- en: Listing 6.7 Cities route (functionality)
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 Cities 路由（功能）
- en: '[PRE45]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this listing, you first import the `CenterMessage` component. React Navigation
    has a way to control certain options around the navigation within a route. To
    do so, you can declare a static `navigationOptions` property on the class and
    declare the configuration for a route. In this case, you want to set a title and
    style the title, so give the configuration a `title` and `headerTitleStyle` property.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，你首先导入 `CenterMessage` 组件。React Navigation 有一种方法可以控制路由内的某些导航选项。为此，你可以在类上声明一个静态的
    `navigationOptions` 属性并声明路由的配置。在这种情况下，你想要设置一个标题并设置标题的样式，因此给配置添加一个 `title` 和 `headerTitleStyle`
    属性。
- en: The `navigate` method calls `this.props.navigation.navigate` and passes in the
    route name as well as the city to access to in the `City` route. Pass in the city
    as the second argument; in the `City` route, you’ll have access to this property
    in `props.navigation.state.params`. The render method accesses and destructures
    the `cities` array. It also includes logic to check whether the `cities` array
    is empty; if it is, show the user an appropriate message. You map over all the
    cities in the array, displaying the city name and country name. Attaching the
    `navigate` method to the `TouchableWithoutFeedback` component lets users navigate
    to the city by pressing anywhere on the city.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigate`方法调用`this.props.navigation.navigate`，并传入路由名称以及要访问的`City`路由中的城市。传入城市作为第二个参数；在`City`路由中，你将能够访问`props.navigation.state.params`中的此属性。渲染方法访问并解构`cities`数组。它还包括检查`cities`数组是否为空的逻辑；如果是，向用户显示适当的消息。你映射数组中的所有城市，显示城市名称和国家名称。将`navigate`方法附加到`TouchableWithoutFeedback`组件，允许用户通过在城市上的任何地方点击来导航到城市。'
- en: Listing 6.8 Cities route (styling)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 Cities路由（样式）
- en: '[PRE46]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![c06_06.png](Images/c06_06.png)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
  zh: '![c06_06.png](Images/c06_06.png)'
- en: '[Figure 6.6](#figureanchor6.6) City.js shows locations within the city.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.6](#figureanchor6.6) City.js显示了城市内的地点。'
- en: Next, create the `City` component (src/Cities/City.js) to hold the locations
    for each city as well as a form that lets users create a new location in a city;
    see [figure 6.6](#figure6.6). This component will access the cities from `screenProps`
    and will also use the `addLocation` method from `screenProps` to add a location
    to the city.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`City`组件（src/Cities/City.js），用于存储每个城市的地点以及一个允许用户在 cities 中创建新地点的表单；参见[图6.6](#figure6.6)。此组件将从`screenProps`中访问城市，并使用`screenProps`中的`addLocation`方法向城市添加地点。
- en: Listing 6.9 City route (functionality)
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 City路由（功能）
- en: '[PRE47]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code first creates the `navigationOptions` property. You use a callback
    function to return an object instead of just declaring an object, because you
    need access to the props in order to have access to the city information passed
    down by the navigation. You need to know the city title for use as the route title
    instead of a hard-coded string.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先创建`navigationOptions`属性。你使用回调函数来返回一个对象，而不是直接声明一个对象，因为你需要访问属性，以便访问通过导航传递下来的城市信息。你需要知道城市标题，用作路由标题，而不是硬编码的字符串。
- en: The `addLocation` method destructures the `city` object available from `this.props.navigation.state.params`
    for use later in the function. You then create a `location` object holding the
    location name and info. Calling `this.props.screenProps.addLocation` adds the
    location to the city you’re currently viewing and then resets the state. Again,
    destructure `city` from the navigation state. You need `city` in order to map
    over the locations in the city and also to use as an argument when creating a
    new location, to identify the city you’re referencing. Finally, you map over the
    cities, returning a component that displays both the city name and city information,
    and create the form with two text inputs and a button.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`addLocation`方法从`this.props.navigation.state.params`中解构`city`对象，以便在函数中稍后使用。然后创建一个包含地点名称和信息的`location`对象。调用`this.props.screenProps.addLocation`将地点添加到当前查看的城市，并重置状态。再次，从导航状态中解构`city`。你需要`city`以便在城市的地点上映射，并在创建新地点时作为参数使用，以标识你引用的城市。最后，你映射城市，返回一个显示城市名称和城市信息的组件，并创建一个包含两个文本输入和一个按钮的表单。'
- en: 6.3 Persisting data
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 持久化数据
- en: You’re finished and should be able to run the app. Play around with the app,
    add cities and locations, and then refresh it. Notice that all the cities disappear
    when you refresh. This is because you’re only storing the data in memory. Let’s
    use `AsyncStorage` to persist the state, so if the user closes or refreshes the
    app, their data remains available.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成，应该能够运行应用程序。在应用程序中尝试添加城市和地点，然后刷新它。注意，当你刷新时，所有城市都会消失。这是因为你只将数据存储在内存中。让我们使用`AsyncStorage`来持久化状态，这样如果用户关闭或刷新应用程序，他们的数据仍然可用。
- en: 'To do so, you’ll work in the `App` component in App.js and do the following:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你将在`App`组件的App.js中工作，并执行以下操作：
- en: Store the cities array in `AsyncStorage` every time a new city is added.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次添加新城市时，将城市数组存储在`AsyncStorage`中。
- en: Store the cities array in `AsyncStorage` every time a new location is added
    to a city.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次向城市添加新地点时，将城市数组存储在`AsyncStorage`中。
- en: When the user opens the app, check `AsyncStorage` to see whether any cities
    are stored there. If so, update the state with those cities.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户打开应用时，检查 `AsyncStorage` 以查看是否存储了任何城市。如果是，则使用这些城市更新状态。
- en: '`AsyncStorage` only accepts strings for stored values. So, when storing a value,
    call `JSON.stringify` on the value if it isn’t already a string, and `JSON.parse`
    if you want to parse the stored value before using it.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncStorage` 只接受字符串作为存储值。因此，在存储值时，如果该值不是字符串，请调用 `JSON.stringify`，如果在使用前需要解析存储的值，请调用
    `JSON.parse`。'
- en: 'Open App.js and make the changes:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 App.js 并进行以下更改：
- en: Import `AsyncStorage`, and create a key variable.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `AsyncStorage` 并创建一个键变量。
- en: '[PRE48]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a `componentDidMount` function that will check for `AsyncStorage` and
    get any item stored there with the key value you set:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `componentDidMount` 函数，该函数将检查 `AsyncStorage` 并获取您设置的键值存储的任何项：
- en: '[PRE49]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `addCity` method, store the `cities` array in `AsyncStorage` after the
    new `cities` array has been created:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `addCity` 方法中，在创建新的 `cities` 数组后，将其存储在 `AsyncStorage` 中：
- en: '[PRE50]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Update the `addLocation` method to store the city array after `setState` has
    been called.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `addLocation` 方法，在调用 `setState` 后存储城市数组。
- en: '[PRE51]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, when the user opens the app after closing it, their data will still be
    available.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户关闭应用后再打开它，他们的数据仍然可用。
- en: 6.4 Using DrawerNavigator to create drawer-based navigation
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 使用 DrawerNavigator 创建基于抽屉的导航
- en: We’ve gone over how to create stack-based and tab-based navigation. Let’s look
    at the API for creating drawer-based navigation.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何创建基于堆栈和基于标签的导航。让我们看看创建基于抽屉导航的 API。
- en: 'The drawer navigator has an API very similar to that of the stack and tab navigators.
    You’ll use the `createDrawerNavigator` function from React Navigation to create
    a drawer-based navigation. First define the routes to use:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 抽屉导航器的 API 与堆栈和标签导航器非常相似。您将使用 React Navigation 中的 `createDrawerNavigator` 函数来创建基于抽屉的导航。首先定义要使用的路由：
- en: '[PRE52]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, define the screens you want used in the navigator:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义您想要在导航器中使用的屏幕：
- en: '[PRE53]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now you can define the navigator using the screen configuration and use it
    in the app:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用屏幕配置来定义导航器，并在应用中使用它：
- en: '[PRE54]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Summary
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Before building an application, spend time strategizing how you want it to handle
    navigation and routing.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建应用之前，花时间策略化您希望它如何处理导航和路由。
- en: Many navigation libraries are available for React Native, but the two most recommended
    are React Navigation and React Native Navigation. React Navigation is a JavaScript-based
    navigation library, and React Native Navigation is a native implementation.
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多导航库适用于 React Native，但最推荐的两个是 React Navigation 和 React Native Navigation。React
    Navigation 是一个基于 JavaScript 的导航库，而 React Native Navigation 是一个原生实现。
- en: 'There are three main types of navigators:'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要有三种类型的导航器：
- en: Tab-based navigation typically has tabs either at the top or bottom of the screen.
    When you press a tab, you’re taken to the screen that correlates with that tab.
    For example, `createBottomTabNavigator` creates tabs at the bottom of the screen.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于标签的导航通常在屏幕的顶部或底部有标签。当您按下标签时，您将被带到与该标签相关的屏幕。例如，`createBottomTabNavigator` 在屏幕底部创建标签。
- en: Stack-based navigation transitions from one screen to another, replacing the
    current screen. You can go backward or continue moving forward in the stack. Stack-based
    navigation usually implements some sort of animated transition. You create stack-based
    navigation using the `createStackNavigator` function.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于堆栈的导航从一个屏幕切换到另一个屏幕，替换当前屏幕。您可以在堆栈中向后或继续向前移动。基于堆栈的导航通常实现某种动画过渡。您使用 `createStackNavigator`
    函数创建基于堆栈的导航。
- en: Drawer-based navigation is typically a menu that pops out from either the left
    or right side of the screen and shows a list of options. When you press an option,
    the drawer closes and you’re taken to the new screen. You create drawer-based
    navigation using the `createDrawerNavigator` function.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于抽屉的导航通常是一个从屏幕的左侧或右侧弹出的菜单，显示一系列选项。当您按下选项时，抽屉关闭，您将被带到新的屏幕。您使用 `createDrawerNavigator`
    函数创建基于抽屉的导航。
- en: Depending on which kind of navigation you use—tab-based, stack-based, drawer-based,
    or a combination of these—the routing will also differ. Every route or screen
    managed by the React Navigation library has a `navigation` prop you can use to
    control the navigation state.
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您使用的导航类型——基于标签、基于堆栈、基于抽屉或这些类型的组合——路由也会有所不同。React Navigation 库管理的每个路由或屏幕都有一个
    `navigation` 属性，您可以使用它来控制导航状态。
- en: Use `AsyncStorage` to persist state so if the user closes or refreshes the app,
    their data is still available.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AsyncStorage`持久化状态，以便如果用户关闭或刷新应用程序，他们的数据仍然可用。
- en: '7'
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Animations
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 动画
- en: '*****This chapter*** ***covers*****'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章*** ***涵盖*****'
- en: Creating basic animations using `Animated.timing`
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Animated.timing`创建基本动画
- en: Using interpolation with animated values
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插值与动画值
- en: Creating animations and in parallel
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画和并行
- en: Staggering animations using `Animated.stagger`
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Animated.stagger`交错动画
- en: Using the native driver to offload animations to the native UI thread
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生驱动程序将动画卸载到原生UI线程
- en: One of the great things about React Native is the ability to easily create animations
    using the Animated API. This is one of the more stable and easy to use React Native
    APIs, and it’s one of the few places in the React Native ecosystem where, unlike
    areas such as navigation and state management, there’s almost 100% agreement on
    how a problem should be solved.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的其中一个优点是能够轻松地使用Animated API创建动画。这是React Native中更稳定且易于使用的API之一，并且在React
    Native生态系统中，与导航和状态管理等领域不同，几乎有100%的共识来解决一个问题。
- en: Animations are usually used to enhance the UI of an application and bring more
    life to the existing design. Sometimes, the difference between an average and
    above-average user experience can be attributed to using the right animations
    at the right time, thus setting an app apart from other, similar apps.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 动画通常用于增强应用程序的UI，并为现有设计带来更多活力。有时，平均用户体验与优秀用户体验之间的差异可以归因于在正确的时间使用正确的动画，从而将应用程序与其他类似的应用程序区分开来。
- en: 'Real-world use cases that we cover in this chapter include the following:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涵盖的实际用例包括以下内容：
- en: Expanding user inputs that animate when focused
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展用户输入，当聚焦时进行动画
- en: Animated welcome screens that have more life than a basic static welcome screen
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画欢迎界面比基本的静态欢迎界面更具活力
- en: A custom animated loading indicator
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义动画加载指示器
- en: In this chapter, we dive deeply into how to create animations. We’ll cover everything
    you need to know to take full advantage of the Animated API.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨如何创建动画。我们将涵盖您需要了解的一切，以充分利用Animated API。
- en: 7.1 *Introducing the Animated API*
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 *介绍Animated API*
- en: 'The Animated API ships with React Native, so to use it, all you have to do
    is import it as you would any other React Native API or component. When creating
    an animation, you always need to do the following four things:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: Animated API随React Native一起提供，因此要使用它，您只需像导入任何其他React Native API或组件一样导入它。在创建动画时，您始终需要执行以下四个操作：
- en: Import Animated from React Native.
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从React Native导入Animated。
- en: Create an animatable value using the Animated API.
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Animated API创建一个可动画化的值。
- en: Attach the value to a component as a style.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值附加到组件作为样式。
- en: Animate the animatable value using a function.
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个函数动画化可动画化的值。
- en: 'Out of the box, four types of animatable components ship with the Animated
    API:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Animated API附带四种可动画化组件：
- en: '`View`'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View`'
- en: '`ScrollView`'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`'
- en: '`Text`'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text`'
- en: '`Image`'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`'
- en: The examples in this chapter work exactly the same across any of these components.
    In section 7.5, we also cover how to create a custom animated component using
    any element or component with `createAnimatedComponent`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例在这些组件上工作方式完全相同。在第7.5节中，我们还介绍了如何使用`createAnimatedComponent`创建任何元素或组件的自定义动画组件。
- en: Let’s take a quick look at what a basic animation might look like using Animated.
    In the example, you’ll animate the top margin of a box (see [figure 7.1](#figure7.1)).
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下使用Animated的基本动画可能是什么样子。在示例中，您将动画化一个框的顶部边距（见[图7.1](#figure7.1)）。
- en: Listing 7.1 Using Animated and updating the `marginTop` property
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 使用Animated和更新`marginTop`属性
- en: '[PRE55]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![c07_01.eps](Images/c07_01.png)'
  id: totrans-695
  prefs: []
  type: TYPE_IMG
  zh: '![c07_01.eps](Images/c07_01.png)'
- en: '[Figure 7.1](#figureanchor7.1) Animating the top margin of a square box using
    Animated'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.1](#figureanchor7.1) 使用Animated动画化一个正方形框的顶部边距'
- en: 'This example uses the `timing` function to animate a value. The `timing` function
    takes two arguments: a starting value and a configuration object. The configuration
    object is passed a `toValue` to set the value the animation should animate to,
    and a duration in milliseconds to set the length of the animation.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用`timing`函数来动画化一个值。`timing`函数接受两个参数：一个起始值和一个配置对象。配置对象传递一个`toValue`来设置动画应该动画化的值，以及一个以毫秒为单位的持续时间来设置动画的长度。
- en: 'Rather than a `View` component, you use an `Animated.View`. Animated has four
    components that can be animated out of the box: `View`, `Image`, `ScrollView`,
    and `Text`. In the styling of the `Animated.View`, you pass in an array of styles
    consisting of a base style (`styles.box`) and an animated style (`marginTop`).'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 与`View`组件不同，你使用`Animated.View`。Animated有四个可以开箱即用的可动画组件：`View`、`Image`、`ScrollView`和`Text`。在`Animated.View`的样式化中，你传入一个包含基本样式（`styles.box`）和动画样式（`marginTop`）的样式数组。
- en: Now that you’ve created a basic animated component, you’ll create a few more
    animations using real-world use cases that may come in handy.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个基本的动画组件，你将使用可能有用的真实世界用例创建更多动画。
- en: 7.2 Animating a form input to expand on focus
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 动画化表单输入以在聚焦时扩展
- en: In this example, you’ll create a basic form input that expands when the user
    focuses it, and contracts when the input is blurred. This is a popular UI pattern.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将创建一个基本的表单输入，当用户聚焦时它会扩展，当输入失焦时会收缩。这是一个流行的UI模式。
- en: Along with the props that you’ve used with the `TextInput` component so far
    in this book, such as `value`, `placeholder`, and `onChangeText`, you can also
    use `onFocus` and `onBlur` to call functions when the inputs are focused and blurred.
    That’s how you’ll achieve this animation (shown in figure 7.2).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在这本书中与`TextInput`组件一起使用的属性，例如`value`、`placeholder`和`onChangeText`，你还可以使用`onFocus`和`onBlur`在输入聚焦和失焦时调用函数。这就是你将实现这种动画（如图7.2所示）的方式。
- en: Listing 7.2 Animating a TextInput to expand when the input is focused
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 动画化TextInput以在输入聚焦时扩展
- en: '[PRE56]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![c07_02.eps](Images/c07_02.png)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
  zh: '![c07_02.eps](Images/c07_02.png)'
- en: Figure 7.2 Animating a `TextInput` component when the input is focused
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 当输入聚焦时动画化`TextInput`组件
- en: 7.3 Creating a custom loading animation using interpolation
  id: totrans-707
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 使用插值创建自定义加载动画
- en: Many times, you need to create animations that are infinite loops, such as loading
    indicators and activity indicators. One easy way to create such animations is
    to use the `Animated.loop` function. In this section, you use `Animated.loop`
    along with the Easing module to create a loading indicator, spinning an image
    in an infinite loop!
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你需要创建无限循环的动画，例如加载指示器和活动指示器。创建此类动画的一种简单方法是用`Animated.loop`函数。在本节中，你将使用`Animated.loop`与Easing模块一起创建一个加载指示器，无限循环地旋转图像！
- en: 'So far, we’ve only looked at calling an animation using `Animated.timing`.
    In this example, you want the animation to run continuously without stopping.
    To do this, you’ll use a new static method called `loop`. `Animated.loop` runs
    a given animation continuously: each time it reaches the end, it resets to the
    beginning and starts again.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了如何使用`Animated.timing`调用动画。在这个例子中，你希望动画持续运行而不停止。为此，你将使用一个新的静态方法`loop`。`Animated.loop`会持续运行给定的动画：每次到达末尾时，它会重置到开始并重新开始。
- en: 'You’ll also deal with styling a little differently than in the past. In listings
    7.1 and 7.2, you used the animated value directly in the `style` prop of the component.
    In subsequent examples, you’ll store these animation values in variables and interpolate
    the values before using the new interpolated variables in the `style` prop. Because
    you’re creating a spinning effect, you’ll use strings instead of numbers: for
    example, you’ll reference a value such as `360deg` for `style`.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 你将比过去以不同的方式处理样式。在列表7.1和7.2中，你直接在组件的`style`属性中使用动画值。在后续的例子中，你将在变量中存储这些动画值，并在使用新的插值变量在`style`属性之前对值进行插值。因为你要创建一个旋转效果，所以你会使用字符串而不是数字：例如，你将引用一个如`360deg`的值用于`style`。
- en: 'Animated has a class method called `interpolate` that you can use to manipulate
    animated values, changing them into other values that you can also use. The `interpolate`
    method takes a configuration object with two keys: `inputRange` (array) and `outputRange`
    (also an array). `inputRange` is the original animated values you work with in
    a class, and `outputRange` specifies the values the original values should be
    changed to.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: Animated有一个名为`interpolate`的类方法，你可以使用它来操作动画值，将它们转换为你可以使用的其他值。`interpolate`方法接受一个包含两个键的配置对象：`inputRange`（数组）和`outputRange`（也是一个数组）。`inputRange`是在类中处理的原始动画值，而`outputRange`指定了原始值应更改到的值。
- en: Finally, you’ll change the easing value of the animation. *Easing* basically
    allows you to control the animation’s motion. In this example, you want a smooth,
    even motion for the spin effect, so you’ll use a linear easing function.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将更改动画的缓动值。*缓动*基本上允许您控制动画的运动。在这个例子中，您希望旋转效果有一个平滑、均匀的运动，所以您将使用线性缓动函数。
- en: 'React Native has a built-in way to implement common easing functions. Just
    as you’ve imported other APIs and components, you can import the Easing module
    and use it along with Animated. Easing can be configured in the configuration
    object where you set values like `toValue` and `duration`, in the second argument
    of `Animated.timing`. Let’s look at an example with an animated value called `animatedMargin`.
    Setting `animatedMargin` to 0 and animating the value to 200 would normally achieve
    the easing effect by directly animating the value between 0 and 200 in the timing
    function. Using interpolation, you can instead animate a value between 0 and 1
    in the timing function and later interpolate the value by using the Animated `interpolate`
    class method, saving the value into another variable, and then referencing *that*
    variable in the style, usually in the render method:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: React Native有一个内置的方式来实现常见的缓动函数。就像您导入其他API和组件一样，您可以导入Easing模块并使用它，与Animated一起使用。Easing可以在配置对象中配置，在`Animated.timing`的第二个参数中设置值，如`toValue`和`duration`。让我们看看一个名为`animatedMargin`的动画值的例子。将`animatedMargin`设置为0并将值动画化到200，通常通过在时间函数中直接将值从0到200动画化来实现缓动效果。使用插值，您可以在时间函数中动画化0到1之间的值，然后使用Animated的`interpolate`类方法通过使用另一个变量来插值该值，并将该值保存到另一个变量中，然后在样式（通常在渲染方法中）中引用*那个*变量：
- en: '[PRE57]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, use interpolation to create the loading indicator. You’ll show the indicator
    when the application loads; in `componentDidMount`, you’ll call `setTimeout`,
    which cancels the loading state after 2,000 milliseconds (see [figure 7.3](#figure7.3)).
    The icon used here is located at [https://github.com/dabit3/react-native-in-action/blob/chapter7/assets/35633-200.png](https://github.com/dabit3/react-native-in-action/blob/chapter7/assets/35633-200.png);
    feel free to use it or any other image you want.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用插值来创建加载指示器。当应用程序加载时，您将显示指示器；在`componentDidMount`中，您将调用`setTimeout`，该调用在2,000毫秒后取消加载状态（参见[图7.3](#figure7.3)）。这里使用的图标位于[https://github.com/dabit3/react-native-in-action/blob/chapter7/assets/35633-200.png](https://github.com/dabit3/react-native-in-action/blob/chapter7/assets/35633-200.png)；您可以自由使用它或任何其他您想要的图像。
- en: '![c07_03.tif](Images/c07_03.png)'
  id: totrans-716
  prefs: []
  type: TYPE_IMG
  zh: '![c07_03.tif](Images/c07_03.png)'
- en: '[Figure 7.3](#figureanchor7.3) Creating a spinning loading indicator using
    interpolation and an animated loop'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.3](#figureanchor7.3) 使用插值和动画循环创建旋转加载指示器'
- en: Listing 7.3 Creating an infinitely spinning loading animation
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 创建无限旋转的加载动画
- en: '[PRE58]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `animate` class method passes `Animated.timing` into a call to `Animated.loop`.
    In the configuration, you set `toValue` to 1, `duration` to 1800, and `easing`
    to `Easing.linear`, to create a smooth spinning movement.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`animate`类方法将`Animated.timing`传递给`Animated.loop`的调用。在配置中，您将`toValue`设置为1，`duration`设置为1800，`easing`设置为`Easing.linear`，以创建平滑的旋转运动。'
- en: 'The `animatedRotation` value creates a new value called `rotation`, using the
    `interpolate` method. `inputRange` gives the animation’s beginning and end values,
    and `outputRange` gives the values `inputRange` should map to: a beginning value
    of 0 degrees and a final value of 360 degrees, creating a full 360-degree rotation.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`animatedRotation`值通过`interpolate`方法创建一个新的名为`rotation`的值。`inputRange`给出动画的开始和结束值，`outputRange`给出`inputRange`应映射到的值：开始值为0度，最终值为360度，创建一个完整的360度旋转。'
- en: In the `return` statement, first check to see whether `loading` is `true`. If
    it is, show the animated loading indicator (update this path to that of the image
    in your application); if it’s `false`, show a welcome message. Attach the `rotation`
    variable to the `transform` `rotate` value in the styling of `Animated.Image`.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在`return`语句中，首先检查`loading`是否为`true`。如果是，显示动画加载指示器（更新此路径为您的应用程序中图像的路径）；如果是`false`，则显示欢迎信息。将`rotation`变量附加到`Animated.Image`的样式中的`transform`
    `rotate`值。
- en: 7.4 Creating multiple parallel animations
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 创建多个并行动画
- en: Sometimes you need to create multiple animations at once and have them run simultaneously.
    The Animated library has a class method called `parallel` you can use to do this.
    `parallel` starts an array of animations at the same time.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您需要同时创建多个动画并使它们同时运行。Animated库有一个名为`parallel`的类方法，您可以使用它来做这件事。`parallel`同时启动一个动画数组。
- en: '![c07_04.png](Images/c07_04.png)'
  id: totrans-725
  prefs: []
  type: TYPE_IMG
  zh: '![c07_04.png](Images/c07_04.png)'
- en: '[Figure 7.4](#figureanchor7.4) Welcome screen using parallel animations (shown
    after the animations are complete)'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.4](#figureanchor7.4) 使用并行动画的欢迎屏幕（动画完成后显示）'
- en: For example, to make a welcome screen with two messages and a button all appear
    to move into the screen at once, you could create three separate animations and
    call `.start()` on each of them. But a more efficient way would be to use the
    `Animated.parallel` function and pass in the array of animations to run at the
    same time.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使两个消息和一个按钮同时出现在欢迎屏幕上，你可以创建三个独立的动画，并对每个动画调用`.start()`。但更高效的方法是使用`Animated.parallel`函数，并将要同时运行的动画数组传递给它。
- en: In this example, you’ll create a welcome screen that animates in two messages
    and a button when the component mounts (see [figure 7.4](#figure7.4)). Because
    you’re using `Animated.parallel`, all three animations will begin at exactly the
    same time. You’ll add a `delay` property to the configuration to control the start
    time of two of the animations.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将创建一个欢迎屏幕，当组件挂载时，屏幕上的两个消息和按钮会进行动画。因为你使用了`Animated.parallel`，所以所有三个动画将同时开始。你将在配置中添加一个`delay`属性来控制两个动画的开始时间。
- en: Listing 7.4 Creating an animated welcome screen
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 创建动画欢迎屏幕
- en: '[PRE59]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 7.5 Creating an animated sequence
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 创建动画序列
- en: 'An animated *sequence* is a series of animations that occur one after another,
    with each animation waiting for the previous animation to complete before it begins.
    You can create an animated sequence with `sequence`. Like `parallel`, `sequence`
    takes an array of animations:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 动画*序列*是一系列依次发生的动画，每个动画在开始之前都要等待前一个动画完成。你可以使用`sequence`创建动画序列。与`parallel`类似，`sequence`也接受一个动画数组：
- en: '[PRE60]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, you’ll create a sequence that drops the numbers 1, 2, and 3
    into the screen, 500 milliseconds apart ([figure 7.5](#figure7.5)).
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将创建一个序列，将数字1、2和3每隔500毫秒依次降落到屏幕上（[图7.5](#figure7.5)）。
- en: '![c07_05.tif](Images/c07_05.png)'
  id: totrans-735
  prefs: []
  type: TYPE_IMG
  zh: '![c07_05.tif](Images/c07_05.png)'
- en: '[Figure 7.5](#figureanchor7.5) Creating an animated sequence of numbers'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.5](#figureanchor7.5) 创建数字的动画序列'
- en: Listing 7.5 Creating a sequence of animations
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 创建动画序列
- en: '[PRE61]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This example uses beginning animated values of -30 because they’re the `marginTop`
    values for the text elements: the text is pulled off the top of the screen and
    hidden before the animation begins. The `createAnimation` function also receives
    an animated value as its argument.'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用初始动画值为-30，因为它们是文本元素的`marginTop`值：文本在动画开始之前被拉出屏幕并隐藏。`createAnimation`函数也接收一个动画值作为其参数。
- en: 7.6 Using Animated.stagger to stagger animation start times
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 使用Animated.stagger错开动画开始时间
- en: 'The last type of animation we’ll go over is `Animated.stagger`. Like `parallel`
    and `sequence`, `stagger` takes an array of animations. The array of animations
    starts in parallel, but the start time is staggered equally across all the animations.
    Unlike `parallel` and `sequence`, the first argument to `stagger` is the stagger
    time, and the second argument is the array of animations:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一种动画类型是`Animated.stagger`。与`parallel`和`sequence`类似，`stagger`也接受一个动画数组。动画数组以并行方式开始，但所有动画的开始时间均匀错开。与`parallel`和`sequence`不同，`stagger`的第一个参数是错开时间，第二个参数是动画数组：
- en: '[PRE62]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this example, you’ll dynamically create a large number of animations that
    are used to stagger a series of red boxes onto the screen (figure 7.6).
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将动态创建大量动画，用于将一系列红色框错开显示在屏幕上（图7.6）。
- en: '![c07_06.png](Images/c07_06.png)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![c07_06.png](Images/c07_06.png)'
- en: Figure 7.6 Using Animated.stagger to create an array of staggered animations
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 使用Animated.stagger创建错开动画数组
- en: Listing 7.6 Using `Animated.stagger` to stagger a series of animations
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 使用`Animated.stagger`来错开一系列动画的开始时间
- en: '[PRE63]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 7.7 Other useful tips for using the Animated library
  id: totrans-748
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 使用Animated库的其他有用技巧
- en: 'In addition to the parts of the Animated API we’ve already covered, a few more
    techniques are useful to know about: resetting an animated value, invoking callbacks,
    offloading animations to the native thread, and creating custom animatable components.
    This section takes a quick look at each of these.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经介绍过的Animated API的部分之外，还有一些其他技巧值得了解：重置动画值、调用回调、将动画卸载到原生线程以及创建自定义可动画组件。本节将简要介绍这些内容。
- en: 7.7.1 Resetting an animated value
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 重置动画值
- en: 'If you’re calling an animation, you can reset the value to whatever you want
    by using `setValue(value)`. This is useful if you’ve already called an animation
    on a value and need to call the animation again, and you want to reset the value
    to either the original value or a new value:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在调用动画，你可以使用 `setValue(value)` 将值重置为你想要的任何值。如果你已经对一个值调用过动画，需要再次调用动画，并且希望将值重置为原始值或新值，这很有用：
- en: '[PRE64]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 7.7.2 Invoking a callback
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.2 调用回调
- en: 'When an animation is completed, an optional callback function can be fired,
    as shown here:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画完成时，可以触发一个可选的回调函数，如下所示：
- en: '[PRE65]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 7.7.3 Offloading animations to the native thread
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.3 将动画卸载到原生线程
- en: Out of the box, the Animated library performs animations using the JavaScript
    thread. In most cases, this works fine, and you shouldn’t have many performance
    problems. But if anything is blocking the JavaScript thread, you may see issues
    like frames being skipped, causing laggy or jumpy animations.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Animated 库使用 JavaScript 线程执行动画。在大多数情况下，这没问题，你不太会遇到性能问题。但如果有任何操作阻塞了 JavaScript
    线程，你可能会看到帧被跳过，导致动画卡顿或跳跃。
- en: 'There’s a way around using the JavaScript thread: you can use a configuration
    Boolean called `useNativeDriver`. `useNativeDriver` offloads the animation to
    the native UI thread, and the native code can then update the views directly on
    the UI thread, as shown here:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种绕过使用 JavaScript 线程的方法：你可以使用一个名为 `useNativeDriver` 的配置布尔值。`useNativeDriver`
    将动画卸载到原生 UI 线程，然后原生代码可以直接在 UI 线程上更新视图，如下所示：
- en: '[PRE66]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Not every animation can be offloaded using `useNativeDriver`, so be sure to
    check the Animated API documentation when you use it. As of this writing, only
    non-layout properties can be animated using this method; flexbox properties as
    well as properties like margins and padding can’t be animated.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有动画都可以使用 `useNativeDriver` 卸载，所以当你使用它时，务必检查 Animated API 文档。截至本文撰写时，只有非布局属性可以使用此方法进行动画化；flexbox
    属性以及诸如边距和填充之类的属性不能进行动画化。
- en: 7.7.4 Creating a custom animatable component using createAnimatedComponent
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.4 使用 createAnimatedComponent 创建自定义可动画化组件
- en: 'We mentioned in section 7.1 that the only animatable components out of the
    box are `View`, `Text`, `Image`, and `ScrollView`. There’s also a way to create
    an animated component from any existing or custom React Native element or component.
    You can do this by wrapping the component in a call to `createAnimatedComponent`.
    Here’s an example:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 7.1 节中提到，默认情况下唯一可动画化的组件是 `View`、`Text`、`Image` 和 `ScrollView`。还有一种方法可以从任何现有或自定义
    React Native 元素或组件创建动画组件。你可以通过将组件包裹在 `createAnimatedComponent` 的调用中来实现这一点。以下是一个示例：
- en: '[PRE67]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now you can use the button just like a regular React Native component.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像使用常规 React Native 组件一样使用按钮。
- en: Summary
  id: totrans-765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The built-in Animated API is the recommended way to create animations in React
    Native.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的 Animated API 是在 React Native 中创建动画的推荐方式。
- en: '`Animated.timing` is the main method to use to create animations using the
    Animated library.'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated.timing` 是使用 Animated 库创建动画的主要方法。'
- en: The only components that are animatable out of the box are `View`, `Text`, `ScrollView`,
    and `Image`, but you can create custom animatable components using `createAnimatedComponent`.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，唯一可动画化的组件是 `View`、`Text`、`ScrollView` 和 `Image`，但你可以使用 `createAnimatedComponent`
    创建自定义的可动画化组件。
- en: To interpolate and reuse animated values, use the Animated `interpolate` method.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要插值和重用动画值，请使用 Animated 的 `interpolate` 方法。
- en: To create and trigger an array of animations at the same time, use `Animated.parallel`.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要同时创建和触发一组动画，请使用 `Animated.parallel`。
- en: To create an infinitely looping animation, use `Animated.loop`.
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建无限循环的动画，请使用 `Animated.loop`。
- en: Use `Animated.sequence` to create a sequence of animations that execute one
    after another.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Animated.sequence` 创建一系列依次执行的动画。
- en: Use `Animated.stagger` to create an array of animations that happen in parallel,
    but whose start times are staggered based on the time passed in.
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Animated.stagger` 创建一个并行发生的动画数组，但其开始时间基于传入的时间进行错位。
- en: '8'
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Using the Redux data architecture library
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Redux 数据架构库
- en: '*****This chapter*** ***covers*****'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '*****本章*** ***涵盖*****'
- en: How the React context API works
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 上下文 API 的工作原理
- en: Creating a Redux `store`
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Redux `store`
- en: How to use Redux actions and reducers to manage global state
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Redux 动作和 Reducers 管理全局状态
- en: Reducer composition using `combineReducers`
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `combineReducers` 进行 Reducer 组合
- en: 'When building React and React Native applications in the real world, you’ll
    quickly learn that the data layer can become complex and unmanageable if it isn’t
    handled very precisely and deliberately. One way to handle data is to keep it
    in component state and pass it around as props, as we’ve done throughout this
    book. Another way is to use a data architecture pattern or library. This chapter
    covers the Redux library: it’s the most widely adopted method of handling data
    in the React ecosystem, and it’s maintained by Facebook, the same team that maintains
    both React and React Native.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中构建React和React Native应用程序时，你会很快学到，如果处理不当，数据层可能会变得复杂且难以管理。处理数据的一种方法是将它保存在组件状态中，并作为props传递，正如我们在本书中所做的那样。另一种方法是使用数据架构模式或库。本章介绍了Redux库：它是React生态系统中处理数据最广泛采用的方法，由维护React和React
    Native的Facebook团队维护。
- en: 8.1 What is Redux?
  id: totrans-782
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 什么是Redux？
- en: In the Redux documentation, the library is described as “a predictable state
    container for JavaScript apps.” Redux is basically a global state object that’s
    the single source of truth in an application. This global state object is received
    as props into React Native components. Any time a piece of data is changed in
    the Redux state, the entire application receives this new data as props.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux文档中，该库被描述为“JavaScript应用程序的可预测状态容器。”Redux基本上是一个全局状态对象，它是应用程序中的唯一真相来源。这个全局状态对象作为props被接收进React
    Native组件。每当Redux状态中的某个数据被更改时，整个应用程序都会以props的形式接收这个新数据。
- en: Redux simplifies application state by moving it all into one place called a
    *store*; this makes it much easier to reason about and understand. When you need
    the value of something, you’ll know exactly where to look in a Redux application
    and can expect the same value to be available and up-to-date elsewhere in the
    application, too.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: Redux通过将所有状态移动到一个称为*store*的地方来简化应用程序状态；这使得推理和理解变得更加容易。当你需要某个值时，你将知道在Redux应用程序中确切地在哪里查找，并且可以预期在应用程序的其他地方也能获得相同且最新的值。
- en: So how does Redux work? It takes advantage of a React feature called *context*,
    a mechanism for creating and managing global state.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Redux是如何工作的呢？它利用了React的一个特性，称为*上下文*，这是一种创建和管理全局状态的机制。
- en: 8.2 Using context to create and manage global state in a React application
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 在React应用程序中使用上下文创建和管理全局状态
- en: Context is a React API that creates global variables that can be accessed anywhere
    in the application, as long as the component receiving the context is a child
    of the component that created it. Normally you’d have to do this by passing props
    down each level of the component structure. With context, you don’t need to use
    props. You can use the context anywhere in the app and access it without passing
    it down to each level.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是React API，它创建可以在应用程序的任何地方访问的全局变量，只要接收上下文的组件是创建它的组件的子组件。通常，你需要通过将props传递到组件结构的每一层来实现这一点。使用上下文，你不需要使用props。你可以在应用程序的任何地方使用上下文，并访问它而无需将其传递到每一层。
- en: 'Let’s look at how to create context in a basic component structure of three
    components: `Parent`, `Child1`, and `Child2`. This example shows how to apply
    application-wide theming from a parent level, which could make it possible to
    control the styling of an entire application if needed.'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在三个组件的基本组件结构中创建上下文：`Parent`、`Child1`和`Child2`。这个例子展示了如何从父级应用应用范围的主题，如果需要，这可以使得控制整个应用程序的样式成为可能。
- en: Listing 8.1 Creating context
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 创建上下文
- en: '[PRE68]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `Child2` stateless function returns a component that’s wrapped in a `ThemeContext.Consumer`.
    `ThemeContext.Consumer` requires a function as its child. The function receives
    an argument containing whatever context is available (in this case, the `val`
    object containing two properties). You can now use the context values in the component.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child2` 无状态函数返回一个被`ThemeContext.Consumer`包裹的组件。`ThemeContext.Consumer`需要一个函数作为其子元素。该函数接收一个包含任何可用上下文的参数（在这个例子中，包含两个属性的`val`对象）。现在你可以在组件中使用这些上下文值。'
- en: When you use Redux with React, you’ll take advantage of a function called `connect`,
    which basically takes pieces of context and makes them available as props in the
    component. Understanding context should make learning Redux much easier!
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Redux与React结合时，你会利用一个名为`connect`的函数，该函数基本上将上下文的片段转换为组件的props。理解上下文应该会使学习Redux变得更加容易！
- en: 8.3 Implementing Redux with a React Native app
  id: totrans-793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 在React Native应用程序中实现Redux
- en: 'Now that you’ve know the fundamentals of what Redux is and have seen what’s
    going on under the hood with context, let’s create a new React Native app and
    start adding Redux. You’ll be creating a basic list app you can use to keep up
    with books you’ve read (see [figure 8.1](#figure8.1)). Follow these steps:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Redux 的基础知识，并看到了在上下文背后的操作，让我们创建一个新的 React Native 应用程序并开始添加 Redux。你将创建一个基本的列表应用程序，你可以用它来跟踪你读过的书籍（参见
    [图 8.1](#figure8.1)）。按照以下步骤操作：
- en: '![c08_01.tif](Images/c08_01.png)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![c08_01.tif](Images/c08_01.png)'
- en: '[Figure 8.1](#figureanchor8.1) Completed book list application'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.1](#figureanchor8.1) 完成的图书列表应用'
- en: '![c08_02.tif](Images/c08_02.png)'
  id: totrans-797
  prefs: []
  type: TYPE_IMG
  zh: '![c08_02.tif](Images/c08_02.png)'
- en: '[Figure 8.2](#figureanchor8.2) RNRedux src folder structure'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.2](#figureanchor8.2) RNRedux src 文件夹结构'
- en: 'Create a new React Native application, and call it RNRedux:'
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 React Native 应用程序，并将其命名为 RNRedux：
- en: '[PRE69]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Change into the new directory:'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到新目录：
- en: '[PRE70]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Install the Redux-specific dependencies you’ll need:'
  id: totrans-803
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装你需要的 Redux 特定依赖项：
- en: '[PRE71]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the root of the directory, create a folder called src, and add to it the
    following files: Books.js and actions.js. Also, in src, create a folder called
    reducers, containing two files: bookReducer.js and index.js. The src folder structure
    should now look like [figure 8.2](#figure8.2).'
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目录的根目录下创建一个名为 src 的文件夹，并向其中添加以下文件：Books.js 和 actions.js。此外，在 src 中创建一个名为 reducers
    的文件夹，包含两个文件：bookReducer.js 和 index.js。src 文件夹结构现在应该看起来像 [图 8.2](#figure8.2)。
- en: The next thing to do is create the first piece of Redux state. You’ll do this
    in bookReducer.js. In section 8.1, I described Redux as a global object. To create
    this global object, you’ll piece together smaller objects using what are known
    as *reducers*.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建第一个 Redux 状态。你将在 bookReducer.js 中做这件事。在第 8.1 节中，我将 Redux 描述为一个全局对象。要创建这个全局对象，你将使用所谓的
    *Reducer* 将更小的对象拼接在一起。
- en: 8.4 Creating Redux reducers to hold Redux state
  id: totrans-807
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 创建 Redux Reducer 以存储 Redux 状态
- en: A reducer is a function that returns an object; when combined with other reducers,
    they create the global state. Reducers can be more easily thought of as data stores.
    Each store contains a piece of data, which is exactly what reducers do in the
    Redux architecture.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 是一个返回对象的函数；当与其他 Reducer 结合时，它们会创建全局状态。Reducer 可以更容易地被视为数据存储。每个存储包含一块数据，这正是
    Redux 架构中 Reducer 所做的。
- en: 'In the reducers folder are two files: bookReducer.js and index.js. In index.js,
    you’ll combine all the reducers in the app to create the global state. The app
    will have only one reducer to start with (`bookReducer`), so the global state
    object will look something like this:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在 reducers 文件夹中有两个文件：bookReducer.js 和 index.js。在 index.js 中，你将结合应用中的所有 Reducer
    来创建全局状态。应用一开始将只有一个 Reducer (`bookReducer`)，因此全局状态对象将看起来像这样：
- en: '[PRE72]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You’ve yet to decide what to put in `bookReducer`. An array in which to store
    a list of books will be a good start. This reducer will create and return a piece
    of state that you’ll access later from the Redux store. In reducers/bookReducer.js,
    create your first reducer. This code creates a function whose only purpose (for
    now) is to return the state.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有决定在 `bookReducer` 中放置什么。一个用于存储图书列表的数组将是一个好的开始。这个 Reducer 将创建并返回一个状态，你稍后将从
    Redux 存储中访问它。在 reducers/bookReducer.js 中，创建你的第一个 Reducer。这段代码创建了一个函数，其唯一目的（目前）是返回状态。
- en: Listing 8.2 Creating a reducer
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 创建 Reducer
- en: '[PRE73]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `initialState` object will hold the beginning state. In this case, that’s
    an array of books that you’ll populate with objects containing `name` and `author`
    props. You create a function that takes an argument, `state`, and sets the default
    value to the initial state. When this function is first called, `state` will be
    undefined and will return the `initialState` object. At this time, the function’s
    only purpose is to return the state.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialState` 对象将保存初始状态。在这种情况下，那是一个包含 `name` 和 `author` 属性的对象数组，你将用这些对象填充它。你创建一个函数，该函数接受一个参数
    `state`，并将默认值设置为初始状态。当这个函数第一次被调用时，`state` 将是未定义的，并将返回 `initialState` 对象。此时，这个函数的唯一目的是返回状态。'
- en: Now that you’ve created the first reducer, go into `rootReducer` (reducers/index.js)
    and create what will be the global state. The root reducer gathers all the reducers
    in the application and allows you to make a global store (state object) by combining
    them.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了第一个 Reducer，进入 `rootReducer`（reducers/index.js）并创建将成为全局状态的内容。根 Reducer
    收集应用中的所有 Reducer，并允许你通过将它们组合起来创建一个全局存储（状态对象）。
- en: Listing 8.3 Creating a root reducer
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 创建根 Reducer
- en: '[PRE75]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Next, to hook this all together, you’ll go into App.js, create the Redux store,
    and make the store available to all child components using a couple of Redux and
    React-Redux helpers.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了将这些组件连接起来，你将进入 App.js，创建 Redux 存储，并使用几个 Redux 和 React-Redux 辅助函数使存储对所有子组件可用。
- en: 8.5 Adding the provider and creating the store
  id: totrans-820
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 添加提供者并创建存储
- en: In this section, you’ll add a *provider* to the app. A provider is usually a
    parent component that passes data of some kind along to all child components.
    In Redux, the provider passes the global state/store to the rest of the application.
    In App.js, update the code as follows.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将在应用中添加一个 *provider*。provider 通常是一个父组件，它将某种类型的数据传递给所有子组件。在 Redux 中，provider
    将全局状态/存储传递给应用的其他部分。在 App.js 中，按照以下方式更新代码。
- en: '![c08_03.png](Images/c08_03.png)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
  zh: '![c08_03.png](Images/c08_03.png)'
- en: '[Figure 8.3](#figureanchor8.3) Rendering the list of books from the Redux store'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.3](#figureanchor8.3) 从 Redux 存储渲染书籍列表'
- en: Listing 8.4 Adding the provider and store
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 添加提供者和存储
- en: '[PRE76]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `Provider` wrapper is used to wrap the main component. Any child of `Provider`
    will have access to the Redux store. `createStore` is a utility from Redux that
    you use to create the Redux store by passing in the `rootReducer`. You’re finished
    with the basic Redux setup, and you can now access the Redux store in the app.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '`Provider` 包装器用于包装主组件。`Provider` 的任何子组件都将能够访问 Redux 存储。`createStore` 是 Redux
    中的一个实用工具，你通过传递 `rootReducer` 来创建 Redux 存储。你已经完成了基本的 Redux 设置，现在你可以通过 Redux 和 React-Redux
    的几个辅助函数在应用中访问 Redux 存储。'
- en: In the `Books` component, you’ll hook into the Redux store, pull out the `books`
    array, and map over the books, displaying them in the UI ([figure 8.3](#figure8.3)).
    Because `Books` is a child of `Provider`, it can access anything in the Redux
    store.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Books` 组件中，你将连接到 Redux 存储，提取 `books` 数组，并对书籍进行映射，在 UI 中显示它们（[图 8.3](#figure8.3)）。因为
    `Books` 是 `Provider` 的子组件，它可以访问 Redux 存储中的任何内容。
- en: 8.6 Accessing data using the connect function
  id: totrans-828
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 使用 connect 函数访问数据
- en: You access the Redux store from a child component by using the `connect` function
    from react-redux. The first argument to `connect` is a function that gives you
    access to the entire Redux state. You can then return an object with whatever
    pieces of the store you want access to.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 react-redux 中的 `connect` 函数从子组件访问 Redux 存储。`connect` 的第一个参数是一个函数，它给你提供访问整个
    Redux 状态的权限。然后你可以返回一个对象，包含你想要访问的存储的任何部分。
- en: '`connect` is a *curried* function, meaning in the most basic sense a function
    that returns another function. You’ll have two sets of arguments, and a blueprint
    that looks something like this: `connect(args)(args)`. The properties in the object
    returned from the first argument to `connect` are then made available to the component
    as props.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 是一个 *curried* 函数，这意味着在最基本的意义上，它是一个返回另一个函数的函数。你将有两组参数，一个看起来像这样的蓝图：`connect(args)(args)`。从
    `connect` 的第一个参数返回的对象中的属性然后作为 props 传递给组件。'
- en: Let’s see what this means by looking at the `connect` function you’ll use in
    the Books.js component.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看你在 Books.js 组件中将使用的 `connect` 函数来了解这意味着什么。
- en: Listing 8.5 `connect` function in Books.js
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 Books.js 中的 `connect` 函数
- en: '[PRE77]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The first argument to `connect` is a function that gives the global Redux `state`
    object as an argument. You can then reference this `state` object and have access
    to anything in the Redux state. You return an object from this function. Whatever
    keys are returned in the object become available as props in the component you’re
    wrapping: in this case, `Books`. You pass in `Books` as the only argument to the
    `connect` function’s second function call.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect` 函数的第一个参数是一个函数，它将全局 Redux `state` 对象作为参数传递。然后你可以引用这个 `state` 对象，并访问
    Redux 状态中的任何内容。从这个函数中返回一个对象。对象中返回的任何键都将成为你包装的组件（在这个例子中是 `Books`）中的 props。你将 `Books`
    作为 `connect` 函数第二个函数调用的唯一参数传递。'
- en: 'Often, you’ll separate this function and store it in a variable to make this
    easier to read:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会将这个函数分离并存储在一个变量中，以便更容易阅读。
- en: '[PRE78]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In this connected component is a new property called `this.props.books`, which
    is the `books` array from `bookReducer`. Tie all this together, access the `books`
    array, and map over the books to display them in the UI, as shown in the following
    listing (Books.js).
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个连接组件中有一个新的属性叫做 `this.props.books`，这是来自 `bookReducer` 的 `books` 数组。将这些全部结合起来，访问
    `books` 数组，并对书籍进行映射，以显示在 UI 中，如下所示（Books.js）。
- en: Listing 8.6 Accessing the Redux store and `bookReducer` data
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 访问 Redux 存储 和 `bookReducer` 数据
- en: '[PRE79]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You begin by importing `connect` from react-redux. In [listing 8.5](#listing8.5),
    you wrote the function returning the props inline. This listing separates it and
    names it `mapStateToProps`, following the convention of the Redux ecosystem. This
    naming convention makes a lot of sense, because you’re essentially mapping Redux
    state to component props. This function takes the Redux state as an argument and
    returns an object with one key containing the `books` array from `bookReducer`.
    Finally, you export the `connect` function, passing in `mapStateToProps` as the
    first argument to `connect` and `Books` as the only argument in the second set
    of arguments to `connect`.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先从 `react-redux` 中导入 `connect`。在 [列表 8.5](#listing8.5) 中，你直接在函数中返回了属性。此列表将其分离并命名为
    `mapStateToProps`，遵循 Redux 生态系统的约定。这种命名约定非常有意义，因为你实际上是在将 Redux 状态映射到组件属性。此函数接受
    Redux 状态作为参数，并返回一个包含一个键的对象，该键包含 `bookReducer` 中的 `books` 数组。最后，你导出 `connect` 函数，将
    `mapStateToProps` 作为 `connect` 的第一个参数传递，并将 `Books` 作为 `connect` 第二组参数中的唯一参数。
- en: After launching the application, you should see a basic list of books, as shown
    earlier in figure 8.3.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序后，你应该会看到一个基本的书籍列表，如图 8.3 中所示。
- en: 8.7 Adding actions
  id: totrans-842
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 添加动作
- en: 'Now that you have access to the Redux state, a logical next step is to add
    some functionality that will allow you to add books to the `books` array Redux
    store. To do this, you’ll use *actions*. Actions are basically functions that
    return objects that send data to the store and update reducers; they’re the only
    way to change the store. Each action should contain a `type` property in order
    for reducers to be able to use them. Here are a couple of examples of actions:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以访问 Redux 状态，下一步的逻辑是添加一些功能，允许你向 Redux 存储 `books` 数组中添加书籍。为此，你将使用 *动作*。动作基本上是返回对象的函数，这些对象将数据发送到存储并更新
    reducer；它们是更改存储的唯一方式。每个动作都应该包含一个 `type` 属性，以便 reducer 能够使用它们。以下是一些动作的示例：
- en: '[PRE80]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Actions, when called using a Redux `dispatch` function, are sent to all reducers
    in the application as the second argument to the reducer. (We’ll cover how to
    attach the Redux `dispatch` function later in this chapter.) When the reducer
    receives the action, you check the action’s `type` property and update what the
    reducer returns based on whether the action is one that it’s listening for.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Redux 的 `dispatch` 函数调用动作时，这些动作作为第二个参数发送到应用程序中的所有 reducer。（我们将在本章后面介绍如何附加
    Redux 的 `dispatch` 函数。）当 reducer 接收到动作时，你检查动作的 `type` 属性，并根据动作是否是它正在监听的动作来更新 reducer
    返回的内容。
- en: In this case, the only action you need for the next step is `addBook`, to add
    additional books to the array of books. In actions.js, create the following action.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你只需要为下一步添加一个 `addBook` 动作，以便向书籍数组中添加额外的书籍。在 actions.js 文件中，创建以下动作。
- en: Listing 8.7 Creating the first action
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 创建第一个动作
- en: '[PRE81]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Next, wire up `bookReducer` to use the `addBook` action.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `bookReducer` 连接到使用 `addBook` 动作。
- en: Listing 8.8 Updating `bookReducer` to use the `addBook` action
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 更新 `bookReducer` 以使用 `addBook` 动作
- en: '[PRE82]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the listing, if the action type is equal to `ADD_BOOK`, you return a new
    `books` array containing all the previous items in the array. You do so by creating
    a new array, using the spread operator to add the contents of the existing `books`
    array to the new array, and adding to the array a new item that’s the `book` property
    of the action.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，如果动作类型等于 `ADD_BOOK`，你将返回一个新的 `books` 数组，包含数组中的所有先前项。你是通过创建一个新的数组，使用扩展运算符将现有
    `books` 数组的元素添加到新数组中，并将动作的 `book` 属性作为新项添加到数组中。
- en: That’s all you need to do in the Redux configuration to get this working. The
    last step is to go into the UI and wire it all together. To get the user’s book
    info, you need to create a form. [Figure 8.4](#figure8.4) shows what the UI will
    look like.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 配置中，你需要做的就这些来使它工作。最后一步是进入 UI 并将其全部连接起来。为了获取用户的书籍信息，你需要创建一个表单。[图 8.4](#figure8.4)
    展示了 UI 将会是什么样子。
- en: 'This form has two inputs: one for the book name and one for the author name.
    It also has a submit button. When the user types into the form, you need to keep
    up with the values in the local state. You can then pass those values on to the
    action when the user clicks the submit button.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单有两个输入：一个用于书籍名称，一个用于作者名称。它还有一个提交按钮。当用户在表单中输入时，你需要跟踪本地状态中的值。然后，当用户点击提交按钮时，你可以将这些值传递给动作。
- en: '![c08_04.png](Images/c08_04.png)'
  id: totrans-855
  prefs: []
  type: TYPE_IMG
  zh: '![c08_04.png](Images/c08_04.png)'
- en: '[Figure 8.4](#figureanchor8.4) UI with added text inputs to capture the book
    and the author name'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.4](#figureanchor8.4) 添加了文本输入以捕获书籍和作者名称的 UI'
- en: Open Books.js, and import the additional components needed for this functionality,
    as well as the `addBook` function from the actions. You’ll also create an `initialState`
    variable to use as the local component state.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Books.js`，导入实现此功能所需的额外组件，以及从actions中导入的`addBook`函数。你还将创建一个`initialState`变量，用作本地组件状态。
- en: Listing 8.9 Additional imports in Books.js
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 Books.js中的额外导入
- en: '[PRE83]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, in the body of the class, you need to create three things: the component
    state, a method that keeps up with the component state when the `textInput` values
    change, and a method that will send the action to Redux containing the book values
    (name and author) when the submit button is pressed. Before the `render` method,
    add the following code.'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在类的主体中，你需要创建三样东西：组件状态，一个当`textInput`值改变时跟踪组件状态的方法，以及一个当提交按钮被按下时将包含书籍值（名称和作者）的动作发送到Redux的方法。在`render`方法之前，添加以下代码。
- en: Listing 8.10 Adding state and class methods to Books.js
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 向Books.js添加状态和类方法
- en: '[PRE84]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `addBook` method calls a function that you have access to as props from
    the `connect` function: `dispatchAddBook`. This function accepts the entire state
    as an argument, which is an object with `name` and `author` properties. After
    the dispatch action has been called, you then clear the component state by resetting
    it to the `initialState` value.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '`addBook`方法调用一个你可以通过`connect`函数访问的props中的函数：`dispatchAddBook`。这个函数接受整个状态作为参数，它是一个具有`name`和`author`属性的对象。在调用dispatch动作之后，然后通过将其重置为`initialState`值来清除组件状态。'
- en: With the functionality in place, you can create the UI and hook these methods
    up to it. Under the closing tag of the `ScrollView` in Books.js, add the form
    UI.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能实现后，你可以创建UI并将这些方法连接到它。在`Books.js`中的`ScrollView`关闭标签下添加表单UI。
- en: Listing 8.11 Adding the UI for the form
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 添加表单的UI
- en: '[PRE85]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the `mapDispatchToProps` object, you can declare functions you want access
    to as props in the component. You create a new function called `dispatchAddBook`
    and have it call the `addBook` action, passing in `book` as an argument. Similar
    to how `mapStateToProps` maps state to component props, `mapDispatchToProps` maps
    actions (that need to be dispatched to reducers) to component props. In order
    for an action to be recognized by the Redux reducers, it must be declared in this
    `mapDispatchToProps` object. You pass in `mapDispatchToProps` as the second argument
    to the `connect` function.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mapDispatchToProps`对象中，你可以声明你希望在组件的props中访问的函数。你创建一个新的函数名为`dispatchAddBook`，并让它调用`addBook`动作，传入`book`作为参数。类似于`mapStateToProps`将状态映射到组件props，`mapDispatchToProps`将需要分发到reducer的动作映射到组件props。为了使一个动作能被Redux的reducer识别，它必须在`mapDispatchToProps`对象中声明。你将`mapDispatchToProps`作为`connect`函数的第二个参数传入。
- en: Now you should be able to easily add books to the book list.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够轻松地将书籍添加到书单中。
- en: 8.8 Deleting items from a Redux store in a reducer
  id: totrans-869
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 在reducer中从Redux存储中删除项目
- en: The next logical step is to add a way to remove books you’ve already read. Given
    everything you’ve put together, this won’t require too much more work ([figure
    8.5](#figure8.5)).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个合乎逻辑的步骤是添加一种方法来移除你已经读过的书籍。考虑到你已经构建的一切，这不会需要太多额外的工作（[图8.5](#figure8.5)）。
- en: '![c08_05.png](Images/c08_05.png)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
  zh: '![c08_05.png](Images/c08_05.png)'
- en: '[Figure 8.5](#figureanchor8.5) Adding the Remove button to the Books.js UI'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.5](#figureanchor8.5) 在Books.js UI中添加移除按钮'
- en: 'The first thing to think about when removing an item from an array such as
    this is how to identify a book as being unique. Right now, a user could have multiple
    books with the same author or multiple books with the same name, so using the
    existing properties won’t work. Instead, you can use a library such as uuid to
    create unique identifiers on the fly. To begin setting this up, from the command
    line, install the uuid library into `node_modules`:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 当从类似这样的数组中移除项时，首先要考虑的是如何识别一个书籍作为唯一的。目前，一个用户可能有多个作者相同的书籍或多个名称相同的书籍，所以使用现有的属性将不起作用。相反，你可以使用如uuid这样的库来动态创建唯一标识符。为了开始设置，从命令行，将uuid库安装到`node_modules`：
- en: '[PRE86]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Next, you’ll implement a unique identifier in the reducer for the items in the
    `initialState` `books` array. In reducers/bookReducer.js, update the imports and
    `initialState` to look like the next listing.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将在reducer中为`initialState`中的`books`数组项实现一个唯一标识符。在`reducers/bookReducer.js`中，更新导入和`initialState`以类似于以下列表。
- en: Listing 8.12 Importing and using uuid
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 导入和使用uuid
- en: '[PRE87]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The uuid library has a few algorithms to choose from. Here, you import only
    the v4 algorithm, which creates a random 32-character string. Then you add a new
    property to the `initialState` `books` array, `id`, and generate a new unique
    identifier by calling `uuidV4()`.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: uuid 库提供了一些算法可供选择。在这里，你只导入 v4 算法，它创建一个随机的 32 位字符字符串。然后你向 `initialState` 的 `books`
    数组添加一个新的属性 `id`，并通过调用 `uuidV4()` 生成一个新的唯一标识符。
- en: Now that you have a way to uniquely identify the items in the `books` array,
    you’re ready to move forward with the rest of the functionality. The next step
    is to create a new action in actions.js; you’ll call it when you want to remove
    a book. You also need to update the `addBook` action to add an ID to newly created
    books.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了在 `books` 数组中唯一标识项目的方法，你就可以继续实现其余的功能。下一步是在 `actions.js` 中创建一个新的动作；当你想要删除一本书时，你会调用它。你还需要更新
    `addBook` 动作，以便为新创建的书籍添加一个 ID。
- en: Listing 8.13 Creating the `removeBook` action
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 创建 `removeBook` 动作
- en: '[PRE88]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Next, the reducer needs to be aware of the new action. In reducers/bookReducer.js,
    create a new type listener, this one for `REMOVE_BOOK`, and add the necessary
    functionality to remove a book from the array of books stored in the Redux state.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，reducer 需要意识到新的动作。在 `reducers/bookReducer.js` 中，创建一个新的类型监听器，这个监听器用于 `REMOVE_BOOK`，并添加必要的功能以从
    Redux 状态中存储的书籍数组中删除一本书。
- en: Listing 8.14 Removing an item from an array in a Redux reducer
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 在 Redux reducer 中从数组中移除一个项目
- en: '[PRE89]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The last thing to do is implement this new `removeBook` functionality in the
    UI of the `Books` component (Books.js). You’ll import the `removeBook` action,
    add a remove button to each rendered item, and wire the remove button up to the
    `removeBook` action.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是在 `Books` 组件（Books.js）的 UI 中实现这个新的 `removeBook` 功能。你会导入 `removeBook`
    动作，为每个渲染的项目添加一个删除按钮，并将删除按钮连接到 `removeBook` 动作。
- en: Listing 8.15 Adding `removeBook` functionality
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 添加 `removeBook` 功能
- en: '[PRE90]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Summary
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: With context, you can pass properties and data to children in a React Native
    application without explicitly passing the properties to each individual child.
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文，你可以在 React Native 应用程序中向子组件传递属性和数据，而无需显式地将属性传递给每个单独的子组件。
- en: Reducers are similar to a traditional data store in the sense that they keep
    up with and return data, but also allow you to update data in the store.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer 在某种程度上类似于传统的数据存储，因为它们会跟踪并返回数据，同时也允许你更新存储中的数据。
- en: You can create and use actions to update a Redux store.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建并使用动作来更新 Redux 存储。
- en: With the `connect` function, you can access data from the Redux state as props
    and also create dispatch functions that interact with reducers using actions.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `connect` 函数，你可以将 Redux 状态中的数据作为 props 访问，并且可以创建与 reducer 通过动作交互的 dispatch
    函数。
- en: Any time data needs to be changed in a reducer, it must be done by using an
    action.**
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何需要在 reducer 中更改数据的时候，都必须通过使用一个动作来完成。**
