- en: 5 Summary cards with hover interactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 张具有悬停交互的总结卡片
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Clipping static background images using the `background-clip` property
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`background-clip`属性裁剪静态背景图像
- en: Using transitions to reveal content on hover
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过渡效果在悬停时显示内容
- en: Using media queries to choose styles based on device capabilities and window
    size
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体查询根据设备能力和窗口大小选择样式
- en: '*Summary cards* are used for a range of purposes, whether that be showing a
    preview for a film, buying a property, previewing a news article, or (in this
    chapter) showing a list of hotels. Usually, a summary card contains a title, description,
    and a call to action; sometimes, it also contains an image. Figure 5.1 shows the
    cards we’ll create in this project.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*总结卡片*用于多种目的，无论是显示电影的预览、购买房产、预览新闻文章，还是（在本章中）显示酒店列表。通常，总结卡片包含标题、描述和行动号召；有时，它还包含一个图像。图5.1显示了我们将在这个项目中创建的卡片。'
- en: '![](../Images/05-01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-01.png)'
- en: Figure 5.1 Finished product
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 成品
- en: The cards will be placed in a single line, using the CSS Grid Layout Module
    for layout. Each card will have its own background image, with the content placed
    on top. If the user is viewing the card on a device that supports hover and has
    a screen at least 700 pixels wide, they’ll be able to see the title and then hover
    over the card, which will reveal the short description and an orange call-to-action
    button for contrast with the black background (figure 5.2).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片将排成一行，使用CSS Grid布局模块进行布局。每个卡片都将有自己的背景图像，内容放置在顶部。如果用户在支持悬停且屏幕宽度至少为700像素的设备上查看卡片，他们将能够看到标题，然后悬停在卡片上，这将揭示简短的描述和一个橙色的行动号召按钮，以与黑色背景形成对比（图5.2）。
- en: '![](../Images/05-02.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-02.png)'
- en: Figure 5.2 Hover effect on finished product
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 成品上的悬停效果
- en: For users whose devices don’t support hover or have a screen less than 700 pixels
    wide, we’ll show all the information without hover so that the user experience
    isn’t affected (figure 5.3).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持悬停或屏幕宽度小于700像素的用户设备，我们将显示所有信息而不使用悬停，以确保用户体验不受影响（图5.3）。
- en: '![](../Images/05-03.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-03.png)'
- en: Figure 5.3 Finished product on small or touch devices that can’t handle the
    hover state
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 小型或触摸设备上无法处理悬停状态的成品
- en: The other piece of this project is the header, which we want to make stand out
    and have some visual interest. To do this, we’ll explore the `background-clip`
    property and see how we can clip an image around the text.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的另一部分是页眉，我们希望使其突出并具有视觉吸引力。为此，我们将探索`background-clip`属性，看看我们如何可以在文本周围裁剪图像。
- en: 5.1 Getting started
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 开始
- en: Listing 5.1 and listing 5.2 include our starting CSS and HTML for the page that
    we’ll build on in this chapter. To follow along as we style the page, you can
    download the starting HTML and CSS from the GitHub repository at [http://mng.bz/KlaO](http://mng.bz/KlaO)
    or from CodePen at [https://codepen.io/michaelgearon/pen/vYpaQPO](https://codepen.io/michaelgearon/pen/vYpaQPO).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1和列表5.2包含了我们在本章中将要构建的页面的起始CSS和HTML。要跟随我们为页面添加样式的过程，您可以从GitHub仓库[http://mng.bz/KlaO](http://mng.bz/KlaO)或从CodePen[https://codepen.io/michaelgearon/pen/vYpaQPO](https://codepen.io/michaelgearon/pen/vYpaQPO)下载起始HTML和CSS。
- en: The mobile and desktop experiences will use the same HTML and stylesheet. Similarly
    to what we did in chapter 4, we’ll use media queries to alter the styles based
    on browser size and capabilities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 移动端和桌面端体验将使用相同的HTML和样式表。类似于我们在第4章中所做的那样，我们将使用媒体查询根据浏览器大小和能力来调整样式。
- en: Listing 5.1 shows our starting HTML. Each card is wrapped in a `<section>` element
    and includes its title (`<h2>`), description (`<p>`), and call to action (`<a>`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1显示了我们的起始HTML。每个卡片都包裹在一个`<section>`元素中，并包括其标题（`<h2>`）、描述（`<p>`）和行动号召（`<a>`）。
- en: Listing 5.1 Starting HTML
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 起始HTML
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Page title
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ① 页面标题
- en: ② Start of the first summary card
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第一张总结卡片的开始
- en: ③ Card title
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 卡片标题
- en: ④ Card description (shown only on hover when browser allows)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 卡片描述（当浏览器允许时仅在悬停时显示）
- en: ⑤ Card call to action
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 卡片行动号召
- en: ⑥ End of first summary card
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 第一张总结卡片的结束
- en: Our starting CSS (listing 5.2) includes some base styles to set up our page.
    For the body, we’re increasing the margin by 40 pixels and adding padding of 20
    pixels to all four sides. We’re using Google Fonts—this time the font family Cardo,
    regular weight, italicized version—for the description of each card. For the headers,
    we’ll use Rubik in both regular and bold weights. This font is a good choice because
    it combines good readability with rounded edges, providing a sense of informality
    that works well with the Cardo font. Notice that when we’re loading multiple Google
    Fonts, we can combine the imports into one request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始的CSS（列表5.2）包括一些基本样式来设置我们的页面。对于主体，我们增加了40像素的边距，并在所有四边添加了20像素的填充。我们使用Google
    Fonts——这次是Cardo字体家族，常规重量，斜体版本——来描述每张卡片。对于标题，我们将使用Rubik字体的常规和粗体重量。这种字体是一个不错的选择，因为它结合了良好的可读性和圆角，提供了一种与Cardo字体相得益彰的非正式感。注意，当我们加载多个Google
    Fonts时，我们可以将导入合并为一个请求。
- en: Listing 5.2 Starting CSS
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 起始CSS
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① One request to load both the Cardo and Rubik fonts
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ① 请求加载Cardo和Rubik两种字体
- en: As we begin styling our project, our page looks like figure 5.4.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始为我们的项目添加样式时，我们的页面看起来像图5.4。
- en: '![](../Images/05-04.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-04.png)'
- en: Figure 5.4 Starting point
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 起始点
- en: 5.2 Laying out the page using grid
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 使用网格布局页面
- en: 'A good starting point is reviewing the layout of our cards and the web page
    as a whole. We need to consider three aspects of our layout:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的起点是回顾我们卡片和网页的整体布局。我们需要考虑我们布局的三个方面：
- en: The header and main content
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题和主要内容
- en: The container for the cards
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片的容器
- en: The content within the cards
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片内的内容
- en: We’ll use the CSS Grid Layout Module for layout in all three use cases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在所有三个用例中使用CSS Grid布局模块进行布局。
- en: Note The CSS Grid Layout Module allows us to place and align elements across
    both the vertical and horizontal axes in a system of columns and rows. Check out
    chapter 2 to find out how this module works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：CSS Grid布局模块允许我们在列和行的系统中在垂直和水平轴上放置和定位元素。查看第2章以了解此模块的工作原理。
- en: To lay out the elements on our page, we’ll start by creating the styles for
    narrow screens and edit the layout as we build up to larger screen sizes by using
    media queries.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的页面上布局元素，我们将首先为窄屏幕创建样式，并通过使用媒体查询，在构建到更大屏幕尺寸的过程中编辑布局。
- en: 5.2.1 Layout using grid
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 使用网格布局
- en: 'Our layout consists of two landmarks: `<header>` and `<main>`, which are immediate
    children of `<body>` (listing 5.3). By giving the `<body>` a `display` property
    with a value of `grid`, we’ll be affecting the position of the `<header>` and
    `<main>` elements.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局由两个地标组成：`<header>`和`<main>`，它们是`<body>`的直接子元素（列表5.3）。通过给`<body>`设置一个值为`grid`的`display`属性，我们将影响`<header>`和`<main>`元素的位置。
- en: Listing 5.3 Starting HTML
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 起始HTML
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we use the `place-items` property to center the elements on the page.
    This property is a shorthand way to combine declaring values for the `align-items`
    and `justify-items` properties. We’ll set its value to `center`, aligning all
    the items in the middle of their respective rows and columns. The following listing
    shows our updated `body` rule.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`place-items`属性来在页面上居中元素。这个属性是合并声明`align-items`和`justify-items`属性值的简写方式。我们将其值设置为`center`，使所有项目在其各自的行和列中间对齐。以下列表显示了我们的更新后的`body`规则。
- en: Listing 5.4 Positioning the `<header>` and `<main>` elements
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 定位`<header>`和`<main>`元素
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that we haven’t defined any `grid-template-rows`, `grid-template-columns`,
    or `grid-template-areas`. By default, when none of these areas is declared, the
    browser creates a one-column grid with as many rows as there are elements to position.
    In our case, we have two elements: `<main>` and `<body>`. Therefore, our grid
    has one column and two rows (figure 5.5).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有定义任何`grid-template-rows`、`grid-template-columns`或`grid-template-areas`。默认情况下，当没有声明这些区域时，浏览器会创建一个一列网格，行数与要定位的元素数量相同。在我们的例子中，我们有两个元素：`<main>`和`<body>`。因此，我们的网格有一列和两行（图5.5）。
- en: '![](../Images/05-05.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-05.png)'
- en: Figure 5.5 One-by-two grid
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 一行两列网格
- en: The widths of the `<header>` and `<main>` are altered by being within the grid
    to take only as much horizontal space as their content requires. Because the `<header>`
    has narrow content (the `<h1>` containing the word *hotel*), the page title centers
    itself on the page. The `<main>` element takes the full width available to it
    because the description of Flamingo Beach (in the second card) needs the full
    width and even wraps. If we extend the width of the screen further, we see that
    the `<main>` element also centers itself (figure 5.6).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`<header>` 和 `<main>` 的宽度通过在网格内调整，仅占用它们内容所需的水平空间。因为 `<header>` 的内容较窄（包含单词 *hotel*
    的 `<h1>`），页面标题会自动居中在页面上。`<main>` 元素占据其可用的全部宽度，因为 Flamingo Beach 的描述（在第二张卡片中）需要全部宽度，并且甚至可以包裹。如果我们进一步扩展屏幕宽度，我们会看到
    `<main>` 元素也会居中（图5.6）。'
- en: '![](../Images/05-06.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-06.png)'
- en: Figure 5.6 Centered `main` on a wide screen
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 宽屏幕上的居中`main`
- en: We’ll also rely on the default functionality of the grid and omit defining rows
    and columns because we want to keep the cards stacked on narrow screens. To add
    space between cards, we include a gap of `1rem`. We also restrict the width of
    the `<main>` element to a maximum 1024 pixels to prevent our cards being too spaced
    out on wide screens after we align them horizontally on wide screens (section
    5.2.2). Our updated CSS, shown in the following listing, keeps the cards stacked
    but adds a 1-rem gap between cards (figure 5.7).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将依赖网格的默认功能，省略定义行和列，因为我们希望在小屏幕上保持卡片堆叠。为了在卡片之间添加空间，我们包括一个`1rem`的间隙。我们还限制`<main>`元素的宽度最大为1024像素，以防止我们在宽屏幕上将卡片水平对齐后，卡片在宽屏幕上过于分散（第5.2.2节）。以下列表显示了我们的更新CSS，它保持了卡片的堆叠，但在卡片之间添加了1rem的间隙（图5.7）。
- en: '![](../Images/05-07.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-07.png)'
- en: Figure 5.7 Grid applied to `<main>`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 应用到`<main>`的网格
- en: Listing 5.5 Positioning the cards on narrow screens
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 在窄屏幕上定位卡片
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 5.2.2 Media queries
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 媒体查询
- en: 'At the moment, our cards are stacked vertically—the default behavior in most
    cases with HTML elements. This layout makes sense on mobile devices, which have
    rather narrow screens. For desktop screens, however, because the browser window
    can be much wider, we can take advantage of the horizontal space by using media
    queries. We can define some media queries to adjust the layout:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的卡片是垂直堆叠的——这是大多数情况下HTML元素的默认行为。这种布局在具有相对较窄屏幕的移动设备上是有意义的。然而，对于桌面屏幕，由于浏览器窗口可以非常宽，我们可以通过使用媒体查询来利用水平空间。我们可以定义一些媒体查询来调整布局：
- en: If the window width is greater than or equal to 700 pixels, we adjust the grid
    to have two equal-size columns and set the height of each section to exactly 350
    pixels.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果窗口宽度大于或等于700像素，我们将调整网格以有两个等宽的列，并将每个部分的宽度设置为正好350像素。
- en: At 950 pixels, we adjust the layout again to have four equal-size columns overriding
    the `grid-template-columns` value set in the preceding media query. The `height`
    property value remains 350 pixels because the condition for the preceding media
    query `(min-width:` `700px)` is still being met.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在950像素时，我们再次调整布局，将布局调整为四个等宽的列，覆盖前面媒体查询中设置的`grid-template-columns`值。`height`属性值保持为350像素，因为前面媒体查询的条件（`min-width:`
    `700px`）仍然满足。
- en: If neither of the requirements for these media queries is met (when the browser
    window is less than 700 pixels wide), the cards will be stacked vertically in
    a single column. The following listing shows the two media queries being created.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些媒体查询的要求都不满足（当浏览器窗口宽度小于700像素时），卡片将垂直堆叠在单列中。以下列表显示了创建的两个媒体查询。
- en: Listing 5.6 Layout for the cards
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 卡片的布局
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Media query to determine whether the browser window is at least 700 pixels
    wide. If so, the styles within the query are used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ① 媒体查询用于确定浏览器窗口是否至少有700像素宽。如果是这样，则使用查询内的样式。
- en: ② Second media query to determine whether the browser window is at least 950
    pixels wide. If so, this query overrides the preceding query and sets the grid
    to four columns wide.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第二个媒体查询用于确定浏览器窗口是否至少有950像素宽。如果是这样，此查询将覆盖前面的查询，并将网格设置为四列宽。
- en: '![](../Images/05-08.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-08.png)'
- en: Figure 5.8 Layout on a screen 800 pixels wide
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 800像素宽屏幕上的布局
- en: Figure 5.8 and figure 5.9 show the output in browser windows that are 800 and
    1000 pixels wide, respectively.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8和图5.9分别显示了浏览器窗口宽度为800像素和1000像素时的输出。
- en: '![](../Images/05-09.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-09.png)'
- en: Figure 5.9 Layout on a screen 1000 pixels wide
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 1000像素宽屏幕上的布局
- en: With our layout in hand, let’s focus on styling our content, starting with the
    header. We’re going to change the font for our `<h1>` element and look at how
    to use an image to color our text.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有我们的布局后，让我们专注于内容的样式设计，从标题开始。我们将更改 `<h1>` 元素的字体，并查看如何使用图片来为文本着色。
- en: 5.3 Styling the header using the background-clip property
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 使用 background-clip 属性设置标题样式
- en: 'The title of this page—Hotels—could be more interesting visually. One way to
    liven it up could be to set a nice vibrant color and update the font family to
    something modern. Another way is to apply a background image to the text. These
    changes are possible through two experimental properties: `background-clip` and
    `text-fill-color`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面的标题“酒店”在视觉上可能更有趣。一种让页面生动起来的方法可以是设置一个漂亮的鲜艳颜色，并将字体家族更新为现代风格。另一种方法是应用背景图像到文本。这些更改可以通过两个实验性属性：`background-clip`
    和 `text-fill-color` 来实现。
- en: Experimental properties
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实验性属性
- en: Some properties’ browser support may be value-specific. The `background-clip`
    property is one of those. This property is supported in all major browsers without
    a vendor prefix for all its possible values except `text`, which still required
    a vendor prefix in Microsoft Edge and Google Chrome when this book was written
    ([https://caniuse.com/?search=background-clip](https://caniuse.com/?search=background-clip)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性的浏览器支持可能是值特定的。`background-clip` 属性就是其中之一。这个属性在其所有可能值中（除了 `text`，在撰写本书时，在
    Microsoft Edge 和 Google Chrome 中仍然需要供应商前缀）都得到了所有主流浏览器的支持，没有供应商前缀。
- en: Experimental properties should be used with care because they often have nonstandard
    implementations. For more details about experimental properties, please refer
    to chapter 3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实验性属性应谨慎使用，因为它们通常具有非标准实现。有关实验性属性的更多详细信息，请参阅第 3 章。
- en: We can reduce the risks from `background-clip:` `text` being an experimental
    property by setting a fallback color value so that if these two properties don’t
    work, the user will see the text without the background image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置回退颜色值，我们可以减少 `background-clip:` `text` 作为实验性属性带来的风险，这样如果这两个属性不起作用，用户将看到没有背景图像的文本。
- en: 5.3.1 Setting the font
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 设置字体
- en: The first step is to update the `font-family`, `weight`, and `size`, as well
    as transform the text to `uppercase`. The following listing shows these changes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新 `font-family`、`weight` 和 `size`，并将文本转换为 `uppercase`。以下列表显示了这些更改。
- en: Listing 5.7 Header typography
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 标题排版
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Shorthand font property
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ① 简写字体属性
- en: We used the shorthand `font` property. The first value sets the `weight`, which
    in this case is `heavy`. The second value is the font size (`120px`), followed
    by the `font-family` we want to use. If this font can’t be loaded, we fall back
    to a `sans-serif` font.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了简写的 `font` 属性。第一个值设置 `weight`，在这个例子中是 `heavy`。第二个值是字体大小（`120px`），然后是我们想要使用的
    `font-family`。如果这个字体无法加载，我们将回退到 `sans-serif` 字体。
- en: We transformed the text to uppercase through styling rather than by writing
    it all in uppercase letters within the HTML. Using all uppercase characters can
    affect accessibility, as some screen readers may interpret all caps as an acronym
    and read the letters individually. If we set the text to uppercase through CSS,
    we’re styling the text only visually; the characters can be mixed-case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过样式将文本转换为大写，而不是在 HTML 中将所有文本都写成大写字母。使用全部大写字母可能会影响可访问性，因为一些屏幕阅读器可能会将全部大写字母解释为缩写，并逐个读取字母。如果我们通过
    CSS 设置文本为大写，我们只是在视觉上样式化文本；字符可以是混合大小写。
- en: Moreover, we’re in a unique position with only one page to style. In a traditional
    project, our styles would most likely be applied to multiple pages. By adjusting
    our casing in our styles, we help ensure consistency throughout our website or
    application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们只有一个页面可以设置样式，这使我们处于独特的位置。在一个传统项目中，我们的样式很可能会应用于多个页面。通过调整我们的样式中的大小写，我们帮助确保整个网站或应用程序的一致性。
- en: It’s also worth noting that we should use all capitals sparingly, as that format
    can affect the readability of the content. Now our header looks like figure 5.10.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，我们应该少量使用全部大写字母，因为这种格式可能会影响内容的可读性。现在我们的标题看起来像图 5.10。
- en: '![](../Images/05-10.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-10.png)'
- en: Figure 5.10 Applied typography styles to headers
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 应用到标题的排版样式
- en: 5.3.2 Using background-clip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 使用 background-clip
- en: Now we’ll use an image to color the letters, essentially applying a background
    image to the letters themselves. The first thing we need to do is set a background
    image on the `<h1>` element. To ensure that the image covers the entirety of the
    `<h1>` element, we assign the `background-size` property a value of `cover`. This
    value automatically calculates the width and height the image needs to make sure
    that the image covers the entire element.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用图像来着色字母，本质上是将背景图像应用于字母本身。首先，我们需要在 `<h1>` 元素上设置一个背景图像。为了确保图像覆盖 `<h1>`
    元素的全部，我们将 `background-size` 属性的值设置为 `cover`。此值会自动计算图像所需的宽度和高度，以确保图像覆盖整个元素。
- en: Next, we manipulate the image to apply only to the letters, rather than the
    entire `<h1>` element. This step is where the `background-clip` property comes
    into play. This property defines, based on the box model, which part of the element
    the background should cover. In our case, we’ll give it a value of `text` because
    we want the image to show behind the letters. This property with the value of
    `text` still requires a browser prefix for WebKit-based browsers (Chrome, Edge,
    and Opera), so we also include the prefixed property for compatibility with those
    browsers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们操作图像，使其仅应用于字母，而不是整个 `<h1>` 元素。这一步是 `background-clip` 属性发挥作用的地方。此属性基于盒模型定义了背景应该覆盖元素的哪个部分。在我们的例子中，我们将它的值设置为
    `text`，因为我们希望图像显示在字母后面。具有 `text` 值的此属性仍然需要基于 WebKit 的浏览器（Chrome、Edge 和 Opera）的前缀，因此我们也包括针对这些浏览器的带前缀的属性以实现兼容性。
- en: Currently, our text is black, preventing the image from showing through. We
    must make the letters transparent so as not to obscure the image we set as our
    text background. The `text-fill-color` property allows us to set the color of
    the text. This property is similar to `color`, but if both properties are set,
    `text-fill-color` supersedes `color`. Because `text-fill-color` also requires
    a vendor prefix (for both WebKit- and Mozilla-based browsers), we can use the
    `color` property as a fallback in case the image doesn’t load or any of the experimental
    properties fails.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的文本是黑色，阻止了图像的显示。我们必须使字母透明，以便不遮挡我们设置为文本背景的图像。`text-fill-color` 属性允许我们设置文本的颜色。此属性类似于
    `color`，但如果两个属性都设置了，`text-fill-color` 将会覆盖 `color`。因为 `text-fill-color` 也需要浏览器前缀（对于基于
    WebKit 和 Mozilla 的浏览器），所以如果图像没有加载或任何实验性属性失败，我们可以将 `color` 属性用作回退。
- en: We’re using `text-fill-color` instead of using the `color` property with a value
    of `transparent` because we’ll use the `color` to create a fallback in case `background-clip`
    doesn’t work in a user’s browser. We set its value to `white` because we’ll add
    a black background to our page later in this chapter. That way, if `background-clip`
    fails or isn’t supported, our text will still be visible to the user; it will
    be white instead of having the image coloring it. The following listing shows
    our updated header class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `text-fill-color` 而不是使用值为 `transparent` 的 `color` 属性，因为我们将会使用 `color` 创建一个回退方案，以防
    `background-clip` 在用户的浏览器中不起作用。我们将它的值设置为 `white`，因为我们将在本章后面添加黑色背景。这样，如果 `background-clip`
    失败或不受支持，用户仍然可以看到文本；它将是白色而不是被图像着色。下面的列表显示了我们的更新后的标题类。
- en: Listing 5.8 `background-clip` text code
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 `background-clip` 文本代码
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Adds the background image
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ① 添加背景图像
- en: ② Clips the background to be applied only behind the text
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ② 仅将背景裁剪应用于文本后面
- en: ③ Makes the text transparent to allow the image to show through
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使文本透明，以便图像能够显示出来
- en: ④ Fallback color
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 回退颜色
- en: When using prefixes, we add the `-moz-` and `-webkit-` properties before the
    non-prefixed version if an nonprefixed version is available. This allows the browser
    to make sure it’s using the nonexperimental version when it becomes available.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用前缀时，如果存在非前缀版本，我们会在非前缀版本之前添加 `-moz-` 和 `-webkit-` 属性。这允许浏览器确保在非实验性版本可用时使用该版本。
- en: With our header styled (figure 5.11), the next task is styling the cards. We’ll
    focus on styling the cards without the hover effect first and then create our
    media query for handling cards on wide screens that support hover.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的标题样式（图 5.11）完成后，下一个任务是样式化卡片。我们首先关注没有悬停效果的卡片样式，然后创建用于处理支持悬停的宽屏幕卡片的媒体查询。
- en: '![](../Images/05-11.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11](../Images/05-11.png)'
- en: Figure 5.11 Background image clipped to the heading
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 背景图像裁剪到标题处
- en: 5.4 Styling the cards
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 样式化卡片
- en: Each card is created with an outer `<section>` element that has a background
    image and an inner `<div>`, which we’ll give a background color to keep our text
    legible over the image. Within that `<div>` is the actual content. The following
    listing shows our card structure in isolation from the rest of the HTML.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个卡片都通过一个具有背景图像的外部 `<section>` 元素创建，并且有一个内部 `<div>`，我们将为它设置背景颜色，以保持文本在图像上的可读性。在该
    `<div>` 内是实际的内容。以下列表显示了我们的卡片结构，独立于其他 HTML 部分。
- en: Listing 5.9 Card HTML in isolation
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 独立的卡片 HTML
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Outer card container. Each section has a class name based on the hotel it
    describes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ① 外部卡片容器。每个部分都有一个基于其描述的酒店的类名。
- en: ② Content container
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ② 内容容器
- en: ③ Content
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 内容
- en: To style each part of the card, we’ll work from the outside in, styling the
    container for each card, followed by the container for the content, and finally
    the content itself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为卡片的每个部分进行样式设计，我们将从外向内工作，首先为每个卡片的容器进行样式设计，然后是内容容器的样式，最后是内容本身。
- en: 5.4.1 Outer card container
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 外部卡片容器
- en: The outer container is the element that gets the background image. Each section
    gets an image for its hotel or resort. We’ll select each section individually
    by its class name. Then we’ll assign each of the sections a background image,
    as shown in the following listing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 外部容器是获取背景图像的元素。每个部分为其酒店或度假村获取一个图像。我们将通过其类名单独选择每个部分。然后，我们将为每个部分分配一个背景图像，如下列所示。
- en: Listing 5.10 Adding background images
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 添加背景图像
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the background images added (figure 5.12), let’s configure some general
    styles that apply to all the sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了背景图像（图 5.12）后，让我们配置适用于所有部分的通用样式。
- en: '![](../Images/05-12.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-12.png)'
- en: Figure 5.12 Card background pictures
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 卡片背景图片
- en: We can see that the images aren’t properly centered and don’t showcase the hotels
    and resorts well. We can adjust the size of the images by using the `background-size`
    property. We set this property to `cover` to maximize the amount of the picture
    being shown without leaving any whitespace visible if the aspect ratio of the
    image differs from that of our card. We also add a `background-color` of `#3a8491`
    (turquoise) as a fallback. Finally, we add a `border-radius` to the card to curve
    our corners and soften our edges. Listing 5.11 shows our container styles.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到图片没有正确居中，并且没有很好地展示酒店和度假村。我们可以通过使用 `background-size` 属性来调整图片的大小。我们将此属性设置为
    `cover`，以最大化显示图片，同时如果图片的宽高比与卡片的不同，则不会留下任何空白可见。我们还添加了 `#3a8491`（青绿色）作为后备颜色。最后，我们在卡片上添加了
    `border-radius` 以使角落弯曲并软化边缘。列表 5.11 显示了我们的容器样式。
- en: Listing 5.11 Card container styles
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 卡片容器样式
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With our outer container addressed (figure 5.13), let’s move on to the content
    container.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了外部容器（图 5.13）后，让我们继续到内容容器。
- en: '![](../Images/05-13.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-13.png)'
- en: Figure 5.13 Styled outer card container
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 样式化的外部卡片容器
- en: 5.4.2 Inner container and content
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 内部容器和内容
- en: Currently, our text isn’t readable; the dark text is hard to read against the
    image background and also close to the edge of the outer container. To improve
    readability, we’ll give our inner container a `background-color` of `rgba(0,`
    `0,` `0,` `.75)`, which is black with some transparency. We’ll also change the
    text color to `whitesmoke` and center it. By not using pure black or pure white
    in our design, we achieve a softer feel for our overall composition.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的文本不可读；深色文本在图像背景上难以阅读，并且靠近外部容器的边缘。为了提高可读性，我们将内部容器的 `background-color` 设置为
    `rgba(0, 0, 0, .75)`，这是一种带有一定透明度的黑色。我们还将文本颜色更改为 `whitesmoke` 并将其居中。通过在设计中使用纯黑或纯白，我们为整体构图带来了一种更柔和的感觉。
- en: With the added background color, we add `1rem` of padding with our content container
    to keep the text away from the edge of our dark background and `1rem` of margin
    to leave a gap between the edge of the picture and the beginning of the background.
    Finally, we adjust the `font-size`, `font-weight`, `line-height`, and `font-family`
    of our text inside our card. The following listing shows the CSS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加背景颜色后，我们在内容容器中添加了 `1rem` 的填充，以使文本远离深色背景的边缘，并添加了 `1rem` 的边距，以在图片边缘和背景开始处留出空间。最后，我们调整了卡片内文本的
    `font-size`、`font-weight`、`line-height` 和 `font-family`。以下列表显示了 CSS 代码。
- en: Listing 5.12 Card content styles
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 卡片内容样式
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Card content container
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ① 卡片内容容器
- en: ② Card header
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ② 卡片标题
- en: ③ Card content
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 卡片内容
- en: With our styles applied (figure 5.14), the last piece of content that needs
    styling is our link.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用了样式（图 5.14）后，最后需要样式的内容部分是我们的链接。
- en: '![](../Images/05-14.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-14.png)'
- en: Figure 5.14 Card inner container and typography
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 卡片内部容器和排版
- en: Because our link serves as a call to action, getting users to look at more information
    about the hotel or resort, we want to make it bold and flashy (listing 5.13).
    To achieve this end, because the majority of our elements inside our cards are
    rather dark, we’ll give the link a bright yellowish-orange (`#ffa600`) background
    and change its text color to almost black. We’ll also add padding. But because
    a link is an inline element by default, we’ll want to change its `display` property’s
    value to `inline-block` so that the padding will affect the height of the element.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的链接充当行动号召，引导用户查看更多关于酒店或度假村的信息，所以我们希望使其加粗并引人注目（列表 5.13）。为了达到这个目的，因为卡片内部的大部分元素颜色都比较深，我们将给链接一个明亮的黄橙色（`#ffa600`）背景，并将其文字颜色改为接近黑色。我们还会添加填充。但由于链接默认是一个内联元素，我们希望将其
    `display` 属性的值更改为 `inline-block`，这样填充就会影响元素的高度。
- en: Listing 5.13 Link styles
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 链接样式
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To match our cards, we’ll give the links a `border-radius` of `4px` and finally
    handle `hover` and `focus`. Instead of underlining, which we’ll remove, on `hover`
    we’ll darken the background color slightly, and on `focus` we’ll add a dashed
    outline offset from the link by 3 pixels. Figure 5.15 shows our styled links.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与卡片匹配，我们将链接的 `border-radius` 设置为 `4px`，并最终处理 `hover` 和 `focus` 状态。我们不会使用下划线，我们将移除它，在
    `hover` 状态下，我们将稍微加深背景颜色，在 `focus` 状态下，我们将添加一个偏移 3 像素的虚线轮廓。图 5.15 显示了我们的样式化链接。
- en: '![](../Images/05-15.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-15.png)'
- en: Figure 5.15 Styled links
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 样式化链接
- en: Not having all of the links aligned horizontally is a bit odd and doesn’t seem
    to be organized. To have all the links aligned, we’ll use `grid` once again. We’ll
    give our inner container a `display` value of `grid` and set our `grid-template-rows`
    value to `min-content` `auto` `min-content`, at the same time setting the height
    of the inner container to `100%` minus the padding and margin we allotted to it
    (figure 5.16).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的链接都没有水平对齐，看起来会有些奇怪，并且似乎没有组织。为了使所有链接对齐，我们将再次使用 `grid`。我们将给内部容器一个 `display`
    值为 `grid`，并将 `grid-template-rows` 值设置为 `min-content` `auto` `min-content`，同时将内部容器的高度设置为
    `100%` 减去我们为其分配的填充和边距（图 5.16）。
- en: '![](../Images/05-16.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-16.png)'
- en: Figure 5.16 Aligning card elements horizontally
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 水平对齐卡片元素
- en: 'Earlier in this chapter, we gave the inner container a `margin` of `1rem` and
    `padding` of `1rem`, meaning that the height it needs to take up the full height
    of the space provided is equal to `100%` minus `4rem` (1 rem of padding and 1
    rem of margin at the top and the same at the bottom, equaling 4 rems total). To
    achieve this effect in CSS, we use the `calc()` function to do the math for us,
    assigning `calc(100%` `-` `4rem)` to the `height` property. The combination of
    defined rows (`grid-template-rows`: `min-content` `auto` `min-content`) and set
    height creates a layout in which the header and link take only as much room as
    they need and the middle section (the paragraph element) gets what is left.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章的早期部分，我们给内部容器设置了 `margin` 为 `1rem` 和 `padding` 为 `1rem`，这意味着它需要占据的空间高度等于
    `100%` 减去 `4rem`（1 rem 的填充和 1 rem 的边距在顶部和底部，总共等于 4 rem）。为了在 CSS 中实现这种效果，我们使用 `calc()`
    函数来为我们进行计算，将 `calc(100% - 4rem)` 分配给 `height` 属性。定义的行（`grid-template-rows`: `min-content`
    `auto` `min-content`）和设置的高度组合创建了一个布局，其中标题和链接只占据它们所需的空间，中间部分（段落元素）则得到剩余的空间。'
- en: Finally, to center the paragraph content vertically in the middle of the card,
    we use the `align-items` property with a value of `center` and remove the bottom
    margin automatically added by the browser to the `<h2>`. If we left the margin
    at the bottom of the header, we’d have more room at the top of the paragraph than
    at the bottom because `min-content` takes the margin included on an element into
    account. Because the link at the bottom of the card has no margin, there would
    be a disproportionate amount of whitespace above the paragraph compared with below
    it. The following listing shows our layout adjustments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在卡片中间垂直居中段落内容，我们使用 `align-items` 属性并设置为 `center`，同时移除浏览器自动添加到 `<h2>` 的底部边距。如果我们保留标题底部的边距，那么段落顶部的空间会比底部多，因为
    `min-content` 会考虑元素上的边距。因为卡片底部的链接没有边距，所以与段落下方相比，段落上方的空白空间会不成比例。下面的列表显示了我们的布局调整。
- en: Listing 5.14 Inner container layout adjustments
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 内部容器布局调整
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This last adjustment finishes our card layout (figure 5.17). Next, we’ll focus
    on showing and hiding parts of the content for devices that are wide enough (width
    greater than or equal to 700 pixels) and have hover capabilities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的调整完成了卡片布局（图5.17）。接下来，我们将关注在宽度足够大（宽度大于或等于700像素）且具有悬停功能的设备上显示和隐藏内容部分。
- en: '![](../Images/05-17.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-17.png)'
- en: Figure 5.17 Styled cards
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 样式化卡片
- en: 5.5 Using transitions to animate content on hover and focus-within
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 使用过渡动画在悬停和焦点内动画化内容
- en: To start, we need to create a media query that checks whether the device supports
    the `hover` interaction, whether the browser window is at least 700 pixels wide,
    and whether our user has `prefers-reduced-motion` enabled on their machine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个媒体查询，检查设备是否支持`hover`交互，浏览器窗口是否至少700像素宽，以及用户是否在他们的机器上启用了`prefers-reduced-motion`。
- en: Reduced-motion preference
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 减少运动偏好
- en: Some users want to opt out of motion-heavy animations. They can do this by enabling
    a setting on their devices that is conveyed to the browser via the `prefers-reduced-motion`
    property. We want to make sure that we respect our users’ settings. Therefore,
    we’ll state that the setting isn’t set (has a value of `no-preference`) as part
    of our query determining whether to animate our content. For more information
    about `prefers-reduced-motion`, refer to chapter 3.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户希望退出运动密集的动画。他们可以通过在设备上启用一个设置来实现，该设置通过`prefers-reduced-motion`属性传达给浏览器。我们想确保我们尊重用户的设置。因此，我们将声明该设置未设置（具有`no-preference`的值）作为我们确定是否动画化内容的查询的一部分。有关`prefers-reduced-motion`的更多信息，请参阅第3章。
- en: Our media query is `@media` `(hover:` `hover)` `and` `(min-width:` `700px)`
    `and` `(prefers-reduced-motion:` `no-preference)` `{` `}`. Notice that we can
    chain multiple parameters that need to be met for the CSS in the query to be applied.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的媒体查询是`@media` `(hover:` `hover)` `and` `(min-width:` `700px)` `and` `(prefers-reduced-motion:`
    `no-preference)` `{` `}`。请注意，我们可以链式多个参数，只有当这些参数都满足时，查询中的CSS才会应用。
- en: To hide everything but the header, we’ll shift the content down to the bottom
    of the card by using the `transform` property with a value of `translateY()`.
    The `translateY()` value allows us to move content vertically outside the flow
    of the page; the content around the element being moved is unaffected by the movement
    and won’t reposition itself or get out of the way.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏除标题之外的所有内容，我们将使用`transform`属性和`translateY()`值将内容向下移动到卡片的底部。`translateY()`值允许我们将内容垂直移动到页面流之外；被移动元素周围的内容不受移动影响，不会重新定位或让路。
- en: To calculate the distance that the element needs to move, we’ll use the `calc()`
    function again. We’ll move the header down by the height of the card (`350px`)
    minus `8rem` (the top margin of the container + top padding of the container +
    size of the header), as shown in the following listing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算元素需要移动的距离，我们再次使用`calc()`函数。我们将通过以下列表所示，将标题向下移动卡片的高度（`350px`）减去`8rem`（容器的顶部边距
    + 容器的顶部填充 + 标题的大小）。
- en: Listing 5.15 Hiding the nonheader content
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.15 隐藏非标题内容
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The inner portion of the card is moved down, as shown in figure 5.18.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片的内部部分向下移动，如图5.18所示。
- en: '![](../Images/05-18.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-18.png)'
- en: Figure 5.18 Moving the content down
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 将内容向下移动
- en: 'Because we’re going to animate showing the content when the user stops hovering
    over the section, we don’t want the trailing content at the bottom to remain:
    if the user hovers on the content bleeding out of the picture, the content will
    move upward into the picture, lose the hover, and then move back down. This behavior
    will repeat, creating a flicker. Therefore, we’ll set a height of `5rem` for our
    inner container and hide the overflow when the paragraph and link are hidden.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要在用户停止悬停在部分上方时动画显示内容，所以我们不想让底部的尾随内容保持：如果用户悬停在图片外溢的内容上，内容将向上移动到图片中，失去悬停状态，然后再次向下移动。这种行为会重复，产生闪烁。因此，我们将为我们的内部容器设置`5rem`的高度，并在段落和链接隐藏时隐藏溢出。
- en: Notice that in the second card, a little bit of the paragraph content will still
    be visible when the content should be hidden, so we’ll also hide the nonheader
    content by using opacity when it shouldn’t be seen. Additionally, we’ll move that
    content down `1rem` by using `translateY()`, which will give it a bit of motion
    when we animate it back in on `hover`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第二个卡片中，当内容应该被隐藏时，段落内容的一小部分仍然可见，因此我们还将使用不透明度隐藏非标题内容。此外，我们还将使用`translateY()`将内容向下移动`1rem`，这样当我们在`hover`时将其动画回时，它将获得一点运动效果。
- en: All together, the CSS used to hide the content and shorten the inner container
    appears in the following listing. To select all the content that isn’t the header,
    we can use the `:not()` pseudo-class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的CSS，用于隐藏内容和缩短内部容器，如下所示。为了选择所有不是标题的内容，我们可以使用`:not()`伪类。
- en: Listing 5.16 Hiding the nonheader content
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.16 隐藏非标题内容
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Media query
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ① 媒体查询
- en: ② Moves and shortens the inner content container
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ② 移动并缩短内部内容容器
- en: ③ Hiding all the non-<h2> content
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 隐藏所有非`<h2>`内容
- en: The `not()` pseudo-class allows us to filter selectors. In this case, we want
    to target anything that isn’t an `<h2>`. Figure 5.19 diagrams the process.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`not()`伪类允许我们过滤选择器。在这种情况下，我们想要定位任何不是`<h2>`的东西。图5.19展示了这个过程。'
- en: '![](../Images/05-19.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-19.png)'
- en: Figure 5.19 Selecting anything that isn’t an `<h2>` inside the inner container
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 选择内部容器内所有不是`<h2>`的内容
- en: Now that the content is hidden (figure 5.20), we can focus on showing it again.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在内容已被隐藏（图5.20），我们可以专注于再次显示它。
- en: '![](../Images/05-20.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05-20.png)'
- en: Figure 5.20 Hiding content
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 隐藏内容
- en: To show the content again, we need to undo everything we did to hide it on both
    `hover` and `focus`. Because we’re not removing the links from the Document Object
    Model (DOM), they’re hidden only visually; programmatically, they still exist,
    and a user can tab to a link via the keyboard. As a result, we need to show the
    content both when the user hovers over the card and when a link gains focus. Because
    we want to act on an ancestor (the content container) when a child (the link)
    is in focus, we can use the `:focus-within` pseudo-class. This pseudo-class allows
    us to apply styles conditionally based on whether a descendant of the element
    is currently in focus.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要再次显示内容，我们需要撤销我们在`hover`和`focus`状态下所做的所有隐藏操作。因为我们没有从文档对象模型（DOM）中移除链接，它们只是视觉上被隐藏了；在程序上，它们仍然存在，用户可以通过键盘切换到链接。因此，当用户悬停在卡片上或链接获得焦点时，我们都需要显示内容。因为我们希望在子元素（链接）获得焦点时对祖先元素（内容容器）进行操作，我们可以使用`:focus-within`伪类。这个伪类允许我们根据元素是否有后代当前处于焦点状态有条件地应用样式。
- en: So when either the link is in focus or the section is being hovered over, we
    move the container back into place by setting the `translateY()` parameter to
    `0` (no vertical displacement) and setting the height of the inner container to
    `350px` (height of the outer container) minus `4rem` (total of the vertical padding
    and margin of the container). We also need to reinstate the paragraph and link,
    the opacity of which was set to `0` and which had been moved down by `1rem`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当链接获得焦点或章节被悬停时，我们通过将`translateY()`参数设置为`0`（无垂直位移）并将内部容器的高度设置为`350px`（外部容器的高度）减去`4rem`（容器垂直内边距和边界的总和）来将容器恢复到原位。我们还需要恢复段落和链接，它们的透明度被设置为`0`，并且已经被向下移动了`1rem`。
- en: We’ll finish our `hover` and `focus-within` effect by adding a transition to
    elements being shown and hidden. Because we have predefined states that we’re
    changing between and want the animation to run only once, when the change occurs,
    we don’t need to use keyframes. We can simply instruct the CSS to animate all
    the changes when they happen, using the `transition` property with a value of
    `all` `700ms` `ease-in-out`. All the changes will be animated; the animation will
    take 700 milliseconds to complete; and the animation will start slow, accelerate,
    and then slow again before completing. The following listing shows our `hover`
    and `focus-within` CSS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为显示和隐藏的元素添加过渡效果来完成`hover`和`focus-within`效果。因为我们已经预定义了要改变的状态，并且希望动画只运行一次，当变化发生时，我们不需要使用关键帧。我们可以简单地指示CSS在变化发生时动画化所有变化，使用`transition`属性，值为`all
    700ms ease-in-out`。所有变化都将被动画化；动画将花费700毫秒完成；动画将以慢速开始，加速，然后在完成前再次减速。以下列表显示了我们的`hover`和`focus-within`CSS。
- en: Listing 5.17 Showing content on `hover` and `focus-within`
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.17 在`hover`和`focus-within`时显示内容
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Animates the changes
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ① 动画变化
- en: ② On section hover, moves container back into place
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在章节`hover`时，将容器恢复到原位
- en: ③ On section focus-within, moves container back into place
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在章节`focus-within`时，将容器恢复到原位
- en: ④ On hover, moves all non-<h2> elements inside the container back into place
    with full opacity
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在`hover`时，将容器内的所有非`<h2>`元素恢复到原位，具有全不透明度
- en: ⑤ On section focus-within, moves all non-<h2> elements inside the container
    back into place with full opacity
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 在章节`focus-within`时，将容器内的所有非`<h2>`元素恢复到原位，具有全不透明度
- en: With these changes applied (figure 5.21), all that’s left to do to complete
    the project is set the background on our page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些更改（图5.21）后，完成项目剩下的工作就是在我们的页面上设置背景。
- en: '![](../Images/05-21.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-21.png)'
- en: Figure 5.21 The `hover` and `focus-within` effect
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 `hover`和`focus-within`效果
- en: To make the pictures pop, we’ll add a dark gray, almost black background to
    the entire page. To apply the background color, we’ll add the `background` property
    with a value of `#010101` to our existing `body` rule, as shown in the following
    listing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使图片更加突出，我们将为整个页面添加深灰色、几乎黑色的背景。要应用背景颜色，我们将添加值为`#010101`的`background`属性到现有的`body`规则中，如下面的列表所示。
- en: Listing 5.18 Adding the background
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.18 添加背景
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Figures 5.22, 5.23, and 5.24 show our finished project at various screen sizes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22、5.23和5.24展示了我们在不同屏幕尺寸下的完成项目。
- en: '![](../Images/05-22.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-22.png)'
- en: Figure 5.22 Project in window 600 pixels wide
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22 在宽度为600像素的窗口中的项目
- en: '![](../Images/05-23.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-23.png)'
- en: Figure 5.23 Project in window 850 pixels wide
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23 在宽度为850像素的窗口中的项目
- en: '![](../Images/05-24.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05-24.png)'
- en: Figure 5.24 Project in window 1310 pixels wide with `prefers-reduced-motion`
    enabled
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 在宽度为1310像素的窗口中启用`prefers-reduced-motion`的项目
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Grid can be used for entire layouts or individual elements within the layout.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格可以用于整个布局或布局中的单个元素。
- en: The `text-transform` property can change text to uppercase without affecting
    the accessibility of the content.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text-transform`属性可以将文本转换为大写，而不会影响内容的可访问性。'
- en: Use `text-transform:` `uppercase` sparingly, not on large areas of content.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请谨慎使用`text-transform:` `uppercase`，不要在大量内容区域使用。
- en: The `background-clip` property with a value of `text` can clip a background
    image around the text.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background-clip`属性值为`text`时，可以剪裁背景图像以围绕文本。'
- en: The `background-clip` property with a value of `text` still needs to be prefixed,
    and this property can change while it’s being implemented.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background-clip`属性值为`text`时仍需要前缀，并且该属性在实现过程中可能会发生变化。'
- en: We can use a media query to check whether a device supports `hover` and adjust
    our layout so that it prevents the user from seeing the content if their device
    doesn’t support `hover`.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用媒体查询来检查设备是否支持`hover`，并调整我们的布局，以防止用户在设备不支持`hover`时看到内容。
- en: We can chain multiple conditions in the same media query by using `and`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用`and`来在同一个媒体查询中链式多个条件。
- en: We can use `prefers-reduced-motion` in our media query to respect user preferences
    regarding animations and motion.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在媒体查询中使用`prefers-reduced-motion`来尊重用户对动画和运动的偏好。
- en: The `:not()` pseudo-class represents elements that don’t match a list of selectors.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:not()`伪类代表不匹配一系列选择器的元素。'
- en: '`translateY()` will move content vertically without affecting reflow.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateY()`将内容垂直移动，而不会影响重新流。'
- en: We can use the `transition` property to animate style changes between states.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`transition`属性在状态之间动画化样式变化。
- en: To apply styles conditionally based on an element’s descendant being in focus,
    we use the `focus-withi`n pseudo-class.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要根据元素的子代是否处于焦点来有条件地应用样式，我们使用`focus-within`伪类。
