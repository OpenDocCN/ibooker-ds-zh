- en: 2 Introducing continuous integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 介绍持续集成
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Documenting requirements in your source code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中记录需求
- en: Establishing a central code repository as the starting point for your pipeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以中央代码仓库作为你流水线的起点
- en: Automating the steps needed to build your product by using a continuous integration
    system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用持续集成系统来自动化构建你产品所需的步骤
- en: Creating a basic application to start development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本应用程序以开始开发
- en: It’s Monday, and you’ve been drinking your morning coffee and scrolling through
    emails when you see an invitation to a meeting titled “Kickoff.” You check the
    time and realize you are going to be late. Grabbing your laptop, you run to the
    conference room and see just one person sitting there, a product manager. As you
    close the door and walk to a seat, they say, “Glad you could make it; sorry about
    the last-minute invite, but we need to get something built this week. Our company
    would like to explore creating a new hello translation service that is cheaper
    and faster than our legacy system. In the future, we want to expand beyond just
    translating ‘hello,’ but our system will not scale. The conversation has been
    going on too long at this point, and I want to prove to them we can get something
    done quickly and still meet their targets. Do you think we can do it?”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 周一，你一边喝着早咖啡一边浏览着邮件，突然看到一封会议邀请，标题为“启动会议”。你看了看时间，意识到自己要迟到了。拿起笔记本电脑，你跑到会议室，只见那里坐着一个人，一个产品经理。当你关上门走向座位时，他说：“很高兴你能来；很抱歉临时邀请，但我们需要在本周内完成一些工作。我们公司希望探索创建一个比我们遗留系统更便宜、更快的新的hello翻译服务。在未来，我们希望将服务扩展到不仅仅是翻译‘hello’，但我们的系统将无法扩展。到目前为止，对话已经持续得太久，我想向他们证明我们可以快速完成工作，同时还能达到他们的目标。你认为我们能做到吗？”
- en: A new service to replicate the functionality of an old service in less than
    a week, with better performance and at a cheaper cost? Sure, why not? What do
    you have to lose?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新服务，在一周内以更优的性能和更低的成本复制旧服务的功能？当然，为什么不呢？你有什么可失去的？
- en: “What I want is for you to do this in pieces and write it so that we can get
    feedback quickly. Also, I want to demo this tomorrow from a live server. It doesn’t
    need to be perfect; it just needs to show what we were able to do in a day. I
    also want it so that we can have others join you once this demo is over. And we
    need to be sure it works as we expect and that we can prove why it does.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “我希望你分步骤完成这项工作，并编写代码以便我们能快速获得反馈。此外，我希望明天能从实时服务器演示这个。它不需要完美；只需要展示我们一天内能做什么。我还希望其他人演示结束后能加入你。我们还需要确保它按预期工作，并且我们可以证明为什么它能。”
- en: As they’re talking, you quickly open a terminal and type `mkdir` `hello-api`
    `&&` `touch hello-api/README.md`. You open your `README.md` file and write the
    code in the following listing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们在谈话时，你迅速打开一个终端并输入 `mkdir` `hello-api` `&&` `touch hello-api/README.md`。你打开你的
    `README.md` 文件，并按照以下列表编写代码。
- en: Listing 2.1 `README.md`
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 `README.md`
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: “Great, once you are done, let me know, and we can chat about the next steps.
    I appreciate you doing this. I think it will be great for us to show our company
    how rapid product development can work and make us a success.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “很好，一旦你完成了，告诉我，我们可以讨论下一步。我很感激你做这件事。我认为这将对我们展示公司如何快速进行产品开发并取得成功大有裨益。”
- en: 'You leave the room with your laptop and go get some more coffee. When you get
    back to your desk, you look at the time: 9:15\. It’s time to start coding.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你带着笔记本电脑离开房间去喝更多的咖啡。当你回到办公桌前，你看了看时间：9:15。是时候开始编码了。
- en: 2.1 Where to start?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 从哪里开始？
- en: Beginning a project based on an idea can be a little overwhelming. What language
    do you write it in? How should it be structured? What are the various use cases?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于一个想法开始一个项目可能会有些令人不知所措。你用哪种语言编写它？应该如何构建？有哪些不同的用例？
- en: Interestingly, none of that matters. If you are asked to create something in
    a day, you will go with the language you are most comfortable with. You will write
    the code in the simplest way possible. You will never know all of the use cases,
    so it is best to just get something in the hands of the customers. With this project,
    you have the benefit of knowing some business requirements because there is a
    legacy system, but in most cases, you will never know.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这些都无关紧要。如果你被要求在一天内创建某物，你将使用你最熟悉的语言。你将以最简单的方式编写代码。你永远不会知道所有的用例，所以最好是尽快将产品交给客户。在这个项目中，你有一个好处，就是了解一些业务需求，因为有一个遗留系统，但在大多数情况下，你永远不会知道。
- en: 'As you start, it is a great idea to create a document to write down your setup
    process, milestones, testing process, and so forth. You already started the documentation
    in your meeting when you started a `README.md`. Most developers will open this
    file first, and it is a great way of communicating asynchronously. The README
    file is not a new concept and has been a fixture of software development for decades.
    Its purpose is to give the user relevant information to configure, install, run,
    or use a piece of software. What goes into your README depends on your team, but
    often it will hold the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始时，创建一个文档来记录您的设置过程、里程碑、测试过程等是一个很好的主意。您在开始`README.md`时已经开始了文档。大多数开发者会首先打开这个文件，这是一种异步沟通的好方法。README文件不是一个新概念，并且几十年来一直是软件开发的一个固定元素。它的目的是向用户提供配置、安装、运行或使用软件的相关信息。您的README包含的内容取决于您的团队，但通常它将包含以下内容：
- en: Instructions on how to run the software
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行软件的说明
- en: Configurations in your environment to run the software
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的环境中运行软件的配置
- en: Known dependencies
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知依赖项
- en: Troubleshooting information
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除信息
- en: Common use cases and examples of using the software
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的使用案例和软件使用示例
- en: Software milestones
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件里程碑
- en: Figure 2.1 shows how a document acts as a map for new team members.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1显示了文档如何作为新团队成员的地图。
- en: '![](../../OEBPS/Images/CH02_F01_Holmes4.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F01_Holmes4.png)'
- en: Figure 2.1 The README document is a pointer to all other documents within your
    product. This will help enhance the developers’ understanding of how to contribute,
    run, build, or debug your product.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 README文档是指向您产品中所有其他文档的指针。这将有助于增强开发者对如何贡献、运行、构建或调试您产品的理解。
- en: 'You have already added one of these items from the list: software milestones.
    Now you want to add a description of what the software does, what it needs, and
    how to start working on it. The README has now become a lab notebook in which
    you tell others what you are doing and how to replicate the experiment. It should
    also have a thesis or a purpose that tells the reader what this product does.
    If you find it hard to write a thesis, you may not have a great idea of what you
    are building. Let’s write this out:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经从列表中添加了这些项目之一：软件里程碑。现在您想添加对软件功能的描述，它需要什么，以及如何开始工作。README现在已经成为一个实验室笔记本，您在其中告诉他人您正在做什么以及如何复制实验。它还应包含一个论文或目的，告诉读者这个产品做什么。如果您发现很难写论文，那么您可能对您正在构建的东西没有很好的想法。让我们把它写出来：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is an improved version of the current `hello-api` we use in production.
    It will use less memory and be cheaper to run in production, and it will scale,
    expand to additional words, and be more stable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前我们在生产中使用的`hello-api`的改进版本。它将使用更少的内存，在生产中运行成本更低，并且可以扩展，扩展到更多的单词，并且更稳定：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Great! You’ve used this to make your first decision. Choosing Go was natural
    for you because it is a fun, newer language you’ve been using in your spare time.
    It will be a great way to introduce this to your company and has a reputation
    for using little memory, being scalable, and being stable. Notice that you left
    `Setup` blank. This is intentional. This is a living document that should be updated
    when infrastructure changes are implemented. This will help us throughout the
    chapter by guiding us to the logical step that we should take next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！您已经用它做出了第一个决定。选择Go对您来说很自然，因为它是一种您在业余时间一直在使用的有趣、较新的语言。这将是一种向公司介绍它的好方法，并且它以使用少量内存、可扩展性和稳定性而闻名。请注意，您留下了`设置`为空白。这是故意的。这是一个活文档，应该在基础设施变更实施时更新。这将通过引导我们走向下一步的逻辑步骤来帮助我们贯穿整个章节。
- en: 2.2 A greenfield project
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 绿色项目
- en: 'For this book, we use a Unix-based development environment. Why? Because most
    of the deployment services we will use are Linux based. Windows even has this
    neat feature available to run Ubuntu Linux inside Windows. Between Linux and Windows,
    we have a pretty large share of users. macOS will work for most things, so we
    need to indicate when it won’t. This is very important to note, so we should probably
    add this to our `README.md` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们使用基于Unix的开发环境。为什么？因为我们将要使用的许多部署服务都是基于Linux的。Windows甚至有一个很酷的功能可以在Windows内部运行Ubuntu
    Linux。在Linux和Windows之间，我们有相当大的用户份额。macOS对于大多数事情都适用，所以我们需要指出它不适用的情况。这一点非常重要，所以我们可能需要将其添加到我们的`README.md`文件中：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Development expects to run in a Unix-like system. If you are running Windows,
    please consider following these directions ([http://mng.bz/VpQr](http://mng.bz/VpQr)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 开发预期将在类 Unix 系统上运行。如果你正在运行 Windows，请考虑遵循以下指示（[http://mng.bz/VpQr](http://mng.bz/VpQr)）。
- en: Now we need to install Go. It would be easy to simply paste a link to a download
    and tell users to follow the instructions. However, you might be on version 1.7.2
    and the next person on 1.7.3, and the person after that on a different version.
    Soon everyone is on a different version, which seems benign but could become a
    problem when you’re helping a colleague solve a problem, because it works on your
    machine and not theirs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要安装 Go。简单地粘贴下载链接并告诉用户遵循指示会很容易。然而，你可能使用的是 1.7.2 版本，下一个人使用的是 1.7.3 版本，再下一个人使用的是不同的版本。很快，每个人都使用不同的版本，这看起来无害，但当你帮助同事解决问题时可能会成为问题，因为它在你的机器上工作，但在他们的机器上不工作。
- en: It’s at times like this when we want to use standardized tools to help create
    repeatable tasks. To do this, we will create a Makefile—a standard in the developing
    world, which can become very complex. Our Makefile will just house some small
    commands that we can reference in the documentation and aid us in development.
    Open a new Makefile in your code editor, and add the code in the following listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种时候，我们希望使用标准化工具来帮助创建可重复的任务。为此，我们将创建一个 Makefile——在开发世界中是一种标准，它可以变得非常复杂。我们的
    Makefile 将仅包含一些小命令，我们可以在文档中引用它们，并帮助我们进行开发。在您的代码编辑器中打开一个新的 Makefile，并添加以下列表中的代码。
- en: Listing 2.2 Makefile
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 Makefile
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ .PHONY is used to define some of our methods in advance so that we can use
    them in the setup phase.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `.PHONY` 用于提前定义我们的一些方法，以便我们可以在设置阶段使用它们。
- en: ❷ Runs commands to install Go and setup environment
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行命令安装 Go 并设置环境
- en: ❸ Downloads a specific version of Go and installs it
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 下载特定版本的 Go 并安装
- en: ❹ Adds Go location to your local environment
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 Go 位置添加到您的本地环境
- en: Alternatives
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'The following code is in Make because it is used fairly often by the DevOps
    community and developers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 Make，因为它被 DevOps 社区和开发者相当频繁地使用：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**NOTE** If you are not using Bash as your shell, you will have to modify these
    steps to add Go to your system path.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 如果你不是使用 Bash 作为您的 shell，你将不得不修改这些步骤以将 Go 添加到系统路径。'
- en: Notice the `TODO` comment here. This is okay. Remember that we are trying to
    move fast but also be helpful. What is important is to document what is missing
    so that others will know when they join your codebase. `TODO` items are a great
    way for people to start contributing! Add the code in the following listing to
    your README.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的 `TODO` 注释。这是可以的。记住，我们试图快速行动但也要有帮助。重要的是要记录缺失的内容，这样其他人加入代码库时就会知道。`TODO`
    项是人们开始贡献的绝佳方式！将以下列表中的代码添加到您的 README 中。
- en: Listing 2.3 `README.md`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 `README.md`
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ macOS is not supported by this Makefile yet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此 Makefile 还不支持 macOS。
- en: By using standardization and documentation, you establish a guide on how to
    work on this product. This is almost like pulling out a set of building instructions
    for a table from Ikea. Anyone who picks it up should be able to follow the directions
    and have a running application. Standardizing our system allows others to contribute.
    Given our tools and our documentation, the next step in the evolution of product
    development is automation. For factories, this came in the form of the assembly
    line. For software, it came from the continuous integration pipeline.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标准化和文档化，你建立了一项关于如何在此产品上工作的指南。这几乎就像从宜家拿出一张桌子的一套组装说明。任何拿起它的人都应该能够遵循指示并运行应用程序。标准化我们的系统允许他人贡献。鉴于我们的工具和文档，产品开发进化的下一步是自动化。对于工厂来说，这表现为装配线。对于软件来说，这来自持续集成管道。
- en: 2.3 The assembly line
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 装配线
- en: Once producers were able to standardize the way they did their work in their
    homes, they started moving to centralized factories. These factories still had
    each worker sitting at their workbench assembling items by themselves. One worker’s
    job may have been to cut the leather for a shoe and then deliver the stack of
    cut pieces to another worker, who attached it to a bottom piece, and so on. Today,
    assembly lines are much different. Some people stand and do repetitive tasks,
    but with the advent of more advanced automation, these stations have become more
    skilled and nuanced, requiring special training and knowledge, much like today’s
    software developers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当生产者能够在家中将他们的工作标准化后，他们开始转向集中式工厂。这些工厂仍然让每个工人坐在他们的工作台上自己组装物品。一个工人的工作可能只是切割鞋子的皮革，然后将切割好的皮革堆叠交给另一个工人，由他将其固定到底部部件上，依此类推。今天，装配线大不相同。有些人站立并执行重复性任务，但随着更高级自动化的出现，这些工作站变得更加熟练和细致，需要特殊培训和知识，就像今天的软件开发者一样。
- en: In software, we can imagine this as a developer sitting at their machine, writing
    code, compiling it, and then deploying it. While many people produce code this
    way, it does not scale well. Artisans will produce custom furniture, and in the
    same way, many programmers will sit at home hacking away at a project on their
    own. But this isn’t industrial development. These are solo projects. Most companies
    do not need artisanal software; they need predictability and reliability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，我们可以想象这是一个开发者坐在他们的机器上，编写代码，编译它，然后部署它。虽然许多人以这种方式生产代码，但这并不容易扩展。工匠会制作定制家具，同样，许多程序员会坐在家里独自对一个项目进行黑客攻击。但这不是工业发展。这些都是独立项目。大多数公司不需要工匠软件；他们需要可预测性和可靠性。
- en: What is needed is a way of automating the flow of items through a factory so
    that workers aren’t doing everything themselves or spending time handing things
    off. In factories, this was called the assembly line; in software development,
    it is called a *continuous integration pipeline*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的是一种自动化工厂中物品流动的方法，这样工人就不必自己完成所有工作或花费时间传递物品。在工厂中，这被称为装配线；在软件开发中，它被称为*持续集成管道*。
- en: A continuous integration pipeline, or CI system, is just an application that
    moves code along a set of predefined processes. A CI system can be as simple as
    copying a file to a different location to as complicated as handling multiple
    deployments and quality checks. In this book, we will move from the former to
    the latter using GitHub Actions. Table 2.1 outlines some of the most common CI
    systems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成管道，或 CI 系统，只是一个将代码沿着一系列预定义流程移动的应用程序。CI 系统可以像将文件复制到不同位置那样简单，也可以像处理多个部署和质量检查那样复杂。在这本书中，我们将使用
    GitHub Actions 从前者过渡到后者。表 2.1 概述了一些最常见的 CI 系统。
- en: Table 2.1 Continuous integration servers have also evolved over the years and
    often have a cloud-based hosting solution so you don’t need to run them yourself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 持续集成服务器也随着时间而发展，通常拥有基于云的托管解决方案，因此您无需自行运行它们。
- en: '| Continuous integration system | Year | Hosted service |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 持续集成系统 | 年份 | 托管服务 |'
- en: '| Azure DevOps | 2005 | Yes |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| Azure DevOps | 2005 | 是 |'
- en: '| TeamCity | 2006 | Yes |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| TeamCity | 2006 | 是 |'
- en: '| Circle CI | 2011 | Yes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Circle CI | 2011 | 是 |'
- en: '| Jenkins | 2011 | No |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| Jenkins | 2011 | 否 |'
- en: '| Travis CI | 2012 | Yes |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| Travis CI | 2012 | 是 |'
- en: '| GitLab | 2014 | Yes |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| GitLab | 2014 | 是 |'
- en: '| GitHub Actions | 2020 | Yes |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| GitHub Actions | 2020 | 是 |'
- en: GitHub Actions is a fairly new technology to help create integration pipelines
    for developers’ source code. It uses a special YAML file to help us define the
    various stages that we want our code to go through, when to run the stages, and
    what to do if something doesn’t work. The pipeline is broken down into a set of
    jobs. Each job can have a series of steps involved and can depend on other jobs.
    Each step can either run a command directly on the underlying system (bash commands,
    scripts, etc.) or use libraries to help do repetitive tasks (set up Go, check
    out code, etc.). When you look at some definitions, you will see things like `actions/setup-go@v2`,
    which means we will use the `GithubAction` command to set up our Go environment
    with the proper version.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是一种相对较新的技术，用于帮助开发者为源代码创建集成管道。它使用一个特殊的 YAML 文件来帮助我们定义我们希望代码通过的各个阶段，何时运行这些阶段，以及如果出现问题应该做什么。管道被分解为一组作业。每个作业可以包含一系列步骤，并且可以依赖于其他作业。每个步骤可以直接在底层系统上运行命令（bash
    命令、脚本等）或使用库来帮助执行重复性任务（设置 Go、检出代码等）。当你查看一些定义时，你会看到像 `actions/setup-go@v2` 这样的东西，这意味着我们将使用
    `GithubAction` 命令来使用正确版本设置我们的 Go 环境。
- en: 'Additionally, we want to understand the first pipeline we are building. At
    first, all we want to do is create a binary and upload it as an artifact to our
    GitHub repository. You should see the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想了解我们正在构建的第一个管道。一开始，我们只想创建一个二进制文件并将其作为工件上传到我们的 GitHub 仓库。你应该看到以下步骤：
- en: Set up Go.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Go 环境。
- en: Check out the code.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出代码。
- en: Build a binary.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建二进制文件。
- en: Copy the file to the upload directory.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件复制到上传目录。
- en: Upload the artifact to GitHub.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工件上传到 GitHub。
- en: To show how simple it is, we will create our pipeline now before we have written
    any code. In your terminal, type `mkdir` `-p` `.github/workflows` `&&` `touch`
    `.github/workflows/pipeline.yml`, and open the file. In it, we will add the code
    in the following listing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示其简单性，我们将在编写任何代码之前创建我们的管道。在你的终端中，输入 `mkdir -p .github/workflows && touch
    .github/workflows/pipeline.yml`，然后打开文件。在其中，我们将添加以下列表中的代码。
- en: Listing 2.4 `pipeline.yml`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 `pipeline.yml`
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ We will only run this CI process when a change is made to the main branch.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们只有在主分支有更改时才会运行这个 CI 流程。
- en: ❷ These are the various stages that are run in our pipeline.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些是我们管道中运行的各个阶段。
- en: ❸ Run this on a Linux-based machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Linux 的机器上运行此程序。
- en: ❹ Ensures that our image has Go 1.18 or higher
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 确保我们的镜像有 Go 1.18 或更高版本
- en: ❺ Pulls code from a local repository
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从本地仓库拉取代码
- en: ❻ Tells our build command to build a binary
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 告诉我们的构建命令构建一个二进制文件
- en: ❼ Copies the resulting binary to a directory to upload
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将生成的二进制文件复制到上传目录
- en: ❽ Creates an archive to be attached to the workflow with the binary
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 创建一个包含二进制文件的存档，并将其附加到工作流程中
- en: ❾ Names the binary directory something you will be able to identify it with
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将二进制目录命名为你可以识别的名称
- en: Hopefully, some of you will have caught that we have a new `make` target listed.
    Here, we are standardizing our build using `make build`. Why? Well, Go allows
    us to configure our builds using flags and various other features, and we want
    to make sure that we have it standardized. For now, we will use the simple Go
    build, but in future chapters, we will have alternative configurations that we
    will want to use. Let’s add our build command to our Makefile using the code in
    the following listing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你们中的一些人已经注意到我们列出了一个新的 `make` 目标。在这里，我们正在使用 `make build` 标准化我们的构建。为什么？好吧，Go
    允许我们使用标志和各种其他功能来配置我们的构建，我们想确保它是标准化的。现在，我们将使用简单的 Go 构建，但在未来的章节中，我们将有其他配置，我们希望使用。让我们使用以下列表中的代码将我们的构建命令添加到
    Makefile 中。
- en: Listing 2.5 `\.gitignore`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 `\.gitignore`
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The build command will compile the main application into a binary named api.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建命令将编译主应用程序到一个名为 api 的二进制文件中。
- en: You may be wondering where the code is built. Trust me, we’ll get there. For
    now, you can see how we can tie in the standardized build system to our assembly
    line. Our developers can use the same commands that we use on the assembly line
    to ensure they work locally but will be triggered automatically on our pipeline.
    If we need to change the process, it can then be reflected across both local and
    production environments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道代码是在哪里构建的。相信我，我们很快就会到达那里。现在，你可以看到我们如何将标准化的构建系统与我们的生产线结合起来。我们的开发者可以使用我们在生产线上使用的相同命令来确保它们在本地工作，但将在我们的管道上自动触发。如果我们需要更改流程，它就可以在本地和生产环境中得到反映。
- en: NOTE You changed a process. Did you update the documentation?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你更改了流程。你是否更新了文档？
- en: The assembly line is often mistaken as an invention of Henry Ford. However,
    the concept of an assembly line goes back decades before Ford’s use of it on his
    famous Model T. Clothing, machines, bicycles, and boats were all applications
    of the concept of moving pieces between divided pieces of labor as far back as
    the industrial revolution. Automated tracks of materials would move around assembly
    or unit production. You can compare the two in figure 2.2.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 装配线常被误认为是亨利·福特的一项发明。然而，装配线的概念在福特在著名的 T 型车中使用它之前就已经存在了几十年。服装、机器、自行车和船只都是将零件在劳动分工的不同部分之间移动的概念的应用，这一概念可以追溯到工业革命时期。自动化的材料轨道会在装配或单元生产中移动。你可以在图
    2.2 中比较这两个。
- en: '![](../../OEBPS/Images/CH02_F02_Holmes4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F02_Holmes4.png)'
- en: Figure 2.2 Assembly lines have evolved over the years in what they can do. Automation
    enhances the worker’s ability to create higher-quality products more efficiently.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 随着时间的推移，装配线在它们能做什么方面已经发生了演变。自动化增强了工人创造更高品质产品更有效率的能力。
- en: Henry Ford didn’t even create the *automated* assembly line. What he is famous
    for is his application of the assembly line by creating core principles that efficiently
    delivered his product from start to finish.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 亨利·福特甚至没有发明**自动化**生产线。他因应用生产线而闻名，通过创建核心原则，这些原则有效地从开始到结束高效地交付了他的产品。
- en: 'His principles were simple:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 他的原则很简单：
- en: Place the tools and people in the order of operation.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按操作顺序放置工具和人员。
- en: Optimize the flow for each station of work.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化每个工作站的工作流程。
- en: Automate the line to move the product being assembled.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化生产线以移动正在组装的产品。
- en: 'These principles boil down to grouping tools and workers: create a system that
    is easy to assemble and requires pieces to move automatically from each stage.
    Today, assembly lines are more sophisticated and have higher levels of automation,
    but the principles remain the same: make your tools easy to use, use the tools
    efficiently, and automate the flow to the next step.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则归结为将工具和工人分组：创建一个易于组装的系统，需要部件自动从每个阶段移动。今天，生产线更加复杂，自动化程度更高，但原则保持不变：使你的工具易于使用，高效地使用工具，并自动化流向下一步的流程。
- en: We have just created our assembly line, moving our artisan development into
    industrial development. What we need to do now is find a way of moving materials
    into factories and moving products out.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一条生产线，将我们的工匠开发转变为工业化开发。我们现在需要做的是找到一种将材料运入工厂和将产品运出的方法。
- en: 2.4 Warehouses
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 仓库
- en: I live in Pittsburgh, the Steel City. It got that name because of the large
    steel industry that was built here in the late 1800s. Throughout the outskirts
    of the city today, you will still see functioning steel mills and abandoned ones.
    What caused the steel industry to be so big here? Was it the climate? The population?
    The technology? No. The success was its proximity to the materials needed to create
    steel and its proximity to the distribution networks of the time. Coal, iron,
    and limestone would come down from the mountains surrounding the city and nearby
    areas into the factories. The factories would then produce steel and ship it out
    on the railroad or on barges down one of the rivers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我住在匹兹堡，钢铁之城。它之所以得名，是因为在19世纪末在这里建立的大型钢铁工业。今天，你仍然可以在城市的郊区看到仍在运行的钢铁厂和废弃的钢铁厂。是什么原因使这里的钢铁工业如此庞大？是气候吗？人口吗？技术吗？不。成功在于其靠近制造钢铁所需的材料以及当时分销网络的邻近性。煤炭、铁和石灰石从城市周围的山脉和附近地区运下来进入工厂。然后工厂生产钢铁，通过铁路或通过河流上的驳船运出。
- en: 'The *proximity of resources* and *distribution networks* are essential to modern
    production as well. Instead of relying on the location of natural resources, now
    companies will build warehouses to store their materials until they can get around
    to processing them. When a product is completed, it then goes to another warehouse
    until it is needed by a customer. These warehouses also go by another, more generic
    name: repositories.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 资源**邻近性**和**分销网络**对现代生产同样至关重要。不再依赖于自然资源的地理位置，现在公司会建造仓库来储存他们的材料，直到他们可以处理它们。当产品完成时，它随后会进入另一个仓库，直到客户需要。这些仓库也有另一个更通用的名字：存储库。
- en: '*Repositories* are locations to store things. In software, we have code repositories
    that store our code. As with manufacturing, we want our source code to have close
    proximity to our factory to make product development more efficient. In our case,
    we want our software code to be close to our pipeline code as it gets assembled.
    Code repositories come in many shapes and sizes, but we will use Git for our code
    repository hosted on GitHub.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储库**是存储物品的地方。在软件中，我们有代码存储库来存储我们的代码。与制造业一样，我们希望我们的源代码与我们的工厂保持接近，以使产品开发更高效。在我们的情况下，我们希望我们的软件代码在组装时接近我们的管道代码。代码存储库有多种形状和大小，但我们将使用GitHub上托管的Git作为我们的代码存储库。'
- en: We will build a project to use throughout the book. The source code can be found
    at [https://github.com/holmes89/hello-api](https://github.com/holmes89/hello-api).
    In each chapter, we add new tasks and procedures to our repository to show how
    we can test, build, and deploy multiple products from a single repository.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中使用一个项目。源代码可以在[https://github.com/holmes89/hello-api](https://github.com/holmes89/hello-api)找到。在每一章中，我们向我们的存储库添加新的任务和程序，以展示我们如何从一个存储库测试、构建和部署多个产品。
- en: First, if you haven’t already signed up for a GitHub Account, go to [https://github.com/join](https://github.com/join)
    and then [http://mng.bz/xdxq](http://mng.bz/xdxq) (SSH access to your account).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你还没有注册GitHub账户，请访问[https://github.com/join](https://github.com/join)然后[http://mng.bz/xdxq](http://mng.bz/xdxq)（SSH访问你的账户）。
- en: Then navigate to the upper right-hand corner, click the plus sign, and select
    New Repository. Then you will be on a setup page. Pick a name and add a description
    if you’d like. Follow the setup in figure 2.3.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后导航到右上角，点击加号，选择新建仓库。然后你将进入一个设置页面。选择一个名称，如果你愿意的话，还可以添加一个描述。按照图2.3中的设置进行操作。
- en: '![](../../OEBPS/Images/CH02_F03_Holmes4.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F03_Holmes4.png)'
- en: Figure 2.3 Provide a name, and create a `.gitignore` file using a Go template.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 提供一个名称，并使用Go模板创建一个`.gitignore`文件。
- en: 'Then click Create Repository. Congratulations! You’ve created a repo. Please
    make sure that you have Git installed ([http://mng.bz/AlXE](http://mng.bz/AlXE)).
    Then we will configure our local directory to use this repository. In your directory,
    run the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击创建仓库。恭喜！你已经创建了一个仓库。请确保你已经安装了Git([http://mng.bz/AlXE](http://mng.bz/AlXE))。然后我们将配置我们的本地目录以使用这个仓库。在你的目录中运行以下代码：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now can store our code in a central location, and our actions will produce
    a binary that is also shared here with others. This repository is essential for
    the growth of our product. Once we share our code, others can start contributing
    and sharing as well. Our code is the material used by our system to build, test,
    and ship our products.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将代码存储在中央位置，我们的操作将生成一个二进制文件，这个文件也将与其他人共享。这个仓库对我们产品的增长至关重要。一旦我们分享代码，其他人也可以开始贡献和共享。我们的代码是我们系统构建、测试和发货产品的材料。
- en: This means that our product code, testing code, and infrastructure code all
    reside in the same repository, where they can be processed and used to ship the
    product. Not only does our product code get checked for quality, but so does our
    test code and infrastructure code. We will see this as we move throughout this
    book. It is visualized in figure 2.4, where you see that material that is used
    for a product is shipped to a single assembly, and a product is then shipped.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的产品代码、测试代码和基础设施代码都存储在同一个仓库中，它们可以经过处理并用于发货产品。不仅我们的产品代码要经过质量检查，测试代码和基础设施代码也是如此。随着我们继续阅读本书，我们将看到这一点。如图2.4所示，用于产品的材料被运送到单个装配点，然后产品被发货。
- en: '![](../../OEBPS/Images/CH02_F04_Holmes4.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F04_Holmes4.png)'
- en: Figure 2.4 In manufacturing, materials are delivered from a repository of raw
    resources and are then assembled into a finished product, which is delivered to
    a customer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 在制造业中，材料从原材料仓库中交付，然后组装成成品，交付给客户。
- en: The repository will need to hold everything that goes into making our product.
    This includes product code, deployment code, infrastructure definitions, testing
    plans, auto-
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '仓库需要存储制作我们产品所需的一切。这包括产品代码、部署代码、基础设施定义、测试计划、自动- '
- en: mated testing frameworks, and so forth. This may seem radical to some people,
    but it is core to the idea of continuous integration. This is the single source
    of truth for how to build our product and creates a sense of ownership for everyone
    working on it. You may find that a project may require more than one repository
    or rely on external systems. These fall into different patterns of development
    and deployment. We focus on a single project repository in this instance to keep
    our work simple and organized. What we want is code going in and a product going
    out, as illustrated in figure 2.5.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试框架等等。这可能对一些人来说似乎很激进，但这是持续集成理念的核心。这是我们构建产品的唯一真相来源，并为所有参与其中的人创造了一种所有权感。你可能发现一个项目可能需要多个仓库或依赖于外部系统。这些属于不同的开发和部署模式。在这个例子中，我们专注于单一项目仓库，以保持我们的工作简单和有序。我们想要的代码进入，产品出去，如图2.5所示。
- en: '![](../../OEBPS/Images/CH02_F05_Holmes4.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH02_F05_Holmes4.png)'
- en: Figure 2.5 Similar to the manufacturing process, we can assemble our source
    code into a product through an integration layer to then be shipped to a customer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 与制造过程类似，我们可以通过集成层将源代码组装成产品，然后交付给客户。
- en: With a single repository, you can solve a lot of organizational problems. For
    example, by having your test code in the same repository as your product code,
    you can have your assembly line easily run integration tests after a build before
    the artifact is deployed. Otherwise, a trigger may need to happen on the testing
    repository to start tests after the build has been completed. Or you may find
    that you have a chicken or egg problem when it comes to releasing a new feature
    or schema change. As I mentioned before, this will need to be based on how you
    and your team want to structure it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个仓库，你可以解决许多组织问题。例如，通过将测试代码与产品代码放在同一个仓库中，你可以在部署工件之前，在构建后轻松运行集成测试。否则，可能需要在测试仓库上触发以在构建完成后开始测试。或者，你可能会发现，在发布新功能或模式更改时，你面临的是一个鸡生蛋的问题。正如我之前提到的，这需要基于你和你团队想要的结构来决定。
- en: 'Some items may not be required to check into your repository. Specifically,
    things like compiled binaries and external libraries aren’t typically checked
    in but are scraps left over from your development that you don’t want to add to
    the repository. To handle this, we can create a special file called `.gitignore`.
    Create one, open it, and add the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目可能不需要检查到你的仓库中。特别是，像编译后的二进制文件和外部库通常不会被检查，但它们是你开发过程中留下的碎片，你不想将它们添加到仓库中。为了处理这个问题，我们可以创建一个特殊的文件，称为`.gitignore`。创建一个，打开它，并添加以下内容：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ We do not want to save the binary to our source control.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们不希望将二进制文件保存到我们的源代码控制中。
- en: This should prevent us from adding these files to our repository so that it
    stays clean. You may not need all of these files, but they are standard files
    you wouldn’t want to check into your repository.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该可以防止我们将这些文件添加到我们的仓库中，以保持其整洁。你可能不需要所有这些文件，但它们是标准文件，你不会希望将它们检查到你的仓库中。
- en: We now have standardization with a Makefile, documentation in a README, process
    in the form of a pipeline, storage in the form of a repository, and shipping in
    the form of a release. All we are missing is the material to produce our product.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Makefile的标准，README中的文档，以管道形式的过程，以仓库形式存储，以及以发布形式交付。我们唯一缺少的是生产产品的材料。
- en: 2.5 Material
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 材料内容
- en: Where is the code? Why haven’t we written a single line of Go yet? Why are we
    going through all of this setup before we even have a product?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在哪里？为什么我们还没有写一行Go代码？为什么在我们甚至没有产品之前，我们要经历所有这些设置？
- en: These are good questions, and to be honest, it does seem a little backward to
    be putting in all of this work to build a pipeline and document it without anyone
    else working on the project and no code written. This was intentional, though,
    to prove a point. Our process should be agnostic of the code we have written.
    I chose Go for this book for a variety of reasons, but you may be a JavaScript
    or Python developer, and these principles still apply. We can imagine that our
    project changes from a `hello-service` to a `good-bye-service`, and all of the
    work we did will not change. The code does not matter!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是很好的问题，说实话，似乎有点反常，要在没有其他人参与项目并且没有编写代码的情况下投入所有这些工作来构建管道并记录它。但这却是故意的，目的是证明一个观点。我们的流程应该与我们所编写的代码无关。我选择Go作为本书的原因有很多，但你可能是一名JavaScript或Python开发者，这些原则仍然适用。我们可以想象，我们的项目从`hello-service`变为`good-bye-service`，而我们所做的所有工作都不会改变。代码并不重要！
- en: To demonstrate this magic, let’s write our code. Type `mkdir cmd && touch cmd/main.go`,
    open the file, and add the code in the following listing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个魔法，让我们编写我们的代码。输入`mkdir cmd && touch cmd/main.go`，打开文件，并添加以下列表中的代码。
- en: Listing 2.6 `main.go`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 `main.go`
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Hardcoding system port; for now, we will be able to configure it in the future.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 硬编码系统端口；目前我们将来能够配置它。
- en: ❷ Creates a single handler, for now, to meet the minimum requirements of our
    system
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 目前创建一个单独的处理程序，以满足我们系统的最低要求。
- en: ❸ Sets the default header type since this will be a REST API
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置默认的头部类型，因为这将是一个REST API
- en: ❹ Additional logging information for the server port; this information is often
    helpful for running multiple servers on a single machine.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为服务器端口提供额外的日志信息；这些信息在运行单个机器上的多个服务器时通常很有帮助。
- en: ❺ Runs the server
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 运行服务器
- en: ❻ Common structure to store translation information
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 存储翻译信息的通用结构
- en: 'We will use the internal HTTP `mux` library and Gorilla Mux in this book, but
    there are other options as well:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用内部HTTP `mux`库和Gorilla Mux，但还有其他选项：
- en: Gin
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gin
- en: kit
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kit
- en: beego
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: beego
- en: Let’s also package our code so that others will know which libraries it depends
    on. To do this, we will initialize a Go module. For more information on Go modules,
    please visit [https://go.dev/blog/using-go-modules](https://go.dev/blog/using-go-modules).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打包我们的代码，以便其他人知道它依赖于哪些库。为此，我们将初始化一个Go模块。有关Go模块的更多信息，请访问[https://go.dev/blog/using-go-modules](https://go.dev/blog/using-go-modules)。
- en: 'Type `make build` and then `./api`, and see your server run. Test it by running
    it in a separate terminal:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`make build`然后`./api`，看看你的服务器是否运行。通过在另一个终端运行它来测试：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just like magic. Now, for my next trick, we will let our pipeline produce a
    binary. In your terminal type
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样。现在，接下来我要展示的是，我们将让我们的管道生成一个二进制文件。在你的终端输入
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Navigate to GitHub, click on the Actions tab, and see your pipeline run. Hopefully,
    everything turns green. Click on the run, and you will see a binary called `api`.
    Download it and run it, and you will see that it works the same as the local instance.
    You can play around with the code and change the output to see the pipeline run
    and deliver new binaries.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到GitHub，点击“操作”标签，查看你的管道运行情况。希望一切都会变成绿色。点击运行，你会看到一个名为`api`的二进制文件。下载并运行它，你会看到它与本地实例的工作方式相同。你可以玩弄代码，更改输出以查看管道运行并交付新的二进制文件。
- en: 'This code is pretty dumb, but this is intentional. Think about the level of
    effort put in and what this opens up for others. If a coworker is waiting on this
    to work to build a UI, they don’t need the fully developed system to start integrating.
    Or, if we aren’t sure exactly what our customer wants quite yet, we can just get
    this out there for a demo. It’s not perfect, but it works. And this is the essence
    of continuous integration and deployment: small slices of work that can keep you
    moving forward. Now that we have the basic code written, we need to put it on
    the conveyor belt for assembly and delivery.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当愚蠢，但这是故意的。想想投入的努力以及这为他人打开了什么。如果同事正在等待这个功能来构建用户界面，他们不需要完整的系统来开始集成。或者，如果我们还没有完全确定客户想要什么，我们可以先把这个东西拿出来进行演示。它并不完美，但它是有效的。这正是持续集成和部署的本质：小块的工作可以让你不断前进。现在我们已经写好了基本代码，我们需要将其放入传送带进行组装和交付。
- en: We can now deliver a product for someone to use as we go back and improve the
    code we wrote. Breaking down tasks into small pieces is essential to creating
    a high-quality product that meets customers’ demands. It also reduces the risk
    of introducing more code and features than what we need or can support.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以交付一个产品供他人使用，同时我们回头改进我们编写的代码。将任务分解成小块对于创建满足客户需求的高质量产品至关重要。这也有助于降低引入比我们需要的或能够支持更多的代码和功能的风险。
- en: Our project manager wanted a demo by tomorrow to show that this will work, and
    you have just done that. It isn’t dynamic, and that’s okay. That is a complexity
    we will add along the way, but it will be easy now that we have an automated way
    to do it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目经理希望明天能有一个演示，以证明这将有效，而你刚刚做到了这一点。它不是动态的，但这没关系。这是我们将在过程中添加的复杂性，但现在有了自动化的方式来做这件事，它将变得简单。
- en: You look at your clock and realize that it is time for lunch. You stand up and
    see the head of the QA department walking right toward your desk. Your eyes lock,
    and they wave, yelling, “Hey, do you have a quick minute?” You nod and sit back
    down.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你看看你的钟表，意识到是吃午饭的时间了。你站起来，看到QA部门的负责人正朝你的桌子走来。你的目光相遇，他们挥手喊道：“嘿，你有几分钟时间吗？”你点头，又坐了下来。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The code repository is the start of your pipeline where all code lives.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码仓库是管道的起点，所有代码都存储在这里。
- en: Use scripts and tools to make environments uniform for all developers and systems.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本和工具使所有开发者和系统环境保持一致。
- en: Document everything in your code base to make developers productive from day
    one.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码库中记录下所有内容，以便开发者从第一天开始就能提高生产力。
- en: Automate all tasks associated with your code.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化与你的代码相关的所有任务。
