- en: 3 Input of strings and numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 输入字符串和数字
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Input of numbers and strings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入数字和字符串
- en: Using `optional` when we may not have a value
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们可能没有值时使用`optional`
- en: Working with random numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理随机数
- en: Further practice with lambdas and `std::function`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步练习使用lambda和`std::function`
- en: In this chapter, we will write a number-guessing game to practice taking inputs
    by using strings and numbers. We need to generate a random number to guess, accept
    input from a player, and report whether the player’s guess is correct. We will
    ensure the guess is actually a number, so we will learn about working with strings
    and numbers. We will give clues if the guess is wrong, starting with “too big”
    or “too small,” and then add more clues, such as how many digits are correct.
    The brief introduction to random numbers will give us a foundation for later chapters,
    and we will learn several more C++ features along the way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个猜数字游戏来练习使用字符串和数字进行输入。我们需要生成一个随机数字来猜测，接受玩家的输入，并报告玩家的猜测是否正确。我们将确保猜测实际上是一个数字，因此我们将学习如何处理字符串和数字。如果猜测错误，我们将给出提示，从“太大”或“太小”开始，然后添加更多提示，例如有多少位是正确的。对随机数的简要介绍将为后续章节奠定基础，并且我们将在过程中学习更多C++特性。
- en: 3.1 Guessing a predetermined number
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 猜测一个预定的数字
- en: We will start with a constant number to guess. Guessing a number that never
    changes is not much of a game, but it means we can concentrate on dealing with
    user input. If we put the predetermined number in a function, we can change it
    later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从猜测一个固定数字开始。猜测一个永远不会改变的数字并不是一个很有趣的游戏，但这意味着我们可以专注于处理用户输入。如果我们把预定的数字放入一个函数中，我们以后可以改变它。
- en: Listing 3.1 A number to guess
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 一个要猜测的数字
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Feel free to pick another number. We don’t need an entire function for this,
    but it might make the guessing-game code clearer than sending in a hard-coded
    or *magic* number. We will switch this out for a random number later. For now,
    all we need to do is take some user input and see if it matches.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随意选择另一个数字。我们不需要一个完整的函数来做这件事，但这可能比发送硬编码或*魔法*数字的猜测游戏代码更清晰。我们稍后会用随机数替换它。现在，我们只需要做一些用户输入，看看它是否匹配。
- en: 3.1.1 Accepting user input the hard way
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 以困难的方式接受用户输入
- en: 'We used the stream insertion `operator` `<<` to send values to the screen in
    the last chapter. The `iostream` header also provides input via the stream extraction
    `operator` `>>`. We can use this operator to send input into a variable like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了流插入`operator` `<<`将值发送到屏幕上。`iostream`头文件还通过流提取`operator` `>>`提供输入。我们可以使用此运算符将输入发送到变量中，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It’s defined for all standard C++ types, as is `operator<<`. We are trying to
    stream anything typed into an `unsigned` because our number to guess is `unsigned`.
    If the user types in digits followed by Enter, the variable might contain a number.
    In the last chapter, we saw that we can assign a negative number to an `unsigned`.
    For a signed number, the high order bit indicates the sign of the number, whereas
    an unsigned number uses this bit as part of the value, so we can say `unsigned`
    `int` `number` `=` `-2`, and it will compile, but the number will have a large
    positive value, `4294967294`, in Visual Studio 2022\. Furthermore, the input might
    not be a number or might even be too big to fit into our chosen numeric type.
    This suggests streaming straight into an `unsigned` is a bad idea, but we can
    persuade it to behave relatively well with some extra effort. We will try alternative
    approaches in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它为所有标准C++类型定义，就像`operator<<`一样。我们正在尝试将任何键入的内容流式传输到`unsigned`，因为我们的猜测数字是`unsigned`。如果用户输入数字后按Enter键，变量可能包含一个数字。在上一章中，我们看到了我们可以将一个负数赋给一个`unsigned`。对于一个有符号数，最高位表示数字的符号，而一个无符号数使用这个位作为值的一部分，所以我们可以说`unsigned
    int number = -2`，它将编译，但数字在Visual Studio 2022中将具有很大的正值，`4294967294`。此外，输入可能不是一个数字，甚至可能太大而无法适合我们选择的数值类型。这表明直接将流式传输到`unsigned`是一个坏主意，但我们可以通过一些额外的工作来说服它相对良好地表现。我们将在下一节尝试替代方法。
- en: 'Let us see how far we can get if we stick with direct input to an `unsigned`.
    The operator skips over any initial whitespace and then consumes characters until
    Enter is pressed, as shown in figure 3.1\. If there is only initial whitespace
    and a few digits, everything is fine. The whitespace is ignored, and the digits
    are transformed into a value stored in the `unsigned` variable. However, if the
    input is not suitable for an `unsigned`, two things happen: the input stream is
    in an error state, and it has unused characters that need clearing up.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们坚持直接将输入到 `unsigned` 中，我们能走多远。操作符会跳过任何初始空白，然后消费字符直到按下 Enter，如图 3.1 所示。如果只有初始空白和一些数字，一切正常。空白被忽略，数字被转换成一个存储在
    `unsigned` 变量中的值。然而，如果输入不适合 `unsigned`，会发生两件事：输入流处于错误状态，并且它有未使用的字符需要清除。
- en: '![CH03_F01_Buontempo](../Images/CH03_F01_Buontempo.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F01_Buontempo](../Images/CH03_F01_Buontempo.png)'
- en: Figure 3.1 Streaming into an `unsigned` skips over initial whitespace, accepts
    as many digits as fit into the `unsigned`, and then ignores anything else, leaving
    the unused characters in the stream.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 将流输入到 `unsigned` 中会跳过初始空白，接受尽可能多的数字，然后忽略其他任何内容，留下流中的未使用字符。
- en: 'As soon as an unsuitable character is encountered, a flag is set, which we
    could check directly by calling `std::cin .fail()`. We can also use the operator’s
    explicit conversion to a `bool` by checking whether `(std::cin` `>>` `number)`
    is true. The stream’s conversion happens via an `explicit operator bool`, which
    means it can be *explicitly* converted to a `bool`. CppReference ([http://mng.bz/W164](http://mng.bz/W164))
    describes this check as idiomatic. The operator is marked as `explicit`, so we
    need to be in a context that expects a `bool`, such as an `if` or `while`, meaning
    we cannot accidentally convert the stream to a `bool`. If something fails, we
    need to clear the failed flag and mop up the bad characters using the `ignore`
    function. The function takes two parameters: the number of characters to extract
    and a delimiting character to stop at, so we want the maximum possible number
    of characters and to stop at a new line character, `''\n''`. Then we can loop
    until the user enters something sensible. Pulling this together and including
    the `limits` and `iostream` headers gives us the following.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦遇到不合适的字符，就会设置一个标志，我们可以通过调用 `std::cin .fail()` 直接检查这个标志。我们也可以通过检查 `(std::cin
    >> number)` 是否为真来使用操作符的显式转换为 `bool`。流的转换是通过一个 `explicit operator bool` 进行的，这意味着它可以被*显式地*转换为
    `bool`。CppReference ([http://mng.bz/W164](http://mng.bz/W164)) 将这种检查描述为惯用法。操作符被标记为
    `explicit`，这意味着我们需要在一个期望 `bool` 的上下文中，例如 `if` 或 `while`，这意味着我们不会意外地将流转换为 `bool`。如果发生错误，我们需要清除失败标志并使用
    `ignore` 函数清除坏字符。该函数接受两个参数：要提取的字符数和一个停止的定界字符，因此我们希望提取尽可能多的字符，并在换行符 `'\n'` 处停止。然后我们可以循环直到用户输入合理的内容。将这一切组合起来并包括
    `limits` 和 `iostream` 头文件，我们得到以下内容。
- en: Listing 3.2 Reading a number from standard input
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 从标准输入读取数字
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Streams characters in and checks nothing failed
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 流入字符并检查是否没有失败
- en: ❷ Clears the fail flag
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 清除失败标志
- en: ❸ Mops up invalid input
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 清除无效输入
- en: ❹ Returns a number if we escape the loop
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果我们退出循环，则返回一个数字
- en: Armed with our initial predetermined number from listing 3.1, we can use the
    input function from listing 3.2 and create a guessing game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 带着从列表 3.1 中预定的初始数字，我们可以使用列表 3.2 中的输入函数创建一个猜谜游戏。
- en: Listing 3.3 A first attempt at a number-guessing game
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 尝试编写一个数字猜谜游戏
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Loops while the guess is wrong
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当猜测错误时循环
- en: ❷ Only exits the loop for a correct guess
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有在猜测正确时才退出循环
- en: ❸ Calls our guessing function with our predetermined number
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用预定的数字调用我们的猜测函数
- en: We can play the game, but we can also make several improvements. We are ensuring
    a number is entered. If we try some gibberish, we get told off over and over again
    until we enter a number, as shown in figure 3.2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以玩游戏，但也可以进行一些改进。我们确保输入了一个数字。如果我们尝试一些乱码，我们会一次又一次地被告知，直到我们输入一个数字，如图 3.2 所示。
- en: '![CH03_F02_Buontempo](../Images/CH03_F02_Buontempo.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_Buontempo](../Images/CH03_F02_Buontempo.png)'
- en: Figure 3.2 We get stuck in a loop if we do not enter a number.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 如果我们不输入数字，我们会陷入循环。
- en: Now try a negative number, for example, `-1`. Figure 3.3 shows what happens.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一个负数，例如 `-1`。图 3.3 显示了发生了什么。
- en: '![CH03_F03_Buontempo](../Images/CH03_F03_Buontempo.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F03_Buontempo](../Images/CH03_F03_Buontempo.png)'
- en: Figure 3.3 Guessing a negative number doesn’t work as expected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 猜测一个负数并不像预期的那样工作。
- en: We know why this happened; when we assign `-1` to an `unsigned`, it wraps around.
    We can fix this by changing the type to `int`. As shown in figure 3.4, if we try
    a few other nonnegative numbers and end with our not-very-random number, `42`,
    we win.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道为什么会发生这种情况；当我们将`-1`赋值给一个`unsigned`时，它会回绕。我们可以通过将类型更改为`int`来修复这个问题。如图3.4所示，如果我们尝试一些其他非负数，并以我们不太随机的数字`42`结束，我们就赢了。
- en: '![CH03_F04_Buontempo](../Images/CH03_F04_Buontempo.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F04_Buontempo](../Images/CH03_F04_Buontempo.png)'
- en: Figure 3.4 Provided we avoid bad input, we can play a rather predictable game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 假设我们避免不良输入，我们可以玩一个相当可预测的游戏。
- en: We have a semblance of a number-guessing game, but it would be nice to give
    the user a way to indicate they give up. By changing the input function, we can
    make numeric input *optional* so the user can stop the game more easily.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似数字猜谜游戏的样子，但最好给用户一个表明他们放弃的方式。通过改变输入函数，我们可以使数字输入成为*可选的*，这样用户就可以更容易地停止游戏。
- en: 3.1.2 Accepting optional numeric input
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 接受可选的数字输入
- en: 'The `c` in `cin` stands for character. Instead of streaming directly into a
    numeric type, we could stream the characters into a string. If we include the
    `string` header, we can accept input this way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`cin`中的`c`代表字符。我们不是直接将字符流输入到数值类型中，而是将字符流输入到一个字符串中。如果我们包含`string`头文件，我们可以这样接受输入：'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `string` will contain the user input, but `cin` will stop on whitespace.
    If we type “Hello, World!,” the string will only contain “Hello,” leaving the
    remaining input behind to stream into another `string` or ignore. We can get the
    entire line instead like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`将包含用户输入，但`cin`会在空白处停止。如果我们输入“Hello, World!”，字符串将只包含“Hello，”剩下的输入将留给我们，以便流到另一个`string`或忽略。我们可以这样获取整行：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will collect every character, including whitespace until the end of the
    line, leaving the characters before the end line for us in the `std::string in`.
    We can then choose what to do with the entire line.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将收集每一行中的每个字符，包括空白，直到行尾，将行尾之前的字符留给我们放入`std::string in`中。然后我们可以选择如何处理整行。
- en: 'Because we want to compare the input with a number, we will need to do something
    to convert the input. If we write an appropriate function, called `read_number`,
    taking a stream, we process the string we got from `getline` after including the
    `sstream` header:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想将输入与一个数字进行比较，我们需要做些事情来转换输入。如果我们编写一个适当的函数，称为`read_number`，它接受一个流，我们处理包含`sstream`头文件后从`getline`得到的字符串：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'How do we implement this `read_number` function? There are various ways to
    try to parse an integer from a string or stream. Working with `IOStreams` can
    get very gnarly very quickly. Angelika Langer and Klaus Kreft wrote a book called
    *Standard C++ IOStreams and Locales: Advanced Programmer’s Guide and Reference*
    (Addison-Wesley Professional; 2000), which gives in-depth coverage. It is a huge
    book, which reflects the complexity of this topic. To keep things simple, we will
    use `std::optional` here, which will make our life easier.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这个`read_number`函数？有各种方法尝试从字符串或流中解析整数。与`IOStreams`一起工作可能会很快变得非常复杂。Angelika
    Langer和Klaus Kreft写了一本名为《标准C++ IOStreams和Locales：高级程序员指南和参考》（Addison-Wesley Professional；2000）的书，对这一主题进行了深入探讨。这是一本很大的书，反映了这一主题的复杂性。为了使事情简单，我们将在这里使用`std::optional`，这将使我们的生活更容易。
- en: 'The `optional` type was introduced in C++17 and lives in the `optional` header.
    It is sometimes described as a *vocabulary type*, along with `std::any` and `std::variant`.
    They are templates, so take a type as a parameter. After the response we saw in
    figure 3.3, we know we should use integers rather than unsigned integers, so we
    will use a signed integer for the template type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional`类型是在C++17中引入的，它位于`optional`头文件中。它有时被描述为一种*词汇类型*，与`std::any`和`std::variant`一起。它们是模板，所以需要传入一个类型作为参数。在图3.3中看到响应之后，我们知道我们应该使用整数而不是无符号整数，因此我们将使用有符号整数作为模板类型：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This has no value. We can see if an `optional` has a value by checking the `has_value()`
    member function explicitly or using the `explicit` `operator` `bool`; in other
    words, using the `optional` in an `if` or `while` expression or similar. This
    is similar semantics to the stream used earlier. It’s worth noticing patterns
    in the C++ language and library. They can inform our own code by showing us sensible
    approaches. Having no value might be legitimate, but we can initialize the value
    with an integer instead
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有值。我们可以通过显式检查`has_value()`成员函数或使用`explicit`运算符`bool`来查看`optional`是否有值；换句话说，在`if`或`while`表达式或类似表达式中使用`optional`。这与之前使用的流具有类似的语义。值得注意的是C++语言和库中的模式。它们可以通过向我们展示合理的途径来告知我们的代码。没有值可能是合法的，但我们可以用整数初始化值
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'or change the value:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更改值：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This allows `optional` to possibly contain a value. Some functional programming
    languages have the idea of a `maybe` type. We don’t have to reserve values to
    indicate a variable is unset if we use an optional type. The `operator` `bool`
    will return `true` if the value is set. If we want to use the value, we call the
    `value` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许`optional`可能包含一个值。一些函数式编程语言有`maybe`类型的概念。如果我们使用可选类型，我们不需要为表示变量未设置而保留值。`operator
    bool`将返回`true`如果值已设置。如果我们想使用这个值，我们调用`value`函数：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the `optional` doesn’t contain a value, we will get an exception. If it does,
    we get a number.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`optional`不包含值，我们将得到一个异常。如果它包含值，我们将得到一个数字。
- en: We can now write a function to read a number from a stream. We can either use
    `getline` outside the function to form a stream, having read the whole line of
    input, or tidy up nonnumeric input in our `read_number` function. If we do the
    latter, we don’t need to remember to do this when we call the function. Our new
    function looks like this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写一个函数来从流中读取数字。我们可以在函数外部使用`getline`来形成一个流，读取整个输入行，或者在`read_number`函数中整理非数字输入。如果我们这样做，我们就不需要在调用函数时记住做这件事。我们新的函数看起来像这样。
- en: Listing 3.4 Taking optional input
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 获取可选输入
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Zero initializes the int.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将int初始化为零。
- en: ❷ Tries to read a number
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试读取一个数字
- en: ❸ Returns the int (as an optional)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个int（作为可选）
- en: ❹ Tidies up
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 整理
- en: ❺ Otherwise returns an empty optional
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 否则返回一个空的可选
- en: Notice we are returning an empty `optional` on the penultimate line. If we return
    the `result`, we are returning an `int`, so the `optional` will have a value,
    defeating the point of using the `optional` to indicate that the user wanted to
    stop guessing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在倒数第二行返回了一个空的可选。如果我们返回`result`，我们返回的是一个`int`，因此`optional`将有一个值，这样就违背了使用`optional`来表示用户想要停止猜测的目的。
- en: We have given ourselves options by sending the stream into the reading function,
    rather than pinning it down to standard input. For example, we could get the whole
    line of input using `std::stringstream in_stream(in)` outside the function and
    send that in instead. This would mean we still know what the user typed. We decided
    to clear the stream if it didn’t contain a number, so we have lost the input if
    `cin` is sent in directly. That is good enough for our game, but we can see that
    we have choices here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将流发送到读取函数而不是将其固定到标准输入，我们给自己提供了选择。例如，我们可以在函数外部使用`std::stringstream in_stream(in)`来获取整个输入行，并将其发送进来。这意味着我们仍然知道用户输入了什么。我们决定如果流不包含数字就清除它，所以如果直接发送`cin`，我们就失去了输入。这对我们的游戏来说已经足够好了，但我们可以看到我们在这里有选择。
- en: If the user enters a number, our new function will return an `optional` with
    a value; otherwise, an empty `optional` is returned. We can check for an empty
    optional in the `while` loop with
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入一个数字，我们的新函数将返回一个带有值的`optional`；否则，返回一个空的`optional`。我们可以在`while`循环中检查空的可选：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'so we can drop out of the loop and stop asking for guesses if the player doesn’t
    enter a number. Note that a few compilers may issue a warning when we use the
    result of the assignment as a condition, especially if using clang or GCC with
    the warning flag `-Wparentheses`. Using a second set of parentheses indicates
    we do intend to check the value assigned and stops the warning:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在玩家没有输入数字时跳出循环并停止请求猜测。注意，一些编译器在我们将赋值的结果用作条件时可能会发出警告，尤其是在使用带有警告标志 `-Wparentheses`
    的 clang 或 GCC 时。使用第二组括号表示我们确实打算检查所赋的值，从而停止警告：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We could even say what the number is if the player gives up. Pulling this together,
    we have code for a slightly better game.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家放弃，我们甚至可以说出这个数字。将这些放在一起，我们就有了一个稍微更好的游戏代码。
- en: Listing 3.5 Allowing giving up
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 允许放弃
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Drops out of the loop if input is not a number
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果输入不是数字，则退出循环
- en: ❷ Stops if the guess is correct
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果猜测正确，则停止
- en: ❸ Tells the player the number
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 告诉玩家数字
- en: If we play the game now, we can give up, by typing either “Give up” or any input
    other than a number (figure 3.5).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在玩游戏，我们可以通过输入“放弃”或任何非数字输入来放弃（图 3.5）。
- en: '![CH03_F05_Buontempo](../Images/CH03_F05_Buontempo.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F05_Buontempo](../Images/CH03_F05_Buontempo.png)'
- en: Figure 3.5 The player can now give up and find out the number.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 玩家现在可以选择放弃并找出数字。
- en: Our game works, but it would be nice to give the player clues when they are
    wrong. Once we have that in place, we will be ready to dive into using random
    numbers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏可以工作，但如果在玩家猜错时给出提示会更好。一旦我们有了这个，我们就可以准备深入研究使用随机数了。
- en: 3.1.3 Validation and feedback using std::function and lambdas
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 使用std::function和lambda进行验证和反馈
- en: If the guess is wrong, it is either too big or too small. We could check that
    in place, but using a validation function gives us more flexibility. Although
    we will only report if a number is too big or too small here, we will add various
    other feedback in our final section when we create a prime number-guessing game.
    We will use a lambda again and see how to send it to our guessing game.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果猜测错误，它要么太大要么太小。我们可以在原地检查这一点，但使用验证函数给我们更多的灵活性。虽然我们在这里只会报告数字太大或太小，但当我们创建质数猜测游戏时，我们将在最后一节添加各种其他反馈。我们再次使用lambda，并看看如何将其发送到我们的猜测游戏。
- en: 'We want to change our function signature to say something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想改变我们的函数签名，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, there is no lambda keyword. Every lambda has a unique type, so we
    need another way to express that we have something we can call, like a function
    or a lambda, known as a *callable*, as our second parameter. We could use a template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有lambda关键字。每个lambda都有一个独特的类型，因此我们需要另一种方式来表达我们可以调用某些内容，比如一个函数或lambda，这被称为*可调用*，作为我们的第二个参数。我们可以使用模板：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, this does not express that the message is callable. We could use a
    *concept* to constrain the template type, giving an alternative approach that
    we will look at in the next chapter. For now, we will use `std::function`. This
    will help us understand lambdas better.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有表达出消息是可调用的。我们可以使用*概念*来约束模板类型，提供一种替代方法，我们将在下一章中探讨。现在，我们将使用`std::function`。这将帮助我们更好地理解lambda。
- en: '`std::function` is a template providing a general-purpose wrapper for lambdas,
    named functions, or any callable object. We need to specify the return and parameter
    types in the template. For our game, we have a number and a guess, which are our
    inputs for the message function, and we want to return a message to display, which
    can be a `string`. For a named function, the signature would look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::function`是一个模板，提供对lambda、命名函数或任何可调用对象的通用包装器。我们需要在模板中指定返回和参数类型。对于我们的游戏，我们有一个数字和一个猜测，它们是消息函数的输入，我们想要返回一个要显示的消息，它可以是`string`。对于命名函数，签名看起来像这样：'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The return type comes first, followed by the function name and the parameters
    (two `int`s in our case). To create an `std::function`, we include the `functional`
    header and declare a function wrapper with the same signature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型首先，然后是函数名和参数（在我们的例子中是两个`int`）。要创建`std::function`，我们需要包含`functional`头文件并声明一个具有相同签名的函数包装器：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The template parameters, `std::string(int,` `int)`, look like the named function,
    but without a name. We call `callable` as we would any function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数`std::string(int, int)`看起来像命名函数，但没有名称。我们像调用任何函数一样调用`callable`：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because we haven’t specified what the `callable` should do, it is an *empty*
    function, so it throws an exception. This mirrors the behavior of `optional`.
    We can initialize `callable` with a lambda:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有指定`callable`应该做什么，所以它是一个*空*函数，因此会抛出异常。这反映了`optional`的行为。我们可以用lambda初始化`callable`：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function is no longer empty, and we can safely call it. Notice we are using
    `std::format` again. Section 2.2.5 gave instructions on how to use the `fmt` library
    instead if your compiler does not support `std::format` yet. Don’t forget that
    you will need to change `std::format` to `fmt::format` and include the `fmt/core.h`
    header instead of the standard `format` header. We can now add an extra parameter
    for a message function to our game so we can give the player clues if their guess
    is wrong.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不再为空，我们可以安全地调用它。注意我们再次使用了 `std::format`。第2.2.5节提供了关于如果您的编译器还不支持 `std::format`，如何使用
    `fmt` 库的说明。别忘了您需要将 `std::format` 改为 `fmt::format`，并包含 `fmt/core.h` 头文件而不是标准的 `format`
    头文件。现在我们可以为我们的游戏添加一个额外的参数，以便在玩家的猜测错误时提供线索。
- en: Listing 3.6 Providing clues if the guess is wrong
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 如果猜测错误则提供线索
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Shows a message if the guess is wrong
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果猜测错误则显示消息
- en: ❷ Adds a prompt after the message
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在消息后添加提示
- en: We also need to change our `main` function, providing the message via a lambda
    function. We can either send it in directly or declare the lambda on a separate
    line using `auto`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改我们的 `main` 函数，通过一个 lambda 函数提供消息。我们可以直接发送它，或者使用 `auto` 在单独的一行上声明 lambda。
- en: Listing 3.7 Improved number-guessing game
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 改进的数字猜测游戏
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Why do we declare the `message` as `auto` rather than specifying `std::function<std::
    string(int,` `int)>`? Although it is less typing, there is an important point
    to note here as well. The type of the lambda or *closure* is unnamable by us,
    but `auto` infers the exact type for us. Two lambdas taking the same parameters
    and having the same return type actually have different types. However, both lambdas
    could be assigned to the same `std::function`. This is useful for our purposes
    but has drawbacks. A lambda can be inlined, avoiding the overhead of a function
    call. If we copy a lambda into an `std::function`, it can no longer be inlined,
    so calling it might be slower. Copying our lambda to an `std::function` might
    also involve dynamic memory allocation. Scott Meyers gives full details in “Item
    5: Prefer auto to explicit type declarations” in his book *Effective Modern C++*
    (O’Reilly Media, 2014)*,* and we already know we should almost always use `auto`.
    If we declare the lambda as `auto`, we avoid the overheads, although it will be
    copied to an `std::function` in the method call. We could actually change the
    function signature in listing 3.6 to use `auto` as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '为什么我们声明 `message` 为 `auto` 而不是指定 `std::function<std:: string(int, int)>`？尽管这减少了输入量，但这里也有一个重要的观点需要注意。lambda
    或 *闭包* 的类型是我们无法命名的，但 `auto` 会为我们推断出确切的类型。两个具有相同参数和相同返回类型的 lambda 实际上具有不同的类型。然而，两个
    lambda 都可以赋值给同一个 `std::function`。这对我们的目的很有用，但也有缺点。lambda 可以内联，避免函数调用的开销。如果我们把
    lambda 复制到 `std::function` 中，它就不再可以内联，所以调用它可能会更慢。将我们的 lambda 复制到 `std::function`
    也可能涉及动态内存分配。Scott Meyers 在他的书 *Effective Modern C++*（O’Reilly Media，2014）中的“项目5：优先使用auto而不是显式类型声明”中提供了全部细节，我们已经知道我们几乎总是应该使用
    `auto`。如果我们将 lambda 声明为 `auto`，我们可以避免开销，尽管它将在方法调用中复制到 `std::function`。实际上，我们可以将列表3.6中的函数签名更改为使用
    `auto`：'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We now have another reason to almost always use `auto`. We have lost the idea
    of the message generator being an invocable function, though. Once we know a bit
    about concepts, we can fix that. For the impatient, we can include the concepts
    header and say
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎总是使用 `auto` 的另一个原因。虽然我们已经失去了消息生成器是一个可调用函数的想法，但一旦我们对概念有所了解，我们就可以解决这个问题。对于急于求成的人来说，我们可以包含概念头文件，并说
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: to get helpful compiler errors if we pass something that is not able to be invoked
    with two integers. We will see more concepts in the next chapter. For the patient,
    there is a proposal to introduce an `std::function_ref` as an alternative to `std::function`,
    overcoming the performance problems ([http://mng.bz/wjgg](http://mng.bz/wjgg)).
    C++ is continuing to evolve to make our lives easier. However we make our messages,
    we now get clues when we try to guess the number (figure 3.6).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得如果传递无法用两个整数调用的东西时的有用编译器错误。我们将在下一章中看到更多概念。对于有耐心的人，有一个提议要引入 `std::function_ref`
    作为 `std::function` 的替代方案，以克服性能问题 ([http://mng.bz/wjgg](http://mng.bz/wjgg))。C++
    正在继续发展，使我们的生活变得更简单。然而，我们如何制作消息，现在当我们尝试猜测数字时（图3.6）我们会得到线索。
- en: '![CH03_F06_Buontempo](../Images/CH03_F06_Buontempo.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F06_Buontempo](../Images/CH03_F06_Buontempo.png)'
- en: Figure 3.6 The game now gives clues and allows the player to give up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 游戏现在提供线索并允许玩家放弃。
- en: We now have a functioning, if somewhat boring, number-guessing game. We can
    improve on that by picking a random number to guess.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能正常、但有些无聊的猜数字游戏。我们可以通过选择一个随机数来猜测来改进它。
- en: 3.2 Guessing a random number
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 猜测一个随机数
- en: C++11 introduced a random number library. It takes a bit more effort to use
    than C’s `rand` function but provides lots of different ways to generate random
    numbers with various useful properties. This section will show how to get a random
    number from one of the many distributions. We need to pick a seed and choose an
    engine, as well as decide which distribution to use. We will look at the distributions
    in more detail in chapter 6\. This section sets the groundwork.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 引入了一个随机数库。与 C 的 `rand` 函数相比，使用它需要更多一些努力，但它提供了许多不同的方式来生成具有各种有用特性的随机数。本节将展示如何从众多分布中获取一个随机数。我们需要选择一个种子，选择一个引擎，并决定使用哪种分布。我们将在第
    6 章中更详细地研究分布。本节为这些内容奠定了基础。
- en: 3.2.1 Setting up a random number generator
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 设置随机数生成器
- en: For our guessing game, we want a random integer. Picking the random number from
    an interval would be nice, and any number should be equally likely, so we will
    use the *uniform* integer distribution, called `uniform_int_distribution`. This
    distribution is suitable for simulating dice rolling, which needs a number between
    one and six for each roll without bias toward any outcome. It is useful for any
    situation requiring equally likely whole numbers, such as picking a number for
    us to guess in our game.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的猜数字游戏，我们想要一个随机整数。从区间中选取随机数会很方便，并且任何数字都应该有相同的可能性，因此我们将使用 *均匀* 整数分布，称为 `uniform_int_distribution`。这种分布适合模拟掷骰子，每次掷骰子需要一个介于
    1 和 6 之间的数字，且不偏向任何结果。它在需要等可能整数的任何情况下都很有用，例如在我们的游戏中选择一个数字让我们猜测。
- en: 'Each distribution is a template taking a type of number to generate. The `uniform_int_distribution`
    is constrained to whole number types. There is a similar `uniform_real_distribution`
    for floats or doubles. We will use an integer and request numbers between `1`
    and `100` inclusive:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分布都是一个模板，用于生成特定类型的数字。`uniform_int_distribution` 限制为整数类型。还有一个类似的 `uniform_real_distribution`
    用于浮点数或双精度浮点数。我们将使用整数并请求介于 `1` 和 `100`（包括）之间的数字：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The C `rand` function does not support intervals, which we often want with random
    numbers. For example, a dice roll needs a number between 1 and 6, or picking a
    card from a deck needs a number between 1 and 52\. C++ helps us out here, allowing
    us to be explicit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C 的 `rand` 函数不支持区间，而我们通常希望使用随机数。例如，掷骰子需要一个介于 1 和 6 之间的数字，或者从一副牌中抽牌需要一个介于 1 和
    52 之间的数字。C++在这里帮了我们，允许我们明确指定。
- en: To provide numbers, the distribution needs an engine or generator. The engine
    provides random numbers. Yes, to generate random numbers, the distribution needs
    to be provided with random numbers. The distribution uses probability functions
    to ensure the numbers are uniform or follow whichever distribution is requested.
    For a uniform number in a range, the distribution squashes or transforms the numbers
    the engine provides to the requested interval. If we used C’s `rand` instead,
    we would have to squash the numbers to the interval ourselves.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供数字，分布需要一个引擎或生成器。引擎提供随机数。是的，为了生成随机数，分布需要提供随机数。分布使用概率函数来确保数字是均匀的或遵循请求的任何分布。对于范围内的均匀数，分布会将引擎提供的数字压缩或转换到请求的区间。如果我们使用
    C 的 `rand`，我们就必须自己将数字压缩到区间。
- en: We cannot generate a genuinely random number from a function because a function
    returning a different value every time it is called would usually be regarded
    as a bug. So how can a random number engine work? What we can do is generate a
    *pseudo-random number* by writing a function that starts with a seed and does
    some arithmetic to generate a new number, while remembering that new number for
    the next call. Eventually, the numbers will start repeating if the number matches
    the original seed. Many pseudo-random number generators use a polynomial function
    combined with some modulo arithmetic. We could write a generator ourselves.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能从函数中生成真正的随机数，因为每次调用返回不同值的函数通常会被视为一个错误。那么随机数引擎是如何工作的呢？我们可以通过编写一个以种子开始并执行一些算术以生成新数字的函数来生成
    *伪随机数*，同时记住这个新数字以便下一次调用。最终，如果数字与原始种子匹配，数字将开始重复。许多伪随机数生成器使用多项式函数结合一些模运算。我们自己可以编写一个生成器。
- en: Listing 3.8 A terrible random number generator
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 一个糟糕的随机数生成器
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Static storage holding the number for the next call
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 静态存储，用于保存下一次调用的数字
- en: ❷ Makes a new value from the last value
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从最后一个值生成新值
- en: This is a terrible random number generator because it will only return `0` or
    `1`, and these values alternate. We either get `0,` `1,` `0,` `1, ...` or `1,`
    `0,` `1,` `0,` `...` depending on the seed. As it repeats every two numbers, it
    has a *period* of two. Fortunately, C++ provides several engines that do a much
    better job, including the tersely named `mt19937` engine. The `mt` stands for
    Mersenne Twister. These generators use prime numbers that are one less than a
    power of two, called Mersenne primes, in their modulus part and have a much better
    calculation step than our increment, `++x`. This engine provides a period of 2^(19937)
    - 1\. We could also use the `std::default_random_engine`, which may well be the
    `mt19937` engine.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个糟糕的随机数生成器，因为它只会返回 `0` 或 `1`，这些值交替出现。我们可能会得到 `0,` `1,` `0,` `1, ...` 或 `1,`
    `0,` `1,` `0,` ... 取决于种子。由于它每两个数字重复一次，它有一个 *周期* 为两个。幸运的是，C++ 提供了几个做得更好的引擎，包括简短命名的
    `mt19937` 引擎。`mt` 代表 Mersenne Twister。这些生成器在它们的模数部分使用 Mersenne 基数，这些基数是 2 的幂次方减一，并且它们的计算步骤比我们的增量
    `++x` 要好得多。这个引擎提供了一个 2^(19937) - 1 的周期。我们也可以使用 `std::default_random_engine`，这可能是
    `mt19937` 引擎。
- en: There are various ways to seed the random number engine. If we stick with a
    specific number, we will get the same sequence of random numbers for each run.
    The ability to regenerate a sequence of pseudo-random numbers by supplying the
    same seed is useful for simulations and for testing, as the outcomes are then
    identical for each run. We could use the current time to get different numbers
    on each run, but we haven’t learned about time in C++ yet. We will do that in
    the next chapter. The `random` header provides a `random_device`, which is itself
    a random number generator, producing *non-deterministic* random numbers. CppReference
    points out that it may generate the same number sequence every time it is called
    ([http://mng.bz/84RZ](http://mng.bz/84RZ)). Some older implementations always
    returned `0`, so it is worth checking whether you get a different number if you
    call it a few times running. The random device might be using the state of your
    hard drive, or similar physical component, to generate a number. CppReference
    also warns us that even though it generates random numbers, it is designed to
    generate a seed because calling it repeatedly may start generating the same numbers
    over and over.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式来设置随机数引擎的种子。如果我们坚持使用特定的数字，那么每次运行都会得到相同的随机数序列。通过提供相同的种子来重新生成伪随机数序列的能力对于模拟和测试很有用，因为每次运行的结果都是相同的。我们可以使用当前时间来在每次运行中获得不同的数字，但我们还没有学习
    C++ 中的时间。我们将在下一章中学习。`random` 头文件提供了一个 `random_device`，它本身就是一个随机数生成器，产生 *非确定性*
    随机数。CppReference 指出，它每次被调用时可能会生成相同的数字序列（[http://mng.bz/84RZ](http://mng.bz/84RZ)）。一些较旧的实现总是返回
    `0`，所以如果你多次调用它，检查你是否得到了不同的数字是值得的。随机设备可能会使用你的硬盘状态或类似的物理组件来生成数字。CppReference 也警告我们，尽管它生成随机数，但它被设计为生成种子，因为重复调用它可能会反复生成相同的数字。
- en: 'After including the `random` header, we use the random device to seed our random
    number generator:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含 `random` 头文件后，我们使用随机设备来为我们的随机数生成器设置种子：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This gives us the engine or generator we need to use a distribution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了所需的引擎或生成器，以便使用分布。
- en: 3.2.2 Using the random number generator
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 使用随机数生成器
- en: Armed with a seed and engine, we can now draw a single number from the distribution.
    We do this by calling the distribution’s `operator()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有种子和引擎后，我们现在可以从分布中抽取一个数字。我们通过调用分布的 `operator()` 来完成此操作。
- en: Listing 3.9 Generating a single random number
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 生成单个随机数
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ A device to get a random number
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取随机数的设备
- en: ❷ An engine seeded with the device
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用设备种子引擎
- en: ❸ A distribution to pick a number
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择数字的分布
- en: ❹ Our actual random number
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们实际的随机数
- en: That is quite a bit of code to generate one number, but we need a seed, an engine,
    and a distribution before we can request a random number. We cannot get away with
    less code here. We will use random numbers in future chapters too, so we will
    get more practice. Now, if we want several random numbers, we could make a class
    and set up the seed and distribution in a constructor, calling `dist(engine)`
    from a member function each time we need a new number. We will create a class
    in chapter 5 and only need one number here, so the function suits our needs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个数字需要相当多的代码，但在我们能够请求一个随机数之前，我们需要一个种子、一个引擎和一个分布。在这里我们不能用更少的代码来解决问题。在未来的章节中我们也会使用随机数，所以我们将得到更多的实践机会。现在，如果我们想要几个随机数，我们可以在构造函数中创建一个类，并设置种子和分布，每次我们需要一个新的数字时，从成员函数中调用`dist(engine)`。我们将在第5章创建一个类，这里只需要一个数字，所以这个函数符合我们的需求。
- en: Notice that C++ has given us more control than the C function. The engine can
    be switched out to another that repeats less often, although the `mt19937` is
    fine here because we only need one number. We have also specified the range the
    random number should come from. The first three lines are set up, which we only
    have to do once. If we wanted another random number, we would call `dist(engine)`
    again without the setup. If we called this several times and recorded the results,
    we would see the numbers for 0 to 100 generated in approximately equal or uniform
    proportions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到C++给了我们比C函数更多的控制。我们可以将引擎切换为另一个重复频率较低的引擎，尽管`mt19937`在这里是合适的，因为我们只需要一个数字。我们还指定了随机数应该来自的范围。前三行是设置，我们只需要做一次。如果我们想要另一个随机数，我们再次调用`dist(engine)`而不需要设置。如果我们多次调用这个函数并记录结果，我们会看到0到100之间的数字以大约相等或均匀的比例生成。
- en: We can now make our game slightly more challenging by calling the new function
    instead of `some_const_number` in `main` function, leaving everything else the
    same.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在`main`函数中调用新函数而不是`some_const_number`来使我们的游戏稍微更具挑战性，同时保持其他一切不变。
- en: Listing 3.10 A random number guessing game
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 一个随机数猜测游戏
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Possibly not 42 for a change
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 可能这次不是42
- en: We could change the message to give different clues (e.g., whether the number
    is odd or even, or we could keep track of guesses to remind the user if they have
    already tried a number). We will not do that here, but we can see how passing
    in the message keeps the code relatively flexible. What we will do is generate
    a prime number to guess. We will therefore learn how to generate a random number
    with a required property, in this case, a prime number, and will provide clues
    if the number is wrong.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改消息以提供不同的线索（例如，数字是奇数还是偶数，或者我们可以跟踪猜测次数，以提醒用户他们是否已经尝试了一个数字）。我们在这里不会这样做，但我们可以看到传递消息如何使代码相对灵活。我们将要做的是生成一个素数来猜测。因此，我们将学习如何生成具有所需属性的随机数，在这种情况下，是一个素数，并且如果数字错误，我们将提供线索。
- en: 3.3 Guessing a prime number
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 猜测一个素数
- en: For more practice with random numbers, we will generate a prime number to guess.
    If the player gets it wrong, we will say which digits are correct. That will give
    us a bit more practice with the lambdas for our messages too.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更多地练习随机数，我们将生成一个素数来猜测。如果玩家猜错了，我们将说明哪些数字是正确的。这将给我们更多的机会练习我们的消息lambda。
- en: 3.3.1 Checking whether the number is prime
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 检查数字是否为素数
- en: We need to adapt our function generating the number to guess if we want a prime
    number. Instead of returning `dist(engine)` immediately like we did in listing
    3.9, we can first check if the number is prime. If so, we return it; otherwise,
    we try another random number until we get something suitable. How do we check
    if a number is prime?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整生成数字的函数，以便猜测我们是否想要一个素数。我们不能再像在3.9列表中那样立即返回`dist(engine)`，而是首先检查这个数字是否是素数。如果是，我们就返回它；否则，我们尝试另一个随机数，直到我们得到一个合适的数字。我们如何检查一个数字是否是素数？
- en: Prime numbers have two factors. One only has one factor, so we can special case
    this and return false. 2 is 1 × 2 (or 2 × 1), so it has precisely two factors.
    This is the first prime. 3 is the next prime, so we can return true immediately
    for either of these numbers. Any multiples of 2 or 3 after that are not prime.
    For example, 6 is divisible by 2 and 3 and is also divisible by 1 and 6\. We can
    therefore check for these using `operator%`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 素数有两个因子。只有一个因子，所以我们可以特别处理这种情况并返回false。2是1×2（或2×1），所以它恰好有两个因子。这是第一个素数。3是下一个素数，所以我们可以立即为这两个数字返回true。之后的任何2或3的倍数都不是素数。例如，6可以被2和3整除，也可以被1和6整除。因此，我们可以使用`operator%`来检查这些。
- en: The number 4 gets caught in the check for multiples of 2\. We therefore only
    need to check if the number is a multiple of any number from 5 upwards since we
    covered 2, 3, and 4\. We could keep track of the primes we find, rather than only
    considering multiples of 2 or 3, and build what is known as the sieve of Eratosthenes.
    This would be more efficient, but it means we would need to keep track of the
    primes. We can stop checking at the square root of our number to save a bit of
    time. There is no point in checking beyond that. For example, the number 35 is
    5 × 7\. Starting to check from 5, we immediately find a factor, so we can say
    35 is not prime. We found this before the square root of 35, something slightly
    less than 6\. Having found the first factor, we do not need to check the 7 because
    we found the 5 already and returned. If a factor is larger than the square root,
    there will always be another factor smaller than the square root, which we will
    find first. We pull our checks for factors together into a function as follows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数字4在检查2的倍数时被捕获。因此，我们只需要检查这个数是否是5以上的任何数的倍数，因为我们已经涵盖了2、3和4。我们可以跟踪我们找到的素数，而不仅仅是考虑2或3的倍数，并构建所谓的埃拉托斯特尼筛法。这将更有效率，但这意味着我们需要跟踪素数。我们可以检查到我们的数字的平方根来节省一点时间。检查超过这个范围是没有意义的。例如，数字35是5乘以7。从5开始检查，我们立即找到一个因子，所以我们可以说35不是素数。我们在35的平方根之前就找到了这个因子，略小于6。找到第一个因子后，我们不需要检查7，因为我们已经找到了5并返回了。如果一个因子大于平方根，那么总会有一个小于平方根的因子，我们首先会找到它。我们将对因子的检查组合到一个函数中，如下所示。
- en: Listing 3.11 Function to check whether a number is prime
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 检查一个数是否为素数的函数
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ 2 and 3 are prime.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 2和3是素数。
- en: ❷ 1 and any multiple of 2 or 3 are not prime.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 1和任何2或3的倍数都不是素数。
- en: ❸ Checks if 5 upwards is a factor
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查5及以上是否是因子
- en: ❹ We found a factor, so the number is not prime.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们找到了一个因子，所以这个数不是素数。
- en: ❺ If we get here, we have a prime.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果我们到达这里，我们有一个素数。
- en: We could make other optimizations to make the function faster, but this is quick
    enough for our game. We have a way to check if a number is prime, but before we
    use it, we will add some tests for this function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对函数进行其他优化以使其更快，但对于我们的游戏来说这已经足够快了。我们有一种方法来检查一个数是否为素数，但在使用它之前，我们将为这个函数添加一些测试。
- en: 3.3.2 Checking properties with static_assert
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 使用`static_assert`检查属性
- en: 'We will add a function to test whether our `is_prime` function works. We can
    hard-code a few numbers for the test. This means we are not using any runtime
    input, so we can run our checks at compile time. We indicate that by adding the
    keyword `constexpr`, short for constant expression, at the start of our function
    signature:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个函数来测试我们的`is_prime`函数是否工作。我们可以为测试硬编码一些数字。这意味着我们不是使用任何运行时输入，因此我们可以在编译时运行我们的检查。我们通过在函数签名开头添加关键字`constexpr`（常量表达式）来表示这一点：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Saying a function or variable is a `constexpr` means it can be evaluated at
    compile time, in theory. It might not be. A `constexpr` variable is `const`, meaning
    we can’t change its value. For a `constexpr` function, the arguments have to be
    constant expressions too. If they don’t get set until runtime, for example, via
    user input, evaluation cannot happen at compile time. So `constexpr` indicates
    that a value, or return value, is both constant and computed at compile time,
    when possible. Using `constexpr` can therefore allow us to evaluate variables
    or functions at compile time. Let’s see how.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 说到一个函数或变量是`constexpr`，意味着它可以在编译时进行评估，从理论上讲。但这可能并不总是如此。一个`constexpr`变量是`const`的，这意味着我们无法改变它的值。对于一个`constexpr`函数，其参数也必须是常量表达式。例如，如果它们直到运行时才被设置，比如通过用户输入，那么评估就不能在编译时发生。因此，`constexpr`表示一个值，或返回值，在可能的情况下既是常量又在编译时计算。因此，使用`constexpr`可以让我们在编译时评估变量或函数。让我们看看如何做。
- en: 'We can still call our function at runtime, but we can now check the code at
    compile time too. Instead of using C’s `assert` function like we did in the last
    chapter, we can use `static_assert` in a test function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以在运行时调用我们的函数，但现在我们也可以在编译时检查代码。与我们在上一章中使用C的`assert`函数不同，我们可以在测试函数中使用`static_assert`：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `static_assert` can be used in other places too, such as a namespace (see
    [http://mng.bz/E97o](http://mng.bz/E97o)), but making a function for our tests
    makes them easy to find. The `static_assert` needs a constant expression, such
    as our `constexpr` function, and generates a compiler error if the expression
    is false. We can add a call to the `check_properties` function at the start of
    the `main` function, and our single assertion passes at compile time, leaving
    nothing to do at runtime. If we use a non-prime number, such as 4, instead of
    2, we get a compile error:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_assert`也可以用在其他地方，例如在命名空间中（见[http://mng.bz/E97o](http://mng.bz/E97o)），但为我们的测试创建一个函数可以使它们更容易找到。`static_assert`需要一个常量表达式，例如我们的`constexpr`函数，如果表达式为假，则生成编译器错误。我们可以在`main`函数的开始处添加对`check_properties`函数的调用，并且我们的单个断言在编译时通过，运行时不需要做任何事情。如果我们用非素数，如4，而不是2，我们会得到一个编译错误：'
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finding and catching errors early is always a good thing. Furthermore, evaluation
    at compile time can speed up runtime. Both `static_assert` and `constexpr` were
    introduced back in C++11\. The latter was made more flexible over time, allowing
    local variables and loops. Prior to that, we needed to use recursion. C++20 then
    introduced the specifiers `consteval` and `constinit`. `consteval` is applied
    to functions to ensure they are being evaluated at compile time, whereas a `constexpr`
    may or may not be evaluated at compile time. `constinit` is applied to variables,
    ensuring initialization at compile time. A `consteval` function is also called
    an *immediate function*, and we get a compile error if it cannot be evaluated
    at compile time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 早期发现和捕获错误始终是一件好事。此外，编译时的评估可以加快运行时。`static_assert`和`constexpr`都是在C++11中引入的。后者随着时间的推移变得更加灵活，允许局部变量和循环。在那之前，我们需要使用递归。C++20随后引入了`consteval`和`constinit`指定符。`consteval`应用于函数，以确保它们在编译时被评估，而`constexpr`可能或可能不在编译时评估。`constinit`应用于变量，确保在编译时初始化。`consteval`函数也被称为*即时函数*，如果它不能在编译时评估，我们会得到一个编译错误。
- en: 'We can also see variables declared as `constexpr`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到声明为`constexpr`的变量：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This makes the variables constant as well as calculated at compile time, so
    we cannot change them. Trying to do so by saying `x` `=` `43` results in a compile
    error. Compile time evaluation is a powerful tool. The important point for now
    is that `constexpr` function can run at compile time or runtime.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得变量在编译时既是常量也是计算的，所以我们不能改变它们。如果我们说`x` `=` `43`来尝试这样做，结果会得到一个编译错误。编译时评估是一个强大的工具。现在的重要点是`constexpr`函数可以在编译时或运行时运行。
- en: Now that we know how to test if a number is prime, we can use the check to generate
    a prime number to guess in our game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何测试一个数是否为素数，我们可以使用这个检查来生成一个素数来猜测我们的游戏。
- en: 3.3.3 Generating a random prime number
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 生成随机素数
- en: We saw how to generate a random number in listing 3.9\. We used `random_device`
    to seed an engine and a distribution to pick a random number from a range. There
    aren’t so many prime numbers between 1 and 100, so we will increase the range
    to 99,999, giving us more possible prime numbers and up to five digits. Instead
    of returning the first number generated, we need to check to see if it fulfills
    our requirements. We use our `is_prime` function and keep trying until we get
    a suitable number in an empty `while` loop. Let’s use `{}` to initialize everything
    to remind ourselves about uniform initialization.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表3.9中看到了如何生成随机数。我们使用`random_device`来初始化一个引擎和一个分布来从范围内选择一个随机数。在1到100之间，素数并不多，所以我们将范围增加到99,999，给我们更多的可能素数，最多有五位数。我们不需要返回生成的第一个数，我们需要检查它是否满足我们的要求。我们使用我们的`is_prime`函数，并在一个空的`while`循环中不断尝试，直到我们得到一个合适的数。让我们使用`{}`来初始化一切，以提醒自己关于统一初始化。
- en: Listing 3.12 Generating a prime number
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 生成素数
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Uses a larger interval
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用更大的区间
- en: ❷ Default initializes n, using {}
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用{}默认初始化n。
- en: ❸ Keeps on until we get a prime
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 继续直到我们得到一个素数
- en: Filtering out random numbers that do not fulfill a criterion is known as *rejection
    sampling*. It’s a simple way to generate random numbers that fulfill a property.
    Many of the distributions provide random numbers with properties required for
    simulations and games, but when the distribution is hard to encode mathematically,
    rejection sampling works well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤掉不符合标准的随机数被称为*拒绝抽样*。这是一种生成满足特定属性的随机数的方法。许多分布提供了用于模拟和游戏的随机数，但当一个分布难以用数学公式表示时，拒绝抽样效果很好。
- en: 'We can now amend our guessing game, using a randomly generated prime number,
    and adapting the call to the guessing game in listing 3.10 appropriately:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改我们的猜测游戏，使用随机生成的素数，并适当地调整列表3.10中的猜测游戏调用：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is all very well, but we can generate better clues. We could report if
    any of the digits are correct with a bit of thought. There are only 10 digits,
    so we could make two guesses with different digits. If a new clue tells us which
    are in the number, we know which digits to use. We may get them in the wrong place,
    and some may repeat, but it should be much easier to guess the number.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们可以生成更好的提示。我们可以通过一点思考来报告是否有任何数字是正确的。只有10个数字，所以我们可以用不同的数字做两次猜测。如果一个新的提示告诉我们哪些数字在数字中，我们就知道要使用哪些数字。我们可能会把它们放在错误的位置，而且可能会有重复，但应该更容易猜出数字。
- en: 3.3.4 Deciding which digits are correct
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 决定哪些数字是正确的
- en: We will use the character `^` to indicate a digit in the wrong place, `*` for
    a digit in the right place, and a dot for a digit that isn’t present. If the number
    is 12347 and we guessed 23471, we have guessed all the digits, but they are in
    the wrong place. We would indicate this by displaying "`^^^^^`". If the number
    is 78737 and we guess 87739, we would display "^^**". Displaying this under the
    guess would give
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字符`^`来表示位置错误的数字，`*`表示位置正确的数字，点表示不存在的数字。如果数字是12347，而我们猜测的是23471，我们猜对了所有数字，但它们的位置是错误的。我们会通过显示"`^^^^^`"来表示这一点。如果数字是78737，而我们猜测的是87739，我们会显示"^^**"。在猜测下方显示这将给出
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The second 7 and the 3 are in the right place, so they get an `*`. The 7 and
    8 at the start are in the wrong place, so each gets a ^. The final digit, 9, is
    wrong, so it gets a dot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个7和第三个3在正确的位置，所以它们得到一个`*`。开头的7和8位置错误，所以每个都得到一个`^`。最后一个数字，9，是错误的，所以它得到一个点。
- en: 'To create the clue, we need a function taking the number and the guess and
    returning a string. If we convert the numbers to a string, we can check the digits
    one at a time. There are various ways to do this, and we will use `format`. We
    want to add leading zeros, so the number itself and the guess are both five digits
    long. We used the format specifier `"{: ^6}"` in the last chapter to pad a number
    with spaces ensuring it was six characters long. The `^` means center-justified.
    This time, we want right-justified, so use `>,` and we want 0 instead of space,
    giving us `"{:0>5}"`. If we set up a string filled with five dots, `std::string
    matches(5,` `''.'')`, and put stars where the digits are correct, we are partway
    there.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '要创建提示，我们需要一个函数，该函数接受数字和猜测值，并返回一个字符串。如果我们将数字转换为字符串，我们可以逐个检查数字。有各种方法可以做到这一点，我们将使用`format`。我们想要添加前导零，所以数字和猜测值都是五位数长。我们在上一章中使用了格式说明符`"{:
    ^6}"`来用空格填充数字，确保它有六个字符长。`^`表示居中对齐。这次，我们想要右对齐，所以使用`>,`，我们想要0而不是空格，给出`"{:0>5}"`。如果我们设置一个由五个点组成的字符串，`std::string
    matches(5, ''.'')`，并在正确的数字位置放置星号，我们就走了一半的路。'
- en: Listing 3.13 Start of a function indicating which digits are correct
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 函数开始指示哪些数字是正确的
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Converts numbers to strings
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数字转换为字符串
- en: ❷ Starts with five dots
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 以五个点开始
- en: ❸ Indicates correct digits with a star
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用星号表示正确的数字
- en: 'Now we need to find whether there are any digits in the wrong place. If the
    number is 78737 and we guess 87739, we have two 7s. One is correct, so it got
    an `*`, and the other is wrong. If we change the middle 7 in the number to an
    `*`, we won’t use it in our check for misplaced digits. We can do that in the
    first loop; then we find digits that are in the wrong place in a second loop,
    indicating this with a `^`. Once we have counted a digit as misplaced, we will
    change that to a `^` as well, so we don’t report two misplaced digits when only
    one is in the number. For example, if the number is 12347 and the guess is 11779,
    both 7s are wrong, but we want to indicate we have one misplaced 7, rather than
    two:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找出是否有任何数字位置错误。如果数字是78737，而我们猜测的是87739，我们有两个7。一个是正确的，所以它得到了一个`*`，另一个是错误的。如果我们把数字中间的7改为`*`，我们不会在检查位置错误的数字时使用它。我们可以在第一个循环中做到这一点；然后我们通过第二个循环找到位置错误的数字，用`^`来表示这一点。一旦我们计算出一个数字是位置错误的，我们将它也改为`^`，这样我们就不报告只有一个数字在数字中时有两个位置错误的数字。例如，如果数字是12347，猜测是11779，两个7都是错误的，但我们要表示我们有一个位置错误的7，而不是两个：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If both 7s were to get the `^`, indicating they are misplaced, that suggests
    the number contains two 7s. Our feedback makes it clear there is only one 7 in
    the number.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个7都得到`^`，表示它们位置错误，这表明数字中包含两个7。我们的反馈清楚地表明数字中只有一个7。
- en: 'An `std::string` has a find method, which returns `npos` if there is no position
    matching. Some compilers also now support a `contains` function, which is more
    succinct, but we need the position if the digit is found to avoid using it again,
    so we need to use `find`. The `find` function takes a character to find and a
    starting position and returns an index. Because we want to search from the start,
    we need to use starting position `0`. If we get `npos` back, this means the character
    isn’t there. We can do this in one `if` statement, using the `if` statements with
    initializer:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`有一个`find`方法，如果没有找到匹配的位置，则返回`npos`。一些编译器现在也支持`contains`函数，它更简洁，但我们需要找到数字的位置以避免再次使用它，所以我们需要使用`find`。`find`函数接受要查找的字符和一个起始位置，并返回一个索引。因为我们想从开始搜索，所以我们需要使用起始位置`0`。如果我们得到`npos`，这意味着字符不在那里。我们可以使用具有初始化器的`if`语句在一个`if`语句中完成这个操作：'
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This was introduced in C++17\. It looks like a normal `if`, but has an initialization
    followed by a semi-colon and then a condition: `if` `(init;` `condition)`. Without
    this, we would have to find the index and then check the value in separate statements.
    Either way is fine, but `if` statements with an initializer can keep code tighter,
    particularly by keeping the scope of the variable smaller because the variable
    is only in scope inside the `if` block. Adding the check for misplaced digits
    to the previous listing gives us the following.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在C++17中引入的。它看起来像是一个普通的`if`语句，但有一个初始化语句，后面跟着一个分号，然后是一个条件：`if` `(init;` `condition)`。如果没有这个，我们就必须找到索引，然后检查单独语句中的值。两种方式都行，但具有初始化器的`if`语句可以使代码更紧凑，尤其是通过保持变量的作用域更小，因为变量仅在`if`块内部有效。将查找放置错误的数字的检查添加到前面的列表中，我们得到以下内容。
- en: Listing 3.14 Showing misplaced digits
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 显示放置错误的数字
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Don’t double count this digit.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不要重复计算这个数字。
- en: ❷ Now checks guesses that don’t match
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 现在检查不匹配的猜测
- en: ❸ Looks for the guess character
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查找猜测字符
- en: ❹ Don’t reuse this digit either.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 也不要重复使用这个数字。
- en: ❺ idx has now gone out of scope.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ `idx`现在已经超出作用域。
- en: 'We can and should add tests to our properties function. For example, after
    including the `cassert` header, we can add a check:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以也应该为属性函数添加测试。例如，在包含`cassert`头文件后，我们可以添加一个检查：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The code provided with this book has several tests in the properties function,
    covering repeated and missing digits, omitted here for brevity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码在属性函数中包含几个测试，涵盖了重复和缺失的数字，这里为了简洁省略。
- en: We can now use our function to create a clue in the guessing game and call our
    properties test from `main`. While we are making that change, we will return the
    number formatted to five digits. This way, shorter numbers get leading zeros,
    so the `^` looks like it is pointing at any misplaced digits. For example, if
    the number is 17231 and we guess 1723, we would see
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的函数在猜测游戏中创建线索，并从`main`中调用属性测试。当我们进行这个更改时，我们将返回格式化为五位数的数字。这样，较短的数字会有前导零，所以`^`看起来像是在指向任何放置错误的数字。例如，如果数字是17231，而我们猜测1723，我们会看到
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This isn’t required, but it will remind a player they can use a zero. The following
    listing shows what we have when we put things together.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是必需的，但它会提醒玩家他们可以使用零。以下列表显示了我们将事物组合在一起时的结果。
- en: Listing 3.15 A much better number-guessing game
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.15 一个更好的数字猜测游戏
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Displays clues
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示线索
- en: ❷ Shows the correct number as five digits
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 以五位数字显示正确的数字
- en: ❸ Calls the tests
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用测试
- en: ❹ Messages saying which digits are correct
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 显示哪些数字是正确的信息
- en: ❺ Plays the game
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 玩游戏
- en: If we play the game, we can start with two prime numbers with different digits
    to narrow down possible numbers. 12347 and 56809 cover all the digits, so they
    are good starting guesses (figure 3.7).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们玩游戏，我们可以从两个具有不同数字的质数开始，以缩小可能的数字范围。12347和56809涵盖了所有数字，所以它们是好的起始猜测（图3.7）。
- en: '![CH03_F07_Buontempo](../Images/CH03_F07_Buontempo.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F07_Buontempo](../Images/CH03_F07_Buontempo.png)'
- en: Figure 3.7 Start with two prime numbers with different digits to narrow down
    possible numbers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 从两个具有不同数字的质数开始，以缩小可能的数字范围。
- en: 3.3.5 Providing different clues using std::function
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 使用std::function提供不同的线索
- en: Now, 90113, guessed in figure 3.7, is not a prime number. We can add this check
    to our message easily enough.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，90113，如图3.7所示，不是一个质数。我们可以轻松地将这个检查添加到我们的信息中。
- en: Listing 3.16 A longer message
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.16 一条较长的信息
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Is the guess prime?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 猜测的数是质数吗？
- en: ❷ Which digits are correct?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 哪些数字是正确的？
- en: We could extend this further, but adding lots of separate checks into the single
    lambda is a bad idea. Lambdas are good when we need a small function, but we should
    not let them get unwieldy. We need a different approach. We can add a check for
    the length as well because the number will not be more than five digits. We are
    therefore trying to check three things and return a message in each case. We can
    check the length and whether a number is prime with two separate lambdas, taking
    the guess and returning a string.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步扩展，但是将许多单独的检查添加到单个 lambda 中是一个坏主意。当我们需要一个小函数时，lambda 是好的，但我们不应该让它们变得难以控制。我们需要不同的方法。由于数字不会超过五位数，我们可以添加一个长度检查。因此，我们正在尝试检查三件事，并在每种情况下返回一条消息。我们可以使用两个单独的
    lambda 来检查长度和数字是否为质数，一个用于猜测并返回一个字符串。
- en: Listing 3.17 Check the length and whether the number is prime
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 检查长度以及数字是否为质数
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Listing 3.14 gave clues about which digits were correct, but it requires the
    number as well as the guess. We can use the closure aspect of lambdas to make
    an anonymous function taking a single integer if we capture the number to guess.
    We saw `[=]` and `[&]` for captures by value and by reference in section 2.3 when
    we first met lambdas. We can say `[number]` to mean capture the variable `number`
    by value since we don’t use the `=` sign when we capture a specific variable by
    value. We could use `[&number]` to mean capture `number` by reference. Either
    way, we have *enclosed* our function, taking two numbers with the number to guess
    to make a new function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 提供了有关哪些数字是正确的线索，但它需要数字以及猜测。如果我们捕获要猜测的数字，我们可以使用 lambda 的闭包特性来创建一个接受单个整数的匿名函数。我们在
    2.3 节首次遇到 lambda 时看到了 `[=]` 和 `[&]` 用于按值和按引用捕获。我们可以说 `[number]` 来表示按值捕获变量 `number`，因为我们捕获特定变量时没有使用
    `=` 符号。我们可以使用 `[&number]` 来表示按引用捕获 `number`。无论如何，我们都有 *封装* 了我们的函数，接受两个数字，包括要猜测的数字来创建一个新的函数。
- en: Listing 3.18 Capturing the number
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 捕获数字
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Captures the number by copy
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过复制捕获数字
- en: We now have three lambdas that take an integer and return a string. It would
    be nice to put them in a container, like a `vector`, so the game can walk through
    the clues and possibly add more checks. What type would the `vector` contain,
    though? We know that each lambda has a different type, but we can wrestle them
    into an `std::function` and put them in a container if we include the `functional`
    and `vector` headers. The guessing game can then check the clues and show the
    first one only. If we check whether the number is prime first, we can enforce
    that the guess is prime and avoid giving further clues until another guess is
    made. We therefore need a slight change to our guessing function to call the messages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个 lambda，它们接受一个整数并返回一个字符串。将它们放入容器中，如 `vector`，将很好，这样游戏可以遍历线索，并可能添加更多检查。但是，`vector`
    将包含什么类型呢？我们知道每个 lambda 都有不同的类型，但如果我们包含 `functional` 和 `vector` 头文件，我们可以将它们强制转换为
    `std::function` 并放入容器中。猜谜游戏可以检查线索并只显示第一个。如果我们首先检查数字是否为质数，我们可以强制猜测是质数，并在另一次猜测之前避免提供更多线索。因此，我们需要对我们的猜测函数进行轻微的修改，以调用消息。
- en: Listing 3.19 Using all the clues
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 使用所有线索
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Gets messages
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取消息
- en: ❷ Only displays first clue
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅显示第一个线索
- en: Now we can call our game after we call our test code in the `main` function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用我们的游戏，在 `main` 函数中调用我们的测试代码之后。
- en: Listing 3.20 Pulling it all together
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 整合所有内容
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Lines up checks and clues
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对齐检查和线索
- en: ❷ Plays the game
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 玩游戏
- en: Having a handful of prime numbers to start off with will make playing easier.
    Try 12347 and 56809, as they use all the digits. We are free to ignore any clues,
    so we can try to find out which five digits we need first.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些质数开始玩会更容易。尝试 12347 和 56809，因为它们使用了所有数字。我们可以自由地忽略任何线索，所以我们可以尝试找出我们首先需要哪些五个数字。
- en: Wrestling the lambda into an `std::function` is not ideal, as we saw in section
    3.1.3, because it can no longer be inlined. We will see another approach when
    we learn about parameter packs for templates in the final chapter. For now, we
    have learned about input and output, as well as strings, integers, and vectors.
    We can also generate random numbers. We will learn about handling time next and
    continue to build up our C++ knowledge.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将 lambda 强制转换为 `std::function` 并非理想选择，正如我们在 3.1.3 节中看到的，因为它不能再内联。当我们学习到最后一章的模板参数包时，我们将看到另一种方法。现在，我们已经了解了输入和输出，以及字符串、整数和向量。我们还可以生成随机数。我们将学习如何处理时间，并继续构建我们的
    C++ 知识。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Character input comes from `std::cin` and can be streamed into specific types,
    but we need to check for errors and clean up unused input.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符输入来自 `std::cin`，可以被流式传输到特定类型，但我们需要检查错误并清理未使用的输入。
- en: Use `std::getline` to get an entire line of text, including whitespace.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::getline` 来获取整行文本，包括空白字符。
- en: '`std::optional` can be used for a value that may be unset.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::optional` 可以用于可能未设置的值。'
- en: Both `std::cin` and `std::optional` have an `explicit operator bool`, allowing
    us to check for errors or missing values easily.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::cin` 和 `std::optional` 都有一个 `explicit operator bool`，这使得我们能够轻松地检查错误或缺失的值。'
- en: Look for common patterns in the language and libraries to inform your own code.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在语言和库中寻找常见模式，以指导自己的代码。
- en: Random numbers in C++ require both an engine and a distribution.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的随机数需要同时有一个引擎和一个分布。
- en: A random number engine can be seeded with `std::random_device`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用 `std::random_device` 来初始化随机数生成器。
- en: Rejection sampling is a quick way to select random numbers fulfilling properties
    if a suitable distribution is not available.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受采样是一种快速选择满足特定属性随机数的方法，如果不可用合适的分布。
- en: Some expressions can be calculated at compile time, so marking them with `constexpr`
    is a good idea.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些表达式可以在编译时计算，因此用 `constexpr` 标记它们是个好主意。
- en: Use `static_assert` to check expressions at compile time.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `static_assert` 在编译时检查表达式。
- en: A lambda can be stored in `std::function`, but this may make code larger and
    slower.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将 lambda 存储在 `std::function` 中，但这可能会使代码更大、更慢。
