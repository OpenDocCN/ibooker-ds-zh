- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Getting to production
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 达到生产
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Addressing concerns, risks, and problems when taking your data pipeline to production
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将数据处理管道迁移到生产时解决关注点、风险和问题
- en: Employing strategies for building a production-ready application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个生产就绪应用程序的策略
- en: Our data-wrangling journey together is coming to a close, although it’s at this
    stage where your real work is about to begin. Although it may seem that exploratory
    coding, development, and testing are a pile of work, you ain’t seen nothing yet.
    Building and testing your data pipeline are often only small parts of the project
    lifecycle.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们共同的数据处理之旅即将结束，尽管此时你的真正工作即将开始。虽然探索性编码、开发和测试可能看起来是一大堆工作，但你还没有看到最糟糕的。构建和测试你的数据处理管道通常只是项目生命周期中的小部分。
- en: 'An ugly truth of software development is that most developers will spend the
    majority of their time maintaining existing applications after they’ve entered
    production. Getting to production is a big deal: we need to deploy our application,
    monitor it, and understand its behavior.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的丑陋真相是，大多数开发者进入生产阶段后，将花费大部分时间维护现有应用程序。达到生产阶段是一个大事件：我们需要部署我们的应用程序，监控它，并理解其行为。
- en: We then need to update our app so that we can deploy bug fixes or upgrade its
    feature set. At the same time, we need a solid testing regime to ensure that it
    doesn’t explode in a smoldering mess. These are several of the things we must
    deal with after our application enters the production phase.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的应用程序，以便我们可以部署错误修复或升级其功能集。同时，我们需要一个坚实的测试制度来确保它不会变成一团糟。这些是我们应用程序进入生产阶段后必须处理的一些事情。
- en: This final chapter of *Data Wrangling with JavaScript* takes you on a whirlwind
    tour of production concerns and problems. We’ll learn the problems to anticipate,
    how to handle unanticipated problems, and various strategies for dealing with
    them. This chapter isn’t hands-on, and it’s also not exhaustive; it’s a taste
    of the issues you’ll face getting to production. This is such a huge topic, and
    we don’t have much time left, so please strap in!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这本《使用JavaScript进行数据处理》的最后一章将带你快速浏览生产关注点和问题。我们将学习预期的问题，如何处理意外问题，以及处理这些问题的各种策略。本章不是实战性的，也不是详尽的；它是对你达到生产阶段将面临的问题的一个预览。这是一个如此庞大的主题，而我们剩下的时间不多，所以请系好安全带！
- en: 14.1 Production concerns
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 生产关注点
- en: Are you ready to move your app to its production environment? This is where
    we need our app to deliver it to the intended audience. We might push our code
    to a hosted server or a virtual machine in the cloud. Wherever we host our application,
    we need to get it there and make it available to as many users as necessary. This
    is one aim of production deployment. Other aims are listed in [table 14.1](#table14.1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好将你的应用程序迁移到生产环境了吗？这是我们希望应用程序能够送达目标受众的地方。我们可能会将代码推送到托管服务器或云中的虚拟机。无论我们在哪里托管我们的应用程序，我们都需要将其放置在那里，并使其对尽可能多的用户可用。这是生产部署的一个目标。其他目标在[表14.1](#table14.1)中列出。
- en: Table 14.1 Production aims
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 生产目标
- en: '| **Aim** | **Description** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **目标** | **描述** |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Delivery | Deliver our software to the intended audience. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 交付 | 将我们的软件交付给目标受众。 |'
- en: '| Capacity | Serve as many users as needed. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 容量 | 为所需数量的用户提供服务。 |'
- en: '| Deployment | Update our software without failure or problems. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 部署 | 无故障或问题地更新我们的软件。 |'
- en: '| Recovery | Recover quickly from any failures that do occur. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 恢复 | 快速从发生的任何故障中恢复。 |'
- en: '| System longevity | Operate for its intended period of longevity. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 系统寿命 | 在其预期的寿命期内运行。 |'
- en: Through these aims, we face many risks. Chief among them is the risk that we’ll
    deploy bad code and our app will be broken. Other potential risks are listed in
    [table 14.2](#table14.2). Different projects will also have their own unique risks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些目标，我们面临着许多风险。其中最主要的风险是我们可能会部署有缺陷的代码，我们的应用程序会崩溃。其他潜在的风险在[表14.2](#table14.2)中列出。不同的项目也将有其独特的风险。
- en: What exactly are we risking here? Well, we risk our app failing to function
    as intended. Our app might break for whatever reason. It then can no longer handle
    its workload, it becomes unresponsive, or it causes us to make business decisions
    based on broken data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里究竟冒着什么风险？好吧，我们冒着应用程序无法按预期工作的风险。我们的应用程序可能因为任何原因而崩溃。然后它将无法处理其工作负载，变得无响应，或者导致我们基于错误的数据做出商业决策。
- en: Why is this important? Well, broken systems cost money because organizations
    stop working when systems go down. Also, when we act on bad or broken data, we
    make the wrong decisions for our business. Broken systems can also make for frustrated
    users and a loss in goodwill, although reputation loss is much harder to quantify.
    At the worst extreme, for example, with our early warning system from chapter
    12, people can come to harm as a result of system failure. We need to think about
    the damage that could result from a failure in our app. This will help us determine
    the amount of precaution to take when setting up our app for production use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么很重要呢？好吧，当系统出现故障时，组织会停止工作，因此损坏的系统会花费金钱。此外，当我们根据坏数据或损坏的数据采取行动时，我们会为我们的业务做出错误的决定。损坏的系统也可能导致用户沮丧和信誉损失，尽管信誉损失很难量化。在最坏的情况下，例如，根据第12章中的早期预警系统，人们可能会因为系统故障而受到伤害。我们需要考虑我们的应用程序故障可能造成的损害。这将帮助我们确定在为生产使用设置应用程序时需要采取多少预防措施。
- en: Table 14.2 Production risks
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.2 生产风险
- en: '| **Risk** | **Description** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **风险** | **描述** |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Broken code is deployed. | The system breaks on initial release or update.
    This probably highlights an inadequate testing regime. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 部署了损坏的代码。 | 系统在初始发布或更新时崩溃。这很可能表明测试制度不充分。 |'
- en: '| The demand or load is more than the app can handle. | Demand for the system
    exceeds the capacity of the system to respond effectively. The system either responds
    slowly or is broken due to being overwhelmed. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 需求或负载超过了应用程序的处理能力。 | 系统的需求超过了系统有效响应的能力。系统要么响应缓慢，要么因为过载而损坏。 |'
- en: '| Incoming data is corrupt or invalid. | Bad data coming in is something that
    should be expected, and our system should be resilient enough to deal with it.
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 进入的数据是损坏或无效的。 | 进入的坏数据是应该预料到的事情，我们的系统应该足够健壮，能够处理它。 |'
- en: '| Broken code is manifested by new input, use case, or changed conditions.
    | A bug can remain hidden in code for a significant time until something changes
    (input, the way the system is used, another code module) that causes the bug to
    manifest. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 损坏的代码通过新的输入、用例或变化条件表现出来。 | 一个错误可以在代码中隐藏很长时间，直到某些事情发生变化（输入、系统使用方式、另一个代码模块）导致错误表现出来。
    |'
- en: In this chapter we’ll address a series of production concerns. These are listed
    in [table 14.3](#table14.3). We’ll discuss each of these briefly throughout this
    chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一系列生产问题。这些问题列在[表14.3](#table14.3)中。我们将在本章中简要讨论这些问题。
- en: Table 14.3 Production concerns
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.3 生产问题
- en: '| **Concern** | **Description** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | **描述** |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Deployment | We must deploy our app to production in a way that’s safe, convenient,
    and easy to reverse should something go wrong. We need a deployment pipeline.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 部署 | 我们必须以安全、方便且易于回滚的方式将我们的应用程序部署到生产环境中，以防万一出现问题。我们需要一个部署管道。 |'
- en: '| Monitoring | How do we know the system is operational and functioning adequately?
    We need a monitoring system. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 监控 | 我们如何知道系统正在运行并且功能正常？我们需要一个监控系统。 |'
- en: '| Reliability | Our system must be operating effectively and reliably. It must
    be there when its users need it. We need techniques that ensure reliable functioning.
    The system should gracefully handle failures and bounce back into operation. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 可靠性 | 我们的系统必须有效且可靠地运行。当用户需要时，它必须在那里。我们需要确保可靠运行的技术。系统应该优雅地处理故障并重新进入运行状态。 |'
- en: '| Security | Our system should be as secure as it needs to be to prevent unwanted
    intrusion or snooping. We need security principles and mechanisms to protect our
    system. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 我们的系统应该足够安全，以防止未授权的入侵或窥探。我们需要安全原则和机制来保护我们的系统。 |'
- en: '| Scalability | How will our system handle large bursts of user activity? How
    will we scale our system to meet the user demand without it failing over? |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性 | 我们的系统将如何处理大量用户活动的突发情况？我们将如何扩展我们的系统以满足用户需求，而不会导致系统失败？ |'
- en: 14.2 Taking our early warning system to production
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 将我们的早期预警系统推向生产
- en: In chapter 12 we developed an early warning system for air pollution monitoring.
    Let’s now talk about bringing this project to production. We’ll need to deploy
    the application to a production environment; that’s an environment through which
    the app is delivered to its users.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12章中，我们为空气污染监测开发了一个早期预警系统。现在让我们谈谈将这个项目推向生产。我们需要将应用程序部署到生产环境中；这是一个应用程序通过它交付给用户的环境。
- en: What exactly are we delivering, and what issues do we face? We might have a
    dashboard that can be viewed by thousands of people. Can our system handle that
    many concurrent users? Does it respond to them in a timely fashion?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们究竟在交付什么，我们面临什么问题？我们可能有一个可以由数千人查看的仪表板。我们的系统能够处理这么多并发用户吗？它能否及时响应他们？
- en: We might have an automated report that’s sent to hundreds of users who need
    that information on a daily basis. Can it do that consistently without failing
    over? When our emergency warning system triggers and the SMS alert is sent to
    emergency responders, how do we ensure the system can do that without issue? These
    are the kinds of issues we must ponder when moving to production.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个自动生成的报告，发送给数百名需要每天获取这些信息的用户。它能否持续不断地执行而不会失败？当我们的紧急预警系统触发，并将短信警报发送给应急响应人员时，我们如何确保系统可以无问题地完成这项任务？这些是我们转移到生产时必须深思的问题。
- en: Getting to production requires an update to our workflow. The workflow shown
    in [figure 14.1](#figure14.1) is different to what you might remember from chapter
    1 of this book. It now shows that the end result of development is the production
    deployment of the application. That’s to say that the code for the app is eventually
    moved from development to its production environment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序投入生产需要更新我们的工作流程。图14.1中所示的工作流程与您可能从本书第一章中记住的不同。它现在显示，开发的最终结果是应用程序的生产部署。也就是说，应用程序的代码最终将从开发环境转移到其生产环境。
- en: '![c14_01.eps](Images/c14_01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![c14_01.eps](Images/c14_01.png)'
- en: '[Figure 14.1](#figureanchor14.1) Development workflow and when you should start
    thinking about production'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.1](#figureanchor14.1) 开发工作流程和何时开始考虑生产'
- en: '[Figure 14.1](#figure14.1) indicates that we need to start thinking about production
    way back in our planning stage. Thinking more about architecture and design, not
    to mention testing, early on in development can save us much pain later when we’ll
    inevitably run into issues relating to reliability, security, and performance.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.1](#figureanchor14.1) 表明，我们在规划阶段就需要开始考虑生产。在开发早期更多地考虑架构和设计，更不用说测试，可以让我们在遇到与可靠性、安全性和性能相关的问题时减少痛苦。'
- en: Our first problem is how to get our app into its production environment. [Figure
    14.2](#figure14.2) shows a common software development process called continuous
    delivery—an ongoing sequence of iterations—where each iteration is followed by
    production deployment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要解决的问题是如何将我们的应用程序部署到其生产环境。[图14.2](#figureanchor14.2) 展示了一个常见的软件开发过程，称为持续交付——一个持续的迭代序列——其中每个迭代之后都跟随生产部署。
- en: To implement continuous delivery, we’ll need a deployment pipeline.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现持续交付，我们需要一个部署管道。
- en: 14.3 Deployment
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 部署
- en: How we deploy our app to production depends on where we’re deploying it to because
    different environments will require different mechanisms. Generally, though, it’s
    common to have a scripted/automated deployment pipeline, an example of which is
    depicted in [figure 14.3](#figure14.3). Each phase in the pipeline (the boxes
    with dashed lines) is implemented by a build or deployment script, and gateways
    (the diamonds) between each phase that control entry (or not) to the next phase.
    The gateways might be automatic, or they might require manual activation, depending
    on what’s appropriate for your project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将应用程序部署到生产环境取决于我们部署的位置，因为不同的环境将需要不同的机制。不过，通常来说，有一个脚本/自动化部署管道是很常见的，图14.3中展示了这样一个例子。管道中的每个阶段（带有虚线的框）都由一个构建或部署脚本实现，以及在每个阶段之间的网关（菱形），这些网关控制着进入（或未进入）下一阶段。这些网关可能是自动的，也可能需要手动激活，具体取决于您项目的适当性。
- en: '![c14_03.eps](Images/c14_03.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![c14_03.eps](Images/c14_03.png)'
- en: '[Figure 14.3](#figureanchor14.3) A continuous delivery deployment pipeline'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.3](#figureanchor14.3) 持续交付部署管道'
- en: '![c14_02.eps](Images/c14_02.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![c14_02.eps](Images/c14_02.png)'
- en: '[Figure 14.2](#figureanchor14.2) Continuous delivery: Our app is frequently
    and routinely deployed to production.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.2](#figureanchor14.2) 持续交付：我们的应用程序经常且定期部署到生产环境。'
- en: We start on the left by committing a code change to our version control system.
    This triggers invocation of your continuous integration system, which automatically
    builds and tests your code. If the code builds and passes its tests, then we enter
    the production deployment phase.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从左侧开始，将代码更改提交到我们的版本控制系统。这触发了您的持续集成系统的调用，该系统会自动构建和测试您的代码。如果代码构建并通过测试，那么我们就进入生产部署阶段。
- en: We can write scripts for this phase to deploy our code to the production environment.
    If the deployment phase is successful, we enter the automated monitoring phase.
    In this phase, we might run a smoke test or health check followed by regular automated
    monitoring. Congratulations! Your app has made it through a production deployment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为此阶段编写脚本，将我们的代码部署到生产环境。如果部署阶段成功，我们就进入自动监控阶段。在这个阶段，我们可能会运行烟雾测试或健康检查，然后进行常规的自动监控。恭喜！你的应用已经通过了生产部署。
- en: It’s important to note that code deployments, the updates to your app, are often
    the biggest cause of application failure. [Figure 14.4](#figure14.4) provides
    an example. All is well on our first and second release, but then, for example,
    on the third release, we may find a major bug that somehow got through our testing
    regime and blammo—the system fails over.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，代码部署，即你应用的更新，往往是应用失败的最大原因。[图14.4](#figure14.4) 提供了一个例子。在我们的第一个和第二个版本中一切顺利，但然后，例如，在第三个版本中，我们可能会发现一个严重的错误，这个错误
    somehow通过了我们的测试流程，然后——系统失败了。
- en: '![c14_04.eps](Images/c14_04.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![c14_04.eps](Images/c14_04.png)'
- en: '[Figure 14.4](#figureanchor14.4) Failures often occur when new software is
    released. The fastest way to deal with them is to roll back to the previous working
    version.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.4](#figureanchor14.4) 失败通常发生在新软件发布时。处理它们最快的方法是回滚到之前的正常版本。'
- en: What should we do when we have a major system failure? The simplest solution,
    the one that’s least disruptive to our users, is to immediately roll the whole
    thing back to the previous working version. This highlights an important requirement
    for our deployment pipeline. We should strive for a deployment system that makes
    it easy to roll back or redeploy an earlier version of the app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到重大系统故障时，我们应该怎么做？最简单、对用户影响最小的解决方案是立即将整个系统回滚到之前的正常版本。这突显了我们部署管道的一个重要要求。我们应该努力实现一个部署系统，使其能够轻松回滚或重新部署应用的早期版本。
- en: Unfortunately, though, errors can go unnoticed for a long period of time before
    being discovered. We must be prepared for errors to manifest in the future, and
    they’ll often appear at the most inconvenient times. For big system failures,
    it might be obvious that the app isn’t working, but what happens for less drastic
    problems? How do we know whether the system is functioning normally or abnormally?
    We need a way to monitor our app.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不幸的是，错误可能在被发现之前长时间不被注意。我们必须为将来可能出现的错误做好准备，并且它们通常会在最不方便的时候出现。对于大型系统故障，应用无法工作可能是显而易见的，但对于不那么严重的问题呢？我们如何知道系统是正常工作还是异常工作？我们需要一种方法来监控我们的应用。
- en: 14.4 Monitoring
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 监控
- en: Deploying our code to production is the first step. Now we need to know if the
    app is functioning or not. It’s imperative that we have transparency over what
    the app is doing; we can’t fix problems if we don’t know about them. We need to
    check if the app is behaving normally and whether it’s already experienced a failure
    and since recovered.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的代码部署到生产环境是第一步。现在我们需要知道应用是否在正常工作。我们必须对应用正在做什么有透明度；如果我们不知道问题，我们就无法修复它们。我们需要检查应用是否表现正常，以及它是否已经经历过失败并已恢复。
- en: Debugging your code thoroughly while in development is important. Reading every
    line of code isn’t the same as watching each line of code execute. Debugging is
    a tool we can use to understand what our code is doing and not what we think it’s
    doing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中彻底调试代码很重要。阅读每一行代码并不等同于观察每一行代码的执行。调试是我们用来理解代码正在做什么而不是我们以为它在做什么的工具。
- en: Unfortunately, though, we can’t easily debug our code when it’s running in production.
    You must do adequate testing and debugging on your development workstation before
    you attempt to get your code working in production.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不幸的是，当我们的代码在生产环境中运行时，我们并不能轻松地调试它。在你尝试在生产环境中使你的代码工作之前，你必须在你的开发工作站上做足够的测试和调试。
- en: Instead of debugging production code, to know what’s going on, we can use logging
    and reporting of events and metrics to understand how our app is behaving. A simple
    way to do this (assuming you already have a database at hand) is to record your
    logging and metrics to your database, as shown in [figure 14.5](#figure14.5).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是调试生产代码，为了了解正在发生的事情，我们可以使用事件和指标的日志记录和报告来了解我们的应用是如何表现的。一种简单的方法（假设你已经有了一个数据库）是将你的日志和指标记录到你的数据库中，如图14.5所示。
- en: '![c14_05.eps](Images/c14_05.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![c14_05.eps](Images/c14_05.png)'
- en: '[Figure 14.5](#figureanchor14.5) Collect logs, errors, and metrics from your
    system so you can have visibility of its activity.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.5](#figureanchor14.5) 从您的系统中收集日志、错误和指标，以便您可以了解其活动情况。'
- en: We might be tempted to log to standard output or a file, which is a great way
    to start and is useful during development, but it’s less useful when the app goes
    to production.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会倾向于将日志记录到标准输出或文件中，这是一个很好的开始方式，并且在开发期间很有用，但当应用程序进入生产阶段时，它的实用性就降低了。
- en: If we put our logs and metrics in our database, we can start to do interesting
    things. First, we can view the data remotely using a database viewer, which is
    great when we’re physically separated from the server that’s running our app.
    Second, we can use our data-wrangling and analysis skills to transform, aggregate,
    and understand the behavior of our app. We might even build a custom log or metrics
    viewer or use an off-the-shelf system to search and interrogate the history of
    our app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将日志和指标放入我们的数据库中，我们就可以开始做一些有趣的事情。首先，我们可以使用数据库查看器远程查看数据，这在我们在物理上与运行我们应用程序的服务器分离时非常有用。其次，我们可以使用我们的数据处理和分析技能来转换、汇总并理解应用程序的行为。我们甚至可以构建一个定制的日志或指标查看器，或者使用现成的系统来搜索和查询应用程序的历史记录。
- en: We can take our logging and monitoring system even further—say, if we need to
    support a distributed system (a collection of applications). To do this, we can
    create (or buy) a dedicated monitoring server, as shown in [figure 14.6](#figure14.6),
    to service multiple apps and integrate their logging and metrics into a single
    searchable system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的日志和监控系统进一步扩展——比如说，如果我们需要支持分布式系统（一组应用程序）。为此，我们可以创建（或购买）一个专门的监控服务器，如图14.6所示，为多个应用程序提供服务，并将它们的日志和指标整合到一个可搜索的系统中。
- en: Centralizing our server monitoring system gives us more power for understanding
    our distributed system. We now have one place to manage how we monitor and report
    on our production applications. It’s similar to the reporting and alert system
    for our early warning system from chapter 12, and we can reuse those same ideas
    here. For example, we might want to send daily reports on application performance
    or trigger SMS alerts when failures are detected.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的服务器监控系统集中化，使我们能够更好地理解我们的分布式系统。我们现在有一个地方来管理我们如何监控和报告我们的生产应用程序。这与第12章中我们的早期预警系统的报告和警报系统类似，我们可以在这里重用那些相同的思想。例如，我们可能希望每天报告应用程序的性能，或者在检测到故障时触发短信警报。
- en: Another improvement on the server monitoring system is to give it the capability
    to actively monitor the app. As shown in [figure 14.7](#figure14.7), the server
    monitoring system can have a bidirectional communication channel with the app
    and be actively pinging it to check that it’s still alive, responding quickly,
    and isn’t overloaded.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器监控系统的一个改进是赋予它主动监控应用程序的能力。如图14.7所示，服务器监控系统可以与应用程序建立双向通信通道，并主动ping它以检查它是否仍然活跃、响应迅速且未过载。
- en: '![c14_06.eps](Images/c14_06.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![c14_06.eps](Images/c14_06.png)'
- en: '[Figure 14.6](#figureanchor14.6) Multiple systems can feed into a single server
    monitoring system.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.6](#figureanchor14.6) 多个系统可以输入到单个服务器监控系统。'
- en: '![c14_07.eps](Images/c14_07.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![c14_07.eps](Images/c14_07.png)'
- en: '[Figure 14.7](#figureanchor14.7) We can make the relationship between our system
    and the monitoring API bidirectional; the monitoring API is now actively checking
    the health of our system.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.7](#figureanchor14.7) 我们可以使我们的系统与监控API之间的关系双向化；监控API现在正在主动检查我们系统的健康状况。'
- en: 'With the capability to understand what our app is doing, we can now have a
    continuous understanding of its state: whether it’s working or broken. But this
    still raises the question of how we can best structure our code to ensure it continues
    to work and has a high tolerance for failures.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解我们的应用程序正在做什么，我们现在可以持续了解其状态：它是在工作还是出了问题。但这仍然提出了一个问题，即我们如何最好地组织我们的代码以确保它继续工作并具有高度的容错能力。
- en: 14.5 Reliability
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5 可靠性
- en: When we take our app to production, we have an expectation that it will perform
    with a level of reliability. We have ways to prepare early on to create robust
    and stable code; inevitably, though, problems will happen, and we should take
    care to write code that can quickly bounce back from failure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将应用程序推向生产时，我们期望它能够以一定的可靠性运行。我们有一些方法可以在早期准备，以创建健壮和稳定的代码；然而，不可避免的是，问题会发生，我们应该注意编写能够快速从失败中恢复的代码。
- en: Many tactics can be used to improve the reliability and stability of our code,
    not least of which is adequate testing, which we’ll come to soon. We’ll also discuss
    various techniques that will help you create fault tolerant code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多策略来提高我们代码的可靠性和稳定性，其中最重要的莫过于充分的测试，这一点我们很快就会讨论。我们还将讨论各种技术，这些技术将帮助你创建容错代码。
- en: 14.5.1 System longevity
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.1 系统寿命
- en: It’s important that we understand how long our application is expected to remain
    in operation. By this, I mean the amount of time it must reliably operate before
    it’s restarted or its host is rebooted. If you’re using the continuous delivery
    process, then your delivery cycle will dictate the time between reboots, as indicated
    in [figure 14.8](#figure14.8).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解我们的应用程序预期将保持运行多长时间是很重要的。通过这一点，我指的是在它重启或其宿主重启之前，它必须可靠运行的时间。如果你使用持续交付流程，那么你的交付周期将决定重启之间的时间，如[图14.8](#figure14.8)所示。
- en: '![c14_08.eps](Images/c14_08.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![c14_08.eps](Images/c14_08.png)'
- en: '[Figure 14.8](#figureanchor14.8) Your deployment schedule dictates the longevity
    of your system (the time between system reboots).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.8](#figureanchor14.8) 你的部署计划决定了你系统的寿命（系统重启之间的时间）。'
- en: If your delivery schedule is monthly, the system must survive and continue to
    operate for at least a month. We’ll need to gear our testing around this period
    of time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的交付计划是每月一次，系统必须至少持续运行一个月。我们需要围绕这个时间段进行测试。
- en: 14.5.2 Practice defensive programming
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.2 实践防御性编程
- en: I usually like to be coding in the mindset of defensive programming. This is
    a mode of working where we always expect that errors will occur, even if we don’t
    yet know what they’ll be. We should expect that we’ll get bad inputs. We should
    expect that the function we’re calling or the service we’re depending on is going
    to behave badly or be unresponsive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常喜欢以防御性编程的心态进行编码。这是一种工作模式，我们始终预期会发生错误，即使我们还不清楚它们会是什么。我们应该预期我们会得到不良的输入。我们应该预期我们调用的函数或我们依赖的服务会表现不佳或无响应。
- en: 'You can think of this as Murphy’s Law: if something can go wrong, it will go
    wrong. If you’re coding, and you find yourself avoiding a problem and telling
    yourself the problem will never occur—well, that’s the time to assume that it
    will go wrong! When we practice defensive programming, we assume that any and
    all such problems can occur, and we take measures to allow our code to survive
    and report failures.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其视为墨菲定律：如果某件事可能出错，它就会出错。如果你在编码，发现自己正在避免一个问题，并告诉自己这个问题永远不会发生——那么，那就是你假设它将会出错的时候！当我们实践防御性编程时，我们假设任何和所有这样的问题都可能发生，并采取措施让我们的代码能够生存并报告失败。
- en: Cultivating this attitude will help you build resilient software.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 培养这种态度将帮助你构建健壮的软件。
- en: 14.5.3 Data protection
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.3 数据保护
- en: 'If we have a first rule of data wrangling, then it should be this: don’t lose
    your data!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个数据整理的第一规则，那么它应该是这样的：不要丢失你的数据！
- en: 'Whatever happens, protection of your data is paramount. Internalize and live
    by these rules:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论发生什么，保护你的数据是最重要的。内化并遵守以下规则：
- en: Safely record your data as soon as it’s captured.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦数据被捕获，就安全地记录它。
- en: Never overwrite your source data.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要覆盖你的源数据。
- en: Never delete your source data.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要删除你的源数据。
- en: If you follow these rules, your data will be protected. In certain circumstances,
    for example, when your expanding database starts to impact on your system longevity,
    you may need to break these rules, but be careful when you do—here be dragons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这些规则，你的数据将会得到保护。在某些情况下，例如，当你的数据库扩展开始影响你的系统寿命时，你可能需要打破这些规则，但当你这样做时要小心——这里可能有龙。
- en: In chapter 12 when working on the early warning system, we discussed the implications
    of transforming your data before or after capturing it to your database. I’ll
    reiterate it again here. You should capture your important data first—making sure
    it’s safe—before doing any additional work on it. [Figure 14.9](#figure14.9) indicates
    the right way to approach this. The code that captures your data is the code that
    protects your data; it should be your most well-tested code. You should also minimize
    the amount of code that does this job. Small amounts of code are easier to test
    and easier to prove correct.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12章中，当我们讨论早期预警系统时，我们讨论了在将数据捕获到数据库之前或之后转换数据的影响。我再次强调这一点。你应该首先捕获你的重要数据——确保它是安全的——然后再对它进行任何额外的工作。[图14.9](#figure14.9)
    指出了正确处理这一点的正确方法。捕获你的数据的代码是保护你的数据的代码；它应该是你测试最充分的代码。你还应该尽量减少执行这项工作的代码量。少量的代码更容易测试，也更容易证明其正确性。
- en: '![c14_09.eps](Images/c14_09.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![c14_09.eps](Images/c14_09.png)'
- en: '[Figure 14.9](#figureanchor14.9) Capture your incoming data to the database
    before doing any work. Don''t risk losing your data!'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.9](#figureanchor14.9) 在进行任何工作之前，将你的数据捕获到数据库中。不要冒险丢失你的数据！'
- en: When transforming data and writing it back to the database, never overwrite
    your source data. If you do this, any problem in your transformation code could
    result in corruption of your source data. Bugs happen; losing your data should
    not. This is a risk that you shouldn’t take. Please store your transformed data
    separately to your source data. [Figure 14.10](#figure14.10) shows the approach
    to take.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换数据并将其写回数据库时，永远不要覆盖你的源数据。如果你这样做，你的转换代码中的任何问题都可能导致源数据的损坏。错误是会发生的；丢失数据不应该。这是一个你不应该承担的风险。请将你的转换数据与源数据分开存储。[图14.10](#figure14.10)显示了应采取的方法。
- en: It might seem obvious, but you should also be backing up your source data. In
    the industry, we like to say that it doesn’t exist unless we have at least three
    copies of it! Also, if your source data is being updated or collected routinely,
    you should also back it up routinely. If this becomes tedious, then you need to
    automate it!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显，但你还需要备份你的源数据。在业界，我们喜欢说，除非我们有至少三份副本，否则它就不存在！此外，如果你的源数据是定期更新或收集的，你也应该定期备份它。如果这变得繁琐，那么你需要自动化它！
- en: '![c14_10.eps](Images/c14_10.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![c14_10.eps](Images/c14_10.png)'
- en: '[Figure 14.10](#figureanchor14.10) When transforming data, write the output
    to a separate database table/collection. Don''t risk corrupting your source data!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.10](#figureanchor14.10) 在转换数据时，将输出写入单独的数据库表/集合。不要冒险损坏你的源数据！'
- en: 14.5.4 Testing and automation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.4 测试与自动化
- en: Testing is an essential factor in producing robust code although we’ve barely
    covered it in this book—but that doesn’t mean it’s not important! As we worked
    through the code in the various chapters, we tested manually as we went, and we
    didn’t do any automated testing. But automated testing is important when you’re
    aiming to achieve accurate and highly reliable software.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是生产健壮代码的一个关键因素，尽管在这本书中我们几乎没有涉及它——但这并不意味着它不重要！在我们逐章处理代码的过程中，我们边做边手动测试，并没有进行任何自动化测试。但是，当你致力于实现准确且高度可靠的软件时，自动化测试是非常重要的。
- en: To make your testing worthwhile, you also need to do it in a testing environment
    that emulates your production environment as closely as possible. Many broken
    production deployments have been followed with the familiar excuse “but it worked
    on my computer!” If your development workstation is different from your production
    environment, which it probably is, then you should use either Vagrant or Docker
    to simulate your production machines. You might also consider using Docker to
    provision your production environment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的测试有价值，你还需要在尽可能接近生产环境的测试环境中进行。许多生产部署的失败都伴随着熟悉的借口：“但是它在我的电脑上运行过！”如果你的开发工作站与你的生产环境不同，这很可能是这样，那么你应该使用Vagrant或Docker来模拟你的生产机器。你也可以考虑使用Docker来配置你的生产环境。
- en: Let’s discuss several popular types of testing that I believe work well for
    data pipelines. All the types of testing mentioned here can be automated, so once
    you create a test, it can thereafter run automatically as part of your continuous
    delivery pipeline (as discussed in section 14.3).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论几种我认为适用于数据管道的流行测试类型。这里提到的所有测试类型都可以自动化，所以一旦你创建了一个测试，它就可以作为你持续交付管道的一部分自动运行（如第14.3节所述）。
- en: Test-driven development
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '![c14_11.eps](Images/c14_11.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![c14_11.eps](Images/c14_11.png)'
- en: '[Figure 14.11](#figureanchor14.11) The test-driven development cycle'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.11](#figureanchor14.11) 测试驱动开发周期'
- en: Test-driven development (TDD) starts with building a failing test. We then write
    the code to satisfy that test and make it pass. Last, we refactor to improve the
    code (shown in [figure 14.11](#figure14.11)). The TDD cycle results in reliable
    code that can evolve quickly. It’s commonly known as the process of building granular
    unit tests to exercise your code and verify that it functions correctly. A single
    unit test will test a single aspect of your code. A collection of such tests is
    called a test suite.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）从构建一个失败的测试开始。然后我们编写代码来满足这个测试并使其通过。最后，我们重构代码以改进它（如图14.11所示）。TDD周期产生可靠的代码，可以快速演变。它通常被称为构建细粒度单元测试来锻炼你的代码并验证其正确性的过程。单个单元测试将测试你代码的一个方面。这种测试的集合被称为测试套件。
- en: Using TDD results in your having a significant suite of tests that cover the
    functionality of your app. These tests run automatically whenever you make a change
    to your code. In practice, at least if you have good test coverage, this makes
    it difficult to break your application and allows you to aggressively refactor
    and restructure to improve its design—ultimately making it easier to slot in new
    features. This allows for rapid forward progress, but at the same time you have
    a safety net to catch problems when things go wrong.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD会导致您拥有一个涵盖应用程序功能的重大测试套件。这些测试在您对代码进行更改时自动运行。在实践中，至少如果您有良好的测试覆盖率，这将使破坏应用程序变得困难，并允许您积极重构和重构以改进其设计——最终使添加新功能变得更加容易。这允许快速向前发展，同时您有一个安全网来捕捉出错时的问题。
- en: You might remember in chapter 1 where I said the biggest failure for many coders
    is a failure to plan their work and all the problems that this causes later. Well,
    in my opinion, TDD goes a long way to fixing this problem. You can’t do TDD unless
    you also do planning. They go hand in hand—you must plan your tests before you
    can code a system. TDD forces you to do planning and helps you foresee and mitigate
    risks that might otherwise have troubled you in the future. This never works perfectly,
    but it can go a long way to correcting the no-planning defect in our workflow.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在第一章我说过，许多程序员最大的失败是没有规划他们的工作，以及这后来引起的所有问题。好吧，在我看来，TDD在很大程度上解决了这个问题。您不能进行TDD而不进行规划。它们是手牵手的关系——您必须在编码系统之前规划您的测试。TDD迫使您进行规划，并帮助您预见和减轻可能在未来困扰您的风险。这从不完美，但它可以在很大程度上纠正我们工作流程中缺乏规划的缺陷。
- en: Unfortunately, TDD doesn’t go so well with exploratory coding. That’s because
    exploratory coding is the part of our process where we’re trying to understand
    the data we have and also discover the requirements of our application. In this
    sense, exploratory coding feeds into our planning phase. To make it work, we must
    extract it from the TDD phase. You can see the updated workflow in [figure 14.12](#figure14.12).
    We use exploratory coding to understand our data and requirements before moving
    into TDD. After each round of development, we deploy to production, and like any
    agile process, the cycle repeats iteration after iteration until the app is complete.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，TDD与探索性编码不太兼容。这是因为探索性编码是我们试图理解我们拥有的数据和发现应用程序需求的过程的一部分。从这个意义上说，探索性编码为我们的规划阶段提供信息。为了使其有效，我们必须将其从TDD阶段中提取出来。您可以在[图14.12](#figure14.12)中看到更新的工作流程。我们使用探索性编码在进入TDD之前理解我们的数据和需求。在每一轮开发之后，我们将部署到生产环境，就像任何敏捷流程一样，周期会迭代重复，直到应用程序完成。
- en: '![c14_12.eps](Images/c14_12.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![c14_12.eps](Images/c14_12.png)'
- en: '[Figure 14.12](#figureanchor14.12) Successful TDD relies on good planning;
    exploratory coding builds understanding and feeds into planning, so it will usually
    come before TDD.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.12](#figureanchor14.12) 成功的TDD依赖于良好的规划；探索性编码建立理解并融入规划，因此它通常会在TDD之前。'
- en: I love the test-first philosophy, and I think it applies to much more than unit
    testing. Proper practice of TDD gets you into the habit of thinking about how
    you’ll test your system before you start coding. In my mind, that’s its biggest
    benefit. Once you make the switch to this mindset, it will have a positive payoff
    in more reliable and better tested systems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我热爱测试优先的哲学，我认为它不仅适用于单元测试。正确实践TDD会使您养成在编码之前思考如何测试系统的习惯。在我看来，这是它的最大好处。一旦您切换到这种心态，它将在更可靠和更好测试的系统上产生积极回报。
- en: We can do TDD in JavaScript using any one of the popular testing frameworks
    that are available. My personal choice is to use Mocha.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何流行的测试框架在JavaScript中执行TDD。我个人的选择是使用Mocha。
- en: Output testing
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出测试
- en: 'This form of testing, which I like to call output testing, is simple and works
    well for data-oriented applications. It’s rather simplistic: compare the output
    from previous and current iterations of the code. Then ask the following questions:
    Did the output change? Was the change expected? This will help you understand
    if changes to the code have broken your data pipeline.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试形式，我倾向于称之为输出测试，简单且适用于以数据为导向的应用程序。它相当简单：比较代码的前后迭代输出。然后提出以下问题：输出是否发生了变化？这种变化是预期的吗？这将帮助您了解代码的更改是否破坏了您的数据管道。
- en: The output can be anything that makes sense for your application. In a data
    pipeline, the output could be the textual version of the data that’s output from
    the pipeline. In a different kind of app, the output might be text logging that
    describes the behavior of the application. [Figure 14.13](#figure14.13) illustrates
    the process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以是您应用程序中任何有意义的部分。在数据管道中，输出可能是从管道输出的数据的文本版本。在另一种类型的应用程序中，输出可能是描述应用程序行为的文本日志。[图
    14.13](#figureanchor14.13) 展示了该过程。
- en: '![c14_13.eps](Images/c14_13.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![c14_13.eps](Images/c14_13.png)'
- en: '[Figure 14.13](#figureanchor14.13) Comparing the output of test runs, what
    I call *output testing*, is a great way to test code changes to data pipelines.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.13](#figureanchor14.13) 比较测试运行的输出，我称之为“输出测试”，是测试数据管道代码更改的绝佳方式。'
- en: This testing process allows you to detect unexpected code breakages, and it
    gives you the freedom to refactor and restructure your data pipeline with little
    fear of breaking it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试过程允许您检测意外的代码故障，并让您有自由重构和重新构建您的数据管道，而不用担心将其破坏。
- en: I often use version control software (for example, Git or Mercurial) to manage
    my output testing. I store my output data in a separate repository. Then after
    a test run, I use the version-control software to detect if the output changed
    and, if so, look at the comparison to understand the difference.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用版本控制软件（例如，Git 或 Mercurial）来管理我的输出测试。我将输出数据存储在单独的仓库中。然后，在测试运行之后，我使用版本控制软件来检测输出是否发生变化，如果发生了变化，我会查看比较以了解差异。
- en: This method of testing might seem to you like a brute-force approach. But it’s
    simple, effective, and easy to work with.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试方法可能看起来像是暴力方法。但它简单、有效，并且易于操作。
- en: Integration testing
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is a higher-level form of testing than unit testing. Typically,
    a single integration test will test multiple components or multiple aspects of
    your code. Integration testing tends to cover more ground per test than unit testing
    and isn’t as tedious—you get more bang for the buck. For this reason, I believe
    that integration testing can be more cost effective than unit testing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是比单元测试更高层次的测试形式。通常，一个单独的集成测试会测试多个组件或代码的多个方面。集成测试通常比单元测试覆盖的范围更广，而且不那么繁琐——你花同样的钱可以得到更多的回报。因此，我认为集成测试可能比单元测试更具有成本效益。
- en: Please don’t get me wrong, though; I do believe unit testing is effective and
    that it’s the best way to produce bulletproof code. It’s also time consuming,
    and the investment in time needs to be worthwhile. Consider using integration
    testing for full test coverage and save unit testing for your most valuable code
    or for the code that needs to be the most reliable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然请别误会我的意思；我确实相信单元测试是有效的，并且是生产出坚不可摧代码的最佳方式。但它也很耗时，投入的时间需要物有所值。考虑使用集成测试以实现全面的测试覆盖，并将单元测试留给您最宝贵的代码或需要最可靠代码的部分。
- en: Integration testing works best when you have a natural boundary in your system
    that you can apply the tests to. I mention this because in our early warning system
    we have an appropriate system boundary. Our REST API is delivered through an HTTP
    interface, and integration testing happens to work fantastically well with HTTP.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在系统中有一个可以应用测试的自然边界时，集成测试效果最佳。我之所以提到这一点，是因为在我们的早期预警系统中，我们有一个合适的系统边界。我们的 REST
    API 通过 HTTP 接口交付，而集成测试恰好与 HTTP 工作得非常好。
- en: We can use any of the JavaScript testing frameworks to do automated integration
    testing. [Figure 14.14](#figure14.14) indicates how Mocha is applied to test a
    REST API. In this instance, we can start our web server for testing the way we
    did in chapter 11\. Once the tests have run their course, we evaluate the results,
    Mocha informs of the test pass/fail, and we then stop the web server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何 JavaScript 测试框架来进行自动集成测试。[图 14.14](#figure14.14) 显示了 Mocha 如何应用于测试
    REST API。在这种情况下，我们可以像第 11 章中那样启动我们的 Web 服务器进行测试。一旦测试完成，我们评估结果，Mocha 会通知测试通过/失败，然后我们停止
    Web 服务器。
- en: '![c14_14.eps](Images/c14_14.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![c14_14.eps](Images/c14_14.png)'
- en: '[Figure 14.14](#figureanchor14.14) HTTP REST APIs can easily be tested using
    standard JavaScript testing frameworks such as Mocha.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.14](#figureanchor14.14) HTTP REST API 可以很容易地使用标准的 JavaScript 测试框架，如 Mocha
    进行测试。'
- en: Record and replay
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 记录和回放
- en: Another useful testing technique is what I like to call *record and replay*.
    This works well with data pipelines, especially when you can decouple the pipeline
    stages to the extent where the results of each stage can be recorded and then
    replayed to create an automated test for the next stage. This allows us to create
    a kind of unit testing for each stage of our data pipeline. But if stage-by-stage
    testing isn’t feasible for you, then you could still use record and replay to
    test your entire data pipeline.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的测试技术是我喜欢称之为“记录和回放”的技术。这种方法与数据处理管道配合得很好，尤其是在可以将管道阶段解耦到每个阶段的结果可以被记录并回放以创建下一阶段的自动化测试的程度。这使我们能够为数据处理管道的每个阶段创建一种单元测试。但如果逐阶段测试对您来说不可行，您仍然可以使用记录和回放来测试整个数据处理管道。
- en: We already did this in a fashion. Think back to chapter 12 where we took prerecorded
    air pollution data (our test data) and fed it to our system. We used precanned
    data so that we had a convenient way to develop and evolve our system, but we
    might also use this recorded data to create an automated test for the system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经以这种方式做过这件事了。回想一下第12章，我们使用了预先录制的大气污染数据（我们的测试数据）并将其输入到我们的系统中。我们使用预先准备好的数据，以便我们有一个方便的方式来开发和演进我们的系统，但我们也可以使用这些记录的数据来为系统创建一个自动化的测试。
- en: I’ve seen the replay technique used in the games industry, where having a replay
    feature is often important to game play. I’ve also seen this technique used effectively
    in client/server-type applications where one side of that equation can be recorded
    and then simulated by replaying the recording to the other side.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我在游戏行业中见过回放技术的应用，拥有回放功能对于游戏体验通常很重要。我也见过这种技术在客户端/服务器类型的应用中有效地使用，其中方程的一侧可以被记录，然后通过回放记录来模拟给另一侧。
- en: Load testing
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 压力测试
- en: Load testing is a different form of testing that we can apply to our web server
    or REST API. This is the process of applying or simulating load on the system
    to determine how much it can handle. [Figure 14.15](#figure14.15) indicates how
    we might send a stream of requests to our server to test its capacity.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试是我们可以应用于我们的Web服务器或REST API的另一种测试形式。这是在系统上应用或模拟负载的过程，以确定它可以处理多少。图14.15表明我们可以向服务器发送请求流来测试其容量。
- en: Online services exist that we can use for load testing, or we might roll our
    own script that’s a custom fit for our app. Either way, we can now optimize our
    system so that it can handle more load. Without any performance testing like this,
    we have no way of knowing if our optimization helps the situation or whether it
    makes it worse.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着我们可以用于负载测试的在线服务，或者我们可能编写一个定制的脚本来适应我们的应用程序。无论哪种方式，我们现在都可以优化我们的系统，使其能够处理更多的负载。如果没有这种性能测试，我们就无法知道我们的优化是否有助于改善情况，或者是否使情况变得更糟。
- en: '![c14_15.eps](Images/c14_15.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![c14_15.eps](Images/c14_15.png)'
- en: '[Figure 14.15](#figureanchor14.15) Load test your server to see how much traffic
    and workload it can handle.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.15](#figureanchor14.15) 对您的服务器进行负载测试，以查看它可以处理多少流量和工作负载。'
- en: Load testing is similar to *stress testing*, but the difference is subtle. In
    load testing, we seek to test that the system can handle the load that we intended,
    but with stress testing, we’re actively trying to push the system to its breaking
    point to understand where that point is.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试类似于压力测试，但区别是微妙的。在负载测试中，我们试图测试系统是否可以处理我们打算处理的负载，但在压力测试中，我们积极尝试将系统推向其断裂点，以了解那个点在哪里。
- en: Soak testing
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浸泡测试
- en: The last form of testing to mention is soak testing. This is a long-running
    test to determine if your system is capable of running for its intended system
    longevity. For example, earlier we decided that our system longevity would be
    one month to coincide with our continuous delivery schedule. Our system must survive
    in the wild and under load for at least one month.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的测试形式是浸泡测试。这是一种长时间运行的测试，用于确定您的系统是否能够运行其预期的系统寿命。例如，我们之前决定，我们的系统寿命将是一个月，以符合我们的持续交付计划。我们的系统必须在野外和负载下至少运行一个月。
- en: To believe that our app can survive this long, we can simulate its operation
    under load for this amount of time. This is what we call soak testing. During
    testing, you need to collect metrics from the app. For example, metrics include
    measuring its memory usage and response time over the duration of the test. Now
    use your data analysis and visualization skills to understand what this data is
    telling you. Can the system go the distance? Is its performance stable over time?
    If not, then you may need to take corrective measures.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要相信我们的应用程序可以存活这么长时间，我们可以模拟它在负载下的运行时间。这就是我们所说的压力测试。在测试期间，你需要从应用程序中收集指标。例如，指标包括在测试期间测量其内存使用情况和响应时间。现在使用你的数据分析技能和可视化技能来理解这些数据在告诉你什么。系统能否坚持下去？其性能是否随时间稳定？如果不稳定，那么你可能需要采取纠正措施。
- en: 14.5.5 Handling unexpected errors
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.5 处理意外错误
- en: Errors happen. Software fails. If we planned effectively, we already have a
    good understanding of the anticipated ways that our data pipeline will fail. For
    example, when reading data from sensors, eventually they’re going to give us faulty
    data. Or when we have humans doing data entry, the data will contain occasional
    errors. These are risks that we can easily anticipate, plan for, and mitigate
    in the design of our software.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 错误会发生。软件会失败。如果我们计划得当，我们已经有了一个很好的理解，即我们的数据管道可能会以预期的方式失败。例如，当我们从传感器读取数据时，最终它们会给我们错误的数据。或者当我们有人员进行数据录入时，数据中会包含偶尔的错误。这些是我们可以在软件设计中轻松预测、计划和缓解的风险。
- en: What happens when errors occur that we didn’t expect? How will our app deal
    with it? Well, we can’t anticipate every problem that might occur in production.
    This is especially so when we’re building software in a new domain or a domain
    that’s unique. However, we can plan for our app to handle unexpected situations
    gracefully and recover as best it can.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生我们没有预料到的错误时会发生什么？我们的应用程序将如何处理？好吧，我们无法预测生产中可能发生的每一个问题。这尤其适用于我们在新领域或独特领域构建软件时。然而，我们可以计划让我们的应用程序优雅地处理意外情况，并尽可能恢复。
- en: Different people are going to tell you to deal with this problem in different
    ways. My preferred approach is that an unexpected error shouldn’t cripple your
    application. Instead, the problem should be reported and the app allowed to continue,
    as shown in [figure 14.16](#figure14.16).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的人会告诉你以不同的方式处理这个问题。我首选的方法是意外的错误不应该使你的应用程序瘫痪。相反，应该报告问题，并允许应用程序继续运行，如图14.16所示。
- en: '![c14_16.eps](Images/c14_16.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![c14_16.eps](Images/c14_16.png)'
- en: '[Figure 14.16](#figureanchor14.16) Unexpected errors shouldn''t cripple your
    app. Make sure it can handle them as best it can and continue.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.16](#figureanchor14.16) 意外的错误不应该使你的应用程序瘫痪。确保它能够尽可能好地处理它们并继续运行。'
- en: The easiest way to achieve this is to handle the Node.js uncaught exception
    event as shown in the following listing. Here we can report the error (for example,
    to our monitoring server from section 14.4) and then allow the program to attempt
    to continue.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的最简单方法是处理Node.js中的未捕获异常事件，如下所示列表。在这里，我们可以报告错误（例如，向第14.4节中的监控服务器报告）然后允许程序尝试继续。
- en: Listing 14.1 Handling an uncaught exception in Node.js
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.1 在Node.js中处理未捕获的异常
- en: '[PRE0]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Certain people advocate for not handling uncaught exceptions. They say that
    we should let the program crash and restart; then we should monitor for crashes
    and correct these crashes as they’re found. I think this can be a valid approach
    at times, depending on the situation at hand, but in the context of a data pipeline,
    I find it rather disturbing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 某些人主张不处理未捕获的异常。他们说我们应该让程序崩溃并重新启动；然后我们应该监控崩溃，并在发现时纠正这些崩溃。我认为在某些情况下，这可以是一个有效的方法，但根据具体情况，在数据管道的背景下，我觉得这相当令人不安。
- en: If you let your program be terminated, what happens to asynchronous operations
    that are in progress? They will be aborted, and this may result in data loss (refer
    to the first rule of data wrangling—“don’t lose your data”—from section 14.5.3).
    I prefer to explicitly handle unhandled exceptions, report the error to an error
    tracking system, and then let our system recover as best it can. We still have
    visibility over problems that occur, and I believe we’re now at less of a risk
    of data loss.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你让程序终止，正在进行的异步操作会发生什么？它们将被终止，这可能会导致数据丢失（参考第14.5.3节的数据整理的第一条规则——“不要丢失你的数据”）。我更喜欢显式地处理未处理的异常，将错误报告给错误跟踪系统，然后让我们的系统尽可能恢复。我们仍然可以了解发生的问题，我相信我们现在面临的数据丢失风险更小。
- en: Similarly, we should also handle unhandled rejected promises, as shown in [listing
    14.2](#listing14.2). This is a slightly different scenario. Regardless of how
    you want to deal with uncaught exceptions, you should always set up a handler
    for unhandled promise rejection. If you don’t do this, you risk unhandled rejections
    going into production, where you’ll have no idea that you have missed a catch
    somewhere (you can tell when this happens in development by reading the Node.js
    console).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也应该处理未处理的拒绝承诺，如[列表14.2](#listing14.2)所示。这是一个稍微不同的场景。无论你如何处理未捕获的异常，你都应该始终为未处理的承诺拒绝设置处理程序。如果你不这样做，你可能会让未处理的拒绝进入生产环境，在那里你将不知道你在某个地方遗漏了一个catch（你可以在开发中通过阅读Node.js控制台来知道这种情况发生了）。
- en: Listing 14.2 Handing an unhandled promise rejection in Node.js
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.2 在Node.js中处理未处理的承诺拒绝
- en: '[PRE1]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '});'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: Even if you could tell me that you always put a catch on the end of your promise
    chains (you never forget that, right?), can you also tell me that you never have
    an error in your catch callback? All it takes is one exception in your final catch
    handler, and you now have an unhandled promise rejection that can go unnoticed
    into production. That’s what makes this such an insidious problem.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你能告诉我你总是在你的承诺链的末尾加上catch（你永远不会忘记这一点，对吧？），但你也能告诉我你的catch回调中从未有过错误吗？只需在最终的catch处理程序中有一个异常，你现在就有一个未处理的承诺拒绝，它可能不会被注意到进入生产环境。这就是为什么这是一个如此隐蔽的问题。
- en: Errors do happen, and your data pipeline shouldn’t cease operation because of
    them. Also, don’t forget to test your uncaught exception handlers. Like all other
    code, this code needs to be tested; otherwise, you can’t have confidence that
    your system can cope with these worst-case scenarios.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 错误确实会发生，你的数据管道不应该因为它们而停止运行。此外，别忘了测试你的未捕获异常处理程序。像所有其他代码一样，这段代码也需要测试；否则，你无法确信你的系统可以应对这些最坏的情况。
- en: 14.5.6 Designing for process restart
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.6 设计进程重启
- en: For any long-running and expensive process—for example, that database copy that
    I mentioned way back in chapter 1—you should design the process so that it can
    handle being interrupted and resumed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何运行时间较长且昂贵的进程——例如，我在第1章中提到的那个数据库副本——你应该设计这个进程，使其能够处理中断和恢复。
- en: You never know when something is going to interrupt your code. It might be a
    bug that manifests or a network outage. Someone might trip over a cable and turn
    off your workstation. To avoid wasting time, make sure the process can restart
    from the point (or nearby) where it was interrupted. See [figure 14.17](#figure14.17)
    to understand how this might work.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不知道什么时候会中断你的代码。它可能是一个显现的bug，或者是一个网络中断。有人可能绊倒在电缆上，关闭了你的工作站。为了避免浪费时间，确保进程可以从它被中断的点（或附近）重新启动。参见[图14.17](#figure14.17)了解这可能如何工作。
- en: The long-running process should commit its result periodically and record its
    progress somehow, for example, to your database. If the process needs to restart,
    it must then check the database and determine where to resume its work.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 长运行进程应该定期提交其结果并记录其进度，例如，到你的数据库中。如果进程需要重启，它必须然后检查数据库并确定从哪里继续其工作。
- en: '![c14_17.eps](Images/c14_17.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![c14_17.eps](Images/c14_17.png)'
- en: '[Figure 14.17](#figureanchor14.17) Design long processes to restart and resume
    in case of unexpected interruption.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.17](#figureanchor14.17) 设计长进程以在意外中断的情况下重启和恢复。'
- en: 14.5.7 Dealing with an ever-growing database
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.7 处理不断增长的数据库
- en: 'Any long-running application with a growing database will eventually run out
    of memory or disk space. We must decide how to deal with this before it becomes
    a problem. We can deal with it using a combination of the following strategies:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 任何运行时间较长且数据库不断增长的应用程序最终都会耗尽内存或磁盘空间。我们必须在它成为问题之前决定如何处理这个问题。我们可以通过以下策略的组合来处理它：
- en: Purge old data. We can periodically purge data, but only if old data is no longer
    relevant; otherwise, this is a violation of our rule “don’t lose your data.”
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理旧数据。我们可以定期清理数据，但只有当旧数据不再相关时；否则，这违反了我们的规则“不要丢失你的数据”。
- en: Archive old data. If we do need to retain old data, then we must periodically
    archive it to a low-cost storage solution. Be careful with the code that archives
    your data. A problem here means you’ll lose data.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档旧数据。如果我们确实需要保留旧数据，那么我们必须定期将其存档到低成本存储解决方案中。在归档你的数据的代码上要小心。这里的问题意味着你会丢失数据。
- en: Purge or archive and summarize. Periodically purge or archive old data but aggregate
    it and retain a summary of pertinent details of the old data.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理或存档并总结。定期清理或存档旧数据，但汇总它并保留旧数据的有关细节的摘要。
- en: What happens if we run out of space before the periodic purge or archive kicks
    in? If this is a danger, then we need to monitor the situation through metrics
    (section 14.4) and either be automatically alerted before the situation becomes
    dire or have the purge or archive process activate automatically as necessary.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在定期清理或存档启动之前我们就用完了空间，会发生什么？如果这是一个危险，那么我们需要通过指标（第 14.4 节）来监控情况，或者在情况变得严重之前自动发出警报，或者根据需要自动激活清理或存档过程。
- en: 14.6 Security
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 安全性
- en: Security will be more or less of an issue for you depending on how valuable
    and/or sensitive your data and systems are. The data in our early warning system
    isn’t sensitive per se, but we still don’t want anyone to tamper with it and hide
    an emergency or trigger a false alarm. Possibly more important is the need to
    secure access to the system so that it can’t be disrupted in any way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性对于您来说或多或少是一个问题，这取决于您的数据和系统有多有价值以及/或者有多敏感。我们早期预警系统中的数据本身并不敏感，但我们仍然不希望任何人篡改它，隐藏紧急情况或触发误报。可能更重要的是，我们需要确保系统能够安全访问，以防止任何形式的干扰。
- en: We can’t hope to cope with all possible security issues, but we can prepare
    as well as possible by taking a layered approach. Like a castle that has both
    walls and a moat, multiple layers can make our system more secure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法期望应对所有可能的安全问题，但我们可以通过采取分层方法尽可能做好准备。就像城堡既有城墙又有护城河一样，多层可以使得我们的系统更加安全。
- en: 14.6.1 Authentication and authorization
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.1 身份验证和授权
- en: Our first layer of security is to ensure that whoever accesses our data and
    system is someone we’ve allowed to do so. Through authentication, we confirm that
    people are who they say they are. With authorization, we’re checking that a person
    is allowed to access a certain system or database.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一层安全措施是确保访问我们数据和系统的人是我们允许的。通过身份验证，我们确认人们是他们所说的那个人。通过授权，我们检查一个人是否有权访问某个系统或数据库。
- en: Authentication usually takes the form of validating a user’s password before
    that user can use a system. Because an HTTP service is stateless, we must somehow
    remember (at least for a period of time) the user’s security credentials. A session
    stored in the server or database remembers such details. On the client side, the
    user is identified by a cookie from the browser; the server then associates the
    cookie with the session and can remember the authenticated user. This scenario
    is shown in [figure 14.18](#figure14.18).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证通常是在用户可以使用系统之前验证用户的密码。由于 HTTP 服务是无状态的，我们必须以某种方式记住（至少在一段时间内）用户的安全凭证。存储在服务器或数据库中的会话会记住这些细节。在客户端，用户通过浏览器中的
    cookie 来识别；然后服务器将 cookie 与会话关联起来，并可以记住经过身份验证的用户。这种场景在[图 14.18](#figure14.18)中展示。
- en: '![c14_18.eps](Images/c14_18.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![c14_18.eps](Images/c14_18.png)'
- en: '[Figure 14.18](#figureanchor14.18) A cookie identifies a user to the server;
    the server remembers the user''s authentication in a session.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.18](#figureanchor14.18) 一个 cookie 识别用户给服务器；服务器在会话中记住用户的身份验证。'
- en: When working under Node.js, we can use the de facto standard *Passport* library
    to manage our authentication.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Node.js 下工作时，我们可以使用事实上的标准库 *Passport* 来管理我们的身份验证。
- en: We might implement authorization by recording some extra data in our database
    against each user; this extra data would record the user’s level of privilege
    in our system. For example, they might be marked as an ordinary user or an admin
    user or as a level of privilege in between. We can then read the user’s privilege
    level from the database as necessary to know if we should allow or deny access
    to sensitive server-side data or operations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能通过在数据库中为每个用户记录一些额外数据来实现授权；这些额外数据将记录用户在我们系统中的权限级别。例如，他们可能被标记为普通用户或管理员用户，或者介于两者之间的权限级别。然后我们可以根据需要从数据库中读取用户的权限级别，以确定是否允许或拒绝访问敏感的服务器端数据或操作。
- en: 14.6.2 Privacy and confidentiality
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.2 隐私和机密性
- en: To mitigate the risk of a third-party intercepting and snooping on our data,
    we could encrypt it at all points. This isn’t a concern for our early warning
    system where the data itself isn’t so secret, but in another more secure system,
    you might want to consider using the built-in Node.js Crypto module to encrypt
    your sensitive data. You might want to use HTTPs to encrypt communications between
    your client and server. Encryption may even be supported by your database, which
    is something to look into for that ultimate level of data protection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻第三方拦截和窃听我们数据的风险，我们可以在所有点对其进行加密。这并不是我们预警系统的担忧，因为数据本身并不那么机密，但在另一个更安全的系统中，你可能想要考虑使用内置的Node.js
    Crypto模块来加密你的敏感数据。你可能还想使用HTTPs来加密客户端和服务器之间的通信。加密甚至可能得到数据库的支持，这是需要考虑的，以实现数据保护的最终权威级别。
- en: If you’re managing data about individual users, then you should consider anonymizing
    the stored data. Scrub each record clean of any fields that identify it with a
    particular individual, so if your database is somehow lost, the sensitive data
    cannot be connected with anyone in particular. This helps reduce your privacy
    concerns.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在管理有关个人用户的数据，那么你应该考虑对存储的数据进行匿名化。清除每个记录中的任何字段，以防止它与特定个人相关联，这样如果数据库以某种方式丢失，敏感数据就不能与任何特定个人联系起来。这有助于减少你的隐私担忧。
- en: Of more interest in our current example project is securing the system that
    manages and stores our data. In particular, our database should be on a private
    network and behind a firewall so that it isn’t directly accessible by the outside
    world, as indicated in [figure 14.19](#figure14.19).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的示例项目中，更有兴趣的是保护管理和存储我们数据系统的安全。特别是，我们的数据库应该位于私有网络和防火墙后面，这样它就不能直接被外部世界访问，如图14.19所示。
- en: '![c14_19.eps](Images/c14_19.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![c14_19.eps](Images/c14_19.png)'
- en: '[Figure 14.19](#figureanchor14.19) Our database is hidden behind a firewall
    on a private network. It can''t be accessed from the outside world and is more
    secure.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.19](#figureanchor14.19) 我们的数据库隐藏在私有网络上的防火墙后面。它不能从外部世界访问，因此更加安全。'
- en: If we had sensitive business logic and/or significant intellectual property
    to protect, we might also take this a step further and divide our server into
    public and private components, then move the private server behind the firewall
    alongside the database, as shown in [figure 14.20](#figure14.20).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有敏感的商业逻辑和/或重要的知识产权需要保护，我们也可以更进一步，将服务器分为公共和私有组件，然后将私有服务器与数据库一起移到防火墙后面，如图14.20所示。
- en: As an example, imagine that you have a secret algorithm for analyzing your data
    to produce the daily report for the early warning system. The output of the report
    isn’t so much secret, only the formula used to interpret the data, and you consider
    this to be valuable intellectual property. You could move the algorithm that produces
    the report behind the firewall, where it will be less vulnerable to external intrusion.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，你有一个分析数据以生成预警系统每日报告的秘密算法。报告的输出并不那么机密，只是用来解释数据的公式，而你认为这是有价值的知识产权。你可以将生成报告的算法移到防火墙后面，这样它就会对外部入侵的脆弱性降低。
- en: This kind of compartmentalization of your system and isolation of the most sensitive
    parts of it is another example of creating multiple layers of security. To breach
    the most sensitive parts of the system, a would-be attacker must penetrate the
    security at multiple levels.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对系统进行分区和隔离其最敏感部分的例子，是创建多层安全性的另一个例子。要突破系统的最敏感部分，潜在的攻击者必须突破多个级别的安全。
- en: No doubt you have already heard this, but it’s also important that you keep
    your server operating system and software updated to stay on top of the latest
    known security vulnerabilities. It’s important for you to understand that your
    whole system is only as secure as its weakest link.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，你已经听说过这一点，但同样重要的是，你需要保持你的服务器操作系统和软件更新，以跟上最新的已知安全漏洞。你需要明白，你的整个系统只有在其最薄弱环节上才是安全的。
- en: '![c14_20.eps](Images/c14_20.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![c14_20.eps](Images/c14_20.png)'
- en: '[Figure 14.20](#figureanchor14.20) Divide our server into public and private
    components; then put the private server behind the firewall. We now have a more
    secure home for sensitive operations and intellectual property.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.20](#figureanchor14.20) 将我们的服务器分为公共和私有组件；然后将私有服务器放在防火墙后面。我们现在为敏感操作和知识产权提供了一个更安全的家。'
- en: 14.6.3 Secret configuration
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.3 秘密配置
- en: One last point to note on security is that you need a secure way to store your
    application’s secrets. Recall in chapter 12 the file that we created to store
    the configuration details of our application—for example, storing the login details
    to your email server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全方面需要注意的最后一点是，你需要一种安全的方式来存储你的应用程序的秘密。回想一下第12章中我们创建的用于存储应用程序配置详细信息的文件——例如，存储到你的电子邮件服务器的登录详情。
- en: This approach encouraged you to store your configuration details in version
    control, but that’s the least secure way of managing sensitive configuration.
    We did it that way purely for simplicity, but in a production system, we need
    to consider the security implications of this. For example, in this case we probably
    don’t want granting access to the source code repository to also grant access
    to the email server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法鼓励你将配置详情存储在版本控制中，但这是管理敏感配置最不安全的方式。我们这样做纯粹是为了简单，但在生产系统中，我们需要考虑这种做法的安全影响。例如，在这种情况下，我们可能不希望授予对源代码存储库的访问权限也授予对电子邮件服务器的访问权限。
- en: The way we should securely deal with this problem in production depends on the
    cloud provider that we go with, but we should use the secure storage or vault
    provided (or one by a trusted third-party) because rolling your own secure storage
    for secrets is fraught with danger.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在生产中安全处理这个问题的方法取决于我们选择的云提供商，但我们应该使用提供的（或由受信任的第三方提供的）安全存储或保险库，因为自己构建用于存储秘密的安全存储充满了危险。
- en: 14.7 Scaling
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.7 扩展
- en: What do we do when we get to production and find out our application isn’t handling
    the work load that it needs to? How can we increase the application’s capacity?
    We need to be able to scale our application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入生产阶段并发现我们的应用程序无法处理所需的工作负载时，我们该怎么办？我们如何增加应用程序的容量？我们需要能够扩展我们的应用程序。
- en: As with any of the topics discussed in this chapter, any level of thought we
    can put into this while planning is going to save us much pain later on.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章讨论的任何主题一样，我们在规划时投入的任何思考都将使我们以后少受很多痛苦。
- en: 14.7.1 Measurement before optimization
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.7.1 优化前的测量
- en: 'Before we can understand and improve the performance of our system, we must
    measure it. We have many different metrics to choose from: data throughput (for
    example, bytes per second), server response time (in milliseconds), or the number
    of concurrent users that can be serviced by the app.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够理解和改进系统的性能之前，我们必须对其进行测量。我们有多种不同的指标可供选择：数据吞吐量（例如，每秒字节数）、服务器响应时间（以毫秒为单位），或应用程序可以服务的并发用户数。
- en: The main point is that, like any optimization process, we can’t hope to improve
    performance until we can measure it. Once we can measure performance, we can now
    conduct experiments and show categorically if our optimization efforts have yielded
    results.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的观点是，就像任何优化过程一样，我们无法希望提高性能，除非我们能够测量它。一旦我们能够测量性能，我们现在就可以进行实验，并明确地展示我们的优化努力是否产生了结果。
- en: We can evaluate a system’s performance by capturing, recording, and analyzing
    appropriate system metrics. Your data analysis skills from chapter 9 will come
    in handy here for determining the trend and finding patterns in your metrics.
    With a system in place to measure performance, you can now think about scaling
    to increase your app’s performance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过捕获、记录和分析适当的系统指标来评估系统的性能。在第9章中，你的数据分析技能在这里将很有用，用于确定趋势和找到指标中的模式。有了测量性能的系统，你现在可以思考扩展以提高应用程序的性能。
- en: 14.7.2 Vertical scaling
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.7.2 垂直扩展
- en: The first method of scaling we should consider is called vertical scaling. This
    is the easiest method of scaling and generally doesn’t require changes to your
    app. As indicated in [figure 14.21](#figure14.21), we increase the size of the
    PC that the app is running on. This is difficult to do if we’re running it on
    physical hardware but is trivial when we’re running on a virtual machine (VM)
    with any of the major cloud providers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑的第一个扩展方法是垂直扩展。这是扩展中最简单的方法，通常不需要对您的应用程序进行更改。如图14.21所示，我们增加应用程序运行的PC的大小。如果我们运行在物理硬件上，这很困难，但如果我们运行在任何主要云提供商的虚拟机（VM）上，这将是微不足道的。
- en: '![c14_21.eps](Images/c14_21.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![c14_21.eps](Images/c14_21.png)'
- en: '[Figure 14.21](#figureanchor14.21) You can scale your server up by increasing
    the size of the virtual machine that hosts it.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.21](#figureanchor14.21) 您可以通过增加托管服务器的虚拟机的大小来扩展服务器。'
- en: All we’re doing here is scaling up the size of the PC used to run our app. We’ve
    increased the CPU, memory, and disk and hopefully increased the capacity of our
    app at the same time. There’s a limit to this, though, and eventually we’ll exhaust
    the capacity of the server. At this point, we must now turn to horizontal scaling.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们所做的一切只是扩大了我们用来运行应用的PC的规模。我们已经增加了CPU、内存和硬盘，并希望同时增加了我们应用的能力。然而，这有一个限制，最终我们将耗尽服务器的容量。在这个时候，我们必须现在转向水平扩展。
- en: 14.7.3 Horizontal scaling
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.7.3 水平扩展
- en: The second option we have for scaling is called horizontal scaling. The simplest
    version of this is when we replicate our app to multiple virtual machines (VMs)
    running in the cloud and use a load balancer to distribute the load between the
    various instances of our app, as shown in [figure 14.22](#figure14.22).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于扩展的第二个选项被称为水平扩展。这种扩展的最简单版本是我们将应用复制到多个在云中运行的虚拟机（VM）上，并使用负载均衡器在应用的不同实例之间分配负载，如图14.22所示。
- en: This form of scaling is more complicated to manage and configure than vertical
    scaling, but it can be more cost effective, especially because the scaling can
    be automatic where new instances are created on demand to expand capacity and
    meet the workload.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种扩展形式比垂直扩展更复杂，但可能更经济高效，尤其是在扩展可以自动进行的情况下，新的实例可以根据需求创建以扩展容量并满足工作量。
- en: This approach is more difficult when the application instances must share a
    resource. For example, all instances might share the same database, and that has
    the potential to be a performance bottleneck. Similar to what we talked about
    with security, your application can have performance only as good as its weakest
    link—what we call the bottleneck. Fortunately, most modern databases such as MongoDB
    can be scaled in the same way and can be distributed over multiple machines.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用实例必须共享资源时，这种方法会更困难。例如，所有实例可能共享同一个数据库，这有可能成为性能瓶颈。类似于我们讨论的安全问题，你的应用性能只能与其最薄弱的环节一样好——我们称之为瓶颈。幸运的是，大多数现代数据库，如MongoDB，都可以以相同的方式进行扩展，并且可以分布到多台机器上。
- en: '![c14_22.eps](Images/c14_22.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![c14_22.eps](Images/c14_22.png)'
- en: '[Figure 14.22](#figureanchor14.22) Horizontal scaling distributes the load
    across multiple instances of your app.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.22](#figureanchor14.22) 水平扩展将负载分配到应用的多实例之间。'
- en: Horizontal scaling also gives another benefit. It gives us redundancy and another
    way to handle application failures. If the app fails, the load balancer can automatically
    redistribute traffic away from the broken instance to be handled by other instances
    while the failed server is fixed or rebooted.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展还提供了另一个好处。它为我们提供了冗余和另一种处理应用故障的方法。如果应用失败，负载均衡器可以自动重新分配流量，远离故障实例，由其他实例处理，同时修复或重启失败的服务器。
- en: I wouldn’t be surprised if you come away from this chapter feeling a little
    overwhelmed. Getting to production is a difficult affair, and you have so much
    to consider. But if you should take away one thing from this chapter, it’s not
    that production is complicated (although it is), and it’s not that getting to
    production involves solving many problems (although it does).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读完这一章感到有些不知所措，我不会感到惊讶。将应用推向生产是一个困难的过程，你需要考虑很多因素。但如果你从这个章节中带走了一件事，那不是生产很复杂（尽管确实如此），也不是到达生产需要解决很多问题（尽管确实如此）。
- en: 'If you remember one thing, please remember this: the problems that come with
    production are good problems to have. That’s because these are the problems that
    come with success. If your app isn’t successful, you won’t have these problems.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得一件事，请记住这一点：与生产相关的问题都是好问题。这是因为这些都是与成功相关的问题。如果你的应用不成功，你就不会遇到这些问题。
- en: Now you have something of a handle on many of the facets of bringing your data
    pipeline to production. This is indeed a big and complex area, and when you come
    to production, you’ll surely encounter your own unique problems. I could write
    a whole book on this subject, but hopefully you have enough for now to start on
    your own road to production and the completion of your product, whatever that
    may be. Good luck, my friend. Please enjoy the journey and always be learning
    new things.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对将你的数据管道带入生产的一些方面有了某种程度的了解。这确实是一个庞大而复杂领域，当你进入生产时，你肯定会遇到你自己的独特问题。我可以就这个主题写一本书，但希望你现在有足够的了解，开始你自己的生产之路和产品的完成，无论那可能是什么。祝你好运，我的朋友。请享受这段旅程，并始终学习新事物。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned that there’s a whole new world of problems to deal with bringing
    your data pipeline to product.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解到将你的数据管道带入产品意味着要处理一个全新的问题世界。
- en: We discussed what deployment might look like for your app using the continuous
    delivery technique.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了使用持续交付技术，你的应用部署可能的样子。
- en: We described how being able to roll back a broken deployment is an essential
    feature of any deployment script.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们描述了能够回滚失败的部署是任何部署脚本的基本功能。
- en: We explored the structure of a monitoring system that would allow us to check
    that our app is functioning well with good performance.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探索了一种监控系统的结构，该系统能够让我们检查我们的应用是否运行良好且性能优秀。
- en: We learned various ways to improve the reliability of our code for increased
    system longevity, better protection of our data, and graceful handling of unexpected
    errors.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了各种提高我们代码可靠性、增加系统寿命、更好地保护我们的数据以及优雅处理意外错误的方法。
- en: You learned that good security is a multilayered approach, and a potential attacker
    must breach numerous layers to compromise the security of your application.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解到良好的安全性是一个多层次的方法，潜在的攻击者必须突破多个层次才能危害你应用的安全性。
- en: Finally, you gained an understanding of how the capacity of an application can
    be increased through vertical and horizontal scaling.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你了解了如何通过垂直和水平扩展来增加应用程序的容量。
