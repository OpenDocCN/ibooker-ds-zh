- en: '20 Password strength: Generating a secure and memorable password'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20 密码强度：生成安全且易记的密码
- en: It’s not easy to create passwords that are both difficult to guess and easy
    to remember. An XKCD comic describes an algorithm that provides both security
    and recall by suggesting that a password be composed of “four random common words”
    ([https://xkcd.com/936/](https://xkcd.com/936/)). For instance, the comic suggests
    that the password composed of the words “correct,” “horse,” “battery,” and “staple”
    would provide “~44 bits of entropy” which would require around 550 years for a
    computer to guess, given 1,000 guesses per second.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建既难以猜测又容易记住的密码并不容易。一个XKCD漫画描述了一个算法，通过建议密码由“四个随机常用词汇”组成，提供了安全性和记忆力的双重保障 ([https://xkcd.com/936/](https://xkcd.com/936/))。例如，漫画建议由“correct”、“horse”、“battery”和“staple”这些单词组成的密码将提供“~44位的熵”，这意味着在每秒1000次猜测的情况下，需要大约550年才能被计算机猜出。
- en: 'We’re going to write a program called password.py that will create passwords
    by randomly combining words from some input files. Many computers have a file
    that lists thousands of English words, each on a separate line. On most of my
    systems, I can find this at /usr/share/dict/words, and it contains over 235,000
    words! As the file can vary by system, I’ve added a version to the repo so that
    we can use the same file. This file is a little large, so I’ve compressed to inputs/words.txt.zip.
    You should unzip it before using it:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为password.py的程序，通过随机组合一些输入文件中的词汇来创建密码。许多计算机都有一个列出数千个英语单词的文件，每个单词单独一行。在我的大多数系统中，我可以在/usr/share/dict/words中找到这个文件，它包含超过235,000个单词！由于文件可能因系统而异，我已经在仓库中添加了一个版本，这样我们就可以使用相同的文件。这个文件有点大，所以我将其压缩到inputs/words.txt.zip。在使用之前，你应该解压缩它：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we should both have the same inputs/words.txt file so that this is reproducible
    for you:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们都应该有相同的输入文件/words.txt，这样你才能重现这个过程：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Hmm, maybe those aren’t going to be the easiest to remember! Perhaps instead
    we should be a bit more judicious about the source of our words? We’re drawing
    from a pool of over 200,000 words, but the average speaker tends to use somewhere
    between 20,000 and 40,000 words.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许这些并不是最容易记住的！也许我们更应该对词汇的来源更加谨慎？我们正在从超过200,000个词汇的库中抽取，但平均说话者通常使用20,000到40,000个词汇。
- en: '![](../Images/20-unnumb-1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/20-unnumb-1.png)'
- en: (Image used with permission from [xkcd.com](http://xkcd.com).)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: （图片使用xkcd.com的许可）
- en: 'We can generate more memorable passwords by drawing from an actual piece of
    English text, such as the US Constitution. Note that to use a piece of input text
    in this way, we will need to remove any punctuation, as we have done in previous
    exercises:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从实际的英文文本中抽取，例如美国宪法，来生成更多易记的密码。请注意，为了以这种方式使用输入文本，我们需要移除任何标点符号，就像我们在之前的练习中所做的那样：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another strategy for generating memorable words could be to limit the pool
    of words to the more interesting parts of speech, like nouns, verbs, and adjectives
    taken from texts like novels or poetry. I’ve included a program I wrote called
    harvest.py that uses a natural language processing library in Python called spaCy
    ([https://spacy.io](https://spacy.io)) that will extract those parts of speech
    into files that we can use as input to our program. If you want to use this program
    on your own input files, you’ll need to be sure you first install the module:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 生成易记词汇的另一种策略可能是限制词汇池到更有趣的词性，例如从小说或诗歌等文本中提取的名词、动词和形容词。我包括了一个我编写的程序harvest.py，它使用Python中的自然语言处理库spaCy
    ([https://spacy.io](https://spacy.io))，可以将这些词性提取到文件中，我们可以将这些文件作为程序的输入。如果你想在自己的输入文件上使用这个程序，你需要确保首先安装这个模块：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I ran the harvest.py program on some texts and placed the outputs into directories
    in the 20_password directory of the source repo. For instance, here is the output
    drawing from nouns found in the US Constitution:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我在几个文本上运行了harvest.py程序，并将输出放置在源仓库的20_password目录下的目录中。例如，这里是从美国宪法中找到的名词的输出：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here we have passwords generated using only verbs found in *The Scarlet
    Letter* by Nathaniel Hawthorne:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们展示了仅使用纳撒尼尔·霍桑的《红字》中找到的动词生成的密码：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here are some generated from adjectives extracted from William Shakespeare’s
    sonnets:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些是从威廉·莎士比亚的十四行诗中提取的形容词生成的密码：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just in case that does not result in a strong enough password, we will also
    provide a `--l33t` flag to further obfuscate the text by
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不足以生成一个足够强大的密码，我们还将提供一个`--l33t`标志，通过进一步混淆文本来提供：
- en: Passing the generated password through the ransom.py algorithm from chapter
    12
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的密码通过第12章的 ransom.py 算法进行传递
- en: Substituting various characters with a given table, as we did in jump_the_five.py
    from chapter 4
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用给定的表格替换各种字符，就像我们在第4章的 jump_the_five.py 中做的那样
- en: Adding a randomly selected punctuation character to the end
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在末尾添加一个随机选择的标点符号字符
- en: 'Here is what the Shakespearean passwords look like with this encoding:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用此编码的莎士比亚密码的样子：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this exercise, you will
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: Take a list of one or more input files as positional arguments
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个或多个输入文件作为位置参数
- en: Use a regular expression to remove non-word characters
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式删除非单词字符
- en: Filter words by some minimum length requirement
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过某些最小长度要求过滤单词
- en: Use sets to create unique lists
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合创建唯一的列表
- en: Generate a given number of passwords by combining some given number of randomly
    selected words
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合一定数量的随机选择的单词生成给定数量的密码
- en: Optionally encode text using a combination of algorithms we’ve previously written
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地使用我们之前编写的算法组合对文本进行编码
- en: 20.1 Writing password.py
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.1 编写 password.py
- en: Our program should be written in the 20_password directory and will be called
    password.py. It will create some `--num` number of passwords (default, `3`) each
    by randomly choosing some `--num_words` number of words (default, `4`) from a
    unique set of words from one or more input files. As it will use the `random`
    module, the program will also accept a random `--seed` argument, which should
    be an integer value with a default of `None`. The words from the input files will
    need to be a `--min_word_len` minimum length (default, `3`) up to a `--max_word_len`
    maximum length (default, `6`) after removing any non-characters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将程序编写在 20_password 目录中，并将其命名为 password.py。它将通过从来自一个或多个输入文件的唯一单词集中随机选择一些
    `--num_words` 数量的单词（默认，`4`）来创建一些 `--num` 数量的密码（默认，`3`）。由于它将使用 `random` 模块，程序还将接受一个随机的
    `--seed` 参数，它应该是一个整数值，默认为 `None`。输入文件中的单词需要满足 `--min_word_len` 最小长度（默认，`3`）到 `--max_word_len`
    最大长度（默认，`6`）的要求，在移除非字符后。
- en: 'As always, our first priority is to sort out the inputs to the program. Do
    not move ahead until your program can produce this usage with the `-h` or `--help`
    flags and can pass the first eight tests:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们的首要任务是整理程序的输入。在程序能够通过 `-h` 或 `--help` 标志产生此用法并通过前八个测试之前，不要继续前进：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The words from the input files will be title cased (first letter uppercase,
    the rest lowercase), which we can achieve using the `str.title()` method. This
    makes it easier to see and remember the individual words in the output. Note that
    we can vary the number of words included in each password as well as the number
    of passwords generated:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件中的单词将被首字母大写（第一个字母大写，其余小写），我们可以使用 `str.title()` 方法来实现这一点。这使得在输出中更容易看到和记住单个单词。请注意，我们可以调整每个密码中包含的单词数量以及生成的密码数量：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `--min_word_len` argument helps to filter out shorter, less interesting
    words like “a,” “I,” “an,” “of,” and so on, while the `--max_word_len` argument
    prevents the passwords from becoming unbearably long. If you increase these values,
    the passwords change quite drastically:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`--min_word_len` 参数有助于过滤掉像“a”，“I”，“an”，“of”等较短、不太有趣的单词，而 `--max_word_len` 参数防止密码变得过长。如果你增加这些值，密码会有很大的变化：'
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `--l33t` flag is a nod to “leet”-speak, where `31337` `H4X0R` means “ELITE
    HACKER”.[1](#pgfId-1013514) When this flag is present, we’ll encode each of the
    passwords in two ways. First, we’ll pass the word through the `ransom()` algorithm
    we wrote in chapter 12:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`--l33t` 标志是对“leet”-speak的一种致敬，其中 `31337` `H4X0R` 代表“ELITE HACKER”。[1](#pgfId-1013514)
    当这个标志存在时，我们将以两种方式对每个密码进行编码。首先，我们将通过我们在第12章中编写的 `ransom()` 算法传递单词：'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we’ll use the following substitution table to substitute characters in
    the same way we did in chapter 4:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下替换表以与第4章中相同的方式替换字符：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To cap it off, we’ll use `random.choice()` to select one character from `string.punctuation`
    to add to the end:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `random.choice()` 从 `string.punctuation` 中选择一个字符添加到末尾：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Figure 20.1 shows a string diagram that summarizes the inputs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1显示了总结输入的字符串图。
- en: 20.1.1 Creating a unique list of words
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.1 创建唯一的单词列表
- en: 'Let’s start off by making our program print the name of each input file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从让我们的程序打印每个输入文件的名称开始：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Always set random.seed() right away as it will globally affect all actions
    by the random module.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ① 总是立即设置 random.seed()，因为它将全局影响 `random` 模块的所有操作。
- en: ② Iterate through the file arguments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历文件参数。
- en: ③ Print the name of the file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打印文件名。
- en: '![](../Images/20-1.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/20-1.png)'
- en: Figure 20.1 Our program has many possible options but requires only one or more
    input files. The output will be unbreakable passwords.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1 我们程序有许多可能的选项，但只需要一个或多个输入文件。输出将是不可破解的密码。
- en: 'Let’s test it with the words.txt file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`words.txt`文件来测试它：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let’s try it with some of the other inputs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一些其他输入来试一试：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our first goal is to create a unique list of words we can use for sampling.
    So far we’ve used lists to keep ordered collections of things like strings and
    numbers. The elements in a `list` do not have to be *unique*, though. We’ve also
    used dictionaries to create key/value pairs, and the keys of a dictionary *are*
    unique. Since we don’t care about the values, we could set each key of a dictionary
    equal to some arbitrary value, like `1`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是创建一个唯一的单词列表，我们可以用它来进行抽样。到目前为止，我们使用列表来保持有序集合，如字符串和数字。列表中的元素不必是唯一的。我们也使用字典来创建键/值对，字典的键是唯一的。由于我们不在乎值，我们可以将字典的每个键设置为某个任意值，比如`1`：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Create an empty dict to hold the unique words.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个空的字典来存储唯一的单词。
- en: ② Iterate through the files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历文件。
- en: ③ Iterate through the lines of the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 遍历文件的行。
- en: ④ Lowercase the line and split it on spaces into words.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将行转换为小写并在空格处拆分为单词。
- en: ⑤ Set the key words[word] equal to 1 to indicate we saw it. We’re only using
    a dict to get the unique keys. We don’t care about the values, so you could use
    whatever value you like.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将关键字[word]的键设置为1以表示我们看到了它。我们只使用字典来获取唯一的键。我们不在乎值，所以你可以使用任何你喜欢的值。
- en: 'If you run this on the US Constitution, you should see a fairly large list
    of words (some output elided here):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这份《美国宪法》上运行它，你应该看到一个相当长的单词列表（此处省略了一些输出）：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I can spot one problem, in that the word `''states,''` has a comma attached
    to it. If we try in the REPL with the first bit of text from the Constitution,
    we can see the problem:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以注意到一个问题，即单词`'states,'`附有一个逗号。如果我们尝试在REPL中使用宪法的第一部分文本，我们可以看到这个问题：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How can we get rid of the punctuation?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何去除标点符号？
- en: 20.1.2 Cleaning the text
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.2 清理文本
- en: We’ve seen several times that splitting on spaces leaves punctuation, but splitting
    on non-word characters can break contracted words like “Don’t” in two. We’d like
    a function that will `clean()` a word.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到，在空格上拆分会留下标点符号，但在非单词字符上拆分可能会将缩写词如“Don’t”拆分成两部分。我们希望有一个函数可以对单词进行`clean()`。
- en: First let’s imagine the test for it. Note that in this exercise, I’ll put all
    my unit tests into a file called unit.py, which I can run with `pytest` `-xv`
    `unit.py`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们想象一下对这个的测试。注意，在这个练习中，我会把所有的单元测试都放在一个名为`unit.py`的文件中，我可以使用`pytest` `-xv`
    `unit.py`来运行它。
- en: 'Here is the test for our `clean()` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们`clean()`函数的测试：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① It’s always good to test your functions on nothing, just to make sure it does
    something sane.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ① 总是测试你的函数在无输入的情况下，以确保它做了合理的事情。
- en: ② The function should remove punctuation at the end of a string.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ② 函数应该移除字符串末尾的标点符号。
- en: ③ The function should not split a contracted word in two.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 函数不应该将缩写词拆分成两部分。
- en: I would like to apply this to all the elements returned by splitting each line
    into words, and `map()` is a fine way to do that. We often use a `lambda` when
    writing `map()`, as in figure 20.2.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我想将此应用于将每一行拆分为单词后返回的所有元素，`map()`是一个很好的方法来做这件事。我们经常在编写`map()`时使用`lambda`，如图20.2所示。
- en: '![](../Images/20-2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/20-2.png)'
- en: Figure 20.2 Writing `map()` using a `lambda` to accept each word from splitting
    a string
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.2 使用`lambda`编写`map()`以接受从字符串拆分得到的每个单词
- en: We don’t actually need to write a `lambda` for `map()` here because the `clean()`
    function expects a single argument, as shown in figure 20.3.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不需要为`map()`编写`lambda`，因为`clean()`函数期望一个单一参数，如图20.3所示。
- en: '![](../Images/20-3.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/20-3.png)'
- en: Figure 20.3 Writing the `map()` without the `lambda` because the function expects
    a single value
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.3 不使用`lambda`编写`map()`，因为函数期望一个单一值
- en: 'See how it integrates with the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看看它是如何与代码集成的：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Use map() to apply the clean() function to the results of splitting the line
    on spaces. No lambda is required because clean() expects a single argument.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用`map()`将`clean()`函数应用于在空格上拆分行的结果。不需要`lambda`，因为`clean()`期望一个单一参数。
- en: 'If we run that on the US Constitution again, we can see that `''states''` has
    been fixed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次在《美国宪法》上运行它，我们可以看到`'states'`已经被固定：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I’ll leave it to you to write a `clean()` function that will satisfy that test.
    You might use a list comprehension, a `filter()`, or maybe a regular expression.
    The choice is yours, so long as it passes the test.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个任务留给你来编写一个 `clean()` 函数，以满足那个测试。你可能可以使用列表推导式、`filter()` 或可能是一个正则表达式。选择权在你，只要它通过测试即可。
- en: 20.1.3 Using a set
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.3 使用集合
- en: 'There is a better data structure than a `dict` to use for our purposes here.
    It’s called a `set`, and you can think of it as being like a unique `list` or
    just the keys of a `dict`. Here is how we could change our code to use a `set`
    to keep track of *unique* words:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，有一个比 `dict` 更好的数据结构。它被称为 `set`，你可以把它想象成一个唯一的 `list` 或 `dict` 的键。以下是我们可以如何更改我们的代码以使用
    `set` 来跟踪 *唯一* 单词的示例：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Use the set() function to create an empty set.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 `set()` 函数创建一个空集合。
- en: ② Use set.add() to add a value to a set.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 `set.add()` 向集合中添加一个值。
- en: 'If you run this code now, you will see slightly different output, where Python
    shows you a data structure in curly brackets (`{}`) that will make you think of
    a `dict`, but you’ll notice that the contents look more like a `list` (as pointed
    out in figure 20.4):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这段代码，你会看到略微不同的输出，Python 会用花括号 (`{}`) 显示一个数据结构，这会让你想到 `dict`，但你也会注意到内容看起来更像一个
    `list`（如图 20.4 所示）：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/20-4.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 20.4](../Images/20-4.png)'
- en: Figure 20.4 A set looks like a cross between a dictionary and a list.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.4 集合看起来像是字典和列表的交叉。
- en: 'We’re using sets here because they so easily allow us to keep a unique list
    of words, but sets are much more powerful than this. For instance, you can find
    the shared values between two lists by using `set.intersection()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用集合，因为它们可以很容易地让我们保持一个唯一的单词列表，但集合的功能远不止于此。例如，你可以通过使用 `set.intersection()`
    来找到两个列表之间的共享值：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can read `help(set)` in the REPL or in the documentation online to learn
    about all the amazing things you can do with sets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 REPL 或在线文档中阅读 `help(set)` 来了解你可以用集合做所有惊人的事情。
- en: 20.1.4 Filtering the words
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.4 过滤单词
- en: 'If we look again at the output we have, we’ll see that the empty string is
    the first element:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看我们的输出，我们会看到空字符串是第一个元素：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We need a way to filter out unwanted values like strings that are too short.
    In chapter 14 we looked at the `filter()` function, which is a higher-order function
    that takes two arguments:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来过滤掉不想要的值，比如太短的字符串。在第 14 章中，我们研究了 `filter()` 函数，它是一个高阶函数，它接受两个参数：
- en: A function that accepts one element and returns `True` if the element should
    be kept or `False` if the element should be excluded
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受一个元素并返回 `True`（如果元素应该被保留）或 `False`（如果元素应该被排除）的函数
- en: Some “iterable” (like a `list` or `map()`) that produces a sequence of elements
    to be filtered
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些“可迭代”对象（如 `list` 或 `map()`），它产生一系列要过滤的元素
- en: 'In our case, we want to accept only words that have a length greater than or
    equal to the `--min_word_len` argument, and less than or equal to `--max_word_len`.
    In the REPL, we can use a `lambda` to create an anonymous function that accepts
    a `word` and makes these comparisons. The result of that comparison is either
    `True` or `False`. Only words with a length from 3 to 6 are allowed, so this has
    the effect of removing short, uninteresting words. Remember that `filter()` is
    lazy, so I have to coerce it using the `list` function in the REPL to see the
    output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只想接受长度大于或等于 `--min_word_len` 参数且小于或等于 `--max_word_len` 参数的单词。在 REPL
    中，我们可以使用 `lambda` 创建一个匿名函数，该函数接受一个 `word` 并进行这些比较。比较的结果是 `True` 或 `False`。只有长度在
    3 到 6 之间的单词是被允许的，因此这起到了移除短且无趣单词的作用。记住，`filter()` 是惰性的，所以我必须使用 REPL 中的 `list` 函数来强制转换它以查看输出：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This `filter()` will also remove longer words that would make our passwords
    cumbersome:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `filter()` 也会移除会使我们的密码变得繁琐的较长的单词：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One way we could incorporate the `filter()` is to create a `word_len()` function
    that encapsulates the preceding `lambda`. Note that I defined it inside `main()`
    in order to create a *closure*, because I want to reference the values of `args.min_word_len`
    and `args.max_word_len`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合 `filter()` 的一种方法是通过创建一个 `word_len()` 函数来封装前面的 `lambda`。请注意，我将其定义在 `main()`
    内部，是为了创建一个 *闭包*，因为我想要引用 `args.min_word_len` 和 `args.max_word_len` 的值：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① This function will return True if the length of the given word is in the allowed
    range.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果给定单词的长度在允许的范围内，这个函数将返回 `True`。
- en: ② We can use word_len (without the parentheses!) as the function argument to
    filter().
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们可以将 `word_len`（不带括号）用作 `filter()` 的函数参数。
- en: 'We can again try our program to see what it produces:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次尝试我们的程序，看看它会产生什么：
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Try it on multiple inputs, such as all the nouns, adjectives, and verbs from
    *The Scarlet Letter*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个输入上尝试，例如来自《红字》的所有名词、形容词和动词：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| ![](../Images/20-unnumb-2.png)  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/20-unnumb-2.png) |'
- en: 20.1.5 Titlecasing the words
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.5 将单词大写
- en: We used the `line.lower()` function to lowercase all the input, but the passwords
    we generate will need each word to be in “Title Case,” where the first letter
    is uppercase and the rest of the word is lowercase. Can you figure out how to
    change the program to produce this output?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`line.lower()`函数将所有输入转换为小写，但生成的密码需要每个单词都使用“标题大小写”，即第一个字母大写，其余单词小写。你能想出如何更改程序以生成这种输出吗？
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we have a way to process any number of files to produce a unique list of
    title-cased words that have non-word characters removed and have been filtered
    to remove the ones that are too short or long. That’s quite a lot of power packed
    into a few lines of code!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种方法来处理任意数量的文件，以生成一个独特的标题化单词列表，其中已移除非单词字符，并已过滤掉太短或太长的单词。这只是在几行代码中打包了相当多的功能！
- en: 20.1.6 Sampling and making a password
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.6 采样并创建密码
- en: We’re going to use the `random.sample()` function to randomly choose `--num`
    number of words from our `set` to create an unbreakable, yet memorable, password.
    We’ve talked before about the importance of using a random seed to test that our
    “random” selections are reproducible. It’s also quite important that the items
    from which we sample always be ordered in the same way so that the same selections
    are made. If we use the `sorted()` function on a `set`, we get back a sorted `list`,
    which is perfect for using with `random.sample()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`random.sample()`函数从我们的`set`中随机选择`--num`数量的单词来创建一个不可破解但易于记忆的密码。我们之前已经讨论过使用随机种子的重要性，以确保我们的“随机”选择是可重复的。同样重要的是，从其中采样的项目总是以相同的方式排序，以便做出相同的选择。如果我们对`set`使用`sorted()`函数，我们会得到一个排序后的`list`，这对于与`random.sample()`一起使用是完美的。
- en: 'We can add this line to the code from before:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此行添加到之前的代码中：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now when I run the program with *The Scarlet Letter* input, I will get a list
    of words that might make an interesting password:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我用`The Scarlet Letter`作为输入运行程序，我会得到一个可能有趣的密码的单词列表：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result of `random.sample()` is a `list` that you can join on the empty
    string in order to make a new password:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`random.sample()`的结果是一个`list`，您可以通过空字符串将其连接起来以创建一个新的密码：'
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will need to create the number of passwords indicated by the user, similar
    to how we created some number of insults in chapter 9\. How will you do that?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建用户指示的密码数量，类似于我们在第9章中创建的一些侮辱性词汇。您将如何做到这一点？
- en: 20.1.7 l33t-ify
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.7 l33t-ify
- en: 'The last piece of our program involves creating an `l33t()` function that will
    obfuscate the password. The first step is to convert the password with the same
    algorithm we wrote for ransom.py. I’m going to create a `ransom()` function for
    this, and here is the test that is in unit.py:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的最后一部分是创建一个`l33t()`函数，该函数将混淆密码。第一步是将密码转换为与我们在`ransom.py`中编写的相同算法。我将为这个创建一个`ransom()`函数，这里是`unit.py`中的测试：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① Save the current global state.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ① 保存当前的全球状态。
- en: ② Set random.seed() to a known value for the test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将`random.seed()`设置为测试中已知的值。
- en: ③ Restore the state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 恢复状态。
- en: I’ll leave it to you to create the function that satisfies this test.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个任务留给你来创建满足这个测试的函数。
- en: Note You can run `pytest` `-xv` `unit.py` to run the unit tests. The program
    will import the various functions from your password.py file to test. Open unit.py
    and inspect it to understand how this happens.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以通过运行`pytest -xv unit.py`来执行单元测试。程序将导入您的`password.py`文件中的各种函数进行测试。打开`unit.py`并检查它，以了解这是如何发生的。
- en: 'Next I will replace some of the characters according to the following table.
    I recommend you revisit chapter 4 to see how you did that:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将根据以下表格替换一些字符。我建议您重新阅读第4章，看看您是如何做到这一点的：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I wrote an `l33t()` function that combines `ransom()` with the preceding substitution
    and then adds a punctuation character by appending `random.choice(string.punctuation)`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个`l33t()`函数，该函数结合了`ransom()`函数和前面的替换操作，然后通过追加`random.choice(string.punctuation)`来添加一个标点符号。
- en: 'Here is the `test_l33t()` function you can use to write your function. It works
    almost identically to the previous test, so I shall eschew commentary:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您可以使用来编写您函数的`test_l33t()`函数。它几乎与之前的测试完全相同，所以我将省略注释：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 20.1.8 Putting it all together
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1.8 将所有内容组合在一起
- en: 'Without giving away the ending, I’d like to say that you need to be *really
    careful* about the order of operations that include the `random` module. My first
    implementation would print different passwords given the same seed when I used
    the `--l33t` flag. Here was the output for plain passwords:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不透露结局，我想说的是，你需要非常小心包含 `random` 模块的运算顺序。在我的第一次实现中，当使用 `--l33t` 标志时，给定相同的种子会打印出不同的密码。以下是普通密码的输出：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'I would have expected the *exact same passwords*, only encoded. Here is what
    my program produced instead:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我原本期望得到的是完全相同的密码，只是进行了编码。以下是我程序产生的结果：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first password looks OK, but what are those other two? I modified my code
    to print both the original password and the l33ted one:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个密码看起来没问题，但那另外两个是什么？我修改了我的代码来打印原始密码和 `l33ted` 版本：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `random` module uses a global state to make each of its “random” choices.
    In my first implementation, I was modifying this state after choosing the first
    password by immediately modifying the new password with the `l33t()` function.
    Because the `l33t()` function also uses `random` functions, the state was altered
    for the next password. My solution was to first generate *all* the passwords and
    then alter them using the `l33t()` function, if necessary.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 模块使用全局状态来使其每个“随机”选择。在我的第一次实现中，我在选择第一个密码后立即使用 `l33t()` 函数修改新密码，从而修改了这个状态。因为
    `l33t()` 函数也使用 `random` 函数，所以状态被改变，影响了下一个密码。我的解决方案是首先生成所有密码，然后如果需要，使用 `l33t()`
    函数修改它们。'
- en: Those are all the pieces you should need to write your program. You have the
    unit tests to help you verify the functions, and you have the integration tests
    to ensure your program works as a whole.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你编写程序所需的所有部分。你有单元测试来帮助验证函数，你还有集成测试来确保你的程序作为一个整体工作。
- en: 20.2 Solution
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.2 解决方案
- en: I hope you will use your program to generate your passwords. Be sure to share
    them with your author, especially the ones to your bank account and favorite shopping
    sites!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你会使用你的程序来生成你的密码。务必与你的作者分享它们，特别是那些用于银行账户和最喜欢的购物网站的密码！
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ① Set the random.seed() to the given value or the default None, which is the
    same as not setting the seed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 `random.seed()` 设置为给定的值或默认的 `None`，这与不设置种子相同。
- en: ② Create an empty set to hold all the unique words we’ll extract from the texts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个空集合来存储我们从文本中提取的所有唯一单词。
- en: ③ Create a word_len() function for filter() that returns True if the word’s
    length is in the allowed range and False otherwise.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为 `filter()` 创建一个 `word_len()` 函数，如果单词的长度在允许的范围内则返回 `True`，否则返回 `False`。
- en: ④ Iterate through each open file handle.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 遍历每个打开的文件句柄。
- en: ⑤ Iterate through each line of text in the file handle.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 遍历文件句柄中的每一行文本。
- en: ⑥ Iterate through each word generated by splitting the lowercased line on spaces,
    removing non-word characters with the clean() function, and filtering for words
    of an acceptable length.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 遍历由分割小写行并使用 `clean()` 函数移除非单词字符以及过滤出可接受长度的单词生成的每个单词。
- en: ⑦ Title-case the word before adding it to the set.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在将单词添加到集合之前将其转换为标题大小写。
- en: ⑧ Use the sorted() function to order words into a new list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用 `sorted()` 函数将单词排序到一个新的列表中。
- en: ⑨ Use a list comprehension with a range to create the correct number of passwords.
    Since I don’t need the actual value from range, I can use _ to ignore the value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 使用列表推导式和 `range()` 创建正确数量的密码。由于我不需要 `range()` 的实际值，我可以使用 `_` 来忽略它。
- en: ⑩ See if the args.l33t flag is True.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 检查 `args.l33t` 标志是否为 `True`。
- en: ⑪ Use map() to run all the passwords through the l33t() function to produce
    a new list of passwords. It’s safe to call the l33t() function here. If we had
    used the function in the list comprehension, it would have altered the global
    state of the random module, thereby altering the following passwords.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 使用 `map()` 运行所有密码通过 `l33t()` 函数，以产生一个新的密码列表。在这里调用 `l33t()` 函数是安全的。如果我们使用它在列表推导式中，它将改变随机模块的全局状态，从而改变后续的密码。
- en: ⑫ Print the passwords joined on newlines.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 打印在新行上连接的密码。
- en: ⑬ Define a function to clean() a word.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 定义一个 `clean()` 函数来清理单词。
- en: ⑭ Use a regular expression to substitute the empty string for anything that
    is not an English alphabet character.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 使用正则表达式将非英文字母字符替换为空字符串。
- en: ⑮ Define a function to l33t() a word.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 定义一个 `l33t()` 函数来转换单词。
- en: ⑯ Use the ransom() function to randomly capitalize letters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 使用 `ransom()` 函数随机大写字母。
- en: ⑰ Make a translation table/dict for character substitutions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 创建一个用于字符替换的转换表/字典。
- en: ⑱ Use the str.translate() function to perform the substitutions and append a
    random piece of punctuation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 使用str.translate()函数执行替换，并附加一个随机的标点符号。
- en: ⑲ Define a function for the ransom() algorithm from chapter 12.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ⑲ 定义一个函数，用于从第12章的ransom()算法。
- en: ⑳ Return a new string created by randomly upper- or lowercasing each letter
    in a word.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ⑳ 返回一个新字符串，该字符串通过随机将每个单词中的字母大写或小写来创建。
- en: 20.3 Discussion
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.3 讨论
- en: I hope you found this program challenging and interesting. There wasn’t anything
    new in `get_args()`, but, again, about half the lines of code are found just in
    this function. I feel this is indicative of just how important it is to correctly
    define and validate the inputs to a program!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您觉得这个程序具有挑战性和趣味性。`get_args()`中没有什么新内容，但，再次强调，大约一半的代码行都只在这个函数中。我觉得这表明正确定义和验证程序输入是多么重要！
- en: Now, let’s get on with talking about the auxiliary functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论辅助函数。
- en: 20.3.1 Cleaning the text
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3.1 清理文本
- en: 'I chose to use a regular expression to remove any characters that are outside
    the set of lower- and uppercase English characters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用正则表达式来删除任何不在大小写英文字符集合之外的字符：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① The re.sub() function will substitute any text matching the pattern (the first
    argument) found in the given text (the third argument) with the value given by
    the second argument.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ① re.sub()函数将用第二个参数给出的值替换在给定文本中找到的与模式（第一个参数）匹配的任何文本。
- en: Recall from chapter 18 that we can write the character class `[a-zA-Z]` to define
    the characters in the ASCII table bounded by those two ranges. We can then *negate*
    or complement that class by placing a caret (`^`) as the *first character* inside
    that class, so `[^a-zA-Z]` can be read as “any character not matching a to z or
    A to Z.”
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第18章，我们可以编写字符类`[a-zA-Z]`来定义ASCII表中由这两个范围限定的字符。然后我们可以通过在该类内部放置一个感叹号（`^`）来*否定*或补充该类，所以`[^a-zA-Z]`可以读作“任何不匹配a到z或A到Z的字符。”
- en: 'It’s perhaps easier to see it in action in the REPL. In the following example,
    only the letters “AbCd” will be left from the text “A1b*C!d4”:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中看到它的实际操作可能更容易理解。在下面的例子中，从文本“A1b*C!d4”中只会留下字母“AbCd”：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the only goal were to match ASCII letters, it would be possible to solve
    it by looking for membership in `string.ascii_letters`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果唯一的目标是匹配ASCII字母，可以通过查找`string.ascii_letters`中的成员资格来解决它：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A list comprehension with a guard can also be written using `filter()`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用带有守卫器的列表推导式来编写`filter()`：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Both of the non-regex versions seem like more effort to me. Additionally, if
    the function ever needed to be changed to allow, say, numbers and a few specific
    pieces of punctuation, the regular expression version becomes significantly easier
    to write and maintain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种非正则表达式版本在我看来似乎需要更多的努力。此外，如果函数需要更改以允许，例如，数字和几个特定的标点符号，正则表达式版本就变得更容易编写和维护。
- en: 20.3.2 A king’s ransom
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3.2 一笔巨款
- en: 'The `ransom()` function was taken straight from the ransom.py program in chapter
    12, so there isn’t too much to say about it except, hey, look how far we’ve come!
    What was the idea for an entire chapter is now a single line in a much longer
    and more complicated program:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ransom()`函数直接从第12章的ransom.py程序中提取，所以关于它没有太多可说的，除了，嘿，看看我们走了多远！原本一个整章的想法现在在一个更长、更复杂的程序中只是一行：'
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ① Join the resulting list from the map() on the empty string to create a new
    string.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用空字符串将map()的结果列表连接起来，创建一个新的字符串。
- en: ② Use map() to iterate through each character in the text and select either
    the upper- or lowercase version of the character based on a “coin toss,” using
    random.choice() to select between a “truthy” value (1) or a “falsey” value (0).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用map()遍历文本中的每个字符，并根据“抛硬币”的结果选择字符的大写或小写版本，使用random.choice()在“真值”（1）或“假值”（0）之间进行选择。
- en: 20.3.3 How to l33t()
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3.3 如何l33t()
- en: 'The `l33t()` function builds on `ransom()` and then adds a text substitution
    that is straight out of chapter 4\. I like the `str.translate()` version of that
    program, so I used it again here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`l33t()`函数基于`ransom()`并添加了来自第4章的直接文本替换。我喜欢那个程序的`str.translate()`版本，所以我在这里再次使用了它：'
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ① Randomly capitalize the given text.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ① 随机大写给定的文本。
- en: ② Make a translation table from the given dict that describes how to modify
    one character to another. Any characters not listed in the keys of this dict will
    be ignored.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从给定的字典中创建一个转换表，描述如何将一个字符修改为另一个字符。任何未列在该字典键中的字符将被忽略。
- en: ③ Use the str.translate() method to make all the character substitutions. Use
    random.choice() to select one additional character from string.punctuation to
    append to the end.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用str.translate()方法进行所有字符替换。使用random.choice()从string.punctuation中选择一个额外的字符附加到末尾。
- en: 20.3.4 Processing the files
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3.4 处理文件
- en: 'To use these functions, we need to create a unique set of all the words in
    our input files. I wrote this bit of code with an eye both on performance and
    on style:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些函数，我们需要创建一个包含我们输入文件中所有单词的唯一集合。我写这段代码时既关注性能也关注风格：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ① Iterate through each open file handle.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ① 遍历每个打开的文件句柄。
- en: ② Read the file handle line by line with a for loop, not with a method like
    fh.read(), which will read the entire contents of the file at once.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用for循环逐行读取文件句柄，而不是使用像fh.read()这样的方法，它会一次性读取文件的全部内容。
- en: ③ Reading this code requires starting at the end where I split line.lower()
    on spaces. Each word from str.split() goes into clean(), which then must pass
    through the filter() function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 阅读此代码需要从末尾开始，我在那里按空格分割line.lower()。str.split()中的每个单词都进入clean()，然后必须通过filter()函数。
- en: ④ Title-case the word before adding it to the set.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在将单词添加到集合之前将其转换为标题格式。
- en: Figure 20.5 shows a diagram of that `for` line.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.5显示了该`for`行的示意图。
- en: '`line.lower()` will return a lowercase version of `line`.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`line.lower()`将返回`line`的小写版本。'
- en: The `str.split()` method will break the text on whitespace to return words.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str.split()`方法将根据空白字符分割文本以返回单词。'
- en: Each word is fed into the `clean()` function to remove any character that is
    not in the English alphabet.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个单词都输入到`clean()`函数中，以删除任何不在英语字母表中的字符。
- en: The cleaned words are filtered by the `word_len()` function.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清洗后的单词通过`word_len()`函数进行过滤。
- en: The resulting `word` has been transformed, cleaned, and filtered.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的`word`已经过转换、清洗和过滤。
- en: '![](../Images/20-5.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/20-5.png)'
- en: Figure 20.5 A visualization of the order of operations for the various functions
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.5展示了各种函数操作顺序的可视化。
- en: 'If you don’t like the `map()` and `filter()` functions, you might rewrite the
    code like so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢`map()`和`filter()`函数，你可以这样重写代码：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ① Iterate through each open file handle.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ① 遍历每个打开的文件句柄。
- en: ② Iterate through each line of the file handle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历文件句柄的每一行。
- en: ③ Iterate through each “word” from splitting the lowercased line on spaces.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 遍历从按空格分割小写行得到的每个“单词”。
- en: ④ Remove unwanted characters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 移除不需要的字符。
- en: ⑤ Check if the word is an acceptable length.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 检查单词是否为可接受的长度。
- en: ⑥ Add the title-cased word to the set.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将标题格式的单词添加到集合中。
- en: However you choose to process the files, at this point you should have a complete
    `set` of all the unique, title-cased words from the input files.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择如何处理文件，到这一点你应该有一个包含输入文件中所有唯一、标题格式单词的完整`set`。
- en: 20.3.5 Sampling and creating the passwords
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3.5 抽样和创建密码
- en: 'As noted earlier, it’s vital to sort the `words` for our tests so that we can
    verify that we are making consistent choices. If you only wanted random choices
    and didn’t care about testing, you would not need to worry about sorting--but
    then you’d also be a morally deficient person for not testing, so perish the thought!
    I chose to use the `sorted()` function, as there is no other way to sort a `set`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了验证我们正在做出一致的选择，对`words`进行排序对于我们的测试至关重要。如果你只想随机选择而不关心测试，你不需要担心排序——但如果你不测试，那么你就是一个道德上有缺陷的人，所以不要想这个！我选择使用`sorted()`函数，因为没有其他方法可以排序`set`：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ① There is no set.sort() function. Sets are ordered internally by Python. Calling
    sorted() on a set will create a new, sorted list.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ① 没有set.sort()函数。集合在Python内部是有序的。对集合调用sorted()将创建一个新的、排序后的列表。
- en: We need to create a given number of passwords, and I thought it might be easiest
    to use a `for` loop with a `range()`. In my code, I used `for` `_` `in` `range(...)`
    just as in chapter 9 because I don’t need to know the value each time through
    the loop. The underscore (`_`) is a way to indicate that you are ignoring the
    value. It’s fine to say `for` `i` `in` `range(...)` if you want, but some linters
    might complain if they see that your code declares the variable `i` but never
    uses it. That could legitimately be a bug, so it’s best to use the `_` to show
    that you mean to ignore this value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一定数量的密码，我认为使用带有`range()`的`for`循环可能最简单。在我的代码中，我使用了`for _ in range(...)`，就像在第9章中一样，因为我每次通过循环不需要知道值。下划线（`_`）是一种表示你正在忽略值的方式。如果你想，可以说`for
    i in range(...)`，但一些linters可能会抱怨，如果看到你的代码声明了变量`i`但从未使用它。这可能是真正的错误，所以最好使用`_`来表明你打算忽略这个值。
- en: Here is the first way I wrote the code that led to the bug I mentioned earlier,
    where different passwords would be chosen even when I used the same random seed.
    Can you spot the bug?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是导致我之前提到的错误的代码的第一种写法，即使我使用了相同的随机种子，也会选择不同的密码。你能找到错误吗？
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ① Iterate through the args.num of passwords to create.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ① 遍历要创建的args.num个密码。
- en: ② Each password will be based on a random sampling from words, and I will choose
    the value given in args.num_words. The random.sample() function returns a list
    of words that I str.join() on the empty string to create a new string.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ② 每个密码将基于从单词中随机采样生成，我将选择args.num_words中给出的值。random.sample()函数返回一个单词列表，我使用str.join()在空字符串上连接这些单词以创建一个新的字符串。
- en: ③ If the args.l33t flag is True, we’ll print the l33t version of the password;
    otherwise, I’ll print the password as is. This is the bug! Calling l33t() here
    modifies the global state used by the random module, so the next time I call random.sample(),
    I get a different sample.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果args.l33t标志为True，我们将打印密码的l33t版本；否则，我将按原样打印密码。这是错误！在这里调用l33t()修改了随机模块使用的全局状态，所以下次我调用random.sample()时，我会得到不同的样本。
- en: 'The solution is to separate the concerns of generating the passwords and possibly
    modifying them:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将生成密码和可能修改密码的关注点分开：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ① Use a list comprehension to iterate through range(args.num) to generate the
    correct number of passwords.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用列表推导式遍历range(args.num)以生成正确数量的密码。
- en: ② If the args.leet flag is True, use the l33t() function to modify the passwords.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果args.leet标志为True，使用l33t()函数修改密码。
- en: ③ Print the passwords joined on newlines.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打印以换行符连接的密码。
- en: 20.4 Going further
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20.4 进一步学习
- en: The substitution part of the `l33t()` function changes every available character,
    which perhaps makes the password too difficult to remember. It would be better
    to modify only maybe 10% of the password, much like how we changed the input strings
    in chapter 10’s Telephone exercise.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l33t()`函数的替换部分会更改每个可用的字符，这可能会使密码难以记住。最好只修改密码的约10%，就像我们在第10章的“电话”练习中更改输入字符串那样。'
- en: Create programs that combine other skills you’ve learned. Like maybe a lyrics
    generator that randomly selects lines from files of songs by your favorite bands,
    then encodes the text as in chapter 15, then changes all the vowels to one vowel
    as in chapter 8, and then SHOUTS IT OUT as in chapter 5?
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建结合你所学其他技能的程序。比如，可能是一个歌词生成器，它会随机选择你最喜欢的乐队歌曲文件中的歌词，然后将文本编码成第15章所述的形式，接着将所有元音字母都改为一个元音字母，就像第8章中做的那样，最后像第5章中那样大声喊出来？
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A `set` is a unique collection of values. Sets can interact with other sets
    to create differences, intersections, unions, and more.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`是一个唯一的值集合。集合可以与其他集合交互以创建差异、交集、并集等。'
- en: Changing the order of operations using the `random` module can change the output
    of a program because the global state of the `random` module may be affected.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`random`模块改变操作顺序可能会改变程序输出，因为`random`模块的全局状态可能会受到影响。
- en: Short, tested functions can be composed to create more complicated, tested programs.
    Here we combined many ideas from previous exercises in concise, powerful expressions.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短小、经过测试的函数可以组合成更复杂、经过测试的程序。在这里，我们以简洁、强大的表达方式结合了之前练习中的许多想法。
- en: '| ![](../Images/20-unnumb-3.png)  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/20-unnumb-3.png)  |'
- en: '* * *'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1 See the “Leet” Wikipedia page ([https://en.wikipedia.org/wiki/Leet](https://en.wikipedia.org/wiki/Leet))
    or the Cryptii translator [https://cryptii .com/](https://cryptii.com/).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 1 请参阅“Leet”维基百科页面([https://en.wikipedia.org/wiki/Leet](https://en.wikipedia.org/wiki/Leet))或Cryptii翻译器[https://cryptii.com/](https://cryptii.com/).
