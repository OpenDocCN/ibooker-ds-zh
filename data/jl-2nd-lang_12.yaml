- en: 10 Representing unknown values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 表示未知值
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding how undefined values are used
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用未定义的值
- en: Representing the absence of a value with the Nothing type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nothing类型表示值的缺失
- en: Dealing with values that exist but are unknown using the Missing type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Missing类型处理存在但未知的值
- en: 'Something important to deal with in any programming language is representing
    the absence of a value. For a long time, most mainstream programming languages,
    such as C/C++, Java, C#, Python, and Ruby, had a value called null or nil, which
    is what a variable would contain if it did not have any value. More accurately
    phrased: null or nil indicates that a variable is not bound to a concrete object.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中处理的一个重要问题是表示值的缺失。长期以来，大多数主流编程语言，如C/C++、Java、C#、Python和Ruby，都有一个名为null或nil的值，这是变量在没有值时可能包含的内容。更准确地说：null或nil表示变量没有绑定到具体对象。
- en: 'When would this be useful? Let’s use Julia’s findfirst function as an example.
    It locates the first occurrence of a substring:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这在什么情况下会有用？让我们以Julia的findfirst函数为例。它定位子串的第一个出现：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Substring hello found.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 找到子串hello。
- en: ❷ Substring foo not found.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 未找到子串foo。
- en: But how do you indicate that a substring cannot be found? Languages such as
    Java, C#, and Python would use the null or nil keywords to indicate this. However,
    it is not without reason its inventor, British computer scientist Tony Hoare,
    called the null pointer his billion-dollar mistake.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何表示找不到子串呢？像Java、C#和Python这样的语言会使用null或nil关键字来表示这一点。然而，它的发明者，英国计算机科学家Tony Hoare，称null指针是他的十亿美元错误，并非没有原因。
- en: It makes it difficult to write safe code because any variable could be null
    at any given time. In programs written using languages supporting null, you need
    a lot of boilerplate code performing null checks. That is because it is unsafe
    to perform operations on null objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得编写安全代码变得困难，因为任何变量在任何给定时间都可能为null。在支持null的语言编写的程序中，你需要大量的样板代码来执行null检查。这是因为对null对象执行操作是不安全的。
- en: For this reason, modern languages have tended to avoid having null objects or
    pointers. Julia does not have a generic null object or pointer. Instead, it has
    a variety of types representing unknown or absent values. This chapter will teach
    you more about these different types, how to use them, and when to use them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代语言倾向于避免有null对象或指针。Julia没有通用的null对象或指针。相反，它有各种类型来表示未知或缺失的值。本章将向您介绍这些不同类型，如何使用它们以及何时使用它们。
- en: 10.1 The nothing object
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 nothing对象
- en: The closest thing to null Julia has, is the nothing object of type Nothing.
    It is a simple concrete type defined in Julia, as shown in the following listing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中最接近null的对象是Nothing类型的nothing对象。它是在Julia中定义的一个简单具体类型，如下所示。
- en: Listing 10.1 Nothing type and nothing constant as defined by Julia
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 Julia定义的Nothing类型和nothing常量
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The nothing object is an instance of the type Nothing. However, every instance
    of Nothing is the same object. You can test that yourself in the REPL:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: nothing对象是类型Nothing的一个实例。然而，Nothing的每个实例都是同一个对象。您可以在REPL中自行测试：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, there is *nothing* magical going on here. When you call the constructor
    of a composite type with zero fields, you always get the same object returned.
    To state this in more formal terms: for a type T with no fields, every instance
    t of type T is the same object. This example should help clarify:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里并没有什么神奇的事情发生。当你用零字段调用复合类型的构造函数时，你总是得到相同的对象返回。用更正式的话来说：对于没有字段的类型T，类型T的每个实例t都是同一个对象。以下示例应该有助于澄清：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instances of different empty composite types are, however, considered different.
    Hence Empty() does not return the same object as Nothing():'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不同空复合类型的实例被认为是不同的。因此，Empty()返回的对象与Nothing()不同：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Empty composite types make it easy to make special-purpose objects in Julia,
    which you want to assign special meaning. By convention, Julia uses nothing to
    indicate that something could not be found or does not exist:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 空复合类型使得在Julia中创建具有特殊意义的专用对象变得容易。按照惯例，Julia使用nothing来表示某物找不到或不存在：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 10.2 Using nothing in data structures
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 在数据结构中使用nothing
- en: The multistage rocket is similar to a more generic data structure called a *linked-list*.
    Just like with the rocket example, it can often be useful to chain together multiple
    objects. You could, for example, use this to represent a train made up of multiple
    wagons holding some cargo. The following definition will not work. Can you determine
    why?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 多级火箭类似于一个更通用的数据结构，称为 *链表*。就像火箭的例子一样，将多个对象链接起来通常很有用。例如，你可以使用它来表示由多个车厢组成的火车，这些车厢承载着一些货物。以下定义将不会工作。你能确定为什么吗？
- en: Listing 10.2 Defining an infinite train
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 定义一个无限火车
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Tons of cargo in the train wagon
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 火车车厢中有大量的货物
- en: ❷ The next wagon linked to this one
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 链接到这个车厢的下一节车厢
- en: ❸ Calculate the total cargo in all wagons.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算所有车厢中的总货物量。
- en: 'There is no way of building a train made out of these wagons with the definition
    we have given. I’ll clarify with an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '使用我们给出的定义，无法构建由这些车厢组成的火车。我将通过一个例子来澄清：I’ll clarify with an example:'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is no way to end this chain of wagons. Every Wagon constructor requires
    a wagon object as its second argument. To illustrate an infinite chain of wagons
    I inserted .... in the code example. The next field always has to be a Wagon.
    But what if you made Wagon an abstract type instead? That is one possible solution,
    which was already employed in the multistage rocket example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无法结束这列车厢的链条。每个 Wagon 构造函数都需要一个车厢对象作为其第二个参数。为了说明无限车厢链条，我在代码示例中插入了 ....。下一个字段始终必须是一个
    Wagon。但如果你将 Wagon 设为一个抽象类型呢？这是可能的解决方案之一，这已经在多级火箭的例子中得到了应用。
- en: Remember, not every Rocket subtype had a next stage field. However, in this
    chapter I will introduce a more generic solution to this problem, utilizing *parametric
    types*. This will just cover the basics, since chapter 18 is completely devoted
    to parametric types.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，并非每个 Rocket 子类型都有一个下一阶段字段。然而，在本章中，我将介绍一个更通用的解决方案来解决这个问题，利用 *参数化类型*。这只是为了介绍基础知识，因为第
    18 章完全致力于参数化类型。
- en: Important Parametric types may look like an add-on feature only of interest
    to advanced Julia programmers. However, I have deliberately minimized usage of
    parametric types in the code examples. Real-world Julia code uses parametric types
    extensively. Parametric types are crucial for type correctness, performance, and
    reducing code duplication.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要参数化类型可能看起来只是对高级 Julia 程序员有吸引力的附加功能。然而，我故意在代码示例中尽量减少参数化类型的使用。现实世界的 Julia 代码广泛使用参数化类型。参数化类型对于类型正确性、性能和减少代码重复至关重要。
- en: 10.2.1 What is a parametric type?
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 参数化类型是什么？
- en: 'You were exposed to parametric types when I defined ranges and pairs. If P{T}
    is a parametric type P, then T is the type parameter. I know this sounds very
    abstract, but it will become a lot clearer with some examples:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我定义范围和配对时，你已经接触到了参数化类型。如果 P{T} 是一个参数化类型 P，那么 T 就是类型参数。我知道这听起来非常抽象，但通过一些例子，它将变得非常清晰：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Parametric type Vector with type parameter Char
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 带有 Char 类型参数的参数化类型 Vector
- en: ❷ Parametric type UnitRange with type parameter Int64
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 带有 Int64 类型参数的参数化类型 UnitRange
- en: ❸ Parametric type Rational with type parameter UInt8
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 带有 UInt8 类型参数的参数化类型 Rational
- en: You can think of Vector as a template to make an actual type. To make an actual
    concrete vector you need to know the types of the elements in the vector. In the
    first example, the type parameter is Char because each element is a character.
    For UnitRange, the type parameter represents the type of the start and end of
    the range. For Rational, the type parameter specifies the type of the nominator
    and denominator in a fraction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Vector 视为一个模板来创建一个实际类型。要创建一个具体的向量，你需要知道向量中元素的类型。在第一个例子中，类型参数是 Char，因为每个元素都是一个字符。对于
    UnitRange，类型参数表示范围的起始和结束的类型。对于 Rational，类型参数指定分数中的分子和分母的类型。
- en: 'Type parameters are to parametric types what values are to functions. You input
    a value to a function and get a value out:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数对于参数化类型，就像值对于函数。你将一个值输入到函数中，得到一个值输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You input x to function f and get value y out. One could make the same analogy
    for parametric types:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 x 输入到函数 f 中，得到值 y。对于参数化类型，可以做出相同的类比：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You input the type T to P and get the type S out. You can demonstrate this
    with some actual Julia types:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你将类型 T 输入到 P 中，得到类型 S。你可以通过一些实际的 Julia 类型来演示这一点：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Create a range type called IntRange.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个名为 IntRange 的范围类型。
- en: ❷ Make a range type based on floating-point numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 基于浮点数创建一个范围类型。
- en: ❸ Construct a range using the custom range type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用自定义范围类型构建一个范围。
- en: In this example you can see how types can be treated much like objects. You
    make new type objects and bind them to variables IntRange, FloatRange, and NumPair.
    These custom types are then used to instantiate different types of objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到类型可以被处理得像对象一样。你创建新的类型对象，并将它们绑定到变量IntRange、FloatRange和NumPair。然后使用这些自定义类型来实例化不同类型的对象。
- en: 10.2.2 Using union types to end the wagon train
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 使用联合类型结束车厢列车
- en: Union is a parametric type. You can supply it with multiple type parameters
    to construct a new type. Union types are special in that they can serve as placeholders
    for any of the types listed as type parameters. Alternatively, you can think of
    union types as a way of combining two or more types into one type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 联合是一种参数化类型。你可以提供多个类型参数来构建新的类型。联合类型是特殊的，因为它们可以作为任何列出的类型参数的占位符。或者，你可以将联合类型视为将两种或更多类型组合成一种类型的方法。
- en: 'Say you have types named T1, T2, and T3. You can create a union of these types
    by writing Union{T1, T2, T3}. This creates a new type, which can be a placeholder
    for any of those types. This means if you wrote a method with the signature f(x::Union{T1,
    T2, T3}), this particular method would get called whenever x was of type T1, T2
    or T3. Let’s look at a concrete example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有名为T1、T2和T3的类型。你可以通过编写Union{T1, T2, T3}来创建这些类型的联合。这创建了一个新类型，它可以作为任何这些类型的占位符。这意味着如果你编写了一个具有签名的f(x::Union{T1,
    T2, T3})的方法，那么每当x是T1、T2或T3类型时，这个特定的方法就会被调用。让我们看一个具体的例子：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last example fails because x is a floating-point number, and we have only
    defined a method for function f taking a union of Int and String. Float64 is not
    included.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子失败是因为x是一个浮点数，而我们只定义了一个接受Int和String联合的函数f的方法。Float64没有被包括在内。
- en: 'Every type included in a type union will be counted as a subtype of that union.
    You use the <: operator to either define a subtype or test whether a type is a
    subtype:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型联合中包含的每个类型都将被计为该联合的子类型。你使用<:运算符来定义子类型或测试类型是否为子类型：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Type parameter order does not matter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 类型参数顺序无关紧要。
- en: The ordering of type parameters in a Union definition does not matter, as shown
    by the last evaluated expression. Armed with union types you can solve your problem
    with infinite trains.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 联合定义中类型参数的顺序无关紧要，如最后评估的表达式所示。有了联合类型，你可以用无限列车解决问题。
- en: Listing 10.3 Defining a finite train
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 定义有限列车
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ The next linked wagon can be nothing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 下一个链接的车厢可以是空值。
- en: ❷ Values that are not wagons have no cargo.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 非车厢的值没有货物。
- en: 'Reload your Julia REPL, and paste in the new type definition. This code will
    allow you to create a finite chain of wagons. Notice how two cargo methods have
    been defined. You have two different cases to deal with, since next can be either
    a Wagon or nothing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载你的Julia REPL，并粘贴新的类型定义。此代码将允许你创建有限的车厢链。注意，已经定义了两种货物方法。你有两种不同的情况要处理，因为next可以是Wagon或无值：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Attempt to use 42 as the next wagon.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试将42用作下一个车厢。
- en: The last example was included to demonstrate that due to the Union definition,
    next can only be a Wagon or a Nothing object. Therefore, setting next to an integer,
    such as 42, is not legal. It causes the Julia type system to protest loudly by
    throwing an exception.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个例子包括是为了展示由于联合定义，next只能是Wagon或Nothing对象。因此，将next设置为整数，如42，是不合法的。这会导致Julia类型系统大声抗议，通过抛出异常。
- en: 10.3 Missing values
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 缺失值
- en: Missing values are represented in Julia with the missing object, which is of
    type Missing. This seems very similar to nothing, so why do you need it?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值在Julia中用缺失对象表示，其类型为Missing。这看起来与nothing非常相似，那么为什么你需要它呢？
- en: This comes about because Julia aims to be a good language for academics doing
    scientific computing, statistics, big data, and so on. In statistics, missing
    data is an important concept. It happens all the time because in almost any data
    collection for statistics there will be missing data. For instance, you may have
    a situation in which participants are filling out forms and some of them fail
    to fill out all the fields.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Julia旨在成为科学计算、统计学、大数据等学术领域的良好语言。在统计学中，缺失数据是一个重要概念。它经常发生，因为在几乎任何用于统计的数据收集中都会有缺失数据。例如，你可能遇到参与者填写表格的情况，其中一些人未能填写所有字段。
- en: Some participants may leave a study before it is finished, leaving those who
    conduct the experiment with incomplete data. Missing data can also exist due to
    errors in data entry. So unlike the concept of nothing, missing data actually
    exists in the real world. We simply don’t know what it is.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参与者可能在研究完成前离开，留下那些进行实验的人拥有不完整的数据。缺失数据也可能由于数据录入错误而存在。所以，与“无”的概念不同，缺失数据实际上存在于现实世界中。我们只是不知道它是什么。
- en: Specialized software for statisticians, such as R (see [https://www.r-project.org](https://www.r-project.org))
    and SAS (see [https://www.sas.com](https://www.sas.com)), has long established
    that missing data should propagate rather than throw exceptions. This means that
    if a missing value is introduced in any part of a larger calculation, the whole
    calculation evaluates to missing. Julia has chosen to follow this convention as
    well. Let’s look at what that means in practice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 专门为统计学家设计的软件，如R（见[https://www.r-project.org](https://www.r-project.org)）和SAS（见[https://www.sas.com](https://www.sas.com)），长期以来一直认为缺失数据应该传播而不是抛出异常。这意味着如果在大计算中的任何部分引入了缺失值，整个计算将评估为缺失。Julia也选择了遵循这一惯例。让我们看看这在实践中意味着什么。
- en: Listing 10.4 Comparing behavior of missing and nothing in mathematical expressions
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4 比较数学表达式中缺失值和“无”的行为
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see in listing 10.4 that every mathematical operation involving a missing
    value evaluates to missing, unlike nothing, which causes exceptions to be thrown.
    The rationale for this is that a lot of serious mistakes have been made in statistical
    work in the past, stemming from not noticing there are missing values. Since missing
    spreads like a virus in Julia, an unhandled missing value will quickly get caught.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在列表10.4中看到，涉及缺失值的每个数学运算都会评估为缺失，与“无”不同，它会导致抛出异常。这样做的原因是，过去在统计工作中已经犯了许多严重的错误，这些错误源于没有注意到存在缺失值。由于缺失值在Julia中像病毒一样传播，未处理的缺失值会迅速被发现。
- en: 'Missing can be handled explicitly. For instance, if you want to calculate the
    sum or averages of an array that may contain missing values, you can use the skipmissing
    function to avoid attempting to include missing values in the result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值可以显式处理。例如，如果你想计算可能包含缺失值的数组的总和或平均值，你可以使用skipmissing函数来避免尝试将缺失值包含在结果中：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The presence of a missing value pollutes the whole calculation, causing the
    result to be missing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 缺失值的出现会污染整个计算，导致结果缺失。
- en: ❷ You skip the missing values, so you can add up the non-missing values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跳过缺失值，因此你可以将非缺失值相加。
- en: 10.4 Not a number
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 非数值
- en: 'Somewhat related to missing values is the floating-point number NaN (not a
    number). You get NaN as a result when the result of an operation is undefined.
    This typically becomes an issue when dividing zero by zero:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与缺失值多少有些相关的是浮点数NaN（非数值）。当操作的结果未定义时，你会得到NaN。这通常在除以零时成为一个问题：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case Inf stands for *infinity* and is what you get when dividing a number
    other than zero by zero. This makes some sense. As the divisor approaches zero,
    the result tends to grow larger.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Inf代表*无穷大*，是除以非零数除以零时得到的结果。这有些道理。当除数接近零时，结果往往会变得更大。
- en: It is tempting to consider NaN as similar to missing and that they are interchangeable.
    After all, NaN also propagates through all calculations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将NaN视为与缺失值相似，并且它们可以互换。毕竟，NaN也会在所有计算中传播。
- en: Listing 10.5 Propagation of NaN in mathematical operations
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 数学运算中NaN的传播
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, NaN comparisons return false. The following reason is why you should
    *not* use NaN for missing values: if you have a mistake in your algorithm that
    causes a 0/0 to happen, you will get NaN. This will be indistinguishable from
    having missing values as input.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，NaN的比较结果为假。以下是不应使用NaN作为缺失值的原因：如果你在算法中犯了一个错误导致0/0发生，你将得到NaN。这将与输入缺失值无法区分。
- en: Listing 10.6 Cannot distinguish between calculation causing NaN or input being
    NaN
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 无法区分导致NaN的计算或输入为NaN
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may falsely believe your algorithm is working because it is removing missing
    values in the calculation, thus masking a defect. For example, in listing 10.6
    you are not checking if the input x is zero before dividing. Thus when x is 0,
    you get a NaN as result. If you pass NaN as input to the calc function in order
    to indicate a missing value, then you are unable to make a distinction between
    a programmer mistake and a missing value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会错误地认为你的算法正在工作，因为它在计算中移除了缺失值，从而掩盖了一个缺陷。例如，在列表 10.6 中，你在除法之前没有检查输入 x 是否为零。因此，当
    x 为 0 时，你得到一个 NaN 作为结果。如果你将 NaN 作为 calc 函数的输入以指示缺失值，那么你无法区分程序员错误和缺失值。
- en: 10.5 Undefined data
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 未定义数据
- en: Undefined data is something you rarely encounter in Julia, but it is worth being
    aware of. Undefined data occurs when a variable or field of a struct has not been
    set. Usually, Julia tries to be smart about this; if you define a struct with
    number fields, Julia will automatically initialize them to zero if you don’t do
    anything. However, if you define a struct without telling Julia what the type
    of its fields are, Julia has no way of guessing what the fields should be initialized
    to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，你很少会遇到未定义的数据，但了解这一点是值得的。未定义数据发生在变量或结构体的字段未设置时。通常，Julia 会尽量聪明地处理这种情况；如果你定义了一个具有数字字段的
    struct，Julia 会自动将它们初始化为零，除非你做了其他操作。然而，如果你定义了一个没有告诉 Julia 字段类型的 struct，Julia 就没有方法猜测字段应该初始化为什么。
- en: Listing 10.7 Defining a composite type, instantiated with undefined values
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 定义一个复合类型，使用未定义的值实例化
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Julia allows the construction of composite objects with uninitialized fields.
    However, it will throw an exception if you try to access an uninitialized field.
    There are no benefits to having uninitialized values, but they help catch programmer
    mistakes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 允许构建具有未初始化字段的复合对象。然而，如果你尝试访问一个未初始化的字段，它将抛出一个异常。未初始化的值没有好处，但它们有助于捕捉程序员的错误。
- en: 10.6 Putting it all together
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 将所有内容组合在一起
- en: 'Distinguishing between each of these concepts of *nothing* can be a bit daunting,
    so I’ll briefly summarize the differences: nothing is the *programmer’s* type
    of null. It is what a programmer wants when something does not exist. missing
    is the *statistician’s* type of null. It is what they want when a value is missing
    in their input data. NaN indicates that somewhere in your code there was an illegal
    math operation. In other words, this has to do with calculations and not with
    the statistical collection of data. *Undefined* is when you, the programmer, forgot
    to do your job and initialize all used data. Most likely, it points to a bug in
    your program.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这些 *nothing* 概念中的每一个可能有点令人畏惧，所以我将简要总结它们之间的区别：nothing 是程序员的 null 类型。当某物不存在时，程序员想要的就是这个。missing
    是统计员的 null 类型。当他们的输入数据中缺少值时，他们想要的就是这个。NaN 表示在代码中某个地方发生了非法的数学操作。换句话说，这与计算有关，而不是与数据的统计收集有关。*未定义*
    是指程序员忘记初始化所有使用的数据。这很可能是程序中的错误。
- en: 'As a final reminder: Julia does *not* have null in the common sense because
    you need to explicitly allow for a nothing value using type unions. Otherwise,
    a function argument cannot accidentally pass a nothing value.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的提醒：Julia 在常规意义上没有 null，因为你需要使用类型联合显式允许 nothing 值。否则，函数参数不会意外地传递一个 nothing
    值。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Unknown values in Julia are represented by nothing, missing, NaN, and undefined.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的未知值由 nothing、missing、NaN 和 undefined 表示。
- en: nothing is of type Nothing and indicates something doesn’t exist. Use as return
    value when a find function fails or in data structures (e.g., to terminate a linked
    list).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nothing 是类型 Nothing，表示不存在的东西。当查找函数失败或在数据结构中（例如，用于终止链表）时，将其用作返回值。
- en: missing is data that exists but which is missing, such as in a survey. It is
    of type Missing. When implementing code that reads in statistical data from a
    file, use missing as a placeholder for data which is missing.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: missing 是存在但缺失的数据，例如在调查中。它是类型 Missing。当实现从文件中读取统计数据的代码时，使用 missing 作为缺失数据的占位符。
- en: NaN is the result of illegal math operations. Should your function return NaN,
    you should investigate whether you have made a programming mistake. For example,
    are you making sure 0/0 never happens in your code?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaN 是非法数学操作的结果。如果你的函数返回 NaN，你应该调查你是否犯了一个编程错误。例如，你确保你的代码中 0/0 永远不会发生吗？
- en: Undefined is when a variable was not initialized to a known value.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义是指变量未初始化为已知值。
- en: Neither nothing nor missing are built-in values in the language, but they are
    defined as composite types without any fields.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该语言中，既没有“无”也没有“缺失”作为内置值，但它们被定义为没有任何字段的复合类型。
- en: The Union parameterized type is practical to use with Nothing and Missing types.
    For instance, if a field can be either a string or nothing, define the type as
    Union{Nothing, String}.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合参数化类型与“无”和“缺失”类型一起使用非常实用。例如，如果一个字段可以是字符串或无，则将类型定义为 Union{Nothing, String}。
