- en: 7 Hooks to fuel your web applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 个钩子为您的 Web 应用程序提供动力
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: A larger perspective on creating stateful components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有状态组件的更广阔视角
- en: Introducing advanced topics solvable by hooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍通过钩子可解决的先进主题
- en: Rules to observe when using hooks in general
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用钩子时需要注意的规则
- en: Hooks are what make modern React applications tick. They’re a pretty small part
    of the overall React API, but very significant nonetheless. Hooks are also quite
    tricky to use. In this chapter, we’ll discuss all the hooks, what they do, and
    some important things to know about using hooks in general.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是使现代 React 应用程序运行的关键。它们是 React API 中的一个相对较小的部分，但仍然非常重要。钩子的使用也非常复杂。在本章中，我们将讨论所有钩子，它们的功能，以及使用钩子时的一些重要事项。
- en: Hooks are a special kind of creature in the React biosphere. From the outside,
    they seem completely unrelated in functionality, but when examined closer, they
    have some common traits and behaviors that we need to account for when using them.
    You could say that they stem from a common ancestor somewhere in the evolutionary
    tree, even though they have advanced to become very different beings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是 React 生物圈中的一种特殊生物。从外部看，它们在功能上似乎完全不相关，但当我们仔细观察时，它们有一些共同的特性和行为，我们在使用它们时需要考虑。可以说，它们起源于进化树中的某个共同祖先，尽管它们已经进化成为非常不同的生物。
- en: We’ve dedicated this chapter to all the hooks for this very reason. So, while
    we’re going to be covering some wildly different topics, all of them are concerned
    with using hooks. We’ll tie a bow on it at the end by explaining how all of these
    hooks are, in fact, related, despite their seemingly divergent purposes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以将本章奉献给所有这些钩子，正是因为这个原因。因此，虽然我们将要涵盖一些截然不同的主题，但它们都与使用钩子有关。我们将在最后通过解释所有这些钩子实际上是如何相互关联的，尽管它们似乎具有不同的目的，来为它们画上一个句号。
- en: 'You’ve seen three different hooks so far: useState (in chapter 5) and useEffect
    and useLayoutEffect (in chapter 6). At the time of writing, there are 15 built-in
    hooks in React (as of React 18), which we’ll cover briefly, grouped by their functionality:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了三个不同的钩子：useState（第 5 章）和 useEffect 以及 useLayoutEffect（第 6 章）。在撰写本文时，React
    中有 15 个内置钩子（截至 React 18），我们将简要介绍，按其功能分组：
- en: '*Stateful hooks*—These functions are concerned with making components and applications
    stateful on several different layers and levels of complexity: useState, useReducer,
    useRef, useContext, useDeferredValue, and useTransition.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有状态钩子*—这些函数关注于在多个不同层次和复杂度级别上使组件和应用具有状态：useState, useReducer, useRef, useContext,
    useDeferredValue, 和 useTransition。'
- en: '*Effect hooks*—These functions are concerned with running effects inside a
    component at different stages of the overall component life cycle as well as during
    each individual render cycle: useEffect and useLayoutEffect.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*效果钩子*—这些函数关注在组件的不同生命周期阶段以及每个渲染周期内运行效果：useEffect 和 useLayoutEffect。'
- en: '*Memoization hooks*—These functions are used for performance optimization by
    avoiding recalculating values if their constituent parts haven’t changed: useMemo,
    useCallback, useId.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记忆化钩子*—这些函数通过避免重新计算其组成部分未发生变化时的值来用于性能优化：useMemo, useCallback, useId。'
- en: '*Library hooks*—These advanced functions are almost exclusively used in larger
    component libraries that are created to be shared either with the community or
    internally in a larger organization. These functions are rarely used in smaller
    or medium-size applications: useDebugValue, useImperativeHandle, useInsertionEffect,
    and useSyncExternalStore.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*库钩子*—这些高级函数几乎仅用于创建大型组件库，这些库是为了与社区共享或在更大的组织内部共享而创建的。这些函数在较小或中等规模的应用程序中很少使用：useDebugValue,
    useImperativeHandle, useInsertionEffect, 和 useSyncExternalStore。'
- en: These 15 hooks are the built-in “base” hooks that React comes with. You can
    build more hooks on top of them, but you can’t build your own base hooks. You
    can only build hooks that utilize one or more of the existing hooks. We’ll discuss
    custom hooks in chapter 10.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这 15 个钩子是 React 内置的“基础”钩子。您可以在它们之上构建更多钩子，但不能构建自己的基础钩子。您只能构建利用一个或多个现有钩子的钩子。我们将在第
    10 章中讨论自定义钩子。
- en: Note that React might be extended with more built-in hooks in future releases.
    React 18.0 came with five new hooks, and incremental releases after React 18 might
    come with even more.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，React 可能会在未来的版本中扩展更多内置钩子。React 18.0 带来了五个新的钩子，React 18 之后的增量版本可能会带来更多。
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch07](https://rq2e.com/ch07).
    But as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在 [https://rq2e.com/ch07](https://rq2e.com/ch07) 获取。但正如你在第 2 章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 7.1 Stateful components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 有状态组件
- en: We’ve covered stateful components in general in chapter 5, but we’ll gladly
    reiterate that information here for completeness. Stateful components and, in
    turn, stateful applications are essential for web applications to actually be
    interesting to use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 5 章中一般性地介绍了有状态组件，但为了完整性，我们在这里会再次重申这些信息。有状态组件以及相应的有状态应用程序对于使网络应用程序真正有趣使用是必不可少的。
- en: An application without state is completely static. The application will be identical
    for the entire time you have it open in the browser, and it will be identical
    for every user using the application. If you need login, sessions, interaction,
    and variability and changes over time, you need your application to be stateful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有状态的应用程序是完全静态的。整个你在浏览器中打开它的过程中，应用程序都是相同的，对于使用该应用程序的每个用户来说也都是相同的。如果你需要登录、会话、交互以及随时间的变化和变化，你需要你的应用程序是有状态的。
- en: However, stateful components aren’t all the same, just like not all states are
    the same. One state is only kept briefly, another state is hyperlocal to an individual
    component, and yet another state is application-wide. In addition, state can be
    a single variable or a huge complex web of interdependent variables that have
    to update in unison. In this section, we’ll cover some different use cases for
    stateful components and applications, and discuss how to solve the given challenge
    via the proper hooks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有状态组件并不都是一样的，就像不是所有的状态都是一样的。一个状态只是短暂地保持，另一个状态是针对单个组件的超局部状态，而另一个状态是应用级别的。此外，状态可以是一个单一变量，也可以是一个复杂的相互依赖的变量网络，这些变量必须同时更新。在本节中，我们将介绍一些有状态组件和应用程序的不同用例，并讨论如何通过适当的钩子解决给定的挑战。
- en: 7.1.1 Simple state values with useState
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 使用 useState 的简单状态值
- en: useState is the bread and butter of stateful applications. You’ll probably find
    yourself using this hook the majority of times that you need state, so it’s definitely
    an important one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: useState 是有状态应用程序的基石。你可能会发现自己需要状态时，大多数情况下都会使用这个钩子，所以它肯定是一个重要的钩子。
- en: If you have a menu that can open and close, you keep its state in a local useState
    inside your menu component. This single simple value is only used inside this
    component, and it’s unrelated to any other state values in the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个可以打开和关闭的菜单，你会在你的菜单组件内部使用一个本地的 useState 来保持其状态。这个单一简单的值只在这个组件内部使用，并且与应用程序中的任何其他状态值无关。
- en: We discussed all the ins and outs of useState in chapter 5, so we won’t go into
    further detail on this hook here. However, in the rest of this section, we’ll
    introduce some more complex scenarios where useState isn’t enough or is suboptimal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 5 章中讨论了 useState 的所有细节，所以在这里我们不会进一步详细介绍这个钩子。然而，在本节的其余部分，我们将介绍一些更复杂的场景，在这些场景中
    useState 不够用或不是最优的。
- en: 7.1.2 Creating complex state with useReducer
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 使用 useReducer 创建复杂状态
- en: Imagine that we have a loader component, where we want to know whether loading
    succeeded or failed, what the error message is in case of failure, and what the
    data is in case of success. The value of the error message is only relevant if
    the loading fails. If loading succeeds, the error message is completely irrelevant
    and shouldn’t even be set—and vice versa for the result data. This is an example
    of *interdependent* state. The individual values in the state depend on each other,
    and you’ll often be updating multiple values at the same time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个加载组件，我们想知道加载是否成功或失败，在失败的情况下错误信息是什么，在成功的情况下数据是什么。错误信息的值只有在加载失败时才有意义。如果加载成功，错误信息就完全无关紧要，甚至不应该设置——反之亦然，对于结果数据也是如此。这是一个
    *相互依赖* 状态的例子。状态中的各个值相互依赖，你通常会同时更新多个值。
- en: useReducer is a stateful hook for exactly this purpose. It’s an advanced version
    of useState where we can alter our state in a more complex and controlled way
    (almost like a state machine, but not really) if we have a setup that’s more complex
    than a single state value can reasonably represent.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: useReducer 是为了这个目的而设计的有状态钩子。它是对 useState 的一个高级版本，如果我们有一个比单个状态值可以合理表示更复杂的设置，我们可以以更复杂和受控的方式改变我们的状态（几乎像状态机，但又不完全是）。
- en: Using a reducer is a way to generate a new state (“reduce”) solely based on
    the current state and some action that takes some payload. The concept of *reducing
    state* is known from other frameworks such as Redux (hence, the name), so it’s
    already familiar to many React developers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 reducer 是一种仅基于当前状态和一些携带负载的动作来生成新状态（“减少”）的方法。*减少状态*的概念来自其他框架，如 Redux（因此得名），所以它对许多
    React 开发者来说已经很熟悉了。
- en: Note that useReducer is never strictly necessary—anything we can do with a reducer
    can also be done with a combination of simpler useStates. There are many cases
    where you would likely want to use a reducer rather than settle for multiple disparate
    states to ensure stricter data flow and better control.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，useReducer 永远不是严格必要的——我们可以用 reducer 做任何事情，也可以用更简单的 useState 的组合来做。有许多情况下，你可能会想使用
    reducer 而不是满足于多个不同的状态，以确保更严格的数据流和更好的控制。
- en: We’ll present some examples of a reducer in chapter 10 when we move to more
    complex application architecture. A reducer is only relevant for rather complex
    data flows, so it’s not something we’ll use a lot in the simple applications that
    we’re building throughout this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向更复杂的应用架构时，我们将在第 10 章中展示一些 reducer 的示例。reducer 只与相对复杂的数据流相关，因此它不是我们在本书中构建的简单应用中会大量使用的东西。
- en: 7.1.3 Remembering a value without re-rendering with useRef
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 使用 useRef 记忆值而不重新渲染
- en: Imagine that we want to create a button that only works on double-clicking within
    a certain number of milliseconds. To create this, we need to remember how much
    time has passed between successive clicks. Remembering data inside a component
    is exactly what we have state for. We have a value that we want to persist between
    renders, but we don’t use it for rendering. The button doesn’t change when we
    click the first time. We just need to remember a value inside a component instance
    for some amount of time, but we won’t use the value to determine the output of
    the component.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个按钮，它只在该按钮被双击且在特定毫秒数内时才起作用。为了实现这一点，我们需要记住连续点击之间经过的时间。在组件内部记忆数据正是我们使用状态的目的。我们有一个希望在渲染之间持续存在的值，但我们不使用它来进行渲染。按钮在第一次点击时不会改变。我们只需要在组件实例内部记住一个值一段时间，但我们不会使用这个值来确定组件的输出。
- en: useRef is both one of the simplest hooks in React and also one of the least
    understood hooks. It’s a hook with a *passive state*, which means the hook can
    contain state, but setting or updating the state doesn’t cause a re-render.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: useRef 既是 React 中最简单的钩子之一，也是理解最少的钩子之一。它是一个具有*被动状态*的钩子，这意味着钩子可以包含状态，但设置或更新状态不会导致重新渲染。
- en: useRef is used for a number of purposes, including remembering values between
    renders and serving as a reference to DOM elements used in the render. The latter
    is a very important use case (and the reason for the name, useRef), as it’s the
    best and simplest way to address DOM elements through script in your components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: useRef 被用于多个目的，包括在渲染之间记忆值以及作为在渲染中使用的 DOM 元素的引用。后者是一个非常重要的用例（也是其名称的由来，useRef），因为这是在组件中通过脚本访问
    DOM 元素的最佳和最简单的方式。
- en: Passive state values
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 被动状态值
- en: You can use the useRef hook to remember some value that is relevant between
    renders of the component but that doesn’t directly affect the outcome of the component.
    That sounds a bit complex and even rare. When would you have such a value in a
    component? As an example, let’s recreate our counter component once again, but
    this time with the added functionality that the increment button only works if
    double-clicked.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 useRef 钩子来记忆一些在组件渲染之间相关但不会直接影响组件输出的值。这听起来有点复杂，甚至罕见。你何时会在组件中遇到这样的值？作为一个例子，让我们再次重构我们的计数器组件，但这次增加了功能，即增加按钮只有在双击时才起作用。
- en: We need to store the time of the last click event somewhere in our component,
    and it needs to be in a place that persists between renders. We already know that
    we can store such a value in a state provided by the useState hook. A sketch of
    this scenario is shown in figure 7.1, and the implementation is shown in listing
    7.1.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在组件中某个地方存储上一次点击事件的时刻，并且这个时刻需要在渲染之间持续存在。我们已经知道，我们可以通过 useState 钩子提供的状态来存储这样的值。这个场景的草图如图
    7.1 所示，实现代码见列表 7.1。
- en: '![07-01](../Images/07-01.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![07-01](../Images/07-01.png)'
- en: Figure 7.1 As the user clicks the button, the execution bifurcates based on
    whether this click happens within a very short time of the last recorded click.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 当用户点击按钮时，根据这个点击是否发生在上一次记录的点击非常短的时间内，执行路径会分支。
- en: Listing 7.1 A double-click counter with useState
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 使用useState的双击计数器
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Remembers the time of the last click in a state value
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在状态值中记住上一次点击的时间
- en: ❷ If the time since the last click is less than 300 ms, it’s a double-click.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果上一次点击的时间小于 300 毫秒，则认为是双击。
- en: ❸ Increments the counter only if it’s a double-click
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 只有在是双击的情况下才增加计数器
- en: ❹ Remembers the time of the current click if it’s not a double-click
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果不是双击，则记住当前点击的时间
- en: This isn’t necessary, however, and will cause needless extra re-renders. When
    we call setLastClickTime, React will re-render the component because a state value
    changes. However, the JSX won’t change in the component, and the same DOM output
    will be rendered to the screen. The code in listing 7.1 works, but it’s less than
    optimal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是必要的，并且会导致不必要的额外重新渲染。当我们调用setLastClickTime时，React会因为状态值的变化而重新渲染组件。然而，组件中的JSX不会改变，并且相同的DOM输出将被渲染到屏幕上。列表
    7.1 中的代码是有效的，但不是最优的。
- en: Because we only need the state value internally in the component and don’t need
    the component to re-render just because the value is updated, we can instead use
    a reference via the useRef hook. To instantiate a useRef hook, you simply call
    the hook and store it in a variable. You can optionally pass an initial value
    to the hook as well. To read or update the current value of a useRef hook, you
    access the .current property on the hook return value. Compare the sketch of this
    scenario in figure 7.2 with the scenario in figure 7.1—we skip an entire cycle
    of rendering! This is implemented in listing 7.2.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要在组件内部使用状态值，并且不需要因为值更新而使组件重新渲染，我们可以通过useRef钩子使用引用。要实例化一个useRef钩子，您只需调用该钩子并将其存储在一个变量中。您还可以向钩子传递一个初始值。要读取或更新useRef钩子的当前值，您需要访问钩子返回值的.current属性。将图
    7.2 中的场景与图 7.1 中的场景进行比较——我们跳过了一个完整的渲染周期！这是在列表 7.2 中实现的。
- en: '![07-02](../Images/07-02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![07-02](../Images/07-02.png)'
- en: Figure 7.2 This time, if the user clicks the button the first time, the last
    click time is recorded, but it doesn’t cause a re-render because it’s not an active
    state value, but a passive one. This means that we can still access the value
    later (on this or future renders), but it doesn’t cause a new render by itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 这次，如果用户第一次点击按钮，记录上一次点击的时间，但由于它不是一个活动状态值，而是一个被动状态值，所以不会引起重新渲染。这意味着我们仍然可以在稍后（在这个或未来的渲染中）访问这个值，但它本身不会引起新的渲染。
- en: Listing 7.2 A double-click counter with useRef
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 使用useRef的双击计数器
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Remembers the time of the last click in a useRef value
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在useRef值中记住上一次点击的时间
- en: ❷ Performs the same check as before, except now the value is accessed through
    the .current property
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行与之前相同的检查，但现在通过.current属性访问值
- en: ❸ Updates the current value of the state through the .current property
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过.current属性更新状态值
- en: 'Repository: rq07-double-counter'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq07-double-counter
- en: 'This example can be seen in repository rq07-double-counter. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq07-double-counter仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在您的浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq07-double-counter](https://rq2e.com/rq07-double-counter)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq07-double-counter](https://rq2e.com/rq07-double-counter)'
- en: This is a much better version of our component, because we don’t have needless
    re-renders. We persist the state properly in a way that works, even if the component
    does re-render for some other reason.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们组件的一个更好的版本，因为我们没有不必要的重新渲染。我们以正确的方式持久化状态，即使组件因其他原因重新渲染也是如此。
- en: References to DOM elements
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对 DOM 元素的引用
- en: 'The other use case for useRef is, as mentioned, to get references to DOM elements.
    You’ll see this used many times throughout the remainder of this book. We use
    it to have a reference to the actual DOM element that is rendered in the document
    as a consequence of the JSX element that we’ve created. The syntax is very simple:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，useRef的另一个用途是获取DOM元素的引用。您将在本书的其余部分多次看到它的使用。我们使用它来引用由我们创建的JSX元素在文档中渲染的实际DOM元素。语法非常简单：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a reference using the hook
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用钩子创建引用
- en: ❷ “Assigns” the reference to the DOM node, which, when the component is rendered,
    assigns a reference to the DOM node inside the ref object
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ “分配”引用到 DOM 节点，当组件渲染时，将引用分配给 ref 对象内部的 DOM 节点
- en: This doesn’t use the reference for anything, but merely creates it. You can
    use the reference in an effect hook to, for example, invoke methods on the element,
    which isn’t directly possible through properties of the DOM element.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是使用引用做任何事情，而仅仅是创建它。你可以在 effect 钩子中使用引用来，例如，调用元素的函数，这是通过 DOM 元素的属性直接无法实现的。
- en: 'For instance, let’s autofocus an input field when a component is mounted:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在组件挂载时自动聚焦输入字段：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Creates an effect that runs on mount only (empty dependency array) and focuses
    the element through the ref object. Note that it uses the ref.current syntax as
    mentioned previously.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在组件挂载时运行效果（空依赖数组）并通过引用对象聚焦元素。注意，它使用了之前提到的 ref.current 语法。
- en: This latter use of useRef is the more common use (and the originally intended
    purpose). There’s quite a bit more to say about how both useRef and the JSX ref
    property work, but we’ll leave it here for now. We’ll expand a bit on this in
    future chapters where relevant.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这后一种 useRef 的使用更为常见（以及最初的目的）。关于 useRef 和 JSX 引用属性的工作方式还有很多话要说，但我们现在就到这里。我们将在相关的未来章节中对此进行一些扩展。
- en: 7.1.4 Easier multicomponent state with useContext
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 使用 useContext 实现更简单的多组件状态
- en: useContext is a stateful hook, meaning that it works similarly to useState.
    But rather than load and update values in a local store, useContext works in a
    store in a parent component somewhere up the component tree. This is the hook
    version of the React Context API, and we’ll see a lot more about how this works
    in practice in chapter 10\. We can reveal that it’s one of the more powerful hooks
    when it comes to building good architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: useContext 是一个有状态的钩子，意味着它的工作方式类似于 useState。但与在本地存储中加载和更新值不同，useContext 在组件树中某个父组件的存储中工作。这是
    React Context API 的钩子版本，我们将在第 10 章中看到更多关于它在实践中是如何工作的。我们可以揭示，当涉及到构建良好的架构时，它是最强大的钩子之一。
- en: 7.1.5 Low-priority state updates with useDeferredValue and useTransition
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.5 使用 useDeferredValue 和 useTransition 进行低优先级状态更新
- en: Note This topic is both fairly advanced and also brand new. These are features
    only just added with React 18, so there’s still a lot of discoveries around best
    practices yet to be made. It’s also an advanced topic that probably isn’t relevant
    for everyday applications. We won’t cover the functionality of these hooks in
    full in this section, but we’ll only briefly outline why they exist. If you don’t
    care about them at this point, feel free to skip this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这个主题既相当高级，又非常新颖。这些是仅随着 React 18 新增的功能，因此关于最佳实践的发现还有很多。它也是一个高级主题，可能对日常应用不相关。我们不会在本节中全面介绍这些钩子的功能，但我们将简要概述它们存在的原因。如果你现在不关心它们，请随意跳过这一节。
- en: Imagine that we’ve created an online document editor application similar to
    Google Docs, and we’ve added many features to it. We’re now adding a spell-checker
    to the application and want to do this by adding a button that can be clicked
    to enable spell-checking and clicked again to disable it. The button has a different
    background color if enabled.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们创建了一个类似于 Google Docs 的在线文档编辑应用程序，并为其添加了许多功能。我们现在正在向应用程序添加拼写检查器，并希望通过添加一个可以点击以启用和再次点击以禁用拼写检查的按钮来实现这一点。当启用时，按钮具有不同的背景颜色。
- en: When a user clicks this button, it should react instantly. The button should
    change display within a few milliseconds for the user to feel like the button
    works. We can implement this using state by just toggling an enabled property
    inside the button using a useState setter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击此按钮时，它应该立即响应。按钮应在几毫秒内改变显示，使用户感觉按钮在起作用。我们可以通过在按钮内部使用 useState 设置器切换一个启用属性来实现这一点。
- en: But our button is going to do more than that. When spell-check is enabled, all
    the typos in the document should be highlighted with a red line underneath them.
    If the user is working on a large document, finding and highlighting all the errors
    might be an expensive operation. You have to run a lot of operations on all the
    words in the document to find errors and maybe even find suggestions for correct
    spellings for each. These tasks can easily take tenths of a second or even whole
    seconds to execute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的按钮将要做的不仅仅是这些。当拼写检查被启用时，文档中的所有错别字都应该用红色下划线突出显示。如果用户正在处理一个大型文档，查找和突出显示所有错误可能是一个昂贵的操作。你必须在文档中的所有单词上运行很多操作来查找错误，甚至可能为每个错误找到正确的拼写建议。这些任务可能需要十分之一秒甚至整秒的时间来执行。
- en: If we update both the internal enabled state flag inside the button as well
    as the global flag that triggers the spell-check calculation with the same priority
    at the same time in React, React’s internals will treat both updates as happening
    at the same time and won’t render anything until both updates have been fully
    calculated. This isn’t ideal because the spell-check button will seem nonfunctional.
    When the user clicks the button and nothing happens, they will click it again.
    Then, all of a sudden, the button will actually work after the calculation is
    completed, but because the user had already clicked it again, the user disables
    the functionality. That’s a horrible user experience.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在React中同时更新按钮内部的内部启用状态标志以及触发拼写检查计算的全球标志，并且具有相同的优先级，React的内部将把这两个更新视为同时发生，并且不会渲染任何内容，直到这两个更新都已经完全计算完成。这并不理想，因为拼写检查按钮将看起来没有功能。当用户点击按钮而没有发生任何事时，他们会再次点击它。然后，突然之间，按钮在计算完成后实际上会工作，但由于用户已经再次点击了它，用户禁用了该功能。这是一个糟糕的用户体验。
- en: 'What if we could inform React that updating the button state is high priority
    and should happen right away, whereas highlighting all the spelling errors in
    the document is lower priority, and we don’t mind if that trails the button click
    by several render cycles? React 18 introduced a brand-new concept, Concurrent
    Mode, which allows exactly that. The useDeferredValue and useTransition hooks
    are two different ways of specifying low-priority state updates from two different
    angles. Given the complexity of these hooks, we won’t cover them further in this
    book, but please refer to the following online materials for more information:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能通知React更新按钮状态是高优先级的，应该立即发生，而突出显示文档中的所有拼写错误是低优先级的，我们并不介意它落后于按钮点击几个渲染周期呢？React
    18引入了一个全新的概念，并发模式，它正好允许这样做。useDeferredValue和useTransition钩子是两种从不同角度指定低优先级状态更新的不同方法。鉴于这些钩子的复杂性，我们不会在本书中进一步介绍它们，但请参考以下在线材料以获取更多信息：
- en: 'Article: [http://mng.bz/jPAP](http://mng.bz/jPAP)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章：[http://mng.bz/jPAP](http://mng.bz/jPAP)
- en: 'Video: [http://mng.bz/WzM1](http://mng.bz/WzM1)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频：[http://mng.bz/WzM1](http://mng.bz/WzM1)
- en: 7.2 Component effects
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 组件效果
- en: 'This section is going to be short, so try not to blink or you might miss it
    completely! *Component effects* are a group of hooks dedicated to running side
    effects from within hooks with three different purposes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将会很短，所以请尽量不要眨眼，否则你可能会完全错过！*组件效果*是一组专门用于在钩子内部执行副作用，具有三个不同目的的钩子：
- en: To influence the outside based on the component state
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于组件状态影响外部
- en: To update the component state based on something from the outside
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于外部信息更新组件状态
- en: To both influence the outside and update the component state at the same time
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时影响外部并更新组件状态
- en: We’ve seen two such hooks already presented in the previous chapter, useEffect
    and useLayoutEffect. There is only one more such hook, useInsertionEffect, but
    it’s reserved for advanced use by specific libraries, so it’s not recommended
    to be used by “regular” developers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中看到了两个这样的钩子，即useEffect和useLayoutEffect。只有一个这样的钩子，即useInsertionEffect，但它被保留给特定库的高级使用，因此不建议“常规”开发者使用。
- en: We won’t add any information on useEffect and useLayoutEffect in this chapter,
    as we covered everything there is to know in chapter 6\. The last effect hook,
    useInsertionEffect, will be briefly covered in section 7.4.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会添加有关useEffect和useLayoutEffect的信息，因为我们已经在第6章中涵盖了所有需要知道的内容。最后一个效果钩子useInsertionEffect将在第7.4节中简要介绍。
- en: 7.3 Optimizing performance by minimizing re-rendering
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 通过最小化重新渲染来优化性能
- en: Note This is an advanced topic not required by most simple applications. We’ll
    only quickly introduce the topic here and not cover it in detail, as it’s not
    necessary for your first, your second, or even your tenth application. Only once
    you start moving into larger applications with dozens or even hundreds of components
    do these hooks start to shine.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这是一个高级话题，对于大多数简单应用程序不是必需的。我们在这里只会简要介绍这个话题，而不会详细讨论，因为它对于你的第一个、第二个甚至第十个应用程序都不是必需的。只有当你开始开发包含数十个甚至数百个组件的大型应用程序时，这些钩子才开始发挥作用。
- en: If you’re working on a larger application with many moving parts, data updating
    from many sources, and events listening to many types of input, performance might
    start to degrade if components render unnecessarily. Once your application gets
    to that point, memoization might be the trick that can help your application regain
    its responsiveness.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个包含许多动态部分、数据来自多个来源以及监听多种类型输入的大型应用程序，如果组件不必要地渲染，性能可能会开始下降。一旦你的应用程序达到这个阶段，记忆化可能就是帮助你应用程序恢复响应性的技巧。
- en: At its core, *memoization* is the principle of caching the result of a given
    calculation so that if the same calculation is performed later, the cached result
    is returned. This can be used in React in a number of ways, including the three
    hooks we’ll introduce in this section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，*记忆化* 是缓存给定计算结果的原则，以便如果稍后执行相同的计算，则返回缓存的结果。这可以在 React 中以多种方式使用，包括本节中我们将介绍的三种钩子。
- en: As mentioned, we won’t go into detail about these hooks in this chapter, as
    they aren’t necessary when starting out as a React developer. In fact, wrongly
    applying memoization might lead to worse performance, not better. So given the
    advanced nature of this topic, we don’t use memoization at all in this book, and
    we’ll only briefly introduce the three hooks in the following subsections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会在本章中详细介绍这些钩子，因为作为 React 开发者入门时它们并不是必需的。实际上，错误地应用记忆化可能会降低性能，而不是提高。因此，鉴于这个主题的先进性，我们在这本书中根本不使用记忆化，我们将在以下子节中简要介绍这三个钩子。
- en: You can read more about optimizing React performance in *Job-Ready React* (Morten
    Barklund, Manning, 2024), which covers not only these hooks and memoization in
    general, but also other ways to make your application more performant.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *Job-Ready React* (Morten Barklund, Manning, 2024) 中了解更多关于优化 React 性能的内容，这本书不仅涵盖了这些钩子和一般性的记忆化，还介绍了其他使你的应用程序更高效的方法。
- en: 7.3.1 Memoizing any value with useMemo
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 使用 useMemo 记忆化任何值
- en: Let’s say you need to display the cryptographic hash of a given password as
    entered in an input field. The calculation of such a hash is pretty expensive,
    so you don’t want to perform the calculation if the password doesn’t change. But
    your component re-renders several times, even without the password changing. For
    this and similar occasions, you can use the useMemo hook to recalculate a given
    value in a component only if its dependencies change.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要显示在输入字段中输入的给定密码的加密散列。这种散列的计算相当昂贵，因此你不希望在密码没有改变的情况下执行计算。但是，即使密码没有改变，你的组件也会多次重新渲染。在这种情况下，你可以使用
    useMemo 钩子仅在依赖项更改时在组件中重新计算给定的值。
- en: 7.3.2 Memoizing functions with useCallback
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 使用 useCallback 记忆化函数
- en: useCallback is just a specialized version of useMemo, which is useful when useMemo
    is used to memoize a function. But because this happens so often, the useCallback
    hook exists for this purpose and is often used more than useMemo.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: useCallback 是 useMemo 的一个特殊版本，当 useMemo 用于记忆化一个函数时非常有用。但由于这种情况经常发生，因此存在 useCallback
    钩子用于此目的，并且它通常比 useMemo 更常用。
- en: 7.3.3 Creating stable DOM identifiers with useId
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 使用 useId 创建稳定的 DOM 标识符
- en: This is an even more advanced topic that is only relevant for server-generated
    React. It requires quite a buildup of knowledge to understand the circumstances
    for this hook that has such an extremely narrow usage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更加高级的话题，仅与服务器生成的 React 相关。要理解这个钩子如此狭窄的使用情况，需要相当多的知识积累。
- en: useId makes sure that for two completely identical component trees, if a particular
    component inside either tree calls useId, it will get the same ID returned regardless
    of which platform the hook is run on. This is used to ensure that generated HTML
    is identical on the client and on the server.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: useId 确保对于两个完全相同的组件树，如果树中的某个组件调用 useId，无论在哪个平台上运行钩子，它都会得到相同的 ID。这用于确保在客户端和服务器上生成的
    HTML 是相同的。
- en: 7.4 Creating complex component libraries
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 创建复杂组件库
- en: This section is only included for completion, so we cover all the hooks in React.
    The four hooks described in the next subsections are all very advanced and rarely
    used. They are meant for reusable packages such as component libraries or open
    source modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅为了完整性而包含，因此我们涵盖了 React 中的所有钩子。下一小节中描述的四个钩子都非常高级且很少使用。它们主要用于可重用的包，如组件库或开源模块。
- en: The last two hooks mentioned in this section are introduced in React 18 as a
    consequence of the new Concurrent Mode. Some libraries have to be updated to correctly
    render in Concurrent Mode to avoid calculating logic that isn’t required or is
    premature because of concurrency. Feel free to skip this section and go on to
    section 7.5 if you want to get on with the more practical stuff.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后提到的两个钩子是在 React 18 中作为新并发模式的结果引入的。一些库必须更新以正确地在并发模式下渲染，以避免计算不必要的逻辑或由于并发而提前计算的逻辑。如果你想继续更实用的内容，可以自由跳过本节，直接进入
    7.5 节。
- en: 7.4.1 Creating component APIs with useImperativeHandle
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 使用 useImperativeHandle 创建组件 API
- en: This hook is used for advanced component libraries where you want to expose
    an API to parent components that is either custom for your particular component
    or that mimics a built-in DOM element for ease of use. It’s almost exclusively
    used with forwardRef, which allows you to create your own components that accept
    refs, but pass them on to other elements or make a custom reference.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子用于高级组件库，其中你希望向父组件暴露一个 API，这个 API 要么是针对特定组件的自定义的，要么是为了便于使用而模仿内置 DOM 元素。它几乎总是与
    forwardRef 一起使用，这允许你创建自己的组件，这些组件可以接受引用，但将它们传递给其他元素或创建一个自定义引用。
- en: A quick example of this is a generalized custom input component where you want
    the parent component to be able to focus the input. Maybe you have an error message
    saying “missing field,” and if the user clicks the error message, the correct
    field is focused. However, inside your component, the input can be many different
    types of elements (input, text area, or select) and can even have multiple input
    fields (imagine a phone form field, consisting of both a country prefix field
    and another phone number field).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个快速示例是一个通用的自定义输入组件，其中你希望父组件能够聚焦到输入框。也许你有一个错误信息提示“缺少字段”，如果用户点击错误信息，正确的字段就会被聚焦。然而，在你的组件内部，输入可以是许多不同类型的元素（输入框、文本区域或选择框），甚至可以有多个输入字段（想象一下一个电话表单字段，包括国家前缀字段和另一个电话号码字段）。
- en: To generalize this and make a unified API for all of these cases, you can use
    the hook useImperativeHandle to expose a focus() method for your component. This
    method can be used in imperative code (rather than declarative code through properties
    only), which will make sure to focus the proper element when invoked.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些情况统一起来并创建一个统一的 API，你可以使用 useImperativeHandle 钩子来为你的组件暴露一个 focus() 方法。这个方法可以在命令式代码中使用（而不是仅通过属性进行声明式代码），确保在调用时聚焦到正确的元素。
- en: 'We won’t go into details about how this hook nor forwardRef work in this book,
    as that is an advanced subject beyond the scope of this chapter, but it’s good
    to know this hook exists if you want to create an advanced custom component that
    exposes a custom API through a reference. For more information, see this “ultimate
    guide*”* to useImperativeHandle: [http://mng.bz/EQ0O](http://mng.bz/EQ0O).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会详细介绍这个钩子以及 forwardRef 的工作原理，因为这属于本章范围之外的进阶主题，但如果你想创建一个通过引用暴露自定义 API 的高级自定义组件，了解这个钩子的存在是有好处的。更多信息，请参阅使用
    useImperativeHandle 的“终极指南”*：[http://mng.bz/EQ0O](http://mng.bz/EQ0O)。
- en: 7.4.2 Better debugging of hooks with useDebugValue
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 使用 useDebugValue 提高钩子的调试能力
- en: This is a hook only meant for developer experience. It doesn’t change nor improve
    the user experience of your application regardless of how it’s used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅针对开发者体验的钩子。无论如何使用，它都不会改变或提升你应用程序的用户体验。
- en: The useDebugValue hook allows you as a React library developer to display a
    custom message when other developers are inspecting your custom hooks in their
    React application using the React Developer Tools plugin in their browser.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: useDebugValue 钩子允许你作为 React 库开发者，当其他开发者在他们的 React 应用程序中使用浏览器中的 React Developer
    Tools 插件检查你的自定义钩子时，显示一个自定义消息。
- en: Normally a custom hook would display all of its internal states in the React
    Developer Tools explorer, but that might be confusing to someone who doesn’t care
    about the internals of your custom hook. With the useDebugValue hook, you can
    expose only what the developer using your hook cares about. For more information,
    see “How to Use useDebugValue in React” at [http://mng.bz/N251](http://mng.bz/N251).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，自定义hook会在React开发者工具资源管理器中显示其所有内部状态，但这对不关心你自定义hook内部结构的人来说可能很困惑。使用useDebugValue钩子，你可以仅暴露开发者使用你的hook所关心的内容。更多信息，请参阅“如何在React中使用useDebugValue”在[http://mng.bz/N251](http://mng.bz/N251)。
- en: 7.4.3 Synchronizing non-React data with useSyncExternalStore
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 使用useSyncExternalStore同步非React数据
- en: In Concurrent Mode, React can be updating a state value with low priority, and
    while calculating the consequences of said update, an urgent update comes in that
    has to be calculated irrespective of the incomplete update. Because React is running
    concurrently, React will have several completely separate instances of the application
    running and can thus spin off a new calculation based on a former state when an
    urgent update comes in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发模式中，React可以以低优先级更新状态值，在计算该更新的后果时，可能会出现紧急更新，该更新必须在不考虑不完整更新的情况下进行计算。因为React是并发运行的，React将运行几个完全独立的实例，因此当出现紧急更新时，可以根据之前的状态启动新的计算。
- en: 'If an application uses an external library to keep state updated, this external
    library has to be able to support this kind of concurrent state logic so it, too,
    can keep multiple instances of the state running at the same time. React 18 introduces
    the useSyncExternalStore for that exact purpose. For more information, see this
    article on useSyncExternalStore: [http://mng.bz/8r1K](http://mng.bz/8r1K).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序使用外部库来保持状态更新，那么这个外部库必须能够支持这种并发状态逻辑，以便它也能同时运行多个状态实例。React 18引入了useSyncExternalStore就是为了这个目的。更多信息，请参阅有关useSyncExternalStore的文章：[http://mng.bz/8r1K](http://mng.bz/8r1K)。
- en: 7.4.4 Running effect before rendering with useInsertionEffect
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.4 使用useInsertionEffect在渲染前运行副作用
- en: If you have a library that creates stylesheets or similar HTML nodes in the
    document as a side effect of component rendering, your library now needs to be
    aware of Concurrent Mode to render the correct nodes at the correct time. For
    that specific purpose, React 18 introduces the useInsertionEffect hook.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个库，在组件渲染的副作用中创建样式表或类似的HTML节点，那么你的库现在需要了解并发模式以在正确的时间渲染正确的节点。为此特定目的，React
    18引入了useInsertionEffect钩子。
- en: 'While this is and looks like an effect hook in the same vein as useEffect and
    useLayoutEffect, the useInsertionEffect hook is never applicable to regular components.
    It was only created as a consequence of how some general-purpose libraries have
    to be updated to account for the consequences of concurrency. For a bit more detail,
    see this short article on useInsertionEffect: [http://mng.bz/EQlq](http://mng.bz/EQlq).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是一个与useEffect和useLayoutEffect类似的副作用钩子，但useInsertionEffect钩子永远不会适用于常规组件。它只是作为一些通用库必须更新的结果而创建的，以考虑到并发的影响。更多细节，请参阅有关useInsertionEffect的这篇简短文章：[http://mng.bz/EQlq](http://mng.bz/EQlq)。
- en: 7.5 The two key principles of hooks
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 hooks的两个关键原则
- en: 'You only need to obey two rules regarding React hooks:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于React hooks，你只需要遵守两条规则：
- en: Only call hooks *unconditionally* at the *top level* of functional components.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在函数组件的*顶层*无条件地调用hooks。
- en: Only call hooks *inside* functional components.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在函数组件内部调用hooks。
- en: 'The first rule, we already discussed: you can only use hooks directly in your
    components, and you must always include the same number of hooks. That means you
    can never call hooks inside a function (including inside a function used in a
    hook) or a nested block (either a conditional or loop), and you can’t have early
    returns in your component before you’ve rendered all your hooks.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则，我们已经讨论过了：你只能在组件中直接使用hooks，并且必须始终包含相同数量的hooks。这意味着你永远不能在函数内部（包括在钩子中使用的函数内）或嵌套块（无论是条件还是循环）中调用hooks，而且在你渲染所有hooks之前，你的组件中不能有提前返回。
- en: 'The second rule is kind of obvious, but maybe kind of *not* obvious: you can
    only use hooks inside functional components. You can’t create some helper function
    or callback that calls a hook. You also can’t use them inside class-based components.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则可能很显然，但也许并不那么明显：你只能在函数组件中使用hooks。你不能创建一些辅助函数或回调来调用hook。你也不能在基于类的组件中使用它们。
- en: The only exception to this rule is that you can use hooks inside other hooks,
    which are called *custom hooks*, and you can again use custom hooks inside other
    custom hooks, and so on. But you can only use those custom hooks either in other
    custom hooks or in your components, so you can’t circumvent this rule—you can
    just hide it one layer (or multiple layers) down. We’ll cover custom hooks in
    chapter 10.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是，你可以在其他钩子中使用钩子，这些钩子被称为**自定义钩子**，你还可以在其他自定义钩子中使用自定义钩子，依此类推。但你可以使用这些自定义钩子要么在其他自定义钩子中，要么在你的组件中，所以你不能规避这个规则——你只能将其隐藏一层（或多层）之下。我们将在第
    10 章中介绍自定义钩子。
- en: 7.6 Quiz
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 习题
- en: React has always had and will always have 15 hooks. *True* or *false*?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 一直有，将来也总是会有 15 个钩子。**正确**还是**错误**？
- en: Which of these are considered *stateful* hooks?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些被认为是**状态钩子**？
- en: useState
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState`'
- en: useValue
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useValue`'
- en: useId
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useId`'
- en: useReducer
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useReducer`'
- en: useMemo is a specialized version of useCallback. *True* or *false*?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useMemo` 是 `useCallback` 的一个专用版本。**正确**还是**错误**？'
- en: You can’t call a hook inside a function unless it’s a functional component or
    a custom hook. *True* or *false*?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能在函数内部调用钩子，除非它是功能组件或自定义钩子。**正确**还是**错误**？
- en: Which of the following constructions aren’t allowed?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种构造是不允许的？
- en: '| a. |'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| a. |'
- en: '[PRE5]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| b. |'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| b. |'
- en: '[PRE6]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| c. |'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| c. |'
- en: '[PRE7]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Quiz answers
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 习题答案
- en: '*False*. React 16.8 introduced the first 10 hooks, and React 18.0 added another
    5\. More will definitely come in future releases.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误**。React 16.8 引入了前 10 个钩子，React 18.0 又增加了 5 个。未来版本中肯定还会增加更多。'
- en: useState and useReducer are stateful hooks. useValue isn’t a built-in hook (but
    you could make a custom hook named this if you wanted), and useId is instead used
    for a rather specific memoization purpose.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState` 和 `useReducer` 是状态钩子。`useValue` 不是一个内置钩子（但如果你愿意，你可以创建一个名为此的自定义钩子），而
    `useId` 则用于一个相当特定的记忆目的。'
- en: '*False*. It’s the other way around. useMemo is a general hook for memoizing
    *any value*, whereas useCallback is a hook for memoizing *functions* only.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误**。情况正好相反。`useMemo` 是一个用于记忆**任何值**的通用钩子，而 `useCallback` 是一个仅用于记忆**函数**的钩子。'
- en: '*True*. You shouldn’t attempt to call hooks inside functions that aren’t themselves
    custom hooks. Even though it might seem to work at first, it will only lead to
    problems down the line if you suddenly start calling one of these functions outside
    of a functional component. Obey the principles of hooks!'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**正确**。你不应该在不是自定义钩子的函数中调用钩子。尽管一开始可能看起来可以工作，但如果你突然开始在功能组件之外调用这些函数之一，这只会导致后续出现问题。遵守钩子的原则！'
- en: The illegal constructions are a and b. Only version c is a valid component.
    Versions a and b both use conditional rendering of hooks, which isn’t allowed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 违法的构造是 a 和 b。只有版本 c 是有效的组件。版本 a 和 b 都使用了钩子的条件渲染，这是不允许的。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: React has 15 different built-in hooks, but several of them are rarely used,
    leaving about 10 as the core API on which all React applications are built.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 有 15 个不同的内置钩子，但其中一些很少使用，大约留下 10 个作为所有 React 应用程序构建的核心 API。
- en: Hooks are used for a variety of purposes that make components smart and able
    to interact with the web page as a whole. Even though all the hooks vary wildly
    in their purposes, they all have some common features.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子用于各种目的，使组件变得智能，并能够与整个网页进行交互。尽管所有钩子的用途都大相径庭，但它们都有一些共同的特征。
- en: Stateful hooks are required to make applications stateful. You can use several
    different hooks depending on the complexity of your application and the values
    in your state. With React 18, you can even make lower priority and higher priority
    state updates to help React make your UI as responsive as possible.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态钩子是使应用程序具有状态所必需的。你可以根据应用程序的复杂性和状态中的值使用几个不同的钩子。在 React 18 中，你甚至可以进行低优先级和高优先级的状态更新，以帮助
    React 使你的 UI 尽可能地响应。
- en: Effect hooks are used to run side effects inside components, as you learned
    in chapter 6\. By using the dependency array, you can trigger your effect to run
    at the desired time(s).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效果钩子用于在组件内部运行副作用，正如你在第 6 章中学到的。通过使用依赖数组，你可以触发你的效果在期望的时间（们）运行。
- en: Memoization hooks are used for optimization of rendering in React, once your
    application grows large and complex.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆钩子用于优化 React 中的渲染，一旦你的应用程序变得庞大而复杂。
- en: Library hooks are meant for more complex codebases only and probably aren’t
    relevant for your everyday applications.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库钩子仅适用于更复杂的代码库，可能对你的日常应用不相关。
- en: 'If you use a hook, you must obey the two laws of hooks: only call hooks at
    the top level of a component (so no conditional hooks or loops of hooks), and
    only use hooks inside functional components (so no hooks outside a component,
    in a helper function, or even in a class-based component).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用钩子，你必须遵守钩子的两条法则：只能在组件的最顶层调用钩子（因此不能有条件钩子或钩子的循环），并且只能在函数组件内部使用钩子（因此不能在组件外部、辅助函数中，甚至在基于类的组件中使用钩子）。
