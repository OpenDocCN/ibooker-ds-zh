- en: Part 3\. More sophisticated projects
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分\. 更复杂的项目
- en: This part of the book ups the ante and opens new possibilities through serial
    communication and the snazzy, Node.js-capable Tessel 2 development board.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这一部分通过串行通信和 Node.js 兼容的炫酷 Tessel 2 开发板，提高了难度并开启了新的可能性。
- en: To use more sophisticated sensors and exchange more complex data, you’ll need
    to get a handle on how serial communication works, which is the topic of [chapter
    7](kindle_split_016.html#ch07). You’ll get a chance to experiment with some nifty
    sensors, including an accelerometer, a GPS, and a compass. Along the way, you’ll
    learn the difference between asynchronous and synchronous serial, and you’ll meet
    the I²C and SPI protocols. You’ll also learn to solder.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用更复杂的传感器和交换更复杂的数据，你需要掌握串行通信的工作原理，这是第 [7 章](kindle_split_016.html#ch07) 的主题。你将有机会实验一些有趣的传感器，包括加速度计、GPS
    和指南针。在这个过程中，你将了解异步串行和同步串行的区别，并遇到 I²C 和 SPI 协议。你还将学习焊接技术。
- en: In [chapter 8](kindle_split_017.html#ch08), you’ll untether your projects, going
    wires-free with the Tessel 2 development board. You’ll get to know the Tessel,
    which can run your Johnny-Five scripts natively, and you’ll build more complex
    experiments that make increasing use of third-party npm packages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](kindle_split_017.html#ch08) 中，你将使用 Tessel 2 开发板摆脱线的束缚，实现无线的项目。你将了解
    Tessel，它可以在本地运行 Johnny-Five 脚本，并构建更多更复杂的实验，这些实验越来越多地使用第三方 npm 包。
- en: As you continue your adventure, you’ll likely be starting to think of your own
    things to build. [Chapter 9](kindle_split_018.html#ch09) walks through the steps
    of adapting existing hardware and writing your own software support for components.
    You’ll hack a remote-controlled outlet switch and the APDS-9960 gesture sensor
    breakout board.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续你的冒险，你可能会开始考虑自己要建造的东西。[第 9 章](kindle_split_018.html#ch09) 将介绍如何适应现有硬件并编写你自己的软件支持组件的步骤。你将破解遥控插座开关和
    APDS-9960 手势传感器扩展板。
- en: This part of the book is a step toward more independence and sophistication
    for your projects. You’ll achieve independence from wires via the Tessel’s native
    Node.js and onboard WiFi, and you’ll try out more sophisticated components using
    serial communication.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这一部分是朝着你的项目更加独立和复杂迈出的一步。你将通过 Tessel 的原生 Node.js 和板载 WiFi 实现对线的独立，并尝试使用串行通信使用更复杂的组件。
- en: Chapter 7\. Serial communication
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. 串行通信
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What serial communication is, what it can do, and where it gets used
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行通信是什么，它能做什么，以及它在哪些地方被使用
- en: How to work with asynchronous serial components like GPS modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与异步串行组件（如 GPS 模块）一起工作
- en: An introduction to the core skills of soldering
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊接核心技能简介
- en: 'The basics of synchronous serial communication and the most popular protocols
    for hobby electronics: SPI and I²C'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步串行通信的基础以及业余电子爱好者中最流行的协议：SPI 和 I²C
- en: Building more complex projects by combining multiple serial device components
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合多个串行设备组件来构建更复杂的项目
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](tool.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下物品：**'
- en: 1 Arduino Uno and USB cable
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Arduino Uno 和 USB 线
- en: 1 Adafruit Ultimate GPS breakout board
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Adafruit Ultimate GPS 扩展板
- en: 1 Adafruit HMC5883L magnetometer (compass) breakout board
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Adafruit HMC5883L 磁力计（指南针）扩展板
- en: 1 Adafruit BMP180 multisensor breakout board
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Adafruit BMP180 多传感器扩展板
- en: 1 Adafruit ADXL345 Triple-Axis accelerometer breakout board
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Adafruit ADXL345 三轴加速度计扩展板
- en: 1 16x2 parallel LCD module, or, optionally, I²C-enabled Grove RGB LCD module
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 16x2 并行 LCD 模块，或者可选的 I²C 启用 Grove RGB LCD 模块
- en: 1 rotary potentiometer (for parallel LCD)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个旋转电位器（用于并行 LCD）
- en: Breakaway male header pins
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开式雄性插针
- en: Soldering iron and soldering supplies
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊接铁和焊接材料
- en: Jumper wires
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 2 half-size breadboards
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个半尺寸面包板
- en: '![](0182fig01_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](0182fig01_alt.jpg)'
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In our experiments so far, we’ve been able to glean some fun but straightforward
    data about the world around us, such as temperature ([figure 7.1](#ch07fig01))
    or ambient light intensity. And by listening for variance in a basic digital signal
    (HIGH vs. LOW), we could tell if a button had been pressed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的实验中，我们已经能够收集一些关于周围世界的有趣但简单的数据，例如温度（[图 7.1](#ch07fig01)）或环境光强度。通过监听基本数字信号（高
    vs. 低）的变化，我们可以判断是否按下了按钮。
- en: Figure 7.1\. With a simple analog sensor like the TMP36, you can obtain a value
    for a single data point (temperature) by sampling the voltage of the signal at
    different points in time (A, B, C).
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 使用简单的模拟传感器如TMP36，你可以通过在不同时间点（A、B、C）采样信号的电压来获得单个数据点（温度）的值。
- en: '![](07fig01_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig01_alt.jpg)'
- en: But there’s a lot more information out there than can be (plausibly) relayed
    with a single analog signal. In fact, much of the interesting data is considerably
    more complicated and needs more refined coordination ([figure 7.2](#ch07fig02)).
    What if you want to detect physical motion in three directions simultaneously—like
    from an accelerometer? What about reading information from GPS chips? Precise
    compass coordinates and headings? More sophisticated data calls for more structured,
    sophisticated methods of digital communication between components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但比单一流传模拟信号能传达的信息要多得多。事实上，许多有趣的数据相当复杂，需要更精细的协调([figure 7.2](#ch07fig02))。如果你想同时检测三个方向上的物理运动——比如从加速度计？从GPS芯片读取信息？精确的指南针坐标和航向？更复杂的数据需要更结构化、更复杂的组件间数字通信方法。
- en: Figure 7.2\. The complex digital data from sensors like accelerometers, compasses,
    and GPS modules requires a more sophisticated method of data exchange.
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 加速度计、指南针和GPS模块等传感器产生的复杂数字数据需要更复杂的数据交换方法。
- en: '![](07fig02_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig02_alt.jpg)'
- en: 7.1\. Communicating digital data in parallel and in serial
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 并行和串行通信数字数据
- en: 'Serial communication: it’s a single concept with myriad manifestations. The
    single concept at its core is dead simple: *serial* simply means that information—data—is
    sent one bit at time, one bit following the next. This is in contrast with *parallel*
    communication, in which multiple bits get sent at the same time ([figure 7.3](#ch07fig03)).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 串行通信：这是一个单一的概念，有着无数的表现形式。其核心的单一概念非常简单：*串行*仅仅意味着信息——数据——是逐比特发送的，一个比特接着一个比特。这与*并行*通信形成对比，在并行通信中，多个比特同时发送([figure
    7.3](#ch07fig03))。
- en: Figure 7.3\. In serial communication (top), one bit is sent at a time sequentially.
    In contrast, parallel communication (bottom) transmits multiple bits at the same
    time.
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. 在串行通信（顶部）中，逐个比特按顺序发送。相比之下，并行通信（底部）同时传输多个比特。
- en: '![](07fig03_alt.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig03_alt.jpg)'
- en: 'The benefits of communicating in parallel can be rather evident: why throw
    bits around one at a time if you can open the floodgates and chuck out a whole
    slew of bits simultaneously? It’s true, parallel communication can be very fast.
    But there are some gotchas.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 并行通信的好处可能相当明显：如果你可以打开闸门同时抛出一大批比特，为什么还要一次抛出一个比特呢？确实，并行通信可以非常快。但也有一些需要注意的问题。
- en: 'In fact, you’ve already seen one of the downsides of parallel communication.
    Remember the LCD timer experiment in [chapter 5](kindle_split_013.html#ch05)?
    That circuit used a parallel LCD component. Think back for a moment to the circuit.
    One of its hallmarks was that it required an entire herd of wires. Four of those
    wires were responsible for sending data, in parallel, to the LCD, and that circuit
    only used four of a possible eight parallel data pins on the LCD. Drawback number
    one for parallel: tons of wires.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你已经看到了并行通信的一个缺点。还记得第5章中的LCD计时器实验[kindle_split_013.html#ch05]吗？那个电路使用了一个并行LCD组件。回想一下电路。它的一个特点是需要一大群电线。其中四条电线负责将数据并行发送到LCD，而这个电路只使用了LCD上可能的八个并行数据引脚中的四个。并行的第一个缺点：大量的电线。
- en: Parallel hardware also requires more physical bits and pieces than serial hardware.
    More wires leads to more expensive, complex circuits—and lots of pieces means
    that there are more things that might break.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并行硬件也比串行硬件需要更多的物理比特和部件。更多的电线导致更昂贵、更复杂的电路——更多的部件意味着有更多可能损坏的东西。
- en: 'It’s also tricky to wrangle all of those parallel bits and make sure they get
    to the same place at the same time. In the end, parallel’s complexity can be more
    trouble than it’s worth. And serial, despite its simplicity, is more than fast
    enough. Serial is all around us: HDMI, USB, Ethernet. Serial is the data exchange
    method for a vast array of electronic components. So let’s talk about serial.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同时控制所有这些并行比特并确保它们同时到达同一地点也很棘手。最终，并行的复杂性可能比它的价值更大。而串行，尽管简单，已经足够快了。串行无处不在：HDMI、USB、以太网。串行是大量电子组件的数据交换方法。那么，让我们来谈谈串行。
- en: 7.2\. The basics of serial communication
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 串行通信的基本原理
- en: Although the core concept of serial communication isn’t hard to grasp—one bit
    at a time down the wire—there are an intimidating number of ways that it can actually
    happen. How fast should those bits move around? How many bits make up each discrete
    grouping (*frame*) of delivered data? How are errors detected and corrected? If
    there are more than two components communicating, how does data get sent (*addressed*)
    to the correct component? Is one component in charge (the *master*) of several
    connected components?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然串行通信的核心概念并不难理解——一次一位沿着电线传输——但实际上它发生的方式有很多。这些位应该以多快的速度移动？每个数据分组（*帧*）由多少位组成？错误是如何检测和纠正的？如果有超过两个组件进行通信，数据是如何发送（*寻址*）到正确的组件的？是否有一个组件（*主控*）负责多个连接的组件？
- en: All of the components conversing on the same serial communication channel, or
    *bus*, need to be in agreement about how that conversation is going to work ([figure
    7.4](#ch07fig04))—they need to use the same *protocol*. There are a lot of serial
    protocols, and it can feel overwhelming. The good news is that only a handful
    are commonly used in hobby electronics components. Get a conceptual grip on basic
    asynchronous serial, I²C, and perhaps SPI, and you’ll be in good shape. And if
    you’re feeling especially wary, note that nearly all of the low-level complexity
    can be abstracted out for you by libraries such as Johnny-Five.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一串行通信通道（或总线）上对话的所有组件，需要就如何进行对话达成一致（[图7.4](#ch07fig04)）——它们需要使用相同的*协议*。有大量的串行协议，可能会让人感到不知所措。好消息是，在业余电子组件中只有少数几种是常用的。掌握基本异步串行、I²C，也许还有SPI的概念，你就能处于良好的状态。如果你特别谨慎，请注意，几乎所有低级复杂性都可以通过像Johnny-Five这样的库为你抽象出来。
- en: Figure 7.4\. For devices to exchange data using serial communication, they need
    to know how to talk to each other.
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. 为了使用串行通信交换数据，设备需要知道如何相互交谈。
- en: '![](07fig04_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig04_alt.jpg)'
- en: 7.3\. Asynchronous serial communication
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 异步串行通信
- en: When people refer to *serial* without any further qualification, they often
    mean *asynchronous serial communication*—two devices transmitting (TX) and receiving
    (RX) data between themselves ([figure 7.5](#ch07fig05)). Yet even a setup as simple
    as this needs to have some rules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们提到*串行*而没有进一步说明时，他们通常指的是*异步串行通信*——两个设备在它们之间进行（TX）和（RX）数据传输（[图7.5](#ch07fig05)）。然而，即使是这个简单的设置也需要一些规则。
- en: 'Figure 7.5\. The exchange of asynchronous serial data: each of two connected
    devices can transmit (TX) data to and receive (RX) data from the other component.
    Note that one device’s TX connects to the other’s RX and vice versa. A GPS breakout
    board like Adafruit’s is an example of a component that communicates its data
    using asynchronous serial.'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5\. 异步串行数据交换：两个连接的设备中的每一个都可以将数据（TX）发送到另一个组件，并从另一个组件接收（RX）数据。注意，一个设备的TX连接到另一个设备的RX，反之亦然。像Adafruit的GPS扩展板这样的组件就是使用异步串行通信来传输数据的例子。
- en: '![](07fig05_alt.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig05_alt.jpg)'
- en: '*Asynchronous* serial is so called because there’s no managed clock signal
    shared by the components. Each device has to be its own timekeeper. That’s fine,
    but there has to be a common agreement between components about how many bits
    are sent per unit of time. Put another way, each component needs to know how long
    one bit of data will take—for example, how long will a signal remain HIGH to indicate
    a single 1-bit value? (Without knowing this, how would a receiver be able to tell
    the difference between two sequential 1 bits and a single, long 1 bit?). The speed
    of bits is usually expressed in bits per second (*bps*), or *baud rate*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步*串行之所以被称为异步，是因为组件之间没有共享的管理时钟信号。每个设备都必须是自己时间的守护者。这没问题，但组件之间必须就每单位时间内发送多少位达成共识。换句话说，每个组件需要知道一个数据位将花费多长时间——例如，信号保持HIGH多长时间来表示单个1位值？（如果没有这个信息，接收器如何能够区分两个连续的1位和一个单一的、长时间的1位？）。位速度通常以每秒比特数（*bps*）或*波特率*来表示。'
- en: 'But wait, there’s more! Data isn’t sent in endless streams of 1s and 0s. Instead,
    data is packaged in brief segments called *frames*. Each frame of data sent is
    composed of several parts: the data itself (5–9 bits of it), but also a start
    bit, a stop bit (or two), and, maybe (though not all that often) a *parity bit*
    to aid in error detection ([figure 7.6](#ch07fig06)).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有更多！数据不是以无尽的1和0的流发送的。相反，数据被封装在简短的段中，称为*帧*。发送的每个数据帧都由几个部分组成：数据本身（5-9位），还有一个起始位，一个停止位（或两个），以及可能（但不常）一个*奇偶校验位*来帮助检测错误（[图7.6](#ch07fig06)）。
- en: Figure 7.6\. A frame of asynchronous serial data. A single start bit is followed
    by 5–9 bits of data. A parity bit may be used for error detection. Then one or
    two stop bits indicate the end of the frame.
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6\. 异步串行数据帧。一个起始位后跟 5-9 位数据位。可能使用奇偶校验位进行错误检测。然后一个或两个停止位表示帧的结束。
- en: '![](07fig06_alt.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig06_alt.jpg)'
- en: Each asynchronous protocol configuration defines the specifics of how its data
    frames will be structured, as well as the baud rate. For example, 9600/8N1, a
    common protocol configuration, indicates a data rate of 9600 baud, 8-bit data
    chunks, no parity bit, and one stop bit ([figure 7.7](#ch07fig07)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个异步协议配置定义了其数据帧的具体结构以及波特率。例如，9600/8N1，这是一个常见的协议配置，表示数据速率为 9600 波特，8 位数据块，无奇偶校验位，一个停止位([图
    7.7](#ch07fig07))。
- en: 'Figure 7.7\. The data frame structure of 9600/8N1: start bit, 8 data bits,
    no parity bit, one stop bit'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 9600/8N1 的数据帧结构：起始位，8 个数据位，无奇偶校验位，一个停止位
- en: '![](07fig07_alt.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig07_alt.jpg)'
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Firmata, serial, and a bit more about how Johnny-Five works**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Firmata，串行，以及 Johnny-Five 的工作方式的一些更多内容**'
- en: The architecture of Johnny-Five makes a clear distinction between the exposed,
    high-level JS API for components and the actual I/O implementation under the covers
    that writes data to and reads it from those connected components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five 的架构在暴露的、高级的 JS API 组件和实际写入和从连接组件读取数据的底层 I/O 实现之间做出了明确的区分。
- en: Johnny-Five assumes that compatible dev boards have the ability to perform a
    set of I/O operations. For example, the logic inside of the `Led` class assumes
    it’s possible to enact a digital write to a pin (to set it HIGH or LOW), but it
    doesn’t specifically care *how* that digital write is implemented. Instead, it’s
    the responsibility of compatible *I/O plugins* to define how those operations
    actually take place.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five 假设兼容的开发板能够执行一组 I/O 操作。例如，`Led` 类内部的逻辑假设可以执行对引脚的数字写入（将其设置为 HIGH 或
    LOW），但它并不关心 *如何* 执行该数字写入。相反，定义这些操作实际如何进行的责任在于兼容的 *I/O 插件*。
- en: When you instantiate a `Board` object, you can optionally declare which I/O
    plugin to use. For example, if you wanted to use Johnny-Five with the Tessel 2
    board (and we will, in the next chapter), you can set an `io` option property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化一个 `Board` 对象时，你可以选择声明要使用哪个 I/O 插件。例如，如果你想使用 Johnny-Five 与 Tessel 2 板（我们将在下一章中这样做）一起使用，你可以设置一个
    `io` 选项属性。
- en: Listing 7.1\. Using a different I/O plugin with Johnny-Five
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 使用 Johnny-Five 的不同 I/O 插件
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’ve probably noted that, so far, we haven’t been providing an `io` option
    in our `Board` instantiations. If the option isn’t set, Johnny-Five, by default,
    uses *Firmata* for I/O. That default Firmata I/O layer is compatible with a slew
    of Arduino boards, including your Uno.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，到目前为止，我们还没有在我们的 `Board` 实例化中提供 `io` 选项。如果未设置此选项，Johnny-Five 默认使用 *Firmata*
    进行 I/O。默认的 Firmata I/O 层与一系列 Arduino 板兼容，包括你的 Uno。
- en: 'When running a Johnny-Five Node.js script on your host computer, it’s Firmata
    that’s translating your application’s logic into I/O commands to send to the board.
    It’s also running on the board as firmware and does the translation in the other
    direction: sending data from the board back to the host computer.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在主机计算机上运行 Johnny-Five Node.js 脚本时，是 Firmata 将你的应用程序逻辑转换为发送到板子的 I/O 命令。它也在板上作为固件运行，并在相反方向进行转换：将数据从板子发送回主机计算机。
- en: Firmata’s execution is an example of asynchronous serial in action. Firmata
    data is transmitted in 8-bit chunks (8N1) between the host computer and the Arduino
    board at a fast baud rate. When you execute a Uno-compatible Johnny-Five Node.js
    program on your host computer (“compatible” meaning it uses the default Firmata
    I/O), Firmata data is sent and received through the connected USB cable. (USB
    does stand for Universal *Serial* Bus, after all!) On the Arduino’s end, receiving
    and transmitting serial Firmata data is handled by the Uno’s single on-board Universal
    Asynchronous Receiver/Transmitter (UART) ([figure 7.8](#ch07fig08)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Firmata 的执行是异步串行操作的例子。Firmata 数据以 8 位块（8N1）的形式在主机计算机和 Arduino 板之间以快速波特率传输。当你执行主机计算机上的
    Uno 兼容 Johnny-Five Node.js 程序时（“兼容”意味着它使用默认的 Firmata I/O），Firmata 数据将通过连接的 USB
    线缆发送和接收。(毕竟，USB 代表通用 *串行* 总线！)在 Arduino 端，接收和发送串行 Firmata 数据由 Uno 单个板载通用异步接收/发送器
    (UART) 处理([图 7.8](#ch07fig08))。
- en: Figure 7.8\. A UART is specialized hardware for asynchronous serial communication
    and parallel-to-serial conversion.
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. UART 是一种专门用于异步串行通信和并行到串行转换的硬件。
- en: '![](07fig08_alt.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![07fig08_alt.jpg](07fig08_alt.jpg)'
- en: 'For the curious: although the Firmata protocol defines the structure of messages,
    and the Firmata implementation handles the packaging and processing of these messages,
    the actual nuts-and-bolts mechanics of serial data exchange via your computer’s
    USB port is supported by an npm package called node-serialport.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇者：尽管 Firmata 协议定义了消息的结构，并且 Firmata 实现处理这些消息的打包和处理，但通过计算机的 USB 端口进行串行数据交换的实际机械部分是由一个名为
    node-serialport 的 npm 包支持的。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3.1\. UARTs
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. UARTs
- en: 'A *universal asynchronous receiver/transmitter* (UART) is a piece of hardware
    for handling asynchronous serial communication ([figure 7.8](#ch07fig08)). A UART
    can take a bunch of parallel data—say, data coming from several I/O pins or other
    sources—digest it, and spit it out in a desired serial protocol. It goes the other
    way, too: a UART can also decode incoming serial data and make it available as
    parallel data. Parallel in, serial out—and vice versa. UARTs can be configured
    to speak different flavors of asynchronous serial: different baud rates, and so
    on. That makes UARTs highly flexible and useful bits of hardware.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用异步接收/发送器* (UART) 是一种用于处理异步串行通信的硬件设备 ([图 7.8](#ch07fig08))。UART 可以接收大量的并行数据——比如说，来自几个
    I/O 引脚或其他来源的数据——对其进行处理，并以所需的串行协议输出。反之亦然：UART 也可以解码传入的串行数据并将其作为并行数据提供。并行输入，串行输出——反之亦然。UART
    可以配置为使用不同类型的异步串行：不同的波特率等。这使得 UART 非常灵活，是很有用的硬件。'
- en: The term *transistor-transistor logic* (TTL) in this case refers to the use
    of asynchronous serial communication via UARTs. With TTL, logical HIGH is represented
    as the microcontroller’s Vcc (+5 V in the case of the Uno), and LOW is represented
    as 0 V—that is, the voltage range is always limited to the voltages appropriate
    for the microcontroller at hand.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，术语 *晶体管-晶体管逻辑* (TTL) 指的是通过 UART 进行异步串行通信的使用。在 TTL 中，逻辑 HIGH 被表示为微控制器的
    Vcc（在 Uno 的情况下为 +5 V），而 LOW 被表示为 0 V——也就是说，电压范围始终限制在适合手头微控制器的电压范围内。
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The multiple meanings of TTL**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**TTL 的多重含义**'
- en: 'The term *transistor-transistor logic* (TTL) usually refers to a method for
    constructing digital circuits using transistors for logic—for example, AND gates,
    logical inverters, XOR gates, and so on. Standard voltages used in TTL components
    will look familiar: +5 V to indicate a logical HIGH and 0 V for LOW. TTL ICs,
    especially those compatible with the wildly popular Texas Instruments 7400 family,
    were widely used into the 1990s. They’re still very much available and are useful
    for hobby projects or simpler embedded systems, though they’ve been superseded
    by other technologies for most sophisticated mass-produced electronics (for example,
    *complimentary metal-oxide-semiconductor*, which is abbreviated to something you
    may recognize: *CMOS*).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *晶体管-晶体管逻辑* (TTL) 通常指的是使用晶体管进行逻辑构建数字电路的方法——例如，AND 门、逻辑反相器、XOR 门等。在 TTL 组件中使用的标准电压看起来很熟悉：+5
    V 表示逻辑 HIGH，0 V 表示 LOW。TTL 集成电路，尤其是与广受欢迎的德州仪器 7400 系列兼容的集成电路，在 1990 年代被广泛使用。尽管它们已被其他技术取代，用于大多数复杂的批量生产电子产品（例如，*互补金属氧化物半导体*，简称
    *CMOS*），但它们仍然非常可用，并且对于爱好项目或更简单的嵌入式系统很有用。
- en: Perhaps confusingly, the term *TTL* is also applied to a device or circuit that
    can be connected to another device or circuit without any extra translation or
    interfacing. In this context, it indicates that the signal between the two will
    communicate logically using HIGH (+5 V) and LOW (0 V) logic levels. It’s this
    usage that leads to the convention of alternately referring to asynchronous serial
    as *TTL serial*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人困惑，术语 *TTL* 也被应用于一种可以连接到其他设备或电路而无需任何额外翻译或接口的设备或电路。在这种情况下，它表示两个设备之间的信号将使用
    HIGH (+5 V) 和 LOW (0 V) 逻辑电平进行逻辑通信。正是这种用法导致了将异步串行通信交替称为 *TTL 串行* 的惯例。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Your trusty Arduino Uno has one UART (more accurately, its ATmega 328P microcontroller
    has one UART). While a Johnny-Five script is executing on your host computer,
    the Uno’s UART is busy receiving and transmitting messages in Firmata format.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您的忠实 Arduino Uno 拥有一个 UART（更准确地说，它的 ATmega 328P 微控制器有一个 UART）。当在您的宿主计算机上执行 Johnny-Five
    脚本时，Uno 的 UART 正在忙于接收和发送 Firmata 格式的消息。
- en: There’s a potential conflict here. Say you’ve got a device component you want
    to use in your project that communicates data using async serial. But your Uno’s
    UART is already occupied, monopolized by the Firmata communication it needs to
    carry on in order to make Johnny-Five programs work.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在潜在的冲突。假设你有一个想要在你的项目中使用的设备组件，它使用异步串行通信数据。但你的Arduino Uno的UART已经被用于Firmata通信所占用，这是为了使Johnny-Five程序能够运行。
- en: Fortunately, there’s a way! The work a UART performs is certainly more efficient
    and speedy when implemented in hardware, but it can be emulated in software. So-called
    *software serial* allows you to communicate in async serial via microcontroller
    pins that wouldn’t normally support it at the hardware level. Software serial
    can be processor-intensive and it isn’t as fast as a UART, but it can be *fast
    enough* and gets the job done.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有办法！当UART在硬件中实现时，它执行的工作确实更高效、更快，但也可以在软件中模拟。所谓的*软件串行*允许你通过那些在硬件级别通常不支持异步串行的微控制器引脚进行通信。软件串行可能会占用处理器资源，并且它的速度不如UART快，但它可以*足够快*并且能完成工作。
- en: 7.3.2\. Trying out software serial with a GPS breakout board
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 使用GPS扩展板尝试软件串行
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备的东西
- en: '![](note.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 breadboard
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个面包板
- en: 1 Adafruit Ultimate GPS breakout board
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Adafruit Ultimate GPS扩展板
- en: Red, black, yellow, and white jumper wires
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色、黑色、黄色和白色跳线
- en: Arduino Uno and USB cable
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Uno和USB线
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Here’s where it gets fun—the first time you connect up a GPS and see incoming
    data, it feels pretty awesome. Reading GPS data with an Arduino Uno used to feel
    a little arcane—lots of copying and pasting of Arduino code and relying on low-level
    libraries cooked up by community members. It worked, but it wasn’t terribly intuitive
    for the non-C expert.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开始变得有趣——第一次连接GPS并看到传入的数据，感觉非常棒。使用Arduino Uno读取GPS数据过去感觉有点神秘——需要大量复制粘贴Arduino代码，并依赖于社区成员编写的低级库。它确实有效，但对于非C语言专家来说并不直观。
- en: Interacting with GPS using Johnny-Five these days, however, is so streamlined
    it feels almost magical. Your little GPS chip is listening to *satellites*! It’s
    hard to believe that something so sophisticated can be controlled and sampled
    with only a few, clear lines of JavaScript. Technology is cool.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今使用Johnny-Five与GPS交互变得如此流畅，几乎感觉像魔法。你的小GPS芯片正在监听*卫星*！难以相信如此复杂的设备可以用几行清晰的JavaScript代码进行控制和采样。技术真酷。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**GPS data and NMEA sentences**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**GPS数据和NMEA句子**'
- en: 'Many GPS chips output data conforming to a standard called NMEA 0183\. The
    National Marine Electronics Association (NMEA) maintains this standard, which
    defines the structure of data from the kinds of hardware you might expect to find
    aboard a seagoing vessel: sonar, gyroscopes, marine radar—and GPS.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多GPS芯片输出的数据符合称为NMEA 0183的标准。国家海洋电子协会（NMEA）维护此标准，该标准定义了从你可能在海上航行船只上找到的硬件（如声纳、陀螺仪、海上雷达和GPS）的数据结构。
- en: NMEA data is communicated over asynchronous serial as ASCII characters—ASCII
    characters are 7 bits, which fit nicely inside of a byte of data—and those characters
    are assembled into comma-delimited *NMEA sentences*. Although the standard does
    make mention of a particular configuration (4800 8N1), NMEA data can be sent over
    various configurations. The GPS breakout from Adafruit defaults to 9600 baud,
    but some GPS modules can transmit even faster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: NMEA数据以ASCII字符形式通过异步串行进行通信——ASCII字符是7位，非常适合数据字节——这些字符被组装成逗号分隔的*NMEA句子*。尽管标准确实提到了特定的配置（4800
    8N1），但NMEA数据可以通过各种配置发送。Adafruit的GPS扩展板默认为9600波特率，但一些GPS模块可以传输得更快。
- en: '![](0189fig01_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](0189fig01_alt.jpg)'
- en: Sample NMEA sentence and some of its fields explained. Data transmitted from
    the GPS is sent in comma-delimited ASCII conforming to the NMEA standard.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 样本NMEA句子及其一些字段解释。从GPS传输的数据以符合NMEA标准的逗号分隔ASCII格式发送。
- en: Johnny-Five’s `GPS` class parses NMEA sentences from the GPS hardware using
    software serial and organizes them into handy properties like `latitude` and `longitude`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five的`GPS`类使用软件串行从GPS硬件解析NMEA句子，并将它们组织成方便的属性，如`latitude`（纬度）和`longitude`（经度）。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The good news is that building a circuit with a GPS breakout board requires
    minimal connections. You’ll find that the supporting electronic components are
    often built into breakout boards—capacitors, resistors, and so on—leaving you
    with just power and data connections to hook up.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，使用GPS扩展板构建电路只需要最少的连接。你会发现，辅助电子组件通常已经集成在扩展板上——电容器、电阻器等等——只留下电源和数据连接需要连接。
- en: On the flip side, you’ll need to learn to solder now. The Adafruit GPS breakout
    board needs to be soldered onto headers so that you can plug it into a breadboard
    ([figure 7.9](#ch07fig09)). Soldering isn’t hard, but like any new core life skill,
    it can take a few tries before you’ll have your soldering sea legs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，你现在需要学习焊接。Adafruit GPS扩展板需要焊接在引脚上，以便你可以将其插入面包板([图7.9](#ch07fig09))。焊接并不难，但像任何新的核心生活技能一样，你可能需要尝试几次才能熟练掌握。
- en: Figure 7.9\. Before you can use it on a breadboard, the GPS needs to have some
    header pins soldered to it.
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9\. 在你可以在面包板上使用它之前，GPS需要焊接一些引脚。
- en: '![](07fig09_alt.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![07fig09_alt.jpg](07fig09_alt.jpg)'
- en: 7.3.3\. Learn to solder!
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 学习焊接！
- en: '*Solder* is a metal alloy intended for making—*fusing*—permanent bonds between
    bits of metal ([figure 7.10](#ch07fig10)). Solder melts at a lower temperature
    than the legs and connections of your components, allowing it to flow, liquid,
    around those connections without damaging them. Once it hardens—this happens nearly
    instantly—you’ve got a permanent connection. It’s sort of like conductive metal
    glue. Solder comes in long, thin lengths on a spool, like wire.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*焊料*是一种金属合金，用于在金属碎片之间形成——*熔接*——永久连接([图7.10](#ch07fig10))。焊料的熔点低于你的组件腿和连接，允许它在这些连接周围流动，液态，而不损坏它们。一旦它硬化——这几乎瞬间发生——你就得到了一个永久连接。它有点像导电金属胶水。焊料像电线一样，卷在卷轴上，细长。'
- en: Figure 7.10\. Solder comes on a wound spool, like thread.
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10\. 焊料像线一样卷在卷轴上。
- en: '![](07fig10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![07fig10.jpg](07fig10.jpg)'
- en: To provide the heat needed to melt solder and make those connections, you’ll
    need a *soldering iron* ([figure 7.11](#ch07fig11)). Soldering irons range from
    ten bucks (U.S.) to several hundred. Unsurprisingly, you get what you pay for.
    Cheap soldering irons behave in, well, cheap ways and aren’t adjustable. But an
    inexpensive soldering iron will get the job done just fine if you’re not ready
    to invest in a quality model.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供熔化焊料并形成这些连接所需的热量，你需要一个*烙铁*([图7.11](#ch07fig11))。烙铁的价格从10美元(美国)到几百美元不等。不出所料，你得到的就是你付出的。便宜的烙铁表现得很便宜，不可调节。但如果你还没有准备好投资一个高质量的模型，一个便宜的烙铁也能很好地完成任务。
- en: Figure 7.11\. A run-of-the-mill inexpensive soldering iron. Cheap ones don’t
    typically have temperature-control settings—they just get one flavor of hot.
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11\. 一款普通的廉价烙铁。便宜的那些通常没有温度控制设置——它们只是保持一种热度。
- en: '![](07fig11_alt.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![07fig11_alt.jpg](07fig11_alt.jpg)'
- en: Make sure your soldering iron has a *stand* to put it in when it’s not in your
    hand ([figure 7.12](#ch07fig12)). You’ll also need sponge for cleaning the tip
    of your soldering iron between solders and for tinning the tip (more on that shortly).
    Good soldering sponges are brass, but regular household sponges work, too. If
    you use a cellulose household sponge, make sure to dampen it before using it with
    your iron.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的烙铁有一个*支架*，当它不在你手中时可以放进去([图7.12](#ch07fig12))。你还需要海绵来清洁烙铁尖端，在焊接之间以及给尖端上锡（稍后会有更多介绍）。好的焊接海绵是黄铜的，但普通的家用海绵也行。如果你使用纤维素家用海绵，确保在使用烙铁之前将其弄湿。
- en: Figure 7.12\. Your soldering iron needs a stand to hold it when not in use,
    and to protect things around it from burning.
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.12\. 当烙铁不用时，需要一个支架来固定它，并保护周围的东西免受烧毁。
- en: '![](07fig12_alt.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![07fig12_alt.jpg](07fig12_alt.jpg)'
- en: Putting together your soldering kit
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 组装你的焊接套件
- en: If the list of necessary soldering supplies seems onerous ([figure 7.13](#ch07fig13)),
    you might consider a “learn-to-solder” kit, sold by online electronics retailers,
    which comes with most of the items you’ll need and a practice project to boot.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必要的焊接材料清单看起来很繁琐([图7.13](#ch07fig13))，你可能考虑购买一个“学习焊接”套件，由在线电子产品零售商销售，其中包含你需要的多数物品，还有一个实践项目。
- en: Figure 7.13\. Key things you’ll need to start soldering
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.13\. 开始焊接所需的关键物品
- en: '![](07fig13_alt.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![07fig13_alt.jpg](07fig13_alt.jpg)'
- en: Solder, traditionally, is made of an alloy containing a high percentage of lead.
    As you likely know, lead is bad for humans. Since 2006, the use of lead in electronics
    has been restricted in the EU via the Restriction of Hazardous Substances Directive
    (RoHS), which has all but eliminated the use of lead in manufacturing solder.
    Lead-free solder is definitely good for people and the earth, but it’s also a
    little more challenging to work with—it doesn’t flow as smoothly as leaded solder.
    Both lead-free and leaded solder are available; some feel that learning to solder
    with leaded solder is easier than with lead-free.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，焊锡是由含有高比例铅的合金制成的。正如你可能知道的，铅对人类有害。自2006年以来，欧盟通过《有害物质限制指令》(RoHS)限制了电子中使用铅，这几乎消除了制造焊锡中使用铅。无铅焊锡无疑对人类和地球都有好处，但它也稍微有点难以操作——它不像含铅焊锡那样流动顺畅。无铅和含铅焊锡都可用；有些人认为学习使用含铅焊锡比使用无铅焊锡更容易。
- en: 'You may also wish to pick up a spool of solder wick (a.k.a. *desoldering braid*).
    This braided copper wire acts as a chemical vacuum cleaner to undo bad solders:
    reheat the soldered joint and use the solder braid to wick up the misplaced solder.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想买一卷焊锡吸球(也称为*脱焊线*)。这种编织铜线充当化学真空吸尘器，用于去除不良焊点：重新加热焊点，并使用焊锡吸球吸取多余的焊锡。
- en: How to solder, step by step
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如何焊接，一步一步来
- en: 'Read these instructions completely before setting out to solder, so you’re
    prepared and ready to rock:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始焊接之前，请完全阅读这些说明，这样你就准备好了，可以大显身手：
- en: Before you begin, set up your workspace using a third hand ([figure 7.14](#ch07fig14))
    or some other method for securing your work and leaving your hands free—slotting
    header pins into a breadboard and positioning the board in place on top is also
    an option. Have the tools and parts you anticipate needing at the ready so you’re
    not flailing around with a hot soldering iron later.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，使用三爪夹具([图7.14](#ch07fig14))或其它方法来固定你的工作台，并让你的双手自由——将排针插入面包板并将板子放置在适当位置也是一种选择。准备好你预计需要的工具和零件，这样你就不需要在之后手忙脚乱地拿着热焊锡枪了。
- en: Figure 7.14\. Secure your components before soldering. A third hand is a convenient
    tool for this.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.14。在焊接之前固定你的组件。三爪夹具是完成这项工作的方便工具。
- en: '![](07fig14.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](07fig14.jpg)'
- en: Plug your soldering iron in and let it heat up for several minutes. Now, especially
    if you have an inexpensive model, wait a few more minutes—that is, be patient.
    Working with a soldering iron that’s not hot enough is a recipe for frustration
    and singed boards.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插上你的焊锡枪并让它加热几分钟。现在，特别是如果你有一个价格低廉的型号，再等几分钟——也就是说，要有耐心。使用不够热的焊锡枪是令人沮丧和烧焦电路板的原因。
- en: Prepare (*tin*) your soldering iron’s tip. Melt a little bit of solder onto
    the tip of the iron and then wipe off the excess on your sponge. This should result
    in a shiny, bright tip on your soldering iron. If the solder doesn’t melt readily
    when you touch it to the iron’s tip, the iron isn’t hot enough. Wait a few more
    minutes and try again.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备(加锡)你的焊锡枪尖端。在焊锡枪的尖端熔化一点焊锡，然后在你的海绵上擦掉多余的焊锡。这应该在你的焊锡枪上留下一个闪亮的、明亮的尖端。如果你将焊锡接触到焊锡枪的尖端时焊锡不轻易熔化，那么焊锡枪不够热。等待几分钟再试一次。
- en: Hold the soldering iron in your dominant hand and the solder in your other hand.
    Press the tip of your hot iron to the header pin and the connection pad for about
    one second ([figure 7.15](#ch07fig15)).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你的主手握住焊锡枪，用另一只手握住焊锡。将热焊锡枪的尖端压在排针和连接垫上大约一秒钟([图7.15](#ch07fig15))。
- en: Figure 7.15\. Place the soldering iron’s tip on the metal connection pad and
    the pin to heat them up.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.15。将焊锡枪的尖端放在金属连接垫和引脚上，以加热它们。
- en: '![](07fig15.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](07fig15.jpg)'
- en: Keep the iron in place and apply the end of the solder to the opposite side
    of the joint ([figure 7.16](#ch07fig16)). You won’t be melting the solder directly
    with the iron—solder instead comes into contact with the heated pin and board
    connection. Keep your soldering iron at the bottom of the pin; ignore the temptation
    to move it up toward the solder.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持焊锡枪的位置，并将焊锡的末端涂在接合点的另一侧([图7.16](#ch07fig16))。你不会直接用焊锡枪熔化焊锡——焊锡会与加热的引脚和板子连接接触。保持你的焊锡枪在引脚的底部；忽略将焊锡枪向上移动到焊锡的诱惑。
- en: Figure 7.16\. The heated pin will cause the solder to melt and flow around the
    joint.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.16。加热的引脚会使焊锡熔化并围绕接合点流动。
- en: '![](07fig16.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](07fig16.jpg)'
- en: The solder will melt and flow around the joint. Once you have a nice-looking
    mountain-shaped mound of solder ([figure 7.17](#ch07fig17)), remove the soldering
    iron and voila! You’ll find with time that the solder kind of naturally “wants”
    to flow into that volcano shape.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 焊料会熔化并围绕焊点流动。一旦你得到一个漂亮的火山形状的焊料堆（[图7.17](#ch07fig17)），取下烙铁，哇！你会发现随着时间的推移，焊料似乎自然而然地“想要”流向那个火山形状。
- en: Figure 7.17\. A well-soldered connection resembles a little volcano of solder.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.17\. 一个良好的焊接连接看起来像一个小焊料火山。
- en: '![](07fig17.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](07fig17.jpg)'
- en: 'Soldering isn’t complicated, but it can take a few rounds to get it quite right.
    YouTube and the web are your friend: there are tons of videos and tutorials for
    learning to solder. It’s one of those skills that may be easier to understand
    if you watch it in motion. SparkFun’s “Through-Hole Soldering” tutorial is clear
    and straightforward ([http://mng.bz/cv1Z](http://mng.bz/cv1Z)).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 焊接并不复杂，但要完全做对可能需要几轮。YouTube和互联网是你的朋友：有大量的视频和教程教你如何焊接。这是一种如果你看到它在运动中可能更容易理解技能。SparkFun的“通孔焊接”教程清晰易懂（[http://mng.bz/cv1Z](http://mng.bz/cv1Z)）。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Common challenges for soldering newbies**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**焊接新手常见挑战**'
- en: 'Like any new physical skill, soldering takes a while to master. Here are some
    of the common things that can slow you down:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何新的物理技能一样，焊接需要一段时间才能掌握。以下是一些可能让你慢下来的常见事情：
- en: '***A soldering gun you know to be hot doesn’t seem to “want” to melt solder,
    or, “it just doesn’t seem to work”*—** Make sure you keep the tip of your soldering
    iron *tinned*, that is, coated with just a bit of solder. You can tell a tip is
    tinned because it will be shiny. If your soldering iron’s tip is black or matte-textured,
    it’s oxidized and you need to *re-tin* it. This process can be tedious: you need
    to get solder melted so that it will coat the tip, but non-tinned parts of the
    tip don’t cause the chemical reaction that causes solder to flow correctly. Take
    your time, be patient, and get this right, using your sponge to help direct the
    solder and wipe off excess. The best way to fix this is to keep it from happening
    in the first place: check your iron after every few soldered joints, and touch
    up the tip with some additional solder if it starts to look oxidized in any spot.
    Note that lead-free solder will cause your soldering iron to oxidize considerably
    faster than leaded solder.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***你知道烙铁很热，但它似乎“不想”熔化焊料，或者说，“它就是不起作用”*—** 确保你保持烙铁尖端*镀锡*，也就是说，涂上一点焊料。你可以通过尖端变得闪亮来判断尖端是否镀锡。如果你的烙铁尖端是黑色或哑光纹理，它已经氧化了，你需要*重新镀锡*。这个过程可能很繁琐：你需要让焊料熔化，这样它才能覆盖尖端，但未镀锡的尖端部分不会引起使焊料正确流动的化学反应。花点时间，耐心，正确地完成这个过程，使用海绵帮助引导焊料并擦掉多余的焊料。最好的办法是防止这种情况发生：在每焊接几个接头后检查烙铁，如果任何地方开始看起来氧化，就使用额外的焊料进行修补。注意，无铅焊料会使你的烙铁氧化得比含铅焊料快得多。'
- en: '***Blackened, warped, or singed boards*—** Soldering doesn’t damage components
    if you don’t apply too much heat, but it’s pretty easy to mess this up by touching
    your soldering iron to the board (instead of the metal connections), using too
    high a temperature setting, holding the iron too long against a component, and
    so on. You’ll get better at this with practice. Often singed-looking boards or
    components will still function okay, but sometimes you may find that you’ve truly
    fried something. Go slow, aim carefully, and try out your first few soldering
    tasks on inexpensive components, just in case.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***烧黑、变形或烧焦的电路板*—** 如果你不使用过多的热量，焊料不会损坏组件，但很容易因为将烙铁接触到电路板（而不是金属连接），使用过高的温度设置，长时间将烙铁对准组件，等等，而搞砸。通过练习你会变得更好。通常看起来烧焦的电路板或组件仍然可以正常工作，但有时你可能发现你真的烧毁了某个东西。慢慢来，仔细瞄准，并在便宜的组件上尝试你的第一次焊接任务，以防万一。'
- en: '***Soldered joints don’t work right*—** A joint without enough solder (a “cold
    joint”) won’t conduct—plug your soldering iron back in and try again. Another
    common problem is accidentally using too much solder and soldering the connection
    to a neighboring connection as well, causing any number of woes with the circuit.
    An overabundance of solder can be cleaned up with *soldering wick*.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***焊接接头不工作*—** 如果焊料不足（“冷焊”）的接头不会导电——重新插上烙铁再试一次。另一个常见问题是意外使用过多的焊料，并将连接焊接到相邻的连接上，导致电路出现各种问题。过多的焊料可以用*焊料吸球*清理。'
- en: '***Solder just won’t stick to the thing you’re trying to stick it to*—** Soldering
    is a chemical process. You can’t solder to non-metal surfaces like plastics, and
    even some metals are non-solderable.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***焊锡根本无法粘附到你试图粘附的东西上*——** 焊接是一个化学过程。你不能在非金属表面如塑料上焊接，甚至一些金属也不可焊接。'
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3.4\. Building the GPS circuit
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.4\. 构建GPS电路
- en: Once the header pins are soldered onto the GPS breakout board, building the
    circuit is a snap. Plug the GPS into the breadboard. Connect power and GND to
    the Uno’s 5 V and GND pins, respectively. Connect the board’s TX pin to pin 11
    on the Uno, and the RX to pin 10 ([figure 7.18](#ch07fig18)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将引脚头焊接到GPS扩展板上，构建电路就变得简单了。将GPS插入面包板。将电源和GND分别连接到Arduino Uno的5V和GND引脚。将板的TX引脚连接到Arduino
    Uno的11号引脚，RX连接到10号引脚([图7.18](#ch07fig18))。
- en: Figure 7.18\. GPS circuit wiring diagram
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.18\. GPS电路布线图
- en: '![](07fig18.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig18.jpg)'
- en: Reading GPS data with Johnny-Five
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Johnny-Five读取GPS数据
- en: The code required is breathtakingly simple. In your Johnny-Five working directory,
    create a new file called gps.js and add the following code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的代码简单得令人惊叹。在你的Johnny-Five工作目录中，创建一个名为gps.js的新文件，并添加以下代码。
- en: Listing 7.2\. Johnny-Five GPS
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. Johnny-Five GPS
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Software serial is supported on these pins—and only these pins—on the
    Uno.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 软件串行仅在这些引脚——并且只有这些引脚——上支持Uno。**'
- en: '***2* Makes the GPS object (gps) available in the REPL**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使GPS对象（gps）在REPL中可用**'
- en: As soon as the GPS board is connected to power, it will start trying to get
    a satellite fix. Until it has a fix, you’ll see an onboard LED blink about once
    per second.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦GPS板连接到电源，它就会开始尝试获取卫星定位。直到它有定位，你将看到板载LED大约每秒闪烁一次。
- en: The GPS has a built-in antenna, but it won’t be able to get a satellite fix
    without exposure to a wide slice of sky. Most likely, you’ll need to go outside.
    With luck, this requirement won’t be too cumbersome—scoop up your laptop and Uno
    and breadboard, and head to the great outdoors for a few minutes. Then again,
    it was 24 degrees (F) out and spitting snow pellets when I tested this code. Or
    maybe you’re working on a desktop computer, which isn’t going to be outdoor-friendly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: GPS内置了天线，但如果没有暴露在广阔的天空区域，它将无法获取卫星定位。很可能会需要你外出。幸运的是，这个要求可能不会太麻烦——拿起你的笔记本电脑、Arduino
    Uno和面包板，到户外待几分钟。然而，当我测试这个代码时，外面是24华氏度（F）并且下着雪球。或者你可能正在使用台式电脑，这不太可能适合户外使用。
- en: You might have luck next to a large window with a clear view of the sky, or
    you may be able to use a longer USB cord so that your Uno and breadboard can sit
    outside while your computer is inside.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在大窗户旁边，有清晰的视野看到天空时会有所帮助，或者你可能能够使用更长的USB线，这样你的Arduino Uno和面包板可以放在户外，而你的电脑在室内。
- en: It takes about 30–60 seconds to get a solid (“cold-start”) satellite fix.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个稳定的（“冷启动”）卫星定位大约需要30-60秒。
- en: “But wait,” you say, “my phone can get my GPS position in just a few seconds...and
    it works inside. What gives?”
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: “但是等等，”你说，“我的手机可以在几秒钟内获取我的GPS位置……并且它可以在室内工作。怎么回事？”
- en: 'Your smartphone uses some extra tricks to derive your location: where it is
    relative to local cell phone towers and nearby WiFi networks. In fact, for your
    phone to get a real GPS lock—the satellite kind—it can take just as long or longer
    than these standalone chips—up to several minutes.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你的智能手机使用一些额外的技巧来确定你的位置：它相对于本地手机塔和附近的WiFi网络的位置。实际上，为了你的手机能够获得真正的GPS锁定——卫星类型的——这可能需要与这些独立芯片一样长或更长的时间——长达几分钟。
- en: 'Once your GPS chip has a satellite fix, the onboard LED will stop blinking
    so quickly, slowing down to one blink every 15 seconds. It doesn’t matter when
    you start the gps.js script—before the chip has a fix or after—but, obviously,
    location data won’t be available until the fix is solid:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的GPS芯片有了卫星定位，板载LED将停止快速闪烁，减慢到每15秒闪烁一次。你启动gps.js脚本的时间无关紧要——在芯片有定位之前或之后——但显然，直到定位稳定之前，位置数据将不可用：
- en: '[PRE2]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assuming you have a fix, you can now start interacting with your GPS and logging
    out data, as shown in the next listing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经有了修复方案，现在你可以开始与你的GPS交互并记录数据，如下面的列表所示。
- en: Listing 7.3\. Photoresistor data logging output
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 光敏电阻数据记录输出
- en: '[PRE3]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All right, cool—almost too easy! You can try inspecting other properties on
    your `gps` object, like `longitude`. See the Johnny-Five GPS documentation for
    the latest about what you can do ([http://johnny-five.io/api/gps/](http://johnny-five.io/api/gps/)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，太酷了——几乎太简单了！你可以尝试检查你的`gps`对象上的其他属性，比如`longitude`。有关你可以做什么的最新信息，请参阅Johnny-Five
    GPS文档([http://johnny-five.io/api/gps/](http://johnny-five.io/api/gps/))。
- en: Nice. You’ve mastered basic asynchronous serial connectivity using software
    serial. Let’s see what else serial can do.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。你已经掌握了使用软件串行实现的基本异步串行连接。让我们看看串行还能做什么。
- en: 7.4\. Synchronous serial communication
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 同步串行通信
- en: 'Async serial is straightforward and useful, but it isn’t the right fit for
    everything. To account for small potential differences in the clocks of each of
    the components, each data chunk has to be surrounded by start and stop bits, and
    maybe a parity bit is thrown in there, too. That’s a sizable overhead: best case
    (one start bit, one stop bit, no parity), it takes 10 bits to transmit 8 bits
    of information. UART hardware is complex, and software implementations are slower
    and processor-intensive. Getting the baud rate and other details sorted out between
    components can be finicky. Finally, async serial is really only cut out for letting
    two devices talk to each other.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 异步串行简单且有用，但并不适合所有情况。为了考虑到每个组件时钟之间可能存在的小差异，每个数据块都必须被起始位和停止位包围，也许还会加入一个奇偶校验位。这是一个相当大的开销：最佳情况（一个起始位，一个停止位，无奇偶校验），传输8位信息需要10位。UART硬件复杂，软件实现较慢且占用处理器资源。在组件之间整理波特率和其他细节可能会很棘手。最后，异步串行实际上只适合让两个设备进行通信。
- en: Synchronous serial protocols add a shared clock line in addition to data connections
    for synchronizing components. Because the clock signal dictates the speed of the
    data transmission, the data rate of components doesn’t have to be configured beforehand.
    Certain synchronous serial protocols also make it possible and convenient to communicate
    among many devices on the same communication bus. There are also drawbacks; for
    example, both the SPI and I²C protocols you’re about to meet require connecting
    wires to be short—for example, you can’t reasonably communicate using I²C over
    a 20-foot cable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同步串行协议在数据连接之外还增加了一个共享时钟线，用于同步组件。由于时钟信号决定了数据传输的速度，因此不需要事先配置组件的数据速率。某些同步串行协议还使得在同一通信总线上多个设备之间的通信变得可能且方便。但也存在一些缺点；例如，你即将遇到的SPI和I²C协议都需要连接的线尽可能短——例如，你不能合理地使用I²C通过20英尺的电缆进行通信。
- en: 7.4.1\. Serial Peripheral Interface (SPI)
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. 串行外设接口（SPI）
- en: Serial Peripheral Interface (SPI) is a synchronous serial protocol originally
    developed by Motorola in the 1980s. It allows for a “master” device to control
    and coordinate data exchange between itself and one or more “slave” devices. For
    a one-to-one master-slave connection, as few as three wires can be used ([figure
    7.19](#ch07fig19)), but four or more are required if there are multiple slave
    devices ([figure 7.20](#ch07fig20)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 串行外设接口（SPI）是一种同步串行协议，最初由摩托罗拉在20世纪80年代开发。它允许一个“主”设备控制并协调自身与一个或多个“从”设备之间的数据交换。对于一对一的主从连接，可以使用最少的三个线（[图7.19](#ch07fig19)），但如果有多于一个的从设备，则需要四条或更多的线（[图7.20](#ch07fig20)）。
- en: 'Figure 7.19\. In a simple SPI configuration—one master, one slave—as few as
    three wires can be used for data exchange: a shared clock line (SCK) managed by
    the master, master-out-slave-in (MOSI), and master-in-slave-out (MISO).'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.19\. 在一个简单的SPI配置中——一个主设备，一个从设备——数据交换可以使用最少的三个线：一个由主设备管理的共享时钟线（SCK）、主设备输出从设备输入（MOSI）和主设备输入从设备输出（MISO）。
- en: '![](07fig19_alt.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19的替代图片](07fig19_alt.jpg)'
- en: Figure 7.20\. When more devices are added, at least one additional line—slave-select
    (SS)—is needed, though some SPI configurations require one SS line per slave device.
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.20\. 当添加更多设备时，至少需要一条额外的线——从设备选择（SS），尽管某些SPI配置可能需要为每个从设备一个SS线。
- en: '![](07fig20_alt.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20的替代图片](07fig20_alt.jpg)'
- en: SPI’s biggest advantage is that it allows for really fast data transmission
    rates. The receive hardware is also significantly simpler than a UART. SDCard
    memory cards are a popular example of real-world use of the SPI protocol.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SPI最大的优点是它允许实现真正快速的数据传输速率。接收硬件也比UART简单得多。SD卡存储卡是SPI协议在实际应用中的流行例子。
- en: 'SPI components are widely available to hobby tinkerers. Johnny-Five has support
    for a certain SPI barometer, for example. Also, we’ll work with an LCD module
    (Nokia 5110) in [chapter 10](kindle_split_020.html#ch10) that has an SPI interface.
    But SPI components aren’t nearly as common as the big-hitter protocol: I²C. That’s
    where we’ll put our attention.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SPI组件对业余爱好者来说非常容易获得。例如，Johnny-Five支持某些SPI气压计。此外，我们将在第10章（[kindle_split_020.html#ch10](kindle_split_020.html#ch10)）中使用具有SPI接口的LCD模块（诺基亚5110）。但SPI组件并不像I²C这样的主流协议那么常见。这就是我们将关注的焦点。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**An aside on terminology**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于术语的补充说明**'
- en: I’m no fan of the archaic *master-slave* terminology to describe certain metaphors
    in electronics and computer science. But it’s entirely pervasive in serial protocols—for
    example, it’s hard-baked into acronyms like *MOSI* and *MISO*. Thus, I am using
    *master-slave* language here, reluctantly, as to do otherwise could lead to confusion.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不喜欢使用过时的**主从**术语来描述电子和计算机科学中的某些隐喻。但在串行协议中，这种术语却无处不在——例如，它在像**MOSI**和**MISO**这样的缩写中根深蒂固。因此，我这里不情愿地使用**主从**语言，否则可能会导致混淆。
- en: Note also that in these discussions about different serial configurations, the
    dev board’s serial hardware is playing the part of “master,” and the connected
    devices are the “slaves.”
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这些关于不同串行配置的讨论中，开发板上的串行硬件扮演着“主”的角色，而连接的设备则是“从”。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.4.2\. I²C
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2\. I²C
- en: '*Inter-Integrated Circuit* (more commonly written as *I²*C**, pronounced “I-squared-C”)
    is a synchronous serial protocol created by Philips Semiconductor (which is now
    NXP). Although it’s not quite as fast as SPI, I²C makes up for it with flexibility
    and simplicity—only two wires ([figure 7.21](#ch07fig21))!'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成电路间通信**（通常写作**I²C**，发音为“I-squared-C”）是由飞利浦半导体（现在是恩智浦）创建的一种同步串行协议。尽管它的速度并不比SPI快，但I²C通过灵活性和简单性来弥补这一点——只需两条线（[图7.21](#ch07fig21)）！'
- en: 'Figure 7.21\. No matter how many devices are connected together, with I²C there
    are always just two lines: SCL (clock) and SDA (data).'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.21\. 无论连接了多少个设备，使用I²C时始终只有两条线：SCL（时钟）和SDA（数据）。
- en: '![](07fig21_alt.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图7.21](07fig21_alt.jpg)'
- en: With I²C, you can have up to, oh, about a thousand devices on a single bus (1008
    if you use 10-bit addressing; the more common 7-bit addressing allows up to 127).
    That means that you’re back to the connection simplicity of async serial—minimal
    wires—but you get the benefits of sync serial—multiple devices and no advance
    configuration.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在I²C中，你可以在单条总线上连接多达，哦，大约一千个设备（如果你使用10位寻址，则是1008个；更常见的7位寻址允许最多127个）。这意味着你回到了异步串行的连接简单性——最少的线缆——但你得到了同步串行的好处——多个设备和无需预先配置。
- en: All of the data for all connected components is carried on a single SDA (serial
    data) line. The second wire is SCL (serial clock), which, like SDA, is shared
    by all of the connected components. Connect each device to the SDA and SCL lines
    (and give ’em some power!), and you’re ready to go.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所有连接组件的数据都通过单一的SDA（串行数据）线传输。第二条线是SCL（串行时钟），它像SDA一样被所有连接组件共享。将每个设备连接到SDA和SCL线（并给它们一些电源！），你就可以开始了。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How I²C devices talk to each other**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**I²C设备如何相互通信**'
- en: Because there are often many I²C components on the same bus, I²C messages have
    to be more structured, and something needs to take control of directing traffic.
    One or more *master* device on the bus has this authority. The active master (there
    can be more than one master device on a bus, but only one can be *actively* in
    charge at any given time) generates the clock signal and tells other devices when
    to transmit or receive data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为通常有很多I²C组件连接在同一个总线上，所以I²C消息必须更加结构化，并且需要某种机制来控制交通。总线上的一个或多个**主**设备拥有这种权限。活动的主设备（总线上可以有多个主设备，但任何给定时间只能有一个主设备处于**活动**状态）生成时钟信号，并告知其他设备何时发送或接收数据。
- en: To start the ball rolling, the active master first transmits an *address* frame
    (first frame on left in the following figure) to determine which connected slave
    device needs to perform the subsequent action.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个过程，活动的主设备首先发送一个**地址**帧（以下图中左侧的第一个帧）以确定哪个连接的从设备需要执行后续操作。
- en: '![](0199fig01_alt.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图0199](0199fig01_alt.jpg)'
- en: High-level structure of I²C frames
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: I²C帧的高级结构
- en: Each connected device on the bus has its own, unique address. Commonly, this
    is a 7-bit address, and the full (8-bit) address frame consists of 7 address bits
    followed by a R/W (read/write) bit. The R/W bit designates whether the indicated
    device should read or write data. The addressed device is then expected to transmit
    a single ACK bit to indicate that all systems are go. Then data frames can be
    transmitted, each frame followed by an ACK bit. All this is choreographed by the
    shared clock signal.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 总线上的每个连接设备都有自己的、唯一的地址。通常，这是一个7位地址，完整的（8位）地址帧由7位地址位后跟一个R/W（读/写）位组成。R/W位指定指示的设备应该读取还是写入数据。然后，被寻址的设备预期会发送一个单ACK位来指示所有系统正常工作。然后可以发送数据帧，每个帧后面跟着一个ACK位。所有这些都是在共享时钟信号的协调下进行的。
- en: The ins and outs of the protocol’s details are a bit more involved—for example,
    you’d need to use 10-bit addresses to exercise the 1008-device bus maximum (7-bit
    numbers don’t go higher than 127, and every device needs to have a unique address)
    and the exact mechanics of a read-from-slave process require identifying things
    like which memory register to read from. If you want to learn more, I recommend
    Sparkfun’s “I²C” tutorial ([https://learn.sparkfun.com/tutorials/i2c](https://learn.sparkfun.com/tutorials/i2c)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 协议细节的输入输出稍微复杂一些——例如，你需要使用 10 位地址来发挥 1008 设备总线的最大作用（7 位数字不超过 127，每个设备都需要一个唯一的地址），而读取从从设备的过程的精确机制需要识别诸如从哪个内存寄存器读取等问题。如果你想了解更多，我推荐
    Sparkfun 的 “I²C” 教程 ([https://learn.sparkfun.com/tutorials/i2c](https://learn.sparkfun.com/tutorials/i2c))。
- en: 'Many I²C devices ship with hardware-defined addresses. That means you can’t
    change the device’s address: if you have another device with the same (hard-wired)
    address, you won’t be able to put them on the same bus. But some devices have
    configurable addresses.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 I²C 设备带有硬件定义的地址。这意味着你不能更改设备的地址：如果你有另一个具有相同（硬连线）地址的设备，你将无法将它们放在同一个总线上。但有些设备具有可配置的地址。
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.4.3\. Making a digital compass with an I²C magnetometer
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3. 使用 I²C 磁力计制作数字罗盘
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备的东西
- en: '![](note.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Arduino Uno 和 USB 线
- en: 1 HMC5883L magnetometer (compass) 5 V-friendly breakout board, such as Adafruit’s
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 HMC5883L 磁力计（罗盘）5 V 兼容的解析板，例如 Adafruit 的
- en: 1 half-size breadboard
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个半尺寸面包板
- en: Red, black, yellow, and white jumper wires
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色、黑色、黄色和白色跳线
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Honeywell HMC5883L is a popular I²C triple-axis *magnetometer* chip—that
    is, a compass—available on a 5 V-friendly breakout board from Adafruit. Determining
    your orientation is moments away, combining Johnny-Five’s `Compass` class with
    a breakout board centered on the Honeywell chip.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Honeywell HMC5883L 是一种流行的 I²C 三轴 *磁力计* 芯片——即罗盘——可在 Adafruit 的 5 V 兼容解析板上找到。确定你的方向只需片刻，结合
    Johnny-Five 的 `Compass` 类和一个以 Honeywell 芯片为中心的解析板。
- en: You’ll have to exercise your soldering skills again—the breakout board will
    need to be soldered onto header pins ([figure 7.22](#ch07fig22)) before it can
    slot into a breadboard.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你将再次需要练习你的焊接技能——解析板需要在将其插入面包板之前焊接到引脚头上 ([图 7.22](#ch07fig22))。
- en: Figure 7.22\. The compass breakout board, like the GPS breakout, will need to
    be soldered onto header pins.
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.22. 罗盘解析板，就像 GPS 解析板一样，需要焊接到引脚头上。
- en: '![](07fig22.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig22.jpg)'
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Watch out for operating voltages!
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意操作电压！
- en: Breakout boards for the HMC5883L are available from various electronics resellers,
    but make sure the board you choose can tolerate 5 V. Many, including Sparkfun’s
    variant, are made for 3.3 V logic-level voltages. Connecting a 3.3 V compass to
    your Arduino’s 5 V power and pin outputs can fry the chip. Adafruit’s HMC5883L
    breakout board has an on-board *power regulator*, which makes it safe to provide
    anywhere from 3–5 V DC—it’s a so-called “5 V-safe” component. Although there are
    ways to make 3.3 V components work safely with a 5 V board like the Uno, it requires
    some extra steps and hardware, so for now, make sure you have a 5 V-friendly breakout
    board.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: HMC5883L 解析板可以从各种电子分销商处获得，但请确保你选择的板子可以承受 5 V 的电压。许多板子，包括 Sparkfun 的变体，都是为 3.3
    V 逻辑电压而设计的。将 3.3 V 罗盘连接到 Arduino 的 5 V 电源和引脚输出可能会烧毁芯片。Adafruit 的 HMC5883L 解析板有一个板载
    *电源调节器*，这使得它可以从 3–5 V DC 供电——它是一个所谓的 “5 V 安全” 组件。尽管有方法使 3.3 V 组件在 5 V 板（如 Uno）上安全工作，但这需要一些额外的步骤和硬件，所以现在请确保你有一个
    5 V 兼容的解析板。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As with the GPS breakout board, once the headers are soldered, the wiring is
    simple for this circuit: connect the breakout board’s SDA pin to the Uno’s A4
    pin and the SCL to Uno pin A5\. Connect VIN to the Arduino’s 5 V power and connect
    the ground pin to GND ([figure 7.23](#ch07fig23)).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GPS 解析板一样，一旦焊好引脚，这个电路的布线就很简单了：将解析板的 SDA 引脚连接到 Uno 的 A4 引脚，将 SCL 连接到 Uno 的
    A5 引脚。将 VIN 连接到 Arduino 的 5 V 电源，并将地线引脚连接到 GND ([图 7.23](#ch07fig23))。
- en: Figure 7.23\. Wiring diagram for compass
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.23. 罗盘布线图
- en: '![](07fig23.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig23.jpg)'
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I²C hardware support on Arduino Uno
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Arduino Uno 上的 I²C 硬件支持
- en: 'Note that the pin numbers for this circuit aren’t arbitrary: Uno pins A4 and
    A5 have hardware support for I²C; other pins don’t. The Uno’s A4 pin provides
    SDA; A5 is SCL.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个电路的引脚编号不是随意的：Uno 的 A4 和 A5 引脚支持硬件 I²C；其他引脚不支持。Uno 的 A4 引脚提供 SDA；A5 是 SCL。
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Johnny-Five’s `Compass` class supports a number of different chips, so you’ll
    need to let it know, during instantiation, which specific controller to use; see
    [listing 7.4](#ch07ex04). The Johnny-Five `Compass` documentation identifies the
    supported components ([http://johnny-five.io/api/compass/](http://johnny-five.io/api/compass/)).
    You don’t have to define which pins the compass is connected to, as there’s only
    one way to connect I²C devices to the Uno board (pins A4 and A5).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five的`Compass`类支持多种不同的芯片，因此在实例化时，你需要让它知道使用哪个特定的控制器；参见[列表7.4](#ch07ex04)。Johnny-Five
    `Compass`文档标识了支持的组件([http://johnny-five.io/api/compass/](http://johnny-five.io/api/compass/))。你不需要定义罗盘连接到的引脚，因为连接I²C设备到Uno板只有一种方式（引脚A4和A5）。
- en: Listing 7.4\. Instantiating a `Compass` with a specific controller
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 使用特定控制器实例化`Compass`
- en: '[PRE4]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using a `controller` option to differentiate between different supported hardware
    is a common pattern in many of Johnny-Five’s component classes. You first saw
    it in [chapter 4](kindle_split_012.html#ch04), with the TMP36 analog temperature
    sensor.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`controller`选项来区分不同支持的硬件是Johnny-Five组件类中的一种常见模式。你第一次在[第4章](kindle_split_012.html#ch04)中看到它，与TMP36模拟温度传感器一起。
- en: Inside of your Johnny-Five working directory, create a file called compass.js,
    as shown in the following listing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Johnny-Five工作目录中，创建一个名为compass.js的文件，如下所示。
- en: 'Listing 7.5\. compass.js: reading HMC5883L data with Johnny-Five'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5\. compass.js：使用Johnny-Five读取HMC5883L数据
- en: '[PRE5]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Instantiates a Compass for the HMC588L chip**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 为HMC588L芯片实例化罗盘'
- en: '***2* Compass object instances, like most other J5 component objects, have
    a change event.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 罗盘对象实例，像大多数其他J5组件对象一样，有一个change事件。'
- en: '***3* The bearing property is an object with information about the compass’s
    orientation.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 罗盘属性是一个包含罗盘方向信息的对象。'
- en: 'Now run the script:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行脚本：
- en: '[PRE6]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the board and REPL initialize, you’ll see output in your terminal like
    this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当板子和REPL初始化后，你会在终端看到如下输出：
- en: '[PRE7]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each `bearing` object being logged contains several properties (`abbr`, `heading`,
    and so on). This digital compass would be slicker if it had an output—we’ll make
    one now.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每个正在记录的`bearing`对象包含几个属性（`abbr`、`heading`等）。如果这个数字罗盘有一个输出，它会更加出色——我们现在就来做。
- en: '7.5\. Pulling it together: shake-to-change multisensor widget'
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 汇总：摇动切换多传感器小部件
- en: 'This next experiment combines several I²C sensors together and displays output
    on an LCD. There are enough sensors here that it’s tough to display all the output
    at once on the LCD, so we’ll use an accelerometer to create a shake-to-swap-display
    feature. By shaking the device, you can toggle which data is displayed on the
    LCD: a screen with temperature and pressure data, or a screen with the current
    compass heading.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个下一个实验将几个I²C传感器组合在一起，并在LCD上显示输出。这里传感器足够多，一次性在LCD上显示所有输出比较困难，所以我们将会使用加速度计来创建一个摇动切换显示功能。通过摇动设备，你可以切换在LCD上显示的数据：一个显示温度和压力数据的屏幕，或者一个显示当前罗盘方向的屏幕。
- en: Pins A4 and A5 are the only I²C-compatible pins on the Arduino Uno, but that’s
    just fine—the I²C protocol allows a whole bunch of devices on a single bus. That
    is, you can control multiple I²C devices using just those two pins.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: A4和A5是Arduino Uno上唯一的I²C兼容引脚，但这完全没问题——I²C协议允许在单个总线上连接大量设备。也就是说，你可以只用这两个引脚来控制多个I²C设备。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备的东西
- en: '![](note.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![note.jpg](note.jpg)'
- en: 1 Arduino Uno and USB cable
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Arduino Uno和USB线
- en: 1 HMC5883L (compass) 5 V-friendly breakout board, such as Adafruit’s
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 HMC5883L（罗盘）5 V-friendly分线板，例如Adafruit的
- en: '1 16x2 LCD: parallel or Johnny-Five-compatible I²C LCD, such as the Grove-compatible
    JHD1313M1'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 16x2 LCD：并行或Johnny-Five兼容的I²C LCD，例如Grove兼容的JHD1313M1
- en: Adafruit 5 V-ready BMP180 breakout board (I²C temperature, atmospheric pressure
    sensor)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit 5 V-ready BMP180分线板（I²C温度、大气压力传感器）
- en: Adafruit ADXL345 triple-axis accelerometer
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit ADXL345三轴加速度计
- en: Jumper wires
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 2 half-size breadboards or 1 full-size breadboard
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 半尺寸面包板或1个全尺寸面包板
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Mixing and matching sensors**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合和匹配传感器**'
- en: 'The specifics of this experiment’s code and wiring are based on the items mentioned
    in the list of supplies, but you can mix and match other Johnny-Five-supported
    I²C sensors:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验的代码和接线细节基于供应清单中提到的物品，但你也可以混合使用其他Johnny-Five支持的I²C传感器：
- en: 'Other “multi” sensors (combining temperature, pressure, altimeters, and sometimes
    humidity): BME 280, BMP 280, HTU21D, and so on. See the Johnny-Five “Multi” API
    page for more supported I²C devices: [http://johnny-five.io/api/multi/](http://johnny-five.io/api/multi/).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他“多”传感器（结合温度、压力、高度计，有时还有湿度）：BME 280、BMP 280、HTU21D等。有关更多支持的I²C设备，请参阅Johnny-Five的“多”API页面：[http://johnny-five.io/api/multi/](http://johnny-five.io/api/multi/)。
- en: 'Other accelerometers. See the Johnny-Five “Accelerometer” API page for more
    supported I²C accelerometers: [http://johnny-five.io/api/accelerometer/](http://johnny-five.io/api/accelerometer/).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他加速度计。有关更多支持的I²C加速度计，请参阅Johnny-Five的“加速度计”API页面：[http://johnny-five.io/api/accelerometer/](http://johnny-five.io/api/accelerometer/)。
- en: Of course, you’ll need to adapt the code examples to use the correct controllers
    for the hardware you choose.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要将代码示例修改为适用于你选择的硬件的正确控制器。
- en: Note that most of these sensors come on breakout boards that require you to
    solder header pins.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些传感器中的大多数都安装在需要你焊接引脚的扩展板上。
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you have a Johnny-Five-supported I²C LCD like the Grove RGB LCD module on
    hand, you’re in luck: it’s a breeze to connect I²C LCDs. A parallel LCD will work
    fine in this circuit, too, but, as you now know, it requires a slew more wires.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手头有Johnny-Five支持的I²C LCD，如Grove RGB LCD模块，那么你很幸运：连接I²C LCD非常简单。在这个电路中，并行LCD也可以正常工作，但正如你所知，它需要更多的电线。
- en: '7.5.1\. Step 1: combining a compass with LCD output'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1\. 第1步：将指南针与LCD输出结合
- en: The wiring diagram in [figure 7.24](#ch07fig24) shows how to orient the compass
    and LCD on two breadboards. (As you add sensors to this project, there won’t be
    enough room on a single breadboard.)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24中的接线图显示了如何在两个面包板上定位指南针和LCD。（随着你向这个项目中添加传感器，单个面包板上将没有足够的空间。）
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Why not use the GPS in this experiment?
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么在这个实验中不使用GPS？
- en: Using the GPS breakout in this combined-sensor project seems like it would be
    a nifty idea. However, Johnny-Five support for software serial is relatively fresh,
    and some of the complications of implementing software serial mean that it can
    be hard to predict how much data a sensor is going to communicate (the data exchange
    isn’t structured like I²C in that regard). Because of this, at the time of writing,
    combining a GPS with other sensors or output can cause garbage-y issues with the
    LCD’s display and other unpredictable behavior.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个多传感器项目中使用GPS模块似乎是个不错的想法。然而，Johnny-Five对软件串行的支持相对较新，实现软件串行的一些复杂性意味着很难预测传感器将要传输多少数据（数据交换在这一点上不像I²C那样结构化）。正因为如此，在撰写本文时，将GPS与其他传感器或输出结合可能会引起LCD显示的垃圾数据问题和其他不可预测的行为。
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 7.24\. Wiring diagram, step 1\. The wires on the breadboard with the
    compass breakout board are arranged to make room for sensors that will be added
    later.
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.24\. 接线图，第1步。带有指南针扩展板的面包板上的电线排列是为了为以后要添加的传感器留出空间。
- en: '![](07fig24_alt.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig24_alt.jpg)'
- en: Configuring magnetic declination for better accuracy
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置磁偏角以获得更好的精度
- en: One thing I like to do with my compass headings is correct them for my local
    *magnetic declination*. A compass will always give readings relative to *magnetic
    north*, which is in different places relative to true (geographic) north depending
    on where you are on the surface of the earth. In my locale, true north is about
    14 degrees *west* of magnetic north—that is, there’s a magnetic declination here
    of –14.28 degrees. You can find your magnetic declination by visiting [www.magnetic-declination.com](http://www.magnetic-declination.com)—we’ll
    make use of it in the code for the device.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢用指南针方向做的一件事是，将其校正为我的本地*磁偏角*。指南针总是给出相对于*磁北*的读数，而磁北相对于真北（地理北）的位置因你所在地球表面的位置而异。在我的地区，真北大约比磁北西14度——也就是说，这里的磁偏角为-14.28度。你可以通过访问[www.magnetic-declination.com](http://www.magnetic-declination.com)来找到你的磁偏角——我们将在设备的代码中使用它。
- en: Building the multisensor code
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建多传感器代码
- en: Create a script called multi-sensor.js and start with this configuration code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为multi-sensor.js的脚本，并从以下配置代码开始。
- en: 'Listing 7.6\. multi-sensor.js: configuration'
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. multi-sensor.js：配置
- en: '[PRE8]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Your local magnetic declination: this should be the value from [www.magnetic-declination.com](http://www.magnetic-declination.com).**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 您当地的磁偏角：这应该是从[www.magnetic-declination.com](http://www.magnetic-declination.com)获取的值。**'
- en: '***2* How frequently to update the LCD’s display**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新LCD显示的频率**'
- en: '***3* Keeps track of the last thing displayed on the LCD**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 跟踪LCD上最后显示的内容**'
- en: Next, add a helper function to correct compass readings for local declination.
    The arithmetic in the following declination-correcting function will ensure that
    the returned value is a valid degree measurement between 0 and 360.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个辅助函数来校正罗盘读取的本地偏差。以下偏差校正函数中的算术将确保返回的值是一个有效的 0 到 360 度之间的度数测量值。
- en: 'Listing 7.7\. multi-sensor.js: correcting for declination'
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.7\. multi-sensor.js: 校正偏差'
- en: '[PRE9]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* This function corrects a (Number) heading for local declination.**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此函数校正一个（数字）航向的本地偏差。**'
- en: '***2* Ensures corrected value is positive**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保校正后的值是正数**'
- en: '***3* Subtracts units of 360 (degrees) from corrected value until it’s less
    than 360**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从校正值中减去 360（度）的单位，直到它小于 360**'
- en: And now, a formatting helper function to format the display of `readings` taken
    from the project’s sensors. In this first round, shown in the following listing,
    it’ll format a `heading` property—we’ll populate it shortly with data from the
    compass.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个格式化辅助函数用于格式化从项目传感器中读取的 `readings`。在这个第一轮中，如下所示，它将格式化 `heading` 属性——我们很快会用罗盘的数据填充它。
- en: 'Listing 7.8\. multi-sensor.js: display formatting for compass heading'
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.8\. multi-sensor.js: 显示罗盘航向的格式'
- en: '[PRE10]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Takes a readings object and returns what to display on each of the LCD’s
    two lines**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 读取一个读取对象，并返回在 LCD 的两条线上显示的内容**'
- en: '***2* :circle: is a special character that can be displayed on the LCD.**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* :circle: 是一个可以在 LCD 上显示的特殊字符。**'
- en: Now, let’s finish up this round of code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们完成这一轮代码。
- en: 'Listing 7.9\. multi-sensor.js: displaying compass heading'
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 7.9\. multi-sensor.js: 显示罗盘航向'
- en: '[PRE11]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Instantiates a parallel LCD**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化一个并行 LCD**'
- en: '***2* Tells the LCD to use the special circle character (for a degree marker)**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 告诉 LCD 使用特殊的圆圈字符（作为度数标记）**'
- en: '***3* Corrects the compass reading for declination and populates readings.heading
    with the result**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 校正罗盘读取的偏差，并将结果填充到 readings.heading 中**'
- en: '***4* Has the display value changed? If so, updates the LCD.**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 显示值是否已更改？如果是，则更新 LCD。**'
- en: '***5* Keeps track of the last thing displayed**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 跟踪最后显示的内容**'
- en: '***6* Sets up a loop to invoke update every UPDATE_FREQ_MS milliseconds (1000
    ms, in this example)**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 设置一个循环，每 UPDATE_FREQ_MS 毫秒（本例中为 1000 毫秒）调用一次更新**'
- en: By only checking data every second (`board.loop` frequency) and only reprinting
    to the LCD if data has changed, performance is improved and excessive LCD flicker
    is avoided.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 通过每秒只检查一次数据（`board.loop` 频率）并且只有在数据发生变化时才重新打印到 LCD，可以提高性能并避免过度的 LCD 闪烁。
- en: 'Try it out:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下：
- en: '[PRE12]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should see a compass heading on your LCD—adjusted for magnetic declination
    and rounded to the nearest full degree. It should update every second as the compass
    is reoriented.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 LCD 上看到罗盘航向——调整了磁偏差并四舍五入到最接近的整数度。它应该每秒更新一次，因为罗盘被重新定位。
- en: '7.5.2\. Step 2: adding a multisensor to the device'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2\. 第 2 步：将多传感器添加到设备中
- en: Johnny-Five’s `Multi` component class is meant for devices like the BMP180,
    which combine *multiple sensors* into one package. [Figure 7.25](#ch07fig25) shows
    Adafruit’s BMP180 breakout board, which contains both temperature and atmospheric
    pressure sensors. Like the GPS and compass, the BMP180 board needs to be soldered
    onto header pins before use in a breadboard.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five 的 `Multi` 组件类旨在用于像 BMP180 这样的设备，这些设备将多个传感器组合成一个包。[图 7.25](#ch07fig25)
    展示了 Adafruit 的 BMP180 分线板，它包含温度和大气压力传感器。像 GPS 和罗盘一样，BMP180 板在使用面包板之前需要焊接在引脚头上。
- en: Figure 7.25\. Adafruit’s BMP180 breakout board
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.25\. Adafruit 的 BMP180 分线板
- en: '![](07fig25.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig25.jpg)'
- en: A `Multi` object behaves as a container for various sensor components and lets
    you interact with them in a coordinated manner. Each contained sensor is mapped
    to its own appropriate J5 component class. For example, the object instantiated
    as
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Multi` 对象作为一个容器，用于各种传感器组件，并允许你以协调的方式与之交互。每个包含的传感器都映射到其适当的 J5 组件类。例如，以下实例
- en: '[PRE13]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'will contain the following instance properties:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含以下实例属性：
- en: '`thermometer`—A reference to a Johnny-Five `Thermometer` instance for the temperature
    sensor'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thermometer`—一个指向 Johnny-Five `Thermometer` 实例的温度传感器'
- en: '`barometer`—A reference to a Johnny-Five `Barometer` instance for the pressure
    sensor'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`barometer`—一个指向 Johnny-Five `Barometer` 实例的压力传感器'
- en: The BMP180 uses I²C for communication, meaning you can connect it to the shared
    SDA and SCL line already in use by the compass ([figure 7.26](#ch07fig26)).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: BMP180 使用 I²C 进行通信，这意味着你可以将其连接到已经由罗盘使用的共享 SDA 和 SCL 线。[图 7.26](#ch07fig26))。
- en: Figure 7.26\. Wiring diagram for adding the BMP180 breakout to the circuit
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.26\. 添加 BMP180 扩展板到电路的布线图
- en: '![](07fig26_alt.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig26_alt.jpg)'
- en: '7.5.3\. Step 3: updating the display to show temperature and pressure'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3\. 步骤 3：更新显示以显示温度和压力
- en: 'Displaying temperature, atmospheric pressure, and compass heading at the same
    time overcrowds the limited 16x2 character space on the LCD. It would be better
    if we split the display into two screenfuls: one to display temperature and pressure,
    and the other to show compass heading. In our first version, there won’t be a
    way to swap between the two screens—it’ll just show temperature and pressure—but
    we’ll come back to that in a few moments.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 同时显示温度、大气压力和罗盘方向会占用 LCD 有限的 16x2 字符空间。如果我们将显示分成两个屏幕，会更好：一个用于显示温度和压力，另一个用于显示罗盘方向。在我们的第一个版本中，将无法在两个屏幕之间切换——它只会显示温度和压力——但我们将在几分钟后回到这一点。
- en: 'First, add one more additional variable near the top of the file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文件顶部附近添加一个额外的变量：
- en: '[PRE14]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is simplistic way to help the program determine which screen—temperature
    and pressure, or compass heading—to display.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的方法，帮助程序确定显示哪个屏幕——温度和压力，还是罗盘方向。
- en: Now, update the display-formatting function, shown in the next listing.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新显示格式化函数，如以下列表所示。
- en: 'Listing 7.10\. multi-sensor.js: updating the display formatting'
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. multi-sensor.js：更新显示格式化
- en: '[PRE15]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Update to take an altDisplay parameter (Boolean).**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新以接受 altDisplay 参数（布尔值）。**'
- en: '***2* This branch will never execute in this version of the code (it’s always
    false).**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此分支将在此代码版本中永远不会执行（它始终为假）。**'
- en: '***3* Pressure is in kPa; multiply by 10 and round to get more familiar millibars**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 压力单位为 kPa；乘以 10 并四舍五入以获得更熟悉的毫巴**'
- en: 'Next, update the board’s `ready` callback: instantiate a `Multi` sensor and
    pass more properties to the display-formatting function, as shown in the following
    listing.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新板的 `ready` 回调：实例化一个 `Multi` 传感器并将更多属性传递给显示格式化函数，如以下列表所示。
- en: 'Listing 7.11\. multi-sensor.js: updating the board’s `ready` callback'
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. multi-sensor.js：更新板的 `ready` 回调
- en: '[PRE16]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Instantiates a Multi object for the BMP180**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为 BMP180 实例化一个 Multi 对象**'
- en: '***2* Adds a temperature property from the BMP180’s temperature value, in Fahrenheit**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 BMP180 的温度值添加一个温度属性，单位为华氏度**'
- en: '***3* Adds a pressure property from the BMP180’s pressure sensor**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从 BMP180 的压力传感器添加一个压力属性**'
- en: '***4* Passes the (currently always false) altDisplay value**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 传递（目前始终为假）的 altDisplay 值**'
- en: 'Now try things out:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试以下操作：
- en: '[PRE17]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see the current temperature and pressure on the LCD’s screen (but
    not the compass heading).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 LCD 屏幕上看到当前的温度和压力（但不是罗盘方向）。
- en: '7.5.4\. Step 4: adding a shake-to-swap display feature with an accelerometer'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.4\. 步骤 4：使用加速度计添加摇动切换显示功能
- en: Accelerometers measure acceleration and orientation changes. By monitoring an
    accelerometer for acceleration—forces that exceed 1 G—you can create a shake-to-change
    display feature.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计测量加速度和方向变化。通过监控加速度计的加速度——超过 1 G 的力——你可以创建一个摇动以更改显示的功能。
- en: The ADXL345 triple-axis accelerometer breakout board from Adafruit ([figure
    7.27](#ch07fig27)) is a 5 V-friendly accelerometer component that provides both
    I²C and SPI interfaces. Although the board’s connections support both serial protocols,
    Johnny-Five’s support for it uses the I²C interface (only).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit 的 ADXL345 三轴加速度计扩展板（[图 7.27](#ch07fig27)）是一个 5 V 兼容的加速度计组件，提供 I²C 和
    SPI 接口。尽管该板上的连接支持两种串行协议，但 Johnny-Five 对其的支持仅使用 I²C 接口（仅限）。
- en: Figure 7.27\. The ADXL345 triple-axis accelerometer breakout board from Adafruit.
    It can be connected to an I²C bus (via SDA and SCL pins) or, with some pins doing
    double duty as noted in the image, a four-wire SPI setup (via CS, SDO, SDA, and
    SCL pins).
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.27\. Adafruit 的 ADXL345 三轴加速度计扩展板。它可以连接到 I²C 总线（通过 SDA 和 SCL 引脚）或者，如图中所示，一些引脚作为双重功能使用，一个四线
    SPI 设置（通过 CS、SDO、SDA 和 SCL 引脚）。
- en: '![](07fig27_alt.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig27_alt.jpg)'
- en: Add the accelerometer to the circuit ([figure 7.28](#ch07fig28)) once it’s soldered
    onto header pins, connecting to the shared SDA and SCL rows on the breadboard.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将加速度计添加到电路中（[图 7.28](#ch07fig28)），一旦它焊接在排针上，连接到面包板上的共享 SDA 和 SCL 行。
- en: Figure 7.28\. Wiring diagram for adding the accelerometer to the circuit
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.28\. 添加加速度计到电路的布线图
- en: '![](07fig28_alt.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig28_alt.jpg)'
- en: The Johnny-Five `Accelerometer` class provides support for, you guessed it,
    accelerometers (J5 component classes are probably starting to feel old hat).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five `加速度计`类提供了对加速度计的支持（你猜对了，J5组件类可能开始感觉过时了）。
- en: To implement the shake-to-swap display feature, we’ll bind to the `Accelerometer`
    instance’s `acceleration` event, which is fired when the device’s acceleration
    reading has changed, and see if it exceeds a rough threshold that suggests a brisk,
    shaking-like movement.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现摇动交换显示功能，我们将绑定到`加速度计`实例的`加速度`事件，该事件在设备加速度读数发生变化时触发，并查看它是否超过了一个大致的阈值，这表明有快速的摇动动作。
- en: Edit the following code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑以下代码。
- en: 'First, add additional variables near the top of the file to set a shake threshold
    (in Gs) and to keep track of last shake detected, for debounce purposes:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文件顶部附近添加额外的变量来设置摇动阈值（以G为单位）并跟踪最后一次检测到的摇动，用于去抖动：
- en: '[PRE18]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Detecting and debouncing “shakes”**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测和去抖动“摇动”**'
- en: An `Accelerometer` object’s `acceleration` event fires whenever the acceleration
    reading changes. In rough, unscientific experimentation, I found that a reasonable
    threshold for what should register as a shake is around 1.15 G. If you find that
    this is too sensitive or requires too energetic a shake, you can adjust the threshold
    in the code.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`加速度计`对象的`加速度`事件会在加速度读数变化时触发。在粗略、非科学的实验中，我发现应该注册为摇动的合理阈值大约是1.15 G。如果你发现这太敏感或需要太剧烈的摇动，你可以在代码中调整阈值。
- en: A real-life movement like a shake generates fluctuating acceleration values
    over the period of several device reads. That is, several sequential `acceleration`
    events are fired in a short amount of time, multiple times, with readings that
    exceed the threshold. If we implemented the swapping to switch displays each time
    the accelerometer reported acceleration above the threshold, the display would
    flicker wildly back and forth.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的摇动动作会在几次设备读数期间产生波动加速度值。也就是说，在短时间内，会连续触发多个`加速度`事件，多次读取，读数超过阈值。如果我们每次加速度计报告的加速度超过阈值时都切换显示，那么显示会疯狂地来回闪烁。
- en: Instead, we need to *debounce* the swap, preventing it from occurring too frequently.
    We can do this by keeping track of the last time the display was swapped, and
    making sure we don’t swap it more often than, say, once per second.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要对交换进行*去抖动*，防止它过于频繁地发生。我们可以通过跟踪最后一次显示交换的时间，并确保我们不会比每秒一次更频繁地交换它来实现这一点。
- en: '|  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Inside the `ready` callback, instantiate the accelerometer:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ready`回调函数内部，实例化加速度计：
- en: '[PRE19]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Also inside the `ready` callback function, add a handler for the `acceleration`
    event, shown in the following listing.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ready`回调函数内部，添加一个`加速度`事件的处理程序，如下所示。
- en: 'Listing 7.12\. multi-sensor.js: acceleration handler'
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表7.12\. multi-sensor.js: 加速度处理程序'
- en: '[PRE20]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* If the current value of the acceleration property exceeds the G threshold...**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果当前加速度属性的值超过G阈值...**'
- en: '***2* If the display wasn’t swapped within the past 1000 ms...**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果在过去1000毫秒内没有交换显示...**'
- en: '***3* Flip the value of altDisplay.**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 翻转altDisplay的值。**'
- en: '***4* Keep track of the time the swap happened.**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 记录交换发生的时间。**'
- en: '***5* Update the display.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 更新显示。**'
- en: It’s done! Run.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！运行。
- en: '[PRE21]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Initially, you should see the temperature and pressure information displayed
    on the LCD. Pick up the breadboard with the sensors, and give it a brisk shake:
    you should see the LCD swap over to the compass-heading display.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，你应该在LCD上看到温度和压力信息显示。拿起带有传感器的面包板，给它一个快速的摇动：你应该看到LCD切换到罗盘航向显示。
- en: By now, it’s likely you’ve started noticing an elephant in the room. You’ve
    just built an orienteering-like device...that is chained by a cable to your laptop
    or computer. The Arduino and its attached components are helpless without the
    compute power on the host machine—that’s where the Node.js process executes. This
    is, of course, a pretty ridiculous setup for hiking through the woods. Similarly,
    the robot you built in [chapter 6](kindle_split_014.html#ch06) can only rove as
    far as its USB cable allows.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经开始注意到房间里有一头大象。你刚刚构建了一个类似定向仪的设备...它通过电缆连接到你的笔记本电脑或计算机。没有主机机器上的计算能力，Arduino及其附加组件是无能为力的——这就是Node.js进程执行的地方。当然，这对于穿越森林的远足来说是一个非常荒谬的设置。同样，你在[第6章](kindle_split_014.html#ch06)中构建的机器人只能在其USB电缆允许的范围内移动。
- en: It’s time to break free. In the next chapter, we’ll start untethering our projects
    and setting them free.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候摆脱束缚了。在下一章中，我们将开始解放我们的项目，让它们自由发展。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Swapping in an I²C LCD: a case study**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**替换 I²C LCD：一个案例研究**'
- en: The wiring for the combined-sensor circuit is crowded, requiring two breadboards.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 组合传感器电路的布线很拥挤，需要两个面包板。
- en: 'On the off chance you have an I²C-enabled LCD display hanging around (I did),
    you can use that instead of the parallel one. I used a Grove-compatible I²C LCD
    (part number, JHD1313M1). Grove is a system of components made by Seeed Studio
    that all share common connectors—but, alas, those connectors aren’t compatible
    with headers or breadboards. You can purchase connector adapters, but in my case,
    I did some homebrew surgery: I cut the connector off the end and soldered the
    four stranded wires (VCC, GND, SCL, and SDA, just like any other I²C device) to
    solid-core hookup wire that slotted more easily into a breadboard.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手头有一个 I²C 兼容的 LCD 显示器（我就是这样），你可以用那个代替并行显示器。我使用了一个 Grove 兼容的 I²C LCD（零件编号，JHD1313M1）。Grove
    是由 Seeed Studio 制造的组件系统，所有组件都共享相同的连接器——但是，唉，这些连接器与引脚或面包板不兼容。你可以购买连接器适配器，但在我这个例子中，我进行了一些家庭式手术：我切掉了连接器，并将四根多股线（VCC、GND、SCL
    和 SDA，就像任何其他 I²C 设备一样）焊接到了更容易插入面包板的实心连接线上。
- en: The resulting circuit frees up a bunch of Uno pins and is much simpler overall.
    I²C is an ideal protocol for cutting down on the number of physical dev board
    I/O pins you’ll need to support your project’s components.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 结果电路释放了大量 Uno 引脚，整体上更加简单。I²C 是减少您需要支持的项目的组件的物理开发板 I/O 引脚数量的理想协议。
- en: '![](0213fig01_alt.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](0213fig01_alt.jpg)'
- en: Wiring diagram using the Grove I²C LCD component. It can share the same SDA
    and SCL lines as the other connected sensors.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Grove I²C LCD 组件的布线图。它可以与其他连接的传感器共享相同的 SDA 和 SCL 线。
- en: The only change to the orienteering code is in the LCD’s instantiation. Instead
    of this,
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对定向代码的唯一更改是在 LCD 的实例化上。而不是这样，
- en: '[PRE22]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'use this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个：
- en: '[PRE23]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Although simple analog signals suffice for basic sensor data, reading data from
    more advanced components calls for a more structured way of exchanging information.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然简单的模拟信号足以满足基本传感器数据，但读取更高级组件的数据需要一种更结构化的信息交换方式。
- en: Parallel communication is fast by its nature, but it can be cumbersome. Serial
    communication—one bit at a time—is the method of choice for exchanging data in
    hobby electronics.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行通信在本质上很快，但可能会很麻烦。串行通信——一次一个比特——是业余电子学中交换数据的首选方法。
- en: Asynchronous serial is commonplace, but it requires both devices to be configured
    for protocol specifics beforehand and is limited to two devices.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步串行很常见，但需要两个设备事先配置协议特定设置，并且限制为两个设备。
- en: TTL (transistor-transistor logic) is the type of async serial used on dev boards.
    UART hardware makes fast TTL serial possible on boards, but this type of serial
    communication can also be emulated in software (software serial).
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TTL（晶体管-晶体管逻辑）是开发板上使用的异步串行类型。UART 硬件使得在板上实现快速 TTL 串行成为可能，但这种类型的串行通信也可以在软件中模拟（软件串行）。
- en: Synchronous serial protocols add a shared clock line to the communication bus.
    SPI is a protocol that requires three or four (data and clock) wires; the even
    more popular I²C protocol only requires two wires.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步串行协议在通信总线上增加了一条共享时钟线。SPI 是一种需要三到四条（数据线和时钟线）线的协议；更受欢迎的 I²C 协议只需要两条线。
- en: Serial components can be combined to make fun and more powerful projects. Although
    only two devices can exchange data over an async (TTL) serial connection, many
    devices can be added to the same SPI or I²C buses, allowing more efficient use
    of development board I/O pins.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将串行组件组合起来制作有趣且功能强大的项目。尽管只有两个设备可以通过异步（TTL）串行连接交换数据，但可以将许多设备添加到相同的 SPI 或 I²C
    总线上，从而更有效地使用开发板的 I/O 引脚。
- en: I²C can support up to 1008 devices on a single bus (with 10-bit addresses).
    Each device on the bus needs to have a unique address.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I²C 可以在一个总线上支持多达 1008 个设备（使用 10 位地址）。总线上的每个设备都需要一个唯一的地址。
- en: Support for serial data exchange is usually provided at the hardware level (software
    serial emulation being the evident exception). On development boards, this is
    often dependent on the serial support provided by the microcontroller or processor.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行数据交换的支持通常在硬件级别提供（软件串行仿真是明显的例外）。在开发板上，这通常取决于微控制器或处理器提供的串行支持。
- en: Serial connections are available only on certain pins. For the Arduino Uno,
    I²C is supported on pins A4 (SDA) and A5 (SCL), SPI on pins 10 (SS), 11 (MOSI),
    12 (MISO), and 13 (SCK).
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行连接仅在某些引脚上可用。对于Arduino Uno，I²C支持在引脚A4（SDA）和A5（SCL）上，SPI在引脚10（SS）、11（MOSI）、12（MISO）和13（SCK）上。
- en: Chapter 8\. Projects without wires
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章\. 无线项目
- en: '*This chapter covers*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why hobby electronics projects need wires, and how to get rid of them
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么业余电子项目需要电线，以及如何摆脱它们
- en: Using Johnny-Five with different I/O plugins on different platforms
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同平台上使用Johnny-Five与不同的I/O插件
- en: Configuring and working with the Tessel 2 development platform
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和使用Tessel 2开发平台
- en: Adapting to 3.3 V logic levels and different pin configurations
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应3.3 V逻辑电平和不同的引脚配置
- en: Deploying code wirelessly to the Tessel 2
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无线部署代码到Tessel 2
- en: Taking advantage of the Node.js and npm ecosystem to create more complex software
    for the Tessel 2
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Node.js和npm生态系统为Tessel 2创建更复杂的软件
- en: Using batteries to go fully wires-free with the Tessel 2
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电池让Tessel 2完全摆脱电线
- en: '|  |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](tool.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![工具图片](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下物品：**'
- en: 1 Tessel 2 development board
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Tessel 2开发板
- en: 1 USB A to USB micro cable
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1根USB A到USB micro线
- en: 1 standard LED, any color
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个标准LED灯，任何颜色
- en: 1 100 V resistor
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个100 V电阻
- en: 1 Adafruit BMP180 multisensor breakout board
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Adafruit BMP180多传感器扩展板
- en: 'Any one of the following:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下任何一个：
- en: 3 female header pins
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3个公头引脚
- en: 2 lengths of 22-gauge, solid-core wire
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2根22号规格、实心导线
- en: 9 V battery and snaps
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 V电池和夹子
- en: Soldering iron and supplies
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊锡铁和配件
- en: 1 USB 5 V wall charger or similar, to power the Tessel 2
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个USB 5 V电源适配器或类似设备，为Tessel 2供电
- en: 1 USB battery (sometimes called a *power bank*)
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个USB电池（有时称为*移动电源*）
- en: Jumper wires
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 1 half-size breadboard
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个半尺寸面包板
- en: Roving robot (motor-driving circuit and chassis) from [chapter 6](kindle_split_014.html#ch06)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第6章（[kindle_split_014.html#ch06](kindle_split_014.html#ch06)）中的巡游机器人（电机驱动电路和底盘）
- en: '![](0215fig01_alt.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![0215fig01_alt.jpg](0215fig01_alt.jpg)'
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The things we’re building are becoming more intricate and powerful, but there’s
    a limiting factor: they’re physically connected to a computer. These Arduino Uno-based
    Johnny-Five projects lack physical independence—they’re wholly dependent on a
    host computer for logical instructions and power. For some kinds of projects,
    this tethered host-client setup isn’t a problem. But to move further on your journey,
    to create JavaScript-controlled, autonomous, self-contained projects—to free yourself
    of wires—you’ll need to expand your hardware horizons.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的东西变得越来越复杂和强大，但有一个限制因素：它们物理上连接到计算机。这些基于Arduino Uno的Johnny-Five项目缺乏物理独立性——它们完全依赖于主机计算机进行逻辑指令和电源。对于某些类型的项目，这种束缚的主机-客户端设置并不是问题。但为了进一步发展，为了创建JavaScript控制的、自主的、自包含的项目——为了摆脱电线——你需要扩大你的硬件视野。
- en: The ATmega328P microcontroller used on the Arduino Uno is too constrained to
    run a full operating system or execute JavaScript natively. If you want to control
    the Uno with JavaScript, you have to use something external and more powerful—a
    *host*—to execute the JavaScript on the board’s behalf.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Uno上使用的ATmega328P微控制器过于受限，无法运行完整的操作系统或原生执行JavaScript。如果你想用JavaScript控制Uno，你必须使用外部且更强大的东西——一个*主机*——来代表板执行JavaScript。
- en: On the host, the logic in the JavaScript program needs to be translated into
    instructions the constrained microcontroller can understand. Those instructions
    then need to be communicated to the Uno, which acts as a thin *client*. Likewise,
    data coming from the Uno—sensor readings, and so on—are communicated back to the
    host for processing ([figure 8.1](#ch08fig01)).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，JavaScript程序中的逻辑需要转换为受限制的微控制器可以理解的指令。然后，这些指令需要传达给Uno，它充当一个薄的*客户端*。同样，来自Uno的数据——传感器读数等——需要传达回主机进行处理（[图8.1](#ch08fig01)）。
- en: Figure 8.1\. This sketch from [chapter 1](kindle_split_008.html#ch01) outlines
    theoretical host-client communications for an automatic fan widget. In your experiments
    so far, the Arduino Uno has acted as a thin client, and your computer as the host.
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 这段来自第1章（[kindle_split_008.html#ch01](kindle_split_008.html#ch01)）的代码概述了自动风扇小部件的理论主机-客户端通信。在你迄今为止的实验中，Arduino
    Uno充当了一个薄的客户端，而你的计算机作为主机。
- en: '![](08fig01_alt.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![08fig01_alt.jpg](08fig01_alt.jpg)'
- en: With Johnny-Five, formatting and exchanging those instructions and data between
    host and client is the job of the *I/O layer*.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在Johnny-Five中，格式化和交换主机和客户端之间的指令和数据是*I/O层*的工作。
- en: 'Arduinos, including the Uno, are a special case with Johnny-Five: Firmata provides
    the I/O layer and is available by default in Johnny-Five. That is, when you instantiate
    a `Board` object, unless you tell it otherwise (with an option), Firmata (over
    USB) will be used for I/O. You’ve been using this default I/O in the previous
    chapters.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino，包括Uno，是Johnny-Five的特殊案例：Firmata提供了I/O层，并在Johnny-Five中默认可用。也就是说，当您实例化一个`Board`对象时，除非您告诉它否则（使用选项），Firmata（通过USB）将用于I/O。您在之前的章节中一直在使用这种默认的I/O。
- en: 8.1\. Why you’ve been tethered so far
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 为什么您一直处于连接状态
- en: You’ve used physical USB tethering for your projects thus far because the USB
    connection has provided both a means of I/O exchange and a supply of power. To
    unplug, you need to satisfy those requirements—I/O and power—in different ways,
    so let’s dig deeper to see what’s going on under the hood.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直使用物理USB连接线为您的项目供电，因为USB连接提供了I/O交换和电源供应的双重功能。要断开连接，您需要以不同的方式满足这些要求——I/O和电源，因此让我们深入了解内部的工作原理。
- en: 8.1.1\. Data exchange, the I/O layer, and I/O plugins
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1. 数据交换、I/O层和I/O插件
- en: 'Although Johnny-Five defines APIs and the logical behavior of components, exactly
    how data and instructions are exchanged between a Johnny-Five application and
    the hardware is left up to the *I/O layer*. This is how Johnny-Five keeps itself
    platform-agnostic: it leaves those details up to compatible *I/O plugins*.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Johnny-Five定义了API和组件的逻辑行为，但数据指令如何在Johnny-Five应用程序和硬件之间交换则留给*I/O层*。这就是Johnny-Five保持平台无关性的方式：它将这些细节留给兼容的*I/O插件*。
- en: 'You haven’t been using any Johnny-Five I/O plugins up to this point because
    common Arduinos, including the Uno, are special cases with Johnny-Five. When you
    instantiate `Board` objects without specifying what I/O to use, Johnny-Five uses
    Firmata over USB by default—that’s why it “just works.” Unlike I/O plugins for
    other platforms, which have to be installed individually, Firmata comes with Johnny-Five
    (technically: it’s a dependency). That can make it seem like Firmata and nitty-gritty
    I/O details are part of Johnny-Five’s code, which isn’t actually the case. As
    you try out Johnny-Five on other platforms, you’ll see that you have to install
    appropriate I/O plugins. More on that in a bit.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您还没有使用任何Johnny-Five I/O插件，因为常见的Arduino，包括Uno，是Johnny-Five的特殊案例。当您实例化`Board`对象而不指定要使用的I/O时，Johnny-Five默认通过USB使用Firmata——这就是为什么它“直接工作”的原因。与其他平台的I/O插件不同，它们必须单独安装，Firmata与Johnny-Five一起提供（技术上讲：它是一个依赖项）。这可能会让人感觉Firmata和琐碎的I/O细节是Johnny-Five代码的一部分，但实际上并非如此。当您在其他平台上尝试Johnny-Five时，您会看到您必须安装适当的I/O插件。关于这一点，稍后会有更多介绍。
- en: In your host-client Johnny-Five setup with an Arduino Uno thus far, the USB
    cable serves as an umbilical cord for the exchange of serial Firmata-formatted
    messages. That’s one reason you’ve been physically tethered.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在您迄今为止的Arduino Uno主机-客户端Johnny-Five设置中，USB电缆充当了交换串行Firmata格式消息的脐带。这就是您一直处于物理连接状态的一个原因。
- en: 8.1.2\. USB as a power source
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2. USB作为电源
- en: Something has to power the circuits in a project. The USB connection you’ve
    been using is a source of steady 5 V power. With the exception of a few inductive
    circuits—motors and servos, which require more current or voltage than the development
    board can provide—you’ve relied on the USB cable for power as well as for data
    exchange.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中的电路需要某种电源。您一直使用的USB连接提供稳定的5V电源。除了少数需要比开发板能提供的更多电流或电压的感应电路——如电机和伺服机构——之外，您一直依赖USB电缆供电以及数据交换。
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DC power for development boards**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发板的直流电源**'
- en: The Arduino Uno has a built-in DC barrel jack that you can use to connect it
    to a wall-powered DC adapter. Such “wall warts” are ubiquitous, converting wall-based
    AC power to the DC power that so many electronics hunger for.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Uno内置了一个直流圆筒形插孔，您可以使用它将Arduino连接到壁挂式直流适配器。这种“壁挂式电源适配器”无处不在，它将基于墙面的交流电转换为许多电子设备所需的直流电。
- en: The wall warts of yore have barrel-jack connectors that can socket into anything
    from answering machines to your own development boards, like the Uno.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的壁挂式电源适配器具有圆筒形插孔，可以插入从答录机到您自己的开发板（如Uno）的任何设备。
- en: '![](0218fig01_alt.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![0218fig01_alt.jpg]'
- en: The Uno has a DC-in barrel jack for power
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Uno有一个直流输入圆筒形插孔用于供电
- en: Most dev boards (including the Uno) have onboard *voltage regulators* for their
    power inputs, which means it’s OK to provide anywhere from 9 V to over 20 V to
    the Uno via DC, and it takes care of regulating that down to its needed 5 V.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发板（包括 Uno）都有内置的 *电压调节器* 用于其电源输入，这意味着可以通过直流电源为 Uno 提供从 9 V 到超过 20 V 的电压，并且它会将其调节到所需的
    5 V。
- en: Voltage regulators need to be provided with a higher voltage than their target
    output voltage. Like with LEDs, there’s a forward voltage drop across the regulator
    itself—the power-adjusting circuitry on the board eats up some of the input voltage.
    In the Uno’s case, to get a steady 5 V, at least 7 V input is needed.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 电压调节器需要提供比其目标输出电压更高的电压。就像 LED 一样，调节器本身存在正向电压降——板上的功率调节电路消耗了一些输入电压。在 Uno 的例子中，为了得到稳定的
    5 V，至少需要 7 V 的输入电压。
- en: Any 9 V–12 V DC adapter with center-positive polarity and a 5.5 mm x 2.5 mm
    plug (the most common size) is ideal for powering the Uno.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有中心正极性、5.5 mm x 2.5 mm 插头（最常见的尺寸）的 9 V–12 V DC 适配器都适用于为 Uno 提供电力。
- en: '![](0218fig02_alt.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](0218fig02_alt.jpg)'
- en: This symbol indicates that the power adapter has center-positive polarity. That
    is, the tip of the connector has positive polarity, and the sleeve is negative.
    A majority of DC wall warts are center-positive polarity—that’s the kind you want
    for powering the Uno and, typically, other dev boards.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 此符号表示电源适配器具有中心正极性。也就是说，插头尖端具有正极性，而套筒是负极。大多数直流电源适配器都具有中心正极性——这正是你为 Uno 和通常其他开发板供电所需要的那种。
- en: Not all adapters have a polarity symbol printed on them. That’s a pity, because
    you can’t assume a given adapter is center-positive polarity—there’s no default,
    although center-positive polarity is more common.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有适配器上都打印有极性符号。这很遗憾，因为你不能假设某个适配器具有中心正极性——没有默认值，尽管中心正极性更为常见。
- en: I keep a collection of DC wall warts, as well as 5 V USB chargers, at hand for
    use in projects. Long-since orphaned from their original consumer electronics,
    they’re handy in their second life of providing power for various prototypes and
    projects.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我手头备有直流电源适配器和 5 V USB 充电器，以便在项目中使用。这些适配器早已从它们原始的消费电子产品中分离出来，在为各种原型和项目提供电力方面变得非常方便。
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.1.3\. Options for wires-free project communication
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 无线项目通信选项
- en: 'As you’ve seen, there are two main reasons projects have wires: data exchange
    and power. We’ll tackle power momentarily, but let’s first look at different ways
    to create projects that don’t require physically tethered data connections.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，项目使用线缆有两个主要原因：数据交换和电力。我们将稍后解决电力问题，但首先让我们看看创建不需要物理连接数据连接的项目的方法。
- en: Wireless host-client setups
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无线主机-客户端设置
- en: Certain development boards with constrained microcontrollers provide wireless
    communication capabilities, like WiFi or Bluetooth.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 某些具有受限微控制器的开发板提供了无线通信功能，如 WiFi 或蓝牙。
- en: A host is still needed to execute JavaScript logic, but data and instructions
    can be exchanged between the host and client wirelessly—obviating the need for
    a physical USB data tether ([figure 8.2](#ch08fig02)).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 JavaScript 逻辑需要一个主机，但主机和客户端之间可以通过无线方式交换数据和指令——从而消除了物理 USB 数据连接的需求（[图 8.2](#ch08fig02)）。
- en: Figure 8.2\. Like the Uno, these boards have constrained microcontrollers, but
    both can communicate wirelessly.
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2\. 与 Uno 一样，这些板具有受限的微控制器，但两者都可以无线通信。
- en: '![](08fig02_alt.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig02_alt.jpg)'
- en: The Blend Micro board, for example, can be used wirelessly with Johnny-Five
    by making use of the blend-micro-io I/O plugin and using BLEFirmata firmware on
    the board. You’ll meet another BLE-capable small board, Espruino’s Puck.js, in
    [chapter 12](kindle_split_022.html#ch12).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Blend Micro 板可以通过使用 blend-micro-io I/O 插件和板上的 BLEFirmata 固件无线地与 Johnny-Five
    一起使用。你将在 [第 12 章](kindle_split_022.html#ch12) 中遇到另一个具有 BLE 功能的小型板，Espruino 的 Puck.js。
- en: Embedded JavaScript
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 嵌入式 JavaScript
- en: Another class of development boards has microcontrollers that range from constrained
    to moderately sophisticated and are optimized to run JavaScript, some subset of
    JavaScript, or JavaScript-like code natively. The microcontrollers on these boards
    aren’t cut out to run full-fledged OSs, but tend to be power-efficient, inexpensive,
    and small—all ideal characteristics for embedded systems.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类开发板具有从受限到中等复杂性的微控制器，并针对运行 JavaScript、JavaScript 的某些子集或类似 JavaScript 的代码进行了优化。这些板上的微控制器不适合运行完整的操作系统，但往往具有高效能、低成本和小型化——所有这些都是嵌入式系统的理想特性。
- en: Workflow varies from platform to platform. In some cases, the JavaScript you
    write might get compiled to something else (code that’s more low-level and efficient)
    before being flashed to the device. In other cases, the board’s microcontroller
    might be able to execute some subset of JavaScript directly—meaning you write
    in JavaScript, but you might not have access to every language feature ([figure
    8.3](#ch08fig03)). We’ll revisit constrained, embedded JavaScript platforms in
    [chapter 10](kindle_split_020.html#ch10).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程因平台而异。在某些情况下，您编写的 JavaScript 可能会被编译成其他东西（更底层和高效的代码）然后再被烧录到设备上。在其他情况下，板上的微控制器可能能够直接执行
    JavaScript 的某些子集——这意味着您使用 JavaScript 编写代码，但您可能无法访问每种语言的所有功能（[图 8.3](#ch08fig03)）。我们将在第
    10 章中重新探讨受限的嵌入式 JavaScript 平台。
- en: Figure 8.3\. This class of devices combines constrained microcontrollers with
    optimized variants of JavaScript and JavaScript-like runtimes. We’ll explore both
    the Pico and the Element in [chapter 10](kindle_split_020.html#ch10).
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '图 8.3\. 这类设备将受限的微控制器与优化的 JavaScript 和类似 JavaScript 的运行时版本相结合。我们将在第 10 章中探讨
    Pico 和 Element。 '
- en: '![](08fig03_alt.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig03_alt.jpg)'
- en: Controlling a client with tiny computers (SBCs)
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用微型计算机（SBC）控制客户端
- en: Single-board computers (SBCs) are capable of running a real, multitasking operating
    system and provide a range of options in terms of processing power and onboard
    peripheral support. They can do a lot, including running Node.js, but they’re
    correspondingly more power-hungry, more costly, and physically larger than other
    development boards for embedded projects.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 单板计算机（SBC）能够运行真正的多任务操作系统，并在处理能力和板载外围设备支持方面提供多种选择。它们可以做很多事情，包括运行 Node.js，但相应地，它们比其他嵌入式项目开发板更耗电、更昂贵，体积也更大。
- en: 'With SBCs, the lines can be blurry between computer and dev board: some, like
    the popular Raspberry Pi series, combine generalized computing functionality with
    dev-board-like I/O on one board. Does that count as embedded logic execution,
    or is it a miniaturized variant of the host-client setup (with the Pi’s processor
    serving as a host to control the I/O)? Things get even more convoluted because
    you can, for example, use a Raspberry Pi to control an Arduino attached to one
    of the Pi’s own USB ports—a mini host-client setup. We’ll look at more SBCs in
    [chapter 11](kindle_split_021.html#ch11).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在单板计算机（SBC）中，计算机和开发板之间的界限可能变得模糊：一些，如流行的 Raspberry Pi 系列，将通用计算功能与类似开发板的 I/O 结合在一块板上。这算作嵌入式逻辑执行，还是作为主机-客户端设置的微型变体（Pi
    的处理器作为主机来控制 I/O）？事情变得更加复杂，因为您可以使用 Raspberry Pi 控制连接到 Pi 自身 USB 端口的一个 Arduino——一个微型主机-客户端设置。我们将在第
    11 章中探讨更多 SBC。
- en: 8.2\. Toward wires-free projects using the Tessel 2
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 使用 Tessel 2 实现无线的项目
- en: The Tessel 2 ([https://tessel.io/](https://tessel.io/)) is an open source development
    platform (both the hardware and the software are open source) centered around
    Node.js and the npm package manager ([figure 8.4](#ch08fig04)). In addition to
    the kinds of basic I/O you’ve come to rely on—digital, analog, PWM, I²C, and so
    on—the Tessel 2 also has a few higher-level peripheral goodies, like USB ports,
    Ethernet, and—hooray!—WiFi. (The Tessel 2 is the only Tessel model currently available,
    so I’ll generally just refer to it as the Tessel.)
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel 2 ([https://tessel.io/](https://tessel.io/)) 是一个以 Node.js 和 npm 软件包管理器为中心的开源开发平台（硬件和软件都是开源的）。除了您已经习惯的基本
    I/O 类型——数字、模拟、PWM、I²C 等等——Tessel 2 还提供了一些高级外围设备，如 USB 端口、以太网，以及——欢呼！——WiFi。（Tessel
    2 是目前唯一可用的 Tessel 型号，所以我会通常直接称之为 Tessel。）
- en: Figure 8.4\. The Tessel 2 open source development board
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. Tessel 2 开源开发板
- en: '![](08fig04.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig04.jpg)'
- en: The Tessel is an interesting and useful piece of hardware. Based on the “can
    run a real OS” criterion, it’d fall in the SBC category of devices—it ships with
    *OpenWrt*, a Linux distribution commonly found on routers, preinstalled.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel 是一个有趣且实用的硬件设备。根据“能够运行真实操作系统”的标准，它将属于 SBC 类别的设备——它预装了 *OpenWrt*，这是一个常见于路由器的
    Linux 发行版。
- en: 'But the development workflow is more reminiscent of host-client setups and
    embedded-JavaScript devices: you write code on your computer and deploy *to* the
    Tessel, as opposed to writing code *on* it. And although the Tessel runs OpenWrt
    and comes with some nifty software goodies that we’ll check out in a bit, it’s
    more constrained than SBC platforms like Raspberry Pis. It only has 64 MB of RAM
    and 32 MB of Flash space for programs. That’s leagues beyond what’s available
    on ATmega328P-based boards like the Uno, but it’s not in the same ballpark as
    a typical desktop computer.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 但开发工作流程更像是主机-客户端设置和嵌入式JavaScript设备：你在电脑上编写代码，并将其部署到Tessel上，而不是在Tessel上编写代码。尽管Tessel运行OpenWrt并附带一些我们将要检查的实用软件，但它比像Raspberry
    Pi这样的SBC平台更受限制。它只有64 MB的RAM和32 MB的Flash空间用于程序。这比基于ATmega328P的板如Uno上可用的空间大得多，但与典型的桌面计算机相比，它不在同一个水平上。
- en: After developing projects with Johnny-Five for the Uno, you’ll find many of
    the ergonomics with the Tessel familiar. Indeed, the mechanics of working with
    the Tessel will feel old hat if you’re used to developing with or for Node.js
    in general.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用Johnny-Five为Uno开发项目后，你会发现Tessel的许多人体工程学方面都很熟悉。确实，如果你习惯于使用Node.js进行开发，那么与Tessel一起工作的机制会感觉非常熟悉。 '
- en: 'There’s one difference between the Tessel and the Arduino Uno that’s essential
    to note: the Tessel operates at 3.3 V versus the Uno’s 5 V.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel与Arduino Uno之间有一个重要的区别需要注意：Tessel在3.3 V下运行，而Uno是5 V。
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tessel 2 is 3.3 V
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tessel 2是3.3 V
- en: 'The Tessel 2 operates at 3.3 V. You need to design circuits with this in mind,
    and make sure to use 3.3 V-friendly components. Plugging 5 V components or power
    into your Tessel 2’s pins could do damage to the board. Don’t worry: we’ll walk
    through the details as we go.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel 2在3.3 V下运行。你需要考虑到这一点来设计电路，并确保使用3.3 V兼容的组件。将5 V组件或电源插入Tessel 2的引脚可能会损坏电路。不用担心：我们会随着进展逐步介绍细节。
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.3\. Getting your Tessel set up
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 设置你的Tessel
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要准备的东西
- en: '![](note.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![note.jpg]'
- en: 1 Tessel 2
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Tessel 2
- en: '1 USB cable: USB A to USB micro'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1条USB线：USB A到USB micro
- en: '|  |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To get the Tessel ready for adventure, you need to connect it to your laptop
    with a USB cable, just like with the Uno. But there are some big differences.
    For one, the JavaScript code you’ll write will get uploaded to and run on the
    Tessel itself—the Tessel doesn’t need a host to do its thinking for it. Also,
    the Tessel has WiFi, so you don’t have to keep it plugged into USB once it’s set
    up—you can deploy to it wirelessly.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Tessel准备好冒险，你需要用USB线将其连接到你的笔记本电脑上，就像与Uno一样。但是有一些很大的不同。首先，你将要编写的JavaScript代码将上传到Tessel本身并运行——Tessel不需要主机来为它思考。此外，Tessel有WiFi，所以一旦设置好，你就不需要一直将其插入USB——你可以无线部署到它上面。
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Tessel and Node.js LTS**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tessel和Node.js LTS**'
- en: The Tessel supports the Long Term Support (LTS) version of Node.js, which at
    the time of writing is at 6.11 (and by the time you read this, it’ll likely be
    considerably further along). The code examples in this book will assume at least
    version 6.11, and the example scripts will make use of available language features
    in that version. Node.js versions newer than current LTS may not be compatible
    with the Tessel.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel支持Node.js的长期支持（LTS）版本，截至写作时是6.11（到你阅读时，它可能已经大大前进）。本书中的代码示例将假设至少是6.11版本，示例脚本将使用该版本中可用的语言功能。比当前LTS版本更新的Node.js版本可能不与Tessel兼容。
- en: Note that the version of Node.js running on the Tessel itself is likely different
    (and older) than your system Node.js version. Once your Tessel is configured,
    you can see what version of Node.js it’s running onboard, as well as its firmware
    version, by using the `t2 version` command (more on the `t2` tool shortly).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Tessel上运行的Node.js版本可能与你系统的Node.js版本不同（并且更旧）。一旦你的Tessel配置完成，你可以使用`t2 version`命令查看它正在运行的Node.js版本以及固件版本（稍后将有更多关于`t2`工具的介绍）。
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.3.1\. Configuring the Tessel
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 配置Tessel
- en: The following explanations may make the setup steps feel lengthy, but the process
    takes just a few minutes in most cases.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明可能会让设置步骤感觉比较长，但在大多数情况下这个过程只需要几分钟。
- en: 'Step 1: install the CLI'
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤1：安装CLI
- en: 'Install the command-line interface (CLI) for controlling your Tessel from your
    computer. This should be installed as a global npm package by entering the following
    command in your terminal:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 安装用于从你的电脑控制Tessel的命令行界面（CLI）。这应该作为一个全局npm包安装，你需要在终端中输入以下命令：
- en: '[PRE24]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once the module is installed, you’ll be able to use the `t2` command in a terminal
    to control your Tessel.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 模块安装完成后，您将能够在终端中使用 `t2` 命令来控制您的 Tessel。
- en: '|  |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`t2` vs. `t2-cli`'
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`t2` 与 `t2-cli`'
- en: The npm module is named `t2-cli`, but the command it makes available is `t2`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: npm 模块名为 `t2-cli`，但它提供的命令是 `t2`。
- en: '|  |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Step 2: connect, find, and rename your Tessel'
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 2 步：连接、查找并重命名您的 Tessel
- en: Connect a USB cable from the USB micro port on your Tessel to a USB port on
    your computer. This will provide power to the Tessel, and you should see an LED
    blink as it boots (this can take about 30 seconds).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 Tessel 上的 USB 微型端口连接到电脑上的 USB 端口。这将给 Tessel 提供电源，您应该会看到 LED 闪烁（这需要大约 30
    秒）。
- en: 'Find the Tessel by using this command in your terminal:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中查找 Tessel：
- en: '[PRE25]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should see something like this.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的内容。
- en: Listing 8.1\. `t2 list`
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. `t2 list`
- en: '[PRE26]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Yay! But `Tessel-02A397D5D8A4` isn’t very catchy. Luckily, it’s easy as pie
    to rename your Tessel with this command:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！但 `Tessel-02A397D5D8A4` 并不是很有吸引力。幸运的是，使用此命令重命名您的 Tessel 简单得就像做饼一样：
- en: '[PRE27]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I decided to call my Tessel `sweetbirch`. You can choose your own name.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定将我的 Tessel 命名为 `sweetbirch`。您可以选择自己的名字。
- en: Listing 8.2\. `t2 rename`
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. `t2 rename`
- en: '[PRE28]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Step 3: get Tessel on WiFi and provision'
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3 步：将 Tessel 连接到 WiFi 并配置
- en: 'Get your Tessel on your WiFi network with the following command:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将您的 Tessel 连接到 WiFi 网络：
- en: '[PRE29]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|  |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tessel’s WiFi compatibility
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tessel 的 WiFi 兼容性
- en: It’s usually easy to get a Tessel on a typical 2.4 GHz home WiFi network with
    a single command. But be aware, Tessels aren’t, at this time, compatible with
    5 GHz networks. If you run into trouble, head over to Tessel’s WiFi connection
    setup page ([http://tessel.github.io/t2-start/wifi.html](http://tessel.github.io/t2-start/wifi.html))
    for more connection info.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用单个命令就可以轻松地将 Tessel 连接到典型的 2.4 GHz 家庭 WiFi 网络。但请注意，Tessels 目前还不兼容 5 GHz
    网络。如果您遇到问题，请访问 Tessel 的 WiFi 连接设置页面 ([http://tessel.github.io/t2-start/wifi.html](http://tessel.github.io/t2-start/wifi.html))
    获取更多信息。
- en: '|  |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Finally, provision the Tessel so that you can send code to it from your computer
    over WiFi:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，配置 Tessel 以便您可以通过 WiFi 从您的电脑发送代码到它：
- en: '[PRE30]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The output of the `t2 list` command after provisioning should show the Tessel
    as available both on a USB connection and over WiFi (LAN), as shown in the next
    listing.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 配置后的 `t2 list` 命令输出应显示 Tessel 既可以通过 USB 连接，也可以通过 WiFi（局域网）可用，如以下列表所示。
- en: Listing 8.3\. `t2 list` after provisioning
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. 配置后的 `t2 list`
- en: '[PRE31]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Step 4: update your Tessel'
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 4 步：更新您的 Tessel
- en: 'Updates are released now and again for the Tessel’s firmware. Make sure you
    have the latest version by running this command:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel 的固件会不时发布更新。请确保您拥有最新版本，通过运行以下命令：
- en: '[PRE32]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If there are available updates, this process may take a few minutes.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有可用的更新，此过程可能需要几分钟。
- en: Make sure your Tessel is still connected to USB and booted up. To get the LED-blinking
    code going on your Tessel, first initialize the project as shown in the following
    listing.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 Tessel 仍然连接到 USB 并已启动。要在您的 Tessel 上运行 LED 闪烁代码，首先按照以下列表初始化项目。
- en: Listing 8.4\. Initialize the Blinking-LED Tessel project
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 初始化闪烁 LED Tessel 项目
- en: '[PRE33]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The `t2 init` command**'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**`t2 init` 命令**'
- en: 'Newer releases of the `t2-cli` npm package require you to run the command `t2
    init` within a project directory before that project’s code can be deployed to
    your Tessel. You only need to do this once (per project). If you forget to run
    `t2 init`, you’ll get a helpful message:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`t2-cli` npm 包的新版本要求您在将项目代码部署到您的 Tessel 之前，在项目目录中运行 `t2 init` 命令。您只需这样做一次（每个项目一次）。如果您忘记运行
    `t2 init`，您将收到一条有用的消息：'
- en: '[PRE34]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.3.2\. “Hello World” LED blinking on the Tessel
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. “Hello World” LED 在 Tessel 上闪烁
- en: You can control the Tessel with JavaScript right out of the proverbial box—that’s
    what the Tessel is made for. Create a file called hello-tessel.js and add the
    LED-blinking code in the following listing to it. This script will make one of
    the Tessel’s built-in, onboard LEDs blink.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接使用 JavaScript 控制 Tessel，这正是 Tessel 的用途。创建一个名为 hello-tessel.js 的文件，并在其中添加以下列表中的
    LED 闪烁代码。此脚本将使 Tessel 的内置板载 LED 闪烁。
- en: Listing 8.5\. hello-tessel.js
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. hello-tessel.js
- en: '[PRE35]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Imports the tessel hardware interface**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 tessel 硬件接口**'
- en: '***2* Starts by turning one of the onboard LEDs on**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 首先打开板载 LED 之一**'
- en: '***3* Toggles LEDs every 100 ms**'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每 100 毫秒切换 LED**'
- en: Now you can run the LED-blinking code on the Tessel by using the `t2 run <file>`
    command, as in the following listing. After the code deploys and starts running,
    you should see two of the Tessel’s onboard LEDs blinking rapidly.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`t2 run <file>`命令在Tessel上运行LED闪烁代码，如下所示。在代码部署并开始运行后，你应该看到Tessel的两个板载LED快速闪烁。
- en: Listing 8.6\. `t2 run`
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. `t2 run`
- en: '[PRE36]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `--lan` flag
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`--lan`标志'
- en: Johnny-Five scripts that log to the REPL (with `console .log()`) do better if
    the script is deployed over a LAN (WiFi) connection. The `--lan` flag for the
    `t2 run` command specifies that the WiFi connection should be used (versus the
    wired `usb` connection).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five脚本如果通过LAN（WiFi）连接部署到REPL（使用`console.log()`）会表现得更好。`t2 run`命令的`--lan`标志指定应该使用WiFi连接（而不是有线`usb`连接）。
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Understanding the “Hello Tessel” example
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解“Hello Tessel”示例
- en: There are some familiar-looking things in the hello-tessel.js code, but some
    details are unique to the Tessel (as compared to controlling the Uno with Johnny-Five).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在hello-tessel.js代码中有些看起来熟悉的东西，但一些细节是Tessel特有的（与使用Johnny-Five控制Uno相比）。
- en: 'The first thing in the code is the requirement of a library called `tessel`:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的第一件事是引入一个名为`tessel`的库的要求：
- en: '[PRE37]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Sharp-eyed observers may note that this is curious: you never `npm install`-ed
    any such library or otherwise made it available to the code on your computer.
    The Tessel 2 Hardware API documentation ([http://mng.bz/Ror5](http://mng.bz/Ror5))
    explains this `require` statement:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 留意观察者可能会注意到这一点很奇怪：你从未使用`npm install`安装过这样的库，或者以其他方式使其在你的电脑上的代码中可用。Tessel 2硬件API文档（[http://mng.bz/Ror5](http://mng.bz/Ror5)）解释了这个`require`语句：
- en: '*When you* `require(''tessel'')` *within a script which is executed on Tessel
    2, this loads a library which interfaces with the Tessel 2 hardware, including
    pins, ports, and LEDs...*'
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当你*在Tessel 2上执行的脚本中`require(''tessel'')`*时，这会加载一个与Tessel 2硬件接口的库，包括引脚、端口和LED...*'
- en: 'An important piece of the puzzle here is the phrase “executed on Tessel 2.”
    It’s true: if you tried to run the hello-tessel.js script with Node.js on your
    own computer, you wouldn’t get far—you’d encounter an error about the missing
    module. You won’t find the `tessel` package on npm, either. Instead, `tessel`
    is a JavaScript API library preinstalled on the Tessel itself, and therefore available
    to scripts that run on Tessel 2.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个重要的部分是短语“在Tessel 2上执行”。这是真的：如果你尝试在自己的电脑上用Node.js运行hello-tessel.js脚本，你不会走得太远——你会遇到一个关于缺少模块的错误。你也不会在npm上找到`tessel`包。相反，`tessel`是一个预安装在Tessel板上的JavaScript
    API库，因此对在Tessel 2上运行的脚本可用。
- en: 'Turning on and toggling the Tessel’s onboard LEDs via the `tessel` object looks
    sort of like working with Johnny-Five `Led` objects, but not quite:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`tessel`对象开启和切换Tessel板上的LED灯，看起来有点像使用Johnny-Five的`Led`对象，但又不完全一样：
- en: '[PRE38]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `tessel` object gives you access to the ports and pins on the Tessel board,
    exposing a hardware API to work with them. It’s a lower-level API than Johnny-Five:
    you can read and write digital, analog, and serial data, but there are no higher-level
    objects that wrap, say, a temperature sensor. The Tessel 2 Hardware API documentation
    provides lots more information ([http://mng.bz/Ror5](http://mng.bz/Ror5)).'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`tessel`对象让你可以访问Tessel板上的端口和引脚，暴露了一个硬件API来与之交互。这是一个比Johnny-Five更底层的API：你可以读取和写入数字、模拟和串行数据，但没有更高层次的对象来封装，比如温度传感器。Tessel
    2硬件API文档提供了更多相关信息（[http://mng.bz/Ror5](http://mng.bz/Ror5)）。'
- en: 8.3.3\. Blinking an external LED with the Tessel
  id: totrans-564
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 使用Tessel闪烁外部LED
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![note.jpg]'
- en: 1 Tessel 2
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Tessel 2
- en: 1 USB to USB-micro cable
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个USB到USB-micro线缆
- en: 1 standard LED
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个标准LED
- en: 1 100 V resistor
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个100 V电阻
- en: Jumper wires
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 1 full-size breadboard
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个全尺寸面包板
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Honoring the age-old tradition of the blinking-LED “Hello World,” let’s sink
    our teeth further into the Tessel with this classic first circuit. Instead of
    blinking an onboard LED, this example uses an externally connected LED. Although
    this experiment is pedestrian in scope, it will introduce you to the workflow
    and structure of Tessel projects.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 按照古老的闪烁LED“Hello World”传统，让我们进一步深入Tessel，使用这个经典的第一个电路。这个例子不是闪烁板载LED，而是使用外部连接的LED。虽然这个实验范围有限，但它会介绍你如何进行Tessel项目的工作流程和结构。
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Tessel project structure**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tessel项目结构**'
- en: 'Instead of writing one-off, standalone scripts as you did with the Uno, you’ll
    structure each Tessel experiment as a proper Node.js project:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 与你用Uno编写的单次、独立脚本不同，你将把每个Tessel实验结构化为一个合适的Node.js项目：
- en: Each experiment will have its own working directory.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个实验都将有自己的工作目录。
- en: You’ll use a package.json file to manage dependencies.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将使用 package.json 文件来管理依赖项。
- en: The main (entry point) script for experiments will be named index.js.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验的主要（入口）脚本将命名为 index.js。
- en: If you’re experienced with writing software with Node.js, this structure will
    look familiar.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉使用 Node.js 编写软件，这个结构看起来会很熟悉。
- en: '|  |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Setting up a Johnny-Five Tessel project
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置 Johnny-Five Tessel 项目
- en: 'Before writing any code, set up the working area for the project. You’ll need
    to create a directory and set up a package.json file using the `npm init` command.
    Open up a terminal and execute the following commands:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，设置项目的工作区域。你需要创建一个目录并使用 `npm init` 命令设置 package.json 文件。打开终端并执行以下命令：
- en: '[PRE39]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Running `npm init` will typically walk you through an interactive set of questions
    to set up your project. Adding the `-y` flag will skip those steps and create
    a package.json file with default settings. It’s a faster way to get started if
    you’re not concerned with your project’s specific configuration details. Once
    you’ve run `npm init`, you’ll have a package.json file.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm init` 通常会引导你通过一系列交互式问题来设置项目。添加 `-y` 标志将跳过这些步骤并使用默认设置创建 package.json
    文件。如果你不关心项目的特定配置细节，这是一个更快开始的方式。一旦你运行了 `npm init`，你将有一个 package.json 文件。
- en: Wiring the 3.3 V LED circuit
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接 3.3 V LED 电路
- en: Though you’ve build a basic LED-blink circuit before, a little arithmetic is
    in order to adjust for Tessel’s 3.3 V supply voltage. The circuit is similar to
    the basic LED circuit for the Uno you built in [chapter 3](kindle_split_010.html#ch03)
    ([figure 8.5](#ch08fig05)), but you’ll need a different current-limiting resistor
    to account for the Tessel’s 3.3 V logic.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你之前已经构建了一个基本的 LED 闪烁电路，但为了调整 Tessel 的 3.3 V 供电电压，需要进行一些算术运算。电路与你在 [第 3 章](kindle_split_010.html#ch03)
    中构建的 Uno 的基本 LED 电路相似（[图 8.5](#ch08fig05)），但你将需要一个不同的限流电阻来适应 Tessel 的 3.3 V 逻辑。
- en: Figure 8.5\. The original basic LED circuit for the Uno. The Uno operates at
    5.5 V, whereas the Tessel is a 3.3 V device. The circuit needs to be adjusted
    for the different voltage of the Tessel.
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. Uno 的原始基本 LED 电路。Uno 工作电压为 5.5 V，而 Tessel 是 3.3 V 设备。电路需要调整以适应 Tessel
    的不同电压。
- en: '![](08fig05_alt.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig05_alt.jpg)'
- en: 'Back in [chapter 3](kindle_split_010.html#ch03), you made a calculation for
    the needed current-limiting resistor for a single LED in a series circuit by taking
    into account both the Uno’s operating voltage (5 V) and an approximation of an
    LED’s forward voltage (~1.8 V). You came up with this:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](kindle_split_010.html#ch03) 中，你通过考虑 Uno 的工作电压（5 V）和 LED 正向电压的近似值（约
    1.8 V）来计算串联电路中单个 LED 所需的限流电阻。你得到了以下结果：
- en: '[PRE40]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Targeting 20 mA of current for the LED, you then used Ohm’s law:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 为 LED 设定 20 mA 的电流，然后你使用了欧姆定律：
- en: '[PRE41]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 160 V isn’t a common resistance value, so you rounded up to 220 V (which is
    a common value).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 160 V 不是一个常见的电阻值，所以你将其四舍五入到 220 V（这是一个常见值）。
- en: 'Adjust the values for the 3.3 V supply on the Tessel:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 调整 Tessel 上的 3.3 V 供电值：
- en: '[PRE42]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '75 V isn’t a common resistance value, but 100 V is—a 100 V resistor will do
    just fine here! It makes sense that a lower resistance value is called for than
    in the 5 V circuit: there’s less voltage left over after the LED voltage drop
    to account for.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 75 V 不是一个常见的电阻值，但 100 V 是——一个 100 V 的电阻在这里就足够了！在 5 V 电路中，所需的电阻值较低是有道理的：LED 电压降后剩余的电压较少。
- en: Wire the circuit as shown in the Tessel LED wiring diagram ([figure 8.6](#ch08fig06)).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 Tessel LED 连接图（[图 8.6](#ch08fig06)）所示连接电路。
- en: Figure 8.6\. Connect the LED’s anode to Tessel’s port A, pin 5, and its cathode
    to the GND connection on port A.
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6\. 将 LED 的阳极连接到 Tessel 的端口 A，引脚 5，将阴极连接到端口 A 的 GND 连接。
- en: '![](08fig06_alt.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig06_alt.jpg)'
- en: Writing the LED-blinking code
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 LED 闪烁代码
- en: In [chapter 2](kindle_split_009.html#ch02), the blinking-LED experiment for
    the Arduino Uno using Johnny-Five used the following code.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](kindle_split_009.html#ch02) 中，使用 Johnny-Five 为 Arduino Uno 编写的闪烁 LED
    实验使用了以下代码。
- en: Listing 8.7\. led.js
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. led.js
- en: '[PRE43]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Instantiates a Board object with no non-default options**'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用无非默认选项的 Board 对象实例化**'
- en: '***2* When the board is ready...**'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当板子准备好...**'
- en: '***3* Instantiates an Led, connected to pin 13**'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实例化一个连接到引脚 13 的 Led 对象**'
- en: '***4* Blinks the LED**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 闪烁 LED**'
- en: 'There isn’t much that needs changing to make this work with the Tessel. You
    need to account for two things:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此代码与 Tessel 一起工作，不需要做太多更改。你需要考虑两件事：
- en: The Tessel needs different I/O-layer support to work with Johnny-Five. You’ll
    need to make your `Board` object use `tessel-io` for its I/O (instead of the default
    `firmata`).
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tessel需要不同的I/O层支持才能与Johnny-Five协同工作。您需要确保您的`Board`对象使用`tessel-io`进行I/O（而不是默认的`firmata`）。
- en: The pin number that the LED is attached to needs to be updated.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更新的LED连接到的引脚编号。
- en: 'Start by running the following command in your `t2-blink` working directory:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在您的`t2-blink`工作目录中运行以下命令：
- en: '[PRE44]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will install the `johnny-five` and `tessel-io` packages locally and `save`
    the dependencies into the package.json file. You know the `johnny-five` package
    well already. `tessel-io` is the Johnny-Five I/O plugin for the Tessel.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这将本地安装`johnny-five`和`tessel-io`包，并将依赖项保存到package.json文件中。您已经熟悉`johnny-five`包。`tessel-io`是Johnny-Five为Tessel提供的I/O插件。
- en: Create a file called index.js in the same directory, and add the following code.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个名为index.js的文件，并添加以下代码。
- en: Listing 8.8\. index.js
  id: totrans-618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. index.js
- en: '[PRE45]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Requires the tessel-io package**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要tessel-io包**'
- en: '***2* Tells the Board to use tessel-io for I/O**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 告诉板使用tessel-io进行I/O**'
- en: '***3* The LED is connected to port A, pin 5 on the Tessel.**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* LED连接到Tessel的端口A，引脚5。**'
- en: 'This code is remarkably similar to the Uno-compatible code. The only differences
    are the I/O plugin and the pin number. Go ahead and try it out by using the `t2
    run` command:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与Uno兼容代码非常相似。唯一的不同是I/O插件和引脚编号。请使用`t2 run`命令尝试运行它：
- en: '[PRE46]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You should see output similar to the next listing, and the LED should start
    blinking.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下列表的输出，并且LED应该开始闪烁。
- en: Listing 8.9\. Running the LED-blink code on the Tessel
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9\. 在Tessel上运行LED闪烁代码
- en: '[PRE47]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 8.3.4\. Exploring the Tessel’s pins and capabilities
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 探索Tessel的引脚和功能
- en: Like the Arduino Uno, different pins on the Tessel do different things. There
    are 16 I/O pins on the Tessel, split between two ports ([figure 8.7](#ch08fig07)).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 与Arduino Uno类似，Tessel上的不同引脚执行不同的功能。Tessel上有16个I/O引脚，分布在两个端口之间（[图8.7](#ch08fig07)）。
- en: Figure 8.7\. The Tessel’s pins are divided into two “ports,” each with 8 I/O
    pins.
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7\. Tessel的引脚分为两个“端口”，每个端口有8个I/O引脚。
- en: '![](08fig07.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig07.jpg)'
- en: Pins are numbered A0–A7 (on port A) and B0–B7 (on port B). The top two pins
    in each physical port provide power connections (GND and 3.3 V). Other features,
    like I²C, SPI, and UART (asynchronous/TTL serial) are supported on specific pins
    ([figure 8.8](#ch08fig08)).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚编号为A0–A7（在端口A上）和B0–B7（在端口B上）。每个物理端口顶部两个引脚提供电源连接（GND和3.3 V）。其他功能，如I²C、SPI和UART（异步/TTL串行），在特定引脚上得到支持（[图8.8](#ch08fig08)）。
- en: Figure 8.8\. Tessel 2 pins and their features. Any numbered pin can be used
    as digital I/O.
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.8\. Tessel 2引脚及其功能。任何编号的引脚都可以用作数字I/O。
- en: '![](08fig08_alt.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig08_alt.jpg)'
- en: Although all pins can be used as digital I/O pins, analog input (ADC) is available
    on pins A4 and A7 and on all port B pins. You can also see that some pins support
    interrupts (meaning they would be viable for “listening” for button presses or
    for other applications that need to accurately detect a change from LOW to HIGH
    or vice versa). Some, but not all, pins support PWM.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有引脚都可以用作数字I/O引脚，但模拟输入（ADC）在引脚A4和A7以及所有端口B引脚上可用。您还可以看到一些引脚支持中断（这意味着它们可以用于“监听”按钮按下或其他需要准确检测从低电平到高电平或反之的变动的应用）。一些引脚支持PWM，但并非所有引脚都支持。
- en: 'Pin B7 has a capability we haven’t run into yet: analog *out*. That pin can
    provide digital-to-analog conversion (DAC). We won’t explore that capability directly,
    but it is available on the Tessel.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚B7有一个我们尚未遇到的功能：模拟*输出*。该引脚可以提供数字到模拟转换（DAC）。我们不会直接探索这个功能，但在Tessel上它是可用的。
- en: 8.4\. Projects without wires on the Tessel
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. Tessel上的无线路由项目
- en: Hey, wait! The LED example still has you tethered. Next you’ll start removing
    some wires.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，等等！LED示例仍然需要连接。接下来，您将开始移除一些电线。
- en: First, you’ll untether the Tessel from your computer but use a wall outlet to
    provide power.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将Tessel从您的计算机上断开连接，但使用电源插座供电。
- en: '|  |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What you’ll need
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 您需要准备
- en: '![](note.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Tessel 2
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Tessel 2
- en: 5 V–12 V USB charger
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 V–12 V USB充电器
- en: 1 LED
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 LED
- en: 1 100 V resistor
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 100 V电阻
- en: 1 half-size breadboard
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 半尺寸面包板
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Wall power for the Tessel**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tessel的墙电源**'
- en: If your Tessel didn’t come with a USB DC adapter, you can use a 5 V USB charger,
    like a tablet or phone charger, to power the Tessel.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Tessel没有附带USB直流适配器，您可以使用5 V USB充电器（如平板电脑或手机充电器）为Tessel供电。
- en: Like the Arduino Uno’s DC input jack, the Tessel’s USB micro connection has
    a power regulator to regulate input voltage down to the needed 3.3 V. The standard
    5 V (USB voltage) is just right for input voltage.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Arduino Uno 的直流输入插孔一样，Tessel 的 USB 微型连接也具有电源调节器，可以将输入电压调节到所需的 3.3 V。标准的 5
    V（USB 电压）正好适合输入电压。
- en: '![](0231fig01.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![](0231fig01.jpg)'
- en: USB wall adapters that provide 5 V DC power are widespread. They’re especially
    popular as chargers for phones and tablets.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 提供直流 5 V 电压的 USB 墙上适配器很常见。它们特别受欢迎，因为手机和平板电脑的充电器。
- en: '|  |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Just to prove you can, you’ll adapt the LED blink code a bit to make the LED
    pulse. You can do this because the LED is connected to a PWM-capable pin on the
    Tessel.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了证明你可以做到，你将稍微修改 LED 闪烁代码，使其 LED 闪烁。你可以这样做，因为 LED 连接到 Tessel 上的一个 PWM 功能引脚。
- en: 'To make that change, find the following line in index.js:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行此更改，请在 index.js 中找到以下行：
- en: '[PRE48]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Replace it with this:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换它：
- en: '[PRE49]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, plug your Tessel into wall power anywhere you like, as long as it’s within
    range of the same WiFi network that your computer’s on. Allow it time to boot
    before trying to deploy code to it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将你的 Tessel 插入任何你喜欢的电源插座，只要它在你电脑所在的同一 WiFi 网络范围内。在尝试向其部署代码之前，请给它一些时间来启动。
- en: 'Now, back at your computer, you can try deploying in a slightly different fashion.
    In your working directory, execute this command:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的电脑上，你可以尝试以稍微不同的方式部署。在你的工作目录中，执行以下命令：
- en: '[PRE50]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `t2 push` command differs from the `t2 run` command. With `t2 run`, the
    Node.js process will execute on the Tessel only until the host computer kills
    the process (typically via Ctrl-C). With `t2 push`, the program will be flashed
    to the Tessel and will run as long as the Tessel has power. If you unplug the
    Tessel and plug it back in again, it will resume executing the program.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`t2 push` 命令与 `t2 run` 命令不同。使用 `t2 run` 时，Node.js 进程将在 Tessel 上执行，直到主机计算机终止该进程（通常通过
    Ctrl-C）。使用 `t2 push` 时，程序将被烧录到 Tessel 上，并且只要 Tessel 有电就会一直运行。如果你拔掉 Tessel 并再次插上，它将恢复执行程序。'
- en: 'Now you have an LED pulsing somewhere yonder, but that’s not terrifically exciting.
    It’s time to build something a little more functional that can also hook into
    the Node.js ecosystem available on the Tessel. You can use the Tessel as an independent
    weather station: reading data from one or more sensors and serving that data by
    running a local web server ([figure 8.9](#ch08fig09)).'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个在某处闪烁的 LED，但这并不特别令人兴奋。是时候构建一个功能更强大、可以连接到 Tessel 上 Node.js 生态系统的项目了。你可以将
    Tessel 用作独立的气象站：从一个或多个传感器读取数据，并通过运行本地 Web 服务器来提供这些数据（[图 8.9](#ch08fig09)）。
- en: Figure 8.9\. A Tessel serves as the nerve center for a mini weather station.
    A Node.js application running on the Tessel will read data from the BMP180 multisensor
    and run a web server so that other computers on the same WiFi network can view
    weather information in a web browser.
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.9\. Tessel 作为迷你气象站的神经中枢。运行在 Tessel 上的 Node.js 应用程序将读取 BMP180 多传感器数据，并运行
    Web 服务器，以便同一 WiFi 网络上的其他计算机可以在 Web 浏览器中查看天气信息。
- en: '![](08fig09_alt.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig09_alt.jpg)'
- en: '8.4.1\. Wires-free data: a remote weather station'
  id: totrans-668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 无线数据：远程气象站
- en: '|  |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要
- en: '![](note.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
  zh: '![](note.jpg)'
- en: 1 Tessel 2
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Tessel 2
- en: 1 USB-micro to USB-A cable
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 根 USB-micro 到 USB-A 线缆
- en: 1 5 V–12 V USB charger
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 5 V–12 V USB 充电器
- en: 1 Adafruit BMP180 I²C multisensor
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个 Adafruit BMP180 I²C 多传感器
- en: Jumper wires
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 1 half-size breadboard
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个半尺寸面包板
- en: '|  |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'There’s a nifty feature of the Adafruit I²C sensors used in [chapter 7](kindle_split_016.html#ch07):
    they’re happy at both 5 V and 3.3 V. Their breakout boards each contain voltage
    regulator hardware and can handle level shifting—that is, they can account for
    the different logic-level voltages of 3.3 V and 5 V microcontrollers. You can
    use these sensors as easily with the Tessel as with the Arduino Uno.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](kindle_split_016.html#ch07) 中使用的 Adafruit I²C 传感器有一个很酷的功能：它们在 5 V
    和 3.3 V 下都很高兴。它们的分线板每个都包含电压调节器硬件，可以处理电平转换——也就是说，它们可以处理 3.3 V 和 5 V 微控制器的不同逻辑电平电压。你可以像使用
    Arduino Uno 一样轻松地使用这些传感器。
- en: 'The circuit is straightforward: wire the BMP180 I²C sensor to the Tessel as
    shown in [figure 8.10](#ch08fig10).'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 电路很简单：将 BMP180 I²C 传感器按照 [图 8.10](#ch08fig10) 所示连接到 Tessel。
- en: Figure 8.10\. Connect the BMP180 I²C sensor to power (GND and 3.3 V pins of
    port A), SCL (A0), and SDA (A1).
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.10\. 将 BMP180 I²C 传感器连接到电源（A 端口的 GND 和 3.3 V 引脚）、SCL（A0）和 SDA（A1）。
- en: '![](08fig10_alt.jpg)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig10_alt.jpg)'
- en: 'In your terminal application, set up a new working project directory and install
    dependencies in the same way as for the LED example:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端应用程序中，设置一个新的工作项目目录，并像 LED 示例一样安装依赖项：
- en: '[PRE51]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a file called index.js and add the following code.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 index.js 的文件并添加以下代码。
- en: Listing 8.10\. index.js
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. index.js
- en: '[PRE52]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Don’t forget to specify tessel-io as the I/O layer.**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不要忘记指定 tessel-io 作为 I/O 层。**'
- en: '***2* When the change event fires on the sensor’s thermometer instance...**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当传感器的温度实例上触发变化事件时...**'
- en: '***3* ...logs out the current reading in Fahrenheit**'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* ...记录当前的华氏温度**'
- en: As with the previous LED-blinking code, the abstraction of I/O out of Johnny-Five
    core components makes this code look nearly identical to how you’d use an I²C
    sensor on the Arduino Uno. In fact, the only difference here is that you’re passing
    a different I/O plugin option when creating the `Board` object. You don’t have
    to mess with pin numbers because the `board` already knows which pins support
    I²C on the Tessel (and it will default to port A).
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 LED-闪烁代码一样，将 I/O 抽象化到 Johnny-Five 核心组件中使得这段代码看起来几乎与你在 Arduino Uno 上使用 I²C
    传感器的方式相同。实际上，这里唯一的区别在于创建 `Board` 对象时传递了不同的 I/O 插件选项。你不需要与引脚号打交道，因为 `board` 已经知道
    Tessel 上哪些引脚支持 I²C（并且它将默认使用端口 A）。
- en: 'The preceding code accesses the `thermometer` instance via `weatherSensor`.
    A `Multi` object instance for controller `BMP180` contains `thermometer` and `barometer`
    properties, which are references to component class instances representing the
    BMP180’s temperature and pressure sensors. Each multisensor component generates
    events independently, and events are also aggregated up to the `Multi` instance
    collectively:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过 `weatherSensor` 访问 `thermometer` 实例。一个用于控制器 `BMP180` 的 `Multi` 对象实例包含
    `thermometer` 和 `barometer` 属性，这些属性是代表 BMP180 的温度和压力传感器的组件类实例的引用。每个多传感器组件独立生成事件，事件也会汇总到
    `Multi` 实例中：
- en: '[PRE53]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Other *collection* component classes in Johnny-Five (such as `Buttons` and `Leds`)
    behave in a similar fashion.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five（如 `Buttons` 和 `Leds`）中的其他 *collection* 组件类以类似的方式运行。
- en: 'With your Tessel connected via USB for now, use `t2 run` to try the script
    out on the Tessel:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前你的 Tessel 通过 USB 连接，使用 `t2 run` 在 Tessel 上尝试运行脚本：
- en: '[PRE54]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see something like this:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似这样的内容：
- en: '[PRE55]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To do something useful with the sensor’s readings—something more intuitive and
    visual—you’ll take advantage of the Tessel’s ability to support npm packages and
    execute more sophisticated Node.js code—let’s see how to build a web app.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用传感器的读数做一些有用的事情——一些更直观和可视化的东西——你将利用 Tessel 支持 npm 包和执行更复杂的 Node.js 代码的能力——让我们看看如何构建一个网络应用程序。
- en: Building more sophisticated apps on the Tessel
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Tessel 上构建更复杂的应用程序
- en: To serve web content from the Tessel, you’ll need to create a few additional
    files. At the very least, you’ll need to start with a basic HTML document.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Tessel 服务器上提供网页内容，你需要创建一些额外的文件。至少，你需要从一个基本的 HTML 文档开始。
- en: Create a directory called “app” inside the t2-weather directory. Create an index.html
    file inside of that directory, as shown in the following directory structure.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在 t2-weather 目录内创建一个名为“app”的目录。在该目录内创建一个 index.html 文件，如下面的目录结构所示。
- en: Listing 8.11\. Project directory and file structure, so far
  id: totrans-703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 到目前为止的项目目录和文件结构
- en: '[PRE56]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open up index.html and add the following content.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 index.html 并添加以下内容。
- en: Listing 8.12\. index.html
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. index.html
- en: '[PRE57]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When you execute code on the Tessel, the Tessel knows to copy over and use the
    script you’re running as well as the Node.js modules installed for the project.
    But you need to tell it explicitly if it needs to use assets outside of those
    items. You can do this by placing a .tesselinclude file in the root level of your
    project.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Tessel 上执行代码时，Tessel 会知道复制并使用你正在运行的脚本以及为项目安装的 Node.js 模块。但是，如果你需要使用这些项目之外的资源，你需要明确地告诉它。你可以通过在你的项目根目录中放置一个
    .tesselinclude 文件来实现这一点。
- en: 'Create a .tesselinclude file and add the following to it:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 .tesselinclude 文件并添加以下内容：
- en: '[PRE58]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Each line in a .tesselinclude is a *glob*, a pattern for matching files. For
    example, `app/` matches all the files in the app directory. This will ensure that
    the Tessel copies over all of the files in the app directory when it deploys.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: .tesselinclude 中的每一行都是一个 *glob*，一个用于匹配文件的模式。例如，`app/` 匹配 app 目录中的所有文件。这将确保当
    Tessel 部署时，它会复制 app 目录中的所有文件。
- en: After adding .tesselinclude, your file structure should look like this.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 .tesselinclude 之后，你的文件结构应该看起来像这样。
- en: Listing 8.13\. Project directory and file structure with .tesselinclude
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 包含 .tesselinclude 的项目目录和文件结构
- en: '[PRE59]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, you’ll tackle building a web app to show weather station data in two
    steps:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将分两步构建一个 Web 应用程序来显示气象站数据：
- en: You’ll set up a basic, static web server by combining the Express ([http://expressjs.com/](http://expressjs.com/))
    web application framework with built-in Node.js modules. This will serve a basic
    web page that will be the container for the weather station data.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将通过将 Express ([http://expressjs.com/](http://expressjs.com/)) Web 应用程序框架与内置的
    Node.js 模块相结合来设置一个基本的静态 Web 服务器。这将提供基本的网页，它将成为气象站数据的容器。
- en: You’ll set up a socket.IO server on the Tessel (the web server) and connect
    to it from the client (from the JavaScript that runs in the browser). You’ll also
    spiff up the HTML with some CSS and structured markup.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在 Tessel（即网络服务器）上设置一个 socket.IO 服务器，并从客户端（从浏览器中运行的 JavaScript）连接到它。你还将使用一些
    CSS 和结构化标记来美化 HTML。
- en: Setting up a static web server
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置静态 Web 服务器
- en: You’ll start simple by spinning up a basic, static web server in your app’s
    code. *Static* here means that the web server will deliver assets (like HTML,
    images, JavaScript, and the like) without performing any dynamic, server-side
    processing on them—it’ll just deliver the files it’s asked for from a designated
    directory.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过在你的应用程序代码中启动一个基本的静态 Web 服务器来开始简单。在这里，“静态”意味着 Web 服务器将交付资产（如 HTML、图像、JavaScript
    等），而不会对它们执行任何动态的服务器端处理——它只会从指定的目录中交付请求的文件。
- en: 'Begin by installing the `express` web framework. Make sure you’re in the t2-weather
    directory, and execute the following command in a terminal:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 `express` Web 框架。确保你处于 t2-weather 目录中，并在终端中执行以下命令：
- en: '[PRE60]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Returning now to the index.js script, add the following code to the top of the
    file.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到 index.js 脚本，将以下代码添加到文件顶部。
- en: Listing 8.14\. index.js
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. index.js
- en: '[PRE61]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Requires Express**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要 Express**'
- en: '***2* Requires some built-in Node.js modules**'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 需要一些内置的 Node.js 模块**'
- en: '***3* Instantiates a new Express app**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实例化一个新的 Express 应用程序**'
- en: '***4* Tells the app to serve static assets out of the app/ directory**'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 告诉应用程序从 app/ 目录中提供静态资产**'
- en: '***5* Creates an HTTP server and passes it the app**'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建一个 HTTP 服务器并将应用程序传递给它**'
- en: '***6* Omit or comment out the console.log lines from the previous version.**'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 从上一个版本中省略或注释掉 console.log 行**'
- en: '***7* Makes the server listen for requests on port 3000**'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使服务器在端口 3000 上监听请求**'
- en: It’s not necessary to `npm install` the modules `os`, `path`, or `http` because
    they’re built into Node.js.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们内置在 Node.js 中，因此没有必要使用 `npm install` 安装 `os`、`path` 或 `http` 模块。
- en: Try it out!
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下！
- en: '[PRE62]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You should see results like the following.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果。
- en: Listing 8.15\. Running index.js
  id: totrans-736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. 运行 index.js
- en: '[PRE63]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* The app is getting larger as you add more dependencies.**'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 随着你添加更多的依赖项，应用程序正在变得更大。**'
- en: '***2* This is the Tessel’s internal address and actively listening HTTP port.**'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是 Tessel 的内部地址，并且正在积极监听 HTTP 端口。**'
- en: You can now open up a web browser and view the URL logged in the console (make
    sure you use the URL that displays in your output—not the one shown in the preceding
    example output).
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以打开一个 Web 浏览器并查看控制台日志中记录的 URL（确保你使用输出中显示的 URL——而不是前面示例输出中显示的 URL）。
- en: '|  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The Tessel’s IP address**'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tessel 的 IP 地址**'
- en: Your Tessel needs to be connected to the same network as your computer for this
    experiment to work. This will likely be a WiFi network, as discussed in the setup
    section, though the Tessel does also have an Ethernet port.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个实验工作，你的 Tessel 需要连接到与你的计算机相同的网络。这可能是 WiFi 网络，如设置部分中讨论的那样，尽管 Tessel 也有一个以太网端口。
- en: 'Being connected to the network results in the Tessel being assigned its own
    IP address, which you’ll need to know to access the web server running on it.
    The following line in the index.js code conveniently displays this for you:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到网络会导致 Tessel 被分配自己的 IP 地址，你需要知道这个地址才能访问其上运行的 Web 服务器。在 index.js 代码中的以下行方便地显示了这一点：
- en: '[PRE64]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can copy and paste the output of this from your terminal app into a browser’s
    URL bar. Visiting the output URL in a browser will render the current index.html
    file ([figure 8.11](#ch08fig11)).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将终端应用程序中的输出复制并粘贴到浏览器的 URL 框中。在浏览器中访问输出 URL 将渲染当前的 index.html 文件 ([图 8.11](#ch08fig11))。
- en: '|  |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 8.11\. Nothing fancy! Navigating to the Tessel’s IP address and port
    in a browser displays the index.html file, which doesn’t do anything much yet.
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.11\. 没有什么花哨的！在浏览器中导航到 Tessel 的 IP 地址和端口会显示 index.html 文件，但目前它还没有做什么。
- en: '![](08fig11_alt.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig11_alt.jpg)'
- en: Using Socket.IO to display live data
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Socket.IO显示实时数据
- en: 'One option for a simple web app would be to include the current sensor values
    within the markup of the HTML document that’s served. This is a perfectly valid
    approach, and it follows a traditional HTTP model: the browser is in charge of
    asking the server for more data, in the form of a full document (web page) request.
    The side effect is that a user would have to reload the page in the browser to
    see new readings.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的Web应用，一个选项是在提供的HTML文档的标记中包含当前的传感器值。这是一个完全有效的方法，并且遵循传统的HTTP模型：浏览器负责请求服务器更多的数据，形式为完整的文档（网页）请求。副作用是，用户必须在浏览器中重新加载页面才能看到新的读取值。
- en: There’s a better way!
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 有更好的方法！
- en: The WebSocket API is a web standard that lets a client (a browser) and a server
    exchange asynchronous messages over a single TCP *socket*. Each can push messages
    to the other, allowing for the exchange of near-real-time data.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket API是一个网络标准，允许客户端（浏览器）和服务器通过单个TCP *socket*进行异步消息交换。每个都可以向对方推送消息，从而实现近乎实时数据的交换。
- en: WebSocket is supported by many, but not all, browsers. To help plug the gaps,
    you’ll use Socket.IO, an API that uses WebSocket when it can (when the browser
    supports it), but that has a long list of other fallback transports to emulate
    WebSocket behavior. In short, it makes using WebSocket features easy and worry-free.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket被许多浏览器支持，但并非所有浏览器。为了填补这些空白，你将使用Socket.IO，这是一个API，当浏览器支持WebSocket时（当浏览器支持时），它会使用WebSocket，但它有一长串其他回退传输来模拟WebSocket行为。简而言之，它使得使用WebSocket功能变得简单且无忧。
- en: With Socket.IO, when sensor readings change, the socket server can “push” the
    new data to the client (assuming the client is listening for it and does something
    useful with the updated data). The net effect is that you can make the sensor
    readings update in the browser frequently, without page reloads.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Socket.IO，当传感器读取值发生变化时，socket服务器可以将新数据“推送”到客户端（假设客户端正在监听并使用更新的数据）。最终效果是，你可以在浏览器中频繁更新传感器读取值，而无需重新加载页面。
- en: 'The first step is to install the `socket.io` npm package:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装`socket.io` npm包：
- en: '[PRE65]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, update the contents of index.js with the following code.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码更新index.js的内容。
- en: Listing 8.16\. index.js
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.16\. index.js
- en: '[PRE66]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Requires the socket.io library**'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要socket.io库**'
- en: '***2* Creates the socket.io server**'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建socket.io服务器**'
- en: '***3* Has Johnny-Five reduce the frequency of sensor reads down to five seconds**'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 让Johnny-Five将传感器读取频率降低到五秒**'
- en: '***4* Registers a callback for when a client requests a connection**'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为客户端请求连接时注册回调**'
- en: Dialing down the sensor-read frequency to every five seconds keeps performance
    within bounds and establishes a reasonable threshold for how often the client
    will receive new data over the socket. Every five seconds is the maximum frequency
    that the socket server will trigger updates, because the `weather` event will
    only get fired if the sensor readings change.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 将传感器读取频率降低到每五秒一次，可以保持性能在合理范围内，并为客户端通过socket接收新数据的频率设定一个合理的阈值。每五秒是socket服务器触发更新的最大频率，因为只有当传感器读取值发生变化时，`weather`事件才会被触发。
- en: Let’s examine the Socket.IO `connection` handling more closely in the following
    listing.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查以下列表中的Socket.IO `connection`处理。
- en: Listing 8.17\. index.js
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.17\. index.js
- en: '[PRE67]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|  |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Code not production-worthy
  id: totrans-770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码非生产级
- en: The code in these examples is pared down to a minimum for clarity and brevity.
    That’s fine for at-home prototyping, but the code in index.js isn’t production-ready.
    In a “real” codebase, you’d want to be sure that the socket server doesn’t willy-nilly
    accept every incoming connection, that a maximum number of connections is enforced,
    and so on. In addition, although the index.html markup contains valid HTML, it
    lacks a few accessibility and polish niceties, and greater care could be taken
    in the CSS for supporting older browsers and diverse browsing environments (such
    as mobile devices).
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的代码被简化到最小，以保持清晰和简洁。这对于在家原型设计来说是不错的，但index.js中的代码并不是为生产准备的。在一个“真实”的代码库中，你想要确保socket服务器不会随意接受每个传入的连接，要强制执行最大连接数，等等。此外，尽管index.html标记包含有效的HTML，但它缺少一些可访问性和润色细节，并且在CSS中可以更加关注支持旧版浏览器和多样化的浏览环境（如移动设备）。
- en: '|  |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The socket server won’t be too useful if there isn’t also a client that takes
    advantage of it. First, you need to prepare the HTML to display sensor values
    by adding some structured markup, as shown in the next listing.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有利用它的客户端，socket 服务器将不会太有用。首先，你需要通过添加一些结构化标记来准备 HTML 以显示传感器值，如下一个列表所示。
- en: Listing 8.18\. index.html
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. index.html
- en: '[PRE68]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Includes the client socket.io JavaScript**'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含客户端 socket.io JavaScript**'
- en: '***2* You’ll create this CSS file shortly.**'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你将很快创建这个 CSS 文件。**'
- en: '***3* Marks the content up in some container elements that will render as a
    row**'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在某些容器元素中标记内容，这些元素将渲染为行**'
- en: '***4* The .data—value spans will be populated with sensor data.**'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* .data—value spans 将会被填充上传感器数据。**'
- en: 'This line may be causing you to scratch your head:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行可能让你感到困惑：
- en: '[PRE69]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Where’d that JavaScript file “magically” come from?
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 JavaScript 文件“神奇地”是从哪里来的？
- en: In index.js, you started up socket.io by giving it a `server` instance—it makes
    client-side code available automatically, via the server, at /socket.io/socket.io.js.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在 index.js 中，你通过提供一个 `server` 实例启动了 socket.io，这使得客户端代码可以通过服务器自动在 /socket.io/socket.io.js
    上提供。
- en: 'As for this line:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一行：
- en: '[PRE70]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You’ll make that stylesheet now. Within the t2-weather directory, navigate into
    the app subdirectory and create a file called style.css. Add the following code
    to it.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将创建那个样式表。在 t2-weather 目录中，导航到 app 子目录并创建一个名为 style.css 的文件。向其中添加以下代码。
- en: Listing 8.19\. style.css
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.19\. style.css
- en: '[PRE71]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '|  |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**CSS flexbox**'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS flexbox**'
- en: The CSS here makes use of the “flexible box” layout mode, a.k.a. *flexbox*.
    Flexbox allows you to arrange and position elements without the confusion of floats
    and collapsing margins. Flexbox is increasingly well supported, but if you’re
    using Internet Explorer, things may lay out a bit funky (Edge browsers do, however,
    support flexbox). If all this is gibberish, not to worry. The CSS here just styles
    the web page and isn’t critical to understanding the functionality of the project.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 CSS 使用了“flexible box”布局模式，也就是 *flexbox*。Flexbox 允许你安排和定位元素，而不会因为浮动和塌陷边距的混淆。Flexbox
    越来越受到良好的支持，但如果你在使用 Internet Explorer，布局可能会有些奇怪（然而，Edge 浏览器确实支持 flexbox）。如果这一切听起来很陌生，不要担心。这里的
    CSS 只是样式化网页，并不关键于理解项目的功能。
- en: '|  |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 8.20\. Complete file and directory structure of project
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.20\. 项目的完整文件和目录结构
- en: '[PRE72]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, finally, the linchpin. The client needs to connect to the socket server,
    listen for relevant events (`weather`, in this case), and respond to them in some
    useful manner. Return to index.html and add the following code to the file, just
    before the `body` closing tag (`</body>`).
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后的关键部分。客户端需要连接到 socket 服务器，监听相关事件（在这种情况下是 `weather`），并以某种有用的方式响应它们。回到 index.html，并在
    `</body>` 标签之前添加以下代码到文件中。
- en: Listing 8.21\. index.html
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.21\. index.html
- en: '[PRE73]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* When the page’s DOM is all loaded...**'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当页面的 DOM 完全加载...**'
- en: '***2* Create a Socket.IO client.**'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建 Socket.IO 客户端。**'
- en: '***3* Register a callback for weather events.**'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注册天气事件的回调函数。**'
- en: '***4* Handler function for the weather event: parses updated data and updates
    page display**'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 处理天气事件的处理器函数：解析更新后的数据并更新页面显示**'
- en: Let’s look more closely at the preceding code.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看前面的代码。
- en: 'When the DOM has loaded, you need to create a Socket.IO client and tell it
    to invoke a callback (`updateData`) whenever a `weather` event happens:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DOM 加载完成后，你需要创建一个 Socket.IO 客户端，并告诉它在发生 `weather` 事件时调用回调函数 (`updateData`)：
- en: '[PRE74]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|  |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Where’d io() come from?
  id: totrans-806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: io()函数是从哪里来的？
- en: The `io` function, for initializing a Socket.IO client, is made available globally
    via the inclusion of the /socket.io/socket.io.js script.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '`io` 函数，用于初始化 Socket.IO 客户端，通过包含 /socket.io/socket.io.js 脚本来全局提供。'
- en: '|  |'
  id: totrans-808
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `updateData` function takes the updated `data` object and updates the page’s
    DOM to include the new values, as the following listing shows.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateData` 函数接受更新的 `data` 对象，并更新页面的 DOM 以包含新值，如下面的列表所示。'
- en: Listing 8.22\. updateData() detail
  id: totrans-810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.22\. updateData() 详细信息
- en: '[PRE75]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'First, the HTML elements with IDs `temperature` and `pressure` are updated—their
    HTML content is set to the value of the temperature and pressure sensors, respectively:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新具有 IDs `temperature` 和 `pressure` 的 HTML 元素——它们的 HTML 内容分别设置为温度和压力传感器的值：
- en: '[PRE76]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The sensor values are formatted such that two digits display after the decimal.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器值被格式化为小数点后显示两位数字。
- en: 'Then, as a visual cue, an additional class—`connected`—is added to the `#temperature`
    and `#pressure` elements (the CSS styles this as green text) to show that data
    is being received over the socket:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，作为一个视觉提示，额外的类`connected`被添加到`#temperature`和`#pressure`元素上（CSS将其设置为绿色文本），以显示数据正在通过套接字接收：
- en: '[PRE77]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '|  |'
  id: totrans-817
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DOM-manipulation code, jQuery style**'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM操作代码，jQuery风格**'
- en: To avoid excessive client dependencies, the JavaScript in index.html uses the
    browser DOM API directly; for example, `document.querySelectorAll()`. But lots
    of people are more familiar with jQuery-style syntax, which makes DOM traversal
    and manipulation more readable and intuitive.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过度依赖客户端，index.html中的JavaScript直接使用浏览器DOM API；例如，`document.querySelectorAll()`。但很多人更熟悉jQuery风格的语法，这使得DOM遍历和操作更易于阅读和直观。
- en: You can use jQuery if you like. To do this, you’d need to add a `<script>` tag
    to include it. Using their CDN-hosted code ([https://code.jquery.com/](https://code.jquery.com/))
    is recommended so you don’t have to add another file to the app directory.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，可以使用jQuery。为此，你需要添加一个`<script>`标签来包含它。使用他们CDN托管的代码([https://code.jquery.com/](https://code.jquery.com/))是推荐的，这样你就不必将另一个文件添加到应用目录中。
- en: 'The updated index.html script would then look something like this:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的index.html脚本可能看起来像这样：
- en: '[PRE78]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|  |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'It’s ready! You can position the Tessel, plugged into wall power, anywhere
    within your wireless network’s range. Then, once again, from your computer, enter
    this command:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了！你可以将连接到墙式电源的Tessel放置在无线网络范围内的任何地方。然后，再次从你的电脑上，输入这个命令：
- en: '[PRE79]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Open a browser to the URL indicated in the console ([figure 8.12](#ch08fig12)).
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器到控制台指示的URL([图8.12](#ch08fig12))。
- en: Figure 8.12\. The temperature and pressure values update in real time in your
    browser, via websockets.
  id: totrans-827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.12. 温度和压力值在浏览器中实时更新，通过websockets。
- en: '![](08fig12_alt.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![08fig12_alt.jpg]'
- en: t2 push deployment for full independence
  id: totrans-829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: t2 push deployment for full independence
- en: 'Remember, when deploying a project with `t2 run`, the Tessel still has some
    dependence on your computer: the process only runs on the Tessel as long as it
    isn’t terminated from your computer. With `t2 push`, the Tessel can reach full
    autonomy.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用`t2 run`部署项目时，Tessel仍然对你的电脑有一些依赖：只要没有从你的电脑终止，该进程就会在Tessel上运行。使用`t2 push`，Tessel可以达到完全自主。
- en: Take note of your Tessel’s current IP address and web server port. If you need
    to be reminded, run `t2 run index.js` again and copy the logged IP address and
    port combination somewhere you can access. When deploying via `t2 push`, you won’t
    be able to see output from `console.log` anymore.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 记下你的Tessel当前的IP地址和Web服务器端口。如果你需要提醒，再次运行`t2 run index.js`并复制记录的IP地址和端口组合到你可以访问的地方。通过`t2
    push`部署时，你将无法再看到`console.log`的输出。
- en: 'Now, run this command:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行这个命令：
- en: '[PRE80]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You should see output like the following.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出。
- en: Listing 8.23\. t2 push output
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.23. t2 push输出
- en: '[PRE81]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Give the Tessel several seconds to finish spinning up the web server and get
    started, and then view the weather station web page (at the Tessel’s IP address,
    port 3000) in your browser.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 给Tessel几秒钟的时间来启动网络服务器并开始工作，然后在你的浏览器中查看气象站网页（在Tessel的IP地址，端口3000）。
- en: Even if your Tessel loses power, it will start running the weather station script
    once it regains power and boots up. The Tessel doesn’t need your computer anymore.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的Tessel失去电力，一旦恢复电力并启动，它将开始运行气象站脚本。Tessel不再需要你的电脑了。
- en: '|  |'
  id: totrans-839
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Make it stop
  id: totrans-840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 让它停止
- en: You can use `t2 erase` to make the Tessel stop running the weather station program.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`t2 erase`让Tessel停止运行气象站程序。
- en: '|  |'
  id: totrans-842
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.5\. Powering projects with batteries
  id: totrans-843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5. 使用电池为项目供电
- en: 'There’s one wire left: a wall connection that provides power for the Tessel
    and its circuit.'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下一根线：一个为Tessel及其电路提供电力的墙式连接。
- en: There are myriad options for powering projects, such as wall power, alkaline
    or rechargeable household batteries, many forms of lithium-ion batteries, or solar
    panels. The options can feel overwhelming. Let’s break it down a bit.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目供电有多种选择，如墙式电源、碱性或可充电家用电池、多种锂离子电池或太阳能板。这些选项可能会让人感到不知所措。让我们稍微分析一下。
- en: First, what exactly needs to be powered? For a project like the weather station,
    the Tessel itself (dev board, microcontroller, processor) needs to be powered,
    and the Tessel subsequently provides power at 3.3 V to the BMP180 breakout board.
    In that case, it’s natural to think of providing power to the dev board and assume
    the dev board will serve as a power source for the rest of the circuit and its
    components.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，究竟需要为哪些设备供电？对于像气象站这样的项目，Tessel本身（开发板、微控制器、处理器）需要供电，Tessel随后以3.3V的电压为BMP180扩展板供电。在这种情况下，自然地会想到为开发板供电，并假设开发板将作为整个电路及其组件的电源。
- en: 'That’s a fine concept when the project circuitry requires little in the way
    of power, but it’s different when projects contain motors or other current-hungry
    components. Back in [chapter 6](kindle_split_014.html#ch06), the circuitry for
    the rover robot contained two DC motors and required more current than the Arduino
    Uno pins could provide directly. That project included a secondary power source
    to drive the motors: a 9 V alkaline battery ([figure 8.13](#ch08fig13)).'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目电路对电源需求不大时，这是一个很好的概念，但当项目包含电机或其他电流消耗大的组件时，情况就不同了。在[第6章](kindle_split_014.html#ch06)中，漫游机器人的电路包含两个直流电机，所需的电流超过了Arduino
    Uno引脚可以直接提供的电流。那个项目包括一个辅助电源来驱动电机：一个9V碱性电池（[图8.13](#ch08fig13)）。
- en: 'Figure 8.13\. The dual-motors setup for the robot in [chapter 6](kindle_split_014.html#ch06)
    used a power source external to the Uno for powering the DC motors: a 9 V battery.'
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.13。在[第6章](kindle_split_014.html#ch06)中，用于机器人的双电机设置使用了外部电源为直流电机供电：一个9V电池。
- en: '![](08fig13_alt.jpg)'
  id: totrans-849
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig13_alt.jpg)'
- en: In any case, whatever you select to provide power for your project needs to
    power the whole project—sometimes all of the power will flow through the dev board,
    sometimes not, depending on what’s in the circuit.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，你选择的为项目提供电源的设备都需要为整个项目供电——有时所有电流都会流经开发板，有时则不会，这取决于电路中的内容。
- en: 'For your first foray into completely battery-powered freedom, we’ll use a *USB
    power bank*. Perhaps you already have one on hand: these little power packs are
    often used to provide extra juice for mobile phones and tablets on the go. They
    provide a steady 5 V current over USB and are easy to charge with USB wall chargers.
    They’re great as an extra battery for your mobile device, but they’re also great
    for powering projects that can run on 5 V power.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你第一次尝试完全使用电池供电的自由，我们将使用一个*USB移动电源*。也许你手头已经有一个：这些小巧的电源包通常用于为移动手机和平板电脑提供额外的电量。它们通过USB提供稳定的5V电流，并且可以用USB壁式充电器轻松充电。它们作为移动设备的备用电池非常棒，同时也非常适合为可以运行5V电源的项目供电。
- en: '|  |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Battery capacity**'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**电池容量**'
- en: The amount of “juice” in a given battery is measured in terms of current over
    time. A battery’s capacity is measured in *Amp hours* at its rated voltage, or,
    in the context of household batteries, *milliamp hours* (mAh). A 1.5 V battery
    with a capacity of 500 mAh should be able to provide, at 1.5 V, a steady current
    of 100 mA for 5 hours. Or a steady current of 10 mAh for 50 hours.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 给定电池中的“电量”是以电流随时间的变化来衡量的。电池的容量是以其额定电压下的*安时（Ah）*来衡量的，或者在家庭电池的背景下，是*毫安时（mAh）*。一个1.5V、容量为500mAh的电池应该能够在1.5V下提供100mA的稳定电流5小时。或者提供10mA的稳定电流50小时。
- en: 'Of course, it’s not quite that simple. A battery’s actual capacity varies based
    on a lot of variables: discharge rate (higher discharge rates result in lower
    total capacity), ambient temperature (batteries don’t like the cold), time elapsed
    since the battery was charged (batteries naturally and normally slowly discharge),
    the battery’s chemistry, and more.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，事情并没有那么简单。电池的实际容量受许多变量影响：放电率（较高的放电率会导致总容量降低）、环境温度（电池不喜欢寒冷）、电池充电后的时间（电池会自然且缓慢地放电）、电池的化学成分等等。
- en: Consumer 1.5 AA batteries can range in capacity from 400 to over 3000 mAh depending
    on their chemistry and other factors. That’s a big range!
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者1.5AA电池的容量可以从400mAh到3000mAh以上不等，这取决于它们的化学成分和其他因素。这是一个很大的范围！
- en: The beefiest of my current collection of USB power banks provides 8000 mAh (8
    Amp hours). On the opposite end, some of my smaller lithium polymer (LiPo) batteries
    are only a few hundred mAh.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前拥有的USB移动电源中最强大的一个提供8000mAh（8安时）。在另一端，我的一些小型锂聚合物（LiPo）电池只有几百mAh。
- en: The power needs of the Tessel (not a particularly low-power board) and motors
    call for a higher-capacity battery like that USB brick, whereas a project combining
    an Arduino Nano (a small and efficient Arduino board) and a low-power temperature
    sensor would do fine on a lower-capacity LiPo.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel（不是特别低功耗的板）和电机的功耗需要更高容量的电池，如USB砖块，而将Arduino Nano（一个小巧高效的Arduino板）和低功耗温度传感器结合在一起的项目可以在较低容量的LiPo上运行良好。
- en: '|  |'
  id: totrans-859
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.5.1\. A battery-powered robot with the Tessel
  id: totrans-860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1\. 使用Tessel的电池供电机器人
- en: '|  |'
  id: totrans-861
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What you’ll need
  id: totrans-862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你需要什么
- en: '![](note.jpg)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
  zh: '![注意](note.jpg)'
- en: 1 Tessel 2
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 Tessel 2
- en: 1 constructed roving robot and chassis from [chapter 6](kindle_split_014.html#ch06)
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 从[第6章](kindle_split_014.html#ch06)构建的漫游机器人底盘
- en: 1 USB “power bank” battery with a USB micro connection
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个带有USB微型连接的USB“电源银行”电池
- en: 3 female header pins *or* a length of solid-core wire (22-gauge solid-core is
    ideal) (optional)
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3个女性接插件引脚*或*一段实心导线（22号实心导线是理想的）（可选）
- en: Soldering gun and supplies
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊接枪和材料
- en: '|  |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: By making some minor alterations, the robot you built with the Arduino Uno in
    [chapter 6](kindle_split_014.html#ch06) can be set free (of wires). Won’t that
    feel more like a real robot?
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行一些小的修改，你可以在[第6章](kindle_split_014.html#ch06)中用Arduino Uno构建的机器人可以摆脱（线缆）。这不会感觉更像一个真正的机器人吗？
- en: 'To liberate the bot, you’ll need to do the following:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解放机器人，你需要做以下事情：
- en: Solder some connections to the Tessel to make a 5 V power source available to
    the motors (optional)
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Tessel上焊接一些连接，为电机提供一个5 V电源（可选）
- en: Replace the Uno in the circuit with a Tessel
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电路中的Uno替换为Tessel
- en: Initialize a project working directory, copy the rover code into the new project,
    and adjust pin numbers for the motor-driver pins
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个项目工作目录，将漫游机器人代码复制到新项目中，并调整电机驱动引脚的引脚号
- en: Powering the motors
  id: totrans-875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为电机供电
- en: In [chapter 6](kindle_split_014.html#ch06), the roving robot’s motors were powered
    with a 9 V battery. The Tessel’s 3.3 V operating voltage is too low to power the
    motors—and besides, the current restrictions on the pins would be problematic.
    But Tessel boards provide access to 5 V power with enough current to get the job
    done ([figure 8.14](#ch08fig14)). The trick is accessing it—you’ll need to do
    a bit of soldering.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_014.html#ch06)中，漫游机器人的电机由9 V电池供电。Tessel的3.3 V工作电压太低，无法为电机供电——而且，引脚上的电流限制也会造成问题。但Tessel板提供了访问5
    V电源的途径，有足够的电流来完成工作（[图8.14](#ch08fig14)）。关键是访问它——你需要做一些焊接工作。
- en: Figure 8.14\. The Tessel can provide 5 V power from the power pins highlighted
    here.
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.14\. Tessel可以从这里突出显示的电源引脚提供5 V电源。
- en: '![](08fig14.jpg)'
  id: totrans-878
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig14.jpg)'
- en: The most flexible option is to solder *female headers* to the three power pins
    on the Tessel, resulting in reusable “sockets” you can plug jumper cables into
    (8.15).
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 最灵活的选项是将*女性接插件*焊接在Tessel上的三个电源引脚上，从而产生可重复使用的“插座”，你可以将跳线电缆插入其中（8.15）。
- en: 'Soldering female header pins ([figure 8.16](#ch08fig16)) is a little different
    than soldering on male breakaway headers: you turn the board upside down and solder
    the pins on the bottom. Use a piece of tape to keep the pins in place on the top
    so they don’t fall off the board when you invert it.'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 焊接女性接插件（[图8.16](#ch08fig16)）与焊接男性断开式接插件略有不同：你将板翻转过来，并在底部焊接引脚。使用一块胶带将引脚固定在顶部，以防你翻转板时掉落。
- en: Figure 8.15\. Soldering female header pins to the 5 V power pins provides handy
    reusable slots for jumper wires.
  id: totrans-881
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.15\. 将女性接插件焊接在5 V电源引脚上提供了方便的可重复使用的插槽，用于跳线。
- en: '![](08fig15.jpg)'
  id: totrans-882
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig15.jpg)'
- en: Figure 8.16\. To solder female headers to the board, flip the board over and
    solder on the bottom. You’ll need a piece of tape to hold the pins in place from
    the top while you solder.
  id: totrans-883
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.16\. 要将女性接插件焊接在板上，将板翻转并焊接在底部。你需要一块胶带将引脚固定在顶部，以便你在焊接时保持位置。
- en: '![](08fig16_alt.jpg)'
  id: totrans-884
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig16_alt.jpg)'
- en: Alternatively, you could solder lengths of wire to the +5 V and GND pins ([figure
    8.17](#ch08fig17)). However, this results in permanently attached wires.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以将导线焊接在+5 V和GND引脚上（[图8.17](#ch08fig17)）。然而，这会导致永久性连接的导线。
- en: Figure 8.17\. Soldering solid-core wires to the power pins is also an option.
  id: totrans-886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.17\. 将实心导线焊接在电源引脚上也是一种选择。
- en: '![](08fig17.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig17.jpg)'
- en: 'If this seems like too much hassle, you could opt to use two power supplies
    for this project: the existing 9 V battery for the motor power rail, and the USB
    battery to power the Tessel—a wiring diagram for each is provided in the next
    section.'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来太麻烦，你可以选择为这个项目使用两个电源：现有的9 V电池用于电机电源轨，USB电池为Tessel供电——下一节提供了每个的接线图。
- en: '|  |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Don’t power the motors from 3.3 V
  id: totrans-890
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不要从3.3 V电源给电机供电
- en: The Tessel’s 3.3 V power pins provide neither the voltage nor the current the
    motors require. Don’t attempt to power the motors directly from the Tessel’s 3.3
    V pins.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel的3.3 V电源引脚既不能提供电机所需的电压也不能提供电流。不要尝试直接从Tessel的3.3 V引脚给电机供电。
- en: '|  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: (Re-)building the robot circuit
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: （重新）构建机器人电路
- en: Take the top off of the Uno-powered robot chassis ([figure 8.18](#ch08fig18))
    so that you can access the inside, and alter the circuit to use the Tessel instead
    of the Uno. If you soldered connections to the Tessel’s 5 V power, build the circuit
    as shown in [figure 8.19](#ch08fig19). If you opted to continue using the 9 V
    battery, wire the circuit as shown in [figure 8.20](#ch08fig20).
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 取下由Uno供电的机器人底盘的顶部（[图8.18](#ch08fig18)），以便可以访问内部，并将电路更改为使用Tessel而不是Uno。如果你已经将连接焊接到Tessel的5
    V电源，则按照[图8.19](#ch08fig19)所示构建电路。如果你选择继续使用9 V电池，则按照[图8.20](#ch08fig20)所示布线电路。
- en: Figure 8.18\. By replacing the Uno in [chapter 6](kindle_split_014.html#ch06)’s
    roving bot with a Tessel, making a couple of wiring adjustments, and plugging
    in a USB battery to the Tessel, you can create a wires-free roving bot.
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.18。通过将[第6章](kindle_split_014.html#ch06)的漫游机器人中的Uno替换为Tessel，做一些布线调整，并将USB电池插入Tessel，你可以创建一个无需接线的漫游机器人。
- en: '![](08fig18_alt.jpg)'
  id: totrans-896
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig18_alt.jpg)'
- en: Figure 8.19\. The rover robot circuit using the Tessel and the Tessel’s 5 V
    power. The Tessel’s 5 V power needs to power both power rails—make sure you connect
    the positive columns of the power rails together using an additional (red) jumper
    wire (near the top).
  id: totrans-897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.19。使用Tessel及其5 V电源的漫游机器人电路。Tessel的5 V电源需要为两个电源轨供电——确保使用额外的（红色）跳线（靠近顶部）将电源轨的正列连接在一起。
- en: '![](08fig19_alt.jpg)'
  id: totrans-898
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig19_alt.jpg)'
- en: 'Figure 8.20\. The rover circuit using two power sources: the Tessel’s 3.3 V
    and a 9 V battery for the motors.'
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.20。使用两个电源的漫游电路：Tessel的3.3 V和9 V电池为电机供电。
- en: '![](08fig20_alt.jpg)'
  id: totrans-900
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig20_alt.jpg)'
- en: Updating the rover code
  id: totrans-901
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新漫游代码
- en: 'Create a working directory and install some dependencies. In a terminal (making
    sure you’re not inside the t2-weather or any other preexisting project directory),
    enter these commands:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个工作目录并安装一些依赖项。在终端中（确保你不在t2-weather或任何其他现有项目目录内），输入以下命令：
- en: '[PRE82]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `keypress` package is used to capture keyboard input, so the bot can be
    steered with the arrow keys.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '`keypress`包用于捕获键盘输入，因此可以使用箭头键控制机器人。'
- en: 'Copy the two robot scripts into the t2-rover directory—index.js and Rover.js
    (or flip back to [chapter 6](kindle_split_014.html#ch06) to find the source).
    Open the index.js file in a text editor and make the following changes:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个机器人脚本复制到t2-rover目录中——index.js和Rover.js（或翻回[第6章](kindle_split_014.html#ch06)以找到源代码）。在文本编辑器中打开index.js文件并做出以下更改：
- en: 'Add a `require` for `tessel-io` near the top of the file:'
  id: totrans-906
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加`require`对`tessel-io`：
- en: '[PRE83]'
  id: totrans-907
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Update the `board` instantiation to specify the I/O plugin:'
  id: totrans-908
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`board`实例化以指定I/O插件：
- en: '[PRE84]'
  id: totrans-909
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Update the motor pins:'
  id: totrans-910
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新电机引脚：
- en: '[PRE85]'
  id: totrans-911
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'That’s it! Your bot is ready to go, wires-free. Nestle the Tessel board into
    place on the roving bot where the Uno was previously. Plug in the USB power supply
    (and 9 V battery, if you’re using one) and use tape or Velcro to secure it to
    the robot chassis. Make sure the Tessel is fully booted and visible over the LAN
    (use `t2 list` to make sure). Then run this command:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你的机器人已经准备就绪，无需接线。将Tessel板放置在之前放置Uno的漫游机器人上。插入USB电源（如果你使用的是9 V电池，也请插入）并使用胶带或魔术贴将其固定在机器人底盘上。确保Tessel已完全启动并在局域网中可见（使用`t2
    list`确保）。然后运行以下命令：
- en: '[PRE86]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You should be able to control your robot from your computer using the arrow
    keys, and the rover should be able to roam much more widely than when it was tethered
    with a USB cable.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够使用箭头键从你的电脑上控制你的机器人，并且漫游机器人应该能够比用USB线连接时走得更远。
- en: Through the experiments in this chapter, you’ve seen how you can start setting
    your projects free from physical tethers. You’re past the basics now. It’s time
    to give you more tools to invent your own experiments and create things that haven’t
    been created before.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的实验，你看到了如何开始让你的项目摆脱物理束缚。现在你已经超越了基础。是时候给你更多的工具来发明你自己的实验，创造以前从未创造过的事物。
- en: '|  |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Voltages and the motor driver**'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '**电压和电机驱动器**'
- en: The Arduino Uno-based rover used 5 V logic levels, and the motors were provided
    with 9 V of power from a battery. Remember, there are two power sources here—one
    for the motor driver’s logic and one to power the motors themselves.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Arduino Uno的机器人使用了5V逻辑电平，电机由电池提供9V的电力。记住，这里有两个电源——一个用于电机驱动器的逻辑，另一个用于为电机本身供电。
- en: In the Tessel-based setup, the motor driver is connected to 3.3 V logic levels
    and the motors only get 5 V (unless you’re using a 9 V battery). The motor driver
    works on 3.3 V logic because 3.3 V HIGH is enough to register as a logical HIGH
    for the 5 V motor driver device—oftentimes you can use 5 V logic with 3.3 V because
    the range of valid HIGH voltages for a 5 V device usually includes 3.3 V.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Tessel的设置中，电机驱动器连接到3.3V逻辑电平，电机只获得5V的电压（除非你使用9V电池）。电机驱动器在3.3V逻辑电平上工作，因为3.3V的高电平足以在5V电机驱动器设备上注册为逻辑高电平——很多时候你可以使用5V逻辑电平与3.3V电平一起使用，因为5V设备的有效高电压范围通常包括3.3V。
- en: '![](0253fig01_alt.jpg)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![图片](0253fig01_alt.jpg)'
- en: 3.3 V logic is sometimes compatible with components that have 5 V logic levels.
    The voltage range that’s interpreted as HIGH for 5 V logic-level devices often
    encompasses 3.3 V. That is, a +3.3 V signal (HIGH from the 3.3 V device) will
    be interpreted as HIGH on the 5 V device because it falls within its HIGH voltage
    range.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3V逻辑有时与具有5V逻辑电平的组件兼容。5V逻辑电平设备解释为高电平的电压范围通常包括3.3V。也就是说，一个+3.3V的信号（来自3.3V设备的逻辑高电平）将在5V设备上被解释为高电平，因为它在其高电压范围内。
- en: You’ll notice that the motors aren’t as zippy with 5 V as on 9 V. That’s to
    be expected. But they’re still good enough to rove.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在5V电压下，电机不如在9V电压下那样灵活。这是可以预料的。但它们仍然足够好，可以四处移动。
- en: '|  |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'There are two main reasons that projects require wired connections: data and
    communication exchange, and power.'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目需要有线连接的两个主要原因：数据和通信交换以及电力。
- en: Using Johnny-Five with Arduino Uno is an example of a host-client setup. A tether
    must exist between a host computer and the Uno at all times. Some constrained
    hardware like the Photon Particle can communicate wirelessly with Johnny-Five,
    but a host computer is still required to do the thinking.
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Johnny-Five与Arduino Uno结合使用是主机-客户端设置的例子。主机计算机和Uno之间必须始终存在连接。一些受限制的硬件，如Photon
    Particle，可以无线与Johnny-Five通信，但仍需要一个主机计算机来进行思考。
- en: Tessel 2 is an open source platform that runs embedded Linux and Node.js directly
    on the board itself. The Tessel can execute code independently of a host computer.
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tessel 2是一个开源平台，它直接在板上运行嵌入式Linux和Node.js。Tessel可以在没有主机计算机的情况下独立执行代码。
- en: The Tessel 2 operates at 3.3 V. It has two ports of 8 pins each and supports
    different features on different pins.
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tessel 2在3.3V电压下运行。它有两个8针端口，并支持不同引脚上的不同功能。
- en: For the most part, the only adaptations required to write Johnny-Five scripts
    for the Tessel versus the Uno (or to port between the platforms) is to use the
    `tessel-io` I/O plugin for Johnny-Five and change the pin numbering for components.
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数项目来说，编写Johnny-Five脚本所需的适应主要是针对Tessel与Uno（或在不同平台之间移植）使用`tessel-io` I/O插件，并更改组件的引脚编号。
- en: Because the Tessel can run Node.js natively and supports npm packages, it’s
    possible to create sophisticated, high-level applications and execute them directly
    on the Tessel.
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Tessel可以原生运行Node.js并支持npm包，因此可以在Tessel上创建复杂的高级应用程序并直接执行它们。
- en: There are many options for powering projects. So far you’ve used wall power,
    alkaline batteries, and a USB power bank. USB batteries are handy because they
    have multiple applications, including charging up mobile devices, and they’re
    easy to use.
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目供电有许多选择。到目前为止，你已经使用了墙上的电源、碱性电池和USB电源宝。USB电池很方便，因为它们有多个用途，包括为移动设备充电，而且使用起来也很简单。
- en: Chapter 9\. Building your own thing
  id: totrans-932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 创建你自己的东西
- en: '*This chapter covers*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The endless possibilities of creating your own mashups using preexisting, low-voltage
    consumer electronics
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有的、低电压的消费电子产品创建自己的混合体的无限可能性
- en: 'Steps for creating your own inventions: prototyping, iterating, and debugging'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的发明步骤：原型设计、迭代和调试
- en: Isolating circuits from each other using photocouplers
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光电耦合器隔离电路
- en: Analyzing datasheets and other software and firmware implementations to create
    your own software support for components
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析数据表和其他软件和固件实现，为组件创建自己的软件支持
- en: Encapsulating component behavior with custom Johnny-Five plugins and the J5
    Collection mixin
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义Johnny-Five插件和J5 Collection混入封装组件行为
- en: 'Wrangling sophisticated sensors: processing complex data and managing configuration'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理复杂的传感器：处理复杂数据和管理配置
- en: '|  |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](tool.jpg)'
  id: totrans-941
  prefs: []
  type: TYPE_IMG
  zh: '![](tool.jpg)'
- en: '**For this chapter, you’ll need the following:**'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于本章，你需要以下内容：**'
- en: 1 Tessel 2
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Tessel 2
- en: 1 set of remote-controlled wall outlets
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1套遥控插座
- en: 1 SparkFun 3.3 V APDS-9960 breakout board
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个SparkFun 3.3 V APDS-9960分线板
- en: Soldering iron and supplies
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊接铁和配件
- en: Push buttons and/or LEDs for debugging circuits (optional)
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于调试电路的按钮和/或LED（可选）
- en: 6 photocouplers (opto-isolators), such as the 4N25
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个光电耦合器（光隔离器），例如4N25
- en: 6 100 V resistors
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个100 V电阻
- en: 1 full-size breadboard
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个全尺寸面包板
- en: Jumper wires
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳接线
- en: 1 multimeter
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个万用表
- en: 0.1″ male breakaway headers
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.1″公头断开式引脚
- en: 22AWG solid-core wire (optional, for soldering to remote control circuitry)
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 22AWG实心线（可选，用于焊接遥控电路）
- en: Hardware toolkit for [chapter 9](#ch09) (optional 22AWG solid-core wire not
    shown)
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件工具包（第9章）（可选，未显示22AWG实心线）
- en: '![](0254fig01_alt.jpg)'
  id: totrans-956
  prefs: []
  type: TYPE_IMG
  zh: '![](0254fig01_alt.jpg)'
- en: '|  |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Already you’ve moved well beyond the light-up-an-LED world, and you might be
    chafing to start building things with electronics that haven’t been built before,
    to chart your own course. Let’s take a tour through the arc of an entire example
    project—remixing a remote-controlled set of outlet switches—from inception, through
    prototyping, troubleshooting, iteration, and improvement. Instead of relying upon
    preexisting schematics, instructions, and software, you’ll forge your own way
    through some parts of the project.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经远远超越了点亮LED的世界，可能正渴望开始构建以前未曾构建过的电子设备，规划自己的路线。让我们通过一个完整示例项目的全过程进行一次巡礼——重混一个遥控插座开关——从构思、原型设计、故障排除、迭代和改进。你将不再依赖于现有的电路图、说明书和软件，而是将在项目的某些部分开辟自己的道路。
- en: 'The projects in this chapter will expose you to more software complexity than
    earlier experiments. Depending on your level of JavaScript expertise, this might
    hit a sweet spot, or it might feel like more than you want to bite off right now.
    If it’s too much, that’s just fine: it’s always valid to put together projects
    from preexisting component support.'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的项目将让你接触到比早期实验更多的软件复杂性。根据你的JavaScript熟练程度，这可能会达到一个甜蜜点，或者可能会觉得超出了你现在的承受范围。如果太多，那也没关系：总是可以从现有的组件支持中组合项目。
- en: Real-world projects have ups and downs. It takes a touch of bravery to jump
    into more elaborate projects with unknowns. Making it work in the end is sweetly
    rewarding, and I hope you’ll learn to relish the plunge.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的项目有起有落。需要一点勇气才能跳入更复杂的项目，面对未知。最终使其工作是非常甜蜜的回报，我希望你能学会享受这种冒险。
- en: 9.1\. Hacking consumer electronics
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 消费电子产品黑客技术
- en: 'One of the most electrifying moments (if you’ll pardon the wretched pun) during
    the growth of my electronics expertise was when I realized that I had enough basic
    know-how to mess around with existing consumer electronics: to make them better,
    or to invent creative mash-ups—scratching whatever inventor’s itch might arise.
    Why design, buy parts for, and laboriously build a circuit if you’ve got an unused
    electronic trinket lying around the house that already performs the same function?'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电子专业知识增长过程中，最令人兴奋的时刻之一（如果你能原谅这个糟糕的双关语）是我意识到自己拥有足够的基本知识来摆弄现有的消费电子产品：使它们变得更好，或者发明创造性的混合体——挠一挠可能出现的任何发明家的痒处。如果你家里有一个闲置的电子小玩意儿已经执行了相同的功能，为什么还要设计、购买零件并费力地构建电路呢？
- en: 9.1.1\. Modifying RF-controlled outlet switches
  id: totrans-963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 修改射频控制的插座开关
- en: Wandering around a room to turn on (or off) several individual lamps can be
    tiresome, especially if their switches are inconveniently located. Wirelessly
    controlled plug-in switches for electrical outlets can be handy. For about $20
    you can buy a set of three with a remote control ([figure 9.1](#ch09fig01)).
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在房间里四处走动以打开（或关闭）几个单独的灯具可能会很麻烦，尤其是如果它们的开关位置不方便。无线控制的插座插头开关可以很方便。大约20美元就可以买到一套带有遥控器的三个（[图9.1](#ch09fig01)）。
- en: Figure 9.1\. Sets of remote-controlled outlets are inexpensive and widely available
    at hardware stores and home centers. The remote control unit is powered by a low-voltage
    battery.
  id: totrans-965
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 在五金店和家居中心，遥控插座套装既便宜又容易买到。遥控单元由低压电池供电。
- en: '![](09fig01.jpg)'
  id: totrans-966
  prefs: []
  type: TYPE_IMG
  zh: '![09fig01.jpg]'
- en: With the battery-operated remote in hand, you can turn each of the plugged-in
    switches (and, by turn, the lamps plugged into them) on or off, individually.
    This is a step up from having to make a physical lap around the room. But there
    are some things which could be improved upon.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 拿着电池供电的遥控器，你可以单独打开或关闭每个已插入的开关（以及它们插入的灯）。这比在房间里物理地绕一圈要好。但还有一些事情可以改进。
- en: It’s not possible—at least with the model I have—to turn all of the switches
    (and thus their lights) on or off at the same time. Each has to be switched individually.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 至少用我有的这个型号，不可能同时打开或关闭所有开关（以及它们的灯）。每个都必须单独切换。
- en: More interestingly, wouldn’t it be nice to be able to trigger the lights in
    other, possibly automated, ways? Maybe you want the lights to turn on when it
    gets dark, or from another room in your home, or using some other form of input
    that you’ve dreamed up.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，如果能够以其他方式，比如自动化的方式触发灯光，那岂不是很好？也许你希望灯光在变暗时打开，或者从家里的另一个房间，或者使用你梦想中的其他形式的输入。
- en: Good news! The circuitry inside these little remote controls is both low in
    complexity and in oomph—low voltage, low current. They’re easy to understand and
    probably won’t zap you terribly if you mess something up. Let’s get hacking. Using
    the guts of the remote control, you’ll cobble together your own personalized device.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！这些小遥控器内部的电路既简单又强大——低压，低电流。它们很容易理解，如果你弄错了什么，可能也不会对你造成太大的伤害。让我们开始破解。使用遥控器的内部组件，你可以组装出自己的个性化设备。
- en: '|  |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Always be careful!**'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '**务必小心！**'
- en: Although the circuitry in many low-voltage, battery-powered consumer electronics
    is benign, every device is different, and you need to exercise common sense.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多低压、电池供电的消费电子产品电路是良性的，但每个设备都不同，你需要运用常识。
- en: Unless you’re a qualified electrician, *don’t* open up or alter the outlet components
    of the remote-control system—keep your hackery confined to the remote-control
    unit. The outlets plug into the wall, and I make it a policy never to get near
    mains power in my electronics explorations—this keeps me out of the hospital.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是合格的电工，*不要*打开或更改遥控器系统的插座组件——将你的破解限制在遥控器单元上。插座插入墙壁，我在电子探索中有一个政策，那就是永远不接触主电源——这让我远离了医院。
- en: Remove batteries from electronics when you’re working with them. And always,
    always give capacitors a wide berth. They can hold a charge for a long time, even
    when not connected to power.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理电子设备时，请取出电池。并且始终，始终远离电容器。即使没有连接到电源，它们也能保持电荷很长时间。
- en: '|  |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Disassembling the remote control unit
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 拆卸遥控器单元
- en: 'You’ll need to dismantle the remote control assembly. Your remote control unit
    may be slightly different, but to disassemble the remote control that I have,
    I removed two small screws. Inside of the case, I found just a few things ([figure
    9.2](#ch09fig02)):'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要拆卸遥控器组件。你的遥控器单元可能略有不同，但为了拆卸我拥有的遥控器，我取下了两个小螺丝。在盒子里，我只找到了几样东西（[图9.2](#ch09fig02)）：
- en: A 3 V coin-cell battery (lithium CR2032 in this remote)
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 V的硬币电池（在这个遥控器中是锂CR2032）
- en: The physical, pressable buttons, which are all attached together on one flexible
    bed of plastic
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以按压的物理按钮，它们都连接在一个柔软的塑料床上
- en: A small circuit board containing the contact pads for the buttons, battery contacts,
    and a status LED (among other things, like the radio transmitter)
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含按钮触点、电池触点和状态LED（以及其他东西，如无线电发射器）的小电路板
- en: A telescoping antenna, attached to the circuit board
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可伸缩的天线，连接到电路板上
- en: Figure 9.2\. The deconstructed remote control
  id: totrans-983
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 拆卸后的遥控器
- en: '![](09fig02_alt.jpg)'
  id: totrans-984
  prefs: []
  type: TYPE_IMG
  zh: '![09fig02_alt.jpg]'
- en: Each button has a corresponding pad beneath it on the circuit board, which looks
    like a zig-zag pattern. When the overlying button is pressed, it makes a connection
    between the two different sides of the zig-zag, completing the circuit. You can
    connect the circuit yourself, acting like a single pressed button, by using a
    jumper wire and touching one end to each side of the zig-zag ([figure 9.3](#ch09fig03)).
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮在电路板上都对应一个垫片，其形状像锯齿状。当上面的按钮被按下时，它会在锯齿状的两边之间建立连接，完成电路。你可以通过使用跳线并触摸锯齿状的一端到两边来自己连接电路，就像一个单独按下的按钮一样（[图9.3](#ch09fig03)）。
- en: Figure 9.3\. When a button is pressed, it makes contact with both sides of the
    zig-zag contacts underneath it. You can reproduce this effect by connecting the
    two sides with a jumper wire.
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 当按钮被按下时，它会与下面的锯齿状触点的两边接触。你可以通过用跳线连接两边来重现这种效果。
- en: '![](09fig03.jpg)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03.jpg)'
- en: Adding onto the remote’s circuitry
  id: totrans-988
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 增加遥控电路
- en: One side of the zig-zag is connected to ground. You need to determine which
    side that is so that you can wire up your own “buttons” correctly (that is, not
    backwards). The best way to do this is with a multimeter, but if you don’t want
    to purchase a multimeter right now, you can try touching the LED’s leads to each
    side of the button contacts and see when it lights up—whichever side the cathode
    of the LED is touching at that point is the ground side ([figure 9.4](#ch09fig04)).
    Keep in mind that you run the risk of sacrificing the LED if it ends up getting
    too much current or balks at being connected backward.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 锯齿状的一侧连接到地。你需要确定哪一侧是那一侧，以便你可以正确地连接你自己的“按钮”（也就是说，不是反的）。最好的方法是使用万用表，但如果你现在不想购买万用表，你可以尝试将LED的引脚触摸到按钮触点的每一侧，看看它何时亮起——在那个时刻，LED的阴极接触的那一侧就是接地侧（[图9.4](#ch09fig04)）。记住，如果你不小心让LED流过太多电流或反向连接，你可能会损坏LED。
- en: Figure 9.4\. No multimeter? You may be able to use an LED to figure out which
    side of the button contacts is the ground side. An LED is a diode—it will only
    allow current to flow if it’s aligned correctly in the circuit. When it lights
    up, that means its cathode is on the ground side of the button.
  id: totrans-990
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. 没有万用表？你可能可以使用LED来确定按钮触点的哪一侧是接地侧。LED是一种二极管——只有当它在电路中正确对齐时才会允许电流流动。当它亮起时，这意味着它的阴极位于按钮的接地侧。
- en: '![](09fig04.jpg)'
  id: totrans-991
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04.jpg)'
- en: '|  |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mastering multimeters**'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '**掌握万用表**'
- en: A multimeter, which can measure voltage, current, and resistance, is an essential
    tool for an electronic-tinkerer’s toolbox. They’re inexpensive—tolerable hobby-quality
    ones can be had for less than $20.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 万用表，可以测量电压、电流和电阻，是电子爱好者工具箱中的必备工具。它们价格低廉——可承受的业余品质的万用表价格低于20美元。
- en: '![](0258fig01_alt.jpg)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
  zh: '![](0258fig01_alt.jpg)'
- en: A multimeter allows you to measure resistance, current, and voltage.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 万用表允许你测量电阻、电流和电压。
- en: In our current experiment, you can determine which side of the button contact
    pads are connected to ground by looking at the difference in voltage potential
    between the two sides of the zig-zag. To do this, set the multimeter to a DC voltage
    setting. I chose 20 V—the device should operate around 3 V based on its battery.
    The 20 V setting can display voltage readings up to 20 V; the device’s voltage
    is just a tad too high to use my 2 V setting.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的实验中，你可以通过观察锯齿状两边的电压电位差来确定按钮接触垫片的哪一侧连接到地。为此，将万用表设置为直流电压设置。我选择了20 V——根据其电池，设备应在3
    V左右运行。20 V设置可以显示高达20 V的电压读数；设备的电压略高于我的2 V设置，无法使用。
- en: '![](0259fig01.jpg)'
  id: totrans-998
  prefs: []
  type: TYPE_IMG
  zh: '![](0259fig01.jpg)'
- en: With the multimeter set to an appropriate DC voltage setting, the reading will
    be positive when the ground probe is on the ground side of the button contacts.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 将万用表设置为适当的直流电压设置时，当接地探针位于按钮触点的接地侧时，读数将是正数。
- en: When you touch the multimeter’s probes to each side of the button contacts,
    you should see a voltage reading on the device. If the number is negative, swap
    the probes. Once you see a positive reading—mine was about 2.5 V—you’ve found
    the positive side (red probe connection) and the negative side (black probe connection).
    Take note of these for each button connection.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将万用表的探针接触到按钮触点的每一侧时，你应该在设备上看到电压读数。如果数字是负数，交换探针。一旦你看到正数读数——我的大约是2.5 V——你就找到了正极（红色探针连接）和负极（黑色探针连接）。为每个按钮连接做笔记。
- en: 'The controls can look intimidating at first, but multimeters are a great friend
    to have for sanity checking and debugging circuits. SparkFun’s “How to Use a Multimeter”
    tutorial is a good one: [http://mng.bz/9f03](http://mng.bz/9f03).'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器一开始可能看起来令人畏惧，但万用表是检查电路和调试电路的好帮手。SparkFun的“如何使用万用表”教程是一个很好的教程：[http://mng.bz/9f03](http://mng.bz/9f03)。
- en: '|  |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The next step may require some ingenuity depending on the specifics of your
    device’s circuit board: you need to attach wires to each side of the button zig-zags
    (two wires per button). Subsequently you’ll be able to turn remote switches on
    and off by controlling—making and breaking—connections between these wires.'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步可能需要一些独创性，具体取决于你设备电路板的细节：你需要将电线连接到每个按钮的Z字形两侧（每个按钮两根电线）。随后，你将能够通过控制这些电线之间的连接和断开来开启和关闭遥控开关。
- en: If you’re lucky, you can solder wires directly to the button contact pads ([figure
    9.5](#ch09fig05)). In my case, the remote control’s *printed circuit board* (PCB)—a
    board manufactured specifically for this product with connections *silkscreened*
    onto it and *traces* connecting different elements—made this challenging. Although
    the button contacts were electrically conductive, solder would not adhere to them.
    Try as I might, all I achieved was globbing solder onto my wires and making a
    mess. Securing the wires to the pads using electrical tape was frustrating and
    finicky and kept falling apart on me.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很幸运，可以直接将电线焊接在按钮的接触垫上（[图9.5](#ch09fig05)）。在我的情况下，遥控器的*印刷电路板*（PCB）——一块专门为该产品制造的板，上面有*丝网印刷*的连接和连接不同元件的*走线*——这使得任务变得具有挑战性。尽管按钮接触是导电的，但焊锡不会粘附在其上。尽管我尽力了，但我所取得的成果只是在电线上涂抹焊锡，弄脏了它们。使用电工胶带将电线固定在垫子上既令人沮丧又麻烦，而且总是从我手中脱落。
- en: Figure 9.5\. An ideal setup would be to solder wires directly to each side of
    each button contact pad.
  id: totrans-1005
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. 理想的情况是将电线直接焊接在每个按钮接触垫的两侧。
- en: '![](09fig05_alt.jpg)'
  id: totrans-1006
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig05_alt.jpg)'
- en: Finally, poking around using my multimeter, I was able to find holes on the
    circuit board that corresponded to button contacts. Those holes still didn’t hold
    solder, but they served as anchor points through which I could stick wires into
    an underlying breadboard ([figure 9.6](#ch09fig06)).
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过使用我的万用表，我找到了电路板上的孔，这些孔对应于按钮接触点。这些孔仍然不能焊接焊锡，但它们作为锚点，我可以将电线插入下面的面包板中（[图9.6](#ch09fig06)）。
- en: Figure 9.6\. My home-brew wiring solution, taking advantage of the structure
    of the particular circuit board
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. 我自制的布线解决方案，利用了特定电路板的结构
- en: '![](09fig06_alt.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig06_alt.jpg)'
- en: It turned out that each button on the circuit board had its own separate connection
    to ground (blue wires—top six in [figure 9.6](#ch09fig06)). But all of the buttons
    were connected via traces to a single shared positive power source (yellow wire—bottom
    in [figure 9.6](#ch09fig06)). To activate any one button, it was necessary to
    complete the circuit by connecting the button’s specific ground connection to
    the shared positive source.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，电路板上的每个按钮都有自己的独立接地连接（蓝色电线——[图9.6](#ch09fig06)中的顶部六根）。但所有按钮都通过走线连接到单个共享的正电源（黄色电线——[图9.6](#ch09fig06)中的底部）。要激活任何一个按钮，必须通过将按钮的特定接地连接连接到共享的正电源来完成电路。
- en: '|  |'
  id: totrans-1011
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Learning to have patience when inventing**'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习在发明时保持耐心**'
- en: When you’re blazing new trails and inventing your own things, chances are you’ll
    have at least one point in each project where things don’t go as expected (probably
    more, to be honest). It can be a letdown. Whether it’s a problem soldering a wire
    to a connection or a component that doesn’t fit into a breadboard, you’ll need
    to be resourceful and thoughtful to get through it.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开辟新道路并发明自己的东西时，每个项目中至少有一个点事情不会按预期进行（说实话，可能更多）。这可能是一种失望。无论是焊接电线到连接点的问题，还是无法插入面包板的组件，你都需要富有创造力和思考才能克服它。
- en: Try not to rush or get flustered—easier advised than done, of course! It’s all
    part of the experience. Try to use the right tool for the job, even if that means
    putting your project aside for a few days while you wait for the right online-ordered
    tool or part to arrive in the mail. Even if you do have the necessary materials
    on hand, sometimes it’s a good idea to take a breather.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要急躁或慌乱——当然，这比听起来容易！这都是经验的一部分。尽量使用合适的工具来完成工作，即使这意味着将你的项目放在一边几天，等待你在线订购的工具或部件通过邮寄到达。即使你手头有必要的材料，有时休息一下也是一个好主意。
- en: 'It does get better! As you go on, you’ll learn to foresee certain gotchas.
    You’ll also be building your toolset, so you’ll have more options to fall back
    on when you need to fix a glitch or troubleshoot. And you’ll learn how long it
    really takes to build a project from scratch: it can take longer than you’d think!'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 这还只是开始！随着你继续学习，你会学会预见某些问题。你也会构建你的工具集，所以当你需要修复故障或进行故障排除时，你将有更多的选择。你还将学会从头开始构建项目真正需要多长时间：这可能会比你想象的要长！
- en: '|  |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you’d like to experiment, you can wire up a few momentary switches (push
    buttons) to your button wires and use those to make connections, thus turning
    on or off the remote switches ([figure 9.7](#ch09fig07)).
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实验，你可以将几个瞬态开关（按钮）连接到按钮线上，并使用这些开关来建立连接，从而打开或关闭遥控器开关（[图9.7](#ch09fig07)）。
- en: Figure 9.7\. If you like, you can connect up one or more of your wired buttons
    to a push button to test it out.
  id: totrans-1018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7\. 如果你愿意，你可以连接一个或多个你的有线按钮到按钮上以测试它。
- en: '![](09fig07.jpg)'
  id: totrans-1019
  prefs: []
  type: TYPE_IMG
  zh: '![09fig07.jpg](09fig07.jpg)'
- en: So far, this has been an interesting exercise in understanding how things work,
    but you may have realized that it doesn’t accomplish anything useful. It still
    requires pokes from human fingers to operate the controls. Instead, let’s design
    it so you can control the device based on whatever input or logic you desire.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这已经是一个有趣的练习，用于理解事物是如何工作的，但你可能已经意识到这并没有完成任何有用的任务。它仍然需要人类手指的戳击来操作控件。相反，让我们设计它，以便你可以根据你想要的任何输入或逻辑来控制设备。
- en: Using photocouplers to keep circuits isolated
  id: totrans-1021
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用光电耦合器来隔离电路
- en: When interfacing with circuits in other electronics, it’s best to keep the power
    sources and circuit components of the target device isolated from your development
    board and circuit. You wouldn’t want vagaries of current or voltage in the remote
    to damage the electronics in the dev-board circuit or vice versa. You want your
    development board and the devices connected to it to be able to *control* the
    flow of current through the remote (making and breaking connections for different
    buttons), but you don’t want to actually *connect* to the remote’s circuitry ([figure
    9.8](#ch09fig08)).
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他电子设备中的电路进行接口时，最好将目标设备的电源和电路组件与你的开发板和电路隔离。你不想让遥控器中的电流或电压的不可预测性损坏开发板电路中的电子设备，反之亦然。你希望你的开发板及其连接的设备能够*控制*通过遥控器的电流流动（为不同的按钮建立和断开连接），但你不想实际上*连接*到遥控器的电路（[图9.8](#ch09fig08)）。
- en: Figure 9.8\. For each button on the remote, you want to be able to press and
    release the button using the Tessel as a switch-like controller. You want it so
    that applying current across points 1 and 2 (the input side) causes current to
    flow between points 3 and 4 (the output, remote side), but you don’t want the
    two circuits to be physically connected.
  id: totrans-1023
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.8\. 对于遥控器上的每个按钮，你希望能够使用Tessel作为类似开关的控制器来按下和释放按钮。你希望当在点1和点2（输入端）之间施加电流时，电流能够在点3和点4（输出端，遥控器端）之间流动，但你不想让两个电路在物理上连接。
- en: '![](09fig08_alt.jpg)'
  id: totrans-1024
  prefs: []
  type: TYPE_IMG
  zh: '![09fig08_alt.jpg](09fig08_alt.jpg)'
- en: This is where *photocoupler* components shine (literally). When current is flowing
    between two pins on the input side of a photocoupler component, current is allowed
    to flow between two pins on the *output* side. That is, the output-side switch
    is closed ([figure 9.9](#ch09fig09)). If this notion strikes you as somewhat reminiscent
    of how transistors work—a small input current that allows current to flow between
    two other pins—you’re right. But in this case, the input current activates the
    output transistor without “touching” it with its current. Instead, an internal
    LED is powered by the current flowing across the input pins. The output-side transistor
    is photosensitive and activates (closes the switch) when light hits it.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是光电耦合器组件（字面意义上）发光的地方。当电流在光电耦合器组件输入端的两个引脚之间流动时，允许电流在输出端的两个引脚之间流动。也就是说，输出端的开关是关闭的（[图9.9](#ch09fig09)）。如果你觉得这个概念有点像晶体管的工作方式——一个小的输入电流允许电流在两个其他引脚之间流动——你是正确的。但在这个案例中，输入电流通过不“接触”它来激活输出晶体管。相反，内部LED由流经输入引脚的电流供电。输出端的晶体管是光敏的，当光线照射到它时，会激活（关闭开关）。
- en: Figure 9.9\. Current applied to the input side of a photocoupler activates an
    internal infrared LED. The LED shines onto a photosensitive transistor, activating
    it and allowing current to flow on the output side.
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9\. 电流施加到光电耦合器的输入端会激活内部红外LED。LED发出的光照射到光敏晶体管上，激活它并允许电流在输出端流动。
- en: '![](09fig09_alt.jpg)'
  id: totrans-1027
  prefs: []
  type: TYPE_IMG
  zh: '![09fig09_alt.jpg](09fig09_alt.jpg)'
- en: 'As you’ve seen with some other components, a photocoupler goes by many alternative
    names: you may see them referred to as *optocouplers* or *opto-isolators*.'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你看到的一些其他组件一样，光电耦合器有许多不同的名称：你可能会看到它们被称为*光电耦合器*或*光电隔离器*。
- en: 9.2\. Controlling the remote switches with a Johnny-Five component plugin
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 使用Johnny-Five组件插件控制遥控器开关
- en: Your first experiment with remotely controlling the remote control (oh, it’s
    getting meta!) will involve using existing Johnny-Five features, but cobbling
    them together in new ways.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 你第一次尝试远程控制遥控器（哦，它变得很抽象了！）将涉及使用现有的Johnny-Five功能，但以新的方式组合它们。
- en: In this first iteration, you’ll make it so you can control each on and off switch—virtually
    pressing buttons—using application logic running on the Tessel.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一次迭代中，你将使其能够通过Tessel上运行的应用逻辑控制每个开/关开关——虚拟地按下按钮。
- en: 9.2.1\. Prototyping the switch project
  id: totrans-1032
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 开关项目原型设计
- en: Instead of going all-in and wiring up all of the photocouplers and switches
    at once—six photocouplers and related components in my case—it can be helpful
    to start with one chunk of the circuit and make sure it works. Then you can whip
    up some less-than-polished code to check that things are behaving as expected
    before doing any fine tuning.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一次性连接所有光耦合器和开关——在我的情况下是六个光耦合器和相关组件——从电路的一个部分开始并确保它工作可能是有帮助的。然后你可以编写一些不够完善的代码来检查事物是否按预期运行，然后再进行任何精细调整。
- en: This process of *prototyping* can help you validate your approach and troubleshoot
    issues on a smaller scale before diving in too deep.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**原型设计**过程可以帮助你在深入之前，在小规模上验证你的方法并排除问题。
- en: Prototyping the hardware
  id: totrans-1035
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原型设计硬件
- en: Wire up the first set of on and off buttons as shown in [figure 9.10](#ch09fig10).
    Yellow wires should connect to positive button connections, black to negative
    (in my case, all yellow wires connect to the same, shared positive source). Make
    sure the dot indicating pin 1 on the photocouplers is oriented correctly. Connect
    pin 2 of both photocouplers to ground.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图9.10所示连接第一组开/关按钮。[图9.10](#ch09fig10)。黄色电线应连接到正按钮连接，黑色电线连接到负极（在我的情况下，所有黄色电线都连接到相同的共享正极源）。确保光耦合器上指示引脚1的圆点方向正确。将两个光耦合器的引脚2连接到地。
- en: Figure 9.10\. Wiring diagram for the first set of on/off buttons
  id: totrans-1037
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.10. 第一组开/关按钮的布线图
- en: '![](09fig10_alt.jpg)'
  id: totrans-1038
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10的替代图片](09fig10_alt.jpg)'
- en: Connect pin 1 of the first photocoupler to pin A0 on the Tessel through a 100
    V resistor, and pin 2 to GND. The current-limiting resistor is needed here because
    there’s an LED inside of the photocoupler. Connect pin 5 of the photocoupler to
    the positive wire of the first switch’s *on* button, and pin 4 to the ground wire
    for that button.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个100欧姆电阻将第一个光耦合器的引脚1连接到Tessel的引脚A0，将引脚2连接到GND。这里需要限流电阻，因为光耦合器内部有一个LED。将光耦合器的引脚5连接到第一个开关的*开*按钮的正极，将引脚4连接到该按钮的地线。
- en: Connect the second photocoupler in a similar fashion, but connect it to pin
    A1 on the Tessel (source) side and to the positive and ground wires of the first
    switch’s *off* button.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式连接第二个光耦合器，但将其连接到Tessel（源）侧的引脚A1和第一个开关的*关*按钮的正极和地线。
- en: Prototyping the software
  id: totrans-1041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原型设计软件
- en: Here’s something to consider. What does it mean to “press a button” on the remote?
    The connection that the button-press makes doesn’t stay connected forever, nor
    is it an instantaneous blip—think of a human finger pressing and then releasing
    the button. On my remote, in fact, I’d noticed in the past that if I pressed a
    button too fast—releasing it too quickly—the switch didn’t always respond. There’s
    a bit of press-and-hold involved.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的事情。在遥控器上“按下按钮”意味着什么？按钮按下所建立的连接不会永远保持连接，也不是瞬间的脉冲——想想人类手指按下然后释放按钮。事实上，在我的遥控器上，我过去注意到，如果我按得太快——释放得太快——开关并不总是响应。这里涉及到一点按下并保持。
- en: You can imitate this with software by enabling a button’s connection via the
    photocoupler and keeping it on for a period of time, say half a second, before
    turning it off again. This is probably easier to conceptualize by looking at actual
    code. Let’s go.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过软件通过启用按钮的连接并通过光电耦合器保持一段时间，比如半秒钟，然后再关闭它来模仿这一点。通过查看实际代码可能更容易理解这一点。让我们开始吧。
- en: 'First, set up the project:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置项目：
- en: '[PRE87]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, install the standard dependencies and create an index.js file:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装标准依赖项并创建一个index.js文件：
- en: '[PRE88]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Instead of using a higher-level Johnny-Five component class like `Led`, you’ll
    write digital values—HIGH (1) or LOW (0)—to pins A0 and A1 directly. A pin can
    be configured as a digital output pin, like this:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用高级的 Johnny-Five 组件类如 `Led` 不同，你将直接写入数字值——HIGH（1）或 LOW（0）到 A0 和 A1 引脚。一个引脚可以被配置为数字输出引脚，如下所示：
- en: '[PRE89]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Once configured, it can be written to like this:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，就可以像这样写入：
- en: '[PRE90]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: To “press” the button that turns the first switch on, you’ll want to set pin
    A0 HIGH—”turning on” the photocoupler and allowing current to flow across the
    first button. After 500 milliseconds, you’ll set A0 LOW again, breaking the circuit
    connection and “releasing” the button.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 要“按下”第一个开关的按钮，你需要将引脚 A0 设置为 HIGH——“打开”光电耦合器，允许电流通过第一个按钮。500 毫秒后，你再次将 A0 设置为
    LOW，断开电路连接并“释放”按钮。
- en: Add the following prototype switching code to index.js.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下原型切换代码添加到 index.js 中。
- en: Listing 9.1\. Prototype button-pressing code
  id: totrans-1054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 原型按钮按下代码
- en: '[PRE91]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* These two pins are connected to the source side of the two photocouplers.**'
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这两个引脚连接到两个光电耦合器的源端。**'
- en: '***2* “Presses and holds” buttons for 500 milliseconds to ensure switch activation**'
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “按下并保持”按钮 500 毫秒以确保开关激活**'
- en: '***3* Configures A0 and A1 as digital output pins**'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 A0 和 A1 配置为数字输出引脚**'
- en: '***4* To press a button, first set the associated photocoupler pin HIGH.**'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 要按下按钮，首先将相关的光电耦合器引脚设置为 HIGH。**'
- en: '***5* Then set a timeout for pressDuration (500 ms) before setting the pin
    LOW again.**'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 然后在将引脚再次设置为 LOW 之前，为 pressDuration（500 毫秒）设置超时。**'
- en: '***6* For the prototyping phase, make turnOn and turnOff available to the REPL.**'
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在原型设计阶段，将 turnOn 和 turnOff 方法提供给 REPL 使用。**'
- en: 'Try it out. Deploy the code to the Tessel over LAN (you need to deploy over
    LAN for the REPL to function):'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。通过局域网将代码部署到 Tessel（你需要通过局域网部署，以便 REPL 能够工作）：
- en: '[PRE92]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Try invoking the `turnOn()` and `turnOff()` functions from the REPL. Note that
    both functions return `undefined`—this is fine and not an error.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从 REPL 调用 `turnOn()` 和 `turnOff()` 函数。注意，这两个函数都返回 `undefined`——这是正常的，不是错误。
- en: '[PRE93]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Doing this should “press” the on and off buttons on the remote and turn the
    associated wall outlet on and off.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做应该会“按下”远程控制器的开/关按钮，并打开/关闭相关的墙壁插座。
- en: Building out the rest of the circuit
  id: totrans-1067
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建电路的其余部分
- en: Once you’re feeling more confident that your first circuit is doing what you
    expect, expand on it as shown in [figure 9.11](#ch09fig11). Make sure to pay attention
    to each photocoupler’s orientation.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更有信心你的第一个电路正在按预期工作，就可以像 [图 9.11](#ch09fig11) 所示那样扩展它。确保注意每个光电耦合器的方向。
- en: Figure 9.11\. The completed switch/photocoupler wiring. The outputs from the
    photocouplers should connect to the button contact wires.
  id: totrans-1069
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.11\. 完成的开关/光电耦合器接线图。光电耦合器的输出应该连接到按钮接触线。
- en: '![](09fig11_alt.jpg)'
  id: totrans-1070
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig11_alt.jpg)'
- en: 9.2.2\. Writing the RemoteSwitch plugin
  id: totrans-1071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 编写 RemoteSwitch 插件
- en: Now that you’ve polished the circuit, it’s time to polish the code. Instead
    of having a motley collection of code in the application’s main module (index.js),
    you can encapsulate the behavior of each of the three on/off switch combinations
    in a custom component called `RemoteSwitch`. Whisking away the component-specific
    code will allow you, back in index.js, simply to instantiate a `RemoteSwitch`
    object for each of the three on/off pairs (or however many switch pairs your remote
    has) and turn them on or off at will.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完善了电路，是时候完善代码了。你可以在应用程序的主模块（index.js）中封装每个三个开/关开关组合的行为，而不是有一个杂乱无章的代码集合。通过移除组件特定的代码，你可以在
    index.js 中简单地实例化一个 `RemoteSwitch` 对象，用于每个开/关对（或者你的远程控制器有多少个开关对）并随意打开或关闭它们。
- en: Let’s walk through the steps of creating a reusable Johnny-Five component plugin.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地创建一个可重用的 Johnny-Five 组件插件。
- en: '|  |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Johnny-Five component plugins vs. component classes
  id: totrans-1075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Johnny-Five 组件插件与组件类
- en: Built-in *component classes* like `Led` and `Motor` are part of Johnny-Five’s
    core. Creating a new component class requires changes to the Johnny-Five codebase
    itself. On the other hand, *component plugins* can be created without making any
    modifications to Johnny-Five—ergo the terminology *plugin*. The structure of a
    component plugin bears many similarities to the structure of component class code,
    but the two things—component class versus component plugin—are different animals,
    so don’t get confused (you are making a *plugin*)!
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 内置 *组件类* 如 `Led` 和 `Motor` 是 Johnny-Five 的核心部分。创建一个新的组件类需要对 Johnny-Five 代码库本身进行更改。另一方面，*组件插件*
    可以创建，而无需对 Johnny-Five 进行任何修改——因此术语 *插件*。组件插件的结构与组件类代码的结构有许多相似之处，但这两者——组件类与组件插件——是不同的东西，所以不要混淆（你正在制作一个
    *插件*）！
- en: '|  |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Component plugin structure basics
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 组件插件结构基础
- en: Create a new file in the remote-switches directory called RemoteSwitch.js to
    contain the plugin module. The structure of the module will start out as shown
    in the following listing. This skeleton structure follows some Johnny-Five component
    plugin conventions to make it modular and flexible.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 在 remote-switches 目录中创建一个新的文件名为 RemoteSwitch.js，用于包含插件模块。模块的结构将开始如下所示。这个骨架结构遵循
    Johnny-Five 组件插件约定，使其模块化和灵活。
- en: 'Listing 9.2\. RemoteSwitch.js: starting point'
  id: totrans-1080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. RemoteSwitch.js：起点
- en: '[PRE94]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* Consuming module provides a reference to Johnny-Five (five).**'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 消费模块提供对 Johnny-Five（five）的引用。**'
- en: '***2* This will initialize a new RemoteSwitch object (this is its constructor).**'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这将初始化一个新的 RemoteSwitch 对象（这是它的构造函数）。**'
- en: '***3* You’ll add three prototype methods to control the switch component.**'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你将添加三个原型方法来控制开关组件。**'
- en: The `RemoteSwitch` module doesn’t have a direct dependency on Johnny-Five. Instead,
    it takes a Johnny-Five object reference as an argument to its exported function.
    That way the plugin can work on top of whichever Johnny-Five object is in play
    when it’s included. The passed Johnny-Five object might contain a `board` configured
    with the Tessel I/O plugin, or it might have an Arduino with a Firmata I/O layer,
    or perhaps something else—this way the plugin doesn’t have to care about logistics
    or valid pin numbers or anything. The passed-in Johnny-Five object will take care
    of that, leaving you free to deal with the logic at hand.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoteSwitch` 模块没有直接依赖 Johnny-Five。相反，它将其导出函数的参数作为一个 Johnny-Five 对象引用。这样，插件就可以在包含它的任何
    Johnny-Five 对象之上工作。传递的 Johnny-Five 对象可能包含配置了 Tessel I/O 插件的 `board`，或者它可能有一个带有
    Firmata I/O 层的 Arduino，或者可能是其他东西——这样插件就不必关心物流或有效的引脚编号等任何事情。传递的 Johnny-Five 对象将负责这些，让你可以自由处理手头的逻辑。'
- en: 'The plugin needs to have a constructor that can take some options, perform
    any setup it needs to do, and register itself with Johnny-Five. The instantiation
    of a `RemoteSwitch` will look like this when you’re done:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 插件需要有一个构造函数，它可以接受一些选项，执行它需要进行的任何设置，并注册到 Johnny-Five。当你完成时，`RemoteSwitch` 的实例化将看起来像这样：
- en: '[PRE95]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You’ll work on that constructor next.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来将工作在这个构造函数上。
- en: Coding the plugin
  id: totrans-1089
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写插件代码
- en: Add the following code to `RemoteSwitch.js`.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `RemoteSwitch.js`。
- en: 'Listing 9.3\. RemoteSwitch.js: constructor'
  id: totrans-1091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. RemoteSwitch.js：构造函数
- en: '[PRE96]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* This (boilerplate) pattern ensures the function is called with the “new”
    keyword.**'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个（样板）模式确保函数使用“new”关键字调用。**'
- en: '***2* Registers the component**'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注册组件**'
- en: '***3* You don’t know, technically, whether the switch is on or off at the outset.**'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在一开始，技术上你不知道开关是开启还是关闭。**'
- en: '***4* isActive is true when one of the switch’s buttons is activated (being
    pressed).**'
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当开关的一个按钮被激活（按下）时，isActive 为 true。**'
- en: '***5* Configures the switch’s on and off pins to be digital output pins.**'
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将开关的开启和关闭引脚配置为数字输出引脚。**'
- en: Now it’s time to add the methods that turn the switch on and off.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加切换开关开启和关闭的方法了。
- en: 'Listing 9.4\. RemoteSwitch.js: prototype methods'
  id: totrans-1099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. RemoteSwitch.js：原型方法
- en: '[PRE97]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '***1* Doesn’t activate the switch if it’s already active (busy)**'
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果开关已经处于激活（忙碌）状态，则不会激活开关**'
- en: '***2* Denotes that the switch is currently active**'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 表示开关当前处于激活状态**'
- en: '***3* Determines toggle behavior if turnOn is missing**'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果缺少 turnOn，则确定切换行为**'
- en: '***4* Determines which of the switch’s pins (on or off) to activate**'
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 确定要激活开关的哪个引脚（开启或关闭）**'
- en: '***5* Switch is no longer active; isActive should be false again**'
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 开关不再处于激活状态；isActive 应该再次设置为 false**'
- en: '***6* Keeps track of the switch’s current state**'
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 跟踪开关的当前状态**'
- en: You’ll notice that everything centers around the `toggle` method. The single
    `toggle` argument, `turnOn`, defines what happens. If it’s truthy, the switch
    will turn on. If it’s falsy, the switch will turn off. If it’s *missing* (`undefined`),
    the switch will toggle from whatever state it’s currently in. To support that
    functionality, the switch’s current state is stored in the `isOn` property.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到一切都与 `toggle` 方法有关。单个 `toggle` 参数 `turnOn` 定义了会发生什么。如果是真值，开关会打开。如果是假值，开关会关闭。如果是
    *缺失的* (`undefined`)，开关将从当前状态切换。为了支持该功能，开关的当前状态存储在 `isOn` 属性中。
- en: To prevent the remote from trying to send two signals at once, the `isActive`
    property is used as a flag. `toggle` won’t write to any pins if `isActive` is
    true.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止远程设备尝试同时发送两个信号，使用 `isActive` 属性作为标志。如果 `isActive` 为真，则 `toggle` 不会写入任何引脚。
- en: Refactoring index.js to use RemoteSwitch
  id: totrans-1109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将 index.js 重构为使用 RemoteSwitch
- en: You can now update index.js to contain the following code.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以将 index.js 更新为包含以下代码。
- en: Listing 9.5\. Refactored index.js
  id: totrans-1111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 重构后的 index.js
- en: '[PRE98]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* Imports the RemoteSwitch module and passes it the five reference**'
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 RemoteSwitch 模块并将其传递五个参考**'
- en: 'Try it out:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下：
- en: '[PRE99]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Once it’s running, you can interact with the switch objects in the REPL:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它开始运行，您就可以在 REPL 中与开关对象交互：
- en: '[PRE100]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Iteration: queuing and callbacks'
  id: totrans-1118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 迭代：排队和回调
- en: 'Right now, the `toggle` method on `RemoteSwitch` instances won’t do anything
    if `isActive` is true—that is, it won’t allow multiple simultaneous switch activations.
    The downside is that, as it’s currently written, commands to `toggle` will be
    effectively thrown away and ignored if they happen while the switch is already
    active. Say for some reason you wanted to blink the switch on and off again several
    times, and you had the following code in index.js to try to accomplish that:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果 `isActive` 为真，则 `RemoteSwitch` 实例上的 `toggle` 方法不会做任何事情——也就是说，它不允许多个同时的开关激活。缺点是，按照目前的编写方式，如果在开关已经激活时发生，`toggle`
    命令将被有效地丢弃并忽略。假设出于某种原因，您想多次闪烁开关，并在 index.js 中有如下代码来尝试完成这个任务：
- en: '[PRE101]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The switch would toggle once as expected, sure. But the subsequent nine calls
    to `toggle` would happen immediately afterward—while the switch is still activated
    from the first invocation (and, thus, while `isActive` is `true`). They’d be ignored.
    As a result, the switch would only toggle once, not 10 times.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 开关确实会按预期切换一次。但随后的九次 `toggle` 调用会立即发生——在第一次调用激活开关之后（因此，当 `isActive` 为 `true`
    时）。它们会被忽略。因此，开关只会切换一次，而不是十次。
- en: You can fix that by throwing in simple FIFO queueing (first in, first out—analogous
    to “calls are answered in the order they’re received”) for toggle commands that
    come in while the switch is active. This requires just a few lines of code.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在开关激活时加入简单的 FIFO 排队（先进先出——类似于“按接收顺序回答电话”）来修复这个问题。这只需要几行代码。
- en: While you’re in there, you can also add some *callback* support to `RemoteSwitch`’s
    methods, as shown in the next listing. This is consistent with other J5 components
    and makes it possible to register a function to be called when the switch command
    (on/off/toggle) is complete. Right now this is gravy, but it’ll be useful later.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在那里时，你还可以向 `RemoteSwitch` 的方法添加一些 *回调* 支持，如下一列表所示。这与其他 J5 组件保持一致，并使得在开关命令（开/关/切换）完成时注册一个要调用的函数成为可能。目前这只是一个额外的功能，但将来会很有用。
- en: Listing 9.6\. The complete `RemoteSwitch` plugin
  id: totrans-1124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 完整的 `RemoteSwitch` 插件
- en: '[PRE102]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* Instantiates an empty array to hold queued “commands”**'
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化一个空数组来存储排队的“命令”**'
- en: '***2* Now accepts a callback**'
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在接受回调**'
- en: '***3* Pushes things onto the queue if the switch is busy**'
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果开关忙碌，则将项目推入队列**'
- en: '***4* The toggle action is complete: invokes the callback, if there is one**'
  id: totrans-1129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 切换动作完成：如果有回调，则调用**'
- en: '***5* Calls toggle on the next item in the queue, if there is one**'
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果队列中有下一个项目，则调用 toggle**'
- en: '***6* on and off handler functions take a callback argument and pass it on
    to toggle.**'
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 开关和关闭处理函数接受一个回调参数并将其传递给切换**'
- en: 'Now if you add the following code to index.js, it should work as expected:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您将以下代码添加到 index.js 中，它应该按预期工作：
- en: '[PRE103]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '|  |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Your hardware may vary
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 您的硬件可能不同
- en: The switch should toggle 10 times, based on the software we’ve written. It’s
    worth noting, however, that there may be hardware limitations that prevent this
    from actually being the case. For example, your remote’s electronics may not allow
    a switch to be toggled that frequently.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们编写的软件，开关应该切换10次。然而，值得注意的是，可能存在硬件限制，这可能会阻止这种情况的发生。例如，你的遥控器的电子设备可能不允许开关频繁切换。
- en: '|  |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So far, you’ve hacked into consumer electronics, built a small prototype, and
    then expanded that into a more polished circuit with a custom Johnny-Five component
    plugin for output (switches).
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经黑入了消费电子产品，构建了一个小型原型，并将其扩展为一个更精致的电路，其中包含一个定制的Johnny-Five组件插件用于输出（开关）。
- en: You could trigger your `RemoteSwitch` components with some of the input devices
    you’ve seen before. You could use a photoresistor and trigger the switches when
    it gets dark in the room. You could use a motion or proximity sensor to turn them
    on when your cat walks by (and turn them off automatically after a certain amount
    of elapsed time). But what happens when you have your heart set on controlling
    the switches with a kind of input that isn’t supported by Johnny-Five? What then?
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用你之前看到的一些输入设备来触发你的`RemoteSwitch`组件。你可以使用光敏电阻，当房间变暗时触发开关。你可以使用运动或接近传感器，当你的猫经过时打开它们（并在一定时间后自动关闭）。但是，当你一心想要用Johnny-Five不支持的一种输入方式来控制开关时会发生什么？那时怎么办？
- en: 9.3\. Writing software for sophisticated hardware
  id: totrans-1140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 编写复杂硬件的软件
- en: 'There’s this nifty I²C device that caught my eye. The Avago APDS-9960 device
    ([figure 9.12](#ch09fig12)) contains multiple sensors: an RGB ambient light sensor,
    a proximity sensor, and a sophisticated gesture sensor. SparkFun sells an inexpensive
    (about $15) breakout board based on the chip. Neat! A gesture sensor! What a fun
    way to control your remotely switched lamps. Why poke buttons when you can swipe
    through the air like a magician?'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样一个吸引我注意的I²C设备。Avago APDS-9960设备（[图9.12](#ch09fig12)）包含多个传感器：一个RGB环境光传感器、一个接近传感器和一个复杂的手势传感器。SparkFun销售基于该芯片的廉价（约15美元）分线板。真
    neat！一个手势传感器！这是一个控制你远程开关灯的有趣方式。为什么还要按按钮，当你可以像魔术师一样在空中滑动呢？
- en: Figure 9.12\. The APDS-9960 crams three sensors into one package, including
    a gesture sensor. SparkFun offers a breakout board that makes working with the
    chip easier.
  id: totrans-1142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.12. APDS-9960将三个传感器集成在一个封装中，包括一个手势传感器。SparkFun提供了一块使芯片工作更简单的分线板。
- en: '![](09fig12.jpg)'
  id: totrans-1143
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig12.jpg)'
- en: 'The problem is, at the time I stumbled upon the APDS-9960, there was no preexisting
    Johnny-Five support for it. There’s no component class for gesture sensors. That
    means you need to create that support! When preexisting software doesn’t exist
    for something you want to use, you’ve got two options: substitute another piece
    of hardware that does have support, or create that support yourself.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我偶然发现APDS-9960时，并没有现成的Johnny-Five支持。没有手势传感器的组件类。这意味着你需要创建那个支持！当你想使用的软件不存在时，你有两个选择：替换另一个有支持的硬件，或者自己创建那个支持。
- en: '9.3.1\. Project: Johnny-Five support for APDS-9660 gesture sensor'
  id: totrans-1145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1. 项目：为APDS-9660手势传感器添加Johnny-Five支持
- en: The APDS-9960 is going to test your mettle (it’s a sophisticated device), but
    the high-level structure of the plugin you’ll create for it will mirror that of
    `RemoteSwitch`. The following project process is based on a real experience and
    highlights some common phases, setbacks, and results encountered while creating
    new support for a piece of hardware.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: APDS-9960将考验你的能力（它是一个复杂的设备），但你为它创建的插件的高级结构将与`RemoteSwitch`相似。以下的项目流程基于真实经验，并突出了在创建硬件新支持时遇到的一些常见阶段、挫折和结果。
- en: 'To build the support, you’ll do the following:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建支持，你需要做以下事情：
- en: Define the goals and scope
  id: totrans-1148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义目标和范围
- en: Gather information and do research on the APDS-9960
  id: totrans-1149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集关于APDS-9960的信息并进行研究
- en: Build a quick, proof-of-concept prototype
  id: totrans-1150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个快速的原型
- en: Define the API surface and plugin lifecycle
  id: totrans-1151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义API界面和插件生命周期
- en: Write the code for the plugin
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写插件的代码
- en: Test that the plugin works
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试插件是否工作
- en: Finish the project, integrating the APDS-9960 plugin with your `RemoteSwitch`
    from earlier in the chapter
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成项目，将本章早些时候的`RemoteSwitch`与APDS-9960插件集成
- en: Goals for the gesture sensor plugin
  id: totrans-1155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 手势传感器插件的目标
- en: Before plugging in wires, soldering, or slinging code, the first thing to do
    is ask yourself what you’re trying to accomplish.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 在插上电线、焊接或编写代码之前，首先要问自己你想要完成什么。
- en: You want to make a Johnny-Five component plugin for the gesture sensor on the
    APDS-9960\. A reasonable API consistent with other Johnny-Five components would
    include exposing gesture events that could be listened for and responded to by
    application code.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要为APDS-9960手势传感器创建一个Johnny-Five组件插件。一个合理的API，与其它Johnny-Five组件保持一致，应该包括暴露手势事件，这些事件可以被应用程序代码监听和响应。
- en: What’s not in scope? Given the complexity of the APDS-9960’s gesture sensor
    alone, don’t try to tackle support for its other sensors. Likewise, to save on
    development time and headaches, you’ll go ahead and hard-code many of the default
    settings and feature support that could later be managed in another way, such
    as through options passed to the plugin.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 范围之外的内容是什么？鉴于APDS-9960手势传感器的复杂性，不要尝试支持其它的传感器。同样，为了节省开发时间和减少麻烦，你将直接硬编码许多默认设置和功能支持，这些可以在以后通过其他方式管理，例如通过传递给插件的选项。
- en: Designing the code to be usable on multiple hardware platforms is a good goal,
    as is keeping flexibility for the future in mind as you go. Writing a module that
    conforms to Johnny-Five component plugin conventions—like `RemoteSwitch`—will
    aid with the cross-platform objective. Being mindful about how constants are managed,
    paying attention to the consistency of the API surface, and keeping methods modular
    will help make the software easier to modify and to expand upon later.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 设计代码以便在多个硬件平台上使用是一个良好的目标，同时也要考虑到未来的灵活性。编写一个符合Johnny-Five组件插件约定的模块——例如`RemoteSwitch`——将有助于实现跨平台的目标。注意常量的管理方式，关注API表面的一致性，并保持方法模块化，将有助于使软件更容易修改和扩展。
- en: You’ll be writing this gesture-sensor support based on the Tessel. There’s no
    reason to think it wouldn’t work on other (3.3 V) Johnny-Five-compatible platforms,
    but you won’t be taking the time in this project to do testing beyond the Tessel.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 你将基于Tessel编写这个手势传感器支持。没有理由认为它不会在其他（3.3 V）Johnny-Five兼容平台上工作，但在这个项目中你不会花费时间去进行超出Tessel的测试。
- en: Gathering information about the APDS-9960
  id: totrans-1161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收集有关APDS-9960的信息
- en: 'With your goals and scope defined, it’s time to gather information. There are
    many questions to answer:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确了目标和范围之后，是时候收集信息了。有许多问题需要回答：
- en: '***Physical hardware and protocols*—** What is the operating voltage of the
    device? What are the pins and connections? What communications protocol does it
    use?'
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***物理硬件和协议*—** 设备的工作电压是多少？有哪些引脚和连接？它使用哪种通信协议？'
- en: '***Communicating*—** What are the particulars for reading data from and writing
    it to the device?'
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***通信*—** 从设备读取数据和写入数据的具体细节是什么？'
- en: '***Configuration and setup*—** What steps need to be taken to initialize the
    device, set defaults, and enable needed features?'
  id: totrans-1165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***配置和设置*—** 初始化设备、设置默认值和启用所需功能需要采取哪些步骤？'
- en: '***Data*—** What kind of data is produced by the device? How do you interpret
    and process the data?'
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数据*—** 设备产生了哪些类型的数据？你如何解释和处理这些数据？'
- en: 'Your first stop on the discovery journey is to read SparkFun’s APDS-9960 hookup
    guide and documentation ([http://mng.bz/MapU](http://mng.bz/MapU)). SparkFun’s
    breakout board for the APDS-9960 takes care of some of the hardware-level busywork
    for you—jumpers and power connections. The resulting board can be wired up like
    other I²C components you’ve encountered. But there’s one addition: a connection
    to an interrupt-capable pin. We’ll come back to that. Another really important
    detail is that this device operates at 3.3 V—that’s totally fine for the Tessel,
    but don’t try to connect it to a 5 V Arduino.'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索之旅的第一站，你需要阅读SparkFun的APDS-9960连接指南和文档([http://mng.bz/MapU](http://mng.bz/MapU))。SparkFun为APDS-9960提供的分线板为你处理了一些硬件层面的繁琐工作——跳线和电源连接。结果板可以像你遇到的其他I²C组件一样布线。但有一个额外的连接：一个中断能力的引脚。我们稍后会回到这一点。另一个非常重要的细节是，这个设备在3.3
    V下运行——这对Tessel来说完全没问题，但不要尝试将其连接到5 V的Arduino。
- en: 'Next, get your hands on the datasheet for the APDS-9960 and give it a scan
    ([http://mng.bz/by50](http://mng.bz/by50)). The great news is that the APDS-9960’s
    datasheet is excellent, as datasheets go. But it’s still a datasheet for a nontrivial
    device: don’t panic if an initial peek makes your eyes cross a bit. Read page
    1 in its entirety—it’s a good summary. From the datasheet you can obtain vital
    details like the device’s hard-coded I²C address (it’s `0x39`; see p. 8).'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取APDS-9960的数据表并进行扫描([http://mng.bz/by50](http://mng.bz/by50))。好消息是，APDS-9960的数据表相当出色，作为数据表来说。但请注意，它仍然是一个非平凡设备的数据表：如果初次浏览让你感到眼花缭乱，请不要慌张。完整阅读第1页——这是一个很好的总结。从数据表中，你可以获取到设备硬编码的I²C地址等重要细节（它是`0x39`；见第8页）。
- en: 'By reviewing existing software and firmware support for the APDS-9960, you
    can get a big leg up. Shawn Hymel at SparkFun authored a complete and excellent
    open source Arduino library (for 3.3 V Arduinos only!) that supports every feature
    of the device ([http://mng.bz/8gE7](http://mng.bz/8gE7)). It’s outstanding: readable
    and exhaustively commented. Cross-referencing between the Arduino library and
    the datasheet fleshes out some other details about working with the device.'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过审查现有的APDS-9960软件和固件支持，你可以获得很大的优势。SparkFun的Shawn Hymel编写了一个完整且出色的开源Arduino库（仅适用于3.3
    V Arduino！），它支持设备的每个功能([http://mng.bz/8gE7](http://mng.bz/8gE7))。它非常出色：易于阅读且注释详尽。Arduino库和数据表之间的交叉引用详细说明了与设备一起工作的其他一些细节。
- en: How to work with the APDS-9960
  id: totrans-1170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如何使用APDS-9960
- en: Before gesture data can be generated, the APDS-9960 hardware needs to be initialized
    and have its gesture mode enabled. This is, conceptually, a two-step process.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成手势数据之前，APDS-9960硬件需要初始化并启用其手势模式。从概念上讲，这是一个两步的过程。
- en: First, there’s a *setup* phase in which defaults and settings are written to
    a number of different individual registers on the APDS-9960\. Subsequently, there’s
    an *enable* phase in which the gesture mode is activated (as opposed to a mode
    for one of the device’s other sensors) and some gesture-specific settings are
    written to some more registers ([figure 9.13](#ch09fig13)).
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个*设置*阶段，在这个阶段，默认值和设置被写入APDS-9960上的多个不同寄存器。随后，有一个*启用*阶段，在这个阶段，手势模式被激活（而不是设备其他传感器的模式），并且一些特定于手势的设置被写入更多的寄存器([图9.13](#ch09fig13))。
- en: Figure 9.13\. In this simplified partial state machine representation of your
    plugin, a plugin object instance starts out in a `new` state. Via a `setup` method
    it moves into an `initialized` state, at which point the APDS-9960 device is initialized
    but not actively sensing gestures. An `enable` method enables the gesture mode
    on the device.
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.13。在这个简化的部分状态机表示中，插件对象实例最初处于`new`状态。通过`setup`方法，它进入`initialized`状态，此时APDS-9960设备已初始化但未主动感应手势。`enable`方法启用了设备上的手势模式。
- en: '![](09fig13_alt.jpg)'
  id: totrans-1174
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig13_alt.jpg)'
- en: 'To use a very sloppy, inaccurate metaphor: *setup* is like turning the chip
    on and booting it up, whereas *enable* is like launching a gesture-specific app
    on the device. Although your implementation will only support gesture sensing—which
    means enable will always happen right after setup without user intervention—keeping
    these two phases distinct will make it easier to add additional sensor support
    later.'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个非常粗略、不准确的比喻来说：*设置*就像打开芯片并启动它，而*启用*就像在设备上启动一个特定手势的应用程序。尽管你的实现将仅支持手势感应——这意味着启用总是在设置之后立即发生，无需用户干预——保持这两个阶段的不同将使以后添加额外的传感器支持更容易。
- en: Which registers and what values need to be written during setup and enable?
    All of that info is in the datasheet; it requires time and patience and attention
    to detail to organize it all.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置和启用过程中，需要写入哪些寄存器和什么值？所有这些信息都在数据表中；需要时间、耐心和细致的注意力来组织它们。
- en: With setup and enable completed, the APDS-9960 will be actively sensing for
    gesture movement. When the device senses motion and begins to produce data, it
    will *pull the interrupt pin LOW*, signaling that a gesture has been detected.
    That is, the voltage on the Tessel pin connected to the breakout board’s interrupt
    pin will change from 3.3 V to 0 V. That so-called *falling edge* from HIGH to
    LOW is the sign that your software should read gesture data from the device.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和启用完成后，APDS-9960将积极感应手势运动。当设备感应到运动并开始产生数据时，它将*将中断引脚拉低*，表示已检测到手势。也就是说，连接到分线板中断引脚的Tessel引脚上的电压将从3.3
    V变为0 V。从高到低的所谓*下降沿*是软件应该从设备读取手势数据的信号。
- en: The data representing a gesture is composed of a collection of 4-byte datasets,
    each containing 1 byte (a value from 0 to 255) for each direction (up, down, left,
    right). By analyzing the way these values change for each direction over the set
    of dataset samples, it’s possible to derive an overall gesture direction.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 手势数据表示由一系列4字节的数据集组成，每个数据集包含每个方向（上、下、左、右）的1字节（一个从0到255的值）。通过分析这些值在每个方向上的变化，可以推导出手势的整体方向。
- en: When the device detects gesture movements, it pulls the interrupt LOW and then
    starts stashing datasets into memory registers. There are 128 bytes of space on
    the device for this—up to 32 readings of 4 bytes each—and the data is put into
    these registers in a FIFO (first-in, first-out) manner ([figure 9.14](#ch09fig14)).
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备检测到手势动作时，它会将中断引脚拉低，然后开始将数据集存入内存寄存器。设备上为此预留了128字节的空间——最多可以存储32个4字节的数据读取——数据以FIFO（先进先出）的方式放入这些寄存器中（[图9.14](#ch09fig14)）。
- en: Figure 9.14\. There are 128 bytes of FIFO RAM, starting at memory address 0xFC,
    available to hold gesture data. In this example, there are three datasets available
    in the FIFO queue. A dataset is composed of four bytes, each representing data
    for a different direction—up, down, left, and right.
  id: totrans-1180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.14。有128字节的FIFO RAM可用，起始内存地址为0xFC，用于存储手势数据。在这个例子中，FIFO队列中有三个数据集可用。一个数据集由四个字节组成，每个字节代表不同方向的数据——上、下、左和右。
- en: '![](09fig14_alt.jpg)'
  id: totrans-1181
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig14_alt.jpg)'
- en: When the controlling device—your Tessel—reads data bytes out of those registers,
    it frees up space, and more data can be pushed into the FIFO RAM. This cycle continues—the
    controller reads, the device puts more data in the FIFO—until no more gesture
    data is coming in and the FIFO is emptied. Then the data can be processed by the
    controlling device ([figure 9.15](#ch09fig15)).
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制设备——你的Tessel——从这些寄存器中读取数据字节时，它就会释放空间，更多的数据可以被推入FIFO RAM。这个过程会持续进行——控制器读取，设备将更多数据放入FIFO——直到没有更多的手势数据进入，FIFO被清空。然后，数据可以被控制设备处理（[图9.15](#ch09fig15)）。
- en: '|  |'
  id: totrans-1183
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Technically speaking: interrupts'
  id: totrans-1184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 技术上讲：中断
- en: Technically, the device will trigger an interrupt on detecting gesture data
    because you’ll configure it to do so as part of the enable step. The APDS-9960
    is highly configurable, and gesture interrupt is an optional feature. Even more
    technically, it will trigger an interrupt after four datasets (samples) have been
    put into the FIFO RAM. Precisely when that interrupt triggers is, yep, also configurable.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，当检测到手势数据时，设备将触发一个中断，因为你在启用步骤中将其配置为这样做。APDS-9960具有高度可配置性，手势中断是一个可选功能。更技术性地，它将在FIFO
    RAM中放入四个数据集（样本）后触发中断。确切的中断触发时间，是的，也是可配置的。
- en: '|  |'
  id: totrans-1186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 9.15\. The plugin’s state machine gains more detail as research continues.
    When an interrupt is detected, the plugin instance enters a reading cycle phase
    and then a processing phase before returning to the active-listening enabled state.
  id: totrans-1187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.15。随着研究的深入，该插件的有限状态机变得更加详细。当检测到中断时，插件实例进入读取周期阶段，然后进入处理阶段，最后返回到激活监听状态。
- en: '![](09fig15_alt.jpg)'
  id: totrans-1188
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig15_alt.jpg)'
- en: Prototyping a proof-of-concept
  id: totrans-1189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建一个概念验证原型
- en: Before tackling the plugin implementation, a sanity check is in order. You’re
    going to establish a working area, wire up the chip, and make sure you can establish
    I²C communication with it. That will make you feel more confident as you get into
    the more detail-oriented development phases.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手插件实现之前，需要进行一次合理性检查。你将建立一个工作区，连接芯片，并确保可以与它建立I²C通信。这将使你在进入更注重细节的开发阶段时更有信心。
- en: Wiring up the APDS-9960 breakout board is easy, though you’ll need to solder
    header pins onto it first. Connect it as shown in [figure 9.16](#ch09fig16). The
    interrupt pin is connected to pin A2 on the Tessel, which is an interrupt-capable
    pin.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 连接APDS-9960扩展板很简单，但首先需要在其上焊接引脚头。按照[图9.16](#ch09fig16)所示连接。中断引脚连接到Tessel的A2引脚，这是一个具有中断能力的引脚。
- en: Figure 9.16\. Wiring diagram for APDS-9960 breakout board
  id: totrans-1192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.16。APDS-9960扩展板的布线图
- en: '![](09fig16_alt.jpg)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig16_alt.jpg)'
- en: 'Create a new project working area and install these dependencies:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目工作区并安装这些依赖项：
- en: '[PRE104]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Copy the RemoteSwitch.js file into the gesture directory, as well. You’ll be
    using it again later.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也将RemoteSwitch.js文件复制到手势目录中，你稍后会再次使用它。
- en: '|  |'
  id: totrans-1197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Creating and sharing circuit and wiring diagrams**'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建和共享电路和布线图**'
- en: To create the wiring diagrams used in this book, I used the open source Fritzing
    software ([http://fritzing.org/home/](http://fritzing.org/home/)), which is available
    on Mac, Windows, and Linux platforms. It comes with a variety of parts, including
    boards and components that you can build diagrams with. In addition, parts manufacturers
    like SparkFun and AdaFruit often provide Fritzing parts for their products. I
    was able to find a part for the APDS-9960 in SparkFun’s Fritzing_Parts repository,
    for example ([http://mng.bz/Hsa2](http://mng.bz/Hsa2)).
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建本书中使用的布线图，我使用了开源的 Fritzing 软件 ([http://fritzing.org/home/](http://fritzing.org/home/))，它可在
    Mac、Windows 和 Linux 平台上使用。它包含各种部件，包括你可以用来构建图表的板子和组件。此外，像 SparkFun 和 AdaFruit 这样的部件制造商经常为他们的产品提供
    Fritzing 部件。例如，我能在 SparkFun 的 Fritzing_Parts 存储库中找到一个 APDS-9960 的部件 ([http://mng.bz/Hsa2](http://mng.bz/Hsa2))。
- en: It’s possible to create schematics as well as diagrams with Fritzing, though
    I find it finicky. Considerably more heavy-hitting in the schematic and PCB-design
    software world is EAGLE by Autodesk. It has, unsurprisingly, a learning curve,
    but it’s widely used and there is a cross-platform free version if you want to
    take it for a spin ([www.autodesk.com/products/eagle/free-download](http://www.autodesk.com/products/eagle/free-download)).
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fritzing 可以创建原理图以及图表，尽管我发现它有点挑剔。在原理图和 PCB 设计软件领域，Autodesk 的 EAGLE 是一个更强大的选择。不出所料，它有一个学习曲线，但它被广泛使用，如果你想尝试的话，还有一个跨平台的免费版本
    ([www.autodesk.com/products/eagle/free-download](http://www.autodesk.com/products/eagle/free-download))。
- en: KiCad EDA is another option for cross-platform, open source schematic and PCB
    design software ([http://kicad-pcb.org/](http://kicad-pcb.org/)).
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: KiCad EDA 是另一个跨平台的开源原理图和 PCB 设计软件选项 ([http://kicad-pcb.org/](http://kicad-pcb.org/))。
- en: If you’re keen on experimenting with simulating electronics circuitry—not high-level
    breakout boards and microcontrollers, but fundamentals like capacitors, logic
    gates, transistors, and transformers—you might try the iCircuit App ($9.99), available
    for iOS, Android, and Windows (desktop and phone). This isn’t a static drawing
    or drafting app. Instead, it’s a live-simulation engine that allows you to see
    what really happens as you make changes to circuits.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你热衷于尝试模拟电子电路——不是高级的断出板和微控制器，而是像电容器、逻辑门、晶体管和变压器这样的基础知识——你可能想尝试 iCircuit App
    ($9.99)，适用于 iOS、Android 和 Windows（桌面和手机）。这不是一个静态绘图或制图应用。相反，它是一个实时模拟引擎，允许你在更改电路时看到真正发生的事情。
- en: '|  |'
  id: totrans-1203
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: One of the many registers on the APDS-9960 is a read-only `DEVICE_ID` register,
    with address `0x92` (p. 25 of the datasheet). When reading a byte from that address,
    you should always get the value `0xAB` ([figure 9.17](#ch09fig17)). This isn’t
    useful for your further operation of the chip, but it is a convenient way to make
    sure that I²C communication is working and that you are, indeed, connected to
    an APDS-9960.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: APDS-9960 的许多寄存器之一是一个只读的 `DEVICE_ID` 寄存器，地址为 `0x92`（数据手册第 25 页）。当你从该地址读取一个字节时，你应该始终得到值
    `0xAB` ([图 9.17](#ch09fig17))。这对于你进一步操作芯片来说并不有用，但它是一个方便的方式来确保 I²C 通信正在工作，并且你确实连接到了
    APDS-9960。
- en: Figure 9.17\. The value in the `DEVICE_ID` register at address 0x92 on the APDS-9960
    should always be `0xAB` (`10101011` in binary).
  id: totrans-1205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.17\. 在 APDS-9960 的地址 0x92 上的 `DEVICE_ID` 寄存器中的值应该始终是 `0xAB`（二进制中的 `10101011`）。
- en: '![](09fig17_alt.jpg)'
  id: totrans-1206
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig17_alt.jpg)'
- en: Create a file called i2c-test.js and add the following code to it.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 i2c-test.js 的文件，并将以下代码添加到其中。
- en: Listing 9.7\. Testing the connection to the APDS-9960
  id: totrans-1208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 测试与 APDS-9960 的连接
- en: '[PRE105]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '***1* Starts I²C communications with slave address 0x39\. This is the APDS-9960’s
    hard-coded I²C address.**'
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用从机地址 0x39 开始 I²C 通信。这是 APDS-9960 的硬编码 I²C 地址。**'
- en: '***2* Reads 1 byte from the 0x92 register of the device at address 0x39**'
  id: totrans-1211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从地址 0x39 的设备 0x92 寄存器中读取 1 个字节**'
- en: '***3* If that register doesn’t contain the data 0xAB, something went wrong.**'
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果该寄存器不包含数据 0xAB，则表示出了问题。**'
- en: '|  |'
  id: totrans-1213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Defaul I²C interface
  id: totrans-1214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认 I²C 接口
- en: Tessel has two I²C interfaces. Johnny-Five, via `tessel-io`, will automatically
    use the one on port A if not told otherwise in options passed to `board.i2cConfig()`.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: Tessel 有两个 I²C 接口。Johnny-Five 通过 `tessel-io`，如果没有在 `board.i2cConfig()` 传递的选项中指定，将自动使用
    A 端口的接口。
- en: '|  |'
  id: totrans-1216
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1217
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**I²C capabilities in Johnny-Five**'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '**Johnny-Five 的 I²C 功能**'
- en: The `i2cReadOnce(address, register, bytesToRead, handler(arrayOfBytes))` method
    reads the given number of `bytesToRead` starting from the `register` indicated.
    The callback is called and passed an array of bytes when the read is complete.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cReadOnce(address, register, bytesToRead, handler(arrayOfBytes))` 方法从指定的
    `register` 寄存器开始读取给定的 `bytesToRead` 字节数。读取完成后，回调函数被调用并传递一个字节数组。'
- en: '`i2cReadOnce` is distinct from a related method, `i2cRead`. Like the name implies,
    `i2cReadOnce` *reads once*, whereas `i2cRead` will *continuously* read from the
    indicated address/register combination. `i2cRead` is handy if you want to read
    from the same register(s) over and over again to watch for changes. In your case,
    you’ll be using the interrupt capability of the APDS-9960 to let you know when
    there’s new gesture data, not polling using `i2cRead`.'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cReadOnce` 与相关方法 `i2cRead` 不同。正如其名所示，`i2cReadOnce` 只会 *读取一次*，而 `i2cRead`
    将会 *持续* 从指定的地址/寄存器组合中读取。如果你想要反复从相同的寄存器（们）读取以观察变化，`i2cRead` 会很有用。在你的情况下，你将使用APDS-9960的中断功能来通知你何时有新的手势数据，而不是使用
    `i2cRead` 进行轮询。'
- en: The actual underlying implementation of these I²C utility methods—which also,
    unsurprisingly, include the ability to *write* to an I²C device—is up to the active
    I/O plugin. In the Tessel’s case, this is handled by `tessel-io`; for Arduino,
    it would be Firmata doing the heavy lifting here.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些I²C实用方法的实际底层实现——这些方法也出人意料地包括向I²C设备写入的能力——取决于活动的I/O插件。在Tessel的情况下，这是由`tessel-io`处理的；对于Arduino，这里将是由Firmata来完成繁重的工作。
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this test code out on your connected Tessel and APDS-9960 circuit:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的连接Tessel和APDS-9960电路板上尝试这段测试代码：
- en: '[PRE106]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Once you successfully see the logged message “Connected to APDS-9960!” it’s
    time to move on and build the component plugin itself.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你成功看到日志消息“已连接到APDS-9960！”就到了继续前进并构建组件插件的时候了。
- en: Writing the APDS9960 plugin
  id: totrans-1226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写APDS9960插件
- en: Create a file called APDS9960.js and start with the code shown in the following
    listing. To complete the plugin’s code, you’ll fill these sections in.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为APDS9960.js的文件，并从以下列表中显示的代码开始。为了完成插件的代码，你将填充这些部分。
- en: Listing 9.8\. APDS9960.js starting point
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8。APDS9960.js的起点
- en: '[PRE107]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Methods in the high-level API surface represent the complete state machine ([figure
    9.18](#ch09fig18)). Now you need to implement those methods.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 高级API中的方法表示完整的状态机（[图9.18](#ch09fig18)）。现在你需要实现这些方法。
- en: Figure 9.18\. The plugin’s state machine is now complete. The next step is to
    implement it.
  id: totrans-1231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.18。该插件的有限状态机现在已完整。下一步是实现它。
- en: '![](09fig18_alt.jpg)'
  id: totrans-1232
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig18_alt.jpg)'
- en: Constants and configuration settings
  id: totrans-1233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常量和配置设置
- en: You’ll get some constants defined first, as there are a lot of them. But don’t
    panic. The constants in APDS9960.js define register addresses, bitmasks, default
    values, and some other configuration bits and bobs.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先定义一些常量，因为有很多。但不要慌张。APDS9960.js中的常量定义了寄存器地址、位掩码、默认值以及一些其他配置位和组件。
- en: Figuring out which registers need to be written to set up and enable the device
    is a detail-oriented exercise of datasheet reference (and peeking at other software
    implementations when available).
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 确定需要写入哪些寄存器以设置和启用设备是一项注重细节的练习，需要参考数据手册（并在可能的情况下查看其他软件实现）。
- en: '[Figure 9.19](#ch09fig19) shows some of the registers to which configuration
    settings are written during setup and enable. Some registers’ values are set to
    a simple sensible default value, such as `GPENTH`, which is set to the binary
    representation of `40`. Others are disabled—`GOFFSET_U` is set to `0x00`. And
    some are bitmasks, setting several flags—configuration values—at once (`GCONF1`,
    `GCONF2`).'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.19](#ch09fig19) 展示了在设置和启用过程中写入的一些寄存器。一些寄存器的值被设置为简单的合理默认值，例如 `GPENTH`，其设置为
    `40` 的二进制表示。其他寄存器被禁用——`GOFFSET_U` 被设置为 `0x00`。还有一些是位掩码，一次设置多个标志——配置值（`GCONF1`，`GCONF2`）。'
- en: Figure 9.19\. A sampling of the APDS-9960 registers that are written to during
    setup and enable
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.19。设置和启用过程中写入的APDS-9960寄存器的样本
- en: '![](09fig19_alt.jpg)'
  id: totrans-1238
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig19_alt.jpg)'
- en: '|  |'
  id: totrans-1239
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using bitmasking to manage feature configuration
  id: totrans-1240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用位掩码管理功能配置
- en: The APDS-9960 plugin makes use of *bitmasking* to manage configuration settings
    on the APDS-9960—several configuration values are often contained within a single
    byte, with different bit positions corresponding to the values for different features.
    Several mask flags are bitwise-OR’ed together to compose the multifeature byte.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: APDS-9960 插件使用 *掩码* 来管理 APDS-9960 上的配置设置——几个配置值通常包含在一个字节中，不同的位位置对应不同功能的值。几个掩码标志通过按位或运算组合成多功能的字节。
- en: For example, the register at address `0xA3` (`GCONF2`), contains configuration
    for three features ([figure 9.20](#ch09fig20)).
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，地址为 `0xA3` 的寄存器（`GCONF2`）包含三个功能的配置（[图 9.20](#ch09fig20)）。
- en: Figure 9.20\. Different bit ranges within the `GCONF` register correspond to
    different settings. The two bits in positions 6 and 5 set the gesture gain, for
    instance. Bit 7 isn’t used.
  id: totrans-1243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.20\. `GCONF` 寄存器中的不同位范围对应不同的设置。例如，位置 6 和 5 的两个位设置手势增益。位 7 未使用。
- en: '![](09fig20_alt.jpg)'
  id: totrans-1244
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig20_alt.jpg)'
- en: Once again, I point you to MDN’s excellent article on bitwise operators and
    bitmasking ([http://mng.bz/CLvy](http://mng.bz/CLvy)).
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒你，MDN 关于位运算符和掩码的出色文章（[http://mng.bz/CLvy](http://mng.bz/CLvy)）。
- en: '|  |'
  id: totrans-1246
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Fill in the constants as shown in the following listing.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下列表填写常量。
- en: Listing 9.9\. APDS9960 constants
  id: totrans-1248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. APDS9960 常量
- en: '[PRE108]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '|  |'
  id: totrans-1250
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Technically speaking: how it actually works'
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 技术上讲：它是如何实际工作的
- en: The APDS-9960 senses “gestures” by detecting changes in the amount of energy
    reflected back to it by a built-in, infrared LED. Details of this LED’s configuration—how
    much power is used to drive it, how many times it pulses, and how long each pulse
    lasts per detection cycle—pop up frequently in the defined configuration values.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: APDS-9960 通过检测内置红外 LED 反射回的能量变化来感应“手势”。这个 LED 的配置细节——驱动它的功率、脉冲次数以及每个脉冲在检测周期中的持续时间——在定义的配置值中经常出现。
- en: '|  |'
  id: totrans-1253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3.2\. Implementing constructor and initialization methods
  id: totrans-1254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 实现构造函数和初始化方法
- en: Next, you’ll flesh out the constructor as well as the methods for initializing
    and enabling the device into gesture mode.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将完善构造函数以及初始化和启用设备进入手势模式的方法。
- en: The basic structure of the constructor is the same as the `RemoteSwitch` constructor.
    The constructor also kicks off setup and enable, as shown in the next listing.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的基本结构与 `RemoteSwitch` 构造函数相同。构造函数还启动了设置和启用，如下一列表所示。
- en: 'Listing 9.10\. APDS9960: constructor and gesture data reset'
  id: totrans-1257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. APDS9960：构造函数和手势数据重置
- en: '[PRE109]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '***1* Registers the component with the active board**'
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将组件注册到活动板上**'
- en: '***2* Interrupt will pull from HIGH to LOW to activate; starts with a HIGH
    value (1)**'
  id: totrans-1260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 中断将从高电平拉到低电平以激活；初始值为高电平（1）**'
- en: '***3* Readies the I²C address to pass to i2cConfig**'
  id: totrans-1261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 准备 I²C 地址以传递给 i2cConfig**'
- en: '***4* Retains the I²C address on the component object, too**'
  id: totrans-1262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 同时保留组件对象上的 I²C 地址**'
- en: '***5* this.io is a reference to the active board instance.**'
  id: totrans-1263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* this.io 是对活动板实例的引用。**'
- en: '***6* Resets (initializes) gesture-holding data object**'
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 重置（初始化）手势保持数据对象**'
- en: '***7* Kicks off setup (followed by enable)**'
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 启动设置（随后是启用）**'
- en: 'Next, the initialization methods: `setup` and `enable`.'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是初始化方法：`setup` 和 `enable`。
- en: 'Listing 9.11\. APDS9960: filling in `setup`, and `enable`'
  id: totrans-1267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. APDS9960：填写 `setup` 和 `enable`
- en: '[PRE110]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '***1* Writes default values (SETUP_DEFAULTS) for device setup to various registers**'
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将设备设置的默认值（SETUP_DEFAULTS）写入各个寄存器**'
- en: '***2* Invokes callback (enable, in this case)**'
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用回调（在这个例子中是 enable）**'
- en: '***3* Configures the connected interrupt as a digital input pin**'
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将连接的中断配置为数字输入引脚**'
- en: '***4* Reads values continuously from the interrupt pin**'
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从中断引脚连续读取值**'
- en: '***5* When interrupt goes from HIGH to LOW, invokes readGesture**'
  id: totrans-1273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当中断从高电平变为低电平时，调用 readGesture**'
- en: '***6* Like setup, writes configuration for gesture-mode-specific features**'
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 与设置类似，为手势模式特定的功能写入配置**'
- en: Reading sensor data
  id: totrans-1275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 读取传感器数据
- en: 'With that code for initialization and setup squared away, let’s attack the
    real meat of the plugin: reading and processing gesture data. When the interrupt
    pin goes LOW, `readGesture` is invoked, reading data from the APDS-9960.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化和设置代码就绪后，让我们着手插件的核心部分：读取和处理手势数据。当中断引脚变为低电平时，`readGesture` 被调用，从 APDS-9960
    读取数据。
- en: Listing 9.12\. Reading gesture data
  id: totrans-1277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12\. 读取手势数据
- en: '[PRE111]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'First, `readGesture` reads a byte from the `GSTATUS` register. If the value
    in that register has its least significant (0th) bit set to `1`, you’re in business:
    there’s valid data to be read out of FIFO. But how much data? The value of the
    `GFLVL` (gesture FIFO level) register will tell you how many dataset samples are
    available in the FIFO at the moment. Then it goes ahead and reads that many samples
    out of the FIFO registers, which start at `GFIFO_U` (address 0xFC).'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`readGesture`从`GSTATUS`寄存器读取一个字节。如果该寄存器中的值最低位（0位）设置为`1`，那么你就可以开始了：可以从FIFO中读取有效数据。但是有多少数据？`GFLVL`（手势FIFO级别）寄存器的值将告诉你此刻FIFO中有多少数据集样本可用。然后它继续从FIFO寄存器中读取这么多样本，这些寄存器从`GFIFO_U`（地址0xFC）开始。
- en: Recall that each dataset is four bytes (one byte for each direction), so the
    total number of bytes to read out of the FIFO is `fifoLevel * 4`. `readGestures`
    makes use of the `i2cReadOnce` method once more, this time reading `fifoLevel
    * 4` bytes instead of a single byte. Then it iterates over each full dataset and
    stuffs individual bytes corresponding to each direction into the `raw` data structure
    for later processing. Then it calls itself (recursively) again to see if there’s
    more data available to read ([figure 9.21](#ch09fig21)).
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个数据集是四个字节（每个方向一个字节），所以需要从FIFO中读取的总字节数是`fifoLevel * 4`。`readGestures`再次使用`i2cReadOnce`方法，这次读取`fifoLevel
    * 4`个字节而不是一个字节。然后它遍历每个完整的数据集，将对应于每个方向的单独字节放入`raw`数据结构中，以供后续处理。然后它再次调用自己（递归地）以查看是否有更多数据可供读取（[图9.21](#ch09fig21)）。
- en: Figure 9.21\. The read cycle begins by checking that the 0th bit in the `GSTATUS`
    register is `1`. If so, `GFLVL` is read to see how many samples are available
    (0101, that is, 5), and then the indicated number are read from the FIFO. The
    cycle continues until `GSTATUS<0>` is `0`.
  id: totrans-1281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.21。读取周期首先检查`GSTATUS`寄存器中的0位是否为`1`。如果是，则读取`GFLVL`以查看有多少样本可用（0101，即5），然后从FIFO中读取指示的数量。循环继续，直到`GSTATUS<0>`为`0`。
- en: '![](09fig21_alt.jpg)'
  id: totrans-1282
  prefs: []
  type: TYPE_IMG
  zh: '![图9.21](09fig21_alt.jpg)'
- en: This cycle repeats until the `GSTATUS` register value indicates that no valid
    data is left to read—the first conditional fails and execution continues in the
    `else` clause. When the data-read cycle is complete, the processing of that data
    begins.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会一直重复，直到`GSTATUS`寄存器的值指示没有剩余的有效数据可读取——第一个条件失败，执行继续在`else`子句中。当数据读取周期完成时，开始处理这些数据。
- en: Processing and decoding gesture data
  id: totrans-1284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理和解码手势数据
- en: The methods in your APDS9960 plugin distinguish between *processing* and *decoding*
    gesture data ([figure 9.22](#ch09fig22)).
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 您的APDS9960插件中的方法区分了*处理*和*解码*手势数据（[图9.22](#ch09fig22)）。
- en: Figure 9.22\. `processData` performs arithmetic on data; `decodeData` derives
    gesture direction from the computed results and fires events. Finally, the gesture
    data object is reset on the instance so it’s ready to collect data from the next
    gesture.
  id: totrans-1286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.22。`processData`对数据进行算术运算；`decodeData`从计算结果中派生出手势方向并触发事件。最后，在实例上重置手势数据对象，以便它准备好收集下一个手势的数据。
- en: '![](09fig22_alt.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22](09fig22_alt.jpg)'
- en: In the processing step, math happens. The complete raw collection of samples
    is filtered to include only readings in which every direction’s value exceeds
    a defined threshold constant. Then the change (delta) in the ratios of readings
    over time is computed on each axis (up/down and left/right).
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理步骤中，会发生数学运算。完整的原始样本集合被过滤，只包括每个方向上的值都超过定义的阈值常数的读取值。然后，在每个轴（上下和左右）上计算读取值随时间变化的比率（变化量）。
- en: Listing 9.13\. Processing gesture data
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.13。处理手势数据
- en: '[PRE112]'
  id: totrans-1290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '***1* Computes deltas by comparing ratios of different directions’ readings**'
  id: totrans-1291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过比较不同方向读取值的比率来计算变化量**'
- en: '***2* Filters samples to include only those with readings exceeding the threshold**'
  id: totrans-1292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 过滤样本，只包括那些读取值超过阈值的样本**'
- en: '***3* Makes sure there is valid data to process**'
  id: totrans-1293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 确保存在有效数据可处理**'
- en: '***4* Ultimately, cooks up some deltas**'
  id: totrans-1294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 最终，计算出一些变化量**'
- en: Finally, the decoding step in the following listing translates the deltas computed
    by the `processGesture` method into derived directions for the overall gesture.
    It then fires a corresponding event—`up`, `down`, `left`, or `right`—or, if it
    can’t determine a clear, single gesture direction, it will fire a generic `gesture`
    event, as shown in the next listing.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下述列表中的解码步骤将`processGesture`方法计算出的变化量转换为整体手势的派生方向。然后它触发相应的事件——`上`、`下`、`左`或`右`——或者，如果它无法确定一个清晰的单个手势方向，它将触发一个通用的`gesture`事件，如下一列表所示。
- en: Listing 9.14\. Decoding gesture data
  id: totrans-1296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.14。解码手势数据
- en: '[PRE113]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: With that, the code for the plugin is complete!
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，插件的代码就完成了！
- en: 9.3.3\. Integrating the gesture sensor and remote switches
  id: totrans-1299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3\. 集成手势传感器和远程开关
- en: You can now edit index.js to add some quick testing code, as shown in the following
    listing. Before you get to the big combination step—hooking up the remote switches—you
    can test for different direction swipe events and log them to the console.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以编辑 index.js 来添加一些快速测试代码，如下所示。在你进行大组合步骤——连接远程开关之前，你可以测试不同的滑动方向事件并将它们记录到控制台。
- en: Listing 9.15\. APDS9960 test drive
  id: totrans-1301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. APDS9960 测试驱动
- en: '[PRE114]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Run index.js on the Tessel (`t2 run index.js --lan`) and try moving your hand
    over the top of the gesture sensor—the best distance is around eight inches (20
    cm).
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tessel 上运行 index.js (`t2 run index.js --lan`) 并尝试将你的手移至手势传感器上方——最佳距离大约八英寸（20
    厘米）。
- en: Combining APDS9960 and RemoteSwitch
  id: totrans-1304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结合 APDS9960 和 RemoteSwitch
- en: You’ve already got the ingredients to control individual on/off switch combinations
    using the gesture sensor and `RemoteSwitch`. For example, you could do something
    like what’s shown in the following listing.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经拥有了使用手势传感器和 `RemoteSwitch` 控制单个开关开/关组合的原料。例如，你可以做如下所示的事情。
- en: Listing 9.16\. APDS9960 controlling a single switch with the gesture sensor
  id: totrans-1306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.16\. 使用手势传感器控制单个开关的 APDS9960
- en: '[PRE115]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: So far, so good. But wasn’t one of the stated goals way back at the beginning
    the ability to turn all of the switches on or off at once? The good news is that
    you’re about to make that happen. The other news is that you need to take another
    step to make it so.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但最初提出的目标之一不是能够一次性打开或关闭所有开关吗？好消息是，你即将实现这一点。另一个消息是，你需要再迈出一步才能实现这一点。
- en: The challenges of orchestrating several switches
  id: totrans-1309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 协调多个开关的挑战
- en: 'The design of `RemoteSwitch` takes into account the need to stagger switch
    activations: it queues “commands” that come in when one of the buttons is already
    active, sticks them in a FIFO queue, and executes the next queued command when
    it’s no longer active. In addition, it will invoke a provided callback when it’s
    done with a command. So you could execute the code in the following listing without
    fear of the switch stepping on itself.'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoteSwitch` 的设计考虑到了需要错开开关激活的需求：它将当其中一个按钮已经激活时到达的“命令”排队，将它们放入一个 FIFO 队列，并在不再激活时执行下一个排队的命令。此外，它将在完成一个命令后调用提供的回调函数。因此，你可以放心地执行以下列表中的代码，不用担心开关会相互干扰。'
- en: Listing 9.17\. A pair of buttons managed by a `RemoteSwitch` instance has a
    queue
  id: totrans-1311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.17\. 由 `RemoteSwitch` 实例管理的按钮对有一个队列
- en: '[PRE116]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'But, alas, there’s a shortcoming: the queueing is managed individually for
    each switch pair. Different `RemoteSwitch` instances have no idea of each other;
    see the following listing.'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，遗憾的是，存在一个缺点：每个开关对之间的排队是单独管理的。不同的 `RemoteSwitch` 实例之间互不相识；请参见以下列表。
- en: Listing 9.18\. Each `RemoteSwitch` has its own queue
  id: totrans-1314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.18\. 每个 `RemoteSwitch` 都有自己的队列
- en: '[PRE117]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: It’s quite probable that `switch2` and `switch3` will try to activate while
    `switch1` is still busy—the equivalent of mashing several buttons on the remote
    at the same time. That’s probably not good. `RemoteSwitch` was designed in such
    a way that each switch pair is unaware of each other. That’s a nice nod toward
    hardware abstraction, but our reality is that multiple switch pairs are sharing
    the same transmitter on a single remote device.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能 `switch2` 和 `switch3` 会尝试在 `switch1` 仍然忙碌时激活——相当于同时按下遥控器上的多个按钮。这可能不是什么好事。`RemoteSwitch`
    是这样设计的，每个开关对之间互不相识。这是一个很好的硬件抽象的提示，但我们的现实是，多个开关对正在共享单个遥控设备上的同一发射器。
- en: Controlling multiple switches with Collection
  id: totrans-1317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用集合控制多个开关
- en: Hooboy, another inflection point in the project. You could tear `RemoteSwitch`
    apart and rewrite it to handle multiple sets of switches and their co-mingled
    queues. Or you could write some code for managing multiple switch pairs inside
    the application-specific logic.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，项目中的另一个转折点。你可以拆分 `RemoteSwitch` 并重新编写它以处理多组开关及其混合队列。或者，你可以在应用程序特定逻辑中编写一些管理多个开关对的代码。
- en: Both of those options have drawbacks. It would be tedious to adapt `RemoteSwitch`
    without breaking its existing API or overcomplicating it (this option would seem
    more attractive if you were starting from scratch). Dumping related logic into
    your main application code would be ugly and distracting. After some mulling,
    I settled on a pragmatic—if slightly cobbled-together—third option that takes
    advantage of a Johnny-Five mixin called `Collection`.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择都有缺点。在不破坏现有 API 或过度复杂化它的前提下适应 `RemoteSwitch` 会很麻烦（如果您是从零开始，这个选项看起来会更吸引人）。将相关逻辑直接放入主应用程序代码中会显得很丑陋且分散注意力。经过一番思考，我决定采用一种实用——虽然有些拼凑——的第三种方案，该方案利用了
    Johnny-Five 的 `Collection` 混合。
- en: Built-in *collection classes* like `Motors` (which you saw in [chapter 6](kindle_split_014.html#ch06))
    make use of the `Collection` mixin in Johnny-Five, which provides features for
    managing multiple components within a single container-like object. You can use
    some of the features offered by this mixin to create a component that can manage
    multiple `RemoteSwitch` objects. Once finished, you’ll be able to write code like
    that in the following listing from within your main application module.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 内置 *集合类* 如 `Motors`（您在[第 6 章](kindle_split_014.html#ch06)中看到过）利用 Johnny-Five
    的 `Collection` 混合，该混合提供了在单个容器-like 对象内管理多个组件的功能。您可以使用此混合提供的某些功能来创建一个可以管理多个 `RemoteSwitch`
    对象的组件。完成后，您将能够在主应用程序模块中编写如下列表所示的代码。
- en: Listing 9.19\. Using `RemoteSwitches`
  id: totrans-1321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.19\. 使用 `RemoteSwitches`
- en: '[PRE118]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Create a file called RemoteSwitches.js in your working directory, and add the
    following code.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的当前工作目录中创建一个名为 RemoteSwitches.js 的文件，并添加以下代码。
- en: Listing 9.20\. `RemoteSwitches`
  id: totrans-1324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.20\. `RemoteSwitches`
- en: '[PRE119]'
  id: totrans-1325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 9.3.4\. Pulling the whole project together
  id: totrans-1326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 整合整个项目
- en: All the pieces are ready now to make a combined project, bringing together software
    and circuit modules into a gesture-controlled remote control.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件现在都已准备就绪，可以创建一个综合项目，将软件和电路模块结合成一个手势控制遥控器。
- en: Combine the two circuits—remote control and gesture—as shown in [figure 9.23](#ch09fig23).
    The output sides of the photocouplers should connect to the remote control’s button
    contacts. Note that the photocouplers are now connected to different pins on the
    Tessel to make room for the APDS-9960.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 按照如图 9.23 所示的方式组合两个电路——遥控和手势。光电耦合器的输出端应连接到遥控器的按钮触点。请注意，光电耦合器现在连接到 Tessel 的不同引脚，以腾出
    APDS-9960 的空间。
- en: Figure 9.23\. Wiring diagram showing the combination of the APDS-9960 breakout
    board and the button/photocoupler circuits.
  id: totrans-1329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.23\. 显示 APDS-9960 分线板和按钮/光电耦合器电路组合的布线图。
- en: '![](09fig23_alt.jpg)'
  id: totrans-1330
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig23_alt.jpg)'
- en: '|  |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using full-size breadboards
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用全尺寸面包板
- en: 'If you use a full-size breadboard, as shown in [figure 9.23](#ch09fig23), make
    sure you connect the power rails as shown midway along the board’s length: the
    power rail connections have a break in the middle.'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是全尺寸面包板，如[图 9.23](#ch09fig23)所示，请确保按照板长中部的说明连接电源轨：电源轨连接在中部有断裂。
- en: You can think of a full-size breadboard as two half-size breadboards glommed
    together.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将全尺寸面包板想象成两个半尺寸面包板拼接在一起。
- en: '|  |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Finalizing the software
  id: totrans-1336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最终确定软件
- en: 'Your `gesture` directory should now contain the following:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `gesture` 目录现在应包含以下内容：
- en: '***APDS9960.js_*—** Gesture sensor plugin'
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***APDS9960.js_*—** 手势传感器插件'
- en: '***RemoteSwitch.js*—** (Individual) remote switch plugin'
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***RemoteSwitch.js*—** (单个) 远程开关插件'
- en: '***RemoteSwitches.js*—** Remote switch collection'
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***RemoteSwitches.js*—** 远程开关集合'
- en: '***index.js*—** Application logic'
  id: totrans-1341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***index.js*—** 应用逻辑'
- en: To make room for the APDS-9960 connections, the connections for the photocouplers
    have to jog down a couple of pins (see [figure 9.23](#ch09fig23))—those updated
    pin numbers are accounted for in the final version of index.js, as shown in the
    next listing.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为 APDS-9960 连接腾出空间，光电耦合器的连接必须向下移动几个引脚（参见[图 9.23](#ch09fig23)）——这些更新的引脚编号在
    index.js 的最终版本中已考虑，如下一列表所示。
- en: Listing 9.21\. Pulling it all together in index.js
  id: totrans-1343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.21\. 在 index.js 中整合所有内容
- en: '[PRE120]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Requires the RemoteSwitches module**'
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要 RemoteSwitches 模块**'
- en: '***2* You can, of course, change which gestures correspond to what switch behavior.**'
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 您当然可以更改哪些手势对应哪些开关行为。**'
- en: That was a lot of work! But there are some solid results here. You’ve definitely
    carved a few more triumphant notches on your pole of electronics-hackery experience.
    Of course, there are still wires going everywhere, something you’ll tackle in
    a bit when we look into different kinds of project enclosures for different form
    factors.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项大量工作！但这里有一些稳固的结果。你无疑在你的电子黑客经验之柱上刻下了几个胜利的凹槽。当然，到处都是电线，这是我们稍后将要解决的问题，当我们探讨不同外形尺寸的项目外壳时。
- en: Speaking of form factors, you’ve been giving tons of attention to the Arduino
    Uno and the Tessel, using both with Johnny-Five. But there are a lot more options
    for JavaScript-controlled hardware out there. It’s time to meet some of the other
    players.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 说到外形尺寸，你一直非常关注Arduino Uno和Tessel，两者都使用Johnny-Five。但JavaScript控制的硬件选项还有很多。是时候认识一些其他玩家了。
- en: Summary
  id: totrans-1349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Battery-operated, low-voltage consumer electronics can often be repurposed into
    parts and components for your own projects (provided you exercise care!). Photocoupler
    components can help isolate the circuitry in those electronics from your microcontroller
    circuits.
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池供电、低压消费电子产品通常可以被重新用于你自己的项目中的部件和组件（前提是你小心操作！）。光电耦合器组件可以帮助隔离这些电子产品中的电路与你的微控制器电路。
- en: Invention requires ingenuity but also persistence and patience. It often requires
    thinking creatively to solve unexpected problems.
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发明需要独创性，但也需要坚持和耐心。它通常需要创造性思维来解决意外的问题。
- en: Datasheets can be overwhelmingly data-dense, but they’re vital, and over time
    you’ll learn the ropes and be able to find key information within them—like memory
    register addresses and configuration steps—more quickly.
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据表可能数据密集到令人难以承受，但它们是至关重要的，随着时间的推移，你会学会如何快速在其中找到关键信息——比如内存寄存器地址和配置步骤。
- en: 'Even personal hobby projects can benefit from an organized development approach:
    identifying goals and scope, researching, prototyping, and iterating.'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是个人爱好项目，也可以从有组织的开发方法中受益：确定目标和范围、研究、原型设计和迭代。
- en: Encapsulating behavior into modular, component-level chunks is a good development
    practice, especially for abstraction and cross-platform support. With Johnny-Five,
    you can create component plugins, and you also took advantage of the `Collection`
    mixin.
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将行为封装成模块化、组件级别的块是良好的开发实践，特别是对于抽象和跨平台支持。使用Johnny-Five，你可以创建组件插件，你也利用了`Collection`混入。
