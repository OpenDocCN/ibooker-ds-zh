- en: 7 Designing programs with function composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用函数组合设计程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining workflows with function composition and method chaining
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数组合和方法链定义工作流程
- en: Writing functions that compose well
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写易于组合的函数
- en: An end-to-end example of handling server requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务器请求的端到端示例
- en: Function composition is not only powerful and expressive but also pleasant to
    work with. It’s used to some extent in any programming style, but in FP, it’s
    used extensively. For example, have you noticed that when you use LINQ to work
    with lists, you can get a lot done with only a few lines of code? That’s because
    LINQ is a functional API, designed with composition in mind.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合不仅强大且表达能力强，而且易于使用。它在任何编程风格中都有一定程度的运用，但在函数式编程中，它被广泛使用。例如，你有没有注意到，当你使用LINQ处理列表时，你只需几行代码就能完成很多事情？这是因为LINQ是一个以组合为设计理念的函数式API。
- en: In this chapter, we’ll cover the basic concept and techniques of function composition
    and illustrate its use with LINQ. We’ll also implement an end-to-end server-side
    workflow in which we’ll use the `Option` API introduced in chapter 6\. This example
    illustrates many of the ideas and benefits of the functional approach, so we’ll
    end the chapter with a discussion of those.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍函数组合的基本概念和技术，并使用LINQ来展示其用法。我们还将实现一个端到端的服务器端工作流程，在这个工作流程中，我们将使用第6章中引入的`Option`
    API。这个示例展示了函数方法的一些思想和好处，因此我们将以对这些内容的讨论结束本章。
- en: 7.1 Function composition
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 函数组合
- en: Let’s start by reviewing function composition and how it relates to method chaining.
    Function composition is part of any programmer’s implicit knowledge. It’s a mathematical
    concept you learn in school and then use every day without thinking about it too
    much. Let’s quickly brush up on the definition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下函数组合及其与方法链的关系。函数组合是任何程序员隐性知识的一部分。它是你在学校学到的数学概念，然后每天都在不经意间使用。让我们快速复习一下定义。
- en: 7.1.1 Brushing up on function composition
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 快速复习函数组合
- en: 'Given two functions, *f* and *g*, you can define a function *h* to be the composition
    of those two functions, notated as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个函数*f*和*g*，你可以定义一个函数*h*，它是这两个函数的组合，表示如下：
- en: '*h* = *f* · *g*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*h* = *f* · *g*'
- en: 'Applying *h* to a value *x* is the same as applying *g* to *x* and then applying
    *f* to the result:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将*h*应用于值*x*等同于先对*x*应用*g*，然后对结果应用*f*：
- en: '*h*(*x*) = (*f* · *g*)(*x*) = *f*(*g*(*x*))'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*(*x*) = (*f* · *g*)(*x*) = *f*(*g*(*x*))'
- en: 'For example, say you want to get an email address for someone working at Manning.
    You can have a function calculate the local part (identifying the person) and
    another append the domain:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想为在Manning工作的人获取电子邮件地址。你可以有一个函数计算本地部分（标识人员），另一个则添加域名：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`AbbreviateName` and `AppendDomain` are two functions that you can compose
    to get a new function that yields the Manning email for my hypothetical collaborator.
    Take a look at the following listing.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbbreviateName`和`AppendDomain`是两个你可以组合以得到一个新的函数，该函数可以生成我假设的合作伙伴的Manning电子邮件。请看以下列表。'
- en: Listing 7.1 Defining a function as the composition of two existing functions
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 定义一个函数为两个现有函数的组合
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ `emailFor` composes `AppendDomain` with `AbbreviateName`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `emailFor`将`AppendDomain`与`AbbreviateName`组合。
- en: 'There are a couple of things worth noting. First, you can only compose functions
    with matching types: if you’re composing (*f* · *g*), the output of *g* must be
    assignable to the input type of *f*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点值得注意。首先，你只能组合具有匹配类型的函数：如果你正在组合(*f* · *g*)，那么*g*的输出必须可以赋值给*f*的输入类型。
- en: Second, in function composition, functions appear in the reverse order in which
    they’re performed, so *f* · *g* is sometimes read as “*f* after *g.*” For example,
    in `AppendDomain(AbbreviateName(p))`, you *first* execute the rightmost function
    and then the one to its left. This is not ideal for readability, especially if
    you want to compose several functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，在函数组合中，函数的顺序与它们执行顺序相反，所以*f* · *g*有时读作“*f*在*g*之后。”例如，在`AppendDomain(AbbreviateName(p))`中，你首先执行最右侧的函数，然后是左侧的函数。这不利于可读性，尤其是当你想组合多个函数时。
- en: C# doesn’t have any special syntactic support for function composition, and
    although you could define a HOF `Compose` to compose two or more functions, this
    doesn’t improve readability. This is why in C# it’s best to resort to method chaining
    instead.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C#没有为函数组合提供任何特殊的语法支持，尽管你可以定义一个高阶函数`Compose`来组合两个或多个函数，但这并不会提高可读性。这就是为什么在C#中，最好求助于方法链。
- en: 7.1.2 Method chaining
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 方法链
- en: 'The method chaining syntax (that is, chaining the invocation of several methods
    with the `.` operator) provides a more readable way of achieving function composition
    in C#. Given an expression, you can chain to it any method that’s defined as an
    instance or extension method on the type of the expression. For instance, the
    previous example would need to be modified as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链式语法（即使用 `.` 运算符链式调用多个方法的调用）提供了在C#中实现函数组合的更可读的方式。给定一个表达式，你可以将其链式调用到任何在表达式的类型上定义的实例或扩展方法。例如，前面的例子需要按以下方式修改：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The `this` keyword makes this an extension method
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `this` 关键字使这成为一个扩展方法
- en: You can now chain these methods to obtain the email for the person. The following
    listing shows this approach.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将这些方法链式调用以获取某人的电子邮件。以下列表显示了这种方法。
- en: Listing 7.2 Using method chaining syntax to compose functions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 使用方法链式语法组合函数
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that now the extension methods appear in the order in which they will
    be executed. This significantly improves readability, especially as the complexity
    of the workflow increases (longer method names, additional parameters, more methods
    to be chained), and it’s why method chaining is the preferable way of achieving
    function composition in C#.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在扩展方法出现的顺序是它们将被执行的顺序。这显著提高了可读性，尤其是在工作流程复杂性增加时（更长的方法名、额外的参数、更多要链式调用的方法），这也是为什么方法链式调用是C#中实现函数组合的首选方式。
- en: A common misconception about extension methods
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于扩展方法的常见误解
- en: 'Extension methods are called with the `.` operator, like instance methods,
    yet the semantics are different from instance methods. For example, suppose you
    define a type `Circle` like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法使用 `.` 运算符调用，就像实例方法一样，但其语义与实例方法不同。例如，假设你定义了一个类型 `Circle` 如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you now define methods `Move` and `Scale` as instance methods on `Circle`,
    that implies that a `Circle` *knows* how to move/scale itself or *is responsible
    for* moving itself. That’s an OO way of seeing things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在将 `Move` 和 `Scale` 定义为 `Circle` 上的实例方法，这意味着 `Circle` *知道* 如何移动/缩放自己或 *负责*
    移动自己。这是面向对象看待事物的方式。
- en: 'In FP, on the other hand, we would put this logic into functions that are separate
    from the data they act on (more on this in section 11.4). For example, take a
    look at the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，另一方面，我们会将这个逻辑放入与它们作用的数据分离的函数中（更多内容请见第11.4节）。例如，看看以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ A module of functions for working with circles
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个用于处理圆的函数模块
- en: ❷ Yields a circl that was moved
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个被移动的圆
- en: ❸ Yields a circle that was scaled
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个被缩放的圆
- en: 'The fact that we define `Move` and `Scale` as extension methods allows us to
    call them like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Move` 和 `Scale` 定义为扩展方法的事实使我们能够像这样调用它们：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is equivalent to but more readable than the corresponding invocation without
    the extension method syntax:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这与没有扩展方法语法的相应调用等效，但更易读。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Developers steeped in OOP tend to treat extension methods as though they were
    instance methods; e.g., just because `Move` marks the given circle with the `this`
    modifier, they tend to feel that `Move` *belongs* to `Circle` or that a `Circle`
    therefore *knows* or *is responsible for* moving itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 深受面向对象编程（OOP）影响的开发者往往将扩展方法视为实例方法；例如，仅仅因为 `Move` 使用了 `this` 修饰符标记了给定的圆，他们倾向于认为
    `Move` *属于* `Circle` 或因此 `Circle` *知道* 或 *负责* 移动自己。
- en: This is a misconception you should leave behind. In the current example, you
    should think of `Move` and `Scale` simply as functions that process the given
    data; the fact that we’re using them as extension methods is purely for readability.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你应该摒弃的误解。在当前示例中，你应该将 `Move` 和 `Scale` 简单地视为处理给定数据的函数；我们使用它们作为扩展方法纯粹是为了可读性。
- en: 7.1.3 Composition in the elevated world
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 高级世界中的组合
- en: 'Function composition is so important that it should also hold in the world
    of elevated values. Let’s stay with the current example of determining a person’s
    email address, but now we have an `Option<Person>` as a starting value. You would
    assume that the following holds:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合非常重要，它也应该在高级值的世界中成立。让我们继续当前示例，确定某人的电子邮件地址，但现在我们有一个 `Option<Person>` 作为起始值。你会假设以下内容成立：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ `emailFor` is composed of `Append-Domain` with `AbbreviateName`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `emailFor` 由 `Append-Domain` 和 `AbbreviateName` 组成。
- en: ❷ Maps the composed functions
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 映射组合函数
- en: ❸ Maps `AbbreviateName` and `AppendDomain` in separate steps
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 分步骤映射 `AbbreviateName` 和 `AppendDomain`
- en: Whether you map `AbbreviateName` and `AppendDomain` in separate steps or map
    their composition `emailFor` in a single step, the result shouldn’t change. You
    should be able to safely refactor between these two forms.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是分步映射 `AbbreviateName` 和 `AppendDomain`，还是将它们的组合 `emailFor` 在一个步骤中映射，结果都不应该改变。你应该能够安全地在这两种形式之间重构。
- en: More generally, if *h* = *f* · *g*, then mapping *h* onto a functor should be
    equivalent to mapping *g* over that functor and then mapping *f* over the result.
    This should hold for any functor and for any pair of functions—it’s one of the
    *functor laws*, so any implementation of `Map` should observe it.[¹](#pgfId-1123641)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地，如果 *h* = *f* · *g*，那么将 *h* 映射到函子应该等同于先映射 *g* 到该函子，然后映射 *f* 到结果。这应该适用于任何函子和任何一对函数——这是函子定律之一，因此任何
    `Map` 的实现都应该遵守它。[¹](#pgfId-1123641)
- en: If this sounds complicated, that’s probably because it describes something that
    you intuitively feel should always obviously hold. Indeed, it’s not easy to break
    this law, but you could come up with a mischievous functor that, say, keeps an
    inner counter of how many times `Map` is applied (or otherwise changes its state
    with every call to `Map`), and then the preceding wouldn’t hold because `b` would
    have a greater inner count than `a`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，那可能是因为它描述的是你直觉上认为应该始终明显成立的事情。确实，打破这条定律并不容易，但你可能会想出一个恶作剧般的函子，比如，它保留一个内部计数器，记录
    `Map` 被应用了多少次（或者每次调用 `Map` 时以其他方式改变其状态），然后前面的情况就不会成立，因为 `b` 的内部计数会比 `a` 更大。
- en: Simply put, `Map` should apply a function to the functor’s inner value(s) and
    do nothing else so that function composition holds when working with functors
    just as it does with normal values. The beauty of this is that you can use any
    functional library in any programming language and use any functor with confidence
    that a refactoring such as changing between `a` and `b` in the preceding snippet
    will be safe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`Map` 应该将函数应用于函子的内部值（或值），而不再做其他任何事情，以确保在处理函子时函数组合保持不变，就像处理正常值时一样。这种方法的优点在于，你可以在任何编程语言中使用任何函数库，并且可以自信地使用任何函子，因为像在前面代码片段中从
    `a` 到 `b` 的重构这样的重构将是安全的。
- en: 7.2 Thinking in terms of data flow
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 从数据流的角度思考
- en: 'You can write entire programs with function composition. Each function somehow
    processes its input, and the output becomes the input to the following function.
    When you do this, you start to look at your program in terms of data flow: the
    program is just a set of functions, and data flows through the program through
    one function and into the next. Figure 7.1 illustrates a linear flow—the simplest
    and most useful kind.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用函数组合编写整个程序。每个函数以某种方式处理其输入，输出成为下一个函数的输入。当你这样做时，你开始从数据流的角度看待你的程序：程序只是一组函数，数据通过一个函数流到下一个函数。图
    7.1 展示了一个线性流——最简单且最有用的类型。
- en: '![](Images/CH07_F01_Buonanno2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F01_Buonanno2.png)'
- en: Figure 7.1 Data flowing through a sequence of functions
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 数据通过一系列函数流动
- en: 7.2.1 Using LINQ’s composable API
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 使用 LINQ 的可组合 API
- en: In the previous example, we made the `AbbreviateName` and `AppendDomain` methods
    chainable by making them extension methods. This is also the approach taken in
    the design of LINQ, and if you look at `System.Linq.Enumerable`, you’ll see that
    it contains dozens of extension methods for working with `IEnumerable`. Let’s
    look at an example of composing functions with LINQ.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过使 `AbbreviateName` 和 `AppendDomain` 方法成为扩展方法，使它们可链式调用。这也是 LINQ 设计中采取的方法，如果你查看
    `System.Linq.Enumerable`，你会看到它包含了许多用于处理 `IEnumerable` 的扩展方法。让我们看看使用 LINQ 组合函数的一个例子。
- en: Imagine that, given a population, you want to find the average earnings of the
    richest quartile (that is, the richest 25% of people in the target population).
    You could write something like the following listing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设给定一个群体，你想找到最富有的四分位数（即目标群体中最富有的 25% 的人）的平均收入。你可以编写如下所示的内容。
- en: Listing 7.3 Defining a query by chaining methods in `Linq.Enumerable`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 通过链式方法在 `Linq.Enumerable` 中定义查询
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how cleanly you can write this query using LINQ (compared to, say, writing
    the same query imperatively with control flow statements). You may have some sense
    that internally the code will iterate over the list and that `Take` will have
    an `if` check to only yield the requested number of items, but you don’t really
    care. Instead, you can lay out your function calls in the form of a flat workflow—a
    linear sequence of instructions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你可以如何干净地使用 LINQ 编写这个查询（与使用控制流语句强制性地编写相同的查询相比）。你可能有一种感觉，内部代码将遍历列表，并且 `Take`
    将有一个 `if` 检查来只返回请求的项目数，但你并不真的关心。相反，你可以以扁平工作流的形式安排你的函数调用——一系列指令的线性序列：
- en: Sort the population (richest at the top).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对人口进行排序（最富有的人排在顶部）。
- en: Only take the top 25%.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只取前 25%。
- en: Take each person’s earnings.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取每个人的收入。
- en: Compute their average.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算它们的平均值。
- en: 'Notice how similar the code is to the workflow description. Let’s look at it
    in terms of data flow: you can see the `AverageEarningsOfRichestQuartile` function
    as a simple program. Its input is a `List<Person>`, and the output is a `decimal`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码与工作流描述的相似性。让我们从数据流的角度来看它：你可以将 `AverageEarningsOfRichestQuartile` 函数视为一个简单的程序。它的输入是
    `List<Person>`，输出是 `decimal`。
- en: Furthermore, `AverageEarningsOfRichestQuartile` is effectively the composition
    of four functions, so that the input data flows through four transformative steps
    and is, thus, stepwise transformed into the output value as figure 7.2 shows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AverageEarningsOfRichestQuartile` 实际上是四个函数的组合，因此输入数据通过四个转换步骤，如图 7.2 所示，逐步转换为输出值。
- en: '![](Images/CH07_F02_Buonanno2.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F02_Buonanno2.png)'
- en: Figure 7.2 Data flow through the `AverageEarningsOfRichestQuartile` function
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 `AverageEarningsOfRichestQuartile` 函数中的数据流
- en: 'The first function, `OrderByDescending`, preserves the type of the data and
    yields a population sorted by earnings. The second step also preserves the type
    of the data but changes the cardinality: if the input population is composed of
    *n* people, `Take` now only yields *n*/4 people. `Select` preserves the cardinality
    but changes the type to a list of `decimal`s, and `Average` again changes the
    type to return a single `decimal` value.[²](#pgfId-1123688)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `OrderByDescending` 保留了数据的类型，并按收入对人口进行排序。第二步也保留了数据的类型，但改变了基数：如果输入的人口由
    *n* 个人组成，`Take` 现在只返回 *n*/4 个人。`Select` 保留了基数，但将类型改为 `decimal` 的列表，而 `Average`
    再次将类型改为返回单个 `decimal` 值。[²](#pgfId-1123688)
- en: Let’s try to generalize this idea of data flow so that it applies not only to
    queries on `IEnumerable` but to data in general. When something of interest happens
    in your program (a request, a mouse click, or simply your program being started),
    you can think of that something as *input*. That input, which is data, then goes
    through a series of transformations as the data flows through a sequence of functions
    in your program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将数据流的概念推广，使其不仅适用于对 `IEnumerable` 的查询，而且适用于一般数据。当你的程序中发生某些有趣的事情（一个请求、鼠标点击，或者简单地程序启动），你可以将这个“某些事情”视为
    *输入*。这个输入，即数据，然后通过一系列转换，作为数据通过程序中一系列函数的流动。
- en: 7.2.2 Writing functions that compose well
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 编写可组合的函数
- en: The simple `AverageEarningsOfRichestQuartile` function shown in listing 7.3
    demonstrates how the design of the LINQ library allows you to compose general-purpose
    functions into specific queries. There are some properties that make some functions
    more composable than others:[³](#pgfId-1123699)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 中所示的简单 `AverageEarningsOfRichestQuartile` 函数展示了 LINQ 库的设计如何允许你将通用函数组合成特定查询。有些属性使得某些函数比其他函数更易于组合：[³](#pgfId-1123699)
- en: '*Pure*—If your function has side effects, it’s less reusable.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纯函数*——如果你的函数有副作用，它的可重用性就较低。'
- en: '*Chainable*—A `this` argument (implicit on instance methods and explicit on
    extension methods) makes it possible to compose through chaining.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可链式*——`this` 参数（实例方法中隐式存在，扩展方法中显式存在）使得通过链式组合成为可能。'
- en: '*General*—The more specific the function, the fewer cases where it’s useful
    to compose it.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通用*——函数越具体，可用于组合的情况就越少。'
- en: '*Shape-preserving*—The function preserves the shape of the structure, so if
    it takes an `IEnumerable`, it returns an `IEnumerable`, and so on.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*形状保留*——函数保留结构的形状，因此如果它接受 `IEnumerable`，则返回 `IEnumerable`，依此类推。'
- en: And, naturally, functions are more composable than actions. Because an `Action`
    has no output value, it’s a dead end, so it can only come at the end of a pipeline.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，函数比操作更易于组合。因为 `Action` 没有输出值，它是一个死胡同，所以它只能位于管道的末尾。
- en: Notice that the LINQ functions we’ve used all score 100% based on these criteria,
    with the exception of `Average`, which is not shape-preserving. Also note that
    the core functions we defined in the `Option` API do well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的LINQ函数根据这些标准都得了100%，除了`Average`，它不具备形状保持性。此外，请注意我们在`Option` API中定义的核心函数表现良好。
- en: 'How composable is `AverageEarningsOfRichestQuartile`? Well, about 40%: it’s
    pure, and it has an output value, but it’s not an extension method, and it’s extremely
    specific. To demonstrate this, look at some code that consumes the function as
    part of a unit test:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`AverageEarningsOfRichestQuartile`的可组合性如何？嗯，大约40%：它是纯函数，并且有一个输出值，但它不是一个扩展方法，而且它非常具体。为了演示这一点，看看以下作为单元测试一部分消耗该函数的代码：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The test passes, but the code also shows that `AverageEarningsOfRichestQuartile`
    doesn’t share the qualities of the LINQ methods it’s composed of: it’s not chainable,
    and it’s so specific that you’d hardly hope to reuse it. Let’s change that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了，但代码也显示`AverageEarningsOfRichestQuartile`不具备其组合的LINQ方法的特性：它不可链式调用，而且它非常具体，你几乎不希望重用它。让我们改变这一点：
- en: 'Split it into two more general functions: `AverageEarnings` (so you can query
    the average earnings for any segment of the population) and `RichestQuartile`
    (after all, there are many other properties of the richest quartile you may be
    interested in).'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拆分为两个更通用的函数：`AverageEarnings`（这样你可以查询任何人口段的平均收入）和`RichestQuartile`（毕竟，你可能对最富有的四分之一的许多其他属性感兴趣）。
- en: 'Make them extension methods so they can be chained:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们做成扩展方法，以便它们可以链式调用：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice how easy it was to do this refactoring! This is because of the compositional
    nature of the function we refactored: the new functions just compose fewer of
    the original building blocks. (If you had an implementation of the same logic
    with `for` and `if` statements, the refactoring would probably not have been as
    easy.) You can now rewrite the test as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意进行这种重构是多么容易！这是因为我们重构的函数的组合性质：新函数只是组合了更少的原始构建块。（如果你有一个使用`for`和`if`语句的逻辑实现，重构可能不会这么容易。）你现在可以按如下方式重写测试：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see how much more readable the test is now. By refactoring to smaller
    functions and to the extension method syntax, you’ve created more composable functions
    and a more readable interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到测试的阅读性有多好了。通过重构为更小的函数和扩展方法语法，你创建了更多可组合的函数和更易读的接口。
- en: TIP If you compose two pure functions, the resulting function is also pure,
    giving you all the benefits discussed in chapter 3\. As a result, libraries consisting
    mainly of pure, composable functions (like LINQ) tend to be powerful and pleasant
    to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你组合两个纯函数，结果函数也是纯函数，这为你提供了第3章中讨论的所有好处。因此，主要由纯、可组合函数组成的库（如LINQ）往往功能强大且易于使用。
- en: In this section, you’ve seen how LINQ provides (among many other things) a set
    of readily composable functions that work effectively with `IEnumerable`. Next,
    we’ll see how we can use declarative, flat workflows when working with `Option`.
    Let’s start by clarifying what we mean by workflows and why they matter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你看到了LINQ如何提供（许多其他事物中）一套易于组合的函数，这些函数与`IEnumerable`一起工作非常有效。接下来，我们将看到如何在使用`Option`时使用声明性、扁平的工作流程。让我们首先明确我们所说的“工作流程”是什么，以及为什么它很重要。
- en: 7.3 Programming workflows
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 编程工作流程
- en: Workflows are a powerful way of understanding and expressing application requirements.
    A *workflow* is a meaningful sequence of operations leading to a desired result.
    For example, a cooking recipe describes the workflow for preparing a dish.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程是理解和表达应用程序需求的一种强大方式。一个*工作流程*是一系列有意义的操作序列，旨在达到一个期望的结果。例如，烹饪食谱描述了准备菜肴的工作流程。
- en: Workflows can be effectively modeled through function composition. Each operation
    in the workflow can be performed by a function, and these functions can be composed
    into *function pipelines* that perform the workflow, just as you saw in the previous
    example involving data flowing through different transformations in a LINQ query.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程可以通过函数组合有效地建模。工作流程中的每个操作都可以由一个函数执行，这些函数可以组合成*函数管道*，执行工作流程，就像你在上一个例子中看到的那样，涉及数据在LINQ查询中通过不同的转换流动。
- en: 'We’re now going to look at a more complex workflow of a server processing a
    command. The scenario is that of a user requesting to make a money transfer through
    the Bank of Codeland (BOC) online banking application. We’re only concentrating
    on the server side, so the workflow is kicked off when the server receives a request
    to make a transfer. We can write a specification for the workflow as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看服务器处理命令的更复杂的工作流程。场景是用户通过Codeland银行（BOC）的在线银行应用程序请求进行货币转账。我们只关注服务器端，因此工作流程在服务器接收到转账请求时启动。我们可以为工作流程编写以下规范：
- en: Validate the requested transfer.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证请求的转移。
- en: Load the account.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载账户。
- en: If the account has sufficient funds, debit the amount from the account.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果账户有足够的资金，则从账户中扣除金额。
- en: Persist the changes to the account.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改持久化到账户中。
- en: Wire the funds via the SWIFT network.[⁴](#pgfId-1123761)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SWIFT网络转账资金。[⁴](#pgfId-1123761)
- en: 7.3.1 A simple workflow for validation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 验证的一个简单工作流程
- en: 'The entire money transfer workflow is fairly complex, so to get us started,
    let’s simplify it as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 整个货币转账工作流程相当复杂，为了让我们开始，让我们将其简化如下：
- en: Validate the requested transfer.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证请求的转移。
- en: Book the transfer (all subsequent steps).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预订转移（所有后续步骤）。
- en: Let’s say that all the steps following validation are part of the subworkflow
    of actually booking the transfer, which should only be triggered if validation
    passes (see figure 7.3).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设验证之后的所有步骤都是实际预订转移的子工作流程的一部分，这个子工作流程只有在验证通过的情况下才会被触发（见图7.3）。
- en: '![](Images/CH07_F03_Buonanno2.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F03_Buonanno2.png)'
- en: 'Figure 7.3 Example workflow: validating a request before processing it'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 示例工作流程：在处理之前验证请求
- en: 'Let’s take a stab at implementing this high-level workflow. Assume that the
    server uses ASP.NET Core to expose an HTTP API and that it’s set up so that requests
    are authenticated and routed to the appropriate MVC controller (in section 9.5.3,
    I’ll show you how to build Web APIs without the need for controllers), making
    it the entry point for implementing the workflow:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试实现这个高级工作流程。假设服务器使用ASP.NET Core公开HTTP API，并且已经设置好，以便请求被身份验证并路由到适当的MVC控制器（在9.5.3节中，我将向您展示如何构建不需要控制器的Web
    API），使其成为实现工作流程的入口点：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ `POST` requests to this route are routed to this method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向此路由的`POST`请求被路由到该方法。
- en: ❷ Deserializes the request body into a `MakeTransfer`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将请求体反序列化为`MakeTransfer`
- en: 'The details about the requested transfer are captured in a `MakeTransfer` type,
    which is sent in the body of the user’s request. Validation is delegated to a
    service on which the controller depends, which implements this interface:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请求转移的详细信息被捕获在一个`MakeTransfer`类型中，该类型包含在用户请求的主体中。验证委托给控制器所依赖的服务，该服务实现了此接口：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now to the interesting part, the workflow itself:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是更有趣的部分，工作流程本身：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That’s the imperative approach of explicit control flow. I’m always wary of
    using `if`s: a single `if` may look harmless, but if you start allowing one `if`,
    nothing is keeping you from having dozens of nested `if`s as additional requirements
    come in, and the complexity that ensues is what makes applications error-prone
    and difficult to reason about. Next, we’ll look at how to use function composition
    instead.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是显式控制流的命令式方法。我总是对使用`if`持谨慎态度：一个单独的`if`可能看起来无害，但如果你开始允许一个`if`，随着额外要求的增加，没有什么可以阻止你拥有数十个嵌套的`if`，随之而来的复杂性使得应用程序易于出错且难以推理。接下来，我们将看看如何使用函数组合来解决这个问题。
- en: 7.3.2 Refactoring with data flow in mind
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 考虑数据流进行重构
- en: Remember that idea we had about data flowing through various functions? Let’s
    try to think of the transfer request as data flowing through validation and into
    the `Book` method that performs the transfer. Figure 7.4 shows how this would
    look.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们关于数据通过各种函数流动的想法？让我们尝试将转移请求视为数据通过验证并流入执行转账的`Book`方法。图7.4显示了这将如何看起来。
- en: '![](Images/CH07_F04_Buonanno2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F04_Buonanno2.png)'
- en: Figure 7.4 Viewing validation as a step in the data flow
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 将验证视为数据流中的一个步骤
- en: 'There’s a bit of a problem with types: `IsValid` returns a Boolean, whereas
    `Book` requires a `MakeTransfer` object, so these two functions don’t compose,
    as figure 7.5 illustrates.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型上有点问题：`IsValid`返回一个布尔值，而`Book`需要一个`MakeTransfer`对象，因此这两个函数不能组合，如图7.5所示。
- en: '![](Images/CH07_F05_Buonanno2.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F05_Buonanno2.png)'
- en: Figure 7.5 A type mismatch preventing function composition
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 类型不匹配阻止函数组合
- en: 'Furthermore, we need to ensure that the request data flows through the validation
    and into `Book` *only* if it passes validation. This is where `Option` can help
    us: we can use `None` to represent an invalid transfer request and `Some<MakeTransfer>`
    for a valid one.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要确保只有当请求数据通过验证后，它才会流入`Book`。这就是`Option`能帮到我们的地方：我们可以使用`None`来表示无效的传输请求，而使用`Some<MakeTransfer>`来表示有效的请求。
- en: Notice that, in doing so, we’re expanding the meaning we give to `Option`. We
    interpret `Some` not just to indicate the presence of data, but also the presence
    of *valid* data, just like we do in the smart constructor pattern. We can now
    rewrite the controller method as the following listing demonstrates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个过程中，我们正在扩展我们对`Option`赋予的意义。我们不仅将`Some`解释为表示数据的存在，而且表示*有效*数据的存在，就像我们在智能构造器模式中所做的那样。现在，我们可以像以下列表所示那样重写控制器方法。
- en: Listing 7.4 Using `Option` to represent passing/failing validation
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 使用`Option`表示通过/失败验证
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We lift the transfer data into an `Option` and apply the `IsValid` predicate
    with `Where`; this yields a `None` if validation fails, in which case, `Book`
    won’t be called. In this example, `Where` is the highly composable function that
    allows us to glue everything together. This style may be unfamiliar, but it’s
    actually very readable: “Keep the transfer if it’s valid, then book it.”'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传输数据提升到`Option`中，并使用`Where`应用`IsValid`谓词；如果验证失败，则返回`None`，在这种情况下，`Book`不会被调用。在这个例子中，`Where`是一个高度可组合的函数，它允许我们将所有东西粘合在一起。这种风格可能不熟悉，但实际上非常易于阅读：“如果传输有效，则保留传输。”
- en: 7.3.3 Composition leads to greater flexibility
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 组合带来更大的灵活性
- en: Once you have a workflow in place, it becomes easy to make changes, such as
    adding a step to the workflow. Suppose you want to normalize the request before
    validating it so that things like whitespace and casing don’t cause validation
    to fail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个工作流程，就很容易进行更改，比如向工作流程中添加一个步骤。假设你希望在验证之前规范化请求，以便像空白和大小写这样的问题不会导致验证失败。
- en: How would you go about it? You need to define a function that performs the new
    step and then integrate it into your workflow. The following listing shows how
    to do this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何做？你需要定义一个执行新步骤的函数，然后将其集成到你的工作流程中。以下列表显示了如何做到这一点。
- en: Listing 7.5 Adding a new step to an existing workflow
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 向现有工作流程添加新步骤
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Plugs a new step into the workflow
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将新步骤插入到工作流程中
- en: More generally, if you have a business workflow, you should aim to express it
    by composing a set of functions, where *each function represents a step in the
    workflow*, and their composition represents the workflow itself. Figure 7.6 shows
    this one-to-one translation from steps in the workflow to functions in a pipeline.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，如果你有一个业务工作流程，你应该旨在通过组合一组函数来表示它，其中*每个函数代表工作流程中的一步*，它们的组合代表工作流程本身。图7.6显示了从工作流程步骤到管道函数的一对一转换。
- en: '![](Images/CH07_F06_Buonanno2.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F06_Buonanno2.png)'
- en: Figure 7.6 Modeling a linear workflow with function composition
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 使用函数组合建模线性工作流程
- en: To be precise, in this case we’re not composing these functions directly—as
    you’ve seen, the signatures don’t allow this—but rather as arguments to the HOFs
    defined in `Option`, as figure 7.7 shows.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要精确地说，在这种情况下，我们并不是直接组合这些函数——正如你所看到的，签名不允许这样做——而是将它们作为定义在`Option`中的HOFs（高阶函数）的参数，如图7.7所示。
- en: '![](Images/CH07_F07_Buonanno2.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F07_Buonanno2.png)'
- en: Figure 7.7 The `Option` API helps us compose existing functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 `Option` API帮助我们组合现有函数。
- en: Next, let’s see how we can implement the rest of the workflow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何实现工作流程的其余部分。
- en: 7.4 An introduction to functional domain modeling
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 函数域建模简介
- en: Domain modeling means creating a representation for the entities and behaviors
    specific to the business domain in question. In this case, we need a representation
    for the bank account from which the transferred funds will be debited. We’ll look
    at domain modeling in more detail in chapter 11, but it’s good to see the fundamentals
    in the current scenario.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 域建模意味着为特定业务领域的实体和行为创建表示。在这种情况下，我们需要一个表示将从其中扣除转账资金的银行账户的表示。我们将在第11章中更详细地探讨域建模，但在当前场景中了解基础知识是很好的。
- en: Let’s start with a ridiculously simplistic representation of a bank account
    that just captures the account balance. This is enough to illustrate the fundamental
    differences between the OO and functional approaches. The following listing shows
    how an OO implementation could look.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的银行账户表示开始，它只捕获账户余额。这足以说明面向对象和函数式方法之间的基本区别。以下列表展示了面向对象实现可能的样子。
- en: Listing 7.6 In OOP, objects capture both data and behavior
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 在面向对象编程中，对象同时捕获数据和行为
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In OOP, data and behavior live in the same object, and methods in the object
    can typically modify the object’s state. By contrast, in FP data is captured with
    “dumb” data objects while behavior is encoded in functions, so we’ll separate
    the two. We’ll use an `AccountState` object that only contains state and a static
    `Account` class that contains functions for interacting with an account.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，数据和操作都存在于同一个对象中，对象中的方法通常可以修改对象的状态。相比之下，在函数式编程中，数据通过“愚蠢”的数据对象捕获，而行为则编码在函数中，因此我们将它们分开。我们将使用一个只包含状态的
    `AccountState` 对象和一个包含与账户交互的函数的静态 `Account` 类。
- en: 'More importantly, notice how the preceding implementation of `Debit` is full
    of side effects: exceptions if business validation fails and state mutation. Instead,
    we’re going to make `Debit` a pure function. Instead of modifying the existing
    instance, we’ll return a new `AccountState` with the new balance.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，注意前面 `Debit` 的实现充满了副作用：如果业务验证失败会抛出异常，并且会改变状态。相反，我们将使 `Debit` 成为一个纯函数。而不是修改现有的实例，我们将返回一个新的
    `AccountState` 对象，其中包含新的余额。
- en: What about avoiding the debit if the funds on the account are insufficient?
    Well, by now you should have learned the trick! Use `None` to signal an invalid
    state and skip the following computations! The following listing provides a functional
    counterpart to the code in listing 7.6.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果账户上的资金不足，如何避免借记操作？嗯，到现在你应该已经学会了这个技巧！使用 `None` 来表示无效状态并跳过以下计算！以下列表提供了列表 7.6
    中代码的函数式对应版本。
- en: Listing 7.7 FP separates data and behavior
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 函数式编程分离数据和行为
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ An immutable record, only containing data
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个不可变的记录，只包含数据
- en: ❷ Only contains pure logic
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只包含纯逻辑
- en: ❸ `None` here signals that the debit operation failed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `None` 在这里表示借记操作失败。
- en: ❹ `Some` wraps the new state of the account as a result of the operation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `Some` 将操作结果作为新账户状态包装。
- en: 'Notice how the OO implementation of `Debit` in listing 7.6 isn’t composable:
    it has side effects and returns `void`. The functional counterpart in listing
    7.7 is completely different: it’s a pure function and returns a value, which can
    be used as input to the next function in the chain. Next, we’ll integrate this
    into the end-to-end workflow.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表 7.6 中的面向对象 `Debit` 实现不是可组合的：它有副作用并返回 `void`。列表 7.7 中的函数式对应版本则完全不同：它是一个纯函数并返回一个值，这个值可以用作链中下一个函数的输入。接下来，我们将将其集成到端到端工作流程中。
- en: 7.5 An end-to-end server-side workflow
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 端到端服务器端工作流程
- en: 'Now that we have the main workflow skeleton and our simple domain model in
    place, we’re ready to complete the end-to-end workflow. We still need to implement
    the `Book` function, which should do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了主要工作流程骨架和简单的领域模型，我们准备完成端到端工作流程。我们仍然需要实现 `Book` 函数，它应该执行以下操作：
- en: Load the account.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载账户。
- en: If the account has sufficient funds, debit the amount from the account.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果账户有足够的资金，则从账户中扣除金额。
- en: Persist the changes to the account.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更改持久化到账户中。
- en: Wire the funds via the SWIFT network.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 SWIFT 网络转账资金。
- en: 'Let’s define two services that capture DB and SWIFT access:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义两个服务来捕获数据库和 SWIFT 访问：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using these interfaces is still an OO pattern, but let’s stick to it for now
    (you’ll see how to use *just* functions in chapter 9). Note that `IRepository.Get`
    returns an `Option` to acknowledge the fact that there’s no guarantee that an
    item will be found for any given `Guid`. The following listing displays the fully
    implemented controller, including the `Book` method that was missing until now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些接口仍然是一个面向对象的模式，但现在让我们坚持使用它（你将在第 9 章中看到如何只使用函数）。注意 `IRepository.Get` 返回一个
    `Option`，以承认对于任何给定的 `Guid`，没有保证找到项目。以下列表显示了完全实现的控制器，包括之前缺失的 `Book` 方法。
- en: Listing 7.8 Implementation of the end-to-end workflow in the controller
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 控制器中端到端工作流程的实现
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s look at the newly added `Book` method. Notice that `accounts.Get` returns
    an `Option` (in case no account was found with the given ID), and `Debit` also
    returns an `Option` (in case there were insufficient funds). Therefore, we compose
    these two operations with `Bind`. Finally, we use `ForEach` to perform the side
    effects we need: saving the account with the new balance and wiring the funds
    to SWIFT.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新添加的 `Book` 方法。注意，`accounts.Get` 返回一个 `Option`（如果找不到具有给定 ID 的账户），`Debit`
    也返回一个 `Option`（如果资金不足）。因此，我们使用 `Bind` 组合这两个操作。最后，我们使用 `ForEach` 来执行所需的副作用：保存具有新余额的账户并将资金汇入
    SWIFT。
- en: There are a couple of obvious shortcomings in the overall solution. First, we’re
    effectively using `Option` to stop the computation if something goes wrong along
    the way, but we’re not giving any feedback to the user as to whether the request
    was successful or why. In chapter 8, you’ll see how to remedy this with `Either`
    and related structures; this allows you to capture error details without fundamentally
    altering the approach shown here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 整体解决方案中存在一些明显的不足。首先，我们实际上使用 `Option` 来在过程中出现错误时停止计算，但我们没有向用户提供任何反馈，说明请求是否成功或失败的原因。在第
    8 章中，您将看到如何使用 `Either` 和相关结构来解决这个问题；这允许您捕获错误详情，而不会从根本上改变这里展示的方法。
- en: 'Another problem is that saving the account and wiring the funds should be done
    atomically: if the process fails in the middle, we could have debited the funds
    without sending them to SWIFT. Solutions to this issue tend to be infrastructure-specific
    and aren’t specific to FP.[⁵](#pgfId-1123987) Now that I’ve come clean about what’s
    missing, let’s discuss the good bits.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在保存账户和汇款资金时应该原子化操作：如果过程在中间失败，我们可能会扣除资金而未将其发送到 SWIFT。解决这个问题的方法通常是特定于基础设施的，并不特定于函数式编程。[⁵](#pgfId-1123987)
    既然我已经坦白地说明了缺少什么，让我们来讨论一下好的方面。
- en: 7.5.1 Expressions vs. statements
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 表达式与语句
- en: Something that should stand out when you look at the controller in listing 7.8
    is that there are no `if` statements, no `for` statements, and so forth. In fact,
    there are practically *no statements* at all!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看第 7.8 节中的控制器时，应该注意到其中没有 `if` 语句，没有 `for` 语句，等等。事实上，几乎没有任何语句！
- en: One fundamental difference between the functional and imperative style is that
    imperative code relies on statements; functional code relies on expressions. (For
    a refresher on how these differ, see the “Expressions, statements, declarations”
    sidebar.) In essence, expressions have a value; statements don’t. While expressions
    such as function calls *can* have side effects, statements *only* have side effects,
    so they don’t compose.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式风格和命令式风格之间的一个基本区别是，命令式代码依赖于语句；函数式代码依赖于表达式。（关于这些差异的复习，请参阅“表达式、语句、声明”侧边栏。）本质上，表达式具有值；语句没有。虽然函数调用等表达式
    *可以* 有副作用，但语句 *只有* 有副作用，因此它们不能组合。
- en: 'If you create workflows by composing functions as we have, side effects naturally
    gravitate towards the end of the workflow: functions like `ForEach` don’t have
    a useful return value, so that’s where the pipeline ends. This helps to isolate
    side effects, even visually.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像我们这样通过组合函数来创建工作流程，副作用自然会聚集在工作流程的末尾：例如，`ForEach` 函数没有有用的返回值，所以那里就是管道的终点。这有助于隔离副作用，甚至从视觉上也是如此。
- en: The idea of programming without using statements can seem quite foreign at first,
    but as the code in this and previous chapters demonstrates, it’s perfectly feasible
    in C#. Notice that the only statements are the two within the last `ForEach`.
    This is fine because we want to have two side effects—there’s no point hiding
    that.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，不使用语句进行编程的想法可能相当陌生，但正如本章节和前几章节中的代码所展示的，在 C# 中这是完全可行的。请注意，唯一的语句是最后 `ForEach`
    中的两个。这是可以的，因为我们想要有两个副作用——隐藏这一点是没有意义的。
- en: I recommend you try coding using just expressions. It doesn’t guarantee good
    design, but it certainly promotes better design.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您尝试仅使用表达式进行编码。这并不能保证良好的设计，但它确实促进了更好的设计。
- en: Expressions, statements, declarations
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式、语句、声明
- en: '*Expressions* include anything that produces a value such as these:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式* 包括产生值的所有内容，例如这些：'
- en: Literals such as `123` or `"something"`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 `123` 或 `"something"` 这样的字面量
- en: Variables such as x
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 x 这样的变量
- en: 'Operators and operands such as `a || b`, `b ? x : y` or `new object()`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如 `a || b`、`b ? x : y` 或 `new object()` 这样的运算符和操作数'
- en: Expressions can be used wherever a value is expected; for example, as arguments
    in function invocations or as return values of a function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以在任何需要值的地方使用；例如，作为函数调用的参数或作为函数的返回值。
- en: '*Statements* are instructions to the program, such as assignments, conditionals
    (`if/else`), loops, and so on.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*语句*是程序的指令，例如赋值、条件（`if/else`）、循环等。'
- en: '*Invocations* are considered expressions if they produce a value, for example
    `"hello".ToUpper()` or `Math.Sqrt(Math.Abs(n) + m)`. They’re considered statements
    if they don’t; that is, if the method being invoked returns `void`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用*被认为是表达式，如果它们产生一个值，例如 `"hello".ToUpper()` 或 `Math.Sqrt(Math.Abs(n) + m)`。如果它们不产生值；也就是说，如果被调用的方法返回
    `void`，则被认为是语句。'
- en: '*Declarations* (of classes, methods, fields, and so on) are often considered
    statements but for the purpose of this discussion are best thought of as a category
    in their own right. Whether you prefer statements or expressions, declarations
    are equally necessary, so they’re best left out of the statements versus expressions
    argument.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明*（类、方法、字段等）通常被认为是语句，但为了讨论的目的，最好将其视为一个独立的类别。无论你更喜欢语句还是表达式，声明都是同样必要的，因此最好将它们排除在语句与表达式之争之外。'
- en: 7.5.2 Declarative vs. imperative
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 声明式与命令式
- en: 'When we prefer expressions to statements, our code becomes more declarative.
    It declares what’s being computed rather than instructing the computer on which
    specific operations to carry out. In other words, it’s higher-level and closer
    to the way in which we communicate with other human beings. For example, the top-level
    workflow in our controller reads as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更喜欢表达式而不是语句时，我们的代码变得更加声明式。它声明了正在计算的内容，而不是指示计算机执行哪些特定操作。换句话说，它是更高层次的，更接近我们与其他人类交流的方式。例如，我们控制器中的顶层工作流程如下所示：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Discounting things like `Map` and `Where`, which essentially act as glue between
    the operations, this reads much like the verbal, bullet-point definition of the
    workflow. This means the code is closer to the spoken language and, hence, easier
    to understand and to maintain. Let’s contrast the imperative and declarative styles
    in table 7.1.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 折扣掉像 `Map` 和 `Where` 这样的东西，它们本质上在操作之间充当粘合剂，这样读起来就像工作流程的口头、要点定义。这意味着代码更接近于口语，因此更容易理解和维护。让我们在表7.1中对比命令式和声明式风格。
- en: Table 7.1 Comparing the imperative and declarative styles
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 比较命令式和声明式风格
- en: '| Imperative | Declarative |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 命令式 | 声明式 |'
- en: '| Tells the computer what to do (for example, “Add this item to this list”).
    | Tells the computer what you want (for example, “Give me all the items that match
    a condition”). |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 告诉计算机做什么（例如，“将此项目添加到此列表”）。 | 告诉计算机你想要什么（例如，“给我所有符合条件的项目”）。|'
- en: '| Relies mainly on statements. | Relies mainly on expressions. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 主要依赖于语句。 | 主要依赖于表达式。|'
- en: '| Side effects are ubiquitous. | Side effects naturally gravitate toward the
    end of the expression evaluation.[^a](#pgfId-1124047) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 副作用无处不在。 | 副作用自然地倾向于表达式评估的末尾。[^a](#pgfId-1124047) |'
- en: '| Statements can be readily translated into machine instructions. | There is
    more indirection (hence, potentially more optimizations) in the process of translating
    expressions to machine instructions. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 语句可以轻松地翻译成机器指令。 | 在将表达式翻译成机器指令的过程中存在更多的间接引用（因此，可能存在更多的优化）。|'
- en: ^a This is because side-effecting functions don’t normally return a value that
    can be used in further evaluation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^a 这是因为副作用函数通常不会返回一个可以在进一步评估中使用的值。
- en: 'Another thing worth pointing out is that, because declarative code is higher-level,
    it’s hard to look at the implementation and see that it works without the confidence
    of unit tests. This is actually a good thing: it’s much better to convince yourself
    through unit tests than to rely on the false confidence of looking at the code
    and seeing that it looks like it’s doing the right thing.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得指出的是，由于声明式代码是更高层次的，很难在没有单元测试的信心下查看实现并看到它是否工作。这实际上是一件好事：通过单元测试来让自己信服比依赖查看代码并看到它看起来像是在做正确的事情的虚假信心要好得多。
- en: 7.5.3 The functional take on layering
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 层次化的函数式方法
- en: The implementation we’ve looked at sheds some light on a natural way to structure
    applications with function composition. In any reasonably complex application,
    we tend to introduce some form of *layering*, distinguishing a hierarchy of high-
    to low-level components where the highest-level components are entry points into
    the application (in our example, the controller), and the lowest are exit points
    (in our example, the repository and SWIFT service).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所探讨的实现为我们展示了以函数组合结构化应用程序的自然方式。在任何合理复杂的应用程序中，我们往往会引入某种形式的*分层*，区分从高级到低级组件的层次结构，其中最高级组件是应用程序的入口点（在我们的例子中是控制器），而最低级的是出口点（在我们的例子中是存储库和SWIFT服务）。
- en: Unfortunately, I’ve worked on many projects where layering is more of a curse
    than a blessing, as you need to traverse several layers for any operation. This
    is because there’s a tendency to structure invocations between layers, as in figure
    7.8.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我参与过许多项目，其中分层更像是一种诅咒而不是祝福，因为任何操作都需要跨越几个层次。这是因为存在在层之间结构调用调用的倾向，如图7.8所示。
- en: '![](Images/CH07_F08_Buonanno2.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F08_Buonanno2.png)'
- en: Figure 7.8 An unhelpful way to structure interaction between layers
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 层之间交互的无用结构
- en: 'In this approach, there’s an implicit assumption that a layer should only call
    into an immediately adjacent layer. This makes the architecture rigid. Furthermore,
    it means that the whole implementation will be impure: because the lowest-level
    components have side effects (they typically access the DB or external APIs),
    everything above is also impure—a function that calls an impure function is itself
    impure.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，存在一个隐含的假设，即层应该只调用相邻的层。这使得架构变得僵化。此外，这意味着整个实现将是非纯的：因为最低级组件有副作用（它们通常访问数据库或外部API），所以其上的一切也是非纯的——调用非纯函数的函数本身也是非纯的。
- en: In the approach demonstrated in this chapter, the interaction between layers
    looks more like figure 7.9.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章展示的方法中，层之间的交互看起来更像图7.9。
- en: '![](Images/CH07_F09_Buonanno2.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F09_Buonanno2.png)'
- en: Figure 7.9 A top-level workflow composing functions exposed by lower-level components
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 顶层工作流程组合了低级组件公开的函数
- en: 'A higher-level component can depend on any lower-level component but not vice
    versa. This is a more flexible and effective approach to layering. In our example,
    there’s a top-level workflow that composes functions exposed by lower-level components.
    There are a couple of advantages here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 高级组件可以依赖于任何低级组件，但反之则不然。这是一种更灵活、更有效的分层方法。在我们的例子中，有一个顶层工作流程，它组合了低级组件公开的函数。这里有几个优点：
- en: '*You get a clear, synthetic overview of the workflow within the top-level component.*
    This doesn’t preclude you from defining subworkflows within a lower-level component.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您可以在顶级组件中获得清晰的综合工作流程概述*。这并不妨碍您在低级组件中定义子工作流程。'
- en: '*Mid-level components can be pure.* In our example, the interaction between
    components looks like figure 7.10.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中级组件可以是纯函数的*。在我们的例子中，组件之间的交互看起来像图7.10。'
- en: '![](Images/CH07_F10_Buonanno2.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F10_Buonanno2.png)'
- en: Figure 7.10 Mid-level components can be pure.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 中级组件可以是纯函数的。
- en: As you can see, the domain representation can (and should!) consist of pure
    functions only because there’s no interaction with lower-level components; there’s
    only computation of a result based on inputs. The same could be true of other
    functionality like validation (depending on what the validation consists of).
    Therefore, this approach helps you to isolate side effects and facilitates testing.
    Because the domain model and other mid-level components are pure functions, they
    can easily be tested without the need for mocks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，领域表示可以（并且应该！）仅由纯函数组成，因为没有与低级组件的交互；它只是基于输入计算结果。其他功能（如验证，取决于验证的内容）也可能如此。因此，这种方法有助于您隔离副作用并便于测试。由于领域模型和其他中级组件是纯函数，因此它们可以很容易地测试，无需模拟。
- en: Exercises
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Without looking at any code or documentation, write the type of the functions
    `OrderBy`, `Take`, and `Average`, which were used to implement `AverageEarningsOfRichestQuartile`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不看任何代码或文档，写出`OrderBy`、`Take`和`Average`函数的类型，这些函数被用来实现`AverageEarningsOfRichestQuartile`。
- en: 'Check your answer with the MSDN documentation: [http://mng.bz/MvwD](http://mng.bz/MvwD).
    How is `Average` different?'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用MSDN文档检查您的答案：[http://mng.bz/MvwD](http://mng.bz/MvwD)。`Average`与`AverageEarningsOfRichestQuartile`有何不同？
- en: Implement a general-purpose `Compose` function that takes two unary functions
    and returns the composition of the two.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个通用`Compose`函数，它接受两个一元函数并返回这两个函数的组合。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Function composition means combining two or more functions into a new function,
    and it’s widely used in FP.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合意味着将两个或更多函数组合成一个新的函数，这在函数式编程（FP）中得到了广泛应用。
- en: In C#, the extension method syntax allows you to use function composition by
    chaining methods.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中，扩展方法语法允许你通过链式调用方法来使用函数组合。
- en: Functions lend themselves to being composed if they are pure, chainable, and
    shape-preserving.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数是纯的、可链式调用的且保持形状不变，它们就适合进行组合。
- en: 'Workflows are sequences of operations that can be effectively expressed in
    your programs through function pipelines: one function for each step of the workflow
    with the output of each function fed into the next.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作流是一系列操作，可以通过函数管道在你的程序中有效地表达：每个工作流步骤一个函数，每个函数的输出被传递到下一个函数。
- en: The LINQ library has a rich set of easily composable functions to work with
    `IEnumerable`s, and you can use it as inspiration to write your own APIs.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ库提供了一套丰富的易于组合的函数，用于处理`IEnumerable`，你可以从中获得灵感来编写自己的API。
- en: Functional code prefers expressions over statements, unlike imperative code.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式代码偏好表达式而非语句，这与命令式代码不同。
- en: Relying on expressions leads to your code becoming more declarative and, hence,
    more readable.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于表达式会导致你的代码变得更加声明式，因此更易于阅读。
- en: '* * *'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ There’s a second, even simpler functor law: if you `Map` the identity function
    (`x` `→` `x`) over a functor `f`, the resulting functor is identical to `f`. Simply
    put, the identity function should hold in the elevated world of functors.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 存在第二个甚至更简单的函子法则：如果你在函子`f`上`Map`一个恒等函数（`x` `→` `x`），得到的函子与`f`相同。简单来说，恒等函数应该在函子的提升世界中成立。
- en: ² `Average` also causes the whole chain of methods to be evaluated because it’s
    the only “greedy” method in the chain.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ² `Average`也会导致整个方法链被评估，因为它是链中唯一的“贪婪”方法。
- en: ³ These are general guidelines. It will always be possible to compose functions
    that don’t have these properties, but in practice, these properties are good indicators
    of how easy and useful it will be to compose those functions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 这些只是一般性指南。总是有可能组合不具有这些特性的函数，但在实践中，这些特性是判断组合这些函数的容易程度和有用性的良好指标。
- en: ⁴ SWIFT is an interbank network; as far as we’re concerned, it’s just a third-party
    application with which we need to communicate.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ SWIFT是一个银行间网络；就我们而言，它只是一个我们需要与之通信的第三方应用程序。
- en: ⁵ This problem is difficult and fairly common in distributed architectures.
    If you’re storing the accounts in a database, you could be tempted to open a DB
    transaction, save the account within the transaction, wire the funds, and only
    commit once that’s done. This still leaves you unprotected if the process dies
    after wiring the funds but before committing the transaction. A thorough solution
    is to atomically create a single task, representing both operations, and have
    a process that performs both and removes the task only when *both* have successfully
    been carried out. This means that any of the operations are potentially performed
    more than once so provisions need to be made for the operations to be idempotent.
    A reference text on these sorts of problems and solutions is *Enterprise Integration
    Patterns* by Gregor Hohpe and Bobby Woolf (Addison-Wesley, 2004).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 这个问题在分布式架构中很常见且难度较大。如果你在数据库中存储账户，可能会倾向于打开一个数据库事务，在事务中保存账户，转账，并在完成后提交。但如果在转账后但在提交事务之前进程死亡，这仍然不能保护你。一个彻底的解决方案是原子性地创建一个单一的任务，代表这两个操作，并有一个执行这两个操作并在两者都成功执行后删除该任务的进程。这意味着任何操作都可能被多次执行，因此需要为操作提供幂等性。关于这类问题和解决方案的参考文献是Gregor
    Hohpe和Bobby Woolf合著的《企业集成模式》（Addison-Wesley，2004年）。
