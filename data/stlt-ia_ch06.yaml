- en: '7 The CEO Strikes Back: Supercharging our dashboard'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 CEO 反击：提升我们的仪表板
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Critically evaluating an app and resolving user feedback
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估应用并解决用户反馈
- en: Adding flexibility to Streamlit visualizations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Streamlit 可视化添加灵活性
- en: Improving usability by making commonly-used features easy to access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使常用功能易于访问来提高可用性
- en: Creating modal dialogs in Streamlit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Streamlit 中创建模态对话框
- en: Using query parameters to enable deeplinks in a Streamlit app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询参数在 Streamlit 应用中启用深链接
- en: When Python was first released, it lacked many of the features we rely on today.
    The Python we know and love has been carefully refined over the years—and that
    process is still ongoing. A big part of this evolution comes from the feedback
    of developers who actively build with the language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 首次发布时，它缺少了我们今天依赖的许多功能。我们熟悉并喜爱的 Python 已经经过多年的精心打磨——这个过程仍在继续。这个演变的一个很大部分来自于积极使用该语言的开发者的反馈。
- en: Indeed, no software is perfect at launch. Instead, it is refined over time,
    with a bugfix here and a new feature added there. The projects we build in this
    book are no exception.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，没有任何软件在发布时是完美的。相反，它需要随着时间的推移不断改进，这里修复一个错误，那里添加一个新功能。本书中构建的项目也不例外。
- en: In the previous chapter, we created a metrics dashboard for a company called
    Note n' Nib. In this one, we'll skip forward and see how users responded. We'll
    use their opinions and comments to revisit our app in a critical light and improve
    it. As we go through this process, we'll learn more about Streamlit visualizations,
    introduce modal dialogs and query parameters, and understand how to program an
    advanced, flexible dashboard.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为一家名为 Note n' Nib 的公司创建了一个指标仪表板。在这一章中，我们将跳过一段时间，看看用户是如何反应的。我们将使用他们的意见和评论，以批判性的眼光重新审视我们的应用程序，并对其进行改进。在这个过程中，我们将了解更多关于
    Streamlit 可视化的知识，介绍模态对话框和查询参数，并了解如何编写高级、灵活的仪表板。
- en: If Chapter 6 was about *launching* a dashboard based on user requirements, Chapter
    7 is about *landing* it, addressing our users' concerns and iterating on the app
    to ensure quality and satisfaction.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第 6 章是关于根据用户需求**发布**仪表板，那么第 7 章是关于**着陆**它，解决用户的问题，并对应用程序进行迭代以确保质量和满意度。
- en: 7.1 Feedback on the dashboard
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 仪表板的反馈
- en: The dashboard you built in the last chapter has made waves at Note n' Nib. For
    the first time, the company's executives can look up updated sales numbers, compare
    performance between products, and analyze trends on their own, without having
    to enlist help from Engineering.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一章中构建的仪表板在 Note n' Nib 公司引起了轰动。第一次，公司的管理层可以查找更新的销售数据，比较产品之间的性能，并自行分析趋势，而无需寻求工程部门的帮助。
- en: The CEO has requested that all staff meetings start with a review of the key
    sales metrics, which means that the top brass is now intimately familiar with
    your dashboard. Of course, with that kind of attention comes increased scrutiny,
    and you're not entirely surprised when, one Monday afternoon a few weeks after
    launch, you find an email from the CEO in your inbox.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CEO 要求所有员工会议都以回顾关键销售指标开始，这意味着高层现在对您的仪表板非常熟悉。当然，有了这样的关注，自然会带来更多的审查，所以在发布后的几周的一个周一下午，你在收件箱里收到
    CEO 的电子邮件，你并不完全感到惊讶。
- en: The email contains collated feedback about your dashboard from the higher-ups—essentially
    a wishlist of additional features for you to implement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这封电子邮件包含了高层对您的仪表板反馈的汇总——基本上是一个您要实现的新功能愿望清单。
- en: Well, there goes the rest of your week. You're excited about the work, though,
    since you get to play with Streamlit some more! Over the course of this chapter,
    we'll inspect and resolve each item of feedback.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你的这个星期就这样过去了。尽管如此，你对这项工作还是很兴奋的，因为你又能多玩一会儿 Streamlit！在本章的整个过程中，我们将检查并解决每一项反馈。
- en: 7.2 Granularity in the time series chart
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 时间序列图表的粒度
- en: 'The first bullet point in the email reads: "The time chart is useful in reviewing
    a few days of data, but it''s hard to make sense of for longer periods".'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件中的第一点写道：“时间图表在回顾几天数据时很有用，但对于更长时间的数据则难以理解”。
- en: Recall that our dashboard has a line chart showing a selected metric's evolution
    over time. For smaller date ranges (about a month or so), it works reasonably
    well (see the left side of figure 7.1), but for longer ones (say a year or more),
    it looks like the right side.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的仪表板有一个折线图，显示了选定指标随时间的变化。对于较短的日期范围（大约一个月左右），它工作得相当不错（见图 7.1 的左侧），但对于较长的日期范围（比如说一年或更长时间），它看起来就像图
    7.1 的右侧。
- en: '![image](../Images/ch07__image001.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image001.png)'
- en: Figure 7.1 The day granularity in the existing time chart works for small time
    frames like a month (left) but not for longer time frames (right)
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1 现有时间图表中的日粒度适用于像一个月这样的小时间框架（左），但不适用于更长的时间框架（右）。
- en: All the data is there, but there's so much of it that it's overwhelming. When
    considering *years* of data, we don't need to plot a single point for every date
    in the range.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据都在那里，但数据量如此之大以至于令人不知所措。当考虑 *多年* 的数据时，我们不需要在日期范围内的每一天都绘制一个点。
- en: You can see how doing so increases the number of individual markers in the chart;
    if we're observing a date range of two years, that's 365 x 2 = 730 points—far
    too many to interpret.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这样做是如何增加图表中单个标记的数量；如果我们观察的是两年的日期范围，那么就是 365 x 2 = 730 个点——太多以至于难以解释。
- en: So, how do we address this? A granularity of a single day is too much over a
    longer time horizon, but if we have a shorter date range, like a week or a month,
    it's reasonable. For longer ranges, we would probably want one marker for a week,
    a month, or perhaps even a year.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这个问题呢？在较长的时间范围内，单日粒度太多，但如果我们的日期范围较短，比如一周或一个月，这是合理的。对于更长的范围，我们可能希望有一个表示一周、一个月甚至一年的标记。
- en: The easiest solution would be to allow the user to pick the granularity they
    want. Let's tackle this now.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是允许用户选择他们想要的粒度。现在让我们来解决这个问题。
- en: 7.2.1 Enabling different time grains
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 启用不同的时间粒度
- en: To enable weekly, monthly, and yearly granularities, we first have to ensure
    our data *has* those fields, which it doesn't currently. Once we do, we'll be
    able to aggregate each metric to the right grain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用周、月和年粒度，我们首先必须确保我们的数据 *具有* 这些字段，目前它还没有。一旦我们做到了，我们就能将每个指标聚合到正确的粒度。
- en: Recall that the flow of data in our app starts with the `load_data` function
    in `data_loader.py`, which obtains the data from an external source, currently
    a CSV file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们应用中的数据流始于 `data_loader.py` 中的 `load_data` 函数，该函数从外部源获取数据，目前是一个 CSV 文件。
- en: This is followed by `prep_data` in `data_wrangling.py` where we rename the columns
    and add the `Day` field. This is also where we need to make changes to incorporate
    the other grains we want.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `data_wrangling.py` 中的 `prep_data` 后续进行，我们重命名列并添加 `Day` 字段。这也是我们需要进行更改以包含我们想要的其它粒度的地方。
- en: 'Go ahead and edit `prep_data` so it now looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就去编辑 `prep_data`，使其看起来像这样：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''re adding three new columns to the Pandas dataframe: `Week`, `Month` and
    `Year`. To obtain each field, we start with the `Day` column (`df[''Day'']`),
    convert it to a period, and then convert the result to a timestamp. Consider one
    such statement:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向 Pandas 数据框中添加三个新列：`Week`、`Month` 和 `Year`。为了获取每个字段，我们首先从 `Day` 列 (`df['Day']`)
    开始，将其转换为周期，然后将结果转换为时间戳。考虑以下这样的语句：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`.dt` here is used to access the date/time-related properties of the column
    in an element-wise manner. `to_period(''M'')` converts the `Day` column into a
    monthly "period" type internal to Pandas, representing a whole month rather than
    a specific point in time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`.dt` 用于以元素方式访问列的日期/时间相关属性。`to_period('M')` 将 `Day` 列转换为 Pandas 内部的月度“周期”类型，代表整个月而不是特定的时间点。
- en: We then use a second `.dt` accessor to get the date/time properties of the transformed
    column, and finally `.to_timestamp()` to convert each monthly period into a date
    representing the start of the month.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用第二个 `.dt` 访问器来获取转换列的日期/时间属性，最后使用 `.to_timestamp()` 将每个月度周期转换为表示月份开始的日期。
- en: For instance, if one of the elements we're operating on in `df['Day']` is the
    date `2024-07-12`, we end up with the date `2024-07-01`, the start of the corresponding
    month.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在操作 `df['Day']` 中的某个元素，而这个元素是日期 `2024-07-12`，我们最终得到的是日期 `2024-07-01`，即对应月份的开始。
- en: The other two statements that create the `Week` and `Year` columns are analogous,
    adding dates representing the start of the week and the year respectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Week` 和 `Year` 列的其他两个语句是类似的，分别添加表示周开始和年开始的日期。
- en: Elsewhere in the code—specifically within (other) functions in `data_wrangling.py`
    and `time_series_chart.py`—we've been treating `Day` as a hardcoded column name.
    Once we have these other columns, all we need to do in the backend is to introduce
    a variable to represent the grain instead.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的其他地方——特别是在 `data_wrangling.py` 和 `time_series_chart.py` 中的（其他）函数内——我们一直将
    `Day` 视为一个硬编码的列名。一旦我们有了这些其他列，我们只需要在后台引入一个变量来表示粒度即可。
- en: 'So, the function `get_metric_time_series` from `data_wrangling.py` would now
    look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`data_wrangling.py` 中的 `get_metric_time_series` 函数现在看起来是这样的：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And `get_time_series_chart` (in `time_series_chart.py`) becomes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `get_time_series_chart`（在 `time_series_chart.py` 中）变为：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In both cases, we''re making the same changes: adding `grain` as a new parameter
    in the function, and replacing `''Day''` wherever it occurs to `grain`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都在做同样的更改：在函数中添加 `grain` 作为新的参数，并将 `'Day'` 替换为 `grain`。
- en: 7.2.2 Creating a time grain selector
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 创建时间粒度选择器
- en: Now that we've wired up the functions that ultimately generate the time series
    chart to handle `grain` as a variable, we need to provide the user with a way
    to select what grain they want.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将生成时间序列图的函数连接起来，以处理作为变量的 `grain`，我们需要提供一个让用户选择他们想要的时间粒度的方式。
- en: st.select_slider
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.select_slider
- en: 'Let''s use a new Streamlit widget for this: `st.select_slider`, another selection
    element. `st.select_slider` is a cross between `st.selectbox`, which lets you
    pick a single value from a dropdown, and `st.slider`, which lets you choose a
    numeric value.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个新的 Streamlit 小部件来完成这个任务：`st.select_slider`，另一个选择元素。`st.select_slider`
    是 `st.selectbox` 和 `st.slider` 的结合，`st.selectbox` 允许你从下拉列表中选择单个值，而 `st.slider`
    允许你选择数值。
- en: You use it when you have a list of text options for users to pick from, but
    also want to impose some ordering on them. For instance, when you're creating
    options for a survey, "Strongly agree", "Agree", "Neutral", "Disagree", and "Strongly
    disagree" are strings, but they have a specific order to them—from the most to
    the least agreement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有用户可以选择的文本选项列表，但还想对它们施加一些顺序时，你会使用它。例如，当你创建调查选项时，“强烈同意”、“同意”、“中立”、“不同意”和“强烈不同意”是字符串，但它们有特定的顺序——从最同意到最不同意。
- en: In our case, the time grain options we want the user to see—"Day," "Week," "Month,"
    and "Year"—also have an order, from the smallest unit of time to the largest.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望用户看到的时间粒度选项——“日”、“周”、“月”和“年”——也有一个顺序，从最小的时间单位到最大的时间单位。
- en: 'For our purposes, we can use `st.select_slider` like this within the `time_series_chart`
    function in `time_series_chart.py`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们可以在 `time_series_chart.py` 中的 `time_series_chart` 函数内这样使用 `st.select_slider`：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`grain_options` here holds the ordered list of options, and is fed to the second
    parameter of `st.select_slider`, the first being the label to display. You''ll
    find these parameters very similar to those of `st.selectbox` and `st.radio`.
    `st.select_slider` returns the option selected by the user, which we store in
    `grain`, and pass as the new parameter we recently added to `get_time_series_chart`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`grain_options` 这里持有有序的选项列表，并将其提供给 `st.select_slider` 的第二个参数，第一个是显示的标签。你会发现这些参数与
    `st.selectbox` 和 `st.radio` 的参数非常相似。`st.select_slider` 返回用户选择的选项，我们将其存储在 `grain`
    中，并将其作为新添加到 `get_time_series_chart` 中的参数传递。'
- en: Save and run your app with `streamlit run <path to dashboard.py>` to get figure
    7.2
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `streamlit run <path to dashboard.py>` 命令保存并运行你的应用程序以获取图 7.2
- en: '![image](../Images/ch07__image002.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image002.png)'
- en: Figure 7.2 The line chart now has a time grain selector (see chapter_7/in_progress_01
    in the GitHub repo for the full code at this point)
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2 线形图现在有了一个时间粒度选择器（有关完整代码，请参阅 GitHub 仓库中的 chapter_7/in_progress_01）
- en: Play around with the grain selector. Using the month grain makes the chart much
    more palatable when viewing a long date range spanning multiple years.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用时间粒度选择器。使用月粒度在查看跨越多年多个日期范围的长时间范围内会使图表更加易于接受。
- en: 7.3 Interdependent filters
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 依赖性过滤器
- en: '"If I''ve already selected the ''Writing tools'' category, why does it still
    ask me if I want to see staples and calendars?" asks a verbatim comment in the
    email, reportedly from the CFO, one of the dashboard''s more passionate users.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我已经选择了‘书写工具’类别，为什么它仍然问我是否想查看订书机和日历？”邮件中的一条直接引语问道，据报道这是来自首席财务官，他是仪表板更热情的用户之一。
- en: You admit it's a valid question. She's referring to the filter bar in figure
    7.3, which doesn't take the existing selections into account while displaying
    options in the filter dropdowns, leading to nonsensical combinations such as "Writing
    tools" paired with "Paper clips."
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你承认这是一个有效的问题。她指的是图 7.3 中的过滤器栏，在显示过滤器下拉列表中的选项时没有考虑现有的选择，导致出现诸如“书写工具”与“回形针”这样的荒谬组合。
- en: '![image](../Images/ch07__image003.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image003.png)'
- en: Figure 7.3 The filter bar options can have mismatching combinations
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3 过滤器栏选项可能存在不匹配的组合
- en: The filter bar isn't "intelligent". Filtering on a product category doesn't
    update the options available to the user in the segment and product name filters,
    even if those segments and products don't belong to the selected category.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤栏并不是“智能”的。在产品类别上过滤不会更新段和产品名称过滤器中用户可用的选项，即使那些段和产品不属于所选类别。
- en: If a user filters the data for "Writing tools", it's a bit annoying to still
    see all the other product lines (like "Paper clips") in the segment dropdown.
    The example data we've been using only has ten products overall, so it isn't a
    dealbreaker per se, but consider the situation where there are hundreds. At that
    point, using the higher levels in the product hierarchy (like "category") to filter
    out irrelevant products from the other dropdowns becomes a necessary feature,
    not a nice-to-have.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户过滤“写作工具”的数据，仍然在段下拉列表中看到所有其他产品线（如“回形针”）会有些恼人。我们一直在使用的示例数据总共只有十个产品，所以这本身并不是一个决定性的问题，但考虑一下有数百个产品的情况。到那时，使用产品层次结构中的较高级别（如“类别”）来从其他下拉列表中过滤掉不相关的产品成为一个必要的功能，而不仅仅是一个锦上添花的功能。
- en: Let's consider how to fix this.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何解决这个问题。
- en: One possibility is to record the interdependencies between the dimensions, and
    then look up and resolve those dependencies while obtaining the unique values
    for each field. For example, since `Product name` should depend on the selections
    for `Category` and `Segment`, we might record that dependency somewhere.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是记录维度之间的相互依赖关系，然后在获取每个字段的唯一值时查找和解决这些依赖关系。例如，由于“产品名称”应该依赖于“类别”和“段”的选择，我们可能会在某个地方记录这种依赖关系。
- en: This requires us to maintain a new configuration and the logic could get fairly
    involved.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要我们维护一个新的配置，逻辑可能会相当复杂。
- en: 'There''s an easier alternative: rather than obtaining all the unique filter
    values first and *then* filtering the dataframe (figure 7.4), we could get the
    unique values for the first filter, apply the filter to get a new dataframe, get
    the unique values for the second filter, apply that one too, and so on.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更简单的方法：而不是首先获取所有唯一的过滤值，然后过滤数据框（图7.4），我们可以先获取第一个过滤器的唯一值，应用过滤器以获取新的数据框，然后获取第二个过滤器的唯一值，再应用它，依此类推。
- en: '![image](../Images/ch07__image004.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image004.png)'
- en: 'Figure 7.4 Old filtering approach: Get unique values for all filters first,
    then filter based on selections'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4 旧的过滤方法：首先获取所有过滤器的唯一值，然后根据选择进行过滤
- en: In the new approach (figure 7.5), since we filter the data frame before getting
    the unique values for the next filter, we're guaranteed to show only the available
    values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的方法（图7.5）中，由于我们在获取下一个过滤器的唯一值之前过滤数据框，我们保证只显示可用的值。
- en: '![image](../Images/ch07__image005.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image005.png)'
- en: 'Figure 7.5 New filtering approach: Get unique values for each filter, apply
    filter based on selection, then repeat for other filters'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5 新的过滤方法：获取每个过滤器的唯一值，根据选择应用过滤器，然后对其他过滤器重复此操作
- en: So when a user selects the category `"Writing tools"` the dataframe is filtered
    to only include those rows, and the unique values for the segment filter are drawn
    from this new set, which won't include staplers and the like.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户选择“写作工具”类别时，数据框会被过滤，只包含那些行，并且段过滤器的唯一值从这个新集合中抽取，这个新集合不会包括订书机之类的物品。
- en: 'To implement this, modify `filter_panel`.py:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，修改`filter_panel.py`：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The changes aren't too complicated. In each iteration through the filter fields,
    rather than passing `df` directly to `get_unique_values` to get the set of dropdown
    options to display, we introduce a variable called `effective_df` and pass that.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 变化并不复杂。在遍历过滤字段时，我们不是直接将`df`传递给`get_unique_values`以获取要显示的下拉选项集，而是引入一个名为`effective_df`的变量并将它传递。
- en: In line with our explanation of the approach, `effective_df` is recomputed in
    each loop iteration by applying the filters we have so far (we import `apply_filters`
    at the top for this purpose).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们对方法的解释，`effective_df`在每个循环迭代中通过应用我们迄今为止的过滤器被重新计算（我们在此目的上在顶部导入`apply_filters`）。
- en: Go ahead and re-run your app! Figure 7.6 shows what happens when you select
    `"Writing tools"` as the only category you're interested in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 放手去重新运行你的应用！图7.6展示了当你仅选择“写作工具”作为你感兴趣的唯一类别时会发生什么。
- en: '![image](../Images/ch07__image006.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image006.png)'
- en: Figure 7.6 The filter bar only shows valid option combinations (see chapter_7/in_progress_02
    in the GitHub repo for the full code)
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6 过滤栏仅显示有效的选项组合（有关完整代码，请参阅GitHub仓库中的chapter_7/in_progress_02）
- en: As expected, the `Segment` filter now only shows writing instruments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`Segment`过滤器现在只显示书写工具。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The *order* of the filters is now meaningful. If the Category filter were to
    be placed *after* Segment, choosing a category would have no effect on Segment
    because the unique values for Segment would already have been computed by the
    time the selected Category values are evaluated.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的*顺序*现在是有意义的。如果类别过滤器被放置在*分段*之后，选择一个类别对分段没有影响，因为分段的唯一值已经在评估所选类别值之前已经计算出来了。
- en: 7.4 Date range comparisons
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 日期范围比较
- en: 'Another piece of feedback comes from one of the product line chiefs, who posted
    a screenshot (figure 7.7) to illustrate her point: "I can see that sales for RoyalQuill
    were $1.32M for July. But is that good or bad? How did we do last year?"'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 来自产品线主管之一的反馈也很有帮助，她发布了一张截图（图7.7）来说明她的观点：“我可以看到RoyalQuill7月份的销售额为132万美元。但这好还是不好？去年我们做得怎么样？”
- en: '![image](../Images/ch07__image007.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image007.png)'
- en: Figure 7.7 Sales for RoyalQuill were $1.32M but there's no indication of whether
    that's good, or what the sales were in a previous comparable period
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7 RoyalQuill的销售额为132万美元，但没有迹象表明这是否是好的，或者之前可比期间的销售额是多少
- en: Often, the hard part about analyzing data is not obtaining or transforming it
    but *contextualizing* it. A metric by itself doesn't mean much. To make it useful,
    you have to be able to *compare* it to something. If we know sales for a product
    are $1m in a year, the decisions we would make if we knew that last year's sales
    were $10m are very different from those we'd make if last year's sales were only
    $100k.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 分析数据时，困难的部分往往不是获取或转换数据，而是*情境化*数据。一个指标本身并没有多少意义。为了使其有用，你必须能够*比较*它。如果我们知道某个产品的年销售额为100万美元，那么如果我们知道去年的销售额是1000万美元，我们做出的决策将与我们知道去年的销售额仅为10万美元时做出的决策大不相同。
- en: Our dashboard doesn't currently offer an easy way to make this comparison.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制板目前没有提供一种简单的方式来做出这种比较。
- en: Ideally, when we see a metric for a certain time period, we should also be able
    to tell how it's *changed* as compared to the past. In this section, we'll explore
    this requirement more deeply and incorporate it into our dashboard.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，当我们看到某个特定时间段的指标时，我们也应该能够知道它与过去相比是如何*变化*的。在本节中，我们将更深入地探讨这一要求，并将其纳入我们的控制板。
- en: 7.4.1 Adding another date range selector
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 添加另一个日期范围选择器
- en: What exactly does it mean to compare a metric to its past value? What start
    date and end date do we use for "the past"? Let's consider some frequently-accessed
    comparisons that users may be interested in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将指标与其过去值进行比较究竟意味着什么？我们使用什么开始日期和结束日期来表示“过去”？让我们考虑一些用户可能感兴趣的常用比较。
- en: For instance, if the user is viewing the total sales for August 1 to August
    15, 2024, there's a good chance that they might want to see how that compares
    to the same dates in the previous month, i.e. July 1 to July 15, 2024\. This is
    called a "month-over-month" comparison, often abbreviated to "MoM".
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户正在查看2024年8月1日至8月15日的总销售额，那么他们很可能想看看这与上个月相同日期（即2024年7月1日至7月15日）相比如何。这被称为“月环比”比较，通常缩写为“MoM”。
- en: 'Other similar comparisons the user might want to make are QoQ ("quarter-over-quarter")
    and YoY ("year-over-year"), which are both similar to MoM. QoQ means comparing
    to analogous dates in the previous quarter. For example, August 1 to August 15
    represents the first 15 days of the second month of Q3, so QoQ would compare this
    to the first 15 days of the second month of *Q2*, or exactly three months earlier:
    May 1 to May 15.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能想要进行的其他类似比较包括QoQ（“季度环比”）和YoY（“年度环比”），它们都与MoM相似。QoQ意味着与上一个季度相同日期的比较。例如，8月1日至8月15日代表第三季度第二个月的头15天，因此QoQ将比较这些日期与第二季度第二个月的头15天，即正好三个月前：5月1日至5月15日。
- en: YoY should be obvious—it's the date range that's exactly a year in the past,
    so August 1 to August 15, *2023* for our example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: YoY应该是显而易见的——这是正好一年前的日期范围，所以以我们的例子来说，就是2023年8月1日至8月15日。
- en: Another type of comparison an executive might want to make is against the immediately
    prior X days, where X is the number of days in the currently selected main date
    range.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 高管可能想要进行的另一种比较是对立即之前的X天进行比较，其中X是当前选定主要日期范围的天数。
- en: So, if the main range is August 1 to August 15, the "previous period" would
    be the 15 days immediately preceding August 1, i.e. July 17 to July 31.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果主要范围是8月1日至8月15日，则“上一个期间”将是8月1日之前的15天，即7月17日至7月31日。
- en: 'Let''s now implement these commonly-accessed comparisons. We start by updating
    our `date_range_panel` function in `date_range_panel.py` to incorporate a comparison
    selector and return two more dates to the caller (`dashboard.py`, which we''ll
    edit later):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现这些常用的比较功能。我们首先更新 `date_range_panel.py` 中的 `date_range_panel` 函数，以便包含一个比较选择器，并向调用者（稍后我们将编辑的
    `dashboard.py`）返回两个额外的日期：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since the comparison options are discrete values, we use an `st.selectbox` to
    offer users a choice between them, and call a yet-to-be-defined function, `get_compare_range`,
    to get the actual start and end dates of the comparison range.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于比较选项是离散值，我们使用 `st.selectbox` 为用户提供选择，并调用尚未定义的函数 `get_compare_range` 来获取比较范围的起始和结束日期。
- en: We also expose these comparison dates to the user in an `st.info` box so the
    user doesn't have to do any calendar math themselves to get that information.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过 `st.info` 框向用户公开这些比较日期，这样用户就不必自己进行日历计算来获取这些信息。
- en: 'Let''s also define the `get_compare_range` function we referenced above (in
    the same file, `date_range_panel.py`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义上面提到的 `get_compare_range` 函数（在同一文件 `date_range_panel.py` 中）：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function accepts three parameters: the start and end dates of the main
    date range, and `comparison`, a string that holds the type of comparison we want
    to perform—as discussed above, this could be `MoM`, `QoQ`, `YoY`, or `Previous
    period`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受三个参数：主日期范围的起始和结束日期，以及 `comparison`，一个字符串，包含我们想要执行的比较类型——如上所述，这可以是 `MoM`、`QoQ`、`YoY`
    或 `Previous period`。
- en: Calculating the comparison date range comes down to subtracting the right *offset*
    from both the start and end dates. For example, for an MoM comparison, we need
    to subtract one month from both dates. For QoQ, we subtract 3 months, and for
    YoY, we subtract a year.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 计算比较日期范围归结为从起始和结束日期中减去正确的 *偏移量*。例如，对于 MoM 比较，我们需要从两个日期中减去一个月。对于 QoQ，我们减去 3 个月，对于
    YoY，我们减去一年。
- en: For the `Previous period` comparison, we first find the number of days within
    the main date range using `(end - start).days + 1`, and use that as the offset.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Previous period` 比较来说，我们首先使用 `(end - start).days + 1` 计算主日期范围内的天数，并将其用作偏移量。
- en: 'We store these offsets in a dictionary (called `offsets` in the code above)
    with the comparison name as the key and a Pandas `DateOffset` object as the value.
    We can then obtain the new start and end dates by subtracting the offset from
    each:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些偏移量存储在一个字典中（如上述代码中所示，称为 `offsets`），比较名称作为键，Pandas `DateOffset` 对象作为值。然后我们可以通过从每个日期中减去偏移量来获得新的起始和结束日期：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Why are the `.date()`s necessary here? Well, if you've been paying particularly
    close attention, you might have realized that `start` and `end` are `datetime.date`
    objects, not Pandas timestamp objects. Pandas makes sure that `pd.DateOffset`
    is compatible with `datetime.date` and that the former can be subtracted from
    the latter, but the result is a Pandas timestamp object. Since we've been trying
    to keep our date ranges `datetime.date` objects elsewhere, we use the `.date()`
    method of the Pandas timestamp class to convert `start - offset` and `end - offset`
    to `datetime.dates`—thus ensuring consistency.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这里需要 `.date()`？好吧，如果您特别关注，您可能会意识到 `start` 和 `end` 是 `datetime.date` 对象，而不是
    Pandas 时间戳对象。Pandas 确保与 `datetime.date` 兼容的 `pd.DateOffset`，并且前者可以从后者中减去，但结果是
    Pandas 时间戳对象。由于我们一直在尝试将日期范围保持为 `datetime.date` 对象，我们使用 Pandas 时间戳类的 `.date()`
    方法将 `start - offset` 和 `end - offset` 转换为 `datetime.dates`，从而确保一致性。
- en: Since the function `date_range_panel` now returns four values (`start`, `end`,
    `compare_start`, and `compare_end`) instead of just two, we need to update the
    code that calls it to reflect this.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `date_range_panel` 函数现在返回四个值（`start`、`end`、`compare_start` 和 `compare_end`），而不是两个，我们需要更新调用它的代码以反映这一点。
- en: 'This code happens to be in `dashboard.py`, within the sidebar. Change it from:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码恰好位于 `dashboard.py` 文件中的侧边栏部分。将其修改为：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Your app's sidebar should now look like figure 7.8.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序侧边栏现在应该看起来像图 7.8 所示。
- en: '![image](../Images/ch07__image008.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image008.png)'
- en: Figure 7.8 Sidebar showing a start/end date selector for the main date range
    as well as a "Compare to" input (see chapter_7/in_progress_03 in the GitHub repo
    for the full code)
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8 展示了主日期范围的起始/结束日期选择器以及“比较到”输入（请参阅 GitHub 仓库中的 chapter_7/in_progress_03
    以获取完整代码）
- en: Though we're not actually doing anything with the comparison date range, you
    can see the new selectors.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们实际上并没有对比较日期范围做任何事情，但您可以看到新的选择器。
- en: 7.4.2 Showing the comparison in the metric bar
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 在指标栏中显示比较
- en: Now that we've collected the date range to compare to the main date range, how
    do we use it to resolve the feedback we received?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了要与主要日期范围比较的日期范围，我们如何使用它来解决我们收到的反馈？
- en: 'Let''s consider this with an example. Say we have two date ranges: August 1
    to August 31, 2024 (the "main" date range) and July 1 to July 31, 2024 (the comparison
    date range). If we''re comparing the total sales between those ranges, we''ll
    need to calculate them separately for both date ranges and then display the *delta*
    (difference) between them.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来考虑这个问题。假设我们有两个日期范围：2024年8月1日至8月31日（“主要”日期范围）和2024年7月1日至7月31日（比较日期范围）。如果我们比较这两个日期范围之间的总销售额，我们需要分别计算这两个日期范围的变化，然后显示它们之间的
    *delta*（差异）。
- en: 'If the August sales are $5m and those in July are $4m, we would display a delta
    of $1m. Generally speaking, expressing the difference as a percentage of the past
    number is more useful, so the delta is 20% ($4m / $5m x 100). We would show this
    number alongside the August sales to provide a complete picture: Sales in August
    were $5m, up 20% from the previous period.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果八月份的销售额为500万美元，而七月份的销售额为400万美元，我们将显示100万美元的变化。一般来说，将差异表示为过去数值的百分比更有用，因此变化为20%（400万美元
    / 500万美元 x 100）。我们将显示这个数字与八月份的销售额一起，以提供完整的画面：八月份的销售额为500万美元，比上一期增长20%。
- en: 'This approach requires us to do two things:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法要求我们做两件事：
- en: Calculate the metric separately for the comparison date frame, keeping everything
    else (mainly the filter values) constant
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别为比较日期范围计算指标，同时保持其他一切（主要是过滤器值）不变。
- en: Compute the percentage delta and display it with the main metric.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算百分比变化并将其与主要指标一起显示。
- en: 'For the first part, let''s modify `dashboard.py`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一部分，让我们修改 `dashboard.py`：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we're obtaining a new Pandas dataframe, `compare_df`, in much the same
    way that we get `main_df`—by passing the raw prepped data to `get_filtered_data_within_date_range`
    with the appropriate start and end dates and filters.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以类似获取 `main_df` 的方式获取一个新的 Pandas 数据框 `compare_df`——通过将原始准备好的数据传递给 `get_filtered_data_within_date_range`，并带有适当的起始和结束日期以及过滤器。
- en: The filters are the same as those used to create `main_df`. This is important
    because if a user has filtered for, say, a particular category and/or gender,
    the comparison they want to see is with the same category and/or gender, just
    for a different date range.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器与创建 `main_df` 时使用的过滤器相同。这很重要，因为如果用户过滤了特定的类别和/或性别，他们想要的比较就是与相同的类别和/或性别，只是不同的日期范围。
- en: We also pass `compare_df` as a second argument to `metric_bar`, which it doesn't
    support yet, but will when we're done.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `compare_df` 作为 `metric_bar` 的第二个参数传递，它目前还不支持，但完成时将支持。
- en: To compute and display the percentage delta, the changes we need to make are
    in `metric_bar.py`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算和显示百分比变化，我们需要在 `metric_bar.py` 中进行以下更改。
- en: 'Let''s start by modifying `metric_bar` to accept the extra argument we passed
    in:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先修改 `metric_bar` 以接受我们传递的额外参数：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Earlier, for each metric we needed to display, we would get the formatted value
    using `format_metric` and pass that, along with a title, to `st.metric` for display
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，对于每个需要显示的指标，我们会使用 `format_metric` 获取格式化的值，并将其与标题一起传递给 `st.metric` 以进行显示，如下所示：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, `st.metric` supports showing a delta as well, through its third and
    fourth argument (internally named `delta` and `delta_color`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`st.metric` 也支持显示变化，通过其第三个和第四个参数（内部命名为 `delta` 和 `delta_color`）。
- en: The third argument is the formatted number to show as the change (in this case,
    the percentage difference), while the fourth argument, `delta_color`, indicates
    the color scheme to display the delta in.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是要显示的变化（在这种情况下，百分比差异）的格式化数字，而第四个参数 `delta_color` 指示显示变化时使用的颜色方案。
- en: '`delta_color` can take the values `"normal,"` `"inverse,"` or `"off."` If it''s
    set to `"normal,"` positive deltas are displayed in green, and negative changes
    will be in red. If it''s `"inverse,"` the reverse is true: increases are in red,
    and decreases are green (this is appropriate for metrics where a lower value is
    better, like cost). If it''s `"off,"` Streamlit just shows everything in gray.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`delta_color` 可以取 `"normal"`、`"inverse"` 或 `"off"` 的值。如果设置为 `"normal"`，则正变化以绿色显示，负变化以红色显示。如果设置为
    `"inverse"`，则相反：增加以红色显示，减少以绿色显示（这对于值越低越好的指标来说很合适，比如成本）。如果设置为 `"off"`，Streamlit
    只会以灰色显示所有内容。'
- en: 'In this case, we''re calling `st.metric` like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们调用 `st.metric` 的方式如下：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`"normal"` is appropriate for all of our metrics since a higher value is better
    for all of them (you''d want higher sales, a higher gross margin, a higher margin
    percentage, and a higher average transaction value). For the third argument, we
    pass in `formatted_delta`, which we''re obtaining above by calling a function
    we haven''t defined yet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: “正常”适用于我们所有的度量，因为更高的值对它们来说都更好（你希望有更高的销售额、更高的毛利率、更高的利润百分比和更高的平均交易价值）。对于第三个参数，我们传递`formatted_delta`，这是我们通过调用尚未定义的函数获得的：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s go ahead and create `get_formatted_delta`, and any associated functions
    now:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建`get_formatted_delta`以及任何相关的函数：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ve defined two functions: `get_delta` calculates the actual delta, while
    `get_formatted_delta` calls it and formats the result.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个函数：`get_delta`计算实际增量，而`get_formatted_delta`调用它并格式化结果。
- en: '`get_delta` accepts the value of the main metric, `compare_df`—the comparison
    dataframe we computed in `dashboard.py`—and `metric`, which is the `Metric` object
    that represents the measure we''re trying to show the change in.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_delta`接受主要度量的值，`compare_df`——我们在`dashboard.py`中计算的比较数据框——以及`metric`，它是一个`Metric`对象，代表我们试图展示其变化的度量。'
- en: 'The body of `get_delta` isn''t complicated. We use the `get_metric` function
    on `compare_df` to calculate the metric for the comparison date range, and obtain
    the percentage delta as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_delta`的主体并不复杂。我们使用`compare_df`上的`get_metric`函数来计算比较日期范围的度量，并按以下方式获取百分比增量：'
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At any point, if we realize that a delta can't be displayed (either because
    `compare_df` contains no data or because trying to calculate it would cause a
    divide-by-zero error since the comparison value is zero), we return `None` instead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，如果我们意识到一个增量无法显示（要么是因为`compare_df`没有数据，要么是因为尝试计算它会导致除以零错误，因为比较值是零），我们将返回`None`。
- en: 'In `get_formatted_delta`, we take this returned value and get a formatted version
    of it by calling `format_metric`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_formatted_delta`中，我们获取这个返回值，并通过调用`format_metric`来获取其格式化版本：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Recall from Chapter 6 that `format_metric` (defined in the file `formatting.py`)
    converts a numeric value into a user-friendly string depending on its type. In
    this case, the metric type is a "percent," so format_metric will add a "%" sign
    at the end.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第6章的内容，`format_metric`（在`formatting.py`文件中定义）将数值转换为用户友好的字符串，具体取决于其类型。在这种情况下，度量类型是“百分比”，因此`format_metric`将在末尾添加一个“%”符号。
- en: If there's no delta to format (which happens when `get_delta` returns `None`),
    `get_formatted_delta` returns `None` as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有增量需要格式化（当`get_delta`返回`None`时发生），`get_formatted_delta`也会返回`None`。
- en: When this is eventually passed to `st.metric`, Streamlit handles the `None`
    value correctly by not displaying anything at all.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个值最终传递给`st.metric`时，Streamlit会正确地处理`None`值，根本不显示任何内容。
- en: You can now re-run the dashboard to view your updated metric bar (remember to
    choose a comparison date range that we have data for), as shown in figure 7.9.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以重新运行仪表板来查看更新的度量条（记得选择我们有数据的比较日期范围），如图7.9所示。
- en: '![image](../Images/ch07__image009.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image009.png)'
- en: Figure 7.9 Metric bar showing how each metric has changed from the comparison
    date range (see chapter_7/in_progress_04 in the GitHub repo for the full code)
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9 展示了每个度量如何从比较日期范围变化的度量条（GitHub仓库中的chapter_7/in_progress_04章节有完整代码）
- en: As you can see, the metric bar now shows how each metric has changed as compared
    to its value in the comparison date range.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，度量条现在显示了每个度量与比较日期范围中的值相比的变化情况。
- en: Boom! We've addressed another key piece of feedback and are well on our way
    to version 2.0 of our dashboard! Let's see what else the email has to say.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 嘣！我们解决了另一个关键反馈点，并且正在朝着仪表板的2.0版本稳步前进！让我们看看邮件中还有什么要说的。
- en: 7.5 A drilldown view
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 深入查看
- en: Note n' Nib's CEO prides himself on being a "details guy," so when he sees a
    number on the dashboard, he wants to investigate *why*. For instance, if he finds
    that the average transaction value on ball pens is lower than that on fountain
    pens, he wants to dig deeper into the data to understand if there's a certain
    demographic driving the ATV down.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，N' Nib的CEO以自己是“细节控”而自豪，所以当他看到仪表板上的数字时，他想知道*为什么*。例如，如果他发现圆珠笔的平均交易价值低于钢笔，他希望深入挖掘数据，了解是否有一些特定的群体在推动ATV下降。
- en: Our dashboard doesn't expose data beyond what's in the metrics bar, line and
    pie charts, but there's clearly a desire for a more flexible and detailed view,
    perhaps even showing the individual rows in the source data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仪表板没有暴露比度量栏、折线图和饼图更多的数据，但显然人们希望有一个更灵活和详细的视图，也许甚至可以显示源数据中的单个行。
- en: So far in our dashboard design, we've tried to shield users from complexity
    where possible. We've relied on visualizations to make data easy to grasp and
    used a clear, friendly metric bar to display key aggregate numbers. The quality
    of abstracting away complexity is a laudable one most of the time and for most
    users. Now and then, however, you'll come across a power user who wants to go
    deeper and interact with your software in more advanced ways.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的仪表板设计中，我们尽可能地屏蔽了复杂性。我们依靠可视化使数据易于理解，并使用清晰、友好的度量栏来显示关键汇总数字。抽象复杂性的质量通常是值得赞扬的，对于大多数用户来说也是如此。然而，有时你可能会遇到一个想要深入了解并更高级地与你的软件交互的强大用户。
- en: In our case, Note n' Nib's CEO fits this description—he's comfortable with data
    and has expressed frustration at not being able to drill down for more detailed
    insights. Addressing this feedback will likely be the most complex task of this
    chapter, as we'll need to create a whole new view rather than just improve upon
    the existing features.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，Note n' Nib的CEO符合这一描述——他对数据很熟悉，并表达了对无法钻取以获取更详细见解的挫败感。解决这一反馈可能是本章最复杂的任务，因为我们需要创建一个全新的视图，而不仅仅是改进现有功能。
- en: 7.5.1 Inserting a modal dialog
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 插入模态对话框
- en: Before considering what a drilldown view might contain, let's ponder where to
    place this functionality. Since we're classifying it as an "advanced" feature,
    we probably shouldn't place it in the main window of the dashboard. Casual users
    should be able to ignore the new, more detailed view, while advanced users should
    be able to find it with no trouble.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑钻取视图可能包含的内容之前，让我们思考一下将此功能放在哪里。由于我们将其归类为“高级”功能，我们可能不应该将其放在仪表板的主窗口中。普通用户应该能够忽略这个新的、更详细视图，而高级用户应该能够轻松找到它。
- en: 'Let''s use this opportunity to discuss a new UI construct: a modal dialog.
    A modal dialog is essentially an overlay displayed on top of the main content,
    temporarily blocking interaction with the underlying interface until it has been
    dismissed. This overlay would remain focused on a particular task, which makes
    it ideal for presenting advanced functionality like drilldowns.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这个机会讨论一个新的用户界面结构：模态对话框。模态对话框本质上是在主内容之上显示的覆盖层，在它被取消之前暂时阻止与底层界面的交互。这个覆盖层将专注于特定任务，这使得它非常适合展示像钻取这样的高级功能。
- en: st.dialog
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.dialog
- en: Streamlit offers modal dialogs out of the box with `st.dialog`. Let's see this
    in action now.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit通过`st.dialog`提供了开箱即用的模态对话框。现在让我们看看它是如何工作的。
- en: For our first iteration on the drilldown view, to keep things simple, when a
    user wants to drill down into the data, we'll just show them the entire Pandas
    dataframe. Of course, since users are likely to want to also dive into the comparison
    date range we recently added, we'll need to show both the main and the comparison
    dataframes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对钻取视图的第一轮迭代中，为了保持简单，当用户想要钻取数据时，我们只需向他们展示整个Pandas数据框。当然，由于用户可能还希望深入了解我们最近添加的比较日期范围，我们需要展示主数据和比较数据框。
- en: Listing 7.1 shows a new file, `drilldown.py`, set up to achieve this.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1展示了新文件`drilldown.py`，该文件已设置以实现这一点。
- en: Listing 7.1 drilldown.py
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1 drilldown.py
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It may surprise you to learn that `st.dialog` is *not* structured the same way
    as `st.columns`, `st.tabs`, or `st.container`, i.e., as a widget that holds other
    widgets within.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 了解到`st.dialog`的结构与`st.columns`、`st.tabs`或`st.container`不同，即它不是一个包含其他小部件的小部件，可能会让你感到惊讶。
- en: Instead, it's similar to `st.cache_data` from chapter 6 in that it's a *decorator*.
    A function decorated with `st.dialog` runs and has its content rendered inside
    a popup dialog.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它与第6章中的`st.cache_data`类似，它是一个装饰器。用`st.dialog`装饰的函数运行时，其内容将在弹出对话框中渲染。
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The width parameter simply sets the size of the dialog, which may be `"small"`
    (500 pixels wide) or `"large"` (750 pixels wide).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度参数简单地设置了对话框的大小，可以是`"small"`（500像素宽）或`"large"`（750像素宽）。
- en: The function being decorated is called `drilldown`, and it accepts `main_df`
    and `compare_df` from `dashboard.py` as arguments. The function renders two tabs
    titled "Main" and "Compare", and uses a new widget, `st.dataframe`, to display
    the passed Pandas dataframes in their respective tabs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 被装饰的函数称为 `drilldown`，它接受来自 `dashboard.py` 的 `main_df` 和 `compare_df` 作为参数。该函数渲染两个标签页，分别命名为“主”和“比较”，并使用一个新的小部件
    `st.dataframe` 在各自的标签页中显示传递的 Pandas 数据框。
- en: Using `st.dataframe` like this simply shows the dataframe on the screen, just
    as `st.write` did in Chapter 6\. We'll encounter it later too.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `st.dataframe` 如此简单地在屏幕上显示数据框，就像第 6 章中 `st.write` 所做的那样。我们稍后也会遇到它。
- en: To see the dialog, we need to *trigger* it, so let's focus on that next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到对话框，我们需要 *触发* 它，所以让我们专注于这一点。
- en: Using st.container to display UI elements out of order
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 st.container 来显示 UI 元素顺序
- en: As alluded to earlier, the drilldown view should be unobtrusive to the casual
    user, but fairly obvious for a power user to access. One way to achieve this would
    be to add a button labeled "Drilldown" to the sidebar, and have it trigger the
    dialog when clicked.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，钻取视图应该对普通用户不显眼，但对高级用户来说相当明显。实现这一目标的一种方法是在侧边栏中添加一个标签为“钻取”的按钮，并在点击时触发对话框。
- en: 'Let''s examine the existing code in `dashboard.py`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `dashboard.py` 中的现有代码：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The sidebar already has the date range panel in it, with four widgets (two date
    inputs for the main range, a comparison selectbox, and an info box showing the
    comparison range), all lined up vertically. Since we want the drilldown trigger
    to be easily visible, we probably don't want it to be *below* the date range panel.
    Cool, so we put it above the panel instead, right?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏已经包含了日期范围面板，其中包含四个小部件（两个用于主要范围的日期输入、一个比较选择框和一个显示比较范围的说明框），所有这些都垂直排列。由于我们希望钻取触发器易于可见，我们可能不希望它位于日期范围面板
    *下方*。好，所以我们把它放在面板上方，对吧？
- en: Except, there's a bit of an ordering issue here. To trigger the drilldown view,
    we need to call the `drilldown` function we just decorated with `st.dialog`. The
    parameters to this function are `main_df` and `compare_df`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这一点，这里还有一点排序问题。为了触发钻取视图，我们需要调用我们刚刚用 `st.dialog` 装饰的 `drilldown` 函数。这个函数的参数是
    `main_df` 和 `compare_df`。
- en: 'If you inspect the `dashboard.py` code again, you''ll realize that obtaining
    `main_df` and `compare_df` requires that we already *have* the `start`, `end`,
    `compare_start` and `compare_end` values so we can pass them in like this (for
    `main_df`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次检查 `dashboard.py` 代码，你会意识到获取 `main_df` 和 `compare_df` 需要我们已经有 `start`、`end`、`compare_start`
    和 `compare_end` 的值，这样我们才能像这样（对于 `main_df`）传递它们：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But where do we get these values? Why, in the sidebar!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些值从何而来？当然是在侧边栏中！
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Do you see our dilemma? To place the drilldown button above the date range panel,
    we'd need to write its code *before* this line, but that code requires values
    that are only available *after* this line!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我们的困境了吗？为了将钻取按钮放置在日期范围面板上方，我们需要在这一点之前编写其代码，但该代码需要只有在这之后才能获得的值！
- en: 'This is the perfect place to elaborate on something I mentioned in passing
    in Chapter 6: the ability to display elements out of order. We need a way to separate
    the order in which Streamlit renders widgets on the screen from the order in which
    those widgets are computed.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我在第 6 章中顺便提到的事情的完美阐述：显示元素顺序的能力。我们需要一种方法来区分 Streamlit 在屏幕上渲染小部件的顺序和这些小部件计算的顺序。
- en: We'll use `st.container` for this. In chapter 6, we used it to display a border
    around the metric bar and visualizations. This time, we'll capitalize on a different
    property—`st.container` can put a *placeholder* widget on the screen that we can
    populate with other widgets when we can.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `st.container` 来实现这一点。在第 6 章中，我们使用它来显示指标栏和可视化内容的边框。这次，我们将利用不同的属性——`st.container`
    可以在屏幕上放置一个 *占位符* 小部件，当我们能够填充其他小部件时。
- en: For our use case, the placeholder will be above the date range panel—within
    the sidebar—and we'll only populate it with the actual drilldown button once we
    have `main_df` and `compare_df` later in the code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，占位符将位于日期范围面板上方——在侧边栏内——并且我们只有在代码中稍后获得 `main_df` 和 `compare_df` 后才会填充实际的钻取按钮。
- en: 'Let''s lay this out in `dashboard.py`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `dashboard.py` 中安排这个布局：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#A This is the placeholder defined within st.sidebar'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这是在 st.sidebar 中定义的占位符'
- en: As promised, we use `st.container` above the date range panel to put a placeholder
    and refer to it by the name `dd_button_container`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我们在日期范围面板上方使用 `st.container` 放置一个占位符，并通过名称 `dd_button_container` 来引用它。
- en: Then, once we have `main_df` and `compare_df`, we create the button that calls
    the drilldown function when clicked. Notice that we're using the syntax `dd_button_container.button`
    instead of the `with`/`st.button` structure, just as we could with columns or
    tabs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦我们有了 `main_df` 和 `compare_df`，我们创建了一个按钮，当点击时调用钻取函数。注意，我们使用的是 `dd_button_container.button`
    语法，而不是 `with`/`st.button` 结构，就像我们可以在列或选项卡中使用的那样。
- en: It's finally time to see our dialog come to life! Re-run `dashboard.py` and
    click the drilldown button to get figure 7.10.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看到我们的对话框生动起来！重新运行 `dashboard.py` 并点击钻取按钮以获取图7.10。
- en: '![image](../Images/ch07__image010.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image010.png)'
- en: Figure 7.10 A basic raw dataframe view rendered in a dialog using st.dialog
    (see chapter_7/in_progress_05 in the GitHub repo for the full code)
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10 使用 st.dialog 在对话框中渲染的基本原始数据框视图（完整代码请见GitHub仓库中的 chapter_7/in_progress_05）
- en: You may have noticed that the drilldown button took a second to appear before
    you clicked it. As you probably guessed, that's because we delayed its rendering
    until a bunch of other stuff was processed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在点击之前，钻取按钮出现需要一秒钟。正如你可能猜到的，那是因为我们推迟了它的渲染，直到处理完其他一堆东西。
- en: 7.5.2 Designing the content of the drilldown
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 设计钻取内容
- en: Turn your attention to the dialog in figure 7.10 for a minute. We're currently
    just displaying `main_df` and `compare_df` as-is. It's rather ugly, with the horizontal
    *and* vertical scrollbars indicating that we only see a tiny portion of the data.
    More to the point, we can't easily use this view to look for specific data points
    or view a specific subset of the data. The boss would not be pleased if he had
    to use this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 把你的注意力转到图7.10中的对话框上。我们目前只是以原样显示 `main_df` 和 `compare_df`。它相当难看，水平 *和* 垂直滚动条表明我们只看到了数据的一小部分。更重要的是，我们无法轻松使用这种视图来查找特定的数据点或查看特定数据子集。如果老板必须使用这个，他不会高兴的。
- en: No, we need to think carefully to get the experience right.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们需要仔细思考才能获得正确的体验。
- en: What do users need from a drilldown view?
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户需要从钻取视图中得到什么？
- en: It's clear that the content of the drilldown page needs to change, but how?
    What do our users need from this view? Well, what better way to understand than
    to talk to a user?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，钻取页面的内容需要改变，但如何改变？我们的用户需要从这个视图中得到什么？好吧，还有什么比与用户交谈更好的方式来理解呢？
- en: So, you book a slot on the CEO's calendar—it's a sign of his enthusiasm for
    the dashboard that he readily accepts. In your interview with him, he lays out
    the original motivation for the feedback he provided about the drilldown view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你在CEO的日程上预订了一个时间段——他愿意接受，这表明他对仪表板的热情。在你与他面试时，他阐述了他提供关于钻取视图反馈的原始动机。
- en: 'Note n'' Nib has two separate products in its best-selling line of fountain
    pens: Inkstream and RoyalQuill. InkStream is supposed to be a chic modern take
    on the fountain pen, while RoyalQuill, reminiscent of the classic elegance of
    vintage pens, is targeted at older customers.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Note n' Nib 在其畅销钢笔系列中有两个独立的产品：InkStream 和 RoyalQuill。InkStream 被视为对钢笔的现代时尚诠释，而
    RoyalQuill，让人联想到经典复古笔的优雅，针对的是老年客户。
- en: Recently, the company ran an advertising campaign for RoyalQuill, specifically
    targeting women in the 46-55 and 56+ age groups. The CEO wanted some data on the
    assumptions and results of this campaign. Specifically, he wanted to know how
    sales broke down for InkStream and RoyalQuill by age *and* gender.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，公司为 RoyalQuill 运行了一项广告活动，特别针对46-55岁和56岁以上的女性。CEO希望了解这次活动的假设和结果数据。具体来说，他想知道按年龄
    *和* 性别划分的 InkStream 和 RoyalQuill 的销售额如何。
- en: Our current dashboard shows users a breakdown of a metric by age *or* gender
    but not by both, so he can't easily access this information.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的仪表板向用户展示了按年龄 *或* 性别划分的指标细分，但不是两者兼而有之，因此他无法轻松访问这些信息。
- en: You may see how this feedback can be generalized to *any* combination of dimensions
    in the data, not just age group/gender. Also, it would be tricky to present this
    kind of detail in a coherent repeatable visualization.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到这种反馈可以推广到 *任何* 数据维度的组合，而不仅仅是年龄组/性别。此外，在连贯且可重复的可视化中呈现这类细节可能会很棘手。
- en: 'What we need, then, is a highly flexible tabular form to show the data, similar
    to pivot tables that you may be familiar with from spreadsheet programs like Microsoft
    Excel. This table should:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们需要的是一个高度灵活的表格形式来显示数据，类似于你可能从像Microsoft Excel这样的电子表格程序中熟悉的交叉表。这个表格应该：
- en: enable us to view numbers for any combination of dimensions we choose
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们能够查看我们选择的任何维度的组合的数字
- en: allow us to focus on just the fields we care about, hiding irrelevant rows and/or
    columns
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只让我们关注我们关心的字段，隐藏无关的行和/或列
- en: show aggregate numbers so we can see a full breakdown
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示汇总数字，以便我们可以看到完整的分解
- en: A mock UI created with these requirements in mind is shown in figure 7.11.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些要求创建的模拟用户界面如图7.11所示。
- en: '![image](../Images/ch07__image011.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image011.png)'
- en: Figure 7.11 A mock UI for the drilldown view
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11 钻取视图的模拟用户界面
- en: The mock shows us a fairly flexible table, that's quite similar to a pivot table.
    The "Drilldown fields" box is a multi-select that lets us choose the dimensions
    we care about. Below that is a table that only shows the dimensions we've selected.
    It *aggregates* the data over those dimensions, showing the metrics for every
    combination of the selected dimensions. There's also a total row that adds up
    everything.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟显示了一个相当灵活的表格，相当类似于交叉表。`钻取字段`框是一个多选框，允许我们选择我们关心的维度。下面是一个只显示我们已选择的维度的表格。它在这些维度上*聚合*数据，显示所选维度的每个组合的指标。还有一个总行，将所有内容加起来。
- en: We've also retained the main/comparison tabs so that users can switch between
    them to see a past/present view of the metrics. This format is quite flexible,
    and meets our requirements, so it's time to build it out!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还保留了主/比较标签，以便用户可以在它们之间切换，查看指标的过去/现在视图。这种格式非常灵活，符合我们的要求，因此是时候构建它了！
- en: 7.5.3 Implementing the drilldown view
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 实现钻取视图
- en: The drilldown view in figure 7.11 is fairly complex, so we'll assemble it piece
    by piece, starting with the drilldown field selector, and ending with some formatting
    and styling.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11中的钻取视图相当复杂，所以我们将逐步组装它，从钻取字段选择器开始，以一些格式化和样式结束。
- en: Aggregating by a few chosen dimensions
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按几个选定的维度聚合
- en: 'Building the dimension selector (the top widget in figure 7.11) is just a matter
    of passing the possible dimension options in an `st.multiselect`. Add a new function
    to `drilldown.py` that does this and returns the list of the user''s selections:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 构建维度选择器（图7.11顶部的控件）只是将可能的维度选项传递给`st.multiselect`的问题。向`drilldown.py`添加一个新函数来完成此操作，并返回用户的选定列表：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As our mock in figure 7.11 shows, we want to display all key metrics simultaneously.
    Let's put another function (also in `drilldown.py`) that takes in a dataframe
    (or a slice thereof), calculates all the metrics by aggregating it, and returns
    the results. Remember to import all the modules we need!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7.11中的模拟所示，我们希望同时显示所有关键指标。让我们在`drilldown.py`中添加另一个函数（也在此文件中），它接受一个数据框（或其切片），通过聚合计算所有指标，并返回结果。记得导入我们需要的所有模块！
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The expression `{met: metric.func(df) for met, metric in metrics.items()}`
    is a *dictionary comprehension*, which is shorthand to create a dictionary by
    iterating through something. Here it''s saying "iterate through the metrics dictionary
    (from `metric_config.py`) and return a new dictionary where each key is the name
    of the metric, and the corresponding value is the result of applying the metric
    function `metric.func` on `df`, i.e. the value of that metric".'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '表达式 `{met: metric.func(df) for met, metric in metrics.items()}` 是一种 *字典推导式*，它通过迭代某个东西来创建字典的简写形式。这里的意思是“迭代`metrics`字典（来自`metric_config.py`），并返回一个新的字典，其中每个键是指标的名称，对应的值是应用指标函数`metric.func`在`df`上的结果，即该指标的价值”。'
- en: We use a Pandas series here because, as you'll see shortly, it's a versatile
    data type that integrates seamlessly with various dataframe operations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用Pandas系列，因为，正如您很快就会看到的，它是一种多功能的数据类型，可以无缝集成到各种数据框操作中。
- en: 'To prepare the aggregated table given a dataframe and a list of dimensions,
    we introduce a new function called `get_aggregate_metrics` in the same file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备给定数据框和维度列表的聚合表，我们在同一文件中引入了一个名为`get_aggregate_metrics`的新函数：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If `dimensions` is not an empty list, i.e. if the user has indeed selected some
    drilldown dimensions, `get_aggregate_metrics` groups `df` by those fields, and
    applies `get_metric_cols` to each of the groups (using `grouped.apply`, which
    you should be familiar with from Chapter 6), thus obtaining metric values for
    each group.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dimensions`不是一个空列表，即如果用户确实选择了某些钻取维度，`get_aggregate_metrics`将`df`按这些字段分组，并对每个组应用`get_metric_cols`（使用您在第六章中应该熟悉的`grouped.apply`），从而为每个组获得指标值。
- en: 'If no dimensions are selected, then we call `get_metric_cols` directly on `df`
    to get a Pandas series object with the aggregated metrics for the entire dataframe.
    Finally, we convert this series into a dataframe and return its *transpose*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择维度，那么我们直接在 `df` 上调用 `get_metric_cols` 来获取一个包含整个数据框聚合度量的 Pandas 系列对象。最后，我们将这个系列转换为数据框并返回其
    **转置**：
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The transpose (referenced using a Pandas dataframe's `.T` property) of a dataframe
    is another dataframe whose rows and columns are interchanged. In this case, `metric_cols`
    is a `pd.Series` object, and calling `pd.Dataframe` on it would return a one-column
    dataframe where each of the metrics is a row.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框的转置（使用 Pandas 数据框的 `.T` 属性引用）是另一个数据框，其行和列已互换。在这种情况下，`metric_cols` 是一个 `pd.Series`
    对象，对其调用 `pd.Dataframe` 将返回一个单列数据框，其中每个度量值都是一个行。
- en: The `.T` is required to turn this into a one-*row* dataframe where each metric
    is a column, a format that's more handy.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`.T` 是必需的，以便将其转换为只有一个-**行**的数据框，其中每个度量值都是一个列，这种格式更方便。'
- en: 'Next, we write a function that returns our full drilldown table. For now it''s
    pretty thin since we''re only doing some aggregations:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写一个函数来返回我们的完整钻取表格。目前它相当单薄，因为我们只进行了一些聚合：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We'll add more logic to `get_drilldown_table` later.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后向 `get_drilldown_table` 添加更多逻辑。
- en: 'To wrap up, we also need a function that displays the drilldown table (which
    is currently a Pandas dataframe):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们还需要一个函数来显示钻取表格（目前是一个 Pandas 数据框）：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This should be simple; we display a warning if there's no data, or use `st.dataframe`
    to display the aggregated table otherwise. Note the use of `hide_index=True`.
    By default, Streamlit displays the index field (which, as you may recall from
    Chapter 6, is a unique identifier for the row, defaulting to a simple serial number)
    alongside each row. You can see this in figure 7.10 (they're the numbers to the
    extreme left in the dataframe). We don't want the index displayed to the user,
    so we hide it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很简单；如果没有数据，我们显示警告，或者使用 `st.dataframe` 来显示聚合的表格。注意使用 `hide_index=True`。默认情况下，Streamlit
    会显示索引字段（如您可能从第 6 章中回忆起，它是行的唯一标识符，默认为简单的序列号）并排显示在每个行旁边。您可以在图 7.10 中看到这一点（它们是数据框中极左边的数字）。我们不希望向用户显示索引，所以将其隐藏。
- en: 'With these changes made, we can update the `drilldown` function too:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些更改后，我们还可以更新 `drilldown` 函数：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The order of operations is logical: First we get the drilldown dimensions from
    the user (`dimensions = drilldown_dimensions()`), then we compute the aggregated
    dataframes (for both `main_df` and `compare_df`) using `get_drilldown_table`,
    and eventually display them in separate tabs using `display_drilldown_table`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 操作顺序是逻辑的：首先我们从用户那里获取钻取维度（`dimensions = drilldown_dimensions()`），然后使用 `get_drilldown_table`
    计算聚合的数据框（对于 `main_df` 和 `compare_df`），最后使用 `display_drilldown_table` 在单独的标签页中显示它们。
- en: If you re-run the dashboard now, you should see a much more palatable version
    of the drilldown view, as shown in figure 7.12.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在重新运行仪表板，您应该会看到一个更加令人满意的钻取视图版本，如图 7.12 所示。
- en: '![image](../Images/ch07__image012.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image012.png)'
- en: Figure 7.12 Drilldown view with a dimension selector and aggregated for selected
    dimensions (see chapter_7/in_progress_06 in the GitHub repo for the full code)
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.12 带有维度选择器和按选定维度聚合的钻取视图（请参阅 GitHub 仓库中的 chapter_7/in_progress_06 以获取完整代码）
- en: The user can now pick whichever dimensions they want, and see the metrics for
    every combination of those dimensions. This effectively lets the user drill into
    the required level of detail in the data, but perhaps a summary "total" row would
    be warranted to understand the whole that's being broken down here.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以挑选他们想要的任何维度，并查看这些维度的每个组合的度量值。这实际上让用户能够钻取到所需的数据细节级别，但也许添加一个汇总“总计”行来理解这里正在分解的整体是有益的。
- en: Adding a "Total" row
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加“总计”行
- en: 'Adding a summary row to the drilldown table is relatively complicated for a
    couple of reasons:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在钻取表格中添加一个汇总行相对复杂，原因有几个：
- en: Pandas dataframes do not natively have a way of designating a row as a summary
    of all the other rows. When we want totals, we have to wrangle them together using
    various operations.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 数据框没有原生的方式来指定一行作为其他所有行的汇总。当我们需要总和时，我们必须使用各种操作将它们整理在一起。
- en: The dimension values are meaningless in a total row and should be blank.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维度值在总计行中是没有意义的，应该留空。
- en: 'To take an example, let''s say we have the following drilldown dataframe (after
    the filtering and aggregation):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说明，假设我们有以下钻取数据框（在过滤和聚合之后）：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the total row added to the top, we would have a dataframe that looks like
    this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部添加总计行后，我们将得到一个看起来像这样的dataframe：
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s implement this with a new function, `add_total_row`, in `drilldown.py`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`drilldown.py`中使用一个新的函数`add_total_row`来实现这一点：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`add_total_rows` takes three arguments: `df`, `all_df`, and `dimensions` (the
    same list of dimension names we''ve been passing around). `df` is the drilldown
    dataframe we have so far (e.g. the first table above), while `all_df` is the dataframe
    with the original granular columns *before* aggregation.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_total_rows`函数接受三个参数：`df`、`all_df`和`dimensions`（我们一直在传递的相同维度名称列表）。`df`是我们到目前为止的钻取dataframe（例如上面的第一个表格），而`all_df`是在聚合之前的原始细粒度列的dataframe。'
- en: Why do we need both `df` *and* `all_df` here? Recall that we have a `get_metric_cols`
    function that can calculate all the metrics we need for a given dataframe—in other
    words, the numeric values for the "total" row we're trying to build. `get_metric_cols`
    expects a raw non-aggregated dataframe, not the aggregated version. This means
    we need to pass it `all_df`, not `df`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这里需要同时使用`df`和`all_df`？回想一下，我们有一个`get_metric_cols`函数，它可以计算给定dataframe所需的所有指标——换句话说，就是我们要构建的“总计”行的数值。`get_metric_cols`期望一个原始的非聚合dataframe，而不是聚合版本。这意味着我们需要传递`all_df`而不是`df`。
- en: That is indeed what the first statement in the function does, storing the results
    in `total_metrics`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 那确实是函数中的第一个语句所做的事情，将结果存储在`total_metrics`中。
- en: The next part builds the total row if the dimensions list is non-empty (`if
    dimensions:`), i.e. if the user has selected some drilldown dimensions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分在维度列表非空（`if dimensions:`）的情况下构建总计行，即如果用户选择了某些钻取维度。
- en: 'The following two lines are associated with populating the dimension values:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行与填充维度值相关：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first line is another dictionary comprehension that has a blank value for
    every dimension key from dimensions. We then set the value for the first dimension
    to `"Total"`. This effectively creates the text display values for our total row
    as we saw in our example above—`"Total"` in the first field and blanks for everything
    else.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是另一个字典推导式，为`dimensions`中的每个维度键都有一个空值。然后我们将第一个维度的值设置为`"Total"`。这实际上创建了我们上面示例中看到的总计行的文本显示值——第一个字段是`"Total"`，其余所有字段都是空白。
- en: 'We have the dimension values for the total row in `dim_vals` (a dictionary)
    and the metric values in `total_metrics` (a `pd.Series`). All we need to do is
    to put them together! That''s what the next line does:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`dim_vals`（一个字典）中有总计行的维度值，在`total_metrics`（一个`pd.Series`）中有指标值。我们只需要将它们放在一起！这就是下一行所做的事情：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's some interesting syntax here, so let's break it down.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的语法，让我们来分解一下。
- en: The character sequence `**` here is called a *dictionary unpacking operator*.
    It unpacks the items from a dictionary so they can be combined with other items
    to form a new dictionary, or even passed as function arguments.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的字符序列`**`被称为*字典解包运算符*。它将字典中的项解包，以便它们可以与其他项结合形成新的字典，甚至可以作为函数参数传递。
- en: 'The former is what''s happening here. For instance, if `dim_vals` is something
    like `{''Gender'': ''Total'', ''Segment'': '''', ...}` and total_metrics is `{''Total
    sales'': 300000, …}`, `{**dim_vals, **total_metrics}` gives you a *combined* dictionary
    `{''Gender'': ''Total'', ''Segment'': '''', ..., ''Total sales'': 300000, ...}`.
    The `index=[0]` sets the index of the only row in this single-row dataframe to
    0.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '前者是这里发生的情况。例如，如果`dim_vals`类似于`{''Gender'': ''Total'', ''Segment'': '''', ...}`，而`total_metrics`是`{''Total
    sales'': 300000, …}`，则`{**dim_vals, **total_metrics}`会给你一个*合并*的字典`{''Gender'':
    ''Total'', ''Segment'': '''', ..., ''Total sales'': 300000, ...}`。`index=[0]`将这个单行dataframe的唯一行的索引设置为0。'
- en: 'You might notice one issue with this though: Didn''t we just say that `total_metrics`
    is a `pd.Series` and *not* a dictionary? Well, though that''s true, a Pandas series
    actually has many of the properties of a regular Python dictionary—among them
    support for the `**` operator.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个问题：我们刚才不是说过`total_metrics`是一个`pd.Series`而不是字典吗？好吧，虽然这是真的，但Pandas系列实际上具有许多常规Python字典的特性——其中包括对`**`运算符的支持。
- en: 'The next line concatenates this total row to the rest of the drilldown dataframe
    and returns it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将这个总计行连接到其他钻取dataframe的剩余部分，并返回它：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, if the user has *not* selected any dimensions and `dimensions` is empty,
    getting the dataframe with a total row becomes easier; we just need to add a blank
    column that says `''Total''` to `total_metrics`, and there''s nothing to concatenate
    the row to—the dataframe consists of only the total row:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户没有选择任何维度并且 `dimensions` 为空，获取带有总行的数据框变得更容易；我们只需向 `total_metrics` 添加一个表示
    `'Total'` 的空白列，就没有必要连接行了——数据框只包含总行：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now add the act of obtaining the total row to the transformations in
    `get_drilldown_table` like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将获取总行的操作添加到 `get_drilldown_table` 中的转换，如下所示：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Re-run the dashboard to see what your total row looks like (see figure 7.13):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行仪表板以查看总行看起来如何（见图 7.13）：
- en: '![image](../Images/ch07__image013.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image013.png)'
- en: Figure 7.13 Drilldown dataframe view with a total row (see chapter_7/in_progress_07
    in the GitHub repo for the full code)
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.13 显示了带有总行的钻取数据框视图（在 GitHub 仓库的 chapter_7/in_progress_07 中查看完整代码）
- en: This is *almost* perfect, but wouldn't it be nice if the total row were highlighted
    or shaded to set it apart from the other rows?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是完美的，但如果总行被突出显示或着色，以区别于其他行，那岂不是更好？
- en: Formatting and styling the drilldown table
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式化和样式钻取表格
- en: 'While we have the content of our drilldown table ready to go, the presentation
    leaves a couple of things to be desired:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经准备好了我们的钻取表格内容，但展示方式还有一些不足之处：
- en: As figure 7.17 shows, the numbers in the table are user-unfriendly raw ones,
    with hardly any formatting. Ideally, we'd want these to be shown in the same way
    as in the metric bar (e.g. "$1.2m" instead of "1200000").
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如图 7.17 所示，表中的数字是用户不友好的原始数字，几乎没有格式化。理想情况下，我们希望它们以与指标栏相同的方式显示（例如，“$1.2m”而不是“1200000”）。
- en: No shading distinguishes the total row from the rest of the table.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有阴影区分总行和其他表格行。
- en: Let's tackle the former first. Formatting the numbers in the table should be
    quite straightforward because we've already defined the actual formatting rules
    in the `formatting.py` file from Chapter 6.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决前者。在表格中格式化数字应该是相当直接的，因为我们已经在第 6 章的 `formatting.py` 文件中定义了实际的格式化规则。
- en: All we need is a function to apply the formatting to an entire Pandas dataframe
    rather than the individual numbers displayed in the metric bar.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的只是一个函数，可以将格式应用到整个 Pandas 数据框，而不是指标栏中显示的单独数字。
- en: 'Spin up a new function for this in `formatting.py`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `formatting.py` 中为这个新功能启动一个新的函数：
- en: '[PRE39]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `format_dataframe` function should be simple to wrap your head around. After
    accepting two parameters (`df`, the dataframe to format, and the `metrics` dictionary
    from `metrics.py`), we simply iterate through the columns in `df`, and apply `format_metric`
    (a function we wrote in chapter 6) element-wise to each column.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_dataframe` 函数应该很容易理解。在接收两个参数（`df`，要格式化的数据框，以及来自 `metrics.py` 的 `metrics`
    字典）后，我们只需遍历 `df` 中的列，并将 `format_metric`（我们在第 6 章中编写的函数）逐元素应用到每一列。'
- en: Notice how we're passing `metric_type` to `format_metric` as *another* parameter
    to `.apply()`!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将 `metric_type` 传递给 `.apply()` 函数作为 *另一个* 参数的！
- en: 'Essentially the following expression:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上以下表达式：
- en: '[PRE40]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'is saying: "issue the function call `format_metric(element, metric_type=metrics[col].type)`"
    for every element in `df[col]`, and save the result, which should be our formatted
    dataframe.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 表示的是：为 `df[col]` 中的每个元素发出函数调用 `format_metric(element, metric_type=metrics[col].type)`，并保存结果，这应该是我们的格式化数据框。
- en: 'Let''s turn to the shading problem next: let''s say we want to give the total
    row a gray background so it stands out from the rest of the table.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来解决着色问题：假设我们想要给总行一个灰色背景，使其从表格的其他部分中脱颖而出。
- en: The key to this lies in the `style` property of a Pandas dataframe, which enables
    us to apply *conditional formatting* (i.e. formatting based on certain rules)
    to the dataframe.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这的关键在于 Pandas 数据框的 `style` 属性，它使我们能够应用 *条件格式化*（即基于某些规则的格式化）到数据框。
- en: To achieve this, we would use the `.apply` method of the `style` property, along
    with a custom function that defines the conditional style to apply.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用 `style` 属性的 `.apply` 方法，以及一个自定义函数，该函数定义了要应用的条件样式。
- en: 'Let''s create a new function in `drilldown.py` to implement this logic:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `drilldown.py` 中创建一个新的函数来实现这个逻辑：
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `style_total_row` function accepts the drilldown dataframe `df`, and applies
    the shading we need. To achieve this, it does something interesting: it defines
    *another* function called `get_style` within its body!'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`style_total_row`函数接受钻取数据框`df`，并应用所需的阴影。为了实现这一点，它在其体内定义了另一个名为`get_style`的函数！'
- en: In Python, a function defined within another is called a *nested function* or
    an *inner function*. Python considers a nested function to be local to the enclosing
    function's scope. In other words, any code outside of `style_total_row` cannot
    call `get_style`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，定义在另一个函数中的函数称为*嵌套函数*或*内部函数*。Python认为嵌套函数是封装函数作用域内的局部变量。换句话说，`style_total_row`之外的所有代码都不能调用`get_style`。
- en: Getting to the logic of the `get_style` function, it operates on an individual
    row of a Pandas dataframe, and so takes in row as a parameter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看`get_style`函数的逻辑，它操作Pandas数据框的单行，因此将行作为参数传入。
- en: It then identifies the name of the first column of the dataframe using `first_col
    = row.index[0]`. The `index` property of a dataframe row is a list-like object
    containing the names of its columns, so `index[0]` gives the name of the first
    column.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它使用`first_col = row.index[0]`确定数据框的第一列名称。数据框行的`index`属性是一个类似列表的对象，包含其列的名称，因此`index[0]`给出第一列的名称。
- en: 'The next line defines (and returns) the actual conditional style we want to
    apply:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行定义（并返回）了我们想要应用的真正条件样式：
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The expression we're returning is a *list comprehension* which builds a new
    list by iterating through something (similar to how the dictionary comprehensions
    we've seen build new dictionaries).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的表达式是一个*列表推导式*，通过迭代某个东西（类似于我们之前看到的如何构建新的字典）来构建一个新的列表。
- en: In this case, we're iterating through the fields in the dataframe row, using
    `for _ in row`. We don't actually need to refer to the fields themselves, which
    is why we use `_`—a perfectly valid Python identifier, by the way—as the loop
    index here.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在通过`for _ in row`遍历数据框行的字段。实际上我们不需要引用字段本身，这就是为什么我们在这里使用`_`——一个完全有效的Python标识符——作为循环索引。
- en: 'For each field, if the passed row is the total row (which we verify by checking
    if the value of the first column is `"Total"),` we add a peculiar string, `''background-color:
    lightgray''`, to the list we''re constructing.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '对于每个字段，如果传入的行是总行（我们通过检查第一列的值是否为`"Total"`来验证），我们在我们构建的列表中添加一个特殊的字符串，`''background-color:
    lightgray''`。'
- en: 'This notation comes from CSS, the language used to style web pages. I know
    I promised you don''t need to learn CSS to read this book, but this particular
    piece of it should be obvious enough: we''re telling Pandas to give a light gray
    background to every field in a total row.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法来自CSS，这是用于样式化网页的语言。我知道我承诺过你不需要学习CSS就能阅读这本书，但这个特定的部分应该足够明显：我们正在告诉Pandas给总行中的每个字段一个浅灰色背景。
- en: 'We''ve now defined the conditional style we want to apply, but we still need
    to do the applying. The last line in `style_total_row` does this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了我们想要应用的条件样式，但我们仍然需要应用它。`style_total_row`中的最后一行执行此操作：
- en: '[PRE43]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`.apply` here expects a function that accepts a dataframe row, so it can call
    it on every row ( as we''ve seen before).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`.apply`在这里期望一个接受数据框行的函数，因此它可以在每一行上调用它（正如我们之前看到的）。'
- en: 'To complete our drilldown view, the final thing we need is to add the formatting
    and styling to `get_drilldown_table`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们的钻取视图，我们还需要添加`get_drilldown_table`的格式化和样式：
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And that's it! Our drilldown view is fully formed now. Check it out in figure
    7.14.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的钻取视图现在已经完全形成。在图7.14中查看。
- en: '![image](../Images/ch07__image014.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image014.png)'
- en: Figure 7.14 Completed drilldown view with shaded total row and formatted values
    (see chapter_7/in_progress_08 in the GitHub repo for the full code)
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.14 完成的钻取视图，带有阴影的总行和格式化值（完整代码请见GitHub仓库中的chapter_7/in_progress_08）
- en: Whew! That was a lot of work! However, we have more feature requests to address
    before we're done.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁！这真是做了很多工作！然而，在我们完成之前，我们还有更多功能请求要处理。
- en: The fragment-like behavior of st.dialog
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: st.dialog的片段式行为
- en: If you paid especially close attention in Chapter 4 where we learned about Streamlit's
    execution model, there's one aspect of how we implemented the drilldown view that
    may be puzzling you.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你特别关注了第4章中我们学习的Streamlit执行模型，那么我们实现钻取视图的一个方面可能会让你感到困惑。
- en: 'To show the dialog, we nested it under a button like this (in `dashboard.py`):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示对话框，我们将其嵌套在一个按钮下面，如下所示（在`dashboard.py`中）：
- en: '[PRE45]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: with `drilldown` being a function decorated with `st.dialog`. Within the drilldown,
    we can perform many interactions, such as selecting a dimension, or setting a
    filter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`drilldown`是一个用`st.dialog`装饰的函数。在钻入中，我们可以执行许多交互，例如选择一个维度或设置一个过滤器。'
- en: But in previous projects, we've seen that the "clicked" state of `st.button`
    only holds for a single re-run, and that whenever we interact with something nested
    under a button, the app gets re-run again, and the button click gets cleared.
    In fact, we had to jump through a bunch of hoops in chapter 4 using `st.session_state`
    to get the behavior we wanted.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但在之前的项目中，我们发现`st.button`的“点击”状态只持续一次重运行，而且每次我们与按钮下嵌套的任何东西交互时，应用都会再次运行，并且按钮点击会被清除。实际上，我们不得不在第四章跳过一系列的障碍，使用`st.session_state`来获得我们想要的行为。
- en: But we didn't need to do any of that in this case. Shouldn't interacting with
    the drilldown have caused a re-run with the button-click getting reset and the
    drilldown disappearing?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，我们不需要做任何这些。交互钻入不应该导致按钮点击重置并且钻入消失吗？
- en: This doesn't happen because of some special behavior that `st.dialog` exhibits.
    When a user interacts with a widget within an `st.dialog`-decorated function,
    only the decorated function gets re-run, *not* the entire app!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是因为`st.dialog`表现出某种特殊行为。当用户与`st.dialog`装饰的函数内的小部件交互时，只有装饰的函数会重新运行，而不是整个应用！
- en: In the above case, when someone selects a drilldown dimension, only the drilldown
    function gets re-run, and the button remains in the "clicked" state. `st.dialog`
    gets this behavior from a more general decorator called `st.fragment`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，当有人选择一个钻入维度时，只有钻入功能会重新运行，按钮保持在“点击”状态。`st.dialog`从更通用的装饰器`st.fragment`中获取这种行为。
- en: 7.6 Enabling deeplinks
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 启用deeplinks
- en: Next up on the feedback list is a complaint about not being able to share views
    on the dashboard with other people. Naturally, the CEO frequently emails his reports
    about data she sees on the dashboard after applying a variety of filters and selections.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个反馈列表上的问题是关于无法与其他人共享仪表板视图的投诉。自然地，CEO经常在应用了各种过滤器和选择后，通过电子邮件向他的报告发送他在仪表板上看到的数据。
- en: When receiving one of these, the subordinate spends a good few minutes trying
    to recreate what his boss saw on the dashboard, sometimes using trial-and-error
    to get the filters and date ranges right. "This," the CEO writes, "amounts to
    a collaboration tax."
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到这样的反馈时，下属会花很多时间尝试重新创建他的老板在仪表板上看到的内容，有时会通过试错来获取正确的过滤器和日期范围。“这，”CEO写道，“相当于一种协作税。”
- en: Decision-making through data is not an isolated activity, or shouldn't be, at
    any enterprise. You generally want at least a few other pairs of eyes to validate
    the decisions you intend to make. This presents a real problem for users of our
    dashboard currently.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数据做出决策不是一项孤立的活动，或者在任何企业中都不应该是。你通常至少希望有其他几对人眼来验证你打算做出的决策。这对我们仪表板的当前用户来说是一个真正的问题。
- en: 'Using the dashboard, they may identify a trend or data point that is key to
    a decision the company is evaluating. However, if they are to share it with someone
    else, they have two options: either screenshot the app or give the sharee instructions
    on how to recreate the view.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仪表板，他们可能识别出对公司正在评估的决策至关重要的趋势或数据点。然而，如果他们要与别人分享，他们有两个选择：要么截图应用，要么给分享者提供如何重新创建视图的说明。
- en: Neither of these is ideal. A screenshot prevents the other person from interacting
    with the app further, and the other way is decidedly low-tech (imagine a user
    telling someone, "You're doing it wrong. You need to apply a date range of last
    year, filter for the 18-25 age group, and choose a monthly granularity!").
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都不是理想的。截图阻止了其他人进一步与应用交互，而另一种方法显然是低技术的（想象一下用户告诉某人，“你做错了。你需要应用去年的日期范围，过滤18-25岁的年龄组，并选择月度粒度！”）。
- en: Wouldn't it be nice if the user could just copy-paste the URL they're looking
    at over chat, and the recipient could go to the URL to see exactly what the first
    user was seeing? After all, this works for many other websites. For instance,
    when you use a search engine like Google or DuckDuckGo, you can send someone directly
    to the search results page by sending them your search URL.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户可以直接将他们正在查看的URL复制粘贴到聊天中，而接收者可以访问该URL并看到第一个用户看到的确切内容，那岂不是很好？毕竟，这对许多其他网站都有效。例如，当你使用像Google或DuckDuckGo这样的搜索引擎时，你可以通过发送你的搜索URL直接将某人带到搜索结果页面。
- en: This functionality is called *deeplinking*, in the sense of linking someone
    "deep" into your website.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能被称为*深度链接*，即在您的网站上链接某人“深入”。
- en: 'How do deeplinks work? Let''s take an example from the search engine DuckDuckGo.
    If you search for `"streamlit"` on duckduckgo.com, the URL of the search results
    page will be something like:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 深度链接是如何工作的？让我们以搜索引擎 DuckDuckGo 的一个例子来说明。如果您在 duckduckgo.com 上搜索“streamlit”，搜索结果页面的
    URL 将类似于：
- en: '[PRE46]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Copy-and-paste this URL in your browser and it'll take you directly to the search
    results page for the query "streamlit". The part of the URL where it says `q=streamlit`
    is what makes this possible. The URL has embedded information about the inputs
    entered by the first user, and DuckDuckGo uses this information to direct the
    second user to the right page.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将此 URL 复制并粘贴到您的浏览器中，它将直接带您到查询“streamlit”的搜索结果页面。URL 中显示 `q=streamlit` 的部分使得这一点成为可能。该
    URL 包含了第一个用户输入的信息，DuckDuckGo 使用这些信息将第二个用户引导到正确的页面。
- en: 'If we apply this logic to our app, we need two things to implement deeplinks:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这种逻辑应用到我们的应用中，实现深度链接需要两个东西：
- en: A way to embed the inputs entered by a user in the app's URL
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种在应用 URL 中嵌入用户输入的方法
- en: Given such a URL, a way to repopulate these inputs in the app automatically
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定这样的 URL，一种在应用中自动重新填充这些输入的方法
- en: 7.6.1 Using st.query_params
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 使用 st.query_params
- en: The part of the URL that contains the "extra" information after the actual address
    is called a *query string*. It is separated from the rest of the URL by a question
    mark (`?`) character. The query string is made up of several key-value pairs called
    *query parameters*, separated in turn by the ampersand (`&`) character.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: URL 中包含实际地址之后“额外”信息的那部分被称为*查询字符串*。它通过问号（`?`）字符与 URL 的其余部分分开。查询字符串由几个称为*查询参数*的键值对组成，这些键值对依次通过
    ampersand（`&`）字符分隔。
- en: 'For example, in the URL we discussed above, i.e. `https://duckduckgo.com/?t=h_&q=streamlit&ia=web`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上文中我们讨论的 URL 中，即 `https://duckduckgo.com/?t=h_&q=streamlit&ia=web`：
- en: The query string is `t=h_&q=streamlit&ia=web`
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串是 `t=h_&q=streamlit&ia=web`
- en: 'The query parameters are: `t=h_` (key `t` and value `h_`), `q=streamlit` (key
    `q` and value `streamlit`), and `ia=web` (key `ia` and value `web`).'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数是：`t=h_`（键 `t` 和值 `h_`），`q=streamlit`（键 `q` 和值 `streamlit`），以及 `ia=web`（键
    `ia` 和值 `web`）。
- en: 'If our app were to have query parameters, what would they look like? Well,
    since the query string needs to capture the inputs entered by the user, it might
    be something like the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用有查询参数，它们会是什么样子？嗯，由于查询字符串需要捕获用户输入的信息，它可能看起来像以下这样：
- en: '[PRE47]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Essentially, the user's selections need to be part of the query string (and,
    therefore, the URL).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，用户的选项需要成为查询字符串的一部分（因此，也是 URL 的一部分）。
- en: Streamlit allows you to manage query parameters through `st.query_params`, which
    is another dictionary-like object similar to `st.session_state`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 允许您通过 `st.query_params` 管理查询参数，这是一个类似于 `st.session_state` 的字典样式的对象。
- en: At any point, `st.query_params` contains whatever key-value pairs are in your
    app's URL query string. You can also modify the query string in your browser's
    address bar by modifying `st.query_params`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，`st.query_params` 包含您应用 URL 查询字符串中的所有键值对。您也可以通过修改 `st.query_params` 来修改浏览器地址栏中的查询字符串。
- en: The syntax for getting and setting parameters in `st.query_params` is identical
    to using a dictionary. For example, the code `st.query_params["pie_chart_dimension"]
    = "Gender"` would set the `pie_chart_dimension` parameter, updating the URL to
    include `pie_chart_dimension=Gender` somewhere.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `st.query_params` 中获取和设置参数的语法与使用字典相同。例如，代码 `st.query_params["pie_chart_dimension"]
    = "Gender"` 会设置 `pie_chart_dimension` 参数，更新 URL 以包含 `pie_chart_dimension=Gender`。
- en: 'You could also read in the value of the parameter like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以这样读取参数的值：
- en: '[PRE48]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Our solution, then, would involve something like figure 7.15.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的解决方案将涉及类似于图 7.15 的内容。
- en: '![image](../Images/ch07__image015.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/ch07__image015.png)'
- en: Figure 7.15 Approach for implementing deeplinking
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.15 实现深度链接的方法
- en: When someone first navigates to our app, we should extract the query parameters
    from the URL if there are any.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当某人第一次导航到我们的应用时，如果 URL 中有查询参数，我们应该从 URL 中提取它们。
- en: We then set the values of the widgets based on those parameters. For instance,
    if we have `start_date=2024-08-01` as one of the query parameters, we would set
    the start date in the date range selector widget to 2024-08-01\. If there are
    no query parameters, or no value specified for a particular widget, we don't set
    the value of the widget; instead we let the default behavior take over.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据这些参数设置小部件的值。例如，如果我们有一个 `start_date=2024-08-01` 作为查询参数之一，我们将在日期范围选择器小部件中将开始日期设置为2024-08-01。如果没有查询参数，或者没有为特定小部件指定值，我们不会设置小部件的值；相反，我们让默认行为接管。
- en: Then, when someone changes a selection in a widget, we *update* the query parameters
    to reflect that change, thus also changing the URL in the address bar. This way,
    if a user copies the URL, it always has the latest selections they've made in
    the app!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当有人在小部件中更改选择时，我们会 *更新* 查询参数以反映该更改，从而也更改地址栏中的URL。这样，如果用户复制URL，它总是包含他们在应用程序中做出的最新选择！
- en: 7.6.2 Setting widget defaults through st.session_state
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 通过 st.session_state 设置小部件默认值
- en: There's one part of our scheme that hasn't been covered in any previous chapters.
    How do we programmatically set the value of an input widget?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方案中有一个部分在之前的任何章节中都没有涉及。我们如何通过编程设置输入小部件的值？
- en: Recall from chapter 4 that every Streamlit widget (or UI element) has a unique
    identifier called a widget key. The key is usually created automatically by Streamlit,
    but if you have two identical widgets, you have to give each one a key manually
    so Streamlit can tell them apart. One neat thing I didn't mention earlier is that
    every time you provide a widget a key, its value becomes accessible in `st.session_state`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第4章，Streamlit中的每个小部件（或UI元素）都有一个唯一的标识符，称为小部件键。键通常由Streamlit自动创建，但如果您有两个相同的小部件，您必须手动为每个小部件提供一个键，以便Streamlit可以区分它们。我之前没有提到的一个巧妙之处是，每次您为小部件提供一个键时，其值就会在
    `st.session_state` 中变得可访问。
- en: 'So if you have a dropdown input coded like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您有一个如下编码的下拉输入：
- en: '[PRE49]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can access its value using `st.session_state["select_dim"]`
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `st.session_state["select_dim"]` 来访问其值
- en: 'Importantly for us, we can also *set* its value, simulating a user selection,
    like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说非常重要的一点是，我们还可以 *设置* 其值，模拟用户选择，如下所示：
- en: '[PRE50]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: One caveat is that we can only do this *before* the widget code is run. In other
    words, we can set the value of the widget key in `st.session_state` *first* and
    have the widget take on that value when it renders later, but you can't render
    the widget with a key *first* and *then* overwrite its value by setting the value
    of the key in `st.session_state`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的问题是，我们只能在 *运行小部件代码之前* 做这件事。换句话说，我们可以在 `st.session_state` 中设置小部件键的值 *首先*，然后在小部件渲染时采用该值，但您不能先渲染带有键的小部件，然后通过在
    `st.session_state` 中设置键的值来 *覆盖* 其值。
- en: 7.6.3 Implementing deeplinks
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.3 实现deeplinks
- en: We now have all the information needed to build the deeplink functionality.
    Create a new file called `query_params.py` with the content shown in listing 7.2.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了构建deeplink功能所需的所有信息。创建一个名为 `query_params.py` 的新文件，其内容如列表7.2所示。
- en: Listing 7.2 query_params.py
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2 query_params.py
- en: '[PRE51]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `get_param` function gets the value of a particular query parameter given
    its name. It does so by using the `.get()` method of `st.query_params`, which—identically
    to that of a regular dictionary—returns a default value of `None` if the key does
    not exist.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_param` 函数通过使用 `st.query_params` 的 `.get()` 方法获取特定查询参数的值。它这样做的方式与常规字典相同，如果键不存在，则返回默认值
    `None`。'
- en: '`set_widget_defaults` populates the values of various widgets in the app from
    the query parameters by iterating through them and setting the value of each widget
    key in `st.session_state`.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_widget_defaults` 通过迭代它们并设置 `st.session_state` 中每个小部件键的值，从查询参数中填充应用程序中各种小部件的值。'
- en: 'Why do we have the following condition?:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们有以下条件？：
- en: '[PRE52]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We don't necessarily want *every* key stored in `st.session_state` to appear
    in the URL, just those representing widgets. To ensure this, later on we'll prefix
    the string `'w:'` to every widget key we want in the query parameters. This gives
    us the flexibility of using `st.session_state` for other purposes should we need
    to while still being able to autopopulate widget values with it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不一定希望 `st.session_state` 中存储的 *所有* 键都出现在URL中，只是那些代表小部件的键。为了确保这一点，稍后我们将为查询参数中想要包含的每个小部件键添加前缀
    `'w:'`。这使我们能够在需要时使用 `st.session_state` 来实现其他目的，同时仍然能够使用它来自动填充小部件的值。
- en: We also don't want Streamlit to try to set the widget value from `st.query_params`
    in every re-run of the app because then *users* wouldn't be able to change the
    value. Instead, we only want to set each widget value once, when the app is being
    loaded for the first time from the parameter-embedded URL. That's why we have
    the sub-condition `key not in st.session_state`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不希望 Streamlit 在每次重新运行应用程序时尝试从 `st.query_params` 中设置小部件值，因为这样用户就无法更改值了。相反，我们只想在应用程序第一次从参数嵌入的
    URL 加载时设置每个小部件值一次。这就是为什么我们有子条件 `key not in st.session_state`。
- en: '`set_widget_defaults` fulfills the first part of what we need for deep links—the
    ability to populate widget inputs from the URL. However, we still need to change
    the query parameters whenever a user makes a selection.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_widget_defaults` 完成了我们需要的深链接的第一部分——从 URL 中填充小部件输入的能力。然而，我们仍然需要在用户做出选择时更改查询参数。'
- en: That's what the `set_params` function does. It loops through `st.session_state`,
    gets the value of every widget key and stores them in a dictionary, `query_params_dict`.
    It then populates all of `st.query_params` directly from this dictionary using
    the `from_dict` method. As I illustrated earlier, we could also have set each
    value in `st.query_params`, but I wanted to show you this way too.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `set_params` 函数所做的事情。它遍历 `st.session_state`，获取每个小部件键的值并将它们存储在一个字典中，即 `query_params_dict`。然后，它使用
    `from_dict` 方法直接从这个字典中填充所有的 `st.query_params`。正如我之前所展示的，我们也可以在 `st.query_params`
    中设置每个值，但我还想展示这种方法。
- en: Of course, for this to work, all of the widgets we want in the query parameters
    must have keys defined, starting with `'w:'`. Therefore, we'll need to go through
    all of our code and add widget keys to each widget. Not a lot of fun, I'm afraid,
    but it has to be done.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使这可行，我们想要包含在查询参数中的所有小部件都必须有键定义，以 `'w:'` 开头。因此，我们需要遍历我们所有的代码，并为每个小部件添加小部件键。这恐怕不是一件很有趣的事情，但这是必须完成的。
- en: 'Here are the changes we''ll need to make, if you''re following along:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随，以下是我们需要进行的修改：
- en: Changes to date_range_panel.py
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对 `date_range_panel.py` 的修改
- en: 'In `date_range_panel.py`, there are three date selection widgets we show the
    user. We need to add keys to each of them. These would become:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `date_range_panel.py` 文件中，我们向用户展示了三个日期选择小部件。我们需要为它们每个都添加键。这些键将变成：
- en: '[PRE53]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The exact names for the keys don't matter as long as they start with `w:`. There
    is an additional wrinkle here though.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 只要键以 `w:` 开头，键的确切名称并不重要。不过这里有一个额外的复杂性。
- en: Notice that we currently assign default values `THIRTY_DAYS_AGO` and `TODAY`
    to the start and end date selectors respectively, through the `value` parameter
    in `st.date_input`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们目前通过 `st.date_input` 中的 `value` 参数将默认值 `THIRTY_DAYS_AGO` 和 `TODAY` 分别分配给开始和结束日期选择器。
- en: When we use `st.session_state` to set widget values—as we're doing in the `set_widget_defaults`
    function we created earlier—Streamlit will throw an error if we *also* try to
    set the value using the `value` parameter. We can't use both methods, we have
    to choose one.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `st.session_state` 来设置小部件值——就像我们在之前创建的 `set_widget_defaults` 函数中所做的那样——如果我们也尝试使用
    `value` 参数来设置值，Streamlit 将会抛出一个错误。我们不能同时使用这两种方法，我们必须选择其中一种。
- en: '[PRE54]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we've removed the `value` parameter from both widgets and added some logic
    at the beginning to set the same values using `st.session_state`. These lines
    must come before the widgets are defined.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经从两个小部件中移除了 `value` 参数，并在定义小部件之前添加了一些逻辑来使用 `st.session_state` 设置相同的值。这些行必须在定义小部件之前。
- en: 'For reference, the overall `date_range_panel` function is now:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，整体的 `date_range_panel` 函数现在如下所示：
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Changes to filter_panel.py
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对 `filter_panel.py` 的修改
- en: '`filter_panel.py` has multiselects we need to add a key to:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_panel.py` 中有我们需要添加键的多选框：'
- en: '[PRE56]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this case, since multiple widgets are populated through a loop, we use the
    f-string `f'w:filter|{dim}'` as the key, using the dimension name `dim` to differentiate
    between the keys.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于多个小部件通过循环填充，我们使用 f-string `f'w:filter|{dim}'` 作为键，使用维度名称 `dim` 来区分键。
- en: Changes to pie_chart.py and time_series_chart.py
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对 `pie_chart.py` 和 `time_series_chart.py` 的修改
- en: 'In `pie_chart.py`, add a key to the `st.selectbox` assigned to `split_dimension`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pie_chart.py` 中，向分配给 `split_dimension` 的 `st.selectbox` 添加一个键：
- en: '[PRE57]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Similarly, in `time_series_chart.py`, add keys to `grain` and `split_dimension`
    in the `time_series_chart` function:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 `time_series_chart.py` 中，向 `time_series_chart` 函数中的 `grain` 和 `split_dimension`
    添加键：
- en: '[PRE58]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With the widget keys in place, we can now call the relevant functionality we
    defined earlier in query_params.py from `dashboard.py`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件键就位后，我们现在可以从 `dashboard.py` 中调用之前在 `query_params.py` 中定义的相关功能：
- en: '[PRE59]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Pay attention to exactly where we've placed the calls to `set_widget_defaults`
    and `set_params`. As mentioned earlier, we can only use `st.session_state` to
    set widget key values *before* any of the widgets are created, so the call to
    `set_widget_defaults()` needs to go right at the top (just after `st.set_page_config(layout='wide')`
    which needs to be the first command).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们放置 `set_widget_defaults` 和 `set_params` 调用的确切位置。如前所述，我们只能在创建任何小部件之前使用 `st.session_state`
    来设置小部件键值，因此 `set_widget_defaults()` 调用需要放在最上面（紧随 `st.set_page_config(layout='wide')`
    之后，这需要是第一条命令）。
- en: On the other hand, the query parameters need to capture changes to *any* widget
    that the user has changed, so the call to `set_params` has to go at the very *end*
    of `dashboard.py`, after all the widgets have been created.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，查询参数需要捕获用户更改的任何小部件的变化，因此 `set_params` 调用必须放在 `dashboard.py` 的末尾，在所有小部件创建之后。
- en: 'Let''s test out our deeplinks! Save everything and re-run the app. Then try
    making the following selections in the app:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下我们的deeplinks！保存一切并重新运行应用程序。然后在应用程序中尝试进行以下选择：
- en: Set "Start date" to 2024/07/01, and "Compare to" to YoY.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 "开始日期" 设置为 2024/07/01，并将 "比较" 设置为 YoY。
- en: Set the "Time grain" slider in the line chart to Week.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将折线图中的 "时间粒度" 滑块设置为周。
- en: 'If you now check the URL in your browser''s address bar, it should look something
    like:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在检查浏览器地址栏中的URL，它应该看起来像：
- en: '[PRE60]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When a web URL contains certain special characters, such as a colon (`:`) or
    a space, it is converted into *percent-encoded* characters to ensure that browsers
    and web servers interpret them correctly. Each special character is usually replaced
    by a `%` sign followed by a two-digit hexadecimal code representing the original
    character in the ASCII standard. One exception is the space character, which,
    when it appears in the query parameters part of the URL, is encoded as a `+` sign.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网页URL包含某些特殊字符，例如冒号（`:`）或空格时，它会被转换为*百分编码*字符以确保浏览器和Web服务器能够正确解释它们。每个特殊字符通常会被一个
    `%` 符号后跟两个十六进制数字代码所替换，该代码代表ASCII标准中的原始字符。一个例外是空格字符，当它在URL的查询参数部分出现时，会被编码为 `+`
    符号。
- en: 'In our case, the following substitutions have occurred:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，以下替换已经发生：
- en: The colon character has become `%3A`, so `w:ts_grain` becomes `w%3Ats_grain`
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒号字符已变为 `%3A`，因此 `w:ts_grain` 变为 `w%3Ats_grain`
- en: The space character has become `+`, so `Age group` becomes `Age+group`
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格字符已变为 `+`，因此 `Age group` 变为 `Age+group`
- en: 'Reverse those substitutions and the URL becomes:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 反向替换这些值，URL变为：
- en: This is pretty much what we expected—the selections we made are reflected in
    the URL (along with the value of the pie chart dimension selectbox, which gets
    a non-blank value—`Age group`—by default, which is automatically captured in the
    URL).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们预期的——我们做出的选择反映在URL中（以及饼图维度选择框的值，它默认获得一个非空值——`Age group`，这会自动捕获到URL中）。
- en: Note
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The URL starts with http://localhost: since we''re currently developing locally.
    When we deploy our app, the localhost part will be replaced by whatever the address
    of the app is. For instance, if we deploy to Streamlit Community Cloud under [https://ceo-dashboard.streamlit.app](https://ceo-dashboard.streamlit.app),
    our URL with query parameters would look something like https://ceo-dashboard.streamlit.app?query_param1=value1&query_param2=...'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们目前正在本地开发，URL以 http://localhost: 开头。当我们部署我们的应用程序时，localhost部分将被应用程序的地址所替换。例如，如果我们部署到Streamlit
    Community Cloud下的 [https://ceo-dashboard.streamlit.app](https://ceo-dashboard.streamlit.app)，我们的带有查询参数的URL将类似于
    https://ceo-dashboard.streamlit.app?query_param1=value1&query_param2=...'
- en: Next, paste the original URL you copied into another browser tab and navigate
    to it. Unfortunately, the app throws an error (see figure 7.16).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将您复制的原始URL粘贴到另一个浏览器标签中并导航到它。不幸的是，应用程序抛出了一个错误（请参阅图7.16）。
- en: '![image](../Images/ch07__image016.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image016.png)'
- en: Figure 7.16 We get an error when we inadvertently pass a string to an st.date_input
    (see chapter_7/in_progress_09 in the GitHub repo for the full code)
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.16 当我们无意中向st.date_input传递字符串时，我们会得到一个错误（有关完整代码，请参阅GitHub仓库中的chapter_7/in_progress_09）。
- en: The error claims that we tried to pass the wrong kind of value to a "DateInput",
    presumably the "Start date" and/or "End date" widgets.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息声称我们试图向一个 "DateInput" 传递了错误类型的值，可能是 "开始日期" 和/或 "结束日期" 小部件。
- en: 'The issue here is that in the (parsed) URL above, the value given to the start
    date widget (with the key `w:start`) is the string `"2024-07-01"`:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，在上面的（解析后的）URL中，分配给开始日期小部件（键为 `w:start`）的值是字符串 `"2024-07-01"`：
- en: '[PRE61]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When Streamlit tries to assign this value to the date input widget when it's
    eventually defined, it results in an error because `st.date_input` expects a date
    object, not a string.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当Streamlit试图将此值分配给最终定义的日期输入小部件时，它会导致错误，因为`st.date_input`期望一个日期对象，而不是字符串。
- en: 'There''s a similar problem with our filter inputs: these widgets expect lists
    (as you can select multiple values), but we''re passing strings.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过滤器输入也存在类似的问题：这些小部件期望列表（因为您可以选择多个值），但我们传递的是字符串。
- en: We need some special handling logic for when the value to be set is not a string
    but a date or a list.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当要设置的值不是字符串而是日期或列表时，我们需要一些特殊的处理逻辑。
- en: 'Firstly, when setting the value of such a widget in `st.query_params`, let''s
    add a prefix to denote that the value we''re placing is a list or a date—say `L#`
    for a list and `D#` for a date. Here''s the `set_params` function in `query_params.py`
    with this modification:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当在`st.query_params`中设置此类小部件的值时，让我们添加一个前缀来表示我们放置的值是一个列表或日期——比如说，对于列表使用`L#`，对于日期使用`D#`。以下是经过修改的`query_params.py`中的`set_params`函数：
- en: '[PRE62]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, before adding a value to `query_params_dict`, we check its type using
    `isinstance`. If it's a list, we convert it to a string in a specific format (e.g.
    `['M', 'F']` becomes `L#M,F`). If it's a date, we convert it into a different
    format (e.g. `2024-08-01` becomes `D#2024-08-01`).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在将值添加到`query_params_dict`之前，我们使用`isinstance`检查其类型。如果是列表，我们将其转换为特定格式的字符串（例如，`['M',
    'F']`变为`L#M,F`）。如果是日期，我们将其转换为不同的格式（例如，`2024-08-01`变为`D#2024-08-01`）。
- en: 'We also need the reverse logic to decode these string formats and convert them
    into the original values. This part goes in the `get_param` function, which we''ll
    rewrite entirely:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要反向逻辑来解码这些字符串格式，并将它们转换回原始值。这部分代码位于`get_param`函数中，我们将完全重写它：
- en: '[PRE63]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, for a particular key, if the value is a string that starts with
    one of our special prefixes—either `L#` or `D#`—we do the reverse transformation,
    converting the string to the original list or date respectively.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于特定的键，如果值是一个以我们的特殊前缀之一开头的字符串——无论是`L#`还是`D#`——我们进行反向转换，将字符串转换为原始列表或日期。
- en: When we use this returned value in `set_widget_defaults`, it will thus be in
    the expected type, identical to the value that the user originally set, removing
    the error.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`set_widget_defaults`中使用这个返回值时，它将因此处于预期的类型，与用户最初设置的值相同，从而消除了错误。
- en: You can see for yourself by retrying the earlier steps. You should see figure
    7.17 now, demonstrating that you can now copy and paste the current URL of your
    dashboard to show others exactly what you're seeing.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重试前面的步骤亲自查看。现在您应该可以看到图7.17，展示了您现在可以复制并粘贴仪表板的当前URL，以向他人展示您所看到的确切内容。
- en: '![image](../Images/ch07__image017.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image017.png)'
- en: Figure 7.17 The widgets in the dashboard are populated based on the URL values
    (see chapter_7/in_progress_10 in the GitHub repo for the full code)
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.17 仪表板中的小部件是根据URL值填充的（有关完整代码，请参阅GitHub仓库中的chapter_7/in_progress_10）
- en: Explore the deeplinks some more. Note n' Nib's execs can now spend less time
    fiddling with the dashboard and more time making decisions that benefit the company!
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 再探索一下deeplinks。注意，Nib的执行人员现在可以花更少的时间摆弄仪表板，有更多时间做出对公司有利的决策！
- en: 7.7 Sourcing data from a data warehouse
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 从数据仓库中获取数据
- en: 'We''ve addressed all of the user feedback on the dashboard, but there''s one
    glaring practical problem with it we have yet to talk about: the data we display
    in the dashboard is sourced from a static CSV file.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了所有关于仪表板的用户反馈，但还有一个明显的实际问题我们尚未讨论：仪表板中显示的数据来自静态CSV文件。
- en: 'I chose this approach as I wanted us to focus primarily on what we do with
    the data once we have it. Reading a static CSV file is probably the easiest way
    to ingest data in our app. However, there are multiple issues with this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这种方法是因为我想让我们主要关注我们一旦拥有数据后如何处理数据。在我们的应用中，读取静态CSV文件可能是摄入数据的最简单方式。然而，这种方法存在多个问题：
- en: While a CSV is manageable when dealing with a small amount of data, it quickly
    becomes inefficient when handling large datasets.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理少量数据时，CSV文件是可管理的，但当处理大量数据集时，它很快就会变得低效。
- en: We can't query the data flexibly at the source, and instead have to load it
    in memory to perform operations like filtering, aggregations, and joins.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法在源处灵活查询数据，而必须将其加载到内存中执行过滤、聚合和连接等操作。
- en: In the real world, we would generally store this data in a *data warehouse,*
    which is a specialized system designed to manage large volumes of structured data.
    In this section, we'll swap out our CSV for a table in a data warehouse—specifically
    Google BigQuery.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们通常会把这个数据存储在 *数据仓库* 中，这是一个专门为管理大量结构化数据而设计的系统。在本节中，我们将用数据仓库中的表替换我们的 CSV
    文件——具体来说就是 Google BigQuery。
- en: 7.7.1 Getting our data into BigQuery
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 将数据导入 BigQuery
- en: Google BigQuery is a cloud-based data warehouse service that's part of the Google
    Cloud Platform (GCP). It allows you to efficiently store and analyze massive datasets
    using a language called *Structured Query Language* (SQL), without needing to
    manage infrastructure or worry about scaling.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Google BigQuery 是 Google Cloud Platform (GCP) 的一部分，是一个基于云的数据仓库服务。它允许您使用名为 *结构化查询语言*
    (SQL) 的语言高效地存储和分析大量数据集，无需管理基础设施或担心扩展问题。
- en: To begin, you'll need to set up a GCP account, which you can do at cloud.google.com.
    You'll probably need to enter details of a payment method such as a credit card,
    but you won't get charged since we're only going to be using free resources for
    this exercise.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要设置一个 GCP 账户，您可以在 cloud.google.com 上完成此操作。您可能需要输入支付方式详情，例如信用卡，但由于我们只是要使用此练习中的免费资源，您不会收到任何费用。
- en: When you create a new account, Google will also create a *GCP project* for you.
    In GCP parlance, a project is a container for organizing and managing your Google
    Cloud resources. You need one to use BigQuery; feel free to use the default one
    created for you or to create a new one. A project has a unique ID; you can choose
    what this is when you create a project, but the default one is a randomly generated
    string. For instance, my default project ID was `dauntless-brace-436702-q0`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建新账户时，Google 也会为您创建一个 *GCP 项目*。在 GCP 术语中，项目是组织和管理您的 Google Cloud 资源的一个容器。您需要有一个项目来使用
    BigQuery；您可以自由使用为您创建的默认项目或创建一个新的项目。项目有一个唯一的 ID；您可以在创建项目时选择这个 ID，但默认 ID 是随机生成的字符串。例如，我的默认项目
    ID 是 `dauntless-brace-436702-q0`。
- en: Next, let's go to BigQuery itself. Google Cloud is so vast and offers so many
    products and services that its UI may be intimidating to a beginner. The most
    reliable way to find BigQuery is probably to enter the search string "bigquery"
    in the search box at the top (see figure 7.18)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转到 BigQuery 本身。Google Cloud 非常庞大，提供的产品和服务众多，其 UI 可能会让初学者感到 intimidating。最可靠的方法可能是将搜索字符串
    "bigquery" 输入顶部的搜索框中（如图 7.18）。
- en: '![image](../Images/ch07__image018.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image018.png)'
- en: Figure 7.18 The most reliable way to find something on GCP is to use the search
    bar.
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.18 在 GCP 中找到某物的最可靠方法是使用搜索栏。
- en: Once on the BigQuery page, you should be able to see your BigQuery resources
    categorized under your GCP projects in an Explorer side panel to the left (see
    figure 7.19). "Resources" here means things like "queries", "notebooks", "workflows"
    etc., all of which you may ignore.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入 BigQuery 页面，您应该能够在左侧的探索器侧面板中看到您的 BigQuery 资源，这些资源按您的 GCP 项目分类。"资源" 这里指的是
    "查询"、"笔记本"、"工作流" 等等，所有这些都可能被忽略。
- en: What we're trying to do is to create a BigQuery table by uploading our CSV file.
    Before we can do this, we need to create a dataset. A BigQuery dataset is just
    a way to organize your tables within a project.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图通过上传我们的 CSV 文件来创建一个 BigQuery 表。在我们能够这样做之前，我们需要创建一个数据集。BigQuery 数据集只是您在项目内组织表的一种方式。
- en: Make your first dataset by clicking the three dots next to your project ID in
    the Explorer panel and then "Create dataset" (figure 7.19).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在探索器面板中点击项目 ID 旁边的三个点，然后选择 "创建数据集"（如图 7.19），来创建您的第一个数据集。
- en: '![image](../Images/ch07__image019.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image019.png)'
- en: Figure 7.19 The Explorer pane in BigQuery
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.19 BigQuery 中的探索器面板
- en: This will open a screen where you can configure the dataset. All you need to
    enter is a name (I chose `sia_ceo_dashboard`); you can use the defaults for the
    remaining options.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个屏幕，您可以配置数据集。您需要输入的只是名称（我选择了 `sia_ceo_dashboard`）；其余选项可以使用默认设置。
- en: Once created, your dataset should appear in the Explorer panel. Click the three
    dots next to it and "Create table" to get to the table creation screen where we
    can upload our file.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，您的数据集应该会出现在探索器面板中。点击它旁边的三个点，然后选择 "创建表"，以进入创建表的屏幕，在那里我们可以上传我们的文件。
- en: 'Select "Upload" under the "Create table from" options, and "CSV" as the file
    format. You can then select the `sales_data.csv` file from your local disk. You''ll
    need to pick a name for the table (`sales_data` works). The remaining options
    should be straightforward and will likely be auto-populated: your project ID,
    and the name of the dataset you just created. Figure 7.20 shows what the screen
    looks like.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在“从创建表”选项下选择“上传”，并将文件格式选为“CSV”。然后您可以从本地磁盘选择`sales_data.csv`文件。您需要为表格选择一个名称（`sales_data`是一个不错的选择）。其余选项应该是直截了当的，并且很可能会自动填充：您的项目ID和您刚刚创建的数据集名称。图7.20显示了屏幕的外观。
- en: '![image](../Images/ch07__image020.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/ch07__image020.png)'
- en: Figure 7.20 The table creation screen in BigQuery
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.20 BigQuery中的表创建屏幕
- en: Check the "Auto detect" box under "Schema" so you don't have to enter it manually.
    Then click the button at the bottom to actually create your table.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在“模式”下勾选“自动检测”框，这样您就不必手动输入。然后点击底部的按钮来实际创建您的表格。
- en: At this point, your data is in BigQuery, and the table should appear under your
    dataset in Explorer. If you like, you can click into it and go to the "Preview"
    tab to see the data.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，您数据已经在BigQuery中，表格应该出现在资源管理器中您的数据集下。如果您愿意，可以点击进入并转到“预览”标签来查看数据。
- en: 7.7.2 Setting up the Python-BigQuery connection
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.2 设置Python-BigQuery连接
- en: We can now access our data in the BigQuery interface, but we also need to be
    able to connect to it from our Python code.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过BigQuery界面访问我们的数据，但我们还需要能够从我们的Python代码中连接到它。
- en: Enabling the BigQuery and BigQuery Storage APIs
  id: totrans-468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用BigQuery和BigQuery存储API
- en: 'First, we need to enable a couple of BigQuery-related APIs in our GCP project:
    the BigQuery and BigQuery Storage APIs. The BigQuery API is what enables us to
    connect to BigQuery in the first place, while the Storage API makes it faster
    to ingest data into a Pandas dataframe.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的GCP项目中启用一些与BigQuery相关的API：BigQuery和BigQuery存储API。BigQuery API使我们能够首先连接到BigQuery，而存储API使得将数据快速导入Pandas数据框变得更快。
- en: In each case, the corresponding result should lead you to a page when you can
    enable the API.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，相应的结果都应引导您到一个页面，您可以在该页面启用API。
- en: Creating a service account
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建服务账户
- en: Since our app will connect to BigQuery programmatically, we need a *GCP service
    account* to handle authentication. A service account is a special type of account
    that belongs to your application instead of to an individual user. It enables
    your app to authenticate and interact with Google Cloud services, including BigQuery.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用将通过编程方式连接到BigQuery，我们需要一个*GCP服务账户*来处理身份验证。服务账户是一种特殊类型的账户，属于您的应用程序而不是个人用户。它使您的应用能够进行身份验证并与Google
    Cloud服务（包括BigQuery）交互。
- en: To create a service account, first find "IAM & Admin" and then "Service accounts"
    in the Google Cloud navigation menu (or better still, search for "service accounts"
    and click the first result.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务账户，首先在Google Cloud导航菜单中找到“IAM & Admin”，然后找到“服务账户”（或者更好的是，搜索“服务账户”并点击第一个结果）。
- en: In the "Service Accounts" page, click the option to create one. This screen
    will ask you for a service account name (I used `sia_service_account`) and description.
    Once you've created the account, you'll also need to grant it access to your project
    on the same screen. Choose the role "Viewer" when you do this.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在“服务账户”页面中，点击创建账户的选项。此屏幕将要求您输入服务账户名称（我使用了`sia_service_account`）和描述。一旦创建账户，您还需要在同一屏幕上授予它对您项目的访问权限。创建时选择“查看者”角色。
- en: Your service account should now appear in the Service Accounts page.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务账户现在应该显示在服务账户页面中。
- en: Creating a service account key
  id: totrans-476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建服务账户密钥
- en: We have a service account that can access our BigQuery resources, but we still
    need to obtain the credentials that will let our Streamlit app act *as* the service
    account. For this, we require a service account key.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个可以访问我们的BigQuery资源的服务账户，但我们仍然需要获取让我们的Streamlit应用能够以服务账户身份操作的凭证。为此，我们需要一个服务账户密钥。
- en: Find the account you just created on the Service Accounts page, click the three
    dots under "Actions" next to it, and then click "Manage keys."
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务账户页面中找到您刚刚创建的账户，点击它旁边“操作”下的三个点，然后点击“管理密钥”。
- en: Click "ADD KEY" > "Create new key" and select "JSON" as the key type. When you
    click "Create", your computer should automatically download a JSON file. Inspect
    this file in a text editor. It should contain the credentials you need to access
    BigQuery from your app, as well as additional details such as your project ID.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 "添加密钥" > "创建新密钥" 并选择 "JSON" 作为密钥类型。当你点击 "创建" 时，你的计算机应该会自动下载一个 JSON 文件。使用文本编辑器检查此文件。它应该包含你从应用程序访问
    BigQuery 所需的凭证，以及一些额外的详细信息，如你的项目 ID。
- en: Generating secrets.toml
  id: totrans-480
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成 secrets.toml
- en: The credentials we just obtained must be kept secret as they allow anyone who
    has them to read your BigQuery data. Recall from Chapter 5 that the optimal way
    to maintain confidential info in Streamlit is to use a `secrets.toml` file in
    conjunction with `st.secrets`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚获得的凭证必须保密，因为它们允许任何拥有它们的人读取你的 BigQuery 数据。回想一下第 5 章，在 Streamlit 中维护机密信息的最佳方式是使用
    `secrets.toml` 文件结合 `st.secrets`。
- en: Unfortunately, the credential file we have is in JSON, so we need to convert
    it to TOML. You can do this manually, but let's use Python instead.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们拥有的凭证文件是 JSON 格式的，因此我们需要将其转换为 TOML。你可以手动完成此操作，但让我们使用 Python 来完成。
- en: First create a `.streamlit` folder to hold your `secrets.toml`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个 `.streamlit` 文件夹来存放你的 `secrets.toml` 文件。
- en: 'Rename your JSON file to `sia-service-account.json`, then open a Python shell
    from the same folder and type in the following commands:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 JSON 文件重命名为 `sia-service-account.json`，然后从同一文件夹打开 Python 命令行，并输入以下命令：
- en: '[PRE64]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may first need to run "pip install toml" to get this to work.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先需要运行 "pip install toml" 来使这生效。
- en: All we're doing here is opening the JSON file we got from GCP, reading it into
    a Python dictionary, and writing it back to `secrets.toml` under the key "bigquery".
    If you now open `secrets.toml`, you should be able to see the credentials in TOML
    format.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是打开我们从 GCP 获得的 JSON 文件，将其读取到一个 Python 字典中，并将其写回到 `secrets.toml` 中的
    "bigquery" 键下。如果你现在打开 `secrets.toml`，你应该能够看到以 TOML 格式显示的凭证。
- en: '[PRE65]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 7.7.3 Updating the dashboard to load data from BigQuery
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.3 更新仪表板以从 BigQuery 加载数据
- en: 'It''s time to update our code to source data from BigQuery instead of a static
    CSV file. We need to install three new Python modules to enable this, so go ahead
    and enter the following commands into a terminal window:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候更新我们的代码，从 BigQuery 而不是静态 CSV 文件中获取数据源了。我们需要安装三个新的 Python 模块来实现这一点，所以请继续在终端窗口中输入以下命令：
- en: '[PRE66]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first two are needed to access the BigQuery and BigQuery Storage APIs. `db-dtypes`
    is required to enable converting the data returned by BigQuery to a Pandas dataframe.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个是访问 BigQuery 和 BigQuery Storage API 所必需的。`db-dtypes` 是必需的，以便将 BigQuery 返回的数据转换为
    Pandas 数据框。
- en: Since we wrote our code in a modular way, the only thing we need to change is
    the implementation of the `load_data` function in `data_loader.py`, and the rest
    of our app should work as before. This is an advantage of the "separation of concerns"
    principle we discussed in chapter 3.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们以模块化的方式编写了代码，我们唯一需要更改的是 `data_loader.py` 中 `load_data` 函数的实现，而我们的应用程序的其他部分应该像以前一样工作。这是我们在第
    3 章中讨论的“关注点分离”原则的优势。
- en: Listing 7.3 shows the new `data_loader.py` with `load_data` re-implemented to
    use BigQuery.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 显示了新的 `data_loader.py`，其中 `load_data` 已重新实现以使用 BigQuery。
- en: Listing 7.3 data_loader.py reimplemented to use BigQuery
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3 重新实现了 `data_loader.py` 以使用 BigQuery
- en: '[PRE67]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We keep a couple of constants at the top (`DATASET` and `TABLE`) to hold the
    names of the dataset and table we created in BigQuery.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在顶部保留了一些常量（`DATASET` 和 `TABLE`），以保存我们在 BigQuery 中创建的数据集和表的名称。
- en: 'Within `load_data`, we first save the credentials from the `bigquery` key in
    `st.secrets` to `service_account_info`. We then pass in these credentials to create
    a BigQuery client (essentially an object that contains the methods and abstractions
    needed to interact with BigQuery):'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `load_data` 中，我们首先将 `st.secrets` 中 `bigquery` 键的凭证保存到 `service_account_info`。然后我们将这些凭证传递进去创建一个
    BigQuery 客户端（本质上是一个包含与 BigQuery 交互所需的方法和抽象的对象）：
- en: '[PRE68]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We want to use the same credentials in the BigQuery Storage API client too,
    so we extract the credentials from the BigQuery client and use them to initialize
    `storage_client`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在 BigQuery Storage API 客户端中也使用相同的凭证，因此我们从 BigQuery 客户端提取凭证，并使用它们来初始化 `storage_client`：
- en: '[PRE69]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Our connection is now established.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已建立连接。
- en: 'Tables in BigQuery are referred to using a dot-separated combination of the
    project ID, dataset name, and table name. For instance, the table I created would
    be referenced as:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BigQuery 中，表是通过项目 ID、数据集名称和表名称的点分隔组合来引用的。例如，我创建的表将被引用为：
- en: '[PRE70]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We obtain the project ID from the credentials (`project_id = service_account_info["project_id"]`)
    and the dataset and table names from the constants we created above.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从凭证中获取项目 ID (`project_id = service_account_info["project_id"]`)，以及从上面创建的常量中获取数据集和表名。
- en: 'We use the table reference to construct a SQL query like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用表引用来构建这样的 SQL 查询：
- en: '[PRE71]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We'll encounter more SQL in chapter 8, but for the moment, all you need to understand
    is that "`SELECT * from <table>`" means "get me all the columns from `<table>`".
    Essentially, we're telling BigQuery to return all the data in the table.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，我们将遇到更多的 SQL，但就目前而言，你需要理解的是，“`SELECT * from <table>`”意味着“从 `<table>`
    获取所有列”。本质上，我们是在告诉 BigQuery 返回表中的所有数据。
- en: Though we're not doing it here, we could have used a different SQL query to
    obtain some *subset* of the data; we couldn't have done this if we were still
    using a CSV file.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里没有这样做，但我们本可以使用不同的 SQL 查询来获取数据的某些 *子集*；如果我们还在使用 CSV 文件，我们就无法这样做。
- en: 'The next two lines execute the query itself, wait for it to finish, and save
    the results to result:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行执行查询本身，等待其完成，并将结果保存到 result：
- en: '[PRE72]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Lastly, we convert the result to a Pandas dataframe, utilizing the BigQuery
    Storage client for optimized performance, and return the dataframe.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 BigQuery 存储客户端来优化性能，将结果转换为 Pandas 数据框，并返回数据框。
- en: If you execute `streamlit run dashboard.py` again (you can't just re-run the
    app in the browser since we're using `st.cache_data` and simply re-running would
    return a previously cached version), the app will now pull data from BigQuery!
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次执行 `streamlit run dashboard.py`（由于我们使用了 `st.cache_data`，你无法在浏览器中重新运行应用程序，因为这会返回之前缓存的版本），应用程序现在将从
    BigQuery 中拉取数据！
- en: 7.7.4 Notes on deployment to Streamlit Community Cloud
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.4 Streamlit 社区云部署注意事项
- en: In chapter 5, we explored how to deploy our apps to Streamlit Community Cloud.
    The process to do so remains the same for our metrics dashboard, but I want to
    call out a couple of things.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，我们探讨了如何将我们的应用程序部署到 Streamlit 社区云。为此所做的过程对我们指标仪表板来说仍然相同，但我想要强调几点。
- en: The first is related to where we store the data. When deploying, if you're using
    the static CSV approach to source the data, you need to commit the CSV file in
    git, essentially storing it in your GitHub repo.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分与数据存储位置有关。在部署时，如果你使用静态 CSV 方法来获取数据，你需要将 CSV 文件提交到 git 中，本质上是在你的 GitHub 仓库中存储它。
- en: If you're using BigQuery instead, the CSV is obviously not required, and you
    don't have to check it into your repository. However, you do need to configure
    your GCP credentials in Streamlit Community Cloud using the same process we used
    in Chapter 5.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 BigQuery，显然不需要 CSV，你也不必将其检入你的仓库。然而，你确实需要在 Streamlit 社区云中使用我们在第 5 章中使用的过程来配置你的
    GCP 凭证。
- en: You'll also need to create a `requirements.txt` with all the modules we're using
    and need Community Cloud to install. As discussed in chapter 5, you can use the
    `pip freeze` command to identify the specific versions of the libraries we're
    using.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要创建一个包含我们使用和需要的所有模块的 `requirements.txt` 文件，并让社区云进行安装。如第 5 章所述，你可以使用 `pip
    freeze` 命令来识别我们使用的库的具体版本。
- en: An example `requirements.txt` for the dashboard is provided in listing 7.4.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 提供了仪表板的示例 `requirements.txt`。
- en: Listing 7.4 requirements.txt
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4 requirements.txt
- en: '[PRE73]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We're finally all set to release version 2.0 of our dashboard! Without a doubt,
    there will be more feedback later, and each iteration will refine our dashboard
    further.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好发布仪表板的 2.0 版本了！毫无疑问，之后会有更多的反馈，每一次迭代都会进一步改进我们的仪表板。
- en: For now, however, it's time to bid farewell to Note n' Nib and its data needs.
    In the next chapter, we're shifting gears from data insights to interactive tools,
    as we dive into a web app for creating, storing, and sharing haikus.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在是我们告别 Note n' Nib 及其数据需求的时候了。在下一章中，我们将从数据洞察转向交互式工具，因为我们深入到一个用于创建、存储和共享俳句的
    Web 应用程序。
- en: 7.8 Summary
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 概述
- en: '*Launching* an app is only the first part of making it successful. You also
    have to *land* it, making sure that it serves your users'' needs. For this, it
    is critical to hear from users directly.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动* 应用程序只是使其成功的第一步。你还需要 *着陆* 它，确保它满足用户的需求。为此，直接听取用户的反馈至关重要。'
- en: '`st.select_slider` is a cross between `st.selectbox` and `st.slider`, used
    when you want to impose a logical order between options.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.select_slider` 是 `st.selectbox` 和 `st.slider` 的结合，用于当你想要在选项之间施加逻辑顺序时使用。'
- en: '`st.metric` can show the delta associated with a metric, i.e. how a value has
    changed over time.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.metric` 可以显示与指标相关的增量，即一个值随时间的变化情况。'
- en: '`st.dialog` is a decorator that lets you create a modal dialog, an overlay
    that blocks interaction with the rest of the app.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.dialog` 是一个装饰器，允许你创建一个模态对话框，一个覆盖层，它会阻止与应用程序其余部分的交互。'
- en: You can use `st.container` to create placeholders in your app, only rendering
    the content you want to show when it's available.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `st.container` 在你的应用程序中创建占位符，只有当内容可用时才会渲染你想要显示的内容。
- en: Pandas dataframes have a style property that can be used to set conditional
    rules that modify how they are displayed on the screen.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 数据帧有一个样式属性，可以用来设置条件规则，以修改它们在屏幕上的显示方式。
- en: '`st.query_params` is a dictionary-like object that lets you read and update
    URL query parameters—this can be used to enable deeplinks in an app.'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.query_params` 是一个类似于字典的对象，允许你读取和更新 URL 查询参数——这可以用来在应用程序中启用深链接。'
- en: A data warehouse is a specialized system designed to store and retrieve large
    amounts of data.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据仓库是一个专门设计的系统，用于存储和检索大量数据。
- en: Google BigQuery—part of GCP—is an example of a data warehouse. To enable an
    app to connect to it, you need to create a service account with a key, and record
    the credentials in `st.secrets`.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google BigQuery——GCP 的一部分——是数据仓库的一个例子。要使应用程序能够连接到它，你需要创建一个带有密钥的服务帐户，并将凭据记录在
    `st.secrets` 中。
