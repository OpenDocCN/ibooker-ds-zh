- en: 9 Creating your own hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 创建你自己的hooks
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Extracting functionality into custom hooks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能提取到自定义hooks中
- en: Following the Rules of Hooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循Hooks规则
- en: Consuming a context value with a custom hook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义hook消费上下文值
- en: Encapsulating data fetching with a custom hook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义hook封装数据获取
- en: Exploring further examples of custom hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索自定义hooks的更多示例
- en: React Hooks promise to simplify component code and to promote encapsulation,
    reusability, and maintainability. They let function components work closely with
    React to manage state and hook into life-cycle events for mounting, rendering,
    and unmounting. Function components with hooks collocate related code and remove
    the need to mix unrelated code within and across the separate life-cycle methods
    of class-based components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks承诺简化组件代码并促进封装、可重用性和可维护性。它们让函数组件能够与React紧密合作来管理状态，并挂钩到生命周期事件以进行挂载、渲染和卸载。带有hooks的函数组件将相关代码集中在一起，并消除了在类组件的单独生命周期方法中混合无关代码的需要。
- en: Figure 9.1 contrasts the location of code in class-based and function-based
    versions of a `Quiz` component that loads question data and subscribes to a user
    service. Whereas the class component spreads the functionality across its methods,
    the `Quiz` function component manages local state with calls to `useState` or
    `useReducer` and wraps up the loading of question data and the subscription to
    a user service within separate calls to `useEffect`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1对比了基于类和基于函数的`Quiz`组件中代码的位置，该组件加载问题数据并订阅用户服务。而类组件将功能分散在其方法中，`Quiz`函数组件通过调用`useState`或`useReducer`来管理本地状态，并在单独的调用中使用`useEffect`来封装问题数据的加载和用户服务的订阅。
- en: '![](../Images/9-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-1.png)'
- en: Figure 9.1 React Hooks let us move related code into a single place and stop
    mixing unrelated code in life-cycle methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 React Hooks让我们将相关代码移动到单个位置，并停止在生命周期方法中混合无关代码。
- en: We could stop there, with function components containing state and effects managed
    by hooks. The `Quiz` function component already looks neater and easier to reason
    about than the class component. But in the same way that we split longer functions
    into a number of shorter functions, we can extract the work the hooks do into
    *custom hooks* outside the component, to simplify the component code and to prepare
    the functionality for reuse. For the `Quiz` component, we could load question
    data with a `useFetch` hook and subscribe to the service with a `useUsers` hook,
    for example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里停止，让函数组件包含由hooks管理的状态和效果。`Quiz`函数组件看起来比类组件更整洁，更容易理解。但就像我们将较长的函数拆分成多个较短的函数一样，我们也可以将hooks执行的工作提取到组件外部的*自定义hooks*中，以简化组件代码并准备功能以供重用。例如，对于`Quiz`组件，我们可以使用`useFetch`hook来加载问题数据，并使用`useUsers`hook来订阅服务。
- en: This chapter includes *custom hooks*, some based on code we’ve seen before (examples
    of `useEffect` from chapter 4, including hooks for fetching data) and some extending
    previous code (we create a hook to access context values from chapter 8). The
    examples illustrate how custom hooks can be made flexible with parameters and
    can provide useful return values with functions, arrays, and objects. But the
    neatness and flexibility of hooks do come with a couple of restrictions, summarized
    as the *Rules of Hooks* in section 9.2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括*自定义hooks*，一些基于我们之前看到的代码（第4章中的`useEffect`示例，包括用于获取数据的hooks）和一些扩展了之前的代码（我们创建一个hook来访问第8章中的上下文值）。这些示例说明了自定义hooks如何通过参数变得灵活，并可以通过函数、数组和对象提供有用的返回值。但hooks的整洁性和灵活性也带来了一些限制，这些限制在9.2节中总结为*Hooks规则*。
- en: Before we get serious with the rules or in-depth with the bookings app, let’s
    start with a little more detail about why custom hooks are a good thing and with
    our first two custom hooks, `useRandomTitle` and `useDocumentTitle`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究规则或对预订应用进行深入探讨之前，让我们先详细了解一下为什么自定义hooks是一件好事，以及我们的前两个自定义hooks，`useRandomTitle`和`useDocumentTitle`。
- en: 9.1 Extracting functionality into custom hooks
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 将功能提取到自定义hooks中
- en: React hooks let us manage local state in function components, access application
    state via context, and hook into life-cycle events to perform and clean up side
    effects. By keeping related code in one place, rather than spread across various
    class methods, they let us make better use of functions. We can extract commonly
    used code into separate functions, simplifying our components. Figure 9.2 shows
    how the key functionality of the `Quiz` component, loading questions and subscribing
    to a user service, could be extracted into two functions, or custom hooks, `useFetch`
    and `useUsers`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: React钩子让我们在函数组件中管理本地状态，通过上下文访问应用程序状态，并挂钩到生命周期事件以执行和清理副作用。通过将相关代码放在一个地方，而不是分散在各种类方法中，我们可以更好地利用函数。我们可以将常用代码提取到单独的函数中，简化我们的组件。图9.2展示了`Quiz`组件的关键功能，加载问题和订阅用户服务，可以被提取到两个函数中，或者自定义钩子`useFetch`和`useUsers`。
- en: '![](../Images/9-2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-2.png)'
- en: Figure 9.2 With custom hooks, we can move some state and functionality into
    separate functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 使用自定义钩子，我们可以将一些状态和功能移动到单独的函数中。
- en: With appropriately named custom hooks, the code for the `Quiz` component becomes
    shorter and easier to follow, as shown on the left of figure 9.3\. It should be
    clear that the `Quiz` component is accessing user information by calling `useUsers`
    and fetching data by calling `useFetch`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合适的自定义钩子命名，`Quiz`组件的代码变得更短，更容易理解，如图9.3的左侧所示。应该很明显，`Quiz`组件通过调用`useUsers`来访问用户信息，并通过调用`useFetch`来获取数据。
- en: '![](../Images/9-3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-3.png)'
- en: Figure 9.3 Many components can call our custom hooks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 许多组件可以调用我们的自定义钩子。
- en: Moving the functionality into custom hooks also lets us reuse that functionality
    in multiple components, and figure 9.3 shows a second component, `Chat`, calling
    the same `useUsers` hook. Particularly useful hooks can be shared across a team
    or even published and made available to developers across the world.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能移动到自定义钩子中，也让我们可以在多个组件中重用该功能，图9.3展示了第二个组件`Chat`调用相同的`useUsers`钩子。特别有用的钩子可以在团队间共享，甚至发布并使全球的开发者可用。
- en: 'Library authors can create hooks to make key functionality available to function
    components, and we look at a couple of examples—routing with React Router and
    fetching data with React Query—in chapter 10\. In this section, we say hello again
    to a simple component from chapter 4 that accesses the document’s title from within
    an effect. We consider the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 库的作者可以创建钩子，使关键功能对函数组件可用，我们在第10章中查看了一些示例——使用React Router进行路由和用React Query获取数据。在本节中，我们再次向第4章中的一个简单组件问好，该组件在效果内部访问文档的标题。我们考虑以下内容：
- en: Recognizing functionality that could be shared
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别可共享的功能
- en: Defining custom hooks outside your components
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件外部定义自定义钩子
- en: Calling custom hooks from custom hooks
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从自定义钩子中调用自定义钩子
- en: In creating our first examples, we encounter the naming convention for custom
    hooks, setting up the need for a few rules in section 9.2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的第一个示例时，我们遇到了自定义钩子的命名约定，这需要在第9.2节中设置一些规则。
- en: 9.1.1 Recognizing functionality that could be shared
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 识别可共享的功能
- en: We have a `SayHello` component that displays greetings in the document’s title.
    On first loading, the component shows a random greeting and a Say Hi button. It
    updates the greeting whenever the button is clicked, as shown in figure 9.4.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`SayHello`组件，它在文档的标题中显示问候语。首次加载时，组件显示一个随机问候语和一个“说你好”按钮。每次点击按钮时，它会更新问候语，如图9.4所示。
- en: '![](../Images/9-4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-4.png)'
- en: Figure 9.4 Three views of the browser document with different greetings as titles
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 以不同问候语为标题的浏览器文档的三个视图
- en: 'The component performs two main tasks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 组件执行两个主要任务：
- en: Chooses a greeting from a list
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中选择问候语
- en: Sets the document title to the chosen greeting
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文档标题设置为所选问候语
- en: In the subsections that follow, we extract the title-setting code into our first
    custom hook, `useDocumentTitle`, and the random title selection into our second,
    `useRandomTitle`. The original code for the `SayHello` component is shown again
    in listing 9.1, where you can see the call to the `useEffect` hook that sets the
    document’s title. (The effect in this listing now has `index` specified as a dependency;
    it sets the title only when the index changes.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将标题设置代码提取到我们的第一个自定义钩子`useDocumentTitle`中，并将随机标题选择提取到第二个`useRandomTitle`中。`SayHello`组件的原始代码再次在列表9.1中显示，其中可以看到调用`useEffect`钩子来设置文档的标题。（此列表中的效果现在指定了`index`作为依赖项；它仅在`index`更改时设置标题。）
- en: '*Live*: [https://jhijd.csb.app](https://jhijd.csb.app), *Code*: [https://codesandbox.io/s/sayhello-jhijd](https://codesandbox.io/s/sayhello-jhijd)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时演示*: [https://jhijd.csb.app](https://jhijd.csb.app)，*代码*: [https://codesandbox.io/s/sayhello-jhijd](https://codesandbox.io/s/sayhello-jhijd)'
- en: Listing 9.1 Updating the browser title
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 更新浏览器标题
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Import the useEffect hook.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 `useEffect` 钩子。
- en: ❷ Pass the useEffect hook a function, the effect.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将函数传递给 `useEffect` 钩子，作为效果。
- en: ❸ Update the browser title from inside the effect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在效果内部更新浏览器标题。
- en: ❹ Update the title only if the index changes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅当索引发生变化时更新标题。
- en: Setting a document’s title is functionality we might like to use on multiple
    pages and in multiple projects. As functions, hooks let us extract and share functionality
    easily. Components can pass arguments to our hooks, and the hooks can return state
    values and functions to give the components the powers they need to complete their
    tasks. Let’s see how.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文档的标题是我们可能在多个页面和多个项目中想要使用的功能。作为函数，钩子让我们可以轻松地提取和共享功能。组件可以将参数传递给我们的钩子，钩子可以返回状态值和函数，以赋予组件完成任务所需的权力。让我们看看如何。
- en: 9.1.2 Defining custom hooks outside your components
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 在组件外部定义自定义钩子
- en: Setting a document title is a simple example, and you could easily just re-create
    the effect whenever you want the functionality. But its simplicity lets us focus
    on the extraction to a custom hook without any cognitive strain related to what
    the effect does. Listing 9.2 shows the same friendly `SayHello` component from
    listing 9.1, this time with the effect moved into a separate function, `useDocumentTitle`,
    outside the component definition.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文档标题是一个简单的例子，你可以在需要该功能时轻松地重新创建效果。但它的简单性让我们可以专注于将提取到自定义钩子中，而不必与效果本身相关的任何认知压力。列表9.2显示了与列表9.1中相同的友好的
    `SayHello` 组件，这次效果被移动到一个单独的函数 `useDocumentTitle` 中，该函数位于组件定义之外。
- en: Listing 9.2 Extracting an effect into the `useDocumentTitle` hook
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 将效果提取到 `useDocumentTitle` 钩子中
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Define the custom hook as a function whose name begins with “use.”
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个以“use”开头的函数作为自定义钩子。
- en: ❷ Call the original useEffect hook from within the custom hook.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在自定义钩子内部调用原始的 `useEffect` 钩子。
- en: ❸ Update the document title only if the title changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅当标题发生变化时更新文档标题。
- en: ❹ Call the custom hook, passing it the title to show.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用自定义钩子，并传递要显示的标题。
- en: In listing 9.2, the custom hook has been defined outside the component but in
    the same file. You could, and often do, move the custom hook into its own file
    (or a file with multiple utility hooks) and import it into any components that
    need it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表9.2中，自定义钩子是在组件外部定义的，但在同一文件中。你可以，并且通常这样做，将自定义钩子移动到自己的文件（或包含多个实用钩子的文件）中，并将其导入任何需要它的组件中。
- en: We called the custom hook `useDocumentTitle`. When using hooks, there are a
    couple of rules to follow to keep your components running smoothly, as discussed
    in section 9.2, and starting the name of all hooks with “use” helps enforce those
    rules. It’s an important enough naming convention to warrant its own sidebar.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将自定义钩子命名为 `useDocumentTitle`。在使用钩子时，有一些规则需要遵循以保持组件的平稳运行，如第9.2节所述，并且所有钩子的名称都以“use”开头有助于强制执行这些规则。这是一个重要的命名约定，值得拥有自己的侧边栏。
- en: Start the names of custom hooks with “use”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义钩子的名称应以“use”开头
- en: To make it clear that a function is a custom hook and should follow the rules
    of hooks, start its name with `use`, for example, `useDocumentTitle`, `useFetch`,
    `useUsers`, or `useLocalStorage`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确一个函数是自定义钩子并且应该遵循钩子的规则，请以 `use` 开头命名，例如，`useDocumentTitle`、`useFetch`、`useUsers`
    或 `useLocalStorage`。
- en: It’s not only components that we can power up by calling custom hooks. Our custom
    hooks are free to make the most of extra powers too! It’s just functions calling
    functions at the end of the day.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以通过调用自定义钩子来增强组件的功能。我们的自定义钩子也可以充分利用额外的功能！毕竟，最终只是函数调用函数。
- en: 9.1.3 Calling custom hooks from custom hooks
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 在自定义钩子中调用自定义钩子
- en: In doing their jobs, your freshly sculpted hooks might perform useful tasks
    that could be extracted into their own custom hooks, with one hook calling one
    or more other hooks. And your hooks can return values to the calling component,
    either for inclusion in the UI or to update a hook-controlled state. For example,
    for the `SayHello` component in listing 9.2, we could also extract the “choose
    a random greeting” functionality. Listing 9.3 shows the final, compact form of
    our title-setting component, `SayHello`, with the key title-setting functionality
    extracted into a `useRandomTitle` hook imported from another file (shown in listing
    9.4).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行他们的工作时，你新塑造的钩子可能会执行一些有用的任务，这些任务可以被提取成它们自己的自定义钩子，其中一个钩子调用一个或多个其他钩子。并且你的钩子可以向调用组件返回值，这些值可以用于UI中，或者用于更新由钩子控制的州。例如，对于列表9.2中的`SayHello`组件，我们还可以提取“选择一个随机问候语”的功能。列表9.3显示了我们的标题设置组件`SayHello`的最终、紧凑形式，其中关键标题设置功能被提取到一个从另一个文件导入的`useRandomTitle`钩子中（如列表9.4所示）。
- en: '*Live*: [https://ynmc2.csb.app/](https://ynmc2.csb.app/), *Code*: [https://codesandbox.io/s/userandomtitle-ynmc2](https://codesandbox.io/s/userandomtitle-ynmc2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://ynmc2.csb.app/](https://ynmc2.csb.app/), *Code*: [https://codesandbox.io/s/userandomtitle-ynmc2](https://codesandbox.io/s/userandomtitle-ynmc2)'
- en: Listing 9.3 A compact, title-setting `SayHello` component
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 一个紧凑的标题设置`SayHello`组件
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Import our custom hook.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们的自定义钩子。
- en: ❷ Pass the custom hook the greetings to use and assign the function it returns
    to a variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将自定义钩子传递给要使用的问候语，并将它返回的函数分配给一个变量。
- en: ❸ Use the function returned by the hook to update the document title whenever
    the button is clicked.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用钩子返回的函数来更新文档标题，每当按钮被点击时。
- en: In listing 9.3, we pass the `useRandomTitle` hook the list of greetings from
    which to choose the document title. The hook returns a function we invoke to generate
    the next title. We have abstracted how the title is generated into the hook but,
    by using sensible hook and variable names, the component code is easy to follow.
    Figure 9.5 shows the component calling one hook, which calls another.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表9.3中，我们向`useRandomTitle`钩子传递了用于选择文档标题的问候语列表。钩子返回一个我们调用的函数来生成下一个标题。我们已经将标题的生成过程抽象到钩子中，但通过使用合理的钩子和变量名称，组件代码易于理解。图9.5显示了组件调用一个钩子，该钩子又调用另一个。
- en: '![](../Images/9-5.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-5.png)'
- en: Figure 9.5 The simplified `SayHello` component calls the `useRandomTitle` hook,
    which calls the `useDocumentTitle` hook.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 简化的`SayHello`组件调用了`useRandomTitle`钩子，该钩子又调用了`useDocumentTitle`钩子。
- en: Listing 9.4 shows the code for the `useRandomTitle` hook. It includes two hook
    calls of its own, one to the built-in `useState` hook and one to our `useDocumentTitle`
    custom hook, now moved to its own file (shown in listing 9.5).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4显示了`useRandomTitle`钩子的代码。它包括它自己的两个钩子调用，一个是对内置的`useState`钩子的调用，另一个是对我们之前提到的`useDocumentTitle`自定义钩子的调用，现在已移动到自己的文件中（如列表9.5所示）。
- en: '*Live*: [https://ynmc2.csb.app/](https://ynmc2.csb.app/), *Code*: [https://codesandbox.io/s/userandomtitle-ynmc2](https://codesandbox.io/s/userandomtitle-ynmc2)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://ynmc2.csb.app/](https://ynmc2.csb.app/), *Code*: [https://codesandbox.io/s/userandomtitle-ynmc2](https://codesandbox.io/s/userandomtitle-ynmc2)'
- en: Listing 9.4 The `useRandomTitle` custom hook calls `useDocumentTitle`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 `useRandomTitle`自定义钩子调用`useDocumentTitle`
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Import our custom hook.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们的自定义钩子。
- en: ❷ Define this function outside the hook.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在钩子外部定义此函数。
- en: ❸ Provide a default list of greetings.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提供一个默认的问候语列表。
- en: ❹ Provide a function to choose a random greeting index for the initial state.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 提供一个函数来为初始状态选择一个随机的问候语索引。
- en: ❺ Call our imported custom hook to update the document title.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用我们导入的自定义钩子来更新文档标题。
- en: ❻ Return a function so code using this hook can update the title.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回一个函数，以便使用此钩子的代码可以更新标题。
- en: The `useRandomTitle` custom hook uses the `useState` hook to manage the index
    of the title to be shown. Code that uses the hook doesn’t need to know how the
    hook manages the current title; it just needs to be able to ask for a new title
    to be shown. The hook returns a function so code that uses the hook can ask for
    the next title. The `useRandomTitle` custom hook also calls our `useDocumentTitle`
    custom hook from earlier, and the following listing shows that custom hook exported
    from its own file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRandomTitle`自定义钩子使用`useState`钩子来管理要显示的标题的索引。使用钩子的代码不需要知道钩子如何管理当前标题；它只需要能够请求显示一个新的标题。钩子返回一个函数，以便使用钩子的代码可以请求下一个标题。`useRandomTitle`自定义钩子还调用了我们之前提到的`useDocumentTitle`自定义钩子，以下列表显示了从其自己的文件中导出的该自定义钩子。'
- en: '*Live*: [https://ynmc2.csb.app/](https://ynmc2.csb.app/), *Code*: [https://codesandbox.io/s/userandomtitle-ynmc2](https://codesandbox.io/s/userandomtitle-ynmc2)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://ynmc2.csb.app/](https://ynmc2.csb.app/), *Code*: [https://codesandbox.io/s/userandomtitle-ynmc2](https://codesandbox.io/s/userandomtitle-ynmc2)'
- en: Listing 9.5 The `useDocumentTitle` hook exported from its own file
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 从其自己的文件导出的 `useDocumentTitle` hook
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Specify a parameter for the title.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为标题指定一个参数。
- en: ❷ Set the document’s title to the value passed in.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将文档的标题设置为传入的值。
- en: ❸ Update the document title only when the title value changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅当标题值改变时更新文档标题。
- en: Listings 9.3, 9.4, and 9.5, together, show how custom hooks can call custom
    hooks and return only what’s needed by components that use them. But before we
    get carried away by our extraction/abstraction enthusiasm, we need to understand
    a little about how React manages these hook calls and how to make sure they work
    as intended. Yes, there are rules!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3、9.4 和 9.5 一起展示了自定义 hooks 如何调用自定义 hooks 并仅返回组件使用时所需的内容。但在我们被我们的提取/抽象热情冲昏头脑之前，我们需要了解一下
    React 如何管理这些 hook 调用以及如何确保它们按预期工作。是的，有规则！
- en: 9.2 Following the Rules of Hooks
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 遵循 Hooks 的规则
- en: 'We’ve seen many advantages of hooks so far in this book and in this chapter.
    The way they help to organize and clarify code and their promise of efficient
    code abstraction and reuse are both very appealing. But in order for hooks to
    deliver on their promises, the React team has made some interesting implementation
    decisions. While React doesn’t generally impose too many idioms on your JavaScript,
    with hooks the team has laid down some rules:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书和这一章中我们已经看到了 hooks 的许多优点。它们帮助组织和澄清代码的方式以及它们承诺的高效代码抽象和重用都是非常有吸引力的。但是，为了让
    hooks 履行其承诺，React 团队做出了一些有趣的实现决策。虽然 React 通常不会对你的 JavaScript 强加太多惯例，但与 hooks 一起，团队已经制定了一些规则：
- en: Start the names of custom hooks with “use.”
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 hooks 的名称以 “use.” 开头。
- en: Call hooks only at the top level.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在顶层调用 hooks。
- en: Call hooks only from React functions.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在 React 函数中调用 hooks。
- en: When you call hooks like `useState` and `useEffect`, you’re enlisting React’s
    help to manage state and side effects, batch updates, calculate UI differences,
    and schedule DOM changes. For React to successfully and reliably track your components’
    state, the hook calls from those components need to be consistent in order and
    number. The three rules of hooks are there to ensure that the call order of your
    hooks doesn’t change from one render to the next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用像 `useState` 和 `useEffect` 这样的 hooks 时，你是在请求 React 的帮助来管理状态和副作用、批量更新、计算
    UI 差异以及安排 DOM 变更。为了 React 能够成功且可靠地跟踪组件的状态，这些组件中的 hook 调用需要保持一致性和数量。hooks 的三个规则就是为了确保你的
    hooks 调用顺序在渲染之间不会改变。
- en: The Rules of Hooks
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 的规则
- en: Start hook names with “use.”
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 “use.” 开头命名 hooks。
- en: Call hooks only at the top level.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在顶层调用 hooks。
- en: Call hooks only from React functions.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只在 React 函数中调用 hooks。
- en: Let’s look at the last two rules in a little more detail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看最后两个规则。
- en: 9.2.1 Call hooks only at the top level
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 只在顶层调用 hooks
- en: 'It’s important that components call hooks consistently each time they run.
    You shouldn’t call hooks only on some occasions but not on others, and you shouldn’t
    call them a different number of times each time a component runs. To help ensure
    that your hook calls are consistent, follow these conventions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 组件每次运行时都一致地调用 hooks 非常重要。你不应该在某些情况下调用 hooks，而在其他情况下不调用，也不应该在组件每次运行时以不同的次数调用它们。为了确保你的
    hook 调用一致，遵循以下约定：
- en: '*Don’t* put hooks inside conditionals.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要* 在条件语句中放置 hooks。'
- en: '*Don’t* put hooks inside loops.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要* 在循环中放置 hooks。'
- en: '*Don’t* put hooks inside nested functions.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要* 在嵌套函数中放置 hooks。'
- en: Each of those three scenarios can lead to you skipping hook calls or changing
    the number of times you call the hooks for a component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个场景中的任何一个都可能导致你跳过 hooks 的调用或改变组件调用 hooks 的次数。
- en: 'If you have an effect that should run only under certain conditions, and the
    conditions aren’t covered by the dependency array, put the conditions inside the
    effect function. *Don’t do this*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个只在特定条件下运行的副作用，并且这些条件没有被依赖数组覆盖，将条件放在副作用函数中。*不要这样做*：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Don’t put the hook call inside the condition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不要在条件中将 hook 调用放在里面。
- en: 'Hiding an effect in a condition may skip the effect depending on the condition.
    But our effects must *always* run. Instead, *do this*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件中隐藏一个副作用可能会根据条件跳过该副作用。但我们的副作用必须 *始终* 运行。相反，*这样做*：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Do put the condition inside the hook call.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将条件放在 hook 调用中。
- en: This code always calls the hook but checks the condition before performing the
    effect’s task.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码始终调用钩子，但在执行副作用任务之前检查条件。
- en: 9.2.2 Call hooks only from React functions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 只从React函数中调用钩子
- en: 'Hooks allow function components to have state and to manage when they use or
    cause side effects. Components that use hooks should be easy to understand, maintain,
    and share. Their state should be predictable and reliable. Expected changes of
    state should be visible within the component, although you might extract exact
    implementations of those state changes into custom hooks. To help your components
    work sensibly:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子允许函数组件拥有状态，并管理它们何时使用或引起副作用。使用钩子的组件应该易于理解、维护和共享。它们的状态应该是可预测和可靠的。预期的状态变化应该在组件内部可见，尽管你可能将那些状态变化的精确实现提取到自定义钩子中。为了帮助你的组件合理工作：
- en: '*Do* call hooks from React function components.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确实*可以从React函数组件中调用钩子。'
- en: '*Do* call hooks from custom hooks (with names starting with “use”).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确实*可以从自定义钩子（以“use”开头命名）中调用钩子。'
- en: Don’t call hooks from other, regular JavaScript functions. Keep your hook calls
    within function components and custom hooks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在其他常规JavaScript函数中调用钩子。请将钩子调用保持在函数组件和自定义钩子内。
- en: 9.2.3 Using an ESLint plugin for the rules of hooks
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 使用ESLint插件为钩子规则提供支持
- en: Undoubtedly, these “rules” may raise a few eyebrows. But I think the pros of
    hooks outweigh the cons of the three rules. To help you spot when you may have
    overlooked the rules in your code, there’s an ESLint plugin called `eslint-plugin-react-hooks`.
    If you’ve used `create-react-app` to generate your project skeleton, the plugin
    is already in place.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这些“规则”可能会引起一些疑问。但我认为钩子的优点超过了三条规则的缺点。为了帮助你在代码中找出可能忽略规则的情况，有一个名为`eslint-plugin-react-hooks`的ESLint插件。如果你使用`create-react-app`生成项目骨架，该插件已经就位。
- en: 9.3 Extracting further examples of custom hooks
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 提取自定义钩子的更多示例
- en: 'In chapter 4, we saw a few other examples of side effects: getting the window
    size, using local storage, and fetching data. Although we wrapped the side effects
    inside calls to `useEffect`, they were still within the embrace of the components
    using them. But the functionality is worth sharing, so let’s extract and export
    it.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们看到了一些其他副作用示例：获取窗口大小、使用本地存储和获取数据。尽管我们将副作用包裹在`useEffect`的调用中，但它们仍然在使用它们的组件的范围内。但是，这种功能值得分享，所以让我们提取并导出它。
- en: 'In this section, we create a couple more custom hooks:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了更多自定义钩子：
- en: '`useWindowSize`—Returns the height and width of the document window'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useWindowSize`—返回文档窗口的高度和宽度'
- en: '`useLocalStorage`—Gets and sets a value using the browser’s local storage API'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useLocalStorage`—使用浏览器的本地存储API获取和设置值'
- en: In section 9.4, we access context via a custom hook, and in section 9.5 we set
    up a custom hook to make it easy to fetch data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9.4节中，我们通过自定义钩子访问上下文，在第9.5节中，我们设置一个自定义钩子以简化数据获取。
- en: 'As functions, hooks can return whatever values are needed to expose their functionality.
    We’ve already seen no return value from `useDocumentTitle` and a function return
    value from `useRandomTitle`. The two examples that follow return two further types
    of values: `useWindowSize` returns an object with properties, and `useLocalStorage`
    returns an array. As you read through the examples, consider how the different
    return types work for the custom hooks and the components that use the hooks.
    First up is a hook that returns the window length and width as properties of a
    single object.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数，钩子可以返回任何所需的值以暴露其功能。我们已经看到了`useDocumentTitle`没有返回值，以及`useRandomTitle`的函数返回值。接下来的两个示例返回两种进一步类型的值：`useWindowSize`返回一个具有属性的对象，而`useLocalStorage`返回一个数组。当你阅读这些示例时，请考虑不同的返回类型如何适用于自定义钩子和使用钩子的组件。首先是一个返回单个对象属性（窗口长度和宽度）的钩子。
- en: 9.3.1 Accessing window dimensions with a useWindowSize hook
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 使用`useWindowSize`钩子访问窗口尺寸
- en: Say you want to measure the width and height of a browser window and show the
    dimensions onscreen, updating them automatically if the user resizes the window.
    Figure 9.6 shows the same window reporting its dimensions at two different sizes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想测量浏览器窗口的宽度和高度，并在屏幕上显示这些尺寸，如果用户调整窗口大小，则自动更新它们。图9.6显示了同一窗口在两个不同尺寸下报告其尺寸。
- en: '![](../Images/9-6.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-6.png)'
- en: Figure 9.6 Displaying the width and height of a window as it’s resized
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 显示窗口尺寸随其调整而变化
- en: As we saw in chapter 4, this requires adding and removing event listeners to
    the window’s resize event. With a custom hook, we can simplify the component that
    uses the dimensions. The following listing shows how simple the `WindowSizer`
    component becomes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第4章中看到的，这需要向窗口的调整大小事件添加和移除事件监听器。使用自定义钩子，我们可以简化使用尺寸的组件。以下列表显示了 `WindowSizer`
    组件变得多么简单。
- en: '*Live*: [https://zswj6.csb.app/](https://zswj6.csb.app/), *Code*: [https://codesandbox.io/s/usewindowsize-zswj6](https://codesandbox.io/s/usewindowsize-zswj6)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://zswj6.csb.app/](https://zswj6.csb.app/), *Code*: [https://codesandbox.io/s/usewindowsize-zswj6](https://codesandbox.io/s/usewindowsize-zswj6)'
- en: Listing 9.6 A compact component showing the window width and height
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 一个紧凑的组件，显示窗口宽度和高度
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Import the custom hook.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入自定义钩子。
- en: ❷ Call the hook and assign the returned dimensions to variables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用钩子并将返回的尺寸赋值给变量。
- en: ❸ Use the dimensions in the UI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在UI中使用尺寸。
- en: 'The `WindowSizer` component gets ahold of the window dimensions in a single
    line of code. It doesn’t care how the values are arrived at and doesn’t have to
    set up and tear down any event listeners itself:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowSizer` 组件通过一行代码获取窗口尺寸。它不关心值是如何得到的，也不需要自己设置和拆除任何事件监听器：'
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Any projects and components that need the dimensions can import and use the
    custom hook. The hook’s abstracted magic is shown in listing 9.7\. It performs
    the same actions as the dimension-reporting component from chapter 4, but now
    the call to `useEffect` and the event-related code is separated from any individual
    component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要尺寸的项目和组件都可以导入和使用自定义钩子。钩子的抽象魔法在列表9.7中显示。它执行与第4章中尺寸报告组件相同的操作，但现在将 `useEffect`
    调用和与事件相关的代码从任何单个组件中分离出来。
- en: '*Live*: [https://zswj6.csb.app/](https://zswj6.csb.app/), *Code*: [https://codesandbox.io/s/usewindowsize-zswj6](https://codesandbox.io/s/usewindowsize-zswj6)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://zswj6.csb.app/](https://zswj6.csb.app/), *Code*: [https://codesandbox.io/s/usewindowsize-zswj6](https://codesandbox.io/s/usewindowsize-zswj6)'
- en: Listing 9.7 The `useWindowSize` custom hook
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 `useWindowSize` 自定义钩子
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Define a function that returns the dimensions of the window.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个返回窗口尺寸的函数。
- en: ❷ Read the dimensions from the window object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从窗口对象中读取尺寸。
- en: ❸ Update the state, triggering a re-render.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新状态，触发重新渲染。
- en: ❹ Register an event listener for the resize event.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注册一个调整大小事件的监听器。
- en: ❺ Return a cleanup function to remove the listener.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回一个清理函数以移除监听器。
- en: ❻ Pass an empty array as the dependency argument.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将空数组作为依赖参数传递。
- en: ❼ Return the object containing the dimensions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 返回包含尺寸的对象。
- en: The call to `useEffect` includes an empty dependency array (it runs only when
    the calling component first mounts), and it returns a cleanup function (it removes
    the event listener when the calling component unmounts). The `useWindowSize` custom
    hook returns an object with `width` and `height` properties. The next custom hook,
    `useLocalStorage`, takes a different approach, returning an array with two elements,
    just like the `useState` hook.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 的调用包括一个空依赖数组（它只在调用组件首次挂载时运行），并返回一个清理函数（它在调用组件卸载时移除事件监听器）。`useWindowSize`
    自定义钩子返回一个具有 `width` 和 `height` 属性的对象。下一个自定义钩子 `useLocalStorage` 采用不同的方法，返回一个包含两个元素的数组，就像
    `useState` 钩子一样。'
- en: 9.3.2 Getting and setting values with a useLocalStorage hook
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 使用 useLocalStorage 钩子获取和设置值
- en: Our fourth custom hook comes from the third `useEffect` example in chapter 4\.
    We have a user picker that lets us select a user from a drop-down menu. We store
    the selected user in the browser’s local storage, so the page remembers the selected
    user from visit to visit, as shown in figure 9.7.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第四个自定义钩子来自第4章中的第三个 `useEffect` 示例。我们有一个用户选择器，允许我们从下拉菜单中选择用户。我们将所选用户存储在浏览器的本地存储中，以便页面能够记住每次访问所选的用户，如图9.7所示。
- en: '![](../Images/9-7.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-7.png)'
- en: Figure 9.7 Once you select a user, refreshing the page automatically reselects
    the same user.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 一旦选择了一个用户，刷新页面会自动重新选择相同的用户。
- en: We want our custom hook to manage setting and retrieving the selected user from
    local storage. As shown in the following listing, the `useLocalStorage` hook returns
    the user and an updater function to the `UserPicker` component as two elements
    in an array.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的自定义钩子能够管理从本地存储中设置和检索所选用户。如下所示，`useLocalStorage` 钩子将用户和一个更新函数作为数组中的两个元素返回给
    `UserPicker` 组件。
- en: '*Live*: [https://zkl7p.csb.app/](https://zkl7p.csb.app/), *Code*: [https://codesandbox.io/s/uselocalstorage-zkl7p](https://codesandbox.io/s/uselocalstorage-zkl7p)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时查看*: [https://zkl7p.csb.app/](https://zkl7p.csb.app/)，*代码*: [https://codesandbox.io/s/uselocalstorage-zkl7p](https://codesandbox.io/s/uselocalstorage-zkl7p)'
- en: Listing 9.8 A user picker component that uses local storage
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 使用本地存储的用户选择器组件
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Import the custom hook.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入自定义钩子。
- en: ❷ Call the hook with a key and initial value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用键和初始值调用钩子。
- en: ❸ Use the state and updater function returned by the hook.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用钩子返回的状态和更新函数。
- en: The `UserPicker` component uses array destructuring to assign the saved user
    and the updater function to local variables, `user` and `setUser`. Again, the
    component doesn’t care how the custom hook does its thing; it cares only about
    the saved user (so it can select the appropriate option in the drop-down list)
    and the updater function (so any change to the selection can be saved). The following
    listing shows the code we extract into the custom hook.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserPicker` 组件使用数组解构将保存的用户和更新函数分配给局部变量 `user` 和 `setUser`。同样，组件不关心自定义钩子是如何工作的；它只关心保存的用户（以便可以在下拉列表中选择适当的选项）和更新函数（以便任何对选择的更改都可以保存）。以下列表显示了我们将提取到自定义钩子中的代码。'
- en: '*Live*: [https://zkl7p.csb.app/](https://zkl7p.csb.app/), *Code*: [https://codesandbox.io/s/uselocalstorage-zkl7p](https://codesandbox.io/s/uselocalstorage-zkl7p)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时查看*: [https://zkl7p.csb.app/](https://zkl7p.csb.app/)，*代码*: [https://codesandbox.io/s/uselocalstorage-zkl7p](https://codesandbox.io/s/uselocalstorage-zkl7p)'
- en: Listing 9.9 The `useLocalStorage` custom hook
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 `useLocalStorage` 自定义钩子
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Accept a key and an initial value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接受一个键和一个初始值。
- en: ❷ Manage the state locally.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 本地管理状态。
- en: ❸ Get any local storage value for the key.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取键的任何本地存储值。
- en: ❹ Update the local state if there’s a value from local storage.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果从本地存储中有值，则更新本地状态。
- en: ❺ Rerun this effect if the key changes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果键更改，则重新运行此效果。
- en: ❻ Save the latest value to local storage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将最新值保存到本地存储。
- en: ❼ Rerun this effect for a new key or value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 重新运行此效果以使用新的键或值。
- en: ❽ Return an array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 返回一个数组。
- en: The code calls the `useState` hook to manage the selected user state locally.
    It also uses two calls to the `useEffect` hook, to retrieve any saved value from
    local storage and to save changed values. Check back in chapter 4 if you want
    a step-by-step account of how the two effects work together to use local storage
    to save and retrieve the selected user. In this chapter, we move on to a context
    we first encountered in chapter 8.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用 `useState` 钩子来管理本地选择的用户状态。它还使用了两个 `useEffect` 钩子的调用，用于从本地存储检索任何保存的值以及保存更改的值。如果您想了解这两个效果如何一起使用本地存储来保存和检索所选用户，请回顾第
    4 章。在本章中，我们将继续探讨在第 8 章首次遇到的上文。
- en: 9.4 Consuming a context value with a custom hook
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用自定义钩子消耗上下文值
- en: In chapter 8, we saw how to use React’s Context API to share values across an
    application or subtree of the application by wrapping components in a context
    provider and setting the provider’s `value` prop. Any components that consume
    the context value need to import the provider’s corresponding context object and
    pass it to the `useContext` hook. In the bookings app, multiple components need
    access to the current user, and we created a custom provider to make that value
    available across the app.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，我们看到了如何使用 React 的 Context API 通过将组件包裹在上下文提供者中并设置提供者的 `value` 属性来在应用程序或应用程序的子树中共享值。任何消耗上下文值的组件都需要导入提供者对应的上下文对象并将其传递给
    `useContext` 钩子。在预订应用中，多个组件需要访问当前用户，我们创建了一个自定义提供者来使该值在整个应用程序中可用。
- en: 'The consuming components don’t need to know where the values come from or what
    mechanism is used to make them available; we can abstract the details behind a
    custom hook. For the bookings app, let’s create a `useUser` hook that provides
    the current user and an updater function for any components that need to set the
    user. We’ll use it like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 消费组件不需要知道值来自何处或使用什么机制使它们可用；我们可以通过自定义钩子抽象这些细节。对于预订应用，让我们创建一个 `useUser` 钩子，为需要设置用户的任何组件提供当前用户和更新函数。我们将像这样使用它：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or, for components that need only the value, we do this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于只需要值的组件，我们这样做：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following listing expands on the custom user provider from chapter 8\. The
    file exports the existing provider and our new custom hook.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表扩展了第 8 章中提到的自定义用户提供者。该文件导出现有的提供者和我们新的自定义钩子。
- en: 'Branch: 0901-context-hook, File: /src/components/Users/UserContext.js'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0901-context-hook，文件：/src/components/Users/UserContext.js
- en: Listing 9.10 The `useUser` custom hook
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 `useUser` 自定义钩子
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Don’t export the contexts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不要导出上下文。
- en: ❷ Export the custom hook.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导出自定义钩子。
- en: ❸ Consume the contexts from inside the hook.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在钩子内部消耗上下文。
- en: ❹ Throw an error if the provider is missing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果提供者缺失，则抛出错误。
- en: ❺ Return the two context values in an array.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 以数组的形式返回两个上下文值。
- en: The custom hook, `useUser`, consumes the two context values set up in the provider,
    returning the user value and updater function as the two elements in an array.
    It performs a check to make sure a provider component has been used further up
    the component tree and throws an error if it’s missing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义钩子`useUser`消耗在提供者中设置的两个上下文值，返回用户值和更新函数作为数组中的两个元素。它执行检查以确保在组件树的上层使用了提供者组件，如果缺失则抛出错误。
- en: 'With our custom hook ready to go, we can simplify the components that need
    access to the current user: `UserPicker`, `UsersPage`, and `BookingDetails`. They
    no longer need to import the contexts they consume; they simply import and call
    the `useUser` hook. The following listing shows the `UserPicker` component.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义钩子已经准备好，我们可以简化需要访问当前用户的组件：`UserPicker`、`UsersPage`和`BookingDetails`。它们不再需要导入它们消耗的上下文；它们只需导入并调用`useUser`钩子。以下列表显示了`UserPicker`组件。
- en: 'Branch: 0901-context-hook, File: /src/components/Users/UserPicker.js'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0901-context-hook，文件：/src/components/Users/UserPicker.js
- en: Listing 9.11 Calling the `useUser` hook from the `UserPicker` component
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.11 从`UserPicker`组件调用`useUser`钩子
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Remove unused imports.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 删除未使用的导入。
- en: ❷ Import the custom hook.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入自定义钩子。
- en: ❸ Call the hook and assign the user and updater function to local variables.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用钩子并将用户和更新函数分配给局部变量。
- en: Because the call to `useUser` returns an array, we can destructure the return
    value by using variable names we choose. The `UserPicker` component uses `user`
    and `setUser`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`useUser`的调用返回一个数组，我们可以通过使用我们选择的变量名来解构返回值。`UserPicker`组件使用`user`和`setUser`。
- en: 'The `BookingDetails` component needs only the user, so its `useUser` call can
    look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingDetails`组件只需要用户，所以它的`useUser`调用可以看起来像这样：'
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `UsersPage` component names the current user from the context `loggedInUser`,
    so its `useUser` call can look like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersPage`组件从上下文`loggedInUser`中命名当前用户，所以它的`useUser`调用可以看起来像这样：'
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With more functionality moved into custom hooks, the components themselves become
    simpler, starting to resemble presentational components that just receive and
    display state. Before hooks, presentational components would leave any business
    logic to wrapper components. With hooks, the business logic can be more easily
    encapsulated, reused, and shared.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多功能被移动到自定义钩子中，组件本身变得更加简单，开始类似于仅接收和显示状态的展示组件。在钩子之前，展示组件会将任何业务逻辑留给包装组件。有了钩子，业务逻辑可以更容易地封装、重用和共享。
- en: Challenge 9.1
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战9.1
- en: Update the `UsersPage` and `BookingDetails` components to call the `useUser`
    hook rather than the `useContext` hook. The current branch, 0901-context-hook,
    already has the latest code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`UsersPage`和`BookingDetails`组件以调用`useUser`钩子而不是`useContext`钩子。当前分支0901-context-hook已经包含了最新的代码。
- en: 9.5 Encapsulating data fetching with a custom hook
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 使用自定义钩子封装数据获取
- en: It’s common for multiple components in an application to display data, usually
    fetched from data sources over a network or over the internet. As our applications
    get bigger and the data consumed by components starts to intersect, we may need
    to reach for centralized data stores that efficiently manage retrieval, caching,
    and updating. (We look at the React Query library in chapter 10.) But many applications
    function perfectly well with components fetching their own data, usually within
    calls to the `useEffect` hook. Often, all that changes from component to component
    is the URL from which to grab the data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，多个组件显示数据是很常见的，通常是从网络或互联网上的数据源获取的。随着我们的应用程序变大，组件消耗的数据开始交叉，我们可能需要使用集中式数据存储，这些存储可以有效地管理检索、缓存和更新。（我们将在第10章中查看React
    Query库。）但许多应用程序在组件使用自己的数据时运行得很好，通常是在`useEffect`钩子的调用中。通常，组件之间唯一的变化是从中获取数据的URL。
- en: 'In this section, we create a custom hook for fetching data. We supply the hook
    with the URL, and it returns the data, along with a status value and maybe an
    error object if something goes wrong. We use the hook like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个用于获取数据的自定义钩子。我们向钩子提供URL，它返回数据，以及一个状态值，如果出现错误，可能还会返回一个错误对象。我们这样使用钩子：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the hook returns an object with the three properties we need.
    The hook works equally well for fetching users or bookables in our example app.
    Bookings, however, require a bit of extra work to be most useful, so we’ll create
    a specialized hook for fetching those. This section is divided into three parts:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，钩子返回了一个包含我们需要的三个属性的对象。钩子在我们的示例应用程序中对于获取用户或可预订项同样有效。然而，预订需要一些额外的工作才能变得最有用，因此我们将创建一个专门的钩子来获取这些。本节分为三个部分：
- en: Creating the `useFetch` hook
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `useFetch` 钩子
- en: Using the data and status values that the `useFetch` hook returns
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useFetch` 钩子返回的数据和状态值
- en: 'Creating a more specialized data-fetching hook: `useBookings`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建更专业的数据获取钩子：`useBookings`
- en: The `useFetch` hook could be used in multiple projects, so let’s look at it
    in some detail.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetch` 钩子可以在多个项目中使用，因此让我们详细地看看它。'
- en: 9.5.1 Creating the useFetch hook
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 创建 `useFetch` 钩子
- en: Our custom `useFetch` hook accepts a URL and returns an object with `data`,
    `status`, and `error` properties, as shown in listing 9.12\. It uses the `useState`
    hook to manage the data (which could be `undefined`, a primitive, an object, or
    an array), the status (which can be `idle`, `loading`, `success`, or `error`),
    and the error object (which can be `null` or a JavaScript error object). The hook
    uses our `getData` API function from within `useEffect`, just as our components
    did in previous chapters.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制 `useFetch` 钩子接受一个 URL 并返回一个包含 `data`、`status` 和 `error` 属性的对象，如列表 9.12
    所示。它使用 `useState` 钩子来管理数据（可能是 `undefined`、基本类型、对象或数组），状态（可以是 `idle`、`loading`、`success`
    或 `error`），以及错误对象（可以是 `null` 或 JavaScript 错误对象）。钩子使用我们来自 `useEffect` 内部的 `getData`
    API 函数，就像我们之前的章节中组件所做的那样。
- en: 'Branch: 0902-use-fetch, File: /src/utils/useFetch.js'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0902-use-fetch，文件：/src/utils/useFetch.js
- en: Listing 9.12 The `useFetch` hook
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 `useFetch` 钩子
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Set the initial status as “idle.”
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将初始状态设置为“idle。”
- en: ❷ Just before sending a request, set the status to “loading.”
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在发送请求之前，将状态设置为“loading。”
- en: ❸ If the data comes back successfully, set the status to “success.”
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果数据成功返回，将状态设置为“success。”
- en: ❹ If there was a problem fetching, set the status to “error.”
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果在获取数据时出现问题，将状态设置为“error。”
- en: Rather than using Booleans like `isLoading` and `isError`, the `useFetch` hook
    uses a `status` value, set to a string. (Rather than having strings scattered
    across the application, it would be better to export the possible status values
    as variables from their own file and import them wherever they’re needed. But
    for the purposes of the example app, we’ll stick with the simpler, if slightly
    more error-prone, naked string approach.) Components that call `useFetch` can
    check the status to decide what UI to return. To see `useFetch` in action, let’s
    update the `BookablesList` component, making use of the `status` value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `isLoading` 和 `isError` 这样的布尔值不同，`useFetch` 钩子使用一个 `status` 值，设置为字符串。（而不是在应用程序中散布字符串，最好是将可能的状态值作为变量从它们自己的文件中导出，并在需要的地方导入。但为了示例应用程序的目的，我们将坚持使用更简单、但稍微容易出错的无装饰字符串方法。）调用
    `useFetch` 的组件可以检查状态以决定返回什么 UI。为了看到 `useFetch` 的实际应用，让我们更新 `BookablesList` 组件，利用
    `status` 值。
- en: 9.5.2 Using the data, status, and error values the useFetch hook returns
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 使用 `useFetch` 钩子返回的数据、状态和错误值
- en: We designed the `useFetch` hook to return more than just the data; it also gives
    us a `status` string and an `error` object. The status is great for deciding what
    UI to show, and the updated `BookablesList` component in listing 9.13 uses it
    to choose between an error message, a loading spinner, or the list of bookables.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计 `useFetch` 钩子不仅返回数据，还提供了一个 `status` 字符串和一个 `error` 对象。状态对于决定显示什么 UI 非常有用，列表
    9.13 中的更新后的 `BookablesList` 组件就使用了它来在错误消息、加载指示器或可预订项列表之间进行选择。
- en: 'Branch: 0902-use-fetch, File: src/components/Bookables/BookablesList.js'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0902-use-fetch，文件：src/components/Bookables/BookablesList.js
- en: Listing 9.13 Calling the `useFetch` hook from the `BookablesList` component
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 从 `BookablesList` 组件调用 `useFetch` 钩子
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Import our new useFetch hook.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们新的 `useFetch` 钩子。
- en: ❷ Call useFetch and destructure the object it returns.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 `useFetch` 并解构返回的对象。
- en: ❸ Select the first bookable when the bookables load.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当可预订项加载时选择第一个可预订项。
- en: ❹ Check the status to see if an error has occurred.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查状态以查看是否发生错误。
- en: ❺ Display the message property of the error object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 显示错误对象的 `message` 属性。
- en: ❻ Check the status to see if the bookables are loading.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查状态以查看可预订项是否正在加载。
- en: 'Listing 9.13 calls `useFetch` and destructures the object it returns, assigning
    the properties to local variables:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13调用`useFetch`并解构返回的对象，将属性分配给局部变量：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It assigns the `data` property to the `bookables` variable and includes a default
    value of an empty array for when the `data` property is `undefined`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`data`属性赋值给`bookables`变量，并在`data`属性为`undefined`时包含一个空数组的默认值：
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you check our implementation of `useFetch` in listing 9.12, you’ll see that
    no initial value was passed to `useState` for the `data` value, and it’s explicitly
    set to `undefined` every time a new data fetch is started. `useFetch` returns
    the data fetched from the server or `undefined`. When destructuring an object,
    JavaScript assigns a specified default value whenever the property value is `undefined`.
    `BookablesList` uses that behavior to assign an empty array to `bookables` whenever
    `data` is `undefined`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查我们的`useFetch`实现（列表9.12），你会看到没有为`data`值传递给`useState`的初始值，并且每次启动新的数据获取时都明确将其设置为`undefined`。`useFetch`返回从服务器获取的数据或`undefined`。在解构对象时，JavaScript会在属性值为`undefined`时分配指定的默认值。"BookablesList"利用这种行为，当`data`为`undefined`时，将空数组分配给`bookables`。
- en: Challenge 9.2
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战9.2
- en: Update the `UserPicker` and `UsersList` components to call `useFetch` to get
    the list of users from the database. Use the `status` value to determine what
    UI to show. Again, the current branch, 0902-use-fetch, already has the changed
    files.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`UserPicker`和`UsersList`组件以调用`useFetch`从数据库获取用户列表。使用`status`值来确定要显示的UI。再次强调，当前分支0902-use-fetch已经包含了更改的文件。
- en: '9.5.3 Creating a more specialized data-fetching hook: useBookings'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 创建更专业的数据获取钩子：useBookings
- en: Custom hooks make it easy to encapsulate and share functionality across components,
    and our `useFetch` hook makes it easy to fetch data from any component. We have
    the `BookablesList`, `UserPicker`, and `UsersList` components all calling `useFetch`
    to manage their data-loading only when they first mount. For interactive applications,
    though, we continue fetching data in response to user choices. For example, the
    bookings grid displays bookings for a chosen bookable and week, as shown in figure
    9.8, and the user can choose new bookables and new weeks at will, so we need to
    fetch new data to keep everything synchronized.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义钩子使得在组件之间封装和共享功能变得容易，我们的`useFetch`钩子使得从任何组件中获取数据变得简单。我们有`BookablesList`、`UserPicker`和`UsersList`组件都调用`useFetch`来管理它们的数据加载，仅在它们首次挂载时。对于交互式应用程序，尽管如此，我们仍然在用户选择时继续获取数据。例如，预订网格显示所选可预订项和周的预订，如图9.8所示，用户可以随意选择新的可预订项和新的周，因此我们需要获取新的数据以保持一切同步。
- en: '![](../Images/9-8.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-8.png)'
- en: Figure 9.8 The `BookingsGrid` shows bookings for a chosen bookable (Meeting
    Room) and week (containing 2020-06-24).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 `BookingsGrid`显示了所选可预订项（会议室）和周（包含2020-06-24）的预订。
- en: 'To display a grid filled with bookings, we generate the grid for the chosen
    bookable and week and transform the bookings data into a form that’s easy to reference
    when filling the grid. So, there’s more to it than just fetching the bookings.
    We’ll split the code into three parts:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示一个填充了预订的网格，我们为所选可预订项和周生成网格，并将预订数据转换成在填充网格时易于参考的形式。所以，这不仅仅是获取预订那么简单。我们将代码分为三个部分：
- en: '`useBookings`—A custom hook to load and transform the booking data'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useBookings`——一个自定义钩子，用于加载和转换预订数据'
- en: '`useGrid`—A custom hook to generate the empty grid of booking slots'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useGrid`——一个自定义钩子，用于生成空的预订时段网格'
- en: '`BookingsGrid`—The updated component that calls the two custom hooks'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BookingsGrid`——调用两个自定义钩子的更新组件'
- en: The relationships of the three parts are shown in figure 9.9, which includes
    one component, three custom hooks, and two built-in React hooks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 三个部分的相互关系如图9.9所示，其中包括一个组件、三个自定义钩子和两个内置的React钩子。
- en: '![](../Images/9-9.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-9.png)'
- en: Figure 9.9 The `BookingsGrid` component calls the `useBookings` and `useGrid`
    custom hooks, and the `useBookings` hook calls the `useFetch` custom hook. React’s
    `useMemo` and `useEffect` hooks are also used.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 `BookingsGrid`组件调用`useBookings`和`useGrid`自定义钩子，`useBookings`钩子调用`useFetch`自定义钩子。React的`useMemo`和`useEffect`钩子也被使用。
- en: Okay, let’s dig in to the code, starting with the two custom hooks, `useBookings`
    and `useGrid`, in a new bookingsHooks.js file.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们深入代码，从新的bookingsHooks.js文件中的两个自定义钩子`useBookings`和`useGrid`开始。
- en: useBookings
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: useBookings
- en: This is where more specialized custom hooks can come in handy. Listing 9.14
    shows the `useBookings` hook. It fetches bookings data for a specified bookable
    ID, start date, and end date. It also uses our previously created `transformBookings`
    function to return the data in a format that the bookings grid finds easy to work
    with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是更专业的自定义钩子可以派上用场的地方。列表 9.14 展示了 `useBookings` 钩子。它为指定的可预订 ID、开始日期和结束日期获取预订数据。它还使用我们之前创建的
    `transformBookings` 函数，以预订网格易于处理的数据格式返回数据。
- en: 'Branch: 0903-use-bookings, File: /src/components/Bookings/bookingsHooks.js'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0903-use-bookings，文件：/src/components/Bookings/bookingsHooks.js
- en: Listing 9.14 The `useBookings` hook
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 `useBookings` 钩子
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Import our useFetch custom hook.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们的 useFetch 自定义钩子。
- en: ❷ Use parameters to specify the data to fetch.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用参数指定要获取的数据。
- en: ❸ Build the query string for the specified data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为指定数据构建查询字符串。
- en: ❹ Call the useFetch hook with the specific URL.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用特定的 URL 调用 useFetch 钩子。
- en: ❺ Transform loaded data before returning it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在返回之前转换加载的数据。
- en: 'The `useBookings` hook uses the `bookableId` and the `startDate` and `endDate`
    values converted to strings, `start` and `end`, to build the URL for the specific
    data we want, in a format that our data server, `json-server`, understands:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`useBookings` 钩子使用转换为字符串的 `bookableId`、`startDate` 和 `endDate` 值，即 `start`
    和 `end`，来构建我们想要获取的特定数据的 URL，这是我们的数据服务器 `json-server` 能够理解的形式：'
- en: '[PRE24]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9.14 splits the query string across two lines to fit this book’s formatting,
    but it’s the same string. Our `useBookings` hook then passes the generated URL
    to our `useFetch` hook to grab the `data`, `status`, and `error` values wrapped
    in an object it assigns to `query`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 将查询字符串拆分为两行以适应本书的格式，但它是一个相同的字符串。然后我们的 `useBookings` 钩子将生成的 URL 传递给我们的
    `useFetch` 钩子，以获取 `data`、`status` 和 `error` 值，这些值被封装在一个对象中，该对象被分配给 `query`：
- en: '[PRE25]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, just like the `useFetch` hook, the `useBookings` hook returns an object
    with the data and status and error values. As it’s a more specialized data-fetching
    hook, we rename the `data` property to `bookings`. We could call it `data` to
    make it consistent with `useFetch` but, seeing as we’re using it only to fetch
    bookings, calling it `bookings` seems like a good choice, and the `data` property
    will still be there in the return object because the query object (`data`, `status`,
    and `error`) is spread into the return object too.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像 `useFetch` 钩子一样，`useBookings` 钩子返回一个包含数据和状态以及错误值的对象。作为一个更专业的数据获取钩子，我们将
    `data` 属性重命名为 `bookings`。我们可以将其称为 `data` 以保持与 `useFetch` 的一致性，但鉴于我们只使用它来获取预订，将其称为
    `bookings` 看起来是一个不错的选择，并且 `data` 属性仍然会在返回对象中，因为查询对象（`data`、`status` 和 `error`）也被扩展到返回对象中。
- en: useGrid
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: useGrid
- en: Each bookable can be booked only on certain days of the week and for certain
    sessions during the day. The `BookingsGrid` component displays the appropriate
    grid for the current bookable. But, to run the grid creation logic only when the
    bookable changes, we wrap the call to `getGrid` in the `useMemo` hook. Although
    this code could happily remain within the `BookingsGrid` itself, we pull it into
    its own custom hook, `useGrid`, shown in the following listing, to continue our
    component simplification process.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可预订项目只能在每周的某些天和一天中的某些时段进行预订。`BookingsGrid` 组件显示当前可预订项目的适当网格。但是，为了仅在可预订项目更改时运行网格创建逻辑，我们将对
    `getGrid` 的调用包裹在 `useMemo` 钩子中。尽管这段代码可以愉快地保留在 `BookingsGrid` 本身中，但我们将其拉入自己的自定义钩子
    `useGrid`，如下所示，以继续我们的组件简化过程。
- en: 'Branch: 0903-use-bookings, File: /src/components/Bookings/bookingsHooks.js'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0903-use-bookings，文件：/src/components/Bookings/bookingsHooks.js
- en: Listing 9.15 The `useGrid` hook
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 `useGrid` 钩子
- en: '[PRE26]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `useGrid` and `useBookings` hooks could remain in the same file as `BookingsGrid`
    because that’s the only place they’re used, but we’ll have more booking hooks
    and utility functions later in the book, so a dedicated bookingsHooks.js file
    will work for us. I’ve mostly tended toward splitting functions, hooks, and components
    into their own files for the purposes of the code listings in this book. But don’t
    feel that that’s a recommendation; you can follow a course that makes the most
    sense and is the most useful to you and your team.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`useGrid` 和 `useBookings` 钩子可以保留在同一个文件中，与 `BookingsGrid` 一起，因为它们只在那里使用，但本书后面会有更多的预订钩子和实用函数，所以一个专门的
    bookingsHooks.js 文件对我们来说将更合适。我主要倾向于将函数、钩子和组件分开到各自的文件中，以便于本书的代码列表。但请不要认为这是一个推荐；你可以遵循对你和你的团队最有意义且最有用的课程。'
- en: With our hooks ready and waiting, let’s put the `bookings`, `status`, and `error`,
    and `grid`, `sessions`, and `dates` values they return to good use in the `BookingsGrid`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的钩子已经准备就绪，现在让我们在`BookingsGrid`中充分利用`bookings`、`status`和`error`以及`grid`、`sessions`和`dates`返回的值。
- en: BookingsGrid
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: BookingsGrid
- en: With our two new custom hooks, `useBookings` and `useGrid`, in place, we can
    update the `BookingsGrid` component to call them. As the following listing shows,
    with functionality hidden away in the custom hooks, `BookingsGrid` itself is almost
    exclusively concerned with displaying the grid and its bookings.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的两个新自定义钩子`useBookings`和`useGrid`就位后，我们可以更新`BookingsGrid`组件以调用它们。如下所示，随着功能被隐藏在自定义钩子中，`BookingsGrid`本身几乎只关注显示网格及其预订。
- en: 'Branch: 0903-use-bookings, File: /src/components/Bookings/BookingsGrid.js'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0903-use-bookings，文件：/src/components/Bookings/BookingsGrid.js
- en: Listing 9.16 The `BookingsGrid` component
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.16 `BookingsGrid`组件
- en: '[PRE27]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Import our new custom hooks.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们的新自定义钩子。
- en: ❷ Call the useBookings hook with the specified bookable and dates.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用指定的可预订项和日期调用`useBookings`钩子。
- en: ❸ Call the useGrid hook with the specified bookable and date.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用指定的可预订项和日期调用`useGrid`钩子。
- en: ❹ Deselect the booking when switching weeks or bookables.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在切换周或可预订项时取消预订。
- en: ❺ Use the status value to check if the bookings are available.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用状态值检查预订是否可用。
- en: ❻ Use the status value to check for an error.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用状态值检查是否有错误。
- en: ❼ Display the error message.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 显示错误消息。
- en: ❽ Use the status value to set the class of the grid.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用状态值设置网格的类。
- en: The component now uses the `status` and `error` values that `useBookings` returns
    to enable interaction with the grid and show a message if there’s a problem.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件现在使用`useBookings`返回的`status`和`error`值来与网格交互，并在出现问题时显示消息。
- en: Moving functionality into custom hooks has made our components simpler and made
    it easier to share functionality across components and projects. Our custom hook
    examples became increasingly sophisticated over the course of the chapter, but
    they’re just scratching the surface of what can be achieved. In chapter 10, we
    introduce third-party hooks for routing and data fetching, and start to see how
    custom hooks let us access the power of existing third-party libraries with ease.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能移动到自定义钩子中使我们的组件更简单，并使跨组件和项目共享功能变得更容易。我们的自定义钩子示例在章节过程中变得越来越复杂，但它们只是触及了可以实现的表面。在第10章中，我们介绍了用于路由和数据获取的第三方钩子，并开始看到自定义钩子如何让我们轻松访问现有第三方库的力量。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To simplify components and share functionality that uses React Hooks, create
    custom hooks outside the components.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化组件并共享使用React Hooks的功能，请在组件外部创建自定义钩子。
- en: To make it clear that a function is a custom hook and should follow the Rules
    of Hooks, start its name with “use.” Examples include `useDocumentTitle`, `useFetch`,
    `useUsers`, and `useLocalStorage`.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了明确一个函数是自定义钩子并且应该遵循钩子规则，请以“use.”开头命名它。例如包括`useDocumentTitle`、`useFetch`、`useUsers`和`useLocalStorage`。
- en: 'It’s important that components call hooks consistently each time they run.
    You shouldn’t call hooks only on some occasions but not on others, and you shouldn’t
    call them a different number of times each time a component runs. To help ensure
    that your hook calls are consistent, follow these conventions:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件每次运行时调用钩子的一致性很重要。你不应该在某些情况下调用钩子，而在其他情况下不调用，也不应该在组件每次运行时以不同的次数调用它们。为了确保你的钩子调用一致，请遵循以下约定：
- en: Don’t put hooks inside conditionals.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将钩子放在条件语句内。
- en: Don’t put hooks inside loops.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将钩子放在循环内。
- en: Don’t put hooks inside nested functions.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将钩子放在嵌套函数内。
- en: 'If you need side-effect code to run only under certain conditions, put the
    condition check inside the effect:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要在某些条件下运行副作用代码，请将条件检查放在副作用内：
- en: '[PRE28]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Don’t call hooks from regular JavaScript functions; keep your hook calls within
    function components and custom hooks.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在常规JavaScript函数中调用钩子；请将钩子调用保持在函数组件和自定义钩子内。
- en: To help you spot when you may have misused hooks in your code, use the ESLint
    plugin called `eslint-plugin-react-hooks`. If you’ve used `create-react-app` to
    generate your project skeleton, the plugin is already in place.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助你发现你可能在代码中误用了钩子，请使用名为`eslint-plugin-react-hooks`的ESLint插件。如果你已经使用`create-react-app`生成了你的项目骨架，该插件已经就位。
- en: 'Manage state and effects related to a hook’s functionality within the hook
    and return only the value(s) that components need:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在钩子内部管理与钩子功能相关的状态和效果，并仅返回组件需要的值：
- en: '[PRE29]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Pass hooks values they need and return nothing, primitives, functions, objects,
    or arrays—whatever is most useful:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '传递它们需要的钩子值，并返回空值、原语、函数、对象或数组—— whatever is most useful:'
- en: '[PRE30]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
