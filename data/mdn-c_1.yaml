- en: Level 1\. Acquaintance
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1级：熟悉
- en: '![](pg_021.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_021.jpg)'
- en: '*Our mascot for this level, the common raven, is a very sociable corvid and
    known for its problem-solving capacity. Ravens organize in teams and have been
    observed playing even as adults.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*本级别的吉祥物，常见的乌鸦，是一种非常社交的鸱科动物，以其解决问题的能力而闻名。乌鸦会组成团队，甚至成年后也会进行游戏。*'
- en: 'This level will acquaint you with the C programming language: that is, it will
    provide you with enough knowledge to write and use good C programs. “Good” here
    refers to a modern understanding of the language, avoiding most of the pitfalls
    of early dialects of C, and offering you some constructs that were not present
    before and that are portable across the vast majority of modern computer architectures,
    from your cell phone to a mainframe computer. Having worked through these chapters,
    you should be able to write short code for everyday needs: not extremely sophisticated,
    but useful and portable.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本级别将使你熟悉C编程语言：也就是说，它将为你提供足够的知识来编写和使用好的C程序。“好”在这里指的是对语言的现代理解，避免了C早期方言的大部分陷阱，并为你提供一些之前不存在且在大多数现代计算机架构上可移植的结构，从你的手机到大型机。完成这些章节后，你应该能够编写满足日常需求的简短代码：不是非常复杂，但有用且可移植。
- en: Buckle up
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系好安全带
- en: In many ways, C is a permissive language; programmers are allowed to shoot themselves
    in the foot or other body parts if they choose to, and C will make no effort to
    stop them. Therefore, just for the moment, we will introduce some restrictions.
    We’ll try to avoid handing out guns in this level, and place the key to the gun
    safe out of your reach for the moment, marking its location with big and visible
    exclamation marks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，C是一种宽容的语言；程序员可以选择自己射中脚或其他身体部位，而C将不会努力阻止他们。因此，暂时，我们将引入一些限制。我们将尝试在本级别中不发放枪支，并将枪柜的钥匙放在你够不到的地方，用大而显眼的感叹号标记其位置。
- en: The most dangerous constructs in C are the so-called *casts**^C*, so we’ll skip
    them at this level. However, there are many other pitfalls that are less easy
    to avoid. We will approach some of them in a way that might look unfamiliar to
    you, in particular if you learned your C basics in the last millennium or if you
    were introduced to C on a platform that wasn’t upgraded to current ISO C for years.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C中最危险的构造是所谓的*类型转换**^C*，所以我们将在本级别跳过它们。然而，还有许多其他陷阱不容易避免。我们将以一种可能对你来说不熟悉的方式处理其中的一些，特别是如果你在上个千年学习C基础知识，或者如果你在一个多年未升级到当前ISO
    C的平台上学C。
- en: '***Experienced C programmers:*** If you already have some experience with C
    programming, what follows may take some getting used to or even provoke allergic
    reactions. If you happen to break out in spots when you read some of the code
    here, take a deep breath and try to relax, but please *do not skip* these pages.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***经验丰富的C程序员：*** 如果你已经有一些C编程经验，以下内容可能需要一些适应，甚至可能引起过敏反应。如果你在阅读这里的一些代码时突然出现皮疹，请深呼吸并尽量放松，但请*不要跳过*这些页面。'
- en: '***Inexperienced C programmers:*** If you are not an experienced C programmer,
    much of the following discussion may be a bit over your head: for example, we
    may use terminology that you have not yet even heard of. If so, this is a digression
    for you, and you may skip to the start of [chapter 3](kindle_split_011.html#ch03)
    and come back later when you feel a bit more comfortable. But be sure to do so
    before the end of this level.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***不熟悉的C程序员：*** 如果你不是经验丰富的C程序员，以下讨论的大部分内容可能对你来说有点难以理解：例如，我们可能会使用你尚未听说过的术语。如果是这样，这对你来说是一个旁白，你可以跳到[第3章](kindle_split_011.html#ch03)的开始部分，稍后再回来，当你觉得稍微舒服一些的时候。但请确保在本级别结束之前这样做。'
- en: 'Some of “getting used to” our approach on this level may concern the emphasis
    and ordering in which we present the material:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个级别上，“适应”我们的方法可能涉及我们呈现材料的重点和顺序：
- en: We will focus primarily on the *unsigned**^C* versions of integer types.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将主要关注整数类型的*无符号**^C*版本。
- en: 'We will introduce pointers in steps: first, in disguise as parameters to functions
    ([section 6.1.4](kindle_split_014.html#ch06lev2sec4)), then with their state (being
    valid or not, [section 6.2](kindle_split_014.html#ch06lev1sec2)), and then, on
    the next level ([chapter 11](kindle_split_021.html#ch11)), using their entire
    potential.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将分步骤介绍指针：首先，作为函数的参数（[第6.1.4节](kindle_split_014.html#ch06lev2sec4)），然后是它们的状态（有效或无效，[第6.2节](kindle_split_014.html#ch06lev1sec2)），然后在下一个级别（[第11章](kindle_split_021.html#ch11)），使用它们的全部潜力。
- en: We will focus on the use of arrays whenever possible, instead.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将尽可能关注数组的用法。
- en: You might also be surprised by some style considerations that we will discuss
    in the following points. On the next level, we will dedicate an entire chapter
    ([chapter 9](kindle_split_019.html#ch09)) to these questions, so please be patient
    and accept them for the moment as they are.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对我们的某些风格考虑感到惊讶，我们将在以下要点中讨论。在下一级，我们将用整整一章（[第9章](kindle_split_019.html#ch09)）来讨论这些问题，所以请耐心等待，暂时接受它们。
- en: '***We bind type modifiers and qualifiers to the left.*** We want to separate
    identifiers visually from their type. So we will typically write things as'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***我们将类型修饰符和限定符绑定到左侧。*** 我们希望从视觉上区分标识符和它们的类型。因此，我们通常会这样写'
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where **`char*`** is the type and name is the identifier. We also apply the
    left-binding rule to qualifiers and write
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中**`char*`**是类型，name是标识符。我们还应用左结合规则到限定符上，并写成
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here the first **`const`** qualifies the **`char`** to its left, the `*` makes
    it to a pointer, and the second **`const`** again qualifies what is to its left.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，第一个**`const`**限定符限定其左侧的**`char`**，`*`使其成为指针，第二个**`const`**再次限定其左侧的内容。
- en: '***We do not use continued declarations.*** They obfuscate the bindings of
    type declarators. For example:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***我们不使用连续声明。*** 它们会模糊类型声明符的绑定。例如：'
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, b has type **`unsigned const`**: that is, the first **`const`** goes
    to the type, and the second **`const`** only goes to the declaration of a. Such
    rules are highly confusing, and you have more important things to learn.'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，b的类型是**`unsigned const`**：也就是说，第一个**`const`**应用于类型，第二个**`const`**只应用于a的声明。这样的规则非常令人困惑，你有更重要的事情要学习。
- en: '***We use array notation for pointer parameters.*** We do so wherever these
    assume that the pointer can’t be null. Examples:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***我们使用数组表示法来表示指针参数。*** 我们在指针不能为空的情况下这样做。例如：'
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first stresses the fact that **strlen** must receive a valid (non-null)
    pointer and will access at least one element of string. The second summarizes
    the fact that **main** receives an array of pointers to **`char`**: the program
    name, argc`-1` program arguments, and one null pointer that terminates the array.
    Note that the previous code is valid as it stands. The second set of declarations
    only adds additional equivalent declarations for features that are already known
    to the compiler.'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个强调了**strlen**必须接收一个有效的（非空）指针，并将至少访问字符串中的一个元素。第二个总结了**main**接收一个指向**`char`**的指针数组的现实，即程序名称、`argc`-1个程序参数和一个终止数组的空指针。请注意，前面的代码是有效的。第二组声明只为编译器已知的功能添加了额外的等效声明。
- en: '***We use function notation for function pointer parameters.*** Along the same
    lines, we do so whenever we know that a function pointer can’t be null:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***我们使用函数表示法来表示函数指针参数。*** 同样地，我们知道函数指针不能为空时，我们会这样做：'
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the first declaration of **atexit** emphasizes that, semantically, it
    receives a function named handler as an argument and that a null function pointer
    is not allowed. Technically, the function parameter handler is “rewritten” to
    a function pointer much as array parameters are rewritten to object pointers,
    but this is of minor interest for a description of the functionality. Note, again,
    that the previous code is valid as it stands and that the second declaration just
    adds an equivalent declaration for **atexit**.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，**atexit**的第一个声明强调了它在语义上接收一个名为handler的函数作为参数，并且不允许空函数指针。技术上，函数参数handler被“重写”为一个函数指针，就像数组参数被重写为对象指针一样，但对于功能描述来说这并不重要。请注意，前面的代码是有效的，第二个声明只是为**atexit**添加了一个等效的声明。
- en: '***We define variables as close to their first use as possible.*** Lack of
    variable initialization, especially for pointers, is one of the major pitfalls
    for novice C programmers. This is why we should, whenever possible, combine the
    declaration of a variable with the first assignment to it: the tool that C gives
    us for this purpose is the *definition*: a declaration together with an initialization.
    This gives a name to a value and introduces this name at the first place where
    it is used. This is particularly convenient for **`for`** loops. The iterator
    variable of one loop is semantically a different object from that in another loop,
    so we declare the variable within the **`for`** to ensure it stays within the
    loop’s scope.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***我们尽可能地将变量定义在其首次使用的地方。*** 缺乏变量初始化，尤其是对于指针，是新手C程序员的主要陷阱之一。这就是为什么我们应该尽可能地将变量的声明与其首次赋值结合起来：C为我们提供这种目的的工具是*定义*：一个声明与初始化的结合。这给一个值命名，并在它首次使用的地方引入这个名称。这对于**`for`**循环尤其方便。一个循环的迭代变量在语义上与另一个循环的迭代变量是不同的对象，因此我们在**`for`**循环内部声明变量，以确保它保持在循环的作用域内。'
- en: '***We use prefix notation for code blocks.*** To be able to read a code block,
    it is important to capture two things about it easily: its purpose and its extent.
    Therefore:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***我们使用前缀记法来表示代码块。*** 为了能够轻松地阅读代码块，重要的是要捕捉到关于它的两个信息：它的目的和它的范围。因此：'
- en: All `{` are prefixed on the same line with the statement or declaration that
    introduces them.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有**`{`**都与其引入它们的语句或声明在同一行上。
- en: The code inside is indented by one level.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码内部缩进一级。
- en: The terminating `}` starts a new line on the same level as the statement that
    introduced the block.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束的**`}`**与引入代码块的语句在同一级别上开始新的一行。
- en: 'Block statements that have a continuation after the `}` continue on the same
    line.Examples:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**`}`**之后继续的代码块语句在同一行上。示例：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Chapter 3\. Everything is about control
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章。一切都是关于控制
- en: This chapter covers
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Conditional execution with **`if`**
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**`if`**进行条件执行
- en: Iterating over domains
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历域
- en: Making multiple selections
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行多选
- en: 'In our introductory example, [listing 1.1](kindle_split_008.html#ch01ex01),
    we saw two different constructs that allowed us to control the flow of a program’s
    execution: functions and the **`for`** iteration. Functions are a way to transfer
    control unconditionally. The call transfers control unconditionally *to* the function,
    and a **`return`** statement unconditionally transfers it *back* to the caller.
    We will come back to functions in [chapter 7](kindle_split_015.html#ch07).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的入门示例中，[列表1.1](kindle_split_008.html#ch01ex01)，我们看到了两种不同的结构，允许我们控制程序执行的流程：函数和**`for`**迭代。函数是一种无条件转移控制的方式。调用无条件地将控制转移到函数，而**`return`**语句无条件地将控制转移回调用者。我们将在第7章中再次回到函数。
- en: 'The **`for`** statement is different in that it has a controlling condition
    (i `< 5` in the example) that regulates if and when the dependent block or statement
    (`{` **printf**`(...) }`) is executed. C has five conditional *control statements*:
    **`if`**, **`for`**, **`do`**, **`while`**, and **`switch`**. We will look at
    these statements in this chapter: **`if`** introduces a *conditional execution*
    depending on a Boolean expression; **`for`**, **`do`**, and **`while`** are different
    forms of *iterations*; and **`switch`** is a *multiple selection* based on an
    integer value.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**`for`**语句与其它不同，因为它有一个控制条件（例如，示例中的`i < 5`），它决定了依赖的代码块或语句（`{` **printf**`(...)
    }`）何时以及是否执行。C有五种条件*控制语句*：**`if`**、**`for`**、**`do`**、**`while`**和**`switch`**。我们将在本章中探讨这些语句：**`if`**根据布尔表达式引入*条件执行*；**`for`**、**`do`**和**`while`**是*迭代*的不同形式；而**`switch`**是基于整数值的*多选*。'
- en: 'C has some other conditionals that we will discuss later: the *ternary operator**^C*,
    denoted by an expression in the form cond `?` A `:` B ([section 4.4](kindle_split_012.html#ch04lev1sec4)),
    the compile-time preprocessor conditionals **`#if`**`/#`**`ifdef`**`/#`**`ifndef`**`/#`**`elif`**`/#`**`else`**`/#`**`endif`**
    ([section 8.1.5](kindle_split_016.html#ch08lev2sec5)), and type generic expressions
    denoted with the keyword **`_Generic`** ([section 16.6](kindle_split_027.html#ch16lev1sec6)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C还有一些其他条件语句，我们将在后面讨论：*三元运算符**^C***，表示为形式为cond `?` A `:` B的表达式（[第4.4节](kindle_split_012.html#ch04lev1sec4)），编译时预处理器条件语句**`#if`**`/#`**`ifdef`**`/#`**`ifndef`**`/#`**`elif`**`/#`**`else`**`/#`**`endif`**（[第8.1.5节](kindle_split_016.html#ch08lev2sec5)），以及用关键字**`_Generic`**表示的类型泛型表达式（[第16.6节](kindle_split_027.html#ch16lev1sec6)）。
- en: 3.1\. Conditional execution
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 条件执行
- en: 'The first construct that we will look at is specified by the keyword **`if`**.
    It looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个结构是由关键字 **`if`** 指定的。它看起来是这样的：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we compare i against the value `25`. If it is larger than 25, j is set
    to the value i `- 25`. In the example, i `> 25` is called the *controlling expression**^C*,
    and the part in `{ ... }` is called the *dependent block**^C*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 i 与值 `25` 进行比较。如果它大于 25，则 j 被设置为 i `- 25` 的值。在这个例子中，i `> 25` 被称为 *控制表达式*^C*，而
    `{ ... }` 部分被称为 *依赖块*^C*。
- en: 'On the surface, this form of an **`if`** statement resembles the **`for`**
    statement that we already encountered. But it works differently than that: there
    is only one part inside the parentheses, and that determines whether the dependent
    statement or block is run once or not at all.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，这种 **`if`** 语句的形式类似于我们之前遇到的 **`for`** 语句。但它的工作方式不同：括号内只有一个部分，它决定了依赖语句或块是否只运行一次或根本不运行。
- en: 'There is a more general form of the **`if`** construct:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**`if`** 构造的更一般形式如下：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It has a second dependent statement or block that is executed if the controlling
    condition is not fulfilled. Syntactically, this is done by introducing another
    keyword **`else`** that separates the two statements or blocks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个依赖语句或块，如果控制条件不满足，则执行。在语法上，这是通过引入另一个关键字 **`else`** 来实现的，它将两个语句或块分开。
- en: The **`if`** `(...) ...` **`else`** `...` is a *selection statement**^C*. It
    selects one of the two possible *code paths**^C* according to the contents of
    `( ... )`. The general form is
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**`if`** `(...) ...` **`else`** `...` 是一个 *选择语句*^C*。它根据 `( ... )` 的内容选择两个可能
    *代码路径*^C* 中的一个。其一般形式是'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The possibilities for condition (the controlling expression) are numerous. They
    can range from simple comparisons, as in this example, to very complex nested
    expressions. We will present all the primitives that can be used in [section 4.3.2](kindle_split_012.html#ch04lev2sec4).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 条件（控制表达式）的可能性有很多。它们可以从简单的比较开始，如本例所示，到非常复杂的嵌套表达式。我们将在 [第 4.3.2 节](kindle_split_012.html#ch04lev2sec4)
    中介绍所有可以使用的原语。
- en: 'The simplest of such condition specifications in an **`if`** statement can
    be seen in the following example, in a variation of the **`for`** loop from [listing
    1.1](kindle_split_008.html#ch01ex01):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **`if`** 语句中最简单的此类条件指定可以在以下示例中看到，这是 [列表 1.1](kindle_split_008.html#ch01ex01)
    中的 **`for`** 循环的一个变体：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here the condition that determines whether **printf** is executed is just i:
    a numerical value by itself can be interpreted as a condition. The text will only
    be printed when the value of i is not `0`.^([[[Exs 1]](#ch03fn-ex01)])'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，决定是否执行 **printf** 的条件仅仅是 i：一个数值本身可以被视为一个条件。只有当 i 的值为非 `0` 时，文本才会被打印。^([[[例
    1]](#ch03fn-ex01)])
- en: ^([Exs 1])
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 1])
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add the **`if`** `(`i`)` condition to the program, and compare the output to
    the previous.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 **`if`** `(`i`)` 条件添加到程序中，并将输出与之前进行比较。
- en: 'There are two simple rules for the evaluation of a numerical condition:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 评估数值条件有两个简单的规则：
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 3.1
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 3.1
- en: '*The value `0` represents logical false.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*`0` 的值代表逻辑假。*'
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 3.2
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 3.2
- en: '*Any value different from `0` represents logical true.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何非 `0` 的值都代表逻辑真。*'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The operators `==` and `!=` allow us to test for equality and inequality, respectively.
    a `==` b is true if the value of a is equal to the value of b, and false otherwise;
    a `!=` b is false if a is equal to b, and true otherwise. Knowing how numerical
    values are evaluated as conditions, we can avoid redundancy. For example, we can
    rewrite
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符 `==` 和 `!=` 允许我们测试相等性和不等性。a `==` b 当且仅当 a 的值等于 b 的值时为真，否则为假；a `!=` b 当 a
    等于 b 时为假，否则为真。了解数值如何作为条件进行评估后，我们可以避免冗余。例如，我们可以重写
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'as:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如下：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Which of these two versions is more readable is a question of *coding style**^C*
    and can be subject to fruitless debates. While the first might be easier for occasional
    readers of C code to read, the latter is often preferred in projects that assume
    some knowledge about C’s type system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个版本更易读是一个关于 *编码风格*^C* 的问题，可能会引起无果的争论。虽然第一个版本可能对偶尔阅读 C 代码的读者来说更容易阅读，但后者在假设对
    C 的类型系统有一定了解的项目中通常更受欢迎。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdbool.h>`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdbool.h>`'
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The type bool, specified in `stdbool.h`, is what we should be using if we want
    to store truth values. Its values are **`false`** and **`true`**. Technically,
    **`false`** is just another name for `0` and **`true`** for `1`. It’s important
    to use **`false`** and **`true`** (and not the numbers) to emphasize that a value
    is to be interpreted as a condition. We will learn more about the bool type in
    [section 5.7.4](kindle_split_013.html#ch05lev2sec13).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `stdbool.h` 中指定的类型 bool，是我们想要存储真值时应使用的类型。它的值是 **`false`** 和 **`true`**。技术上，**`false`**
    只是 `0` 的另一个名称，**`true`** 是 `1`。使用 **`false`** 和 **`true`**（而不是数字）来强调一个值是要被解释为条件的。我们将在
    [第 5.7.4 节](kindle_split_013.html#ch05lev2sec13) 中了解更多关于 bool 类型的内容。
- en: Redundant comparisons quickly become unreadable and clutter your code. If you
    have a conditional that depends on a truth value, use that truth value directly
    as the condition. Again, we can avoid redundancy by rewriting something like
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的比较很快就会变得难以阅读，并使你的代码杂乱无章。如果你有一个依赖于真值的条件，直接使用那个真值作为条件。同样，我们可以通过重写类似的内容来避免重复
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: as
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: as
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Generally:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常：
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 3.3
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 3.3
- en: '*Don’t compare to `0`*, **`false`**, *or* **`true`**.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要与 `0` 比较*，**`false`**，*或* **`true`**。'
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Using the truth value directly makes your code clearer and illustrates one
    of the basic concepts of the C language:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用真值可以使你的代码更清晰，并说明了 C 语言的一个基本概念：
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 3.4
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 3.4
- en: '*All scalars have a truth value.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有标量都有真值。*'
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Here, *scalar**^C* types include all the numerical types such as **`size_t`**,
    bool, and **`int`** that we already encountered, and *pointer**^C* types; see
    [table 3.1](#ch03table01) for the types that are frequently used in this book.
    We will come back to them in [section 6.2](kindle_split_014.html#ch06lev1sec2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*标量*^C* 类型包括所有我们已遇到的数值类型，如 **`size_t`**、bool 和 **`int`**，以及 *指针*^C* 类型；参见
    [表 3.1](#ch03table01) 了解本书中常用类型。我们将在 [第 6.2 节](kindle_split_014.html#ch06lev1sec2)
    回到这些类型。
- en: Table 3.1\. Scalar types used in this book
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1\. 本书使用的标量类型
- en: '| Level | Name | Other | Category | Where | **printf** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 名称 | 其他 | 类别 | 哪里 | **printf** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | **size_t** |   | Unsigned | <stddef.h> | "%zu" "%zx" |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 0 | **size_t** |   | 无符号 | `<stddef.h>` | "%zu" "%zx" |'
- en: '| 0 | **double** |   | Floating | Built in | "%e" "%f" "%g" "%a" |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 0 | **double** |   | 浮点 | 内置 | "%e" "%f" "%g" "%a" |'
- en: '| 0 | **signed** | **int** | Signed | Built in | "%d" |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 0 | **signed** | **int** | 有符号 | 内置 | "%d" |'
- en: '| 0 | **unsigned** |   | Unsigned | Built in | "%u" "%x" |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 0 | **unsigned** |   | 无符号 | 内置 | "%u" "%x" |'
- en: '| 0 | bool | **_Bool** | Unsigned | <stdbool.h> | "%d" as 0 or 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 0 | bool | **_Bool** | 无符号 | `<stdbool.h>` | "%d" 作为 0 或 1 |'
- en: '| 1 | **ptrdiff_t** |   | Signed | <stddef.h> | "%td" |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **ptrdiff_t** |   | 有符号 | `<stddef.h>` | "%td" |'
- en: '| 1 | **char const*** |   | String | Built in | "%s" |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **char const*** |   | 字符串 | 内置 | "%s" |'
- en: '| 1 | **char** |   | Character | Built in | "%c" |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **char** |   | 字符 | 内置 | "%c" |'
- en: '| 1 | **void*** |   | Pointer | Built in | "%p" |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **void*** |   | 指针 | 内置 | "%p" |'
- en: '| 2 | **unsigned char** |   | Unsigned | Built in | "%hhu" "%02hhx" |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **unsigned char** |   | 无符号 | 内置 | "%hhu" "%02hhx" |'
- en: 3.2\. Iterations
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 迭代
- en: Previously, we encountered the **`for`** statement to iterate over a domain;
    in our introductory example, it declared a variable i that was set to the values
    `0`, `1`, `2`, `3`, and `4`. The general form of this statement is
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们遇到了用于遍历域的 **`for`** 语句；在我们的入门示例中，它声明了一个变量 i，其值设置为 `0`、`1`、`2`、`3` 和 `4`。这个语句的一般形式是
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This statement is actually quite generic. Usually, clause1 is an assignment
    expression or a variable definition. It serves to state an initial value for the
    iteration domain. condition2 tests whether the iteration should continue. Then,
    expression3 updates the iteration variable used in clause1. It is performed at
    the end of each iteration. Some advice:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句实际上非常通用。通常，clause1 是一个赋值表达式或变量定义。它用于声明迭代域的初始值。condition2 测试迭代是否应该继续。然后，expression3
    更新 clause1 中使用的迭代变量。它在每个迭代的末尾执行。一些建议：
- en: Because we want iteration variables to be defined narrowly in the context for
    a **`for`** loop (*cf.* [takeaway 2.11](kindle_split_009.html#ch02note12)), clause1
    should in most cases be a variable definition.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们要在 **`for`** 循环的上下文中严格定义迭代变量（*cf.* [要点 2.11](kindle_split_009.html#ch02note12)），所以
    clause1 在大多数情况下应该是一个变量定义。
- en: Because **`for`** is relatively complex with its four different parts and not
    easy to capture visually, statement`-`**`or`**`-`block should usually be a `{
    ... }` block.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 **`for`** 语句有四个不同的部分，相对复杂，且不易于视觉上捕捉，所以 statement`-`**`or`**`-`block 通常应该是一个
    `{ ... }` 块。
- en: 'Let’s see some more examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多的例子：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first **`for`** counts i down from `10` to `1`, inclusive. The condition
    is again just the evaluation of the variable i; no redundant test against value
    `0` is required. When i becomes `0`, it will evaluate to false, and the loop will
    stop. The second **`for`** declares two variables, i and stop. As before, i is
    the loop variable, stop is what we compare against in the condition, and when
    i becomes greater than or equal to stop, the loop terminates.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个**`for`**循环将`i`从`10`递减到`1`（包含`1`）。条件再次只是变量`i`的评估；不需要对值`0`进行冗余测试。当`i`变为`0`时，它将评估为假，循环将停止。第二个**`for`**循环声明了两个变量，`i`和`stop`。与之前一样，`i`是循环变量，`stop`是我们比较的条件，当`i`大于或等于`stop`时，循环终止。
- en: The third **`for`** looks as though it would go on forever, but actually it
    counts down from `9` to `0`. In fact, in the next chapter, we will see that “sizes”
    in C (numbers that have type **`size_t`**) are never negative.^([[[Exs 2]](#ch03fn-ex02)])
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个**`for`**循环看起来似乎会无限进行下去，但实际上它是从`9`递减到`0`。实际上，在下一章中，我们将看到C语言中的“大小”（具有**`size_t`**类型的数字）永远不会是负数.^([[[Exs
    2]](#ch03fn-ex02)])
- en: ^([Exs 2])
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try to imagine what happens when i has value `0` and is decremented by means
    of the operator `--`.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试想象当`i`的值为`0`并且通过`--`运算符进行递减时会发生什么。
- en: Observe that all three **`for`** statements declare variables named i. These
    three variables with the same name happily live side by side, as long as their
    scopes don’t overlap.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有三个**`for`**语句都声明了名为`i`的变量。只要它们的范围不重叠，这三个具有相同名称的变量就可以愉快地并排存在。
- en: 'There are two more iterative statements in C, **`while`** and **`do`**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中还有两个迭代语句，**`while`**和**`do`**：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following example shows a typical use of the first. It implements the so-called
    *Heron approximation* to compute the multiplicative inverse ![](1byx.jpg) of a
    number *x*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了第一个的典型用法。它实现了所谓的*赫伦近似法*来计算数字*x*的乘法逆元 ![](1byx.jpg)。
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It iterates as long as the given condition evaluates true. The **`do`** loop
    is very similar, except that it checks the condition *after* the dependent block:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它会一直迭代，直到给定的条件评估为真。**`do`**循环与它非常相似，除了它在依赖块之后检查条件：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means if the condition evaluates to false, a **`while`** loop will not
    run its dependent block at all, and a **`do`** loop will run it once before terminating.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果条件评估为假，**`while`**循环将根本不会运行其依赖块，而**`do`**循环将在终止前运行一次。
- en: 'As with the **`for`** statement, with **`do`** and **`while`** it is advisable
    to use the `{ ... }` block variants. There is also a subtle syntactical difference
    between the two: **`do`** always needs a semicolon `;` after the **`while`** (conditio`n)`
    to terminate the statement. Later, we will see that this is a syntactic feature
    that turns out to be quite useful in the context of multiple nested statements;
    see [section 10.2.1](kindle_split_020.html#ch10lev2sec1).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与**`for`**语句一样，使用**`do`**和**`while`**时建议使用`{ ... }`块变体。这两个之间也存在微妙的语法差异：**`do`**总是需要在**`while`**（条件）之后有一个分号`;`来终止语句。稍后，我们将看到这是一个在多重嵌套语句的上下文中非常有用的语法特性；参见[第10.2.1节](kindle_split_020.html#ch10lev2sec1)。
- en: 'All three iteration statements become even more flexible with **`break`** and
    **`continue`** statements. A **`break`** statement stops the loop without reevaluating
    the termination condition or executing the part of the dependent block after the
    **`break`** statement:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个迭代语句通过**`break`**和**`continue`**语句变得更加灵活。一个**`break`**语句会停止循环，而无需重新评估终止条件或执行**`break`**语句之后的依赖块：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This way, we can separate the computation of the product a`*`x, the evaluation
    of the stop condition, and the update of x. The condition of the **`while`** then
    becomes trivial. The same thing can be done using a **`for`**, and there is a
    tradition among C programmers to write it as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以将乘积a`*`x的计算、停止条件的评估以及x的更新分开。因此，**`while`**的条件变得很简单。同样的事情也可以使用**`for`**循环来完成，C程序员中有一种传统是将其写成以下形式：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**`for`**`(;;)` here is equivalent to **`while`**`(`**`true`**`)`. The fact
    that the controlling expression of a **`for`** (the middle part between the `;;`)
    can be omitted and is interpreted as “always **`true`**” is just a historical
    artifact in the rules of C and has no other special purpose.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**`for`**`(;;)`在这里等同于**`while`**`(`**`true`**`)`。事实上，**`for`**循环的控制表达式（`;;`之间的中间部分）可以省略，并被解释为“总是**`true`**”，这只是C语言规则中的历史遗迹，没有其他特殊目的。'
- en: '![](pg_032.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_032.jpg)'
- en: 'The **`continue`** statement is less frequently used. Like **`break`**, it
    skips the execution of the rest of the dependent block, so all statements in the
    block after the **`continue`** are not executed for the current iteration. However,
    it then reevaluates the condition and continues from the start of the dependent
    block if the condition is true:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**`continue`** 语句使用得较少。像 **`break`** 一样，它跳过执行依赖块的其余部分，因此当前迭代中依赖块后的所有语句都不会执行。然而，然后它重新评估条件，如果条件为真，则从依赖块的开始继续：'
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<tgmath.h>`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In these examples, we use a standard macro **`fabs`**, which comes with the
    `tgmath.h` header^([[1](#ch03fn01)]). It calculates the absolute value of a **`double`**.
    [Listing 3.1](#ch03ex02) is a complete program that implements the same algorithm,
    where **`fabs`** has been replaced by several explicit comparisons against certain
    fixed numbers: for example, eps1m24 defined to be 1 – 2^(–24), or eps1p24 as 1
    + 2^(–24). We will see later ([section 5.3](kindle_split_013.html#ch05lev1sec3))
    how the constants `0`x1P`-24` and similar used in these definitions work.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，我们使用一个标准的宏 **`fabs`**，它包含在 `tgmath.h` 头文件中^([[1](#ch03fn01)]). 它计算 **`double`**
    类型的绝对值。[列表 3.1](#ch03ex02) 是一个完整的程序，实现了相同的算法，其中 **`fabs`** 已被替换为对某些固定数字的几个显式比较：例如，eps1m24
    定义为 1 – 2^(–24)，或 eps1p24 为 1 + 2^(–24)。我们将在稍后 ([章节 5.3](kindle_split_013.html#ch05lev1sec3))
    看到这些定义中使用的常数 `0`x1P`-24` 和类似的常数是如何工作的。
- en: ¹
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “tgmath” stands for *type generic mathematical functions*.
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “tgmath”代表 *类型通用的数学函数*。
- en: In the first phase, the product of the current number under investigation a
    with the current estimate x is compared to 1.5 and 0.5, and then x is multiplied
    by 0.5 or 2 until the product is close to 1\. Then, the Heron approximation as
    shown in the code is used in a second iteration to close in and to compute the
    multiplicative inverse with high accuracy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，当前研究数字 a 与当前估计值 x 的乘积与 1.5 和 0.5 进行比较，然后 x 乘以 0.5 或 2，直到乘积接近 1。然后，在代码中显示的
    Heron 近似在第二次迭代中使用，以接近并计算乘法逆的高精度值。
- en: 'The overall task of the program is to compute the inverse of all numbers that
    are provided to it on the command line. An example of a program execution looks
    like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的整体任务是计算命令行上提供的所有数字的逆。一个程序执行的例子如下所示：
- en: '`Terminal`'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To process the numbers on the command line, the program uses another library
    function **strtod** from `stdlib.h`.^([[[Exs 3]](#ch03fn-ex03)])^([[[Exs 4]](#ch03fn-ex04)])^([[[Exs
    5]](#ch03fn-ex05)])
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理命令行上的数字，程序使用另一个库函数 `stdlib.h` 中的 **`strtod`**。^([[[Exs 3]](#ch03fn-ex03)])^([[[Exs
    4]](#ch03fn-ex04)])^([[[Exs 5]](#ch03fn-ex05)])
- en: ^([Exs 3])
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Analyze [listing 3.1](#ch03ex02) by adding **printf** calls for intermediate
    values of x.
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过添加对 x 的中间值的 **`printf`** 调用来分析 [列表 3.1](#ch03ex02)。
- en: ^([Exs 4])
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Describe the use of the parameters argc and argv in [listing 3.1](#ch03ex02).
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 描述 [列表 3.1](#ch03ex02) 中参数 argc 和 argv 的使用。
- en: ^([Exs 5])
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 5])
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Print out the values of eps1m01, and observe the output when you change them
    slightly.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打印出 eps1m01 的值，并观察当它们略有变化时的输出。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdlib.h>`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdlib.h>`'
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Sequential sorting algorithms**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序排序算法**'
- en: Can you do
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做
- en: A merge sort (with recursion)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 归并排序（带递归）
- en: A quick sort (with recursion)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速排序（带递归）
- en: on arrays with sort keys such as **`double`** or strings to your liking?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有排序键如 **`double`** 或你喜欢的字符串的数组上？
- en: Nothing is gained if you don’t know whether your programs are correct. Therefore,
    can you provide a simple test routine that checks if the resulting array really
    is sorted?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不知道你的程序是否正确，那么你将一无所获。因此，你能提供一个简单的测试例程来检查结果数组是否真的已排序吗？
- en: This test routine should just scan once through the array and should be much,
    much faster than your sorting algorithms.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试例程应该只扫描一次数组，并且应该比你的排序算法快得多。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 3.1\. Computing multiplicative inverses of numbers
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 计算数字的乘法逆
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 3.3\. Multiple selection
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 多重选择
- en: 'The last control statement that C has to offer is the **`switch`** statement
    and is another *selection**^C* statement. It is mainly used when cascades of **`if-else`**
    constructs would be too tedious:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言提供的最后一个控制语句是 **`switch`** 语句，它也是一种 *选择*^C* 语句。它主要用于当一系列 **`if-else`** 构造过于繁琐时：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, we have a choice that is more complex than a **`false`**`-`**`true`**
    decision and that can have several outcomes. We can simplify this as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个比 **`false`**`-`**`true`** 决策更复杂的选项，并且可以有多个结果。我们可以将其简化如下：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we select one of the **puts** calls according to the value of the arg variable.
    Like **printf**, the function **puts** is provided by `stdio.h`. It outputs a
    line with the string that is passed as an argument. We provide specific cases
    for characters 'm', 'r', 'j', 'c', and a *fallback**^C* case labeled **`default`**.
    The default case is triggered if arg doesn’t match any of the **`case`** values.^([[[Exs
    6]](#ch03fn-ex06)])
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据 arg 变量的值选择一个 **puts** 调用。像 **printf** 一样，函数 **puts** 由 `stdio.h` 提供。它输出一个包含作为参数传递的字符串的行。我们为字符
    'm'、'r'、'j'、'c' 和一个 *后备**^C* 情况提供特定的案例，标记为 **`default`**。如果 arg 不匹配任何 **`case`**
    值，则触发默认情况.^([[[Exs 6]](#ch03fn-ex06)])
- en: ^([Exs 6])
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 6])
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Test the example **`switch`** statement in a program. See what happens if you
    leave out some of the **`break`** statements.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在程序中测试示例 **`switch`** 语句。看看如果你省略了一些 **`break`** 语句会发生什么。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdio.h>`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdio.h>`'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Syntactically, a **`switch`** is as simple as
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 语法上，**`switch`** 如此简单：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'and its semantics are quite straightforward: the **`case`** and **`default`**
    labels serve as *jump targets**^C*. According to the value of the expression,
    control continues at the statement that is labeled accordingly. If we hit a **`break`**
    statement, the whole **`switch`** under which it appears terminates, and control
    is transferred to the next statement after the **`switch`**.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它的语义相当简单：**`case`** 和 **`default`** 标签作为 *跳转目标**^C*。根据表达式的值，控制继续到相应标记的语句。如果我们遇到一个
    **`break`** 语句，它所在的整个 **`switch`** 语句终止，并且控制转移到 **`switch`** 之后的下一个语句。
- en: 'By that specification, **`switch`** statements can be used much more widely
    than iterated **`if-else`** constructs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个规范，**`switch`** 语句可以比迭代 **`if-else`** 结构更广泛地使用：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have jumped into the block, execution continues until it reaches a
    **`break`** or the end of the block. In this case, because there are no **`break`**
    statements, we end up running all subsequent **puts** statements. For example,
    the output when the value of count is `3` is a triangle with three lines:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们跳入代码块，执行将继续，直到遇到一个 **`break`** 或块的末尾。在这种情况下，因为没有 **`break`** 语句，我们最终会运行所有后续的
    **puts** 语句。例如，当 count 的值为 `3` 时，输出是一个由三条线组成的三角形：
- en: '`Terminal`'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The structure of a **`switch`** can be more flexible than **`if-else`**, but
    it is restricted in another way:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**`switch`** 语句的结构可能比 **`if-else`** 更灵活，但它也有另一种限制：'
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 3.5
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 3.5
- en: '**`case`** *values must be integer constant expressions.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**`case`** *值必须是整数常量表达式*。'
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In [section 5.6.2](kindle_split_013.html#ch05lev2sec7), we will see what these
    expressions are in detail. For now, it suffices to know that these have to be
    fixed values that we provide directly in the source, such as the `4`, `3`, `2`,
    `1`, `0` in the previous example. In particular, variables such as count are only
    allowed in the **`switch`** part, not in the individual **`case`** s.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5.6.2 节](kindle_split_013.html#ch05lev2sec7) 中，我们将详细看到这些表达式是什么。现在，只需知道这些必须是我们在源代码中直接提供的固定值就足够了，例如前一个例子中的
    `4`、`3`、`2`、`1`、`0`。特别是，变量如 count 只允许在 **`switch`** 部分使用，不允许在单个 **`case`** 中使用。
- en: 'With the greater flexibility of the **`switch`** statement also comes a price:
    it is more error prone. In particular, we might accidentally skip variable definitions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 **`switch`** 语句的更大灵活性，也伴随着代价：它更容易出错。特别是，我们可能会不小心跳过变量定义：
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 3.6
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 3.6
- en: '**`case`** *labels must not jump beyond a variable definition.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**`case`** *标签不能超出变量定义的范围*。'
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Numerical derivatives**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值导数**'
- en: Something we’ll deal with a lot is the concept of numerical algorithms. To get
    your hands dirty, see if you can implement the numerical derivative **`double`**
    f`(`**`double`** x`)` of a function **`double`** F`(`**`double`** x`)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大量处理的是数值算法的概念。为了亲自动手，看看你是否能实现一个函数 **`double`** F`(`**`double`** x`)` 的数值导数
    **`double`** f`(`**`double`** x`)`。
- en: Implement this with an example F for the function that you use for this exercise.
    A good primary choice for F would be a function for which you know the derivative,
    such as **`sin`**, **`cos`**, or **`sqrt`**. This allows you to check your results
    for correctness.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个示例函数 F 来实现这个练习，对于 F 的一个很好的选择是，你知道其导数的函数，例如 **`sin`**、**`cos`** 或 **`sqrt`**。这允许你检查你的结果是否正确。
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '***π***'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***π***'
- en: Compute the *N* first decimal places of *π*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 计算π的 *N* 位小数。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Numerical values can be directly used as conditions for **`if`** statements;
    0 represents “false,” and all other values are “true.”
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值可以直接用作**`if`**语句的条件；0表示“假”，而所有其他值都是“真”。
- en: 'There are three different iteration statements: **`for`**, **`do`**, and **`while`**.
    **`for`** is the preferred tool for domain iterations.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有三种不同的迭代语句：**`for`**、**`do`**和**`while`**。**`for`**是领域迭代的首选工具。
- en: A **`switch`** statement performs multiple selection. One **`case`** runs into
    the next, if it is not terminated by a **`break`**.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`switch`**语句执行多重选择。如果没有通过**`break`**终止，一个**`case`**会运行到下一个。'
- en: Chapter 4\. Expressing computations
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章。表达计算
- en: This chapter covers
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Performing arithmetic
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行算术运算
- en: Modifying objects
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改对象
- en: Working with booleans
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理布尔值
- en: Conditional compilation with the ternary operator
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三元运算符进行条件编译
- en: Setting the evaluation order
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置评估顺序
- en: We’ve already made use of some simple examples of *expressions**^C*. These are
    code snippets that compute a value based on other values. The simplest such expressions
    are arithmetic expressions, which are similar to those we learned in school. But
    there are others, notably comparison operators such as `==` and `!=`, which we
    saw earlier.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了一些简单的**表达式**^C的例子。这些是计算基于其他值的值的代码片段。最简单的这种表达式是算术表达式，它们与我们学校学过的类似。但还有其他一些，特别是比较运算符，如`==`和`!=`，我们之前已经看到过。
- en: In this chapter, the values and objects on which we will do these computations
    will be mostly of the type **`size_t`**, which we have already met. Such values
    correspond to “sizes,” so they are numbers that cannot be negative. Their range
    of possible values starts at `0`. What we would like to represent are all the
    non-negative integers, often denoted as N, N[0], or “natural” numbers in mathematics.
    Unfortunately, computers are finite, so we can’t directly represent all the natural
    numbers, but we can do a reasonable approximation. There is a big upper limit
    **`SIZE_MAX`** that is the upper bound of what we can represent in a **`size_t`**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对这些值和对象进行计算，它们大多数将是**`size_t`**类型，我们已经遇到过。这样的值对应于“大小”，因此它们是不能为负数的数字。它们可能的值范围从`0`开始。我们想要表示的是所有非负整数，通常在数学中用N、N[0]或“自然数”表示。不幸的是，计算机是有限的，所以我们不能直接表示所有自然数，但我们可以进行合理的近似。有一个很大的上限**`SIZE_MAX`**，它是我们在**`size_t`**中可以表示的上限。
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.1
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果4.1
- en: '*The type* **`size_t`** *represents values in the range* *`[0,`* **`SIZE_MAX`***`]`**.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型* **`size_t`** *表示的范围是* *`[0,`* **`SIZE_MAX`***`]`**。'
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The value of **`SIZE_MAX`** is quite large. Depending on the platform, it is
    one of
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SIZE_MAX`**的值相当大。根据平台的不同，它可能是以下之一'
- en: 2^(16) – 1 = 65535
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2^(16) – 1 = 65535
- en: 2^(32) – 1 = 4294967295
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2^(32) – 1 = 4294967295
- en: 2^(64) – 1 = 18446744073709551615
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2^(64) – 1 = 18446744073709551615
- en: 'The first value is a minimal requirement; nowadays, such a small value would
    only occur on some embedded platforms. The other two values are much more commonly
    used today: the second is still found on some PCs and laptops, and the large majority
    of newer platforms have the third. Such a choice of value is large enough for
    calculations that are not too sophisticated. The standard header `stdint.h` provides
    **`SIZE_MAX`** such that you don’t have to figure out that value yourself, and
    such that you do not have to specialize your program accordingly.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值是一个最小要求；如今，这样的小值只会出现在一些嵌入式平台上。其他两个值在当今更为常见：第二个仍然在一些PC和笔记本电脑上使用，而大多数较新的平台都使用第三个。这样的值选择对于不太复杂的计算来说已经足够大了。标准头文件`stdint.h`提供了**`SIZE_MAX`**，这样你就不必自己找出那个值，也不必相应地专门化你的程序。
- en: '|  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<stdint.h>`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdint.h>`'
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The concept of “numbers that cannot be negative” to which we referred for **`size_t`**
    corresponds to what C calls *unsigned integer types**^C*. Symbols and combinations
    like `+` and `!=` are called *operators**^C*, and the things to which they are
    applied are called *operands**^C*; so, in something like a `+` b, `+` is the operator
    and a and b are its operands.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的“不能为负的数字”的概念，对应于C语言中的*无符号整数类型**^C*。像`+`和`!=`这样的符号和组合被称为*运算符**^C*，而它们所应用的对象被称为*操作数**^C*；因此，在类似`+`
    a b的例子中，`+`是运算符，而a和b是其操作数。
- en: 'For an overview of all C operators, see the following tables: [table 4.1](#ch04table01)
    lists the operators that operate on values, [table 4.2](#ch04table02) lists those
    that operate on objects, and [table 4.3](#ch04table03) lists those that operate
    on types. To work with these, you may have to jump from one table to another.
    For example, if you want to work out an expression such as a `+ 5`, where a is
    some variable of type **`unsigned`**, you first have to go to the third line in
    [table 4.2](#ch04table02) to see that a is evaluated. Then, you can use the third
    line in [table 4.1](#ch04table01) to deduce that the value of a and `5` are combined
    in an arithmetic operation: a `+`. Don’t be frustrated if you don’t understand
    everything in these tables. A lot of the concepts that are mentioned have not
    yet been introduced; they are listed here to form a reference for the entire book.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解所有C运算符的概述，请参阅以下表格：[表4.1](#ch04table01)列出了操作值的运算符，[表4.2](#ch04table02)列出了操作对象的运算符，[表4.3](#ch04table03)列出了操作类型的运算符。在使用这些运算符时，您可能需要从一个表格跳转到另一个表格。例如，如果您想要计算一个表达式，如`a
    + 5`，其中`a`是类型为**`unsigned`**的某个变量，您首先需要查看[表4.2](#ch04table02)的第三行，以了解`a`是如何被评估的。然后，您可以使用[表4.1](#ch04table01)的第三行来推断出`a`和`5`的值在算术操作中被组合：`a
    +`。如果您对这些表格中的所有内容都不理解，请不要沮丧。许多提到的概念尚未介绍；它们被列在这里，作为整本书的参考。
- en: Table 4.1\. Value operators *The Form column gives the syntactic form of the
    operation, where @ represents the operator and a and possibly b denote values
    that serve as operands. For arithmetic and bit operations, the type of the result
    is a type that reconciles the types of a and b. For some of the operators, the
    Nick column gives an alternative form of the operator, or lists a combination
    of operators that has special meaning. Most of the operators and terms will be
    discussed later.*
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.1\. 值运算符 *“形式”列给出了操作的语法形式，其中@代表运算符，a和可能b表示作为操作数的值。对于算术和位操作，结果类型是a和b类型协调的类型。对于一些运算符，别名列给出了运算符的另一种形式，或列出具有特殊意义的运算符组合。大多数运算符和术语将在以后讨论。*
- en: '|   |   |   | type restriction |   |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   | 类型限制 |   |   |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| Operator | Nick | Form | a | b | Result |   |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 别名 | 形式 | a | b | 结果 |   |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '|   |   | a | Narrow |   | Wide | Promotion |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|   |   | a | 窄化 |   | 宽化 | 提升类型 |'
- en: '| + - |   | a@b | Pointer | Integer | Pointer | Arithmetic |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| + - |   | a@b | 指针 | 整数 | 指针 | 算术 |'
- en: '| + - * / |   | a@b | Arithmetic | Arithmetic | Arithmetic | Arithmetic |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| + - * / |   | a@b | 算术 | 算术 | 算术 | 算术 |'
- en: '| + - |   | @a | Arithmetic |   | Arithmetic | Arithmetic |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| + - * / |   | @a | 算术 |   | 算术 | 算术 |'
- en: '| % |   | a@b | Integer | Integer | Integer | Arithmetic |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| % |   | a@b | 整数 | 整数 | 整数 | 算术 |'
- en: '| ~ | **compl** | @a | Integer |   | Integer | Bit |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| ~ | **compl** | @a | 整数 |   | 整数 | 位操作 |'
- en: '| & | **bitand** | a@b | Integer | Integer | Integer | Bit |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| & | **bitand** | a@b | 整数 | 整数 | 整数 | 位操作 |'
- en: '| &#124; | **bitor** |   |   |   |   |   |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | **bitor** |   |   |   |   |   |'
- en: '| ^ | **xor** |   |   |   |   |   |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| ^ | **xor** |   |   |   |   |   |'
- en: '| << >> |   | a@b | Integer | Positive | Integer | Bit |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| << >> |   | a@b | 整数 | 正数 | 整数 | 位操作 |'
- en: '| == < > <= >= |   | a@b | Scalar | Scalar | 0,1 | Comparison |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| == < > <= >= |   | a@b | 标量 | 标量 | 0,1 | 比较 |'
- en: '| != | **not_eq** | a@b | Scalar | Scalar | 0,1 | Comparison |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| != | **not_eq** | a@b | 标量 | 标量 | 0,1 | 比较 |'
- en: '|   | !!a | a | Scalar |   | 0,1 | Logic |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|   | !!a | a | 标量 |   | 0,1 | 逻辑 |'
- en: '| !a | **not** | @a | Scalar |   | 0,1 | Logic |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| !a | **not** | @a | 标量 |   | 0,1 | 逻辑 |'
- en: '| && &#124;&#124; | **and or** | a@b | Scalar | Scalar | 0,1 | Logic |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| && &#124;&#124; | **and or** | a@b | 标量 | 标量 | 0,1 | 逻辑 |'
- en: '| . |   | a@m | **struct** |   | Value | Member |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| . |   | a@m | **结构** |   | 值 | 成员 |'
- en: '| * |   | @a | Pointer |   | Object | Reference |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| * |   | @a | 指针 |   | 对象 | 引用 |'
- en: '| [] |   | a[b] | Pointer | Integer | Object | Member |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| [] |   | a[b] | 指针 | 整数 | 对象 | 成员 |'
- en: '| -> |   | a@m | **struct** Pointer |   | Object | Member |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| -> |   | a@m | **结构**指针 |   | 对象 | 成员 |'
- en: '| () |   | a(b ...) | Function pointer |   | Value | Call |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| () |   | a(b ...) | 函数指针 |   | 值 | 调用 |'
- en: '| **sizeof** |   | @ a | None |   | **size_t** | Size, ICE |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **sizeof** |   | @ a | 无 |   | **size_t** | 大小，ICE |'
- en: '| **_Alignof** | **alignof** | @(a) | None |   | **size_t** | Alignment, ICE
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **_Alignof** | **alignof** | @(a) | 无 |   | **size_t** | 对齐，ICE |'
- en: Table 4.2\. Object operators *The Form column gives the syntactic form of the
    operation, where @ represents the operator, o denotes an object, and a denotes
    a suitable additional *value* (if any) that serves as an operand. An additional
    * in the Type column requires that the object o be addressable.*
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.2\. 对象运算符 *形式列给出了操作的语法形式，其中 @ 代表运算符，o 表示对象，a 表示作为操作数的适当附加 *值*（如果有）。类型列中的附加
    *要求对象 o 可寻址。*
- en: '| Operator | Nick | Form | Type | Result |   |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 别名 | 形式 | 类型 | 结果 |   |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|   |   | o | Array* | Pointer | Array decay |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|   |   | o | 数组* | 指针 | 数组降级 |'
- en: '|   |   | o | Function | Pointer | Function decay |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|   |   | o | 函数 | 指针 | 函数降级 |'
- en: '|   |   | o | Other | Value | Evaluation |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|   |   | o | 其他 | 值 | 评估 |'
- en: '| = |   | o@a | Non-array | Value | Assignment |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| = |   | o@a | 非数组 | 值 | 赋值 |'
- en: '| += -= *= /= |   | o@a | Arithmetic | Value | Arithmetic |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| += -= *= /= |   | o@a | 算术 | 值 | 算术 |'
- en: '| += -= |   | o@a | Pointer | Value | Arithmetic |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| += -= |   | o@a | 指针 | 值 | 算术 |'
- en: '| %= |   | o@a | Integer | Value | Arithmetic |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| %= |   | o@a | 整数 | 值 | 算术 |'
- en: '| ++ -- |   | @o o@ | Arithmetic or pointer | Value | Arithmetic |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| ++ -- |   | @o o@ | 算术或指针 | 值 | 算术 |'
- en: '| &= | **and_eq** | o@a | Integer | Value | Bit |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| &= | **and_eq** | o@a | 整数 | 值 | 位 |'
- en: '| &#124;= | **or_eq** |   |   |   |   |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| &#124;= | **or_eq** |   |   |   |   |'
- en: '| ^= | **xor_eq** |   |   |   |   |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| ^= | **xor_eq** |   |   |   |   |'
- en: '| <<= >>= |   | o@a | Integer | Value | Bit |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| <<= >>= |   | o@a | 整数 | 值 | 位 |'
- en: '| . |   | o@m | **struct** | Object | Member |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| . |   | o@m | **struct** | 对象 | 成员 |'
- en: '| [] |   | o[a] | Array* | Object | Member |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| [] |   | o[a] | 数组 | 对象 | 成员 |'
- en: '| & |   | @o | Any* | Pointer | Address |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| & |   | @o | 任何* | 指针 | 地址 |'
- en: '| **sizeof** |   | @ o | Data Object, non-VLA | **size_t** | Size, ICE |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **sizeof** |   | @ o | 数据对象，非VLA | **size_t** | 大小，ICE |'
- en: '| **sizeof** |   | @ o | VLA | **size_t** | size |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **sizeof** |   | @ o | VLA | **size_t** | 大小 |'
- en: '| **_Alignof** | **alignof** | @(o) | Non-function | **size_t** | Alignment,
    ICE |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| **_Alignof** | **alignof** | @(o) | 非函数 | **size_t** | 对齐，ICE |'
- en: Table 4.3\. Type operators *These operators return an integer constant (ICE)
    of type **`size_t`**. They have function-like syntax with the operands in parentheses.*
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.3\. 类型运算符 *这些运算符返回一个整数常量（ICE）类型为 **`size_t`**。它们具有类似函数的语法，操作数在括号中。*
- en: '| Operator | Nick | Form | Type of T |   |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 别名 | 形式 | T的类型 | 结果 |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **sizeof** |   | **sizeof**(T) | Any | Size |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **sizeof** |   | **sizeof**(T) | 任何 | 大小 |'
- en: '| **_Alignof** | **alignof** | **_Alignof**(T) | Any | Alignment |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **_Alignof** | **alignof** | **_Alignof**(T) | 任何 | 对齐 |'
- en: '|   | **offsetof** | **offsetof**(T,m) | **struct** | Member offset |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|   | **offsetof** | **offsetof**(T,m) | **struct** | 成员偏移 |'
- en: 4.1\. Arithmetic
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 算术
- en: Arithmetic operators form the first group in [table 4.1](#ch04table01) of operators
    that operate on values.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符是操作值的运算符 [表 4.1](#ch04table01) 中的第一组。
- en: 4.1.1\. +, -, and *
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. +, -, 和 *
- en: 'The arithmetic operators *`+`*, *`-`*, and *`*`* mostly work as we would expect
    by computing the sum, the difference, and the product, respectively, of two values:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符 *`+`*、*`-`* 和 *`*`* 主要按我们预期的样子工作，分别计算两个值的和、差和积：
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, c must be equal to `76`, and d to `31`. As you can see from this little
    example, subexpressions can be grouped together with parentheses to enforce a
    preferred binding of the operator.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，c 必须等于 `76`，d 必须等于 `31`。正如您从这个小例子中可以看到的，子表达式可以通过括号分组，以强制执行运算符的优先绑定。 '
- en: 'In addition, the operators *`+`* and *`-`* have unary variants. -b gives the
    negative of b: a value a such that b `+` a is `0`. +a simply provides the value
    of a. The following gives `76` as well:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，运算符 *`+`* 和 *`-`* 有单目变体。-b 给出 b 的相反数：一个值 a，使得 b `+` a 等于 `0`。+a 简单地提供 a 的值。以下也给出
    `76`：
- en: '[PRE30]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though we use an unsigned type for our computation, negation and difference
    by means of the operator `-` are *well defined**^C*. That is, regardless of the
    values we feed into such a subtraction, our computation will always have a valid
    result. In fact, one of the miraculous properties of **`size_t`** is that `+-*`
    arithmetic always works where it can. As long as the final mathematical result
    is within the range `[0,` **`SIZE_MAX`**`]`, then that result will be the value
    of the expression.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在计算中使用无符号类型，通过运算符 `-` 的取反和差分也是 *明确定义的**^C*。也就是说，无论我们向这种减法中输入什么值，我们的计算总是会有一个有效的结果。事实上，`size_t`
    的一个神奇属性是 `+-*` 算术总是在可能的地方工作。只要最终的数学结果在范围 `[0,` **`SIZE_MAX`**`]` 内，那么该结果将是表达式的值。
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.2
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 4.2
- en: '*Unsigned arithmetic is always well defined.*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号算术始终有明确定义。*'
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.3
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.3 摘要
- en: '*The operations* *`+`**,* *`-`**, and* *`*`* *on* **`size_t`** *provide the
    mathematically correct result if it is representable as a* **`size_t`***.*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*`+`**、* *`-`**、和* *`*`* *在* **`size_t`** *上的运算如果可以表示为* **`size_t`** *，则提供数学上正确的结果。'
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When the result is not in that range and thus is not *representable**^C* as
    a **`size_t`** value, we speak of arithmetic *overflow**^C*. Overflow can happen,
    for example, if we multiply two values that are so large that their mathematical
    product is greater than **`SIZE_MAX`**. We’ll look how C deals with overflow in
    the next chapter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当结果不在这个范围内，因此不能*表示*^C*为**`size_t`**值时，我们称之为算术*溢出*^C*。溢出可能发生在，例如，如果我们乘以两个值，它们的数学乘积大于**`SIZE_MAX`**。我们将在下一章中看看C如何处理溢出。
- en: 4.1.2\. Division and remainder
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 除法和余数
- en: 'The operators *`/`* and *`%`* are a bit more complicated, because they correspond
    to integer division and the remainder operation. You might not be as used to them
    as you are to the other three arithmetic operators. a`/`b evaluates to the number
    of times b fits into a, and a%b is the remaining value once the maximum number
    of bs are removed from a. The operators `/` and `%` come in pairs: if we have
    z `=` a `/` b, the remainder a `%` b can be computed as a `-` z`*`b:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '运算符`/`和`%`稍微复杂一些，因为它们对应于整数除法和余数操作。你可能不像对其他三个算术运算符那样熟悉它们。`a`/`b`的结果是b可以放入a中的次数，而`a`%`b`是在从a中移除最大数量的b之后剩余的值。`/`和`%`是一对运算符：如果我们有z
    `=` a `/` b，余数`a`%`b`可以计算为`a`- z`*`b:'
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.4
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.4 摘要
- en: '*For unsigned values,* *`a`* *`==`* *`(`**a`/`b`)``*`**`b`* *`+`* *`(`**a`%`**`b`*).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于无符号值，* *`a`* *`==`* *`(`**a`/`b`)``*`**`b`* *`+`* *`(`**a`%`**`b`*).'
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'A familiar example for the `%` operator is the hours on a clock. Say we have
    a 12-hour clock: 6 hours after 8:00 is 2:00\. Most people are able to compute
    time differences on 12-hour or 24-hour clocks. This computation corresponds to
    a `% 12`: in our example, `(8 + 6) % 12 == 2`.^([[[Exs 1]](#ch04fn01)]) Another
    similar use for `%` is computation using minutes in an hour, of the form a `%
    60`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`%`运算符的一个熟悉例子是时钟上的小时。比如说我们有一个12小时制的时钟：8:00后的6小时是2:00。大多数人能够计算12小时或24小时制时钟上的时间差。这种计算对应于`%
    12`：在我们的例子中，`(8 + 6) % 12 == 2`^([[[Exs 1]](#ch04fn01)])。`%`的另一个类似用途是计算小时中的分钟，形式为`a
    % 60`。
- en: ^([Exs 1])
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement some computations using a 24-hour clock, such as 3 hours after 10:00
    and 8 hours after 20:00.
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用24小时制时钟进行一些计算，例如10:00后的3小时和20:00后的8小时。
- en: 'There is only one value that is not allowed for these two operations: `0`.
    Division by zero is forbidden.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个操作，只有一个值是不允许的：`0`。除以零是被禁止的。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.5
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.5 摘要
- en: '*Unsigned* *`/`* *and* *`%`* *are well defined only if the second operand is
    not* *`0`**.*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号* *`/`* *和* *`%`* *只有在第二个操作数不是* *`0`***时才有定义。*'
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `%` operator can also be used to explain additive and multiplicative arithmetic
    on unsigned types a bit better. As already mentioned, when an unsigned type is
    given a value outside its range, it is said to *overflow**^C*. In that case, the
    result is reduced as if the `%` operator had been used. The resulting value “wraps
    around” the range of the type. In the case of **`size_t`**, the range is `0` to
    **`SIZE_MAX`**, and therefore
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`运算符也可以更好地解释无符号类型上的加法和乘法算术。如前所述，当无符号类型被赋予其范围之外的值时，它被认为是*溢出*^C*。在这种情况下，结果会减少，就像使用了`%`运算符一样。结果值“环绕”类型的范围。对于**`size_t`**，范围是`0`到**`SIZE_MAX`**，因此'
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.6
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.6 摘要
- en: '*Arithmetic on* **`size_t`** *implicitly does the computation* *`%(`***`SIZE_MAX`***`+1)`**.*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*对* **`size_t`** *的算术运算隐式执行* *`%(`***`SIZE_MAX`***`+1)`**.*'
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.7
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.7 摘要
- en: '*In the case of overflow, unsigned arithmetic wraps around.*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*在溢出的情况下，无符号算术会环绕。*'
- en: '|  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This means for **`size_t`** values, **`SIZE_MAX`** `+ 1` is equal to `0`, and
    `0 - 1` is equal to **`SIZE_MAX`**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于**`size_t`**值，**`SIZE_MAX`** `+ 1`等于`0`，而`0 - 1`等于**`SIZE_MAX`**。
- en: This “wrapping around” is the magic that makes the `-` operators work for unsigned
    types. For example, the value `-1` interpreted as a **`size_t`** is equal to **`SIZE_MAX`**;
    so adding `-1` to a value a just evaluates to a `+` **`SIZE_MAX`**, which wraps
    around to
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“环绕”是使“-”运算符对无符号类型起作用的魔法。例如，将值“-1”解释为**`size_t`**等于**`SIZE_MAX`**；因此，将“-1”加到一个值上就相当于一个`+`
    **`SIZE_MAX`**，这会环绕到
- en: a `+` **`SIZE_MAX`** `- (`**`SIZE_MAX`**`+1) =` a `- 1`.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a `+` **`SIZE_MAX`** `- (`**`SIZE_MAX`**`+1) =` a `- 1`。
- en: 'The operators `/` and `%` have the nice property that their results are always
    smaller than or equal to their operands:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 和 `%` 操作符有一个很好的特性，即它们的结果总是小于或等于它们的操作数：'
- en: '|  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.8
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 4.8
- en: '*The result of unsigned* *`/`* *and* *`%`* *is always smaller than the operands.*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号* *`/`* *和* *`%`* *的结果总是小于操作数。'
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: And thus
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: '|  |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.9
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 4.9
- en: '*Unsigned* *`/`* *and* *`%`* *can’t overflow.*'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号* *`/`* *和* *`%`* *不会溢出*。'
- en: '|  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.2\. Operators that modify objects
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 操作符修改对象
- en: 'Another important operation that we have already seen is assignment: *`a`*
    *`= 42`*. As you can see from that example, this operator is not symmetric: it
    has a value on the right and an object on the left. In a freaky abuse of language,
    C jargon often refers to the right side as *rvalue**^C* (right value) and to the
    object on the left as *lvalue**^C* (left *value*). We will try to avoid that vocabulary
    whenever we can: speaking of a value and an object is sufficient.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的一个重要操作是赋值：*`a`* *`= 42`*. 如你所见，这个操作符不是对称的：它在右边有一个值，在左边有一个对象。在一种奇怪的语言滥用中，C语言术语通常将右边称为
    *rvalue**^C*（右值）和左边称为 *lvalue**^C*（左值）。我们将尽可能避免这种词汇：提到值和对象就足够了。
- en: C has other assignment operators. For any binary operator @, the five we have
    seen all have the syntax
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: C语言还有其他赋值操作符。对于任何二元操作符 @，我们看到的五个操作符都具有以下语法
- en: '[PRE31]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: They are just convenient abbreviations for combining the arithmetic operator
    @ and assignment; see [table 4.2](#ch04table02). A mostly equivalent form is
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 它们只是将算术操作符 @ 和赋值组合的方便缩写；见[表 4.2](#ch04table02)。一个大致等价的形式是
- en: '[PRE32]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In other words, there are operators *`+=`*, *`-=`*, *`*`**`=`*, *`/=`*, and
    *`%=`*. For example, in a **`for`** loop, the operator `+=` can be used:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，有操作符 *`+=`*，*`-=`*，*`*`**`=`*，*`/=`* 和 *`%=`*。例如，在一个 **`for`** 循环中，可以使用
    `+=` 操作符：
- en: '[PRE33]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The syntax of these operators is a bit picky. You aren’t allowed to have blanks
    between the different characters: for example, i `+ = 7` instead of i `+= 7` is
    a syntax error.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符的语法有点挑剔。不允许在字符之间有空格：例如，i `+ = 7` 而不是 i `+= 7` 是一个语法错误。
- en: '|  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.10
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 4.10
- en: '*Operators must have all their characters directly attached to each other.*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作符的所有字符必须直接相连*。'
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'We already have seen two other operators that modify objects: the *increment
    operator**^C* *`++`* and the *decrement operator**^C* *`--`*:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了其他两个修改对象的操作符：*递增操作符**^C* *`++`* 和 *递减操作符**^C* *`--`*：
- en: '`++`i is equivalent to i `+= 1`.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`++`i 等价于 i `+= 1`。'
- en: '`--`i is equivalent to i `-= 1`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--`i 等价于 i `-= 1`。'
- en: 'All these assignment operators are real operators. They return a value (but
    not an object!): the value of the object *after* the modification. You could,
    if you were crazy enough, write something like'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些赋值操作符都是真正的操作符。它们返回一个值（但不是对象！）：修改后的对象值。如果你足够疯狂，可以写一些像
- en: '[PRE34]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: But such combinations of modifications to several objects in one go is generally
    frowned upon. Don’t do that unless you want to obfuscate your code. Such changes
    to objects that are involved in an expression are referred to as *side effects**^C*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 但一次性修改多个对象的组合通常是不受欢迎的。除非你想要使你的代码晦涩难懂，否则不要这样做。涉及表达式的对象的变化被称为 *副作用**^C*。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.11
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 4.11
- en: '*Side effects in value expressions are evil.*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*值表达式的副作用是邪恶的*。'
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.12
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 4.12
- en: '*Never modify more than one object in a statement.*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*在一个语句中不要修改超过一个对象*。'
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For the increment and decrement operators, there are even two other forms:
    *postfix increment**^C* and *postfix decrement**^C*. They differ from the one
    we have seen, in the result they provide to the surrounding expression. The prefix
    versions of these operators (`++`a and `-`-a) do the operation first and then
    return the result, much like the corresponding assignment operators (a`+=1` and
    a-=1); the postfix operations return the value *before* the operation and perform
    the modification of the object thereafter. For any of them, the effect on the
    variable is the same: the incremented or decremented value.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递增和递减操作符，还有两种其他形式：*后缀递增**^C* 和 *后缀递减**^C*。它们与我们看到的操作符不同，在于它们提供给周围表达式的结果。这些操作符的前缀版本（`++`a
    和 `-`-a）先执行操作然后返回结果，就像相应的赋值操作符（a`+=1` 和 a`-=1`）一样；后缀操作返回操作之前的值，然后执行对象的修改。对于任何它们，变量的效果都是相同的：递增或递减的值。
- en: All this shows that evaluation of expressions with side effects may be difficult
    to follow. Don’t do it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都表明，带有副作用的表达式求值可能难以跟踪。不要这样做。
- en: 4.3\. Boolean context
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 布尔上下文
- en: 'Several operators yield a value `0` or `1`, depending on whether some condition
    is verified; see [table 4.1](#ch04table01). They can be grouped in two categories:
    comparisons and logical evaluation.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 几个运算符根据某些条件是否得到验证返回 `0` 或 `1`，请参阅 [表4.1](#ch04table01)。它们可以分为两类：比较和逻辑评估。
- en: 4.3.1\. Comparison
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 比较
- en: In our examples, we already have seen the comparison operators *`==`*, *`!=`*,
    *`<`*, and *`>`*. Whereas the latter two perform strict comparisons between their
    operands, the operators *`<=`* and *`>=`* perform “less than or equal” and “greater
    than or equal” comparisons, respectively. All these operators can be used in control
    statements, as we have already seen, but they are actually more powerful than
    that.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们已经看到了比较运算符 *`==`*、*`!=`*、*`<`* 和 *`>`*。而后两个运算符在其操作数之间执行严格的比较，而运算符
    *`<=`* 和 *`>=`* 分别执行“小于等于”和“大于等于”比较。所有这些运算符都可以用于控制语句，正如我们之前看到的，但它们实际上比这更强大。
- en: '|  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.13
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获4.13
- en: '*Comparison operators return the value* **`false`** *or* **`true`***.*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*比较运算符返回值* **`false`** *或* **`true`***。'
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Remember that **`false`** and **`true`** are nothing more than fancy names
    for `0` and `1`, respectively. So, they can be used in arithmetic or for array
    indexing. In the following code, c will always be `1`, and d will be `1` if a
    and b are equal and `0` otherwise:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，**`false`** 和 **`true`** 仅仅是 `0` 和 `1` 的花哨名称。因此，它们可以用于算术或数组索引。在下面的代码中，c 将始终是
    `1`，如果 a 和 b 相等，则 d 将是 `1`，否则为 `0`：
- en: '[PRE35]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the next example, the array element sig`n[`**`false`**`]` will hold the
    number of values in largeA that are greater than or equal to `1.0` and sig`n[`**`true`**`]`
    those that are strictly less:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，数组元素 sig`n[`**`false`**`]` 将包含大于或等于 `1.0` 的 largeA 中的值的数量，而 sig`n[`**`true`**`]`
    将包含严格小于的值：
- en: '[PRE36]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](pg_043.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_043.jpg)'
- en: Finally, there also is an identifier **`not_eq`** that may be used as a replacement
    for `!=`. This feature is rarely used. It dates back to the times where some characters
    were not properly present on all computer platforms. To be able to use it, you’d
    have to include the file `iso646.h`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个标识符 **`not_eq`**，可以用作 `!=` 的替代。这个特性很少使用。它追溯到一些字符没有在所有计算机平台上正确出现的时候。要使用它，你必须包含文件
    `iso646.h`。
- en: '|  |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<iso646.h>`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`<iso646.h>`'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.3.2\. Logic
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 逻辑
- en: Logic operators operate on values that are already supposed to represent a **`false`**
    or **`true`** value. If they do not, the rules described for conditional execution
    ([takeaway 3.1](kindle_split_011.html#ch03note01)) apply first. The operator *`!`*
    (**`not`**) logically negates its operand, operator *`&&`* (**`and`**) is logical
    and, and operator *`||`* (**`or`**) is logical or. The results of these operators
    are summarized in [table 4.4](#ch04table04).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符作用于已经表示 **`false`** 或 **`true`** 值的值。如果它们不是，则首先应用描述条件执行的规则（[收获3.1](kindle_split_011.html#ch03note01)）。运算符
    *`!`*（**`not`**）逻辑上否定其操作数，运算符 *`&&`*（**`and`**）是逻辑与，运算符 *`||`*（**`or`**）是逻辑或。这些运算符的结果总结在
    [表4.4](#ch04table04) 中。
- en: Table 4.4\. Logical operators
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.4\. 逻辑运算符
- en: '| a | **not** a | a **and** b | **false** | **true** | a **or** b | **false**
    | **true** |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| a | **not** a | a **and** b | **false** | **true** | a **or** b | **false**
    | **true** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **false** | **true** | **false** | **false** | **false** | **false** | **false**
    | **true** |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| **false** | **true** | **false** | **false** | **false** | **false** | **false**
    | **true** |'
- en: '| **true** | **false** | **true** | **false** | **true** | **true** | **true**
    | **true** |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| **true** | **false** | **true** | **false** | **true** | **true** | **true**
    | **true** |'
- en: Similar to the comparison operators,
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 与比较运算符类似，
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.14
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获4.14
- en: '*Logic operators return the value* **`false`** *or* **`true`***.*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑运算符返回值* **`false`** *或* **`true`***。'
- en: '|  |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Again, remember that these values are nothing more than `0` and `1` and can
    thus be used as indices:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这些值仅仅是 `0` 和 `1`，因此可以用作索引：
- en: '[PRE37]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, the expression `!!`largeA`[`i`]` applies the `!` operator twice and thus
    just ensures that largeA`[`i`]` is evaluated as a truth value ([takeaway 3.4](kindle_split_011.html#ch03note05)).
    As a result, the array elements isset`[0]` and isset`[1]` will hold the number
    of values that are equal to `0.0` and unequal, respectively.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，表达式`!!`largeA`[`i`]`应用了`!`运算符两次，因此只是确保`largeA`[`i`]`被评估为真值（[要点 3.4](kindle_split_011.html#ch03note05)）。因此，数组元素`isset`[0]`和`isset`[1]`将分别保存等于`0.0`和不等值的数量。
- en: '![](pg_044.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_044.jpg)'
- en: 'The operators `&&` and `||` have a particular property called *short-circuit
    evaluation**^C*. This barbaric term denotes the fact that the evaluation of the
    second operand is omitted if it is not necessary for the result of the operation:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`&&`和`||`有一个称为*短路评估**^C*的特殊属性。这个野蛮的术语表示第二个操作数的评估被省略，如果它对于操作的结果不是必需的：
- en: '[PRE38]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the evaluation of a/b is omitted conditionally during execution, and thereby
    a division by zero can never occur. Equivalent code would be
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在执行过程中有条件地省略了a/b的评估，从而永远不会发生除以零的情况。等效的代码将是
- en: '[PRE39]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 4.4\. The ternary or conditional operator
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 三元或条件运算符
- en: 'The *ternary operator* is similar to an **`if`** statement, but it is an expression
    that returns the value of the chosen branch:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*三元运算符*与**`if`**语句类似，但它是一个返回所选分支值的表达式：'
- en: '[PRE40]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Similar to the operators `&&` and `||`, the second and third operand are evaluated
    only if they are really needed. The macro **`sqrt`** from `tgmath.h` computes
    the square root of a non-negative value. Calling it with a negative value raises
    a *domain error**^C*:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 与运算符`&&`和`||`类似，第二个和第三个操作数只有在真正需要时才会被评估。`tgmath.h`中的宏**`sqrt`**计算非负值的平方根。用负值调用它将引发*域错误**^C*：
- en: '|  |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<tgmath.h>`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE41]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this function, **`sqrt`** is called only once, and the argument to that call
    is never negative. So, sqrt_real is always well behaved; no bad values are ever
    passed to **`sqrt`**.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，**`sqrt`**只调用一次，并且对该调用的参数永远不会是负数。因此，`sqrt_real`总是表现良好；永远不会传递任何坏值给**`sqrt`**。
- en: Complex arithmetic and the tools used for it require the header `complex.h`,
    which is indirectly included by `tgmath.h`. They will be introduced later, in
    [section 5.7.7](kindle_split_013.html#ch05lev2sec16).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 复数运算及其使用的工具需要包含`complex.h`头文件，该文件由`tgmath.h`间接包含。它们将在[第 5.7.7 节](kindle_split_013.html#ch05lev2sec16)中介绍。
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<complex.h>`'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`<complex.h>`'
- en: '`<tgmath.h>`'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the previous example, we also see conditional compilation that is achieved
    with *preprocessor directives**^C*. The **`#ifdef`** construct ensures that we
    hit the **`#error`** condition only if the macro **`__STDC_NO_COMPLEX__`** is
    defined.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们还看到了通过*预处理器指令**^C*实现的条件编译。**`#ifdef`**结构确保只有在宏**`__STDC_NO_COMPLEX__`**被定义的情况下才会遇到**`#error`**条件。
- en: 4.5\. Evaluation order
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5. 评估顺序
- en: 'Of the operators so far, we have seen that `&&`, `||`, and `?:` condition the
    evaluation of some of their operands. This implies in particular that for these
    operators, there is an evaluation order for the operands: the first operand, since
    it is a condition for the remaining ones, is always evaluated first:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的运算符中，我们已经看到`&&`、`||`和`?:`条件了它们的一些操作数的评估。这特别意味着对于这些运算符，它们的操作数有一个评估顺序：第一个操作数，因为它是对剩余操作数的条件，总是首先评估：
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.15
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 4.15
- en: '*`&&`**,* *`||`**,* *`?:`**, and* *`,`* *evaluate their first operand first.*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*`&&`**、* *`||`**、* *`?:`**和* *`,`* *首先评估它们的第一操作数。'
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The comma (*`,`*) is the only operator we haven’t introduced yet. It evaluates
    its operands in order, and the result is the value of the right operand. For example,
    `(`f`(`a`),` f`(`b`))` first evaluates f`(`a`)` and then f`(`b`)`; the result
    is the value of f`(`b`)`. Be aware that the comma *character* plays other syntactical
    roles in C that do *not* use the same convention about evaluation. For example,
    the commas that separate initializations do not have the same properties as those
    that separate function arguments.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号 (*`,`*) 是我们尚未介绍的唯一运算符。它按顺序评估其操作数，结果是右操作数的值。例如，`(`f`(`a`),` f`(`b`))`首先评估`f`(`a`)`，然后评估`f`(`b`)`；结果是`f`(`b`)`的值。请注意，逗号
    *字符* 在C中扮演其他语法角色，这些角色不使用相同的评估约定。例如，分隔初始化的逗号不具有与分隔函数参数的逗号相同的属性。
- en: 'The comma operator is rarely useful in clean code, and it is a trap for beginners:
    A`[`i`,` j`]` is *not* a two-dimensional index for matrix A, but results in A`[`j`]`.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符在干净的代码中很少有用，并且是初学者的陷阱：`A`[`i`,` j`]`不是矩阵A的二维索引，而是结果为`A`[`j`]`。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 4.16
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 4.16
- en: '*Don’t use the* *`,`* *operator.*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要使用* *`,`* *运算符*。'
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Other operators don’t have an evaluation restriction. For example, in an expression
    such as f`(`a`)+`g`(`b`)`, there is no pre-established order specifying whether
    f`(`a`)` or g`(`b`)` is to be computed first. If either the function f or g works
    with side effects (for instance, if f modifies b behind the scenes), the outcome
    of the expression will depend on the chosen order.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 其他运算符没有评估限制。例如，在一个表达式如 f`(`a`)+`g`(`b`)`中，没有预先建立的顺序指定是先计算 f`(`a`)`还是 g`(`b`)`。如果函数
    f 或 g 有副作用（例如，如果 f 在幕后修改了 b），则表达式的结果将取决于选择的顺序。
- en: '|  |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.17
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 4.17
- en: '*Most operators don’t sequence their operands.*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数运算符不会按顺序执行其操作数*。'
- en: '|  |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'That order may depend on your compiler, on the particular version of that compiler,
    on compile-time options, or just on the code that surrounds the expression. Don’t
    rely on any such particular sequencing: it will bite you.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 那个顺序可能取决于你的编译器，那个编译器的特定版本，编译时选项，或者仅仅是围绕表达式的代码。不要依赖于任何这样的特定顺序：它会让你吃苦头。
- en: The same holds for function arguments. In something like
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数参数也是如此。在类似
- en: '[PRE42]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: we wouldn’t know which of the last two arguments is evaluated first.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道最后两个参数中哪一个先被评估。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.18
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 4.18
- en: '*Function calls don’t sequence their argument expressions.*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数调用不会按顺序执行其参数表达式*。'
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The only reliable way not to depend on evaluation ordering of arithmetic expressions
    is to ban side effects:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一可靠的方法是不依赖于算术表达式的评估顺序，就是禁止副作用：
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 4.19
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 4.19
- en: '*Functions that are called inside expressions should not have side effects.*'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*在表达式内部调用的函数不应有副作用*。'
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Union-Find**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**Union-Find**'
- en: The Union-Find problem deals with the representation of partitions over a base
    set. We will identify the elements of the base set using the numbers 0, 1, ...
    and will represent partitions with a forest data structure where each element
    has a “parent” that is another element inside the same partition. Each set in
    such a partition is identified by a designated element called the root of the
    set.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Union-Find 问题处理基础集上的分区表示。我们将使用数字 0, 1, ... 来识别基础集的元素，并将分区表示为一个森林数据结构，其中每个元素都有一个“父节点”，它是同一分区内的另一个元素。这样的分区中的每个集合都由一个称为集合根的指定元素来识别。
- en: 'We want to perform two principal operations:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要执行两个主要操作：
- en: A Find operation receives one element of the ground set and returns the root
    of the corresponding set.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Find 操作接收基础集的一个元素，并返回相应集合的根。
- en: A Union^([[a](#ch04fnsb01)])operation receives two elements and merges the two
    sets to which these elements belong into one.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Union^([[a](#ch04fnsb01)]) 操作接收两个元素，并将这些元素所属的两个集合合并为一个。
- en: ^a
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: C also has a concept called a **`union`**, which we will see later, and which
    is *completely different* than the operation we are currently talking about. Because
    **`union`** is a keyword, we use capital letters to name the operations here.
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C 还有一个称为 **`union`** 的概念，我们将在后面看到，它与当前讨论的操作完全不同。因为 **`union`** 是一个关键字，所以我们在这里使用大写字母来命名操作。
- en: 'Can you implement a forest data structure in an index table of base type **`size_t`**
    called parent? Here, a value in the table **`SIZE_MAX`** would mean a position
    represents a root of one of the trees; another number represents position of the
    parent of the corresponding tree. One of the important features to start the implementation
    is an initialization function that makes parent the singleton partition: that
    is, the partition where each element is the root of its own private set.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否在一个名为 **`size_t`** 的基础类型索引表中实现一个名为 parent 的森林数据结构？在这里，表中 **`SIZE_MAX`** 的值表示一个位置代表了一棵树的根；另一个数字表示对应树的父节点位置。开始实现的一个重要特性是一个初始化函数，它使
    parent 成为单例分区：也就是说，每个元素都是其私有集合的根的分区。
- en: With this index table, can you implement a Find function that, for a given index,
    finds the root of its tree?
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个索引表，你能实现一个 Find 函数，对于给定的索引，找到其树的根吗？
- en: Can you implement a FindReplace function that changes all parent entries on
    a path to the root (including) to a specific value?
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否实现一个 FindReplace 函数，将路径上（包括）所有 parent 条目更改为特定值？
- en: Can you implement a FindCompress function that changes all parent entries to
    the root that has been found?
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否实现一个 FindCompress 函数，将所有找到的根的父节点条目更改为根？
- en: Can you implement a Union function that, for two given elements, combines their
    trees into one? Use FindCompress for one side and FindReplace for the other.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你能实现一个联合函数，将两个给定元素的树合并成一个吗？使用FindCompress对一边，FindReplace对另一边。
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Arithmetic operators do math. They operate on values.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符执行数学运算。它们作用于值。
- en: Assignment operators modify objects.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符修改对象。
- en: Comparison operators compare values and return `0` or `1`.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符比较值并返回`0`或`1`。
- en: Function calls and most operators evaluate their operands in a nonspecific order.
    Only `&&`, `||`, and `?:` impose an ordering on the evaluation of their operands.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用和大多数运算符以非特定的顺序评估它们的操作数。只有`&&`、`||`和`?:`在评估它们的操作数时施加顺序。
- en: Chapter 5\. Basic values and data
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章. 基本值和数据
- en: This chapter covers
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding the abstract state machine
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象状态机
- en: Working with types and values
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与类型和值一起工作
- en: Initializing variables
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化变量
- en: Using named constants
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名常量
- en: Binary representations of types
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型的二进制表示
- en: 'We will now change our focus from “how things are to be done” (statements and
    expressions) to the things on which C programs operate: *values**^C* and *data**^C*.
    A concrete program at an instance in time has to *represent* values. Humans have
    a similar strategy: nowadays we use a decimal presentation to write numbers on
    paper using the Hindu-Arabic numeral system. But we have other systems to write
    numbers: for example, Roman numerals (i, ii, iii, iv, and so on) or textual notation.
    To know that the word *twelve* denotes the value 12 is a nontrivial step and reminds
    us that European languages denote numbers not only in decimal but also in other
    systems. English and German mix with base 12, French with bases 16 and 20\. For
    non-native French speakers like myself, it may be difficult to spontaneously associate
    *quatre vingt quinze* (four times twenty and fifteen) with the value 95.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重点从“如何做事”（语句和表达式）转移到C程序操作的事物上：*值*^C和*数据*^C。一个具体程序在某一时刻必须*表示*值。人类有类似的策略：如今我们使用十进制表示法，在纸上使用印度-阿拉伯数字系统来写数字。但我们还有其他系统来写数字：例如，罗马数字（i，ii，iii，iv，等等）或文本表示法。知道单词*十二*表示值12是一个非平凡的步骤，这提醒我们，欧洲语言不仅在十进制中，也在其他系统中表示数字。英语和德语混合了12进制，法语使用了16进制和20进制。对于像我这样的非母语法语使用者来说，可能很难自发地将*quatre
    vingt quinze*（四乘二十加十五）与值95联系起来。
- en: Similarly, representations of values on a computer can vary “culturally” from
    architecture to architecture or are determined by the type the programmer gave
    to the value. Therefore, we should try to reason primarily about values and not
    about representations if we want to write portable code.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，计算机上值的表示可能因架构而异，或者是由程序员赋予值的类型决定的。“文化”上的差异。因此，如果我们想编写可移植的代码，我们应该主要对值进行推理，而不是对表示进行推理。
- en: If you already have some experience in C and in manipulating bytes and bits,
    you will need to make an effort to actively “forget” your knowledge for most of
    this chapter. Thinking about concrete representations of values on your computer
    will inhibit you more than it helps.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在C语言和操作字节和位方面有一些经验，你将需要在这章的大部分内容中努力“忘记”你的知识。思考你计算机上值的具体表示会比你想象的更阻碍你。
- en: '|  |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.1
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.1要点
- en: '*C programs primarily reason about values and not about their representation.*'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*C程序主要推理值而不是它们的表示*。'
- en: '|  |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The representation that a particular value has should in most cases not be your
    concern; the compiler is there to organize the translation back and forth between
    values and representations.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 特定值的表示在大多数情况下不应是你的关注点；编译器在那里是为了在值和表示之间组织翻译。
- en: In this chapter, we will see how the different parts of this translation are
    supposed to work. The ideal world in which you will usually “argue” in your program
    is C’s *abstract state machine* ([section 5.1](#ch05lev1sec1)). It gives a vision
    of the execution of your program that is mostly independent of the platform on
    which the program runs. The components of the *state* of this machine, the *objects*,
    all have a fixed interpretation (their *type*) and a value that varies in time.
    C’s basic types are described in [section 5.2](#ch05lev1sec2), followed by descriptions
    of how we can express specific values for such basic types ([section 5.3](#ch05lev1sec3)),
    how types are assembled in expressions ([section 5.4](#ch05lev1sec4)), how we
    can ensure that our objects initially have the desired values ([section 5.5](#ch05lev1sec5)),
    how we can give names to recurrent values ([section 5.6](#ch05lev1sec6)), and
    how such values are represented in the abstract state machine ([section 5.7](#ch05lev1sec7)).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到这个翻译的不同部分应该如何工作。你通常在程序中“争论”的理想世界是C的*抽象状态机*([第5.1节](#ch05lev1sec1))。它为你程序的执行提供了一个与程序运行平台基本独立的视角。这个机器的*状态*组成部分，即*对象*，都具有固定的解释（它们的*类型*）和随时间变化的价值。C的基本类型在第5.2节中描述，随后是描述我们如何表达这些基本类型的特定值([第5.3节](#ch05lev1sec3))，如何在表达式中组装类型([第5.4节](#ch05lev1sec4))，如何确保我们的对象最初具有期望的值([第5.5节](#ch05lev1sec5))，如何给重复出现的值命名([第5.6节](#ch05lev1sec6))，以及这些值在抽象状态机中的表示([第5.7节](#ch05lev1sec7))。
- en: 5.1\. The abstract state machine
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 抽象状态机
- en: 'A C program can be seen as a sort of machine that manipulates values: the particular
    values that variables of the program have at a given time, and also intermediate
    values that are the result of computed expressions. Let us consider a basic example:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 一个C程序可以看作是一种操纵值的机器：程序中变量在特定时间点的特定值，以及计算表达式产生的中间值。让我们考虑一个基本示例：
- en: '[PRE43]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here we have two variables, x and y, that have initial values `5.0` and `3.0`,
    respectively. The third line computes some expressions: a subexpression'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个变量，x和y，它们的初始值分别为`5.0`和`3.0`。第三行计算了一些表达式：一个子表达式
- en: '[PRE44]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: that evaluates x and provides the value `5.0`;
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 评估x并提供`5.0`的值；
- en: '[PRE45]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: that results in the value `7.5`;
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为`7.5`；
- en: '[PRE46]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: that evaluates y and provides the value `3.0`;
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 评估y并提供`3.0`的值；
- en: '[PRE47]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: that results in `4.5`;
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为`4.5`；
- en: '[PRE48]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: that changes the value of x to `4.5`;
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 将x的值改为`4.5`；
- en: '[PRE49]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: that evaluates x again, but that now provides the value `4.5`; and
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 再次评估x，但现在提供`4.5`的值；以及
- en: '[PRE50]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: that outputs a text line to the terminal.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本行输出到终端。
- en: Not all operations and their resulting values are *observable* from within your
    program. They are observable only if they are stored in *addressable* memory or
    written to an output device. In the example, to a certain extent, the **printf**
    statement “observes” what was done on the previous line by evaluating the variable
    x and then writing a string representation of that value to the terminal. But
    the other subexpressions and their results (such as the multiplication and subtraction)
    are not observable as such, since we never define a variable that is supposed
    to hold these values.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有操作及其产生的值都可以从你的程序内部观察到。只有当它们存储在可寻址的内存中或写入输出设备时，才是可观察的。在示例中，在某种程度上，**printf**语句“观察”了上一行所执行的操作，通过评估变量x并将该值的字符串表示写入终端来实现。但其他子表达式及其结果（如乘法和减法）并不是以这种方式可观察的，因为我们从未定义一个变量来保存这些值。
- en: Your C compiler is allowed to shortcut any of the steps during a process called
    *optimization**^C* only if it ensures the realization of the end results. Here,
    in our toy example, there are basically two possibilities. The first is that variable
    x is not used later in the program, and its acquired value is only relevant for
    our **printf** statement. In that case, the only effect of our code snippet is
    the output to the terminal, and the compiler may well (and will!) replace the
    whole snippet with the equivalent
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你的C编译器在优化过程中可以跳过任何步骤，只要它确保实现最终结果。在这里，在我们的玩具示例中，基本上有两种可能性。第一种是变量x在程序后面的部分不再使用，它获得的价值只与我们的**printf**语句相关。在这种情况下，我们代码片段的唯一效果是输出到终端，编译器可能会（并且会！）用等效的
- en: '[PRE51]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That is, it will do all the computations at compile time and, the executable
    that is produced will just print a fixed string. All the remaining code and even
    the definitions of the variables disappear.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它将在编译时完成所有计算，生成的可执行文件将只打印一个固定的字符串。所有剩余的代码甚至变量的定义都消失了。
- en: The other possibility is that x might be used later. Then a decent compiler
    would either do something like
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是x可能在以后被使用。那么一个不错的编译器可能会做如下操作
- en: '[PRE52]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: or maybe
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可能是
- en: '[PRE53]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: because to use x at a later point, it is not relevant whether the assignment
    took place before or after the **printf**.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 因为要在以后某个时刻使用x，它是否在**printf**之前或之后赋值并不重要。
- en: For an optimization to be valid, it is only important that a C compiler produces
    an executable that reproduces the *observable states**^C*. These consist of the
    contents of some variables (and similar entities that we will see later) and the
    output as they evolve during the execution of the program. This whole mechanism
    of change is called the *abstract state machine**^C*.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化是有效的，重要的是C编译器生成的可执行文件能够重现*可观察的状态**^C*。这些包括一些变量的内容（以及我们稍后将会看到的类似实体）以及它们在程序执行过程中的输出。这个整个变化机制被称为*抽象状态机**^C*。
- en: To explain the abstract state machine, we first have to look into the concepts
    of a *value* (what state are we in), the *type* (what this state represents),
    and the *representation* (how state is distinguished). As the term *abstract*
    suggests, C’s mechanism allows different platforms to realize the abstract state
    machine of a given program differently according to their needs and capacities.
    This permissiveness is one of the keys to C’s potential for optimization.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释抽象状态机，我们首先必须探讨*值*（我们处于什么状态）、*类型*（这个状态代表什么）和*表示*（如何区分状态）的概念。正如术语*抽象*所暗示的，C的机制允许不同的平台根据它们的需求和能力以不同的方式实现给定程序的抽象状态机。这种宽容性是C优化潜力的关键之一。
- en: 5.1.1\. Values
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 值
- en: 'A *value* in C is an abstract entity that usually exists beyond your program,
    the particular implementation of that program, and the representation of the value
    during a particular run of the program. As an example, the value and concept of
    `0` should and will always have the same effects on all C platforms: adding that
    value to another value *x* will again be *x*, and evaluating a value `0` in a
    control expression will always trigger the **`false`** branch of the control statement.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: C中的*值*是一个抽象实体，通常存在于你的程序之外，该程序的特定实现，以及程序特定运行期间值的表示。例如，`0`的值和概念应该在所有C平台上始终产生相同的效果：将此值添加到另一个值*x*将再次是*x*，并且在控制表达式中评估值`0`将始终触发控制语句的**`false`**分支。
- en: So far, most of our examples of values have been some kind of numbers. This
    is not an accident, but relates to one of the major concepts of C.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大多数关于值的例子都是某种类型的数字。这不是偶然的，而是与C的一个主要概念相关。
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.2
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.2总结
- en: '*All values are numbers or translate to numbers.*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有值都是数字或者可以转换为数字*。'
- en: '|  |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This property really concerns all values a C program is about, whether these
    are the characters or text we print, truth values, measures that we take, or relations
    that we investigate. Think of these numbers as mathematical entities that are
    independent of your program and its concrete realization.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性实际上涉及到C程序中所有的值，无论是我们打印的字符或文本、真值、我们采取的度量，还是我们调查的关系。将这些数字视为独立于你的程序及其具体实现的数学实体。
- en: 'The *data* of a program execution consists of all the assembled values of all
    objects at a given moment. The *state* of the program execution is determined
    by:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行的数据包括在给定时刻所有对象的汇编值。程序执行的状态由以下因素决定：
- en: The executable
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件
- en: The current point of execution
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前执行点
- en: The data
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Outside intervention, such as IO from the user
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了干预，例如来自用户的IO
- en: If we abstract from the last point, an executable that runs with the same data
    from the same point of execution must give the same result. But since C programs
    should be portable between systems, we want more than that. We don’t want the
    result of a computation to depend on the executable (which is platform specific)
    but ideally to depend only on the program specification itself. An important step
    to achieve this platform independence is the concept of *types**^C*.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从最后一点抽象出来，一个从相同执行点运行相同数据的可执行文件必须给出相同的结果。但是，由于C程序应在系统之间具有可移植性，我们想要的不仅仅是这样。我们不希望计算的結果依赖于可执行文件（这是平台特定的），而理想情况下，只依赖于程序规范本身。实现这种平台独立性的一个重要步骤是**类型**的概念^C*。
- en: 5.1.2\. Types
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 类型
- en: A type is an additional property that C associates with values. Up to now, we
    have seen several such types, most prominently **`size_t`**, but also **`double`**
    and bool.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是C与值关联的附加属性。到目前为止，我们已经看到了几种这样的类型，最显著的是**`size_t`**，还有**`double`**和bool。
- en: '|  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.3
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.3
- en: '*All values have a type that is statically determined.*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有值都有一个静态确定的类型*。'
- en: '|  |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.4
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.4
- en: '*Possible operations on a value are determined by its type.*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*对值的可能操作由其类型决定*。'
- en: '|  |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.5
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.5
- en: '*A value’s type determines the results of all operations.*'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '*值的类型决定了所有操作的结果*。'
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.1.3\. Binary representation and the abstract state machine
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3\. 二进制表示和抽象状态机
- en: 'Unfortunately, the variety of computer platforms is not such that the C standard
    can completely impose the results of the operations on a given type. Things that
    are not completely specified as such by the standard are, for example, how the
    sign of a signed type is represented the (*sign representation*), and the precision
    to which a **`double`** floating-point operation is performed (*floating-point
    representation*).^([[1](#ch05fn01)]) C only imposes properties on representations
    such that the results of operations can be deduced *a priori* from two different
    sources:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，计算机平台的多样性并不允许C标准完全规定给定类型的操作结果。标准没有完全规定的事项，例如，有符号类型的符号表示（*符号表示*），以及**`double`**浮点操作执行的精度（*浮点表示*）.^([[1](#ch05fn01)])
    C只对表示施加属性，以便可以从两个不同的来源预先推断出操作的结果：
- en: ¹
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Other international standards are more restrictive about these representations.
    For example, the POSIX [[2009](kindle_split_036.html#bib15)] standard enforces
    a particular sign representation, and ISO/IEC/IEEE 60559 [[2011](kindle_split_036.html#bib6)]
    normalizes floating-point representations.
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其他国际标准对这些表示更为严格。例如，POSIX [[2009](kindle_split_036.html#bib15)]标准强制执行特定的符号表示，而ISO/IEC/IEEE
    60559 [[2011](kindle_split_036.html#bib6)]标准化了浮点表示。
- en: The values of the operands
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数的值
- en: Some characteristic values that describe the particular platform
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些描述特定平台的特征值
- en: For example, the operations on the type **`size_t`** can be entirely determined
    when inspecting the value of **`SIZE_MAX`** in addition to the operands. We call
    the model to represent values of a given type on a given platform the *binary
    representation**^C* of the type.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当检查**`SIZE_MAX`**的值以及操作数时，可以完全确定**`size_t`**类型的操作。我们称表示给定平台给定类型值的模型为该类型的*二进制表示**^C*。
- en: '|  |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.6
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.6
- en: '*A type’s binary representation determines the results of all operations.*'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型的二进制表示决定了所有操作的结果*。'
- en: '|  |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Generally, all information we need to determine that model is within reach
    of any C program: the C library headers provide the necessary information through
    named values (such as **`SIZE_MAX`**), operators, and function calls.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要的所有信息来确定该模型都可通过任何C程序获得：C库头文件通过命名值（如**`SIZE_MAX`**）、运算符和函数调用提供必要的信息。
- en: '|  |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.7
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.7
- en: '*A type’s binary representation is observable.*'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型的二进制表示是可观察的*。'
- en: '|  |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This binary representation is still a model and thus an *abstract representation*
    in the sense that it doesn’t completely determine how values are stored in the
    memory of a computer or on a disk or other persistent storage device. That representation
    is the *object representation*. In contrast to the binary representation, the
    object representation usually is not of much concern to us, as long as we don’t
    want to hack together values of objects in main memory or have to communicate
    between computers that have different platform models. Much later, in [section
    12.1](kindle_split_022.html#ch12lev1sec1), we will see that we can even observe
    the object representation, *if* such an object is stored in memory *and* we know
    its address.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这种二进制表示仍然是一个模型，因此在某种意义上是一个*抽象表示*，因为它并不完全确定值在计算机内存中或磁盘或其他持久存储设备中的存储方式。这种表示是*对象表示*。与二进制表示不同，只要我们不打算在主内存中组合对象的值，或者不需要在不同平台模型之间进行通信，对象表示通常对我们来说并不重要。在稍后的[第12.1节](kindle_split_022.html#ch12lev1sec1)中，我们将看到，如果我们知道这样一个对象存储在内存中并且知道其地址，我们甚至可以观察到对象表示。
- en: As a consequence, all computation is fixed through the values, types, and their
    binary representations that are specified in the program. The program text describes
    an *abstract state machine**^C* that regulates how the program switches from one
    state to the next. These transitions are determined by value, type, and binary
    representation only.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有计算都是通过程序中指定的值、类型及其二进制表示来固定的。程序文本描述了一个*抽象状态机**^C*，它规定了程序如何从一个状态切换到下一个状态。这些转换仅由值、类型和二进制表示决定。
- en: '|  |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.8 (as-if)
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要5.8（as-if）
- en: '*Programs execute* *as if* *following the abstract state machine.*'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序执行* *就像* *遵循抽象状态机*。'
- en: '|  |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.1.4\. Optimization
  id: totrans-574
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.4\. 优化
- en: 'How a concrete executable manages to follow the description of the abstract
    state machine is left to the discretion of the compiler creators. Most modern
    C compilers produce code that *doesn’t* follow the exact code prescription: they
    cheat wherever they can and only respect the observable states of the abstract
    state machine. For example, a sequence of additions with constant values such
    as'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让具体的可执行程序遵循抽象状态机的描述，这取决于编译器创建者的自由裁量权。大多数现代C编译器生成的代码并不严格遵循精确的代码规定：它们在可能的情况下都会作弊，并且只尊重抽象状态机的可观察状态。例如，一系列使用常数值的加法操作
- en: '[PRE54]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: may in many cases be done as if it were specified as either
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下可以像这样执行，即
- en: '[PRE55]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: or
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE56]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The compiler may perform such changes to the execution order as long as there
    will be no observable difference in the result: for example, as long as we don’t
    print the intermediate value of x and as long as we don’t use that intermediate
    value in another computation.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 只要结果没有可观察的差异，编译器就可以对执行顺序进行这样的更改：例如，只要我们不打印x的中间值，并且只要我们不使用这个中间值进行其他计算。
- en: But such an optimization can also be forbidden because the compiler can’t prove
    that a certain operation will not force program termination. In our example, much
    depends on the type of x. If the current value of x could be close to the upper
    limit of the type, the innocent-looking operation x `+= 7` may produce an overflow.
    Such overflows are handled differently according to the type. As we have seen,
    overflow of an unsigned type is not a problem, and the result of the condensed
    operation will always be consistent with the two separate ones. For other types,
    such as signed integer types (**`signed`**) and floating-point types (**`double`**),
    an overflow may *raise an exception* and terminate the program. In that case,
    the optimization cannot be performed.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种优化也可能被禁止，因为编译器无法证明某个操作不会导致程序终止。在我们的例子中，很多都取决于x的类型。如果x的当前值接近类型的上限，看起来无害的操作x
    `+= 7`可能会产生溢出。根据类型的不同，这种溢出会被以不同的方式处理。正如我们所见，无符号类型的溢出不是问题，压缩操作的结果将始终与两个单独的操作一致。对于其他类型，例如有符号整数类型(**`signed`**)和浮点类型(**`double`**)，溢出可能会*引发异常*并终止程序。在这种情况下，优化不能执行。
- en: 'As we have already mentioned, this allowed slackness between program description
    and abstract state machine is a very valuable feature, commonly referred to as
    optimization. Combined with the relative simplicity of its language description,
    this is actually one of the main features that allows C to outperform other programming
    languages that have a lot more knobs and whistles. An important consequence of
    this discussion can be summarized as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这种在程序描述和抽象状态机之间的允许的灵活性是一个非常宝贵的特性，通常被称为优化。结合其语言描述的相对简单性，这实际上是 C 语言能够超越其他具有更多旋钮和哨声的编程语言的主要特性之一。这次讨论的重要后果可以总结如下：
- en: '|  |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.9
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.9 要点
- en: '*Type determines optimization opportunities.*'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型决定了优化机会*。'
- en: '|  |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2\. Basic types
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 基本类型
- en: C has a series of basic types and means of constructing *derived types**^C*
    from them that we will describe later, in [chapter 6](kindle_split_014.html#ch06).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言有一系列基本类型，以及从它们构造 *派生类型**^C* 的方法，这些方法我们将在 [第 6 章](kindle_split_014.html#ch06)
    中描述。
- en: 'Mainly for historical reasons, the system of basic types is a bit complicated,
    and the syntax to specify such types is not completely straightforward. There
    is a first level of specification that is done entirely with keywords of the language,
    such as **`signed`**, **`int`**, and **`double`**. This first level is mainly
    organized according to C internals. On top of that is a second level of specification
    that comes through header files, and we have already seen examples: **`size_t`**
    and bool. This second level is organized by type semantics, specifying what properties
    a particular type brings to the programmer.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 主要由于历史原因，基本类型系统有些复杂，指定这些类型的语法并不完全直接。存在一个一级的指定，完全使用语言的保留字完成，例如 **`signed`**、**`int`**
    和 **`double`**。这一级主要根据 C 的内部结构组织。在其之上是一个二级的指定，通过头文件实现，我们已看到了一些例子：**`size_t`**
    和 bool。这一级是根据类型语义组织的，指定特定类型为程序员带来的属性。
- en: '![](comm.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: 'We will start with the first-level specification of such types. As we discussed
    earlier ([takeaway 5.2](#ch05note02)), all basic values in C are numbers, but
    there are different kinds of numbers. As a principal distinction, we have two
    different classes of numbers, each with two subclasses: *unsigned integers**^C*,
    *signed integers**^C*, *real floating-point numbers**^C*, and *complex floating-point
    numbers**^C*. Each of these four classes contains several types. They differ according
    to their *precision**^C*, which determines the valid range of values that are
    allowed for a particular type.^([[2](#ch05fn02)]) [Table 5.1](#ch05table01) contains
    an overview of the 18 base types.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这类类型的一级指定开始。正如我们之前讨论的 ([要点 5.2](#ch05note02))，C 语言中的所有基本值都是数字，但存在不同种类的数字。作为一个主要区别，我们有两种不同的数字类别，每个类别有两个子类别：*无符号整数**^C*、*带符号整数**^C*、*实数浮点数**^C*
    和 *复数浮点数**^C*。这四个类别中每个都包含几个类型。它们根据它们的 *精度**^C* 不同，这决定了特定类型允许的有效值范围。[表 5.1](#ch05table01)
    包含了 18 种基类型的概述。
- en: ²
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The term *precision* is used here in a restricted sense as the C standard defines
    it. It is different from the *accuracy* of a floating-point computation.
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里使用的 *精度* 一词在 C 标准的定义下具有限制性意义。它与浮点计算的 *精度* 不同。
- en: Table 5.1\. Base types according to the four main type classes. *Types with
    a *gray background* don’t allow for arithmetic; they are *promoted* before doing
    arithmetic. Type* **`char`** *is special since it can be unsigned or signed, depending
    on the platform. *All* types in this table are considered to be distinct types,
    even if they have the same class and precision.*
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1\. 根据四种主要类型类别的基类型。*具有灰色背景的类型*不允许进行算术运算；在进行算术运算之前会被*提升*。类型* **`char`** *是特殊的，因为它可以是无符号的或带符号的，这取决于平台。*表中所有*类型都被视为不同的类型，即使它们具有相同的类别和精度。
- en: '| Class | Systematic name | Other name | Rank |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 系统名称 | 其他名称 | 等级 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Integers | Unsigned | **_Bool** | bool | 0 |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | 无符号 | **_Bool** | bool | 0 |'
- en: '| **unsigned char** |  | 1 |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| **unsigned char** |  | 1 |'
- en: '| **unsigned short** |  | 2 |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| **无符号短整型** |  | 2 |'
- en: '| **unsigned int** | **unsigned** | 3 |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| **无符号整型** | **unsigned** | 3 |'
- en: '| **unsigned long** |  | 4 |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| **无符号长整型** |  | 4 |'
- en: '| **unsigned long long** |   | 5 |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| **无符号长整型** |   | 5 |'
- en: '| [Un]signed | **char** |  | 1 |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| [无]符号 | **char** |  | 1 |'
- en: '|   | **signed char** |  | 1 |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|   | **有符号字符** |  | 1 |'
- en: '|   | **signed short** | **short** | 2 |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '|   | **有符号短整型** | **短整型** | 2 |'
- en: '| Signed | **signed int** | **signed** or **int** | 3 |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| 带符号 | **有符号整型** | **signed** 或 **int** | 3 |'
- en: '|   | **signed long** | **long** | 4 |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|   | **signed long** | **long** | 4 |'
- en: '|   | **signed long long** | **long long** | 5 |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '|   | **signed long long** | **long long** | 5 |'
- en: '| Floating point | Real | **float** |   |   |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | 实数 | **float** |   |   |'
- en: '| **double** |   |   |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| **double** |   |   |'
- en: '| **long double** |   |   |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| **long double** |   |   |'
- en: '| Complex | **float _Complex** | **float** **complex** |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| Complex | **float _Complex** | **float** **complex** |'
- en: '| **double _Complex** | **double** **complex** |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| **double _Complex** | **double** **complex** |'
- en: '| **long double _Complex** | **long double** **complex** |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| **long double _Complex** | **long double** **complex** |'
- en: As you can see from the table, there are six types that we can’t use directly
    for arithmetic, the so-called *narrow types**^C*. They are *promoted**^C* to one
    of the wider types before they are considered in an arithmetic expression. Nowadays,
    on any realistic platform, this promotion will be a **`signed int`** of the same
    value as the narrow type, regardless of whether the narrow type was signed.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从表中可以看到，有六种类型我们无法直接用于算术运算，这些被称为**窄类型**^C*。在它们被用于算术表达式之前，这些类型会被**提升**^C*到更宽的类型之一。如今，在任何一个实际的平台上，这种提升将是一个与窄类型值相同的**`signed
    int`**，无论窄类型是有符号的还是无符号的。
- en: '|  |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.10
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点5.10
- en: '*Before arithmetic, narrow integer types are promoted to* **`signed int`***.*'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '*在算术运算之前，窄整数类型会被提升到* **`signed int`***.*'
- en: '|  |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Observe that among the narrow integer types, we have two prominent members:
    **`char`** and bool. The first is C’s type that handles printable characters for
    text, and the second holds truth values, **`false`** and **`true`**. As we said
    earlier, for C, even these are just some sort of numbers.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在窄整数类型中，我们有两个突出的成员：**`char`**和bool。第一个是C语言处理可打印字符的类型，第二个用于存储真值，**`false`**和**`true`**。正如我们之前所说的，对于C语言，即使是这些也只是某种数字。
- en: The 12 remaining, unpromoted, types split nicely into the four classes.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的12个未提升类型很好地分为四类。
- en: '|  |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.11
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点5.11
- en: '*Each of the four classes of base types has three distinct unpromoted types.*'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '*基本类型中的每一类都有三种不同的未提升类型。*'
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Contrary to what many people believe, the C standard doesn’t prescribe the
    precision of these 12 types: it only constrains them. They depend on a lot of
    factors that are *implementation defined**^C*.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多人认为的相反，C标准没有规定这12种类型的精度：它只是限制了它们。它们的值取决于许多*实现定义**^C*的因素。
- en: 'One of the things the standard *does* prescribe is that the possible ranges
    of values for the signed types must include each other according to their *rank*:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 标准规定了一件事，即有符号类型可能值的范围必须根据它们的**rank**相互包含：
- en: '![](pg_056-01_alt.jpg)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_056-01_alt.jpg)'
- en: 'But this inclusion does not need to be strict. For example, on many platforms,
    the set of values of **`int`** and **`long`** are the same, although the types
    are considered to be different. An analogous inclusion holds for the six unsigned
    types:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种包含关系不必是严格的。例如，在许多平台上，**`int`**和**`long`**的值集是相同的，尽管这些类型被认为是不同的。对于六个无符号类型也有类似的包含关系：
- en: '![](pg_056-02_alt.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_056-02_alt.jpg)'
- en: But remember that for any arithmetic or comparison, the narrow unsigned types
    are promoted to **`signed int`** and not to **`unsigned int`**, as this diagram
    might suggest.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，对于任何算术或比较操作，窄无符号类型会被提升为**`signed int`**，而不是**`unsigned int`**，正如这张图可能暗示的那样。
- en: 'The comparison of the ranges of signed and unsigned types is more difficult.
    Obviously, an unsigned type can never include the negative values of a signed
    type. For the non-negative values, we have the following inclusion of the values
    of types with corresponding rank:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号和无符号类型范围的比较更为复杂。显然，无符号类型永远不会包含有符号类型的负值。对于非负值，我们有以下类型值的包含关系：
- en: '![](pg_056-03.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_056-03.jpg)'
- en: 'That is, for a given rank, the non-negative values of the signed type fit into
    the unsigned type. On any modern platform you encounter, this inclusion is strict:
    the unsigned type has values that do not fit into the signed type. For example,
    a common pair of maximal values is 2^(31)–1 = 2 147 483 647 for **`signed int`**
    and 2^(32)–1 = 4 294 967 295 for **`unsigned int`**.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于给定的rank，有符号类型的非负值可以适合无符号类型。在任何现代平台上，这种包含关系是严格的：无符号类型有值不能适合有符号类型。例如，一个常见的最大值对是**`signed
    int`**的2^(31)–1 = 2 147 483 647和**`unsigned int`**的2^(32)–1 = 4 294 967 295。
- en: Because the interrelationship between integer types depends on the platform,
    choosing the “best” type for a given purpose in a portable way can be a tedious
    task. Luckily, we can get some help from the compiler implementation, which provides
    us with **`typedef`** s such as **`size_t`** that represent certain features.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整数类型之间的关系取决于平台，以可移植的方式为特定目的选择“最佳”类型可能是一项繁琐的任务。幸运的是，我们可以从编译器实现中获得一些帮助，它为我们提供了**`typedef`**，如**`size_t`**，这些代表某些特性。
- en: '|  |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.12
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.12 摘要
- en: '*Use* **`size_t`** *for sizes, cardinalities, or ordinal numbers.*'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`size_t`** *表示大小、基数或序数。'
- en: '|  |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Remember that unsigned types are the most convenient types, since they are
    the only types that have an arithmetic that is defined consistently with mathematical
    properties: the modulo operation. They can’t raise signals on overflow and can
    be optimized best. They are described in more detail in [section 5.7.1](#ch05lev2sec10).'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，无符号类型是最方便的类型，因为它们是唯一具有与数学属性一致定义的算术类型的类型：模运算。它们不能在溢出时发出信号，并且可以最好地优化。它们在[5.7.1
    节](#ch05lev2sec10)中更详细地描述。
- en: '|  |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.13
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.13 摘要
- en: '*Use* **`unsigned`** *for small quantities that can’t be negative.*'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`unsigned`** *表示不能为负的小量。'
- en: '|  |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If your program really needs values that may be both positive and negative but
    don’t have fractions, use a signed type (see [section 5.7.5](#ch05lev2sec14)).
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序确实需要可能为正也可能为负但没有分数的值，请使用有符号类型（参见[5.7.5 节](#ch05lev2sec14)）。
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.14
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.14 摘要
- en: '*Use* **`signed`** *for small quantities that bear a sign.*'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`signed`** *表示带有符号的小量。'
- en: '|  |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.15
  id: totrans-653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.15 摘要
- en: '*Use* **`ptrdiff_t`** *for large differences that bear a sign.*'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`ptrdiff_t`** *表示带有符号的大差异。'
- en: '|  |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you want to do fractional computation with a value such as `0.5` or `3.77189`E`+89`,
    use floating-point types (see [section 5.7.7](#ch05lev2sec16)).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用像`0.5`或`3.77189`E`+89`这样的值进行分数计算，请使用浮点类型（参见[5.7.7 节](#ch05lev2sec16)）。
- en: '|  |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.16
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.16 摘要
- en: '*Use* **`double`** *for floating-point calculations.*'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`double`** *进行浮点计算。'
- en: '|  |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.17
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.17 摘要
- en: '*Use* **`double`** **`complex`** *for complex calculations.*'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`double`** **`complex`** *进行复杂数学运算。'
- en: '|  |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The C standard defines a lot of other types, among them other arithmetic types
    that model special use cases. [Table 5.2](#ch05table02) lists some of them. The
    second pair represents the types with maximal width that the platform supports.
    This is also the type in which the preprocessor does any of its arithmetic or
    comparison.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准定义了许多其他类型，其中还包括其他用于特殊用例的算术类型。[表 5.2](#ch05table02) 列出了一些。第二对表示平台支持的宽度最大的类型。这也是预处理器进行任何算术或比较的类型。
- en: Table 5.2\. Some semantic arithmetic types for specialized use cases
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.2\. 一些用于特定用例的语义算术类型
- en: '| Type | Header | Context of definition | Meaning |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 头文件 | 定义上下文 | 含义 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **size_t** | stddef.h |   | type for “sizes” and cardinalities |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| **size_t** | stddef.h |   | “大小”和基数类型 |'
- en: '| **ptrdiff_t** | stddef.h |   | type for size differences |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| **ptrdiff_t** | stddef.h |   | 大小差异的类型 |'
- en: '| **uintmax_t** | stdint.h |   | maximum width unsigned integer, preprocessor
    |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| **uintmax_t** | stdint.h |   | 最大宽度的无符号整数，预处理器 |'
- en: '| **intmax_t** | stdint.h |   | maximum width signed integer, preprocessor
    |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| **intmax_t** | stdint.h |   | 最大宽度的有符号整数，预处理器 |'
- en: '| **time_t** | time.h | **time**(0), **difftime**(t1, t0) | calendar time in
    seconds since epoch |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| **time_t** | time.h | **time**(0), **difftime**(t1, t0) | 自纪元以来的日历时间（秒） |'
- en: '| **clock_t** | time.h | **clock**() | processor time |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| **clock_t** | time.h | **clock**() | 处理器时间 |'
- en: 'The two types **`time_t`** and **`clock_t`** are used to handle times. They
    are semantic types, because the precision of the time computation can be different
    from platform to platform. The way to have a time in seconds that can be used
    in arithmetic is the function **difftime**: it computes the difference of two
    timestamps. **`clock_t`** values present the platform’s model of processor clock
    cycles, so the unit of time is usually much less than a second; **`CLOCKS_PER_SEC`**
    can be used to convert such values to seconds.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类型**`time_t`**和**`clock_t`**用于处理时间。它们是语义类型，因为时间计算的精度可能因平台而异。要在算术中使用以秒为单位的时间，可以使用函数**difftime**：它计算两个时间戳的差异。**`clock_t`**值表示平台的处理器时钟周期模型，因此时间单位通常小于一秒；可以使用**`CLOCKS_PER_SEC`**将这些值转换为秒。
- en: 5.3\. Specifying values
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 指定值
- en: '![](comm.jpg)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: 'We have already seen several ways in which numerical constants (*literals**^C*)
    can be specified:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种指定数值常量（*字面量**^C*）的方法：
- en: '| 123 | *Decimal integer constant**^C*. The most natural choice for most of
    us. |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| 123 | *十进制整数常量**^C*. 对我们大多数人来说是最自然的选择。|'
- en: '| 077 | *Octal integer constant**^C*. This is specified by a sequence of digits,
    the first being 0 and the following between 0 and 7\. For example, 077 has the
    value 63\. This type of specification merely has historical value and is rarely
    used nowadays. Only one octal literal is commonly used: 0 itself. |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| 077 | *八进制整数常量**^C*. 这是由一系列数字指定的，第一个数字是 0，后面的数字在 0 到 7 之间。例如，077 的值是 63。这种指定方式仅具有历史价值，现在很少使用。只有一种八进制字面量常用：0
    本身。|'
- en: '| 0xFFFF | *Hexadecimal integer constant**^C*. This is specified by starting
    with 0x followed by a sequence of digits between 0, . . . , 9 and a . . . f. For
    example, 0xbeaf has the value 48815\. The a .. f and x can also be written in
    capitals, 0XBEAF. |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| 0xFFFF | *十六进制整数常量**^C*. 这是由以 0x 开头，后跟 0 到 9 和 a 到 f 之间的数字序列指定的。例如，0xbeaf
    的值是 48815。a 到 f 和 x 也可以写成大写，0XBEAF。|'
- en: '| 1.7E-13 | *Decimal floating-point constants**^C*. Quite familiar as the version
    that has a decimal point. But there is also the “scientific” notation with an
    exponent. In the general form, mEe is interpreted as *m* · 10*^e*. |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| 1.7E-13 | *十进制浮点常量**^C*. 与带有小数点的版本非常熟悉。但还有一种带有指数的“科学”表示法。在一般形式中，mEe 被解释为
    *m* · 10*^e*. |'
- en: '| 0x1.7aP-13 | *Hexadecimal floating-point constants**^C*. Usually used to
    describe floating-point values in a form that makes it easy to specify values
    that have exact representations. The general form 0XhPe is interpreted as *h*
    · 2*^e*. Here, *h* is specified as a hexadecimal fraction. The exponent *e* is
    still specified as a decimal number. |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| 0x1.7aP-13 | *十六进制浮点常量**^C*. 通常用于描述易于指定具有精确表示的浮点值的形式。一般形式 0XhPe 被解释为 *h*
    · 2*^e*. 这里，*h* 被指定为十六进制分数。指数 *e* 仍然被指定为十进制数。|'
- en: '| ''a'' | *Integer character constant**^C*. These are characters put between
    '' apostrophes, such as ''a'' or ''?''. These have values that are only implicitly
    fixed by the C standard. For example, ''a'' corresponds to the integer code for
    the character *a* of the Latin alphabet. Among character constants, the \ character
    has a special meaning. For example, we already have seen ''\n'' for the newline
    character. |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| ''a'' | *整数字符常量**^C*. 这些是放在单引号之间的字符，例如 ''a'' 或 ''?''. 它们的值仅由 C 标准隐式确定。例如，''a''
    对应于拉丁字母中的字符 *a* 的整数代码。在字符常量中，反斜杠字符 \ 有特殊含义。例如，我们已经看到了用于换行符的 ''\n''。|'
- en: '| "hello" | *String literals**^C*. They specify text, such as that needed for
    the **printf** and **puts** functions. Again, the \ character is special, as with
    character constants.^([[3](#ch05fn03)]) |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| "hello" | *字符串字面量**^C*. 它们指定文本，例如用于 **printf** 和 **puts** 函数的文本。同样，反斜杠字符
    \ 与字符常量一样具有特殊含义.^([[3](#ch05fn03)]) |'
- en: ³
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If used in the context of the **printf** function, another character also becomes
    “special”: the % character. If you want to print a literal % with **printf**,
    you have to duplicate it.'
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在 **printf** 函数的上下文中使用，另一个字符也变成了“特殊”字符：百分号字符。如果你想在 **printf** 中打印字面量 %，你必须重复它。
- en: 'All but the last are numerical constants: they specify numbers.^([[4](#ch05fn04)])
    String literals are an exception and can be used to specify text that is known
    at compile time. Integrating larger text into our code could be tedious, if we
    weren’t allowed to split string literals into chunks:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后的之外，都是数值常量：它们指定数字.^([[4](#ch05fn04)]) 字符串字面量是一个例外，可以在编译时指定文本。如果我们不允许将字符串字面量分成块，将更大的文本集成到我们的代码中可能会很繁琐：
- en: ⁴
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may have observed that complex numbers are not included in this list. We
    will see how to specify them in [section 5.3.1](#ch05lev2sec5).
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能已经注意到复数不包含在这个列表中。我们将在 [5.3.1 节](#ch05lev2sec5) 中看到如何指定它们。
- en: '[PRE57]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.18
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.18
- en: '*Consecutive string literals are concatenated.*'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '*连续的字符串字面量会被连接起来。*'
- en: '|  |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The rules for numbers are a little bit more complicated.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 数字规则要复杂一些。
- en: '|  |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.19
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.19
- en: '*Numerical literals are never negative.*'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值字面量从不为负。*'
- en: '|  |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That is, if we write something like `-34` or `-1.``5`E`-23`, the leading sign
    is not considered part of the number but is the *negation* operator applied to
    the number that comes after it. We will see shortly where this is important. Bizarre
    as this may sound, the minus sign in the exponent is considered to be part of
    a floating-point literal.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们写像 `-34` 或 `-1.5E-23` 这样的东西，前面的符号不是数字的一部分，而是应用于其后数字的*否定*运算符。我们很快就会看到这在哪里很重要。虽然这听起来可能很奇怪，但指数中的负号被认为是浮点字面量的一部分。
- en: We have already seen ([takeaway 5.3](#ch05note03)) that all literals must have
    not only a value but also a type. Don’t mix up the fact of a constant having a
    positive value with its type, which can be **`signed`**.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 ([摘要 5.3](#ch05note03))，所有的字面量不仅必须有值，还必须有类型。不要把常量具有正值的事实与它的类型混淆，它的类型可以是
    **`signed`**。
- en: '|  |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.20
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.20
- en: '*Decimal integer constants are signed.*'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制整数常量是有符号的*。'
- en: '|  |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This is an important feature: we’d probably expect the expression `-1` to be
    a signed, negative value.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的特性：我们可能期望表达式 `-1` 是一个有符号的负值。
- en: To determine the exact type for integer literals, we always have a *first fit*
    rule.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定整数字面量的确切类型，我们始终有一个 *first fit* 规则。
- en: '|  |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.21
  id: totrans-712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.21
- en: '*A decimal integer constant has the first of the three signed types that fits
    it.*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制整数常量具有适合它的三个有符号类型中的第一个类型*。'
- en: '|  |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This rule can have surprising effects. Suppose that on a platform, the minimal
    **`signed`** value is 2^(15) = –32768 and the maximum value is 2^(15) –1 = 32767\.
    The constant 32768 then doesn’t fit into **`signed`** and is thus **`signed long`**.
    As a consequence, the expression `-32768` has type **`signed long`**. Thus the
    minimal value of the type **`signed`** on such a platform cannot be written as
    a literal constant.^([[[Exs 1]](#ch05fn-ex01)])
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则可能会有意想不到的效果。假设在一个平台上，最小的 **`signed`** 值是 2^(15) = –32768，最大值是 2^(15) –1
    = 32767\. 因此，常量 32768 不适合 **`signed`**，因此是 **`signed long`**。因此，表达式 `-32768` 的类型是
    **`signed long`**。因此，该平台上 **`signed`** 类型的最小值不能写成字面量常量.^([[[Exs 1]](#ch05fn-ex01)])
- en: ^([Exs 1])
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that if the minimal and maximal values for **`signed long long`** have
    similar properties, the smallest integer value for the platform can’t be written
    as a combination of one literal with a minus sign.
  id: totrans-718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明如果 **`signed long long`** 的最小值和最大值具有类似特性，平台的最小整数值不能写成带负号的字面量组合。
- en: '|  |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.22
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.22
- en: '*The same value can have different types.*'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '*相同的值可以有不同的类型*。'
- en: '|  |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Deducing the type of an octal or hexadecimal constant is a bit more complicated.
    These can also be of an unsigned type if the value doesn’t fit for a signed type.
    In the earlier example, the hexadecimal constant `0`x7FFF has the value 32767
    and thus is type **`signed`**. Other than for the decimal constant, the constant
    `0`x8000 (value 32768 written in hexadecimal) then is an **`unsigned`**, and expression
    `-0`x8000 again is **`unsigned`**.^([[[Exs 2]](#ch05fn-ex02)])
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 推断八进制或十六进制常量的类型要复杂一些。如果值不适合有符号类型，它们也可以是无符号类型。在早期示例中，十六进制常量 `0`x7FFF 的值是 32767，因此类型是
    **`signed`**。除了十进制常量外，常量 `0`x8000（用十六进制表示的值为 32768）是一个**`unsigned`**，表达式 `-0`x8000
    再次是 **`unsigned`**.^([[[Exs 2]](#ch05fn-ex02)])
- en: ^([Exs 2])
  id: totrans-724
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that if the maximum **`unsigned`** is 2^(16) –1, then `-`0x8000 has value
    32768, too.
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明如果最大的**`unsigned`**是 2^(16) –1，那么 `-`0x8000 也有值 32768。
- en: '|  |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.23
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.23
- en: '*Don’t use octal or hexadecimal constants to express negative values.*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要使用八进制或十六进制常量来表示负值*。'
- en: '|  |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As a consequence, there is only one choice left for negative values.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只剩下一种选择留给负值。
- en: '|  |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.24
  id: totrans-733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.24
- en: '*Use decimal constants to express negative values.*'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用十进制常量来表示负值*。'
- en: '|  |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Integer constants can be forced to be unsigned or to be a type with minimal
    width. This is done by appending *U*, *L*, or *LL* to the literal. For example,
    `1`U has value 1 and type **`unsigned`**, `1`L is **`signed long`**, and `1`ULL
    has the same value 1 but type **`unsigned long long`**.^([[[Exs 3]](#ch05fn-ex03)])
    Note that we are representing C constants such as `1`ULL in typewriter font and
    distinguish them from their mathematical value 1 which is in normal font.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 整数常量可以强制转换为无符号类型或具有最小宽度的类型。这是通过在字面量后附加 *U*、*L* 或 *LL* 来实现的。例如，`1`U 的值是 1，类型是
    **`unsigned`**，`1`L 是 **`signed long`**，而 `1`ULL 有相同的值 1 但类型是 **`unsigned long
    long`**.^([[[Exs 3]](#ch05fn-ex03)]) 注意，我们用打字机字体表示 C 常量，如 `1`ULL，并将它们与它们的数学值 1
    区分开来，后者用正常字体表示。
- en: ^([Exs 3])
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that the expressions `-`1U, `-`1UL, and `-`1ULL have the maximum values
    and type as the three non-promoted unsigned types, respectively.
  id: totrans-739
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明表达式 `-1U`, `-1UL`, 和 `-1ULL` 分别具有三个非提升的无符号类型的最小值和类型。
- en: A common error is to try to assign a hexadecimal constant to a **`signed`**
    with the expectation that it will represent a negative value. Consider a declaration
    such as **`int`** x `= 0`xFFFFFFFF. This is done under the assumption that the
    hexadecimal value has the same *binary representation* as the signed value –1\.
    On most architectures with 32-bit **`signed`**, this will be true (but not on
    all of them); but then nothing guarantees that the effective value +4294967295
    is converted to the value –1\. [Table 5.3](#ch05table03) has some examples of
    interesting constants, their values and their types.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是尝试将十六进制常量赋给一个 **`signed`** 类型，并期望它将表示一个负值。考虑一个如 **`int`** x `= 0xFFFFFFFF`
    的声明。这是在假设十六进制值与有符号值 -1 的 *二进制表示* 相同的情况下进行的。在大多数具有 32 位 **`signed`** 的架构上，这将是正确的（但并非所有架构都是这样）；但随后没有任何保证将有效值
    +4294967295 转换为值 -1。 [表 5.3](#ch05table03) 包含了一些有趣的常量、它们的值和它们的类型示例。
- en: Table 5.3\. Examples for constants and their types. This is under the supposition
    that **`signed`** and **`unsigned`** have the commonly used representation with
    32 bits
  id: totrans-741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.3\. 常量及其类型的示例。这是在假设 **`signed`** 和 **`unsigned`** 使用常见的 32 位表示的情况下。
- en: '| Constant *x* | Value | Type | Value of *–**x* |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| 常量 *x* | 值 | 类型 | *–*x 的值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 2147483647 | +2147483647 | **signed** | *–*2147483647 |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '| 2147483647 | +2147483647 | **有符号** | *–*2147483647 |'
- en: '| 2147483648 | +2147483648 | **signed long** | *–*2147483648 |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '| 2147483648 | +2147483648 | **signed long** | *–*2147483648 |'
- en: '| 4294967295 | +4294967295 | **signed long** | *–*4294967295 |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '| 4294967295 | +4294967295 | **signed long** | *–*4294967295 |'
- en: '| 0x7FFFFFFF | +2147483647 | **signed** | *–*2147483647 |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| 0x7FFFFFFF | +2147483647 | **有符号** | *–*2147483647 |'
- en: '| 0x80000000 | +2147483648 | **unsigned** | +2147483648 |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '| 0x80000000 | +2147483648 | **无符号** | +2147483648 |'
- en: '| 0xFFFFFFFF | +4294967295 | **unsigned** | +1 |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| 0xFFFFFFFF | +4294967295 | **无符号** | +1 |'
- en: '| 1 | +1 | **signed** | *–*1 |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '| 1 | +1 | **有符号** | *–*1 |'
- en: '| 1U | +1 | **unsigned** | +4294967295 |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '| 1U | +1 | **无符号** | +4294967295 |'
- en: 'Remember that value 0 is important. It is so important that it has a lot of
    equivalent spellings: `0`, `0`x0, and ''\0'' are all the same value, a `0` of
    type **`signed int`**. 0 has no decimal integer spelling: `0.0` *is* a decimal
    spelling for the value 0 but is seen as a floating-point value with type **`double`**.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 记住值 0 非常重要。它如此重要，以至于有大量的等效表示法：`0`, `0`x0, 和 '\0' 都表示相同的值，一个 `0` 的类型为 **`signed
    int`**。0 没有十进制整数的表示法：`0.0` *是* 值 0 的十进制表示法，但它被视为类型为 **`double`** 的浮点值。
- en: '|  |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.25
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.25
- en: '*Different literals can have the same value.*'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '*不同的字面量可以具有相同的值。*'
- en: '|  |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For integers, this rule looks almost trivial, but for floating-point constants
    it is less obvious. Floating-point values are only an *approximation* of the value
    they present literally, because binary digits of the fractional part may be truncated
    or rounded.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数，这个规则看起来几乎是显而易见的，但对于浮点常量来说则不那么明显。浮点值只是它们所表示的值的近似，因为小数部分的二进制位可能被截断或四舍五入。
- en: '|  |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.26
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.26
- en: '*The effective value of a decimal floating-point constant may be different
    from its literal value.*'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制浮点常量的有效值可能与字面值不同。*'
- en: '|  |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For example, on my machine, the constant `0.2` has the value 0.2000000000000000111,
    and as a consequence the constants `0.2` and `0.2000000000000000111` have the
    same value.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的机器上，常量 `0.2` 的值为 0.2000000000000000111，因此常量 `0.2` 和 `0.2000000000000000111`
    具有相同的值。
- en: Hexadecimal floating-point constants have been designed because they better
    correspond to binary representations of floating-point values. In fact, on most
    modern architectures, such a constant (that does not have too many digits) will
    exactly correspond to the literal value. Unfortunately, these beasts are almost
    unreadable for mere humans. For example, consider the two constants `0`x1`.99999`AP`-3`
    and `0`xC.CCCCCCCCCCCCCCDP`-6`. The first corresponds to 1.60000002384 * 2^(–3)
    and the second to 12.8000000000000000002 * 2^(–6); thus, expressed as decimal
    floating points, their values are approximatively 0.20000000298 and 0.200000000000000000003,
    respectively. So the two constants have values that are very close to each other,
    whereas their representation as hexadecimal floating-point constants seems to
    put them far apart.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制浮点常量已经被设计出来，因为它们更好地对应于浮点值的二进制表示。实际上，在大多数现代架构上，这样的常量（位数不是太多）将正好对应于字面量值。不幸的是，这些怪物对于普通人来说几乎不可读。例如，考虑两个常量
    `0`x1`.99999`AP`-3` 和 `0`xC.CCCCCCCCCCCCCCDP`-6`。第一个对应于 1.60000002384 * 2^(–3)，第二个对应于
    12.8000000000000000002 * 2^(–6)；因此，以十进制浮点数表示，它们的值分别约为 0.20000000298 和 0.200000000000000000003。所以这两个常量的值非常接近，而它们作为十六进制浮点常量的表示似乎把它们放在了很远的地方。
- en: 'Finally, floating-point constants can be followed by the letter f or F to denote
    a **`float`** or by l or L to denote a **`long double`**. Otherwise, they are
    of type **`double`**. Be aware that different types of constants generally lead
    to different values for the same literal. Here is a typical example:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，浮点常量可以跟字母 f 或 F 一起使用来表示 **`float`**，或者跟 l 或 L 一起使用来表示 **`long double`**。否则，它们是
    **`double`** 类型。请注意，不同类型的常量通常会导致相同的字面量有不同的值。以下是一个典型的例子：
- en: '|   | **float** | **double** | **long double** |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '|   | **float** | **double** | **long double** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| literal | 0.2F | 0.2 | 0.2L |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| 字面量 | 0.2F | 0.2 | 0.2L |'
- en: '| value | 0x1.99999AP-3F | 0x1.999999999999AP-3 | 0xC.CCCCCCCCCCCCCCDP-6L |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 0x1.99999AP-3F | 0x1.999999999999AP-3 | 0xC.CCCCCCCCCCCCCCDP-6L |'
- en: '|  |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.27
  id: totrans-770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 5.27
- en: '*Literals have value, type, and binary representations.*'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量具有值、类型和二进制表示。*'
- en: '|  |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.3.1\. Complex constants
  id: totrans-773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1. 复合常量
- en: Complex types are not necessarily supported by all C platforms. This fact can
    be checked by inspecting **`__STDC_NO_COMPLEX__`**. To have full support of complex
    types, the header `complex.h` should be included. If you use `tgmath.h` for mathematical
    functions, this is already done implicitly.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型不一定被所有 C 平台支持。可以通过检查 **`__STDC_NO_COMPLEX__`** 来验证这一点。要完全支持复合类型，应包含头文件 `complex.h`。如果你使用
    `tgmath.h` 进行数学函数，这已经隐式地完成了。
- en: '|  |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<complex.h>`'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`<complex.h>`'
- en: '`<tgmath.h>`'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Unfortunately, C provides no literals to specify constants of a complex type.
    It only has several macros^([[5](#ch05fn05)]) that may ease the manipulation of
    these types.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C 提供了没有字面量来指定复合类型常量的功能。它只有几个宏^([[5](#ch05fn05)])，这些宏可能有助于操作这些类型。
- en: ⁵
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will only see in [section 5.6.3](#ch05lev2sec8) what macros really are. For
    now, just take them as names to which the compiler has associated some specific
    property.
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在 [第 5.6.3 节](#ch05lev2sec8) 中看到宏到底是什么。现在，只需把它们当作编译器已经关联了一些特定属性的名称即可。
- en: The first possibility to specify complex values is the macro **`CMPLX`**, which
    comprises two floating-point values, the real and imaginary parts, in one complex
    value. For example, **`CMPLX`**`(0.5, 0.5)` is a **`double`** **`complex`** value
    with the real and imaginary part of one-half. Analogously, there are **`CMPLXF`**
    for **`float`** **`complex`** and **`CMPLXL`** for **`long double`** **`complex`**.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 指定复数值的第一个可能性是宏 **`CMPLX`**，它包含一个复数值，其中包含实部和虚部。例如，**`CMPLX`**`(0.5, 0.5)` 是一个实部和虚部均为一半的
    **`double`** **`complex`** 值。类似地，有 **`CMPLXF`** 用于 **`float`** **`complex`** 和
    **`CMPLXL`** 用于 **`long double`** **`complex`**。
- en: Another, more convenient, possibility is provided by the macro I, which represents
    a constant value of type **`float`** **`complex`** such that I`*`I has the value
    –1\. One-character macro names in uppercase are often used in programs for numbers
    that are fixed for the whole program. By itself, it is not a brilliant idea (the
    supply of one-character names is limited), but you should definitely leave I alone.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更方便的可能性是由宏 I 提供的，它代表一个类型为 **`float`** **`complex`** 的常量值，使得 I`*`I 的值为 –1。在程序中，通常使用大写单字符宏名称来表示整个程序中固定的数字。单独来看，这并不是一个很棒的想法（单字符名称的供应有限），但你绝对应该让
    I 保持原样。
- en: '|  |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.28
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 5.28
- en: '*`I`* *is reserved for the imaginary unit.*'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '*`I`* *是虚数单位保留的。*'
- en: '|  |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I can be used to specify constants of complex types similar to the usual mathematical
    notation. For example, `0.5 + 0.5``*`I would be of type **`double`** **`complex`**
    and `0.`5F `+ 0.5`F`*`I of **`float`** **`complex`**. The compiler implicitly
    *converts**^C* the result to the wider of the types if we mix, for example, **`float`**
    and **`double`** constants for real and imaginary parts.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用类似于常规数学记法的复数类型常数来指定。例如，`0.5 + 0.5``*`I将是**`double`** **`complex`**类型，而`0.`5F
    `+ 0.5`F`*`I是**`float`** **`complex`**类型。如果我们将**`float`**和**`double`**常数混合用于实部和虚部，编译器会隐式地将结果转换为更宽的类型。
- en: '|  |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Complex numbers**'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '**复数**'
- en: 'Can you extend the derivative ([challenge 2](kindle_split_011.html#ch03sb02))
    to the complex domain: that is, functions that receive and return **`double`**
    **`complex`** values?'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 你能将导数([挑战 2](kindle_split_011.html#ch03sb02))扩展到复数域：也就是说，接收和返回**`double`** **`complex`**值的函数吗？
- en: '|  |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.4\. Implicit conversions
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 隐式转换
- en: 'As we have seen in the examples, the type of an operand has an influence on
    the type of an operator expression such as `-1` or `-`1U: whereas the first is
    a **`signed int`**, the second is an **`unsigned int`**. The latter might be particularly
    surprising for beginners, because an **`unsigned int`** has no negative values
    and so the value of `-`1U is a large positive integer.'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中所见，操作数的类型会影响操作表达式（如`-1`或`-`1U）的类型：第一个是**`signed int`**，第二个是**`unsigned
    int`**。后者对于初学者来说可能特别令人惊讶，因为**`unsigned int`**没有负值，所以`-`1U的值是一个很大的正整数。
- en: '|  |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.29
  id: totrans-797
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.29
- en: '*Unary* *`-`* *and* *`+`* *have the type of their promoted argument.*'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元* *`-`* 和 *`+`* 的类型与其提升的参数相同。'
- en: '|  |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'So, these operators are examples where the type usually does not change. In
    cases where they do change, we have to rely on C’s strategy to do *implicit conversions*:
    that is, to move a value with a specific type to one that has another, desired,
    type. Consider the following examples, again under the assumption that –2147483648
    and 2147483647 are the minimal and maximal values of a **`signed int`**, respectively:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些运算符是类型通常不改变的例子。在它们改变的情况下，我们必须依赖C的隐式转换策略：也就是说，将具有特定类型的值移动到具有另一种、所需类型的值。考虑以下示例，再次假设-2147483648和2147483647分别是**`signed
    int`**的最小值和最大值：
- en: '[PRE58]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, the initializations of a and b are harmless. The respective values are
    well in the range of the desired types, so the C compiler can convert them silently.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，a和b的初始化是无害的。相应的值完全在所需类型的范围内，因此C编译器可以静默地转换它们。
- en: The next two conversions for c and d are problematic. As we have seen, `0`x80000000
    is of type **`unsigned int`** and does not fit into a **`signed int`**. So c receives
    a value that is implementation-defined, and we have to know what our platform
    has decided to do in such cases. It could just reuse the bit pattern of the value
    on the right or terminate the program. As for all implementation-defined features,
    which solution is chosen should be documented by your platform, but be aware that
    this can change with new versions of your compiler or may be switched by compiler
    arguments.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: c和d的下一个转换有问题。正如我们所见，`0`x80000000是**`unsigned int`**类型，不能放入**`signed int`**中。因此，c接收到的值是实现定义的，我们必须知道我们的平台在这种情况下决定做什么。它可能只是重新使用右侧值的位模式，或者终止程序。至于所有实现定义的特性，所选择的解决方案应由您的平台文档化，但请注意，这可能会随着编译器新版本的出现而改变，或者可能由编译器参数切换。
- en: 'For the case of d, the situation is even more complicated: `0`x80000000 has
    the value 2147483648, and we might expect that `-0`x80000000 is just –2147483648\.
    But since effectively `-`0x80000000 is again 2147483648, the same problem arises
    as for c.^([[[Exs 4]](#ch05fn-ex04)])'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 对于d的情况，情况更加复杂：`0`x80000000的值是2147483648，我们可能会预期`-0`x80000000只是-2147483648。但是，由于实际上`-`0x80000000再次是2147483648，因此出现了与c相同的问题。[^([Exs
    4])(#ch05fn-ex04)]
- en: ^([Exs 4])
  id: totrans-805
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-806
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Under the assumption that the maximum value for **`unsigned int`** is 0xFFFFFFFF,
    prove that `-0`x80000000 `== 0`x80000000.
  id: totrans-807
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设**`unsigned int`**的最大值是0xFFFFFFFF，证明`-0`x80000000 `== 0`x80000000。
- en: Then, e is harmless, again. This is because we used a negated decimal literal
    `-2147483648`, which has type **`signed long`** and whose value effectively is
    –2147483648 (shown earlier). Since this value fits into a **`signed int`**, the
    conversion can be done with no problem.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，e再次无害。这是因为我们使用了取反的十进制字面量`-2147483648`，它具有**`signed long`**类型，其值实际上是-2147483648（之前已显示）。由于这个值可以放入**`signed
    int`**中，转换可以无问题地进行。
- en: The last example for g is ambiguous in its consequences. A value that is too
    large for an unsigned type is converted according to the modulus. Here in particular,
    if we assume that the maximum value for **`unsigned short`** is 2^(16) –1, the
    resulting value is 0\. Whether or not such a “narrowing” conversion is the desired
    outcome is often difficult to tell.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: g的最后例子在后果上是不明确的。对于无符号类型来说，值太大时，会根据模数进行转换。这里特别地，如果我们假设**`unsigned short`**的最大值是2^(16)
    –1，那么结果值是0。是否这种“缩小”转换是期望的结果往往很难判断。
- en: '|  |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.30
  id: totrans-811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获5.30
- en: '*Avoid narrowing conversions.*'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免缩小转换。*'
- en: '|  |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.31
  id: totrans-815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获5.31
- en: '*Don’t use narrow types in arithmetic.*'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要在算术中使用窄类型。*'
- en: '|  |'
  id: totrans-817
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The type rules become even more complicated for operators such as addition
    and multiplication that have two operands, because these then may have different
    types. Here are some examples of operations that involve floating-point types:
    Here, the first two examples are harmless: the value of the integer constant `1`
    fits well into the type **`double`** or **`complex`** **`float`**. In fact, for
    most such mixed operations, whenever the range of one type fits into the range
    of the other, the result has the type of the wider range.'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有两个操作数的运算符，如加法和乘法，类型规则变得更加复杂，因为这些运算符可能具有不同的类型。以下是一些涉及浮点类型的操作示例：在这里，前两个例子是无害的：整数常量`1`很好地适合**`double`**或**`complex`**
    **`float`**类型。事实上，对于大多数这样的混合操作，只要一个类型的范围适合另一个类型的范围，结果就有更宽的范围的类型。
- en: '[PRE59]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The next two are problematic because **`INT_MAX`**, the maximal value for **`signed
    int`**, usually will not fit into a **`float`** or **`complex`** **`float`**.
    For example, on my machine, **`INT_MAX`** `+ 0.0`F is the same as **`INT_MAX`**
    `+ 1.0`F and has the value 2147483648\. The last line shows that for an operation
    with **`double`**, this would work fine on most platforms. Nevertheless, on an
    existing or future platform where **`int`** is 64 bit, an analogous problem with
    the precision could occur.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个例子有问题，因为**`INT_MAX`**，即**`signed int`**的最大值，通常不会适合**`float`**或**`complex`**
    **`float`**。例如，在我的机器上，**`INT_MAX`** `+ 0.0`F与**`INT_MAX`** `+ 1.0`F相同，其值为2147483648。最后一行显示，对于**`double`**操作，这在大多数平台上都会正常工作。然而，在一个现有的或未来的平台中，如果**`int`**是64位，可能会出现类似的问题。
- en: 'Because there is no strict inclusion of value ranges for integer types, deducing
    the type of an operation that mixes signed and unsigned values can be nasty:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整数类型的值范围没有严格的包含关系，推导混合有符号和无符号值的操作类型可能会很棘手：
- en: '[PRE60]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first three comparisons are harmless, because even if they mix operands
    of different types, they do not mix signedness. Since for these cases the ranges
    of possible values nicely contain each other, C simply converts the other type
    to the wider one and does the comparison there.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个比较是无害的，因为即使它们混合了不同类型的操作数，它们也没有混合符号。由于这些情况的可能值范围很好地包含彼此，C语言简单地将其转换为更宽的类型并执行比较。
- en: The next two cases are unambiguous, but perhaps not what a naive programmer
    would expect. In fact, for both, all operands are converted to **`unsigned int`**.
    Thus both negated values are converted to large unsigned values, and the result
    of the comparison is **`false`**.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个情况是明确的，但可能不是初学者程序员所期望的。实际上，对于这两个情况，所有操作数都被转换为**`unsigned int`**。因此，所有取反的值都被转换为大的无符号值，比较的结果是**`false`**。
- en: The last two comparisons are even more problematic. On platforms where **`UINT_MAX`**
    ≤ **`LONG_MAX`**, `0`U is converted to `0`L, and thus the first result is **`true`**.
    On other platforms with **`LONG_MAX`** *<* **`UINT_MAX`**, `-1`L is converted
    to `-1`U (that is, **`UINT_MAX`**), and thus the first comparison is **`false`**.
    Analogous observations hold for the second comparison of the last two, but be
    aware that there is a good chance the outcome of the two is not the same.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个比较甚至更加有问题。在**`UINT_MAX`** ≤ **`LONG_MAX`**的平台，`0`U被转换为`0`L，因此第一个结果是**`true`**。在其他**`LONG_MAX`**
    < **`UINT_MAX`**的平台，`-1`L被转换为`-1`U（即**`UINT_MAX`**），因此第一个比较是**`false`**。对于最后两个比较的第二个，也有类似的观察，但请注意，这两个结果可能并不相同。
- en: 'Examples like the last two comparisons can give rise to endless debates in
    favor of or against signed or unsigned types, respectively. But they show only
    one thing: that the semantics of mixing signed and unsigned operands is not always
    clear. There are cases where either possible choice of an implicit conversion
    is problematic.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个比较的例子可能会引发关于有符号或无符号类型的无休止的辩论。但它们只表明了一件事：混合有符号和无符号操作数的语义并不总是清晰的。在某些情况下，隐式转换的任何一种选择都可能有问题。
- en: '|  |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.32
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 5.32
- en: '*Avoid operations with operands of different signedness.*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免使用不同符号位的操作数进行操作。*'
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-831
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.33
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 5.33
- en: '*Use unsigned types whenever you can.*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能使用无符号类型。*'
- en: '|  |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.34
  id: totrans-836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 5.34
- en: '*Chose your arithmetic types such that implicit conversions are harmless.*'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择算术类型，以确保隐式转换是无害的。*'
- en: '|  |'
  id: totrans-838
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.5\. Initializers
  id: totrans-839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 初始化器
- en: 'We have seen ([section 2.3](kindle_split_009.html#ch02lev1sec3)) that the initializer
    is an important part of an object definition. Initializers help us to guarantee
    that a program execution is always in a defined state: that whenever we access
    an object, it has a well-known value that determines the state of the abstract
    machine.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到（[第2.3节](kindle_split_009.html#ch02lev1sec3)），初始化器是对象定义的一个重要部分。初始化器帮助我们保证程序执行始终处于定义状态：即每次我们访问一个对象时，它都有一个已知的值，该值决定了抽象机的状态。
- en: '|  |'
  id: totrans-841
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.35
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 5.35
- en: '*All variables should be initialized.*'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有变量都应该初始化。*'
- en: '|  |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There are only a few exception to that rule: variable-length arrays (VLA);
    see [section 6.1.3](kindle_split_014.html#ch06lev2sec3), which don’t allow for
    an initializer, and code that must be highly optimized. The latter mainly occurs
    in situations that use pointers, so this is not yet relevant to us. For most code
    that we are able to write so far, a modern compiler will be able to trace the
    origin of a value to its last assignment or its initialization. Superfluous initializations
    or assignments will simply be optimized out.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 只有少数例外情况遵循这个规则：变长数组（VLA）；参见[第6.1.3节](kindle_split_014.html#ch06lev2sec3)，它不允许有初始化器，以及必须高度优化的代码。后者主要发生在使用指针的情况下，所以这目前对我们来说还不相关。对于到目前为止我们能写的绝大多数代码，现代编译器都能够追踪到一个值的来源，即它的最后赋值或初始化。多余的初始化或赋值将简单地被优化掉。
- en: 'For scalar types such as integers and floating points, an initializer just
    contains an expression that can be converted to that type. We have seen a lot
    of examples of that. Optionally, such an initializer expression may be surrounded
    with `{}`. Here are some examples:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数和浮点数这样的标量类型，初始化器只包含可以转换为该类型的表达式。我们已经看到了很多这样的例子。这样的初始化器表达式可以可选地被 `{}` 包围。以下是一些例子：
- en: '[PRE61]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Initializers for other types *must* have these `{}`. For example, array initializers
    contain initializers for the different elements, each of which is followed by
    a comma:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的初始化器*必须*有这些 `{}`。例如，数组初始化器包含不同元素的初始化器，每个初始化器后面都跟着一个逗号：
- en: '[PRE62]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![](pg_064_alt.jpg)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_064_alt.jpg)'
- en: 'As we have seen, arrays that have an *incomplete type**^C* because there is
    no length specification are completed by the initializer to fully specify the
    length. Here, A has only one element, whereas C has four. For the first two initializers,
    the element to which the scalar initialization applies is deduced from the position
    of the scalar in the list: for example, B`[1]` is initialized to `7`. Designated
    initializers as for C are by far preferable, since they make the code more robust
    against small changes in declarations.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，由于没有长度指定，具有*不完整类型**^C*的数组通过初始化器来完成，以完全指定长度。在这里，A只有一个元素，而C有四个。对于前两个初始化器，应用于标量的初始化元素是从标量在列表中的位置推断出来的：例如，B`[1]`被初始化为`7`。对于C这样的指定初始化器来说，它们无疑是首选的，因为它们使代码对声明中的微小变化更具鲁棒性。
- en: '|  |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.36
  id: totrans-853
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 5.36
- en: '*Use designated initializers for all aggregate data types.*'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于所有聚合数据类型，使用指定初始化器。*'
- en: '|  |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you don’t know how to initialize a variable of type T, the *default initializer**^C*T
    a `= {0}` will almost^([[6](#ch05fn06)]) always do.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道如何初始化类型为T的变量，则*默认初始化器**^C*T `a = {0}`几乎总是可以做到的。
- en: ⁶
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The exceptions are variable-length arrays; see [section 6.1.3](kindle_split_014.html#ch06lev2sec3).
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例外的是变长数组；参见[第6.1.3节](kindle_split_014.html#ch06lev2sec3)。
- en: '|  |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.37
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 5.37
- en: '*`{0}`* *is a valid initializer for all object types that are not VLA.*'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '*`{0}`* *是所有非VLA对象类型的有效初始化器。*'
- en: '|  |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Several things ensure that this works. First, if we omit the designation (the
    .membername for **`struct`** [see [section 6.3](kindle_split_014.html#ch06lev1sec3)]
    or `[`n`]` for arrays [see [section 6.1](kindle_split_014.html#ch06lev1sec1)])
    initialization is just done in *declaration order**^C*: that is, the `0` in the
    default initializer designates the very first member that is declared, and all
    other members are then initialized by default to `0` as well. Then, the `{}` form
    of initializers for scalars ensures that `{ 0 }` is also valid for them.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 几件事情确保了这一点。首先，如果我们省略了指定（对于 **`struct`** 的 `.membername` [参见 [第 6.3 节](kindle_split_014.html#ch06lev1sec3)]
    或数组的 `[`n`]` [参见 [第 6.1 节](kindle_split_014.html#ch06lev1sec1)]），初始化就只是按照 *声明顺序*
    完成^C：也就是说，默认初始化器中的 `0` 指的是声明的第一个成员，然后所有其他成员默认初始化为 `0`。然后，标量初始化器的 `{}` 形式确保 `{
    0 }` 对它们也是有效的。
- en: 'Maybe your compiler warns you about this: annoyingly, some compiler implementers
    don’t know about this special rule. It is explicitly designed as a catch-all initializer
    in the C standard, so this is one of the rare cases where I would switch off a
    compiler warning.'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的编译器会警告你关于这一点：令人烦恼的是，一些编译器实现者不知道这个特殊规则。它是作为 C 标准中的通用初始化器而明确设计的，因此这是少数几个我会关闭编译器警告的情况之一。
- en: In initializers, we often have to specify values that have a particular meaning
    for the program.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器中，我们通常必须指定对程序有特定意义的值。
- en: 5.6\. Named constants
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6. 命名常量
- en: 'A common issue even in small programs is that they use special values for some
    purposes that are textually repeated all over. If for one reason or another this
    value changes, the program falls apart. Take an artificial setting as an example
    where we have arrays of strings,^([[7](#ch05fn07)]) on which we would like to
    perform some operations:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在小程序中，一个常见的问题是它们使用特殊值来完成某些目的，这些值在文本中被重复使用。如果由于某种原因这个值发生变化，程序就会崩溃。以下是一个人工设置的例子，其中我们有一些字符串数组，^([[7](#ch05fn07)])，我们想在它们上执行一些操作：
- en: ⁷
  id: totrans-869
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This uses a *pointer*, type **`char const`**`*`**`const`**, to refer to strings.
    We will see later how this particular technique works.
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使用了一个 *指针*，类型 **`char const`**`*`**`const`**，来引用字符串。我们稍后会看到这种特定技术是如何工作的。
- en: Here we use the constant `3` in several places, and with three different “meanings”
    that are not very correlated. For example, an addition to our set of corvids would
    require two separate code changes. In a real setting, there might be many more
    places in the code that depend on this particular value, and in a large code base
    this can be very tedious to maintain.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在几个地方使用了常量 `3`，并且具有三种不同的“意义”，这些意义之间关联性不大。例如，向我们的松鸦集合添加一个新成员将需要两次单独的代码更改。在实际设置中，代码中可能还有许多其他地方依赖于这个特定的值，在一个大型代码库中，这可能非常难以维护。
- en: '|  |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.38
  id: totrans-874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.38 总结
- en: '*All constants with a particular meaning must be named.*'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有具有特定意义的常量都必须命名。*'
- en: '|  |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It is equally important to distinguish constants that are equal, but for which
    equality is just a coincidence.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 区分相等但相等只是巧合的常量同样重要。
- en: '|  |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.39
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.39 总结
- en: '*All constants with different meanings must be distinguished.*'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有具有不同意义的常量都必须区分开来。*'
- en: '|  |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'C has surprisingly little means to specify named constants, and its terminology
    even causes a lot of confusion about which constructs effectively lead to compile-time
    constants. So we first have to get the terminology straight ([section 5.6.1](#ch05lev2sec6))
    before we look into the only proper named constants that C provides: enumeration
    constants ([section 5.6.2](#ch05lev2sec7)). The latter will help us to replace
    the different versions of `3` in our example with something more explanatory.
    A'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言在指定命名常量方面出奇地少，其术语甚至导致了对哪些构造有效导致编译时常量的很多混淆。因此，在我们深入研究 C 语言提供的唯一合适的命名常量：枚举常量（[第
    5.6.2 节](#ch05lev2sec7)）之前，我们首先必须弄清楚这些术语（[第 5.6.1 节](#ch05lev2sec6)）。后者将帮助我们用更具有说明性的内容替换示例中
    `3` 的不同版本。
- en: '[PRE63]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'second, generic, mechanism complements this feature with simple text replacement:
    macros ([section 5.6.3](#ch05lev2sec8)). Macros only lead to compile-time constants
    if their replacements are composed of literals of base types, as we have seen.
    If we want to provide something close to the concept of constants for more-complicated
    data types, we have to provide them as temporary objects ([section 5.6.4](#ch05lev2sec9)).'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通用的机制通过简单的文本替换：宏（[第 5.6.3 节](#ch05lev2sec8)）来补充这个特性。如果它们的替换由基本类型的字面量组成，就像我们看到的，宏只会导致编译时常量。如果我们想为更复杂的数据类型提供类似于常量的概念，我们必须将它们作为临时对象提供（[第
    5.6.4 节](#ch05lev2sec9)）。
- en: 5.6.1\. Read-only objects
  id: totrans-885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1\. 只读对象
- en: 'Don’t confuse the term *constant*, which has a very specific meaning in C,
    with objects that can’t be modified. For example, in the previous code, bird,
    pronoun, and ordinal are not constants according to our terminology; they are
    **`const`**-qualified objects. This *qualifier**^C* specifies that we don’t have
    the right to change this object. For bird, neither the array entries nor the actual
    strings can be modified, and your compiler should give you a diagnostic if you
    try to do so:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将术语*常量*与C语言中具有非常特定意义的对象混淆。例如，在之前的代码中，bird、pronoun和ordinal根据我们的术语不是常量；它们是**`const`**-限定对象。这个*限定符**^C*指定我们没有权利更改此对象。对于bird，数组的条目以及实际的字符串都不能修改，如果你尝试这样做，你的编译器应该会给出诊断：
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.40
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要5.40
- en: '*An object of* **`const`***-qualified type is read-only.*'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有**`const`***-限定类型的对象是只读的。*'
- en: '|  |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'That doesn’t mean the compiler or run-time system may not perhaps change the
    value of such an object: other parts of the program may see that object without
    the qualification and change it. The fact that you cannot write the summary of
    your bank account directly (but only read it) doesn’t mean it will remain constant
    over time.'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着编译器或运行时系统可能不会更改此类对象的值：程序的其他部分可能看到没有限定符的对象并更改它。你不能直接编写你的银行账户摘要（但只能读取它），并不意味着它将随着时间的推移保持不变。
- en: 'There is another family of read-only objects that unfortunately are not protected
    by their type from being modified: string literals.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一类只读对象，遗憾的是，它们的类型并不能保护它们不被修改：字符串字面量。
- en: '![](comm.jpg)'
  id: totrans-893
  prefs: []
  type: TYPE_IMG
  zh: '![图片](comm.jpg)'
- en: '|  |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.41
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要5.41
- en: '*String literals are read-only.*'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串字面量是只读的。*'
- en: '|  |'
  id: totrans-897
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If introduced today, the type of string literals would certainly be **`char
    const`**`[]`, an array of **`const`**-qualified characters. Unfortunately, the
    **`const`** keyword was introduced to the C language much later than string literals,
    and therefore it remained as it is for backward compatibility.^([[8](#ch05fn08)])
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果今天引入，字符串字面量的类型肯定会是**`char const`**`[]`，一个**`const`**-限定字符数组。不幸的是，**`const`**关键字是在字符串字面量之后被引入到C语言的，因此为了向后兼容，它保持原样.^([[8](#ch05fn08)])
- en: ⁸
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A third class of read-only objects exist: temporary objects. We will see them
    later, in [section 13.2.2](kindle_split_023.html#ch13lev2sec4).'
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 存在第三类只读对象：临时对象。我们将在[第13.2.2节](kindle_split_023.html#ch13lev2sec4)中看到它们。
- en: 'Arrays such as bird also use another technique to handle string literals. They
    use a *pointer**^C* type, **`char const`**`*`**`const`**, to “refer” to a string
    literal. A visualization of such an array looks like this:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 数组如bird也使用另一种技术来处理字符串字面量。它们使用一种*指针**^C*类型，**`char const`**`*`**`const`**，来“引用”字符串字面量。此类数组的可视化如下：
- en: '![](pg_067-01_alt.jpg)'
  id: totrans-903
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_067-01_alt.jpg)'
- en: That is, the string literals themselves are not stored inside the array bird
    but in some other place, and bird only refers to those places. We will see much
    later, in [section 6.2](kindle_split_014.html#ch06lev1sec2) and [chapter 11](kindle_split_021.html#ch11),
    how this mechanism works.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，字符串字面量本身并没有存储在数组bird中，而是在其他某个地方，而bird只是引用了那些地方。我们将在[第6.2节](kindle_split_014.html#ch06lev1sec2)和[第11章](kindle_split_021.html#ch11)中更晚些时候看到这个机制是如何工作的。
- en: 5.6.2\. Enumerations
  id: totrans-905
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2\. 枚举
- en: 'C has a simple mechanism to name small integers as we needed them in the example,
    called *enumerations**^C*:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: C语言有一个简单的机制来命名我们需要的整数，称为*枚举**^C*：
- en: '[PRE64]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This declares a new integer type **`enum`** corvid for which we know four different
    values.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个新的整数类型**`enum`** corvid，我们已知其四个不同的值。
- en: '|  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.42
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要5.42
- en: '*Enumeration constants have either an explicit or a positional value.*'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举常量具有显式或位置值。*'
- en: '|  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As you might have guessed, positional values start from `0` onward, so in our
    example we have raven with value 0, magpie with 1, jay with 2, and corvid_num
    with 3\. This last 3 is obviously the 3 we are interested in.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，位置值从`0`开始，因此在我们这个例子中，乌鸦的值为0，喜鹊为1，乌鸫为2，corvid_num为3。这个最后的3显然是我们感兴趣的3。
- en: '![](pg_067-02_alt.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_067-02_alt.jpg)'
- en: 'Notice that this uses a different order for the array entries than before,
    and this is one of the advantages of the approach with enumerations: we do not
    have to manually track the order we used in the array. The ordering that is fixed
    in the enumeration type does that automatically.'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这使用了与之前不同的数组条目顺序，这是使用枚举方法的一个优点：我们不需要手动跟踪数组中使用的顺序。枚举类型中固定的顺序会自动完成这项工作。
- en: 'Now, if we want to add another corvid, we just put it in the list, anywhere
    before corvid_num:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想添加另一个corvid，我们只需将其放入列表中，在任何地方在corvid_num之前：
- en: Listing 5.1\. An enumeratin type and related array of strings
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 枚举类型和相关字符串数组
- en: '[PRE65]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As for most other narrow types, there is not really much interest in declaring
    variables of an enumeration type; for indexing and arithmetic, they would be converted
    to a wider integer, anyhow. Even the enumeration constants themselves aren’t of
    the enumeration type:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数其他窄类型，实际上对声明枚举类型的变量并不感兴趣；对于索引和算术运算，它们无论如何都会转换为更宽的整数。甚至枚举常量本身也不是枚举类型：
- en: '|  |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.43
  id: totrans-921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.43
- en: '*Enumeration constants are of type* **`signed int`***.*'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举常量是* **`signed int`***.* 类型。'
- en: '|  |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'So the interest really lies in the constants, not in the newly created type.
    We can thus name any **`signed int`** constant that we need, without even providing
    a *tag**^C* for the type name:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，真正的兴趣在于常数，而不是新创建的类型。因此，我们可以为所需的任何**`signed int`**常量命名，甚至不需要为类型名提供*标签*^C：
- en: '[PRE66]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To define these constants, we can use *integer constant expressions**^C* (*ICE*).
    Such an ICE provides a compile-time integer value and is much restricted. Not
    only must its value be determinable at compile time (no function call allowed),
    but also no evaluation of an object must participate as an operand to the value:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义这些常数，我们可以使用*整数常量表达式（ICE）*^C (*ICE*). 这种ICE提供了一个编译时的整数值，并且受到很多限制。不仅其值必须在编译时确定（不允许函数调用），而且没有任何对象的评估必须作为值的一个操作数参与：
- en: '[PRE67]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, o42 is an object, **`const`**-qualified but still, so the expression for
    c52 is not an “integer constant expression.”
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，o42是一个对象，**`const`**-修饰的，但仍然，所以c52的表达式不是一个“整数常量表达式。”
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.44
  id: totrans-930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.44
- en: '*An integer constant expression doesn’t evaluate any object.*'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数常量表达式不评估任何对象*。'
- en: '|  |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So, principally, an ICE may consist of any operations with integer literals,
    enumeration constants, **`_Alignof`** and **`offsetof`** subexpressions, and eventually
    some **`sizeof`** subexpressions.^([[9](#ch05fn09)])
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原则上，一个ICE可以由任何整数文字、枚举常量、**`_Alignof`**和**`offsetof`**子表达式以及最终的一些**`sizeof`**子表达式组成.^([[9](#ch05fn09)])
- en: ⁹
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will handle the latter two concepts in [sections 12.7](kindle_split_022.html#ch12lev1sec7)
    and [12.1](kindle_split_022.html#ch12lev1sec1).
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在[第12.7节](kindle_split_022.html#ch12lev1sec7)和[第12.1节](kindle_split_022.html#ch12lev1sec1)中处理这两个概念。
- en: Still, even when the value is an ICE, to be able to use it to define an enumeration
    constant, you have to ensure that the value fits into a **`signed`**.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 即使值是一个ICE，为了能够用它来定义枚举常量，你必须确保该值适合于一个**`signed`**。
- en: 5.6.3\. Macros
  id: totrans-938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.3\. 宏定义
- en: 'Unfortunately, there is no other mechanism to declare constants of other types
    than **`signed int`** in the strict sense of the C language. Instead, C proposes
    another powerful mechanism that introduces textual replacement of the program
    code: *macros**^C*. A macro is introduced by a *preprocessor**^C* **`#define`**:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在C语言的严格意义上，没有其他机制可以声明除了**`signed int`**之外的其他类型的常数。相反，C语言提出了另一种强大的机制，它引入了程序代码的文本替换：*宏*^C*.
    宏是通过*预处理器*^C* **`#define`** 引入的：
- en: '[PRE68]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This macro definition has the effect that the identifier M_PI is replaced in
    the following program code by the **`double`** constant. Such a macro definition
    consists of five different parts:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏定义的效果是在以下程序代码中将标识符M_PI替换为**`double`**常量。这样的宏定义由五个不同的部分组成：
- en: A starting **`#`** character that must be the first non-blank character on the
    line
  id: totrans-942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行首的**`#`**字符，必须是行上的第一个非空白字符。
- en: The keyword **`define`**
  id: totrans-943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键字 **`define`**
- en: An identifier that is to be declared, here M_PI
  id: totrans-944
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要声明的标识符，这里为M_PI
- en: The replacement text, here `3.14159265358979323846`
  id: totrans-945
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换文本，这里为`3.14159265358979323846`
- en: A terminating newline character
  id: totrans-946
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个终止的换行符
- en: 'With this trick, we can declare textual replacement for constants of **`unsigned`**,
    **`size_t`**, and **`double`**. In fact, the implementation-imposed bound of **`size_t`**,
    **`SIZE_MAX`**, is defined, as well as many of the other system features we have
    already seen: **`EXIT_SUCCESS`**, **`false`**, **`true`**, **`not_eq`**, bool,
    **`complex`** . . . In the color electronic versions of this book, such C standard
    macros are all printed in **`dark red`**.'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个技巧，我们可以为**`unsigned`**、**`size_t`**和**`double`**的常量声明文本替换。实际上，**`size_t`**的实现限制**`SIZE_MAX`**被定义，以及其他我们已经看到的许多系统特性：**`EXIT_SUCCESS`**、**`false`**、**`true`**、**`not_eq`**、bool、**`complex`**
    等。在本书的彩色电子版中，这些C标准宏都打印为**`暗红色`**。
- en: The spelling of these examples from the C standard is not representative for
    the conventions that are generally used in a large majority of software projects.
    Most of them have quite restrictive rules such that macros visually stick out
    from their surroundings.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子来自C标准的拼写并不代表在大多数软件项目中普遍使用的约定。大多数项目都有相当严格的规则，使得宏在视觉上与其周围内容区分开来。
- en: '|  |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.45
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.45
- en: '*Macro names are in all caps.*'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏名全部大写。*'
- en: '|  |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Only deviate from that rule if you have good reasons, in particular not before
    you reach [level 3](kindle_split_025.html#part03).
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你有充分的理由时才偏离该规则，特别是在达到[第3级](kindle_split_025.html#part03)之前。
- en: 5.6.4\. Compound literals
  id: totrans-954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.4\. 复合字面量
- en: For types that don’t have literals that describe their constants, things get
    even more complicated. We have to use *compound literals**^C* on the replacement
    side of the macro. Such a compound literal has the form
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有描述其常量的类型，事情变得更加复杂。我们必须在宏的替换侧使用*复合字面量**^C*。这种复合字面量的形式是
- en: '[PRE69]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'That is, a type, in parentheses, followed by an initializer. Here’s an example:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 即，一个类型，后面跟一个初始化器。以下是一个示例：
- en: '[PRE70]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'With that, we could leave out the bird array and rewrite our **`for`** loop:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以省略鸟数组并重写我们的**`for`**循环：
- en: '[PRE71]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Whereas compound literals in macro definitions can help us to declare something
    that behaves similarly to a constant of a chosen type, it isn’t a constant in
    the narrow sense of C.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 而在宏定义中的复合字面量可以帮助我们声明类似于所选类型常量的东西，但这并不是C的狭义意义上的常量。
- en: '|  |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.46
  id: totrans-963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.46
- en: '*A compound literal defines an object.*'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合字面量定义了一个对象。*'
- en: '|  |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Overall, this form of macro has some pitfalls:'
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体而言，这种形式的宏有一些陷阱：
- en: Compound literals aren’t suitable for ICE.
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合字面量不适合用于ICE。
- en: For our purpose here, to declare named constants, the type T should be **`const-`***qualified**^C*.
    This ensures that the optimizer has a bit more slack to generate good binary code
    for such a macro replacement.
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们这里的目的，为了声明命名常量，类型T应该是**`const-`***限定**^C*。这确保了优化器有更多余地来生成这样的宏替换的良好二进制代码。
- en: There *must* be space between the macro name and the `()` of the compound literal,
    here indicated by the **`/`****`**`****`/`** comment. Otherwise, this would be
    interpreted as the start of a definition of a *function-like macro*. We will see
    these much later.
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏名和复合字面量的`()`之间必须有空格，这里用**`/`****`****`/`**注释表示。否则，这将被解释为*函数式宏*定义的开始。我们将在稍后看到这些。
- en: A backspace character `\` at the *very end* of the line can be used to continue
    the macro definition to the next line.
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行尾的退格字符`\`可以用来将宏定义延续到下一行。
- en: There must be no `;` at the end of the macro definition. Remember, it is all
    just text replacement.
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏定义的末尾绝对不能有`;`。记住，这只是一次文本替换。
- en: '|  |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.47
  id: totrans-973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.47
- en: '*Don’t hide a terminating semicolon inside a macro.*'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要在宏内部隐藏一个终止的分号。*'
- en: '|  |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Also, for readability of macros, please pity the poor occasional reader of
    your code:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了宏的可读性，请同情一下你代码中偶尔的读者：
- en: '|  |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.48
  id: totrans-978
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.48
- en: '*Right-indent continuation markers for macros to the same column.*'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏的续行标记应右缩进到同一列。*'
- en: '|  |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As you can see in the example, this helps to visualize the entire spread of
    the macro definition easily.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例中看到的，这有助于轻松可视化宏定义的整个范围。
- en: 5.7\. Binary representions
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7\. 二进制表示
- en: The *binary representation* of a type is a *model* that describes the possible
    values for that type. It is not the same as the in-memory *object representation*
    that describes the more or less physical storage of values of a given type.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型的*二进制表示*是一个*模型*，它描述了该类型可能具有的值。它不同于描述给定类型值的内存*对象表示*。
- en: '|  |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.49
  id: totrans-985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.49
- en: '*The same value may have different binary representations.*'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '*相同的值可能有不同的二进制表示。*'
- en: '|  |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.7.1\. Unsigned integers
  id: totrans-988
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.1\. 无符号整数
- en: 'We have seen that unsigned integer types are those arithmetic types for which
    the standard arithmetic operations have a nice, closed mathematical description.
    They are closed under arithmetic operations:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，无符号整数类型是那些具有标准算术运算的优美、封闭数学描述的算术类型。它们在算术运算下是封闭的：
- en: '|  |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.50
  id: totrans-991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.50
- en: '*Unsigned arithmetic wraps nicely.*'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号算术运算可以很好地进行环绕。*'
- en: '|  |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In mathematical terms, they implement a *ring*, ![](zopf.jpg)*[N]*, the set
    of integers modulo some number *N*. The values that are representable are 0*,
    . . . , N* – 1\. The maximum value *N* – 1 completely determines such an unsigned
    integer type and is made available through a macro with terminating **`_MAX`**
    in the name. For the basic unsigned integer types, these are **`UINT_MAX`**, **`ULONG_MAX`**,
    and **`ULLONG_MAX`**, and they are provided through `limits.h`. As we have seen,
    the one for **`size_t`** is **`SIZE_MAX`** from `stdint.h`.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学术语中，它们实现了一个 *环*，![](zopf.jpg)*[N]*，即模某个数 *N* 的整数集。可表示的值是 0*, . . . , N* –
    1\. 最大值 *N* – 1 完全决定了这样的无符号整数类型，并通过名称中带有终止符 **`_MAX`** 的宏提供。对于基本的无符号整数类型，这些是 **`UINT_MAX`**，**`ULONG_MAX`**，和
    **`ULLONG_MAX`**，它们通过 `limits.h` 提供。正如我们所见，**`size_t`** 的值来自 `stdint.h` 的 **`SIZE_MAX`**。
- en: '|  |'
  id: totrans-995
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<limits.h>`'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '`<limits.h>`'
- en: '`<stdint.h>`'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdint.h>`'
- en: '|  |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The binary representation for non-negative integer values is always exactly
    what the term indicates: such a number is represented by binary digits *b*[0]*,
    b*[1]*. . . , b**[p–1]* called *bits**^C*. Each of the bits has a value of 0 or
    1\. The value of such a number is computed as'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 非负整数值的二进制表示总是如术语所示：这样的数由二进制位 *b*[0]*, b*[1]*. . . , b**[p–1]* 称为 *位**^C* 表示。每个位都有
    0 或 1 的值。这样的数的值是通过以下方式计算的
- en: equation 5.1\.
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 5.1\.
- en: '![](pg_71-1.jpg)'
  id: totrans-1001
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_71-1.jpg)'
- en: The value *p* in that binary representation is called the *precision**^C* of
    the underlying type. Bit *b*[0] is called the *least-significant bit**^C*, and
    *LSB*, *b**[p–1]* is the *most-significant bit**^C* (*MSB*).
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个二进制表示中，值 *p* 被称为基础类型的 *精度**^C*。位 *b*[0] 被称为 *最低有效位**^C*，即 *LSB*，*b**[p–1]*
    是 *最高有效位**^C* (*MSB*).
- en: Of the bits *b**[i]* that are 1, the one with minimal index *i* is called the
    *least-significant bit set**^C*, and the one with the highest index is the *most-significant
    bit set**^C*. For example, for an unsigned type with *p* = 16, the value `240`
    would have *b*[4] = 1, *b*[5] = 1, *b*[6] = 1, and *b*[7] = 1\. All other bits
    of the binary representation are 0, the least-significant bit set *i* is *b*[4],
    and the most-significant bit set is *b*[7]. From (5.1), we see immediately that
    2*^p* is the first value that cannot be represented with the type. Thus *N* =
    2*^p* and
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *b**[i]* 位中，值为 1 的位中，具有最小索引 *i* 的位被称为 *最低有效位设置**^C*，而具有最高索引的位是 *最高有效位设置**^C*。例如，对于
    *p* = 16 的无符号类型，值 `240` 将有 *b*[4] = 1，*b*[5] = 1，*b*[6] = 1，和 *b*[7] = 1\. 所有其他二进制表示的位都是
    0，最低有效位设置 *i* 是 *b*[4]，最高有效位设置是 *b*[7]。从 (5.1) 我们可以立即看出，2*^p* 是第一个不能用该类型表示的值。因此
    *N* = 2*^p* 和
- en: '|  |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.51
  id: totrans-1005
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得 5.51
- en: '*The maximum value of any integer type is of the form* 2*^p* – 1.'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何整数类型的最值形式为* 2*^p* – 1。'
- en: '|  |'
  id: totrans-1007
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Observe that for this discussion of the representation of non-negative values,
    we haven’t argued about the signedness of the type. These rules apply equally
    to signed and unsigned types. Only for unsigned types, we are lucky, and what
    we have said so far completely suffices to describe such an unsigned type.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于非负值表示的讨论，我们没有争论类型的符号。这些规则同样适用于有符号和无符号类型。只有对于无符号类型，我们很幸运，我们之前所说的已经完全足够描述这样的无符号类型。
- en: '|  |'
  id: totrans-1009
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.52
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得 5.52
- en: '*Arithmetic on an unsigned integer type is determined by its precision.*'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号整数类型的算术运算由其精度决定*。'
- en: '|  |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Finally, [table 5.4](#ch05table04) shows the bounds of some of the commonly
    used scalars throughout this book.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[表 5.4](#ch05table04) 展示了本书中一些常用标量的界限。
- en: Table 5.4\. Bounds for scalar types used in this book
  id: totrans-1014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.4\. 本书使用的标量类型的界限
- en: '| Name | [min, max] | Where | Typical |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | [最小值，最大值] | 位置 | 典型值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **size_t** | [0, **SIZE_MAX**] | <stdint.h> | [0*,* 2*^w* –1], *w* = 32,
    64 |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
  zh: '| **size_t** | [0, **SIZE_MAX**] | <stdint.h> | [0*,* 2*^w* –1], *w* = 32,
    64 |'
- en: '| **double** | [±**DBL_MIN**, ±**DBL_MAX**] | <**float**.h> | [±2*^(–w–2)**,*±2*^w*],
    *w* = 1024 |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '| **double** | [±**DBL_MIN**, ±**DBL_MAX**] | <**float**.h> | [±2*^(–w–2)**,*±2*^w*],
    *w* = 1024 |'
- en: '| **signed** | [**INT_MIN**, **INT_MAX**] | <limits.h> | [–2*^w**,* 2*^w* –1],
    *w* = 31 |'
  id: totrans-1019
  prefs: []
  type: TYPE_TB
  zh: '| **signed** | [**INT_MIN**, **INT_MAX**] | <limits.h> | [–2*^w**,* 2*^w* –1],
    *w* = 31 |'
- en: '| **unsigned** | [0, **UINT_MAX**] | <limits.h> | [0*,* 2*^w* –1], *w* = 32
    |'
  id: totrans-1020
  prefs: []
  type: TYPE_TB
  zh: '| **unsigned** | [0, **UINT_MAX**] | <limits.h> | [0*,* 2*^w* –1], *w* = 32
    |'
- en: '| bool | [**false**, **true**] | <stdbool.h> | [0*,* 1] |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '| bool | [**false**, **true**] | <stdbool.h> | [0*,* 1] |'
- en: '| **ptrdiff_t** | [**PTRDIFF_MIN**, **PTRDIFF_MAX**] | <stdint.h> | [–2*^w**,*
    2*^w* –1], *w* = 31*,* 63 |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
  zh: '| **ptrdiff_t** | [**PTRDIFF_MIN**, **PTRDIFF_MAX**] | <stdint.h> | [–2*^w**,*
    2*^w* –1], *w* = 31*,* 63 |'
- en: '| **char** | [**CHAR_MIN**, **CHAR_MAX**] | <limits.h> | [0*,* 2*^w* –1], *w*
    = 7, 8 |'
  id: totrans-1023
  prefs: []
  type: TYPE_TB
  zh: '| **char** | [**CHAR_MIN**, **CHAR_MAX**] | <limits.h> | [0*,* 2*^w* –1], *w*
    = 7, 8 |'
- en: '| **unsigned char** | [0, **UCHAR_MAX** ] | <limits.h> | [0, 255] |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '| **unsigned char** | [0, **UCHAR_MAX** ] | <limits.h> | [0, 255] |'
- en: 5.7.2\. Bit sets and bitwise operators
  id: totrans-1025
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.2\. 位集和位运算符
- en: 'This simple binary representation of unsigned types allows us to use them for
    another purpose that is not directly related to arithmetic: as bit sets. A bit
    set is a different interpretation of an unsigned value, where we assume that it
    represents a subset of the base set *V* = {0*, . . . , p*–1} and where we take
    element *i* to be a member of the set, if the bit *b**[i]* is present.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 这种无符号类型的简单二进制表示使我们能够将其用于与算术无关的另一个目的：作为位集。位集是对无符号值的不同解释，我们假设它表示基础集 *V* = {0*,
    . . . , p*–1} 的子集，并且如果位 *b**[i]* 存在，则元素 *i* 是集合的成员。
- en: 'There are three binary operators that operate on bit sets: *`|`*, *`&`*, and
    *`^`*. They represent the *set union* *A* *∪* *B*, *set intersection* *A* *∩*
    *B*, and *symmetric difference* *A*Δ*B*, respectively.'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个二元运算符作用于位集：*`|`*，*`&`* 和 *`^`*。它们分别代表 *集合并* *A* *∪* *B*，*集合交* *A* *∩* *B*，和
    *对称差* *A*Δ*B*。
- en: Table 5.5\. Effects of bitwise operators
  id: totrans-1028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.5\. 位运算符的效果
- en: '| Bit op | Value | Hex | *b*[15] | ... | *b*[0] | Set op | Set |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '| Bit op | Value | Hex | *b*[15] | ... | *b*[0] | Set op | Set |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-1030
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| V | 65535 | 0xFFFF | 1111111111111111 |   | {0*,* 1*,* 2*,* 3*,* 4*,* 5*,*
    6*,* 7*,* 8*,* 9*,* 10*,* 11*,* 12*,* 13*,* 14*,* 15} |'
  id: totrans-1031
  prefs: []
  type: TYPE_TB
  zh: '| V | 65535 | 0xFFFF | 1111111111111111 |   | {0*,* 1*,* 2*,* 3*,* 4*,* 5*,*
    6*,* 7*,* 8*,* 9*,* 10*,* 11*,* 12*,* 13*,* 14*,* 15} |'
- en: '| A | 240 | 0x00F0 | 0000000011110000 |   | {4*,* 5*,* 6*,* 7} |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '| A | 240 | 0x00F0 | 0000000011110000 |   | {4*,* 5*,* 6*,* 7} |'
- en: '| ~A | 65295 | 0xFF0F | 1111111100001111 | *V* *\* *A* | {0*,* 1*,* 2*,* 3*,*
    8*,* 9*,* 10*,* 11*,* 12*,* 13*,* 14*,* 15} |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '| ~A | 65295 | 0xFF0F | 1111111100001111 | *V* *\* *A* | {0*,* 1*,* 2*,* 3*,*
    8*,* 9*,* 10*,* 11*,* 12*,* 13*,* 14*,* 15} |'
- en: '| -A | 65296 | 0xFF10 | 1111111100010000 |   | {4*,* 8*,* 9*,* 10*,* 11*,*
    12*,* 13*,* 14*,* 15} |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '| -A | 65296 | 0xFF10 | 1111111100010000 |   | {4*,* 8*,* 9*,* 10*,* 11*,*
    12*,* 13*,* 14*,* 15} |'
- en: '| B | 287 | 0x011F | 0000000100011111 |   | {0*,* 1*,* 2*,* 3*,* 4*,* 8} |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
  zh: '| B | 287 | 0x011F | 0000000100011111 |   | {0*,* 1*,* 2*,* 3*,* 4*,* 8} |'
- en: '| A&#124;B | 511 | 0x01FF | 0000000111111111 | *A* *∪* *B* | {0*,* 1*,* 2*,*
    3*,* 4*,* 5*,* 6*,* 7*,* 8} |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '| A&#124;B | 511 | 0x01FF | 0000000111111111 | *A* *∪* *B* | {0*,* 1*,* 2*,*
    3*,* 4*,* 5*,* 6*,* 7*,* 8} |'
- en: '| A&B | 16 | 0x0010 | 0000000000010000 | *A* *∩* *B* | {4} |'
  id: totrans-1037
  prefs: []
  type: TYPE_TB
  zh: '| A&B | 16 | 0x0010 | 0000000000010000 | *A* *∩* *B* | {4} |'
- en: '| A^B | 495 | 0x01EF | 0000000111101111 | *A*Δ*B* | {0*,* 1*,* 2*,* 3*,* 5*,*
    6*,* 7*,* 8} |'
  id: totrans-1038
  prefs: []
  type: TYPE_TB
  zh: '| A^B | 495 | 0x01EF | 0000000111101111 | *A*Δ*B* | {0*,* 1*,* 2*,* 3*,* 5*,*
    6*,* 7*,* 8} |'
- en: For an example, let us choose *A* = 240, representing {4, 5, 6, 7}, and *B*
    = 287, the bit set {0, 1, 2, 3, 4, 8}; see [table 5.5](#ch05table05). For the
    result of these operations, the total size of the base set, and thus the precision
    *p*, is not needed. As for the arithmetic operators, there are corresponding assignment
    operators *`&=`*, *`|=`*, and *`^=`*, respectively.^([[[Exs 5]](#ch05fn-ex05)])^([[[Exs
    6]](#ch05fn-ex06)])^([[[Exs 7]](#ch05fn-ex07)])^([[[Exs 8]](#ch05fn-ex08)])
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们选择 *A* = 240，代表集合 {4, 5, 6, 7}，以及 *B* = 287，位集 {0, 1, 2, 3, 4, 8}；参见 [表
    5.5](#ch05table05)。对于这些操作的结果，基础集的总大小以及因此的精度 *p* 不需要。至于算术运算符，有相应的赋值运算符 *`&=`*，*`|=`*
    和 *`^=`*。^([[[Exs 5]](#ch05fn-ex05)])^([[[Exs 6]](#ch05fn-ex06)])^([[[Exs 7]](#ch05fn-ex07)])^([[[Exs
    8]](#ch05fn-ex08)])
- en: ^([Exs 5])
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 5])
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that *A* *\* *B* can be computed by A `-` (A&B`)`.
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 *A* *\* *B* 可以通过 A `-` (A&B`)` 来计算。
- en: ^([Exs 6])
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 6])
- en: ''
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that V `+ 1` is 0.
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 V `+ 1` 等于 0。
- en: ^([Exs 7])
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 7])
- en: ''
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that A`^`B is equivalent to `(`A `- (`A`&`B`)) + (`B `- (`A`&`B`))` and
    A `+` B `- 2*(`A`&`B`)`.
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 A`^`B 等价于 `(`A `- (`A`&`B`)) + (`B `- (`A`&`B`))` 和 A `+` B `- 2*(`A`&`B`)`.
- en: ^([Exs 8])
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 8])
- en: ''
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that A`|`B is equivalent to A `+` B `- (`A`&`B`)`.
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 A`|`B 等价于 A `+` B `- (`A`&`B`)`.
- en: 'There is yet another operator that operates on the bits of the value: the complement
    operator *`~`*. The complement ~A would have value 65295 and would correspond
    to the set {0, 1, 2, 3, 8, 9, 10, 11, 12, 13, 14, 15}. This bit complement always
    depends on the precision *p* of the type.^([[[Exs 9]](#ch05fn-ex09)])^([[[Exs
    10]](#ch05fn-ex10)])'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个操作符作用于值的位：补码操作符 *`~`*。补码 ~A 将具有值 65295，并对应于集合 {0, 1, 2, 3, 8, 9, 10, 11,
    12, 13, 14, 15}。这个位补码始终取决于类型的精度 *p*。^([[[Exs 9]](#ch05fn-ex09)])^([[[Exs 10]](#ch05fn-ex10)])
- en: ^([Exs 9])
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 9])
- en: ''
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that ~B can be computed by V `-` B.
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 ~B 可以通过 V `-` B 来计算。
- en: ^([Exs 10])
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 10])
- en: ''
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that -B `=` ~B `+ 1`.
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 -B `=` ~B `+ 1`.
- en: 'All of these operators can be written with identifiers: **`bitor`**, **`bitand`**,
    **`xor`**, **`or_eq`**, **`and_eq`**, **`xor_eq`**, and **`compl`** if you include
    header `iso646.h`.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些运算符都可以用标识符来写：**`bitor`**、**`bitand`**、**`xor`**、**`or_eq`**、**`and_eq`**、**`xor_eq`**
    和 **`compl`**，如果你包含头文件 `iso646.h`。
- en: '|  |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<iso646.h>`'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '`<iso646.h>`'
- en: '|  |'
  id: totrans-1062
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'A typical usage of bit sets is for *flags*, variables that control certain
    settings of a program:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 位集的典型用法是用于 *标志*，这些变量控制程序的一些设置：
- en: '[PRE72]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here the constants for each type of corvid are a power of two, and so they
    have exactly one bit set in their binary representation. Membership in a flock
    can then be handled through the operators: `|=` adds a corvid to flock, and `&`
    with one of the constants tests whether a particular corvid is present.'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每种乌鸦类型的常量都是2的幂，因此它们在二进制表示中恰好有一个位被设置。乌鸦群成员可以通过以下运算符处理：`|=` 向乌鸦群添加乌鸦，`&` 与其中一个常量一起使用来测试特定的乌鸦是否存在。
- en: 'Observe the similarity between operators `&` and `&&` or `|` and `||`: if we
    see each of the bits *b**[i]* of an **`unsigned`** as a truth value, `&` performs
    the *logical and* of all bits of its arguments simultaneously. This is a nice
    analogy that should help you memorize the particular spelling of these operators.
    On the other hand, keep in mind that the operators `||` and `&&` have short-circuit
    evaluation, so be sure to distinguish them clearly from the bit operators.'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运算符 `&` 和 `&&` 或 `|` 和 `||` 之间的相似性：如果我们将 **`unsigned`** 的每个位 *b**[i]* 视为一个真值，`&`
    同时执行其参数所有位的 *逻辑与*。这是一个很好的类比，应该有助于你记住这些运算符的特定拼写。另一方面，请记住，运算符 `||` 和 `&&` 有短路求值，所以一定要清楚地区分它们。
- en: 5.7.3\. Shift operators
  id: totrans-1067
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.3\. 位移运算符
- en: The next set of operators builds a bridge between interpretation of unsigned
    values as numbers and as bit sets. A left-shift operation *`<<`* corresponds to
    the multiplication of the numerical value by the corresponding power of two. For
    example, for *A* = 240, the set {4, 5, 6, 7}, A `<< 2` is 240 · 2² = 240 · 4 =
    960, which represents the set {6, 7, 8, 9}. Resulting bits that don’t fit into
    the binary representation for the type are simply omitted. In our example, A `<<
    9` would correspond to set {13, 14, 15, 16} (and value 122880), but since there
    is no bit 16, the resulting set is {13, 14, 15}, value 57344.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个运算符集在无符号值的解释（作为数字和位集）之间建立了一座桥梁。左移操作 *`<<`* 对应于数值乘以相应的2的幂。例如，对于 *A* = 240，集合
    {4, 5, 6, 7}，A `<< 2` 是 240 · 2² = 240 · 4 = 960，这代表集合 {6, 7, 8, 9}。结果中不适合该类型二进制表示的位被简单地省略。在我们的例子中，A
    `<< 9` 将对应于集合 {13, 14, 15, 16}（和值 122880），但由于没有位 16，结果集合是 {13, 14, 15}，值 57344。
- en: 'Thus, for such a shift operation, the precision *p* is again important. Not
    only are bits that don’t fit dropped, but it also restricts the possible values
    of the operand on the right:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这种位移操作，精度 *p* 仍然很重要。不仅是不适合的位被丢弃，而且它还限制了右操作数的可能值：
- en: '|  |'
  id: totrans-1070
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.53
  id: totrans-1071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.53
- en: '*The second operand of a shift operation must be less than the precision.*'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '*位移操作的第二操作数必须小于精度。*'
- en: '|  |'
  id: totrans-1073
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: There is an analogous right-shift operation *`>>`* that shifts the binary representation
    toward the less-significant bits. Analogously, this corresponds to an integer
    division by a power of two. Bits in positions less than or equal to the shift
    value are omitted for the result. Observe that for this operation, the precision
    of the type isn’t important.^([[[Exs 11]](#ch05fn-ex11)])
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个类似的右移操作 *`>>`*，它将二进制表示向低有效位移动。类似地，这对应于除以2的幂的整数除法。对于小于或等于位移值的位，结果中省略这些位。注意，对于这个操作，类型的精度并不重要.^([[[Exs
    11]](#ch05fn-ex11)])
- en: ^([Exs 11])
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 11])
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that the bits that are “lost” in an operation `x>`>n correspond to the
    remainder x `% (`1ULL `<<` n`)`.
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明在操作 `x>>n` 中“丢失”的位对应于余数 x `% (`1ULL `<<` n`)。
- en: Again, there are also corresponding assignment operators *`<<=`* and *`>>=`*.
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，也存在相应的赋值运算符 *`<<=`* 和 *`>>=`*。
- en: 'The primary use of the left-shift operator `<<` is specifying powers of two.
    In our example, we can now replace the **`#define`** s:'
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左移运算符 `<<` 的主要用途是指定2的幂。在我们的例子中，我们现在可以替换掉 **`#define`**：
- en: '[PRE73]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This makes the example more robust against changes to the enumeration.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得示例对枚举的变化更加健壮。
- en: 5.7.4\. Boolean values
  id: totrans-1082
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.4\. 布尔值
- en: The Boolean data type in C is also considered an unsigned type. Remember that
    it has only values 0 and 1, so there are no negative values. For backward compatibility
    with ancient programs, the basic type is called **`_Bool`**. The name bool as
    well as the constants **`false`** and **`true`** only come through the inclusion
    of `stdbool.h`. Unless you have to maintain a `<stdbool.h>` really old code base,
    you should use the latter.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: C中的布尔数据类型也被视为无符号类型。记住，它只有0和1两个值，所以没有负值。为了与古老的程序保持向后兼容，基本类型被称为**`_Bool`**。名称bool以及常量**`false`**和**`true`**只有通过包含`stdbool.h`才能使用。除非你真的需要维护一个非常旧的`<stdbool.h>`代码库，否则你应该使用后者。
- en: '![](comm.jpg)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
  zh: '![图片](comm.jpg)'
- en: '|  |'
  id: totrans-1085
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`stdbool.h`'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdbool.h`'
- en: '|  |'
  id: totrans-1087
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Treating bool as an unsigned type is a stretch of the concept. Assignment to
    a variable of that type doesn’t follow the modulus rule of [takeaway 4.6](kindle_split_012.html#ch04note07),
    but a special rule for Boolean values ([takeaway 3.1](kindle_split_011.html#ch03note01)).
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 将布尔视为无符号类型是对概念的拉伸。将该类型的变量赋值不遵循[要点4.6](kindle_split_012.html#ch04note07)中的模数规则，而是遵循布尔值的特殊规则([要点3.1](kindle_split_011.html#ch03note01))。
- en: You will probably rarely need bool variables. They are only useful if you want
    to ensure that the value is always reduced to **`false`** or **`true`** on assignment.
    Early versions of C didn’t have a Boolean type, and many experienced C programmers
    still don’t use it.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能很少需要布尔变量。它们只有在你想确保赋值后值总是减少到**`false`**或**`true`**时才有用。C的早期版本没有布尔类型，许多经验丰富的C程序员仍然不使用它。
- en: 5.7.5\. Signed integers
  id: totrans-1090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.5. 带符号整数
- en: 'Signed types are *a bit* more complicated than unsigned types. A C implementation
    has to decide about two points:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 带符号类型比无符号类型要复杂一些。C实现必须决定两个问题：
- en: What happens on arithmetic overflow?
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在算术溢出时会发生什么？
- en: How is the sign of a signed type represented?
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带符号类型的符号如何表示？
- en: 'Signed and unsigned types come in pairs according to their integer rank, with
    the notable two exceptions from [table 5.1](#ch05table01): **`char`** and bool.
    The binary representation of the signed type is constrained by the inclusion diagram
    that we have seen above.'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 带符号和无符号类型根据它们的整数等级成对出现，有两个显著的例外来自[表5.1](#ch05table01)：**`char`** 和 bool。带符号类型的二进制表示受上面看到的包含图的约束。
- en: '|  |'
  id: totrans-1095
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.54
  id: totrans-1096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点5.54
- en: '*Positive values are represented independently from signedness.*'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '*正数与符号无关地表示。*'
- en: '|  |'
  id: totrans-1098
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Or, stated otherwise, a positive value with a signed type has the same representation
    as in the corresponding unsigned type. That is why the maximum value for any integer
    type can be expressed so easily ([takeaway 5.51](#ch05note53)): signed types also
    have a precision, *p*, that determines the maximum value of the type.'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，换句话说，正数在带符号类型中的表示与相应的无符号类型相同。这就是为什么任何整数类型的最大值都可以如此容易地表示出来（[要点5.51](#ch05note53)）：带符号类型也有一个精度，*p*，它决定了类型的最大值。
- en: 'The next thing the standard prescribes is that signed types have one additional
    bit, the *sign bit**^C*. If it is 0, we have a positive value; if it is 1, the
    value is negative. Unfortunately, there are different concepts of how such a sign
    bit can be used to obtain a negative number. C allows three different *sign representations**^C*:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 标准规定的下一件事是，带符号类型有一个额外的位，即 *符号位**^C*。如果是0，则表示正数；如果是1，则表示负数。不幸的是，关于如何使用这样的符号位来获得负数有不同的概念。C允许三种不同的
    *符号表示**^C*：
- en: '*Sign and magnitude**^C*'
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*符号和幅度**^C*'
- en: '*Ones’ complement**^C*'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一补码**^C*'
- en: '*Two’s complement**^C*'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二进制补码**^C*'
- en: 'The first two nowadays probably only have historical or exotic relevance: for
    sign and magnitude, the magnitude is taken as positive values, and the sign bit
    simply specifies that there is a minus sign. Ones’ complement takes the corresponding
    positive value and complements all bits. Both representations have the disadvantage
    that two values evaluate to 0: there is a positive and a negative 0.^([[10](#ch05fn10)])'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的前两种可能只有历史或异国情调的相关性：对于符号和幅度，幅度被视为正值，符号位简单地指定存在负号。一补码取相应的正值并对所有位进行补码。这两种表示都有缺点，即两个值评估为0：有一个正0和一个负0.^([[10](#ch05fn10)])
- en: ^(10)
  id: totrans-1105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^{(10)}
- en: ''
  id: totrans-1106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since these two have fallen completely out of use on modern architectures, efforts
    are underway to remove them from the next revision of the C standard.
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于这两个概念在现代架构中已经完全废弃，因此正在努力在C标准的下一个修订版中将其删除。
- en: '![](comm.jpg)'
  id: totrans-1108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](comm.jpg)'
- en: 'Commonly used on modern platforms is the two’s complement representation. It
    performs exactly the same arithmetic as we have seen for unsigned types, but the
    upper half of unsigned values (those with a high-order bit of 1) is interpreted
    as being negative. The following two functions are basically all that is needed
    to interpret unsigned values as signed values:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代平台上常用的是二进制补码表示法。它执行与无符号类型相同的算术，但无符号值的上半部分（高位为1的值）被解释为负数。以下两个函数基本上是解释无符号值作为有符号值所需的所有内容：
- en: '[PRE74]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[Table 5.6](#ch05table06) shows an example of how the negative of our example
    value `240` can be constructed. For unsigned types, -A can be computed as ~A `+
    1`.^([[[Exs 12]](#ch05fn-ex12)])^([[[Exs 13]](#ch05fn-ex13)])^([[[Exs 14]](#ch05fn-ex14)])
    Two’s complement representation performs exactly the same bit operation for signed
    types as for unsigned types. It only *interprets* representations that have the
    high-order bit as being negative.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5.6](#ch05table06) 展示了如何构建我们示例值 `240` 的负数。对于无符号类型，-A 可以计算为 ~A `+ 1`。^([[[Exs
    12]](#ch05fn-ex12)])^([[[Exs 13]](#ch05fn-ex13)])^([[[Exs 14]](#ch05fn-ex14)])
    二进制补码表示法对有符号类型和无符号类型执行完全相同的位操作。它只 *解释* 高位为负的表示。'
- en: ^([Exs 12])
  id: totrans-1112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 12])
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that for unsigned arithmetic, A `+` `~`A is the maximum value.
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明对于无符号算术，A `+` `~`A 是最大值。
- en: ^([Exs 13])
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 13])
- en: ''
  id: totrans-1116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that for unsigned arithmetic, A `+` `~`A is –1.
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明对于无符号算术，A `+` `~`A 是 -1.
- en: ^([Exs 14])
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 14])
- en: ''
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that for unsigned arithmetic, A `+ (~`A `+ 1) == 0`.
  id: totrans-1120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明对于无符号算术，A `+ (~`A `+ 1) == 0`.
- en: Table 5.6\. Negation for 16-bit unsigned integer types
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.6\. 16位无符号整数类型的取反
- en: '| Op | Value | *b*[15] | ... | *b*[0] |'
  id: totrans-1122
  prefs: []
  type: TYPE_TB
  zh: '| Op | Value | *b*[15] | ... | *b*[0] |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-1123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| A | 240 | 0000000011110000 |'
  id: totrans-1124
  prefs: []
  type: TYPE_TB
  zh: '| A | 240 | 0000000011110000 |'
- en: '| ~A | 65295 | 1111111100001111 |'
  id: totrans-1125
  prefs: []
  type: TYPE_TB
  zh: '| ~A | 65295 | 1111111100001111 |'
- en: '| +1 | 65295 | 0000000000000001 |'
  id: totrans-1126
  prefs: []
  type: TYPE_TB
  zh: '| +1 | 65295 | 0000000000000001 |'
- en: '| -A | 65296 | 1111111100010000 |'
  id: totrans-1127
  prefs: []
  type: TYPE_TB
  zh: '| -A | 65296 | 1111111100010000 |'
- en: 'When done that way, signed integer arithmetic will again behave more or less
    nicely. Unfortunately, there is a pitfall that makes the outcome of signed arithmetic
    difficult to predict: overflow. Where unsigned values are forced to wrap around,
    the behavior of a signed overflow is *undefined**^C*. The following two loops
    look much the same:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式完成，有符号整数算术将再次表现得相当好。不幸的是，有一个陷阱使得有符号算术的结果难以预测：溢出。在无符号值被强制回绕的地方，有符号溢出的行为是
    *未定义**^C*。以下两个循环看起来很相似：
- en: '[PRE75]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We know what happens for the first loop: the counter is incremented up to **`UINT_MAX`**
    and then wraps around to 0\. All of this may take some time, but after **`UINT_MAX`**`-1`
    iterations, the loop stops because i will have reached 0.'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道第一次循环会发生什么：计数器增加到**`UINT_MAX`**，然后回绕到0。所有这些可能需要一些时间，但在**`UINT_MAX`**`-1`次迭代之后，循环停止，因为i将到达0。
- en: For the second loop, everything looks similar. But because here the behavior
    of overflow is undefined, the compiler is allowed to *pretend* that it will never
    happen. Since it also knows that the value at the start is positive, it may assume
    that i, as long as the program has defined behavior, is never negative or 0\.
    The *as-if* Rule ([takeaway 5.8](#ch05note08)) allows it to optimize the second
    loop to
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二次循环，看起来很相似。但是，因为这里的溢出行为是未定义的，编译器被允许 *假装* 它永远不会发生。由于它也知道起始值是正的，它可能假设只要程序有定义的行为，i就永远不会是负的或0。*as-if*
    规则 ([取得成果 5.8](#ch05note08)) 允许它优化第二次循环为
- en: '[PRE76]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: That’s right, an *infinite loop*.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 那是对的，一个 *无限循环*。
- en: '|  |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.55
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 5.55
- en: '*Once the abstract state machine reaches an undefined state, no further assumption
    about the continuation of the execution can be made.*'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦抽象状态机达到一个未定义的状态，就无法再对执行的延续做出任何假设。*'
- en: '|  |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Not only that, the compiler is allowed to do what it pleases for the operation
    itself (“*Undefined? so let’s define it*"), but it may also assume that it will
    never reach such a state and draw conclusions from that.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，编译器被允许对操作本身做它想做的事情（“*未定义？那我们就定义它*”），但它也可以假设它永远不会达到这样的状态，并据此得出结论。
- en: Commonly, a program that has reached an undefined state is referred to as “having”
    or “showing” *undefined behavior*. This wording is a bit unfortunate; in many
    such cases, a program does not “show” any visible signs of weirdness. In the contrary,
    bad things will be going on that you will not even notice for a long time.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个达到未定义状态的程序被称为“具有”或“显示” *未定义行为*。这种说法有点不幸；在许多这样的情况下，程序并不“显示”任何明显的异常迹象。相反，一些不好的事情正在发生，你可能很长时间都不会注意到。
- en: '|  |'
  id: totrans-1140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.56
  id: totrans-1141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 5.56
- en: '*It is your responsibility to avoid undefined behavior of all operations.*'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免所有操作未定义行为是你的责任*。'
- en: '|  |'
  id: totrans-1143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What makes things even worse is that on *some* platforms with *some* standard
    compiler options, the compilation will just look right. Since the behavior is
    undefined, on such a platform, signed integer arithmetic might turn out to be
    basically the same as unsigned. But changing the platform, the compiler, or some
    options can change that. All of a sudden, your program that worked for years crashes
    out of nowhere.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 使事情变得更糟的是，在某些 *平台* 上，使用某些 *标准编译器选项*，编译看起来似乎是正确的。由于行为是未定义的，在这样的平台上，有符号整数算术可能基本上与无符号整数相同。但是改变平台、编译器或某些选项可能会改变这一点。突然之间，你多年来一直运行的程序会突然崩溃。
- en: Basically, what we have discussed up to this chapter always had well-defined
    behavior, so the abstract state machine is always in a well-defined state. Signed
    arithmetic changes this, so as long as you don’t need it, avoid it. We say that
    a program performs a *trap**^C* (or just *traps*) if it is terminated abruptly
    before its usual end.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们到本章为止所讨论的内容总是具有明确的行为，因此抽象状态机总是处于一个明确的状态。有符号算术改变了这一点，所以除非你需要它，否则避免使用它。我们说，如果一个程序在其正常结束之前突然终止，那么它执行了一个
    *trap*^C*（或者简称为 *traps*）。
- en: '|  |'
  id: totrans-1146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.57
  id: totrans-1147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 5.57
- en: '*Signed arithmetic may trap badly.*'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '*有符号算术可能会产生严重的陷阱*。'
- en: '|  |'
  id: totrans-1149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'One of the things that might already overflow for signed types is negation.
    We have seen that **`INT_MAX`** has all bits but the sign bit set to 1\. **`INT_MIN`**
    then has the “next” representation: the sign bit set to 1 and all other values
    set to 0\. The corresponding value is not `-`**`INT_MAX`**.^([[[Exs 15]](#ch05fn-ex15)])'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号类型，可能已经溢出的一个操作是取反。我们已经看到 **`INT_MAX`** 除了符号位外所有位都设置为 1。**`INT_MIN`** 然后具有“下一个”表示：符号位设置为
    1，其他所有值设置为 0。相应的值不是 `-`**`INT_MAX`**.^([[[Exs 15]](#ch05fn-ex15)])
- en: ^([Exs 15])
  id: totrans-1151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 15])
- en: ''
  id: totrans-1152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that **`INT_MIN`**`+`**`INT_MAX`** is –1.
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明 **`INT_MIN`**`+`**`INT_MAX`** 等于 –1。
- en: '|  |'
  id: totrans-1154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.58
  id: totrans-1155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 5.58
- en: '*In two’s complement representation,* **`INT_MIN`** *`< -`***`INT_MAX`***.*'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '*在二进制补码表示法中，* **`INT_MIN`** *`< -`***`INT_MAX`***.*'
- en: '|  |'
  id: totrans-1157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Or, stated otherwise, in two’s complement representation, the positive value
    `-`**`INT_MIN`** is out of bounds since the *value* of the operation is larger
    than **`INT_MAX`**.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，用另一种说法，在二进制补码表示法中，正值 `-`**`INT_MIN`** 超出了范围，因为操作的结果 *值* 大于 **`INT_MAX`**。
- en: '|  |'
  id: totrans-1159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.59
  id: totrans-1160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 5.59
- en: '*Negation may overflow for signed arithmetic.*'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '*有符号算术的取反可能会溢出*。'
- en: '|  |'
  id: totrans-1162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For signed types, bit operations work with the binary representation. So the
    value of a bit operation depends in particular on the sign representation. In
    fact, bit operations even allow us to detect the sign representation:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号类型，位操作与二进制表示一起工作。因此，位操作的结果特别依赖于符号表示。实际上，位操作甚至允许我们检测符号表示：
- en: '[PRE77]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The shift operations then become really messy. The semantics of what such an
    operation is for a negative value is not clear.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 那么位移操作就变得非常混乱。对于负值，这种操作的语义并不明确。
- en: '|  |'
  id: totrans-1166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.60
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 5.60
- en: '*Use unsigned types for bit operations.*'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用无符号类型进行位操作*。'
- en: '|  |'
  id: totrans-1169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.7.6\. Fixed-width integer types
  id: totrans-1170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.6\. 固定宽度整数类型
- en: The precision for the integer types that we have seen so far can be inspected
    indirectly by using macros from `limits.h`, such as **`UINT_MAX`** and **`LONG_MIN`**.
    The C standard only gives us a minimal precision for them. For the unsigned types,
    these are
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的整数类型的精度可以通过使用 `limits.h` 中的宏间接检查，例如 **`UINT_MAX`** 和 **`LONG_MIN`**。C
    标准只为我们提供了它们的最小精度。对于无符号类型，这些是
- en: '|  |'
  id: totrans-1172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<limits.h>`'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '`<limits.h>`'
- en: '|  |'
  id: totrans-1174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| type | minimal precision |'
  id: totrans-1175
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 最小精度 |'
- en: '| --- | --- |'
  id: totrans-1176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| bool | 1 |'
  id: totrans-1177
  prefs: []
  type: TYPE_TB
  zh: '| bool | 1 |'
- en: '| **unsigned char** | 8 |'
  id: totrans-1178
  prefs: []
  type: TYPE_TB
  zh: '| **无符号字符** | 8 |'
- en: '| **unsigned short** | 16 |'
  id: totrans-1179
  prefs: []
  type: TYPE_TB
  zh: '| **无符号短整型** | 16 |'
- en: '| **unsigned** | 16 |'
  id: totrans-1180
  prefs: []
  type: TYPE_TB
  zh: '| **unsigned** | 16 |'
- en: '| **unsigned long** | 32 |'
  id: totrans-1181
  prefs: []
  type: TYPE_TB
  zh: '| **无符号长整型** | 32 |'
- en: '| **unsigned long long** | 64 |'
  id: totrans-1182
  prefs: []
  type: TYPE_TB
  zh: '| **无符号长长整型** | 64 |'
- en: Under usual circumstances, these guarantees should give you enough information;
    but under some technical constraints, such guarantees might not be sufficient,
    or you might want to emphasize a particular precision. This may be the case if
    you want to use an unsigned quantity to represent a bit set of a known maximal
    size. If you know that 32-bit will suffice for your set, depending on your platform,
    you might want to choose **`unsigned`** or **`unsigned long`** to represent it.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在通常情况下，这些保证应该给你足够的信息；但在某些技术约束下，这些保证可能不足，或者你可能想强调特定的精度。这可能是在你想使用无符号量来表示已知最大大小的位集合时的情况。如果你知道32位足以满足你的集合，根据你的平台，你可能想选择**`unsigned`**或**`unsigned
    long`**来表示它。
- en: The C standard provides names for *exact-width integer types* in `stdint.h`.
    As the name indicates, they are of an exact prescribed “width,” which for provided
    unsigned types is guaranteed to be the same as their precision.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: C标准在`stdint.h`中为*精确宽度整数类型*提供了名称。正如名称所示，它们具有精确规定的“宽度”，对于提供的无符号类型，保证其与精度相同。
- en: '|  |'
  id: totrans-1185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdint.h>`'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdint.h>`'
- en: '|  |'
  id: totrans-1187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.61
  id: totrans-1189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**要点5.61**'
- en: '*If the type* *`uintN_t`* *is provided, it is an unsigned integer type with
    exactly* *N* *bits of width and precision.*'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果提供了类型* *`uintN_t`* *，它是一个具有精确* *N* *位宽度和精度的无符号整数类型*。'
- en: '|  |'
  id: totrans-1191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.62
  id: totrans-1193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**要点5.62**'
- en: '*If the type* *`intN_t`* *is provided, it is signed, with two’s complement
    representation and has a width of exactly* *N* *bits and a precision of* *N* –
    1*.*'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果提供了类型* *`intN_t`* *，它是有符号的，具有二进制补码表示，具有精确的* *N* *位宽度和*N* – 1的精度*。'
- en: '|  |'
  id: totrans-1195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: None of these types is guaranteed to exist, but for a convenient set of powers
    of two, the **`typedef`** must be provided if types with the corresponding properties
    exist.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型中没有任何一个是保证存在的，但对于一组方便的2的幂，如果存在具有相应属性的类型，则必须提供**`typedef`**。
- en: '|  |'
  id: totrans-1197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.63
  id: totrans-1198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**要点5.63**'
- en: '*If types with the required properties exist for values of* *N* = 8, 16, 32*,
    and* 64*, types* *`uintN_t`* *and* *`intN_t`**, respectively, must be provided.*'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果存在具有所需属性的* *N* = 8，16，32*和* 64*的值的类型，则必须提供类型* *`uintN_t`* *和* *`intN_t`**。'
- en: '|  |'
  id: totrans-1200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Nowadays, platforms usually provide **`uint8_t`**, **`uint16_t`**, **`uint32_t`**,
    and **`uint64_t`** unsigned types and **`int8_t`**, **`int16_t`**, **`int32_t`**,
    and **`int64_t`** signed types. Their presence and bounds can be tested with the
    macros **`UINT8_MAX`**, . . . , **`UINT64_MAX`** for unsigned types and **`INT8_MIN`**,
    **`INT8_MAX`**, . . . , **`INT64_MIN`** and **`INT64_MAX`**, respectively.^([[[Exs
    16]](#ch05fn-ex16)])
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，平台通常提供**`uint8_t`**，**`uint16_t`**，**`uint32_t`**和**`uint64_t`**无符号类型以及**`int8_t`**，**`int16_t`**，**`int32_t`**和**`int64_t`**有符号类型。它们的存在和界限可以通过无符号类型的宏**`UINT8_MAX`**，...，**`UINT64_MAX`**和分别对应的有符号类型的宏**`INT8_MIN`**，**`INT8_MAX`**，...，**`INT64_MIN`**和**`INT64_MAX`**来测试.^([[[Exs
    16]](#ch05fn-ex16)])
- en: ^([Exs 16])
  id: totrans-1202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 16])
- en: ''
  id: totrans-1203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If they exist, the values of all these macros are prescribed by the properties
    of the types. Think of a closed formula in *N* for these values.
  id: totrans-1204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它们存在，所有这些宏的值都由类型的属性规定。将这些值视为*N*的封闭公式。
- en: To encode literals of the requested type, there are the macros **`UINT8_C`**,
    . . . , **`UINT64_C`**, and **`INT8_C`**, . . . , **`INT64_C`**, respectively.
    For example, on platforms where **`uint64_t`** is **`unsigned long`**, **`INT64_C`**`(1)`
    expands to 1UL.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码请求类型的文字，有宏**`UINT8_C`**，...，**`UINT64_C`**，和**`INT8_C`**，...，**`INT64_C`**，分别。例如，在**`uint64_t`**是**`unsigned
    long`**的平台，**`INT64_C`**`(1)`展开为1UL。
- en: '|  |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.64
  id: totrans-1207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**要点5.64**'
- en: '*For any of the fixed-width types that are provided,* **`_MIN`** *(only signed),
    maximum* **`_MAX`***, and literals* **`_C`** *macros are provided, too.*'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于提供的任何固定宽度类型，还提供了* **`_MIN`** *(仅限有符号)，最大* **`_MAX`***，和文字* **`_C`** *宏*。'
- en: '|  |'
  id: totrans-1209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Since we cannot know the type behind such a fixed-width type, it would be difficult
    to guess the correct format specifier to use for **printf** and friends. The header
    `inttypes.h` provides us with macros for that. For example, for *N* = 64, we are
    provided with **`PRId64`**, **`PRIi64`**, **`PRIo64`**, **`PRIu64`**, **`PRIx64`**,
    and **`PRIX64`**, for **printf** formats "%d", "%i", "%o", "%u", "%x" and "%X",
    respectively:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法知道此类固定宽度类型背后的类型，猜测用于**printf**和朋友的正确格式说明符将很困难。头文件`inttypes.h`为我们提供了相应的宏。例如，对于*N*
    = 64，我们提供了**`PRId64`**，**`PRIi64`**，**`PRIo64`**，**`PRIu64`**，**`PRIx64`**，和**`PRIX64`**，分别对应**printf**格式"%d"，"%i"，"%o"，"%u"，"%x"和"%X"：
- en: '|  |'
  id: totrans-1211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<inttypes.h>`'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '`<inttypes.h>`'
- en: '|  |'
  id: totrans-1213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE78]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, these macros expand to string literals that are combined with
    other string literals into the format string. This is certainly not the best candidate
    for a C coding beauty contest.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些宏扩展为字符串字面量，这些字符串字面量与其他字符串字面量组合成格式字符串。这当然不是C编码之美竞赛的最佳候选人。
- en: 5.7.7\. Floating-point data
  id: totrans-1216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.7\. 浮点数据
- en: Whereas integers come near the mathematical concepts of ![](nopf.jpg) (unsigned)
    or ![](zopf.jpg) (signed), floating-point types are close to ![](ropf.jpg) (non-complex)
    or ![](copf.jpg) (complex). The way they differ from these mathematical concepts
    is twofold. First, there is a size restriction on what is presentable. This is
    similar to what we have seen for integer types. The include file `float.h`, for
    example, has constants **`DBL_MIN`** and **`DBL_MAX`** that provide us with the
    minimal and maximal values for **`double`**. But be aware that here, **`DBL_MIN`**
    is the smallest number that is strictly greater than `0.0`; the smallest negative
    **`double`** value is `-`**`DBL_MAX`**.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 而整数接近数学概念中的 ![](nopf.jpg)（无符号）或 ![](zopf.jpg)（有符号），浮点类型接近 ![](ropf.jpg)（非复数）或
    ![](copf.jpg)（复数）。它们与这些数学概念的不同之处有两点。首先，存在一个大小限制，即可以表示的内容。这与我们所看到的整数类型类似。例如，包含文件
    `float.h` 有常数 **`DBL_MIN`** 和 **`DBL_MAX`**，为我们提供了 **`double`** 的最小值和最大值。但请注意，这里的
    **`DBL_MIN`** 是严格大于 `0.0` 的最小数；最小的负 **`double`** 值是 `-`**`DBL_MAX`**。
- en: '|  |'
  id: totrans-1218
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<float.h>`'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '`<float.h>`'
- en: '|  |'
  id: totrans-1220
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'But real numbers (![](ropf.jpg)) have another difficulty when we want to represent
    them on a physical system: they can have an unlimited expansion, such as the value
    ![](1by3.jpg), which has an endless repetition of the digit 3 in decimal representation,
    or the value of π, which is “transcendent” and so has an endless expansion in
    any representation and doesn’t repeat in any way.'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 但实数(![](ropf.jpg))在我们要在物理系统上表示它们时还有另一个困难：它们可以有无限扩展，例如值 ![](1by3.jpg)，它在十进制表示中有无限重复的数字3，或者π的值，它是“超越”的，因此在任何表示中都有无限扩展并且以任何方式都不重复。
- en: C and other programming languages deal with these difficulties by cutting off
    the expansion. The position where the expansion is cut is “floating” (thus the
    name) and depends on the magnitude of the number in question.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: C和其他编程语言通过截断扩展来处理这些困难。扩展被截断的位置是“浮动”（因此得名）并且取决于所讨论的数字的大小。
- en: 'In a view that is a bit simplified, a floating-point value is computed from
    the following values:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种简化的观点中，浮点值是从以下值计算得出的：
- en: '| *s* | Sign (±1) |'
  id: totrans-1224
  prefs: []
  type: TYPE_TB
  zh: '| *s* | 符号（±1） |'
- en: '| *e* | Exponent, an integer |'
  id: totrans-1225
  prefs: []
  type: TYPE_TB
  zh: '| *e* | 指数，一个整数 |'
- en: '| *f*[1]*, . . . ,* *f**[p]* | values 0 or 1, the mantissa bits |'
  id: totrans-1226
  prefs: []
  type: TYPE_TB
  zh: '| *f*[1]*, . . . ,* *f**[p]* | 值0或1，尾数位 |'
- en: 'For the exponent, we have *e**[min]* ≤ *e* ≤ *e**[max]*. *p*, the number of
    bits in the mantissa, is called *precision*. The floating-point value is then
    given by this formula:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指数，我们有 *e**[min]* ≤ *e* ≤ *e**[max]*。*p*，尾数的位数，被称为*精度*。浮点值由以下公式给出：
- en: '![](pg_79-1.jpg)'
  id: totrans-1228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_79-1.jpg)'
- en: The values *p*, *emin*, and *emax* are type dependent and therefore not represented
    explicitly in each number. They can be obtained through macros such as **`DBL_MANT_DIG`**
    (for *p*, typically 53) **`DBL_MIN_EXP`** (*e**[min]*, –1021), and **`DBL_MAX_EXP`**
    (*e**[max]*, 1024).
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 值 *p*、*emin* 和 *emax* 是类型相关的，因此在每个数字中并未明确表示。它们可以通过宏如 **`DBL_MANT_DIG`**（对于 *p*，通常是53）**`DBL_MIN_EXP`**（*e**[min]*，-1021）和
    **`DBL_MAX_EXP`**（*e**[max]*，1024）来获得。
- en: If we have, for example, a number that has *s* = –1, *e* = –2, *f*[1] = 1, *f*[2]
    = 0, and *f*[2] = 1, its value is
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个数，其 *s* = –1，*e* = –2，*f*[1] = 1，*f*[2] = 0，和 *f*[2] = 1，其值是
- en: '![](pg_79-2.jpg)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_79-2.jpg)'
- en: which corresponds to the decimal value `-0.15625`. From that calculation, we
    see also that floating-point values are always representable as a fraction that
    has some power of two in the denominator.^([[[Exs 17]](#ch05fn-ex17)])
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于十进制值 `-0.15625`。从该计算中，我们还可以看到浮点值总是可以表示为一个分母中有某个2的幂次的分数。^([[[例17]](#ch05fn-ex17)])
- en: ^([Exs 17])
  id: totrans-1233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例17])
- en: ''
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that all representable floating-point values with *e > p* are multiples
    of 2*^(e–p)*.
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明所有可表示的浮点值，其中 *e > p*，都是 2*^(e–p)* 的倍数。
- en: An important thing to keep in mind with such floating-point representations
    is that values can be cut off during intermediate computations.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的浮点表示中要记住的一个重要事情是，值在中间计算过程中可能会被截断。
- en: '|  |'
  id: totrans-1237
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 5.65
  id: totrans-1238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 5.65
- en: '*Floating-point operations are neither* associative*,* commutative*, nor* distributive*.*'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点运算既不是* 结合律 *，也不是* 交换律 *，也不是* 分配律 *。'
- en: '|  |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: So basically, they lose all the nice algebraic properties we are used to when
    doing pure math. The problems that arise from that are particularly pronounced
    if we operate with values that have very different orders of magnitude.^([[[Exs
    18]](#ch05fn-ex18)]) For example, adding a very small floating-point value *x*
    with an exponent that is less than – *p* to a value *y >* 1 just returns *y* again.
    As a consequence, it is really difficult to assert without further investigation
    whether two computations have the “same” result. Such investigations are often
    cutting-edge research questions, so we cannot expect to be able to assert equality
    or not. We are only able to tell that the results are “close."
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们失去了我们在做纯数学时习惯的所有美好的代数属性。由此产生的问题，如果我们操作具有非常不同数量级的值时尤其明显。[[[例 18]](#ch05fn-ex18)])
    例如，将一个非常小的浮点值 *x* 与小于 – *p* 的指数相加到值 *y >* 1 上，只会再次返回 *y*。因此，在没有进一步调查的情况下，很难断言两个计算结果是否“相同”。这类调查通常是尖端研究问题，因此我们无法期望能够断言相等或不相等。我们只能告诉结果“接近”。
- en: ^([Exs 18])
  id: totrans-1242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 18])
- en: ''
  id: totrans-1243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Print the results of the following expressions: `1.0`E`-13 + 1.0`E`-13` and
    `(1.0`E`-13 + (1.0`E`-13 + 1.0)) - 1.0`.'
  id: totrans-1244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打印以下表达式的结果：`1.0`E`-13 + 1.0`E`-13` 和 `(1.0`E`-13 + (1.0`E`-13 + 1.0)) - 1.0`.
- en: '|  |'
  id: totrans-1245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 5.66
  id: totrans-1246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 5.66
- en: '*Never compare floating-point values for equality.*'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '*永远不要比较浮点数的相等性*。'
- en: '|  |'
  id: totrans-1248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<tgmath.h>`'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-1251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The representation of the complex types is straightforward and identical to
    an array of two elements of the corresponding real floating-point type. To access
    the real and imaginary part of a complex number, two type-generic macros also
    come with the header `tgmath.h`: **`creal`** and **`cimag`**. For any z of one
    of the three complex types, we have that z `==` **`creal`**`(`z`) +` **`cimag`**`(`z`)*`I.^([[11](#ch05fn11)])'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 复数类型的表示简单且与相应实浮点类型的数组相同。要访问复数的实部和虚部，`tgmath.h`头文件中也提供了两个类型通用的宏：**`creal`** 和
    **`cimag`**。对于三种复数类型中的任何一种类型z，我们有 z `==` **`creal`**`(`z`) +` **`cimag`**`(`z`)*`I.^([[11](#ch05fn11)])
- en: ^(11)
  id: totrans-1253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11)
- en: ''
  id: totrans-1254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will learn about such function-like macros in [section 8.1.2](kindle_split_016.html#ch08lev2sec2).
  id: totrans-1255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在[第8.1.2节](kindle_split_016.html#ch08lev2sec2)中了解这样的函数式宏。
- en: Summary
  id: totrans-1256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: C programs run in an *abstract state machine* that is mostly independent of
    the specific computer where it is launched.
  id: totrans-1257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C程序在*抽象状态机*上运行，该状态机主要独立于启动它的特定计算机。
- en: All basic C types are kinds of numbers, but not all of them can be used directly
    for arithmetic.
  id: totrans-1258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有基本C类型都是数字类型，但并非所有这些类型都可以直接用于算术。
- en: Values have a type and a binary representation.
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值具有类型和二进制表示。
- en: When necessary, types of values are implicitly converted to fit the needs of
    particular places where they are used.
  id: totrans-1260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时，值类型会隐式转换为适合它们被使用的特定位置的需求。
- en: Variables must be explicitly initialized before their first use.
  id: totrans-1261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量在使用前必须显式初始化。
- en: Integer computations give exact values as long as there is no overflow.
  id: totrans-1262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数运算在没有溢出的情况下给出精确值。
- en: Floating-point computations give only approximated results that are cut off
    after a certain number of binary digits.
  id: totrans-1263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点运算只给出近似结果，这些结果在一定的二进制位数后截断。
- en: Chapter 6\. Derived data types
  id: totrans-1264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 导出数据类型
- en: This chapter covers
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Grouping objects into arrays
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象分组到数组中
- en: Using pointers as opaque types
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针作为不透明类型
- en: Combining objects into structures
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象组合到结构体中
- en: Giving types new names with **`typedef`**
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**`typedef`**为类型赋予新名称
- en: 'All other data types in C are derived from the basic types that we know now.
    There are four strategies for deriving data types. Two of them are called *aggregate
    data types*, because they combine multiple instances of one or several other data
    types:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的所有其他数据类型都源自我们已知的基类型。有四种推导数据类型的方法。其中两种被称为*聚合数据类型*，因为它们组合了一个或多个其他数据类型的多个实例：
- en: '***Arrays:*** These combine items that all have the same base type ([section
    6.1](#ch06lev1sec1)).'
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数组：*** 这些组合了具有相同基本类型的项 ([第6.1节](#ch06lev1sec1))。'
- en: '***Structures:*** These combine items that may have different base types ([section
    6.3](#ch06lev1sec3)).'
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***结构体：*** 这些组合了可能具有不同基本类型的项 ([第6.3节](#ch06lev1sec3))。'
- en: 'The two other strategies to derive data types are more involved:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 推导数据类型的两种其他策略更为复杂：
- en: '***Pointers:*** Entities that refer to an object in memory. Pointers are by
    far the most involved concept, and we will delay a full discussion of them to
    [chapter 11](kindle_split_021.html#ch11). Here, in [section 6.2](#ch06lev1sec2),
    we will only discuss them as opaque data types, without even mentioning the real
    purpose they fulfill.'
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***指针：*** 指向内存中对象的实体。指针是涉及最复杂的概念，我们将推迟对它们的全面讨论，直到 [第 11 章](kindle_split_021.html#ch11)。在这里，在
    [第 6.2 节](#ch06lev1sec2) 中，我们只将它们作为不透明数据类型进行讨论，甚至不提及其真正履行的目的。'
- en: '***Unions:*** These overlay items of different base types in the same memory
    location. Unions require a deeper understanding of C’s memory model and are not
    of much use in a programmer’s everyday life, so they are only introduced later,
    in [section 12.2](kindle_split_022.html#ch12lev1sec2).'
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***联合体：*** 这些在相同内存位置上覆盖不同基本类型的项。联合体需要更深入地理解 C 的内存模型，并且在程序员日常生活中的用途不大，因此它们只会在
    [第 12.2 节](kindle_split_022.html#ch12lev1sec2) 中稍后介绍。'
- en: 'There is a fifth strategy that introduces new names for types: **`typedef`**
    ([section 6.4](#ch06lev1sec4)). Unlike the previous four, this does not create
    a new type in C’s type system, but only creates a new name for an existing type.
    In that way, it is similar to the definition of macros with **`#define`**; thus
    the choice for the keyword for this feature.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种第五种策略引入了类型的新名称：**`typedef`** ([第 6.4 节](#ch06lev1sec4))。与前面的四种不同，这并不在 C 的类型系统中创建一个新类型，而只是为现有类型创建一个新名称。因此，它类似于使用
    **`#define`** 定义宏的定义；因此选择了这个关键字来表示这个特性。
- en: 6.1\. Arrays
  id: totrans-1277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 数组
- en: 'Arrays allow us to group objects of the same type into an encapsulating object.
    We will see pointer types later ([chapter 11](kindle_split_021.html#ch11)), but
    many people who come to C are confused about arrays and pointers. And this is
    completely normal: arrays and pointers are closely related in C, and to explain
    them we face a *chicken and egg* problem: arrays *look like* pointers in many
    contexts, and pointers refer to array objects. We chose an order of introduction
    that is perhaps unusual: we will start with arrays and stay with them as long
    as possible before introducing pointers. This may seem “wrong” to some of you,
    but remember that everything stated here must be viewed based on the *as-if* Rule
    ([takeaway 5.8](kindle_split_013.html#ch05note08)): we will first describe arrays
    in a way that is consistent with C’s assumptions about the abstract state machine.'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许我们将相同类型的对象组合成一个封装的对象。我们将在 [第 11 章](kindle_split_021.html#ch11) 中看到指针类型，但许多初来乍到的
    C 语言程序员对数组和指针感到困惑。这是完全正常的：在 C 语言中，数组和指针密切相关，要解释它们，我们面临一个 *鸡生蛋还是蛋生鸡* 的问题：在许多情况下，数组
    *看起来像* 指针，而指针指向数组对象。我们选择了可能不寻常的介绍顺序：我们将从数组开始，尽可能长时间地停留在数组上，然后再介绍指针。这可能会让一些人觉得“不对”，但请记住，这里所说的每一件事都必须基于
    *as-if* 规则 ([第 5.8 节的要点](kindle_split_013.html#ch05note08)) 来理解：我们将首先以与 C 语言对抽象状态机的假设一致的方式描述数组。
- en: '|  |'
  id: totrans-1279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.1
  id: totrans-1280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 6.1 节要点
- en: '*Arrays are not pointers.*'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组不是指针。*'
- en: '|  |'
  id: totrans-1282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Later, we will see how these two concepts relate, but for the moment it is important
    to read this chapter without prejudice about arrays; otherwise, you will delay
    your ascent to a better understanding of C.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将看到这两个概念是如何相互关联的，但此刻重要的是要无偏见地阅读本章关于数组的内容；否则，你将推迟你对 C 语言更好理解的提升。
- en: 6.1.1\. Array declaration
  id: totrans-1284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 数组声明
- en: 'We have already seen how arrays are declared: by placing something like *`[`**N`]`
    after* another declaration. For example:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何声明数组：通过在另一个声明后放置类似 *`[`**N`]`* 的内容。例如：
- en: '[PRE79]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here, a comprises 4 subobjects of type **`double`** and b comprises N of type
    **`signed`**. We visualize arrays with diagrams like the following, with a sequence
    of boxes of their base type:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，a 包含 4 个类型为 **`double`** 的子对象，而 b 包含 N 个类型为 **`signed`** 的对象。我们用以下这样的图表来可视化数组，其中包含一系列其基本类型的框：
- en: '![](pg_082_alt.jpg)'
  id: totrans-1288
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_082_alt.jpg)'
- en: The dots *…* here indicate that there may be an unknown number of similar items
    between the two boxes.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的点号 *…* 表示两个框之间可能存在未知数量的类似项。
- en: 'The type that composes an array may itself again be an array, forming a *multidimensional
    array**^C*. The declarations for those become a bit more difficult to read since
    `[]` binds to the left. The following two declarations declare variables of exactly
    the same type:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 组成数组的类型本身又可以是数组，形成 *多维数组**^C*。由于 `[]` 左结合，这些声明的可读性变得有点困难。以下两个声明声明了完全相同类型的变量：
- en: '[PRE80]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Both C and D are M objects of array type **`double`**`[`N`]`. This means we
    have to read a nested array declaration from inside out to describe its structure:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: C和D都是数组类型的M对象**`double`**`[`N`]`。这意味着我们必须从内向外读取嵌套数组声明来描述其结构：
- en: '![](pg_083_alt.jpg)'
  id: totrans-1293
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_083_alt.jpg)'
- en: We also have seen how array elements are accessed and initialized, again with
    a pair of `[]`. In the previous example, `a[0]` is an object of **`double`** and
    can be used wherever we want to use, for example, a simple variable. As we have
    seen, `C[0]` is itself an array, so `C[0][0]`, which is the same as `(`C`[0])[0]`,
    is also an object of type **`double`**.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何通过一对`[]`访问和初始化数组元素，在先前的例子中，`a[0]`是一个**`double`**类型的对象，可以在我们想要使用的地方使用，例如，一个简单的变量。正如我们所看到的，`C[0]`本身是一个数组，所以`C[0][0]`，它与`(C[0])[0]`相同，也是一个**`double`**类型的对象。
- en: Initializers can use *designated initializers* (also using `[]` notation) to
    pick the specific position to which an initialization applies. The example code
    in [listing 5.1](kindle_split_013.html#ch05ex01) contains such initializers. During
    development, designated initializers help to make our code robust against small
    changes in array sizes or positions.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器可以使用*指定初始化器*（也使用`[]`表示法）来选择初始化应用的具体位置。示例代码[列表5.1](kindle_split_013.html#ch05ex01)中包含这样的初始化器。在开发过程中，指定初始化器有助于使我们的代码能够抵御数组大小或位置的小变化。
- en: 6.1.2\. Array operations
  id: totrans-1296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 数组操作
- en: Arrays are really just objects of a different type than we have seen so far.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 数组实际上只是与我们之前看到的类型不同的对象。
- en: '|  |'
  id: totrans-1298
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.2
  id: totrans-1299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.2
- en: '*An array in a condition evaluates to* **`true`***.*'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组在条件中的评估结果为* **`true`***。'
- en: '|  |'
  id: totrans-1301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The truth of that comes from the *array decay* operation, which we will see
    later. Another important property is that we can’t evaluate arrays like other
    objects.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实来自于*数组降级*操作，我们将在后面看到。另一个重要的特性是我们不能像其他对象一样评估数组。
- en: '|  |'
  id: totrans-1303
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.3
  id: totrans-1304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.3
- en: '*There are array objects but no array values.*'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '*存在数组对象，但没有数组值。*'
- en: '|  |'
  id: totrans-1306
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So arrays can’t be operands for the value operators in [table 4.1](kindle_split_012.html#ch04table01),
    and there is no arithmetic declared on arrays (themselves).
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 所以数组不能作为[表4.1](kindle_split_012.html#ch04table01)中值运算符的操作数，也没有在数组（自身）上声明算术运算。
- en: '|  |'
  id: totrans-1308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.4
  id: totrans-1309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.4
- en: '*Arrays can’t be compared.*'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组不能进行比较。*'
- en: '|  |'
  id: totrans-1311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Arrays also can’t be on the value side of the object operators in [table 4.2](kindle_split_012.html#ch04table02).
    Most of the object operators are likewise ruled out from having arrays as object
    operands, either because they assume arithmetic or because they have a second
    value operand that would have to be an array, too.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也不能出现在[表4.2](kindle_split_012.html#ch04table02)中对象运算符的值的一侧。大多数对象运算符同样被排除在外，不能将数组作为对象操作数，要么是因为它们假设了算术运算，要么是因为它们有第二个值操作数，这个操作数也必须是数组。
- en: '|  |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.5
  id: totrans-1314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.5
- en: '*Arrays can’t be assigned to.*'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组不能被赋值。*'
- en: '|  |'
  id: totrans-1316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: From [table 4.2](kindle_split_012.html#ch04table02), we also know that there
    are only four operators left that work on arrays as object operators. And we know
    the operator `[]`.^([[1](#ch06fn01)]) The *array decay* operation, the address
    operator `&`, and the **`sizeof`** operator will be introduced later.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 从[表4.2](kindle_split_012.html#ch04table02)中，我们还知道只剩下四个运算符可以作用于数组作为对象运算符。我们知道运算符`[]`。^([[1](#ch06fn01)])
    将在后面介绍*数组降级*操作、地址运算符`&`和**`sizeof`**运算符。
- en: ¹
  id: totrans-1318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The real C jargon story about arrays and `[]` is a bit more complicated. Let
    us apply the **as-if** Rule ([takeaway 5.8](kindle_split_013.html#ch05note08))
    to our explanation. All C programs behave *as if* the `[]` are directly applied
    to an array object.
  id: totrans-1320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于数组和`[]`的真正C语言术语故事要复杂一些。让我们将**as-if**规则([总结5.8](kindle_split_013.html#ch05note08))应用到我们的解释中。所有C程序都表现得*好像*`[]`是直接应用于数组对象。
- en: 6.1.3\. Array length
  id: totrans-1321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 数组长度
- en: 'There are two categories of arrays: *fixed-length arrays**^C* (FLAs) and *variable-length
    arrays**^C* (VLAs). The first are a concept that has been present in C since the
    beginning; this feature is shared with many other programming languages. The second
    was introduced in C99 and is relatively unique to C, and it has some restrictions
    on its usage.'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 数组分为两类：*固定长度数组**^C*（FLAs）和*可变长度数组**^C*（VLAs）。前者是C语言从开始就存在的概念；这个特性与其他许多编程语言共享。后者是在C99中引入的，并且相对而言是C语言特有的，并且对其使用有一些限制。
- en: '|  |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.6
  id: totrans-1324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.6
- en: '*VLAs can’t have initializers.*'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '*VLAs不能有初始化器。*'
- en: '|  |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1327
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.7
  id: totrans-1328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.7
- en: '*VLAs can’t be declared outside functions.*'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: '*VLAs不能在函数外部声明。*'
- en: '|  |'
  id: totrans-1330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So let’s start at the other end and see which arrays are in fact FLAs, such
    that they don’t fall under these restrictions.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从另一端开始，看看哪些数组实际上是 FLA，这样它们就不会受到这些限制。
- en: '|  |'
  id: totrans-1332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.8
  id: totrans-1333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.8
- en: '*The length of an FLA is determined by an integer constant expression (ICE)
    or by an initializer.*'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '*FLA 的长度由一个整数常量表达式 (ICE) 或初始化器确定。*'
- en: '|  |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For the first of these alternatives, the length is known at compile time through
    an ICE (introduced in [section 5.6.2](kindle_split_013.html#ch05lev2sec7)). There
    is no type restriction for the ICE: any integer type will do.'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些选择中的第一个，长度在编译时通过 ICE（在 [第 5.6.2 节](kindle_split_013.html#ch05lev2sec7) 中介绍）是已知的。对于
    ICE 没有类型限制：任何整数类型都可以。
- en: '|  |'
  id: totrans-1337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.9
  id: totrans-1338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.9
- en: '*An array-length specification must be strictly positive.*'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组长度指定必须是严格正数。*'
- en: '|  |'
  id: totrans-1340
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Another important special case leads to an FLA: when there is no length specification
    at all. If the `[]` are left empty, the length of the array is determined from
    its initializer, if any:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的特殊情况会导致 FLA：当没有任何长度指定时。如果 `[]` 被留空，数组的长度将根据其初始化器（如果有）确定：
- en: '[PRE81]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, E and F both are of type **`double`**`[4]`. Since such an initializer’s
    structure can always be determined at compile time without necessarily knowing
    the values of the items, the array is still an FLA.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，E 和 F 都属于类型 **`double`**`[4]`。由于这种初始化器的结构可以在编译时确定，而不必知道项目值，因此数组仍然是 FLA。
- en: '![](pg_084_alt.jpg)'
  id: totrans-1344
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_084_alt.jpg)'
- en: All other array variable declarations lead to VLAs.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他数组变量声明都会导致 VLAs。
- en: '|  |'
  id: totrans-1346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.10
  id: totrans-1347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.10
- en: '*An array with a length that is not an integer constant expression is a VLA.*'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '*长度不是整数常量表达式的数组是 VLA。*'
- en: '|  |'
  id: totrans-1349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The length of an array can be computed with the **`sizeof`** operator. That
    operator provides the size of any object,^([[2](#ch06fn02)]) so the length of
    an array can be calculated using simple division.^([[3](#ch06fn03)])
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度可以使用 **`sizeof`** 运算符计算。该运算符提供了任何对象的大小，^([[2](#ch06fn02)]) 因此可以使用简单的除法计算数组的长度.^([[3](#ch06fn03)])
- en: ²
  id: totrans-1351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Later, we will see what the unit of measure for such sizes is.
  id: totrans-1353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 之后，我们将看到这些大小的度量单位是什么。
- en: ³
  id: totrans-1354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note also that the **`sizeof`** operator comes in two different syntactical
    forms. If applied to an object, as it is here, it does not need parentheses, but
    they would be needed if we applied it to a type.
  id: totrans-1356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，**`sizeof`** 运算符有两种不同的语法形式。如果应用于对象，如这里所示，它不需要括号，但如果我们将其应用于类型，则需要括号。
- en: '|  |'
  id: totrans-1357
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.11
  id: totrans-1358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.11
- en: '*The length of an array* *`A`* *is* *`(`***`sizeof`** *`A)/(`***`sizeof`**
    *`A[0])`**.*'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组 *`A`* 的长度是 *`(`***`sizeof`** *`A)/(`***`sizeof`** *`A[0])`**.*'
- en: '|  |'
  id: totrans-1360
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That is, it is the total size of the array object, divided by the size of any
    of the array elements.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 即，它是数组对象的总大小除以数组元素的大小。
- en: 6.1.4\. Arrays as parameters
  id: totrans-1362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. 数组作为参数
- en: Yet another special case occurs for arrays as parameters to functions. As we
    saw for the prototype of **printf**, such parameters may have empty `[]`. Since
    no initializer is possible for such a parameter, the array dimension can’t be
    determined.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组作为函数参数的情况，还有一个特殊情况。正如我们在 **printf** 原型中看到的那样，这些参数可能有空的 `[]`。由于此类参数不可能有初始化器，因此无法确定数组维度。
- en: '|  |'
  id: totrans-1364
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.12
  id: totrans-1365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.12
- en: '*The innermost dimension of an array parameter to a function is lost.*'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数数组参数的内维丢失。*'
- en: '|  |'
  id: totrans-1367
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1368
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.13
  id: totrans-1369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.13
- en: '*Don’t use the* **`sizeof`** *operator on array parameters to functions.*'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要在数组参数上使用* **`sizeof`** *运算符传递给函数。*'
- en: '|  |'
  id: totrans-1371
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Array parameters are even more bizarre, because we cannot produce *array values*
    ([takeaway 6.3](#ch06note03)), array parameters cannot be passed by value, and
    thus array parameters as such would not make much sense.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 数组参数甚至更加奇特，因为我们不能产生 *数组值* ([总结 6.3](#ch06note03))，数组参数不能按值传递，因此作为这样的数组参数就没有太多意义。
- en: '|  |'
  id: totrans-1373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.14
  id: totrans-1374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.14
- en: '*Array parameters behave* as if *the array is* *passed by reference**^C**.*'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组参数的行为*就像*数组是* *通过引用传递**^C**.*'
- en: '|  |'
  id: totrans-1376
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Take the example shown in [listing 6.1](#ch06ex01).
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 以 [列表 6.1](#ch06ex01) 中的示例为例。
- en: Listing 6.1\. A function with an array parameter
  id: totrans-1378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 带有数组参数的函数
- en: '[PRE82]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, swap_double`(`A`)` will act directly on array A and not on a copy. Therefore,
    the program will swap the values of the two elements of A.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，swap_double`(`A`)` 将直接作用于数组 A，而不是副本。因此，程序将交换 A 的两个元素的值。
- en: '|  |'
  id: totrans-1381
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Linear algebra**'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性代数**'
- en: Some of the most important problems for which arrays are used stem from linear
    algebra.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 数组用于解决的一些最重要的问题源于线性代数。
- en: Can you write functions that do vector-to-vector or matrix-to-vector products
    at this point?
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在能编写执行向量到向量或矩阵到向量乘积的函数吗？
- en: What about Gauß elimination or iterative algorithms for matrix inversion?
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 关于高斯消元法或矩阵求逆的迭代算法呢？
- en: '|  |'
  id: totrans-1386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1.5\. Strings are special
  id: totrans-1387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.5\. 字符串是特殊的
- en: 'There is a special kind of array that we have encountered several times and
    that, in contrast to other arrays, even has literals: *strings**^C*.'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到过一种特殊的数组，它与其他数组不同，甚至有字面量：*字符串**^C*。
- en: '|  |'
  id: totrans-1389
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.15
  id: totrans-1390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 6.15
- en: '*A string is a* *`0`**-terminated array of* **`char`***.*'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串是一个* *`0`**-终止的 **`char`*** 数组。'
- en: '|  |'
  id: totrans-1392
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That is, a string like "hello" always has one more element than is visible,
    which contains the value 0, so here the array has length 6.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，像 "hello" 这样的字符串总是比可见的元素多一个，它包含值 0，所以这里的数组长度为 6。
- en: 'Like all arrays, strings can’t be assigned to, but they can be initialized
    from string literals:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有数组一样，字符串不能被赋值，但可以从字符串字面量初始化：
- en: '[PRE83]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: These are all equivalent declarations. Be aware that not all arrays of **`char`**
    are strings, such as
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是等效的声明。请注意，并非所有 **`char`** 数组都是字符串，例如
- en: '[PRE84]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These both cut off after the 'y' character and so are not `0`-terminated.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都在 'y' 字符后截断，因此不是 `0`-终止的。
- en: '![](pg_086_alt.jpg)'
  id: totrans-1399
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_086_alt.jpg)'
- en: We briefly saw the base type **`char`** of strings among the integer types.
    It is a narrow integer type that can be used to encode all characters of the *basic
    character set**^C*. This character set contains all the characters of the Latin
    alphabet, Arabic digits, and punctuation characters that we use for coding in
    C. It usually doesn’t contain special characters (for example, *ä*, *á*), and
    characters from completely different writing systems).
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地看到了字符串在整数类型中的基本类型 **`char`**。它是一种窄整数类型，可以用来编码所有 *基本字符集**^C* 中的字符。这个字符集包含了拉丁字母、阿拉伯数字以及我们在
    C 语言中使用的标点符号。它通常不包含特殊字符（例如，*ä*，*á*），以及来自完全不同的书写系统的字符）。
- en: 'The vast majority of platforms nowadays use American Standard Code for Information
    Interchange (ASCII) to encode characters in the type **`char`**. We don’t have
    to know how the particular encoding works as long as we stay in the basic character
    set: everything is done in C and its standard library, which use this encoding
    transparently.'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，绝大多数平台使用美国信息交换标准代码（ASCII）来编码 **`char`** 类型的字符。只要我们停留在基本字符集，我们就不必了解特定的编码方式：所有操作都在
    C 语言及其标准库中完成，这些库透明地使用这种编码。
- en: '|  |'
  id: totrans-1402
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<string.h>`'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '`<string.h>`'
- en: '|  |'
  id: totrans-1404
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To deal with **`char`** arrays and strings, there are a bunch of functions in
    the standard library that come with the header `string.h`. Those that just require
    an array argument start their names with mem, and those that in addition require
    that their arguments are strings start with str. [Listing 6.2](#ch06ex02) uses
    some of the functions that are described next.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 **`char`** 数组和字符串，标准库中提供了一系列函数，这些函数包含在头文件 `string.h` 中。那些只需要数组参数的函数以 mem
    开头命名，而那些除了需要数组参数外还需要参数是字符串的函数以 str 开头命名。[列表 6.2](#ch06ex02) 使用了一些接下来将要描述的函数。
- en: Listing 6.2\. Using some of the string functions
  id: totrans-1406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 使用一些字符串函数
- en: '[PRE85]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Functions that operate on **`char`** arrays are as follows:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 操作 **`char`** 数组的函数如下：
- en: '**memcpy**`(`target, source, len) can be used to copy one array to another.
    These have to be known to be distinct arrays. The number of **`char`** s to be
    copied must be given as a third argument len.'
  id: totrans-1409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**memcpy**`(`target, source, len) 可以用来将一个数组复制到另一个数组。这些数组必须是不同的数组。要复制的 **`char`**
    字符数必须作为第三个参数 len 提供。'
- en: '**memcmp**`(`s0, s1, len) compares two arrays in lexicographic order. That
    is, it first scans the initial segments of the two arrays that happen to be equal
    and then returns the difference between the two first characters that are distinct.
    If no differing elements are found up to len, `0` is returned.'
  id: totrans-1410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**memcmp**`(`s0, s1, len) 按字典顺序比较两个数组。也就是说，它首先扫描两个数组中恰好相等的初始段，然后返回两个不同第一个字符之间的差异。如果在
    len 范围内没有找到不同的元素，则返回 `0`。'
- en: '**memchr**(s, c, len) searches array s for the appearance of character c.'
  id: totrans-1411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**memchr**(s, c, len) 在数组 s 中搜索字符 c 的出现。'
- en: 'Next are the string functions:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是字符串函数：
- en: '**strlen**`(`s`)` returns the length of the string s. This is simply the position
    of the first `0` character and *not* the length of the array. It is your duty
    to ensure that s is indeed a string: that it is `0`-terminated.'
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strlen**`(`s`)` 返回字符串 s 的长度。这仅仅是第一个 `0` 字符的位置，而不是数组的长度。确保 s 确实是一个字符串：它是 `0`-终止的。'
- en: '**strcpy**`(`target`,` source) works similarly to **memcpy**. It only copies
    up to the string length of the source, and therefore it doesn’t need a len parameter.
    Again, source must be `0`-terminated. Also, target must be big enough to hold
    the copy.'
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strcpy**`(`target`,` source)` 与 **memcpy** 的工作方式类似。它只复制源字符串的长度，因此不需要 len
    参数。再次强调，源必须以 `0` 结尾。此外，目标必须足够大，可以容纳复制的内容。'
- en: '**strcmp**`(`s0`,` s1`)` compares two arrays in lexicographic order, similarly
    to **memcmp**, but may not take some language specialties into account. The comparison
    stops at the first `0` character that is encountered in either s0 or s1. Again,
    both parameters have to be `0`-terminated.'
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strcmp**`(`s0`,` s1`)` 按字典顺序比较两个数组，类似于 **memcmp**，但可能不会考虑某些语言特性。比较在 s0 或
    s1 中遇到的第一个 `0` 字符处停止。再次强调，两个参数都必须以 `0` 结尾。'
- en: '**strcoll**`(`s0`,` s1`)` compares two arrays in lexicographic order, respecting
    language-specific environment settings. We will learn how to properly set this
    in [section 8.6](kindle_split_017.html#ch08lev1sec6).'
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strcoll**`(`s0`,` s1`)` 按字典顺序比较两个数组，并尊重语言特定的环境设置。我们将在第 8.6 节中学习如何正确设置它[section
    8.6](kindle_split_017.html#ch08lev1sec6)。'
- en: '**strchr**`(`s`,` c`)` is similar to **memchr**, only the string s must be
    `0`-terminated.'
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strchr**`(`s`,` c`)` 与 **memchr** 类似，只是字符串 s 必须以 `0` 结尾。'
- en: '**strspn**`(`s0`,` s1`)` returns the length of the initial segment in s0 that
    consists of characters that also appear in s1.'
  id: totrans-1418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strspn**`(`s0`,` s1`)` 返回 s0 中由 s1 中也出现的字符组成的初始段长度。'
- en: '**strcspn**`(`s0`,` s1`)` returns the length of the initial segment in s0 that
    consists of characters that do not appear in s1.'
  id: totrans-1419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strcspn**`(`s0`,` s1`)` 返回 s0 中由 s1 中不出现的字符组成的初始段长度。'
- en: '|  |'
  id: totrans-1420
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.16
  id: totrans-1421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 6.16
- en: '*Using a string function with a non-string has undefined behavior.*'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用非字符串的字符串函数会有未定义的行为.*'
- en: '|  |'
  id: totrans-1423
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In real life, common symptoms for such misuse may be:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，此类误用的常见症状可能包括：
- en: Long times for **strlen** or similar scanning functions because they don’t encounter
    a `0`-character
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 **strlen** 或类似扫描函数没有遇到 `0` 字符，所以运行时间较长
- en: Segmentation violations because such functions try to access elements after
    the boundary of the array object
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于此类函数尝试访问数组对象边界之外的元素，会发生段错误
- en: Seemingly random corruption of data because the functions write data in places
    where they are not supposed to
  id: totrans-1427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据似乎随机损坏，因为函数在它们不应该写入数据的地方写入数据
- en: In other words, be careful, and make sure all your strings really are strings.
    If you know the length of the character array, but you do not know if it is 0-terminated,
    **memchr** and pointer arithmetic (see [chapter 11](kindle_split_021.html#ch11))
    can be used as a safe replacement for **strlen**. Analogously, if a character
    array is not known to be a string, it is better to copy it by using **memcpy**.^([[[Exs
    1]](#ch06fn-ex01)])
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，要小心谨慎，确保所有字符串确实都是字符串。如果你知道字符数组的长度，但不知道它是否以 0 结尾，可以使用 **memchr** 和指针算术（见第
    11 章）作为 **strlen** 的安全替代品。类似地，如果一个字符数组不是字符串，最好使用 **memcpy** 来复制它.^([[[Exs 1]](#ch06fn-ex01)])
- en: ^([Exs 1])
  id: totrans-1429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-1430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use **memchr** and **memcmp** to implement a bounds-checking version of **strcmp**.
  id: totrans-1431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 **memchr** 和 **memcmp** 来实现一个带有边界检查的 **strcmp** 版本。
- en: 'In the discussion so far, I have been hiding an important detail from you:
    the prototypes of the functions. For the string functions, they can be written
    as'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 在到目前为止的讨论中，我一直隐瞒了一个重要的细节：函数的原型。对于字符串函数，它们可以写成
- en: '[PRE86]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Other than the bizarre return type of **strcpy** and **strchr**, this looks
    reasonable. The parameter arrays are arrays of unknown length, so the `[`**`static`**
    `1]`s correspond to arrays of at least one **`char`**. **strlen**, **strspn**,
    and **strcspn** will return a size, and **strcmp** will return a negative, 0,
    or positive value according to the sort order of the arguments.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **strcpy** 和 **strchr** 的奇特返回类型外，这看起来是合理的。参数数组是未知长度的数组，所以 `[`**`static`**
    `1]`s 对应于至少包含一个 **`char`** 的数组。**strlen**、**strspn** 和 **strcspn** 将返回一个大小，而 **strcmp**
    将根据参数的排序顺序返回负值、0 或正值。
- en: 'The picture darkens when we look at the declarations of the array functions:'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看数组函数的声明时，画面变暗了：
- en: '[PRE87]'
  id: totrans-1436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You are missing knowledge about entities that are specified as **`void`**`*`.
    These are *pointers* to objects of unknown type. It is only in [level 2](kindle_split_018.html#part02),
    [chapter 11](kindle_split_021.html#ch11), that we will see why and how these new
    concepts of pointers and **`void`** type occur.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 你缺少关于指定为**`void`**`*`的实体的知识。这些是指向未知类型对象的指针。只有在[第2级](kindle_split_018.html#part02)、[第11章](kindle_split_021.html#ch11)中，我们才会看到为什么以及如何出现这些关于指针和**`void`**类型的新概念。
- en: '|  |'
  id: totrans-1438
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Adjacency matrix**'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '**邻接矩阵**'
- en: The adjacency matrix of a graph *G* is a matrix A that holds a value **`true`**
    or **`false`** in element A`[`i`][`j`]` if there is an arc from node i to node
    j.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *G* 的邻接矩阵是一个矩阵 A，它在元素 A`[`i`][`j`]`中持有值 **`true`** 或 **`false`**，如果从节点 i 到节点
    j 有弧。
- en: At this point, can you use an adjacency matrix to conduct a breadth-first search
    in a graph *G*? Can you find connected components? Can you find a spanning tree?
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你能否使用邻接矩阵在图 *G* 中进行广度优先搜索？你能找到连通分量吗？你能找到生成树吗？
- en: '|  |'
  id: totrans-1442
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1443
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Shortest path**'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '**最短路径**'
- en: Extend the idea of an adjacency matrix of a graph *G* to a distance matrix D
    that holds the distance when going from point i to point j. Mark the absence of
    a direct arc with a very large value, such as **`SIZE_MAX`**.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 将图 *G* 的邻接矩阵的概念扩展到距离矩阵 D，该矩阵在从点 i 到点 j 的距离时持有。用非常大的值，例如**`SIZE_MAX`**标记直接弧的缺失。
- en: Can you find the shortest path between two nodes x and y given as an input?
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否找到作为输入的两个节点 x 和 y 之间的最短路径？
- en: '|  |'
  id: totrans-1447
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.2\. Pointers as opaque types
  id: totrans-1448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 指针作为不透明类型
- en: 'We now have seen the concept of pointers pop up in several places, in particular
    as a **`void`**`*` argument and return type, and as **`char const`**`*`**`const`**
    to manipulate references to string literals. Their main property is that they
    do not directly contain the information that we are interested in: rather, they
    refer, or *point*, to the data. C’s syntax for pointers always has the peculiar
    `*`:'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到指针的概念在几个地方出现，特别是在作为 **`void`**`*` 参数和返回类型，以及作为 **`char const`**`*`**`const`**
    来操作字符串字面量的引用。它们的主要属性是它们不直接包含我们感兴趣的信息：相反，它们引用，或 *指向* 数据。C 语言中指针的语法总是具有奇特的 `*`：
- en: '[PRE88]'
  id: totrans-1450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'It can be visualized like this:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以像这样可视化：
- en: '![](pg_089-01.jpg)'
  id: totrans-1452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_089-01.jpg)'
- en: 'Compare this to the earlier array jay0, which itself contains all the characters
    of the string that we want it to represent:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与之前包含我们想要表示的字符串所有字符的数组 jay0 进行比较：
- en: '[PRE89]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '![](pg_089-02_alt.jpg)'
  id: totrans-1455
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_089-02_alt.jpg)'
- en: In this first exploration, we only need to know some simple properties of pointers.
    The binary representation of a pointer is completely up to the platform and is
    not our business.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次探索中，我们只需要了解指针的一些简单属性。指针的二进制表示完全取决于平台，与我们无关。
- en: '|  |'
  id: totrans-1457
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.17
  id: totrans-1458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得第6.17条经验教训
- en: '*Pointers are opaque objects.*'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针是不透明的对象*。'
- en: '|  |'
  id: totrans-1460
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This means we will only be able to deal with pointers through the operations
    that the C language allows for them. As I said, most of these operations will
    be introduced later; in our first attempt, we will only need initialization, assignment,
    and evaluation.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们只能通过 C 语言允许的操作来处理指针。正如我所说，大部分这些操作将在以后介绍；在我们的第一次尝试中，我们只需要初始化、赋值和评估。
- en: One particular property of pointers that distinguishes them from other variables
    is their state.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的一个特定属性，使其与其他变量区分开来的是其状态。
- en: '|  |'
  id: totrans-1463
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.18
  id: totrans-1464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得第6.18条经验教训
- en: '*Pointers are valid, null, or indeterminate.*'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针是有效的、空或不确定的*。'
- en: '|  |'
  id: totrans-1466
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For example, our variable p2string is always valid, because it points to the
    string literal "some text", and, because of the second **`const`**, this association
    can never be changed.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的变量 p2string 总是有效的，因为它指向字符串字面量 "some text"，并且由于第二个 **`const`**，这种关联永远不能改变。
- en: The null state of any pointer type corresponds to our old friend `0`, sometimes
    known under its pseudonym **`false`**.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 任何指针类型的空状态对应于我们熟悉的老朋友 `0`，有时也被称为其别名 **`false`**。
- en: '|  |'
  id: totrans-1469
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.19
  id: totrans-1470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得第6.19条经验教训
- en: '*Initialization or assignment with* *`0`* *makes a pointer null.*'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用 *`0`* 进行初始化或赋值使指针变为空*。'
- en: '|  |'
  id: totrans-1472
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Take the following as an example:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下内容为例：
- en: '[PRE90]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We visualize this special situation like this:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像这样可视化这种特殊情况：
- en: '![](pg_090-01.jpg)'
  id: totrans-1476
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_090-01.jpg)'
- en: 'Note that this is different from pointing to an empty string:'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与指向空字符串不同：
- en: '[PRE91]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '![](pg_090-02.jpg)'
  id: totrans-1479
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_090-02.jpg)'
- en: Usually, we refer to a pointer in the null state as a *null pointer**^C*. Surprisingly,
    disposing of null pointers is really a feature.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将处于空状态的指针称为 *空指针**^C*。令人惊讶的是，处理空指针实际上是一个特性。
- en: '|  |'
  id: totrans-1481
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.20
  id: totrans-1482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点6.20
- en: '*In logical expressions, pointers evaluate to* **`false`** *if they are null.*'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: '*在逻辑表达式中，指针如果为null，则评估为**`false`**。*'
- en: '|  |'
  id: totrans-1484
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note that such tests can’t distinguish valid pointers from indeterminate ones.
    So, the really “bad” state of a pointer is indeterminate, since this state is
    not observable.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这样的测试无法区分有效的指针和不确定的指针。所以，指针的“真正”的“坏”状态是不确定的，因为这种状态是不可观察的。
- en: '|  |'
  id: totrans-1486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.21
  id: totrans-1487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点6.21
- en: '*Indeterminate pointers lead to undefined behavior.*'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '*不确定的指针会导致未定义的行为。*'
- en: '|  |'
  id: totrans-1489
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'An example of an indeterminate pointer could look like this:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不确定指针的例子可能如下所示：
- en: '[PRE92]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '![](pg_090-03.jpg)'
  id: totrans-1492
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_090-03.jpg)'
- en: Because it is uninitialized, its state is indeterminate, and any use of it would
    do you harm and leave your program in an undefined state ([takeaway 5.55](kindle_split_013.html#ch05note59)).
    Thus, if we can’t ensure that a pointer is valid, we *must* at least ensure that
    it is set to null.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它未初始化，其状态是不确定的，任何使用它都会对你造成伤害，并使你的程序处于未定义状态（[要点5.55](kindle_split_013.html#ch05note59)）。因此，如果我们不能确保指针是有效的，我们**必须**至少确保它被设置为null。
- en: '|  |'
  id: totrans-1494
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 6.22
  id: totrans-1495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点6.22
- en: '*Always initialize pointers.*'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '*始终初始化指针。*'
- en: '|  |'
  id: totrans-1497
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.3\. Structures
  id: totrans-1498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3. 结构体
- en: As we have seen, arrays combine several objects of the same base type into a
    larger object. This makes perfect sense where we want to combine information for
    which the notion of a first, second . . . element is acceptable. If it is not,
    or if we have to combine objects of different type, then *structures*, introduced
    by the keyword **`struct`** come into play.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，数组将相同基类型的多个对象组合成更大的对象。在我们想要组合具有第一、第二……元素概念的信息时，这完全合理。如果这不是情况，或者如果我们必须组合不同类型的对象，那么通过关键字**`struct`**引入的**结构体**就派上用场了。
- en: 'As a first example, let us revisit the corvids from [section 5.6.2](kindle_split_013.html#ch05lev2sec7).
    There, we used a trick with an enumeration type to keep track of our interpretation
    of the individual elements of an array name. C structures allow for a more systematic
    approach by giving names to so-called *members* (or *field*) in an aggregate:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，让我们回顾一下[第5.6.2节](kindle_split_013.html#ch05lev2sec7)中的乌鸦。在那里，我们使用枚举类型的一个技巧来跟踪我们对数组名称各个元素的解释。C结构体通过为聚合中的所谓**成员**（或**字段**）命名，提供了一种更系统的方法：
- en: '[PRE93]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: That is, from line 1 to 6, we have the declaration of a new type, denoted as
    **`struct`** birdStruct. This structure has four *members**^C*, whose declarations
    look exactly like normal variable declarations. So instead of declaring four elements
    that are bound together in an array, here we name the different members and declare
    types for them. Such declaration of a structure type only explains the type; it
    is not (yet) the declaration of an object of that type and even less a definition
    for such an object.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 即，从第1行到第6行，我们有新类型的声明，表示为**`struct`** birdStruct。这个结构体有四个**成员**，其声明看起来与正常的变量声明完全一样。所以，我们不是声明四个绑定在一起数组的元素，而是为不同的成员命名并声明它们的类型。这种结构体类型的声明只解释了类型；它还不是该类型对象的声明，更不是该对象的定义。
- en: 'Then, starting on line 7, we declare and define a variable (called aName) of
    the new type. In the initializer and in later usage, the individual members are
    designated using a notation with a dot (`.`). Instead of bir`d[`raven`]`, as in
    [section 5.6.1](kindle_split_013.html#ch05lev2sec6), for the array we use aName`.`raven
    for the structure:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从第7行开始，我们声明并定义了一个新类型的变量（称为aName）。在初始化和后续使用中，使用带点的符号（`.`）指定各个成员。与[第5.6.1节](kindle_split_013.html#ch05lev2sec6)中的`bird[raven]`不同，对于数组，我们使用`aName.raven`来表示结构体：
- en: '![](pg_091_alt.jpg)'
  id: totrans-1504
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_091_alt.jpg)'
- en: Please note that in this example, the individual members again only *refer*
    to the strings. For example, the member aName`.`magpie refers to an entity "Frau"
    that is located outside the box and is not considered part of the **`struct`**
    itself.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，各个成员再次只**引用**字符串。例如，成员`aName.magpie`引用一个位于盒子外部的实体“Frau”，并且不被认为是**`struct`**本身的一部分。
- en: 'Now, for a second example, let us look at a way to organize time stamps. Calendar
    time is a complicated way of counting, in years, month, days, minutes, and seconds;
    the different time periods such as months or years can have different lengths,
    and so on. One possible way to organize such data could be an array:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为第二个例子，让我们看看组织时间戳的方法。日历时间是一种复杂的计数方式，按年、月、日、分和秒计算；不同的时间段，如月份或年份，可以有不同长度，等等。组织此类数据的一种可能方式是数组：
- en: '[PRE94]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '![](pg_092_alt.jpg)'
  id: totrans-1508
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_092_alt.jpg)'
- en: 'The use of this array type would be ambiguous: would we store the year in element
    `[0]` or `[5]`? To avoid ambiguities, we could again use our trick with an **`enum`**.
    But the C standard has chosen a different way. In `time.h`, it uses a **`struct`**
    that looks similar to the following:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种数组类型将是不明确的：我们会将年份存储在元素 `[0]` 还是 `[5]` 中？为了避免歧义，我们还可以再次使用我们的技巧，使用 **`enum`**。但
    C 标准选择了不同的方法。在 `time.h` 中，它使用了一个看起来类似的 **`struct`**：
- en: '|  |'
  id: totrans-1510
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<time.h>`'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '`<time.h>`'
- en: '|  |'
  id: totrans-1512
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE95]'
  id: totrans-1513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This **`struct`** has *named members*, such as **`tm_sec`** for the seconds
    and **`tm_year`** for the year. Encoding a date, such as the date of this writing
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 **`struct`** 有 *命名成员*，例如 **`tm_sec`** 用于秒和 **`tm_year`** 用于年。编码日期，例如本文写作的日期
- en: '`Terminal`'
  id: totrans-1515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE96]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'is relatively simple:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 这相对简单：
- en: '**`yday.c`**'
  id: totrans-1518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`yday.c`**'
- en: '[PRE97]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This creates a variable of type **`struct`** **`tm`** and initializes its members
    with the appropriate values. The order or position of the members in the structure
    usually is not important: using the name of the member preceded with a dot `.`
    suffices to specify where the corresponding data should go.'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个类型为 **`struct`** **`tm`** 的变量，并使用适当的值初始化其成员。结构体中成员的顺序或位置通常并不重要：使用带点`.`的前缀成员名称就足以指定相应数据应该放置的位置。
- en: '![](pg_093_alt.jpg)'
  id: totrans-1521
  prefs: []
  type: TYPE_IMG
  zh: '![pg_093_alt.jpg](pg_093_alt.jpg)'
- en: Note that this visualization of today has an extra “box” compared to calArray.
    Indeed, a proper **`struct`** type creates an additional level of abstraction.
    This **`struct`** **`tm`** is a proper type in C’s type system.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 calArray 相比，这种对今天的可视化有一个额外的“框”。实际上，一个合适的 **`struct`** 类型创建了一个额外的抽象级别。这个
    **`struct`** **`tm`** 是 C 类型系统中的一个合适类型。
- en: 'Accessing the members of the structure is just as simple and has similar *`.`*
    syntax:'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 访问结构体的成员就像这样简单，并且具有类似的 *`.`* 语法：
- en: '**`yday.c`**'
  id: totrans-1524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`yday.c`**'
- en: '[PRE98]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: A reference to a member such as toda`y.`**`tm_year`** can appear in an expression
    just like any variable of the same base type.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成员的引用，如 toda`y.`**`tm_year`**，可以出现在表达式中，就像任何相同基类型的变量一样。
- en: 'There are three other members in **`struct`** **`tm`** that we didn’t even
    mention in our initializer list: **`tm_wday`**, **`tm_yday`**, and **`tm_isdst`**.
    Since we didn’t mention them, they are automatically set to `0`.'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **`struct`** **`tm`** 中还有三个我们甚至没有在初始化器列表中提到的成员：**`tm_wday`**、**`tm_yday`**
    和 **`tm_isdst`**。由于我们没有提到它们，它们被自动设置为 `0`。
- en: '|  |'
  id: totrans-1528
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.23
  id: totrans-1529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 6.23
- en: '*Omitted* **`struct`** *initializers force the corresponding member to* *`0`**.*'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '*省略* **`struct`** *初始化器将相应的成员强制设置为* *`0`**。'
- en: '|  |'
  id: totrans-1531
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This can even go to the extreme that all but one of the members are initialized.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况甚至可以极端到除了一个成员外，所有成员都被初始化。
- en: '|  |'
  id: totrans-1533
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.24
  id: totrans-1534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 6.24
- en: '*A* **`struct`** *initializer must initialize at least one member.*'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个* **`struct`** *初始化器必须至少初始化一个成员*。'
- en: '|  |'
  id: totrans-1536
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Previously ([takeaway 5.37](kindle_split_013.html#ch05note38)), we saw that
    there is a default initializer that works for all data types: `{0}`.'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前（[要点 5.37](kindle_split_013.html#ch05note38)），我们看到了有一个默认初始化器适用于所有数据类型：`{0}`。
- en: So when we initialize **`struct`** **`tm`** as we did here, the data structure
    is not consistent; the **`tm_wday`** and **`tm_yday`** members don’t have values
    that would correspond to the values of the remaining members. A function that
    sets this member to a value that is consistent with the others could be something
    like
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们像这里一样初始化 **`struct`** **`tm`** 时，数据结构是不一致的；**`tm_wday`** 和 **`tm_yday`**
    成员没有与剩余成员值相对应的值。一个将此成员设置为与其他成员值一致的函数可能如下所示
- en: '**`yday.c`**'
  id: totrans-1539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`yday.c`**'
- en: '[PRE99]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'It uses the number of days of the months preceding the current one, the **`tm_mday`**
    member, and an eventual corrective for leap years to compute the day in the year.
    This function has a particularity that is important at our current level: it modifies
    only the member of the parameter of the function, t, and not of the original object.'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用当前月份之前的天数、`tm_mday` 成员以及闰年的校正来计算年份中的天数。这个函数有一个在我们当前水平上很重要的特性：它只修改函数参数 t 的成员，而不是原始对象。
- en: '|  |'
  id: totrans-1542
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.25
  id: totrans-1543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 6.25
- en: '**`struct`** *parameters are passed by value.*'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: '**`struct`** 参数是通过值传递的。'
- en: '|  |'
  id: totrans-1545
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To keep track of the changes, we have to reassign the result of the function
    to the original:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪变化，我们必须将函数的结果重新分配给原始变量：
- en: '**`yday.c`**'
  id: totrans-1547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`yday.c`**'
- en: '[PRE100]'
  id: totrans-1548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Later, with pointer types, we will see how to overcome that restriction for
    functions, but we are not there yet. Here we see that the assignment operator
    *`=`* is well defined for all structure types. Unfortunately, its counterparts
    for comparisons are not.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将看到如何通过指针类型克服函数的这种限制，但我们还没有到达那里。这里我们看到，对于所有结构体类型，赋值运算符**`=`**是明确定义的。不幸的是，它的比较对应物并没有。
- en: '|  |'
  id: totrans-1550
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.26
  id: totrans-1551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果6.26
- en: '*Structures can be assigned with* *`=`* *but not compared with* *`==`* *or*
    *`!=`**.*'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体可以用**`=`**赋值，但不能用**`==`**或**`!=`**比较。
- en: '|  |'
  id: totrans-1553
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Listing 6.3](#ch06ex08) shows the complete example code for the use of **`struct`**
    **`tm`**. It doesn’t contain a declaration of the historical **`struct`** **`tm`**
    since this is provided through the standard header `time.h`. Nowadays, the types
    for the individual members would probably be chosen differently. But many times
    in C we have to stick with design decisions that were made many years ago.'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单6.3](#ch06ex08)展示了使用**`struct`** **`tm`**的完整示例代码。它不包含历史性的**`struct`**
    **`tm`**的声明，因为这是通过标准头文件`time.h`提供的。如今，对于各个成员的类型可能的选择可能不同。但许多时候在C语言中，我们不得不坚持多年前做出的设计决策。'
- en: '![](comm.jpg)'
  id: totrans-1555
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: '|  |'
  id: totrans-1556
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<time.h>`'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '`<time.h>`'
- en: '|  |'
  id: totrans-1558
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 6.3\. A sample program manipulating struct **`tm`**
  id: totrans-1559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单6.3\. 一个操作struct **`tm`**的示例程序
- en: '[PRE101]'
  id: totrans-1560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '|  |'
  id: totrans-1561
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.27
  id: totrans-1562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果6.27
- en: '*A structure layout is an important design decision.*'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体布局是一个重要的设计决策。
- en: '|  |'
  id: totrans-1564
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You may regret your design after some years, when all the existing code that
    uses it makes it almost impossible to adapt it to new situations.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，当所有使用它的现有代码几乎不可能适应新情况时，你可能会后悔自己的设计。
- en: 'Another use of **`struct`** is to group objects of different types together
    in one larger enclosing object. Again, for manipulating times with a nanosecond
    granularity, the C standard already has made that choice:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '**`struct`**的另一个用途是将不同类型的对象组合在一个更大的封装对象中。同样，对于以纳秒精度操作时间，C标准已经做出了这样的选择：'
- en: '[PRE102]'
  id: totrans-1567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '![](pg_095.jpg)'
  id: totrans-1568
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_095.jpg)'
- en: Here we see the opaque type **`time_t`** that we saw in [table 5.2](kindle_split_013.html#ch05table02)
    for the seconds, and a **`long`** for the nanoseconds.^([[4](#ch06fn04)]) Again,
    the reasons for this choice are historical; nowadays the chosen types would perhaps
    be a bit different. To compute the difference between two **`struct`** **`timespec`**
    times, we can easily define a function.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到的是我们在[表5.2](kindle_split_013.html#ch05table02)中看到的用于秒的透明类型**`time_t`**，以及用于纳秒的**`long`**。^([[4](#ch06fn04)])
    再次，这种选择的原因是历史性的；如今，选择的数据类型可能略有不同。要计算两个**`struct`** **`timespec`**时间之间的差异，我们可以轻松定义一个函数。
- en: ⁴
  id: totrans-1570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unfortunately, even the semantics of **`time_t`** are different here. In particular,
    **`tv_sec`** may be used in arithmetic.
  id: totrans-1572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很不幸，即使是**`time_t`**的语义在这里也有所不同。特别是，**`tv_sec`**可以用于算术运算。
- en: '![](comm.jpg)'
  id: totrans-1573
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: Whereas the function **difftime** is part of the C standard, such functionality
    here is very simple and isn’t based on platform-specific properties. So it can
    easily be implemented by anyone who needs it.^([[[Exs 2]](#ch06fn-ex02)])
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**difftime**函数是C标准的一部分，但这里的这种功能非常简单，并不基于平台特定的属性。因此，任何需要它的人都可以轻松实现。^([[[Exs
    2]](#ch06fn-ex02)])
- en: ^([Exs 2])
  id: totrans-1575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-1576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function timespec_diff that computes the difference between two **`timespec`**
    values.
  id: totrans-1577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个名为timespec_diff的函数，用于计算两个**`timespec`**值之间的差异。
- en: 'Any data type other than a VLA is allowed as a member in a structure. So structures
    can also be nested in the sense that a member of a **`struct`** can again be of
    (another) **`struct`** type, and the smaller enclosed structure may even be declared
    inside the larger one:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 除了VLA之外，任何数据类型都可以作为结构体的成员。因此，结构体也可以嵌套，即一个**`struct`**的成员可以再次是（另一个）**`struct`**类型，较小的封装结构甚至可以在较大的结构体内部声明：
- en: '[PRE103]'
  id: totrans-1579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '![](pg_096_alt.jpg)'
  id: totrans-1580
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_096_alt.jpg)'
- en: The visibility of declaration **`struct`** stardate is the same as for **`struct`**
    person. A **`struct`** itself (here, person) defines no new scope for a **`struct`**
    (here, stardate) that is defined within the `{}` of the outermost **`struct`**
    declaration. This may be much different from the rules of other programming languages,
    such as C++.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 声明**`struct`** stardate的可见性与**`struct`** person相同。一个**`struct`**本身（这里，person）不会为在最外层**`struct`**声明的大括号`{}`内定义的**`struct`**（这里，stardate）定义新的作用域。这可能与其他编程语言的规则大不相同，例如C++。
- en: '|  |'
  id: totrans-1582
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.28
  id: totrans-1583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果6.28
- en: '*All* **`struct`** *declarations in a nested declaration have the same scope
    of visibility.*'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套声明中的所有**`struct`**声明具有相同的可见范围。
- en: '|  |'
  id: totrans-1585
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That is, if the previous nested **`struct`** declarations appear globally, both
    **`struct`**s are subsequently visible for the whole C file. If they appear inside
    a function, their visibility is bound to the `{}` block in which they are found.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是，如果之前的嵌套 **`struct`** 声明在全局范围内出现，那么这两个 **`struct`** 都可以在整个 C 文件中可见。如果它们出现在函数内部，它们的可见性则绑定在它们所在的
    `{}` 块中。
- en: 'So, a more adequate version would be as follows:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个更合适的版本如下：
- en: '[PRE104]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This version places all **`struct`**s on the same level, because they end up
    there, anyhow.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将所有 **`struct`** 放在同一级别，因为它们最终都会在那里。
- en: '6.4\. New names for types: type aliases'
  id: totrans-1590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 类型的新名称：类型别名
- en: '![](comm.jpg)'
  id: totrans-1591
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: As we saw in the previous chapter, a structure not only introduces a way to
    aggregate differing information into one unit, but also introduces a new type
    name for the beast. For historical reasons (again!), the name that we introduce
    for the structure always has to be preceded by the keyword **`struct`**, which
    makes its use a bit clumsy. Also, many C beginners run into difficulties with
    this when they forget the **`struct`** keyword and the compiler throws an incomprehensible
    error at them.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，结构体不仅提供了一种将不同信息聚合到一个单元中的方法，而且还引入了一个新的类型名称。由于历史原因（再次！），我们为结构体引入的名称总是必须以关键字
    **`struct`** 开头，这使得其使用略显笨拙。此外，许多 C 语言初学者在忘记 **`struct`** 关键字时遇到困难，编译器会向他们抛出一个难以理解的错误。
- en: 'There is a general tool that can help us avoid that, by giving a symbolic name
    to an otherwise existing type: **`typedef`**. Using it, a type can have several
    names, and we can even reuse the *tag name**^C* that we used in the structure
    declaration:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个通用工具可以帮助我们避免这种情况，即通过给一个现有的类型赋予一个符号名称：**`typedef`**。使用它，一个类型可以有多个名称，我们甚至可以重用结构体声明中使用的
    *标签名*：
- en: '[PRE105]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Then, **`struct`** birdStruct, birdStruct, and birdStructure can all be used
    interchangeably. My favorite use of this feature is the following idiom:'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**`struct`** birdStruct、birdStruct 和 birdStructure 都可以互换使用。我最喜欢的这个特性的用法如下：
- en: '[PRE106]'
  id: totrans-1596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: That is, to *precede* the proper **`struct`** declaration by a **`typedef`**
    using exactly the same name. This works because in the combination of **`struct`**
    with a following name, the *tag**^C* is always valid, a *forward declaration**^C*
    of the structure.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是，通过使用完全相同的名称在适当的 **`struct`** 声明之前使用 **`typedef`**。这之所以有效，是因为在 **`struct`**
    与后续名称的组合中，*标签* 总是有效的，这是一个 *结构体的前置声明*。
- en: '|  |'
  id: totrans-1598
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.29
  id: totrans-1599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.29
- en: '*Forward-declare a* **`struct`** *within a* **`typedef`** *using the same identifier
    as the tag name.*'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 *`typedef`** 中使用与标签名相同的标识符来 *前置声明* 一个 **`struct`**。'
- en: '|  |'
  id: totrans-1601
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: C++ follows a similar approach by default, so this strategy will make your code
    easier to read for people who come from there.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C++ 采用类似的方法，因此这种策略会使来自那里的代码更容易阅读。
- en: The **`typedef`** mechanism can also be used for types other than structures.
    For arrays, this could look like
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '**`typedef`** 机制也可以用于结构体以外的类型。对于数组，这可能看起来像这样'
- en: '[PRE107]'
  id: totrans-1604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Here, **`typedef`** only introduces a new name for an existing type, so A,
    B, and C have exactly the same type: **`double`**`[16][64]`.'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**`typedef`** 只引入了一个现有类型的新的名称，因此 A、B 和 C 具有完全相同的类型：**`double`**`[16][64]`。
- en: '|  |'
  id: totrans-1606
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.30
  id: totrans-1607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.30
- en: '*A* **`typedef`** *only creates an alias for a type, but never a new type.*'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '*`typedef`** 只创建一个类型的别名，但永远不会创建一个新类型。'
- en: '|  |'
  id: totrans-1609
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The C standard also uses **`typedef`** a lot internally. The semantic integer
    types such as **`size_t`** that we saw in [section 5.2](kindle_split_013.html#ch05lev1sec2)
    are declared with this mechanism. The standard often uses names that terminate
    with **`_t`** for **`typedef`**. This naming convention ensures that the introduction
    of such a name in an upgraded version of the standard will not conflict with existing
    code. So you shouldn’t introduce such names yourself in your code.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准也大量使用 **`typedef`**。我们在 [第 5.2 节](kindle_split_013.html#ch05lev1sec2) 中看到的语义整数类型，如
    **`size_t`**，就是用这种机制声明的。标准经常使用以 **`_t`** 结尾的名称来为 **`typedef`** 命名。这种命名约定确保在标准的升级版本中引入此类名称时不会与现有代码冲突。因此，你不需要在自己的代码中引入此类名称。
- en: '|  |'
  id: totrans-1611
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 6.31
  id: totrans-1612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 6.31
- en: '*Identifier names terminating with* **`_t`** *are reserved.*'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: '*以 *`_t`** 结尾的标识符名称是保留的*。'
- en: '|  |'
  id: totrans-1614
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-1615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Arrays combine several values of the same base type into one object.
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组将相同基类型的多个值组合成一个对象。
- en: Pointers refer to other objects, are null, or are indeterminate.
  id: totrans-1617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针指向其他对象，可以是空指针，也可以是不确定的。
- en: Structures combine values of different base types into one object.
  id: totrans-1618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体将不同基类型的值组合成一个对象。
- en: '**`typedef`**s provide new names for existing types.'
  id: totrans-1619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`typedef`** 为现有类型提供新的名称。'
- en: Chapter 7\. Functions
  id: totrans-1620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. 函数
- en: This chapter covers
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Introduction to simple functions
  id: totrans-1622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单函数的介绍
- en: Working with **main**
  id: totrans-1623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 **main** 一起工作
- en: Understanding recursion
  id: totrans-1624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解递归
- en: 'We have already seen the different means that C offers for *conditional execution*:
    execution that, based on a value, chooses one branch of the program over another
    to continue. The reason for a potential “jump” to another part of the program
    code (for example, to an **`else`** branch) is a runtime decision that depends
    on runtime data. This chapter starts with a discussion of *unconditional* ways
    to transfer control to other parts of our code: by themselves, they do not require
    any runtime data to decide where to go.'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 C 提供的不同方法来实现 *条件执行*：基于值的执行，选择程序的另一个分支而不是另一个分支以继续。潜在“跳转”到程序代码的另一部分（例如，到
    **`else`** 分支）的原因是依赖于运行时数据的运行时决策。本章从讨论 *无条件* 的方法开始，将控制转移到代码的其他部分：它们本身不需要任何运行时数据来决定去哪里。
- en: The code examples we have seen so far often used functions from the C library
    that provided features we did not want (or were not able) to implement ourselves,
    such as **printf** for printing and **strlen** for computing the length of a string.
    The idea behind this concept of functions is that they implement a certain feature,
    once and for all, and that we then can rely on that feature in the rest of our
    code.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的代码示例通常使用了 C 库中的函数，这些函数提供了我们不想（或无法）自己实现的特性，例如用于打印的 **printf** 和用于计算字符串长度的
    **strlen**。这个函数概念背后的想法是，它们实现了一个特定的功能，一次性和永久性，然后我们可以依赖这个功能在其余代码中。
- en: A function for which we have seen several definitions is **main**, the entry
    point of execution into a program. In this chapter, we will look at how to write
    functions ourselves that may provide features just like the functions in the C
    library.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到几个定义的函数是 **main**，它是程序执行的入口点。在本章中，我们将探讨如何编写我们自己可能提供与 C 库中函数类似功能的函数。
- en: 'The main reasons motivating the concept of functions are *modularity* and *code
    factorization*:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动函数概念的主要原因是 *模块化* 和 *代码分解*：
- en: Functions avoid code repetition. In particular they avoid easily introduced
    copy-and-paste errors and spare the effort of editing in multiple places if you
    modify a piece of functionality. Thereby, functions increase readability and maintainability.
  id: totrans-1629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数避免了代码重复。特别是它们避免了容易引入的复制粘贴错误，并在修改某个功能时节省了在多个地方编辑的努力。因此，函数增加了可读性和可维护性。
- en: Use of functions decreases compilation times. A given code snippet that we encapsulate
    in a function is compiled only once, not at each point where it is used.
  id: totrans-1630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数可以减少编译时间。给定的代码片段，当我们将其封装在函数中时，只会编译一次，而不是在每次使用时都编译。
- en: Functions simplify future code reuse. Once we have extracted code into a function
    that provides certain functionality, it can easily be applied in other places
    that we did not even think of when implementing the function.
  id: totrans-1631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数简化了未来代码的重用。一旦我们将代码提取到提供特定功能的函数中，它就可以轻松地应用于我们甚至在实现函数时都没有想到的其他地方。
- en: 'Functions provide clear interfaces. Function arguments and return types clearly
    specify the origin and type of data that flows into and out of a computation.
    Additionally, functions allow us to specify invariants for a computation: pre-
    and post-conditions.'
  id: totrans-1632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数提供了清晰的接口。函数参数和返回类型清楚地指定了流入和流出计算的数据的来源和类型。此外，函数还允许我们指定计算的不可变条件：前置条件和后置条件。
- en: Functions provide a natural way to formulate algorithms that use a “stack” of
    intermediate values.
  id: totrans-1633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数提供了一种自然的方式来制定使用“堆栈”中间值的算法。
- en: 'In addition to functions, C has other means of unconditional transfer of control,
    which are mostly used to handle error conditions or other forms of exceptions
    from the usual control flow:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数之外，C 还提供了其他无条件转移控制的方法，这些方法主要用于处理错误条件或其他形式的异常，从常规控制流中：
- en: '**exit**, **_Exit**, **quick_exit**, and **abort** terminate the program execution
    (see [section 8.7](kindle_split_017.html#ch08lev1sec7)).'
  id: totrans-1635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exit**、**_Exit**、**quick_exit** 和 **abort** 终止程序执行（参见[章节 8.7](kindle_split_017.html#ch08lev1sec7)）。'
- en: '**`goto`** transfers control within a function body (see [sections 13.2.2](kindle_split_023.html#ch13lev2sec4)
    and [14.5](kindle_split_024.html#ch14lev1sec5)).'
  id: totrans-1636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`goto`** 在函数体内转移控制（参见[章节 13.2.2](kindle_split_023.html#ch13lev2sec4) 和 [14.5](kindle_split_024.html#ch14lev1sec5)）。'
- en: '**setjmp** and **longjmp** can be used to return unconditionally to a calling
    context (see [section 17.5](kindle_split_028.html#ch17lev1sec5)).'
  id: totrans-1637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setjmp** 和 **longjmp** 可以无条件地返回到调用上下文（参见[第17.5节](kindle_split_028.html#ch17lev1sec5)）。'
- en: Certain events in the execution environment or calls to the function **raise**
    may raise *signals* that pass control to a specialized function, a *signal handler*.
  id: totrans-1638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行环境中的某些事件或对函数 **raise** 的调用可能会引发 *信号*，这些信号将控制权传递给一个专门的功能，一个 *信号处理程序*。
- en: 7.1\. Simple functions
  id: totrans-1639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 简单函数
- en: 'We have used a lot of functions and seen some of their declarations (for example
    in [section 6.1.5](kindle_split_014.html#ch06lev2sec5)) and definitions (such
    as [listing 6.3](kindle_split_014.html#ch06ex08)). In all of these functions,
    parentheses *`()`* play an important syntactical role. They are used for function
    declarations and definitions, to encapsulate the list of parameter declarations.
    For function calls, they hold the list of arguments for that concrete call. This
    syntactic role is similar to `[]` for arrays: in declarations and definitions,
    they contain the size of the corresponding dimension. In a designation like `A[`i`]`,
    they are used to indicate the position of the accessed element in the array.'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了很多函数，并看到了其中一些的声明（例如在[第6.1.5节](kindle_split_014.html#ch06lev2sec5)中）和定义（如[列表6.3](kindle_split_014.html#ch06ex08)）。在这些函数中，括号
    *`()`* 扮演着重要的语法角色。它们用于函数的声明和定义，用于封装参数声明列表。对于函数调用，它们包含该具体调用的参数列表。这种语法角色与数组中的 `[]`
    类似：在声明和定义中，它们包含相应维度的尺寸。在像 `A[i]` 这样的指定中，它们用于指示访问数组中元素的位罝。
- en: 'All the functions we have seen so far have a *prototype**^C*: their declaration
    and definition, including a parameter type-list and a return type. To see that,
    let us revisit the leapyear function from [listing 6.3](kindle_split_014.html#ch06ex08):'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所看到的所有函数都有一个 *原型**^C*：它们的声明和定义，包括参数类型列表和返回类型。为了说明这一点，让我们回顾一下[列表6.3](kindle_split_014.html#ch06ex08)中的
    leapyear 函数：
- en: '**`yday.c`**'
  id: totrans-1642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`yday.c`**'
- en: '[PRE108]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'A declaration of that function (without a definition) could look as follows:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的声明（不带定义）可能看起来如下：
- en: '[PRE109]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Alternatively, we could even omit the name of the parameter and/or add the *storage
    specifier* **`extern`**:^([[1](#ch07fn01)])
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们甚至可以省略参数名和/或添加 *存储指定符* **`extern`**:^([[1](#ch07fn01)])
- en: ¹
  id: totrans-1647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: More details on the keyword **`extern`** will be provided in [section 13.2](kindle_split_023.html#ch13lev1sec2).
  id: totrans-1649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于关键字 **`extern`** 的更多细节将在[第13.2节](kindle_split_023.html#ch13lev1sec2)中提供。
- en: '[PRE110]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Important for such a declaration is that the compiler sees the types of the
    argument(s) and the return type, so here the prototype of the function is “*function
    receiving an* **`unsigned`** *and returning a* *`bool`*."
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类声明来说，重要的是编译器可以看到参数（的）类型和返回类型，因此这里函数的原型是“*接收一个* **`unsigned`** *并返回一个* *`bool`*
    的函数。”
- en: 'There are two special conventions that use the keyword **`void`**:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种特殊的约定使用关键字 **`void`**：
- en: If the function is to be called with no parameter, the list is replaced by the
    keyword **`void`**, like **main** in our very first example ([listing 1.1](kindle_split_008.html#ch01ex01)).
  id: totrans-1653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数要无参数调用，则列表被关键字 **`void`** 替换，就像我们非常第一个例子中的 **main** ([列表1.1](kindle_split_008.html#ch01ex01))。
- en: 'If the function doesn’t return a value, the return type is given as **`void`**:
    for example, swap_double.'
  id: totrans-1654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数不返回值，则返回类型为 **`void`**：例如，swap_double。
- en: 'Such a prototype helps the compiler in places where the function is to be called.
    It only has to know about the parameters the function expects. Have a look at
    the following:'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的原型有助于编译器在函数将要被调用的地方。它只需要知道函数期望的参数。看看以下内容：
- en: '[PRE111]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here, the call fbar`(2)` is not directly compatible with the expectation of
    function fbar: it wants a **`double`** but receives a **`signed int`**. But since
    the calling code knows this, it can convert the **`signed int`** argument `2`
    to the **`double`** value `2.0` before calling the function. The same holds for
    the use of the return value in an expression: the caller knows that the return
    type is **`double`**, so floating-point division is applied for the result expression.'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对 fbar`(2)` 的调用与函数 fbar 的预期不直接兼容：它需要一个 **`double`** 但接收一个 **`signed int`**。但由于调用代码知道这一点，它可以在调用函数之前将
    **`signed int`** 参数 `2` 转换为 **`double`** 值 `2.0`。同样，对于在表达式中使用返回值的情况也适用：调用者知道返回类型是
    **`double`**，因此对结果表达式应用了浮点除法。
- en: C has obsolete ways to declare functions without prototype, but you will not
    see them here. You shouldn’t use them; they will be retired in future versions.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言有声明没有原型的函数的过时方式，但在这里你不会看到它们。你不应该使用它们；它们将在未来的版本中退役。
- en: '|  |'
  id: totrans-1659
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.1
  id: totrans-1660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第七点总结 7.1
- en: '*All functions must have prototypes.*'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有函数都必须有原型。*'
- en: '|  |'
  id: totrans-1662
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A notable exception to that rule are functions that can receive a varying number
    of parameters, such as **printf**. They use a mechanism for parameter handling
    called a *variable argument* *list*^(*C*), which comes with the header `stdargs.h`.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的例外是能够接收可变数量参数的函数，例如 **printf**。它们使用一种称为 *可变参数* *列表*^(*C*) 的参数处理机制，该机制由头文件
    `stdargs.h` 提供。
- en: '|  |'
  id: totrans-1664
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<stdargs.h>`'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdargs.h>`'
- en: '|  |'
  id: totrans-1666
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We will see later ([section 16.5.2](kindle_split_027.html#ch16lev2sec2)) how
    this works, but this feature is to be avoided in any case. Already from your experience
    with **printf** you can imagine why such an interface poses difficulties. You,
    as the programmer of the calling code, have to ensure consistency by providing
    the correct "%XX" format specifiers.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面（[章节 16.5.2](kindle_split_027.html#ch16lev2sec2)）看到这是如何工作的，但无论如何都要避免这个特性。从你对
    **printf** 的使用经验中，你可以想象为什么这样的接口会带来困难。作为调用代码的程序员，你必须通过提供正确的 "%XX" 格式说明符来确保一致性。
- en: 'In the implementation of a function, we must watch that we provide return values
    for all functions that have a non-**`void`** return type. There can be several
    **`return`** statements in a function:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的实现中，我们必须注意为所有具有非**`void`**返回类型的函数提供返回值。一个函数中可以有多个**`return`**语句：
- en: '|  |'
  id: totrans-1669
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.2
  id: totrans-1670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第七点总结 7.2
- en: '*Functions have only one entry but can have several* **`return`***s.*'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数只有一个入口，但可以有多个* **`return`***。*'
- en: '|  |'
  id: totrans-1672
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: All **`return`**s in a function must be consistent with the function declaration.
    For a function that expects a return value, all **`return`** statements must contain
    an expression; functions that expect none, mustn’t contain expressions.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的所有**`return`**语句必须与函数声明一致。对于期望返回值的函数，所有**`return`**语句都必须包含一个表达式；不期望返回值的函数，则不应包含表达式。
- en: '|  |'
  id: totrans-1674
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.3
  id: totrans-1675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第七点总结 7.3
- en: '*A function* **`return`** *must be consistent with its type.*'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数* **`return`** *必须与其类型一致。*'
- en: '|  |'
  id: totrans-1677
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: But the same rule as for the parameters on the calling side holds for the return
    value. A value with a type that can be converted to the expected return type will
    be converted before the return happens.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于调用方的参数，同样适用于返回值。在返回之前，具有可以转换为预期返回类型的类型的值将被转换。
- en: 'If the type of the function is **`void`**, the **`return`** (without expression)
    can even be omitted:'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数的类型是 **`void`**，则可以省略**`return`**（无表达式）：
- en: '|  |'
  id: totrans-1680
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.4
  id: totrans-1681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第七点总结 7.4
- en: '*Reaching the end of the* *`{}`* *block of a function is equivalent to a* **`return`**
    *statement without an expression.*'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: '*到达函数的* *`{}`* *块的末尾等同于一个没有表达式的* **`return`** *语句。*'
- en: '|  |'
  id: totrans-1683
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Because otherwise a function that returns a value would have an indeterminate
    value to return, this construct is only allowed for functions that do not return
    a value:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 因为否则，返回值的函数将有一个不确定的返回值，所以这种结构仅允许用于不返回值的函数：
- en: '|  |'
  id: totrans-1685
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.5
  id: totrans-1686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第七点总结 7.5
- en: '*Reaching the end of the* *`{}`* *block of a function is only allowed for*
    **`void`** *functions.*'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '*到达函数的* *`{}`* *块的末尾仅允许在* **`void`** *函数中进行。*'
- en: '|  |'
  id: totrans-1688
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.2\. main is special
  id: totrans-1689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. main 是特殊的
- en: 'Perhaps you have noted some particularities about **main**. It has a very special
    role as the entry point into your program: its prototype is enforced by the C
    standard, but it is implemented by the programmer. Being such a pivot between
    the runtime system and the application, **main** has to obey some special rules.'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经注意到了关于 **main** 的某些特殊性。它作为程序入口点具有非常特殊的作用：其原型由 C 标准强制执行，但由程序员实现。作为运行时系统和应用程序之间的枢纽，**main**
    必须遵守一些特殊规则。
- en: 'First, to suit different needs, it has several prototypes, one of which must
    be implemented. Two should always be possible:'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了满足不同的需求，它有几个原型，其中必须实现一个。两个总是可能的：
- en: '[PRE112]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Then, any C platform may provide other interfaces. Two variations are relatively
    common:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，任何 C 平台都可能提供其他接口。两种变体相对常见：
- en: On some embedded platforms where **main** is not expected to return to the runtime
    system, the return type may be **`void`**.
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些嵌入式平台上，由于 **main** 不需要返回到运行时系统，返回类型可能是 **`void`**。
- en: On many platforms, a third parameter can give access to the “environment."
  id: totrans-1695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多平台上，第三个参数可以提供对“环境”的访问。
- en: 'You should not rely on the existence of such other forms. If you want to write
    portable code (which you do), stick to the two “official” forms. For these, the
    return value of **`int`** gives an indication to the runtime system if the execution
    was successful: a value of **`EXIT_SUCCESS`** or **`EXIT_FAILURE`** indicates
    success or failure of the execution from the programmer’s point of view. These
    are the only two values that are guaranteed to work on all platforms.'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该依赖于这种其他形式的存在。如果你想编写可移植的代码（你确实应该这样做），坚持使用两种“官方”形式。对于这些，**`int`**的返回值向运行时系统指示执行是否成功：**`EXIT_SUCCESS`**或**`EXIT_FAILURE`**的值表示从程序员的角度看执行的成功或失败。这是唯一两个在所有平台上都能保证工作的值。
- en: '|  |'
  id: totrans-1697
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.6
  id: totrans-1698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获7.6
- en: '*Use* **`EXIT_SUCCESS`** *and* **`EXIT_FAILURE`** *as return values for* **main***.*'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用**`EXIT_SUCCESS`**和**`EXIT_FAILURE`**作为**main**的返回值*。'
- en: '|  |'
  id: totrans-1700
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In addition, there is a special exception for **main**, as it is not required
    to have an explicit **`return`** statement:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于**main**还有一个特殊的例外，因为它不需要显式的**`return`**语句：
- en: '|  |'
  id: totrans-1702
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.7
  id: totrans-1703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获7.7
- en: '*Reaching the end of* **main** *is equivalent to a* **`return`** *with value*
    **`EXIT_SUCCESS`***.*'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: '*到达**main**的末尾等同于带有值**`EXIT_SUCCESS`**的**`return`**语句*。'
- en: '|  |'
  id: totrans-1705
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Personally, I am not much of a fan of such exceptions without tangible gain;
    they just make arguments about programs more complicated.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我不是特别喜欢这种没有实际收益的例外；它们只是让程序的论点更加复杂。
- en: 'The library function **exit** has a special relationship with **main**. As
    the name indicates, a call to **exit** terminates the program. The prototype is
    as follows:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数**exit**与**main**有特殊的关系。正如其名所示，对**exit**的调用会终止程序。其原型如下：
- en: '[PRE113]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This function terminates the program exactly as a **`return`** from **main**
    would. The status parameter has the role that the return expression in **main**
    would have.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会像从**main**返回一样精确地终止程序。状态参数具有**main**中返回表达式的角色。
- en: '|  |'
  id: totrans-1710
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.8
  id: totrans-1711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获7.8
- en: '*Calling* **exit***`(`**`s`**`)`* *is equivalent to the evaluation of* **`return`**
    *`s`* *in* **main***.*'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 调用**exit***`(`**`s`**`)`*等同于在**main**中评估**`return`**`s``*。
- en: '|  |'
  id: totrans-1713
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We also see that the prototype of **exit** is special because it has a **`void`**
    type. Just like a **`return`** statement, **exit** never fails.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，**exit**的原型是特殊的，因为它有一个**`void`**类型。就像一个**`return`**语句一样，**exit**永远不会失败。
- en: '|  |'
  id: totrans-1715
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.9
  id: totrans-1716
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获7.9
- en: '**exit** *never fails and never returns to its caller.*'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '**exit**永远不会失败，也不会返回到其调用者。'
- en: '|  |'
  id: totrans-1718
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The latter is indicated by the special keyword **`_Noreturn`**. This keyword
    should only be used for such special functions. There is even a pretty-printed
    version of it, the macro **`noreturn`**, which comes with the header `stdnoreturn.h`.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是特殊关键字**`_Noreturn`**的指示。这个关键字应该只用于这样的特殊函数。甚至还有一个相当打印的版本，宏**`noreturn`**，它包含在头文件`stdnoreturn.h`中。
- en: '|  |'
  id: totrans-1720
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<stdnoreturn.h>`'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdnoreturn.h>`'
- en: '|  |'
  id: totrans-1722
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'There is another feature in the second prototype of **main**: argv, the vector
    of command-line arguments. We looked at some examples where we used this vector
    to communicate values from the command line to the program. For example, in [listing
    3.1](kindle_split_011.html#ch03ex02), these command-line arguments were interpreted
    as **`double`** data for the program:'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 在**main**的第二个原型中，还有一个特性：argv，命令行参数的向量。我们查看了一些例子，展示了我们如何使用这个向量将命令行中的值传递给程序。例如，在[列表3.1](kindle_split_011.html#ch03ex02)中，这些命令行参数被解释为程序的**`double`**数据：
- en: '![](pg_103.jpg)'
  id: totrans-1724
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_103.jpg)'
- en: So each of the argv `[`i`]` for *i* = 0*,..., argc* is a pointer similar to
    those we encountered earlier. As an easy first approximation, we can see them
    as strings.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个argv `[`i`]`，其中*i* = 0，...，argc，都是一个类似于我们之前遇到的指针。作为一个简单的初步近似，我们可以将它们看作是字符串。
- en: '|  |'
  id: totrans-1726
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.10
  id: totrans-1727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获7.10
- en: '*All command-line arguments are transferred as strings.*'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有命令行参数都作为字符串传递*。'
- en: '|  |'
  id: totrans-1729
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It is up to us to interpret them. In the example, we chose the function **strtod**
    to decode a double value that was stored in the string.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于我们如何解释它们。在示例中，我们选择了函数**strtod**来解码存储在字符串中的双精度值。
- en: 'Of the argv strings, two elements hold special values:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 在argv字符串中，有两个元素持有特殊值：
- en: '|  |'
  id: totrans-1732
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.11
  id: totrans-1733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获7.11
- en: '*Of the arguments to* **main***,* *`arg`**`v[0]`* *holds the name of the program
    invocation.*'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: '*在**main**的参数中，*`arg`**v[0]***包含程序调用的名称*。'
- en: '|  |'
  id: totrans-1735
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: There is no strict rule about what program name should be, but usually it is
    the name of the program executable.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 关于程序名称没有严格的规则，但通常它是程序可执行文件的名字。
- en: '|  |'
  id: totrans-1737
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.12
  id: totrans-1738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获7.12
- en: '*Of the arguments to* **main***,* *`argv`**`[`**`argc`**`]`* *is* *`0`**.*'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: '*main* 的参数 *`argv`**`[`**`argc`**`]`* 是 *`0`**。'
- en: '|  |'
  id: totrans-1740
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the argv array, the last argument could always be identified using this
    property, but this feature isn’t very useful: we have argc to process that array.'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 在 argv 数组中，最后一个参数可以通过这个属性来识别，但这个特性并不很有用：我们有 argc 来处理这个数组。
- en: 7.3\. Recursion
  id: totrans-1742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 递归
- en: 'An important feature of functions is encapsulation: local variables are only
    visible and alive until we leave the function, either via an explicit **`return`**
    or because execution falls out of the last enclosing brace of the function’s block.
    Their identifiers (names) don’t conflict with other similar identifiers in other
    functions, and once we leave the function, all the mess we leave behind is cleaned
    up.'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一个重要特性是封装：局部变量仅在离开函数时才可见和存活，无论是通过显式的 **`return`** 还是因为执行超出函数块的最后一个括号。它们的标识符（名称）不会与其他函数中的类似标识符冲突，并且一旦离开函数，我们留下的所有混乱都会被清理干净。
- en: 'Even better: whenever we call a function, even one we have called before, a
    new set of local variables (including function parameters) is created, and these
    are newly initialized. This also holds if we newly call a function for which another
    call is still active in the hierarchy of calling functions. A function that directly
    or indirectly calls itself is called *recursive*, and the concept is called *recursion*.'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是：每次我们调用一个函数，即使是之前调用过的，都会创建一个新的局部变量集（包括函数参数），并且这些变量会被重新初始化。即使我们在调用函数的层次结构中已经有一个调用仍然活跃，这也适用。直接或间接调用自身的函数被称为
    *递归*，这个概念被称为 *递归*。
- en: 'Recursive functions are crucial for understanding C functions: they demonstrate
    and use primary features of the function call model and are only fully functional
    with these features. As a first example, we will look at an implementation of
    Euclid’s algorithm to compute the *greatest common divisor* (gcd) of two numbers:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数对于理解 C 函数至关重要：它们展示了并使用了函数调用模型的基本特性，并且只有具备这些特性才能完全工作。作为一个例子，我们将查看一个实现欧几里得算法的示例，用于计算两个数的
    *最大公约数* (gcd)：
- en: '**`euclid.h`**'
  id: totrans-1746
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`euclid.h`**'
- en: '[PRE114]'
  id: totrans-1747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: As you can see, this function is short and seemingly nice. But to understand
    how it works, we need to thoroughly understand how functions work, and how we
    transform mathematical statements into algorithms.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数很短，看起来很漂亮。但要理解它是如何工作的，我们需要彻底理解函数是如何工作的，以及我们如何将数学语句转换为算法。
- en: 'Given two integers *a, b >* 0, the gcd is defined as the greatest integer *c
    >* 0 that divides into both *a* and *b*. Here is the formula:'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数 *a, b >* 0，gcd 被定义为能够同时整除 *a* 和 *b* 的最大整数 *c >* 0。以下是公式：
- en: gcd(*a, b*) = max{*c* ∈ ![](nopf.jpg) | *c*|*a* and *c*|*b*}
  id: totrans-1750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcd(*a, b*) = max{*c* ∈ ![](nopf.jpg) | *c*|*a* and *c*|*b*}
- en: 'If we also assume that *a < b*, we can easily see that two *recursive* formulas
    hold:'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再假设 *a < b*，我们就可以很容易地看出有两个 *递归* 公式成立：
- en: equation 7.1\.
  id: totrans-1752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 7.1\.
- en: '![](equ7-1.jpg)'
  id: totrans-1753
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-1.jpg)'
- en: equation 7.2\.
  id: totrans-1754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 7.2\.
- en: '![](equ7-2.jpg)'
  id: totrans-1755
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-2.jpg)'
- en: That is, the gcd doesn’t change if we subtract the smaller integer or if we
    replace the larger of the two with the modulus of the other. These formulas have
    been used to compute the gcd since the days of ancient Greek mathematics. They
    are commonly attributed to Euclid (![](pg_105.jpg), around 300 B.C.) but may have
    been known even before him.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，gcd 在我们减去较小的整数或用另一个数的模数替换较大的数时不会改变。这些公式自古希腊数学时代以来就被用来计算 gcd。它们通常归功于欧几里得（![](pg_105.jpg)，约公元前
    300 年），但可能在他之前就已经为人所知。
- en: 'Our C function gcd2 uses equation ([7.2](#ch07equ02)). First (line 9), it checks
    if a precondition for the execution of this function is satisfied: whether the
    first argument is less than or equal to the second. It does this by using the
    **`assert`** macro from `assert.h`. This would abort the program with an informative
    message if the function was called with arguments that didn’t satisfy that condition
    (we will see more explanations of **`assert`** in [section 8.7](kindle_split_017.html#ch08lev1sec7)).'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 C 函数 gcd2 使用方程 ([7.2](#ch07equ02))。首先（第 9 行），它检查执行此函数的先决条件是否得到满足：第一个参数是否小于或等于第二个参数。它是通过使用
    `assert.h` 中的 **`assert`** 宏来做到这一点的。如果函数被带有不满足该条件的参数调用，程序将终止并显示一条信息性消息（我们将在 [第
    8.7 节](kindle_split_017.html#ch08lev1sec7) 中看到更多关于 **`assert`** 的解释）。
- en: '|  |'
  id: totrans-1758
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<assert.h>`'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '`<assert.h>`'
- en: '|  |'
  id: totrans-1760
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1761
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 7.13
  id: totrans-1762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 7.13 总结
- en: '*Make all preconditions for a function explicit.*'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: '*将函数的所有先决条件明确化*。'
- en: '|  |'
  id: totrans-1764
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Then, line 10 checks whether a is `0`, in which case it returns b. This is
    an important step in a recursive algorithm:'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第 10 行检查 a 是否为 `0`，如果是，则返回 b。这是递归算法中的一个重要步骤：
- en: '|  |'
  id: totrans-1766
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.14
  id: totrans-1767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 7.14
- en: '*In a recursive function, first check the termination condition.*'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '*在递归函数中，首先检查终止条件*。'
- en: '|  |'
  id: totrans-1769
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A missing termination check leads to *infinite recursion*; the function repeatedly
    calls new copies of itself until all system resources are exhausted and the program
    crashes. On modern systems with large amounts of memory, this may take some time,
    during which the system will be completely unresponsive. You’d better not try
    it.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少终止检查会导致 *无限递归*；函数反复调用新的自身副本，直到所有系统资源耗尽，程序崩溃。在现代具有大量内存的系统上，这可能会花费一些时间，在此期间系统将完全无响应。你最好不要尝试。
- en: Otherwise, we compute the remainder rem of b modulo a (line 11). Then the function
    is called recursively with rem and a, and the return value of that is directly
    returned.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们计算 b 模 a 的余数 rem（第 11 行）。然后，函数递归调用 rem 和 a，并直接返回该返回值。
- en: '[Figure 7.1](#ch07fig01) shows an example of the different recursive calls
    that are issued from an initial call gcd2`(18, 30)`. Here, the recursion goes
    four levels deep. Each level implements its own copies of the variables a, b,
    and rem.'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.1](#ch07fig01) 展示了从初始调用 gcd2`(18, 30)` 发出的不同递归调用示例。这里，递归深度为四层。每一层实现其自己的
    a、b 和 rem 变量的副本。'
- en: 'For each recursive call, modulo arithmetic ([takeaway 4.8](kindle_split_012.html#ch04note09))
    guarantees that the precondition is always fulfilled automatically. For the initial
    call, we have to ensure this ourselves. This is best done by using a different
    function, a *wrapper**^C*:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次递归调用，模运算（[要点 4.8](kindle_split_012.html#ch04note09)）保证了先决条件总是自动满足。对于初始调用，我们必须自己确保这一点。这最好通过使用不同的函数，一个
    *包装器**^C* 来完成：
- en: '**`euclid.h`**'
  id: totrans-1774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`euclid.h`**'
- en: '[PRE115]'
  id: totrans-1775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '|  |'
  id: totrans-1776
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.15
  id: totrans-1777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 7.15
- en: '*Ensure the preconditions of a recursive function in a wrapper function.*'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保在包装函数中检查递归函数的先决条件*。'
- en: '|  |'
  id: totrans-1779
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'This avoids having to check the precondition at each recursive call: the **`assert`**
    macro is such that it can be disabled in the final production object file.'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免在每次递归调用时检查先决条件：**`assert`** 宏可以在最终的生产对象文件中禁用。
- en: Another famous example of a recursive definition of an integer sequence are
    *Fibonnacci numbers*, a sequence of numbers that appeared as early as 200 B.C.
    in Indian texts. In modern terms, the sequence can be defined as
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 整数序列的递归定义的另一个著名例子是 *斐波那契数*，这是一种早在公元前 200 年就出现在印度文献中的数字序列。用现代术语来说，这个序列可以定义为
- en: Figure 7.1\. Recursive call gcd2`(18, 30)`
  id: totrans-1782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 递归调用 gcd2`(18, 30)`
- en: '![](07fig01_alt.jpg)'
  id: totrans-1783
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig01_alt.jpg)'
- en: equation 7.3\.
  id: totrans-1784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 7.3。
- en: '![](equ7-3.jpg)'
  id: totrans-1785
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-3.jpg)'
- en: equation 7.4\.
  id: totrans-1786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 7.4。
- en: '![](equ7-4.jpg)'
  id: totrans-1787
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-4.jpg)'
- en: equation 7.5\.
  id: totrans-1788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 7.5。
- en: '![](equ7-5.jpg)'
  id: totrans-1789
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-5.jpg)'
- en: The sequence of Fibonacci numbers is fast-growing. Its first elements are 1,
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 377, 610, 987.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列增长迅速。其前几个元素是 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 377, 610, 987。
- en: With the golden ratio
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 使用黄金比例
- en: equation 7.6\.
  id: totrans-1792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 7.6。
- en: '![](equ7-6.jpg)'
  id: totrans-1793
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-6.jpg)'
- en: it can be shown that
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 可以证明
- en: equation 7.7\.
  id: totrans-1795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 7.7。
- en: '![](equ7-7.jpg)'
  id: totrans-1796
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-7.jpg)'
- en: and so, asymptotically, we have
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从渐近的角度来看，我们有
- en: equation 7.8\.
  id: totrans-1798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 7.8。
- en: '![](equ7-8.jpg)'
  id: totrans-1799
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-8.jpg)'
- en: So the growth of *F**[n]* is exponential.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*F**[n]* 的增长是指数级的。
- en: 'The recursive mathematical definition can be translated in a straightforward
    manner into a C function:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 递归数学定义可以简单地转换为 C 函数：
- en: '**`fibonacci.c`**'
  id: totrans-1802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`fibonacci.c`**'
- en: '[PRE116]'
  id: totrans-1803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Here, again, we first check for the termination condition: whether the argument
    to the call, n, is less than `3`. If it is, the return value is `1`; otherwise
    we return the sum of calls with argument values `n-1` and `n-2`.'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查终止条件：调用参数 n 是否小于 `3`。如果是，则返回值是 `1`；否则，我们返回参数值为 `n-1` 和 `n-2` 的调用之和。
- en: '[Figure 7.2](#ch07fig02) shows an example of a call to fib with a small argument
    value. We see that this leads to three levels of stacked calls to the same function
    with different arguments. Because equation ([7.5](#ch07equ05)) uses two different
    values of the sequence, the scheme of the recursive calls is much more involved
    than the one for gcd2. In particular, there are three *leaf calls*: calls to the
    function that fulfill the termination condition, and thus by themselves not go
    into recursion.^([[[Exs 1]](#ch07fn-ex01)])'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.2](#ch07fig02) 展示了使用小参数值调用 fib 的一个示例。我们看到这导致了三个级别的相同函数的不同参数的堆叠调用。因为方程
    ([7.5](#ch07equ05)) 使用了序列的两个不同值，所以递归调用的方案比 gcd2 的方案要复杂得多。特别是，有三个 *叶子调用*：满足终止条件的函数调用，因此它们本身不会进入递归.^([[[例
    1]](#ch07fn-ex01)])'
- en: ^([Exs 1])
  id: totrans-1806
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 1])
- en: ''
  id: totrans-1807
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that a call fib`(`n`)` induces *F**[n]* leaf calls.
  id: totrans-1808
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明调用 fib`(`n`)`会引发 *F**[n]* 个叶子调用。
- en: 'Implemented like that, the computation of the Fibonacci numbers is quite slow.^([[[Exs
    2]](#ch07fn-ex02)]) In fact, it is easy to see that the recursive formula for
    the function itself also leads to an analogous formula for the function’s execution
    time:'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 这样实现，斐波那契数的计算相当慢.^([[[例 2]](#ch07fn-ex02)]) 实际上，很容易看出该函数本身的递归公式也导致函数执行时间的类似公式：
- en: ^([Exs 2])
  id: totrans-1810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 2])
- en: ''
  id: totrans-1811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Measure the times for calls to fib`(`n`)` with *n* set to different values.
    On POSIX systems, you can use `/bin/time` to measure the run time of a program’s
    execution.
  id: totrans-1812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用不同的 *n* 值测量对 fib`(`n`)` 的调用时间。在 POSIX 系统上，您可以使用 `/bin/time` 来测量程序执行的时间。
- en: Figure 7.2\. Recursive call fib`(4)`
  id: totrans-1813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 递归调用 fib`(4)`
- en: '![](07fig02_alt.jpg)'
  id: totrans-1814
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig02_alt.jpg)'
- en: equation 7.9\.
  id: totrans-1815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 7.9\.
- en: '![](equ7-9.jpg)'
  id: totrans-1816
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-9.jpg)'
- en: equation 7.10\.
  id: totrans-1817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 7.10\.
- en: '![](equ7-10.jpg)'
  id: totrans-1818
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-10.jpg)'
- en: equation 7.11\.
  id: totrans-1819
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 7.11\.
- en: '![](equ7-11_alt.jpg)'
  id: totrans-1820
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-11_alt.jpg)'
- en: where *C*[0] and *C*[1] are constants that depend on the platform.
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *C*[0] 和 *C*[1] 是依赖于平台的常数。
- en: It follows that regardless of the platform and the cleverness of our implementation,
    the function’s execution time will always be something like
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论平台如何以及我们的实现多么巧妙，函数的执行时间始终会是类似
- en: equation 7.12\.
  id: totrans-1823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 7.12\.
- en: '![](equ7-12.jpg)'
  id: totrans-1824
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-12.jpg)'
- en: with another platform-dependent constant *C*[2]. So the execution time of fib`(`n`)`
    is exponential in n, which usually rules out using such a function in practice.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 与另一个平台相关的常数 *C*[2]。因此，fib`(`n`)`的执行时间与*n*呈指数关系，这在实践中通常排除了使用此类函数。
- en: '|  |'
  id: totrans-1826
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.16
  id: totrans-1827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结 7.16
- en: '*Multiple recursion may lead to exponential computation times.*'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: '*多重递归可能导致指数级的计算时间*。'
- en: '|  |'
  id: totrans-1829
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If we look at the nested calls in [figure 7.2](#ch07fig02), we see that we
    have the call fib`(2)` twice, and thus all the effort to compute the value for
    fib`(2)` is repeated. The following fibCacheRec function avoids such repetitions.
    It receives an additional argument, cache, which is an array that holds all values
    that have already been computed:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 [图 7.2](#ch07fig02) 中的嵌套调用，我们会看到 fib`(2)` 被调用两次，因此计算 fib`(2)` 的所有努力都被重复了。下面的
    fibCacheRec 函数避免了这种重复。它接收一个额外的参数，cache，它是一个数组，用于存储所有已计算过的值：
- en: '**`fibonacciCache.c`**'
  id: totrans-1831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`fibonacciCache.c`**'
- en: '[PRE117]'
  id: totrans-1832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: By trading storage against computation time, the recursive calls are affected
    only if the value has not yet been computed. Thus the fibCache`(`i`)` call has
    an execution time that is linear in *n*
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以存储空间换取计算时间，只有当值尚未被计算时，递归调用才会受到影响。因此，`fibCache`(`i`)`的执行时间与*n*成线性关系
- en: equation 7.13\.
  id: totrans-1834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 7.13\.
- en: '![](equ7-13.jpg)'
  id: totrans-1835
  prefs: []
  type: TYPE_IMG
  zh: '![](equ7-13.jpg)'
- en: for a platform-dependent parameter *C*[3].^([[[Exs 3]](#ch07fn-ex03)]) Just
    by changing the algorithm that implements our sequence, we are able to reduce
    the execution time from exponential to linear! We didn’t (and wouldn’t) discuss
    implementation details, nor did we perform concrete measurements of execution
    time.^([[[Exs 4]](#ch07fn-ex04)])
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个平台相关的参数 *C*[3]。^([[[例 3]](#ch07fn-ex03)]) 只需改变实现我们的序列的算法，我们就能将执行时间从指数级降低到线性级！我们没有（也不会）讨论实现细节，也没有对执行时间进行具体测量.^([[[例
    4]](#ch07fn-ex04)])
- en: ^([Exs 3])
  id: totrans-1837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 3])
- en: ''
  id: totrans-1838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove equation ([7.13](#ch07equ13)).
  id: totrans-1839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明方程式 ([7.13](#ch07equ13))。
- en: ^([Exs 4])
  id: totrans-1840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 4])
- en: ''
  id: totrans-1841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Measure times for fibCache `(`n`)` call with the same values as for fib.
  id: totrans-1842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用与 fib 相同的值测量 fibCache `(`n`)` 调用的时间。
- en: '|  |'
  id: totrans-1843
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.17
  id: totrans-1844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结 7.17
- en: '*A bad algorithm will never lead to a implementation that performs well.*'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个糟糕的算法永远不会导致性能良好的实现*。'
- en: '|  |'
  id: totrans-1846
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1847
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 7.18
  id: totrans-1848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结 7.18
- en: '*Improving an algorithm can dramatically improve performance.*'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: '*改进算法可以显著提高性能*。'
- en: '|  |'
  id: totrans-1850
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For the fun of it, fib2Rec shows a third implemented algorithm for the Fibonacci
    sequence. It gets away with a fixed-length array (FLA) instead of a variable-length
    array (VLA).
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，fib2Rec展示了实现斐波那契序列的第三个算法。它使用固定长度数组（FLA）而不是可变长度数组（VLA）。
- en: '**`fibonacci2.c`**'
  id: totrans-1852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`fibonacci2.c`**'
- en: '[PRE118]'
  id: totrans-1853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Proving that this version is still correct is left as an exercise.^([[[Exs 5]](#ch07fn-ex05)])
    Also, up to now we have only had rudimentary tools to assess whether this is “faster”
    in any sense we might want to give the term.^([[[Exs 6]](#ch07fn-ex06)])
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 证明这个版本仍然正确留作练习.^([[[Exs 5]](#ch07fn-ex05)]) 此外，到目前为止，我们只有一些基本的工具来评估这“更快”是否在任何我们想要赋予这个术语的意义上.^([[[Exs
    6]](#ch07fn-ex06)])
- en: ^([Exs 5])
  id: totrans-1855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 5])
- en: ''
  id: totrans-1856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use an iteration statement to transform fib2rec into a nonrecursive function
    fib2iter.
  id: totrans-1857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用迭代语句将fib2rec转换为非递归函数fib2iter。
- en: ^([Exs 6])
  id: totrans-1858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 6])
- en: ''
  id: totrans-1859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Measure times for fib2`(`n`)` calls with the same values as fib.
  id: totrans-1860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用与fib相同的值测量fib2`(`n`)`调用的时间。
- en: '|  |'
  id: totrans-1861
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Factorization**'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: '**因式分解**'
- en: Now that we’ve covered functions, see if you can implement a program `factor`
    that receives a number N on the command line and prints out
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了函数，看看你是否能实现一个名为`factor`的程序，该程序接收命令行上的一个数字N，并打印出
- en: '[PRE119]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: where F0 and so on are all the prime factors of N.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 其中F0以及等等都是N的所有素因子。
- en: The core of your implementation should be a function that, given a value of
    type **`size_t`**, returns its smallest prime factor.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 你的实现的核心应该是一个函数，给定一个**`size_t`**类型的值，返回其最小的素因子。
- en: '|  |'
  id: totrans-1867
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Extend this program to receive a list of such numbers and output such a line
    for each of them.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展此程序以接收此类数字的列表，并为每个数字输出此类行。
- en: Summary
  id: totrans-1869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Functions have a prototype that determines how they can be called.
  id: totrans-1870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数有一个原型，它决定了它们如何被调用。
- en: Terminating **main** and calling **exit** are the same.
  id: totrans-1871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止**main**和调用**exit**是相同的。
- en: Each function call has its own copy of local variables and can be called recursively.
  id: totrans-1872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数调用都有自己的局部变量副本，并且可以递归调用。
- en: Chapter 8\. C library functions
  id: totrans-1873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章。C库函数
- en: This chapter covers
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Doing math, handling files, and processing strings
  id: totrans-1875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行数学运算、处理文件和字符串处理
- en: Manipulating time
  id: totrans-1876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作时间
- en: Managing the runtime environment
  id: totrans-1877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理运行时环境
- en: Terminating programs
  id: totrans-1878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止程序
- en: 'The functionality that the C standard provides is separated into two big parts.
    One is the proper C language, and the other is the *C library*. We have looked
    at several functions that come with the C library, including **printf**, **puts**,
    and **strtod**, so you should have a good idea what to expect: basic tools that
    implement features that we need in everyday programming and for which we need
    clear interfaces and semantics to ensure portability.'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: C标准提供的功能分为两大块。一块是正确的C语言，另一块是*C库*。我们已经查看了一些随C库提供的函数，包括**printf**、**puts**和**strtod**，所以你应该有一个很好的预期：实现我们在日常编程中需要的特性的基本工具，并且我们需要清晰的接口和语义来确保可移植性。
- en: On many platforms, the clear specification through an *application programming
    interface* (*API*) also allows us to separate the compiler implementation from
    the library implementation. For example, on Linux systems, we have a choice of
    different compilers, most commonly `gcc` and `clang`, and different C library
    implementations, such as the GNU C library (`glibc`), `dietlibc`, or `musl`; potentially,
    any of these choices can be used to produce an executable.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多平台上，通过*应用程序编程接口*（*API*）的明确指定也允许我们将编译器实现与库实现分开。例如，在Linux系统中，我们有不同编译器的选择，最常见的是`gcc`和`clang`，以及不同的C库实现，如GNU
    C库（`glibc`）、`dietlibc`或`musl`；理论上，这些选择中的任何一个都可以用来生成可执行文件。
- en: 'We will first discuss the general properties and tools of the C library and
    its interfaces, and then describe some groups of functions: mathematical (numerical)
    functions, input/output functions, string processing, time handling, access to
    the runtime environment, and program termination.'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论C库及其接口的一般特性和工具，然后描述一些函数组：数学（数值）函数、输入/输出函数、字符串处理、时间处理、对运行时环境的访问和程序终止。
- en: 8.1\. General properties of the C library and its functions
  id: totrans-1882
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. C库及其函数的一般特性
- en: 'Roughly, library functions target one or two purposes:'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，库函数针对一个或两个目的：
- en: '***Platform abstraction layer:*** Functions that abstract from the specific
    properties and needs of the platform. These are functions that need platform-specific
    bits to implement basic operations such as IO, which could not be implemented
    without deep knowledge of the platform. For example, **puts** has to have some
    concept of a “terminal output” and how to address it. Implementing these functionalities
    would exceed the knowledge of most C programmers, because doing so requires OS-
    or even processor-specific magic. Be glad that some people did that job for you.'
  id: totrans-1884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***平台抽象层：*** 抽象出平台特定属性和需求的函数。这些是需要特定平台位来实现基本操作（如IO）的函数，没有对平台的深入了解就无法实现。例如，**puts**必须有一些关于“终端输出”以及如何访问它的概念。实现这些功能将超出大多数C程序员的认知，因为这需要操作系统或甚至处理器特定的魔法。庆幸的是，有些人已经为你做了这项工作。'
- en: '***Basic tools:*** Functions that implement a task (such as **strtod**) that
    often occurs in programming in C and for which it is important that the interface
    is fixed. These should be implemented relatively efficiently, because they are
    used a lot, and they should be well tested and bug free so we can rely safely
    on them. Implementing such functions should in principle be possible for any confirmed
    C programmer.^([[[Exs 1]](#ch08fn-ex01)])'
  id: totrans-1885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***基本工具：*** 实现常见任务（如**strtod**）的函数，这些任务在C语言编程中经常出现，并且接口的固定性非常重要。这些函数应该相对高效地实现，因为它们被大量使用，并且应该经过良好的测试，没有错误，这样我们才能安全地依赖它们。原则上，任何经过验证的C程序员都应该能够实现这样的函数。[[[例
    1]](#ch08fn-ex01)])'
- en: ^([Exs 1])
  id: totrans-1886
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 1])
- en: ''
  id: totrans-1887
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function my_strtod that implements the functionality of **strtod** for
    decimal floating-point constants.
  id: totrans-1888
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个名为my_strtod的函数，实现**strtod**对十进制浮点常数的功能。
- en: 'A function like **printf** can be viewed as targeting both purposes: it can
    effectively be separated into a formatting phase providing a basic tool and an
    output phase that is platform specific. There is a function **snprintf** (explained
    much later, in [section 14.1](kindle_split_024.html#ch14lev1sec1)) that provides
    the same formatting functionalities as **printf** but stores the result in a string.
    This string could then be printed with **puts** to give the same output as **printf**
    as a whole.'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于**printf**的函数可以视为具有双重目的：它可以有效地分为一个格式化阶段，提供基本工具，以及一个特定平台的输出阶段。有一个名为**snprintf**的函数（将在[14.1节](kindle_split_024.html#ch14lev1sec1)中详细解释）提供了与**printf**相同的格式化功能，但将结果存储在一个字符串中。这个字符串然后可以用**puts**打印出来，以产生与**printf**整体相同的输出。
- en: In the following chapters, we will discuss the different header files that declare
    the interfaces of the C library ([section 8.1.1](#ch08lev2sec1)), the different
    types of interfaces it provides ([section 8.1.2](#ch08lev2sec2)), the various
    error strategies it applies ([section 8.1.3](#ch08lev2sec3)), an optional series
    of interfaces intended to improve application safety ([section 8.1.4](#ch08lev2sec4)),
    and tools that we can use to assert platform-specific properties at compile time
    ([section 8.1.5](#ch08lev2sec5)).
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论声明C库接口的不同头文件（[8.1.1节](#ch08lev2sec1)）、它提供的不同类型的接口（[8.1.2节](#ch08lev2sec2)）、它应用的多种错误策略（[8.1.3节](#ch08lev2sec3)）、一系列可选的接口，旨在提高应用程序的安全性（[8.1.4节](#ch08lev2sec4)），以及我们可以在编译时用来断言平台特定属性的工具（[8.1.5节](#ch08lev2sec5)）。
- en: 8.1.1\. Headers
  id: totrans-1891
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 头文件
- en: The C library has a lot of functions, far more than we can handle in this book.
    A *header**^C* file bundles interface descriptions for a number of features, mostly
    functions. The header files that we will discuss here provide features of the
    C library, but later we can create our own interfaces and collect them in headers
    ([chapter 10](kindle_split_020.html#ch10)).
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: C库有很多函数，远远超过我们在这本书中能处理的范围。一个*头文件*^C*捆绑了多个功能的接口描述，主要是函数。我们将在这里讨论的头文件提供了C库的功能，但稍后我们可以创建自己的接口并将它们收集在头文件中（[第10章](kindle_split_020.html#ch10))。
- en: On this level, we will discuss the functions from the C library that are necessary
    for basic programming with the elements of the language we have seen so far. We
    will complete this discussion on higher levels, when we discuss a range of concepts.
    [Table 8.1](#ch08table01) has an overview of the standard header files.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层面上，我们将讨论C库中必要的函数，这些函数对于使用我们迄今为止看到的语言元素进行基本编程是必需的。当我们在更高层次讨论一系列概念时，我们将完成这次讨论。[表8.1](#ch08table01)概述了标准头文件。
- en: 8.1.2\. Interfaces
  id: totrans-1894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 接口
- en: 'Most interfaces in the C library are specified as functions, but implementations
    are free to choose to implement them as macros, where doing so is appropriate.
    Compared to those we saw in [section 5.6.3](kindle_split_013.html#ch05lev2sec8),
    this uses a second form of macros that are syntactically similar to functions,
    *function-like macros**^C*:'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: C 库中的大多数接口都指定为函数，但实现者可以自由选择将它们实现为宏，如果这样做是合适的。与我们在[第 5.6.3 节](kindle_split_013.html#ch05lev2sec8)中看到的不同，这使用了类似函数的第二个宏形式，*函数式宏**^C*：
- en: '[PRE120]'
  id: totrans-1896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Table 8.1\. C library headers
  id: totrans-1897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.1\. C 库头文件
- en: '| Name | Description | Section |'
  id: totrans-1898
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 章节 |'
- en: '| --- | --- | --- |'
  id: totrans-1899
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <assert.h> | Asserting runtime conditions | 8.7 |'
  id: totrans-1900
  prefs: []
  type: TYPE_TB
  zh: '| <assert.h> | 断言运行时条件 | 8.7 |'
- en: '| <complex.h> | Complex numbers | 5.7.7 |'
  id: totrans-1901
  prefs: []
  type: TYPE_TB
  zh: '| <complex.h> | 复数 | 5.7.7 |'
- en: '| <ctype.h> | Character classification and conversion | 8.4 |'
  id: totrans-1902
  prefs: []
  type: TYPE_TB
  zh: '| <ctype.h> | 字符分类和转换 | 8.4 |'
- en: '| <errno.h> | Error codes | 8.1.3 |'
  id: totrans-1903
  prefs: []
  type: TYPE_TB
  zh: '| <errno.h> | 错误代码 | 8.1.3 |'
- en: '| <fenv.h> | Floating-point environment |   |'
  id: totrans-1904
  prefs: []
  type: TYPE_TB
  zh: '| <fenv.h> | 浮点环境 |  |'
- en: '| <float.h> | Properties of floating-point types | 5.7 |'
  id: totrans-1905
  prefs: []
  type: TYPE_TB
  zh: '| <float.h> | 浮点类型属性 | 5.7 |'
- en: '| <inttypes.h> | Formatting conversion of integer types | 5.7.6 |'
  id: totrans-1906
  prefs: []
  type: TYPE_TB
  zh: '| <inttypes.h> | 整数类型的格式化转换 | 5.7.6 |'
- en: '| <iso646.h> | Alternative spellings for operators | 4.1 |'
  id: totrans-1907
  prefs: []
  type: TYPE_TB
  zh: '| <iso646.h> | 运算符的备选拼写 | 4.1 |'
- en: '| <limits.h> | Properties of integer types | 5.1.3 |'
  id: totrans-1908
  prefs: []
  type: TYPE_TB
  zh: '| <limits.h> | 整数类型属性 | 5.1.3 |'
- en: '| <locale.h> | Internationalization | 8.6 |'
  id: totrans-1909
  prefs: []
  type: TYPE_TB
  zh: '| <locale.h> | 国际化 | 8.6 |'
- en: '| <math.h> | Type-specific mathematical functions | 8.2 |'
  id: totrans-1910
  prefs: []
  type: TYPE_TB
  zh: '| <math.h> | 类型特定的数学函数 | 8.2 |'
- en: '| <setjmp.h> | Non-local jumps | 17.5 |'
  id: totrans-1911
  prefs: []
  type: TYPE_TB
  zh: '| <setjmp.h> | 非局部跳转 | 17.5 |'
- en: '| <signal.h> | Signal-handling functions | 17.6 |'
  id: totrans-1912
  prefs: []
  type: TYPE_TB
  zh: '| <signal.h> | 信号处理函数 | 17.6 |'
- en: '| <stdalign.h> | Alignment of objects | 12.7 |'
  id: totrans-1913
  prefs: []
  type: TYPE_TB
  zh: '| <stdalign.h> | 对象对齐 | 12.7 |'
- en: '| <stdarg.h> | Functions with varying numbers of arguments | 16.5.2 |'
  id: totrans-1914
  prefs: []
  type: TYPE_TB
  zh: '| <stdarg.h> | 变量参数数量的函数 | 16.5.2 |'
- en: '| <stdatomic.h> | Atomic operations | 17.6 |'
  id: totrans-1915
  prefs: []
  type: TYPE_TB
  zh: '| <stdatomic.h> | 原子操作 | 17.6 |'
- en: '| <stdbool.h> | Booleans | 3.1 |'
  id: totrans-1916
  prefs: []
  type: TYPE_TB
  zh: '| <stdbool.h> | 布尔值 | 3.1 |'
- en: '| <stddef.h> | Basic types and macros | 5.2 |'
  id: totrans-1917
  prefs: []
  type: TYPE_TB
  zh: '| <stddef.h> | 基本类型和宏 | 5.2 |'
- en: '| <stdint.h> | Exact-width integer types | 5.7.6 |'
  id: totrans-1918
  prefs: []
  type: TYPE_TB
  zh: '| <stdint.h> | 精确宽度整数类型 | 5.7.6 |'
- en: '| <stdio.h> | Input and output | 8.3 |'
  id: totrans-1919
  prefs: []
  type: TYPE_TB
  zh: '| <stdio.h> | 输入和输出 | 8.3 |'
- en: '| <stdlib.h> | Basic functions | 2 |'
  id: totrans-1920
  prefs: []
  type: TYPE_TB
  zh: '| <stdlib.h> | 基本函数 | 2 |'
- en: '| <stdnoreturn.h> | Non-returning functions | 7 |'
  id: totrans-1921
  prefs: []
  type: TYPE_TB
  zh: '| <stdnoreturn.h> | 不返回的函数 | 7 |'
- en: '| <string.h> | String handling | 8.4 |'
  id: totrans-1922
  prefs: []
  type: TYPE_TB
  zh: '| <string.h> | 字符串处理 | 8.4 |'
- en: '| <tgmath.h> | Type-generic mathematical functions | 8.2 |'
  id: totrans-1923
  prefs: []
  type: TYPE_TB
  zh: '| <tgmath.h> | 类型通用的数学函数 | 8.2 |'
- en: '| <threads.h> | Threads and control structures | 18 |'
  id: totrans-1924
  prefs: []
  type: TYPE_TB
  zh: '| <threads.h> | 线程和控制结构 | 18 |'
- en: '| <time.h> | Handling time | 8.5 |'
  id: totrans-1925
  prefs: []
  type: TYPE_TB
  zh: '| <time.h> | 时间处理 | 8.5 |'
- en: '| <uchar.h> | Unicode characters | 14.3 |'
  id: totrans-1926
  prefs: []
  type: TYPE_TB
  zh: '| <uchar.h> | Unicode 字符 | 14.3 |'
- en: '| <wchar.h> | Wide strings | 14.3 |'
  id: totrans-1927
  prefs: []
  type: TYPE_TB
  zh: '| <wchar.h> | 宽字符串 | 14.3 |'
- en: '| <wctype.h> | Wide character classification and conversion | 14.3 |'
  id: totrans-1928
  prefs: []
  type: TYPE_TB
  zh: '| <wctype.h> | 宽字符分类和转换 | 14.3 |'
- en: As before, these are just textual replacements, and since the replacement text
    may contain a macro argument several times, it would be bad to pass any expression
    with side effects to such a macro or function. Hopefully, our previous discussion
    about side effects ([takeaway 4.11](kindle_split_012.html#ch04note12)) has already
    convinced you not to do that.
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些只是文本替换，由于替换文本可能包含宏参数多次，因此将任何具有副作用的表达式传递给这样的宏或函数是不好的。希望我们之前关于副作用（[要点 4.11](kindle_split_012.html#ch04note12)）的讨论已经说服您不要这样做。
- en: Some of the interfaces we will look at have arguments or return values that
    are pointers. We can’t handle these completely yet, but in most cases we can get
    away with passing in known pointers or `0` for pointer arguments. Pointers as
    return values will only occur in situations where they can be interpreted as an
    error condition.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的一些接口具有指针作为参数或返回值。我们目前还不能完全处理这些，但在大多数情况下，我们可以通过传递已知的指针或为指针参数传递`0`来避免问题。作为返回值的指针只会在它们可以解释为错误条件的情况下出现。
- en: 8.1.3\. Error checking
  id: totrans-1931
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 错误检查
- en: 'C library functions usually indicate failure through a special return value.
    What value indicates the failure can be different and depends on the function
    itself. Generally, you have to look up the specific convention in the manual page
    for the functions. [Table 8.2](#ch08table02) gives a rough overview of the possibilities.
    There are three categories that apply: a special value that indicates an error,
    a special value that indicates success, and functions that return some sort of
    positive counter on success and a negative value on failure.'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: C库函数通常通过特殊的返回值来指示失败。指示失败的具体值可能不同，这取决于函数本身。通常，你必须查阅函数的手册页中的具体约定。[表8.2](#ch08table02)给出了可能性的大致概述。有三个类别适用：指示错误的特殊值，指示成功的特殊值，以及那些在成功时返回某种正计数器，在失败时返回负值的函数。
- en: Table 8.2\. *Error return strategies for C library functions* Some functions
    may also indicate a specific error condition through the value of the **`errno`**
    macro.
  id: totrans-1933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.2\. *C库函数的错误返回策略* 一些函数也可能通过**`errno`**宏的值来指示特定的错误条件。
- en: '| Failure return | Test | Typical case | Example |'
  id: totrans-1934
  prefs: []
  type: TYPE_TB
  zh: '| 失败返回 | 测试 | 典型情况 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1935
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | !value | Other values are valid | **fopen** |'
  id: totrans-1936
  prefs: []
  type: TYPE_TB
  zh: '| 0 | !value | 其他值有效 | **fopen** |'
- en: '| Special error code | value == code | Other values are valid | **puts**, **clock**,
    **mktime**, **strtod**, **fclose** |'
  id: totrans-1937
  prefs: []
  type: TYPE_TB
  zh: '| 特殊错误代码 | value == code | 其他值有效 | **puts**，**clock**，**mktime**，**strtod**，**fclose**
    |'
- en: '| Nonzero value | value | Value otherwise unneeded | **fgetpos**, **fsetpos**
    |'
  id: totrans-1938
  prefs: []
  type: TYPE_TB
  zh: '| 非零值 | value | 不需要的值 | **fgetpos**，**fsetpos** |'
- en: '| Special success code | value != code | Case distinction for failure condition
    | **thrd_create** |'
  id: totrans-1939
  prefs: []
  type: TYPE_TB
  zh: '| 特殊成功代码 | value != code | 失败条件的区分 | **thrd_create** |'
- en: '| Negative value | value < 0 | Positive value is a counter | **printf** |'
  id: totrans-1940
  prefs: []
  type: TYPE_TB
  zh: '| 负值 | value < 0 | 正值是一个计数器 | **printf** |'
- en: 'Typical error-checking code looks like the following:'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的错误检查代码如下：
- en: '[PRE121]'
  id: totrans-1942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here we see that **puts** falls into the category of functions that return a
    special value on error, **`EOF`**, “end-of-file.” The **perror** function from
    `stdio.h` is then used to provide an additional diagnostic that depends on the
    specific error. **exit** ends the program execution. Don’t wipe failures under
    the carpet. In programming,
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到**puts**属于那些在出错时返回特殊值（**`EOF`**），即“文件结束”的函数类别。然后，`stdio.h`中的**perror**函数被用来提供依赖于特定错误的附加诊断。**exit**结束程序执行。不要把失败隐藏在地毯下。在编程中，
- en: '|  |'
  id: totrans-1944
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdio.h>`'
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdio.h>`'
- en: '|  |'
  id: totrans-1946
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1947
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.1
  id: totrans-1948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.1
- en: '*Failure is always an option.*'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: '*失败总是一个选择。*'
- en: '|  |'
  id: totrans-1950
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1951
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.2
  id: totrans-1952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.2
- en: '*Check the return value of library functions for errors.*'
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查库函数的返回值以查找错误。*'
- en: '|  |'
  id: totrans-1954
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: An immediate failure of the program is often the best way to ensure that bugs
    are detected and get fixed early in development.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 程序立即失败通常是确保在开发早期发现并修复错误的最佳方式。
- en: '|  |'
  id: totrans-1956
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.3
  id: totrans-1957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.3
- en: '*Fail fast, fail early, and fail often.*'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速失败，尽早失败，经常失败。*'
- en: '|  |'
  id: totrans-1959
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'C has one major state variable that tracks errors of C library functions: a
    dinosaur called **`errno`**. The **perror** function uses this state under the
    hood, to provide its diagnostic. If a function fails in a way that allows us to
    recover, we have to ensure that the error state also is reset; otherwise, the
    library functions or error checking might get confused:'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: C有一个主要的跟踪C库函数错误的状态变量：一个叫做**`errno`**的恐龙。**perror**函数在幕后使用这个状态，以提供其诊断。如果一个函数以允许我们恢复的方式失败，我们必须确保错误状态也被重置；否则，库函数或错误检查可能会困惑：
- en: '![](comm.jpg)'
  id: totrans-1961
  prefs: []
  type: TYPE_IMG
  zh: '![comm.jpg](comm.jpg)'
- en: '[PRE122]'
  id: totrans-1962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 8.1.4\. Bounds-checking interfaces
  id: totrans-1963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4\. 边界检查接口
- en: Many of the functions in the C library are vulnerable to *buffer overflow**^C*
    if they are called with an inconsistent set of parameters. This led (and still
    leads) to a lot of security bugs and exploits and is generally something that
    should be handled very carefully.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 许多C库函数在用不一致的参数集调用时容易受到**缓冲区溢出**的影响。这导致了（并且仍然导致）许多安全漏洞和利用，通常应该非常小心地处理。
- en: 'C11 addressed this sort of problem by deprecating or removing some functions
    from the standard and by adding an optional series of new interfaces that check
    consistency of the parameters at runtime. These are the *bounds-checking interfaces*
    of *Annex K* of the C standard. Unlike most other features, this doesn’t come
    with its own header file but adds interfaces to others. Two macros regulate access
    to theses interface: **`__STDC_LIB_EXT1__`** tells whether this optional interfaces
    is supported, and **`__STDC_WANT_LIB_EXT1__`** switches it on. The latter must
    be set before any header files are included:'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: C11通过废弃或删除标准中的一些函数，并添加一系列可选的新接口来检查运行时参数的一致性来解决这类问题。这些是C标准附录K的*边界检查接口*。与大多数其他功能不同，它没有自己的头文件，而是向其他接口添加了接口。两个宏控制对这些接口的访问：**`__STDC_LIB_EXT1__`**指示是否支持此可选接口，**`__STDC_WANT_LIB_EXT1__`**将其打开。后者必须在包含任何头文件之前设置：
- en: '[PRE123]'
  id: totrans-1966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This mechanism was (and still is) open to much debate, and therefore Annex K
    is an optional feature. Many modern platforms have consciously chosen not to support
    it. There even has been an extensive study by O’Donell and Sebor [[2015](kindle_split_036.html#bib13)]
    that concluded that the introduction of these interfaces has created many more
    problems than it solved. In the following, such optional features are marked with
    a gray background.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制（现在仍然是）引起了大量争议，因此附录K是一个可选功能。许多现代平台有意识地选择不支持它。甚至有O’Donell和Sebor [[2015](kindle_split_036.html#bib13)]进行的一项广泛研究，该研究得出结论，引入这些接口比解决的问题要多得多。在以下内容中，这样的可选功能将以灰色背景标记。
- en: '|  |'
  id: totrans-1968
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Annex K**'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: '**附录K**'
- en: The bounds-checking functions usually use the suffix _s on the name of the library
    function they replace, such as **printf_s** for **printf**. So you should not
    use that suffix for code of your own.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 边界检查函数通常使用它们所替代的库函数名称上的后缀_s，例如**printf_s**用于**printf**。因此，你不应该为你的代码使用该后缀。
- en: '|  |'
  id: totrans-1971
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.4
  id: totrans-1972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 8.4
- en: Takeaway 8.4
  id: totrans-1973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 8.4
- en: '*Identifier names terminating with* *`_s`* *are reserved.*'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* *`_s`* *结尾的标识符名称是保留的*。'
- en: '|  |'
  id: totrans-1975
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If such a function encounters an inconsistency, a *runtime constraint violation**^C*,
    it usually should end program execution after printing a diagnostic.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样的函数遇到不一致的情况，即*运行时约束违规**^C*，它通常应该在打印诊断信息后结束程序执行。
- en: '|  |'
  id: totrans-1977
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.1.5\. Platform preconditions
  id: totrans-1978
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.5\. 平台先决条件
- en: An important goal of programming with a standardized language such as C is portability.
    We should make as few assumptions about the execution platform as possible and
    leave it to the C compiler and library to fill in the gaps. Unfortunately, this
    is not always an option, in which case we should clearly identify code preconditions.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像C这样的标准化语言进行编程的一个重要目标是可移植性。我们应该尽可能少地对执行平台做出假设，并将其留给C编译器和库来填补空白。不幸的是，这并不总是可行的选择，在这种情况下，我们应该清楚地识别代码先决条件。
- en: '|  |'
  id: totrans-1980
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.5
  id: totrans-1981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 8.5
- en: '*Missed preconditions for the execution platform must abort compilation.*'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于执行平台的遗漏先决条件必须终止编译*。'
- en: '|  |'
  id: totrans-1983
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The classic tools to achieve this are *preprocessor conditionals**^C*, as we
    saw earlier:'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的经典工具是*预处理器条件**^C*，正如我们之前看到的：
- en: '[PRE124]'
  id: totrans-1985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As you can see, such a conditional starts with the token sequence **`# if`**
    on a line and terminates with another line containing the sequence **`# endif`**.
    The **`# error`** directive in the middle is executed only if the condition (here
    `!`**`__STDC_LIB_EXT1__`**) is true. It aborts the compilation process with an
    error message. The conditions that we can place in such a construct are limited.^([[[Exs
    2]](#ch08fn-ex02)])
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这样的条件从一行上的**`# if`**标记序列开始，并以包含另一个序列**`# endif`**的行结束。中间的**`# error`**指令仅在条件（这里为`!`**`__STDC_LIB_EXT1__`**）为真时执行。它通过错误消息终止编译过程。我们可以放入此类构造的条件是有限的.^([[[Exs
    2]](#ch08fn-ex02)])
- en: ^([Exs 2])
  id: totrans-1987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-1988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a preprocessor condition that tests whether **`int`** has two’s complement
    sign representation.
  id: totrans-1989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个前处理器条件，以测试**`int`**是否具有二进制补码表示。
- en: '|  |'
  id: totrans-1990
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.6
  id: totrans-1991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 8.6
- en: '*Only evaluate macros and integer literals in a preprocessor condition.*'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: '*仅在前处理器条件中评估宏和整数文字*。'
- en: '|  |'
  id: totrans-1993
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As an extra feature in these conditions, identifiers that are unknown evaluate
    to `0`. So, in the previous example, the expression is valid, even if **`__STDC_LIB_EXT1__`**
    is unknown at that point.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些条件的一个额外功能，未知的标识符将评估为`0`。所以，在上一个例子中，即使**`__STDC_LIB_EXT1__`**在那个时刻是未知的，表达式也是有效的。
- en: '|  |'
  id: totrans-1995
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.7
  id: totrans-1996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 8.7
- en: '*In preprocessor conditions, unknown identifiers evaluate to* *`0`**.*'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: '*在预处理器条件中，未知标识符的值为* *`0`**.*'
- en: '|  |'
  id: totrans-1998
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If we want to test a more sophisticated condition, **`_Static_assert`** (a
    keyword) and **`static_assert`** (a macro from the header `assert.h`) have a similar
    effect and are at our disposal:'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要测试更复杂的条件，**`_Static_assert`**（一个关键字）和**`static_assert`**（来自头文件 `assert.h`
    的宏）具有相似的效果，并且可供我们使用：
- en: '|  |'
  id: totrans-2000
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<assert.h>`'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: '`<assert.h>`'
- en: '|  |'
  id: totrans-2002
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE125]'
  id: totrans-2003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 8.2\. Mathematics
  id: totrans-2004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 数学
- en: Mathematical *functions* come with the `math.h` header, but it is much simpler
    to use the type-generic macros that come with `tgmath.h`. Basically, for all functions,
    it has a macro that dispatches an invocation such as **`sin`**`(`x`)` or **`pow`**`(`x`,`
    n`)` to the function that inspects the type of x in its argument and for which
    the return value is of that same type.
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 数学 *函数* 随 `math.h` 头文件提供，但使用 `tgmath.h` 提供的类型通用宏要简单得多。基本上，对于所有函数，都有一个宏将调用例如
    **`sin`**`(`x`)` 或 **`pow`**`(`x`,` n`)` 的函数分配给检查其参数类型并返回相同类型的函数。
- en: '|  |'
  id: totrans-2006
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<math.h>`'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: '`<math.h>`'
- en: '`<tgmath.h>`'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tgmath.h>`'
- en: '|  |'
  id: totrans-2009
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The type-generic macros that are defined are far too many to describe in detail
    here. [Table 8.3](#ch08table03) gives an overview of the functions that are provided.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的类型通用的宏太多，无法在此详细描述。[表8.3](#ch08table03) 提供了提供的函数的概述。
- en: Table 8.3\. *Mathematical functions* In the electronic versions of the book,
    type-generic macros appear in red, and plain functions in green.
  id: totrans-2011
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.3\. *数学函数* 在本书的电子版中，类型通用的宏以红色显示，而普通函数以绿色显示。
- en: '| Function | Description |'
  id: totrans-2012
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-2013
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **abs**, **labs**, **llabs** | &#124;*x*&#124; for integers |'
  id: totrans-2014
  prefs: []
  type: TYPE_TB
  zh: '| **abs**, **labs**, **llabs** | 整数的绝对值，&#124;*x*&#124; |'
- en: '| **acosh** | Hyperbolic arc cosine |'
  id: totrans-2015
  prefs: []
  type: TYPE_TB
  zh: '| **acosh** | 双曲余弦函数 |'
- en: '| **acos** | Arc cosine |'
  id: totrans-2016
  prefs: []
  type: TYPE_TB
  zh: '| **acos** | 反余弦 |'
- en: '| **asinh** | Hyperbolic arc sine |'
  id: totrans-2017
  prefs: []
  type: TYPE_TB
  zh: '| **asinh** | 双曲反正弦 |'
- en: '| **asin** | Arc sine |'
  id: totrans-2018
  prefs: []
  type: TYPE_TB
  zh: '| **asin** | 反正弦 |'
- en: '| **atan2** | Arc tangent, two arguments |'
  id: totrans-2019
  prefs: []
  type: TYPE_TB
  zh: '| **atan2** | 反正切，两个参数 |'
- en: '| **atanh** | Hyperbolic arc tangent |'
  id: totrans-2020
  prefs: []
  type: TYPE_TB
  zh: '| **atanh** | 双曲反正切 |'
- en: '| **atan** | Arc tangent |'
  id: totrans-2021
  prefs: []
  type: TYPE_TB
  zh: '| **atan** | 反正切 |'
- en: '| **cbrt** | ![](pg_119-1.jpg) |'
  id: totrans-2022
  prefs: []
  type: TYPE_TB
  zh: '| **cbrt** | ![图片](pg_119-1.jpg) |'
- en: '| **ceil** | ⌈*x*⌉ |'
  id: totrans-2023
  prefs: []
  type: TYPE_TB
  zh: '| **ceil** | ⌈*x*⌉ |'
- en: '| **copysign** | Copies the sign from *y* to *x* |'
  id: totrans-2024
  prefs: []
  type: TYPE_TB
  zh: '| **copysign** | 从 *y* 复制符号到 *x* |'
- en: '| **cosh** | Hyperbolic cosine |'
  id: totrans-2025
  prefs: []
  type: TYPE_TB
  zh: '| **cosh** | 双曲余弦 |'
- en: '| **cos** | Cosine function, cos *x* |'
  id: totrans-2026
  prefs: []
  type: TYPE_TB
  zh: '| **cos** | 余弦函数，cos *x* |'
- en: '| **div**, **ldiv**, **lldiv** | Quotient and remainder of integer division
    |'
  id: totrans-2027
  prefs: []
  type: TYPE_TB
  zh: '| **div**, **ldiv**, **lldiv** | 整数除法的商和余数 |'
- en: '| **erfc** | Complementary error function, ![](pg_119-2.jpg) |'
  id: totrans-2028
  prefs: []
  type: TYPE_TB
  zh: '| **erfc** | 补余误差函数，![图片](pg_119-2.jpg) |'
- en: '| **erf** | Error function, ![](pg_119-3.jpg) |'
  id: totrans-2029
  prefs: []
  type: TYPE_TB
  zh: '| **erf** | 误差函数，![图片](pg_119-3.jpg) |'
- en: '| **exp2** | 2*^x* |'
  id: totrans-2030
  prefs: []
  type: TYPE_TB
  zh: '| **exp2** | 2*^x* |'
- en: '| **expm1** | *e**^x* – 1 |'
  id: totrans-2031
  prefs: []
  type: TYPE_TB
  zh: '| **expm1** | *e**^x* – 1 |'
- en: '| **exp** | *e**^x* |'
  id: totrans-2032
  prefs: []
  type: TYPE_TB
  zh: '| **exp** | *e**^x* |'
- en: '| **fabs** | &#124;*x*&#124; for floating point |'
  id: totrans-2033
  prefs: []
  type: TYPE_TB
  zh: '| **fabs** | 浮点数的绝对值，&#124;*x*&#124; |'
- en: '| **fdim** | Positive difference |'
  id: totrans-2034
  prefs: []
  type: TYPE_TB
  zh: '| **fdim** | 正差 |'
- en: '| **floor** | *⌊**x**⌋* |'
  id: totrans-2035
  prefs: []
  type: TYPE_TB
  zh: '| **floor** | *⌊**x**⌋* |'
- en: '| **fmax** | Floating-point maximum |'
  id: totrans-2036
  prefs: []
  type: TYPE_TB
  zh: '| **fmax** | 浮点数最大值 |'
- en: '| **fma** | *x* · *y* + *z* |'
  id: totrans-2037
  prefs: []
  type: TYPE_TB
  zh: '| **fma** | *x* · *y* + *z* |'
- en: '| **fmin** | Floating-point minimum |'
  id: totrans-2038
  prefs: []
  type: TYPE_TB
  zh: '| **fmin** | 浮点数最小值 |'
- en: '| **fmod** | Remainder of floating-point division |'
  id: totrans-2039
  prefs: []
  type: TYPE_TB
  zh: '| **fmod** | 浮点数除法的余数 |'
- en: '| **fpclassify** | Classifies a floating-point value |'
  id: totrans-2040
  prefs: []
  type: TYPE_TB
  zh: '| **fpclassify** | 对浮点值进行分类 |'
- en: '| **frexp** | Significand and exponent |'
  id: totrans-2041
  prefs: []
  type: TYPE_TB
  zh: '| **frexp** | 尾数和指数 |'
- en: '| **hypot** | ![](pg_120-1.jpg) |'
  id: totrans-2042
  prefs: []
  type: TYPE_TB
  zh: '| **hypot** | ![图片](pg_120-1.jpg) |'
- en: '| **ilogb** | ⌊log[*FLT*_*RADIX*]^(*x*)*⌋* as integer |'
  id: totrans-2043
  prefs: []
  type: TYPE_TB
  zh: '| **ilogb** | ⌊log[*FLT*_*RADIX*]^(*x*)*⌋* 作为整数 |'
- en: '| **isfinite** | Checks if finite |'
  id: totrans-2044
  prefs: []
  type: TYPE_TB
  zh: '| **isfinite** | 检查是否为有限值 |'
- en: '| **isinf** | Checks if infinite |'
  id: totrans-2045
  prefs: []
  type: TYPE_TB
  zh: '| **isinf** | 检查是否为无穷大 |'
- en: '| **isnan** | Checks if NaN |'
  id: totrans-2046
  prefs: []
  type: TYPE_TB
  zh: '| **isnan** | 检查是否为 NaN |'
- en: '| **isnormal** | Checks if normal |'
  id: totrans-2047
  prefs: []
  type: TYPE_TB
  zh: '| **isnormal** | 检查是否为正常值 |'
- en: '| **ldexp** | *x* · 2*^y* |'
  id: totrans-2048
  prefs: []
  type: TYPE_TB
  zh: '| **ldexp** | *x* · 2*^y* |'
- en: '| **lgamma** | log*[e]* Γ(*x*) |'
  id: totrans-2049
  prefs: []
  type: TYPE_TB
  zh: '| **lgamma** | log*[e]* Γ(*x*) |'
- en: '| **log10** | log[10]*x* |'
  id: totrans-2050
  prefs: []
  type: TYPE_TB
  zh: '| **log10** | log[10]*x* |'
- en: '| **log1p** | log*[e]*(1 + *x*) |'
  id: totrans-2051
  prefs: []
  type: TYPE_TB
  zh: '| **log1p** | log*[e]*(1 + *x*) |'
- en: '| **log2** | log[2]*x* |'
  id: totrans-2052
  prefs: []
  type: TYPE_TB
  zh: '| **log2** | log[2]*x* |'
- en: '| **logb** | log[*FLT*_*RADIX*]^(*x*) as floating point |'
  id: totrans-2053
  prefs: []
  type: TYPE_TB
  zh: '| **logb** | log[*FLT*_*RADIX*]^(*x*) 作为浮点数 |'
- en: '| **log** | log*[e]* *x* |'
  id: totrans-2054
  prefs: []
  type: TYPE_TB
  zh: '| **log** | log*[e]* *x* |'
- en: '| **modf**, **modff**, **modfl** | Integer and fractional parts |'
  id: totrans-2055
  prefs: []
  type: TYPE_TB
  zh: '| **modf**, **modff**, **modfl** | 整数部分和小数部分 |'
- en: '| **nan**, **nanf**, **nanl** | Not-a-number (NaN) of the corresponding type
    |'
  id: totrans-2056
  prefs: []
  type: TYPE_TB
  zh: '| **nan**, **nanf**, **nanl** | 对应类型的非数字 (NaN) |'
- en: '| **nearbyint** | Nearest integer using the current rounding mode |'
  id: totrans-2057
  prefs: []
  type: TYPE_TB
  zh: '| **nearbyint** | 使用当前舍入模式找到最近的整数 |'
- en: '| **nextafter**, **nexttoward** | Next representable floating-point value |'
  id: totrans-2058
  prefs: []
  type: TYPE_TB
  zh: '| **nextafter**, **nexttoward** | 下一个可表示的浮点数值 |'
- en: '| **pow** | *x**^y* |'
  id: totrans-2059
  prefs: []
  type: TYPE_TB
  zh: '| **pow** | *x**^y* |'
- en: '| **remainder** | Signed remainder of division |'
  id: totrans-2060
  prefs: []
  type: TYPE_TB
  zh: '| **remainder** | 除法的有符号余数 |'
- en: '| **remquo** | Signed remainder and the last bits of the division |'
  id: totrans-2061
  prefs: []
  type: TYPE_TB
  zh: '| **remquo** | 有符号余数和除法的最后几位 |'
- en: '| **rint**, **lrint**, **llrint** | Nearest integer using the current rounding
    mode |'
  id: totrans-2062
  prefs: []
  type: TYPE_TB
  zh: '| **rint**, **lrint**, **llrint** | 使用当前舍入模式最近的整数 |'
- en: '| **round**, **lround**, **llround** | sign(x) ·⌊&#124;*x*&#124; + 0.5⌋ |'
  id: totrans-2063
  prefs: []
  type: TYPE_TB
  zh: '| **round**, **lround**, **llround** | sign(x) ·⌊&#124;*x*&#124; + 0.5⌋ |'
- en: '| **scalbn**, **scalbln** | *x* · **FLT_RADIX***^y* |'
  id: totrans-2064
  prefs: []
  type: TYPE_TB
  zh: '| **scalbn**, **scalbln** | *x* · **FLT_RADIX***^y* |'
- en: '| **signbit** | Checks if negative |'
  id: totrans-2065
  prefs: []
  type: TYPE_TB
  zh: '| **signbit** | 检查是否为负 |'
- en: '| **sinh** | Hyperbolic sine |'
  id: totrans-2066
  prefs: []
  type: TYPE_TB
  zh: '| **sinh** | 双曲正弦 |'
- en: '| **sin** | Sine function, sin *x* |'
  id: totrans-2067
  prefs: []
  type: TYPE_TB
  zh: '| **sin** | 正弦函数，sin *x* |'
- en: '| **sqrt** | ![](pg_121-1.jpg) |'
  id: totrans-2068
  prefs: []
  type: TYPE_TB
  zh: '| **sqrt** | ![](pg_121-1.jpg) |'
- en: '| **tanh** | Hyperbolic tangent |'
  id: totrans-2069
  prefs: []
  type: TYPE_TB
  zh: '| **tanh** | 双曲正切 |'
- en: '| **tan** | Tangent function, tan *x* |'
  id: totrans-2070
  prefs: []
  type: TYPE_TB
  zh: '| **tan** | 正切函数，tan *x* |'
- en: '| **tgamma** | Gamma function, Γ(*x*) |'
  id: totrans-2071
  prefs: []
  type: TYPE_TB
  zh: '| **tgamma** | Γ函数，Γ(*x*) |'
- en: '| **trunc** | sign(x) ·⌊&#124;*x*&#124;⌋ |'
  id: totrans-2072
  prefs: []
  type: TYPE_TB
  zh: '| **trunc** | sign(x) ·⌊&#124;*x*&#124;⌋ |'
- en: Nowadays, implementations of numerical functions should be high quality, be
    efficient, and have well-controlled numerical precision. Although any of these
    functions could be implemented by a programmer with sufficient numerical knowledge,
    you should not try to replace or circumvent them. Many of them are not just implemented
    as C functions but also can use processor-specific instructions. For example,
    processors may have fast approximations of **`sqrt`** and **`sin`** functions,
    or implement a *floating-point multiply add*, **`fma`**, in a low-level instruction.
    In particular, there is a good chance that such low-level instructions are used
    for all functions that inspect or modify floating-point internals, such as **carg**,
    **`creal`**, **`fabs`**, **`frexp`**, **`ldexp`**, **`llround`**, **`lround`**,
    **`nearbyint`**, **`rint`**, **`round`**, **`scalbn`**, and **`trunc`**. So, replacing
    them or reimplementing them in handcrafted code is usually a bad idea.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数值函数的实现应该是高质量的、高效的，并且具有良好的数值精度控制。尽管任何具有足够数值知识的程序员都可以实现这些函数，但你不应尝试替换或绕过它们。其中许多不仅作为C函数实现，还可以使用处理器特定的指令。例如，处理器可能具有**`sqrt`**和**`sin`**函数的快速近似，或者通过低级指令实现*浮点乘加**`fma`**。特别是，有很好的机会这些低级指令被用于检查或修改浮点内部的所有函数，例如**carg**、**`creal`**、**`fabs`**、**`frexp`**、**`ldexp`**、**`llround`**、**`lround`**、**`nearbyint`**、**`rint`**、**`round`**、**`scalbn`**和**`trunc`**。因此，替换它们或在手工编写的代码中重新实现它们通常是一个坏主意。
- en: 8.3\. Input, output, and file manipulation
  id: totrans-2074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. 输入、输出和文件操作
- en: 'We have seen some of the IO functions that come with the header file `stdio.h`:
    **puts** and **printf**. Whereas the second lets you format output in a convenient
    fashion, the first is more basic: it just outputs a string (its argument) and
    an end-of-line character.'
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些与头文件`stdio.h`一起提供的IO函数：**puts**和**printf**。第二个函数允许你以方便的方式格式化输出，而第一个则更基本：它只是输出一个字符串（其参数）和一个换行符。
- en: '|  |'
  id: totrans-2076
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdio.h>`'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdio.h>`'
- en: '|  |'
  id: totrans-2078
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.3.1\. Unformatted text output
  id: totrans-2079
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1. 无格式文本输出
- en: 'There is an even more basic function than **puts**: **`putchar`**, which outputs
    a single character. The interfaces of these two functions are as follows:'
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个比**puts**更基本的功能：**`putchar`**，它输出单个字符。这两个函数的接口如下：
- en: '[PRE126]'
  id: totrans-2081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The type **`int`** as a parameter for **`putchar`** is a historical accident
    that shouldn’t hurt you much. In contrast to that, having a return type of **`int`**
    is necessary so the function can return errors to its caller. In particular, it
    returns the argument c if successful and a specific negative value **`EOF`** (*E*nd
    *O*f *F*ile) that is guaranteed not to correspond to any character on failure.
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 将**`int`**类型作为**`putchar`**的参数是一个历史事件，它不会对你造成太大的伤害。相比之下，返回类型为**`int`**是必要的，以便函数可以将其错误返回给调用者。特别是，如果成功，它返回参数c，如果失败，则返回特定的负值**`EOF`**（*E*nd
    *O*f *F*ile），该值保证不会对应于任何字符。
- en: '![](comm.jpg)'
  id: totrans-2083
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: 'With this function, we could actually reimplement **puts** ourselves:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，我们实际上可以自己重新实现**puts**：
- en: '[PRE127]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This is just an example; it is probably less efficient than the **puts** that
    your platform provides.
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子；它可能不如你的平台提供的**puts**高效。
- en: 'Up to now, we have only seen how to output to the terminal. Often, you’ll want
    to write results to permanent storage, and the type **`FILE`**`*` for *streams**^C*
    provides an abstraction for this. There are two functions, **fputs** and **fputc**,
    that generalize the idea of unformatted output to streams:'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了如何输出到终端。通常，你可能会想将结果写入永久存储，而类型**`FILE`**`*`为*流**^C*提供了一个抽象。有两个函数，**fputs**和**fputc**，它们将无格式输出的概念推广到流中：
- en: '[PRE128]'
  id: totrans-2088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Here, the `*` in the **`FILE`**`*` type again indicates that this is a pointer
    type, and we won’t go into the details. The only thing we need to know for now
    is that a pointer can be tested whether it is null ([takeaway 6.20](kindle_split_014.html#ch06note21)),
    so we will be able to test whether a stream is valid.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**`FILE`** 类型中的 `*` 再次表示这是一个指针类型，我们不会深入细节。我们现在需要知道的是，指针可以被测试是否为空 ([收获 6.20](kindle_split_014.html#ch06note21))，因此我们将能够测试流是否有效。
- en: The identifier **`FILE`** represents an *opaque type**^C*, for which we don’t
    know more than is provided by the functional interfaces that we will see in this
    chapter. The fact that it is implemented as a macro, and the misuse of the name
    “FILE” for a stream is a reminder that this is one of the historical interfaces
    that predate standardization.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符 **`FILE`** 代表一个 *不透明类型*^C*，对于这个类型，我们只知道在本书中将要看到的函数接口所提供的信息。它被实现为一个宏，以及将“FILE”这个名字用于流的使用不当，都是提醒我们这是历史上预标准化之前的一个接口。
- en: '![](comm.jpg)'
  id: totrans-2091
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: '|  |'
  id: totrans-2092
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.8
  id: totrans-2093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 8.8
- en: '*Opaque types are specified through functional interfaces.*'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: '*不透明类型通过函数接口指定*。'
- en: '|  |'
  id: totrans-2095
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-2096
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.9
  id: totrans-2097
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 8.9
- en: '*Don’t rely on implementation details of opaque types.*'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要依赖于不透明类型的实现细节*。'
- en: '|  |'
  id: totrans-2099
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If we don’t do anything special, two streams are available for output: **`stdout`**
    and **`stderr`**. We have already used **`stdout`** implicitly: this is what **`putchar`**
    and **puts** use under the hood, and this stream is usually connected to the terminal.
    **`stderr`** is similar and also is linked to the terminal by default, with perhaps
    slightly different properties. In any case, these two are closely related. The
    purpose of having two of them is to be able to distinguish “usual” output (**`stdout`**)
    from “urgent” output (**`stderr`**).'
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不进行任何特殊操作，将有两个输出流可用：**`stdout`** 和 **`stderr`**。我们已经在隐式地使用 **`stdout`**：这是
    **`putchar`** 和 **puts** 在底层使用的，并且这个流通常连接到终端。**`stderr`** 类似，默认情况下也连接到终端，可能具有略微不同的属性。无论如何，这两个流是紧密相关的。拥有两个流的目的在于能够区分“常规”输出（**`stdout`**）和“紧急”输出（**`stderr`**）。
- en: 'We can rewrite the previous functions in terms of the more general ones:'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用更通用的函数重写之前的函数：
- en: '[PRE129]'
  id: totrans-2102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Observe that **fputs** differs from **puts** in that it doesn’t append an end-of-line
    character to the string.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 **fputs** 与 **puts** 的不同之处在于它不会在字符串中追加行结束字符。
- en: '|  |'
  id: totrans-2104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.10
  id: totrans-2105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获 8.10
- en: '**puts** *and* **fputs** *differ in their end-of-line handling.*'
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: '**puts** 和 **fputs** 在行结束处理方面有所不同。'
- en: '|  |'
  id: totrans-2107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.3.2\. Files and streams
  id: totrans-2108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 文件和流
- en: 'If we want to write output to real files, we have to attach the files to our
    program execution by means of the function **fopen**:'
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将输出写入实际文件，我们必须通过函数 **fopen** 将文件附加到我们的程序执行中：
- en: '[PRE130]'
  id: totrans-2110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This can be used as simply as here:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以像这里一样简单使用：
- en: '[PRE131]'
  id: totrans-2112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This *opens a file**^C* called "mylog.txt" in the file system and provides
    access to it through the variable logfile. The mode argument "a" opens the file
    for appending: that is, the contents of the file are preserved, if they exist,
    and writing begins at the current end of that file.'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开文件系统中的一个名为 "mylog.txt" 的文件，并通过变量 logfile 提供对其的访问。模式参数 "a" 用于追加文件：也就是说，如果文件存在，则保留其内容，并从该文件的当前末尾开始写入。
- en: 'There are multiple reasons why opening a file might not succeed: for example,
    the file system might be full, or the process might not have permission to write
    at the indicated place. We check for such an error condition ([takeaway 8.2](#ch08note03))
    and exit the program if necessary.'
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件可能失败的原因有很多：例如，文件系统可能已满，或者进程可能没有权限在指定位置写入。我们检查这种错误条件 ([收获 8.2](#ch08note03))
    并在必要时退出程序。
- en: 'As we have seen, the **perror** function is used to give a diagnostic of the
    error that occurred. It is equivalent to something like the following:'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**perror** 函数用于提供发生的错误诊断。它相当于以下内容：
- en: '[PRE132]'
  id: totrans-2116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This “some-diagnostic” might (but does not have to) contain more information
    that helps the user of the program deal with the error.
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“some-diagnostic”可能（但不一定）包含更多帮助程序用户处理错误的信息。
- en: '|  |'
  id: totrans-2118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Annex K**'
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: '**附录 K**'
- en: 'There are also bounds-checking replacements **fopen_s** and **freopen_s**,
    which ensure that the arguments that are passed are valid pointers. Here, **`errno_t`**
    is a type that comes with `stdlib.h` and encodes error returns. The **`restrict`**
    keyword that also newly appears only applies to pointer types and is out of our
    scope for the moment:'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有边界检查替换函数 **fopen_s** 和 **freopen_s**，它们确保传递的参数是有效的指针。在这里，**`errno_t`**
    是 `stdlib.h` 中的一种类型，用于编码错误返回。新出现的 **`restrict`** 关键字仅适用于指针类型，目前不在我们的讨论范围内：
- en: '[PRE133]'
  id: totrans-2121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '|  |'
  id: totrans-2122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: There are different modes to open a file; "a" is only one of several possibilities.
    [Table 8.4](#ch08table04) contains an overview of the characters that may appear
    in that string. Three base modes regulate what happens to a pre-existing file,
    if any, and where the stream is positioned. In addition, three modifiers can be
    appended to them. [Table 8.5](#ch08table05) has a complete list of the possible
    combinations.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件有不同的模式；“a”只是几种可能性之一。[表 8.4](#ch08table04) 包含了可能出现在该字符串中的字符概述。三个基础模式控制如果存在预存文件时会发生什么，以及流的位置。此外，还可以将三个修饰符附加到它们上。[表
    8.5](#ch08table05) 列出了所有可能的组合。
- en: Table 8.4\. *Modes and modifiers for **fopen** and **freopen*** One of the first
    three must start the mode string, optionally followed by one or more of the other
    three. See [table 8.5](#ch08table05) for all valid combinations.
  id: totrans-2124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.4\. **fopen** 和 **freopen** 的模式和修饰符 至少必须有一个基础模式开始模式字符串，可选地后跟一个或多个其他三个。有关所有有效组合，请参阅
    [表 8.5](#ch08table05)。
- en: '| Mode | Memo |   | File status after **fopen** |'
  id: totrans-2125
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 备注 |   | **fopen** 后的文件状态 |'
- en: '| ''a'' | Append | w | File unmodified; position at end |'
  id: totrans-2126
  prefs: []
  type: TYPE_TB
  zh: '| ''a'' | 追加 | w | 文件未修改；位置在末尾 |'
- en: '| ''w'' | Write | w | Content of file wiped out, if any |'
  id: totrans-2127
  prefs: []
  type: TYPE_TB
  zh: '| ''w'' | 写入 | w | 如果有内容，则擦除文件内容 |'
- en: '| ''r'' | Read | r | File unmodified; position at start |'
  id: totrans-2128
  prefs: []
  type: TYPE_TB
  zh: '| ''r'' | 读取 | r | 文件未修改；位置在起始处 |'
- en: '| Modifier | Memo |   | Additional property |'
  id: totrans-2129
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 备注 |   | 额外属性 |'
- en: '| ''+'' | Update | rw | Opens file for reading and writing |'
  id: totrans-2130
  prefs: []
  type: TYPE_TB
  zh: '| ''+'' | 更新 | rw | 打开文件以供读写 |'
- en: '| ''b'' | Binary |   | Views as a binary file; otherwise a text file |'
  id: totrans-2131
  prefs: []
  type: TYPE_TB
  zh: '| ''b'' | 二进制 |   | 视为二进制文件；否则为文本文件 |'
- en: '| ''x'' | Exclusive |   | Creates a file for writing if it does not yet exist
    |'
  id: totrans-2132
  prefs: []
  type: TYPE_TB
  zh: '| ''x'' | 独占 |   | 如果不存在，则创建一个用于写入的文件 |'
- en: Table 8.5\. Mode strings for **fopen** and **freopen** *These are the valid
    combinations of the characters in [table 8.4](#ch08table04).*
  id: totrans-2133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.5\. **fopen** 和 **freopen** 的模式字符串 *这些是 [表 8.4](#ch08table04) 中字符的有效组合。*
- en: '| "a" | Creates an empty text file if necessary; open for writing at end-of-file
    |'
  id: totrans-2134
  prefs: []
  type: TYPE_TB
  zh: '| "a" | 如果需要，创建一个空文本文件；在文件末尾打开以供写入 |'
- en: '| "w" | Creates an empty text file or wipes out content; open for writing |'
  id: totrans-2135
  prefs: []
  type: TYPE_TB
  zh: '| "w" | 创建一个空文本文件或擦除内容；打开以供写入 |'
- en: '| "r" | Opens an existing text file for reading |'
  id: totrans-2136
  prefs: []
  type: TYPE_TB
  zh: '| "r" | 打开一个现有的文本文件以供读取 |'
- en: '| "a+" | Creates an empty text file if necessary; open for reading and writing
    at end-of-file |'
  id: totrans-2137
  prefs: []
  type: TYPE_TB
  zh: '| "a+" | 如果需要，创建一个空文本文件；在文件末尾打开以供读写 |'
- en: '| "w+" | Creates an empty text file or wipes out content; open for reading
    and writing |'
  id: totrans-2138
  prefs: []
  type: TYPE_TB
  zh: '| "w+" | 创建一个空文本文件或擦除内容；打开以供读写 |'
- en: '| "r+" | Opens an existing text file for reading and writing at beginning of
    file |'
  id: totrans-2139
  prefs: []
  type: TYPE_TB
  zh: '| "r+" | 在文件开头打开一个现有的文本文件以供读写 |'
- en: '|'
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE134]'
  id: totrans-2141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '| Same as above, but for a binary file instead of a text file |'
  id: totrans-2142
  prefs: []
  type: TYPE_TB
  zh: '| 与上面相同，但用于二进制文件而不是文本文件 |'
- en: '| "wx" "w+x" "wbx" "w+bx" "wb+x" | Same as above, but error if the file exists
    prior to the call |'
  id: totrans-2143
  prefs: []
  type: TYPE_TB
  zh: '| "wx" "w+x" "wbx" "w+bx" "wb+x" | 与上面相同，但如果在调用之前文件存在，则返回错误 |'
- en: These tables show that a stream can be opened not only for writing but also
    for reading; we will see shortly how that can be done. To know which of the base
    modes opens for reading or writing, just use your common sense. For 'a' and 'w',
    a file that is positioned at its end can’t be read, since there is nothing there;
    thus these open for writing. For 'r', file content that is preserved and positioned
    at the beginning should not be overwritten accidentally, so this is for reading.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表格显示，流不仅可以用于写入，还可以用于读取；我们很快就会看到如何做到这一点。要知道哪个基础模式用于读取或写入，只需运用你的常识即可。对于 'a'
    和 'w'，如果文件位置在其末尾，则无法读取，因为没有内容；因此这些用于写入。对于 'r'，应避免意外覆盖保存在起始位置的文件内容，因此这用于读取。
- en: The modifiers are used less commonly in everyday coding. “Update” mode with
    '+' should be used carefully. Reading and writing at the same time is not easy
    and needs some special care. For 'b', we will discuss the difference between text
    and binary streams in more detail in [section 14.4](kindle_split_024.html#ch14lev1sec4).
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常编码中，修饰符的使用较少。应谨慎使用带有 '+' 的“更新”模式。同时读写并不容易，需要特别注意。对于 'b'，我们将在[第14.4节](kindle_split_024.html#ch14lev1sec4)中更详细地讨论文本和二进制流之间的区别。
- en: 'There are three other principal interfaces to handle streams, **freopen**,
    **fclose**, and **fflush**:'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 处理流的另外三个主要接口是 **freopen**、**fclose** 和 **fflush**：
- en: '[PRE135]'
  id: totrans-2147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The primary uses for **freopen** and **fclose** are straightforward: **freopen**
    can associate a given stream to a different file and eventually change the mode.
    This is particularly useful to associate the standard streams to a file. *E.g*
    our little program from above could be rewritten as'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: '**freopen** 和 **fclose** 的主要用途很简单：**freopen** 可以将给定的流关联到不同的文件，并最终更改模式。这特别有用，可以将标准流关联到文件。*例如*，我们上面的小程序可以重写为'
- en: '[PRE136]'
  id: totrans-2149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 8.3.3\. Text IO
  id: totrans-2150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 文本IO
- en: 'Output to text streams is usually *buffered**^C*: that is, to make more efficient
    use of its resources, the IO system can delay the physical write of to a stream.
    If we close the stream with **fclose**, all buffers are guaranteed to be *flushed**^C*
    to where it is supposed to go. The function **fflush** is needed in places where
    we want to see output immediately on the terminal, or where we don’t want to close
    the file yet but want to ensure that all content we have written has properly
    reached its destination. [Listing 8.1](#ch08ex01) shows an example that writes
    10 dots to **`stdout`** with a delay of approximately one second between all writes.^([[[Exs
    3]](#ch08fn-ex03)])'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到文本流通常是*缓冲**^C*：也就是说，为了更有效地使用其资源，IO系统可以延迟对流的物理写入。如果我们使用 **fclose** 关闭流，所有缓冲区都将保证被*刷新**^C*到它应该去的地方。在需要立即在终端看到输出或不想关闭文件但想确保所有已写入的内容都已正确到达目的地的地方，需要使用
    **fflush** 函数。[列表8.1](#ch08ex01)展示了将10个点写入**`stdout`**的示例，所有写入之间的延迟大约为1秒.^([[[Exs
    3]](#ch08fn-ex03)])
- en: ^([Exs 3])
  id: totrans-2152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-2153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe the behavior of the program by running it with zero, one, and two command-line
    arguments.
  id: totrans-2154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过使用零、一个和两个命令行参数来运行程序，观察程序的行为。
- en: Listing 8.1\. flushing buffered output
  id: totrans-2155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. 清除缓冲输出
- en: '[PRE137]'
  id: totrans-2156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The most common form of IO buffering for text files is *line buffering**^C*.
    In that mode, output is only physically written if the end of a text line is encountered.
    So usually, text that is written with **puts** appears immediately on the terminal;
    **fputs** waits until it encounters an '\n' in the output. Another interesting
    thing about text streams and files is that there is no one-to-one correspondence
    between characters that are written in the program and bytes that land on the
    console device or in the file.
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本文件，最常见的IO缓冲形式是*行缓冲**^C*。在这种模式下，只有在遇到文本行尾时才会进行物理写入。因此，通常使用 **puts** 写入的文本会立即出现在终端上；**fputs**
    等待遇到输出中的 '\n'。关于文本流和文件，另一个有趣的事情是，程序中写入的字符与控制台设备或文件中到达的字节之间没有一一对应的关系。
- en: '|  |'
  id: totrans-2158
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 8.11
  id: totrans-2159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 8.11要点
- en: '*Text input and output converts data.*'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: '*文本输入和输出转换数据*。'
- en: '|  |'
  id: totrans-2161
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'This is because internal and external representations of text characters are
    not necessarily the same. Unfortunately, there are still many different character
    encodings; the C library is in charge of doing the conversions correctly, if it
    can. Most notoriously, the end-of-line encoding in files is platform dependent:'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为文本字符的内部和外部表示不一定相同。不幸的是，仍然有许多不同的字符编码；如果C库能够正确地进行转换，它负责进行转换。最臭名昭著的是，文件中的换行符编码是平台相关的：
- en: '|  |'
  id: totrans-2163
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 8.12
  id: totrans-2164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 8.12要点
- en: '*There are three commonly used conversions to encode end-of-line.*'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: '*有三种常用的转换来编码换行符*。'
- en: '|  |'
  id: totrans-2166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'C gives us a very suitable abstraction in using ''\n'' for this, regardless
    of the platform. Another modification you should be aware of when doing text IO
    is that white space that precedes the end of line may be suppressed. Therefore,
    the presence of *trailing white space**^C* such as blank or tabulator characters
    cannot be relied upon and should be avoided:'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: C语言为我们提供了一个非常适合的抽象，使用 '\n' 来实现这一点，无论平台如何。在进行文本IO时，你应该注意的另一个修改是，行尾前的空白可能会被抑制。因此，不能依赖于*尾随空白**^C*，如空格或制表符字符，应该避免使用：
- en: '|  |'
  id: totrans-2168
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 8.13
  id: totrans-2169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 8.13要点
- en: '*Text lines should not contain trailing white space.*'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: '*文本行不应包含尾随空白*。'
- en: '|  |'
  id: totrans-2171
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The C library additionally also has very limited support for manipulating files
    within the file system:'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: C库还提供了对文件系统内文件操作的支持，但非常有限：
- en: '[PRE138]'
  id: totrans-2173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: These basically do what their names indicate.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本上就是它们名字所表示的意思。
- en: Table 8.6\. Format specifications for **printf** and similar functions, with
    the general syntax "%[FF][WW][.PP][LL]SS", where **`[]`** surrounding a field
    denotes that it is optional.
  id: totrans-2175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.6\. **printf** 和类似函数的格式说明，具有一般语法 "%[FF][WW][.PP][LL]SS"，其中**`[]`**包围的字段表示它是可选的。
- en: '| FF | Flags | Special form of conversion |'
  id: totrans-2176
  prefs: []
  type: TYPE_TB
  zh: '| FF | 标志 | 转换的特殊形式 |'
- en: '| WW | Field width | minimum width |'
  id: totrans-2177
  prefs: []
  type: TYPE_TB
  zh: '| WW | 字段宽度 | 最小宽度 |'
- en: '| PP | Precision |   |'
  id: totrans-2178
  prefs: []
  type: TYPE_TB
  zh: '| PP | 精度 |  |'
- en: '| LL | Modifier | Select width of type |'
  id: totrans-2179
  prefs: []
  type: TYPE_TB
  zh: '| LL | 修饰符 | 选择类型宽度 |'
- en: '| SS | Specifier | Select conversion |'
  id: totrans-2180
  prefs: []
  type: TYPE_TB
  zh: '| SS | 说明符 | 选择转换 |'
- en: 8.3.4\. Formatted output
  id: totrans-2181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 格式化输出
- en: 'We have covered how to use **printf** for formatted output. The function **fprintf**
    is very similar to that, but it has an additional parameter that allows us to
    specify the stream to which the output is written:'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何使用 **printf** 进行格式化输出。函数 **fprintf** 与之非常相似，但它有一个额外的参数，允许我们指定输出写入的流：
- en: '[PRE139]'
  id: totrans-2183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The syntax with the three dots `...` indicates that these functions may receive
    an arbitrary number of items that are to be printed. An important constraint is
    that this number must correspond exactly to the ''%'' specifiers; otherwise the
    behavior is undefined:'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个点 `...` 的语法表示这些函数可以接收任意数量的要打印的项。一个重要的约束是，这个数字必须与 `%` 说明符完全对应；否则行为是未定义的：
- en: '|  |'
  id: totrans-2185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.14
  id: totrans-2186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.14
- en: '*Parameters of* **printf** *must exactly correspond to the format specifiers.*'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: '*printf* *的参数必须与格式说明符完全对应。*'
- en: '|  |'
  id: totrans-2188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'With the syntax `%[`FF`][`WW`][.`PP`][`LL`]`SS, a complete format specification
    can be composed of five parts: flags, width, precision, modifiers, and specifier.
    See [table 8.6](#ch08table06) for details.'
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法 `%[`FF`][`WW`][.`PP`][`LL`]`SS`，一个完整的格式说明可以由五个部分组成：标志、宽度、精度、修饰符和说明符。有关详细信息，请参阅[表8.6](#ch08table06)。
- en: The specifier is not optional and selects the type of output conversion that
    is performed. See [table 8.7](kindle_split_017.html#ch08table07) for an overview.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 说明符不是可选的，它选择要执行的输出转换类型。有关概述，请参阅[表8.7](kindle_split_017.html#ch08table07)。
- en: As you can see, for most types of values, there is a choice of format. You should
    chose the one that is most appropriate for the *meaning* of the value that the
    output is to convey. For all numerical *values*, this should usually be a decimal
    format.
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于大多数类型的值，都有多种格式可供选择。您应该选择最适合输出要传达的值的*意义*的格式。对于所有数值*值*，这通常应该是十进制格式。
- en: '|  |'
  id: totrans-2192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.15
  id: totrans-2193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.15
- en: '*Use* *`"%d"`* *and* *`"%u"`* *formats to print integer values.*'
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* *`"%d"`* *和* *`"%u"`* *格式来打印整数值。*'
- en: '|  |'
  id: totrans-2195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If, on the other hand, you are interested in a bit pattern, use the hexadecimal
    format over octal. It better corresponds to modern architectures that have 8-bit
    character types.
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您对位模式感兴趣，请使用十六进制格式而不是八进制。它更好地符合现代具有8位字符类型的架构。
- en: '|  |'
  id: totrans-2197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.16
  id: totrans-2198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.16
- en: '*Use the* *`"%x"`* *format to print bit patterns.*'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* *`"%x"`* *格式来打印位模式。*'
- en: '|  |'
  id: totrans-2200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Also observe that this format receives unsigned values, which is yet another
    incentive to only use unsigned types for bit sets. Seeing hexadecimal values and
    associating the corresponding bit pattern requires training. [Table 8.8](#ch08table08)
    has an overview of the digits, the values, and the bit pattern they represent.
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，此格式接收无符号值，这也是仅使用无符号类型进行位集的另一个动力。看到十六进制值并关联相应的位模式需要训练。[表8.8](#ch08table08)概述了数字、它们的值以及它们所代表的位模式。
- en: For floating-point formats, there is even more choice. If you do not have specific
    needs, the generic format is the easiest to use for decimal output.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数格式，还有更多的选择。如果您没有特定的需求，通用格式对于十进制输出来说最容易使用。
- en: Table 8.7\. Format specifiers for **printf** and similar functions
  id: totrans-2203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.7\. **printf** 和类似函数的格式说明符
- en: '| ''d'' or ''i'' | Decimal | Signed integer |'
  id: totrans-2204
  prefs: []
  type: TYPE_TB
  zh: '| ''d'' 或 ''i'' | 十进制 | 有符号整数 |'
- en: '| ''u'' | Decimal | Unsigned integer |'
  id: totrans-2205
  prefs: []
  type: TYPE_TB
  zh: '| ''u'' | 十进制 | 无符号整数 |'
- en: '| ''o'' | Octal | Unsigned integer |'
  id: totrans-2206
  prefs: []
  type: TYPE_TB
  zh: '| ''o'' | 八进制 | 无符号整数 |'
- en: '| ''x'' or ''X'' | Hexadecimal | Unsigned integer |'
  id: totrans-2207
  prefs: []
  type: TYPE_TB
  zh: '| ''x'' 或 ''X'' | 十六进制 | 无符号整数 |'
- en: '| ''e'' or ''E'' | [-]d.ddd e±dd, “scientific” | Floating point |'
  id: totrans-2208
  prefs: []
  type: TYPE_TB
  zh: '| ''e'' 或 ''E'' | [-]d.ddd e±dd，“科学” | 浮点数 |'
- en: '| ''f'' or ''F'' | [-]d.ddd | Floating point |'
  id: totrans-2209
  prefs: []
  type: TYPE_TB
  zh: '| ''f'' 或 ''F'' | [-]d.ddd | 浮点数 |'
- en: '| ''g'' or ''G'' | generic e or f | Floating point |'
  id: totrans-2210
  prefs: []
  type: TYPE_TB
  zh: '| ''g'' 或 ''G'' | 通用e或f | 浮点数 |'
- en: '| ''a'' or ''A'' | [-]0xh.hhhh p±d, Hexadecimal | Floating point |'
  id: totrans-2211
  prefs: []
  type: TYPE_TB
  zh: '| ''a'' 或 ''A'' | [-]0xh.hhhh p±d，十六进制 | 浮点数 |'
- en: '| ''%'' | ''%'' character | No argument is converted. |'
  id: totrans-2212
  prefs: []
  type: TYPE_TB
  zh: '| ''%'' | `%` 字符 | 不转换任何参数。 |'
- en: '| ''c'' | Character | Integer |'
  id: totrans-2213
  prefs: []
  type: TYPE_TB
  zh: '| ''c'' | 字符 | 整数 |'
- en: '| ''s'' | Characters | String |'
  id: totrans-2214
  prefs: []
  type: TYPE_TB
  zh: '| ''s'' | 字符串 | 字符串 |'
- en: '| ''p'' | Address | **void*** pointer |'
  id: totrans-2215
  prefs: []
  type: TYPE_TB
  zh: '| ''p'' | 地址 | **void** 指针 |'
- en: Table 8.8\. Hexadecimal values and bit patterns
  id: totrans-2216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.8\. 十六进制值和位模式
- en: '| Digit | Value | Pattern |'
  id: totrans-2217
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | 值 | 模式 |'
- en: '| --- | --- | --- |'
  id: totrans-2218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0000 |'
  id: totrans-2219
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0000 |'
- en: '| 1 | 1 | 0001 |'
  id: totrans-2220
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0001 |'
- en: '| 2 | 2 | 0010 |'
  id: totrans-2221
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 0010 |'
- en: '| 3 | 3 | 0011 |'
  id: totrans-2222
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 0011 |'
- en: '| 4 | 4 | 0100 |'
  id: totrans-2223
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 0100 |'
- en: '| 5 | 5 | 0101 |'
  id: totrans-2224
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 0101 |'
- en: '| 6 | 6 | 0110 |'
  id: totrans-2225
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 0110 |'
- en: '| 7 | 7 | 0111 |'
  id: totrans-2226
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 7 | 0111 |'
- en: '| 8 | 8 | 1000 |'
  id: totrans-2227
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 8 | 1000 |'
- en: '| 9 | 9 | 1001 |'
  id: totrans-2228
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 9 | 1001 |'
- en: '| A | 10 | 1010 |'
  id: totrans-2229
  prefs: []
  type: TYPE_TB
  zh: '| A | 10 | 1010 |'
- en: '| B | 11 | 1011 |'
  id: totrans-2230
  prefs: []
  type: TYPE_TB
  zh: '| B | 11 | 1011 |'
- en: '| C | 12 | 1100 |'
  id: totrans-2231
  prefs: []
  type: TYPE_TB
  zh: '| C | 12 | 1100 |'
- en: '| D | 13 | 1101 |'
  id: totrans-2232
  prefs: []
  type: TYPE_TB
  zh: '| D | 13 | 1101 |'
- en: '| E | 14 | 1110 |'
  id: totrans-2233
  prefs: []
  type: TYPE_TB
  zh: '| E | 14 | 1110 |'
- en: '| F | 15 | 1111 |'
  id: totrans-2234
  prefs: []
  type: TYPE_TB
  zh: '| F | 15 | 1111 |'
- en: '|  |'
  id: totrans-2235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.17
  id: totrans-2236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得8.17要点
- en: '*Use the* *`"%g"`* *format to print floating-point values.*'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* *`"%g"`* *格式来打印浮点数。*'
- en: '|  |'
  id: totrans-2238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The modifier part is important to specify the exact type of the corresponding
    argument. [Table 8.9](#ch08table09) gives the codes for the types we have encountered
    so far. This modifier is particularly important because interpreting a value with
    the wrong modifier can cause severe damage. The **printf** functions only have
    knowledge about their arguments through the format specifiers, so giving a function
    the wrong size may lead it to read more or fewer bytes than provided by the argument
    or to interpret the wrong hardware registers.
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符部分对于指定相应参数的确切类型非常重要。[表8.9](#ch08table09) 提供了我们迄今为止遇到的所有类型的代码。这个修饰符尤其重要，因为使用错误的修饰符解释值可能会导致严重损坏。**printf**
    函数只通过格式说明符了解它们的参数，因此给函数错误的尺寸可能会导致它读取比参数提供的更多或更少的字节，或者解释错误的硬件寄存器。
- en: '|  |'
  id: totrans-2240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.18
  id: totrans-2241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得8.18要点
- en: '*Using an inappropriate format specifier or modifier makes the behavior undefined.*'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用不适当的格式说明符或修饰符会使行为未定义。*'
- en: '|  |'
  id: totrans-2243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A good compiler should warn about wrong formats; please take such warnings seriously.
    Note also the presence of special modifiers for the three semantic types. In particular,
    the combination "%zu" is very convenient because we don’t have to know the base
    type to which **`size_t`** corresponds.
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的编译器应该会警告关于错误格式的信息；请认真对待此类警告。注意，也存在针对三种语义类型的特殊修饰符。特别是，组合 "%zu" 非常方便，因为我们不必知道
    **`size_t`** 对应的基类型。
- en: Table 8.9\. Format modifiers for **printf** and similar functions **`float`**
    arguments are first converted to **`double`**.
  id: totrans-2245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.9\. **printf** 和类似函数的格式修饰符 **`float`** 参数首先转换为 **`double`**。
- en: '| Character | Type | Conversion |'
  id: totrans-2246
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 类型 | 转换 |'
- en: '| --- | --- | --- |'
  id: totrans-2247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| "hh" | **char** types | Integer |'
  id: totrans-2248
  prefs: []
  type: TYPE_TB
  zh: '| "hh" | **char** 类型 | 整数 |'
- en: '| "h" | **short** types | Integer |'
  id: totrans-2249
  prefs: []
  type: TYPE_TB
  zh: '| "h" | **short** 类型 | 整数 |'
- en: '| "" | **signed**, **unsigned** | Integer |'
  id: totrans-2250
  prefs: []
  type: TYPE_TB
  zh: '| "" | **有符号**，**无符号** | 整数 |'
- en: '| "l" | **long** integer types | integer |'
  id: totrans-2251
  prefs: []
  type: TYPE_TB
  zh: '| "l" | **长整数**类型 | 整数 |'
- en: '| "ll" | **long long** integer types | Integer |'
  id: totrans-2252
  prefs: []
  type: TYPE_TB
  zh: '| "ll" | **长长整数**类型 | 整数 |'
- en: '| "j" | **intmax_t**, **uintmax_t** | Integer |'
  id: totrans-2253
  prefs: []
  type: TYPE_TB
  zh: '| "j" | **intmax_t**，**uintmax_t** | 整数 |'
- en: '| "z" | **size_t** | Integer |'
  id: totrans-2254
  prefs: []
  type: TYPE_TB
  zh: '| "z" | **size_t** | 整数 |'
- en: '| "t" | **ptrdiff_t** | Integer |'
  id: totrans-2255
  prefs: []
  type: TYPE_TB
  zh: '| "t" | **ptrdiff_t** | 整数 |'
- en: '| "L" | **long double** | Floating point |'
  id: totrans-2256
  prefs: []
  type: TYPE_TB
  zh: '| "L" | **长双精度浮点数** | 浮点数 |'
- en: Table 8.10\. Format flags for **printf** and similar functions
  id: totrans-2257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.10\. **printf** 和类似函数的格式标志
- en: '| Character | Meaning | Conversion |'
  id: totrans-2258
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 含义 | 转换 |'
- en: '| --- | --- | --- |'
  id: totrans-2259
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| "#" | Alternate form, such as prefix 0x | "aAeEfFgGoxX" |'
  id: totrans-2260
  prefs: []
  type: TYPE_TB
  zh: '| "#" | 替代形式，例如前缀0x | "aAeEfFgGoxX" |'
- en: '| "0" | Zero padding | Numeric |'
  id: totrans-2261
  prefs: []
  type: TYPE_TB
  zh: '| "0" | 填充零 | 数字 |'
- en: '| "-" | Left adjustment | Any |'
  id: totrans-2262
  prefs: []
  type: TYPE_TB
  zh: '| "-" | 左对齐 | 任何 |'
- en: '| " " | '' '' for positive values, ''-'' for negative | Signed |'
  id: totrans-2263
  prefs: []
  type: TYPE_TB
  zh: '| " " | 正值用空格表示，负值用减号表示 | 有符号 |'
- en: '| "+" | ''+'' for positive values, ''-'' for negative | Signed |'
  id: totrans-2264
  prefs: []
  type: TYPE_TB
  zh: '| "+" | 正值用加号表示，负值用减号表示 | 有符号 |'
- en: The width (WW) and precision (`.`PP) can be used to control the general appearance
    of a printed value. For example, for the generic floating-point format "%g", the
    precision controls the number of significant digits. A format of "%20.10g" specifies
    an output field of 20 characters with at most 10 significant digits. How these
    values are interpreted specifically differs for each format specifier.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度（WW）和精度（`.`PP）可以用来控制打印值的总体外观。例如，对于通用的浮点数格式 "%g"，精度控制有效数字的数量。格式 "%20.10g" 指定一个最多有10个有效数字的20字符输出字段。这些值如何具体解释因每个格式说明符而异。
- en: The flag can change the output variant, such as prefixing with signs ("%+d"),
    0x for hexadecimal conversion ("%#X"), `0` for octal ("%#o"), padding with `0`,
    or adjusting the output within its field to the left instead of the right. See
    [table 8.10](#ch08table10). Remember that a leading zero for integers is usually
    interpreted as introducing an octal number, not a decimal. So using zero padding
    with left adjustment "%-0" is not a good idea because it can confuse the reader
    about the convention that is applied.
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 标志可以更改输出变体，例如，使用符号前缀 ("%+d")，十六进制转换前缀 ("0x")，八进制 ("%#o")，用 `0` 填充，或者将输出在其字段内左对齐而不是右对齐。参见
    [表 8.10](#ch08table10)。记住，整数前面的零通常被解释为引入八进制数，而不是十进制数。因此，使用左对齐的零填充 "%-0" 不是好主意，因为它可能会让读者对应用的约定产生混淆。
- en: If we know that the numbers we write will be read back in from a file later,
    the forms "%+d" for signed types, "%#X" for unsigned types, and "%a" for floating
    point are the most appropriate. They guarantee that the string-to-number conversions
    will detect the correct form and that the storage in a file will not lose information.
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道我们写入的数字将被稍后从文件中读取回来，那么对于有符号类型，使用 "%+d"，对于无符号类型，使用 "%#X"，对于浮点数，使用 "%a"
    是最合适的。它们保证了字符串到数字的转换将检测到正确的形式，并且存储在文件中的信息不会丢失。
- en: '|  |'
  id: totrans-2268
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 8.19
  id: totrans-2269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取舍 8.19
- en: '*Use* *`"%+d"`**,* *`"%#X"`**, and* *`"%a"`* *for conversions that have to
    be read later.*'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* *`"%+d"`**,* *`"%#X"`** 和 *`"%a"`* *进行必须稍后读取的转换。*'
- en: '|  |'
  id: totrans-2271
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-2272
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Annex K**'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: '**附件 K**'
- en: 'The optional interfaces **printf_s** and **fprintf_s** check that the stream,
    the format, and any string arguments are valid pointers. They don’t check whether
    the expressions in the list correspond to correct format specifiers:'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 可选接口 **printf_s** 和 **fprintf_s** 检查流、格式和任何字符串参数是否为有效指针。它们不检查列表中的表达式是否对应于正确的格式说明符：
- en: '[PRE140]'
  id: totrans-2275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '|  |'
  id: totrans-2276
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here is a modified example for reopening **`stdout`**:'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个修改后的示例，用于重新打开 **`stdout`**：
- en: '[PRE141]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This improves the diagnostic output by adding the filename to the output string.
    **fprintf_s** is used to check the validity of the stream, the format, and the
    argument string. This function may mix the output of the two streams if they are
    both connected to the same terminal.
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将文件名添加到输出字符串中，这提高了诊断输出。**fprintf_s** 用于检查流的合法性、格式和参数字符串的有效性。如果这两个流都连接到相同的终端，该函数可能会混合两个流的输出。
- en: 8.3.5\. Unformatted text input
  id: totrans-2280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.5\. 未格式化文本输入
- en: 'Unformatted input is best done with **fgetc** for a single character and **fgets**
    for a string. The **`stdin`** standard stream is always defined and usually connects
    to terminal input:'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 未格式化输入最好使用 **fgetc** 读取单个字符，使用 **fgets** 读取字符串。**`stdin`** 标准流始终定义，通常连接到终端输入：
- en: '[PRE142]'
  id: totrans-2282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '|  |'
  id: totrans-2283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Annex K**'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: '**附件 K**'
- en: 'In addition, there are also **getchar** and **gets_s**, which read from **`stdin`**
    but don’t add much to the previous interfaces that are more generic:'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 **getchar** 和 **gets_s**，它们从 **`stdin`** 读取，但并没有为更通用的接口增加多少：
- en: '[PRE143]'
  id: totrans-2286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '|  |'
  id: totrans-2287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Historically, in the same spirit in which **puts** specializes **fputs**, the
    prior version of the C standard had a **`gets`** interface. This has been removed
    because it was inherently unsafe.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，在**puts**专门化**fputs**的同一精神下，C 标准的先前版本有一个 **`gets`** 接口。这已经被移除，因为它固有不安全。
- en: '|  |'
  id: totrans-2289
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 8.20
  id: totrans-2290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取舍 8.20
- en: '*Don’t use* **`gets`***.*'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要使用* **`gets`***.*'
- en: '|  |'
  id: totrans-2292
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The following listing shows a function that has functionality equivalent to
    **fgets**.
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个具有与 **fgets** 相等功能的功能。
- en: Listing 8.2\. Implementing **fgets** in terms of **fgetc**
  id: totrans-2294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. 基于 **fgetc** 实现 **fgets**
- en: '[PRE144]'
  id: totrans-2295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Again, such example code is not meant to replace the function, but to illustrate
    properties of the functions in question: here, the error-handling strategy.'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这样的示例代码并不是要替换该函数，而是要说明所讨论函数的性质：在这里，是错误处理策略。
- en: '|  |'
  id: totrans-2297
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 8.21
  id: totrans-2298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取舍 8.21
- en: '**fgetc** *returns* **`int`** *to be able to encode a special error status,*
    **`EOF`***, in addition to all valid characters.*'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: '**fgetc** *返回* **`int`** *以能够编码一个特殊的错误状态，* **`EOF`***，除了所有有效字符。'
- en: '|  |'
  id: totrans-2300
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Also, detecting a return of **`EOF`** alone is not sufficient to conclude that
    the end of the stream has been reached. We have to call **feof** to test whether
    a stream’s position has reached its end-of-file marker.
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仅检测到 **`EOF`** 的返回并不足以得出已到达流末尾的结论。我们必须调用 **feof** 来测试流的位置是否已达到文件结束标记。
- en: '|  |'
  id: totrans-2302
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 8.22
  id: totrans-2303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取舍 8.22
- en: '*End of file can only be detected* after *a failed read.*'
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: '*只有在* *“读取失败”* *之后才能检测到文件结束。*'
- en: '|  |'
  id: totrans-2305
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Listing 8.3](#ch08ex03) presents an example that uses both input and output
    functions.'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8.3](#ch08ex03)展示了使用输入和输出函数的示例。'
- en: Listing 8.3\. A program to dump multiple text files to **`stdout`**
  id: totrans-2307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 一个将多个文本文件输出到**`stdout`**的程序
- en: '[PRE145]'
  id: totrans-2308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This is a small implementation of cat that reads a number of files that are
    given on the command line and dumps the contents to **`stdout`**.^([[[Exs 4]](#ch08fn-ex04)])^([[[Exs
    5]](#ch08fn-ex05)])^([[[Exs 6]](#ch08fn-ex06)])^([[[Exs 7]](#ch08fn-ex07)])
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个cat的小型实现，它读取命令行上给出的多个文件，并将内容输出到**`stdout`**.^([[[Exs 4]](#ch08fn-ex04)])^([[[Exs
    5]](#ch08fn-ex05)])^([[[Exs 6]](#ch08fn-ex06)])^([[[Exs 7]](#ch08fn-ex07)])
- en: ^([Exs 4])
  id: totrans-2310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-2311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Under what circumstances will this program finish with success or failure return
    codes?
  id: totrans-2312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在什么情况下，这个程序将以成功或失败返回代码结束？
- en: ^([Exs 5])
  id: totrans-2313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 5])
- en: ''
  id: totrans-2314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Surprisingly, this program even works for files with lines that have more than
    31 characters. Why?
  id: totrans-2315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这个程序甚至可以处理包含超过31个字符的行。为什么？
- en: ^([Exs 6])
  id: totrans-2316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 6])
- en: ''
  id: totrans-2317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have the program read from **`stdin`** if no command-line argument is given.
  id: totrans-2318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果没有给出命令行参数，则让程序从**`stdin`**读取。
- en: ^([Exs 7])
  id: totrans-2319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 7])
- en: ''
  id: totrans-2320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have the program precede all output lines with line numbers if the first command-line
    argument is "-n".
  id: totrans-2321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果第一个命令行参数是"-n"，则让程序在所有输出行前加上行号。
- en: 8.4\. String processing and conversion
  id: totrans-2322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 字符串处理和转换
- en: 'String processing in C has to deal with the fact that the source and execution
    environments may have different encodings. It is therefore crucial to have interfaces
    that work independently of the encoding. The most important tools are given by
    the language itself: integer character constants such as ''a'' and ''\n'' and
    string literals such as "hello:\tx" should always do the right thing on your platform.
    As you perhaps remember, there are no constants for types that are narrower than
    **`int`**; and, as an historical artifact, integer character constants such as
    ''a'' have type **`int`**, not **`char`** as you would probably expect.'
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: C中的字符串处理必须处理源和执行环境可能具有不同编码的事实。因此，拥有独立于编码的接口至关重要。最重要的工具由语言本身提供：整数字符常量，如'a'和'\n'，以及字符串字面量，如"hello:\tx"，应该在您的平台上始终正确执行。您可能还记得，没有比**`int`**更窄的类型常量；并且，作为一个历史遗迹，整数字符常量如'a'的类型是**`int`**，而不是您可能期望的**`char`**。
- en: '![](comm.jpg)'
  id: totrans-2324
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: Handling such constants can become cumbersome if you have to deal with character
    classes.
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须处理字符类，处理这样的常数可能会变得繁琐。
- en: Therefore, the C library provides functions and macros that deal with the most
    commonly used classes through the header `ctype.h`. It has the classifiers **isalnum**,
    **isalpha**, **isblank**, **iscntrl**, **isdigit**, **isgraph**, **islower**,
    **isprint**, **ispunct**, **isspace**, **isupper**, and **isxdigit**, and conversions
    **toupper** and **tolower**. Again, for historical reasons, all of these take
    their arguments as **`int`** and also return **`int`**. See [table 8.11](#ch08table11)
    for an overview of the classifiers. The functions **toupper** and **tolower**
    convert alphabetic characters to the corresponding case and leave all other characters
    as they are.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C库通过头文件`ctype.h`提供了处理最常用类的函数和宏。它有分类器**isalnum**、**isalpha**、**isblank**、**iscntrl**、**isdigit**、**isgraph**、**islower**、**isprint**、**ispunct**、**isspace**、**isupper**和**isxdigit**，以及转换**toupper**和**tolower**。同样，由于历史原因，所有这些函数都接受**`int`**类型的参数，并返回**`int`**类型的值。参见[表8.11](#ch08table11)以了解分类器的概述。函数**toupper**和**tolower**将字母字符转换为相应的字母大小写，并保留所有其他字符不变。
- en: '|  |'
  id: totrans-2327
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<ctype.h>`'
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ctype.h>`'
- en: '|  |'
  id: totrans-2329
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The table has some special characters such as '\n' for a new-line character,
    which we have encountered previously. All the special encodings and their meaning
    are given in [table 8.12](#ch08table12).
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中有些特殊字符，如'\n'表示换行符，我们之前已经遇到过。所有特殊编码及其含义都在[表8.12](#ch08table12)中给出。
- en: '![](comm.jpg)'
  id: totrans-2331
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: 'Integer character constants can also be encoded numerically: as an octal value
    of the form ''\037'' or as a hexadecimal value in the form ''\xFFFF''. In the
    first form, up to three octal digits are used to represent the code. For the second,
    any sequence of characters after the x that can be interpreted as a hex digit
    is included in the code. Using these in strings requires special care to mark
    the end of such a character: "\xdeBruyn" is not the same as "\xde" "Bruyn"^([[1](#ch08fn01)])
    but corresponds to "\xdeB" "ruyn", the character with code `3563` followed by
    the four characters ''r'', ''u'', ''y'', and ''n''. Using this feature is only
    portable in the sense that it will compile on all platforms as long as a character
    with code `3563` exists. Whether it exists and what that character actually is
    depends on the platform and the particular setting for program execution.'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字符常量也可以用数值编码：以八进制形式 '\037' 或十六进制形式 '\xFFFF' 表示。在第一种形式中，最多使用三个八进制数字来表示代码。在第二种形式中，x
    后的任何可以解释为十六进制数字的字符序列都包含在代码中。在字符串中使用这些字符需要特别注意标记此类字符的结尾："\xdeBruyn" 与 "\xde" "Bruyn"^([[1](#ch08fn01)])
    不同，而是对应于 "\xdeB" "ruyn"，代码为 `3563` 的字符后面跟着四个字符 'r', 'u', 'y', 和 'n'。使用此功能在所有平台上编译是可移植的，只要存在代码为
    `3563` 的字符。它是否存在以及实际是什么取决于平台和程序执行的特定设置。
- en: ¹
  id: totrans-2333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-2334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But remember that consecutive string literals are concatenated ([takeaway 5.18](kindle_split_013.html#ch05note18)).
  id: totrans-2335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但请记住，连续的字符串字面量会被连接 ([takeaway 5.18](kindle_split_013.html#ch05note18))。
- en: Table 8.11\. *Character classifiers* The third column indicates whether C implementations
    may extend these classes with platform-specific characters, such as 'ä' as a lowercase
    character or '€' as punctuation.
  id: totrans-2336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.11\. *字符分类器* 第三列指示 C 实现是否可以扩展这些类别以包含平台特定的字符，例如 'ä' 作为小写字母或 '€' 作为标点符号。
- en: '| Name | Meaning | C locale | Extended |'
  id: totrans-2337
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 含义 | C 位置 | 扩展 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-2338
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **islower** | Lowercase | ''a'' *...* ''z'' | Yes |'
  id: totrans-2339
  prefs: []
  type: TYPE_TB
  zh: '| **islower** | 小写字母 | ''a'' *...* ''z'' | 是 |'
- en: '| **isupper** | Uppercase | ''A'' *...* ''Z'' | Yes |'
  id: totrans-2340
  prefs: []
  type: TYPE_TB
  zh: '| **isupper** | 大写字母 | ''A'' *...* ''Z'' | 是 |'
- en: '| **isblank** | Blank | '' '', ''\t'' | Yes |'
  id: totrans-2341
  prefs: []
  type: TYPE_TB
  zh: '| **isblank** | 空白字符 | '' '', ''\t'' | 是 |'
- en: '| **isspace** | Space | '' '', ''\f'', ''\n'', ''\r'', ''\t'', ''\v'' | Yes
    |'
  id: totrans-2342
  prefs: []
  type: TYPE_TB
  zh: '| **isspace** | 空格 | '' '', ''\f'', ''\n'', ''\r'', ''\t'', ''\v'' | 是 |'
- en: '| **isdigit** | Decimal | ''0'' *...* ''9'' | No |'
  id: totrans-2343
  prefs: []
  type: TYPE_TB
  zh: '| **isdigit** | 十进制 | ''0'' *...* ''9'' | 否 |'
- en: '| **isxdigit** | Hexadecimal | ''0'' *...* ''9'', ''a'' *...* ''f'', ''A''
    *...* ''F'' | No |'
  id: totrans-2344
  prefs: []
  type: TYPE_TB
  zh: '| **isxdigit** | 十六进制 | ''0'' *...* ''9'', ''a'' *...* ''f'', ''A'' *...* ''F''
    | 否 |'
- en: '| **iscntrl** | Control | ''\a'', ''\b'', ''\f'', ''\n'', ''\r'', ''\t'', ''\v''
    | Yes |'
  id: totrans-2345
  prefs: []
  type: TYPE_TB
  zh: '| **iscntrl** | 控制字符 | ''\a'', ''\b'', ''\f'', ''\n'', ''\r'', ''\t'', ''\v''
    | 是 |'
- en: '| **isalnum** | Alphanumeric | **isalpha**(x)&#124;&#124;**isdigit**(x) | Yes
    |'
  id: totrans-2346
  prefs: []
  type: TYPE_TB
  zh: '| **isalnum** | 字母数字 | **isalpha**(x)&#124;&#124;**isdigit**(x) | 是 |'
- en: '| **isalpha** | Alphabet | **islower**(x)&#124;&#124;**isupper**(x) | Yes |'
  id: totrans-2347
  prefs: []
  type: TYPE_TB
  zh: '| **isalpha** | 字母 | **islower**(x)&#124;&#124;**isupper**(x) | 是 |'
- en: '| **isgraph** | Graphical | (!**iscntrl**(x)) && (x != '' '') | Yes |'
  id: totrans-2348
  prefs: []
  type: TYPE_TB
  zh: '| **isgraph** | 图形字符 | (!**iscntrl**(x)) && (x != '' '') | 是 |'
- en: '| **isprint** | Printable | !**iscntrl**(x) | Yes |'
  id: totrans-2349
  prefs: []
  type: TYPE_TB
  zh: '| **isprint** | 可打印字符 | !**iscntrl**(x) | 是 |'
- en: '| **ispunct** | Punctuation | **isprint**(x)&&!(**isalnum**(x)&#124;&#124;**isspace**(x))
    | Yes |'
  id: totrans-2350
  prefs: []
  type: TYPE_TB
  zh: '| **ispunct** | 标点符号 | **isprint**(x)&&!(**isalnum**(x)&#124;&#124;**isspace**(x))
    | 是 |'
- en: Table 8.12\. Special characters in character and string literals
  id: totrans-2351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.12\. 字符和字符串字面量中的特殊字符
- en: '| ''\'''' | Quote |'
  id: totrans-2352
  prefs: []
  type: TYPE_TB
  zh: '| ''\'''' | 引号 |'
- en: '| ''\"'' | Double quotes |'
  id: totrans-2353
  prefs: []
  type: TYPE_TB
  zh: '| ''\"'' | 双引号 |'
- en: '| ''\?'' | Question mark |'
  id: totrans-2354
  prefs: []
  type: TYPE_TB
  zh: '| ''\?'' | 问号 |'
- en: '| ''\\'' | Backslash |'
  id: totrans-2355
  prefs: []
  type: TYPE_TB
  zh: '| ''\\'' | 反斜杠 |'
- en: '| ''\a'' | Alert |'
  id: totrans-2356
  prefs: []
  type: TYPE_TB
  zh: '| ''\a'' | 警报 |'
- en: '| ''\b'' | Backspace |'
  id: totrans-2357
  prefs: []
  type: TYPE_TB
  zh: '| ''\b'' | 退格 |'
- en: '| ''\f'' | Form feed |'
  id: totrans-2358
  prefs: []
  type: TYPE_TB
  zh: '| ''\f'' | 进纸 |'
- en: '| ''\n'' | New line |'
  id: totrans-2359
  prefs: []
  type: TYPE_TB
  zh: '| ''\n'' | 换行 |'
- en: '| ''\r'' | Carriage return |'
  id: totrans-2360
  prefs: []
  type: TYPE_TB
  zh: '| ''\r'' | 回车 |'
- en: '| ''\t'' | Horizontal tab |'
  id: totrans-2361
  prefs: []
  type: TYPE_TB
  zh: '| ''\t'' | 水平制表符 |'
- en: '| ''\v'' | Vertical tab |'
  id: totrans-2362
  prefs: []
  type: TYPE_TB
  zh: '| ''\v'' | 垂直制表符 |'
- en: '|  |'
  id: totrans-2363
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.23
  id: totrans-2364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 8.23
- en: '*The interpretation of numerically encoded characters depends on the execution
    character set.*'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值编码字符的解释取决于执行字符集。*'
- en: '|  |'
  id: totrans-2366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So, their use is not fully portable and should be avoided.
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们的使用并不完全可移植，应该避免使用。
- en: The following function hexatridecimal uses some of these functions to provide
    a base 36 numerical value for all alphanumerical characters. This is analogous
    to hexadecimal constants, only all other letters have a value in base 36, too:^([[[Exs
    8]](#ch08fn-ex08)])^([[[Exs 9]](#ch08fn-ex09)])^([[[Exs 10]](#ch08fn-ex10)])
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数 hexatridecimal 使用了一些这些函数来为所有字母数字字符提供 36 进制的数值。这与十六进制常量类似，只是所有其他字母在 36 进制中也有值：^([[[Exs
    8]](#ch08fn-ex08)])^([[[Exs 9]](#ch08fn-ex09)])^([[[Exs 10]](#ch08fn-ex10)])
- en: ^([Exs 8])
  id: totrans-2369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 8])
- en: ''
  id: totrans-2370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second **`return`** of hexatridecimal makes an assumption about the relation
    between a and 'A'. What is it?
  id: totrans-2371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hexatridecimal 的第二次 **`return`** 做了一个关于 a 和 'A' 之间关系的假设。那是什么？
- en: ^([Exs 9])
  id: totrans-2372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 9])
- en: ''
  id: totrans-2373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Describe an error scenario in which this assumption is not fulfilled.
  id: totrans-2374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 描述一个假设未满足的错误场景。
- en: ^([Exs 10])
  id: totrans-2375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 10])
- en: ''
  id: totrans-2376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fix this bug: that is, rewrite this code such that it makes no assumption about
    the relation between a and ''A'':'
  id: totrans-2377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修复这个错误：即重写此代码，使其不对a和'A'之间的关系做出假设：
- en: '`strtoul.c`'
  id: totrans-2378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`strtoul.c`'
- en: '[PRE146]'
  id: totrans-2379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: In addition to **strtod**, the C library has **strtoul**, **strtol**, **strtoumax**,
    **strtoimax**, **strtoull**, **strtoll**, **strtold**, and **strtof** to convert
    a string to a numerical value.
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**strtod**之外，C库还有**strtoul**、**strtol**、**strtoumax**、**strtoimax**、**strtoull**、**strtoll**、**strtold**和**strtof**，可以将字符串转换为数值。
- en: 'Here the characters at the end of the names correspond to the type: u for **`unsigned`**,
    l (the letter “el") for **`long`**, d for **`double`**, f for float, and `[`i|`u`]max
    for **`intmax_t`** and **`uintmax_t`**.'
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，名称末尾的字符对应于类型：`u`表示**`unsigned`**，`l`（字母“el”）表示**`long`**，`d`表示**`double`**，`f`表示float，而`[i|u]max`表示**`intmax_t`**和**`uintmax_t`**。
- en: The interfaces with an integral return type all have three parameters, such
    as **strtoul**
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有整数返回类型的接口都有三个参数，例如**strtoul**
- en: '[PRE147]'
  id: totrans-2383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'which interprets a string nptr as a number given in base base. Interesting
    values for base are `0`, `8`, `10`, and `16`. The last three correspond to octal,
    decimal, and hexadecimal encoding, respectively. The first, `0`, is a combination
    of these three, where the base is chosen according to the usual rules for the
    interpretation of text as numbers: "7" is decimal, "007" is octal, and "0x7" is
    hexadecimal. More precisely, the string is interpreted as potentially consisting
    of four different parts: white space, a sign, the number, and some remaining data.'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 它将字符串nptr解释为以base为基数的数字。对于base来说，有趣的值是`0`、`8`、`10`和`16`。最后三个分别对应于八进制、十进制和十六进制编码。第一个`0`是这三个的组合，其中基数根据将文本作为数字解释的常规规则来选择：“7”是十进制，“007”是八进制，“0x7”是十六进制。更准确地说，字符串被解释为可能由四个不同的部分组成：空白字符、符号、数字和一些剩余数据。
- en: The second parameter can be used to obtain the position of the remaining data,
    but this is still too involved for us. For the moment, it suffices to pass a `0`
    for that parameter to ensure that everything works well. A convenient combination
    of parameters is often **strtoul**`(`S`, 0, 0)`, which will try to interpret S
    as representing a number, regardless of the input format. The three functions
    that provide floating-point values work similarly, only the number of function
    parameters is limited to two.
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数可以用来获取剩余数据的位置，但这对于我们来说仍然过于复杂。目前，只需为该参数传递一个`0`即可确保一切正常工作。参数的一个方便的组合是**strtoul**`(`S`,
    0, 0)`，它将尝试将S解释为一个数字，无论输入格式如何。提供浮点值的三种函数工作方式类似，只是函数参数的数量限制为两个。
- en: 'Next, we will demonstrate how such functions can be implemented from more basic
    primitives. Let us first look at Strtoul_inner. It is the core of a **strtoul**
    implementation that uses hexatridecimal in a loop to compute a large integer from
    a string:'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示如何从更基本的原始函数实现这样的函数。让我们首先看看Strtoul_inner。它是使用十六进制循环从字符串计算大整数的**strtoul**实现的核心：
- en: '`strtoul.c`'
  id: totrans-2387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`strtoul.c`'
- en: '[PRE148]'
  id: totrans-2388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: If the string represents a number that is too big for an **`unsigned long`**,
    this function returns **`ULONG_MAX`** and sets **`errno`** to **`ERANGE`**.
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串表示的数字太大，无法用**`unsigned long`**表示，则此函数返回**`ULONG_MAX`**并将**`errno`**设置为**`ERANGE`**。
- en: 'Now Strtoul gives a functional implementation of **strtoul**, as far as this
    can be done without pointers:'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Strtoul提供了**strtoul**的功能实现，只要不使用指针就可以做到这一点：
- en: '`strtoul.c`'
  id: totrans-2391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`strtoul.c`'
- en: '[PRE149]'
  id: totrans-2392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'It wraps Strtoul_inner and does the previous adjustments that are needed: it
    skips white space, looks for an optional sign, adjusts the base in case the base
    parameter was `0`, and skips an eventual `0` or 0x prefix. Observe also that if
    a minus sign has been provided, it does the correct negation of the result in
    terms of **`unsigned long`** arithmetic.^([[[Exs 11]](#ch08fn-ex11)])'
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 它封装了Strtoul_inner并执行所需的先前调整：跳过空白字符，查找可选的符号，在基数参数为`0`的情况下调整基数，并跳过一个可能的`0`或0x前缀。还要注意，如果提供了负号，它将根据**`unsigned
    long`**算术正确地取反结果。^([[[Exs 11]](#ch08fn-ex11)])
- en: ^([Exs 11])
  id: totrans-2394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 11])
- en: ''
  id: totrans-2395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement a function find_prefix as needed by Strtoul.
  id: totrans-2396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现Strtoul所需的find_prefix函数。
- en: To skip the spaces, Strtoul uses **strspn**, one of the string search functions
    provided by `string.h`. This function returns the length of the initial sequence
    in the first parameter that entirely consists of any character from the second
    parameter. The function **strcspn** (“c” for “complement”) works similarly, but
    it looks for an initial sequence of characters not present in the second argument.
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 要跳过空格，Strtoul使用**strspn**，这是`string.h`提供的字符串搜索函数之一。此函数返回第一个参数中完全由第二个参数中的任何字符组成的初始序列的长度。函数**strcspn**（“c”代表“补足”）以类似的方式工作，但它寻找第二个参数中不存在的初始字符序列。
- en: '|  |'
  id: totrans-2398
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<string.h>`'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: '`<string.h>`'
- en: '|  |'
  id: totrans-2400
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'This header provides at lot more memory and string search functions: **memchr**,
    **strchr**, **strpbrk strrchr**, **strstr**, and **strtok**. But to use them,
    we would need pointers, so we can’t handle them yet.'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 此头文件提供了许多内存和字符串搜索函数：**memchr**、**strchr**、**strpbrk**、**strrchr**、**strstr**和**strtok**。但为了使用它们，我们需要指针，所以我们目前还不能处理它们。
- en: 8.5\. Time
  id: totrans-2402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 时间
- en: 'The first class of times can be classified as calendar times, times with a
    granularity and range that would typically appear in a human calendar for appointments,
    birthdays, and so on. Here are some of the functional interfaces that deal with
    times and that are all provided by the `time.h` header:'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类时间可以被归类为日历时间，具有通常出现在人类日历中的粒度和范围，例如约会、生日等。以下是一些处理时间和由`time.h`头文件提供的功能接口：
- en: '|  |'
  id: totrans-2404
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<time.h>`'
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: '`<time.h>`'
- en: '|  |'
  id: totrans-2406
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE150]'
  id: totrans-2407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The first simply provides us with a timestamp of type **`time_t`** of the current
    time. The simplest form uses the return value of **time**`(0)`. As we have seen,
    two such times taken from different moments during program execution can then
    be used to express a time difference by means of **difftime**.
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个简单地为我们提供了当前时间的**`time_t`**类型的时间戳。最简单的形式使用**time**`(0)`的返回值。正如我们所见，在程序执行的不同时刻取出的两个这样的时间可以用来通过**difftime**表达时间差。
- en: 'Let’s see what all this is doing from the human perspective. As we know, **`struct`**
    **`tm`** structures a calendar time mainly as you would expect. It has hierarchical
    date members such as **`tm_year`** for the year, **`tm_mon`** for the month, and
    so on, down to the granularity of a second. It has one pitfall, though: how the
    members are counted. All but one start with `0`: for example, **`tm_mon`** set
    to `0` stands for January, and **`tm_wday`** `0` stands for Sunday.'
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从人类的角度来看一下这一切都在做什么。正如我们所知，**`struct`** **`tm`**结构主要按照您预期的日历时间进行。它具有层次日期成员，如**`tm_year`**表示年份，**`tm_mon`**表示月份，等等，直到秒的粒度。但它有一个陷阱：成员是如何计算的。除了一个之外，所有成员都是从`0`开始的：例如，**`tm_mon`**设置为`0`表示一月，而**`tm_wday`**
    `0`表示星期日。
- en: 'Unfortunately, there are exceptions:'
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，存在例外：
- en: '**`tm_mday`** starts counting days in the month at 1.'
  id: totrans-2411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`tm_mday`**从1开始计算月份中的天数。'
- en: '**`tm_year`** must add 1900 to get the year in the Gregorian calendar. Years
    represented that way should be between Gregorian years 0 and 9999.'
  id: totrans-2412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`tm_year`**必须加1900才能得到格里高利日历中的年份。以这种方式表示的年份应在格里高利年份0到9999之间。'
- en: '**`tm_sec`** is in the range from 0 to 60, inclusive. The latter is for the
    rare occasion of leap seconds.'
  id: totrans-2413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`tm_sec`**的范围是从0到60，包括60，后者是用于罕见的闰秒情况。'
- en: 'Three supplemental date members are used to supply additional information to
    a time value in a **`struct`** **`tm`**:'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个补充日期成员用于向**`struct`** **`tm`**中的时间值提供额外信息：
- en: '**`tm_wday`** for the week day.'
  id: totrans-2415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`tm_wday`**表示星期几。'
- en: '**`tm_yday`** for the day in the year.'
  id: totrans-2416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`tm_yday`**表示一年中的某一天。'
- en: '**`tm_isdst`** is a flag that informs us whether a date is considered to be
    in DST for the local time zone.'
  id: totrans-2417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`tm_isdst`**是一个标志，它告诉我们日期是否被认为是本地时区的夏令时。'
- en: 'The consistency of all these members can be enforced with the function **mktime**.
    It operates in three steps:'
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些成员的一致性可以通过函数**mktime**来强制执行。它分为三个步骤：
- en: '**1**.  The hierarchical date members are normalized to their respective ranges.'
  id: totrans-2419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  层次日期成员被归一化到各自的范围内。'
- en: '**2**.  **`tm_wday`** and **`tm_yday`** are set to the corresponding values.'
  id: totrans-2420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  **`tm_wday`**和**`tm_yday`**被设置为相应的值。'
- en: '**3**.  If tm_isday has a negative value, this value is modified to 1 if the
    date falls into DST for the local platform, or to `0` otherwise.'
  id: totrans-2421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  如果tm_isday具有负值，则如果日期属于本地平台的夏令时，此值将修改为1，否则为`0`。'
- en: '**mktime** also serves an extra purpose. It returns the time as a **`time_t`**.
    **`time_t`** represents the same calendar times as **`struct`** **`tm`** but is
    defined to be an arithmetic type, more suited to compute with such types. It operates
    on a linear time scale. A **`time_t`** value of `0` at the beginning of **`time_t`**
    is called the *epoch**^C* in the C jargon. Often this corresponds to the beginning
    of Jan 1, 1970.'
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: '**mktime**还提供了一个额外的作用。它返回作为**`time_t`**的时间。**`time_t`**代表与**`struct`** **`tm`**相同的日历时间，但被定义为算术类型，更适合与这种类型进行计算。它在一个线性时间尺度上操作。**`time_t`**值`0`在**`time_t`**的开始被称为C术语中的*纪元*。通常这对应于1970年1月1日。'
- en: The granularity of **`time_t`** is usually to the second, but nothing guarantees
    that. Sometimes processor hardware has special registers for clocks that obey
    a different granularity. **difftime** translates the difference between two **`time_t`**
    values into seconds that are represented as a double value.
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: '**`time_t`**的粒度通常到秒，但没有任何东西可以保证这一点。有时处理器硬件有特殊的时钟寄存器，它们遵循不同的粒度。**difftime**将两个**`time_t`**值之间的差异转换为以双精度值表示的秒。'
- en: '|  |'
  id: totrans-2424
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Annex K**'
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: '**附件K**'
- en: 'Other traditional functions that manipulate time in C are a bit dangerous because
    they operate on global state. We will not discuss them here, but variants of these
    interfaces have been reviewed in Annex K in an _s form:'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 其他在C中操作时间的传统函数有点危险，因为它们操作全局状态。我们在这里不会讨论它们，但这些接口的变体已在附件K中以_s形式进行了审查：
- en: '[PRE151]'
  id: totrans-2427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '|  |'
  id: totrans-2428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 8.1](#ch08fig01) shows how all these functions interact:'
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.1](#ch08fig01)展示了所有这些函数是如何交互的：'
- en: Figure 8.1\. Time conversion functions
  id: totrans-2430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 时间转换函数
- en: '![](08fig01_alt.jpg)'
  id: totrans-2431
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig01_alt.jpg)'
- en: 'Two functions for the inverse operation from **`time_t`** into **`struct`**
    **`tm`** come into view:'
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数用于从**`time_t`**到**`struct`** **`tm`**的逆向操作：
- en: '**localtime_s** stores the broken-down local time.'
  id: totrans-2433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**localtime_s**存储分解后的本地时间。'
- en: '**gmtime_s** stores the broken time, expressed as universal time, UTC.'
  id: totrans-2434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gmtime_s**存储分解的时间，以通用时间，UTC表示。'
- en: As indicated, they differ in the time zone they assume for the conversion. Under
    normal circumstances, **localtime_s** and **mktime** should be inverse to each
    other; **gmtime_s** has no direct counterpart in the inverse direction.
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，它们在转换时假设的时间区域不同。在正常情况下，**localtime_s**和**mktime**应该是彼此的逆；**gmtime_s**在逆向方向上没有直接对应物。
- en: Textual representations of calendar times are also available. **asctime_s**
    stores the date in a fixed format, independent of any locale, language (it uses
    English abbreviations), or platform dependency. The format is a string of the
    form
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: 日历时间的文本表示也可用。**asctime_s**以固定格式存储日期，独立于任何区域设置、语言（它使用英语缩写）或平台依赖性。格式是形如的字符串
- en: '[PRE152]'
  id: totrans-2437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '**strftime** is more flexible and allows us to compose a textual representation
    with format specifiers.'
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: '**strftime**更灵活，允许我们使用格式说明符组合文本表示。'
- en: 'It works similarly to the **printf** family but has special `%`-codes for dates
    and times; see [table 8.13](#ch08table13). Here, the Locale column indicates that
    different environment settings, such as preferred language or time zone, may influence
    the output. How to access and eventually set these will be explained in [section
    8.6](#ch08lev1sec6). **strftime** receives three arrays: a **`char`**`[`max`]`
    array that is to be filled with the result string, another string that holds the
    format, and a **`struct`** **`tm`** **`const`**`[1]` that holds the time to be
    represented. The reason for passing in an array for the time will only become
    apparent when we know more about pointers.'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 它与**printf**家族类似，但具有用于日期和时间的特殊`%`-代码；参见[表8.13](#ch08table13)。在这里，区域列表明不同的环境设置，如首选语言或时区，可能会影响输出。如何访问和最终设置这些将在[第8.6节](#ch08lev1sec6)中解释。**strftime**接收三个数组：一个要填充结果字符串的**`char`**`[`max`]`数组，另一个包含格式的字符串，以及一个包含要表示的时间的**`struct`**
    **`tm`** **`const`**`[1]`。传递时间数组的原因只有在了解更多关于指针之后才会变得明显。
- en: Table 8.13\. ***strftime** format specifiers* Those selected in the Locale column
    may differ dynamically according to locale runtime settings; see [section 8.6](#ch08lev1sec6).
    Those selected in the ISO 8601 column are specified by that standard.
  id: totrans-2440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.13\. ***strftime**格式说明符* 在区域列中选定的可能根据区域运行时设置动态变化；参见[第8.6节](#ch08lev1sec6)。在ISO
    8601列中选定的由该标准指定。
- en: '| Spec | Meaning | Locale | ISO 8601 |'
  id: totrans-2441
  prefs: []
  type: TYPE_TB
  zh: '| Spec | Meaning | Locale | ISO 8601 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-2442
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| "%S" | Second ("00" to "60") |   |   |'
  id: totrans-2443
  prefs: []
  type: TYPE_TB
  zh: '| "%S" | 秒 ("00" 到 "60") |   |   |'
- en: '| "%M" | Minute ("00" to "59") |   |   |'
  id: totrans-2444
  prefs: []
  type: TYPE_TB
  zh: '| "%M" | 分钟 ("00" 到 "59") |   |   |'
- en: '| "%H" | Hour ("00" to "23"). |   |   |'
  id: totrans-2445
  prefs: []
  type: TYPE_TB
  zh: '| "%H" | 小时 ("00" 到 "23")。 |   |   |'
- en: '| "%I" | Hour ("01" to "12"). |   |   |'
  id: totrans-2446
  prefs: []
  type: TYPE_TB
  zh: '| "%I" | 小时 ("01" 到 "12")。 |   |   |'
- en: '| "%e" | Day of the month (" 1" to "31") |   |   |'
  id: totrans-2447
  prefs: []
  type: TYPE_TB
  zh: '| "%e" | 月份中的日 (" 1" 到 "31") |   |   |'
- en: '| "%d" | Day of the month ("01" to "31") |   |   |'
  id: totrans-2448
  prefs: []
  type: TYPE_TB
  zh: '| "%d" | 月份中的日 ("01" 到 "31") |   |   |'
- en: '| "%m" | Month ("01" to "12") |   |   |'
  id: totrans-2449
  prefs: []
  type: TYPE_TB
  zh: '| "%m" | 月份 ("01" 到 "12") |   |   |'
- en: '| "%B" | Full month name | X |   |'
  id: totrans-2450
  prefs: []
  type: TYPE_TB
  zh: '| "%B" | 月份的全称 | X |   |'
- en: '| "%b" | Abbreviated month name | X |   |'
  id: totrans-2451
  prefs: []
  type: TYPE_TB
  zh: '| "%b" | 缩写的月份名称 | X |   |'
- en: '| "%h" | Equivalent to "%b" | X |   |'
  id: totrans-2452
  prefs: []
  type: TYPE_TB
  zh: '| "%h" | 等同于 "%b" | X |   |'
- en: '| "%Y" | Year |   |   |'
  id: totrans-2453
  prefs: []
  type: TYPE_TB
  zh: '| "%Y" | 年 |   |   |'
- en: '| "%y" | Year ("00" to "99") |   |   |'
  id: totrans-2454
  prefs: []
  type: TYPE_TB
  zh: '| "%y" | 年 ("00" 到 "99") |   |   |'
- en: '| "%C" | Century number (year/100) |   |   |'
  id: totrans-2455
  prefs: []
  type: TYPE_TB
  zh: '| "%C" | 世纪数（年/100） |   |   |'
- en: '| "%G" | Week-based year; the same as "%Y", except if the ISO week number belongs
    another year |   | X |'
  id: totrans-2456
  prefs: []
  type: TYPE_TB
  zh: '| "%G" | 基于周的年份；与 "%Y" 相同，除非 ISO 周数属于另一年 |   | X |'
- en: '| "%g" | Like "%G", ("00" to "99") |   | X |'
  id: totrans-2457
  prefs: []
  type: TYPE_TB
  zh: '| "%g" | 与 "%G" 类似，("00" 到 "99") |   | X |'
- en: '| "%u" | Weekday ("1" to "7"), Monday being "1" |   |   |'
  id: totrans-2458
  prefs: []
  type: TYPE_TB
  zh: '| "%u" | 星期几 ("1" 到 "7")，星期一为 "1" |   |   |'
- en: '| "%w" | Weekday ("0" to "6", Sunday being "0" |   |   |'
  id: totrans-2459
  prefs: []
  type: TYPE_TB
  zh: '| "%w" | 星期几 ("0" 到 "6"，星期天为 "0") |   |   |'
- en: '| "%A" | Full weekday name | X |   |'
  id: totrans-2460
  prefs: []
  type: TYPE_TB
  zh: '| "%A" | 星期几的全称 | X |   |'
- en: '| "%a" | Abbreviated weekday name | X |  |'
  id: totrans-2461
  prefs: []
  type: TYPE_TB
  zh: '| "%a" | 缩写的工作日名称 | X |  |'
- en: '| "%j" | Day of the year ("001" to "366") |   |   |'
  id: totrans-2462
  prefs: []
  type: TYPE_TB
  zh: '| "%j" | 一年中的日 ("001" 到 "366") |   |   |'
- en: '| "%U" | Week number in the year ("00" to "53"), starting at Sunday |   |  
    |'
  id: totrans-2463
  prefs: []
  type: TYPE_TB
  zh: '| "%U" | 一年中的周数 ("00" 到 "53")，从星期日开始 |   |   |'
- en: '| "%W" | Week number in the year ("00" to "53"), starting at Monday |   |  
    |'
  id: totrans-2464
  prefs: []
  type: TYPE_TB
  zh: '| "%W" | 一年中的周数 ("00" 到 "53")，从星期一开始 |   |   |'
- en: '| "%V" | Week number in the year ("01" to "53"), starting with first four days
    in the new year |   | X |'
  id: totrans-2465
  prefs: []
  type: TYPE_TB
  zh: '| "%V" | 一年中的周数 ("01" 到 "53")，从新年的前四天开始 |   | X |'
- en: '| "%Z" | Timezone name | X |   |'
  id: totrans-2466
  prefs: []
  type: TYPE_TB
  zh: '| "%Z" | 时区名称 | X |   |'
- en: '| "%z" | "+hhmm" or "-hhmm", the hour and minute offset from UTC |   |   |'
  id: totrans-2467
  prefs: []
  type: TYPE_TB
  zh: '| "%z" | "+hhmm" 或 "-hhmm"，相对于 UTC 的小时和分钟偏移量 |   |   |'
- en: '| "%n" | Newline |   |   |'
  id: totrans-2468
  prefs: []
  type: TYPE_TB
  zh: '| "%n" | 换行符 |   |   |'
- en: '| "%t" | Horizontal tabulator |   |   |'
  id: totrans-2469
  prefs: []
  type: TYPE_TB
  zh: '| "%t" | 水平制表符 |   |   |'
- en: '| "%%" | Literal "%" |   |   |'
  id: totrans-2470
  prefs: []
  type: TYPE_TB
  zh: '| "%%" | 文字 "%" |   |   |'
- en: '| "%x" | Date | X |   |'
  id: totrans-2471
  prefs: []
  type: TYPE_TB
  zh: '| "%x" | 日期 | X |   |'
- en: '| "%D" | Equivalent to "%m/%d/%y" |   |   |'
  id: totrans-2472
  prefs: []
  type: TYPE_TB
  zh: '| "%D" | 等同于 "%m/%d/%y" |   |   |'
- en: '| "%F" | Equivalent to "%Y-%m-%d" |   | X |'
  id: totrans-2473
  prefs: []
  type: TYPE_TB
  zh: '| "%F" | 等同于 "%Y-%m-%d" |   | X |'
- en: '| "%X" | Time | X |   |'
  id: totrans-2474
  prefs: []
  type: TYPE_TB
  zh: '| "%X" | 时间 | X |   |'
- en: '| "%p" | Either "AM" or "PM": noon is "PM", midnight is "AM" | X |   |'
  id: totrans-2475
  prefs: []
  type: TYPE_TB
  zh: '| "%p" | "AM" 或 "PM" 之一：中午是 "PM"，午夜是 "AM" | X |   |'
- en: '| "%r" | Equivalent to "%I:%M:%S %p" | X |   |'
  id: totrans-2476
  prefs: []
  type: TYPE_TB
  zh: '| "%r" | 等同于 "%I:%M:%S %p" | X |   |'
- en: '| "%R" | Equivalent to "%H:%M" |   |   |'
  id: totrans-2477
  prefs: []
  type: TYPE_TB
  zh: '| "%R" | 等同于 "%H:%M" |   |   |'
- en: '| "%T" | Equivalent to "%H:%M:%S" |   | X |'
  id: totrans-2478
  prefs: []
  type: TYPE_TB
  zh: '| "%T" | 等同于 "%H:%M:%S" |   | X |'
- en: '| "%c" | Preferred date and time representation | X |   |'
  id: totrans-2479
  prefs: []
  type: TYPE_TB
  zh: '| "%c" | 日期和时间的首选表示 | X |   |'
- en: The opaque type **`time_t`** (and as a consequence **time** itself) only has
    a granularity of seconds.
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 不透明的类型 **`time_t`**（以及作为结果 **time** 本身）只有秒级的粒度。
- en: 'If we need more precision than that, **`struct`** **`timespec`** and the **timespec_get**
    function can be used. With that, we have an additional member **`tv_nsec`** that
    provides nanosecond precision. The second argument, base, has only one value defined
    by the C standard: **`TIME_UTC`**. You should expect a call to **timespec_get**
    with that value to be consistent with calls to **time**. They both refer to Earth’s
    reference time. Specific platforms may provide additional values for base that
    specify a clock that is different from a clock on the wall. An example of such
    a clock could be relative to the planetary or other physical system your computer
    system is involved with.^([[2](#ch08fn02)]) Relativity and other time adjustments
    can be avoided by using a *monotonic clock* that only refers to the startup time
    of the system. A CPU clock could refer to the time the program execution had been
    attributed processing resources.'
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要比这更高的精度，可以使用 **`struct`** **`timespec`** 和 **`timespec_get`** 函数。这样，我们有一个额外的成员
    **`tv_nsec`**，它提供了纳秒级的精度。第二个参数，base，由 C 标准定义了一个值：**`TIME_UTC`**。你应该期望使用该值的 **`timespec_get`**
    调用与 **`time`** 调用保持一致。它们都指的是地球的参考时间。特定的平台可能为 base 提供额外的值，指定一个不同于墙上的时钟的时钟。这样的时钟可以是相对于你的计算机系统参与的行星或其他物理系统。^([[2](#ch08fn02)])
    通过使用只引用系统启动时间的 *单调时钟*，可以避免相对论和其他时间调整。CPU 时钟可以指程序执行被分配处理资源的时间。
- en: ²
  id: totrans-2482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-2483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be aware that objects that move fast relative to Earth, such as satellites and
    spacecraft, may perceive relativistic time shifts compared to UTC.
  id: totrans-2484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，相对于地球快速移动的物体，如卫星和宇宙飞船，可能会相对于 UTC 感知到相对论时间变化。
- en: 'For the latter, there is an additional interface that is provided by the C
    standard library:'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后者，C 标准库提供了一个额外的接口：
- en: '[PRE153]'
  id: totrans-2486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: For historical reasons, this introduces yet another type, **`clock_t`**. It
    is an arithmetic time that gives the processor time in **`CLOCKS_PER_SEC`** units
    per second.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，这引入了另一种类型，**`clock_t`**。它是以 **`CLOCKS_PER_SEC`** 单位每秒给出的处理器时间。
- en: Having three different interfaces, **time**, **timespec_get**, and **clock**,
    is a bit unfortunate. It would have been beneficial to provide predefined constants
    such as TIME_PROCESS_TIME and TIME_THREAD_TIME for other forms of clocks.
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个不同的接口，**time**、**timespec_get** 和 **clock**，有点不幸。如果为其他形式的时钟提供预定义的常量，如 TIME_PROCESS_TIME
    和 TIME_THREAD_TIME，将会很有益。
- en: '![](comm.jpg)'
  id: totrans-2489
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: '|  |'
  id: totrans-2490
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Performance comparison of sorting algorithms**'
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: '**排序算法的性能比较**'
- en: Can you compare the time efficiency of your sorting programs ([challenge 1](kindle_split_011.html#ch03sb01))
    with data sizes of several orders of magnitude?
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 你能比较你的排序程序（[挑战 1](kindle_split_011.html#ch03sb01)）的时间效率与几个数量级的数据大小吗？
- en: Be careful to check that you have some randomness in the creation of the data
    and that the data size does not exceed the available memory of your computer.
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在数据的创建中要有一些随机性，并且数据大小不要超过你电脑的可用内存。
- en: For both algorithms, you should roughly observe a behavior that is proportional
    to *N* log *N*, where *N* is the number of elements that are sorted.
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个算法，你应该大致观察到与 *N* log *N* 成正比的行为，其中 *N* 是排序的元素数量。
- en: '|  |'
  id: totrans-2495
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.6\. Runtime environment settings
  id: totrans-2496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6\. 运行时环境设置
- en: 'A C program can access an *environment list**^C*: a list of name-value pairs
    of strings (often called *environment variables**^C*) that can transmit specific
    information from the runtime environment. There is a historical function **getenv**
    to access this list:'
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序可以访问一个 *环境列表**^C*：一个字符串的名称-值对列表（通常称为 *环境变量**^C*），它可以从运行时环境传输特定信息。有一个历史函数
    **getenv** 来访问这个列表：
- en: '[PRE154]'
  id: totrans-2498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Given our current knowledge, with this function we are only able to test whether
    a name is present in the environment list:'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前的知识，使用这个函数我们只能测试一个名称是否存在于环境列表中：
- en: '[PRE155]'
  id: totrans-2500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Instead, we use the secured function **getenv_s**:'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用安全的函数 **getenv_s**：
- en: '|  |'
  id: totrans-2502
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Annex K**'
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: '**附录 K**'
- en: '[PRE156]'
  id: totrans-2504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This function copies the value that corresponds to name (if any) from the environment
    into value, a **`char`**`[`maxsize`]`, provided that it fits. Printing such a
    value can look as this:'
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将对应于名称（如果有的话）的值从环境复制到 value，一个 **`char`**`[`maxsize`]`，前提是它适合。打印这样的值可能看起来像这样：
- en: '[PRE157]'
  id: totrans-2506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: As you can see, after detecting whether the environment variable exists, **getenv_s**
    can safely be called with the first argument set to `0`. Additionally, it is guaranteed
    that the value target buffer will only be written if the intended result fits
    in it. The len parameter could be used to detect the real length that is needed,
    and dynamic buffer allocation could be used to print out even large values. We
    will wait until higher levels to see such usages.
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在检测到环境变量是否存在之后，可以将第一个参数设置为 `0` 来安全地调用 **getenv_s**。此外，可以保证只有当预期结果适合时，目标缓冲区才会被写入。可以使用
    len 参数来检测所需的实际长度，并使用动态缓冲区分配来打印出更大的值。我们将等待更高层次来查看此类用法。
- en: '|  |'
  id: totrans-2508
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Which environment variables are available to programs depends heavily on the
    operating system. Commonly provided environment variables include "HOME" for the
    user’s home directory, "PATH" for the collection of standard paths to executables,
    and "LANG" or "LC_ALL" for the language setting.
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的环境变量取决于操作系统。常见的环境变量包括 "HOME" 用于用户的家目录，"PATH" 用于可执行文件的集合标准路径，以及 "LANG" 或 "LC_ALL"
    用于语言设置。
- en: The language or *locale**^C* setting is another important part of the execution
    environment that a program execution inherits. At startup, C forces the locale
    setting to a normalized value, called the "C" locale. It has basically American
    English choices for numbers or times and dates.
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 语言或 *locale**^C* 设置是程序执行继承的执行环境的重要组成部分。在启动时，C 将区域设置强制为规范化值，称为 "C" 区域。它基本上有美国英语的选择，用于数字或时间日期。
- en: '|  |'
  id: totrans-2511
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<locale.h>`'
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: '`<locale.h>`'
- en: '|  |'
  id: totrans-2513
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The function **setlocale** from `locale.h` can be used to set or inspect the
    current value:'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `locale.h` 中的 **setlocale** 函数来设置或检查当前值：
- en: '[PRE158]'
  id: totrans-2515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'In addition to "C", the C standard prescribes the existence of one other valid
    value for locale: the empty string "". This can be used to set the effective locale
    to the systems default. The category argument can be used to address all or only
    parts of the language environment. [Table 8.14](#ch08table14) gives an overview
    over the possible values and the part of the C library they affect. Additional
    platform-dependent categories may be available.'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 除了"C"之外，C标准还规定了另一个有效的locale值的存在：空字符串""。这可以用来将有效locale设置为系统默认值。分类参数可以用来处理语言环境的全部或部分。[表8.14](#ch08table14)概述了可能的值以及它们影响的C库部分。可能还有其他平台相关的分类可用。
- en: Table 8.14\. Categories for the **setlocale** function
  id: totrans-2517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.14\. **setlocale**函数的分类
- en: '| **LC_COLLATE** | String comparison through **strcoll** and **strxfrm** |'
  id: totrans-2518
  prefs: []
  type: TYPE_TB
  zh: '| **LC_COLLATE** | 通过**strcoll**和**strxfrm**进行字符串比较 |'
- en: '| **LC_CTYPE** | Character classification and handling functions; see [section
    8.4](#ch08lev1sec4). |'
  id: totrans-2519
  prefs: []
  type: TYPE_TB
  zh: '| **LC_CTYPE** | 字符分类和处理函数；参见[第8.4节](#ch08lev1sec4)。 |'
- en: '| **LC_MONETARY** | Monetary formatting information, **localeconv** |'
  id: totrans-2520
  prefs: []
  type: TYPE_TB
  zh: '| **LC_MONETARY** | 货币格式化信息，**localeconv** |'
- en: '| **LC_NUMERIC** | Decimal-point character for formatted I/O, **localeconv**
    |'
  id: totrans-2521
  prefs: []
  type: TYPE_TB
  zh: '| **LC_NUMERIC** | 格式化I/O的十进制点字符，**localeconv** |'
- en: '| **LC_TIME** | **strftime**; see [section 8.5](#ch08lev1sec5) |'
  id: totrans-2522
  prefs: []
  type: TYPE_TB
  zh: '| **LC_TIME** | **strftime**；参见[第8.5节](#ch08lev1sec5) |'
- en: '| **LC_ALL** | All of the above |'
  id: totrans-2523
  prefs: []
  type: TYPE_TB
  zh: '| **LC_ALL** | 所有上述内容 |'
- en: 8.7\. Program termination and assertions
  id: totrans-2524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7\. 程序终止和断言
- en: 'We have looked at the simplest way to terminate a program: a regular return
    from **main**.'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了终止程序最简单的方法：从**main**的常规返回。
- en: '|  |'
  id: totrans-2526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.24
  id: totrans-2527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要8.24
- en: '*Regular program termination should use a* **`return`** *from* **main***.*'
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: '*常规程序终止应使用从**main**返回的* **`return`** *。*'
- en: '|  |'
  id: totrans-2529
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using the function **exit** from within **main** is kind of senseless, because
    it can be done just as easily with a **`return`**.
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**main**函数内的**exit**函数有点没有意义，因为它可以用**`return`**同样轻松地完成。
- en: '|  |'
  id: totrans-2531
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.25
  id: totrans-2532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要8.25
- en: '*Use* **exit** *from a function that may terminate the regular control flow.*'
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: '*在可能终止常规控制流的函数中使用* **exit** *。*'
- en: '|  |'
  id: totrans-2534
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The C library has three other functions that terminate program execution, in
    order of severity:'
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: C库有三个其他函数可以终止程序执行，按严重程度排序：
- en: '[PRE159]'
  id: totrans-2536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Now, **`return`** from **main** (or a call to **exit**) already provides the
    possibility to specify whether the program execution is considered to be a success.
    Use the return value to specify that; as long as you have no other needs or you
    don’t fully understand what these other functions do, don’t use them. Really:
    don’t.'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从**main**（或对**exit**的调用）返回**`return`**已经提供了指定程序执行是否被认为是成功的机会。使用返回值来指定；只要你没有其他需求或者你并不完全理解这些其他函数的作用，就不要使用它们。真的：不要使用。
- en: '|  |'
  id: totrans-2538
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.26
  id: totrans-2539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要8.26
- en: '*Don’t use functions other than* **exit** *for program termination, unless
    you have to inhibit the execution of library cleanups.*'
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非你不得不抑制库清理的执行，否则不要使用除了* **exit** *之外的函数来终止程序*。'
- en: '|  |'
  id: totrans-2541
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Cleanup at program termination is important. The runtime system can flush and
    close files that are written or free other resources that the program occupied.
    This is a feature and should rarely be circumvented.
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 程序终止时的清理很重要。运行时系统可以刷新和关闭已写入的文件，释放程序占用的其他资源。这是一个特性，应该很少被绕过。
- en: 'There is even a mechanism to install your own *handlers**^C* that are to be
    executed at program termination. Two functions can be used for that:'
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至有一个机制可以安装你自己的*处理程序**^C*，它们将在程序终止时执行。可以使用两个函数来完成这个任务：
- en: '[PRE160]'
  id: totrans-2544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'These have a syntax we have not yet seen: *function parameters**^C*. For example,
    the first reads “function **atexit** that returns an **`int`** and that receives
    a function func as a parameter.”^([[3](#ch08fn03)])'
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有我们尚未见过的语法：*函数参数**^C*。例如，第一个读取为“返回**`int`**并接收一个函数参数func的**atexit**函数。”^([[3](#ch08fn03)])
- en: ³
  id: totrans-2546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-2547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In fact, in C, such a notion of a function parameter func to a function **atexit**
    is equivalent to passing a *function pointer**^C* . In descriptions of such functions,
    you will usually see the pointer variant. For us, this distinction is not yet
    relevant; it is simpler to think of a function being passed by reference.
  id: totrans-2548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 事实上，在C语言中，这种将函数参数func传递给函数**atexit**的概念与传递一个*函数指针**^C*是等价的。在描述此类函数时，你通常会看到指针变体。对我们来说，这种区别还不相关；将其视为通过引用传递函数会更简单。
- en: 'We will not go into detail here. An example will show how this can be used:'
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细介绍。一个例子将展示如何使用它：
- en: '[PRE161]'
  id: totrans-2550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'This uses the function **atexit** to establish the **exit**-handler sayGoodBye.
    After normal termination of the program code, this function will be executed and
    give the status of the execution. This might be a nice way to impress your co-workers
    if you are in need of some respect. More seriously, this is the ideal place to
    put all kinds of cleanup code, such as freeing memory or writing a termination
    timestamp to a log file. Observe that the syntax for calling is **atexit**`(`sayGoodBye`)`.
    There are no `()` for sayGoodBye itself: here, sayGoodBye is not called at that
    point; only a reference to the function is passed to **atexit**.'
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用函数**atexit**来建立**exit**处理程序sayGoodBye。在程序代码的正常终止后，此函数将被执行并给出执行状态。如果你需要一些尊重，这可能是一个很好的方式来给你的同事留下深刻印象。更严重的是，这是放置所有各种清理代码的理想位置，例如释放内存或将终止时间戳写入日志文件。请注意，调用语法为**atexit**`(`sayGoodBye`)`。sayGoodBye本身没有`()`：在这里，sayGoodBye在那个点没有被调用；只是将函数的引用传递给了**atexit**。
- en: Under rare circumstances, you might want to circumvent these established **atexit**
    handlers. There is a second pair of functions, **quick_exit** and **at_quick_exit**,
    that can be used to establish an alternative list of termination handlers. Such
    an alternative list may be useful if the normal execution of the handlers is too
    time consuming. Use with care.
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见情况下，你可能想要绕过这些已建立的**atexit**处理程序。有一对其他函数，**quick_exit**和**at_quick_exit**，可以用来建立替代的终止处理程序列表。如果正常处理程序的执行过于耗时，这样的替代列表可能很有用。请谨慎使用。
- en: 'The next function, **_Exit**, is even more severe: it inhibits both types of
    application-specific handlers to be executed. The only things that are executed
    are the platform-specific cleanups, such as file closure. Use this with even more
    care.'
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数，**_Exit**，更为严重：它抑制了两种类型的应用特定处理程序的执行。唯一执行的是平台特定的清理操作，例如文件关闭。请更加谨慎地使用它。
- en: The last function, **abort**, is even more intrusive. Not only doesn’t it call
    the application handlers, but also it inhibits the execution of some system cleanups.
    Use this with extreme care.
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数，**abort**，更为侵入性。它不仅不会调用应用程序处理程序，还会抑制某些系统清理的执行。请极其谨慎地使用它。
- en: 'At the beginning of this chapter, we looked at **`_Static_assert`** and **`static_assert`**,
    which should be used to make compile-time assertions. They can test for any form
    of compile-time Boolean expression. Two other identifiers come from `assert.h`
    and can be used for runtime assertions: **`assert`** and **`NDEBUG`**. The first
    can be used to test for an expression that must hold at a certain moment. It may
    contain any Boolean expression, and it may be dynamic. If the **`NDEBUG`** macro
    is not defined during compilation, every time execution passes by the call to
    this macro, the expression is evaluated. The functions gcd and gcd2 from [section
    7.3](kindle_split_015.html#ch07lev1sec3) show typical use cases of **`assert`**:
    a condition that is supposed to hold in *every* execution.'
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们探讨了**`_Static_assert`**和**`static_assert`**，它们应该用于进行编译时断言。它们可以测试任何形式的编译时布尔表达式。另外两个标识符来自`assert.h`，可用于运行时断言：**`assert`**和**`NDEBUG`**。第一个可以用于测试必须在某个时刻成立的表达式。它可能包含任何布尔表达式，并且可能是动态的。如果在编译时没有定义**`NDEBUG`**宏，每次执行通过此宏的调用时，都会评估表达式。来自[第7.3节](kindle_split_015.html#ch07lev1sec3)的gcd和gcd2函数展示了**`assert`**的典型用法：一个在*每次*执行中都应成立的条件。
- en: '|  |'
  id: totrans-2556
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<assert.h>`'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: '`<assert.h>`'
- en: '|  |'
  id: totrans-2558
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If the condition doesn’t hold, a diagnostic message is printed, and **abort**
    is called. So, none of this should make it through into a production executable.
    From the earlier discussion, we know that the use of **abort** is harmful, in
    general, and also an error message such as
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件不成立，则会打印诊断信息，并调用**abort**。因此，这些内容都不应该进入生产可执行文件。从之前的讨论中，我们知道**abort**的使用通常是有害的，并且错误信息如下
- en: '`Terminal`'
  id: totrans-2560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE162]'
  id: totrans-2561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: is not very helpful for your customers. It *is* helpful during the debugging
    phase, where it can lead you to spots where you make false assumptions about the
    values of variables.
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的客户来说并不很有帮助。在调试阶段，它可以帮助你找到对变量值做出错误假设的地方。
- en: '|  |'
  id: totrans-2563
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.27
  id: totrans-2564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.27
- en: '*Use as many* **`assert`***s as you can to confirm runtime properties.*'
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能多地使用* **`assert`** 来确认运行时属性。'
- en: '|  |'
  id: totrans-2566
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As mentioned, **`NDEBUG`** inhibits the evaluation of the expression and the
    call to **abort**. Please use it to reduce overhead.
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**`NDEBUG`**会抑制表达式的评估和**abort**的调用。请使用它来减少开销。
- en: '|  |'
  id: totrans-2568
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 8.28
  id: totrans-2569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获8.28
- en: '*In production compilations, use* **`NDEBUG`** *to switch off all* **`assert`***.*'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: '*在生产编译中，使用* **`NDEBUG`** *来关闭所有* **`assert`***.*'
- en: '|  |'
  id: totrans-2571
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-2572
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Image segmentation**'
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像分割**'
- en: In addition to the C standard library, there are many other support libraries
    out there that provide very different features. Among those are a lot that do
    image processing of some kind. Try to find a suitable such image-processing library
    that is written in or interfaced to C and that allows you to treat grayscale images
    as two-dimensional matrices of base type **`unsigned char`**.
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 除了C标准库之外，还有许多其他支持库，它们提供了非常不同的功能。其中有很多是某种形式的图像处理库。尝试找到一个合适的此类图像处理库，它是用C编写的或与C接口，并且允许你将灰度图像作为基类型为**`unsigned
    char`**的两维矩阵来处理。
- en: 'The goal of this challenge is to perform a segmentation of such an image: to
    group the pixels (the **`unsigned char`** elements of the matrix) into connected
    regions that are “similar” in some sense or another. Such a segmentation forms
    a partition of the set of pixels, much as we saw in [challenge 4](kindle_split_012.html#ch04sb01).
    Therefore, you should use a Union-Find structure to represent regions, one per
    pixel at the start.'
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战的目标是对这样的图像进行分割：将像素（矩阵的**`unsigned char`**元素）分组到一些“相似”的连接区域中。这种分割形成了一组像素的划分，就像我们在[挑战4](kindle_split_012.html#ch04sb01)中看到的那样。因此，你应该使用并查集结构来表示区域，每个像素一个区域。
- en: Can you implement a statistics function that computes a statistic for all regions?
    This should be another array (the third array in the game) that for each root
    holds the number of pixels and the sum of all values.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否实现一个统计函数，计算所有区域的统计量？这应该是一个数组（游戏中的第三个数组），对于每个根节点，它包含像素的数量和所有值的总和。
- en: 'Can you implement a merge criterion for regions? Test whether the mean values
    of two regions are not too far apart: say, no more than five gray values.'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否实现一个区域合并标准？测试两个区域的平均值是否相差不远：比如说，不超过五个灰度值。
- en: Can you implement a line-by-line merge strategy that, for each pixel on a line
    of the image, tests whether its region should be merged to the left and/or to
    the top?
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否实现一种逐行合并策略，对于图像中的一行上的每个像素，测试其区域是否应该合并到左侧和/或顶部？
- en: 'Can you iterate line by line until there are no more changes: that is, such
    that the resulting regions/sets all test negatively with their respective neighboring
    regions?'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否逐行迭代，直到没有更多变化：也就是说，结果区域/集合与各自的相邻区域都测试为负？
- en: Now that you have a complete function for image segmentation, try it on images
    with assorted subjects and sizes, and also vary your merge criterion with different
    values for the mean distance instead of five.
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个完整的图像分割函数，尝试将其应用于具有不同主题和大小的图像上，并且用不同的平均距离值来改变你的合并标准，而不是使用五个。
- en: '|  |'
  id: totrans-2581
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-2582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The C library is interfaced via a bunch of header files.
  id: totrans-2583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C库通过一系列头文件进行接口。
- en: Mathematical functions are best used via the type-generic macros from `tgmath.h`.
  id: totrans-2584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学函数最好通过`tgmath.h`中的类型通用宏来使用。
- en: Input and output (IO) are interfaced via `stdio.h`. There are functions that
    do IO as text or as raw bytes. Text IO can be direct or structured by formats.
  id: totrans-2585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出（IO）通过`stdio.h`接口。有一些函数可以以文本或原始字节的形式进行IO。文本IO可以是直接的或通过格式化来结构化。
- en: String processing uses functions from `ctype.h` for character classification,
    from `stdlib` for numerical conversion, and from `string.h` for string manipulation.
  id: totrans-2586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串处理使用`ctype.h`中的函数进行字符分类，使用`stdlib`进行数值转换，使用`string.h`进行字符串操作。
- en: Time handling in `time.h` has *calendar time* that is structured for human interpretation,
    and *physical time* that is structured in seconds and nanoseconds.
  id: totrans-2587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.h`中的时间处理有*日历时间*，它是为人类解释而结构化的，以及*物理时间*，它是以秒和纳秒为单位的结构化。'
- en: Standard C only has rudimentary interfaces to describe the execution environment
    of a running program; **getenv** provides access to environment variables, and
    `locale.h` regulates the interface for human languages.
  id: totrans-2588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准C只有基本的接口来描述运行程序的执行环境；**getenv**提供了对环境变量的访问，而`locale.h`调节了人类语言的接口。
