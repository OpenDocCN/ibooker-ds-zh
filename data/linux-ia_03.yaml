- en: 'Chapter 3\. Remote connectivity: Safely accessing networked machines'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章. 远程连接：安全访问网络机器
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Encryption and secure remote connections
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密和安全的远程连接
- en: Linux system process management with systemd
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用systemd进行Linux系统进程管理
- en: Extra secure and convenient password-free SSH access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外安全和方便的无密码SSH访问
- en: Safely copying files between remote locations with SCP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SCP在远程位置之间安全地复制文件
- en: Using remote graphic programs over SSH connections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SSH连接使用远程图形程序
- en: They say that half the fun is getting there. Well, when it comes to working
    in a distributed computing world, not being able to get to your servers and remote
    resources is pretty much a show stopper. Because so much of the workload these
    days is being carried by the kind of virtual machine you saw in the last chapter,
    and because you can’t just walk up to a virtual server, push the power button,
    and log in, you’ll need some other access route. Welcome to the world of the Secure
    Shell (SSH).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说，一半的乐趣在于到达那里。好吧，当谈到在分布式计算世界中工作时，无法访问你的服务器和远程资源几乎是一个拦路虎。由于当今的大部分工作量都是由你在上一章中看到的虚拟机承担的，而且你不能只是走到虚拟服务器前，按下电源按钮，然后登录，你需要其他访问途径。欢迎来到安全壳（SSH）的世界。
- en: 3.1\. The importance of encryption
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 加密的重要性
- en: In the beginning, there was Telnet for login connections over a network at any
    rate. The Telnet protocol was fast and reliable and, in an innocent world made
    up of smaller and simpler networks, perfectly serviceable. Back then, the fact
    that Telnet sessions sent their data packets without encryption wasn’t a big deal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初，无论如何，网络登录连接都是通过Telnet实现的。Telnet协议速度快且可靠，在一个由较小、较简单的网络组成的纯真世界中，它完全能够满足需求。当时，Telnet会话发送数据包不加密的事实并不是什么大问题。
- en: I’ve been given to understand, however, that things have changed a bit over
    the past few decades. This internet thing where all the cool kids play these days
    is a bit bigger than it used to be, and network admins no longer all know each
    other by their first names. Apparently, security has now become the subject of
    some animated discussion. Or, in other words, if you’re using Telnet to transmit
    private data that includes passwords and personal information in plain text over
    insecure networks, then you should assume it’s no longer private. In fact, anyone
    on the network using freely available packet-sniffing software like Wireshark
    can easily read everything you send and receive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我听说，在过去的几十年里，事情已经有所变化。如今所有酷孩子都在玩的这个互联网事物比以前要大得多，网络管理员也不再都互相认识。显然，安全已经成为一些热烈讨论的主题。换句话说，如果你使用Telnet在不受保护的网络中传输包含密码和个人信息的私有数据，那么你应该假设它已经不再私密。事实上，任何使用免费可用的数据包嗅探软件（如Wireshark）的人都可以轻松读取你发送和接收的所有内容。
- en: Because everyone’s regularly moving sensitive data across public networks, what’s
    a poor admin to do? The solution is to encrypt the data being transferred. But
    just what is encryption?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个人都在公共网络上定期传输敏感数据，管理员该怎么办呢？解决方案是加密传输的数据。但加密究竟是什么呢？
- en: To protect the privacy of data even if it falls into the wrong hands, security
    software can use what’s known as an *encryption key*, which is a small file containing
    a random sequence of characters. As shown in [figure 3.1](#ch03fig01), the key
    can be applied as part of an encryption algorithm to convert plain-text, readable
    data into what amounts to total gibberish. At least that’s how it would appear
    before the key is applied through a reverse application of the same algorithm.
    Using the key on the encrypted version of the file converts the gibberish back
    to its original form. As long as you and your trusted friends are the only people
    in possession of the key, no one else should be able to make any sense of the
    data, even if it’s intercepted.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护数据隐私，即使数据落入错误的手中，安全软件可以使用所谓的*加密密钥*，这是一个包含随机字符序列的小文件。如图[3.1](#ch03fig01)所示，该密钥可以作为加密算法的一部分应用，将可读的纯文本数据转换为几乎无法辨认的乱码。至少在应用密钥之前是这样的。在加密文件的版本上使用密钥将乱码转换回原始形式。只要你和你的信任朋友是唯一拥有密钥的人，其他人就不应该能够理解数据，即使它被截获。
- en: Figure 3.1\. A private/public key pair to encrypt and decrypt the contents of
    a plain-text message. This figure illustrates a symmetric encryption design.
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1. 用于加密和解密纯文本消息内容的私有/公开密钥对。此图说明了对称加密设计。
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig01_alt.jpg)'
- en: When you log in to a remote server, you’re doing nothing more than causing data
    packets containing session information to be sent back and forth between two computers.
    The trick of *secure* communications is to quickly encrypt each of those packages
    before it’s transmitted, and then, just as quickly, decrypt them at the other
    end. The SSH network protocol does this so quickly and so invisibly, in fact,
    that someone already used to connecting through Telnet sessions won’t see any
    difference.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你登录到远程服务器时，你做的只是让包含会话信息的数据包在两台计算机之间来回发送。*安全*通信的技巧是在传输之前快速加密每个数据包，然后在另一端快速解密它们。SSH
    网络协议做得如此之快、如此之隐蔽，以至于已经习惯通过 Telnet 会话连接的人不会看到任何区别。
- en: SSH was designed in the 1990s as a simple way for UNIX-like operating systems
    to safely encrypt the data transferred as part of remote logins. The OpenSSH implementation
    of the protocol is now so popular that Microsoft recently made it available natively
    for Windows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 是在 1990 年代设计的一种简单方式，用于 UNIX 类似操作系统中安全地加密远程登录过程中传输的数据。现在，OpenSSH 协议的实现非常流行，以至于微软最近将其原生地提供给
    Windows。
- en: 3.2\. Getting started with OpenSSH
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 开始使用 OpenSSH
- en: In this section you’re going to check to see if OpenSSH is installed and active
    on your machine. Then, if necessary, you’ll install it. Because testing for a
    package’s active status requires understanding how modern Linux distributions
    manage processes, you’ll also take a detour into the world of systemd. When that’s
    all done, you’ll use OpenSSH to open a login session on a remote server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将检查 OpenSSH 是否已安装并激活在你的机器上。然后，如果需要，你将安装它。因为测试包的激活状态需要了解现代 Linux 发行版如何管理进程，你还将进入
    systemd 的世界。所有这些都完成后，你将使用 OpenSSH 在远程服务器上打开登录会话。
- en: If it’s not already installed, running `apt install openssh-server` from an
    Ubuntu or Debian machine will give you all the software you’ll need. But many
    versions of Linux distributions come with at least minimal SSH functionality right
    out of the box. To find what you’ve got under your hood (on Debian/Ubuntu-based
    machines, at least), you can use the package manager, dpkg.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未安装，从 Ubuntu 或 Debian 机器上运行 `apt install openssh-server` 将会为你提供所需的所有软件。但许多
    Linux 发行版的版本默认至少包含最小化的 SSH 功能。为了找出你机器下（至少在基于 Debian/Ubuntu 的机器上）有什么，你可以使用包管理器
    dpkg。
- en: 'The dpkg command-line tool manages and queries software packages that are part
    of the Advanced Package Tool (APT) system. Running `dpkg` with the `-s` flag and
    the name of a package returns the current installed and update status. If the
    package is already installed (as is true for this `gedit` example), the output
    will look something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: dpkg 命令行工具管理并查询属于高级包工具 (APT) 系统的软件包。使用 `-s` 标志和包名称运行 `dpkg` 会返回当前已安装和更新状态。如果包已经安装（如这个
    `gedit` 示例所示），输出将类似于以下内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Sample dpkg -s output for the gedit package**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* gedit 包的 dpkg -s 输出示例**'
- en: '***2* The package status**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包状态**'
- en: '***3* Two of many dependency packages**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 许多依赖包中的两个**'
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In [chapter 2](kindle_split_010.xhtml#ch02), you saw that you can search for
    available packages that aren’t yet installed using `apt search packagename`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](kindle_split_010.xhtml#ch02) 中，你看到可以使用 `apt search packagename` 搜索尚未安装的可用包。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As illustrated by [figure 3.2](#ch03fig02), when you log in to a remote computer,
    your local PC is acting as a client of the remote server, so you’d use the openssh-client
    package. The operating system (OS) on the remote server you’re logging in to,
    however, is acting as a host for the shell session, so it must be running the
    openssh-server package.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 3.2](#ch03fig02) 所示，当你登录到远程计算机时，你的本地 PC 正在充当远程服务器的客户端，因此你会使用 openssh-client
    包。然而，你登录到的远程服务器上的操作系统正在充当 shell 会话的主机，因此它必须运行 openssh-server 包。
- en: Figure 3.2\. Logging in to a remote server through an encrypted SSH connection
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 通过加密的 SSH 连接登录到远程服务器
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig02_alt.jpg)'
- en: You can run `dpkg -s openssh-client` or `dpkg -s openssh-server` to confirm
    that you’ve got the right package on your machine. Because they’re built to host
    remote shell sessions, Linux containers will always have the full suite installed
    by default.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 `dpkg -s openssh-client` 或 `dpkg -s openssh-server` 来确认你的机器上安装了正确的包。因为它们被构建来托管远程
    shell 会话，Linux 容器默认总是安装完整的套件。
- en: The server version also includes all the tools you’ll find in the client package.
    This means that someone working on a machine with the openssh-server package installed
    will also be able to log in via SSH to other servers. Therefore, if the client
    package isn’t already installed on your machine, installing the server package
    will cover you for anything you might need down the line.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器版本还包括客户端包中包含的所有工具。这意味着在安装了 openssh-server 包的机器上工作的某人也将能够通过 SSH 登录到其他服务器。因此，如果客户端包尚未安装到您的机器上，安装服务器包将覆盖您可能需要的任何内容。
- en: 'On the other hand, security best practices teach us to limit access routes
    into our infrastructure to only what’s absolutely necessary. If you don’t think
    you’ll need to log in to your desktop or laptop, then only install openssh-client:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，安全最佳实践教导我们只将进入我们基础设施的访问路径限制在绝对必要的内容。如果您认为您不需要登录到您的台式机或笔记本电脑，那么只需安装 openssh-client：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Just because a package is properly installed doesn’t mean that you’ll be able
    to use it right away. Sometimes the configuration files are set to inactive by
    default. You’ll see plenty of setup configuration examples as you work through
    this book, and you’ll have a look at the OpenSSH configuration files a bit later
    in this chapter. But there’s another common reason a Linux program might not work
    for you—it isn’t running. You can use `systemctl status` to find out whether SSH
    is running on your machine:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然软件包已经正确安装，但这并不意味着您可以立即使用它。有时配置文件默认设置为不活动。您将在阅读本书的过程中看到大量的设置配置示例，您将在本章稍后查看
    OpenSSH 配置文件。但还有另一个常见的理由，Linux 程序可能无法为您工作——它没有运行。您可以使用 `systemctl status` 来找出
    SSH 是否在您的机器上运行：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* SSH is currently active.**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* SSH 目前处于活动状态。**'
- en: '***2* The process ID (PID) assigned to SSH (280 in this example)**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 分配给 SSH 的进程 ID（PID）（在本例中为 280）**'
- en: As you can see from the Active line of the output, everything is fine. If you
    did have to crank it up yourself though, you’d use `systemctl` once again, but
    this time with `start` in place of `status`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中的“Active”行所看到的那样，一切正常。如果您确实需要自己启动它，那么您将再次使用 `systemctl`，但这次用 `start` 代替
    `status`。
- en: 'Bored with your new toy? `systemctl stop` will neatly put it away for you:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对您的新玩具感到无聊？使用 `systemctl stop` 可以整洁地将其收起来：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can force a process (like SSH) to automatically load on system startup
    using `systemctl enable ssh`, or to not load on startup with `systemctl disable
    ssh`. This code snippet enables SSH:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `systemctl enable ssh` 命令强制一个进程（如 SSH）在系统启动时自动加载，或者使用 `systemctl disable
    ssh` 命令使其在启动时不加载。此代码片段启用了 SSH：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That `systemctl` fellow seems nice enough, but you’ve barely had the chance
    to meet him. Right now OpenSSH awaits us, but I’ll explain process management
    in greater depth at the end of this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl` 这个家伙看起来很友好，但你几乎还没有机会认识他。现在 OpenSSH 正在等待我们，但我会在本章末尾更深入地解释进程管理。'
- en: 3.3\. Logging in to a remote server with SSH
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 使用 SSH 登录远程服务器
- en: Starting up remote sessions is a lot simpler than you might think. Make sure
    that you’ve got a second computer running somewhere with openssh-server loaded
    and to which you’ve network access. You could, for instance, fire up an LXC container
    the way you did in the previous chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 启动远程会话比你想象的要简单得多。确保你有一台运行着 openssh-server 并可以网络访问的第二台计算机。例如，你可以像上一章那样启动一个 LXC
    容器。
- en: 'Now find that computer’s IP address. If you’re using an LXC container, it can
    give you everything you’re after via the `lxc-ls --fancy` command. Here’s an example
    showing one container called test that’s not running, and a second called base
    that is running, using the IP address 10.0.3.144:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在找到该计算机的 IP 地址。如果您使用的是 LXC 容器，它可以通过 `lxc-ls --fancy` 命令提供您所需的一切。以下是一个示例，显示一个名为
    test 的未运行容器和一个名为 base 的运行容器，使用 IP 地址 10.0.3.144：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Command to list LXC containers and their status details**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 列出 LXC 容器和其状态详情的命令**'
- en: '***2* Column headers**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 列表头**'
- en: 'Alternatively, if you happen to be logged in to your server, you can get its
    public IP address using `ip addr`, which will spit out a rather nasty mess of
    characters listing all the local network interfaces. It looks something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您恰好登录到您的服务器，您可以使用 `ip addr` 命令获取其公网 IP 地址，这将输出一个相当糟糕的字符杂乱列表，列出所有本地网络接口。它看起来像这样：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The public network interface (in this example, eth0)**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 公共网络接口（在本例中，为 eth0）**'
- en: '***2* The inet line showing the interface’s public IP address**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示接口公网 IP 地址的 inet 行**'
- en: In this case, the inet line numbered 8 in the interface is our primary interest.
    It shows an IP address of 10.0.3.144.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，接口中编号为8的inet行是我们主要关注的。它显示了一个IP地址为10.0.3.144。
- en: 'With that information in hand, to connect, you’ll need to run `ssh` with the
    name of the account on the server you’ll use to log in and the IP address. If
    this is the first time you’ve accessed the server from your PC, then you’ll be
    asked to confirm the authenticity of the information your server’s OpenSSH program
    sent back by typing `yes`. (That’s *yes* by the way, not just the letter *y*.)
    Finally, you’ll enter the password of the server account you specified (ubuntu,
    in my case), and you’re in:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到这些信息后，为了连接，你需要使用`ssh`命令，并指定你将用于登录的服务器上的账户名称和IP地址。如果你是第一次从你的PC访问服务器，那么你将需要通过输入`yes`来确认服务器OpenSSH程序发送回的信息的真实性。（顺便说一句，是`yes`，而不是仅仅字母`y`。）最后，你将输入你指定的服务器账户的密码（在我的例子中是`ubuntu`），然后你就可以登录了：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Request for confirmation**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. 确认请求***'
- en: '***2* Enter the password for your account on the remote server.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2. 输入你在远程服务器上的账户密码。***'
- en: 'Didn’t work out the way you expected? Looks like you’re in for a terrific learning
    experience! The most common problem you’re likely to encounter involves network
    connectivity, so why not sneak a peek at [chapter 14](kindle_split_022.xhtml#ch14)?
    For now, though, use `ping` to test whether your two computers can see and speak
    to each other. Assuming you’re running this from your local PC and testing its
    connectivity with a remote server using IP 10.0.3.144, a successful ping will
    look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 没有达到你预期的效果？看起来你将有一个极好的学习体验！你很可能会遇到的最常见问题是网络连接问题，所以为什么不偷偷看看[第14章](kindle_split_022.xhtml#ch14)呢？不过，现在，使用`ping`来测试你的两台计算机是否能够相互看到并通信。假设你从你的本地PC运行这个命令，并使用IP
    10.0.3.144测试与远程服务器的连接性，成功的ping将看起来像这样：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Record of a successful response to a ping request**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. 对ping请求成功响应的记录***'
- en: '***2* You can stop the ping requests and regain control of the command line
    by pressing Ctrl-c.**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2. 你可以通过按Ctrl-c来停止ping请求并重新控制命令行。***'
- en: 'And failure will look like the following. To illustrate, I pinged an unused
    IP address:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 失败将看起来像以下这样。为了说明，我ping了一个未使用的IP地址：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Record of an unsuccessful response to a ping request**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. 对ping请求未成功响应的记录***'
- en: 3.4\. Password-free SSH access
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 无密码SSH访问
- en: There’s something a bit depressing about passwords. They’re almost never used
    properly. They’re either too short and/or easy to guess, or just overused for
    multiple accounts. And people seem to forget them with alarming frequency. If
    the only thing protecting your data is a password, then the odds are that it’s
    not all that well protected.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于密码，有些令人沮丧的事情。它们几乎从未被正确使用。要么太短，要么容易被猜到，或者只是因为多个账户而过度使用。而且人们似乎会以惊人的频率忘记它们。如果保护你的数据唯一的东西是密码，那么它可能并没有得到很好的保护。
- en: 'That’s why the industry players with the most credibility when it comes to
    security—like Amazon Web Services (AWS)—will, by default, disable password authentication
    altogether on their cloud instances. If you’re concerned about the risk of unauthorized
    access to your servers, you might want to consider following their lead. Here’s
    what that setting looks like in the /etc/ssh/sshd_config file on an Amazon Linux
    instance on the EC2 service:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在安全性方面最具信誉的行业参与者——如亚马逊网络服务（AWS）——默认情况下会在他们的云实例上完全禁用密码认证。如果你担心未经授权访问你的服务器，你可能想考虑效仿他们的做法。以下是在EC2服务上的Amazon
    Linux实例的`/etc/ssh/sshd_config`文件中该设置的示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**OpenSSH configuration files**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenSSH配置文件**'
- en: Like anything else in Linux, the way OpenSSH behaves on a machine largely depends
    on settings in its plain-text configuration files. And, like most other programs,
    those configuration files can be found in the /etc/ directory hierarchy. In this
    case, they’re in /etc/ssh/.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Linux中的任何其他东西一样，OpenSSH在机器上的行为很大程度上取决于其纯文本配置文件中的设置。而且，就像大多数其他程序一样，这些配置文件可以在`/etc`目录层次结构中找到。在这种情况下，它们位于`/etc/ssh/`目录中。
- en: The configuration file whose settings control how *remote clients* will be able
    to log in to your machine is /etc/ssh/sshd_config. The /etc/ssh/ssh_config file,
    on the other hand, controls the way users on this machine will log in to *remote
    hosts* as a client. Besides limiting how people are allowed to log in to your
    systems through SSH, settings in these files can be used to control all kinds
    of behavior including, as you’ll see a bit later in this chapter, whether you
    permit remote GUI access to local programs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 控制远程客户端如何登录到您的机器的配置文件是 /etc/ssh/sshd_config。另一方面，/etc/ssh/ssh_config 文件控制本机上的用户作为客户端登录到远程主机的方式。除了限制人们通过
    SSH 登录到您的系统的方式外，这些文件中的设置还可以用来控制各种行为，包括您将在本章稍后看到，是否允许远程 GUI 访问本地程序。
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The alternative to SSH password authentication is to create a special key pair
    and then copy the public half of the pair to the remote host, which is the computer
    where you eventually want to log in. With encryption keys available at both ends
    of the connection, OpenSSH running on the host will now have a way to know who
    you are without having to demand a password. That’s not to say passwords have
    no positive role to play in infrastructure security. In fact, you’ll soon see
    how. Ideally, you should create what is called a *passphrase* and use it to authenticate
    yourself locally before using your key pair.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 密码认证的替代方法是创建一个特殊的密钥对，然后将密钥对的一半（公钥）复制到远程主机，即您最终想要登录的计算机。在连接的两端都有加密密钥的情况下，运行在主机上的
    OpenSSH 现在将有一种方式知道你是谁，而无需要求密码。但这并不是说密码在基础设施安全中没有积极作用。实际上，您很快就会看到。理想情况下，您应该创建一个所谓的密码短语，并在使用密钥对之前用它来本地验证自己。
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A *passphrase*, like a password, is a secret text string that you’ve chosen.
    But a passphrase will often also include spaces and consist of a sequence of real
    words. A password like 3Kjsi&*cn@PO is pretty good, but a passphrase like “fully
    tired cares mound” might be even better because of its length and the fact that
    it’s relatively easy to remember.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 密码短语，就像密码一样，是你选择的一个秘密文本字符串。但密码短语通常会包含空格，并由一系列真实单词组成。像 3Kjsi&*cn@PO 这样的密码相当不错，但像“fully
    tired cares mound”这样的密码短语可能更好，因为它长度更长，而且相对容易记住。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.4.1\. Generating a new key pair
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 生成新的密钥对
- en: There’s definitely more than one way to skin this cat. But since all good system
    administrators are, by training, lazy, I’ll go with the approach that requires
    the fewest keystrokes. An unintended but happy consequence of this choice is that
    I’ll get to introduce you to a much more sophisticated use of the pipe character
    (|).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一定有不止一种方法可以解决这个问题。但既然所有优秀的系统管理员在训练中都是懒惰的，我会选择需要最少按键的方法。这个选择的一个意外但令人高兴的结果是，我将有机会向您介绍管道字符（|）的更复杂用法。
- en: 'You’ll begin by creating a new public/private key pair on the client computer
    using the ssh-keygen program. You’ll be asked for a key pair name, but, unless
    you’ve already got a pair called id_rsa, I’d just press Enter and stick with the
    default. As you saw previously, it’s usually better to create a passphrase when
    prompted, especially if you share your computer with others. Remember, if you
    do opt to add a passphrase, you’ll be prompted to enter it each time you use the
    key. Here’s how all that will go:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先使用 ssh-keygen 程序在客户端计算机上创建一个新的公钥/私钥对。您将被要求输入密钥对名称，但除非您已经有一个名为 id_rsa 的密钥对，否则我会按
    Enter 键并保留默认设置。正如您之前所看到的，在提示时创建密码短语通常更好，尤其是如果您与他人共享计算机。记住，如果您选择添加密码短语，每次使用密钥时都会提示您输入它。下面是整个过程：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Displays the name of my local client, base**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示我的本地客户端名称，base**'
- en: '***2* The location and name of your new key pair**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 新密钥对的位置和名称**'
- en: '***3* Helps to prevent man-in-the-middle attacks**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 有助于防止中间人攻击**'
- en: '***4* The key’s randomart, a visual cue, also helps to prevent man-in-the-middle
    attacks.**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 密钥的随机艺术（randomart），一种视觉提示，也有助于防止中间人攻击**。'
- en: 'Well, now you’re the proud owner of a shiny new RSA encryption-based key pair.
    Go ahead and use `ls -l` to display a long list of the contents of your .ssh/
    directory. Notice how there are two files with the name id_rsa, but only one of
    them has the .pub filename extension. That file is the public half of the pair,
    and it’s the file you’ll eventually copy to the remote machine that will be your
    session host:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在你已经是拥有一对闪亮的新RSA加密密钥的所有者了。继续使用`ls -l`来显示.ssh/目录的长列表。注意，有两个文件名为id_rsa，但只有一个具有.pub文件扩展名。这个文件是这对密钥的公共部分，是你最终需要复制到将成为会话主机的远程机器上的文件：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Which algorithm should you use?**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**你应该使用哪种算法？**'
- en: 'Besides RSA (an acronym built from the last names of the three researchers
    who first described it: Ron Rivest, Adi Shamir, and Leonard Adleman), OpenSSH
    also supports the ECDSA and ED25519 signature algorithms. You’ll find some rather
    obscure technical differences between the default RSA and both ECDSA and ED25519,
    which have the advantage of being based on elliptic curves. But all are considered
    reasonably secure. One thing to keep in mind with ECDSA and ED25519 is that they
    might not yet be fully supported with some older implementations.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了RSA（由首先描述它的三位研究者的姓氏缩写而成：Ron Rivest, Adi Shamir, 和 Leonard Adleman）之外，OpenSSH还支持ECDSA和ED25519签名算法。你会在默认的RSA和ECDSA以及ED25519之间发现一些相当晦涩的技术差异，它们的优势在于基于椭圆曲线。但所有这些都被认为是相当安全的。关于ECDSA和ED25519需要注意的一点是，它们可能还没有被一些较旧的实现完全支持。
- en: You should no longer assume that DSA is supported by all implementations of
    OpenSSH. Due to suspicions surrounding its origins, DSA is widely avoided in any
    case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应再假设所有OpenSSH的实现都支持DSA。由于对其起源的怀疑，DSA在任何情况下都被广泛避免。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.4.2\. Copying the public key over a network
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 通过网络复制公钥
- en: 'Passwordless SSH access doesn’t work until you copy the public key over to
    the host. As you can see in [figure 3.3](#ch03fig03), the key pair is generally
    created on a client computer. That’s because the private key should be just that:
    private. As much as possible, you want to avoid moving it around unnecessarily
    and exposing it to unfriendly eyes.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无密码SSH访问直到你将公钥复制到主机上才会生效。正如你在[图3.3](#ch03fig03)中看到的，密钥对通常是在客户端计算机上创建的。这是因为私钥应该是这样的：私有的。尽可能避免不必要地移动它，并使其暴露在不友好的目光之下。
- en: Figure 3.3\. The public key of a key pair must be moved to the host PC, while
    the private key remains on the client.
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 密钥对的公钥必须移动到主机PC上，而私钥则保持在客户端。
- en: '![](Images/03fig03_alt.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig03_alt.jpg)'
- en: Once created, you can move the public key to the file .ssh/authorized_keys on
    the host computer. That way the OpenSSH software running on the host will be able
    to verify the authenticity of a cryptographic message created by the private key
    on the client. Once the message is verified, the SSH session will be allowed to
    begin.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，你可以将公钥移动到主机计算机上的.ssh/authorized_keys文件中。这样，运行在主机上的OpenSSH软件将能够验证由客户端上的私钥创建的加密消息的真实性。一旦消息被验证，SSH会话将被允许开始。
- en: The first thing you’ll need to do is figure out which user account on the host
    you’ll be logging in to. In my case, it’ll be the account called ubuntu. The key
    needs to be copied to a directory called .ssh/, which is beneath /home/ubuntu/.
    In case it’s not there already, you should create it now using `mkdir`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要做的是确定你将登录到主机上的哪个用户账户。在我的情况下，它将是名为ubuntu的账户。密钥需要复制到名为.ssh/的目录中，该目录位于/home/ubuntu/下。如果它还没有在那里，你应该现在使用`mkdir`来创建它。
- en: 'First, though, I’ll introduce you to a cool shortcut: to run a single command,
    you don’t need to actually open a full SSH session on a remote host. Instead,
    you can append your command to the regular `ssh` syntax like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将向你介绍一个酷的快捷方式：要运行单个命令，你实际上不需要在远程主机上打开完整的SSH会话。相反，你可以将你的命令附加到常规的`ssh`语法中，如下所示：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You’ll still need to provide the password to the remote host. But once that’s
    done, you’ll have a .ssh/ directory beneath /home/ubuntu/ on the host.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要为远程主机提供密码。但一旦完成，你将在主机上的/home/ubuntu/目录下拥有一个.ssh/目录。
- en: 'To make it easier for you to read, I split this next command into three lines
    using the backslash character (\), which tells Bash to read the next line as part
    of the current line. Make sure there are no characters (including a space) after
    the backslash. That’s guaranteed to cause you grief:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更容易阅读，我使用反斜杠字符（\）将下一个命令拆分为三行，这告诉 Bash 将下一行作为当前行的一部分读取。确保反斜杠后面没有字符（包括空格）。这肯定会给你带来麻烦：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* The cat command reads the contents of the id_rsa.pub file.**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* cat 命令读取 id_rsa.pub 文件的内容。**'
- en: '***2* The text is piped to the ssh command.**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 文本被传递到 ssh 命令中。**'
- en: '***3* The text is appended to a file called authorized_keys.**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 文本被追加到名为 authorized_keys 的文件中。**'
- en: That single, multi line command will use `cat` to read all the text in the id_rsa.pub
    file and store it in memory. It will then pipe that text via an SSH logon on the
    remote host computer. Finally, it reads the text once again, this time on the
    host computer, and appends it to a file called authorized_keys. If the file doesn’t
    yet exist, `>>` (the append tool) creates it. If a file with that name already
    exists, the text will be added to any content in the file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那个单一的多行命令将使用 `cat` 来读取 id_rsa.pub 文件中的所有文本，并将其存储在内存中。然后，它将通过远程主机计算机上的 SSH 登录将文本传递过去。最后，它再次读取文本，这次是在主机计算机上，并将其追加到名为
    authorized_keys 的文件中。如果该文件尚不存在，`>>`（追加工具）将创建它。如果已存在同名文件，文本将被添加到文件中的任何内容。
- en: 'That’s it. You’re ready to roll. This time, when you run the same old `ssh`
    command, there’s no need to enter a password:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。你已经准备好了。这次，当你运行相同的旧 `ssh` 命令时，不需要输入密码：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* The login proceeds without a password request.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 登录过程不需要密码请求。**'
- en: '***2* The new command prompt indicates that you’re on a different computer.**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 新的命令提示符表明你在一台不同的计算机上。**'
- en: 3.4.3\. Working with multiple encryption keys
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3\. 使用多个加密密钥
- en: 'There will be cases (like having to log in to a virtual machine instance running
    on Amazon’s EC2 service) where you’ll need to specify which key pair to use for
    a given session. This will definitely happen once you start building a collection
    of keys used for different hosts. To tell OpenSSH which key you’re after, you
    add the `-i` flag, followed by the full name and location of the private key file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下（比如需要登录到在亚马逊 EC2 服务上运行的虚拟机实例），你需要指定为给定会话使用哪个密钥对。一旦你开始收集用于不同主机的密钥，这肯定会发生。为了告诉
    OpenSSH 你想要哪个密钥，你添加 `-i` 标志，后跟私钥文件的完整名称和位置：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the .pem file extension in that example? That means the key is saved
    with a format that’s commonly used to access all kinds of VMs, including Amazon
    EC2 instances.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那个例子中的 .pem 文件扩展名吗？这意味着密钥是以一种常用于访问各种虚拟机（包括亚马逊 EC2 实例）的格式保存的。
- en: 3.5\. Safely copying files with SCP
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 使用 SCP 安全地复制文件
- en: I’m sure you remember how the `cp` command copies files and directories from
    place to place within a file system. Well, in theory at least, there’s no reason
    why that couldn’t work just as well for copying files across a network. Except
    that it would be stark raving bonkers—the file contents would be exposed to anyone
    else who happened to be hanging around the network that day, or anyone who happened
    to be browsing through network log data some time later.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信你记得 `cp` 命令是如何在文件系统中从一个地方复制文件和目录到另一个地方的。好吧，至少在理论上，没有理由说这不能同样适用于跨网络复制文件。除非那将是完全疯狂的——文件内容将暴露给那天偶然在网络周围的人，或者任何后来偶然浏览网络日志数据的人。
- en: 'Forget that idea, unless you add an *s* for *secure* in front of that `cp`
    command. The SCP program copies files of any sort hither and yon using the SSH
    protocol for file transfer, relying on all the same keys, passwords, and passphrases.
    Assuming that you knew there was already a .ssh/ directory on the remote host
    you worked with earlier, here’s how you could have transferred the public key
    (id_rsa.pub) to the remote host, renaming it authorized_keys:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 忘掉那个想法，除非你在那个 `cp` 命令前加上一个 *s* 表示 *secure*。SCP 程序使用 SSH 协议进行文件传输，依靠所有相同的密钥、密码和口令短语，来复制各种类型的文件。假设你知道你之前工作的远程主机上已经有一个
    .ssh/ 目录，以下是你可以如何将公钥（id_rsa.pub）传输到远程主机，并将其重命名为 authorized_keys：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If there already was an authorized_keys file in that directory, this operation
    would overwrite it, destroying any existing contents. And, you can only copy or
    save files if the user accounts you’re using have appropriate permissions. Therefore,
    don’t try saving a file to, say, the /etc/ directory on a remote machine if your
    user doesn’t have root privileges. Before you ask, logging in to an SSH session
    as the root user is generally a big security no-no.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在那个目录中已经存在一个authorized_keys文件，这个操作将会覆盖它，破坏任何现有的内容。此外，你只能复制或保存文件，如果使用的用户账户具有适当的权限。因此，如果你的用户没有root权限，不要尝试将文件保存到远程机器上的，例如，/etc/目录。在你问之前，以root用户登录SSH会话通常是一个很大的安全禁忌。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can, by the way, copy remote files to your local machine. This example
    copies a file from an AWS EC2 instance (represented by a fictitious IP address)
    to the specified local directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你顺便可以把远程文件复制到你的本地机器上。以下示例展示了如何从一个AWS EC2实例（用虚构的IP地址表示）复制文件到指定的本地目录：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Saves the file to a directory location relative to the current work directory**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将文件保存到相对于当前工作目录的目录位置**'
- en: 'The commands you’ve used up to this point have illustrated some important tools.
    But I should mention that there’s a third (and official) way to safely copy your
    key over to a remote host—the purpose-built program called ssh-copy-id:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止使用的命令已经展示了几个重要的工具。但我应该提到，还有第三种（也是官方的）安全地将你的密钥复制到远程主机的方法——专门为此目的编写的程序叫做ssh-copy-id：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Automatically copies the public key to the appropriate location on the
    remote host**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 自动将公钥复制到远程主机上的适当位置**'
- en: The nice thing about SSH sessions is that, unburdened by layers of GUI stuff,
    they’re fast and efficient. But that can be a problem if the program you need
    to run on the remote host is of the graphic persuasion. The next section solves
    that problem for you.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SSH会话的好处是，不受GUI层级的负担，它们速度快且效率高。但如果需要在远程主机上运行的程序是图形化的，这可能会成为一个问题。下一节将为你解决这个问题。
- en: 3.6\. Using remote graphic programs over SSH connections
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6. 使用SSH连接远程图形程序
- en: Suppose you’re trying to support a user in a remote location who’s reporting
    trouble with a piece of desktop software like LibreOffice. If you feel that being
    able to launch and run the program could help diagnose and solve the problem,
    then it can be done using a graphic session (with the Linux X window manager)
    over SSH.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在尝试支持一个在远程位置的用户新报告了一个桌面软件（如LibreOffice）的问题。如果你觉得能够启动并运行程序有助于诊断和解决问题，那么可以使用图形会话（通过Linux
    X窗口管理器）在SSH上完成。
- en: Having said that, don’t expect miracles. Running `ssh` with the `-X` flag, using
    what’s called *X11 forwarding*, will allow you to load a host machine-based program
    in the desktop of your client. Depending on a number of factors, including the
    quality of your network connection, your results may not meet your expectations.
    This is especially true of resource-heavy programs like LibreOffice. Nevertheless,
    it’s always worth a try. Suffering through a little low bandwidth might still
    beat a two-hour drive to a client’s office.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，不要期望出现奇迹。使用带有`-X`标志的`ssh`，使用所谓的*X11转发*，将允许你在客户端的桌面上加载基于主机机器的程序。根据许多因素，包括你的网络连接质量，你的结果可能不会达到你的期望。这对于资源密集型程序（如LibreOffice）尤其如此。尽管如此，它总是值得一试。忍受一点低带宽的痛苦可能仍然比开车两小时去客户办公室要好。
- en: 'One more thing: don’t try this on a server. In most cases, the OS version installed
    on a server or VM (like an LXC or a Docker container) comes with little or no
    graphic functionality. If you absolutely must, you can install the desktop packages
    to upgrade it. On an Ubuntu machine, it would look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：不要在服务器上尝试这个。在大多数情况下，服务器或虚拟机（如LXC或Docker容器）上安装的操作系统版本带有很少或没有图形功能。如果你绝对必须这样做，你可以安装桌面包来升级它。在Ubuntu机器上，它看起来像这样：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With all of the disclaimers out of the way, I’d say it’s time to see how this
    actually works. First off, open the sshd_config file on the host machine (the
    one whose program you want to run). You’ll need to make sure that the X11Forwarding
    line has the value `yes` (although, for security considerations, it’s probably
    not a good idea to leave it that way any longer than necessary):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有免责声明都讲完之后，我认为是时候看看这到底是如何工作的了。首先，打开主机机器上的sshd_config文件（你想要运行程序的那个机器）。你需要确保X11Forwarding行具有值`yes`（尽管，出于安全考虑，可能没有必要让它保持这种方式太长时间）：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Edit the line to look exactly like this.**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将行编辑成这个样子。**'
- en: 'There’s a similar line in the ssh_config file on the client machine that will
    also need to be set correctly:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端机器上的ssh_config文件中也有类似的行，也需要正确设置：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Edit the line to look exactly like this.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 修改这一行，使其看起来完全像这样。**'
- en: 'Because you’ve edited the configuration files, you’ll need to restart SSH on
    both machines to make sure that your changes are live:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你编辑了配置文件，你需要在两台机器上重新启动SSH以确保你的更改生效：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And you’re ready to go. To start a session that’s graphic-enabled, add the
    `-X` flag to your `ssh` command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以开始了。要启动一个图形化的会话，将`-X`标志添加到你的`ssh`命令中：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You’ll see the regular command prompt, but you’ll now be able to run a command
    that will launch a graphic program. Try something small. This should work on an
    Ubuntu system:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到常规的命令提示符，但现在你可以运行一个命令来启动一个图形程序。尝试做一些小事情。这应该在Ubuntu系统上工作：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Amazing! You’re successfully running a remote program from a window on your
    local desktop.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你成功地在本地桌面的窗口中运行了一个远程程序。
- en: OpenSSH brings a great deal more value to the table than the core features you’ve
    already seen. Once you’ve got a working SSH connection, there are all kinds of
    tricks you can pull off. Try mounting a local file system or directory on a remote
    machine, allowing remote users to seamlessly access your files. Or, through the
    magic of SSH tunneling, use port forwarding to permit the secure, private use
    of remote HTTP services.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH比你已经看到的核心理念提供了更多的价值。一旦你建立了SSH连接，你就可以施展各种技巧。尝试在远程机器上挂载本地文件系统或目录，允许远程用户无缝访问你的文件。或者，通过SSH隧道技术的魔力，使用端口转发来允许远程HTTP服务的安全、私有使用。
- en: 3.7\. Linux process management
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7\. Linux进程管理
- en: As promised, now I’m going to revisit Linux process management so you can properly
    understand how programs like OpenSSH are handled. Knowing how these things work
    can make general administration and troubleshooting much more effective in the
    long run. But if you don’t feel inspired to dive into such an involved topic right
    now, you can safely skip the rest of this chapter. You should have no problem
    following along with the rest of the book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，现在我将重新审视Linux进程管理，这样你就可以正确理解像OpenSSH这样的程序是如何处理的。了解这些是如何工作的可以使长期的一般管理和故障排除更加有效。但如果你现在不想深入研究这样一个复杂的话题，你可以安全地跳过本章的其余部分。你应该没有问题跟随本书的其余部分。
- en: Just what is systemctl, and what’s it actually doing? To properly answer those
    questions, you’ll have to think for a bit about how Linux manages system processes
    in general. And because it’s always nice to meet new friends, you’ll also learn
    about some process-tracking tools to make understanding the way things work easier.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: systemctl究竟是什么，它实际上在做什么？要正确回答这些问题，你需要稍微思考一下Linux是如何管理系统进程的。而且，因为结识新朋友总是很愉快，你还将了解一些进程跟踪工具，使理解事物的工作方式更加容易。
- en: '*Software*, as I’m sure you already know, is programming code containing instructions
    to control computer hardware on behalf of human users. A *process* is an instance
    of a running software program. An *operating system* is a tool for organizing
    and managing those instances/processes to effectively use a computer’s hardware
    resources.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件*，正如你肯定已经知道的，是包含控制计算机硬件指令的编程代码，代表人类用户。*进程*是运行软件程序的一个实例。*操作系统*是组织和管理工作这些实例/进程的工具，以有效地使用计算机的硬件资源。'
- en: Organizing and managing processes for a complex multiprocess, multiuser operating
    environment is no simple task. To make it work, you’ll need some kind of traffic
    cop to tightly control the many moving parts ([figure 3.4](#ch03fig04)). Let me
    introduce you to systemctl.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的、多进程、多用户的操作环境中组织和管理工作并不简单。为了使其工作，你需要某种交通警察来紧密控制许多移动部件（[图3.4](#ch03fig04)）。让我向你介绍systemctl。
- en: Figure 3.4\. The availability and responsiveness of many system services are
    managed by systemd’s systemctl process manager.
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 许多系统服务的可用性和响应性由systemd的systemctl进程管理器管理。
- en: '![](Images/03fig04_alt.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4](Images/03fig04_alt.jpg)'
- en: 3.7.1\. Viewing processes with the ps command
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.1\. 使用ps命令查看进程
- en: 'Let’s pull out an electron microscope and see if we can’t spot a process in
    its natural habitat. Type the following command into a terminal. It will do nothing
    (`sleep`) in the background (`&`) for 10 seconds and then stop. While it’s running,
    though, type `ps`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿出一个电子显微镜，看看我们是否能在其自然栖息地中找到一个进程。在终端中输入以下命令。它将在后台（`sleep`）运行10秒钟然后停止。然而，当它在运行时，输入`ps`：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* The PID of the command running in the background**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 背景运行命令的 PID***'
- en: '***2* The sleep process launched by the original comman**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 由原始命令启动的 sleep 进程***'
- en: '***3* The ps command to list running processes**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 列出运行进程的 ps 命令***'
- en: 'What you’ll see is a record of the two running processes spawned by that command,
    along with their PIDs: 19829 and 19832, in my case. If you run `ps` once again
    after waiting 10 seconds, you’ll see those two processes are no longer running.
    You should also see a report of the successful completion of the `sleep` command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到由该命令产生的两个正在运行进程的记录，以及它们的 PID：在我的例子中是 19829 和 19832。如果你等待 10 秒后再次运行 `ps`
    命令，你会看到这两个进程不再运行。你也应该看到 `sleep` 命令成功完成的报告：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Normally, if you were to type just `ps` and run it, you’d probably get only
    two results. The first, a process called *bash* that represents the Bash command
    interpreter being used by your current shell session, and the most recent command
    (which, of course, was `ps`). But by looking at the PID assigned to bash (7447,
    in the following example), you know there are lots and lots of other processes
    already hard at work somewhere on your system. These will have been spawned by
    parent shells going all the way back to the init process itself:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你只输入 `ps` 并运行它，你可能会只得到两个结果。第一个是一个名为 *bash* 的进程，代表你的当前 shell 会话使用的 Bash
    命令解释器，以及最近的命令（当然是 `ps`）。但通过查看分配给 bash 的 PID（以下示例中的 7447），你知道在你的系统上已经有成千上万的进程正在努力工作。这些进程是由从
    init 进程本身回溯的所有父 shell 生成的：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On an Ubuntu machine, the first process to wake up and get everything else
    going when a Linux computer boots is called *init*. As you’ll soon discover, that
    name can be misleading, which is why the first process has a different name on
    CentOS. You can see for yourself that init is first by running the following `ps`
    command exactly the way it’s printed here. I’ll explain the details in just a
    minute:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 机器上，当 Linux 计算机启动时，第一个唤醒并启动其他所有进程的进程被称为 *init*。很快你就会发现，这个名字可能会误导，这就是为什么在
    CentOS 上第一个进程有不同的名字。你可以通过运行以下 `ps` 命令（就像这里打印的那样）亲自看到 init 是第一个进程。我将在一分钟内解释细节：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* The file responsible for process 1**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 负责进程 1 的文件***'
- en: The rightmost column of the output (`/sbin/init` on the first line) represents
    the location and name of the file behind the process itself. In this case, it’s
    a file called init that lives in the /sbin/ directory. The leftmost column on
    this first line contains the word `root` and tells you that the owner of this
    process is the root user. The only other piece of information that is of interest
    right now is the number 1, which is the PID of the init process. The only way
    you’re going to get PID 1 is by getting there before anyone else.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最右边一列（第一行显示 `/sbin/init`）表示进程背后的文件的位置和名称。在这种情况下，它是一个位于 `/sbin/` 目录下的名为 init
    的文件。这一行的最左边一列包含单词 `root`，告诉你这个进程的所有者是 root 用户。目前唯一其他值得关注的信息是数字 1，这是 init 进程的 PID。你获得
    PID 1 的唯一方法是在其他人之前到达那里。
- en: Before moving on, it’s worth spending a bit more time with `ps`. As you’ve seen,
    `ps` displays information about active processes. It’s often important to have
    access to process-related information so you can properly plan and troubleshoot
    system behavior. You can expect to use `ps` early and often.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，花更多的时间与 `ps` 命令打交道是值得的。正如你所看到的，`ps` 命令显示有关活动进程的信息。通常，访问与进程相关的信息对于正确规划和排除系统行为故障非常重要。你可以预期会经常且早期使用
    `ps` 命令。
- en: Adding the `-e` argument to `ps` as you did previously returns not only the
    processes running in your current child shell, but all the processes from all
    parent shells right back up to init.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `-e` 参数添加到 `ps` 命令中，就像你之前做的那样，不仅会返回你当前子shell中正在运行的所有进程，还会返回从所有父shell回溯到 init
    的所有进程。
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A *parent shell* is a shell environment from within which new (child) shells
    can subsequently be launched and through which programs run. You can think of
    your GUI desktop session as a shell, and the terminal you open to get a command
    line as its child. The top-level shell (the grandparent?) is the one that’s run
    first when Linux boots.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*父shell* 是一个可以从中启动新的（子）shell并通过它运行程序的环境。你可以把你的 GUI 桌面会话看作是一个 shell，你打开以获取命令行的终端是其子
    shell。顶级 shell（外祖父？）是在 Linux 启动时首先运行的 shell。'
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you want to visualize parent and child shells/processes, you can use the
    `pstree` command (adding the `-p` argument to display the PIDs for each process).
    Note how the first process (assigned PID 1) is systemd. On older versions of Linux
    (Ubuntu 14.04 and earlier, for instance), this would have been called init instead:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想可视化父shell/进程和子shell/进程，可以使用`pstree`命令（添加`-p`参数以显示每个进程的PID）。注意第一个进程（分配PID
    1）是systemd。在较旧的Linux版本（例如Ubuntu 14.04及之前）中，这将被称为init：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* CentOS users might need to install the psmisc package to run pstree.**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* CentOS用户可能需要安装psmisc包才能运行pstree。**'
- en: '***2* systemd, the top-level parent process**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* systemd，顶级父进程**'
- en: Go ahead and try all these commands on your machine. Even on a quiet system,
    you’ll probably see dozens of processes; a busy desktop PC or server can easily
    have hundreds or even thousands.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上尝试所有这些命令。即使在安静的系统上，您也可能看到成百上千的进程；繁忙的桌面PC或服务器可以轻松地有数百甚至数千个。
- en: 3.7.2\. Working with systemd
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.2\. 与systemd一起工作
- en: 'There’s something interesting about that /sbin/init file you just saw: `file`
    is a venerable UNIX program that gives you insider information about a file. If
    you run `file` with `/sbin/init` as its argument, you’ll see that the init file
    is not actually a program, but a *symbolic link* to a program called systemd.
    We’ll talk more about symbolic links in [chapter 12](kindle_split_020.xhtml#ch12),
    but here’s where you get to meet systemd:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚才看到的那个/sbin/init文件有些有趣：`file`是一个古老的UNIX程序，它提供了关于文件的内幕信息。如果您用`/sbin/init`作为参数运行`file`，您会看到init文件实际上不是一个程序，而是指向名为systemd的程序的一个符号链接。我们将在[第12章](kindle_split_020.xhtml#ch12)中更详细地讨论符号链接，但在这里您将有机会认识systemd：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It took years of fragmentation and some vigorous political infighting, but
    nearly all Linux distributions now use the same process manager: systemd. It’s
    a drop-in replacement for a process called *init*, which has long been the very
    first process started during the boot process of all UNIX-based operating systems.
    By *drop-in replacement*, I mean that, even if the way it gets things done can
    be quite different, to the casual observer, systemd functions like init always
    did. That’s why the /sbin/init file is now nothing more than a link to the systemd
    program.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的碎片化和一些激烈的政斗，现在几乎所有Linux发行版都使用相同的进程管理器：systemd。它是名为*init*的进程的替代品，这个进程长期以来一直是所有基于UNIX操作系统的启动过程中启动的第一个进程。通过*drop-in
    replacement*，我的意思是，即使它完成任务的方式可能相当不同，但对普通观察者来说，systemd的功能始终如init。这就是为什么/sbin/init文件现在只是一个指向systemd程序的链接。
- en: This is all a bit theoretical as you’ll probably never actually invoke the systemd
    program itself by name, either directly or through its /sbin/init frontend. This
    is because, as you’ve already seen, the key administration tasks are handled by
    `systemctl` on behalf of systemd.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是理论性的，因为您可能永远不会直接通过其/sbin/init前端以名称调用systemd程序。这是因为，如您所见，关键管理任务是由systemd代表`systemctl`处理的。
- en: 'Technically, systemd’s primary job is to control the ways individual processes
    are born, live their lives, and then die. The `systemctl` command you used previously
    is the tool of choice for those tasks. But, somewhat controversially, the systemd
    developers expanded the functionality far beyond the traditional role of process
    management to take control over various system services. Included under the new
    systemd umbrella are tools like a logging manager (journald), network manager
    (networkd), and device manager (you guessed it: udevd). Curious? The *d* stands
    for *daemon*, a background system process.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，systemd的主要任务是控制单个进程的诞生、生活以及死亡的方式。您之前使用的`systemctl`命令是执行这些任务的首选工具。但是，有些有争议的是，systemd开发者将功能扩展得远远超出了传统进程管理的角色，以控制各种系统服务。在新systemd的范围内包括日志管理器（journald）、网络管理器（networkd）和设备管理器（正如您所猜想的：udevd）。好奇吗？其中的*d*代表*daemon*，即后台系统进程。
- en: You’ll cross paths with at least some of those systemd tools as you work through
    the book. Our next stop will be learning how to manage and, most importantly,
    back up file systems and archives.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您在阅读本书的过程中会遇到至少一些systemd工具。我们的下一个目的地将是学习如何管理和，最重要的是，备份文件系统和存档。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Encrypted connections are a critical part of all networked communications, and
    SSH is pretty much the industry standard.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密连接是所有网络通信的关键部分，而SSH几乎是行业标准。
- en: You can enable password-free SSH access by sharing the public key of a key pair.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过共享密钥对中的公钥来启用无密码SSH访问。
- en: The OpenSSH package also allows for secure file copying and remote graphic sessions.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSH 软件包还允许安全地复制文件和远程图形会话。
- en: On most modern Linux distributions, processes are managed by systemd through
    the systemctl tool.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数现代 Linux 发行版中，进程通过 systemctl 工具由 systemd 管理。
- en: You can pipe data between commands using the `|` (pipe) character and filter
    streaming data with `grep`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `|`（管道）字符在命令之间传递数据，并使用 `grep` 过滤流数据。
- en: Key terms
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键术语
- en: A *password* is a string of regular characters, while a *passphrase* can include
    spaces and punctuation.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密码* 是一串常规字符，而 *口令短语* 可以包含空格和标点符号。'
- en: '*RSA* is a popular encryption algorithm.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RSA* 是一种流行的加密算法。'
- en: '*X11 forwarding* allows graphic programs to be run over a remote connection.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*X11 转发* 允许在远程连接上运行图形程序。'
- en: A Linux *process* is all the ongoing activity that’s associated with a single
    running program.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 的 *进程* 是与单个运行程序相关的所有持续活动。
- en: A *shell* is a terminal environment that provides a command-line interpreter
    (like Bash) to allow a user to execute commands. When you’re working from a Linux
    desktop PC or laptop, you’ll generally access a shell by opening a terminal program
    (like GNOME Terminal).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*shell* 是一个提供命令行解释器（如 Bash）的终端环境，允许用户执行命令。当你从 Linux 桌面 PC 或笔记本电脑工作的时候，你通常会通过打开一个终端程序（如
    GNOME 终端）来访问 shell。'
- en: A *parent shell* is an initial environment, from within which new child shells
    can subsequently be launched and through which programs run. A shell is, for all
    intents and purposes, also a process.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*父 shell* 是一个初始环境，从中可以启动新的子 shell，并通过它运行程序。从所有目的来看，shell 也是一个进程。'
- en: Security best practices
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Always encrypt remote login sessions running over a public network.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是在公共网络上运行的远程登录会话中加密。
- en: Avoid relying on passwords alone; like people, they’re fallible.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要仅依赖密码；就像人一样，它们是会出错的。
- en: Key-based, passwordless SSH sessions are preferable to simple password logins.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于密钥、无密码的 SSH 会话比简单的密码登录更可取。
- en: Never transfer files across public networks in plain text.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在公共网络上以纯文本形式传输文件。
- en: Command-line review
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行回顾
- en: '`dpkg -s openssh-client` checks the status of an APT-based software package.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dpkg -s openssh-client` 检查基于 APT 的软件包的状态。'
- en: '`systemctl status ssh` checks the status of a system process (systemd).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl status ssh` 检查系统进程（systemd）的状态。'
- en: '`systemctl start ssh` starts a service.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl start ssh` 启动一个服务。'
- en: '`ip addr` lists all the network interfaces on a computer.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip addr` 列出计算机上的所有网络接口。'
- en: '`ssh-keygen` generates a new pair of SSH keys.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh-keygen` 生成一个新的 SSH 密钥对。'
- en: '`$ cat .ssh/id_rsa.pub | ssh ubuntu@10.0.3.142 "cat >> .ssh/authorized_keys"`
    copies a local key and pastes it on a remote machine.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ cat .ssh/id_rsa.pub | ssh ubuntu@10.0.3.142 "cat >> .ssh/authorized_keys"`
    将本地密钥复制并粘贴到远程机器上。'
- en: '`ssh-copy-id -i .ssh/id_rsa.pub ubuntu@10.0.3.142` safely copies encryption
    keys (recommended and standard).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh-copy-id -i .ssh/id_rsa.pub ubuntu@10.0.3.142` 安全地复制加密密钥（推荐和标准）。'
- en: '`ssh -i .ssh/mykey.pem ubuntu@10.0.3.142` specifies a particular key pair.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh -i .ssh/mykey.pem ubuntu@10.0.3.142` 指定特定的密钥对。'
- en: '`scp myfile ubuntu@10.0.3.142:/home/ubuntu/myfile` safely copies a local file
    to a remote computer.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scp myfile ubuntu@10.0.3.142:/home/ubuntu/myfile` 安全地将本地文件复制到远程计算机。'
- en: '`ssh -X ubuntu@10.0.3.142` allows you to log in to a remote host for a graphics-enabled
    session.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh -X ubuntu@10.0.3.142` 允许你登录到具有图形功能的远程主机。'
- en: '`ps -ef | grep init` displays all currently running system processes and filters
    results using the string `init`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps -ef | grep init` 显示所有当前运行的系统进程，并使用字符串 `init` 过滤结果。'
- en: '`pstree -p` displays all currently running system processes in a visual tree
    format.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pstree -p` 以可视树格式显示所有当前运行的系统进程。'
- en: Test yourself
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自己
- en: '**[1](#ch03qa2q0a1)**'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch03qa2q0a1)**'
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The purpose of an encryption key is to:'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加密密钥的目的是：
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Establish a secure network connection
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立安全网络连接
- en: Encrypt and decrypt data packets
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密和解密数据包
- en: Obscure sensitive data in transit
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传输过程中隐藏敏感数据
- en: Ensure the reliability of data transmissions
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保数据传输的可靠性
- en: '**[2](#ch03qa2q0a2)**'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch03qa2q0a2)**'
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can check the status of a service using which of the following commands?
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以使用以下哪个命令来检查服务的状态？
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`dpkg -s <servicename>`'
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dpkg -s <servicename>`'
- en: '`systemd status <servicename>`'
  id: totrans-238
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemd status <servicename>`'
- en: '`systemctl status <servicename>`'
  id: totrans-239
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemctl status <servicename>`'
- en: '`systemctl <servicename> status`'
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemctl <servicename> status`'
- en: '**[3](#ch03qa2q0a3)**'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch03qa2q0a3)**'
- en: ''
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these packages must be installed before a host server can accept remote
    SSH logins?
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在主机服务器可以接受远程 SSH 登录之前，必须安装以下哪些软件包？
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: openssh-server
  id: totrans-245
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: openssh-server
- en: ssh-server
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ssh-server
- en: openssh-client
  id: totrans-247
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: openssh-client
- en: ssh-client
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: ssh-client
- en: '**[4](#ch03qa2q0a4)**'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch03qa2q0a4)**'
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On a Linux distribution using systemd, the job of init is performed by which
    of these programs?
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用systemd的Linux发行版中，init的任务由以下哪个程序执行？
- en: ''
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: /lib/systemd/systemd
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /lib/systemd/systemd
- en: /bin/systemd
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /bin/systemd
- en: /sbin/init
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /sbin/init
- en: /bin/init
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: /bin/init
- en: '**[5](#ch03qa2q0a5)**'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch03qa2q0a5)**'
- en: ''
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following services is *not* a systemd service?
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个服务不是systemd服务？
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: networkd
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: networkd
- en: journald
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: journald
- en: processd
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: processd
- en: udevd
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: udevd
- en: '**[6](#ch03qa2q0a6)**'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6](#ch03qa2q0a6)**'
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For passwordless SSH connections, where must the keys be placed?
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于无密码SSH连接，密钥必须放在哪里？
- en: ''
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Public and private keys on the host, private key on the client
  id: totrans-269
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机上的公钥和私钥，客户端上的私钥
- en: Public and private keys on the host, public key on the client
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机上的公钥和私钥，客户端上的公钥
- en: Private key on the host, public key on the client
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机上的私钥，客户端上的公钥
- en: Public key on the host, private key on the client
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机上的公钥，客户端上的私钥
- en: '**[7](#ch03qa2q0a7)**'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7](#ch03qa2q0a7)**'
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the purpose of a passphrase in SSH sessions?
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SSH会话中密码的作用是什么？
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To authenticate your identity to the remote OpenSSH program
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证您的身份给远程的OpenSSH程序
- en: To authenticate your identity to the local OpenSSH program
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证您的身份给本地的OpenSSH程序
- en: To identify which key pair you want to use
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确定您想使用哪个密钥对
- en: To authenticate the status of the key pair
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证密钥对的状态
- en: '**[8](#ch03qa2q0a8)**'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8](#ch03qa2q0a8)**'
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following will copy a remote file to the current directory on your
    local machine (assuming both the remote directory and file exist)?
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个操作会将远程文件复制到您的本地机器的当前目录（假设远程目录和文件都存在）？
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`scp mylogin@10.0.3.142:/home/mylogin/filename .`'
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`scp mylogin@10.0.3.142:/home/mylogin/filename .`'
- en: '`scp mylogin@10.0.3.142/home/mylogin/filename .`'
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`scp mylogin@10.0.3.142/home/mylogin/filename .`'
- en: '`scp mylogin@10.0.3.142:/home/mylogin/filename`'
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`scp mylogin@10.0.3.142:/home/mylogin/filename`'
- en: '[PRE32]'
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Answer key
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 答案键
- en: '**[1.](#ch03qa1q1)**'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1.](#ch03qa1q1)**'
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[2.](#ch03qa1q2)**'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2.](#ch03qa1q2)**'
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[3.](#ch03qa1q3)**'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3.](#ch03qa1q3)**'
- en: ''
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[4.](#ch03qa1q4)**'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4.](#ch03qa1q4)**'
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[5.](#ch03qa1q5)**'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5.](#ch03qa1q5)**'
- en: ''
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[6.](#ch03qa1q6)**'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6.](#ch03qa1q6)**'
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[7.](#ch03qa1q7)**'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7.](#ch03qa1q7)**'
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[8.](#ch03qa1q8)**'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8.](#ch03qa1q8)**'
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
