- en: 10 Developing a testing strategy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 开发测试策略
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Testing level pros and cons
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试级别的优缺点
- en: Common antipatterns in test levels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试级别中的常见反模式
- en: The test recipe strategy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试配方策略
- en: Delivery-blocking and non-blocking tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞和非阻塞测试
- en: Delivery vs. discovery pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付与发现管道
- en: Test parallelization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试并行化
- en: 'Unit tests represent just one of the types of tests you could and should write.
    In this chapter, we’ll discuss how unit testing fits into an organizational testing
    strategy. As soon as we start to look at other types of tests, we start asking
    some really important questions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试只是你可以和应该编写的测试类型之一。在本章中，我们将讨论单元测试如何融入组织测试策略。一旦我们开始查看其他类型的测试，我们就开始提出一些真正重要的问题：
- en: At what *level* do we want to test various features? (UI, backend, API, unit,
    etc.)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想在哪个*级别*测试各种功能？（UI、后端、API、单元等）
- en: How do we decide at which level to test a feature? Do we test it multiple times
    on many levels?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何决定在哪个级别测试一个功能？我们在多个级别上多次测试它吗？
- en: Should we have more functional end-to-end tests or more unit tests?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该有更多功能性的端到端测试还是更多单元测试？
- en: How can we optimize the speed of tests without sacrificing trust in them?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在不牺牲对测试的信任的情况下优化测试速度？
- en: Who should write each type of test?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁应该编写每种类型的测试？
- en: The answers to these questions, and many more, are what I’d call a *testing
    strategy*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案，以及许多其他问题，就是我所说的*测试策略*。
- en: The first step in our journey is to frame the scope of the testing strategy
    in terms of test types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程的第一步是将测试策略的范围用测试类型来界定。
- en: 10.1 Common test types and levels
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 常见测试类型和级别
- en: Different industries might have different test types and levels. Figure 10.1,
    which we first discussed in chapter 7, is a rather generic set of test types that
    I feel fits 90% of the organizations I consult with, if not more. The higher the
    level of the tests, the more real dependencies they use, which gives us confidence
    in the overall system’s correctness. The downside is that such tests are slower
    and flakier.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的行业可能会有不同的测试类型和级别。图10.1，我们在第7章中首次讨论过，是一组相当通用的测试类型，我认为它适合90%以上的我咨询的组织，如果不是更多。测试级别越高，它们使用的真实依赖项就越多，这让我们对整体系统的正确性更有信心。缺点是这种测试较慢且不稳定。
- en: '![10-01](../Images/10-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![10-01](../Images/10-01.png)'
- en: Figure 10.1 Common software test levels
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 常见软件测试级别
- en: Nice diagram, but what do we do with it? We use it when we design a framework
    for decision making about which test to write. There are several criteria (things
    that make our jobs easier or harder) I like to pinpoint; these help me decide
    which test type to use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的图表，但我们该如何使用它？我们在设计关于编写哪个测试的决策框架时使用它。有几个标准（使我们的工作更容易或更难的事情）我喜欢明确指出；这些帮助我决定使用哪种测试类型。
- en: 10.1.1 Criteria for judging a test
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 判断测试的标准
- en: When we’re faced with more than two options to choose from, one of the best
    ways I’ve found to help me decide is to figure out what my *obvious values* are
    for the problem at hand. These obvious values are the things we can all pretty
    much agree are useful or should be avoided when making the choice. Table 10.1
    lists my obvious values for tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们面临超过两个选项可供选择时，我发现帮助我做出决定的最佳方法之一是确定我对当前问题的*明显价值观*。这些明显价值观是我们都可以基本达成共识的有用事物或我们在做出选择时应避免的事物。表10.1列出了我对测试的明显价值观。
- en: Table 10.1 Generic test scorecard
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 通用测试评分卡
- en: '| Criterion | Rating scale | Notes |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 标准 | 评分尺度 | 备注 |'
- en: '| Complexity | 1-5 | How complicated a test is to write, read, or debug. Lower
    is better. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 复杂性 | 1-5 | 编写、阅读或调试测试的复杂程度。越低越好。|'
- en: '| Flakiness | 1-5 | How likely a test is to fail because of things it does
    not control—code from other groups, networks, databases, configuration, and more.
    Lower is better. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 不稳定性 | 1-5 | 测试失败的可能性有多大，因为它是由于它无法控制的事物——其他团队的代码、网络、数据库、配置等等。越低越好。|'
- en: '| Confidence when passes | 1-5 | How much confidence is generated in our minds
    and hearts when a test passes. Higher is better. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 通过时的信心 | 1-5 | 当测试通过时，我们在心中和心中产生的信心有多大。越高越好。|'
- en: '| Maintainability | 1-5 | How often the test needs to change, and how easy
    it is to change. Higher is better. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 可维护性 | 1-5 | 测试需要更改的频率以及更改的难易程度。越高越好。|'
- en: '| Execution speed | 1-5 | How quickly does the test finish? Higher is better.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 执行速度 | 1-5 | 测试完成得多快？越高越好。|'
- en: All values are scaled from 1 to 5\. As you’ll see, each level in figure 10.1
    has pros and cons in each of these criteria.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值都是从1到5进行缩放的。正如您将看到的，图10.1中的每个级别在这些标准中都有优点和缺点。
- en: 10.1.2 Unit tests and component tests
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 单元测试和组件测试
- en: Unit tests and component tests are the types of tests we’ve been discussing
    in this book so far. They both fit under the same category, with the only differentiation
    being that component tests might have more functions, classes, or components as
    part of the unit of work. In other words, component tests include more “stuff”
    between the entry and exit points.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和组件测试是我们在本书中迄今为止讨论的测试类型。它们都属于同一类别，唯一的区别是组件测试可能包含更多的工作单元中的函数、类或组件。换句话说，组件测试在入口点和出口点之间包含更多的“内容”。
- en: 'Here are two test examples to illustrate the difference:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个测试示例来说明差异：
- en: '*Test A*—A unit test of a custom UI button object in memory. You can instantiate
    it, click it, and see that it triggers some form of click event.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试A*——一个内存中自定义UI按钮对象的单元测试。您可以实例化它，点击它，并看到它触发了某种形式的点击事件。'
- en: '*Test B*—A component test that instantiates a higher-level form component and
    includes the button as part of its structure. The test verifies the higher-level
    form, with the button playing a small role as part of the higher-level scenario.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试B*——一个组件测试，它实例化了一个高级别表单组件，并将按钮作为其结构的一部分。该测试验证了高级别表单，其中按钮在高级别场景中扮演着小角色。'
- en: Both tests are still unit tests, in memory, and we have full control over all
    the things being used; there are no dependencies on files, databases, networks,
    configuration, or other things we don’t control. Test A is a lower-level unit
    test, and test B is a component test, or a higher-level unit test.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试仍然是单元测试，在内存中执行，并且我们对所有使用的内容都有完全控制权；没有对文件、数据库、网络、配置或其他我们不控制的东西的依赖。测试A是一个低级别的单元测试，而测试B是一个组件测试，或者是一个高级别的单元测试。
- en: The reason this differentiation needs to be made is because I often get asked
    what I would call a test with a different level of abstraction. The answer is
    that whether a test falls into the unit/component test category is based on the
    dependencies it does or doesn’t have, not on the abstraction level it uses. Table
    10.2 shows the scorecard for the unit/component test layer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行这种区分的原因是，我经常被问及如何称呼具有不同抽象级别的测试。答案是，一个测试是否属于单元/组件测试类别，取决于它是否有或没有依赖关系，而不是它使用的抽象级别。表10.2显示了单元/组件测试层的评分卡。
- en: Table 10.2 Unit/component test scorecard
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2单元/组件测试评分卡
- en: '| Complexity | 1/5 | These are the least complex of all test types due to the
    smaller scope and the fact that we can control everything in the test. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 复杂性 | 1/5 | 由于范围较小以及我们可以控制测试中的所有内容，这些测试类型是最不复杂的。|'
- en: '| Flakiness | 1/5 | These are the least flaky of all test types, since we can
    control everything in the test. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 不稳定性 | 1/5 | 由于我们可以在测试中控制所有内容，这些测试类型中不稳定性最低。|'
- en: '| Confidence when passes | 1/5 | It feels nice when a unit test passes, but
    we’re not really confident that our *application* works. We just know that a small
    piece of it does. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 通过时的信心 | 1/5 | 当单元测试通过时，感觉很好，但我们并不真正确信我们的*应用程序*是否工作正常。我们只知道其中一小部分是正常的。|'
- en: '| Maintainability | 5/5 | These are the easiest to maintain out of all test
    types, since it’s relatively simple to read and to reason about. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 可维护性 | 5/5 | 这些测试类型中，这些是最容易维护的，因为它们相对简单，易于阅读和推理。|'
- en: '| Execution speed | 5/5 | These are the fastest of all test types, since everything
    runs in memory without any hard dependencies on files, network, or databases.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 执行速度 | 5/5 | 这些是所有测试类型中最快的，因为所有内容都在内存中运行，没有任何对文件、网络或数据库的硬依赖。|'
- en: 10.1.3 Integration tests
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 集成测试
- en: Integration tests look almost exactly like regular unit tests, but some of the
    dependencies are not stubbed out. For example, we might use a real configuration,
    a real database, a real filesystem, or all three. But to invoke the test, we still
    instantiate an object from our production code in memory and invoke an entry point
    function directly on that object. Table 10.3 shows the scorecard for integration
    tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试几乎与常规单元测试完全相同，但其中一些依赖项没有被模拟。例如，我们可能使用真实的配置、真实的数据库、真实的文件系统，或者三者都有。但为了调用测试，我们仍然在内存中从我们的生产代码中实例化一个对象，并直接在该对象上调用入口点函数。表10.3显示了集成测试的评分卡。
- en: Table 10.3 Integration test scorecard
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.3集成测试评分卡
- en: '| Complexity | 2/5 | These tests are slightly or greatly more complex, depending
    on the number of dependencies that we do not fake in the test. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 复杂性 | 2/5 | 这些测试的复杂度略高或非常高，这取决于我们在测试中未模拟的依赖项数量。 |'
- en: '| Flakiness | 2-3/5 | These tests are slightly or much flakier depending on
    how many real dependencies we use. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 稳定性 | 2-3/5 | 这些测试的不可靠性略高或很高，这取决于我们使用的真实依赖项数量。 |'
- en: '| Confidence when passes | 2-3/5 | It feels much better when an integration
    test passes because we are verifying that the code uses something we do not control,
    like a database or a config file. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 通过时的信心 | 2-3/5 | 当集成测试通过时感觉会好很多，因为我们正在验证代码使用了我们不控制的东西，比如数据库或配置文件。 |'
- en: '| Maintainability | 3-4/5 | These tests are more complex than a unit test because
    of the dependencies. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 可维护性 | 3-4/5 | 由于依赖关系，这些测试比单元测试更复杂。 |'
- en: '| Execution speed | 3-4/5 | These tests are slightly or much slower than a
    unit test because of the dependency on the filesystem, network, database, or threads.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 执行速度 | 3-4/5 | 由于依赖于文件系统、网络、数据库或线程，这些测试的执行速度略慢或慢得多。 |'
- en: 10.1.4 API tests
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 API测试
- en: 'In previous lower levels of tests, we haven’t needed to deploy the application
    under test or make it properly run to test it. At the API test level, we finally
    need to deploy, at least in part, the application under test and invoke it through
    the network. Unlike unit, component, and integration tests, which can be categorized
    as in-memory tests, API tests are out-of-process tests. We are no longer instantiating
    the unit under test directly in memory. This means we’re adding a new dependency
    into the mix: a network, as well as the deployment of some network service. Table
    10.4 shows the scorecard for API tests.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的测试低级别中，我们不需要部署待测试的应用程序或使其正常运行来测试它。在API测试级别，我们最终需要至少部分部署待测试的应用程序并通过网络调用它。与单元、组件和集成测试不同，这些测试可以归类为内存测试，API测试是进程外测试。我们不再直接在内存中实例化待测试的单元。这意味着我们在混合中添加了一个新的依赖项：网络，以及某些网络服务的部署。表10.4显示了API测试的评分卡。
- en: Table 10.4 API test scorecard
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.4 API测试评分卡
- en: '| Complexity | 3/5 | These tests are slightly or greatly more complex, depending
    on the deployment complexity, configuration, and API setup needed. Sometimes we
    need to include the API schema in the test, which takes extra work and thinking.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 复杂性 | 3/5 | 这些测试的复杂度略高或非常高，这取决于部署复杂性、配置和所需的API设置。有时我们需要在测试中包含API模式，这需要额外的工作和思考。
    |'
- en: '| Flakiness | 3-4/5 | The network adds more flakiness to the mix. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 稳定性 | 3-4/5 | 网络增加了更多的不可靠性。 |'
- en: '| Confidence when passes | 3-4/5 | It feels even better when an API test passes.
    We can trust that others can call our API with confidence after deployment. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 通过时的信心 | 3-4/5 | 当API测试通过时感觉会更好。我们可以相信，在部署后，其他人可以自信地调用我们的API。 |'
- en: '| Maintainability | 2-3/5 | The network adds more setup complexity and needs
    more care when changing a test or adding/changing APIs. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 可维护性 | 2-3/5 | 网络增加了更多的设置复杂性，并且在更改测试或添加/更改API时需要更多的关注。 |'
- en: '| Execution speed | 2-3/5 | The network slows the tests down considerably.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 执行速度 | 2-3/5 | 网络显著减慢了测试速度。 |'
- en: 10.1.5 E2E/UI isolated tests
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.5 E2E/UI隔离测试
- en: At the level of isolated end-to-end (E2E) and user interface (UI) tests, we
    are testing our application from the point of view of a user. I use the word *isolated*
    to specify that we are testing *only* our own application or service, without
    deploying any dependency applications or services that our application might need.
    Such tests fake third-party authentication mechanisms, the APIs of other applications
    that are required to be deployed on the same server, and any code that is not
    specifically a part of the main application under test (including apps from the
    same organization’s other departments—those would be faked as well).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在隔离端到端（E2E）和用户界面（UI）测试的层面上，我们是从用户的角度测试我们的应用程序。我使用“隔离”一词来指明我们只测试*我们自己的*应用程序或服务，而不部署任何依赖的应用程序或服务，这些应用程序或服务可能是我们的应用程序所需要的。这样的测试会模拟第三方认证机制，需要在同一服务器上部署的其他应用程序的API，以及任何不是待测试主应用程序特定部分的代码（包括来自同一组织其他部门的app——这些也会被模拟）。
- en: Table 10.5 shows the scorecard for E2E/UI isolated tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.5显示了E2E/UI隔离测试的评分卡。
- en: Table 10.5 E2E/UI isolated test scorecard
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.5 E2E/UI隔离测试评分卡
- en: '| Complexity | 4/5 | These tests are much more complex than previous tests,
    since we are dealing with user flows, UI-based changes, and capturing or scraping
    the UI for integration and assertions. Waiting and timeouts abound. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 复杂度 | 4/5 | 这些测试比之前的测试要复杂得多，因为我们正在处理用户流程、基于UI的变化，以及捕获或抓取UI以进行集成和断言。等待和超时现象普遍存在。|'
- en: '| Flakiness | 4/5 | There are lots of reasons the test may slow down, time
    out, or not work due to the many dependencies involved. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 不稳定性 | 4/5 | 由于涉及到的许多依赖项，测试可能会减慢速度、超时或无法工作。|'
- en: '| Confidence when passes | 4/5 | It’s a huge relief when this type of test
    passes. We gain a lot of confidence in our application. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 通过时的信心 | 4/5 | 当这种类型的测试通过时，这是一个巨大的安慰。我们在我们的应用程序中获得了很大的信心。|'
- en: '| Maintainability | 1-2/5 | More dependencies add more setup complexity and
    require more care when changing a test or adding or changing workflows. Tests
    are long and usually have multiple steps. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 可维护性 | 1-2/5 | 更多的依赖项增加了设置复杂性，并且在更改测试或添加或更改工作流程时需要更多的关注。测试很长，通常有多个步骤。|'
- en: '| Execution speed | 1-2/5 | These tests can be very slow as we navigate user
    interfaces, sometimes including logins, caching, multipage navigation, etc. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 执行速度 | 1-2/5 | 在导航用户界面时，这些测试可能会非常慢，有时包括登录、缓存、多页导航等。|'
- en: 10.1.6 E2E/UI system tests
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.6 端到端/UI系统测试
- en: 'At the level of system E2E and UI tests *nothing* is fake. This is as close
    to a production deployment as we can get: all dependency applications and services
    are real, but they might be differently configured to allow for our testing scenarios.
    Table 10.6 shows the scorecard for E2E/UI system tests.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统端到端和UI测试级别，*没有任何*是假的。这是我们能够达到的生产部署的近似：所有依赖的应用程序和服务都是真实的，但它们可能被配置得不同，以允许我们的测试场景。表10.6显示了端到端/UI系统测试的评分表。
- en: Table 10.6 E2E/UI system test scorecard
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.6 端到端/UI系统测试评分表
- en: '| Complexity | 5/5 | These are the most complex tests to set up and write due
    to the number of dependencies. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 复杂度 | 5/5 | 由于依赖项的数量，这些是最复杂、设置和编写难度最大的测试。|'
- en: '| Flakiness | 5/5 | These tests can fail for any of thousands of different
    reasons, and often for multiple reasons. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 不稳定性 | 5/5 | 这些测试可能因为成千上万的不同原因而失败，并且通常有多种原因。|'
- en: '| Confidence when passes | 5/5 | These tests give us the highest confidence
    because of all the code that gets tested when the tests execute. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 通过时的信心 | 5/5 | 由于测试执行时测试了所有代码，这些测试给我们带来了最高的信心。|'
- en: '| Maintainability | 1/5 | These tests are hard to maintain, due to the many
    dependencies and long workflows. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 可维护性 | 1/5 | 由于许多依赖项和长工作流程，这些测试难以维护。|'
- en: '| Execution speed | 1/5 | These tests are very slow because they use the UI
    and real dependencies. They can take minutes to hours for a single test. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 执行速度 | 1/5 | 这些测试非常慢，因为它们使用了UI和真实依赖项。单个测试可能需要几分钟到几小时。|'
- en: 10.2 Test-level antipatterns
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 测试级别的反模式
- en: Test-level antipatterns are not technical but organizational in nature. You’ve
    likely seen them firsthand. As a consultant, I can tell you that they are very
    prevalent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试级别的反模式不是技术性的，而是组织性的。你可能亲眼见过。作为一个顾问，我可以告诉你，它们非常普遍。
- en: 10.2.1 The end-to-end-only antipattern
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 仅端到端测试的反模式
- en: A very common strategy that an organization will have is using mostly, if not
    only, E2E tests (both isolated and system tests). Figure 10.2 shows what this
    looks like in the diagram of test levels and types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 组织通常会采用的一种非常常见的策略是主要使用，如果不是唯一使用，端到端测试（包括隔离和系统测试）。图10.2显示了在测试级别和类型图中的这种样子。
- en: '![10-02](../Images/10-02.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![10-02](../Images/10-02.png)'
- en: Figure 10.2 End-to-end-only test antipattern
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 仅端到端测试的反模式
- en: Why is this an antipattern? Tests at this level are very slow, hard to maintain,
    hard to debug, and very flaky. These costs remain the same, while the value you
    get from each new E2E test diminishes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是一个反模式？在这个级别的测试非常慢，难以维护，难以调试，并且非常不稳定。这些成本保持不变，而每个新的端到端测试带来的价值却在减少。
- en: Diminishing returns from E2E tests
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的边际效益递减
- en: The first E2E test you write will bring you the most confidence because of how
    many other paths of code are included as part of that scenario, and because of
    the glue—the code orchestrating the work between your application and other systems—that
    gets invoked as part of that test.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你写的第一个端到端测试会给你带来最大的信心，因为该场景包含了大量其他代码路径，也因为胶水——协调应用程序与其他系统之间工作的代码——作为测试的一部分被调用。
- en: But what about the second E2E test? It will usually be a variation on the first
    test, which means it might only bring a small fraction of the same value. Maybe
    there’s a difference in a combo box and other UI elements, but all the dependencies,
    such as the database and third-party systems, remain the same.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但第二个端到端测试怎么办？它通常是对第一个测试的变体，这意味着它可能只带来一小部分相同的价值。也许组合框和其他UI元素有所不同，但所有依赖项，如数据库和第三方系统，都保持不变。
- en: The amount of extra confidence you get from the *second* E2E test is also only
    a fraction of the extra confidence you got from the first E2E test. However, the
    cost of debugging, changing, reading, and running that test is not a fraction;
    it is basically the same as for the previous test. You’re incurring a lot of extra
    work for a very small bit of extra confidence, which is why I like to say that
    E2E tests have quickly diminishing returns.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二个端到端测试中获得的额外信心也仅仅是第一个端到端测试中获得额外信心的一小部分。然而，调试、更改、阅读和运行该测试的成本并不是一小部分；它基本上与之前的测试相同。你正在为非常小的额外信心承担大量的额外工作，这就是为什么我喜欢说端到端测试的回报迅速递减。
- en: If I want variation on the first test, it would be much more pragmatic to test
    at a lower level than the previous test. I already know most, if not all, of the
    glue between layers works, from the first test. There’s no need to pay the tax
    of another E2E test if I can prove the next scenario at a lower level and pay
    a much smaller fee for pretty much the same bit of confidence.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想对第一个测试进行变化，那么在比上一个测试更低的级别进行测试会更为实际。我已经知道大多数，如果不是所有，层之间的粘合剂都工作正常，从第一个测试开始。如果我能证明下一个场景在较低级别，并且只需支付一小部分费用就能获得几乎相同的信心，那么就没有必要为另一个端到端测试支付税收。
- en: The build whisperer
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 whisperer
- en: With E2E tests, not only do we have diminishing returns, we create a new bottleneck
    in the organization. Because high-level tests are often flaky, they break for
    many different reasons, some of which are not relevant to the test. You then need
    special people in the organization (usually QA leads) to sit down and analyze
    each of the many failing tests, and to hunt down the cause and determine if it’s
    actually a problem or a minor issue.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用端到端测试，我们不仅得到了递减的回报，还在组织中创造了一个新的瓶颈。因为高级测试通常不可靠，它们会因为许多不同的原因而失败，其中一些与测试本身无关。然后你需要组织中的特殊人员（通常是质量保证负责人）坐下来分析许多失败的测试，并追查原因，确定它是否真的是一个问题或是一个小问题。
- en: I call these poor souls *build whisperers*. When the build is red, which it
    is most of the time, build whisperers are the ones who must come in, parse the
    data, and knowingly say, after hours of inspection, “Yes, it looks red, but it’s
    actually green.”
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这些可怜的人称为 *构建 whisperer*。当构建是红色的时候，这通常是大多数情况，构建 whisperer 是必须进来解析数据，并在经过数小时检查后，有意识地表示，“是的，看起来是红色的，但实际上是绿色的。”
- en: Usually, the organization will drive build whisperers into a corner, demanding
    that they say the build is green because “We have to get this release out the
    door.” They are the gatekeepers of the release, and that is a thankless, stressful,
    and often manual and frustrating job. Whisperers usually burn out within a year
    or two, and they get chewed up and spit out into the next organization, where
    they do the same thankless job all over again. You’ll often see build whisperers
    when this antipattern of many high-level E2E tests exists.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，组织会将构建 whisperer 推向角落，要求他们声称构建是绿色的，因为“我们必须把这个发布版本推出门。”他们是发布的守门人，这是一份没有回报、压力很大、通常手动且令人沮丧的工作。whisperer
    通常在一年或两年内就会筋疲力尽，然后被咀嚼并吐出到下一个组织，在那里他们再次做同样的没有回报的工作。你经常会看到当存在许多高级端到端测试的反模式时，就会有构建
    whisperer。
- en: Avoiding build whisperers
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 避免构建 whisperer
- en: There is a way to resolve this mess, and that’s to create and cultivate robust,
    automated test pipelines that can automatically judge whether a build is green
    or not, even if you have flaky tests. Netflix has openly blogged about creating
    their own tool for measuring how a build is doing statistically in the wild, so
    that it can be automatically approved for full release deployment (http://mng.bz/BAA1).
    This is doable, but it takes time and culture to achieve such a pipeline. I write
    more about these types of pipelines in my blog at https://pipelinedriven.org.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以解决这个混乱，那就是创建和培养强大的、自动化的测试流水线，这样它可以自动判断构建是否为绿色，即使你有不可靠的测试。Netflix 公开博客介绍了他们自己的工具，用于统计测量构建在野外的表现，以便可以自动批准全面发布部署（http://mng.bz/BAA1）。这是可行的，但需要时间和文化来实现这样的流水线。我在我的博客
    https://pipelinedriven.org 上写了更多关于这些类型流水线的内容。
- en: A “throw it over the wall” mentality
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一种“扔过墙”的心态
- en: Another reason having only E2E tests hurts organizations is that the people
    in charge of maintaining and monitoring these tests are people in the QA department.
    This means that the organization’s developers might not care about or even know
    the results of these builds, and they are not invested in fixing or caring for
    these tests. They don’t own them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只拥有端到端测试还会伤害组织的另一个原因是，负责维护和监控这些测试的人是QA部门的人。这意味着组织的开发者可能不关心甚至不知道这些构建的结果，他们也没有投入精力去修复或关心这些测试。他们不拥有这些测试。
- en: This “throw it over the wall” mentality can cause lots of miscommunication and
    quality issues because one part of the organization is not connected to the consequences
    of its actions, and the other side is suffering the consequences without being
    able to control the source of the issue. Is it any wonder that, in many organizations,
    developers and QA people don’t get along? The system around them is often designed
    to make them mortal enemies instead of collaborators.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“扔过墙”的心态会导致很多沟通和质量问题，因为组织的某一部分没有与其行动的后果相联系，而另一部分则遭受了后果却无法控制问题的源头。难道在许多组织中，开发人员和QA人员不和睦不是令人惊讶的吗？围绕他们的系统通常被设计成让他们成为死敌而不是合作者。
- en: When this antipattern happens
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种反模式发生时
- en: 'These are some reasons why I see this happen:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我看到这种情况发生的一些原因：
- en: '*Separation of duties*—Separate QA and development departments with separate
    pipelines (automated build jobs and dashboards) exist in many organizations. When
    a QA department has its own pipeline, it is likely to write more tests of the
    same kind. Also, a QA department tends to write only a specific type of test—the
    ones they’re used to and are expected to write (sometimes based on company policy).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*职责分离*—在许多组织中，QA部门和开发部门有独立的管道（自动构建作业和仪表板）。当一个QA部门有自己的管道时，它很可能会编写更多同类型的测试。此外，QA部门倾向于只编写特定类型的测试——他们习惯于编写并且期望编写的测试（有时基于公司政策）。'
- en: '*An “if it works, don’t change it” mentality*—A group might start with E2E
    tests and see that they like the results. They continue to add all their new tests
    in the same way, because it’s what they know, and it has proven to be useful.
    When the time it takes to run tests gets too long, it’s already too late to change
    direction (which relates to the next point).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*“如果它有效，就不要改变它”的心态*—一个团队可能从端到端测试开始，发现他们喜欢这些结果。他们继续以同样的方式添加所有新的测试，因为这正是他们所知道的，并且已经证明是有用的。当运行测试所需的时间变得过长时，改变方向已经太晚了（这与下一个点相关）。'
- en: '*Sunk-costs fallacy*—“We have lots of these types of tests, and if we changed
    them or replaced them with lower-level tests, it would mean we’ve wasted all that
    time and effort on tests that we are removing.” This is a fallacy, because maintaining,
    debugging, and understanding test failures costs a fortune in human time. If anything,
    it costs *less* to delete such tests (keeping only a few basic scenarios) and
    get that time back.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*沉没成本谬误*—“我们有很多这类测试，如果我们改变它们或用低级测试替换它们，那就意味着我们在移除的测试上浪费了所有的时间和精力。”这是一个谬误，因为维护、调试和理解测试失败需要大量的人力时间。实际上，删除这些测试（只保留一些基本场景）并找回这些时间成本更低。'
- en: Should you avoid E2E tests completely?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该完全避免端到端测试吗？
- en: No, we can’t avoid E2E tests. One of the good things they offer is *confidence*
    that the application works. It’s a completely different level of confidence compared
    to unit tests, because they test the integration of the full system, with all
    of its subsystems and components, from the point of view of a user. When they
    pass, the feeling you get is huge relief that the major scenarios you expect your
    users to encounter actually work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们无法避免端到端测试。它们提供的好处之一是*信心*，即应用程序可以正常工作。与单元测试相比，这是一个完全不同的信心水平，因为它们从用户的角度测试了整个系统的集成，包括所有子系统及其组件。当它们通过时，你会感到巨大的解脱，因为你期望用户遇到的主要场景实际上是可以工作的。
- en: So don’t avoid them entirely. Instead, I highly recommend *minimizing* the number
    of E2E tests. We’ll talk about what that minimum is in section 10.3.3.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要完全避免它们。相反，我强烈建议*最小化*端到端测试的数量。我们将在第10.3.3节中讨论这个最小值。
- en: 10.2.2 The low-level-only test antipattern
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 仅低级测试的反模式
- en: The opposite of having only E2E tests is to have low-level tests only. Unit
    tests provide fast feedback, but they don’t provide the amount of confidence needed
    to fully trust that your application works as a single integrated unit (see figure
    10.3).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有端到端测试的反面是只有低级测试。单元测试可以提供快速的反馈，但它们并不能提供足够的信心，以确保你的应用程序作为一个单一集成的单元正常工作（见图10.3）。
- en: '![10-03](../Images/10-03.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![10-03](../Images/10-03.png)'
- en: Figure 10.3 Low-level-only test antipattern
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 只有低级测试的反模式
- en: In this antipattern, the organization’s automated tests are mostly or exclusively
    low-level tests, such as unit tests or component tests. There may be hints of
    integration tests, but there are no E2E tests in sight.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个反模式中，组织的自动化测试主要是或完全是低级测试，如单元测试或组件测试。可能会有一些集成测试的迹象，但看不到端到端测试。
- en: The biggest issue with this is that the confidence level you get when these
    types of tests pass is simply not enough to feel confident that your application
    works. That means people will run the tests and then continue to do manual debugging
    and testing to get the final sense of confidence needed to release something.
    Unless what you’re shipping is a code library that’s meant to be used in the way
    your unit tests are using it, this won’t be enough. Yes, the tests will run quickly,
    but you’ll still spend lots of time manually testing and verifying.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的最大问题是，当这些类型的测试通过时，你获得的信心水平远远不足以让你确信应用程序是正常工作的。这意味着人们会运行测试，然后继续进行手动调试和测试，以获得发布所需最终信心。除非你发布的代码库是打算以你的单元测试使用的方式使用的，否则这还不够。是的，测试会很快运行，但你仍然会花费大量时间进行手动测试和验证。
- en: This antipattern often happens when your developers are only used to writing
    low-level tests, if they don’t feel comfortable writing high-level tests, or if
    they expect the QA people to write those types of tests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式通常发生在你的开发者只习惯于编写低级测试，如果他们不习惯编写高级测试，或者如果他们期望QA人员编写这些类型的测试时。
- en: Does that mean you should avoid unit tests? Obviously not. But I highly recommend
    that you have *not only* unit tests but also higher-level tests. We’ll discuss
    this recommendation in section 10.3.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你应该避免单元测试？显然不是。但我强烈建议你不仅要单元测试，还要有高级测试。我们将在第10.3节中讨论这个建议。
- en: 10.2.3 Disconnected low-level and high-level tests
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 分离的低级和高级测试
- en: This pattern might seem healthy at first, but it really isn’t. It might look
    a bit like figure 10.4.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式一开始可能看起来很健康，但实际上并不是。它可能看起来有点像图10.4。
- en: '![10-04](../Images/10-04.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![10-04](../Images/10-04.png)'
- en: Figure 10.4 Disconnected low-level and high-level tests
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 分离的低级和高级测试
- en: 'Yes, you want to have both low-level tests (for speed) and high-level tests
    (for confidence). But when you see something like this in an organization, you
    will likely encounter one or more of these anti-behaviors:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你想要既有低级测试（为了速度）又有高级测试（为了信心）。但当你在组织中看到这种情况时，你可能会遇到以下一种或多种反行为：
- en: Many of the tests repeat in multiple levels.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多测试在多个级别上重复。
- en: The people who write the low-level tests are not the same people who write the
    high-level tests. This means they don’t care about each other’s test results,
    and they’ll likely have different pipelines execute the different test types.
    When one pipeline is red, the other group might not even know nor care that those
    tests are failing.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写低级测试的人与编写高级测试的人不是同一批人。这意味着他们不关心彼此的测试结果，并且他们可能会设置不同的管道来执行不同的测试类型。当一个管道变红时，另一组人可能甚至不知道也不关心那些测试失败了。
- en: 'We suffer the worst of both worlds: at the top level, we suffer from the long
    test times, difficult maintainability, build whisperers, and flakiness; at the
    bottom level, we suffer from lack of confidence. And because there is often a
    lack of communication, we don’t get the speed benefit of the low-level tests because
    they repeat at the top anyway. We also don’t get the top-level confidence because
    of how flaky such a large number of tests is.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们遭受了两个世界的最坏情况：在顶层，我们遭受了长测试时间、难以维护、构建低语者和易变性的困扰；在底层，我们遭受了缺乏信心。由于通常缺乏沟通，我们无法从低级测试中获得速度优势，因为它们无论如何都会在顶层重复。我们也无法获得顶层信心，因为如此大量的测试如此不稳定。
- en: This pattern often happens when we have separate test and a development organizations
    with different goals and metrics, as well as different jobs and pipelines, permissions,
    and even code repositories. The larger the company, the more likely this is to
    happen.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常发生在我们拥有不同的目标和指标、不同的工作、管道、权限，甚至代码存储库的独立测试和开发组织时。公司越大，这种情况发生的可能性就越大。
- en: 10.3 Test recipes as a strategy
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 测试食谱作为策略
- en: My proposed strategy to achieve balance in the types of tests used by the organization
    is to use *test recipes.* The idea is to have an informal plan for how a particular
    feature is going to be tested. This plan should include not only the main scenario
    (also known as the *happy path*), but also all its significant variations (also
    known as *edge cases*), as shown in figure 10.5\. A well-outlined test recipe
    gives a clear picture of what test level is appropriate for each scenario.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我提出的在组织使用的测试类型之间实现平衡的策略是使用*测试食谱*。想法是制定一个非正式的计划，说明特定功能将如何进行测试。这个计划不仅应该包括主要场景（也称为*成功路径*），还应该包括所有重要的变体（也称为*边缘情况*），如图10.5所示。一个清晰定义的测试食谱可以清楚地展示每个场景适合的测试级别。
- en: '![10-05](../Images/10-05.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![10-05](../Images/10-05.png)'
- en: Figure 10.5 A test recipe is a test plan, outlining at which level a particular
    feature should be tested.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 测试食谱是一个测试计划，概述了特定功能应该在哪个级别进行测试。
- en: 10.3.1 How to write a test recipe
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 如何编写测试食谱
- en: It’s best to have at least two people create a test recipe—hopefully one with
    a developer’s point of view and one with a tester’s point of view. If there is
    no test department, two developers, or a developer with a senior developer will
    suffice. Mapping each scenario to a specific level in the test hierarchy can be
    a highly subjective task, so two pairs of eyes will help keep each other’s implicit
    assumptions in check.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最好至少有两个人创建测试食谱——希望一个是开发者的视角，另一个是测试者的视角。如果没有测试部门，两个开发者或者一个开发者和一个高级开发者就足够了。将每个场景映射到测试层次结构中的特定级别可能是一个非常主观的任务，所以有两双眼睛可以帮助彼此检查隐含的假设。
- en: The recipes themselves can be stored as extra text in a TODO list or as part
    of the feature story on the tracking board for the task. You don’t need a separate
    tool for planning tests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些食谱本身可以存储为TODO列表中的额外文本，或者作为任务跟踪板上的功能故事的组成部分。你不需要一个单独的工具来规划测试。
- en: The best time to create a test recipe is just before you start working on the
    feature. This way, the test recipe becomes part of the definition of “done” for
    the feature, meaning the feature is not complete until the full test recipe is
    passing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试食谱的最佳时机是在开始开发功能之前。这样，测试食谱就成为了功能“完成”定义的一部分，这意味着功能在没有通过完整的测试食谱之前是不完整的。
- en: Of course, a recipe can change as time goes by. The team can add or remove scenarios
    from it. A recipe is not a rigid artifact but a continuous work in progress, just
    like everything else in software development.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随着时间的推移，食谱可能会发生变化。团队可以从中添加或删除场景。食谱不是一个僵化的工件，而是一个持续进行的工作，就像软件开发中的其他一切一样。
- en: A test recipe represents the list of scenarios that will give its creators “pretty
    good confidence” that the feature works. As a rule of thumb, I like to have a
    1 to 5 or 1 to 10 ratio between levels of tests. For any high-level, E2E test,
    I might have 5 tests at a lower level. Or, if you think bottom-up, say you have
    100 unit tests. You usually won’t need to have more than 10 integration tests
    and 1 E2E test.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试食谱代表了将给其创作者提供“相当好的信心”的功能是否正常工作的场景列表。作为一个经验法则，我喜欢在测试级别之间保持1到5或1到10的比例。对于任何高级别的端到端测试，我可能会有5个低级别的测试。或者，如果你从底部向上思考，比如说你有100个单元测试。你通常不需要超过10个集成测试和1个端到端测试。
- en: Don’t treat test recipes as something formal, though. A test recipe is not a
    binding commitment or a list of test cases in a test-planning piece of software.
    Don’t use it as a public report, a user story, or any other kind of promise to
    a stakeholder. At its core, a recipe is a simple list of 5 to 20 lines of text
    detailing simple scenarios to be tested in an automated fashion and at what level.
    The list can be changed, added to, or subtracted from. Consider it a comment.
    I usually like to just put it right in the user story or feature in Jira or whatever
    program I’m using.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，不要将测试配方视为正式的东西。测试配方不是一项约束性的承诺，也不是测试计划软件中的测试用例列表。不要将其用作公共报告、用户故事或对利益相关者的任何其他承诺。本质上，配方是一个简单的5到20行的文本列表，详细说明了要自动测试的场景及其级别。这个列表可以更改、添加或删除。把它当作一个注释。我通常喜欢直接把它放在Jira或我使用的任何程序中的用户故事或功能中。
- en: 'Here’s an example of what one might look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子，看看它可能是什么样子：
- en: '[PRE0]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 10.3.2 When do I write and use a test recipe?
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 我什么时候编写和使用测试配方？
- en: Just before you start coding a feature or a user story, sit down with another
    person and try to come up with various scenarios to be tested. Discuss at which
    level that scenario should be best tested. This meeting will usually be no longer
    than 5 to 15 minutes, and after it, coding begins, including the writing of the
    tests. (If you’re doing TDD, you’ll start with the tests.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编码一个功能或用户故事之前，和另一个人坐下来，尝试想出各种要测试的场景。讨论这个场景应该在哪个层面上进行最佳测试。这次会议通常不会超过5到15分钟，之后就开始编码，包括编写测试。（如果你在做TDD，你会从测试开始。）
- en: In organizations where there are automation or QA roles, the developer will
    write the lower-level tests, and the QA will focus on writing the higher-level
    tests, while coding of the feature is taking place. Both people are working at
    the same time. One does not wait for the other to finish their work before starting
    to write their tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在有自动化或QA角色的组织中，开发者将编写低级测试，QA将专注于编写高级测试，而功能编码正在进行时。这两个人同时工作。一个人不会等待另一个人完成工作才开始编写测试。
- en: If you are working with feature toggles, they should also be checked as part
    of the tests, so that if a feature is off, its tests will not run.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用功能开关，它们也应该作为测试的一部分进行检查，这样如果功能关闭，其测试将不会运行。
- en: 10.3.3 Rules for a test recipe
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 测试配方的规则
- en: 'There are several rules to follow when writing a test recipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在有自动化或QA角色的组织中，开发者将编写低级测试，QA将专注于编写高级测试，而功能编码正在进行时。这两个人同时工作。一个人不会等待另一个人完成工作才开始编写测试。
- en: '*Faster*—Prefer writing tests at lower levels, unless a high-level test is
    the only way for you to gain confidence that the feature works.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更快*—优先编写低级测试，除非高级测试是你获得对功能工作信心唯一方式。'
- en: '*Confidence*—The recipe is done when you can tell yourself, “If all these tests
    passed, I’ll feel pretty good about this feature working.” If you can’t say that,
    write more scenarios that will allow you to say that.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心*—当你能对自己说，“如果所有这些测试都通过了，我会对这个功能的工作感到相当满意。”如果你不能这么说，就编写更多的场景，让你能这么说。'
- en: '*Revise*—Feel free to add or remove tests from the list as you code. Just make
    sure you notify the other person you worked with on the recipe.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修订*—在编码过程中，你可以自由地添加或删除列表中的测试。只需确保通知你合作的配方中的人即可。'
- en: '*Just in time*—Write this recipe just before starting to code, when you know
    who is going to code it.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*及时*—在你知道谁将要编码之前，开始编码之前编写这个配方。'
- en: '*Pair*—Don’t write it alone if you can help it. People think in different ways,
    and it’s important to talk through the scenarios and learn from each other about
    testing ideas and mindset.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结对编程*—如果可能的话，不要独自编写。人们思考的方式不同，讨论场景并从彼此那里学习测试想法和心态是很重要的。'
- en: '*Don’t repeat yourself from other features*—If this scenario is already covered
    by an existing test (perhaps an E2E test from a previous feature), there is no
    need to repeat this scenario at that level.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要从其他功能重复*—如果这个场景已经被现有的测试覆盖（可能是一个来自先前功能的端到端测试），在那个层面上重复这个场景就没有必要了。'
- en: '*Don’t repeat yourself from other layers*—Try not to repeat the same scenario
    at multiple levels. If you’re checking a successful login at the E2E level, lower-level
    tests should only check variations of that scenario (logging in with different
    providers, unsuccessful login results, etc.).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要重复其他层级的代码*—尽量不在多个层面上重复相同的场景。如果你在端到端层面上检查成功的登录，低级测试应该只检查该场景的变体（使用不同提供者的登录、失败的登录结果等）。'
- en: '*More, faster*—A good rule of thumb is to end up with a ratio of at least one
    to five between levels (for one E2E test, you might end up with five or more lower-level
    tests).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更多，更快*—一个很好的经验法则是最终在级别之间达到至少一比五的比例（对于一个端到端测试，你可能会有五个或更多的低级别测试）。'
- en: '*Pragmatic*—Don’t feel the need to write tests at all levels for a given feature.
    Some features or user stories might only require unit tests. Others, only API
    or E2E tests. The basic idea is that, if all the scenarios in the recipe pass,
    you should feel confidence, regardless of what level they are tested at. If that’s
    not the case, move the scenarios around to different levels until you feel more
    confident, without sacrificing too much speed or maintenance burden.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用主义*—对于给定的功能，没有必要在每个级别都编写测试。有些功能或用户故事可能只需要单元测试。其他可能只需要API或端到端测试。基本思想是，如果配方中的所有场景都通过了，无论它们在哪个级别进行测试，你都应该感到自信。如果不是这样，将场景移动到不同的级别，直到你感到更有信心，同时不要牺牲太多的速度或维护负担。'
- en: By following these rules, you’ll get the benefit of fast feedback, because most
    of your tests will be low level, while not sacrificing confidence because the
    few most important scenarios are still covered by high-level tests. The test recipe
    approach also allows you to avoid most of the repetition between tests by positioning
    scenario variations at levels lower than the main scenario. Finally, if QA people
    are involved in writing test recipes too, you’ll form a new communication channel
    between people within your organization, which helps improve mutual understanding
    of your software project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些规则，你将获得快速反馈的好处，因为大部分测试将是低级别的，同时不会牺牲信心，因为少数最重要的场景仍然由高级测试覆盖。测试配方方法还允许你通过在主场景以下级别定位场景变体来避免测试之间的大多数重复。最后，如果QA人员也参与编写测试配方，你将在组织内部形成一个新的沟通渠道，这有助于提高对软件项目的相互理解。
- en: 10.4 Managing delivery pipelines
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 管理交付管道
- en: What about performance tests? Security tests? Load tests? What about lots of
    other tests that might take ages to run? Where and when should we run them? Which
    layer are they? Should they be part of our automated pipeline?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试？安全测试？负载测试？还有许多其他可能需要花费很长时间运行的测试，我们应该在哪里和什么时候运行它们？它们属于哪一层？它们应该成为我们自动化流程的一部分吗？
- en: Lots of organizations run those tests as part of the integration automated pipeline
    that runs for each release or pull request. However, this causes huge delays in
    feedback, and the feedback is often “failed,” even though the failure is not essential
    for a release to go out for these types of tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织将这些测试作为集成自动化管道的一部分运行，该管道为每个发布或拉取请求运行。然而，这会导致反馈延迟巨大，而且反馈通常是“失败”，尽管对于这些类型的测试，失败并不是发布所必需的。
- en: 'We can divide these types of tests into two main groups:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些测试类型分为两大类：
- en: '*Delivery-blocking tests*—These are tests that provide a go or no-go for the
    change that is about to be released and deployed. Unit, E2E, system, and security
    tests all fall into this category. Their feedback is binary: they either pass
    and announce that the change didn’t introduce any bugs, or they fail and indicate
    that the code needs to be fixed before it’s released.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交付阻止测试*—这些是提供即将发布和部署的更改是否可行的测试。单元测试、端到端测试、系统测试和安全测试都属于这一类别。它们的反馈是二元的：要么通过并宣布更改没有引入任何错误，要么失败并指示在发布之前需要修复代码。'
- en: '*Good-to-know tests*—These are tests created for the purpose of discovery and
    continuous monitoring of key performance indicator (KPI) metrics. Examples include
    code analysis and complexity scanning, high-load performance testing, and other
    long-running nonfunctional tests that provide nonbinary feedback. If these tests
    fail, we might add new work items to our next sprints, but we would still be OK
    releasing our software.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值得了解的测试*—这些是为了发现和持续监控关键性能指标（KPI）而创建的测试。例如，包括代码分析和复杂性扫描、高负载性能测试以及其他提供非二进制反馈的长时间运行的非功能性测试。如果这些测试失败，我们可能会将新的工作项添加到我们的下一个迭代中，但我们仍然可以发布我们的软件。'
- en: 10.4.1 Delivery vs. discovery pipelines
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 交付与发现管道
- en: 'We don’t want our good-to-know tests to take valuable feedback time from our
    delivery process, so we’ll also have two types of pipelines:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的“值得了解”的测试从我们的交付过程中夺取宝贵的反馈时间，因此我们还将有两种类型的管道：
- en: '*Delivery pipeline*—Used for delivery-blocking tests. When the pipeline is
    green, we should be confident that we can automatically release the code to production.
    Tests in this pipeline should provide relatively fast feedback.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交付管道*——用于阻止交付的测试。当管道为绿色时，我们应该有信心可以自动将代码发布到生产环境。这个管道中的测试应该提供相对快速的反馈。'
- en: '*Discovery pipeline*—Used for good-to-know tests. This pipeline runs in parallel
    with the delivery pipeline, but continuously, and it’s not taken into account
    as a release criterion. Since there’s no need to wait for its feedback, tests
    in this pipeline can take a long time. If errors are found, they might become
    new work items in the next sprints for the team, but releases are not blocked.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发现管道*——用于应知应会的测试。这个管道与交付管道并行运行，但持续进行，并且不被视为发布标准。由于不需要等待其反馈，这个管道中的测试可以持续很长时间。如果发现错误，它们可能会成为团队在下个冲刺中的新工作项，但发布不会受阻。'
- en: Figure 10.6 illustrates the features of these two kinds of pipelines.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6展示了这两种管道的功能。
- en: '![10-06](../Images/10-06.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![10-06](../Images/10-06.png)'
- en: Figure 10.6 Delivery vs. discovery pipelines
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 交付与发现管道
- en: The point of the delivery pipeline is to provide a go/no-go check that also
    deploys our code if all seems green, perhaps even to production. The point of
    the discovery pipeline is to provide refactoring objectives for the team, such
    as dealing with code complexity that has become too high. It can also show whether
    those refactoring efforts are effective over time. The discovery pipeline does
    not deploy anything except for the purpose of running specialized tests or analyzing
    code and its various KPI metrics. It ends with numbers on a dashboard.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 交付管道的目的在于提供一个通过/不通过检查，如果一切看起来都是绿色的，甚至可能部署我们的代码到生产环境。发现管道的目的是为团队提供重构目标，例如处理变得过于复杂的代码复杂性。它还可以显示这些重构努力是否随着时间的推移而有效。发现管道除了运行专门的测试或分析代码及其各种KPI指标之外，不部署任何内容。它以仪表板上的数字结束。
- en: Speed is a big factor in getting teams to be more engaged, and splitting tests
    into discovery and delivery pipelines is yet another technique to keep in your
    arsenal.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 速度是让团队更加投入的一个大因素，将测试分为发现和交付管道是你要保留在武器库中的另一种技术。
- en: 10.4.2 Test layer parallelization
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 测试层并行化
- en: Since fast feedback is very important, a common pattern you can and should employ
    in many scenarios is to run different test layers in parallel to speed up the
    pipeline feedback, as shown in figure 10.7\. You can even use parallel environments
    that are created dynamically and destroyed at the end of the test.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于快速反馈非常重要，你可以在许多场景中采用并应该采用的一种常见模式是并行运行不同的测试层以加快管道反馈，如图10.7所示。你甚至可以使用在测试结束时动态创建和销毁的并行环境。
- en: '![10-07](../Images/10-07.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![10-07](../Images/10-07.png)'
- en: Figure 10.7 To speed up delivery, you can run pipelines, and even stages in
    pipelines, in parallel.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 为了加快交付，你可以并行运行管道，甚至管道中的阶段。
- en: This approach benefits greatly from having access to dynamic environments. Throwing
    money at environments and automated parallel tests is almost always much more
    effective than throwing money at more people to do more manual tests, or simply
    having people wait longer to get feedback because the environment is being used
    right now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法从能够访问动态环境中受益很大。把钱花在环境和自动并行测试上几乎总是比花钱雇佣更多的人做更多的手动测试，或者简单地让人们等待更长的时间以获得反馈（因为环境正在被使用）要有效得多。
- en: Manual testing is unsustainable because such manual work only increases over
    time and becomes more and more frail and error prone. At the same time, simply
    waiting longer for pipeline feedback results in a huge waste of time for everyone.
    The waiting time, multiplied by the number of people waiting and the number of
    builds per day, results in a monthly investment that can be much larger than investing
    in dynamic environments and automation. Grab an Excel file and show your manager
    a simple formula to get that budget.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试是不可持续的，因为这种手动工作只会随着时间的推移而增加，变得越来越脆弱和容易出错。同时，简单地等待更长时间的管道反馈结果会导致每个人大量的时间浪费。等待时间乘以等待的人数和每天的构建次数，结果是一个月投资可能比投资动态环境和自动化要大得多。拿一个Excel文件，向你的经理展示一个简单的公式来获取那个预算。
- en: You can parallelize not only stages inside a pipeline; you can go further and
    run individual tests in parallel too. For example, if you’re stuck with a large
    number of E2E tests, you can break them up into parallel test suites. That shaves
    a lot of time off your feedback loop.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以并行化管道内的阶段；你还可以进一步并行运行单个测试。例如，如果你遇到了大量E2E测试，你可以将它们拆分成并行测试套件。这将从你的反馈循环中节省大量时间。
- en: Don’t do nightly builds
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不要进行夜间构建
- en: It’s best to run your delivery pipeline after every code commit, instead of
    at a certain time. Running tests with each code change gives you more granular
    and faster feedback than the crude nightly build that simply accumulates all changes
    from the previous day. But if, for some reason, you absolutely have to run your
    pipeline on a timely basis, at least run them continuously instead of once a day.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在每次代码提交后运行你的交付管道，而不是在特定时间。每次代码更改时运行测试，比仅仅积累前一天所有更改的粗略夜间构建提供更细粒度和更快的反馈。但如果由于某种原因，你绝对需要在规定时间内运行管道，至少要持续运行它们，而不是每天只运行一次。
- en: If your delivery pipeline build takes a long time, don’t wait for a magical
    trigger or schedule to run it. Imagine, as a developer, needing to wait until
    tomorrow to know if you broke something. With tests running continuously, you
    would still need to wait, but at least it would only be a couple of hours instead
    of a full day. Isn’t that more productive?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的交付管道构建过程耗时较长，不要等待魔法触发器或安排来运行它。想象一下，作为一个开发者，你需要等到明天才能知道你是否破坏了某些东西。随着测试的持续运行，你仍然需要等待，但至少只需要几个小时而不是整整一天。这不是更有效率吗？
- en: Also, don’t just run the build on demand. The feedback loop will be faster if
    you run the build automatically as soon as the previous one finishes, assuming
    there are code changes since the previous build, of course.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要仅在需要时运行构建。如果假设自上次构建以来有代码更改，那么在完成上一个构建后自动运行构建将使反馈循环更快。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'There are multiple levels of tests: unit, component, and integration tests
    that run in memory; and API, isolated end-to-end (E2E), and system E2E tests that
    run out of process.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试有多个层级：内存中运行的单元测试、组件测试和集成测试；以及运行在进程外的API、隔离端到端（E2E）和系统E2E测试。
- en: 'Each test can be judged by five criteria: complexity, flakiness, confidence
    when it passes, maintainability, and execution speed.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试都可以通过五个标准来评判：复杂性、易出错性、通过时的信心、可维护性和执行速度。
- en: 'Unit and component tests are best in terms of maintainability, execution speed,
    and lack of complexity and flakiness, but they’re worst in terms of the confidence
    they provide. Integration and API tests are the middle ground in the trade-off
    between confidence and the other metrics. E2E tests take the opposite approach
    from unit tests: they provide the best confidence but at the expense of maintainability,
    speed, complexity, and flakiness.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元和组件测试在可维护性、执行速度、缺乏复杂性和易出错性方面表现最佳，但在提供信心方面表现最差。集成和API测试在信心与其他指标之间的权衡中处于中间位置。端到端测试与单元测试采取相反的方法：它们提供最佳的信心，但代价是可维护性、速度、复杂性和易出错性。
- en: The *end-to-end-only antipattern* is when your build consists solely of E2E
    tests. The marginal value of each additional E2E test is low, while the maintenance
    costs of all tests are the same. You’ll get the most return on your efforts if
    you have just a few E2E tests covering the most important functionality.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试唯一反模式**是指你的构建过程仅包含端到端测试。每个额外端到端测试的边际价值很低，而所有测试的维护成本是相同的。如果你只有少数几个端到端测试覆盖最重要的功能，你将获得最大的努力回报。'
- en: The *low-level-only antipattern* is when your build consists solely of unit
    and component tests. Lower-level tests can’t provide enough confidence that your
    functionality as a whole works, and they must be supplemented with higher-level
    tests.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅低级测试反模式**是指你的构建过程仅包含单元和组件测试。低级测试无法提供足够的信心来确保整体功能正常工作，它们必须通过更高层级的测试来补充。'
- en: '*Disconnected low-level and high-level tests* is an antipattern because it’s
    a strong sign that your tests are written by two groups of people who don’t communicate
    with each other. Such tests often duplicate each other and carry high maintenance
    costs.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级与高级测试脱节**是一种反模式，因为这强烈表明你的测试是由两组不同的人编写的，他们之间没有沟通。这样的测试往往相互重复，并且维护成本很高。'
- en: '*A test recipe* is a simple list of 5 to 20 lines of text, detailing which
    simple scenarios should be tested in an automated fashion and at what level. A
    test recipe should give you confidence that, if all outlined tests pass, the feature
    works as intended.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试配方*是一份简单的5到20行的文本列表，详细说明应以自动化方式测试哪些简单场景以及测试的级别。测试配方应让您有信心，如果所有概述的测试都通过，则功能按预期工作。'
- en: Split your build pipeline into *delivery* and *discovery* pipelines. The delivery
    pipeline should be used for delivery-blocking tests, which, if they fail, stop
    delivery of the code under test. The discovery pipeline is used for good-to-know
    tests and runs in parallel with the delivery pipeline.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将构建管道拆分为*交付*和*发现*管道。交付管道应用于阻止交付的测试，如果测试失败，将停止测试代码的交付。发现管道用于需要了解的测试，并且与交付管道并行运行。
- en: You can parallelize not just pipelines but also stages inside those pipelines,
    and even groups of tests inside stages too.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不仅可以并行化管道，还可以并行化管道内的阶段，甚至阶段内的测试组。
