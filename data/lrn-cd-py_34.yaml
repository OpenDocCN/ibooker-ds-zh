- en: Lesson 28\. Aliasing and copying lists and dictionaries
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 28 课：别名和复制列表和字典
- en: After reading [lesson 28](#ch28), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第 28 课](#ch28) 后，你将能够
- en: Make aliases for mutable objects (lists and dictionaries)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可变对象（列表和字典）创建别名
- en: Make copies of mutable objects (lists and dictionaries)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对可变对象（列表和字典）进行复制
- en: Make sorted copies of lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对列表进行排序后的复制
- en: Remove elements from mutable objects based on certain criteria
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据某些标准从可变对象中删除元素
- en: 'Mutable objects are great to use because they allow you to modify the object
    itself without making a copy. When your mutable objects are large, this behavior
    makes sense because otherwise, making a copy of a large item every time you make
    a change to it is expensive and wasteful. But using mutable objects introduces
    a side effect that you need to be aware of: you can have more than one variable
    bound to the same mutable object, and the object can be mutated via both names.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象很方便使用，因为它们允许你修改对象本身而不需要复制。当你的可变对象很大时，这种行为是有意义的，因为否则每次对其做出更改时都复制一个大项是昂贵且浪费的。但是使用可变对象引入了一个你需要注意的副作用：你可以有多个变量绑定到同一个可变对象，并且可以通过这两个名称之一来修改对象。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Think of a famous person. What aliases do they have, or what other names or
    nicknames do they go by?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想想一个名人。他们有哪些别名，或者他们还有哪些其他名字或昵称？
- en: 'Answer: Bill Gates'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：比尔·盖茨
- en: 'Nicknames: Bill, William, William Gates, William Henry Gates III'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 昵称：比尔，威廉，威廉·盖茨，威廉·亨利·盖茨三世
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Suppose you have data on the famous computer scientist Grace Hopper. Let’s
    say Grace Hopper is an object, and her value is a list of labels: `["programmer",
    "admiral", "female"]`. To friends she might be known as *Grace*, to others as
    *Ms. Hopper*, and her nickname is *Amazing Grace*. All these names are aliases
    for the same person, the same object with the same string of labels. Now suppose
    that someone who knows her as Grace adds another value to her list of labels:
    `"deceased"`. To people who know her as Grace, her list of labels is now `["programmer",
    "admiral", "female", "deceased"]`. But because the labels refer to the same person,
    every other one of her aliases now also refers to the new list of labels.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一份关于著名计算机科学家格蕾丝·霍珀的数据。让我们说格蕾丝·霍珀是一个对象，她的值是一个标签列表：`["programmer", "admiral",
    "female"]`。对她来说，朋友们可能知道她叫 *Grace*，其他人可能叫 *Ms. Hopper*，她的昵称是 *Amazing Grace*。所有这些名字都是同一个人的别名，同一个具有相同标签字符串的对象。现在假设一个认识她叫
    Grace 的人向她的标签列表中添加另一个值：`"deceased"`。对于认识她叫 Grace 的人来说，她的标签列表现在是 `["programmer",
    "admiral", "female", "deceased"]`。但是由于标签指的是同一个人，她的其他所有别名现在也指向新的标签列表。
- en: 28.1\. Using object aliases
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.1\. 使用对象别名
- en: In Python, *variable names* are names that point to an object. The object resides
    at a specific location in computer memory. In [lesson 24](kindle_split_039.html#ch24),
    you used the `id()` function to see a numerical representation of the memory location
    of an object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，*变量名* 是指向对象的名称。该对象位于计算机内存中的特定位置。在 [第 24 课](kindle_split_039.html#ch24)
    中，你使用了 `id()` 函数来查看对象的内存位置的数值表示。
- en: 28.1.1\. Aliases of immutable objects
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.1.1\. 不可变对象的别名
- en: 'Before looking at mutable objects, let’s look at what happens when you use
    the assignment operator (equal sign) between two variable names that point to
    immutable objects. Type the following commands in the console and use the `id()`
    function to see the memory locations of the variables `a` and `b`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看可变对象之前，让我们看看当你使用两个指向不可变对象的变量名之间的赋值运算符（等号）时会发生什么。在控制台中输入以下命令，并使用 `id()` 函数查看变量
    `a` 和 `b` 的内存位置：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Out` lines tell you the output of the `id()` function. Notice that both
    `a` and `b` are names that point to the same object (an integer with value `1`).
    What happens if you change the object that `a` points to? In the following code,
    you reassign variable name `a` to point to a different object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Out` 行显示了 `id()` 函数的输出。注意，`a` 和 `b` 都是指向相同对象的名称（一个值为 `1` 的整数）。如果你改变 `a` 指向的对象会发生什么？在下面的代码中，你重新分配变量名
    `a` 以指向不同的对象：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the variable named `a` now points to a completely different object
    with a different memory location. But this operation doesn’t change the variable
    name to which `b` points, so the object that `b` points to is at the same memory
    location as before.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，名为 `a` 的变量现在指向一个完全不同的对象，具有不同的内存位置。但是这个操作并没有改变 `b` 指向的变量名，所以 `b` 指向的对象与之前相同的内存位置。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 28.1**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.1**'
- en: 'You have a variable named `x` that points to an immutable object with `x =
    "me"`. Running `id(x)` gives `2899205431680`. For each of the following lines,
    determine whether the ID of that variable will be the same as `id(x)`. Assume
    that the lines are executed one after another:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个名为 `x` 的变量，它指向一个不可变对象，`x = "me"`。运行 `id(x)` 会得到 `2899205431680`。对于以下每一行，确定该变量的
    ID 是否与 `id(x)` 相同。假设这些行依次执行：
- en: '**[1](kindle_split_056.html#app01qa114q0a1)**'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa114q0a1)**'
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**[2](kindle_split_056.html#app01qa114q0a2)**'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa114q0a2)**'
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**[3](kindle_split_056.html#app01qa114q0a3)**'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa114q0a3)**'
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.1.2\. Aliases of mutable objects
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.1.2\. 可变对象的别名
- en: 'You can do the same sequence of commands as in [section 28.1.1](#ch28lev2sec1)
    on a mutable object, such as a list. In the following code, you can see that using
    the assignment operator between a variable name that points to a list behaves
    in the same way as with an immutable object. Using the assignment operator on
    a mutable object doesn’t make a copy; it makes an alias. An *alias* is another
    name for the same object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在可变对象上执行与 [28.1.1 节](#ch28lev2sec1) 中相同的命令序列，例如列表。在下面的代码中，你可以看到使用指向列表的变量名之间的赋值运算符的行为与不可变对象相同。在可变对象上使用赋值运算符不会创建副本；它创建了一个别名。*别名*
    是对同一对象的另一个名称：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The memory location that objects `genius` and `smart` point to are the same
    because they point to the same object. [Figure 28.1](#ch28fig01) shows how the
    variables `smart` and `genius` point to the same object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `genius` 和 `smart` 指向的内存位置相同，因为它们指向同一个对象。[图 28.1](#ch28fig01) 展示了变量 `smart`
    和 `genius` 如何指向同一个对象。
- en: Figure 28.1\. In the left panel, you create the variable `genius` pointing to
    the list `["einstein", "galileo"]`. In the right panel, the variable `smart` points
    to the same object as `genius`.
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 28.1\. 在左侧面板中，你创建了指向列表 `["einstein", "galileo"]` 的变量 `genius`。在右侧面板中，变量 `smart`
    指向与 `genius` 相同的对象。
- en: '![](images/28fig01_alt.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](images/28fig01_alt.jpg)'
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.2**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.2**'
- en: 'You have a variable named `x` that points to a mutable object with `x = ["me",
    "I"]`. Running `id(x)` gives `2899318311816`. For each of the following lines,
    determine whether the ID of that variable will be the same as `id(x)`. Assume
    that the lines are executed one after another:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个名为 `x` 的变量，它指向一个可变对象，`x = ["me", "I"]`。运行 `id(x)` 会得到 `2899318311816`。对于以下每一行，确定该变量的
    ID 是否与 `id(x)` 相同。假设这些行依次执行：
- en: '**[1](kindle_split_056.html#app01qa115q0a1)**'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa115q0a1)**'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`y = x # what is id(y)`'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`y = x # y 的 id 是什么`'
- en: '**[2](kindle_split_056.html#app01qa115q0a2)**'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa115q0a2)**'
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`z = y # what is id(z)`'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`z = y # z 的 id 是什么`'
- en: '**[3](kindle_split_056.html#app01qa115q0a3)**'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa115q0a3)**'
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a = ["me", "I"] # what is id(a)`'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a = ["me", "I"] # a 的 id 是什么`'
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The difference between mutable and immutable objects is evident in the next
    set of commands, when you mutate the list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象和不可变对象之间的区别在下一组命令中很明显，当你修改列表时：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you modify a mutable object, the object itself is changed. When you append
    a value to the list pointed to by `genius`, the list object itself is changed.
    Variable names `genius` and `smart` still point to the same object at the same
    memory location. The object pointed to by variable name `smart` is also changed
    (because it points to the same thing as the variable `genius`). This is shown
    in [figure 28.2](#ch28fig02).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改一个可变对象时，对象本身会发生变化。当你向 `genius` 指向的列表中添加值时，列表对象本身会发生变化。变量名 `genius` 和 `smart`
    仍然指向相同的对象和相同的内存位置。变量名 `smart` 指向的对象也会发生变化（因为它指向与变量 `genius` 相同的东西）。这如图 28.2 所示。
- en: Figure 28.2\. When the list object `["einstein", "galileo"]` is modified through
    the variable `genius`, the variable `smart` also points to the modified list object.
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 28.2\. 当通过变量 `genius` 修改列表对象 `["einstein", "galileo"]` 时，变量 `smart` 也指向被修改的列表对象。
- en: '![](images/28fig02_alt.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](images/28fig02_alt.jpg)'
- en: Using the equal sign between mutable lists implies that if you modify the list
    through one variable name, all other variable names pointing to the same list
    will point to the mutated value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在可变列表之间使用等号意味着，如果你通过一个变量名修改列表，所有指向同一列表的其他变量名都将指向被修改的值。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.3**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.3**'
- en: 'You have a variable named `x` that points to a mutable object with `x = ["me",
    "I"]`. For each of the following points, answer the question:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个名为 `x` 的变量，它指向一个可变对象，`x = ["me", "I"]`。对于以下每个点，回答问题：
- en: '**[1](kindle_split_056.html#app01qa116q0a1)**'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa116q0a1)**'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does `x` change after the following lines are executed?
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下行之后，`x` 发生变化了吗？
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**[2](kindle_split_056.html#app01qa116q0a2)**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa116q0a2)**'
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does `x` change after the following lines are executed?
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下行之后，`x` 发生变化了吗？
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**[3](kindle_split_056.html#app01qa116q0a3)**'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa116q0a3)**'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does `x` change after the following lines are executed?
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下行之后，`x` 发生变化了吗？
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**[4](kindle_split_056.html#app01qa116q0a4)**'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa116q0a4)**'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does `x` change after the following lines are executed?
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下行之后，`x` 发生变化了吗？
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**[5](kindle_split_056.html#app01qa116q0a5)**'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](kindle_split_056.html#app01qa116q0a5)**'
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does `x` change after the following lines are executed?
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下行之后，`x` 发生变化了吗？
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.1.3\. Mutable objects as function parameters
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.1.3\. 可变对象作为函数参数
- en: In [unit 5](kindle_split_033.html#part06), you saw that variables inside a function
    are independent of variables outside the function. You could have a variable named
    `x` outside the function and a variable named `x` as a parameter to the function.
    They don’t interfere with each other because of scoping rules. When working with
    mutable objects, passing mutable objects as actual parameters to a function implies
    that the actual parameter to the function will be an alias.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 单元](kindle_split_033.html#part06) 中，你看到函数内部的变量与函数外部的变量是独立的。你可以在函数外部有一个名为
    `x` 的变量，在函数内部有一个名为 `x` 的参数。由于作用域规则，它们不会相互干扰。当处理可变对象时，将可变对象作为实际参数传递给函数意味着实际参数将是别名。
- en: '[Listing 28.1](#ch28ex01) shows code that implements a function. The function
    is named `add_word()`. Its input parameters are a dictionary, a word, and a definition.
    The function mutates the dictionary so that even when accessed outside the function,
    the dictionary contains the newly added word. The code then calls the function
    with a dictionary named `words` as the actual parameter. In the function call,
    the dictionary named `d` is the formal parameter and is now an alias for the dictionary
    `words`. Any changes made to `d` inside the function reflect when you access the
    dictionary `words`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 28.1](#ch28ex01) 展示了实现函数的代码。该函数名为 `add_word()`。它的输入参数是一个字典、一个单词和一个定义。该函数会修改字典，使得即使在外部访问时，字典也包含新添加的单词。然后代码使用名为
    `words` 的字典作为实际参数调用该函数。在函数调用中，名为 `d` 的形式参数现在是字典 `words` 的别名。在函数内部对 `d` 的任何修改都会反映在访问字典
    `words` 时。'
- en: Listing 28.1\. Function that mutates a dictionary
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.1\. 修改字典的函数
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* A function that takes in a dictionary, a string (word), and another string
    (definition)**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 接受字典、字符串（单词）和另一个字符串（定义）作为参数的函数**'
- en: '***2* Word in dictionary**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 字典中的单词**'
- en: '***3* Adds definition to end of key’s value list**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将定义添加到键的值列表的末尾**'
- en: '***4* Word not in dictionary**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 字典中不存在的单词**'
- en: '***5* Makes new list with one word as the key’s value**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用一个单词作为键的值创建新的列表**'
- en: '***6* Outside function; creates an empty dictionary**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 函数外部；创建一个空字典**'
- en: '***7* Calls the function with the dictionary named “words” as the actual parameter**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用名为“words”的字典作为实际参数调用函数**'
- en: '***8* Prints {‘box’: [‘fight’]}**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 打印 `{‘box’: [‘fight’]}`**'
- en: '***9* Calls the function again to append to the value for the key “box”**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 再次调用函数以向“box”键的值追加**'
- en: '***10* Prints {‘box’: [‘fight’, ‘container’]}**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 打印 `{‘box’: [‘fight’, ‘container’]}`**'
- en: '***11* Prints {‘ox’: [‘animal’], ‘box’: [‘fight’, ‘container’]}**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 打印 `{‘ox’: [‘animal’], ‘box’: [‘fight’, ‘container’]}`**'
- en: '***12* Calls the function again to add another entry**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12* 再次调用函数以添加另一个条目**'
- en: 28.2\. Making copies of mutable objects
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.2\. 可变对象的复制
- en: 'When you want to make a copy of a mutable object, you need to use a function
    that makes it clear to Python that you want to make a copy. There are two ways
    to do this: make a new list with the same elements as another list, or use a function.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想复制一个可变对象时，你需要使用一个函数来明确告诉 Python 你想要复制。有两种方法可以实现这一点：使用与另一个列表相同元素的新列表，或者使用一个函数。
- en: 28.2.1\. Commands to copy mutable objects
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.1\. 复制可变对象的命令
- en: 'One way to make a copy is to make a new list object with the same values as
    the other one. Given a list `artists` with some elements, the following command
    creates a new list object and binds the variable name `painters` to it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的一种方法是通过创建一个具有与另一个列表相同值的新列表对象。给定一个包含一些元素的列表 `artists`，以下命令创建了一个新的列表对象，并将变量名
    `painters` 绑定到它：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The new list object has the same elements as `artists`. For example, the following
    code shows that the objects that lists `painters` and `artists` point to are different
    because modifying one doesn’t modify the other:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 新的列表对象具有与 `artists` 相同的元素。例如，以下代码显示列表 `painters` 和 `artists` 指向的对象是不同的，因为修改一个不会修改另一个：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The other way is to use the `copy()` function. If `artists` is a list, the
    following command creates a new object that has the same elements as `artists`,
    but copied into the new object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `copy()` 函数。如果 `artists` 是一个列表，以下命令创建了一个新对象，它具有与 `artists` 相同的元素，但被复制到新对象中：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code shows how to use the `copy` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 `copy` 命令：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the console output, you can see that the list objects pointed to by `painters`
    and `artists` are separate because making changes to one doesn’t affect the other.
    [Figure 28.3](#ch28fig03) shows what it means to make a copy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制台输出中，你可以看到 `painters` 和 `artists` 指向的列表对象是分开的，因为对一个对象的修改不会影响另一个对象。[图 28.3](#ch28fig03)
    展示了复制操作的含义。
- en: Figure 28.3\. In the panel on the left, making a copy of the object `["monet",
    "picasso"]` makes a new object with the same elements. In the panel on the right,
    you can mutate one object without interfering with the other object.
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 28.3\. 在左侧面板中，复制对象 `["monet", "picasso"]` 创建了一个具有相同元素的新对象。在右侧面板中，你可以修改一个对象而不会干扰另一个对象。
- en: '![](images/28fig03_alt.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/28fig03_alt.jpg)'
- en: 28.2.2\. Getting copies of sorted lists
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.2\. 获取排序列表的副本
- en: You saw that you can sort a list so that the list itself is modified directly.
    For a list `L`, the command is `L.sort()`. In some situations, you’d like to keep
    your original list and get a sorted copy of the list, while keeping the original
    unchanged.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到你可以对列表进行排序，使列表本身直接被修改。对于列表 `L`，命令是 `L.sort()`。在某些情况下，你可能希望保留原始列表并获取列表的排序副本，同时保持原始列表不变。
- en: 'Instead of making a copy of the list and then sorting the copy, Python has
    a function that allows you to do it in one line. The following command shows a
    function that returns a sorted version of a list and stores it in another list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个函数允许你在单行中完成复制列表并排序的操作。以下命令显示了一个返回列表排序版本并将其存储在另一个列表中的函数：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that the variable `sorted_ages` points to a sorted list, but the
    original list `kid_ages` remains unchanged. Previously, when you wrote the command
    `kid_ages.sort(), kid_ages` would be changed so that it got sorted without a copy
    being made.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到变量 `sorted_ages` 指向一个排序后的列表，但原始列表 `kid_ages` 保持不变。之前，当你写下命令 `kid_ages.sort()`
    时，`kid_ages` 会改变，使其排序而不创建副本。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 28.4**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 28.4**'
- en: 'Write a line of code that achieves each of the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一行代码以实现以下每个目标：
- en: '**[1](kindle_split_056.html#app01qa117q0a1)**'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa117q0a1)**'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Creates a variable named `order` that’s a sorted copy of a list named `chaos`
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个名为 `order` 的变量，它是名为 `chaos` 的列表的排序副本
- en: '**[2](kindle_split_056.html#app01qa117q0a2)**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa117q0a2)**'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sorts a list named `colors`
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对名为 `colors` 的列表进行排序
- en: '**[3](kindle_split_056.html#app01qa117q0a3)**'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa117q0a3)**'
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sorts a list named `deck` and aliases it to a variable named `cards`
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对名为 `deck` 的列表进行排序，并将其别名设置为名为 `cards` 的变量
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 28.2.3\. A word of caution when iterating over mutable objects
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.3\. 在迭代可变对象时的注意事项
- en: Often you want to have code that removes items from a mutable object, provided
    they meet some sort of criteria. For example, suppose you have a dictionary of
    songs and their ratings. You want to remove all songs from the dictionary that
    have a rating of 1.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要编写代码从可变对象中删除满足某些条件的项。例如，假设你有一个包含歌曲及其评分的字典。你想从字典中删除所有评分为 1 的歌曲。
- en: '[Listing 28.2](#ch28ex02) tries (but fails) to accomplish this. The code iterates
    through every key in the dictionary. It checks whether the value associated with
    that key is a `1`. If so, it removes the pair from the dictionary. The code fails
    to run and shows the error message `RuntimeError: dictionary changed size during
    iteration`. Python doesn’t allow you to change the size of a dictionary as you’re
    iterating over it.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 28.2](#ch28ex02) 尝试（但失败）完成此操作。代码遍历字典中的每个键。它检查与该键关联的值是否为 `1`。如果是，它从字典中删除该键值对。代码运行失败并显示错误消息
    `RuntimeError: dictionary changed size during iteration`。Python 不允许你在迭代字典时更改字典的大小。'
- en: Listing 28.2\. Attempt to remove elements from a dictionary while iterating
    over it
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.2\. 在迭代字典时尝试从字典中删除元素
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* songs dictionary**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首歌曲字典**'
- en: '***2* Iterates through every pair**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历每一对**'
- en: '***3* If the rating value is 1...**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果评分值为 1...**'
- en: '***4* ...removes the song with that value**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* ...删除具有该值的歌曲**'
- en: 'Suppose you try to do the same thing, except that instead of a dictionary,
    you have a list. The following listing shows how you might accomplish this, but
    also fails to do the right thing. The code doesn’t fail this time. But it has
    a behavior different from what you expected; it gives the wrong value for `songs`:
    `[1, 5, 4]` instead of `[5, 4]`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你尝试做同样的事情，但这次不是使用字典，而是使用列表。以下列表显示了你可以如何完成这个任务，但它也未能正确执行。这次代码没有失败。但它具有与预期不同的行为；它为
    `songs` 提供了错误的值：`[1, 5, 4]` 而不是 `[5, 4]`。
- en: Listing 28.3\. Attempt to remove elements from a list while iterating over it
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.3\. 尝试在遍历列表的同时删除元素
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Song rating list**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 歌曲评分列表**'
- en: '***2* Iterates through every rating**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历每个评分**'
- en: '***3* If the rating value is 1...**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果评分值为 1...**'
- en: '***4* ...removes the song with that value**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* ...删除具有该值的歌曲**'
- en: '***5* Prints [1,5,4]**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印 [1,5,4]**'
- en: You can see the buggy effect of removing items from a list while iterating over
    it. The loop gets to the element at index 0, sees that it’s a `1`, and removes
    it from the list. The list is now `[1, 5, 4]`. Next, the loop looks at the element
    at index 1\. This element is now from the mutated list `[1, 5, 4]`, so it looks
    at the number 5\. This number isn’t equal to 1, so it doesn’t remove it. Then
    it finally looks at the element at index 2 from the list `[1, 5, 4]`, the number
    4\. It’s also not equal to 1, so it keeps it. The issue here is that when you
    popped the first 1 you saw, you decreased the length of the list. Now the index
    count is one off from the original list. Effectively, the second 1 in the original
    list `[1, 1, 5, 4]` was skipped.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在遍历列表的同时删除项目时的错误效果。循环到达索引 0 的元素，看到它是 `1`，并将其从列表中删除。现在列表是 `[1, 5, 4]`。接下来，循环查看索引
    1 的元素。这个元素现在来自已更改的列表 `[1, 5, 4]`，因此它查看数字 5。这个数字不等于 1，所以它没有删除它。然后它最终查看列表 `[1, 5,
    4]` 中索引 2 的元素，数字 4。它也不等于 1，所以它保留它。这里的问题是，当你弹出你看到的第一个 1 时，你减少了列表的长度。现在索引计数比原始列表少一个。实际上，原始列表
    `[1, 1, 5, 4]` 中的第二个 1 被跳过了。
- en: If you ever need to remove (or add) items to a list, you’ll first make a copy.
    You can iterate over the list copy and then start fresh on the original list by
    adding items you want to keep, as you iterate over the copied list. The following
    listing shows how to modify the code in [listing 28.3](#ch28ex03) to do the right
    thing. This code doesn’t cause an error, and the correct value for `songs` is
    now `[5, 4]`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从列表中删除（或添加）项目，你首先需要创建一个副本。你可以遍历列表副本，然后在原始列表上重新开始，通过在遍历副本时添加你想要保留的项目。以下列表显示了如何修改
    [列表 28.3](#ch28ex03) 中的代码以正确执行。这段代码不会引发错误，现在 `songs` 的正确值现在是 `[5, 4]`。
- en: Listing 28.4\. A correct way to remove elements from a list while iterating
    over it
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 28.4\. 在遍历列表的同时正确删除元素的方法
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Original ratings list**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 原始评分列表**'
- en: '***2* Makes a copy of the object**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建对象的副本**'
- en: '***3* Sets original list to be empty**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将原始列表设置为空**'
- en: '***4* For every rating in the list**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 遍历列表中的每个评分**'
- en: '***5* If the rating is one to keep...**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果评分需要保留...**'
- en: '***6* ...adds the rating to the original list**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* ...将评分添加到原始列表中**'
- en: '***7* Prints [5,4]**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 打印 [5,4]**'
- en: 28.2.4\. Why does aliasing exist?
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 28.2.4\. 为什么存在别名？
- en: If aliasing an object introduces the problem of inadvertently mutating an object
    you didn’t intend to change, why use aliasing in the first place? Why not just
    make copies all the time? All Python objects are stored in computer memory. Lists
    and dictionaries are “heavy” objects, unlike an integer or a Boolean. If you make
    copies, for example, every time you make a function call, this can severely cripple
    the program with many function calls. If you have a list of the names of all people
    in the United States, copying that list every time you want to add someone new
    can be slow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果别名一个对象引入了意外更改你未打算更改的对象的问题，为什么一开始要使用别名？为什么不总是创建副本？所有 Python 对象都存储在计算机内存中。列表和字典是“重”对象，与整数或布尔值不同。例如，每次你进行函数调用时，创建副本可能会严重削弱程序，特别是当有大量函数调用时。如果你有一个包含美国所有人名的列表，每次你想添加新的人名时都要复制这个列表，这可能会很慢。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you about subtleties of dealing with
    mutable objects. Mutable objects are useful because they can store a lot of data
    that can easily be modified in place. Because you’re dealing with mutable objects
    that contain many elements, making copies with every operation becomes inefficient
    in terms of computer time and space. By default, Python aliases objects so that
    using the assignment operator makes a new variable that points to the same object;
    this is called an *alias*. Python recognizes that in some situations you want
    to make a copy of a mutable object, and it allows you to explicitly tell it that
    you want to do so. Here are the major takeaways:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你关于处理可变对象的细微差别。可变对象很有用，因为它们可以存储大量易于修改的数据。由于你处理的是包含许多元素的可变对象，因此每次操作都进行复制在计算机时间和空间效率上变得低效。默认情况下，Python
    为对象提供别名，使用赋值运算符创建一个指向同一对象的新变量；这被称为 *别名*。Python 认识到在某些情况下，你可能想要创建一个可变对象的副本，并允许你明确地告诉它你想这样做。以下是主要收获：
- en: Python aliases all object types.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 为所有对象类型提供了别名。
- en: Aliasing a mutable object may lead to unexpected side effects.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名可变对象可能会导致意外的副作用。
- en: Modifying a mutable object through one alias leads to seeing the change through
    all other aliases of that object.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个别名修改可变对象会导致通过该对象的所有其他别名看到变化。
- en: You can make a copy of a mutable object by making a new object and copying over
    all elements of the original one.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过创建一个新的对象并复制原始对象的所有元素来创建一个可变对象的副本。
- en: Let’s see if you got this...
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了...
- en: '**[Q28.1](kindle_split_056.html#app01qa118q0a1)**'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q28.1](kindle_split_056.html#app01qa118q0a1)**'
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function named `invert_dict` that takes as input a dictionary. The function
    returns a new dictionary; the values are now the original keys, and the keys are
    now the original values. Assume that the values of the input dictionary are immutable
    and unique.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个名为 `invert_dict` 的函数，该函数接受一个字典作为输入。该函数返回一个新的字典；现在的值是原来的键，现在的键是原来的值。假设输入字典的值是不可变的且唯一的。
- en: '**[Q28.2](kindle_split_056.html#app01qa118q0a2)**'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q28.2](kindle_split_056.html#app01qa118q0a2)**'
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function named `invert_dict_inplace` that takes as input a dictionary.
    The function doesn’t return anything. It mutates the dictionary passed in so that
    the values are now the original keys, and the keys are now the original values.
    Assume that the values of the input dictionary are immutable and unique.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个名为 `invert_dict_inplace` 的函数，该函数接受一个字典作为输入。该函数不返回任何内容。它修改传入的字典，使得值现在是原来的键，键现在是原来的值。假设输入字典的值是不可变的且唯一的。
