- en: '6 Words count: Reading files and STDIN, iterating lists, formatting strings'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 单词计数：读取文件和STDIN，迭代列表，格式化字符串
- en: “I love to count!”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我喜欢计数！”
- en: --Count von Count
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: --Count von Count
- en: '| Counting things is a surprisingly important programming skill. Maybe you’re
    trying to find out how many pizzas were sold each quarter or how many times you
    see certain words in a set of documents. Usually the data we deal with in computing
    comes to us in files, so in this chapter, we’re going to push a little further
    into reading files and manipulating strings. | ![](../Images/6-unnumb-1.png)  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 计数事物是一个令人惊讶的重要编程技能。也许你正在尝试找出每个季度卖出了多少披萨，或者你在一组文档中看到某些单词的次数。通常我们在计算机处理的数据以文件的形式到来，所以在本章中，我们将进一步探讨读取文件和操作字符串。
    | ![图片](../Images/6-unnumb-1.png) |'
- en: 'We’re going to write a Python version of the venerable `wc` (“word count”)
    program. Ours will be called wc.py, and it will count the lines, words, and bytes
    found in each input supplied as one or more positional arguments. The counts will
    appear in columns eight characters wide, and they will be followed by the name
    of the file. For instance, here is what wc.py should print for one file:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个Python版本的备受推崇的`wc`（“单词计数”）程序。我们的程序将命名为wc.py，它将计算每个输入参数中找到的行数、单词数和字节数。计数结果将显示在宽度为八个字符的列中，并跟随着文件名。例如，以下是wc.py应该为单个文件打印的内容：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When counting multiple files, there will be an additional “total” line summing
    each column:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算多个文件时，将会有一个额外的“总计”行，汇总每一列：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There may also be *no* arguments, in which case we’ll read from *standard in*,
    which is often written as `STDIN`. We started talking about `STDOUT` in chapter
    5 when we used `sys.stdout` as a file handle. `STDIN` is the complement to `STDOUT`--it’s
    the “standard” place to read input on the command line. When our program is given
    *no* positional arguments, it will read from `sys.stdin`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能没有参数，在这种情况下，我们将从标准输入读取，通常写作`STDIN`。我们在第5章中提到`STDOUT`时，将其用作文件句柄。`STDIN`是`STDOUT`的补充——它是命令行上读取输入的“标准”位置。当我们的程序没有提供任何位置参数时，它将从`sys.stdin`读取。
- en: '`STDIN` and `STDOUT` are common file handles that many command-line programs
    recognize. We can chain the `STDOUT` from one program to the `STDIN` of another
    to create ad hoc programs. For instance, the `cat` program will print the contents
    of a file to `STDOUT`. We can use the pipe operator (`|`) to funnel that output
    as input into our program via `STDIN`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`STDIN`和`STDOUT`是许多命令行程序识别的常见文件句柄。我们可以将一个程序的`STDOUT`链接到另一个程序的`STDIN`，以创建临时程序。例如，`cat`程序会将文件内容打印到`STDOUT`。我们可以使用管道操作符（`|`）将输出作为输入通过`STDIN`传递到我们的程序中：'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another option is to use the `<` operator to redirect input from a file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`<`操作符从文件重定向输入：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One of the handiest command-line tools is `grep`, which can find patterns of
    text in files. If, for instance, we wanted to find all the lines of text that
    contain the word “scarlet” in all the files in the inputs directory, we could
    use this command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最实用的命令行工具之一是`grep`，它可以在文件中找到文本模式。例如，如果我们想在输入目录中的所有文件中找到包含单词“scarlet”的所有行文本，我们可以使用以下命令：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the command line, the asterisk (`*`) is a wildcard that will match anything,
    so `*.txt` will match any file ending with “.txt.” If you run the preceding command,
    you’ll see quite a bit of output.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，星号（`*`）是一个通配符，可以匹配任何内容，所以`*.txt`将匹配任何以“`.txt`”结尾的文件。如果你运行前面的命令，你会看到相当多的输出。
- en: 'To count the lines found by `grep`, we can pipe that output into our wc.py
    program like so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算`grep`找到的行数，我们可以将那个输出通过以下方式管道输入到我们的wc.py程序中：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can verify that this matches what `wc` finds:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证这和`wc`找到的结果是否一致：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this chapter, you will
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将
- en: Learn how to process zero or more positional arguments
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何处理零个或多个位置参数
- en: Validate input files
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入文件
- en: Read from files or from standard input
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件或从标准输入读取
- en: Use multiple levels of `for` loops
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多级`for`循环
- en: Break files into lines, words, and bytes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件拆分为行、单词和字节
- en: Use counter variables
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计数变量
- en: Format string output
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化字符串输出
- en: 6.1 Writing wc.py
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 编写wc.py
- en: 'Let’s get started! Create a program called wc.py in the 06_wc directory, and
    modify the arguments until it will print the following usage if run with the `-h`
    or `--help` flags:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！在06_wc目录下创建一个名为wc.py的程序，并修改参数，直到它使用`-h`或`--help`标志运行时打印以下用法：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Given a nonexistent file, your program should print an error message and exit
    with a nonzero exit value:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序遇到一个不存在的文件，它应该打印一条错误消息并退出，退出码不为零：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Figure 6.1 is a string diagram that will help you think about how the program
    should work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 是一个字符串图，将帮助你思考程序应该如何工作。
- en: 6.1.1 Defining file inputs
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 定义文件输入
- en: Let’s talk about how we can define the program’s parameters using `argparse`.
    This program takes *zero or more* positional arguments and nothing else. Remember
    that you never have to define the `-h` or `--help` arguments, as `argparse` handles
    those automatically.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈如何使用 `argparse` 定义程序的参数。此程序接受 *零个或多个* 位置参数，不接受其他任何参数。记住，你永远不需要定义 `-h` 或
    `--help` 参数，因为 `argparse` 会自动处理这些。
- en: In chapter 3 we used `nargs='+'` to indicate one or more items for our picnic.
    Here we want to use `nargs='*'` to indicate *zero* or more. When there are no
    arguments, the default value will be `None`. For this program, we’ll read `STDIN`
    when there are no arguments.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，我们使用 `nargs='+'` 来表示野餐的一个或多个项目。这里我们想使用 `nargs='*'` 来表示 *零个*。如果没有参数，默认值将是
    `None`。对于这个程序，如果没有参数，我们将读取 `STDIN`。
- en: '![](../Images/6-1.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-1.png)'
- en: Figure 6.1 A string diagram showing that wc.py will read one or more file inputs
    or possibly `STDIN` and will produce a summary of the words, lines, and bytes
    contained in each input.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 一个字符串图，显示 wc.py 将读取一个或多个文件输入或可能 `STDIN`，并将生成每个输入中包含的单词、行和字节的摘要。
- en: All of the possible values for `nargs` are listed in table 6.1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`nargs` 的所有可能值列在表 6.1 中。'
- en: Table 6.1 Possible values for `nargs`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 `nargs` 的可能值
- en: '| Symbol | Meaning |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 |'
- en: '| ? | Zero or one |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| ? | 零个或一个 |'
- en: '| * | Zero or more |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| * | 零个或多个 |'
- en: '| + | One or more |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| + | 一个或多个 |'
- en: Any arguments that are provided to our program *must be readable files*. In
    chapter 5 you learned how to test whether the input argument was a file by using
    `os.path.isfile()`. The input was allowed to be either plain text or a filename,
    so you had to check this yourself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何提供给我们的程序 *必须是可以读取的文件*。在第 5 章中，你学习了如何使用 `os.path.isfile()` 测试输入参数是否为文件。输入可以是纯文本或文件名，因此你必须自己检查这一点。
- en: In this program, the input arguments are required to be readable text files,
    so we can define our arguments using `type=argparse.FileType('rt')`. This means
    that `argparse` takes on all the work of validating the inputs from the user and
    producing useful error messages. If the user provides valid input, `argparse`
    will provide a `list` of *open file handles*. All in all, this will save us quite
    a bit of time. (Be sure to review section A.4.6 on file arguments in the appendix.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，输入参数必须是可以读取的文本文件，因此我们可以使用 `type=argparse.FileType('rt')` 定义我们的参数。这意味着
    `argparse` 会承担所有验证用户输入并产生有用错误信息的工作。如果用户提供了有效的输入，`argparse` 将提供一个 *打开的文件句柄列表*。总的来说，这将为我们节省很多时间。（请务必查阅附录中的
    A.4.6 节关于文件参数的内容。）
- en: In chapter 5 we used `sys.stdout` to write to `STDOUT`. To read from `STDIN`
    here, we’ll use Python’s `sys.stdin` file handle. Like `sys.stdout`, the `sys.stdin`
    file handle does not need an `open()`--it’s always present and available for reading.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，我们使用 `sys.stdout` 将内容写入 `STDOUT`。在这里从 `STDIN` 读取，我们将使用 Python 的 `sys.stdin`
    文件句柄。与 `sys.stdout` 类似，`sys.stdin` 文件句柄不需要 `open()`，它始终存在并可读取。
- en: 'Because we are using `nargs=''*''` to define our argument, the result will
    always be a `list`. To set `sys.stdin` as the `default` value, we should place
    it in a `list` like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用 `nargs='*'` 来定义我们的参数，所以结果将始终是一个 `list`。为了将 `sys.stdin` 设置为 `default`
    值，我们应该将其放在一个 `list` 中，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Zero or more of this argument
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ① 零个或多个此参数
- en: ② If arguments are provided, they must be readable text files. The files will
    be opened by argparse and will be provided as file handles.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果提供了参数，它们必须是可读的文本文件。这些文件将由 argparse 打开，并作为文件句柄提供。
- en: ③ The default will be a list containing sys.stdin, which is like an open file
    handle to STDIN. We do not need to open it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 默认值将是一个包含 `sys.stdin` 的列表，它类似于打开的文件句柄到 `STDIN`。我们不需要打开它。
- en: 6.1.2 Iterating lists
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 列表迭代
- en: 'Your program will end up with a `list` of file handles that will need to be
    processed. In chapter 4 we used a `for` loop to iterate through the characters
    in the input text. Here we can use a `for` loop over the `args.file` inputs, which
    will be open file handles:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序最终将得到一个需要处理的 `file handle` 列表。在第 4 章中，我们使用 `for` 循环遍历输入文本中的字符。这里我们可以使用 `for`
    循环遍历 `args.file` 输入，这些将是打开的文件句柄：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can give whatever name you like to the variable you use in your `for` loop,
    but I think it’s very important to give it a semantically meaningful name. Here
    the variable name `fh` reminds me that this is an open file handle. You saw in
    chapter 5 how to manually `open()` and `read()` a file. Here `fh` is already open,
    so we can use it directly to read the contents.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为在`for`循环中使用的变量取任何名字，但我认为给它一个语义上有意义的名字非常重要。在这里，变量名`fh`让我想起这是一个打开的文件句柄。你在第5章中看到了如何手动`open()`和`read()`一个文件。在这里`fh`已经打开，所以我们可以直接用它来读取内容。
- en: There are many ways to read a file. The `fh.read()` method will give you the
    *entire contents* of the file in one go. If the file is large--if it exceeds the
    available memory on your machine--your program will crash. I would recommend,
    instead, that you use another `for` loop on the `fh`. Python will understand this
    to mean that you wish to read each `line` of the file handle, one at a time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件有许多方法。`fh.read()`方法会一次性给你文件的*全部内容*。如果文件很大——如果它超过了你机器上的可用内存——你的程序将会崩溃。我建议，相反，你在`fh`上使用另一个`for`循环。Python会理解这意味着你希望逐行读取文件句柄。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That’s two levels of `for` loops, one for each file handle and then another
    for each line in each file handle. ONE LOOP! TWO LOOPS! I LOVE TO COUNT!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有两层`for`循环，每一层对应一个文件句柄，然后是每个文件句柄中的每一行。一个循环！两个循环！我喜欢计数！
- en: 6.1.3 What you’re counting
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 你在计数什么
- en: The output for each file will be the number of lines, words, and bytes (like
    characters and whitespace), each of which is printed in a field eight characters
    wide, followed by a space and then the name of the file, which will be available
    to you via `fh.name`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件的输出将是行数、单词数和字节数（如字符和空白），每个都在宽度为八个字符的字段中打印，然后是一个空格，然后是文件名，这可以通过`fh.name`获得。
- en: 'Let’s take a look at the output from the standard `wc` program on my system.
    Notice that when it’s run with just one argument, it produces counts only for
    that file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我的系统上标准`wc`程序的输出。注意，当它只带一个参数运行时，它只会为那个文件产生计数：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The fox.txt file is short enough that you could manually verify that it does
    in fact contain 1 line, 9 words, and 45 bytes, which includes all the characters,
    spaces, and the trailing newline (see figure 6.2).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: fox.txt文件足够短，以至于你可以手动验证它确实包含1行，9个单词，和45个字节，这包括所有字符、空格和尾随换行符（见图6.2）。
- en: '![](../Images/6-2.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-2.png)'
- en: Figure 6.2 The fox.txt file contains 1 line of text, 9 words, and a total of
    45 bytes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 fox.txt文件包含1行文本，9个单词，总共45个字节。
- en: 'When run with multiple files, the standard `wc` program also shows a “total”
    line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行多个文件时，标准`wc`程序也会显示一个“总计”行：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are going to emulate the behavior of this program. For each file, you will
    need to create variables to hold the numbers of lines, words, and bytes. For instance,
    if you use the `for` `line` `in` `fh` loop that I suggest, you will need to have
    a variable like `num_lines` to increment on each iteration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟这个程序的行为。对于每个文件，你需要创建变量来保存行数、单词数和字节数。例如，如果你使用我建议的`for line in fh`循环，你需要有一个像`num_lines`这样的变量，在每次迭代中增加。
- en: 'That is, somewhere in your code you will need to set a variable to `0` and
    then, inside the `for` loop, make it go up by 1\. The idiom in Python is to use
    the `+=` operator to add some value on the right side to the variable on the left
    side (as shown in figure 6.3):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在你的代码中，你需要设置一个变量为`0`，然后，在`for`循环内部，让它每次增加`1`。在Python中，这种做法通常是通过使用`+=`运算符将右侧的值添加到左侧的变量上（如图6.3所示）：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/6-3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-3.png)'
- en: Figure 6.3 The `+=` operator will add the value on the right to the variable
    on the left.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 `+=`运算符将右侧的值添加到左侧的变量上。
- en: You will also need to count the number of words and bytes, so you’ll need similar
    `num_words` and `num_bytes` variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要计算单词和字节数，所以你需要类似的`num_words`和`num_bytes`变量。
- en: To get the words, we’ll use the `str.split()` method to break each `line` on
    spaces. You can then use the length of the resulting `list` as the number of words.
    For the number of bytes, you can use the `len()` (length) function on the `line`
    and add that to a `num_bytes` variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取单词，我们将使用`str.split()`方法将每一行按空格分割。然后你可以使用结果列表的长度作为单词的数量。对于字节数，你可以使用`len()`（长度）函数对`line`进行操作，并将结果添加到`num_bytes`变量中。
- en: Note Splitting the text on spaces doesn’t actually produce “words” because it
    won’t separate the punctuation, like commas and periods, from the letters, but
    it’s close enough for this program. In chapter 15, we’ll look at how to use a
    regular expression to separate strings that look like words from others that do
    not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在空格处分割文本实际上并不会产生“单词”，因为它不会将标点符号（如逗号和句号）与字母分开，但对于这个程序来说已经足够接近了。在第15章中，我们将探讨如何使用正则表达式来区分看起来像单词的字符串和其他不是单词的字符串。
- en: 6.1.4 Formatting your results
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 格式化你的结果
- en: This is the first exercise where the output needs to be formatted in a particular
    way. Don’t try to handle this part manually--that way lies madness. Instead, you
    need to learn the magic of the `str.format()` method. The `help` doesn’t have
    much in the way of documentation, so I recommend you read PEP 3101 on advanced
    string formatting ([www.python.org/dev/peps/pep-3101/](http://www.python.org/dev/peps/pep-3101/)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个需要以特定方式格式化输出的练习。不要尝试手动处理这部分内容——那样只会导致混乱。相反，你需要学习`str.format()`方法的魔法。`help`没有多少文档，所以我建议你阅读PEP
    3101关于高级字符串格式化（[www.python.org/dev/peps/pep-3101/](http://www.python.org/dev/peps/pep-3101/))）。
- en: 'The `str.format()` method uses a template that contains curly brackets (`{}`)
    to create placeholders for the values passed as arguments. For example, we can
    print the raw value of `math.pi` like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.format()`方法使用包含花括号（`{}`）的模板来创建用于传递的值的占位符。例如，我们可以这样打印`math.pi`的原始值：'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can add formatting instructions after a colon (`:`) to specify how you
    want the value displayed. If you are familiar with `printf()` from C-type languages,
    this is the same idea. For instance, I can print `math.pi` with two numbers after
    the decimal by specifying `0.02f`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在冒号（`:`）之后添加格式化指令来指定你想要显示的值的方式。如果你熟悉C类型语言中的`printf()`，这个想法是相同的。例如，我可以通过指定`0.02f`来打印带有两个小数位的`math.pi`：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, the colon (`:`) introduces the formatting options,
    and the `0.02f` describes two decimal points of precision.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，冒号（`:`）引入了格式化选项，而`0.02f`描述了两位小数的精度。
- en: 'You can also use the f-string method, where the variable comes *before* the
    colon:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用f-string方法，其中变量位于冒号之前：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this chapter’s exercise, you need to use the formatting option `{:8}` to
    align each of the lines, words, and characters into columns. The `8` describes
    the width of the field. The text is usually left-justified, like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习中，你需要使用格式化选项`{:8}`来将每一行、单词和字符对齐到列中。`8`描述了字段的宽度。文本通常是左对齐的，如下所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But the text will be right-justified when you are formatting numeric values:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你格式化数值时，文本将右对齐：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will need to place a single space between the last column and the name of
    the file, which you can find in `fh.name`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在最后一列和文件名之间放置一个空格，你可以在`fh.name`中找到这个文件名。
- en: 'Here are a few hints:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: Start with new.py and delete all the nonpositional arguments.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从new.py开始，删除所有非位置参数。
- en: Use `nargs='*'` to indicate zero or more positional arguments for your `file`
    argument.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nargs='*'`来表示`file`参数的零个或多个位置参数。
- en: Try to pass one test at a time. Create the program, get the help right, and
    then worry about the first test, then the next, and so on.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一次通过一个测试。创建程序，正确设置帮助信息，然后关注第一个测试，然后是下一个，依此类推。
- en: Compare the results of your version to the `wc` installed on your system. Note
    that not every system has the same version of `wc`, so results may vary.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的版本的结果与系统上安装的`wc`进行比较。请注意，并非每个系统都有相同的`wc`版本，因此结果可能会有所不同。
- en: It’s time to write this yourself before you read the solution. Fear is the mind
    killer. You can do this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读解决方案之前，现在是时候自己动手写了。恐惧是心灵的杀手。你可以做到这一点。
- en: 6.2 Solution
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 解决方案
- en: Here is one way to satisfy the tests. Remember, it’s fine if you wrote it differently,
    as long as it’s correct and you understand your code!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是满足测试的一种方法。记住，如果你以不同的方式编写，只要它是正确的并且你理解你的代码，那就没问题！
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① If you set the default to a list with sys.stdin, you have handled the STDIN
    option.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果你将默认值设置为包含sys.stdin的列表，你就已经处理了STDIN选项。
- en: ② If the user supplies any arguments, argparse will check if they are valid
    file inputs. If there is a problem, argparse will halt execution of the program
    and show the user an error message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果用户提供了任何参数，argparse将检查它们是否是有效的文件输入。如果有问题，argparse将停止程序执行并向用户显示错误信息。
- en: ③ These are the variables for the “total” line, if I need them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 这些是“总计”行的变量，如果需要的话。
- en: ④ Iterate through the list of arg.file inputs. I use the variable fh to remind
    me that these are open file handles, even STDIN.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 遍历arg.file输入列表。我使用变量fh来提醒自己这些是打开的文件句柄，甚至是STDIN。
- en: ⑤ Initialize variables to count the lines, words, and bytes in just this file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 初始化变量以计算仅此文件的行数、单词数和字节数。
- en: ⑥ Iterate through each line of the file handle.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 遍历文件句柄的每一行。
- en: ⑦ For each line, increment the number of lines by 1.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 对于每一行，行数增加1。
- en: ⑧ The number of bytes is incremented by the length of the line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 字节数增加的量是行长。
- en: ⑨ To get the number of words, we can call line.split() to break the line on
    whitespace. The length of that list is added to the count of words.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 要获取单词数，我们可以调用line.split()来在空白处拆分行。该列表的长度被添加到单词计数中。
- en: ⑩ Add all the counts for lines, words, and bytes for this file to the variables
    for counting the totals.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将此文件的行数、单词数和字节数的计数全部添加到总计计数的变量中。
- en: ⑪ Print the counts for this file using the {:8} option to print in a field 8
    characters wide followed by a single space and then the name of the file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 使用{:8}选项打印此文件的计数，以打印宽度为8个字符的字段，后跟一个空格，然后是文件名。
- en: ⑫ Check if we had more than 1 input.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 检查我们是否有超过1个输入。
- en: ⑬ Print the “total” line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 打印“总计”行。
- en: 6.3 Discussion
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 讨论
- en: This program is rather short and seems rather simple, but it’s not exactly easy.
    Let’s break down the main ideas in the program.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序相当简短，看起来相当简单，但并不容易。让我们分解程序中的主要思想。
- en: 6.3.1 Defining the arguments
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 定义参数
- en: One point of this exercise is to get familiar with `argparse` and the trouble
    it can save you. The key is in defining the `file` parameter. We use `type=argparse.FileType('rt')`
    to indicate that any arguments provided must be readable text files. We use `nargs='*'`
    to indicate zero or more arguments, and we set the `default` to be a list containing
    `sys.stdin`. This means we know that `argparse` will always give us a `list` of
    one or more open file handles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的一个目的是熟悉`argparse`及其可以为你节省的麻烦。关键是定义`file`参数。我们使用`type=argparse.FileType('rt')`来表示提供的任何参数必须是可读文本文件。我们使用`nargs='*'`来表示零个或多个参数，并将`default`设置为包含`sys.stdin`的列表。这意味着我们知道`argparse`将始终给我们一个包含一个或多个打开文件句柄的列表。
- en: That’s really quite a bit of logic packed into a small space, and most of the
    work validating the inputs, generating error messages, and handling the defaults
    is all done for us!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是在一个小空间中打包了相当多的逻辑，并且验证输入、生成错误消息和处理默认值的大部分工作都是为我们完成的！
- en: 6.3.2 Reading a file using a for loop
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 使用for循环读取文件
- en: 'The values that `argparse` returns for `args.file` will be a `list` of *open
    file handles*. We can create such a list in the REPL to mimic what we’d get from
    `args.file`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`为`args.file`返回的值将是一个包含*打开文件句柄*的`list`。我们可以在REPL中创建这样的列表来模拟我们从`args.file`得到的：'
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we use a `for` loop to iterate through them, we need to set up three
    variables to track the *total* number of lines, words, and characters. We could
    define them on three separate lines:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`for`循环遍历它们之前，我们需要设置三个变量来跟踪*总计*行数、单词数和字符数。我们可以在三行不同的地方定义它们：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or we can declare them on a single line like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以像下面这样在单行中声明：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Technically we’re creating a `tuple` on the right side by placing commas between
    the three zeros and then “unpacking” them into three variables on the left side.
    I’ll have more to say about tuples much later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们在右侧通过在三个零之间放置逗号来创建一个`tuple`，然后将它们“解包”到左侧的三个变量中。我会在稍后更多地讨论元组。
- en: Inside the `for` loop for each file handle, we initialize three more variables
    to hold the count of lines, characters, and words *for this particular file*.
    We can then use another `for` loop to iterate over each line in the file handle
    (`fh`). For `lines`, we can add `1` on each pass through the `for` loop. For `bytes`,
    we can add the length of the line (`len(line)`) to track the number of “characters”
    (which may be printable characters or whitespace, so it’s easiest to call them
    “bytes”). Lastly, for `words`, we can use `line.split()` to break the line on
    whitespace to create a `list` of “words.” It’s not a perfect way to count actual
    words, but it’s close enough. We can use the `len()` function on the `list` to
    add to the `words` variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文件句柄的`for`循环内部，我们初始化三个额外的变量来保存特定文件的行数、字符数和单词数计数。然后我们可以使用另一个`for`循环来迭代文件句柄（`fh`）中的每一行。对于`lines`，我们可以在每次通过`for`循环时添加`1`。对于`bytes`，我们可以将行的长度（`len(line)`）添加到跟踪“字符”数量（这些可能是可打印字符或空白字符，因此最容易称它们为“字节”）。最后，对于`words`，我们可以使用`line.split()`在空白处拆分行以创建“单词”的列表。这不是计算实际单词的完美方法，但足够接近。我们可以使用`len()`函数在列表上操作，以将值添加到`words`变量中。
- en: 'The `for` loop ends when the end of the file is reached. Next we can `print()`
    out the counts and the filename, using `{:8}` placeholders in the print template
    to indicate a text field 8 characters wide:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在到达文件末尾时结束。接下来，我们可以使用`print()`输出计数和文件名，在打印模板中使用`{:8}`占位符来指示8个字符宽的文本字段：'
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that the preceding call to `print()` lines up with the *second* `for`
    loop, so that it will run after we’re done iterating over the lines in `fh`. I
    chose to use the f-string method to print each of `lines`, `words`, and `bytes`
    in a space eight characters wide, followed by one space and then the `fh.name`
    of the file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的`print()`调用与第二个`for`循环对齐，因此它将在我们迭代完`fh`中的行之后运行。我选择使用f-string方法以8个字符宽的间隔打印`lines`、`words`和`bytes`，然后是一个空格，然后是文件的`fh.name`。
- en: After printing, we can add the counts to the “total” variables to keep a running
    total.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打印后，我们可以将计数添加到“总计”变量中，以保持累计总和。
- en: '![](../Images/6-unnumb-2.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-unnumb-2.png)'
- en: 'Lastly, if the number of file arguments is greater than 1, we need to print
    the totals:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果文件参数的数量大于1，我们需要打印总计：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 6.4 Going further
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 进一步学习
- en: By default, `wc` will print all the columns like our program does, but it will
    also accept flags to print `-c` for number of characters, `-l` for number of lines,
    and `-w` for number of words. When any of these flags are present, only columns
    for the specified flags are shown, so `wc.py` `-wc` would show just the columns
    for words and characters. Add short and long flags for these options to your program
    so that it behaves exactly like `wc`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`wc`会打印所有列，就像我们的程序一样，但它也会接受标志来打印`-c`表示字符数，`-l`表示行数，`-w`表示单词数。当出现这些标志中的任何一个时，只显示指定标志的列，因此`wc.py`
    `-wc`将只显示单词和字符的列。为这些选项添加短和长标志，以便程序的行为与`wc`完全一致。
- en: Write your own implementation of other system tools like `cat` (to print the
    contents of a file to `STDOUT`), `head` (to print just the first *n* lines of
    a file), `tail` (to print the last *n* lines of a file), and `tac` (to print the
    lines of a file in reverse order).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的其他系统工具实现，例如`cat`（将文件内容打印到`STDOUT`），`head`（打印文件的**前n**行），`tail`（打印文件的**最后n**行），以及`tac`（以相反顺序打印文件的行）。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `nargs` (number of arguments) option to `argparse` allows you to validate
    the number of arguments from the user. The asterisk (`'*'`) means zero or more,
    whereas `'+'` means one or more.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse`的`nargs`（参数数量）选项允许你验证用户提供的参数数量。星号（`''*''`）表示零个或多个，而`''+''`表示一个或多个。'
- en: If you define an argument using `type=argparse.FileType('rt')`, `argparse` will
    validate that the user has provided a readable text file and will make the value
    available in your code as an open file handle.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用`type=argparse.FileType('rt')`定义了一个参数，`argparse`将验证用户是否提供了一个可读的文本文件，并将该值作为打开的文件句柄在代码中提供。
- en: You can read and write from the standard in/out file handles by using `sys.stdin`
    and `sys.stdout`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用`sys.stdin`和`sys.stdout`从标准输入/输出文件句柄中读取和写入。
- en: You can nest `for` loops to handle multiple levels of processing.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以嵌套`for`循环来处理多级处理。
- en: The `str.split()` method will split a string on spaces.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.split()`方法会在空格处拆分字符串。'
- en: The `len()` function can be used on both strings and lists. For lists, it will
    tell you the number of elements the list contains.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len()`函数可以用于字符串和列表。对于列表，它将告诉你列表包含的元素数量。'
- en: Both `str.format()` and Python’s f-strings recognize `printf`-style formatting
    options to allow you to control how a value is displayed.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.format()` 和 Python 的 f-strings 都支持 `printf` 风格的格式化选项，以便您控制值的显示方式。'
