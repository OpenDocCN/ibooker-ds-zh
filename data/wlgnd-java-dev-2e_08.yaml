- en: 6 JDK concurrency libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 JDK 并发库
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Atomic classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子类
- en: Locks classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁类
- en: Concurrent data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发数据结构
- en: BlockingQueues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞队列
- en: Futures and CompletableFuture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Futures 和 CompletableFuture
- en: Executors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器
- en: In this chapter we’ll cover what every well-grounded developer should know about
    `java.util.concurrent` and how to use the toolbox of concurrency building blocks
    it provides. The aim is that by the end of the chapter, you’ll be ready to start
    applying these libraries and concurrency techniques in your own code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍每个有经验的开发者都应该了解的 `java.util.concurrent` 以及如何使用它提供的并发构建块工具箱。目标是到本章结束时，你将准备好在自己的代码中开始应用这些库和并发技术。
- en: 6.1 Building blocks for modern concurrent applications
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 现代并发应用的基本构建块
- en: As we saw in the previous chapter, Java has supported concurrency since the
    very beginning. However, with the advent of Java 5 (which was itself over 15 years
    ago), a new way of thinking about concurrency in Java emerged. This was spearheaded
    by the package `java.util.concurrent`, which contained a rich new toolbox for
    working with multithreaded code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所看到的，Java 从一开始就支持并发。然而，随着 Java 5 的出现（这本身已经超过 15 年了），Java 中关于并发的思考方式出现了一种新的方式。这由
    `java.util.concurrent` 包引领，它包含了一套丰富的工具箱，用于处理多线程代码。
- en: Note This toolbox has been enhanced with subsequent versions of Java, but the
    classes and packages that were introduced with Java 5 still work the same way,
    and they’re still very valuable to the working developer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这个工具箱在 Java 的后续版本中得到了增强，但 Java 5 中引入的类和包仍然以相同的方式工作，并且对工作开发者来说仍然非常有价值。
- en: If you (still!) have existing multithreaded code that is based solely on the
    older (pre-Java 5) approaches, you should consider refactoring it to use `java.util.concurrent`.
    In our experience, your code will be improved if you make a conscious effort to
    port it to the newer APIs—the greater clarity and reliability will be well worth
    the effort expended to migrate in almost all cases.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你（仍然！）有基于较老（Java 5 之前）方法的现有多线程代码，你应该考虑重构它以使用 `java.util.concurrent`。根据我们的经验，如果你有意识地将其迁移到较新的
    API，你的代码将会得到改进——更高的清晰度和可靠性将值得所付出的迁移努力。
- en: We’re going to take a tour through some of the headline classes in `java.util
    .concurrent` and related packages, such as the atomic and locks packages. We’ll
    get you started using the classes and look at examples of use cases for them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将游览 `java.util.concurrent` 和相关包中的一些主要类，例如原子和锁包。我们将帮助你开始使用这些类，并查看它们的使用案例。
- en: You should also read the Javadoc for them and try to build up your familiarity
    with the packages as a whole. Most developers find that the higher level of abstraction
    that they provide makes concurrent programming much easier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该阅读它们的 Javadoc，并尝试熟悉整个包。大多数开发者发现，它们提供的更高层次抽象使并发编程变得更加容易。
- en: 6.2 Atomic classes
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 原子类
- en: The package `java.util.concurrent.atomic` contains several classes that have
    names starting with `Atomic`, for example, `AtomicBoolean`, `AtomicInteger`, `AtomicLong`,
    and `AtomicReference`. These classes are one of the simplest examples of a *concurrency
    primitive*—a class that can be used to build workable, safe concurrent applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 包 `java.util.concurrent.atomic` 包含了几个以 `Atomic` 开头的类，例如 `AtomicBoolean`、`AtomicInteger`、`AtomicLong`
    和 `AtomicReference`。这些类是并发原语的最简单例子之一——一个可以用来构建可工作、安全并发应用的类。
- en: warning Atomic classes don’t inherit from the similarly named classes, so `AtomicBoolean`
    can’t be used in place of a `Boolean`, and an `AtomicInteger` isn’t an `Integer`
    (but it does extend `Number`).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：原子类不继承自同名的类，因此 `AtomicBoolean` 不能替代 `Boolean`，而 `AtomicInteger` 也不是 `Integer`（但它扩展了
    `Number`）。
- en: The point of an atomic is to provide thread-safe mutable variables. Each of
    the four classes provides access to a single variable of the appropriate type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作的目的在于提供线程安全的可变变量。这四个类中的每一个都提供了访问相应类型单个变量的接口。
- en: Note The implementations of the atomics are written to take advantage of modern
    processor features, so they can be nonblocking (lock-free) if support is available
    from the hardware and OS, which it will be for virtually all modern systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：原子操作的实现被编写为利用现代处理器的特性，因此如果硬件和操作系统支持，它们可以是非阻塞的（无锁的），这在几乎所有现代系统中都是可行的。
- en: The access provided is lock-free on almost all modern hardware, so the atomics
    behave in a similar way to a volatile field. However, they are wrapped in a Class
    API that goes further than what’s possible with volatiles. This API includes atomic
    (meaning all-or-nothing) methods for suitable operations—including state-dependent
    updates (which are impossible to do with volatile variables without using a lock).
    The end result is that atomics can be a very simple way for a developer to avoid
    race conditions on shared data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的访问在几乎所有现代硬件上都是无锁的，因此原子操作的行为与 `volatile` 字段类似。然而，它们被封装在一个类 API 中，这个 API 超越了
    `volatile` 的可能性。这个 API 包括适合操作的原子（意味着全有或全无）方法——包括依赖于状态更新（在没有使用锁的情况下，使用 `volatile`
    变量是无法做到的）。结果是，原子操作可以是一个非常简单的方法，让开发者避免在共享数据上出现竞态条件。
- en: Note If you’re curious as to how atomics are implemented, we will discuss the
    details in chapter 17, when we talk about internals and the class `sun.misc .Unsafe`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你对原子操作是如何实现的感兴趣，我们将在第 17 章讨论细节，当我们讨论内部结构和 `sun.misc.Unsafe` 类时。
- en: 'A common use case for atomics is to implement something similar to sequence
    numbers, as you might find provided by an SQL database. This capability is accessed
    by using methods such as the atomic `getAndIncrement()` on the `AtomicInteger`
    or `AtomicLong` classes. Let’s look at how we would rewrite the `Account` example
    from chapter 5 to use an atomic:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作的一个常见用例是实现类似于序列号的功能，就像你可能在 SQL 数据库中找到的那样。这个功能可以通过在 `AtomicInteger` 或 `AtomicLong`
    类上使用原子的 `getAndIncrement()` 方法来访问。让我们看看我们如何将第 5 章中的 `Account` 示例重写为使用原子操作：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As each object is created, we make a call to `getAndIncrement()` on the static
    instance of `AtomicInteger`, which returns us an int value and atomically increments
    the mutable variable. This atomicity guarantees that it is impossible for two
    objects to share the same `accountId`, which is exactly the property that we want
    (just like a database sequence number).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个对象时，我们都会在 `AtomicInteger` 的静态实例上调用 `getAndIncrement()`，它返回一个整数值并原子地增加可变变量。这种原子性保证两个对象不可能共享相同的
    `accountId`，这正是我们想要的属性（就像数据库序列号一样）。
- en: Note We could add the `final` qualifier to the atomic, but it’s not necessary
    because the field is `static` and the class doesn’t provide any way to mutate
    the field.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们可以将 `final` 标识符添加到原子操作中，但这是不必要的，因为字段是 `static` 的，并且类没有提供任何修改字段的方法。
- en: 'For another example, here is how we would rewrite our volatile shutdown example
    to use an `AtomicBoolean`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，以下是我们将如何重写我们的 `volatile` 关闭示例以使用 `AtomicBoolean`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As well as these examples, the `AtomicReference` is also used to implement atomic
    changes but to objects. The general pattern is that some modified (possibly immutable)
    state is built optimistically and can then be “swapped in” by using a *Compare-and-Swap*
    (CAS) operation on an `AtomicReference`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些示例之外，`AtomicReference` 也可以用来实现对象的原子变更。一般模式是构建一些可能不可变的修改后的状态，然后可以通过在 `AtomicReference`
    上使用 *比较并交换* (CAS) 操作来“交换”这些状态。
- en: Next, let’s examine how `java.util.concurrent` models the core of the classic
    synchronization approach—the `Lock` interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考察 `java.util.concurrent` 如何对经典同步方法的核心——`Lock` 接口进行建模。
- en: 6.3 Lock classes
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 锁类
- en: 'The block-structured approach to synchronization is based on a simple notion
    of what a lock is. This approach has a number of shortcomings, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同步的块结构方法基于锁的简单概念。这种方法有一些缺点，如下所述：
- en: Only one type of lock exists.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只存在一种类型的锁。
- en: It applies equally to all synchronized operations on the locked object.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这同样适用于锁定对象上的所有同步操作。
- en: The lock is acquired at the start of the synchronized block or method.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁是在同步块或方法开始时获取的。
- en: The lock is released at the end of the block or method.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁是在块或方法结束时释放的。
- en: Either the lock is acquired or the thread blocks indefinitely—no other outcomes
    are possible.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么获取锁，要么线程无限期地阻塞——没有其他结果可能发生。
- en: 'If we were going to reengineer the support for locks, we could potentially
    change several things for the better:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要重新设计锁的支持，我们可能会对几个方面进行改进：
- en: Add different types of locks (such as reader/writer locks).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加不同类型的锁（例如读写锁）。
- en: Not restrict locks to blocks (allow a lock in one method and an unlock in another).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将锁限制在块中（允许一个方法获取锁，另一个方法释放锁）。
- en: If a thread cannot acquire a lock (e.g., if another thread has the lock), allow
    the thread to back out or carry on or do something else—a `tryLock()`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个线程无法获取锁（例如，如果另一个线程持有锁），允许线程退出或继续或做其他事情——一个`tryLock()`。
- en: Allow a thread to attempt to acquire a lock and give up after a certain amount
    of time.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许一个线程尝试获取锁，并在一定时间后放弃。
- en: 'The key to realizing all of these possibilities is the `Lock` interface in
    `java.util .concurrent.locks`. This interface ships with the following implementations:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有这些可能性的关键是`java.util.concurrent.locks`中的`Lock`接口。此接口附带以下实现：
- en: '`ReentrantLock`—This is essentially the equivalent of the familiar lock used
    in Java synchronized blocks but more flexible.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock`—这本质上等同于Java同步块中使用的熟悉锁，但更灵活。'
- en: '`ReentrantReadWriteLock`—This can provide better performance in cases where
    there are many readers but few writers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantReadWriteLock`—在存在许多读者但很少写者的情况下，这可以提供更好的性能。'
- en: Note Other implementations exist, both within the JDK and written by third parties,
    but these are by far the most common.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：其他实现存在，包括JDK内部和第三方编写的，但这些是最常见的。
- en: The `Lock` interface can be used to completely replicate any functionality that
    is offered by block-structured concurrency. For example, listing 6.1 shows the
    example from chapter 5 for how to avoid deadlock rewritten to use `ReentrantLock`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`接口可以用来完全复制任何由块结构并发提供的功能。例如，列表6.1展示了第5章中如何避免死锁的示例，重写为使用`ReentrantLock`。'
- en: We need to add a lock object as a field to the class, because we will no longer
    be relying on the intrinsic lock on the object. We also need to maintain the principle
    that locks are always acquired in the same order. In our example the simple protocol
    we maintain is that the lock on the object with the lowest account ID is acquired
    *first*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将锁对象作为字段添加到类中，因为我们不再依赖于对象的内建锁。我们还需要维护锁总是以相同顺序获取的原则。在我们的示例中，我们保持的简单协议是，具有最低账户ID的对象的锁首先获取。
- en: Listing 6.1 Rewriting deadlock example to use `ReentrantLock`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 重写死锁示例以使用`ReentrantLock`
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The firstLock object has a lower account ID.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第一个锁对象具有较低的账户ID。
- en: ❷ The secondLock object has a higher account ID.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第二个锁对象具有较高的账户ID。
- en: The pattern of an initial call to `lock()` combined with a `try ... finally`
    block, where the lock is released in the `finally`, is a great addition to your
    toolbox.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将对`lock()`的初始调用与一个`try ... finally`块结合的模式，在`finally`中释放锁，是您工具箱中的一个很好的补充。
- en: Note The locks, like much of `java.util.concurrent`, rely on a class called
    `AbstractQueuedSynchronizer` to implement their functionality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：锁，就像`java.util.concurrent`中的许多内容一样，依赖于一个名为`AbstractQueuedSynchronizer`的类来实现其功能。
- en: The pattern works very well if you’re replicating a situation that is similar
    to one where you’d have used block-structured concurrency. On the other hand,
    if you need to pass around the `Lock` objects (such as by returning it from a
    method), you can’t use this pattern.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在复制一个类似于您会使用块结构并发的场景，这种模式工作得非常好。另一方面，如果您需要传递`Lock`对象（例如，通过从方法返回它），则不能使用此模式。
- en: 6.3.1 Condition objects
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 条件对象
- en: Another aspect of the API provided by `java.util.concurrent` are the *condition
    objects*. These objects play the same role in the API as `wait()` and `notify()`
    do in the original intrinsic API but are more flexible. They provide the ability
    for threads to wait indefinitely for some condition and to be woken up when that
    condition becomes true.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`提供的API的另一个方面是*条件对象*。这些对象在API中扮演的角色与原始内建API中的`wait()`和`notify()`相同，但更灵活。它们提供了线程能够无限期等待某些条件，并在该条件变为真时被唤醒的能力。'
- en: However, unlike the intrinsic API (where the object monitor has only a single
    condition for signaling), the `Lock` interface allows the programmer to create
    as many condition objects as they like. This allows a separation of concerns—for
    example, the lock can have multiple, disjoint groups of methods that can use separate
    conditions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与内建API（其中对象监视器只有一个条件用于信号）不同，`Lock`接口允许程序员创建尽可能多的条件对象。这允许关注点的分离——例如，锁可以有多个不重叠的方法组，这些方法可以使用不同的条件。
- en: A condition object (which implements the interface `Condition`) is created by
    calling the `newCondition()` method on a lock object (one that implements the
    `Lock` interface). As well as condition objects, the API provides a number of
    *latches* and *barriers* as concurrency primitives that may be useful in some
    circumstances.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在实现 `Lock` 接口的锁对象上调用 `newCondition()` 方法创建一个条件对象（它实现了 `Condition` 接口）。除了条件对象之外，API
    还提供了一些 *闩锁* 和 *屏障* 作为并发原语，在某些情况下可能很有用。
- en: 6.4 CountDownLatch
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 CountDownLatch
- en: 'The `CountDownLatch` is a simple concurrency primitive that provides a *consensus
    barrier*—it allows for multiple threads to reach a coordination point and wait
    until the barrier is released. This is achieved by providing an int value (the
    `count`) when constructing a new instance of `CountDownLatch`. After that point,
    two methods are used to control the latch: `countDown()` and `await()`. The former
    reduces the count by 1, and the latter causes the calling thread to block until
    the count reaches 0 (it does nothing if the count is already 0 or less). In the
    following listing, the latch is used by each `Runnable` to indicate when it has
    completed its assigned work.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch` 是一个简单的并发原语，它提供了一个 *共识屏障*——它允许多个线程达到一个协调点并等待直到屏障释放。这是通过在创建
    `CountDownLatch` 的新实例时提供一个整数值（`count`）来实现的。从那时起，使用两个方法来控制闩锁：`countDown()` 和 `await()`。前者将计数减
    1，后者使调用线程阻塞，直到计数达到 0（如果计数已经是 0 或更少，则不执行任何操作）。在下面的列表中，闩锁被每个 `Runnable` 用于指示它已完成分配的工作。'
- en: Listing 6.2 Using latches to signal between threads
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 使用闩锁在线程间进行信号传递
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Updates the count value atomically
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 原子性地更新计数值
- en: ❷ Decrements the latch
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 递减闩锁
- en: Note that the `countDown()` method is nonblocking, so once the latch has been
    decremented, the thread running the `Counter` code will exit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`countDown()` 方法是非阻塞的，因此一旦闩锁被递减，运行 `Counter` 代码的线程将退出。
- en: 'We also need some driver code, shown here (exceptions elided):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些驱动代码，如下所示（省略了异常）：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the code, the latch is set up with a quorum value (in figure 6.1, the value
    is 2). Next, the same number of threads are created and initialized, so that processing
    can begin. The main thread awaits the latch and blocks until it is released. Each
    worker thread will perform a sleep and then `countDown()` once it has finished.
    The main thread will not proceed until both of the threads have completed their
    processing. This situation is show in figure 6.1.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，闩锁被设置为法定人数值（在图 6.1 中，值为 2）。接下来，创建并初始化相同数量的线程，以便开始处理。主线程等待闩锁并阻塞，直到它被释放。每个工作线程在完成处理后将执行睡眠并调用
    `countDown()`。主线程将不会继续进行，直到两个线程都完成其处理。这种情况在图 6.1 中显示。
- en: '![](../Images/CH06_F01_Evans2.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F01_Evans2.png)'
- en: Figure 6.1 Using a `CountDownLatch`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 使用 `CountDownLatch`
- en: To provide another example of a good use case for `CountDownLatch`, consider
    an application that needs to prepopulate several caches with reference data before
    the server is ready to receive incoming requests. We can easily achieve this by
    using a shared latch, a reference to which is held by each cache population thread.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个 `CountDownLatch` 的良好用例的另一个示例，考虑一个需要在服务器准备好接收传入请求之前预先填充几个缓存的参考数据的应用程序。我们可以通过使用一个共享的闩锁，每个缓存填充线程都持有该闩锁的引用，轻松地实现这一点。
- en: When each cache finishes loading, the `Runnable` populating it counts down the
    latch and exits. When all the caches are loaded, the main thread (which has been
    awaiting the latch opening) can proceed and is ready to mark the service as up
    and begin handling requests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个缓存加载完成时，填充它的 `Runnable` 会递减闩锁并退出。当所有缓存都加载完成后，主线程（它一直在等待闩锁打开）可以继续进行，并准备好将服务标记为启动并开始处理请求。
- en: 'The next class we’ll discuss is one of the most useful classes in the multithreaded
    developer’s toolkit: the `ConcurrentHashMap`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的下一个类是多线程开发者工具箱中最有用的类之一：`ConcurrentHashMap`。
- en: 6.5 ConcurrentHashMap
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 ConcurrentHashMap
- en: The `ConcurrentHashMap` class provides a concurrent version of the standard
    `HashMap`. In general, maps are a very useful (and common) data structure for
    building concurrent applications. This is due, at least in part, to the shape
    of the underlying data structure. Let’s take a closer look at the basic `HashMap`
    to understand why.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 类提供了标准 `HashMap` 的并发版本。一般来说，映射是构建并发应用程序非常有用（且常见）的数据结构。这至少部分归因于底层数据结构的形状。让我们更仔细地看看基本的
    `HashMap`，以了解为什么。'
- en: 6.5.1 Understanding a simplified HashMap
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 理解简化的 HashMap
- en: As you can see from figure 6.2, the classic Java `HashMap` uses a function (the
    *hash function*) to determine which *bucket* it will store the key-value pair
    in. This is where the “hash” part of the class’s name comes from.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6.2所示，经典的Java `HashMap`使用一个函数（*哈希函数*）来确定它将存储键值对的哪个*桶*。这就是类名中“哈希”部分的原因。
- en: '![](../Images/CH06_F02_Evans2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F02_Evans2.png)'
- en: Figure 6.2 The classic view of a `HashMap`
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 经典的`HashMap`视图
- en: The key-value pair is actually stored in a linked list (known as the *hash chain*)
    that starts from the bucket corresponding to the index obtained by hashing the
    key.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对实际上存储在一个从通过哈希键获得的索引对应的桶开始的链表中（称为*哈希链*）。
- en: In the GitHub project that accompanies this book is a simplified implementation
    of a `Map<String, String>`—the `Dictionary` class. This class is actually based
    on the form of the `HashMap` that shipped as part of Java 7.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在伴随本书的GitHub项目中，有一个`Map<String, String>`的简化实现——`Dictionary`类。这个类实际上是基于Java 7中作为一部分提供的`HashMap`的形式。
- en: Note Modern Java versions ship a `HashMap` implementation that is significantly
    more complex, so in this explanation, we focus on a simpler version where the
    design concepts are more clearly visible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现代Java版本提供的`HashMap`实现要复杂得多，因此在这个解释中，我们关注一个更简单的版本，其中设计概念更清晰可见。
- en: 'The basic class has only two fields: the main data structure and the `size`
    field, which caches the size of the map for performance reasons, as shown next:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类只有两个字段：主要数据结构和`size`字段，它为了性能原因缓存了映射的大小，如下所示：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These rely on a helper class, called a `Node`, which represents a key-value
    pair and implements the interface `Map.Entry` as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖于一个名为`Node`的辅助类，它代表一个键值对并实现了`Map.Entry`接口，如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To look for a value in the map, we use the `get()` method, which relies on
    a couple of helper methods, `hash()` and `indexFor()` as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在映射中查找值，我们使用`get()`方法，该方法依赖于几个辅助方法，`hash()`和`indexFor()`，如下所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ A bitwise operation to make sure that the hash value is positive
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个位运算操作，以确保哈希值是正数
- en: ❷ A bitwise operation to make sure that the index is within the size of the
    table
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个位运算操作，以确保索引在表的大小范围内
- en: First, the `get()` method deals with the irritating null case. Following that,
    we use the key object’s hash code to construct an index into the array `table`.
    An unwritten assumption says that the size of `table` is a power of two, so the
    operation of `indexFor()` is basically a modulo operation, which ensures that
    the return value is a valid index into `table`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`get()`方法处理了令人烦恼的null情况。随后，我们使用键对象的哈希码来构建一个指向数组`table`的索引。一个未写明的假设是`table`的大小是2的幂，因此`indexFor()`操作基本上是一个模运算，这确保了返回值是`table`的有效索引。
- en: Note This is a classic example of a situation where a human mind can determine
    that an exception (in this case, `ArrayIndexOutOfBoundsException`) will never
    be thrown, but the compiler cannot.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这是一个人类思维可以确定异常（在这种情况下，`ArrayIndexOutOfBoundsException`）永远不会抛出的经典例子，但编译器不能。
- en: 'Now that we have an index into `table`, we use it to select the relevant hash
    chain for our lookup operation. We start at the head and walk down the hash chain.
    At each step we evaluate whether we’ve found our key object, as shown next:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`table`的索引，我们使用它来选择我们的查找操作的相关哈希链。我们从头部开始，沿着哈希链向下走。在每一步中，我们评估是否找到了我们的键对象，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we have, then we return the corresponding value. We store keys and values
    as pairs (really as `Node` instances) to allow for this approach.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有，则返回相应的值。我们将键和值作为对（实际上是`Node`实例）存储，以便采用这种方法。
- en: 'The `put()` method is somewhat similar to the previous code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`put()`方法与之前的代码有些相似：'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This version of a hashed data structure is not 100% production quality, but
    it is intended to demonstrate the basic behavior and approach to the problem,
    so that the concurrent case can be understood.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种哈希数据结构的版本不是100%的生产质量，但它的目的是演示基本行为和解决问题的方法，以便理解并发情况。
- en: 6.5.2 Limitations of Dictionary
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 字典的限制
- en: Before we proceed to the concurrent case, we should mention that some methods
    from `Map` are not supported by our toy implementation, `Dictionary`. Specifically,
    `putAll()`, `keySet()`, `values()`, or `entrySet()` (which need to be defined,
    because the class implements `Map`) will simply `throw new UnsupportedOperationException()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论并发情况之前，我们应该提到，`Map` 中的一些方法在我们的玩具实现 `Dictionary` 中不受支持。具体来说，`putAll()`、`keySet()`、`values()`
    或 `entrySet()`（因为该类实现了 `Map`）将简单地抛出 `UnsupportedOperationException()`。
- en: We do not support these methods purely and solely due to complexity. As we will
    see several times in the book, the Java Collections interfaces are large and feature-rich.
    This is good for the end user, because they have a lot of power, but it means
    an implementor must supply a lot more methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不支持这些方法纯粹是因为复杂性。正如我们将在本书中多次看到的那样，Java 集合接口很大且功能丰富。这对于最终用户来说是个好事，因为他们有很多功能，但这意味着实现者必须提供更多的方法。
- en: In particular, methods like `keySet()` require an implementation of `Map` to
    supply instances of `Set`, and this frequently results in needing to write an
    entire implementation of the `Set` interface as an inner class. That is too much
    extra complexity for our examples, so we just don’t support those methods in our
    toy implementation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是像 `keySet()` 这样的方法需要 `Map` 实现提供 `Set` 实例，这通常会导致需要编写整个 `Set` 接口的实现作为内部类。这对于我们的示例来说太复杂了，所以我们只是不支持这些方法。
- en: Note As we will see later in the book, the monolithic, complex, imperative design
    of the Collections interfaces presents various problems when we start to think
    about functional programming in detail.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正如我们将在本书后面看到的那样，集合接口的单体、复杂、命令式设计在详细考虑函数式编程时会出现各种问题。
- en: 'The simple `Dictionary` class works well, within its limitations. However,
    it does not guard against the following two scenarios:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的 `Dictionary` 类在其限制内工作得很好。然而，它没有防范以下两种情况：
- en: The need to resize `table` as the number of elements stored increases
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着存储元素数量的增加，需要调整 `table` 的大小
- en: Defending against keys that implement a pathological form of `hashCode()`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御实现 `hashCode()` 的病态形式的键
- en: The first of these is a serious limitation. A major point of a hashed data structure
    is to reduce the expected complexity operations down from `O(N)` to `O(log N)`,
    for example, for value retrieval. If the table is not resized as the number of
    elements held in the map increases, this complexity gain is lost. A real implementation
    would have to deal with the need to resize the table as the map grows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的第一个是一个严重的限制。散列数据结构的一个主要目的是将操作的预期复杂度从 `O(N)` 降低到 `O(log N)`，例如，对于值检索。如果表的大小不随映射中存储的元素数量增加而调整，这种复杂度优势就会丧失。实际实现必须处理随着映射增长而调整表大小的需求。
- en: 6.5.3 Approaches to a concurrent Dictionary
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 并发字典的实现方法
- en: As it stands, `Dictionary` is obviously not thread-safe. Consider two threads—one
    trying to delete a certain key and the other trying to update the value associated
    with it. Depending on the ordering of operations, it is entirely possible for
    both the deletion and the update to report that they succeeded when in fact only
    one of them did. To resolve this, we have two fairly obvious (if naïve) ways to
    make `Dictionary` (and, by extension, general Java `Map` implementations) concurrent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前来看，`Dictionary` 显然不是线程安全的。考虑两个线程——一个尝试删除某个键，另一个尝试更新与其关联的值。根据操作顺序的不同，删除和更新都可能报告它们成功了，而实际上只有一个成功了。为了解决这个问题，我们有两种相当明显（如果有些天真）的方法来使
    `Dictionary`（以及由此扩展的通用 Java `Map` 实现）实现并发。
- en: 'First off is the fully synchronization approach, which we met in chapter 5\.
    The punch line is not hard to predict: this approach is unfeasible for most practical
    systems due to performance overhead. However, it’s worth a small diversion to
    look at how we might implement it.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是完全同步的方法，我们在第5章中遇到过。这个结论不难预测：由于性能开销，这种方法对于大多数实际系统来说不可行。然而，简要地看看我们如何实现它还是值得的。
- en: We have two easy ways to achieve simple thread safety here. The first is to
    copy the `Dictionary` class—let’s call it `ThreadSafeDictionary` and then make
    all of its methods `synchronized`. This works but involves a lot of duplicated,
    cut-and-paste code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种简单的方法来实现简单的线程安全。第一种是复制 `Dictionary` 类——让我们称它为 `ThreadSafeDictionary`，然后使所有的方法都同步。这可行，但涉及到大量的复制和粘贴代码。
- en: 'Alternatively, we can use a synchronized wrapper to provide *delegation*—aka
    forwarding— to an underlying object that actually houses the dictionary. Here’s
    how we can do that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用一个同步包装器来提供*委托*——也就是转发——到实际包含字典的底层对象。下面是如何做到这一点的方法：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example has a number of problems, the most important of which is that the
    object `d` already exists and is not synchronized. This is setting ourselves up
    to fail—other code may modify `d` outside of a synchronized block or method, and
    we find ourselves in exactly the situation we discussed in the previous chapter.
    This is not the right approach for concurrent data structures.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有几个问题，其中最重要的是对象`d`已经存在并且没有同步。这是在为自己设置失败——其他代码可能在同步块或方法之外修改`d`，我们发现自己处于与上一章讨论的完全相同的情况。这不是并发数据结构的正确方法。
- en: We should mention that, in fact, the JDK provides just such an implementation—the
    `synchronizedMap()` method provided in the `Collections` class. It works about
    as well and is about as widely used, as you might expect.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该提到，实际上，JDK提供了这样一个实现——`Collections`类中提供的`synchronizedMap()`方法。它的工作效果大致如此，并且像你预期的那样广泛使用。
- en: A second approach is to appeal to immutability. As we will say, and say again,
    the Java Collections are large and complex interfaces. One way in which this manifests
    is that the assumption of mutability is baked throughout the collections. In no
    sense is it a separable concern that some implementations may choose, or not,
    to express—all implementations of `Map` and `List` must implement the mutating
    methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是诉诸不可变性。正如我们将说到的，并且还会再次说到的，Java Collections是庞大而复杂的接口。这种表现方式之一是，可变性的假设贯穿于整个集合中。在没有任何意义上，它不是某些实现可以选择或选择不表达的可分离关注点——所有`Map`和`List`的实现都必须实现修改方法。
- en: Due to this constriction, it might seem as though we have no way to model a
    data structure in Java that is both immutable and conforms to the Java Collections
    APIs—if it conforms to the APIs, the class must also provide an implementation
    of the mutation method. However, a deeply unsatisfactory back door exists. An
    implementation of an interface can always throw `UnsupportedOperationException`
    if it has not implemented a certain method. From a language design point of view,
    this is, of course, terrible. An interface contract should be exactly that—a contract.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种限制，我们可能会觉得在Java中无法建模一个既不可变又符合Java Collections APIs的数据结构——如果它符合API，则该类还必须提供一个修改方法的实现。然而，存在一个令人非常不满意的解决方案。如果一个接口的实现没有实现某个方法，它总是可以抛出`UnsupportedOperationException`。从语言设计的角度来看，这当然是糟糕的。接口合约应该正好是那样——一个合约。
- en: Unfortunately, this mechanism and convention predates Java 8 (and the arrival
    of default methods) and thus represents an attempt to encode a difference between
    a “mandatory” method and an “optional” one, at a time when no such distinction
    actually existed in the Java language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种机制和惯例早于Java 8（以及默认方法的到来），因此它代表了在Java语言中实际上不存在这种区分时，尝试编码“强制”方法和“可选”方法之间的差异。
- en: 'It is a bad mechanism and practice (especially because `UnsupportedOperationException`
    is a runtime exception), but we could use it something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个糟糕的机制和做法（尤其是因为`UnsupportedOperationException`是一个运行时异常），但我们可以这样使用它：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It can be argued that this is something of a violation of object-oriented principles—the
    expectation from the user is that this is a valid implementation of `Map<String,
    String>`, and yet, if a user tries to mutate an instance, an unchecked exception
    is thrown. This can legitimately be seen as a safety hazard.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以认为这是对面向对象原则的一种违反——用户的期望是这是一个有效的`Map<String, String>`实现，然而，如果用户尝试修改实例，则会抛出一个未经检查的异常。这可以合法地被视为一个安全隐患。
- en: 'Note This is basically the compromise that `Map.of()` has to make: it needs
    to fully implement the interface and so has to resort to throwing exceptions on
    mutating method calls.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这基本上是`Map.of()`必须做出的妥协：它需要完全实现接口，因此不得不求助于在修改方法调用时抛出异常。
- en: This is also not the only issue with this approach. Another drawback is that
    this is, of course, subject to the same basic flaw as we saw for the synchronized
    case—a mutable object still exists and can be referenced (and mutated) via that
    route, violating the basic criteria that we were trying to achieve. Let us draw
    a veil over these attempts and try to look for something better.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不是这个方法唯一的问题。另一个缺点是，这当然也受我们之前看到的同步案例的基本缺陷的影响——仍然存在一个可变对象，并且可以通过该路径引用（并修改），违反了我们试图实现的基本标准。让我们对这些尝试画上一个句号，并尝试寻找更好的方法。
- en: 6.5.4 Using ConcurrentHashMap
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.4 使用`ConcurrentHashMap`
- en: 'Having shown a simple map implementation and discussed approaches that we could
    use to make it concurrent, it’s time to meet the `ConcurrentHashMap`. In some
    ways, this is the easy part: it is an extremely easy-to-use class and in most
    cases is a drop-in replacement for `HashMap`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示了简单的映射实现并讨论了我们可以用来使其并发的途径之后，现在是时候认识`ConcurrentHashMap`了。在某种程度上，这很简单：这是一个极其易于使用的类，在大多数情况下是`HashMap`的直接替代品。
- en: 'The key point about the `ConcurrentHashMap` is that it is safe for multiple
    threads to update it at once. To see why we need this, let’s see what happens
    when we have two threads adding entries to a `HashMap` simultaneously (exception
    handling elided):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ConcurrentHashMap`的关键点在于它允许多个线程同时安全地更新它。为了了解为什么我们需要这一点，让我们看看当有两个线程同时向一个`HashMap`添加条目时会发生什么（省略了异常处理）：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we run this code, we will see a different manifestation of our old friend,
    the Lost Update antipattern—the output value for `Count` will be less than `2
    * SIZE`. However, in the case of concurrent access to a map, the situation is
    actually much, much worse.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们将看到我们老朋友，丢失更新反模式的另一种表现——`Count`的输出值将小于`2 * SIZE`。然而，在并发访问映射的情况下，情况实际上要糟糕得多。
- en: The most dangerous behavior of `HashMap` under concurrent modification does
    not always manifest at small sizes. However, if we increase the value of `SIZE`
    it will, eventually, manifest itself.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发修改下，`HashMap`最危险的行为并不总是出现在小尺寸时。然而，如果我们增加`SIZE`的值，它最终会表现出来。
- en: If we increase `SIZE` to, say, `1_000_000`, then we are likely to see the behavior.
    One of the threads making updates to `map` will fail to finish. That’s right—one
    of the threads can (and will) get stuck in an actual infinite loop. This makes
    `HashMap` totally unsafe for use in multithreaded applications (and the same is
    true of our example `Dictionary` class).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`SIZE`增加到，比如说，`1_000_000`，那么我们很可能会看到这种行为。更新`map`的线程之一将无法完成。没错——一个线程可以（并将）陷入一个实际的无穷循环。这使得`HashMap`在多线程应用中使用时完全不安全（我们的示例`Dictionary`类也是如此）。
- en: On the other hand, if we replace `HashMap` with `ConcurrentHashMap`, then we
    can see that the concurrent version behaves properly—no infinite loops and no
    instances of Lost Update. It also has the nice property that, no matter what you
    do to it, map operations will never throw a `ConcurrentModificationException`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们用`ConcurrentHashMap`替换`HashMap`，那么我们可以看到并发版本的行为是正确的——没有无穷循环，也没有丢失更新的实例。它还有一个很好的特性，即无论你对它做什么，映射操作都不会抛出`ConcurrentModificationException`。
- en: 'Let’s take a very brief look at how this is achieved. It turns out that figure
    6.2, which shows the implementation of `Dictionary`, also points the way to a
    useful multithreaded generalization of `Map` that is much better than either of
    our two previous attempts. It is based on the following insight: instead of needing
    to lock the whole structure when making a change, it’s only necessary to lock
    the hash chain (aka bucket) that’s being altered or read.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看这是如何实现的。结果发现，图6.2，它展示了`Dictionary`的实现，也指出了对`Map`的一个有用的多线程泛化，这个泛化比我们之前的两个尝试都要好。它基于以下洞察：在做出更改时，不需要锁定整个结构，只需要锁定正在更改或读取的哈希链（也称为桶）。
- en: We can see how this works in figure 6.3\. The implementation has moved the lock
    down onto the individual hash chains. This technique is known as *lock striping*,
    and it enables multiple threads to access the map, provided they are operating
    on different chains.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图6.3中看到这是如何工作的。实现已经将锁下移到单个哈希链上。这种技术被称为*锁条带化*，它使得多个线程可以访问映射，前提是它们正在操作不同的链。
- en: '![](../Images/CH06_F03_Evans2.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F03_Evans2.png)'
- en: Figure 6.3 Lock striping
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 锁条带化
- en: Of course, if two threads need to operate on the same chain, then they will
    still exclude each other, but in general, this provides better throughput than
    synchronizing the entire map.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果两个线程需要操作同一个链，那么它们仍然会相互排除，但总的来说，这比同步整个映射提供了更好的吞吐量。
- en: Note Recall that as the number of elements in the map increases, the table of
    buckets will resize, meaning that as more and more elements are added to a `ConcurrentHashMap`,
    it will become able to deal with more and more threads in an efficient manner.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意回想一下，随着映射中元素数量的增加，桶的表将进行缩放，这意味着随着越来越多的元素被添加到 `ConcurrentHashMap` 中，它将能够以更有效的方式处理越来越多的线程。
- en: The `ConcurrentHashMap` achieves this behavior, but some additional low-level
    details exist that most developers won’t need to worry about too much. In fact,
    the implementation of `ConcurrentHashMap` changed substantially in Java 8, and
    it is now more complex than the design that we have described here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 实现了这种行为，但存在一些额外的低级细节，大多数开发者不需要过多担心。实际上，`ConcurrentHashMap`
    的实现从 Java 8 开始发生了重大变化，现在它比我们在这里描述的设计更复杂。'
- en: Using `ConcurrentHashMap` can be almost too simple. In many cases, if you have
    a multithreaded program and need to share data, then just use a `Map`, and have
    the implementation be a `ConcurrentHashMap`. In fact, if there is ever a chance
    that a `Map` might need to be modified by more than one thread, then you should
    always use the concurrent implementation. It does use considerably more resources
    than a plain `HashMap` and will have worse throughput due to the synchronization
    of some operations. As we’ll discuss in chapter 7, however, those inconveniences
    are nothing when compared to the possibility of a race condition leading to Lost
    Update or an infinite loop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ConcurrentHashMap` 可以几乎太简单了。在许多情况下，如果你有一个多线程程序并且需要共享数据，那么只需使用一个 `Map`，并让其实现为
    `ConcurrentHashMap`。实际上，如果 `Map` 有可能被多个线程修改，那么你应该始终使用并发实现。它确实比普通的 `HashMap` 使用更多的资源，并且由于某些操作的同步，吞吐量会更差。然而，正如我们将在第
    7 章中讨论的，与可能导致丢失更新或无限循环的竞态条件相比，这些不便微不足道。
- en: 'Finally, we should also note that `ConcurrentHashMap` actually implements the
    `ConcurrentMap` interface, which extends `Map`. It originally contained the following
    new methods to provide thread-safe modifications:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还应该注意，`ConcurrentHashMap` 实际上实现了 `ConcurrentMap` 接口，该接口扩展了 `Map`。它最初包含以下新方法，以提供线程安全的修改：
- en: '`putIfAbsent()`—Adds the key-value pair to the `HashMap` if the key isn’t already
    present.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putIfAbsent()`—如果键不存在，则将键值对添加到 `HashMap` 中。'
- en: '`remove()`—Safely removes the key-value pair if the key is present.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`—如果键存在，则安全地删除键值对。'
- en: '`replace()`—The implementation provides two different forms of this method
    for safe replacement in the `HashMap`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace()`—该实现为 `HashMap` 中的安全替换提供了两种不同形式的方法。'
- en: 'However, with Java 8, some of these methods were retrofitted to the `Map` interface
    as default methods, for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 Java 8 的推出，其中一些方法被回滚到 `Map` 接口作为默认方法，例如：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The gap between `ConcurrentHashMap` and `Map` has narrowed somewhat in recent
    versions of Java, but don’t forget that despite this, `HashMap` remains thread-unsafe.
    If you want to share data safely between threads, you should use `ConcurrentHashMap`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 的最新版本中，`ConcurrentHashMap` 和 `Map` 之间的差距有所缩小，但别忘了，尽管如此，`HashMap` 仍然是非线程安全的。如果你想在多线程之间安全地共享数据，你应该使用
    `ConcurrentHashMap`。
- en: Overall, the `ConcurrentHashMap` is one of the most useful classes in `java.util.concurrent`.
    It provides additional multithreaded safety and higher performance than synchronization,
    and it has no serious drawbacks in normal usage. The counterpart to it for `List`
    is the `CopyOnWriteArrayList`, which we’ll discuss next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`ConcurrentHashMap` 是 `java.util.concurrent` 中最有用的类之一。它提供了比同步更高的多线程安全性和性能，并且在正常使用中没有任何严重的缺点。对于
    `List` 的对应类是 `CopyOnWriteArrayList`，我们将在下一节中讨论。
- en: 6.6 CopyOnWriteArrayList
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 CopyOnWriteArrayList
- en: We can, of course, apply the two unsatisfactory concurrency patterns that we
    saw in the previous section to `List` as well. Fully synchronized and immutable
    (but with mutating methods that throw runtime exception) lists are as easy to
    write down as they are for maps, and they work no better than they do for maps.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以将我们在上一节中看到的两个不令人满意的并发模式应用到 `List` 上。完全同步和不可变（但具有抛出运行时异常的修改方法）的列表与映射一样容易编写，并且它们的效果也不比映射好。
- en: Can we do better? Unfortunately, the linear nature of the list is not helpful
    here. Even in the case of a linked list, multiple threads attempting to modify
    the list raise the possibility of contention, for example, in workloads that have
    a large percentage of append operations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？不幸的是，列表的线性性质在这里没有帮助。即使在链表的情况下，多个线程尝试修改列表也会引发竞争的可能性，例如，在工作负载中有很大比例的追加操作时。
- en: One alternative that does exist is the `CopyOnWriteArrayList` class. As the
    name suggests, this type is a replacement for the standard `ArrayList` class that
    has been made thread-safe by the addition of *copy-on-write semantics*. This means
    that any operations that mutate the list will create a new copy of the array backing
    the list (as shown in figure 6.4). This also means that any iterators created
    don’t have to worry about any modifications that they didn’t expect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个替代方案，那就是`CopyOnWriteArrayList`类。正如其名所示，这种类型是标准`ArrayList`类的替代品，它通过添加*写时复制（copy-on-write）语义*来提高线程安全性。这意味着任何修改列表的操作都将创建一个新副本，作为列表背后的数组（如图6.4所示）。这也意味着任何创建的迭代器都不必担心任何未预期的修改。
- en: '![](../Images/CH06_F04_Evans2.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F04_Evans2.png)'
- en: Figure 6.4 Copy-on-write array
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 写时复制数组
- en: The iterators are guaranteed not to throw `ConcurrentModificationException`
    and will not reflect any additions, removals, or changes to the list since the
    iterator was created—except, of course, that (as usual in Java) the list elements
    can still mutate. It is only the list that cannot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器保证不会抛出`ConcurrentModificationException`，并且不会反映自迭代器创建以来列表的任何添加、删除或更改——当然，除了（在Java中通常如此）列表元素仍然可以修改。只是列表本身不能。
- en: This implementation is usually too expensive for general use but may be a good
    option when traversal operations vastly outnumber mutations, and when the programmer
    does not want the headache of synchronization, yet wants to rule out the possibility
    of threads interfering with each other.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现通常对于一般用途来说太昂贵，但在遍历操作远多于变异操作，并且程序员不想处理同步的麻烦，但又想排除线程相互干扰的可能性时，可能是一个不错的选择。
- en: 'Let’s take a quick look at how the core idea is implemented. The key methods
    are `iterator()`, which always returns a new `COWIterator` object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下核心思想是如何实现的。关键方法是`iterator()`，它始终返回一个新的`COWIterator`对象：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'and `add()`, `remove()`, and other mutation methods. The mutation methods always
    replace the delegate array with a new, cloned, and modified copy of the array.
    Protecting the array must be done within a synchronized block, so the `CopyOnWriteArrayList`
    class has an internal lock that is just used as a monitor (and note the comment
    on it), as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`add()`、`remove()`和其他变异方法。变异方法始终用新的、克隆的并修改后的数组副本替换代表数组。保护数组必须在同步块内完成，因此`CopyOnWriteArrayList`类有一个内部锁，仅用作监视器（并注意其注释），如下所示：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, operations such as `add()` can be protected as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将像`add()`这样的操作保护如下：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This makes the `CopyOnWriteArrayList` less efficient than the `ArrayList` for
    general operations, for several reasons:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`CopyOnWriteArrayList`在一般操作上比`ArrayList`效率更低，原因有几个：
- en: Synchronization of mutation operations.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异操作的同步。
- en: Volatile storage (i.e., `array`).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易失性存储（即`array`）。
- en: '`ArrayList` will only allocate memory when a resize of the underlying array
    is required; `CopyOnWriteArrayList` allocates and copies on every mutation.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList`仅在需要调整底层数组的大小时才会分配内存；`CopyOnWriteArrayList`在每次变异时都会分配和复制。'
- en: 'Creating the iterator stores a reference to the array as it exists at that
    point in time. Further modifications to the list cause a new copy to be created,
    so the iterator will then be pointing at a past version of the array, as shown
    next:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建迭代器时，会存储一个对该数组在那一刻存在的引用。进一步修改列表将导致创建一个新的副本，因此迭代器将指向数组的一个过去版本，如下所示：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `COWIterator` implements `ListIterator` and so, according to the interface
    contract, is required to support list mutation methods, but for simplicity’s sake,
    the mutators all throw `UnsupportedOperationException`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`COWIterator`实现了`ListIterator`，因此根据接口合同，它必须支持列表变异方法，但为了简单起见，所有变异方法都抛出`UnsupportedOperationException`。
- en: The approach taken by `CopyOnWriteArrayList` to shared data may be useful when
    a quick, consistent snapshot of data (which may occasionally be different between
    readers) is more important than perfect synchronization. This is seen reasonably
    often in scenarios that involve non-mission-critical data, and the copy-on-write
    approach avoids the performance hit associated with synchronization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList` 对共享数据采取的方法，当快速、一致的数据快照（读者之间可能偶尔不同）比完美的同步更重要时可能很有用。这在涉及非关键数据的情况下相当常见，而写时复制的方法避免了与同步相关的性能损失。'
- en: Let’s look at an example of copy-on-write in action in the next listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个列表中写时复制的实际示例。
- en: Listing 6.3 Copy-on-write example
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 基于写时复制的示例
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code is specifically designed to illustrate the behavior of an `Iterator`
    under copy-on-write semantics. It produces output like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码专门设计来展示 `Iterator` 在写时复制语义下的行为。它产生如下输出：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In general, the use of the `CopyOnWriteArrayList` class does require a bit more
    thought than using `ConcurrentHashMap`, which is basically a drop-in concurrent
    replacement for `HashMap` because of performance issues—the copy-on-write property
    means that if the list is altered, the entire array must be copied. If changes
    to the list are common, compared to read accesses, this approach won’t necessarily
    yield high performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用 `CopyOnWriteArrayList` 类比使用 `ConcurrentHashMap` 需要更多的思考，因为 `ConcurrentHashMap`
    主要是由于性能问题而成为 `HashMap` 的并发替代品——写时复制的特性意味着如果列表被修改，整个数组必须被复制。如果列表的更改比读取访问更常见，这种方法不一定能提供高性能。
- en: In general, the `CopyOnWriteArrayList` makes different trade-offs than `synchronizedList()`.
    The latter synchronizes on all operations, so reads from different threads can
    block each other, which is not true for a COW data structure. On the other hand,
    `CopyOnWriteArrayList` copies the backing array on every mutation, whereas the
    synchronized version does so only when the backing array is full (the same behavior
    as `ArrayList`). However, as we’ll say repeatedly in chapter 7, reasoning about
    code from first principles is extremely difficult—the only way to reliably get
    well-performing code is to test, retest, and measure the results.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`CopyOnWriteArrayList` 与 `synchronizedList()` 的权衡不同。后者在所有操作上同步，因此不同线程的读取可以相互阻塞，这在
    COW 数据结构中并不成立。另一方面，`CopyOnWriteArrayList` 在每次变异时都会复制底层数组，而同步版本仅在底层数组满时才这样做（与 `ArrayList`
    的行为相同）。然而，正如我们在第 7 章中反复所说的，从第一原理推理代码极其困难——唯一可靠地获得高性能代码的方法是测试、重新测试并衡量结果。
- en: Later, in chapter 15, we’ll meet the concept of a *persistent data structure*,
    which is another way of approaching concurrent data handling. The Clojure programming
    language makes very heavy use of persistent data structures, and the `CopyOnWriteArrayList`
    (and `CopyOnWriteArraySet`) is one example implementation of them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 15 章中，我们将遇到**持久数据结构**的概念，这是另一种处理并发数据的方法。Clojure 编程语言非常重视持久数据结构，`CopyOnWriteArrayList`（以及
    `CopyOnWriteArraySet`）是它们的实现示例之一。
- en: Let’s move on. The next major common building block of concurrent code in `java.util.concurrent`
    is the `Queue`. This is used to hand off work elements between threads, and it
    is used as the basis for many flexible and reliable multithreaded designs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进。`java.util.concurrent` 中并发代码的下一个主要常见构建块是 `Queue`。它用于在线程之间传递工作元素，并且它是许多灵活和可靠的多线程设计的基础。
- en: 6.7 Blocking queues
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 阻塞队列
- en: The queue is a wonderful abstraction for concurrent programming. The queue provides
    a simple and reliable way to distribute processing resources to work units (or
    to assign work units to processing resources, depending on how you want to look
    at it).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是并发编程的一个奇妙抽象。队列提供了一个简单且可靠的方式来分配处理资源给工作单元（或者根据你如何看待它，将工作单元分配给处理资源）。
- en: A number of patterns in multithreaded Java programming rely heavily on the thread-safe
    implementations of `Queue`, so it’s important that you fully understand it. The
    basic `Queue` interface is in `java.util`, because it can be an important pattern,
    even in single-threaded programming, but we’ll focus on the multithreaded use
    cases.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程 Java 编程中的许多模式都严重依赖于 `Queue` 的线程安全实现，因此完全理解它是很重要的。基本的 `Queue` 接口在 `java.util`
    中，因为它可以是一个重要的模式，即使在单线程编程中也是如此，但我们将关注多线程的使用案例。
- en: One very common use case, and the one we’ll focus on, is the use of a queue
    to transfer work units between threads. This pattern is often ideally suited for
    the simplest concurrent extension of `Queue`—the `BlockingQueue`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的用例，也是我们将要关注的，是使用队列在线程之间传递工作单元。这种模式通常非常适合 `Queue` 的最简单的并发扩展——`BlockingQueue`。
- en: 'The `BlockingQueue` is a queue that has the following two additional special
    properties:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue` 是一个具有以下两个额外特殊属性的队列：'
- en: When trying to `put()` to the queue, it will cause the putting thread to wait
    for space to become available if the queue is full.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尝试向队列 `put()` 时，如果队列已满，它将导致放置线程等待空间变得可用。
- en: When trying to `take()` from the queue, it will cause the taking thread to block
    if the queue is empty.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尝试从队列中 `take()` 时，如果队列为空，它将导致获取线程阻塞。
- en: These two properties are very useful because if one thread (or pool of threads)
    is outstripping the ability of the other to keep up, the faster thread is forced
    to wait, thus regulating the overall system. This is illustrated in figure 6.5.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性非常有用，因为如果一个线程（或线程池）的能力超过了另一个线程的能力，那么较快的线程将被迫等待，从而调节整个系统。这如图 6.5 所示。
- en: '![](../Images/CH06_F05_Evans2.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 `BlockingQueue`](../Images/CH06_F05_Evans2.png)'
- en: Figure 6.5 The `BlockingQueue`
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 `BlockingQueue`
- en: 'Java ships with two basic implementations of the `BlockingQueue` interface:
    the `LinkedBlockingQueue` and the `ArrayBlockingQueue`. They offer slightly different
    properties; for example, the array implementation is very efficient when an exact
    bound is known for the size of the queue, whereas the linked implementation may
    be slightly faster under some circumstances.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Java 随带实现了两个基本的 `BlockingQueue` 接口：`LinkedBlockingQueue` 和 `ArrayBlockingQueue`。它们提供了一些不同的属性；例如，当队列的大小有一个确切的上限时，数组实现非常高效，而在某些情况下，链式实现可能稍微快一些。
- en: However, the real difference between the implementations is in the implied semantics.
    Although the linked variant can be constructed with a size limit, it is usually
    created without one, which leads to an object with a queue size of `Integer.MAX_VALUE`.
    This is effectively infinite—a real application would never be able to recover
    from a backlog of over two billion items in one of its queues.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现之间的真正区别在于隐含的语义。尽管链式变体可以构建一个大小限制，但它通常是不带限制创建的，这导致了一个队列大小为 `Integer.MAX_VALUE`
    的对象。这实际上是无限的——在实际应用中，其队列中超过二十亿项的积压是无法恢复的。
- en: So, although in theory the `put()` method on `LinkedBlockingQueue` can block,
    in practice, it never does. This means that the threads that are writing to the
    queue can effectively proceed at an unlimited rate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然在理论上 `LinkedBlockingQueue` 上的 `put()` 方法可能会阻塞，但在实践中，它从未这样做。这意味着正在向队列写入的线程可以有效地以无限的速度进行。
- en: In contrast, the `ArrayBlockingQueue` has a fixed size for the queue—the size
    of the array that backs it. If the producer threads are putting objects into the
    queue faster than they are being processed by receivers, at some point the queue
    will fill completely, further attempts to call `put()` will block, and the producer
    threads will be forced to slow their rate of task production.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`ArrayBlockingQueue` 的队列大小是固定的——支持它的数组的大小。如果生产线程将对象放入队列的速度比接收者处理的速度快，那么在某个时候，队列将完全填满，进一步调用
    `put()` 的尝试将阻塞，生产线程将被迫降低任务生产的速度。
- en: This property of the `ArrayBlockingQueue` is one form of what is known as *back
    pressure*, which is an important aspect of engineering concurrent and distributed
    systems.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBlockingQueue` 的这个属性是所谓的 *背压* 的一种形式，这是并发和分布式系统工程的一个重要方面。'
- en: 'Let’s see the `BlockingQueue` in action in an example: altering the account
    example to use queues and threads. The aim of the example will be to get rid of
    the need to lock both account objects. The basic architecture of the application
    is shown in figure 6.6.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看 `BlockingQueue` 的实际应用：将账户示例修改为使用队列和线程。示例的目标是消除对账户对象进行锁定的需求。应用程序的基本架构如图
    6.6 所示。
- en: '![](../Images/CH06_F06_Evans2.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 处理带队列的账户](../Images/CH06_F06_Evans2.png)'
- en: Figure 6.6 Handling accounts with queues
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 处理带队列的账户
- en: We start by introducing a `AccountManager` class with these fields, as shown
    in the next listing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过以下列表引入一个具有这些字段的 `AccountManager` 类。
- en: Listing 6.4 The `AccountManager` class
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 `AccountManager` 类
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The blocking queues contain `TransferTask` objects, which are simple data carriers
    that denote the transfer to be made, as shown next:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞队列包含 `TransferTask` 对象，这些是简单的数据载体，表示要进行的传输，如下所示：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is no additional semantics for the transfer—the class is just a dumb *data
    carrier* type.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 转账没有额外的语义——该类只是一个笨拙的*数据载体*类型。
- en: Note The `TransferTask` type is very simple and, in Java 17, could be written
    as a record type (which we met in chapter 3)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`TransferTask`类型非常简单，在Java 17中可以写成记录类型（我们在第3章中遇到过）
- en: 'The `AccountManager` class provides functionality for accounts to be created
    and for transfer tasks to be submitted, as illustrated here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountManager`类提供了创建账户和提交转账任务的功能，如下所示：'
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The real work of the `AccountManager` is handled by the two threads that manage
    the transfer tasks between the queues. Let’s look at the withdraw operation first:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountManager`的实际工作由管理队列之间转账任务的两个线程处理。让我们首先看看提款操作：'
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The deposit operation is defined similarly, and then we initialize the account
    manager with the tasks:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 存款操作的定义与此类似，然后我们使用以下任务初始化账户管理器：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The package-private overload of the `init()` method is used to start the background
    threads. It exists as a separate method to allow for easier testing, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`方法的包私有重载用于启动后台线程。它作为一个单独的方法存在，以便更容易进行测试，如下所示：'
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need some code to drive this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些代码来驱动这个过程：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Submits the transfer from acc1 to acc2
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从acc1提交转账到acc2
- en: ❷ Sleeps to allow time for the transfer to execute
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 睡眠以允许时间执行转账
- en: 'This produces output like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生如下输出：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, the code as written does not execute cleanly, despite the calls to
    `shutdown()` and `await()` because of the blocking nature of the calls used. Let’s
    look at figure 6.7 to see why.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管调用了`shutdown()`和`await()`，代码仍然没有干净地执行，因为使用的调用具有阻塞性质。让我们看看图6.7来了解原因。
- en: '![](../Images/CH06_F07_Evans2.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F07_Evans2.png)'
- en: Figure 6.7 An incorrect shutdown sequence
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 错误的关闭序列
- en: When the main code calls `shutdown()`, the volatile boolean flag is flipped
    to true, so every subsequent read of the boolean will see the value as true. Unfortunately,
    both the withdrawal and depositing threads are blocked in calls to `take()` because
    the queues are empty. If an object was somehow placed into the `pending` queue,
    then the withdrawal thread would process it and then place the object into the
    `forDeposit` queue (assuming the withdrawal succeeds). The withdrawal thread would
    at this point exit the `while` loop, and the thread would terminate normally.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当主代码调用`shutdown()`时，volatile布尔标志被翻转成true，所以后续对布尔值的每次读取都将看到这个值。不幸的是，由于队列是空的，提款和存款线程都阻塞在`take()`调用中。如果
    somehow 将对象放入`pending`队列中，那么提款线程将处理它，然后将对象放入`forDeposit`队列（假设提款成功）。此时，提款线程将退出`while`循环，线程将正常终止。
- en: In turn, the depositing thread will now see the object in the `forDeposit` queue
    and will wake up, take it, process it, and then exit its own `while` loop and
    also terminate normally. However, this clean termination process depends on there
    still being tasks in the queue. In the edge case of an empty queue, the threads
    will sit in their blocking `take()` calls forever. To solve this issue, let’s
    explore the full range of methods that are provided by the blocking queue implementations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，存款线程将看到`forDeposit`队列中的对象并唤醒，取走它，处理它，然后退出自己的`while`循环并正常终止。然而，这个干净的终止过程取决于队列中仍然有任务。在队列空的情况边缘，线程将永远坐在它们的阻塞`take()`调用中。为了解决这个问题，让我们探索阻塞队列实现提供的完整方法集。
- en: 6.7.1 Using BlockingQueue APIs
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.1 使用BlockingQueue API
- en: 'The interface `BlockingQueue` actually provides three separate strategies for
    interacting with it. To understand the differences between the strategies, consider
    the possible behaviors that an API could display in the following scenario: a
    thread attempts to insert an item in a capacity-restricted queue that is currently
    unable to accommodate the item (i.e., the queue is full).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue`接口实际上提供了三种与它交互的独立策略。为了理解策略之间的差异，考虑以下场景中API可能显示的可能行为：一个线程尝试向一个当前无法容纳项目的容量受限队列中插入一个项目（即队列已满）。'
- en: Logically, we have the following three possibilities. The insertion call could
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，我们有以下三种可能性。插入调用可能
- en: Block until space in the queue frees up
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞直到队列中有空间释放
- en: Return a value (perhaps Boolean false) indicating failure
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个值（可能是Boolean false）以指示失败
- en: Throw an exception
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: The same three possibilities would, of course, occur in the converse situation
    (attempting to take an item from an empty queue). The first of these possibilities
    is realized by the `take()` and `put()` methods that we have already met.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在相反的情况下（尝试从一个空队列中取出项），也会出现同样的三种可能性。这些可能性中的第一种是通过我们已遇到的`take()`和`put()`方法实现的。
- en: Note The second and third are the options provided by the `Queue` interface,
    which is the super interface of `BlockingQueue`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第二和第三是`Queue`接口提供的选项，它是`BlockingQueue`的超接口。
- en: The second option provides a nonblocking API that returns special values and
    is manifested in the methods `offer()` and `poll()`. If insertion into the queue
    cannot be completed, then `offer()` fails fast and returns false. The programmer
    must examine the return code and take appropriate action.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选项提供了一个非阻塞的API，它返回特殊值，并在`offer()`和`poll()`方法中体现。如果无法完成队列的插入，则`offer()`会快速失败并返回false。程序员必须检查返回码并采取适当的行动。
- en: Similarly, `poll()` immediately returns `null` on failure to retrieve from the
    queue. It might seem a bit odd to have a nonblocking API on a class explicitly
    named `BlockingQueue`, but it is actually useful (and also required as a consequence
    of the inheritance relationship between `BlockingQueue` and `Queue`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`poll()`在无法从队列中检索时立即返回`null`。在名为`BlockingQueue`的类上使用非阻塞API可能看起来有些奇怪，但实际上是有用的（并且也是由于`BlockingQueue`和`Queue`之间的继承关系所要求的）。
- en: In fact, `BlockingQueue` provides an additional overload of the nonblocking
    methods. These methods provide the capability of polling or offering with a timeout,
    to allow the thread encountering issues to back out from its interaction with
    the queue and do something else instead.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`BlockingQueue`提供了非阻塞方法的额外重载。这些方法提供了带有超时的轮询或提供的功能，以便遇到问题的线程可以从与队列的交互中退出并做其他事情。
- en: 'We can modify the `AccountManager` in listing 6.4 to use the nonblocking APIs
    with a timeout, like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将列表6.4中的`AccountManager`修改为使用带有超时的非阻塞API，如下所示：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ If the timer expires, poll() returns null.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果计时器到期，`poll()`返回null。
- en: ❷ Explicit use of a Java loop label to make it clear what is being continued.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显式使用Java循环标签以清楚地表明正在继续什么。
- en: Similar modifications should be made for the deposit thread as well.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也需要对存款线程进行类似的修改。
- en: This solves the shutdown problem that we outlined in the previous subsection,
    because now the threads cannot block forever in the retrieval methods. Instead,
    if no object arrives before the timeout, then the poll will still return and provide
    the value `null`. The test then continues the loop, but the visibility guarantees
    of the volatile Boolean ensure that the `while` loop condition is now met and
    the loop is exited and the thread shuts down cleanly. This means that overall,
    once the `shutdown()` method has been called, the `AccountManager` will shut down
    in bounded time, which is the behavior we want.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们在前一小节中概述的关闭问题，因为现在线程在检索方法中不会永远阻塞。相反，如果在超时之前没有对象到达，则`poll()`仍然会返回并提供值`null`。然后测试将继续循环，但volatile布尔值的可见性保证确保`while`循环条件现在得到满足，循环退出并且线程干净地关闭。这意味着，总的来说，一旦调用`shutdown()`方法，`AccountManager`将在有限的时间内关闭，这正是我们想要的行为。
- en: 'To conclude the discussion of the APIs of `BlockingQueue`, we should look at
    the third approach we mentioned earlier: methods that throw exceptions if the
    queue operation cannot immediately complete. These methods, `add()` and `remove()`,
    are, frankly, problematic for several reasons, not least of which is that the
    exceptions they throw on failure (`IllegalStateException` and `NoSuchElementException`
    respectively) are runtime exceptions and so do not need to be explicitly handled.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束对`BlockingQueue` API的讨论，我们应该看看我们之前提到的第三种方法：如果队列操作无法立即完成，则抛出异常的方法。这些方法`add()`和`remove()`，坦白地说，由于几个原因而存在问题，其中最不重要的是它们在失败时抛出的异常（分别是`IllegalStateException`和`NoSuchElementException`）是运行时异常，因此不需要显式处理。
- en: The problems with the exception-throwing API are deeper than just this, though.
    A general principle in Java states that exceptions are to be used to deal with
    exceptional circumstances, that is, those that a program does not normally consider
    to be part of normal operation. The situation of an empty queue is, however, an
    entirely possible circumstance. So throwing an exception in response to it is
    a violation of the principle that is sometimes expressed as “Don’t use exceptions
    for flow control.”
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异常抛出 API 的问题远不止于此。Java 中的一个普遍原则是，异常应该用于处理异常情况，即程序通常不认为它们是正常操作的一部分。然而，空队列的情况却是一个完全可能的情况。因此，对此情况抛出异常违反了有时被表述为“不要使用异常进行流程控制”的原则。
- en: Exceptions are, in general, quite expensive to use, due to stack trace construction
    when the exception is instantiated and stack unwinding during the throw. It is
    good practice not to create an exception unless it is going to immediately be
    thrown. For these reasons, we do recommend against using the exception-throwing
    form of the `BlockingQueue` APIs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 异常通常很昂贵，因为当异常实例化时需要构建堆栈跟踪，在抛出时需要执行堆栈回溯。因此，除非异常将立即被抛出，否则不创建异常是一个好的做法。出于这些原因，我们确实建议不要使用
    `BlockingQueue` API 的异常抛出形式。
- en: 6.7.2 Using WorkUnit
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.2 使用 WorkUnit
- en: 'The `Queue` interfaces are all generic: they’re `Queue<E>`, `BlockingQueue<E>`,
    and so on. Although it may seem strange, it’s sometimes wise to exploit this and
    introduce an artificial container class to wrap the items of work.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 接口都是泛型的：它们是 `Queue<E>`、`BlockingQueue<E>` 等等。尽管这可能看起来有些奇怪，但有时利用这一点并引入一个人工的容器类来包装工作项是明智的。'
- en: 'For example, if you have a class called `MyAwesomeClass` that represents the
    units of work that you want to process in a multithreaded application, then rather
    than having this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个名为 `MyAwesomeClass` 的类，它代表你想要在多线程应用程序中处理的工作单元，那么你不会这样做：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'it can be better to have this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，这样做可能更好：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'where `WorkUnit` (or `QueueObject`, or whatever you want to call the container
    class) is a packaging class that may look something like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `WorkUnit`（或 `QueueObject`，或你想要称谓的容器类）是一个包装类，可能看起来像这样：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The reason for doing this is that this level of indirection provides a place
    to add additional metadata without compromising the conceptual integrity of the
    contained type (`MyAwesomeClass`, in this example). In figure 6.8, we can see
    how the external metadata wrapper works.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的原因是这种级别的间接性提供了一个地方来添加额外的元数据，而不会损害包含类型（在这个例子中是 `MyAwesomeClass`）的概念完整性。在图
    6.8 中，我们可以看到外部元数据包装器是如何工作的。
- en: '![](../Images/CH06_F08_Evans2.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F08_Evans2.png)'
- en: Figure 6.8 Use of a work unit as a metadata wrapper
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 使用工作单元作为元数据包装器
- en: 'This is surprisingly useful. Use cases where additional metadata is helpful
    are abundant. Here are a few examples:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常实用。需要额外元数据的使用场景很多。以下是一些例子：
- en: Testing (such as showing the change history for an object)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试（例如显示对象的变更历史）
- en: Performance indicators (such as time of arrival or quality of service)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能指标（例如到达时间或服务质量）
- en: Runtime system information (such as how this instance of `MyAwesomeClass` has
    been routed)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时系统信息（例如这个 `MyAwesomeClass` 实例是如何被路由的）
- en: It can be much harder to add in this indirection after the fact. If you later
    discover that more metadata is needed in certain circumstances, it can be a major
    refactoring job to add in what would have been a simple change in the `WorkUnit`
    class. Let’s move on to discuss futures, which are a way of representing a placeholder
    for an in-progress (usually on another thread) task in Java.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在事后添加这种间接性可能要困难得多。如果你后来发现某些情况下需要更多的元数据，那么在 `WorkUnit` 类中添加这些原本简单的更改可能需要进行重大的重构工作。让我们继续讨论期货，期货是表示
    Java 中正在进行的（通常在另一个线程上）任务占位符的一种方式。
- en: 6.8 Futures
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 期货
- en: 'The interface `Future` in `java.util.concurrent` is a simple representation
    of an asynchronous task: it is a type that holds the result from a task that may
    not have finished yet but may at some point in the future. The primary methods
    on a `Future` follow:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 中的 `Future` 接口是对异步任务的一个简单表示：它是一个类型，它持有来自可能尚未完成但可能在未来的某个时刻完成的任务的结果。`Future`
    上的主要方法如下：'
- en: '`get()`—Gets the result. If the result isn’t yet available, will block until
    it is.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`—获取结果。如果结果尚未可用，将阻塞直到它可用。'
- en: '`isDone()`—Allows the caller to determine whether the computation has finished.
    It is nonblocking.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDone()`—允许调用者确定计算是否已完成。它是非阻塞的。'
- en: '`cancel()`—Allows the computation to be canceled before completion.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel()`——允许在完成之前取消计算。'
- en: There’s also a version of `get()` that takes a timeout, which won’t block forever,
    in a similar manner to the `BlockingQueue` methods with timeouts that we met earlier.
    The next listing shows a sample use of a `Future` in a prime number finder.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个版本的 `get()` 方法接受超时，它不会永远阻塞，类似于我们之前遇到的带有超时的 `BlockingQueue` 方法。下面的列表显示了在素数查找器中使用
    `Future` 的一个示例。
- en: Listing 6.5 Finding prime numbers using a `Future`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 使用 `Future` 查找素数
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this snippet, you should imagine that `getNthPrime()` returns a `Future`
    that is executing on some background thread (or even on multiple threads)—perhaps
    on one of the executor frameworks we’ll discuss later in the chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，你应该想象 `getNthPrime()` 返回一个在某个后台线程（甚至多个线程）上执行的未来，可能是我们将在本章后面讨论的执行器框架之一。
- en: The thread running the snippet enters a get-with-timeout and blocks for up to
    60 seconds for a response. If no response is received, then the thread loops and
    enters another blocking wait. Even on modern hardware, this calculation may be
    running for a long time, so you may need to use the `cancel()` method after all
    (although the code as written does not provide any mechanism to cancel our request).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码片段的线程进入带有超时的 get，并最多阻塞 60 秒等待响应。如果没有收到响应，则线程循环并进入另一个阻塞等待。即使在现代硬件上，这个计算也可能需要很长时间，因此你可能需要使用
    `cancel()` 方法（尽管编写的代码没有提供取消请求的任何机制）。
- en: As a second example, let’s consider nonblocking I/O. Figure 6.9 shows the `Future`
    in action to allow us to use a background thread for I/O.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，让我们考虑非阻塞 I/O。图 6.9 显示了 `Future` 的实际应用，允许我们使用后台线程进行 I/O。
- en: '![](../Images/CH06_F09_Evans2.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F09_Evans2.png)'
- en: Figure 6.9 Using `Future` in Java
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 在 Java 中使用 `Future`
- en: 'This API has been around for a while—it was introduced in Java 7—and it allows
    the user to do nonblocking concurrency like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 已经存在了一段时间——它在 Java 7 中被引入——它允许用户执行类似这样的非阻塞并发操作：
- en: '[PRE33]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Opens the file asynchronously
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 异步打开文件
- en: ❷ Requests a read of up to one million bytes
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 请求读取最多一百万字节
- en: ❸ Does something else
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行其他操作
- en: ❹ Gets the result when ready
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当准备好时获取结果
- en: This structure allows the main thread to `doSomethingElse()` while the I/O operation
    is proceeding on another thread—one that is managed by the Java runtime. This
    is a useful approach, but it requires support in the library that provides the
    capability. This can be somewhat limited—and what if we want to create our own
    asynchronous workflows?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构允许主线程在另一个线程上执行 I/O 操作的同时 `doSomethingElse()`，这个线程是由 Java 运行时管理的。这是一个有用的方法，但它需要提供该功能的库的支持。这可能会有些限制——如果我们想创建自己的异步工作流怎么办？
- en: 6.8.1 CompletableFuture
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.1 CompletableFuture
- en: The Java `Future` type is defined as an interface, rather than a concrete class.
    Any API that wants to use a `Future`-based style has to supply a concrete implementation
    of `Future`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 `Future` 类型被定义为一种接口，而不是一个具体的类。任何想要使用基于 `Future` 风格的 API 都必须提供一个具体的 `Future`
    实现。
- en: These can be challenging for some developers to write and represents an obvious
    gap in the toolkit, so from Java 8 onward, a new approach to futures was included
    in the JDK—a concrete implementation of `Future` that enhances capabilities and
    in some ways is more similar to futures in other languages (e.g., Kotlin and Scala).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些开发者来说，这些可能具有挑战性，并且在工具箱中存在明显的差距，因此从 Java 8 开始，JDK 中包含了一种新的未来方法——`Future`
    的具体实现，它增强了功能，并在某些方面与其他语言中的未来（例如 Kotlin 和 Scala）更相似。
- en: The class is called `CompletableFuture`—it is a concrete type that implements
    the `Future` interface and provides additional functionality and is intended as
    a simple building block for building asynchronous applications. The central idea
    is that we can create instances of the `CompletableFuture<T>` type (it is generic
    in the type of the value that will be returned), and the object that is created
    represents the `Future` in an *uncompleted* (or “unfulfilled”) state.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被称为 `CompletableFuture`——它是一个实现了 `Future` 接口的具体类型，提供了额外的功能，并旨在作为构建异步应用程序的简单构建块。核心思想是我们可以创建
    `CompletableFuture<T>` 类型的实例（它对返回值的类型是泛型的），创建的对象代表一个 *未完成*（或“未满足”）状态的未来。
- en: Later, any thread that has a reference to the completable `Future` can call
    `complete()` on it and provide a value—this completes (or “fulfills”) the future.
    The completed value is immediately visible to all threads that are blocked on
    a `get()` call. After completion, any further calls to `complete()` are ignored.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，任何拥有可完成 `Future` 引用的线程都可以调用其上的 `complete()` 并提供值——这完成了（或“履行”）了未来。完成后的值立即对所有在
    `get()` 调用上阻塞的线程可见。完成之后，任何进一步的 `complete()` 调用都将被忽略。
- en: The `CompletableFuture` cannot cause different threads to see different values.
    The `Future` is either uncompleted or completed, and if it is completed, the value
    it holds is the value provided by the first thread to call `complete()`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` 不能导致不同的线程看到不同的值。`Future` 要么未完成，要么已完成，如果已完成，则它持有的值是第一个调用
    `complete()` 的线程提供的值。'
- en: This is obviously not immutability—the state of the `CompletableFuture` does
    change over time. However, it changes only *once*—from uncompleted to completed.
    There is no possibility of an inconsistent state being seen by different threads.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是不可变性——`CompletableFuture` 的状态会随时间改变。然而，它只改变 *一次*——从未完成到完成。不同线程看到不一致状态的可能性是不存在的。
- en: Note Java’s `CompletableFuture` is similar to a *promise*, as seen in other
    languages (such as JavaScript), which is why we call out the alternative terminology
    of “fulfilling a promise” as well as “completing a future.”
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Java 的 `CompletableFuture` 与其他语言（如 JavaScript）中的 *promise* 类似，这就是为什么我们除了“履行承诺”之外，还提到了“完成未来”的替代术语。
- en: 'Let’s look at an example and implement `getNthPrime()`, which we met earlier:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例并实现 `getNthPrime()`，这是我们之前遇到的：
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Creates the completable Future in an uncompleted state
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个未完成的可完成 Future
- en: ❷ Creates and starts a new thread that will complete the Future
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建并启动一个新线程以完成 Future
- en: ❸ The actual calculation of the prime number
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 实际计算素数
- en: The method `getNthPrime()` creates an “empty” `CompletableFuture` and returns
    this container object to its caller. To drive this, we do need some code to call
    `getNthPrime()`—for example, the code shown in listing 6.5.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNthPrime()` 方法创建一个“空”的 `CompletableFuture` 并将此容器对象返回给其调用者。为了驱动它，我们确实需要一些代码来调用
    `getNthPrime()`——例如，列表 6.5 中显示的代码。'
- en: One way to think about `CompletableFuture` is by analogy with client/server
    systems. The `Future` interface provides only a query method— `isDone()` and a
    blocking `get()`. This is playing the role of the client. An instance of `CompletableFuture`
    plays the role of the server side—it provides full control over the execution
    and completion of the code that is fulfilling the future and providing the value.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `CompletableFuture` 的一个方法是通过与客户端/服务器系统的类比。`Future` 接口只提供查询方法——`isDone()`
    和阻塞的 `get()`。这相当于客户端的角色。`CompletableFuture` 的一个实例扮演服务器端的角色——它提供了对正在履行未来并提供值的代码的执行和完成的完全控制。
- en: In the example, `getNthPrime()` evaluates the call to the number service in
    a separate thread. When this call returns, we complete the future explicitly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`getNthPrime()` 在一个单独的线程中评估对数字服务的调用。当这个调用返回时，我们显式地完成未来。
- en: 'A slightly more concise way to achieve the same effect is to use the `CompletableFuture
    .supplyAsync()` method, passing a `Callable<T>` object representing the task to
    be executed. This call makes use of an application wide thread pool that is managed
    by the concurrency library, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同效果的一种稍微更简洁的方法是使用 `CompletableFuture .supplyAsync()` 方法，传递一个表示要执行的任务的 `Callable<T>`
    对象。此调用利用了由并发库管理的全局线程池，如下所示：
- en: '[PRE35]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This concludes our initial tour of the concurrent data structures that are some
    of the main building blocks that provide the raw materials for developing solid
    multithreaded applications.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对并发数据结构的初步探索的结束，这些数据结构是构建坚固的多线程应用程序的主要构建块之一。
- en: Note We will have more to say about the `CompletableFuture` later in the book,
    specifically in the chapters that discuss advanced concurrency and the interplay
    with functional programming.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本书后面还将详细介绍 `CompletableFuture`，特别是在讨论高级并发和与函数式编程交互的章节中。
- en: Next, we’ll introduce the *executors* and threadpools that provide a higher-level
    and more convenient way to handle execution than the raw API based on `Thread`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 *executors* 和 threadpools，它们提供了一种比基于 `Thread` 的原始 API 更高级、更方便的方式来处理执行。
- en: 6.9 Tasks and execution
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 任务和执行
- en: The class `java.lang.Thread` has existed since Java 1.0—one of the original
    talking points of the Java language was built-in, language-level support for multithreading.
    It is powerful and expresses concurrency in a form that is close to the underlying
    operating system support. However, it is a fundamentally low-level API for handling
    concurrency.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Thread` 类自 Java 1.0 以来就存在了——Java 语言最初的一个亮点就是内置、语言级别的对多线程的支持。它功能强大，并以接近底层操作系统支持的形式表达并发。然而，它是一个处理并发的根本上是低级
    API。'
- en: This low-level nature makes it hard for many programmers to work with correctly
    or efficiently. Other languages that were released after Java learned from Java’s
    experience with threads and built upon them to provide alternative approaches.
    Some of those approaches have, in turn, influenced the design of `java.util.concurrent`
    and later innovations in Java concurrency.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这种低级特性使得许多程序员难以正确或高效地使用它。在 Java 之后发布的其他语言从 Java 的线程经验中学习，并在此基础上提供了替代方法。其中一些方法反过来又影响了
    `java.util.concurrent` 的设计以及 Java 并发方面的后续创新。
- en: In this case, our immediate goal is to have tasks (or work units) that can be
    executed without spinning up a new thread for each one. Ultimately, this means
    that the tasks have to be modeled as code that can be called rather than directly
    represented as a thread.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的直接目标是让任务（或工作单元）能够在不为每个任务启动新线程的情况下执行。最终，这意味着任务必须被建模为可调用的代码，而不是直接表示为线程。
- en: Then, these tasks can be scheduled on a shared resource—a pool of threads—that
    executes a task to completion and then moves on to the next task. Let’s take a
    look at how we model these tasks.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些任务可以调度到共享资源——一个线程池——上，该线程池执行任务直到完成，然后继续下一个任务。让我们看看我们是如何建模这些任务的。
- en: 6.9.1 Modeling tasks
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.1 任务建模
- en: 'In this section, we’ll look at two different ways of modeling tasks: the `Callable`
    interface and the `FutureTask` class. We could also consider `Runnable`, but it
    is not always that useful, because the `run()` method does not return a value,
    and, therefore, it can perform work only via side effects.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两种不同的任务建模方法：`Callable` 接口和 `FutureTask` 类。我们也可以考虑 `Runnable`，但它并不总是那么有用，因为
    `run()` 方法不返回值，因此它只能通过副作用执行工作。
- en: One other aspect of the task modeling is important but may not be obvious— the
    notion that if we assume that our thread capacity is finite, tasks must definitely
    complete in bounded time.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 任务建模的另一个重要方面虽然可能不明显——即如果我们假设我们的线程容量是有限的，那么任务必须在有限的时间内完成。
- en: If we have the possibility of an infinite loop, some tasks could “steal” an
    executor thread from the pool, and this would reduce the overall capacity for
    all tasks from then on. Over time, this could eventually lead to exhaustion of
    the thread pool resource and no further work being possible. As a result, we must
    be careful that any tasks we construct do actually obey the “terminate in finite
    time” principle.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有无限循环的可能性，一些任务可能会“窃取”池中的一个执行线程，这将从那时起减少所有任务的总体容量。随着时间的推移，这最终可能导致线程池资源耗尽，无法进行进一步的工作。因此，我们必须小心，确保我们构建的任何任务确实遵守“在有限时间内终止”的原则。
- en: Callable interface
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用接口
- en: The `Callable` interface represents a very common abstraction. It represents
    a piece of code that can be called and returns a result. Despite being a straightforward
    idea, this is actually a subtle and powerful concept that can lead to some extremely
    useful patterns.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable` 接口代表一个非常常见的抽象。它代表了一段可以被调用并返回结果的代码。尽管这是一个直接的想法，但实际上这是一个微妙且强大的概念，可以导致一些极其有用的模式。'
- en: 'One typical use of a `Callable` is the lambda expression (or an anonymous implementation).
    The last line of this snippet sets `s` to be the value of `out.toString()`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable` 的一个典型用途是 lambda 表达式（或匿名实现）。这个片段的最后一行将 `s` 设置为 `out.toString()` 的值：'
- en: '[PRE36]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Think of a `Callable` as being a deferred invocation of the single method, `call()`,
    which the lambda provides.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Callable` 视为对 lambda 提供的单个方法 `call()` 的延迟调用。
- en: FutureTask class
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: FutureTask 类
- en: 'The `FutureTask` class is one commonly used implementation of the `Future`
    interface, which also implements `Runnable`. As we’ll see, this means that a `FutureTask`
    can be fed to executors. The API of `FutureTask` is basically that of `Future`
    and `Runnable` combined: `get()`, `cancel()`, `isDone()`, `isCancelled()`, and
    `run()`, although the last of these—the one that does the actual work—would be
    called by the executor, rather than directly by client code.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`FutureTask` 类是 `Future` 接口的一个常用实现，它也实现了 `Runnable`。正如我们将看到的，这意味着 `FutureTask`
    可以提供给执行器。`FutureTask` 的 API 基本上是 `Future` 和 `Runnable` 的组合：`get()`、`cancel()`、`isDone()`、`isCancelled()`
    和 `run()`，尽管最后一个——实际执行工作的那个——将由执行器调用，而不是由客户端代码直接调用。'
- en: 'Two convenience constructors for `FutureTask` are provided: one that takes
    a `Callable` and one that takes a `Runnable` (which uses `Executors.callable()`
    to convert the `Runnable` to a `Callable`). This suggests a flexible approach
    to tasks, allowing a job to be written as a `Callable` then wrapped into a `FutureTask`
    that can then be scheduled (and cancelled, if necessary) on an executor, due to
    the `Runnable` nature of `FutureTask`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`FutureTask` 提供了两个便利的构造函数：一个接受 `Callable`，另一个接受 `Runnable`（它使用 `Executors.callable()`
    将 `Runnable` 转换为 `Callable`）。这表明了一种灵活的任务处理方法，允许将工作编写为 `Callable`，然后将其包装到 `FutureTask`
    中，这样就可以在执行器上调度（如果需要，还可以取消）它，这是由于 `FutureTask` 的 `Runnable` 特性。'
- en: The class provides a simple state model for tasks and management of a task through
    that model. The possible state transitions are shown in figure 6.10
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了一个简单的任务状态模型，并通过该模型管理任务。可能的状态转换在图 6.10 中显示。
- en: '![](../Images/CH06_F10_Evans2.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 任务状态模型](../Images/CH06_F10_Evans2.png)'
- en: Figure 6.10 State model for tasks
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 任务状态模型
- en: This is sufficient for a wide range of ordinary execution possibilities. Let’s
    meet the standard executors that are provided by the JDK.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于广泛的普通执行可能性是足够的。让我们来看看 JDK 提供的标准执行器。
- en: 6.9.2 Executors
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.2 执行器
- en: 'A couple of standard interfaces are used to describe the threadpools present
    in the JDK. The first is `Executor`, which is very simple and defined like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个标准接口用于描述 JDK 中存在的线程池。第一个是 `Executor`，它非常简单，定义如下：
- en: '[PRE37]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You should note that although this interface has only a single abstract method
    (i.e., it is a so-called SAM type), it is *not* tagged with the annotation `@FunctionalInterface`.
    It can still be used as the target type for a lambda expression, but it is not
    intended for use in functional programming.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，尽管这个接口只有一个抽象方法（即，它是一个所谓的 SAM 类型），但它并没有用 `@FunctionalInterface` 注解标记。它仍然可以用作
    lambda 表达式的目标类型，但它并不打算用于函数式编程。
- en: In fact, the `Executor` is not widely used—far more common is the `ExecutorService`
    interface that extends `Executor` and adds `submit()` as well as several *life
    cycle* methods, such as `shutdown()`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Executor` 并不常用——更常见的是扩展 `Executor` 并添加 `submit()` 以及几个生命周期方法（如 `shutdown()`）的
    `ExecutorService` 接口。
- en: 'To help the developer instantiate and work with some standard threadpools,
    the JDK provides the `Executors` class, which is a collection of static helper
    methods (mostly factories). Four of the most commonly used methods follow:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发者实例化和使用一些标准线程池，JDK 提供了 `Executors` 类，它是一组静态辅助方法（主要是工厂）。以下是最常用的四个方法：
- en: '[PRE38]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s look at each of these in turn. Later in the book, we will dive into some
    of the other, more complex, possibilities that are also provided.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些内容。在本书的后面部分，我们将深入探讨一些其他更复杂但同样提供的可能性。
- en: 6.9.3 Single-threaded executor
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.3 单线程执行器
- en: The simplest of the executors is the single-threaded executor. This is essentially
    an encapsulated combination of a single thread and a task queue (which is a blocking
    queue).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器中最简单的是单线程执行器。这本质上是一个封装的单线程和任务队列（这是一个阻塞队列）的组合。
- en: Client code places an executable task onto the queue via `submit()`. The single
    execution thread then takes the tasks one at a time and runs each to completion
    before taking the next task.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码通过 `submit()` 将可执行任务放入队列。然后单个执行线程一次取一个任务，并运行到完成，然后再取下一个任务。
- en: Note The executors are not implemented as distinct types but instead represent
    different parameter choices when constructing an underlying threadpool.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：执行器不是作为不同的类型实现的，而是表示在构建底层线程池时的不同参数选择。
- en: Any tasks that are submitted while the execution thread is busy are queued until
    the thread is available. Because this executor is backed by a single thread, if
    the previously mentioned “terminate in finite time” condition is violated, it
    means that no subsequently submitted job will ever run.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行线程忙碌时提交的任务将被排队，直到线程可用。因为此执行器由单个线程支持，如果违反了之前提到的“在有限时间内终止”的条件，这意味着随后提交的作业将永远不会运行。
- en: Note This version of the executor is often useful for testing because it can
    be made more deterministic that other forms.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此版本的执行器通常对测试很有用，因为它可以比其他形式更确定。
- en: 'Here is a very simple example of how to use the single-threaded executor:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用单线程执行器的非常简单的例子：
- en: '[PRE39]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `submit()` call hands off the runnable task by placing it on the executor’s
    job queue. That job submission is nonblocking (unless the job queue is full).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit()`调用通过将可运行的任务放置在执行器的作业队列上来传递任务。该作业提交是非阻塞的（除非作业队列已满）。'
- en: However, care must still be taken—for example, if the main thread exits immediately,
    the submitted job may not have had time to be collected by the pool thread and
    may not run. Instead of exiting straightaway, it is wise to call the `shutdown()`
    method on the executor first.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然需要小心——例如，如果主线程立即退出，提交的作业可能没有时间被池线程收集，可能不会运行。为了避免立即退出，首先在执行器上调用`shutdown()`方法是明智的。
- en: The details can be found in the `ThreadPoolExecutor` class, but basically this
    method starts an *orderly shutdown* in which previously submitted tasks are executed
    but no new tasks will be accepted. This effectively solves the issues we saw in
    listing 6.4 about draining the queues of pending transactions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息可以在`ThreadPoolExecutor`类中找到，但基本上这个方法启动了一个*有序关闭*，其中之前提交的任务将被执行，但不会接受新的任务。这有效地解决了我们在6.4列表中看到关于清空挂起事务队列的问题。
- en: Note The combination of a task that loops infinitely and an orderly shutdown
    request will interact badly, resulting in a threadpool that never shuts down.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一个无限循环的任务与有序关闭请求的组合将产生不良交互，导致线程池永远不会关闭。
- en: Of course, if the single-threaded executor was all that was needed, there wouldn’t
    be a need to develop a deep understanding of concurrent programming and its challenges.
    So, we should also look at the alternatives that utilize multiple-executor threads.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果单线程执行器就是所有需要的东西，那么就没有必要深入理解并发编程及其挑战。因此，我们也应该看看利用多个执行器线程的替代方案。
- en: 6.9.4 Fixed-thread pool
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.4 固定线程池
- en: The fixed-thread pool, obtained via one of the variants of `Executors.newFixedThreadPool()`,
    is essentially the multiple-thread generalization of the single-threaded executor.
    At creation time, the user supplies an explicit thread count, and the pool is
    created with that many threads.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Executors.newFixedThreadPool()`的一个变体获得的固定线程池实际上是单线程执行器的多线程推广。在创建时，用户提供一个明确的线程数，并且线程池将使用这么多线程创建。
- en: These threads will be reused to run multiple tasks, one after another. The design
    prevents users having to pay the cost of thread creation. As with the single-threaded
    variant, if all threads are in use, new tasks are stored in a blocking queue until
    a thread becomes free.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这些线程将被重用来运行多个任务，一个接一个。设计防止用户支付线程创建的成本。与单线程变体一样，如果所有线程都在使用中，新任务将存储在阻塞队列中，直到线程空闲。
- en: 'This version of the threadpool is particularly useful if task flow is stable
    and known and if all submitted jobs are roughly the same size, in terms of computation
    duration. It is, once again, most easily created from the appropriate factory
    method, as shown here:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务流稳定且已知，并且所有提交的作业在计算持续时间方面大致相同，则此版本的线程池特别有用。它再次最容易通过适当的工厂方法创建，如下所示：
- en: '[PRE40]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will create an explicit thread pool backed by two executor threads. The
    two threads will take turns accepting tasks from the queue in a nondeterministic
    manner. Even if there is a strict temporal (time-based) ordering of when tasks
    are submitted, there is no guarantee of which thread will handle a given task.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个由两个执行器线程支持的显式线程池。这两个线程将以非确定性的方式轮流从队列中接受任务。即使任务提交有严格的时序（基于时间的）顺序，也无法保证哪个线程将处理给定的任务。
- en: One consequence of this is that in a situation like that shown in figure 6.11,
    the tasks in the downstream queue cannot be relied upon to be accurately temporally
    ordered, even if the tasks in the upstream queue are.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个后果是，在如图6.11所示的情况中，即使上游队列中的任务在时间上准确排序，下游队列中的任务也不能保证准确的时间顺序。
- en: '![](../Images/CH06_F11_Evans2.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F11_Evans2.png)'
- en: Figure 6.11 A threadpool and two queues
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 一个线程池和两个队列
- en: The fixed threadpool has its uses, but it is not the only game in town. For
    one thing, if the executor threads in it die, they are not replaced. If the possibility
    exists of the submitted jobs throwing a runtime exception, this can lead to the
    threadpool starving. Let’s look at another alternative, which makes different
    trade-offs but which can avoid this possibility.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 固定线程池有其用途，但并非市场上唯一的游戏。一方面，如果其中的执行器线程死亡，它们不会被替换。如果提交的工作有抛出运行时异常的可能性，这可能导致线程池饥饿。让我们看看另一种选择，它做出了不同的权衡，但可以避免这种可能性。
- en: 6.9.5 Cached thread pool
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.5 缓存线程池
- en: The fixed threadpool is often used when the activity pattern of the workload
    is known and fairly stable. However, if the incoming work is more uneven or bursty,
    then a pool with a fixed number of threads is likely to be suboptimal.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作负载的活动模式已知且相对稳定时，通常会使用固定线程池。然而，如果进入的工作更加不均匀或突发，那么固定数量的线程池可能不是最优选择。
- en: 'The `CachedThreadPool` is an unbounded pool, that will reuse threads if they
    are available but otherwise will create new threads as required to handle incoming
    tasks, as shown here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`CachedThreadPool`是一个无界池，如果可用将重用线程，否则将根据需要创建新线程来处理进入的任务，如下所示：'
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Threads are kept in the idle cache for 60 seconds, and if they are still present
    at the end of that period, they will be removed from the cache and destroyed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 线程被保留在空闲缓存中60秒，如果它们在那个时间段结束时仍然存在，它们将被从缓存中移除并销毁。
- en: It is, of course, still very important that the tasks do actually terminate.
    If not, then the threadpool will, over time, create more and more threads and
    consume more and more of the machine’s resources and eventually crash or become
    unresponsive.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，确保任务实际上能够终止仍然非常重要。如果不这样做，那么随着时间的推移，线程池将创建越来越多的线程，消耗越来越多的机器资源，最终崩溃或变得无响应。
- en: In general, the trade-off between fixed-size thread pools and cached thread
    pools is largely about reusing threads versus creating and destroying threads
    to achieve different effects. The design of the `CachedThreadPool` should give
    better performance with small asynchronous tasks as compared to the performance
    achieved from fixed-size pools. However, as always, if the effect is thought to
    be significant, proper performance testing much be undertaken.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，固定大小线程池和缓存线程池之间的权衡主要是在重用线程与创建和销毁线程以实现不同效果之间。`CachedThreadPool`的设计应该在小异步任务上提供比固定大小池更好的性能。然而，正如往常一样，如果认为效果显著，必须进行适当的性能测试。
- en: 6.9.6 ScheduledThreadPoolExecutor
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.6 ScheduledThreadPoolExecutor
- en: 'The final example of an executor that we’ll look at is a little bit different.
    This is the `ScheduledThreadPoolExecutor`, sometimes referred to as an STPE, as
    shown here:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的执行器的最后一个例子有一点不同。这是`ScheduledThreadPoolExecutor`，有时简称为STPE，如下所示：
- en: '[PRE42]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that the return type, which we’ve explicitly called out here, is `ScheduledExecutorService`.
    This is different from the other factory methods, which return `ExecutorService`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们明确指出的是返回类型是`ScheduledExecutorService`。这与返回`ExecutorService`的其他工厂方法不同。
- en: Note The `ScheduledThreadPoolExecutor` is a surprisingly capable choice of executor
    and can be used across a wide range of circumstances.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`ScheduledThreadPoolExecutor`是一个令人惊讶的有能力的执行器选择，可以在广泛的情境中使用。
- en: 'The scheduled service extends the usual executor service and adds a small amount
    of new capabilities: `schedule()`, which runs a one-off task after a specified
    delay, and two methods for scheduling periodic (i.e., repeating tasks)—`scheduleAtFixedRate()`
    and `scheduleWithFixedDelay()`.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 调度服务扩展了常规执行器服务并添加了一些新的功能：`schedule()`，在指定延迟后运行一次性的任务，以及两个用于安排周期性（即重复）任务的方法——`scheduleAtFixedRate()`和`scheduleWithFixedDelay()`。
- en: The behavior of these two methods is slightly different. `scheduleAtFixedRate()`
    will activate a new copy of the task on a fixed timetable (and it will do so whether
    or not previous copies have completed), whereas `scheduleWithFixedDelay()` will
    activate a new copy of the task only after the previous instance has completed
    and the specified delay has elapsed.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法的行为略有不同。`scheduleAtFixedRate()`将在固定的时间表上激活任务的副本（无论之前的副本是否完成），而`scheduleWithFixedDelay()`只有在之前的实例完成并且指定的延迟时间过去之后才会激活任务的副本。
- en: 'Apart from the `ScheduledThreadPoolExecutor`, all the other pools we’ve met
    are obtained by choosing slightly different parameter choices for the quite general
    `Thread-PoolExecutor` class. For example, let’s look at the following definition
    of `Executors .newFixedThreadPool()`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ScheduledThreadPoolExecutor`之外，我们遇到的所有其他池都是通过为相当通用的`Thread-PoolExecutor`类选择略微不同的参数选择获得的。例如，让我们看看以下`Executors
    .newFixedThreadPool()`的定义：
- en: '[PRE43]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is the purpose of the helper methods, of course: to provide a convenient
    way of accessing some standard choices for a threadpool without needing to engage
    with the full complexity of `ThreadPoolExecutor`. Beyond the JDK, many other examples
    of executors and related threadpools exist, such as the `org.apache.catalina.Executor`
    class from the Tomcat web server.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是辅助方法的目的：提供一个方便的方式来访问线程池的一些标准选择，而无需与`ThreadPoolExecutor`的全部复杂性打交道。除了JDK之外，还有许多其他执行器和相关线程池的例子，例如来自Tomcat
    web服务器的`org.apache.catalina.Executor`类。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '`java.util.concurrent` classes should be your preferred toolkit for all new
    multithreaded Java code:'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`类应该是你所有新多线程Java代码的首选工具包：'
- en: Atomic integers
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子整数
- en: Concurrent data structures, especially `ConcurrentHashMap`
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发数据结构，特别是`ConcurrentHashMap`
- en: Blocking queues and latches
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞队列和闩锁
- en: Threadpools and executors
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池和执行器
- en: 'These classes can be used to implement safe concurrent programming techniques
    including:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些类可以用来实现安全的并发编程技术，包括：
- en: Addressing inflexibility of `synchronized` locks
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决`synchronized`锁的不灵活性
- en: Use of blocking queues for task handoff
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阻塞队列进行任务传递
- en: Using latches for consensus among a group of threads
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闩锁在多个线程之间达成共识
- en: Partitioning execution into work units
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行分割成工作单元
- en: Job control, including safe shutdown
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务控制，包括安全关闭
