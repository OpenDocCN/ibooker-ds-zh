- en: 7 Adding dynamic elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 添加动态元素
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Adding dynamic elements back into static web pages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动态元素添加回静态网页
- en: Processing form submissions via multiple providers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多个提供商处理表单提交
- en: Creating a search interface to a static site
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为静态网站创建搜索界面
- en: In the old days (you know, two or three years ago), what we know now as the
    Jamstack was a bit simpler. Typically we referred to static sites and static site
    generators. The problem with these terms is that they implied a static, unchanging
    site that couldn’t respond to users’ needs. That wasn’t the case then and isn’t
    the case now.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去（你知道，两三年前），我们现在所知道的 Jamstack 还要简单一些。通常我们指的是静态网站和静态网站生成器。这些术语的问题在于它们暗示了一个静态、不变的网站，无法响应用户的需求。那时不是这样，现在也不是这样。
- en: There are numerous options (some free, some commercial) that aim to provide
    interactivity to web pages. In this chapter, you will see different examples of
    these services as well as how they can be integrated in some of the previous demos.
    We’ll discuss tradeoffs, prices, and other considerations that developers need
    to be aware of before selecting a particular product.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项（有些免费，有些商业）旨在为网页提供交互性。在本章中，您将看到这些服务的不同示例以及它们如何集成到一些之前的演示中。我们将讨论在选择特定产品之前开发者需要了解的权衡、价格和其他考虑因素。
- en: 7.1 Forms, forms, and more forms
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 表单，表单，更多表单
- en: 'One of the first tasks I did as a professional web developer in the ancient
    days of the 1990s was form processing. Back then, our sites were much like now,
    simple HTML, and in order to add functionality to a site, like processing a form,
    we would use programs written in Perl. I had a knack for Perl, so in many projects,
    I’d focus on that area. Forms have been around since the beginning of the web,
    and so has the need to process those forms. Let’s look at a few different options
    for adding processing to your Jamstack site. Broadly, we’re going to look at two
    different ways of doing this: with forms hosted elsewhere and embedded on your
    site, and as services that simply handle receiving the data of a form.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代初期作为专业网页开发者的早期工作中，我做的第一个任务就是表单处理。当时，我们的网站和现在很相似，都是简单的 HTML，为了给网站添加功能，比如处理表单，我们会使用用
    Perl 编写的程序。我对 Perl 很有天赋，所以在许多项目中，我会专注于这个领域。表单自互联网开始以来就存在了，处理这些表单的需求也随之产生。让我们看看为您的
    Jamstack 网站添加处理功能的几种不同选项。广泛地说，我们将探讨两种不同的方法：一种是在您网站上托管并嵌入表单，另一种是作为仅处理表单数据的服务的形式。
- en: 7.1.1 Using Google Forms
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 使用 Google 表单
- en: Google Forms ([http://forms.google.com/](http://forms.google.com/)) is a free
    offering from Google related to the more generic Google Docs service. Developers
    can create forms with multiple types of questions and different styles. Form data
    is automatically stored in a Google Sheet (their version of Microsoft Excel) and
    can also be emailed directly to whomever needs to get the results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Google 表单（[http://forms.google.com/](http://forms.google.com/)）是 Google 提供的一项免费服务，与更通用的
    Google Docs 服务相关。开发者可以创建包含多种类型问题和不同样式的表单。表单数据会自动存储在 Google 表格（他们的 Microsoft Excel
    版本）中，也可以直接通过电子邮件发送给需要获取结果的人。
- en: Using Google Forms in the Jamstack means creating and designing your form on
    Google’s site, and then adding the embed code to an HTML file. This can be done
    in non-HTML files as well. For example, if you are using Liquid in your SSG, you
    can add the embed code there, which will be a part of the final HTML file output
    when building your site. Let’s walk through creating a basic form that will mimic
    the typical Contact Us form seen on websites.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jamstack 中使用 Google 表单意味着在 Google 的网站上创建和设计您的表单，然后将嵌入代码添加到 HTML 文件中。这也可以在非
    HTML 文件中完成。例如，如果您在使用 Liquid 的 SSG，您可以在那里添加嵌入代码，这将作为构建网站时最终 HTML 文件输出的一个部分。让我们一步步创建一个基本的表单，它将模仿网站上常见的“联系我们”表单。
- en: Begin by going to the Google Forms site (you will need a Google account to use
    this service). You should see a list of templates and any recent forms (figure
    7.1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，访问 Google 表单网站（使用此服务需要 Google 账户）。你应该会看到一个模板列表以及任何最近的表单（图 7.1）。
- en: '![CH07_F01_Camden2](Images/CH07_F01_Camden2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_Camden2](Images/CH07_F01_Camden2.png)'
- en: Figure 7.1 The Google Forms home page, listing templates and previous forms
    (if any)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 Google 表单主页，列出模板和之前的表单（如果有）
- en: Start by clicking the Blank template for now. The included templates are pretty
    nice, but it’s best to start off simple. This will take you to the Google Forms
    editing experience (figure 7.2).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先点击空白模板。包含的模板相当不错，但最好从简单开始。这将带您进入 Google 表单编辑体验（图 7.2）。
- en: '![CH07_F02_Camden2](Images/CH07_F02_Camden2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F02_Camden2](Images/CH07_F02_Camden2.png)'
- en: Figure 7.2 The initial blank form
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 初始空白表单
- en: Google’s form editor is incredibly well done. You can choose between different
    types of questions (short answer, longer form, multiple choice, etc.) and are
    free to enter the question-and-answer text as you see fit. Google does some pretty
    amazing parsing of your questions as well, enabling you to write answers quicker.
    For example, if your question implies a yes or no answer, Google picks up on that
    and suggests them for answers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的表单编辑器做得非常好。你可以在不同类型的问题（简短回答、长文本、多项选择等）之间进行选择，并且可以自由地输入你看到的问题和答案文本。谷歌还会对你的问题进行一些相当出色的解析，使你能够更快地编写答案。例如，如果你的问题暗示了是或否的回答，谷歌会注意到这一点并建议这些作为答案。
- en: As we said, our first example is going to be a contact form. These have been
    around forever and typically follow a format of asking for your contact information
    and providing a place to ask your question or send your feedback.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，我们的第一个例子将是一个联系表单。这些表单已经存在很长时间了，通常的格式是要求提供你的联系信息，并提供一个地方来提出你的问题或发送你的反馈。
- en: 'The design of forms can be a complex topic. How many questions do you ask?
    What questions are required? What language do you use for a particular question?
    Get any of these wrong and your users may simply go away, or even worse, spend
    time writing answers and give up halfway. For this particular example, let’s use
    the following questions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的设计可能是一个复杂的话题。你需要问多少个问题？需要哪些问题？你将如何为特定问题选择语言？如果任何一个环节出错，你的用户可能会简单地离开，或者更糟糕的是，花费时间填写答案然后半途而废。对于这个特定的例子，让我们使用以下问题：
- en: '*What is your name?* This will be a short text answer and will be required.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的名字是什么？* 这将是一个简短文本回答，并且是必填项。'
- en: '*What is your email address?* This will also be a short text answer and will
    be required, and it is important so that we have a way to reach the user and respond
    to their comments.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的电子邮件地址是什么？* 这也将是一个简短文本回答，并且是必填项，并且这对于我们能够联系用户并回应他们的评论非常重要。'
- en: '*Do you like our site?* This will not be required and will be used as a quick
    way to gauge if users are enjoying using our site. It’s optional, so users can
    skip it, but we should be prepared for results to skew negative. Why? If a user
    is happy using our site and has no problems, they probably won’t bother contacting
    us to tell us this, so it’s fair to assume that a good portion of users who take
    the time to fill out this form have a problem of some sort and are probably not
    happy. Again, this is where the complexity of forms comes into play: you not only
    have to think of the user experience of the person filling out the form but also
    the psychology of why they are doing so.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你喜欢我们的网站吗？* 这不是必填项，将作为一个快速的方式来衡量用户是否在使用我们的网站。它是可选的，因此用户可以跳过它，但我们应该准备好结果可能偏负面。为什么？如果一个用户在使用我们的网站时感到满意并且没有问题，他们可能不会麻烦联系我们告诉他们这一点，所以我们可以合理地假设填写此表单的大部分用户可能存在某种问题，并且可能并不开心。再次强调，这就是表单复杂性的体现：你不仅要考虑填写表单的人的用户体验，还要考虑他们为什么这样做的原因心理学。'
- en: '*Your comments*. The final field will be a long text field that is required
    and will be used by the site visitor to either ask a question or provide feedback.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的评论*。最后一个字段将是一个必填的长文本字段，供网站访客提问或提供反馈使用。'
- en: To begin, first set a name for the form, replacing “Untitled form” with “Contact
    Form.” Optionally, you can enter a form description, but don’t worry about that
    now. Then enter the text of the first question in the first field of the form
    builder. Be sure to set it to Required. You’ll notice that as soon as you enter
    the text of the question, that intelligence will fire, and Google will default
    the type to short answer. This is just Google trying to help, but and you can
    change this to whatever you want. Figure 7.3 shows how this should look when done.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为表单设置一个名称，将“未命名表单”替换为“联系表单”。可选地，你可以输入表单描述，但现在不必担心这一点。然后在表单构建器的第一个字段中输入第一个问题的文本。确保将其设置为必填项。你会注意到，一旦你输入问题的文本，智能功能就会启动，谷歌会默认将其类型设置为简短回答。这只是谷歌在试图帮助你，但你也可以将其更改为你想要的任何类型。图7.3显示了完成后的样子。
- en: '![CH07_F03_Camden2](Images/CH07_F03_Camden2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F03_Camden2](Images/CH07_F03_Camden2.png)'
- en: Figure 7.3 The form after a bit of editing
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 编辑后的表单
- en: Repeat this step to ask for the user’s email address. To add a new question,
    click the + icon on the right-hand side, as shown in figure 7.3\. Then add the
    question about whether the user likes the site. Not only will Google determine
    that this is a yes/no question, it will suggest those answers along with “maybe.”
    You can click the suggestions to quickly add them (figure 7.4).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重复此步骤以请求用户的电子邮件地址。要添加新问题，请点击如图7.3所示的右侧加号图标，然后添加关于用户是否喜欢网站的问题。谷歌不仅会确定这是一个是/否问题，还会建议这些答案以及“可能”。你可以点击建议快速添加它们（图7.4）。
- en: '![CH07_F04_Camden2](Images/CH07_F04_Camden2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F04_Camden2](Images/CH07_F04_Camden2.png)'
- en: Figure 7.4 Google’s intelligent form editor recognizing your question and suggesting
    answers
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 谷歌智能表单编辑器识别你的问题并建议答案
- en: After adding yes and no as answers, add the final question. Google should suggest
    “Paragraph” as the type, but be sure to set it to Required. When done, click the
    Preview icon on top (it’s an eyeball), and a new tab will open with your form
    (figure 7.5).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加“是”和“否”作为答案后，添加最后一个问题。谷歌应该建议“段落”作为类型，但请确保将其设置为“必填”。完成后，点击顶部的预览图标（它是一个眼睛图标），将打开一个新标签页，显示你的表单（图7.5）。
- en: '![CH07_F05_Camden2](Images/CH07_F05_Camden2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F05_Camden2](Images/CH07_F05_Camden2.png)'
- en: Figure 7.5 The complete form
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 完整的表单
- en: This preview is a fully functioning form that you can use right now and submit.
    You can see how the validation logic works by intentionally leaving things out.
    Go ahead and submit your form. When you do, you’ll get a simple confirmation (figure
    7.6).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个预览是一个完全功能性的表单，你现在就可以使用并提交。你可以通过故意省略一些内容来查看验证逻辑是如何工作的。提交你的表单。当你这样做时，你会得到一个简单的确认（图7.6）。
- en: '![CH07_F06_Camden2](Images/CH07_F06_Camden2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F06_Camden2](Images/CH07_F06_Camden2.png)'
- en: Figure 7.6 What users see after submitting the form
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 用户提交表单后看到的内容
- en: Do this a few times and then return to the tab where you’re editing the form.
    You’ll see the Responses tab will notice that submissions have been received (figure
    7.7).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做几次后，返回你正在编辑表单的标签页。你会看到“回复”标签页会注意到已经收到了提交（图7.7）。
- en: '![CH07_F07_Camden2](Images/CH07_F07_Camden2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F07_Camden2](Images/CH07_F07_Camden2.png)'
- en: Figure 7.7 Highlighting the Responses tab
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 高亮显示“回复”标签页
- en: Clicking on the Responses tab will show you a summary of the responses (figure
    7.8). Google does an admirable job of displaying this data and recognizes that
    the “Do you like our site?” question makes sense as a pie chart, but oddly displays
    email addresses as a bar chart.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“回复”标签页将显示回复的摘要（图7.8）。谷歌在显示这些数据方面做得令人钦佩，并认识到“你喜欢我们的网站吗？”这个问题适合作为饼图，但奇怪的是，将电子邮件地址显示为柱状图。
- en: '![CH07_F08_Camden2](Images/CH07_F08_Camden2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F08_Camden2](Images/CH07_F08_Camden2.png)'
- en: Figure 7.8 Summary of form responses
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 表单回复的摘要
- en: Clicking on the Question tab will let you look at results for one question at
    a time, whereas Individual shows you one complete response at a time. The green
    icon on the top lets you create a Google Sheet and automatically connects the
    response (and future ones too!) to a spreadsheet. In most cases, though, a developer
    (or the owner of the website) will prefer to get an email response. To set this
    up, click the three-dot menu to the right of the green spreadsheet icon, and in
    the pop-up menu, select Get email notifications for new email responses (figure
    7.9).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“问题”标签页将允许你一次查看一个问题的结果，而“单个”则一次显示一个完整的回复。顶部的绿色图标允许你创建一个Google表格，并自动将回复（以及未来的回复）连接到电子表格。然而，在大多数情况下，开发者（或网站的所有者）更愿意收到电子邮件回复。要设置此功能，请点击绿色电子表格图标右侧的三点菜单，并在弹出菜单中选择“为新电子邮件回复获取电子邮件通知”（图7.9）。
- en: '![CH07_F09_Camden2](Images/CH07_F09_Camden2.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F09_Camden2](Images/CH07_F09_Camden2.png)'
- en: Figure 7.9 Setup and configuring email responses
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 设置和配置电子邮件回复
- en: Clicking this will enable email notifications for future submissions, but note
    that it will go to the owner of the Google account. Now, if you fill out the form
    again, you’ll receive an email (figure 7.10).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮将启用未来提交的电子邮件通知，但请注意，它会发送到谷歌账户的所有者。现在，如果你再次填写表单，你会收到一封电子邮件（图7.10）。
- en: '![CH07_F10_Camden2](Images/CH07_F10_Camden2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F10_Camden2](Images/CH07_F10_Camden2.png)'
- en: Figure 7.10 Email received after the form has been submitted
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 提交表单后的收到的电子邮件
- en: Unfortunately you still have to click to get to the responses, but at least
    you know a response was submitted.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你仍然需要点击才能看到回复，但至少你知道已经提交了回复。
- en: Now that your form is built and it can take in submissions, what’s the next
    step? While our website could simply link to the form, that would mean the user
    is leaving our site, and generally that’s not a desirable thing. Instead, we can
    put the form directly on our site. This can be done via an iframe embed code.
    It’s not terribly obvious where you get that code, but it’s found via the Send
    button on the top of the form editor. Clicking this opens a dialog that defaults
    to sending the form via email, but clicking the “<>” icon will show you the iframe
    code (figure 7.11).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的表单已经构建完成，并且可以接收提交的内容，下一步是什么？虽然我们的网站可以简单地链接到表单，但这意味着用户将离开我们的网站，而这通常不是我们希望看到的情况。相反，我们可以直接在我们的网站上放置表单。这可以通过
    iframe 嵌入代码来实现。你可能会觉得这个代码并不明显，但它可以通过表单编辑器顶部的“发送”按钮找到。点击此按钮会打开一个对话框，默认是通过电子邮件发送表单，但点击“<>”图标会显示
    iframe 代码（图 7.11）。
- en: '![CH07_F11_Camden2](Images/CH07_F11_Camden2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F11_Camden2](Images/CH07_F11_Camden2.png)'
- en: Figure 7.11 The Send dialog’s HTML option
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 发送对话框的 HTML 选项
- en: With this code, you can now embed it in any web page you want, including within
    a Jamstack site. But let’s begin with a simple example using a typical HTML page
    with layout. The embed code from Google Forms is included as part of the page.
    Be sure to replace this with your own embed code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，您现在可以将其嵌入到任何您想要的网页中，包括 Jamstack 网站内。但让我们从一个使用典型 HTML 页面布局的简单示例开始。Google
    表单的嵌入代码作为页面的一部分包含在内。请确保将其替换为您自己的嵌入代码。
- en: Listing 7.1 A Google Form embed example (/chapter7/forms/test1.html)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 Google 表单嵌入示例 (/chapter7/forms/test1.html)
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a rather short template with a header and footer and the iframe from
    Google Forms inside. We also use a bit of CSS here to style the page. The only
    reason for this is to show how the form looks when added to a page that has its
    own unique style. Google Forms allows for some customization in look and feel,
    so you can expect to have to work with that a bit, but we wanted to demonstrate
    an out-of-the-box integration with no customization. Figure 7.12 shows how this
    renders on a page.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当短的模板，包含页眉和页脚，以及 Google 表单中的 iframe。我们在这里也使用了一些 CSS 来美化页面。这样做的原因只是为了展示当表单添加到具有独特样式的页面时，表单的外观。Google
    表单允许在外观和感觉上进行一些定制，因此您可能需要稍微处理一下，但我们想展示一个无需定制的即插即用集成。图 7.12 展示了它在页面上的渲染效果。
- en: '![CH07_F12_Camden2](Images/CH07_F12_Camden2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F12_Camden2](Images/CH07_F12_Camden2.png)'
- en: Figure 7.12 The Google Form
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 Google 表单
- en: As you can see, it integrated just fine. There is a scrollbar, but that could
    be adjusted by modifying the iframe’s height attribute or using CSS. If you submit
    this form, the process is done entirely within the iframe, and the user never
    leaves the site. While it definitely sticks out a bit on the page, this is a quick
    and simple solution. Even better, the form could be edited by a nontechnical user,
    and since it’s an embed, nothing would need to change on your site to reflect
    their changes. Now that you’ve seen an example of a remote, hosted form, let’s
    consider something a bit more integrated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它集成得很好。有一个滚动条，但可以通过修改 iframe 的高度属性或使用 CSS 来调整。如果您提交此表单，整个过程将在 iframe 内完成，用户永远不会离开网站。虽然它在页面上确实显得有些突兀，但这是一种快速简单的解决方案。更好的是，表单可以被非技术用户编辑，并且由于它是嵌入的，因此您网站上不需要进行任何更改来反映他们的更改。现在您已经看到了一个远程托管表单的示例，让我们考虑一些更集成的方案。
- en: 7.1.2 Integrating FormCake
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 集成 FormCake
- en: While Google Forms works via an external host displayed in an iframe, developers
    may want more control over the design and setup of their forms. Multiple services
    now exist that provide an endpoint, or a place to send your form data to, that
    will then take in the data, do “stuff” (what they do depends on the service),
    and then redirect the user back to your site. For most people, they have no idea
    what’s happening. They simply clicked your Submit button and then were presented
    with a thank you or confirmation page. But behind the scenes, the service in question
    parsed the form, did something with that data, and then redirected the website
    visitor right back to your site.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Google 表单通过外部宿主在 iframe 中显示，但开发者可能希望对自己的表单设计和设置有更多的控制。现在存在多个服务，它们提供端点，或发送您的表单数据的地方，然后接收数据，进行“操作”（它们做什么取决于服务），然后将用户重定向回您的网站。对于大多数人来说，他们并不知道发生了什么。他们只是点击了您的提交按钮，然后被展示了一个感谢或确认页面。但在幕后，相关的服务解析了表单，对数据进行了一些操作，然后将网站访问者直接重定向回您的网站。
- en: One of these services is FormCake ([https://formcake.com](https://formcake.com)).
    This service provides form processing and includes things like file upload support,
    spam protection, and the ability to perform actions on the data. At a minimum,
    it can email the data to you (or the owner of the site), but it can also integrate
    with solutions like Zapier (an automation service that lets you connect different
    apps in workflows, for example, on a form submission sending information to Salesforce).
    FormCake currently has three different tiers of pricing (see more at [https://formcake.com/pricing](https://formcake.com/pricing)),
    but their free tier allows for unlimited forms, 100 submissions, and basic spam
    protection. This is enough for us to test, so let’s give it a shot.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务之一是FormCake ([https://formcake.com](https://formcake.com))。这项服务提供表单处理，包括文件上传支持、垃圾邮件保护和在数据上执行操作的能力。至少，它可以电子邮件发送数据给你（或网站的拥有者），但它还可以与Zapier（一种自动化服务，允许你在工作流中连接不同的应用程序，例如，在表单提交时将信息发送到Salesforce）等解决方案集成。FormCake目前有三个不同的定价层级（更多详情请见[https://formcake.com/pricing](https://formcake.com/pricing)），但他们的免费层允许无限数量的表单，100次提交和基本的垃圾邮件保护。这对我们来说已经足够了，所以让我们试一试。
- en: Begin by signing up (you can use either an email and password combination or
    your GitHub account). After you’ve done that, you are taken to a dashboard with
    one form already created (figure 7.13).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注册（你可以使用电子邮件和密码组合或你的GitHub账户）。完成之后，你将被带到包含一个已创建表单的仪表板（图7.13）。
- en: '![CH07_F13_Camden2](Images/CH07_F13_Camden2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F13_Camden2](Images/CH07_F13_Camden2.png)'
- en: Figure 7.13 The forms dashboard at FormCake
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 FormCake的表单仪表板
- en: Clicking into the form gives you many settings and integration instructions
    for working with it (figure 7.14).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点击进入表单将为你提供许多设置和集成说明，以便与它一起工作（图7.14）。
- en: '![CH07_F14_Camden2](Images/CH07_F14_Camden2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F14_Camden2](Images/CH07_F14_Camden2.png)'
- en: Figure 7.14 Instructions on how to use the form
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 如何使用表单的说明
- en: The instructions mostly boil down to ensuring your form uses POST and copying
    the action endpoint shown in the first step. Let’s build our form that uses this
    action. The iframe from the Google form has been replaced by a form entirely written
    by hand and using the endpoint provided by FormCake. It asks the same questions
    as before.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 指令主要归结为确保你的表单使用POST，并复制第一步中显示的操作端点。让我们构建一个使用此操作的表单。Google表单的iframe已被完全手动编写的表单和FormCake提供的端点所取代。它提出的问题与之前相同。
- en: NOTE The endpoint is specific to the author and should be replaced with the
    one you get from FormCake.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：端点是针对作者的，应该替换为你从FormCake获得的端点。
- en: Listing 7.2 The FormCake form (/chapter7/forms/test2.html)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 FormCake表单 (/chapter7/forms/test2.html)
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you fire up a local web server to test this (I suggest [https://www.npmjs.com/package/httpster](https://www.npmjs.com/package/httpster)),
    you can view the form, submit it, and then end up on a default submission page
    for FormCake (figure 7.15).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动一个本地Web服务器来测试这个（我建议[https://www.npmjs.com/package/httpster](https://www.npmjs.com/package/httpster)），你可以查看表单，提交它，然后最终到达FormCake的默认提交页面（图7.15）。
- en: '![CH07_F15_Camden2](Images/CH07_F15_Camden2.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F15_Camden2](Images/CH07_F15_Camden2.png)'
- en: Figure 7.15 The default FormCake response
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 默认的FormCake响应
- en: If you go back to the FormCake dashboard, you can click on the Submissions tab
    and see your response (you may need to refresh). Clicking on it will give you
    a detailed view (figure 7.16).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到FormCake仪表板，你可以点击“提交”标签并查看你的响应（你可能需要刷新）。点击它将给你一个详细视图（图7.16）。
- en: '![CH07_F16_Camden2](Images/CH07_F16_Camden2.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F16_Camden2](Images/CH07_F16_Camden2.png)'
- en: Figure 7.16 FormCake’s submission view
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 FormCake的提交视图
- en: 'To make this form a bit nicer, let’s make two changes in the form settings.
    In the Settings tab, scroll down to “Success Redirect” and add a URL to redirect
    the user back to where they submitted the form. Right now we’re testing locally,
    so we can use a localhost URL, but that would not work in production. In my environment,
    my form was available at http://localhost:3333/chapter7/forms/test2.html. I created
    a new file named test2_thankyou.html (you can find this in the GitHub repository
    for the site. It isn’t really important what’s in the file; it just needs to exist),
    and then used this as the redirect value: http://localhost:3333/chapter7/forms/test2_thankyou.html
    (figure 7.17).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个表单看起来更美观，让我们在表单设置中进行两项更改。在“设置”选项卡中，向下滚动到“成功重定向”，并添加一个URL以将用户重定向回他们提交表单的位置。目前我们正在本地测试，因此我们可以使用localhost
    URL，但在生产环境中这不会起作用。在我的环境中，我的表单可在http://localhost:3333/chapter7/forms/test2.html处访问。我创建了一个名为test2_thankyou.html的新文件（你可以在网站的GitHub仓库中找到这个文件。文件中的内容并不重要；它只需要存在），然后将其用作重定向值：http://localhost:3333/chapter7/forms/test2_thankyou.html（图7.17）。
- en: '![CH07_F17_Camden2](Images/CH07_F17_Camden2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F17_Camden2](Images/CH07_F17_Camden2.png)'
- en: Figure 7.17 Form settings with the redirect specified
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 指定重定向的表单设置
- en: Next, we need to set it up so you can get an email every time the form is submitted.
    Click on the Actions tab, and in the Add an Action drop-down menu, select Email
    Notification Action. This will prompt you for a name for the action, an email
    address to send the information to, and a subject. Enter “Email Notification”
    for name, your own email address, and “Form Submission” for the subject. Now you
    can fill out your form again, and after submitting, you will be redirected to
    your thank-you page. The end user will not see a FormCake site and won’t even
    know you’re using the service. To be clear, it isn’t hidden, and developers could
    easily monitor the network traffic, but casual users won’t know (or care). Soon
    after, you’ll get an email notification (figure 7.18).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置它，以便每次表单提交时你都能收到一封电子邮件。点击“操作”选项卡，然后在“添加操作”下拉菜单中选择“电子邮件通知操作”。这将提示你为操作输入名称、发送信息的电子邮件地址和主题。将名称输入为“电子邮件通知”，输入你自己的电子邮件地址，主题为“表单提交”。现在你可以再次填写你的表单，提交后，你将被重定向到你的感谢页面。最终用户不会看到FormCake网站，甚至不知道你正在使用该服务。为了清楚起见，它并不是隐藏的，开发者可以轻松地监控网络流量，但普通用户不会知道（或关心）。不久之后，你会收到一封电子邮件通知（图7.18）。
- en: '![CH07_F18_Camden2](Images/CH07_F18_Camden2.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F18_Camden2](Images/CH07_F18_Camden2.png)'
- en: Figure 7.18 Email copy of the form submission
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 表单提交的电子邮件副本
- en: If you want something a bit more custom, FormCake even allows you to define
    an email template that uses Liquid for variable replacement. This is a pretty
    powerful feature!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一些更定制的功能，FormCake甚至允许你定义一个使用Liquid进行变量替换的电子邮件模板。这是一个相当强大的功能！
- en: 7.1.3 Other options
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 其他选项
- en: There are, of course, other options for working with forms. There are numerous
    ones similar to FormCake, where you simply use a specific action for your form.
    There’s also Wufoo ([https://www.wufoo.com/](https://www.wufoo.com/)), which acts
    more like Google Forms but has powerful design and editing features. As mentioned
    in the previous chapter, Netlify as a Jamstack host has built-in form processing.
    In the next chapter, we’ll discuss serverless functions, and that’s yet another
    way you could respond to a form post.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他处理表单的选项。有许多类似于FormCake的选项，你只需为你的表单使用特定的操作。还有Wufoo([https://www.wufoo.com/](https://www.wufoo.com/))，它更像Google
    Forms，但具有强大的设计和编辑功能。如前一章所述，Netlify作为Jamstack主机内置了表单处理。在下一章中，我们将讨论无服务器函数，这是另一种响应表单提交的方式。
- en: 7.2 Adding search
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 添加搜索
- en: 'After processing basic form input, search is probably one of the most important
    features for a Jamstack site. If your site has more than a few pages, giving users
    the ability to quickly find what they want becomes important. In this section,
    we’ll discuss two different options for search and will follow a format much like
    the previous section. We’ll begin with a “drop into place” solution, once again
    from Google: Programmable Search Engine ([https://programmablesearchengine.google.com/about/](https://programmablesearchengine.google.com/about/)).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理基本表单输入后，搜索可能是Jamstack网站最重要的功能之一。如果你的网站有超过几页，为用户提供快速找到他们想要的内容的能力变得很重要。在本节中，我们将讨论两种不同的搜索选项，并将遵循与上一节类似的格式。我们将从一个“直接插入”的解决方案开始，再次来自Google：可编程搜索引擎([https://programmablesearchengine.google.com/about/](https://programmablesearchengine.google.com/about/))。
- en: Google’s Programmable Search Engine was previously known as Custom Search Engine,
    so if you follow up the tutorial in this book with more research, you may find
    articles referring to that, or CSE. This is a service from Google that lets you
    define, essentially, a portion of Google’s search engine to use within your own
    site.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的可编程搜索引擎之前被称为自定义搜索引擎，因此如果您在本书的教程之后进行更多研究，您可能会找到提到该服务或 CSE 的文章。这是 Google
    提供的一项服务，允许您定义，基本上是 Google 搜索引擎的一部分，用于您自己的网站。
- en: To begin, simply click the Get Started button from the Programmable Search Engine
    site and log in with your Google credentials. Once logged in, you’ll be taken
    to the dashboard (figure 7.19).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，只需从可编程搜索引擎网站点击“开始使用”按钮，并使用您的 Google 凭据登录。登录后，您将被带到仪表板（图 7.19）。
- en: '![CH07_F19_Camden2](Images/CH07_F19_Camden2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F19_Camden2](Images/CH07_F19_Camden2.png)'
- en: Figure 7.19 The Programmable Search dashboard
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 可编程搜索引擎仪表板
- en: Begin working with this service by clicking the Add button. The first prompt
    you’ll be presented with is the sites to search, and here’s where things get interesting.
    You can enter any site you want here. That’s right—even if you are building your
    own site at a domain X, you can enter domain Y (and more) for your search engine.
    You’ll probably want to use your own domain, but Google lets you decide whatever
    makes sense. Note (as seen in figure 7.20) that you can enter subdirectories as
    well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击“添加”按钮开始使用此服务。您将遇到的第一个提示是搜索的网站，这里事情变得有趣。您可以在这里输入任何您想要的网站。没错——即使您正在域名 X 上构建自己的网站，您也可以为您的搜索引擎输入域名
    Y（以及更多）。您可能想使用自己的域名，但 Google 允许您决定任何有意义的选项。注意（如图 7.20 所示），您还可以输入子目录。
- en: '![CH07_F20_Camden2](Images/CH07_F20_Camden2.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F20_Camden2](Images/CH07_F20_Camden2.png)'
- en: Figure 7.20 The initial screen for setting up a programmable search engine
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 设置可编程搜索引擎的初始屏幕
- en: As we said, you can enter anything you’d like here. If you’ve already deployed
    your own Jamstack site, even to a temporary location, you can enter the URL. For
    the purposes of this book, and to give us a lot of content to use, we’ll use my
    blog at [raymondcamden.com](https://www.raymondcamden.com/). For the name of the
    search engine, let’s use JamstackSearch1\. That’s purely arbitrary and is only
    used to help differentiate one of your programmable search engines from another.
    In a real-world scenario, I would typically use the same name as the site itself.
    After you’ve entered your values, click the Create button. You’ll then see a success
    message (figure 7.21).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，您在这里可以输入任何您想输入的内容。如果您已经部署了自己的 Jamstack 网站，即使是在临时位置，您也可以输入 URL。为了本书的目的，并且为了给我们提供大量内容，我们将使用我的博客[raymondcamden.com](https://www.raymondcamden.com/)。对于搜索引擎的名称，让我们使用
    JamstackSearch1。这完全是随机的，只是为了帮助您区分您的可编程搜索引擎与其他搜索引擎。在现实世界的场景中，我通常会使用与网站本身相同的名称。输入您的值后，点击创建按钮。然后您将看到一条成功消息（图
    7.21）。
- en: '![CH07_F21_Camden2](Images/CH07_F21_Camden2.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F21_Camden2](Images/CH07_F21_Camden2.png)'
- en: Figure 7.21 Congratulations, you’ve built your own search engine (well, Google
    did, to be honest).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 恭喜，您已经构建了自己的搜索引擎（说实话，是 Google 帮您构建的）。
- en: At this point, note the three options. The first (Get code) will give you the
    code needed to add the search to your site, and we’ll get to that in a second.
    The third option (Control Panel) is where you’ll configure options; we’ll demonstrate
    that too. The one in the middle (Public URL), though, is something else. As soon
    as you build a programmable search engine, Google provides a URL that lets you
    use your search engine right away. This is great if you want to test how well
    it’s working, how it ranks results, and so forth. You could also share this with
    your client while you are building your site so they can see it as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，请注意三个选项。第一个（获取代码）将为您提供将搜索添加到您网站所需的代码，我们将在下一部分介绍。第三个选项（控制面板）是您配置选项的地方；我们也会演示这一点。然而，中间的（公共
    URL）是另一回事。一旦您构建了一个可编程搜索引擎，Google 就会提供一个 URL，让您可以立即使用您的搜索引擎。如果您想测试它的工作效果、结果排名等，这非常棒。在您构建网站的同时，您也可以与客户分享这个
    URL，让他们也能看到。
- en: For now, click on Get code. In listing 7.3, you’ll be presented with a short
    code snippet. You’ll take this code and drop it into a simple HTML page. The same
    basic shell from the previous section was used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击“获取代码”。在列表 7.3 中，您将看到一个简短的代码片段。您将使用这段代码并将其放入一个简单的 HTML 页面中。与上一节相同的基本外壳被使用。
- en: Listing 7.3 A search test page (/chapter7/search/test1.html)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 搜索测试页面 (/chapter7/search/test1.html)
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The beginning of the snippet from Google
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Google 代码片段的开始部分
- en: ❷ The end of the snippet
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 代码片段的结尾
- en: As with Google Forms, you can drop in the snippet where it makes sense to you.
    Fire up a local web server and then run the page. You’ll see a basic form experience
    completely powered by Google (figure 7.22).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Google 表单一样，您可以在您认为合适的地方插入代码片段。启动本地网络服务器，然后运行页面。您将看到一个完全由 Google 驱动的基本表单体验（图
    7.22）。
- en: '![CH07_F22_Camden2](Images/CH07_F22_Camden2.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F22_Camden2](Images/CH07_F22_Camden2.png)'
- en: Figure 7.22 The default search experience provided by Google
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 Google 提供的默认搜索体验
- en: Enter something in the search. Depending on what domain you entered, you should
    try something that makes sense. If you used my domain ([raymondcamden.com](https://www.raymondcamden.com/)),
    you can try “vue.js” as your input. Figure 7.23 demonstrates what you may see.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索框中输入一些内容。根据您输入的域名，您应该尝试一些有意义的内容。如果您使用了我的域名 ([raymondcamden.com](https://www.raymondcamden.com/))，您可以尝试“vue.js”作为输入。图
    7.23 展示了您可能会看到的内容。
- en: '![CH07_F23_Camden2](Images/CH07_F23_Camden2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F23_Camden2](Images/CH07_F23_Camden2.png)'
- en: Figure 7.23 Results from searching the programmable search engine
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 搜索可编程搜索引擎的结果
- en: Right away you’ll notice that the UI is a bit different from what you may expect.
    Instead of displaying the results on the page, a floating modal is used. If you
    don’t like that (I certainly do not), we can tweak it, and we’ll do so in a moment.
    The next thing you may notice, especially in figure 7.23, is that *every visible
    result* is an advertisement. Yep, just like the main [Google.com](https://www.google.com/)
    site, you’ll get ads in your result. Not shown in the figure is that if you scroll
    past the four ads (yes, four, and your results may vary, of course), you do get
    good results with snippets, and images at times (figure 7.24).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻您会注意到，UI 与您可能预期的略有不同。它不是在页面上显示结果，而是使用一个浮动的模态框。如果您不喜欢这样（我当然不喜欢），我们可以调整它，我们将在稍后这样做。您可能注意到的下一件事，尤其是在图
    7.23 中，是每个可见的结果都是一个广告。是的，就像主要的 [Google.com](https://www.google.com/) 网站，您会在结果中看到广告。图中未显示的是，如果您滚动过四个广告（是的，四个，当然，您的结果可能会有所不同），您确实会得到一些很好的代码片段和图像（图
    7.24）。
- en: '![CH07_F24_Camden2](Images/CH07_F24_Camden2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F24_Camden2](Images/CH07_F24_Camden2.png)'
- en: Figure 7.24 “Real” results can be found after the ads. Google does need the
    money, you know.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 在广告之后可以找到“真实”的结果。Google 需要钱，这是您知道的。
- en: Let’s start customizing the search engine. Back in the dashboard, click on Look
    and feel. Here you will find multiple options for customizing how the search engine
    is displayed, but let’s start by changing the layout from “Overlay” to “Full width”
    (figure 7.25).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始自定义搜索引擎。回到仪表板，点击“外观”。在这里，您将找到多个选项来自定义搜索引擎的显示方式，但让我们先从将布局从“覆盖”更改为“全宽”开始（图
    7.25）。
- en: '![CH07_F25_Camden2](Images/CH07_F25_Camden2.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F25_Camden2](Images/CH07_F25_Camden2.png)'
- en: Figure 7.25 Specifying a new layout for your search engine
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25 为您的搜索引擎指定新的布局
- en: Not shown in figure 7.25, but handy to use, is a live example of your search
    engine on the right-hand side of the dashboard. You can test there if you want,
    or simply click Save and test back in the simple HTML page. Your changes are shown
    immediately (figure 7.26).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25 中未显示，但很方便使用的是，在仪表板的右侧有一个您搜索引擎的实时示例。如果您想测试，可以在这里进行，或者只需点击“保存并测试”回到简单的
    HTML 页面。您的更改将立即显示（图 7.26）。
- en: '![CH07_F26_Camden2](Images/CH07_F26_Camden2.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F26_Camden2](Images/CH07_F26_Camden2.png)'
- en: Figure 7.26 The search engine with inline results
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26 带有内联结果的搜索引擎
- en: Let’s make another tweak. If you click on one of the results, you’ll see that
    it opens in a new tab. While that’s certainly something you may want, let’s change
    that to load in the current tab instead. In the dashboard, go to “Search features,”
    then “Advanced,” then “Websearch settings.” In the Link Target field enter “_self”
    (figure 7.27).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再调整一下。如果您点击其中一个结果，您会看到它将在新标签页中打开。虽然这确实可能是您想要的，但让我们将其更改为在当前标签页中打开。在仪表板中，转到“搜索功能”，“高级”，“网络搜索设置”。在“链接目标”字段中输入“_self”（图
    7.27）。
- en: '![CH07_F27_Camden2](Images/CH07_F27_Camden2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F27_Camden2](Images/CH07_F27_Camden2.png)'
- en: Figure 7.27 Modifying search results behavior via the dashboard
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.27 通过仪表板修改搜索结果行为
- en: As before, save and reload your test HTML file and click on a result. It should
    load in the same tab.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，保存并重新加载您的测试 HTML 文件，然后点击一个结果。它应该在同一个标签页中打开。
- en: Google’s Programmable Search Engine is even more customizable if you want to
    modify the HTML of the snippet. The Developer Guide ([https://developers.google
    .com/custom-search/docs/overview](https://developers.google.com/custom-search/docs/overview))
    goes into detail on what can be accomplished. You can also make use of an API
    that returns results in pure JSON, but this is a commercial feature only. Now
    that we’ve considered a plug-and-play solution, let’s again look at a more integrated
    option.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要修改片段的HTML，谷歌的可编程搜索引擎（Programmable Search Engine）提供了更多的自定义选项。开发者指南（[https://developers.google.com/custom-search/docs/overview](https://developers.google.com/custom-search/docs/overview)）详细介绍了可以实现的功能。你还可以使用一个返回纯JSON结果的API，但这仅是一个商业功能。现在我们已经考虑了一个即插即用的解决方案，让我们再次看看一个更集成的选项。
- en: 7.2.1 Searching with Lunr
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 使用Lunr进行搜索
- en: In the previous search example, the search service itself was entirely handled
    by a third party. You can most likely count on Google being around for a few more
    years, but what if you want an entirely self-hosted, self-contained solution?
    One example of this is Lunr ([https://lunrjs.com/](https://lunrjs.com/)) (figure
    7.28).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的搜索示例中，搜索服务本身完全由第三方处理。你很可能还会依赖谷歌几年，但如果你想要一个完全自托管、自包含的解决方案怎么办？一个例子是Lunr ([https://lunrjs.com/](https://lunrjs.com/))（图7.28）。
- en: '![CH07_F28_Camden2](Images/CH07_F28_Camden2.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F28_Camden2](Images/CH07_F28_Camden2.png)'
- en: Figure 7.28 Lunr’s gloriously simple web page
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28 Lunr的辉煌简单的网页
- en: Lunr is an entirely client-side solution (it can be used server side, but in
    general this isn’t the typical use case) for adding searches to a website. It
    begins with the creation of an index. This is where you decide what you want to
    search. For example, a developer service website may contain a few marketing pages
    and then a deep set of documentation. While you could create an index of everything,
    you may want to instead focus your index just on the developer documentation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Lunr是一个完全客户端解决方案（它也可以在服务器端使用，但通常这不是典型用例），用于向网站添加搜索功能。它从创建索引开始。这是你决定要搜索什么的地方。例如，一个开发者服务网站可能包含一些营销页面和一套深入的文档。虽然你可以创建一个包含所有内容的索引，但你可能只想将索引集中在开发者文档上。
- en: Even after you’ve figured out what to search, you still need to consider the
    size of your index and how you can keep it smaller. Going back to the previous
    example, if your developer documentation covers hundreds of pages of docs, perhaps
    you may consider only indexing the first paragraph of each page of docs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你确定了要搜索的内容，你仍然需要考虑索引的大小以及如何使其更小。回到之前的例子，如果你的开发者文档覆盖了数百页的文档，你可能只考虑索引每页文档的第一段。
- en: Once you’ve figured out what content you want to index, you give this information
    to Lunr. Lunr will parse the text and do magic with it. Okay, not magic, but it
    will parse the content to make it much more searchable. Once the index is created,
    you can then search against it using either a simple search term or perhaps a
    more complex search query (“find all docs that mention cats that are in the API
    category”). The results can then be filtered by their quality (Lunr will score
    every result), if you wish. Let’s look at how Lunr could be added to a Jamstack
    site.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了要索引的内容，你就将这个信息提供给Lunr。Lunr将解析文本并对它进行魔法般的处理。好吧，不是魔法，但它将解析内容使其更容易搜索。一旦创建了索引，你就可以使用简单的搜索词或更复杂的搜索查询（“找到所有提及猫且属于API类别的文档”）来对其搜索。如果你愿意，还可以根据其质量（Lunr将为每个结果评分）进行过滤。让我们看看如何将Lunr添加到Jamstack网站。
- en: Adding Lunr to an Eleventy site
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将Lunr添加到Eleventy网站
- en: In chapter 2, you were introduced to the static site generator Eleventy ([https://www.11ty.dev/](https://www.11ty.dev/)).
    To test adding search to the Jamstack, we’re going to begin with an existing Eleventy
    site. This site makes use of text from the GI Joe wiki ([http://mng.bz/laAB](https://gijoe.fandom.com/wiki/Joepedia_-_The_G.I._Joe_Wiki)),
    an online resource for everything related to the GI Joe franchise. I copied part
    of the description of six different characters to build a very basic site of GI
    Joe personalities (figure 7.29).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，你被介绍到了静态网站生成器Eleventy ([https://www.11ty.dev/](https://www.11ty.dev/))。为了测试将搜索添加到Jamstack，我们将从一个现有的Eleventy网站开始。这个网站使用了来自GI
    Joe维基百科（[http://mng.bz/laAB](https://gijoe.fandom.com/wiki/Joepedia_-_The_G.I._Joe_Wiki)）的文本，这是一个与GI
    Joe系列相关的在线资源。我复制了六个不同角色的部分描述来构建一个非常基础的GI Joe人物网站（图7.29）。
- en: '![CH07_F29_Camden2](Images/CH07_F29_Camden2.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F29_Camden2](Images/CH07_F29_Camden2.png)'
- en: Figure 7.29 The site’s home page, which just lists characters
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29 网站的主页，仅列出角色
- en: Clicking an individual character link shows some basic text and a picture (figure
    7.30).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 点击单个角色链接会显示一些基本文本和一张图片（图7.30）。
- en: '![CH07_F30_Camden2](Images/CH07_F30_Camden2.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F30_Camden2](Images/CH07_F30_Camden2.png)'
- en: Figure 7.30 An individual character page
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30 单个角色页面
- en: The initial code to create this site consists of a few basic pages. (Remember
    that you can find this in the book’s GitHub repository.) First, the home page
    loads in all the characters and displays them in a list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此网站的初始代码由几个基本页面组成。（记住，你可以在本书的GitHub仓库中找到这些内容。）首先，主页加载所有角色并将它们显示在列表中。
- en: Listing 7.4 Home page for the site (/chapter7/search/lunr/index.liquid)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 网站主页（/chapter7/search/lunr/index.liquid）
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One of the ways Eleventy creates collections of related content is by using
    tags. You can see the source for one of the characters. In the front matter on
    top, the tag’s value is set to characters. This is repeated throughout all the
    characters. (Note that we’ve trimmed some of the text to save space.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Eleventy创建相关内容集合的一种方式是使用标签。你可以看到其中一个角色的源代码。在最上面的前导部分，标签的值设置为characters。这在所有角色中都是重复的。（注意，我们已删除一些文本以节省空间。）
- en: Listing 7.5 Example character page (/chapter7/search/lunr/characters/destro.md)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 示例角色页面（/chapter7/search/lunr/characters/destro.md）
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The templates used to display characters and the home page itself can both be
    found in the GitHub repository inside chapter7/search/lunr/_includes. These files
    handle the header and footer and display of the character but don’t relate to
    the search feature we’re about to add. We will, however, show the main template
    shortly when we add support for the client-side aspects of Lunr.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示角色和主页本身的模板都可以在GitHub仓库的chapter7/search/lunr/_includes目录中找到。这些文件处理页眉和页脚以及角色的显示，但与我们即将添加的搜索功能无关。然而，当我们添加对Lunr客户端方面的支持时，我们将很快展示主要模板。
- en: As stated earlier, Lunr requires you to create an index of your data. This is
    a data-friendly view of the content on your site that you want to search. Our
    site consists of a home page, multiple character pages, and, eventually, a search
    page. But we only want to search our character data. In listing 7.4, you saw that
    you can loop over that information in a collection. We can use the same logic
    to create a JSON version of the site that Lunr can eventually use to create an
    index, shown next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Lunr要求你创建你数据的索引。这是你网站上想要搜索的内容的数据友好视图。我们的网站由一个主页、多个角色页面以及最终的一个搜索页面组成。但我们只想搜索我们的角色数据。在列表7.4中，你看到你可以在一个集合中循环遍历这些信息。我们可以使用相同的逻辑来创建一个Lunr最终可以用来创建索引的JSON版本，如下所示。
- en: Listing 7.6 Creating a JSON list of characters (/chapter7/search/lunr/lunr.liquid)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 创建角色JSON列表（/chapter7/search/lunr/lunr.liquid）
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Specifying the destination of the template output
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定模板输出的目标
- en: ❷ Using a filter to output the content in a JSON-safe way
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用过滤器以JSON安全的方式输出内容
- en: ❸ Including a comma for every item except the last
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在除了最后一个项目之外的所有项目中包含逗号
- en: The first thing to note in this template is the use of permalink in the front
    matter. This tells Eleventy to change its normal file-naming behavior for this
    template and to store the result in a file in the root of the site named index.json.
    In the template, we use Liquid to dynamically output an array of characters. For
    each character we output the title, the URL to the character (Eleventy provides
    this for us in the collection), and then the content. Note that we use a filter,
    json, to manipulate the output. The templateContent value provided by Eleventy
    includes the rendered content of the character. That includes HTML and line breaks,
    neither of which we want. We’ll create that filter shortly. Lastly, notice that
    we use a Liquid feature of loops that detects if we’re on the last iteration.
    We do this because we need a comma between each item in the array but do not want
    one after the last item. It may help to see how this JSON looks when done.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中需要注意的第一点是前导部分中使用的永久链接。这告诉Eleventy为此模板更改其正常的文件命名行为，并将结果存储在网站根目录下的index.json文件中。在模板中，我们使用Liquid动态输出角色数组。对于每个角色，我们输出标题、角色的URL（Eleventy为我们提供了这个集合），然后是内容。请注意，我们使用一个过滤器，json，来操作输出。Eleventy提供的templateContent值包括角色的渲染内容。这包括HTML和换行符，我们都不希望包含在内。我们很快将创建这个过滤器。最后，请注意，我们使用了一个Liquid循环特性，它可以检测我们是否处于最后一个迭代。我们这样做是因为我们需要在数组中的每个项目之间放置一个逗号，但不想在最后一个项目后放置一个。查看完成后的JSON看起来可能有助于理解。
- en: Listing 7.7 The generated JSON file
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 生成的JSON文件
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to support the JSON safe filter used in listing 7.6, we have to define
    this in the Eleventy configuration file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持列表7.6中使用的JSON安全过滤器，我们必须在Eleventy配置文件中定义此内容。
- en: Listing 7.8 The Eleventy configuration (/chapter7/search/lunr/.eleventy.js)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 Eleventy配置（/chapter7/search/lunr/.eleventy.js）
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ This line simply tells Eleventy to copy over the CSS used for this simple
    site.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这行代码只是告诉Eleventy复制用于此简单站点的CSS。
- en: The filter works by first removing any and all HTML and then line breaks. Note
    that other methods could be used here as well. For example, what if the character
    description was incredibly long? Or what if we had way more than six characters?
    In order to keep the size of the JSON smaller, you could make the call to only
    return the first thousand letters of the character’s description. In the end,
    Lunr doesn’t care, but the more data you send to it the more it will have to work!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器通过首先删除所有HTML和换行符来工作。注意，这里也可以使用其他方法。例如，如果角色的描述非常长怎么办？或者如果我们有超过六个字符怎么办？为了保持JSON的大小，你可以调用只返回角色的描述的前一千个字母。最终，Lunr并不关心，但发送给它的数据越多，它需要处理的数据就越多！
- en: Now that we have a data file to use as our source, it’s time to build the actual
    search engine. Figure 7.31 shows how this is going to look. We’ve got a simple
    field on top, a button, and that’s it, at least initially.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用作源数据文件，是时候构建实际的搜索引擎了。图7.31展示了它将如何看起来。我们有一个简单的字段在顶部，一个按钮，至少最初就是这样。
- en: '![CH07_F31_Camden2](Images/CH07_F31_Camden2.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F31_Camden2](Images/CH07_F31_Camden2.png)'
- en: Figure 7.31 The initial search form
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.31 初始搜索表单
- en: After entering some input and clicking Search, the results with links to respective
    pages will then be displayed (figure 7.32).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一些内容并点击搜索后，将显示带有指向相应页面链接的结果（图7.32）。
- en: '![CH07_F32_Camden2](Images/CH07_F32_Camden2.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F32_Camden2](Images/CH07_F32_Camden2.png)'
- en: Figure 7.32 Displaying search results below the form
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.32 在表单下方显示搜索结果
- en: The following listing shows how this is built.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了这是如何构建的。
- en: Listing 7.9 The search page (/chapter7/search/lunr/search.liquid)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9 搜索页面（/chapter7/search/lunr/search.liquid）
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Load the Lunr library.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载Lunr库。
- en: ❷ This code runs when the page loads in the browser.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此代码在浏览器页面加载时运行。
- en: ❸ This is where the Lunr index is defined.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是定义Lunr索引的地方。
- en: ❹ This handles user input and performs the search.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此代码处理用户输入并执行搜索。
- en: The template begins with a very short bit of HTML. We’ve got the search field,
    the button, and then an empty div block beneath them. This block will be used
    to render results. The bulk of the listing is the JavaScript.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模板从一段非常短的HTML代码开始。我们有搜索字段、按钮，以及它们下面的一个空div块。这个块将被用来渲染结果。列表的大部分是JavaScript代码。
- en: Before we get into the JavaScript, we have to add support for Lunr itself. This
    is done by pointing to the library on a CDN at [unpkg.com](https://unpkg.com/).
    We could have also downloaded the library and placed it in our site.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入JavaScript之前，我们必须添加对Lunr本身的支持。这是通过指向CDN上的库来完成的，网址为[unpkg.com](https://unpkg.com/)。我们也可以下载库并将其放置在我们的网站上。
- en: Our code begins by specifying a function to run (init) when the page has loaded.
    Some globally used variables are also defined here to be used later.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码首先指定一个在页面加载时运行的函数（init）。还定义了一些全局变量，以便稍后使用。
- en: 'The init function does a variety of things. First, it creates pointers to the
    things in the DOM we need to work with: the search field, button, and empty div.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: init函数执行了各种操作。首先，它创建了指向DOM中我们需要与之交互的元素的指针：搜索字段、按钮和空div。
- en: Next, it uses the fetch API to load the JSON we defined earlier. It loads this
    and converts to JavaScript data by parsing the JSON. Once we have that, we can
    create the Lunr index. We begin by defining the primary key for our data. This
    is a unique identifier for every item in the index. We’ve named this “id.” Then
    we then define what’s going to be searchable. That will be the title and content
    fields from our data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它使用fetch API加载我们之前定义的JSON。它通过解析JSON将其加载并转换为JavaScript数据。一旦我们有了这些，我们就可以创建Lunr索引。我们首先定义数据的主键。这是索引中每个项目的唯一标识符。我们将其命名为“id”。然后我们定义将要被搜索的内容。那将是我们的数据中的标题和内容字段。
- en: At this point, the index behavior is defined, but isn’t actually filled with
    anything. To do that, we loop over each item from our JSON array and add it to
    the index. To create the primary key, we simply use the loop index. This is added
    to our doc object, which is then added to the index.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，索引行为已经定义，但实际上并没有填充任何内容。为了做到这一点，我们遍历JSON数组中的每个项目，并将其添加到索引中。为了创建主键，我们只需使用循环索引。这个索引被添加到我们的文档对象中，然后添加到索引中。
- en: The final thing done in the init function is adding an event handler for the
    Search button. When users click that button, we first see if they typed anything,
    and, if not, simply exit the search function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在init函数中完成的最后一件事是为搜索按钮添加事件处理器。当用户点击该按钮时，我们首先检查他们是否输入了任何内容，如果没有，就简单地退出搜索函数。
- en: 'Searching against Lunr is incredibly easy; it’s literally one line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对Lunr进行搜索非常简单；实际上只是一行代码：
- en: '[PRE9]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This provides us an array of results if anything matched. Note the use of console.log
    immediately after. This lets us use the browser’s developer tools to examine the
    results. This is a handy way to figure out how to work with what Lunr found (figure
    7.33).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个结果数组，如果有什么匹配的话。注意在console.log之后的用法。这让我们可以使用浏览器的开发者工具来检查结果。这是一种了解如何使用Lunr找到的内容的好方法（图7.33）。
- en: '![CH07_F33_Camden2](Images/CH07_F33_Camden2.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F33_Camden2](Images/CH07_F33_Camden2.png)'
- en: Figure 7.33 Browser dev tools showing the Lunr search results
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.33 浏览器开发者工具显示的Lunr搜索结果
- en: Now that we have results, we’ve got to work with them so that we can display
    what was found. One thing that may be surprising about Lunr is that the search
    results do not actually contain the document itself. In figure 7.33, you can see
    that a ref value exists. Remember when we defined a primary key for our content
    and manually added the loop index? This is how we’ll be able to display the results.
    Lunr’s use of ref basically requires you to associate the result with the original
    data. This is what the loop is doing after the search. For each result, we add
    in the title and URL from the original set of documents. With that in place, we
    can then display the results using some simple HTML.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了结果，我们必须处理它们，以便我们可以显示找到的内容。关于Lunr可能会让人惊讶的一点是，搜索结果实际上并不包含文档本身。在图7.33中，你可以看到一个ref值。记得我们为内容定义了主键并手动添加了循环索引吗？这就是我们将如何显示结果的方式。Lunr对ref的使用基本上要求你将结果与原始数据关联起来。这就是搜索之后循环所做的事情。对于每个结果，我们添加了原始文档集中的标题和URL。有了这些，我们就可以使用一些简单的HTML来显示结果。
- en: There is, of course, more that you can do in this template. We could add support
    for letting the user know nothing was found. We could add support for searching
    against one particular part of our content (GI Joe characters are divided in teams,
    and our search interface could let you specify one to search against). Lunr is
    very flexible in this regard and can support pretty much anything your site needs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个模板中你还可以做更多的事情。我们可以添加支持让用户知道没有找到任何内容。我们可以添加支持搜索我们内容的一个特定部分（例如，GI Joe角色被分为团队，我们的搜索界面可以让你指定一个要搜索的部分）。在这一点上，Lunr非常灵活，几乎可以支持你网站上需要的任何功能。
- en: 7.2.2 Other options
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 其他选项
- en: 'As with forms, you’ve got many other options to consider when adding search.
    One in particular stands out that may be of interest to Jamstack developers: Algolia
    ([https://www.algolia.com/](https://www.algolia.com/)). Algolia is a commercial
    service (with a generous free tier) that uses an index like Lunr. Unlike Lunr,
    Algolia hosts your index on its servers and provides API to edit that index and
    search against it. It also provides powerful analytics about how your visitors
    search on your site.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就像表单一样，在添加搜索时，你还有许多其他选项需要考虑。其中一个特别引人注目的选项可能对Jamstack开发者感兴趣：Algolia ([https://www.algolia.com/](https://www.algolia.com/))。Algolia是一个商业服务（提供慷慨的免费层），它使用类似于Lunr的索引。与Lunr不同，Algolia在其服务器上托管你的索引，并提供API来编辑该索引和对其搜索。它还提供了有关访客如何在你的网站上搜索的强大分析。
- en: If you prefer something similar to Google’s service, but would rather not use
    Google, Microsoft has similar services with Bing Custom Search ([https://www .customsearch.ai/](https://www.customsearch.ai/)).
    Like Google, it also provides a free version of this service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢类似Google的服务，但又不想使用Google，Microsoft提供了类似的服务，即Bing Custom Search ([https://www.customsearch.ai/](https://www.customsearch.ai/))。像Google一样，它也提供这项服务的免费版本。
- en: 7.3 Other dynamic options
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 其他动态选项
- en: 'In this chapter, we focused on two particular ways of adding dynamic content
    back into your Jamstack site. Obviously there are a multitude of other ways you
    can do that. In chapter 5, you saw how to add e-commerce to your website. In the
    next chapter, you’ll see how to do nearly anything by adding serverless features.
    Some other forms of dynamic content include the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于两种将动态内容添加回你的 Jamstack 网站的方法。显然，还有许多其他方法可以实现这一点。在第 5 章中，你看到了如何将电子商务添加到你的网站中。在下一章中，你将看到如何通过添加无服务器功能来几乎实现任何事情。以下是一些其他形式的动态内容：
- en: '*Calendars*—Google Calendar ([http://calendar.google.com/](http://calendar.google.com/))
    lets you embed full calendars into an HTML page. Like other Google services, you
    get some basic styling options. You can also use open source libraries like FullCalendar
    ([https://fullcalendar.io/](https://fullcalendar.io/)) to provide completely unique
    designs to your calendars, which still can be driven by Google Calendar data.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日历*—Google Calendar ([http://calendar.google.com/](http://calendar.google.com/))
    允许你将完整的日历嵌入到 HTML 页面中。像其他 Google 服务一样，你有一些基本的样式选项。你也可以使用像 FullCalendar ([https://fullcalendar.io/](https://fullcalendar.io/))
    这样的开源库，为你的日历提供完全独特的设计，同时仍然可以由 Google Calendar 数据驱动。'
- en: '*Comments*—While typically only used on blogs, you may wish to add comments
    to your Jamstack site. Probably the most well known is Disqus ([https://disqus.com/](https://disqus.com/)).
    This is a pretty standard utility used for commenting across the internet and
    can be used for free. Other options include Commento ([commento.io](https://commento.io/))
    and FastComments ([fastcomments.com](https://fastcomments.com/)) if you are willing
    to roll your own solutions, but be prepared to do a bit of work. An article by
    Matt Mink ([https://css-tricks .com/jamstack-comments/](https://css-tricks.com/jamstack-comments/))
    describes just such a system.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*评论*—虽然通常只在博客中使用，但你可能希望在你的 Jamstack 网站中添加评论。最知名的可能就是 Disqus ([https://disqus.com/](https://disqus.com/))。这是一个相当标准的互联网评论工具，可以免费使用。如果你愿意自己构建解决方案，还有其他选项，如
    Commento ([commento.io](https://commento.io/)) 和 FastComments ([fastcomments.com](https://fastcomments.com/))，但要做好一些工作的准备。Matt
    Mink 的一篇文章 ([https://css-tricks.com/jamstack-comments/](https://css-tricks.com/jamstack-comments/))
    描述了这样一个系统。'
- en: '*Chat*—Another common tool on sites (typically commercial sites) is a chat
    box. This is usually a little talk balloon in the lower right of the site that
    lets a user click to speak to a person managing a site. A commercial example of
    such a service is LiveChat ([https://www.livechat.com/](https://www.livechat.com/)).
    Such services can be programmed with canned responses (“When asked about foo,
    respond with goo”), as well as be connected to living, breathing humans.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*聊天*—网站（通常是商业网站）上的另一个常见工具是聊天框。这通常是一个位于网站右下角的谈话气球，允许用户点击与网站管理员交谈。此类服务的商业例子是
    LiveChat ([https://www.livechat.com/](https://www.livechat.com/))。这些服务可以用预设的回复（“当被问及
    foo 时，回复 goo”）进行编程，也可以连接到真实的人类。'
- en: '*APIs*—The A in Jamstack stands for API, which means any remote resource (weather,
    stock data, etc.) that can be called with JavaScript and can be called within
    your Jamstack site.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*APIs*—Jamstack 中的 A 代表 API，意味着任何可以通过 JavaScript 调用的远程资源（如天气、股票数据等），并且可以在你的
    Jamstack 网站中调用。'
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A site that is simple static HTML, CSS, and JavaScript can still contain dynamic
    elements (forms, search, calendars, and more).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的静态 HTML、CSS 和 JavaScript 网站，仍然可以包含动态元素（表单、搜索、日历等）。
- en: Many services exist that make it incredibly easy to add dynamic aspects into
    your static site. For example, Google has multiple services (forms, search, calendars)
    where all you need to do is copy some HTML and paste it into your template. Services
    like WuFoo, FormCake, and FormKeep are just a few options for working with form
    input, one example of dynamic support.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多服务使得将动态特性添加到静态网站变得极其简单。例如，Google 提供了多个服务（表单、搜索、日历），你只需要复制一些 HTML 并将其粘贴到模板中即可。像
    WuFoo、FormCake 和 FormKeep 这样的服务只是处理表单输入的几个选项之一，这是动态支持的一个例子。
- en: Determining which service to use will depend on your needs, your budget, and
    which best provides the result you need.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择使用哪种服务将取决于你的需求、预算以及哪种服务最能提供你需要的成果。
