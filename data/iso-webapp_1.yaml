- en: Part 2\. Isomorphic app basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分 同构应用程序基础知识
- en: If you’ve spent much time in the front-end web world over the last few years,
    you’ve probably experienced “JavaScript fatigue.” That malaise happens because
    there’s a constant stream of libraries, tools, and new ideas to learn about. Being
    exposed to this stream of information can become overwhelming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在过去几年里在前端网络世界中花费了很多时间，你可能已经体验过“JavaScript疲劳”。这种不适是由于不断有库、工具和新想法需要学习。接触到这个信息流可能会变得令人不知所措。
- en: This part of the book provides an overview of each of the libraries and tools
    you need in order to build a best-practice React application that will work in
    a production environment. Several building blocks are required, including React,
    React Router, webpack, Babel, and Redux. The four chapters in this part explore
    these topics in depth and keep you focused on a small slice of the currently available
    JavaScript tools and libraries that are important for application development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这一部分概述了构建一个在生产环境中运行的最佳实践React应用程序所需的每个库和工具。所需的构建块包括React、React Router、webpack、Babel和Redux。本部分中的四章深入探讨了这些主题，并使你专注于当前可用的、对应用程序开发重要的JavaScript工具和库的小部分。
- en: 'In [chapter 3](kindle_split_014_split_000.xhtml#ch03), you’ll learn React,
    starting with the basics of JSX and the virtual DOM and moving into using properties
    and state to create React components. In [chapter 4](kindle_split_015_split_000.xhtml#ch04),
    you’ll learn how to use React Router to add multiple routes to your application.
    That chapter also introduces the React component lifecycle and covers advanced
    React concepts, including component composition and higher-order components. (Three
    appendices have been added to help you learn React Router 4.) It’s the first chapter
    that has you writing code for the All Things Westies app. In [chapter 5](kindle_split_016_split_000.xhtml#ch05),
    you’ll learn all about the build tools: webpack and Babel. In [chapter 6](kindle_split_017_split_000.xhtml#ch06),
    we’ll cover Redux in depth—you’ll learn to write actions, create reducers, and
    use the store.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_014_split_000.xhtml#ch03)中，你将学习React，从JSX和虚拟DOM的基础开始，然后学习如何使用属性和状态来创建React组件。在[第4章](kindle_split_015_split_000.xhtml#ch04)中，你将学习如何使用React
    Router向你的应用程序添加多个路由。该章节还介绍了React组件的生命周期，并涵盖了高级React概念，包括组件组合和高阶组件。（已添加三个附录，帮助你学习React
    Router 4。）这是第一个让你为All Things Westies应用程序编写代码的章节。在[第5章](kindle_split_016_split_000.xhtml#ch05)中，你将了解所有关于构建工具：webpack和Babel的内容。在[第6章](kindle_split_017_split_000.xhtml#ch06)中，我们将深入探讨Redux——你将学习编写动作、创建还原器和使用存储。
- en: Chapter 3\. React overview
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章 React概述
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: How the virtual DOM works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟DOM的工作原理
- en: React’s functional nature
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React的函数式特性
- en: Using JSX to declare React components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX声明React组件
- en: Using React state to handle user interaction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React状态处理用户交互
- en: React is a library for creating user interfaces, invented and used by Facebook.
    The React ecosystem has expanded rapidly over the last few years. It’s now possible
    to use React in many types of applications and architectures. This chapter will
    teach you what you need to know about React to build an isomorphic application.
    I’ll start by teaching you some React basics. The next chapter covers React component
    patterns and introduces React Router.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个用于创建用户界面的库，由Facebook发明并使用。在过去的几年里，React生态系统迅速扩展。现在，可以在许多类型的应用程序和架构中使用React。本章将教你构建同构应用程序所需了解的React知识。我将首先教你一些React基础知识。下一章将涵盖React组件模式并介绍React
    Router。
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Before getting started with this chapter, I recommend installing the React Developer
    tools for Chrome or Firefox. This will make debugging your React code much easier.
    I use React 15.6.1 for the examples in this chapter. [Chapter 9](kindle_split_021_split_000.xhtml#ch09)
    includes a detailed explanation of the React Developer tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，我建议安装Chrome或Firefox的React开发者工具。这将使调试你的React代码变得容易得多。我在本章的示例中使用React
    15.6.1。[第9章](kindle_split_021_split_000.xhtml#ch09)包括对React开发者工具的详细解释。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For a complete view into React, you can explore the many books on the subject,
    such as *React Quickly* by Azat Mardan (Manning, 2017). Feel free to skip over
    this chapter if you already have experience using React.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解React，你可以探索关于该主题的许多书籍，例如Azat Mardan的《React Quickly》（Manning，2017）。如果你已经具备使用React的经验，可以自由跳过本章。
- en: 'A note on the code and libraries used for this chapter: you can download the
    code from the GitHub repo at [https://github.com/isomorphic-dev-js/chapter3-react-overview](https://github.com/isomorphic-dev-js/chapter3-react-overview).
    To get up and running with the example, see README.md. To ensure that you have
    everything set up, make sure you run the following commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章使用的代码和库的说明：您可以从 GitHub 仓库 [https://github.com/isomorphic-dev-js/chapter3-react-overview](https://github.com/isomorphic-dev-js/chapter3-react-overview)
    下载代码。要运行示例，请参阅 README.md。为确保一切设置正确，请运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The examples run at http://localhost:9001\. This repo is organized into folders
    that are named according to chapter and example numbers. For most sections, you’ll
    refer to the components/Chapter_3_X folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 示例运行在 http://localhost:9001。此仓库按章节和示例编号组织成文件夹。对于大多数部分，您将参考 components/Chapter_3_X
    文件夹。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of publishing, the code in this chapter runs only with React 15\.
    But Storybook will be upgraded at some point. When Storybook is compatible with
    React 16, you can choose to use React 16 with the examples in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布时，本章中的代码只能在 React 15 下运行。但 Storybook 将在某个时候升级。当 Storybook 与 React 16 兼容时，您可以选择在本章的示例中使用
    React 16。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.1\. Overview of React
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. React 概述
- en: Let’s walk through setting up an HTML page that loads React and renders a single
    React component. The code for this section can be found in the GitHub repo in
    the html/Chapter_3_1/ path.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步设置一个加载 React 并渲染单个 React 组件的 HTML 页面。本节的代码可以在 GitHub 仓库的 html/Chapter_3_1/
    路径下找到。
- en: React replaces the view in web apps. It provides a simple API that’s easy to
    get up and running but that’s designed to be composed to facilitate building complex
    user interfaces. React works best when you build lots of small components and
    put them together to make your complete UI.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: React 替换了 Web 应用中的视图。它提供了一个简单且易于启动的 API，但设计用于组合，以促进构建复杂用户界面。React 在构建大量小型组件并将它们组合在一起以创建完整
    UI 时表现最佳。
- en: 'Here are the steps to get up and running with React on a static HTML page.
    If you’re familiar with React rendering, you can move on to the next section:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 React 在静态 HTML 页面上运行的基本步骤。如果您熟悉 React 渲染，可以跳到下一节：
- en: '**1**.  Set up an HTML page'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  设置一个 HTML 页面'
- en: '**2**.  Include the React library'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  包含 React 库'
- en: '**3**.  Include a script that renders a React component into the page'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  在页面中包含一个渲染 React 组件的脚本'
- en: To get started, you’re going to render Hello World with React. This first render
    will output only the string “My first react component” into the browser. You can
    see this in [figure 3.1](kindle_split_014_split_001.xhtml#ch03fig01).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您将使用 React 渲染“Hello World”。这次渲染将只将字符串“我的第一个 React 组件”输出到浏览器。您可以在[图 3.1](kindle_split_014_split_001.xhtml#ch03fig01)中看到这一点。
- en: Figure 3.1\. A basic React component’s output when loaded into the browser
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. 当加载到浏览器中的基本 React 组件的输出
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig01_alt.jpg)'
- en: First, you need your index.html. This HTML file, shown in [listing 3.1](kindle_split_014_split_001.xhtml#ch03ex01),
    will include all the required React dependencies as well as the code that creates
    a React component and places it on the DOM. For this first example, the HTML page
    is as bare-bones as possible. To see the output from [figure 3.1](kindle_split_014_split_001.xhtml#ch03fig01),
    open the index.html file in the browser.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个 index.html。此 HTML 文件，如[列表 3.1](kindle_split_014_split_001.xhtml#ch03ex01)所示，将包含所有必需的
    React 依赖项以及创建 React 组件并将其放置在 DOM 上的代码。对于这个第一个示例，HTML 页面尽可能简单。要查看[图 3.1](kindle_split_014_split_001.xhtml#ch03fig01)的输出，请在浏览器中打开
    index.html 文件。
- en: Listing 3.1\. First React render—html/Chapter_3_1/index.html
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 第一次 React 渲染—html/Chapter_3_1/index.html
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* React and React DOM dependencies, loaded off a CDN for simplicity.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* React 和 React DOM 依赖项，为简单起见从 CDN 加载。**'
- en: '***2* div is where the React code will be rendered.**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* div 是 React 代码将被渲染的地方。**'
- en: '***3* The script tag has code for rendering a React element into the DOM.**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 脚本标签包含将 React 元素渲染到 DOM 中的代码。**'
- en: '***4* Call the render method of ReactDOM with two parameters: the React element
    to render and the DOM node to attach to.**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用两个参数调用 ReactDOM 的 render 方法：要渲染的 React 元素和要附加到的 DOM 节点。**'
- en: '***5* Call React.createElement to create div with text.**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用 React.createElement 创建包含文本的 div。**'
- en: '***6* HTML element where React should attach rendered output**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* React 应该附加渲染输出的 HTML 元素**'
- en: The JavaScript in index.html renders a single React element into the empty `<div>`
    in the `<body>`. To do that, you use two of React’s methods. `React.createElement`
    comes from the core library (react.js) and creates a React element. `ReactDOM.render`
    comes from the React DOM library (react-dom.js), takes the React element created
    by `React.createElement`, and renders it into the DOM.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: index.html中的JavaScript将单个React元素渲染到<body>中的空<div>中。为此，你使用了React的两个方法。`React.createElement`来自核心库（react.js），它创建一个React元素。`ReactDOM.render`来自React
    DOM库（react-dom.js），它接受由`React.createElement`创建的React元素，并将其渲染到DOM中。
- en: That example was simple, so let’s look at a slightly more complex one. In [listing
    3.2](kindle_split_014_split_001.xhtml#ch03ex02), there’s a button inside the <div>
    instead of just text. [Figure 3.2](kindle_split_014_split_001.xhtml#ch03fig02)
    shows this button.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子很简单，所以让我们看看一个稍微复杂一点的例子。在[列表3.2](kindle_split_014_split_001.xhtml#ch03ex02)中，<div>中有一个按钮，而不是只有文本。[图3.2](kindle_split_014_split_001.xhtml#ch03fig02)显示了此按钮。
- en: Figure 3.2\. Rendering multiple HTML tags with React
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 使用React渲染多个HTML标签
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig02_alt.jpg)'
- en: To render this button, you replace the text with a new React element. The following
    listing shows you how to update the script tag to render the button.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染此按钮，你需要将文本替换为一个新的React元素。以下列表显示了如何更新脚本标签以渲染按钮。
- en: Listing 3.2\. Rendering multiple HTML tags—html/Chapter_3_1/button.html
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2\. 渲染多个HTML标签—html/Chapter_3_1/button.html
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Instead of putting text into <div>, you can nest React elements—here
    you create an HTML button with text.**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你可以将文本放入<div>中，而不是直接放入文本，你可以嵌套React元素——在这里你创建了一个带有文本的HTML按钮。**'
- en: This button example shows how to nest HTML elements and use React’s declarative
    style to state your app structure. But React’s real power lies in its ability
    to update the DOM as elements change. Next, I’ll introduce the virtual DOM to
    you.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此按钮示例显示了如何嵌套HTML元素并使用React的声明式风格来声明你的应用程序结构。但React真正的力量在于其能够根据元素的变化更新DOM。接下来，我将向您介绍虚拟DOM。
- en: 3.2\. Virtual DOM
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 虚拟DOM
- en: Before I discuss the virtual DOM, I want to make sure you have a clear picture
    of the browser DOM (*DOM* stands for Document Object Model). The DOM is a markup
    representation of a web page. The browser interprets the DOM to determine how
    to render the web page. You could think of this as a plan, or map, that the browser
    reads to determine how to build your page. For example, the rendered output of
    the nested elements in the button example in the previous section is shown in
    the following listing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我讨论虚拟DOM之前，我想确保你对浏览器DOM（*DOM*代表文档对象模型）有一个清晰的了解。DOM是网页的标记表示。浏览器解释DOM以确定如何渲染网页。你可以将其视为浏览器读取以确定如何构建你的页面的计划或地图。例如，上一节中按钮示例中嵌套元素的渲染输出如下所示。
- en: Listing 3.3\. DOM markup for button example
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. 按钮示例的DOM标记
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* div placeholder that React renders into**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* React渲染的div占位符**'
- en: '***2* Root component**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根组件**'
- en: '***3* Button created by React.createElement**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 由React.createElement创建的按钮**'
- en: This code results in a blueprint for the browser that instructs it to render
    two divs with a button inside. Along with a little CSS, it results in the button
    in [figure 3.2](kindle_split_014_split_001.xhtml#ch03fig02).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为浏览器生成一个蓝图，指示它渲染两个包含按钮的div。结合一点CSS，它会在[图3.2](kindle_split_014_split_001.xhtml#ch03fig02)中生成按钮。
- en: The virtual DOM is a lightweight representation of the DOM that can be traversed
    and updated much faster. It’s a JavaScript representation of the DOM. For the
    button example, React keeps a version of the component structure in JavaScript.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM是DOM的一个轻量级表示，可以快速遍历和更新。它是DOM的JavaScript表示。对于按钮示例，React在JavaScript中保留组件结构的版本。
- en: Traditionally, manipulating the DOM has been slow. When a change needs to be
    made, the entire page has to be traversed, and updates are inserted and then rerendered.
    Imagine that you want to update a list of items in HTML. You’d have to find the
    list, traverse it, and make updates and insertions as needed. As your app grows
    and you have more items and more lists, this process gets slower. Enter the virtual
    DOM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，操作DOM很慢。当需要做出更改时，整个页面都必须遍历，然后插入更新并重新渲染。想象一下，你想要更新HTML中的项目列表。你必须找到列表，遍历它，并根据需要做出更新和插入。随着你的应用程序增长，你拥有更多项目和更多列表，这个过程会变得更慢。虚拟DOM应运而生。
- en: '[Figure 3.3](kindle_split_014_split_002.xhtml#ch03fig03) shows the startup
    flow of a React application. When the initial JavaScript is run, React generates
    the base virtual DOM from the React components in your app. Then React attaches
    the DOM tree to the browser DOM.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.3](kindle_split_014_split_002.xhtml#ch03fig03)展示了React应用的启动流程。当初始JavaScript运行时，React从你的应用中的React组件生成基本虚拟DOM。然后React将DOM树附加到浏览器DOM上。'
- en: Figure 3.3\. React’s virtual DOM when the app starts up
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 应用启动时React的虚拟DOM
- en: '![](Images/03fig03_alt.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig03_alt.jpg)'
- en: React takes this virtual DOM and does a diff between the previous state and
    the updated state. React compares the old version of the virtual DOM with the
    new version and calculates anything that has changed. It then uses an algorithm
    optimized for web apps to determine where to make updates to the DOM. [Figure
    3.4](kindle_split_014_split_002.xhtml#ch03fig04) illustrates this process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: React将这个虚拟DOM与之前的状态和更新后的状态进行比较。React比较虚拟DOM的旧版本和新版本，并计算任何变化。然后它使用针对Web应用优化的算法来确定在DOM中哪里需要更新。[图3.4](kindle_split_014_split_002.xhtml#ch03fig04)说明了这个过程。
- en: Figure 3.4\. The continuous update and diff cycle that React goes through to
    keep the DOM up-to-date
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. React为了保持DOM更新而经历的持续更新和diff周期
- en: '![](Images/03fig04_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig04_alt.jpg)'
- en: Ultimately, React updates only those parts that are absolutely necessary so
    that the internal state (virtual DOM) and the view (real DOM) are the same. For
    example, if there’s a `<p>` element and you augment the text via the state of
    the component, only the text will be updated (`innerHTML`), not the element itself.
    This results in increased performance compared to re-rendering entire sets of
    elements or, even more so, entire pages (server-side rendering).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，React只更新绝对必要的部分，以便内部状态（虚拟DOM）和视图（真实DOM）保持一致。例如，如果有一个`<p>`元素，你通过组件的状态增加文本，只有文本会被更新（`innerHTML`），元素本身不会改变。这比重新渲染整个元素集或，更不用说整个页面（服务器端渲染）的性能有所提高。
- en: In [figure 3.5](kindle_split_014_split_002.xhtml#ch03fig05), you can see an
    example of what happens when an update is made. React looks at the component tree
    and figures out which parts need to be updated. Then it intelligently updates
    the browser DOM to match the current state of the application. In this case, one
    list item is removed, and one list item is added. The third list item remains
    unchanged. React is able to optimize for these changes and update the DOM quickly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3.5](kindle_split_014_split_002.xhtml#ch03fig05)中，你可以看到一个更新发生时的示例。React查看组件树，并确定哪些部分需要更新。然后它智能地更新浏览器DOM以匹配当前应用的状态。在这种情况下，一个列表项被移除，一个列表项被添加。第三个列表项保持不变。React能够对这些更改进行优化并快速更新DOM。
- en: Figure 3.5\. The virtual DOM updates the browser DOM based on the diff algorithm
    that React runs on state changes.
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. React根据状态变化运行的diff算法更新浏览器DOM
- en: '![](Images/03fig05_alt.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig05_alt.jpg)'
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about the virtual DOM, you can find additional resources
    online. Codecademy has a good overview ([www.codecademy.com/articles/react-virtual-dom](http://www.codecademy.com/articles/react-virtual-dom)),
    and Hackernoon does a deep dive into the topic ([https://hackernoon.com/virtual-dom-in-reactjs-43a3fdb1d130](https://hackernoon.com/virtual-dom-in-reactjs-43a3fdb1d130)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于虚拟DOM的信息，你可以在网上找到额外的资源。Codecademy有一个很好的概述([www.codecademy.com/articles/react-virtual-dom](http://www.codecademy.com/articles/react-virtual-dom))，而Hackernoon对这个主题进行了深入探讨([https://hackernoon.com/virtual-dom-in-reactjs-43a3fdb1d130](https://hackernoon.com/virtual-dom-in-reactjs-43a3fdb1d130))。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.3\. Todo app overview
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. Todo应用概述
- en: In this section, you’ll build a Todo app. This single-page application (SPA)
    will enable users to store lists of todos, mark them as complete, and see what
    todos are left to be done. [Figure 3.6](kindle_split_014_split_003.xhtml#ch03fig06)
    shows this app. To keep you focused on learning React, this isn’t an isomorphic
    app.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将构建一个Todo应用。这个单页应用（SPA）将使用户能够存储待办事项列表，标记它们为完成，并查看还有哪些待办事项。[图3.6](kindle_split_014_split_003.xhtml#ch03fig06)展示了这个应用。为了让你专注于学习React，这不是一个同构应用。
- en: Figure 3.6\. A wireframe for the Todo app you’ll build in this chapter
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6\. 你在本章中将要构建的Todo应用的线框图
- en: '![](Images/03fig06_alt.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig06_alt.jpg)'
- en: '[Chapter 5](kindle_split_016_split_000.xhtml#ch05) shows how to set up webpack
    and ES6 for isomorphic apps. In the meantime, I’ll use a library called Storybook
    throughout this chapter to help you get started with React code. I want you to
    focus on React—Storybook lets you get started with little setup. If you’d like
    to see more of how this works, you can check out the stories folders in the repo
    as well as the nearby sidebar.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](kindle_split_016_split_000.xhtml#ch05)展示了如何为同构应用设置webpack和ES6。在此同时，我将在本章中使用一个名为Storybook的库来帮助你开始React代码的学习。我希望你专注于React——Storybook允许你以最小的设置开始。如果你想了解更多关于它是如何工作的，你可以查看仓库中的stories文件夹以及附近的侧边栏。'
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using Storybook for previewing React components**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Storybook预览React组件**'
- en: 'The npm package Storybook by Kadira ([https://github.com/kadirahq/react-storybook](https://github.com/kadirahq/react-storybook))
    is a tool for building React components without having to hook up the component
    to your application to see how it works. Storybook makes no assumptions about
    your application. Instead, it can render any React component that you want to
    see in isolation. It can even render full user interfaces composed of multiple
    components if you provide the correct inputs. Here’s Storybook running in the
    browser:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Kadira的npm包Storybook([https://github.com/kadirahq/react-storybook](https://github.com/kadirahq/react-storybook))是一个用于构建React组件的工具，无需将组件连接到你的应用程序以查看其工作情况。Storybook对你的应用程序不做任何假设。相反，它可以渲染你想要单独查看的任何React组件。如果你提供正确的输入，它甚至可以渲染由多个组件组成的完整用户界面。以下是Storybook在浏览器中的运行情况：
- en: '![](Images/0060fig01_alt.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0060fig01_alt.jpg)'
- en: The library takes advantage of iframes to isolate each component so that you
    can easily flip between components. Storybook uses webpack’s hot module loading
    to build and monitor code changes, autorefreshing changes in the browser as you
    edit your code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该库利用iframe来隔离每个组件，这样你可以轻松地在组件之间切换。Storybook使用webpack的hot module loading来构建和监控代码更改，在你编辑代码时自动刷新浏览器中的更改。
- en: 'To use Storybook, you must install it globally:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Storybook，你必须全局安装它：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then in the command line inside the repo, you run the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在仓库内的命令行中运行以下命令：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To write a story, you add code to the components/stories folder. There’s a
    file for each chapter section that uses stories. Storybook provides two functions:
    `storiesOf` and `add`. The first function, `storiesOf`, adds a new story to Storybook,
    which shows on the left (Chapter examples and Todo app). The section function
    (`add`) adds a specific example to the story (link displays with props, list item
    functional). To see this in action, review the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个故事，你需要在components/stories文件夹中添加代码。每个使用故事的章节部分都有一个文件。Storybook提供了两个函数：`storiesOf`和`add`。第一个函数`storiesOf`向Storybook添加一个新的故事，它将在左侧显示（章节示例和Todo应用）。`add`函数（部分函数）向故事添加一个特定的示例（带有属性的链接显示，列表项功能）。要查看这个功能是如何工作的，请查看以下代码：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then Storybook renders these components at localhost:9001\. If you click the
    button in example 2, the action logger will log `button clicked`. That’s how you
    test whether a component is properly calling the expected actions or callbacks
    that have been passed into it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Storybook将在localhost:9001上渲染这些组件。如果你点击示例2中的按钮，动作记录器将记录`button clicked`。这就是测试组件是否正确调用预期动作或回调的方法。
- en: Storybook offers manual assertion testing and visual rendering without the complexity
    of hooking the component into the app. This makes writing the view portion of
    your app faster and lets you test components independent of your business logic.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook提供了手动断言测试和视觉渲染，无需将组件连接到应用程序的复杂性。这使得编写应用程序的视图部分更快，并允许你独立于业务逻辑测试组件。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.4\. Your first React component
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 你的第一个React组件
- en: 'At this point, you should understand why you want to use React and the basics
    of rendering. Now you’ll learn the following best practice development skills:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该理解为什么你想使用React以及渲染的基础知识。现在你将学习以下最佳实践的开发技能：
- en: JSX basics
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX基础
- en: Pure components
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯组件
- en: Using properties
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性
- en: Conditionals and looping
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件和循环
- en: React classes
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React类
- en: User interactions
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户交互
- en: By the end of this section, you’ll be able to build a user interface for a Todo
    application (see [figure 3.1](kindle_split_014_split_001.xhtml#ch03fig01)) with
    user interactions. You’ll have used all the React features necessary for building
    isomorphic applications. To follow along with the examples in this chapter, check
    out the react-components branch in the GitHub repository (`git checkout react-components`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将能够构建一个 Todo 应用程序的用户界面（见 [图 3.1](kindle_split_014_split_001.xhtml#ch03fig01)），并实现用户交互。你将使用所有构建同构应用程序所需的
    React 功能。要跟随本章中的示例，请查看 GitHub 仓库中的 react-components 分支（`git checkout react-components`）。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find the files for this section in components/Chapter_3_4 and components/stories/chapter_3_4.js.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个部分的文件在 components/Chapter_3_4 和 components/stories/chapter_3_4.js 中找到。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: React follows basic core tenets. First, it provides a standard, simple interface
    for building views. Second, it uses a declarative style to handle updates and
    state changes. In React, components don’t worry about how their children function.
    They’re concerned only with the data that needs to be passed into the children.
    For example, to create the list view in the Todo app, you tell React to render
    a list item for each entry in the list of todos. The list view doesn’t worry about
    how React implements the underlying logic to update the browser DOM. It worries
    only about the data needs of the list items. To see this in action, you’ll learn
    to write the Todo app button component with React’s template language, JSX.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: React 遵循基本的核心原则。首先，它提供了一个标准、简单的接口来构建视图。其次，它使用声明式风格来处理更新和状态变化。在 React 中，组件不关心它们的子组件如何工作。它们只关心需要传递给子组件的数据。例如，为了在
    Todo 应用程序中创建列表视图，你告诉 React 为待办事项列表中的每个条目渲染一个列表项。列表视图不关心 React 如何实现更新浏览器 DOM 的底层逻辑。它只关心列表项的数据需求。为了看到这一点，你将学习如何使用
    React 的模板语言 JSX 编写 Todo 应用程序的按钮组件。
- en: 3.4.1\. JSX basics
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. JSX 基础
- en: So far, you’ve seen how to render React components by writing them in JavaScript.
    But React uses a template language called JSX that makes writing components almost
    like writing HTML. JSX is designed to be compiled into JavaScript and allows you
    to mix component declarations, HTML, and JavaScript.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何通过在 JavaScript 中编写它们来渲染 React 组件。但 React 使用一种名为 JSX 的模板语言，这使得编写组件几乎就像编写
    HTML 一样。JSX 被设计成编译成 JavaScript，并允许你混合组件声明、HTML 和 JavaScript。
- en: The Todo app has a lot of buttons, so you’re going to create a button that can
    be reused for various button use cases. [Figure 3.7](kindle_split_014_split_004.xhtml#ch03fig07)
    shows what this looks like.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Todo 应用程序有很多按钮，所以你将创建一个可以用于各种按钮用例的可重用按钮。[图 3.7](kindle_split_014_split_004.xhtml#ch03fig07)
    展示了它的样子。
- en: Figure 3.7\. The button component rendered inside Storybook
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.7\. 在 Storybook 内部渲染的按钮组件
- en: '![](Images/03fig07_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig07_alt.jpg)'
- en: 'A basic button in JSX is written like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 中的基本按钮编写如下：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point, you’ve written what looks to be some HTML. Declaring HTML elements
    is identical to how you’d write them in an HTML file (`div`, `a`, `ul`, `img`,
    `video`, and so forth). But because you’ll compile the JSX into JavaScript, JSX
    provides syntax for indicating where to execute JavaScript expressions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经编写了一些看起来像是 HTML 的内容。声明 HTML 元素的方式与你在 HTML 文件中编写它们的方式相同（`div`、`a`、`ul`、`img`、`video`
    等等）。但由于你将 JSX 编译成 JavaScript，JSX 提供了指示执行 JavaScript 表达式位置的语法。
- en: To illustrate this point, let’s imagine you want to turn the button label into
    a variable. [Listing 3.4](kindle_split_014_split_004.xhtml#ch03ex04) shows the
    code for your first React component. Replace the code in buttonBasic.jsx with
    the code from the listing. I’ve already set up the story for you. After you’ve
    added the code from the listing, you can view it at http://localhost:9001 under
    the JSX basic button tab, as shown in [figure 3.7](kindle_split_014_split_004.xhtml#ch03fig07).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们假设你想要将按钮标签转换为一个变量。[列表 3.4](kindle_split_014_split_004.xhtml#ch03ex04)
    展示了你的第一个 React 组件的代码。用列表中的代码替换 buttonBasic.jsx 中的代码。我已经为你设置了场景。在你添加了列表中的代码之后，你可以在
    JSX 基本按钮选项卡下查看它，如图 [图 3.7](kindle_split_014_split_004.xhtml#ch03fig07) 所示。
- en: Listing 3.4\. JSX Button component—Chapter_3_4/buttonBasic.jsx
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. JSX 按钮组件—第 3 章 4 节/buttonBasic.jsx
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Include React, required in every React component.**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 React，这是每个 React 组件必需的。**'
- en: '***2* Declare button label as a variable.**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将按钮标签声明为一个变量。**'
- en: '***3* Use JSX {} syntax to indicate a JavaScript expression to compiler.**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 JSX {} 语法来指示编译器一个 JavaScript 表达式。**'
- en: '***4* Export component so it can be included in other components.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导出组件，以便它可以被其他组件包含。**'
- en: This JSX will be compiled and will know that `label` is a JavaScript expression.
    You can put any valid JavaScript inside the `{}`. The curly brackets indicate
    JavaScript to be executed. That can be a variable, ternary, function, or other
    valid JavaScript code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSX 将会被编译，并且会知道 `label` 是一个 JavaScript 表达式。你可以在 `{}` 中放置任何有效的 JavaScript
    代码。大括号表示要执行的 JavaScript。这可能是一个变量、三元运算符、函数或其他有效的 JavaScript 代码。
- en: 'To make sure you understand how JSX compiles to JavaScript, let’s revisit the
    render example from earlier in the chapter, where you render “My first React component”
    into the DOM:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你理解 JSX 如何编译成 JavaScript，让我们回顾一下本章前面提到的渲染示例，其中你将“我的第一个 React 组件”渲染到 DOM
    中：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s rewrite this bit of JavaScript by using what you’ve learned so far about
    JSX. I find this second example much easier to process. It reads like HTML:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用你到目前为止学到的关于 JSX 的知识来重写这段 JavaScript 代码。我发现第二个例子更容易处理。它读起来像 HTML：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first example, you have to understand what each parameter is doing. You
    need to know the details of how `React.createElement` works, including what parameters
    to pass in. In the second example, you can immediately see that React will render
    a div that will display “My first React component” because you already know how
    to read HTML.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，你必须理解每个参数的作用。你需要了解 `React.createElement` 的工作细节，包括要传递哪些参数。在第二个例子中，你可以立即看到
    React 将渲染一个 div，并显示“我的第一个 React 组件”，因为你已经知道如何阅读 HTML。
- en: 'Similarly, the compiled version of the button component uses `React.createElement`
    and passes in a set of parameters indicating what to render. In the button example,
    an extra parameter is passed: the JavaScript expression, or in this case, the
    variable called `label`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，按钮组件的编译版本使用 `React.createElement` 并传递一组参数，指示要渲染的内容。在按钮示例中，传递了一个额外的参数：JavaScript
    表达式，或者在这种情况下，名为 `label` 的变量：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example shows the compiled JavaScript version of the JSX. Notice that because
    the JSX is now plain JavaScript, the variable is readable by the JavaScript interpreter.
    That’s the power of JSX. It lets you mix the view declaration with JavaScript
    logic.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了 JSX 编译后的 JavaScript 版本。注意，因为 JSX 现在是纯 JavaScript，变量可以被 JavaScript 解释器读取。这就是
    JSX 的力量。它让你可以将视图声明与 JavaScript 逻辑混合。
- en: If you’re thinking this seems a bit strange, I encourage you to give it five
    minutes (see [https://signalvnoise.com/posts/3124-give-it-five-minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes)).
    The first time I saw JSX, I thought it was terrible. It reminded me of writing
    server-side languages like PHP.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这有点奇怪，我鼓励你花五分钟时间（见 [https://signalvnoise.com/posts/3124-give-it-five-minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes)）。我第一次看到
    JSX 时，认为它很糟糕。它让我想起了编写服务器端语言，如 PHP。
- en: After I started to use JSX, I found that it’s one of the better, if not the
    best, inline view options available for web applications. I now enjoy writing
    JSX! It’s about as close to writing HTML as you can get without just writing HTML.
    It has the added benefit of being easy to read and easy to write. Plus, it enables
    you to write your view logic and your view structure side by side. That lets you
    remove unnecessary boilerplate and makes the developer experience better; it’s
    just more readable than other options. JSX gets bonus points for making unit testing
    your views relatively painless.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始使用 JSX 之后，我发现它可能是最好的，如果不是最好的，内联视图选项之一，适用于网络应用。我现在非常喜欢写 JSX！它几乎和写 HTML 一样，但又不完全是
    HTML。它有易于阅读和易于书写的额外好处。此外，它允许你将视图逻辑和视图结构并排编写。这让你可以移除不必要的样板代码，使开发者体验更好；它比其他选项更易于阅读。JSX
    因为使得单元测试视图相对容易而获得加分。
- en: Common JSX gotchas
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常见 JSX 陷阱
- en: For the most part, JSX plays by normal JavaScript rules. But you should be aware
    of a few exceptions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，JSX 遵循正常的 JavaScript 规则。但你应该注意一些例外。
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'I don’t have space to go over every JSX gotcha. The good news is that Facebook
    keeps its documentation up-to-date. For a full list of JSX gotchas, visit the
    JSX gotchas page and the JSX in-depth page on the React docs: [https://facebook.github.io/react/docs/jsx-gotchas.html](https://facebook.github.io/react/docs/jsx-gotchas.html)
    and [https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有空间来详细说明每个JSX的陷阱。好消息是Facebook保持其文档更新。要查看JSX陷阱的完整列表，请访问JSX陷阱页面和React文档中的JSX深入页面：[https://facebook.github.io/react/docs/jsx-gotchas.html](https://facebook.github.io/react/docs/jsx-gotchas.html)
    和 [https://facebook.github.io/react/docs/jsx-in-depth.html](https://facebook.github.io/react/docs/jsx-in-depth.html)。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'When adding CSS classes in JSX, the compiler will ignore the word `class` because
    it’s a reserved word in JavaScript. Remember that the JSX code will get compiled
    to JavaScript. Instead, you need to use the attribute `className` to add a class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中添加CSS类时，编译器会忽略单词`class`，因为在JavaScript中它是保留字。记住JSX代码将被编译成JavaScript。因此，你需要使用属性`className`来添加类：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'React will also ignore custom attributes. If you need to add a custom attribute,
    use the `data-` prefix instead:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: React也会忽略自定义属性。如果你需要添加自定义属性，请使用`data-`前缀代替：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, JSX looks like HTML, but it’s not HTML. You can’t write `<!--HTML
    Comment-->`. If you do, you’ll get compile errors. But you can still add regular
    JavaScript comments; just put them inside an expression `{}`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JSX看起来像HTML，但它不是HTML。你不能写`<!--HTML Comment-->`。如果你这样做，你会得到编译错误。但是你仍然可以添加常规JavaScript注释；只需将它们放在一个表达式`{}`内：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have some experience with JSX, let’s build the ListItem component
    for the To do app.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对JSX有一些经验了，让我们为待办事项应用构建ListItem组件。
- en: 3.4.2\. Building a reusable component
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 构建可复用组件
- en: So far, I’ve shown you only how to render into the DOM directly and how to write
    JSX. Now you’ll write complete components. The Todo app can be broken into small,
    reusable components such as Button, ListItem, and Tab. Take a look at the visual
    representation of the Todo app’s component parts in [figure 3.8](kindle_split_014_split_004.xhtml#ch03fig08).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我只展示了如何直接渲染到DOM中以及如何编写JSX。现在你将编写完整的组件。待办事项应用可以被分解成小的、可复用的组件，如Button、ListItem和Tab。看看待办事项应用组件部分的视觉表示[图3.8](kindle_split_014_split_004.xhtml#ch03fig08)。
- en: Figure 3.8\. Each rectangle encloses an individual component. Some components
    are nested; for example, the Button component is nested inside the ListItem component,
    which is inside the List component.
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8\. 每个矩形包含一个单独的组件。有些组件是嵌套的；例如，Button组件嵌套在ListItem组件中，而ListItem组件又嵌套在List组件中。
- en: '![](Images/03fig08_alt.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig08_alt.jpg)'
- en: In a React view, each repeatable element can become a component. Other components
    wrap the smaller composable components and determine the layout. In [figure 3.8](kindle_split_014_split_004.xhtml#ch03fig08),
    the wrapper components such as AddItem and List contain smaller, reusable components.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在React视图中，每个可重复的元素都可以成为一个组件。其他组件包裹较小的可组合组件并确定布局。在[图3.8](kindle_split_014_split_004.xhtml#ch03fig08)中，如AddItem和List这样的包装组件包含较小的、可复用的组件。
- en: The smaller components such as ListItem and Button are repeated throughout the
    user interface. React lets you write these once and then use them over and over.
    That simplifies your code, making it more maintainable and readable. It also lets
    you write the view in a declarative style.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如ListItem和Button这样的较小组件在用户界面中重复出现。React允许你一次编写这些组件，然后反复使用它们。这简化了你的代码，使其更易于维护和阅读。它还允许你以声明式风格编写视图。
- en: The first reusable component you’ll build will be the ListItem component for
    the Todo app. (Reusable components are considered best practice because they speed
    up development time.) [Figure 3.9](kindle_split_014_split_004.xhtml#ch03fig09)
    shows the ListItem output.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要构建的第一个可复用组件将是用于待办事项应用的ListItem组件。（可复用组件被认为是最佳实践，因为它们可以加快开发速度。）[图3.9](kindle_split_014_split_004.xhtml#ch03fig09)展示了ListItem的输出。
- en: Figure 3.9\. View of the todo item in Storybook with action logging
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9\. Storybook中待办项的视图以及操作日志
- en: '![](Images/03fig09_alt.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig09_alt.jpg)'
- en: This component is created with the code in the following listing. This code
    replaces the placeholder code in the listItemFunctional.jsx file. After you’ve
    added it, you can see it in Storybook, as the story already exists.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件使用以下列表中的代码创建。此代码替换了listItemFunctional.jsx文件中的占位符代码。添加后，你可以在Storybook中看到它，因为故事已经存在。
- en: Listing 3.5\. List item—components/Chapter_3_4/listItemFunctional.jsx
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. 列表项—components/Chapter_3_4/listItemFunctional.jsx
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Create the component with a JavaScript function declaration—creates pure
    or functional component.**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 JavaScript 函数声明创建组件——创建纯函数组件。**'
- en: '***2* Return JSX to be rendered—must be a single root node or you’ll get error.**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回要渲染的 JSX——必须是一个单一根节点，否则你会得到错误。**'
- en: '***3* Parent component passes in the properties ListItem uses, including name
    and the click handler callback.**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 父组件传递 ListItem 使用到的属性，包括名称和点击处理程序回调。**'
- en: '***4* If multiple elements of the same type are siblings, give them unique
    keys so React knows the difference between them on subsequent renders.**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果同一类型的多个元素是兄弟元素，请为它们提供唯一的键，这样 React 才能在后续渲染中区分它们。**'
- en: It’s important to note the use of the `key` attribute in this example. The `key`
    attribute must be used anytime you have two sibling elements that are the same
    type. In the listing, there are two buttons. React won’t know which one has changed
    unless you provide a key. If it doesn’t know which one has changed, it’ll replace
    both items. With a `key` attribute, React will know which element to update and
    can be much more efficient in making DOM changes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`key` 属性的使用非常重要。任何时候你有两个相同类型的兄弟元素时，都必须使用 `key` 属性。在列表中，有两个按钮。除非你提供键，否则
    React 不会知道哪个发生了变化。如果它不知道哪个发生了变化，它将替换两个项目。有了 `key` 属性，React 就知道哪个元素需要更新，并且可以在进行
    DOM 变更时更加高效。
- en: 'The ListItem component in [listing 3.5](kindle_split_014_split_004.xhtml#ch03ex05)
    is rendered using two important React concepts:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.5](kindle_split_014_split_004.xhtml#ch03ex05) 中的 ListItem 组件使用了两个重要的
    React 概念：'
- en: Properties (`props`)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性 (`props`)
- en: Pure functional components
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数组件
- en: In the next section, we’ll explore how to use React’s concept of properties
    to turn components into reusable templates that take in properties to display.
    Then we’ll look at declaring pure functional components.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 React 的属性概念将组件转换为可重用的模板，该模板接受属性以显示内容。然后我们将查看如何声明纯函数组件。
- en: 3.4.3\. Using properties
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3\. 使用属性
- en: With React, you want to build reusable components. For example, a ListItem that
    can be reused for any todo item that the app needs to display would come in handy.
    This is where React properties shine. With *properties*, you can define how to
    pass in the information that a component will need. React properties make it possible
    to create reusable components. They contain all the information that makes a component’s
    usage unique.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React，你想要构建可重用的组件。例如，一个可以用于任何需要显示的待办事项的 ListItem 组件会很有用。这正是 React 属性大放异彩的地方。通过
    *属性*，你可以定义如何传递组件所需的信息。React 属性使得创建可重用组件成为可能。它们包含使组件使用独特的信息。
- en: 'To use a property, you can pass in the `name` property with value `Cleanup
    my desk`, like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用属性，你可以传递具有值 `Cleanup my desk` 的 `name` 属性，如下所示：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The component can then access this value on the `props` object:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以随后在 `props` 对象上访问此值：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That, in turn, would render the following `div` in the browser DOM tree:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来会在浏览器 DOM 树中渲染以下 `div`：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the property changes, a render is triggered and the component will update.
    We’ll talk more about the component lifecycle in [chapter 4](kindle_split_015_split_000.xhtml#ch04).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性发生变化，将触发渲染，组件将更新。我们将在第 4 章中更多地讨论组件的生命周期。
- en: Think of properties as unchangeable values within an element. They allow elements
    to have different aspects or properties, hence the name.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性视为元素内的不可变值。它们允许元素具有不同的方面或属性，因此得名。
- en: Properties are immutable within their components. A parent assigns properties
    to its children upon their creation. The child element isn’t supposed to modify
    its properties (in development, React will throw errors if you do that).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 属性在其组件内部是不可变的。父组件在创建时将其属性分配给子组件。子元素不应该修改其属性（在开发中，如果你这样做，React 将抛出错误）。
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *child* is an element that’s nested inside another element (for example, `<Button/>`
    is a child of `<ListItem/>`). The parent is the component that wraps the child.
    Components may have many children, and these children may have children.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*子* 是嵌套在另一个元素内部的元素（例如，`<Button/>` 是 `<ListItem/>` 的子元素）。父组件是包裹子组件的组件。组件可以有多个子元素，这些子元素也可以有子元素。'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Spread operator
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: 'One more thing about passing `props` into components: let’s say you have a
    parent component that has a whole bunch of properties. This might include the
    current route information, application state, and application data. Rather than
    writing out each property, you can take advantage of the spread operator (`...`)
    to pass all the properties. The spread operator takes each key on an object and
    “spreads” them out into individual properties.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将`props`传递到组件中还有一点：假设你有一个包含大量属性的父组件。这可能包括当前路由信息、应用程序状态和应用程序数据。而不是逐个写出每个属性，你可以利用扩展运算符（`...`）来传递所有属性。扩展运算符将对象上的每个键“展开”成单独的属性。
- en: 'Let’s revisit our ListItem component from earlier. Say you have several properties
    to pass in. Using the spread operator, you’ll make each property available on
    `props` for the child component:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下之前提到的ListItem组件。假设你有几个属性需要传递。使用扩展运算符，你将使每个属性在子组件的`props`上可用：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then in the component code, you can access each prop individually:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在组件代码中，你可以单独访问每个属性：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This becomes useful as you build up multiple levels of nested children. The
    root component may need to pass a property to a great-great-great-grandchild.
    Each component can pass all the `props` down as needed to help achieve this. But
    you want to be cautious, because indiscriminately passing all the properties down
    the tree can also lead to unnecessary renders and performance issues.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建多层嵌套子组件时，这变得很有用。根组件可能需要将属性传递给曾孙组件。每个组件都可以根据需要向下传递所有`props`以帮助实现这一点。但你要小心，因为无差别地将所有属性向下传递树也可能导致不必要的渲染和性能问题。
- en: You’ve seen how to use properties in React components; now let’s take a look
    at the functional React component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何在React组件中使用属性；现在让我们看看功能React组件。
- en: 3.4.4\. Functional components
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.4\. 功能组件
- en: 'The simplest React components follow the pure function concept: given a set
    of inputs, the component will return a predictable output (making them easy to
    test). A basic addition function illustrates this concept. Given two integer inputs,
    the `add` function will always return the same value:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的React组件遵循纯函数概念：给定一组输入，组件将返回一个可预测的输出（使它们易于测试）。一个基本的加法函数说明了这个概念。给定两个整数输入，`add`函数将始终返回相同的值：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This Link component needs to be told only how to build the link. You can accomplish
    that via properties. [Figure 3.10](kindle_split_014_split_004.xhtml#ch03fig10)
    shows the Link component rendered inside Storybook.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Link组件只需要被告知如何构建链接。你可以通过属性来实现这一点。[图3.10](kindle_split_014_split_004.xhtml#ch03fig10)显示了在Storybook内部渲染的Link组件。
- en: Figure 3.10\. Link component rendered inside Storybook
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10\. Storybook内部渲染的Link组件
- en: '![](Images/03fig10.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig10.jpg)'
- en: The following listing shows the code that creates the Link component, which
    is a simple functional component that returns a link created with the props passed
    into it. Add this code to the link.jsx file. After you’ve done that, you’ll be
    able to see it, as shown in [figure 3.10](kindle_split_014_split_004.xhtml#ch03fig10).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了创建Link组件的代码，这是一个简单的函数组件，它返回一个使用传入的props创建的链接。将此代码添加到link.jsx文件中。完成此操作后，你将能够看到它，如图[3.10](kindle_split_014_split_004.xhtml#ch03fig10)所示。
- en: Listing 3.6\. Link component—components/Chapter_3_4/link.jsx
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.6\. Link组件—components/Chapter_3_4/link.jsx
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Pure functions can be declared with JavaScript function declaration (ES6
    style used here).**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 纯函数可以使用JavaScript函数声明（此处使用ES6风格）。**'
- en: '***2* Link component returns a component that has no state and doesn’t use
    any React lifecycle methods—given a set of inputs (props), returns predictable
    result.**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Link组件返回一个没有状态且不使用任何React生命周期方法的组件——给定一组输入（props），返回可预测的结果。**'
- en: The approach of building pure functional components has benefits for performance,
    testing (see [chapter 9](kindle_split_021_split_000.xhtml#ch09)), maintainability,
    and developer speed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 构建纯函数组件的方法在性能、测试（见第9章）、可维护性和开发者速度方面都有好处。
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This functional component approach shouldn’t be confused with `PureComponent`,
    introduced in React 15\. `React.PureComponent` gives you some performance boosts
    in specific uses cases but is otherwise just like `React.Component`. More information
    can be found at [https://facebook.github.io/react/docs/react-api.html#react.purecomponent](https://facebook.github.io/react/docs/react-api.html#react.purecomponent).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能组件方法不应与在 React 15 中引入的 `PureComponent` 混淆。`React.PureComponent` 在特定用例中为你提供了一些性能提升，但其他方面与
    `React.Component` 相同。更多信息可以在[https://facebook.github.io/react/docs/react-api.html#react.purecomponent](https://facebook.github.io/react/docs/react-api.html#react.purecomponent)找到。
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Many of your components will be reusable display components. React encourages
    “drying up” your code by breaking it into small, reusable bits. Over time, this
    enables building new, more complex components quickly, because most of the pieces
    are already available.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你的许多组件将是可重用的显示组件。React 鼓励通过将其分解成小块来“干燥”你的代码。随着时间的推移，这可以快速构建新的、更复杂的组件，因为大多数部件已经可用。
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*DRY* is an acronym for *don’t repeat yourself*. React allows you to break
    your user interface into small, repeatable, reusable chunks so you don’t repeat
    yourself.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*DRY* 是 *不要重复自己* 的缩写。React 允许你将用户界面分解成小块，可重复使用，以便你不必重复自己。'
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Given these two concepts, properties and pure functional components, you can
    build a good portion of your application. Eventually, you’ll need to add more
    complexity. In the next section, you’ll build the List component and add conditional
    logic to the ListItem.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这两个概念，属性和纯功能组件，你可以构建你应用程序的大部分内容。最终，你需要添加更多的复杂性。在下一节中，你将构建列表组件，并将条件逻辑添加到列表项中。
- en: 3.4.5\. Conditionals and looping
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.5. 条件和循环
- en: In the previous section, you built a ListItem using foundational React concepts.
    In this section, you’ll add complex JavaScript expressions such as ternaries and
    loops to JSX. You’ll build a List component that uses the ListItem component to
    display several todo items. The List component you’ll build in this section is
    displayed in [figure 3.11](kindle_split_014_split_004.xhtml#ch03fig11).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用基础 React 概念构建了一个列表项。在本节中，你将向 JSX 添加复杂的 JavaScript 表达式，如三元和循环。你将构建一个使用列表项组件来显示多个待办事项的列表组件。本节中构建的列表组件在[图
    3.11](kindle_split_014_split_004.xhtml#ch03fig11)中显示。
- en: Figure 3.11\. The List component renders multiple list items based on the data
    it receives.
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.11. 列表组件根据接收到的数据渲染多个列表项。
- en: '![](Images/03fig11.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig11.jpg)'
- en: First, you’ll use conditionals to display the Complete button only for items
    that aren’t done. Then you’ll use loops to display the list of items.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将使用条件语句只为未完成的项显示完成按钮。然后你将使用循环来显示项目列表。
- en: Conditionals
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件
- en: 'Let’s take the List item you built earlier. Remember, you added two buttons
    to it: a Delete button todo and a Complete button. But in the Todo app, you’re
    going to show these items in different states: Current or Done. You don’t want
    to show the Complete button if the todo item has already been completed (see [figure
    3.12](kindle_split_014_split_004.xhtml#ch03fig12)).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下你之前构建的列表项。记住，你给它添加了两个按钮：一个删除按钮 todo 和一个完成按钮。但在待办事项应用中，你将根据不同的状态显示这些项：当前或完成。如果你已经完成了待办事项，你不想显示完成按钮（参见[图
    3.12](kindle_split_014_split_004.xhtml#ch03fig12)）。
- en: Figure 3.12\. The ListItem component has a property that indicates whether the
    item is done. When it’s done, the Complete button no longer shows.
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.12. 列表项组件有一个属性，表示该项是否完成。当它完成时，完成按钮不再显示。
- en: '![](Images/03fig12_alt.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig12_alt.jpg)'
- en: Instead, you’ll add a check to see whether the List item being rendered has
    previously been completed. [Listing 3.7](kindle_split_014_split_004.xhtml#ch03ex07)
    shows how to add a ternary expression to the code. Add the code shown in bold
    into the listItemFunctional.jsx file. Using a ternary expression, the component
    checks for the done property. If it’s true, it doesn’t render the Complete button
    and instead renders an empty string. If it’s false, it renders the Complete button.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你需要添加一个检查以确定正在渲染的列表项是否之前已经被完成。[列表 3.7](kindle_split_014_split_004.xhtml#ch03ex07)
    展示了如何将三元表达式添加到代码中。将以下加粗的代码添加到 listItemFunctional.jsx 文件中。使用三元表达式，组件检查 done 属性。如果它是
    true，则不会渲染完成按钮，而是渲染一个空字符串。如果它是 false，则渲染完成按钮。
- en: Listing 3.7\. Make button optional—components/Chapter_3_4/listItemFunctional.jsx
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7. 使按钮可选——components/Chapter_3_4/listItemFunctional.jsx
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To test the new property you’ve added, you can add a story with the ListItemFunctional
    component and the `done` property. The next listing shows how to update the story.
    Add this code to the Chapter_3_4.js story. After you’ve added it, you’ll be able
    to see the component without the Complete button, as shown in [figure 3.12](kindle_split_014_split_004.xhtml#ch03fig12).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你添加的新属性，你可以添加一个带有 ListItemFunctional 组件和 `done` 属性的故事。下一个列表显示了如何更新故事。将此代码添加到
    Chapter_3_4.js 的故事中。添加后，你将能够看到没有完成按钮的组件，如图 3.12 所示 [figure 3.12](kindle_split_014_split_004.xhtml#ch03fig12)。
- en: Listing 3.8\. Test the `listItem done` prop—components/stories/chapter_3_4.js
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8\. 测试 `listItem done` 属性—components/stories/chapter_3_4.js
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Add a story with the add() function—pass in a title for the story and
    a function that returns the component you want to render.**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 add() 函数添加一个故事—传递故事的标题和返回你想要渲染的组件的函数。**'
- en: '***2* Add done property—component checks for truthy value here, so you can
    set it to true.**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加 done 属性——组件在这里检查真值，因此你可以将其设置为 true。**'
- en: From a logic standpoint, the change you made to the ListItemFunctional component
    is straightforward. If the todo list item is complete, don’t show the Complete
    button. If it isn’t complete, show the Complete button. But how do you do that
    is in JSX? It doesn’t support `if` statements because it’s just markup.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑角度来看，你对 ListItemFunctional 组件所做的更改很简单。如果 todo 列表项已完成，则不显示完成按钮。如果没有完成，则显示完成按钮。但在
    JSX 中如何实现这一点？它不支持 `if` 语句，因为它只是标记。
- en: For low-complexity conditionals such as showing the Complete button, you can
    use a ternary statement. Remember, anything you put inside the `{}` will execute
    as JavaScript code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像显示完成按钮这样的低复杂度条件，你可以使用三元表达式。记住，你放在 `{}` 中的任何内容都将作为 JavaScript 代码执行。
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `done` property is a Boolean on the todo’s data that’s passed in via `props`.
    If it’s true, it will render nothing, but if it’s false, it’ll show the button
    so the user is able to take the complete action on the todo.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`done` 属性是传递给 `props` 的 todo 数据上的布尔值。如果为真，则不会渲染任何内容，但如果为假，则会显示按钮，以便用户能够对 todo
    执行完成操作。'
- en: Loops
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 循环
- en: Now that you have a todo item, you want to be able to display a list of multiple
    todo items. The List component is a pure component that iterates over an array
    of data that has been provided. It takes each object passed in and renders a child
    ListItem component. This List component is still a functional component because
    it has no state. It’s purely responsible for rendering the items. The following
    listing shows the code you need to add to the list.jsx file in the Chapter_3_4
    folder. Make sure to replace all the placeholder code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个 todo 项，你想要能够显示多个 todo 项的列表。List 组件是一个纯组件，它遍历提供的数据数组。它接收传递的每个对象并渲染一个子
    ListItem 组件。这个 List 组件仍然是一个函数组件，因为它没有状态。它纯粹负责渲染项。以下列表显示了你需要添加到 Chapter_3_4 文件夹中的
    list.jsx 文件中的代码。确保替换所有占位符代码。
- en: Listing 3.9\. List component—components/Chapter_3_4/list.jsx
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9\. 列表组件—components/Chapter_3_4/list.jsx
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Create array to push each child component into.**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个数组以将每个子组件推入。**'
- en: '***2* Data is passed in as an array, loop over each item in array.**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 数据作为数组传递，遍历数组中的每个项。**'
- en: '***3* Push each Item component into the listItems array; pass in all properties
    of item and all props.**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将每个 Item 组件推入 listItems 数组；传递 item 的所有属性和所有 props。**'
- en: As in the previous section, you can handle this looping logic before the JSX
    part of the render. The data that’ll be passed into the List component is shown
    in the following listing. I’ve already included this for you in the stories file
    for this section.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节一样，你可以在 JSX 部分的渲染之前处理这个循环逻辑。将传递给 List 组件的数据显示在以下列表中。我已经为你包含在这个部分的 stories
    文件中。
- en: Listing 3.10\. Todo data—components/stories/chapter_3_4.js
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. Todo 数据—components/stories/chapter_3_4.js
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This data has four todos. Two have already been marked as `done`. In the code
    example for the List component, you can see that given this data array, four list
    items will be created. They’re pushed into an array that JSX is able to render.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据有四个 todo。其中两个已经被标记为 `done`。在 List 组件的代码示例中，你可以看到给定这个数据数组，将创建四个列表项。它们被推入一个
    JSX 能够渲染的数组中。
- en: 'At this point, the List component will work. But you’ll need to add one more
    property to each ListItem to get this component finished. In React, when there
    are several components of the exact same type next to each other, you have to
    add a key value. The key must be unique. You need to modify the way you’re creating
    items:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，列表组件将正常工作。但您需要为每个 ListItem 添加一个额外的属性才能完成此组件。在 React 中，当有多个相邻的相同类型的组件时，您必须添加一个
    key 值。key 必须是唯一的。您需要修改创建项目的方式：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember, this matters because React doesn’t know which item changed in the
    list when updates are made. It knows that the list changed, but without the key
    React will have to re-create the entire list. With the key, React knows which
    items were updated and can do an intelligent update and render.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这很重要，因为 React 在更新时不知道列表中哪个项目发生了变化。它知道列表发生了变化，但没有 key，React 将不得不重新创建整个列表。有了
    key，React 就知道哪些项目被更新了，并且可以进行智能更新和渲染。
- en: If you’d like to see the final code from the last few sections, you can switch
    to the react-components-complete branch (`git checkout react-components-complete`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看最后几节中的最终代码，可以切换到 react-components-complete 分支（`git checkout react-components-complete`）。
- en: '3.5\. Interactive components: React state'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 交互式组件：React 状态
- en: Until now, you’ve made components that display things and components that lay
    out their children. But web apps require interactivity and state. In this section,
    you’ll add interactivity to the Todo app by adding different lists of cards. That
    will also require the app to have some application state. If you want to follow
    along and build the components, you can switch to the react-state branch in the
    GitHub repo (`git checkout react-state`).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了显示内容的组件和布局子组件的组件。但是，Web 应用程序需要交互性和状态。在本节中，您将通过添加不同的卡片列表来为 Todo 应用程序添加交互性。这也要求应用程序具有一些应用程序状态。如果您想跟随并构建组件，可以在
    GitHub 仓库中切换到 react-state 分支（`git checkout react-state`）。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find the files for this section in components/todo and components/stories/todo.js.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此节中找到文件 components/todo 和 components/stories/todo.js。
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To do this, you’ll create the Tab component. This component communicates state
    changes to its parent component via a callback that’s passed in as a property.
    [Figure 3.13](kindle_split_014_split_005.xhtml#ch03fig13) shows the Tab components
    rendered above the list of todos. The app will display three lists: All, Current,
    and Done todos.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您将创建选项卡组件。此组件通过作为属性传递的回调函数将状态更改通知其父组件。[图 3.13](kindle_split_014_split_005.xhtml#ch03fig13)
    显示了渲染在待办事项列表上方的选项卡组件。应用程序将显示三个列表：所有、当前和完成的待办事项。
- en: Figure 3.13\. Adding tabs lets the app display different lists of todo items.
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.13\. 添加选项卡使应用程序能够显示不同的待办事项列表。
- en: '![](Images/03fig13.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig13.jpg)'
- en: 3.5.1\. Using classes
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1\. 使用类
- en: The Tab components are going to be interactive and will need to have methods
    for handling clicks. For components that aren’t pure functional components, React
    provides a class that can be extended. That gives you the benefit of access to
    several built-in React lifecycle methods and the other React component API methods
    such as `setState`. The following listing shows the code for the Tab component,
    which should be added to the tabs.jsx file in the todo folder.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡组件将具有交互性，并且需要处理点击的方法。对于不是纯函数组件的组件，React 提供了一个可以扩展的类。这为您提供了访问几个内置的 React 生命周期方法和其他
    React 组件 API 方法，例如 `setState` 的好处。以下列表显示了选项卡组件的代码，该代码应添加到 todo 文件夹中的 tabs.jsx
    文件中。
- en: Listing 3.11\. Tab component complete—components/todo/tabs.jsx
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. 选项卡组件完成—components/todo/tabs.jsx
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* npm package lets you build complex class strings.**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* npm 包允许您构建复杂的类字符串。**'
- en: '***2* Constructor method runs each time a component class instance is created.**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 构造函数方法在每次创建组件类实例时运行。**'
- en: '***3* Call super and pass along params (props)—must be first thing that happens
    in constructor.**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用 super 并传递参数（props）—必须在构造函数中首先发生。**'
- en: '***4* Click handler method notifies app of change in active tab.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 点击处理方法通知应用程序活动选项卡的变化。**'
- en: '***5* Render method runs on each render, equivalent to functions created earlier
    for pure components.**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 渲染方法在每次渲染时运行，相当于之前为纯组件创建的函数。**'
- en: As you can see, the npm package lets you build complex class strings. In this
    case, you want to add an active class if the active prop is true. `classnames`
    reads the object and list of strings passed in and returns a correctly spaced
    string. This is rendered into the `className` prop.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，npm 包允许您构建复杂的类字符串。在这种情况下，如果您想要添加一个活动类，则活动属性必须为 true。`classnames` 读取传入的对象和字符串列表，并返回一个正确间隔的字符串。这个字符串被渲染到
    `className` 属性中。
- en: 'Writing a React class is different from functional components. Using ES6 JavaScript
    classes, you extend the React base class to make a new component:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 React 类与编写函数组件不同。使用 ES6 JavaScript 类，您扩展 React 基类以创建一个新的组件：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then you can add the `constructor()` and `render()` methods. The constructor
    runs when the class instance is created. The render method is just like the functional
    methods you wrote to make the List and ListItem components. It returns the JSX
    of the component.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以添加 `constructor()` 和 `render()` 方法。构造函数在类实例创建时运行。渲染方法就像您编写的用于创建 List 和
    ListItem 组件的函数式方法一样。它返回组件的 JSX。
- en: You can add any additional class functions or React lifecycle functions you
    might need. The Tab component adds a click handler called `handleClick`, which
    calls the action’s callback with the index of the current tab.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加您可能需要的任何额外的类函数或 React 生命周期函数。Tab 组件添加了一个名为 `handleClick` 的点击处理程序，该处理程序使用当前选项卡的索引调用动作的回调。
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The actions object holds Redux actions. For now, the implementation of these
    actions will be in your root component rather than Redux. In [chapter 6](kindle_split_017_split_000.xhtml#ch06),
    I’ll show you how to connect to Redux actions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 动作对象包含 Redux 动作。目前，这些动作的实现将在您的根组件中而不是 Redux 中。在 [第 6 章](kindle_split_017_split_000.xhtml#ch06)
    中，我将向您展示如何连接到 Redux 动作。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To make the click handler function work, you need to add an event listener
    to the tab by adding an `onClick` attribute to the tab `div`. React handles all
    the underlying bindings and cleanup for you. Most events can be attached this
    way:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要使点击处理函数正常工作，您需要通过向标签 `div` 添加 `onClick` 属性来向标签添加事件监听器。React 会为您处理所有底层的绑定和清理。大多数事件都可以这样附加：
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding event listeners in React with classes has a gotcha. In ES6 classes, class
    functions aren’t automatically bound to the `this` context. If you’ve been working
    with JavaScript for a while, this can be confusing at first, because in the prototype
    structure each function on a prototype is bound to the `this` context. In the
    ES6 class structure, each function ends up with the context of the caller (as
    opposed to the parent class).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中使用类添加事件监听器有一个陷阱。在 ES6 类中，类函数不是自动绑定到 `this` 上下文。如果您已经使用 JavaScript 了一段时间，这可能会让您一开始感到困惑，因为在原型结构中，原型上的每个函数都绑定到
    `this` 上下文。在 ES6 类结构中，每个函数最终都会带有调用者的上下文（与父类相反）。
- en: 'When working with event listeners, an event listener’s `this` context will
    be the event itself by default, rather than the class. Fixing this requires forcing
    the event listener to be bound to context of the class. You’ll do this in the
    class `constructor` method:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理事件监听器时，默认情况下，事件监听器的 `this` 上下文将是事件本身，而不是类。修复这个问题需要强制将事件监听器绑定到类的上下文中。您将在类的
    `constructor` 方法中这样做：
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After you’ve added the `bind` call to the constructor, the `this` context of
    your event handler will be the class, allowing you to call `this.props` or `this.state`.
    So the final Tab component will have a constructor, render, and click handler.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在您向构造函数添加 `bind` 调用之后，您的事件处理器的 `this` 上下文将是类，这使得您可以调用 `this.props` 或 `this.state`。因此，最终的
    Tab 组件将有一个构造函数、渲染和点击处理程序。
- en: 3.5.2\. React state
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. React 状态
- en: So far, we’ve discussed components written as pure functions and stateless class-based
    components. React can also handle state inside components. Sometimes this might
    be application state. More often, this state ends up being user-interaction state.
    For example, is a modal hidden or displayed?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了作为纯函数编写的组件和无状态基于类的组件。React 也可以在组件内部处理状态。有时这可能是指应用程序状态。更常见的是，这种状态最终会成为用户交互状态。例如，模态是隐藏还是显示？
- en: In the Todo app, the root component will manage the state. In later chapters,
    you’ll use Redux to manage the application state. The following listing shows
    you the code for the todo root component, which you add to todo.jsx.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Todo 应用中，根组件将管理状态。在后面的章节中，您将使用 Redux 来管理应用程序状态。以下列表显示了 todo 根组件的代码，您将其添加到
    todo.jsx 中。
- en: Listing 3.12\. Todo component—components/todo/todo.jsx
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12\. Todo 组件—components/todo/todo.jsx
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Method provides current list of todos to show based on the activeTab
    property.**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 方法提供基于 activeTab 属性显示的当前待办事项列表。**'
- en: '***2* Set updateTabView method as an action.**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 updateTabView 方法设置为操作。**'
- en: '***3* Pass in actions to the Tabs component so each tab can call back to this
    root component to update the state.**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将操作传递给 Tabs 组件，以便每个标签可以回调到这个根组件以更新状态。**'
- en: '***4* Pass in the calculated list of todos to List component.**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将计算出的待办事项列表传递给 List 组件。**'
- en: 'Each React class component has a state object that’s accessible at `this.state`.
    You need to initialize this state object in the constructor:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 React 类组件都有一个状态对象，该对象在 `this.state` 中可访问。你需要在构造函数中初始化这个状态对象：
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After you’ve initialized the state in the constructor, state becomes *read-only*.
    React provides another method called `setState` for state updates (writes). If
    you want to update the `tab` value, you call `setState`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中初始化状态后，状态变为**只读**。React 提供了另一个名为 `setState` 的方法用于状态更新（写入）。如果你想更新 `tab`
    值，你调用 `setState`：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An important note about `setState`: it’s *asynchronous*. The good news is,
    if you need to run code after you’re sure that the state update has completed,
    you can use the hook that React provides:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `setState` 的重要说明：它是**异步的**。好消息是，如果你在确保状态更新完成后需要运行代码，你可以使用 React 提供的钩子：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You’ve now built most of the Todo app! You’ve also learned how to use all of
    React’s core concepts:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经构建了大多数的 Todo 应用程序！你还学习了如何使用 React 的所有核心概念：
- en: Creating components with JSX
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSX 创建组件
- en: Pure components
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯组件
- en: Properties
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Class components
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类组件
- en: State
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: If you want to view the complete code presented in this chapter, check out the
    master branch. In the next chapter, you’ll learn about React’s component lifecycle
    and the hook functions available to handle more complex logic cases.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章中展示的完整代码，请查看 master 分支。在下一章中，你将学习关于 React 组件生命周期和可用于处理更复杂逻辑案例的钩子函数。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned how to get up and running with React. You walked
    through key pieces of the Todo app built with React. We covered all the React
    basics you need to understand before building an isomorphic app:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 React 开始构建。你了解了使用 React 构建的 Todo 应用程序的关键部分。我们涵盖了在构建同构应用程序之前你需要了解的所有
    React 基础知识：
- en: React uses a declarative style mixed with functional concepts to provide a simple
    view interface.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 使用声明式风格结合函数式概念来提供一个简单的视图接口。
- en: The virtual DOM powers React’s ability to intelligently and quickly make updates.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟 DOM 为 React 提供了智能且快速进行更新的能力。
- en: JSX is React’s declarative template language. It uses an HTML-like syntax with
    the ability to execute JavaScript.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 是 React 的声明式模板语言。它使用类似 HTML 的语法，并具有执行 JavaScript 的能力。
- en: React relies on `props` for communication between components.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 依赖于 `props` 在组件之间进行通信。
- en: State is discouraged in React, but when needed it’s a powerful tool for handling
    user interactions and managing application state.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中，状态是不推荐的，但在需要时，它是处理用户交互和管理应用程序状态的一个强大工具。
- en: Chapter 4\. Applying React
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章\. 应用 React
- en: '*This chapter covers*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Configuring React Router for the browser
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为浏览器配置 React Router
- en: Rendering the route contents in a consistent way by using `props.children`
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `props.children` 以一致的方式渲染路由内容
- en: Building reusable components
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用组件
- en: Using higher-order components to abstract common business logic
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶组件来抽象常见的业务逻辑
- en: Taking advantage of the React component lifecycle
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 React 组件生命周期
- en: In [chapter 3](kindle_split_014_split_000.xhtml#ch03), you learned the basics
    of building views with React. Now you’ll build on those skills by exploring more-advanced
    concepts with React. This chapter will teach you what you need to know in order
    to build a production app with React.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第三章](kindle_split_014_split_000.xhtml#ch03) 中，你学习了使用 React 构建视图的基础知识。现在，你将通过使用
    React 探索更多高级概念来在此基础上构建技能。本章将教你构建生产级应用程序所需了解的内容。
- en: You’ll be working with the All Things Westies app described in [chapter 1](kindle_split_011_split_000.xhtml#ch01).
    This is the first of many chapters in which you’ll be building this app. The code
    can be found at [https://github.com/isomorphic-dev-js/complete-isomorphic-example.git](https://github.com/isomorphic-dev-js/complete-isomorphic-example.git).
    To start, you should be on branch chapter-4.1.1 (`git checkout chapter-4.1.1`).
    The master branch for this repo contains the complete code from all the chapters
    in the book.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用 [第 1 章](kindle_split_011_split_000.xhtml#ch01) 中描述的 All Things Westies
    应用程序进行工作。这是您将构建的许多章节中的第一个。代码可以在 [https://github.com/isomorphic-dev-js/complete-isomorphic-example.git](https://github.com/isomorphic-dev-js/complete-isomorphic-example.git)
    找到。为了开始，您应该在 branch chapter-4.1.1 (`git checkout chapter-4.1.1`) 上。此存储库的 master
    分支包含书中所有章节的完整代码。
- en: 'To run the app for this chapter, use these commands:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章的应用程序，请使用以下命令：
- en: '[PRE37]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the server is running, the app in this chapter will be loaded from http://localhost:3000/
    (although there’s nothing to see on the chapter-4.1.1 branch). It’s not isomorphic
    because I want you to stay focused on the React concepts. As you build out this
    app in [chapters 7](kindle_split_019_split_000.xhtml#ch07) and [8](kindle_split_020_split_000.xhtml#ch08),
    you’ll turn the app into an isomorphic app.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器运行时，本章中的应用程序将从 http://localhost:3000/ 加载（尽管在 chapter-4.1.1 分支上什么也看不到）。它不是同构的，因为我希望您能专注于
    React 概念。当您在 [第 7 章](kindle_split_019_split_000.xhtml#ch07) 和 [第 8 章](kindle_split_020_split_000.xhtml#ch08)
    中构建此应用程序时，您将使应用程序成为同构应用程序。
- en: The app is shown in [figure 4.1](kindle_split_015_split_000.xhtml#ch04fig01).
    I’ve called out the component parts that need to be added to make this work.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在 [图 4.1](kindle_split_015_split_000.xhtml#ch04fig01) 中显示。我指出了需要添加以使此功能正常工作的组件部分。
- en: Figure 4.1\. The All Things Westies sample app that you’ll begin building in
    this chapter. You’ll build out the various parts of this app in later chapters.
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1. 您将在本章中开始构建的 All Things Westies 示例应用程序。您将在后面的章节中构建此应用程序的各个部分。
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig01_alt.jpg)'
- en: 'There are three main routes (and a home route, /): /products, /cart, and /profile.
    In the next section, you’ll set up the routing.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要路由（以及一个主页路由，/）：/products、/cart 和 /profile。在下一节中，您将设置路由。
- en: 4.1\. React Router
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. React Router
- en: To build a web application, you usually need a router. *Routers* provide a mapping
    between the URL-based route and the view that the route should load. Because React
    is the view library, it doesn’t handle application routing on its own. That’s
    where React Router comes into play.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个 Web 应用程序，通常需要一个路由器。*路由器*提供基于 URL 的路由与应加载的视图之间的映射。因为 React 是视图库，它本身不处理应用程序的路由。这就是
    React Router 发挥作用的地方。
- en: React Router has become the community choice for routing in React apps. It even
    has support for server-side routing, making it a great choice for isomorphic apps
    (covered in [chapter 7](kindle_split_019_split_000.xhtml#ch07)). React Router
    makes creating your routes straightforward because it uses JSX to let you declare
    routes. React Router is a React component that handles your routing logic.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 已成为 React 应用中路由选择的社区首选。它甚至支持服务器端路由，使其成为同构应用的绝佳选择（在第 7 章中介绍）。React
    Router 通过使用 JSX 让您声明路由，使得创建您的路由变得简单。React Router 是一个处理您路由逻辑的 React 组件。
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**React Router versions**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Router 版本**'
- en: This app and the rest of the book use React Router 3 (v3.0.5). Since I started
    writing this book, a newer version (v4) has come out. The latest version is a
    complete rewrite of the way React Router works. It’s more in line with how React
    works, but it requires a new way of thinking about how the router interacts with
    an isomorphic app.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序和本书的其余部分使用 React Router 3（v3.0.5）。自从我开始写这本书以来，已经推出了一个新版本（v4）。最新版本是对 React
    Router 工作方式的完全重写。它与 React 的工作方式更一致，但它需要以新的方式思考路由如何与同构应用程序交互。
- en: I’ve provided a version of the app with explanation in three appendices (A–C).
    You’ll find examples related to this chapter in [appendix A](kindle_split_027_split_000.xhtml#app01).
    I explain how to get started with React Router 4 and the major changes with the
    removal of the React Router lifecycle.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我提供了带有三个附录（A–C）中解释的应用程序版本。您将在附录 A 中找到与本章节相关的示例。我解释了如何开始使用 React Router 4 以及移除
    React Router 生命周期后的主要变化。
- en: The good news is the React Router team has committed to supporting v3 for the
    indefinite future (because of the breaking nature of v4). But I do recommend you
    explore v4 if you’re starting a new project.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是 React Router 团队已经承诺无限期地支持 v3（因为 v4 的破坏性）。但我确实建议如果你开始一个新项目，你可以探索 v4。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.1.1\. Setting up an app with React Router
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 使用 React Router 设置应用程序
- en: React Router uses components to introduce routing into your app and to define
    the child routes. Before you initiate the app with the router, you must first
    define a set of routes that’ll be used. You’ll set them up in a sharedRoutes.jsx
    file.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 使用组件将路由引入你的应用程序，并定义子路由。在你使用路由器启动应用程序之前，你必须首先定义一组将要使用的路由。你将在 sharedRoutes.jsx
    文件中设置它们。
- en: In this first section, you’ll add the App component with the router. This will
    let you easily support the server-rendering use case you’ll build later in the
    book. The following listing shows you the code to add to sharedRoutes.jsx. Remember,
    if you want to follow along, you should be on branch chapter-4.1.1.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，你将添加带有路由器的 App 组件。这将使你能够轻松支持书中稍后构建的服务器端渲染用例。以下列表显示了要添加到 sharedRoutes.jsx
    中的代码。记住，如果你想跟上进度，你应该在 chapter-4.1.1 分支上。
- en: Listing 4.1\. App routes—src/shared/sharedRoutes.jsx
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 应用程序路由——src/shared/sharedRoutes.jsx
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Include React because React Router uses React components to implement
    the router.**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 React，因为 React Router 使用 React 组件来实现路由器。**'
- en: '***2* Require the Route component from React Router.**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 React Router 中引入 Route 组件。**'
- en: '***3* Include root component: app.jsx.**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含根组件：app.jsx。**'
- en: '***4* Create the route object with JSX syntax.**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 JSX 语法创建路由对象。**'
- en: '***5* Route component requires two properties, the path to this route and the
    component that’s displayed. This results in the root route returning App as its
    component.**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 路由组件需要两个属性，即此路由的路径和要显示的组件。这导致根路由返回 App 作为其组件。**'
- en: I’ve provided the skeleton of the App component for you so you don’t need to
    add this code. The following listing shows the App component.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为你提供了 App 组件的框架，所以你不需要添加此代码。以下列表显示了 App 组件。
- en: Listing 4.2\. App component—src/components/app.jsx
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. App 组件——src/components/app.jsx
- en: '[PRE39]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Title of app**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 应用程序标题**'
- en: '***2* Root navigation links—each will be added to the sharedRoutes file in
    the next section.**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根导航链接——每个都将在下一节中添加到 sharedRoutes 文件中。**'
- en: '***3* Each route’s contents will render here—for now, there is placeholder
    text.**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个路由的内容将在这里渲染——目前，这里只有占位文本。**'
- en: Next, you’ll set up your app to use React Router. The following listing shows
    you how to set up the main.jsx file.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将设置你的应用程序以使用 React Router。以下列表显示了如何设置 main.jsx 文件。
- en: Listing 4.3\. Render the app with React Router—src/main.jsx
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 使用 React Router 渲染应用程序——src/main.jsx
- en: '[PRE40]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Include your React and ReactDOM dependencies.**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含你的 React 和 ReactDOM 依赖项。**'
- en: '***2* Include the Router component and the browserHistory module from React
    Router.**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含 Router 组件和 browserHistory 模块来自 React Router。**'
- en: '***3* Include the sharedRoutes file you created.**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含你创建的 sharedRoutes 文件。**'
- en: '***4* Render the React app into the DOM by declaring the Router component as
    your root component.**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通过声明 Router 组件作为你的根组件，将 React 应用程序渲染到 DOM 中。**'
- en: '***5* Router takes in the routes you included from sharedRoutes.**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* Router 接收你从 sharedRoutes 中包含的路由。**'
- en: '***6* Router component needs to know which implementation of history it should
    use—here use browser history module so the app can use the built-in browser history
    API.**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 路由组件需要知道它应该使用哪种历史实现——在这里使用 browser history 模块，以便应用程序可以使用内置的浏览器历史 API。**'
- en: Instead of rendering a root component into the DOM, React Router ends up being
    your root component. Another way to think of it is as the top component in your
    component tree (see [figure 4.2](kindle_split_015_split_001.xhtml#ch04fig02)).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 与将根组件渲染到 DOM 中不同，React Router 最终成为你的根组件。另一种思考方式是将其视为组件树中的顶级组件（见[图 4.2](kindle_split_015_split_001.xhtml#ch04fig02)）。
- en: Figure 4.2\. Example component tree with React Router as the root element
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 带有 React Router 作为根元素的示例组件树
- en: '![](Images/04fig02_alt.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig02_alt.jpg)'
- en: Under the hood, the router is using the browser history object. It hooks into
    this object to use push state and other browser-routing APIs.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，路由器正在使用浏览器历史对象。它挂钩到这个对象以使用 push 状态和其他浏览器路由 API。
- en: Additionally, React Router allows you to pass in this history object. That way,
    it doesn’t make any assumptions about which environment it runs in. On the browser,
    you pass in a different history object than on the server. That’s part of what
    makes React Router good for isomorphic apps. Passing in the history object is
    also a more testable pattern.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React Router 允许你传入这个历史对象。这样，它不会对它运行的环境做出任何假设。在浏览器上，你传入一个与服务器上不同的历史对象。这就是
    React Router 适合同构应用程序的部分原因。传入历史对象也是一种更可测试的模式。
- en: 4.1.2\. Adding child routes
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 添加子路由
- en: 'To make the rest of the app work, add the child routes the user will use to
    navigate between the views in the app. This requires two additional steps: creating
    child routes and setting up app.jsx to render any child. The following listing
    shows how to add the new routes to the sharedRoutes file. If you want to follow
    along, the base code for this section is in branch chapter-4.1.2 (`git checkout
    chapter-4.1.2`).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序的其余部分正常工作，添加用户将用于在应用程序中的视图之间导航的子路由。这需要两个额外的步骤：创建子路由并设置 app.jsx 以渲染任何子路由。以下列表显示了如何将新路由添加到
    sharedRoutes 文件中。如果你想跟随，本节的基代码位于分支 chapter-4.1.2（`git checkout chapter-4.1.2`）。
- en: Listing 4.4\. Adding child routes—src/shared/sharedRoutes.jsx
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 添加子路由—src/shared/sharedRoutes.jsx
- en: '[PRE41]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Include the component for each route.**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含每个路由的组件。**'
- en: '***2* Create child routes by nesting them inside the App route.**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过在 App 路由内部嵌套来创建子路由。**'
- en: Each of the child routes will be combined with App. React Router will know the
    appropriate child component that should be made available to App to be rendered.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子路由都将与 App 结合。React Router 将知道应该提供给 App 以供渲染的适当子组件。
- en: 'React: rendering any children'
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: React：渲染任何子组件
- en: The next step in getting the child routes working is to set up the App component
    to display any arbitrary child. The App component doesn’t need to know which child
    it’s rendering—only that it needs to render a child. You decouple the implementation
    of the child and parent. This creates a reusable pattern in which the same child
    can be used in multiple views, or vice versa. [Figure 4.3](kindle_split_015_split_001.xhtml#ch04fig03)
    shows the React Router and child route relationship.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让子路由工作起来的下一步是设置 App 组件以显示任何任意子组件。App 组件不需要知道它正在渲染哪个子组件——只需要知道它需要渲染一个子组件。你解耦了子组件和父组件的实现。这创建了一个可重用模式，其中相同的子组件可以在多个视图中使用，反之亦然。[图
    4.3](kindle_split_015_split_001.xhtml#ch04fig03) 显示了 React Router 和子路由的关系。
- en: Figure 4.3\. Using `props.children` to render components at runtime
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 使用 `props.children` 在运行时渲染组件
- en: '![](Images/04fig03.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03.jpg)'
- en: 'You can pass in children by nesting React components:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过嵌套 React 组件来传入子组件：
- en: '[PRE42]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then inside the `render` function of `MyComponent` you reference the child
    on the `props` object:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `MyComponent` 的 `render` 函数中，你引用了 `props` 对象上的子元素：
- en: '[PRE43]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: React Router handles passing down the children component by assigning props
    via JavaScript and using the lower-level React APIs such as `createElement`. You
    don’t need to worry about this, but if you’re interested in exploring further,
    check out [https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#routercontext](https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#routercontext).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 通过 JavaScript 分配属性和使用低级 React API（如 `createElement`）来处理向下传递子组件。你不需要担心这一点，但如果你想进一步探索，请查看[https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#routercontext](https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#routercontext)。
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This pattern allows the child component to be determined dynamically at runtime.
    The following listing shows how to update the App component to do this. Add the
    code from the listing to the app.jsx component code that already exists.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许在运行时动态确定子组件。以下列表显示了如何更新 App 组件来完成此操作。将列表中的代码添加到已存在的 app.jsx 组件代码中。
- en: Listing 4.5\. Rendering any child—src/components/app.jsx
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 渲染任何子组件—src/components/app.jsx
- en: '[PRE44]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* App component renders the children property**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* App 组件渲染子属性**'
- en: '***2* Setting propTypes on the component**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在组件上设置 propTypes**'
- en: '***3* Prop children is a React element—the propTypes object describes this
    information.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Prop children 是一个 React 元素——propTypes 对象描述了这些信息。**'
- en: Setting `propTypes` on components provides documentation and is considered best
    practice. It’s an object that describes the expected properties, including whether
    they’re required.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件上设置 `propTypes` 提供了文档，并被认为是最佳实践。它是一个对象，描述了预期的属性，包括它们是否是必需的。
- en: Router properties
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路由属性
- en: 'Because the Router wraps the App component, it passes down several router objects
    as `props`. Many of these objects are required in child components, but I’ll focus
    on three:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Router 包装了 App 组件，所以它将几个路由对象作为 `props` 传递下来。许多这些对象在子组件中是必需的，但我会专注于三个：
- en: '**`location`—** This mirrors the `window.location` object, built from the history
    you passed in to the router. It contains properties such as query and pathname
    that you can use in components.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`location`—** 它反映了 `window.location` 对象，由传递给路由的历史数据构建而成。它包含了一些属性，如查询和路径名，你可以在组件中使用这些属性。'
- en: '**`params`—** This object contains all the dynamic parameters on the route.
    If you had a route such as /products/treats that matched a route such as /products/
    :category, this object would contain a property called category: `{ category:
    treats }`.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`params`—** 这个对象包含了路由上的所有动态参数。如果你有一个匹配 `/products/treats` 路由的 `/products/:category`
    路由，这个对象将包含一个名为 category 的属性：`{ category: treats }`。'
- en: '**`router`—** This object contains many methods for interacting with the router
    and history, including lower-level APIs. Most commonly, I find the need to use
    the `push()` method to navigate around an app from JavaScript.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`router`—** 这个对象包含了许多与路由和历史交互的方法，包括低级 API。最常见的情况是，我需要使用 `push()` 方法从 JavaScript
    中导航到应用的不同部分。'
- en: In the next section, you’ll use the Link component, which takes advantage of
    the lower-level router and history APIs so you don’t have to.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将使用 Link 组件，该组件利用了低级路由和历史 API，因此你无需自己操作。
- en: '4.1.3\. Routing from components: Link'
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3\. 从组件中进行路由：Link
- en: React Router goes one step further and provides a React component for you to
    use when you want to trigger navigation. That way, you don’t need to worry about
    what’s going on under the hood.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 更进一步，提供了一个 React 组件，当你想要触发导航时可以使用。这样，你就不必担心底层发生了什么。
- en: The Link component renders an `<a>` tag. To use the Link component, you include
    it in your component and then render it with the properties it needs. If you want
    to follow along with this section and get the code so far, switch to the branch
    called chapter-4.1.3 (`git checkout chapter-4.1.3`). The following listing shows
    you how to update the header to use the Link component instead of standard links
    in app.jsx.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Link 组件渲染一个 `<a>` 标签。要使用 Link 组件，你需要在你的组件中包含它，然后使用它需要的属性来渲染它。如果你想跟随本节内容并获取到目前为止的代码，请切换到名为
    chapter-4.1.3 的分支（`git checkout chapter-4.1.3`）。以下列表展示了如何更新头部以使用 Link 组件而不是 app.jsx
    中的标准链接。
- en: Listing 4.6\. Using the Link component—src/components/app.jsx
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. 使用 Link 组件—src/components/app.jsx
- en: '[PRE45]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Include the Link component from React Router**'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 React Router 中包含 Link 组件**'
- en: '***2* Convert <a> tags to <Link> tags**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 `<a>` 标签转换为 `<Link>` 标签**'
- en: Note that instead of an `href` property, the Link component requires a `to`
    property. After adding the Link components, your app will properly route between
    views.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `href` 属性不同，Link 组件需要一个 `to` 属性。添加 Link 组件后，你的应用程序将能够在视图之间正确路由。
- en: 'The React Router library has one more important part that you’ll want to know
    about for building production apps: how to hook into the router lifecycle.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 库还有一个重要的部分，你可能需要了解它是如何构建生产应用程序的：如何钩入路由生命周期。
- en: 4.1.4\. Understanding the router lifecycle
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 理解路由生命周期
- en: React Router provides hooks into its lifecycle to allow you to add logic between
    routes. A common use case for lifecycle hooks is adding page-view tracking analytics
    to your application so you know how many views each route gets.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 提供了生命周期钩子，允许你在路由之间添加逻辑。生命周期钩子的一个常见用例是为你的应用程序添加页面视图跟踪分析，以便你知道每个路由有多少次查看。
- en: '|  |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix A](kindle_split_027_split_000.xhtml#app01)
    to see how to move this code into the React lifecycle and how to handle the concepts
    discussed in this section.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 React Router 4，请查看附录 A（kindle_split_027_split_000.xhtml#app01），了解如何将此代码移动到
    React 生命周期中，以及如何处理本节讨论的概念。
- en: '|  |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Imagine if you tried to add this logic into your components. You’d end up with
    the tracking logic in every top-level component (Cart, Products, Profile). Or
    you’d end up trying to detect changes based on properties in the App component.
    Both methods are undesirable and leave a lot of room for error.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你尝试将此逻辑添加到你的组件中。你最终会在每个顶级组件（购物车、产品、个人资料）中添加跟踪逻辑。或者你可能会尝试基于 App 组件中的属性来检测变化。这两种方法都不理想，并且留下了很多错误的空间。
- en: Instead, you want to use the `onChange` and `onEnter` lifecycle events for React
    Router. (A third lifecycle hook, `onLeave`, isn’t covered here.) [Figure 4.4](kindle_split_015_split_001.xhtml#ch04fig04)
    shows the order in which these handlers fire.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你想要使用 `onChange` 和 `onEnter` 生命周期事件来处理 React Router。（第三个生命周期钩子 `onLeave`
    在这里没有涉及。）图 4.4 显示了这些处理器触发的顺序。
- en: Figure 4.4\. The `onEnter` handler fires only once for the root route, but the
    `onChange` handler fires on every subsequent route change.
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 根路由的 `onEnter` 处理器只触发一次，但 `onChange` 处理器在每次后续路由变化时都会触发。
- en: '![](Images/04fig04_alt.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig04_alt.jpg)'
- en: For each route, `onEnter` is fired when the app goes to the route from a different
    route. Because / is the root route, it can be entered only once. The `onChange`
    handler is fired each time a child route changes. For the root route, this happens
    on each route action after the first. The following listing shows how to implement
    these handlers in the sharedRoutes.jsx file. If you’re following along and want
    to see the code from the previous sections, you can find it on branch chapter-4.1.4
    (`git checkout chapter-4.1.4`).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个路由，当应用从一个不同的路由跳转到该路由时，会触发 `onEnter` 事件。因为 `/` 是根路由，它只能进入一次。每次子路由发生变化时，都会触发
    `onChange` 处理器。对于根路由，这发生在第一次路由动作之后的每个路由动作。下面的列表显示了如何在 sharedRoutes.jsx 文件中实现这些处理器。如果你正在跟随，并想查看前几节中的代码，你可以在
    branch chapter-4.1.4 (`git checkout chapter-4.1.4`) 上找到它。
- en: Listing 4.7\. Using `onChange` in the router—src/shared/searchRoutes.jsx
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 在路由器中使用 `onChange`—src/shared/searchRoutes.jsx
- en: '[PRE46]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Reusable function for tracking page views (in the real world, you’d call
    your analytics tool)**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于跟踪页面视图的可重用函数（在现实世界中，你会调用你的分析工具）**'
- en: '***2* Handler for onEnter—logs OnEnter**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `onEnter` 处理器的处理器—记录 OnEnter**'
- en: '***3* Handler for onChange—logs OnChange**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `onChange` 处理器的处理器—记录 OnChange**'
- en: '***4* Each Route can have an onEnter and/or onChange property.**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 每个路由都可以有一个 `onEnter` 和/或 `onChange` 属性。**'
- en: Next, you’ll explore React’s component lifecycle, which is a completely different
    set of lifecycle functions specific to React. The lifecycle functions give you
    greater control over when things happen in your app.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将探索 React 的组件生命周期，这是一个完全不同的、特定于 React 的生命周期函数集。生命周期函数让你能够更好地控制应用中事件发生的时间。
- en: 4.2\. Component lifecycle
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 组件生命周期
- en: A site that has user accounts requires a login. Certain parts of the site will
    always be locked down so you can view them only if you’re logged in. For example,
    with the All Things Westies app, users who want to view their settings page to
    update their password or view past orders will need to log in.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 一个拥有用户账户的网站需要登录。网站的某些部分始终会被锁定，只有登录后才能查看。例如，在 All Things Westies 应用中，想要查看设置页面以更新密码或查看过去订单的用户需要登录。
- en: This use case is the opposite of the analytics use case in the preceding section.
    Instead of doing something on every route, you want to check for logged-in status
    only on certain routes. You could do that on the routes, if you’d like, with `onChange`
    or `onEnter` handlers. But you can also put this logic inside the appropriate
    React component. For this example, we’ll use the component lifecycle.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例与上一节中的分析用例相反。你不想在每次路由上执行某些操作，而只想在特定路由上检查登录状态。如果你愿意，你可以在路由上使用 `onChange`
    或 `onEnter` 处理器来做这件事。但你也可以将这个逻辑放在适当的 React 组件中。在这个例子中，我们将使用组件生命周期。
- en: 'React provides several hooks into the lifecycle of components. The render function,
    which you’ve already used, is part of this lifecycle. The lifecycle of a component
    can be broken into three parts (illustrated in [figure 4.5](kindle_split_015_split_002.xhtml#ch04fig05)):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了几个钩子，用于组件的生命周期。你已经使用过的渲染函数就是生命周期的一部分。组件的生命周期可以分为三个部分（如图 4.5 所示）：
- en: '***Mounting events*—** Happen when a React element (instance of a component
    class) is attached to a DOM node. This is where you’d handle the check for being
    logged in.'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***挂载事件*—** 发生在 React 元素（组件类的实例）附加到 DOM 节点时。这是你处理登录检查的地方。'
- en: '***Updating events*—** Happen when React element is updating either as a result
    of new values of its properties or state. If you had a timer in your component,
    you’d manage it in these functions.'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***更新事件*—** 发生在 React 元素更新时，无论是由于其属性或状态的新值引起的。如果你在组件中有一个计时器，你会在这些函数中管理它。'
- en: '***Unmounting events*—** Happen when React element is detached from the DOM.
    If you had a timer in your component, you’d clean it up here.^([[1](kindle_split_015_split_002.xhtml#ch04fn1)])'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***卸载事件*——** 当React元素从DOM中分离时发生。如果你在组件中有一个计时器，你将在这里清理它.^([[1](kindle_split_015_split_002.xhtml#ch04fn1)])'
- en: ¹
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: React lifecycle list and illustration concept are from Azat Mardan’s *React
    Quickly* (Manning, 2017, [https://www.manning.com/books/react-quickly](https://www.manning.com/books/react-quickly)).
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: React生命周期列表和插图概念来自Azat Mardan的《React Quickly》（Manning，2017，[https://www.manning.com/books/react-quickly](https://www.manning.com/books/react-quickly)）。
- en: Figure 4.5\. The React lifecycle consists of three types of lifecycle events.
    Each has corresponding method hooks.
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5。React生命周期包括三种类型的生命周期事件。每种类型都有对应的方法钩子。
- en: '![](Images/04fig05_alt.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig05_alt.jpg)'
- en: 4.2.1\. Hooking into mounting and updating to detect user’s logged-in status
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 利用挂载和更新来检测用户的登录状态
- en: To detect whether the user is logged in, you’ll take advantage of one of the
    React lifecycle functions. This function is fired before the component has *mounted*
    (been attached to the DOM). [Listing 4.8](kindle_split_015_split_002.xhtml#ch04ex08)
    shows how to add the check to the user profile component inside `componentWillMount`.
    There’s a placeholder for Profile, and you’ll want to update it with this code.
    If you’re following along and want to check out the code from the previous sections,
    switch to branch chapter 4.2.1 (`git checkout chapter-4.2.1`).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测用户是否已登录，你将利用React的一个生命周期函数。这个函数在组件挂载（附加到DOM）之前触发。[列表4.8](kindle_split_015_split_002.xhtml#ch04ex08)展示了如何在`componentWillMount`中添加检查到用户配置文件组件中。有一个用于Profile的占位符，你将想要用此代码更新它。如果你正在跟随并想查看前几节中的代码，切换到分支4.2.1（`git
    checkout chapter-4.2.1`）。
- en: Listing 4.8\. Using lifecycle events—src/components/profile.jsx
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8。使用生命周期事件——src/components/profile.jsx
- en: '[PRE47]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Check for a user property—if it doesn’t exist, assume the user needs
    to log in.**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 检查用户属性——如果不存在，假设用户需要登录。**'
- en: '***2* Force user to route to log in using the router object.**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 强制用户使用路由对象路由到登录页面。**'
- en: 'In profile.jsx, you added a reference to the router prop. But if you run the
    code now and load the /profile route, the app will throw an error because you
    haven’t passed in the router object. To do that, you need to update app.jsx to
    pass props to its children. The following listing takes advantage of two React
    top-level API calls: `React.Children` and `React.cloneElement`.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在`profile.jsx`文件中，你添加了对路由属性`router`的引用。但如果你现在运行代码并加载`/profile`路由，应用将抛出错误，因为你还没有传递路由对象。为此，你需要更新`app.jsx`以向其子组件传递属性。以下列表利用了两个React顶级API调用：`React.Children`和`React.cloneElement`。
- en: Listing 4.9\. Passing `props` to children—src/components/app.jsx
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9。向子组件传递`props`——src/components/app.jsx
- en: '[PRE48]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Use the React.Children.map top-level API method to iterate over the current
    children property.**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用React.Children.map顶级API方法遍历当前子属性。**'
- en: '***2* The map function takes in props.children as its first argument.**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 地图函数接受`props.children`作为其第一个参数。**'
- en: '***3* Use the React.cloneElement top-level API to copy the current child and
    pass in additional props.**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用React.cloneElement顶级API来复制当前子元素并传递额外的属性。**'
- en: '***4* The second argument is a callback function that gets called for each
    child.**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 第二个参数是一个回调函数，它为每个子元素被调用。**'
- en: First render cycle
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一个渲染周期
- en: In an isomorphic app, the first render cycle is the most important. That’s where
    you’ll use lifecycle events to control what environment the code runs in. For
    example, some third-party libraries aren’t loadable or usable on the server because
    they rely on the `window` object. Or you might want to add custom scroll behavior
    on the window event. You’ll need to control this by hooking into the various lifecycle
    methods available on the first render.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在同构应用中，第一个渲染周期是最重要的。在那里，你将使用生命周期事件来控制代码运行的环境。例如，一些第三方库在服务器上不可加载或不可用，因为它们依赖于`window`对象。或者你可能想在窗口事件上添加自定义滚动行为。你需要通过挂钩到第一个渲染周期上可用的各种生命周期方法来控制这一点。
- en: 'The first render lifecycle is made up of three functions (`render` and two
    mounting events):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个渲染生命周期由三个函数（`render`和两个挂载事件）组成：
- en: '**`componentWillMount()`—** Happens before the render and before the component
    is mounted on the DOM'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`componentWillMount()`—** 在渲染之前和组件挂载到DOM之前发生'
- en: '**`render()`—** Renders the component'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`render()`—** 渲染组件'
- en: '**`componentDidMount()`—** Happens after the render and after the component
    is mounted on the DOM'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`componentDidMount()`—** 在渲染之后和组件挂载到DOM上之后发生'
- en: For the isomorphic use case, it’s important to note some differences between
    `componentWillMount` and `componentDidMount`. Although both methods run exactly
    once on the browser, `componentWillMount` runs on the server, whereas `componentDidMount`
    never runs on the server. In the previous example, you wouldn’t want to run the
    user logged-in check in `componentWillMount` because the check would also run
    on the server. Instead, you’d put the check in `componentDidMount`, guaranteeing
    that it happens only in the browser.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同构用例，需要注意`componentWillMount`和`componentDidMount`之间的一些区别。尽管这两种方法在浏览器上都会恰好运行一次，但`componentWillMount`在服务器上运行，而`componentDidMount`永远不会在服务器上运行。在先前的例子中，你不会想在`componentWillMount`中运行用户登录检查，因为该检查也会在服务器上运行。相反，你会在`componentDidMount`中放置检查，确保它仅在浏览器中发生。
- en: '`componentDidMount` never runs on the server because React never attaches any
    components to the DOM on the server. Instead, React’s `renderToString` (used on
    the server in place of `render`) results in a string representation of the DOM.
    In the next section, you’ll use `componentDidMount` to add a timer for a modal—something
    you want to do only in the browser.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount`永远不会在服务器上运行，因为React永远不会在服务器上附加任何组件到DOM。相反，React的`renderToString`（在服务器上代替`render`使用）会生成DOM的字符串表示形式。在下一节中，你将使用`componentDidMount`为模态添加计时器——你只想在浏览器中执行的操作。'
- en: 4.2.2\. Adding timers
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 添加计时器
- en: Imagine that you want to add a countdown timer to the Products page. This timer
    launches a tooltip modal after a set amount of time. [Figure 4.6](kindle_split_015_split_002.xhtml#ch04fig06)
    shows what this looks like. Timers are asynchronous and break the normal flow
    of user event-driven React updates. But React provides several lifecycle methods
    that can be used to handle timers within the lifecycle of a React component.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要向产品页面添加一个倒计时计时器。这个计时器在设定的时间后启动一个工具提示模态。![图4.6](kindle_split_015_split_002.xhtml#ch04fig06)显示了它的样子。计时器是异步的，会打断用户事件驱动的React更新流程。但React提供了几个生命周期方法，可以在React组件的生命周期内处理计时器。
- en: Figure 4.6\. The tooltip that shows as a user prompt
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 显示为用户提示的提示框
- en: '![](Images/04fig06.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig06.jpg)'
- en: To add a timer to your component, you need to kick it off after the component
    has mounted. Additionally, you’ll need to handle the cleanup of the timer when
    the component unmounts or when certain other actions happen. To check out the
    base code for this section, switch to branch chapter 4.2.2 (`git checkout chapter-4.2.2`).
    The following listing shows how to add the timer code to products.jsx. The base
    component already exists, so update the code in bold.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要向组件添加计时器，需要在组件挂载后启动它。此外，你还需要处理组件卸载或发生某些其他操作时的计时器清理。要查看本节的基础代码，切换到分支chapter
    4.2.2（`git checkout chapter-4.2.2`）。以下列表显示了如何将计时器代码添加到products.jsx中。基础组件已经存在，因此更新加粗的代码。
- en: Listing 4.10\. Adding the timer—src/components/products.jsx
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10\. 添加计时器—src/components/products.jsx
- en: '[PRE49]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* In componentDidMount, trigger the timer—the setTimeout callback sets
    the component state after 10 seconds.**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在componentDidMount中触发计时器——setTimeout回调在10秒后将设置组件状态。**'
- en: '***2* Change handler for search input, sets state of searchQuery.**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 搜索输入的更改处理程序，设置searchQuery的状态。**'
- en: '***3* Search is set by taking the value from the input element that’s been
    saved to this.search in the ref callback.**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 搜索是通过从保存到this.search的输入元素中获取值来设置的。**'
- en: '***4* The div displays the toolTip (declaring it as a variable makes the ternary
    statement more readable). It shows only when showToolTip is true (after the timer
    has triggered).**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* div元素显示工具提示（将其声明为变量可以使三元表达式更易读）。它仅在showToolTip为true时显示（在计时器触发后）。**'
- en: '***5* The value for input is tied to state so input uses the component state
    as its source of truth.**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 输入值与状态绑定，因此输入使用组件状态作为其真相来源。**'
- en: '***6* The div displays the toolTip (declaring it as a variable makes the ternary
    statement more readable). It shows only when showToolTip is true (after the timer
    has triggered).**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* div元素显示工具提示（将其声明为变量可以使三元表达式更易读）。它仅在showToolTip为true时显示（在计时器触发后）。**'
- en: The tooltip shows up at this point (it’s set to show after 10 seconds). But
    let’s imagine you want to show the tooltip only if the user has never interacted
    with the page. In that case, you need a way to clear the tooltip when the user
    has interacted. Technically, you could do that in the `onChange` handler for search,
    but for illustrative purposes, you’ll add this in `componentWillUpdate`. The following
    listing shows how to do that.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示将在此时出现（设置为10秒后显示）。但让我们假设你只想在用户从未与页面交互时显示工具提示。在这种情况下，你需要一种在用户交互时清除工具提示的方法。技术上，你可以在搜索的`onChange`处理程序中这样做，但为了说明目的，你将在`componentWillUpdate`中添加这个功能。下面的列表显示了如何做到这一点。
- en: Listing 4.11\. Clearing the timer on user interaction—src/components/products.jsx
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 在用户交互时清除计时器—src/components/products.jsx
- en: '[PRE50]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Capture return value of setTimeout so timer can be cleared.**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 捕获 setTimeout 的返回值，以便可以清除计时器。**'
- en: '***2* When component receives new state, check state for presence of search
    query.**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当组件接收到新状态时，检查状态中是否存在搜索查询。**'
- en: '***3* Clear timer.**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 清除计时器。**'
- en: '***4* Log shows that the componentWillUpdate method fires each time a letter
    is typed into the search box (with abbreviation cWU).**'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 日志显示，每当在搜索框中输入字母时，`componentWillUpdate`方法都会触发（缩写为cWU）。**'
- en: If you restart the app and interact with the Products page before the 10-second
    timer is finished, you’ll notice that the tooltip never appears.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重启应用并在10秒计时器完成之前与产品页面交互，你会注意到工具提示从未出现。
- en: Update lifecycle
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新生命周期
- en: 'The update lifecycle methods are made up of several update methods and the
    `render` method, which you can see in the listing. With the exception of the `render`
    method, these methods never run on the server (so the accessing window and document
    are safe):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 更新生命周期方法由几个更新方法和`render`方法组成，你可以在列表中看到。除了`render`方法外，这些方法永远不会在服务器上运行（因此访问window和document是安全的）：
- en: '**`componentWillReceiveProps(nextProps)`—** Happens when the component is about
    to receive properties (runs only when an update happens in a parent component)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`componentWillReceiveProps(nextProps)`—** 当组件即将接收属性时发生（仅在父组件中发生更新时运行）'
- en: '**`shouldComponentUpdate(nextProps, nextState) -> bool`—** Allows you to optimize
    the number of render cycles by determining when the component needs to update'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`shouldComponentUpdate(nextProps, nextState) -> bool`—** 允许你通过确定组件何时需要更新来优化渲染周期数'
- en: '**`componentWillUpdate(nextProps, nextState)`—** Happens right before the component
    renders'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`componentWillUpdate(nextProps, nextState)`—** 在组件渲染之前发生'
- en: '**`render()`—** Renders the component'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`render()`—** 渲染组件'
- en: '**`componentDidUpdate(prevProps, prevState)`—** Happens right after the component
    renders^([[2](kindle_split_015_split_002.xhtml#ch04fn2)])'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`componentDidUpdate(prevProps, prevState)`—** 在组件渲染后立即发生^([[2](kindle_split_015_split_002.xhtml#ch04fn2)])'
- en: ²
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Update lifecycle based on Azat Mardan’s *React Quickly* (Manning, 2017).
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基于 Azat Mardan 的 *React Quickly*（Manning，2017）的更新生命周期。
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, the mounting lifecycle will always run before any of these methods.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，挂载生命周期将始终在这些方法之前运行。
- en: '|  |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Unmounting event
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 卸载事件
- en: One final improvement you need to make to the timer is to make sure it gets
    cleaned up if the user navigates away from the Products page before the timer
    finishes running. If you don’t do that, you’ll see a React error in the console
    after 10 seconds. The error explains that the code being run is trying to reference
    a component that’s no longer mounted in the DOM. This happened because you navigated
    away from the component the timer was in without turning off the timer. [Figure
    4.7](kindle_split_015_split_002.xhtml#ch04fig07) is a screenshot of the error.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对计时器进行的最后一次改进是确保在用户在计时器完成之前离开产品页面时，计时器能够被清理。如果你不这样做，你将在10秒后在控制台中看到React错误。错误解释说正在运行的代码正在尝试引用DOM中不再挂载的组件。这是因为你在没有关闭计时器的情况下离开了计时器所在的组件。[图
    4.7](kindle_split_015_split_002.xhtml#ch04fig07)是错误的截图。
- en: Figure 4.7\. If a component is unmounted, but listeners or timers aren’t cleaned
    up, they’ll end up with a reference to a null component.
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7\. 如果组件已卸载，但监听器或计时器没有被清理，它们最终会得到一个指向 null 组件的引用。
- en: '![](Images/04fig07_alt.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig07_alt.jpg)'
- en: The following listing shows how to add the time-out cleanup to your `componentWillUnmount`
    lifecycle function.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何将超时清理添加到你的`componentWillUnmount`生命周期函数中。
- en: Listing 4.12\. Cleaning up the timer—src/components/products.jsx
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 清理计时器—src/components/products.jsx
- en: '[PRE51]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Clear timer on unmount.**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在卸载时清除计时器。**'
- en: 'There’s only one unmount event: `componentWillUnmount()`. You can take advantage
    of this event to clean up any manually attached event listeners and shut down
    any timers you may have running. This method runs only in the browser. To see
    all the code for the chapter, you can check out branch chapter-4-complete (`git
    checkout chapter-4-complete`).'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个卸载事件：`componentWillUnmount()`。你可以利用这个事件来清理任何手动附加的事件监听器并关闭你可能正在运行的任何计时器。此方法仅在浏览器中运行。要查看本章的所有代码，你可以查看分支
    chapter-4-complete (`git checkout chapter-4-complete`)。
- en: Now that you understand the React lifecycle, let’s explore component architecture
    patterns that can help you build great React apps.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 React 生命周期，让我们来探索可以帮助你构建出色的 React 应用的组件架构模式。
- en: 4.3\. Component patterns
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. 组件模式
- en: 'You can compose React components in user interfaces in two well-defined ways:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在用户界面中以两种明确的方式编写 React 组件：
- en: Higher-order components
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶组件
- en: Presentation and container components
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示组件和容器组件
- en: In the All Things Westies app, it’s beneficial to create reusable parts for
    the view and business logic. This has long-term maintainability benefits for developers
    and makes your code easier to reason about.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在 All Things Westies 应用程序中，创建视图和业务逻辑的可重用部分是有益的。这对开发者的长期可维护性有好处，并使你的代码更容易推理。
- en: 'In some cases, you add reusability by creating a component that takes in another
    component and extends its functionality—a decorator. This happens in Redux when
    you wrap a view component with the Connect component. In other cases, you split
    your components into two types: components that focus on business logic and components
    that focus on what the app looks like. For example, the Products component focuses
    on the business logic of the view.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，通过创建一个接受另一个组件并扩展其功能的组件来增加可重用性——这是一个装饰器。这在 Redux 中通过使用 Connect 组件包装视图组件时发生。在其他情况下，你将组件分为两种类型：关注业务逻辑的组件和关注应用程序外观的组件。例如，产品组件关注视图的业务逻辑。
- en: 4.3.1\. Higher-order components
  id: totrans-509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1. 高阶组件
- en: When building a modular, component-driven UI, you end up having a lot of components
    that need the same kind of data fetching or that have the same view with different
    data fetching. For example, you may have many views that use user data in some
    way. Or you may have many views that use a List component but with different data
    sets. In these cases, you want a way to pull out the data-fetching and manipulation
    logic, making it separate from the component that displays the data.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建模块化、组件驱动的 UI 时，你最终会有很多需要相同类型数据获取或具有相同视图但不同数据获取的组件。例如，你可能有很多使用用户数据的视图。或者你可能有很多使用列表组件但数据集不同的视图。在这些情况下，你想要一种方法来提取数据获取和操作逻辑，使其与显示数据的组件分离。
- en: 'Even though you haven’t added any data fetching to the All Things Westies app
    yet, you’ll eventually need to do that. The products view will need to know about
    the products available for sale. Imagine you wanted to make a component that knew
    how to fetch all the products. It’d look something like this:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你还没有向 All Things Westies 应用程序添加任何数据获取功能，你最终也需要这样做。产品视图需要了解可销售的产品。想象一下，如果你想创建一个知道如何获取所有产品的组件。它看起来可能像这样：
- en: '[PRE52]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The most important part of this example function is that you pass in the component
    (the Products component in this example) to the `ProductsDataFetcher` function.
    In this case, the higher-order component (HOC) function knows how to get the product
    data and will then pass that data into the component ([Figure 4.8](kindle_split_015_split_003.xhtml#ch04fig08)).
    This abstracts away any state or logic from the Products View component, leaving
    it to focus on the UI concerns.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例函数最重要的部分是，你将组件（在这个例子中是产品组件）传递给 `ProductsDataFetcher` 函数。在这种情况下，高阶组件（HOC）函数知道如何获取产品数据，然后会将这些数据传递给组件（[图
    4.8](kindle_split_015_split_003.xhtml#ch04fig08)）。这抽象掉了从产品视图组件中任何状态或逻辑，使其专注于 UI
    问题。
- en: Figure 4.8\. Higher-order functions take a function and return a new function
    with additional functionality. (Reproduced from Azat Mardan’s *React Quickly*,
    Manning, 2017.
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8. 高阶函数接受一个函数并返回一个具有附加功能的新函数。（摘自 Azat Mardan 的《React 快速入门》，Manning，2017年。
- en: '![](Images/04fig08_alt.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8](Images/04fig08_alt.jpg)'
- en: If you have a component and then pass it into the higher-order component, you’ll
    end up with the original component plus additional functionality. In React, this
    almost always results in offloading some sort of state management to the parent
    HOC. In the `ListDataFetcher` example, the HOC knows about the app state and fetching
    the data. That allows the List component to be a presentation component that’s
    highly reusable.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个组件，然后将其传递给高阶组件，你最终会得到原始组件以及额外的功能。在 React 中，这几乎总是导致将某种状态管理卸载到父 HOC。在 `ListDataFetcher`
    示例中，HOC 了解应用状态和数据获取。这使得列表组件成为一个高度可重用的展示组件。
- en: '4.3.2\. Component types: presentation and container'
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 组件类型：展示和容器
- en: 'It’s possible to categorize React components into two distinct buckets: presenters
    and containers. By following this binary type pattern, you can maximize your code
    reuse and minimize unnecessary code coupling and complexity.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 React 组件分为两个不同的类别：展示者和容器。通过遵循这种二进制类型模式，你可以最大化代码重用并最小化不必要的代码耦合和复杂性。
- en: Earlier in this chapter, you built the Products page of the All Things Westies
    app. This has a component called Products that holds onto the state for its part
    of the application. Later in the book, it’ll also be responsible for managing
    data fetching via Redux. These responsibilities make it a container component.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你构建了 All Things Westies 应用程序的产品页面。这个页面包含一个名为 Products 的组件，它负责其应用部分的状态。在本书的后续部分，它还将负责通过
    Redux 管理数据获取。这些职责使其成为一个容器组件。
- en: On the other hand, the Item and App components are presentation components.
    Both contain display elements and rely on properties to determine their functionality.
    Presentation components determine how the app looks.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Item 和 App 组件是展示组件。它们都包含显示元素，并依赖于属性来确定其功能。展示组件决定了应用程序的外观。
- en: '[Table 4.1](kindle_split_015_split_003.xhtml#ch04table01) lists the value of
    container and presentation components.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4.1](kindle_split_015_split_003.xhtml#ch04table01) 列出了容器和展示组件的值。'
- en: Table 4.1\. Attributes of component types
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. 组件类型属性
- en: '| Container | Presentation |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 容器 | 展示 |'
- en: '| --- | --- |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Contains state | Limited state (for user interactions), ideally implemented
    as a functional component |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| 包含状态 | 有限的状态（用户交互），理想情况下作为函数组件实现 |'
- en: '| Responsible for how the app works | Responsible for how the app looks |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| 负责应用的工作方式 | 负责应用的外观 |'
- en: '| Children: container and presentation components | Children: container and
    presentation components |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| 子组件：容器和展示组件 | 子组件：容器和展示组件 |'
- en: '| Connect to rest of application (for example, Redux) | No dependencies on
    model or controller portions of the app (for example, Redux) |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 连接到应用的其他部分（例如，Redux） | 不依赖于模型或控制器部分的应用（例如，Redux） |'
- en: Container components abstract state away from their children. They also handle
    layout and are generally responsible for the *how* of the application. Some higher-order
    components have this as their main purpose. They listen for data changes and then
    pass that state down as properties. Redux provides a higher-order component that
    helps with this (see [chapter 6](kindle_split_017_split_000.xhtml#ch06)).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 容器组件将状态从其子组件中抽象出来。它们还处理布局，通常负责应用程序的“如何”。一些高阶组件的主要目的就是如此。它们监听数据变化，然后将该状态作为属性传递下去。Redux
    提供了一个帮助实现这一功能的高阶组件（见第 6 章）。
- en: Presentation components contain only state related to user interactions. Whenever
    possible, they should be implemented as pure components. They’re concerned with
    what the application looks like.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 展示组件只包含与用户交互相关的状态。尽可能情况下，它们应该作为纯组件实现。它们关注的是应用程序的外观。
- en: One important note is that containers can have other containers and presentation
    components as children. Conversely, presentation components can have both containers
    and presentation components as children. These two types of component nesting
    should be kept flexible to maximize code composition. That may feel strange at
    first, but keeping the two component types clear will help you in the long run.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的注意事项是，容器可以有其他容器和展示组件作为子组件。相反，展示组件可以有容器和展示组件作为子组件。这两种类型的组件嵌套应该保持灵活，以最大化代码组合。这一开始可能感觉有些奇怪，但保持两种组件类型清晰将有助于你长期发展。
- en: Summary
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to set up and use React Router to have a complete
    single-page app experience. You also learned more about React by exploring the
    component lifecycle. Finally, you learned key patterns that are commonly used
    when building React apps.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何设置和使用React Router以获得完整的单页应用体验。您还通过探索组件生命周期对React有了更深入的了解。最后，您学习了在构建React应用时常用的一些关键模式。
- en: React Router uses React’s concepts of components to compose routes into any
    React app.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router使用React的组件概念将路由组合到任何React应用中。
- en: React Router abstracts the history object and provides utilities for linking.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router抽象了历史对象，并提供了链接的实用工具。
- en: React Router has routing hooks that let you add advanced logic.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router具有路由钩子，允许您添加高级逻辑。
- en: React lifecycle methods are used as hooks into the render cycle.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React生命周期方法被用作渲染周期的钩子。
- en: The initial render cycle can be used to trigger timers or lock down logged-in
    routes.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始渲染周期可以用来触发计时器或锁定已登录的路由。
- en: Many component patterns are available for composing React components in reusable
    and maintainable ways.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于以可重用和可维护的方式组合React组件的许多组件模式。
- en: 'Chapter 5\. Tools: webpack and Babel'
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 工具：webpack和Babel
- en: '*This chapter covers*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using webpack to load Node.js packages via npm in order to use them in browser
    code
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack通过npm加载Node.js包，以便在浏览器代码中使用
- en: Compiling code with Babel using webpack loaders
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack加载器使用Babel编译代码
- en: Loading CSS with webpack loaders
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack加载器加载CSS
- en: Using webpack plugins to prepare your code for production
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack插件准备您的代码以供生产使用
- en: Creating multiple configurations to manage builds for multiple environments
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个配置以管理多个环境下的构建
- en: The JavaScript ecosystem provides many great libraries and tools to make writing
    applications faster and easier for developers. To take advantage of them, you
    need to have tooling in place that can compile, transform, and prepare your code
    for production. Enter webpack, a build tool that’s entirely configuration driven.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript生态系统提供了许多优秀的库和工具，使开发者能够更快、更轻松地编写应用程序。为了利用它们，您需要具备能够编译、转换和为生产准备代码的工具。这就是webpack，一个完全由配置驱动的构建工具。
- en: 'I’m going to be completely honest with you: webpack isn’t an intuitive tool.
    I found it frustrating to work with at first. But it’s extremely powerful and
    worth learning. Webpack gives you the ability to include any JavaScript code in
    your build, even libraries that haven’t been set up to run in the browser (for
    example, npm packages). It also can take care of many other build steps, including
    compiling your code with Babel and preparing your code for production. This chapter
    covers all the basics you need in order to have a good workflow in your isomorphic
    project.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我将完全诚实地告诉您：webpack不是一个直观的工具。起初我发现它与工作起来很令人沮丧。但它非常强大，值得学习。Webpack让您能够在构建中包含任何JavaScript代码，甚至包括那些尚未设置在浏览器中运行的库（例如，npm包）。它还可以处理许多其他构建步骤，包括使用Babel编译您的代码以及为生产准备您的代码。本章涵盖了您在异构项目中拥有良好工作流程所需的所有基础知识。
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you ever want to start a React project with webpack set up for you, I recommend
    Create React App. This tool generates a base React app with webpack ([https://github.com/facebookincubator/create-react-app](https://github.com/facebookincubator/create-react-app)).
    Note that it’s not isomorphic!
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用已经为webpack设置好的React项目开始，我推荐Create React App。这个工具生成一个带有webpack的基础React应用([https://github.com/facebookincubator/create-react-app](https://github.com/facebookincubator/create-react-app))。请注意，它不是异构的！
- en: '|  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.1\. Webpack overview
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. Webpack概述
- en: Imagine you’re starting a new isomorphic React project. You want to build a
    calendar reminder app like the one in [figure 5.1](kindle_split_016_split_001.xhtml#ch05fig01).
    This chapter is about the build tools—so this is just a signpost to help you make
    sure things are loading.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下您正在启动一个新的异构React项目。您想要构建一个像[图5.1](kindle_split_016_split_001.xhtml#ch05fig01)中的日历提醒应用。本章是关于构建工具——所以这只是一个路标，帮助您确保一切都在加载。
- en: Figure 5.1\. The calendar reminder app you’ll be setting up with webpack in
    this chapter
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 本章中将使用webpack设置的日历提醒应用
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: In this example, you’ve decided not to build a calendar from scratch. A lot
    of well-written React calendar packages are available on npm. To use these packages
    and build your own app on top of them, you need a build tool that will package
    your Java-Script modules in a way that the browser understands. (Also, this chapter
    is about the build tool, not making an app, so using a package will let you focus
    on learning webpack.)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您决定不从头开始构建日历。在 npm 上有许多编写良好的 React 日历包可用。为了使用这些包并在它们之上构建自己的应用，您需要一个构建工具，该工具将以浏览器理解的方式打包您的
    Java-Script 模块。（此外，本章是关于构建工具，而不是制作应用，因此使用包将让您专注于学习 webpack。）
- en: If you’re wondering why you need to learn yet another build tool, give me a
    few minutes to convince you. Let’s cover the app requirements to establish why
    a build tool is necessary. That way, you don’t have to take my word for it. [Table
    5.1](kindle_split_016_split_001.xhtml#ch05table01) gives an overview of the app
    requirements and the reasons you need webpack.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么您需要学习另一个构建工具，请给我几分钟时间来说服您。让我们讨论应用需求，以确定为什么需要构建工具。这样，您不必仅凭我的话来相信。[表
    5.1](kindle_split_016_split_001.xhtml#ch05table01) 给出了应用需求及其需要 webpack 的原因概述。
- en: Table 5.1\. An overview of the various app requirements that make a build tool
    necessary
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1\. 各类应用需求概述，这些需求使得构建工具变得必要
- en: '| Requirement | Webpack required | Reason |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| 需求 | Webpack 需要 | 原因 |'
- en: '| --- | --- | --- |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Calendar widget (react-big-calendar) | Yes | Import from npm package. In
    particular, this is something that can’t be achieved through tools such as Gulp
    and Grunt or npm build scripts. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| 日历小部件（react-big-calendar） | 是 | 从 npm 包中导入。特别是，这是无法通过 Gulp 和 Grunt 或 npm
    构建脚本实现的事情。|'
- en: '| ES6 | Yes | Requires compilation to work in all browsers. This could be achieved
    with other tools, but webpack loaders make it straightforward. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| ES6 | 是 | 需要编译才能在所有浏览器中工作。这可以通过其他工具实现，但 webpack 加载器使其变得简单直接。|'
- en: '| Load CSS | Optional | Optimize development flow by including in the webpack
    build. This can’t be achieved with tools such as Gulp or Grunt. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| 加载 CSS | 可选 | 通过包含在 webpack 构建中优化开发流程。这无法通过 Gulp 或 Grunt 等工具实现。|'
- en: '| Environment-specific code | Yes | Webpack plugins allow you to inject custom
    variables. This can’t be achieved with Gulp or Grunt. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| 环境特定代码 | 是 | Webpack 插件允许您注入自定义变量。这无法通过 Gulp 或 Grunt 实现。|'
- en: Additionally, there are many other reasons a build tool is required for the
    app. You want to use ES6 to write the latest JavaScript code, but cross-browser
    support for ES6 is mixed. To allow you to use all the latest language features,
    you need to compile your code.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多其他原因使得构建工具对于应用是必需的。您想使用 ES6 编写最新的 JavaScript 代码，但 ES6 在不同浏览器中的支持是混合的。为了让您能够使用所有最新的语言特性，您需要编译您的代码。
- en: Finally, in order to load CSS, you need webpack loaders. You also need webpack
    plugins to inject variables into code. Remember, all the code will run in the
    server and the browser! (If this reminder is starting to feel repetitive, that’s
    great—you’re on your way to thinking in isomorphic terms.)
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了加载 CSS，您需要 webpack 加载器。您还需要 webpack 插件来将变量注入到代码中。记住，所有代码都将运行在服务器和浏览器中！（如果这个提醒开始感觉重复，那很好——您正在朝着同构思维的方向前进。）
- en: Running the code
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'All code for this chapter is located on GitHub at [https://github.com/isomorphic-dev-js/chapter5-webpack-babel](https://github.com/isomorphic-dev-js/chapter5-webpack-babel).
    After you’ve checked out the code with Git, you need to do an npm install:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都位于 GitHub 上，地址为 [https://github.com/isomorphic-dev-js/chapter5-webpack-babel](https://github.com/isomorphic-dev-js/chapter5-webpack-babel)。在您使用
    Git 检出代码后，您需要进行 npm install：
- en: '[PRE53]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To run the complete example, run the following command:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行完整示例，请运行以下命令：
- en: '[PRE54]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Then you can load the calendar example at http://localhost:3050\. You’ll use
    additional scripts and examples throughout the chapter. I’ll explain them as needed.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以在 http://localhost:3050/ 加载日历示例。您将在本章中用到额外的脚本和示例。我会根据需要解释它们。
- en: Before we dive into the specifics of a webpack configuration, I’m going to show
    you how to set up your environment to work with webpack, including how to run
    the webpack command-line interface (CLI). The command-line tool will be useful
    for debugging issues and is great for working on small projects. Later in the
    chapter, you’ll learn to use webpack via JSON configuration.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入 webpack 配置的具体细节之前，我将向您展示如何设置您的环境以与 webpack 一起工作，包括如何运行 webpack 命令行界面（CLI）。命令行工具对于调试问题和在小项目上工作非常有用。在本章的后面部分，您将学习如何通过
    JSON 配置使用 webpack。
- en: To use webpack, you need to install it (I’ve already set up the repo with webpack).
    I recommend doing this on a per project basis rather than installing it globally
    so you can use the version of webpack appropriate to each project.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 webpack，你需要安装它（我已经在仓库中设置了 webpack）。我建议按项目安装，而不是全局安装，这样你可以使用适合每个项目的 webpack
    版本。
- en: After webpack is installed, you can use the webpack CLI to generate your first
    webpack bundle. The syntax is shown next.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 webpack 后，你可以使用 webpack CLI 生成你的第一个 webpack 包。语法如下。
- en: '|  |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: A *bundle* is the file outputted by the webpack transformation pipeline. You
    can name a bundle anything you want.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '*包* 是 webpack 转换管道输出的文件。你可以将包命名为任何你想要的。'
- en: '|  |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](Images/0099fig01_alt.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0099fig01_alt.jpg)'
- en: 'To run this command in the repo, put this command into your terminal:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 要在仓库中运行此命令，请在你的终端中输入此命令：
- en: '[PRE55]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After running this command, you’ll notice a new file in the root of the project
    code directory called output.js, shown in [listing 5.1](kindle_split_016_split_001.xhtml#ch05ex01).
    This file contains your compiled code from entry.js and any dependencies. First
    take a look at the entry.js file contents (written in ES5—later in the chapter,
    you’ll add Babel to compile ES6). This code is already provided in the repo.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你会在项目代码目录的根目录中注意到一个名为 output.js 的新文件，如[列表 5.1](kindle_split_016_split_001.xhtml#ch05ex01)所示。此文件包含从
    entry.js 编译的代码以及任何依赖项。首先查看 entry.js 文件的内容（使用 ES5 编写—本章后面，你将添加 Babel 来编译 ES6）。此代码已在仓库中提供。
- en: Listing 5.1\. Entry.js contents—src/entry.js
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. Entry.js 内容—src/entry.js
- en: '[PRE56]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Path included as dependency—require() is used instead of import because
    this code isn’t being compiled by Babel.**'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含的路径作为依赖项—使用 require() 而不是 import，因为此代码不是由 Babel 编译的。**'
- en: '***2* Log the path to the root folder using path.resolve with the relative
    path**'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 path.resolve 和相对路径记录根文件夹的路径**'
- en: The compiled version of this code is nearly 400 lines of code, some of which
    is shown in the next listing. That’s because webpack collects all the referenced
    files (the node module path, in this case) and includes them in the bundled output.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的编译版本接近 400 行代码，其中一些将在下一列表中显示。这是因为 webpack 收集所有引用的文件（在这种情况下是节点模块路径）并将它们包含在打包输出中。
- en: Listing 5.2\. Compiled webpack output, partial view—output.js
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 编译后的 webpack 输出，部分视图—output.js
- en: '[PRE57]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Webpack wraps modules (your code, any included npm libraries) in JavaScript
    closures, which allows webpack to control, and rewrite import statements.**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Webpack 将模块（你的代码，任何包含的 npm 库）包裹在 JavaScript 闭包中，这使得 webpack 能够控制并重写导入语句。**'
- en: '***2* The require statement for path compiles into a custom webpack require
    statement. The path module is located by number key.**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 路径的 require 语句编译成自定义的 webpack require 语句。路径模块位于数字键中。**'
- en: '***3* Human-readable comments indicating the number of each module are added
    to the final output (helps with debugging).**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加到最终输出的可读性注释，指示每个模块的编号（有助于调试）。**'
- en: The bundled code includes additional functions that are part of the webpack
    library. This includes a browser-friendly polyfill of the Node.js process object,
    which allows you to safely include many npm modules that were originally written
    for Node.js.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的代码包括 webpack 库的一部分额外函数。这包括 Node.js 进程对象的浏览器友好 polyfill，这允许你安全地包含许多最初为 Node.js
    编写的 npm 模块。
- en: There are some exceptions to this. For example, the Node.js file system (fs)
    module isn’t safe for isomorphic use. If an npm package relies on the fs module,
    you shouldn’t use it for browser code. Now that you’ve seen how to use the command
    line to bundle your code, take a look at [figure 5.2](kindle_split_016_split_001.xhtml#ch05fig02).
    It shows how webpack takes your code and creates a bundled output.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些例外。例如，Node.js 文件系统（fs）模块不适合同构使用。如果一个 npm 包依赖于 fs 模块，你不应该将其用于浏览器代码。现在你已经看到了如何使用命令行来打包你的代码，看看[图
    5.2](kindle_split_016_split_001.xhtml#ch05fig02)。它显示了 webpack 如何处理你的代码并创建打包输出。
- en: Figure 5.2\. The webpack compiler flow
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. webpack 编译器流程
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-598
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: Debugging webpack
  id: totrans-599
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试 webpack
- en: Sometimes webpack will fail to compile. You have two helpful command-line options
    for debugging. The first option, `--debug`, shows errors in the command line.
    The second option, `--display-error-details`, provides an additional level of
    detail about any errors that occur.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 webpack 可能无法编译。你有两个有用的命令行选项用于调试。第一个选项，`--debug`，在命令行中显示错误。第二个选项，`--display-error-details`，提供了关于发生的任何错误的额外详细信息。
- en: Webpack can also be debugged using `node --inspect`. This loads a debugging
    tool with which you can see Node.js code in the Chrome DevTools. Then you can
    use breakpoints to debug. For more `--inspect` resources, see [https://nodejs.org/en/docs/inspector/](https://nodejs.org/en/docs/inspector/).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack也可以使用`node --inspect`进行调试。这将加载一个调试工具，你可以用它通过Chrome DevTools查看Node.js代码。然后你可以使用断点进行调试。有关更多`--inspect`资源，请参阅[https://nodejs.org/en/docs/inspector/](https://nodejs.org/en/docs/inspector/).
- en: Now that you’ve seen how to use webpack and explored the parts of a webpack
    bundle, you’ll learn how to use webpack loaders to compile your code.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用webpack并探索了webpack包的各个部分，你将学习如何使用webpack加载器来编译你的代码。
- en: 5.2\. Babel overview
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. Babel概述
- en: Babel is a tool for compiling JavaScript. It takes code that isn’t yet supported
    in all JavaScript environments and compiles it into something understandable by
    browsers. If you want to use the latest and greatest parts of the JavaScript spec
    (ES6, ES7, or sometimes also referred to as ES2015, ES2016, and so forth), you
    must use a compiler. It should be noted that the latest versions of Node.js now
    support most (but not quite all) of the JavaScript spec. But in the browser, support
    is varied and rolls out more slowly.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: Babel是一个用于编译JavaScript的工具。它将尚未在所有JavaScript环境中得到支持的代码编译成浏览器可以理解的形式。如果你想使用JavaScript规范中最新的和最好的部分（ES6、ES7，有时也称为ES2015、ES2016等），你必须使用编译器。需要注意的是，Node.js的最新版本现在支持大多数（但不是全部）JavaScript规范。但在浏览器中，支持情况各异，并且推出速度较慢。
- en: 'In the preceding section, you learned that webpack is a tool that brings together
    many loaders and plugins to create a single bundled code file. Babel is a library
    that does a single job: it compiles JavaScript. Babel is one of many loaders you
    can use with webpack.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你了解到webpack是一个将许多加载器和插件组合在一起以创建单个捆绑代码文件的工具。Babel是一个库，它只做一件事情：编译JavaScript。Babel是你可以与webpack一起使用的许多加载器之一。
- en: 5.2.1\. Getting started with Babel
  id: totrans-606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 开始使用Babel
- en: Babel compiles to code that can be understood by any browser running ES5 JavaScript.
    The generated output is human readable, as you can see in the following listing,
    and includes Babel-injected code that helps convert ES6 syntax into something
    understood by older JavaScript engines.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: Babel编译成任何运行ES5 JavaScript的浏览器都能理解的代码。生成的输出是可读的，如以下列表所示，并包括Babel注入的代码，这些代码有助于将ES6语法转换为旧版JavaScript引擎可以理解的形式。
- en: Listing 5.3\. Babel sample output
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. Babel示例输出
- en: '[PRE58]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Babel-injected function that converts ES6 class into ES5**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Babel注入的函数将ES6类转换为ES5**'
- en: '***2* All import statements converted to requires**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 所有导入语句已转换为requires**'
- en: '***3* Each import statement converts to two requires: one the standard ES5
    require, the other using a special function to ensure the export default feature
    of ES6 works properly.**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个导入语句转换为两个requires：一个是标准的ES5 require，另一个使用特殊函数以确保ES6的export default功能正常工作。**'
- en: '***4* Babel-injected function that checks for the default export**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Babel注入的函数用于检查默认导出**'
- en: '***5* ES6-style functions converted to function() {} syntax**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将ES6风格的函数转换为function() {}语法**'
- en: '***6* Button written as a class in ES6, so here it’s wrapped by Babel _createClass
    helper function.**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在ES6中以类形式编写的按钮，因此在这里它被Babel的_createClass辅助函数包装。**'
- en: The compiled code in [listing 5.3](kindle_split_016_split_002.xhtml#ch05ex03)
    is based on the ES6 code in [listing 5.4](kindle_split_016_split_002.xhtml#ch05ex04).
    Notice that the base code is much simpler and doesn’t include many of the helper
    functions that Babel adds to help run your code in JavaScript environments that
    don’t yet support ES6.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3中的编译代码基于列表5.4中的ES6代码。请注意，基本代码要简单得多，并且不包括Babel添加的许多辅助函数，这些辅助函数有助于在尚未支持ES6的JavaScript环境中运行你的代码。
- en: Listing 5.4\. ES6 code to compile—src/compile-me.js
  id: totrans-617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4\. 要编译的ES6代码—src/compile-me.js
- en: '[PRE59]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Currently, import statements need to be compiled for all environments
    (node and browsers).**'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 目前，所有环境的导入语句（node和浏览器）都需要编译。**'
- en: '***2* ES6 function syntax with scope of parent rather than caller**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* ES6函数语法具有父作用域而不是调用者作用域**'
- en: '***3* A class declaration**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 类声明**'
- en: '***4* The let variable (or in other cases, const)**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 令变量（或在其他情况下，const）**'
- en: '***5* Babel compiler also compiles the JSX.**'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* Babel编译器也编译JSX。**'
- en: 5.2.2\. The Babel CLI
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. Babel CLI
- en: 'Babel can be used on its own as a command-line tool. To get started and understand
    how this tool works, you’ll use the Babel CLI to process the ES6 from [listing
    5.3](kindle_split_016_split_002.xhtml#ch05ex03):'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 可以作为一个独立的命令行工具使用。要开始并了解此工具的工作原理，您将使用 Babel CLI 处理来自 [列表 5.3](kindle_split_016_split_002.xhtml#ch05ex03)
    的 ES6：
- en: '[PRE60]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Babel takes the input (the code in src/compile-me.js), parses it, transforms
    it, and then generates a version of the code that’s compatible with standard browser
    and Node.js environments. [Figure 5.3](kindle_split_016_split_002.xhtml#ch05fig03)
    shows this compile flow. You’ll notice that this flow is similar to webpack’s
    flow.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 接收输入（src/compile-me.js 中的代码），解析它，转换它，然后生成与标准浏览器和 Node.js 环境兼容的代码版本。[图
    5.3](kindle_split_016_split_002.xhtml#ch05fig03) 展示了此编译流程。您会注意到此流程与 webpack 的流程类似。
- en: Figure 5.3\. How the Babel compiler transforms ES6 into browser- and Node.js-compatible
    code
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3\. Babel 编译器如何将 ES6 转换为浏览器和 Node.js 兼容的代码
- en: '![](Images/05fig03.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03.jpg)'
- en: The command in this section outputs the result to the command line. Later, you’ll
    use Babel to compile the code as part of the webpack build.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的命令将结果输出到命令行。稍后，您将使用 Babel 将代码作为 webpack 构建的一部分进行编译。
- en: Babel plugins and presets
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Babel 插件和预设
- en: 'Out of the box, Babel doesn’t know what rules to use to compile your code.
    But you can use plugins that tell Babel what to do. Conveniently, these plug-ins
    are often grouped into *presets.* Presets and plugins need to be installed from
    npm. If you wanted to use the Babel React preset, you’d install the following:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Babel 不知道使用哪些规则来编译您的代码。但您可以使用插件来告诉 Babel 要做什么。方便的是，这些插件通常被分组为 *预设*。预设和插件需要从
    npm 安装。如果您想使用 Babel React 预设，您将安装以下内容：
- en: '[PRE61]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you’re working with the provided code, all the presets you need for this
    chapter are already installed. After you’ve installed all the Babel presets you
    want to use, you can reference them in the .babelrc file, provided in the repo
    and shown in the following listing.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用提供的代码，本章所需的全部预设已安装。在您安装了所有想要使用的 Babel 预设后，您可以在存储库中提供的 .babelrc 文件中引用它们，如下所示列表。
- en: Listing 5.5\. .babelrc configuration file—.babelrc
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. .babelrc 配置文件—.babelrc
- en: '[PRE62]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Tell Babel what presets to use when compiling (you can list multiple
    presets in an array).**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 告诉 Babel 在编译时使用哪些预设（您可以在数组中列出多个预设）。**'
- en: These presets tell Babel to compile everything to ES2015 and properly process
    JSX. Next we’ll look at the Calendar App code.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预设告诉 Babel 将所有内容编译为 ES2015 并正确处理 JSX。接下来，我们将查看日历应用的代码。
- en: 5.3\. The app code
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 应用代码
- en: 'Throughout the rest of this chapter, when you run webpack, you’ll be compiling
    the Calendar App code. Two files make up this example: src/app.jsx and src/main.jsx.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，当您运行 webpack 时，您将编译日历应用的代码。此示例由两个文件组成：src/app.jsx 和 src/main.jsx。
- en: The entry point file for the webpack builds is main.jsx. The following listing
    shows the code that’s provided in the repo.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 构建入口文件是 main.jsx。以下列表显示了存储库中提供的代码。
- en: Listing 5.6\. Entry file—src/main.jsx
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 入口文件—src/main.jsx
- en: '[PRE63]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Import dependencies including React and App component**'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 引入所有依赖，包括 React 和 App 组件**'
- en: '***2* Attach the root component (App) to the DOM.**'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将根组件（App）附加到 DOM 上。**'
- en: The entry point file includes a single component called App from src/app.jsx.
    Shown in the next listing, this component includes npm packages and renders the
    React Big Calendar component. It also includes the CSS for the calendar. We’ll
    talk more about including the CSS in this format when you learn about webpack
    loaders.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '入口文件包含一个名为 App 的组件，来自 src/app.jsx。在下一列表中显示，此组件包含 npm 包并渲染 React Big Calendar
    组件。它还包括日历的 CSS。当您学习 webpack 加载器时，我们将更详细地讨论以这种格式包含 CSS。 '
- en: Listing 5.7\. App component—src/app.jsx
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. App 组件—src/app.jsx
- en: '[PRE64]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Import all dependencies including moment (react-big-calendar requires
    a date library).**'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 引入所有依赖，包括 moment（react-big-calendar 需要一个日期库）。**'
- en: '***2* Require the CSS that comes with react-big-calendar.**'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 引入 react-big-calendar 伴随的 CSS。**'
- en: '***3* Initialize the Calendar component.**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 初始化 Calendar 组件。**'
- en: '***4* Create the App component.**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建 App 组件。**'
- en: '***5* Render Big Calendar with the required props.**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用所需的属性渲染 Big Calendar。**'
- en: These files are simple but will allow you to learn webpack without the example
    getting in the way. They require Babel to compile the ES6 features (`import`,
    `class`) and the JSX. You also need to load the CSS properly. The next section
    shows how to configure webpack from a JavaScript file and introduces using loaders.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件很简单，但将允许你在不受到示例干扰的情况下学习webpack。它们需要Babel来编译ES6功能（`import`、`class`）和JSX。你还需要正确加载CSS。下一节将展示如何从JavaScript文件配置webpack，并介绍使用加载器。
- en: 5.4\. Webpack config with loaders
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 带有加载器的Webpack配置
- en: Earlier in the chapter, you bundled your code with webpack via the command line.
    But webpack is also configurable with a JavaScript configuration file. This file
    is called webpack.config.js by convention. (You can use any name you want in your
    own projects.)
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你通过命令行使用webpack捆绑了你的代码。但webpack也可以通过JavaScript配置文件进行配置。按照惯例，这个文件被称为webpack.config.js。（在你的项目中，你可以使用任何你想要的名称。）
- en: 'The config file is loaded by the `webpack` command. By default, the command
    will look for a file called webpack.config.js. To load the default config, run
    the following command in Terminal:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件由`webpack`命令加载。默认情况下，命令将查找一个名为webpack.config.js的文件。要加载默认配置，请在终端中运行以下命令：
- en: '[PRE65]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This loads the configuration file, compiles your code, and outputs a bundle
    file that can then be loaded in the browser. The most basic configuration file
    includes an entry point and output information (if you ever find yourself needing
    a simple configuration like this one, you can also stick to the command-line options
    introduced at the beginning of the chapter), as shown in the following listing.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载配置文件，编译你的代码，并输出一个可以随后在浏览器中加载的捆绑文件。最基本的配置文件包括一个入口点和输出信息（如果你发现自己需要像这样简单的配置，你也可以坚持使用本章开头介绍的命令行选项），如下所示。
- en: Listing 5.8\. webpack.config.js
  id: totrans-660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. webpack.config.js
- en: '[PRE66]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Entry point uses Node.js path module to resolve path relative to current
    directory (helpful for continuous integration tools).**'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 入口点使用Node.js路径模块解析相对于当前目录的路径（对持续集成工具很有帮助）。**'
- en: '***2* Declare output object.**'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明输出对象。**'
- en: '***3* Use path module to resolve path to output (in this case, root directory).**'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用路径模块解析输出路径（在本例中，为根目录）。**'
- en: '***4* Declare filename of output.**'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明输出文件的名称。**'
- en: Next, you’ll add in webpack loaders to compile your ES6 and CSS.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将添加webpack加载器来编译你的ES6和CSS。
- en: 5.4.1\. Configuring the Babel loader
  id: totrans-667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 配置Babel加载器
- en: To use Babel within webpack, you need two things. First, you still need the
    .babelrc file you saw earlier in the chapter. This tells Babel what presets to
    compile with (React and ES6). Second, you need to declare Babel as a loader in
    the webpack configuration. [Listing 5.9](kindle_split_016_split_004.xhtml#ch05ex09)
    shows the code for the loader.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 要在webpack中使用Babel，你需要两样东西。首先，你仍然需要本章前面看到的.babelrc文件。这告诉Babel要编译哪些预设（React和ES6）。其次，你需要在webpack配置中声明Babel为加载器。[列表5.9](kindle_split_016_split_004.xhtml#ch05ex09)显示了加载器的代码。
- en: '|  |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Pay close attention to the shape of the configuration object—otherwise, your
    build will fail silently. This will be followed by a series of apocalyptic events
    and a sudden dislike for all build tools. In all seriousness, if your webpack
    build is failing silently, check that you put all your properties in the right
    place. You can use the `--debug` and `--progress` options to help you debug (more
    info at [https://webpack.js.org/api/cli/#debug-options](https://webpack.js.org/api/cli/#debug-options)).
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切注意配置对象的形状——否则，你的构建将静默失败。这将会引发一系列灾难性事件，以及对所有构建工具的突然反感。非常认真地说，如果你的webpack构建静默失败，请检查你是否把所有属性都放在了正确的位置。你可以使用`--debug`和`--progress`选项来帮助你调试（更多信息请参阅[https://webpack.js.org/api/cli/#debug-options](https://webpack.js.org/api/cli/#debug-options))。
- en: '|  |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 5.9\. Adding Babel loader webpack.config.js
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9\. 添加Babel加载器webpack.config.js
- en: '[PRE67]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Add module object.**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加模块对象。**'
- en: '***2* Array of all loaders to use (called rules)**'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 要使用的所有加载器数组（称为规则）**'
- en: '***3* Regular expression that determines what files should be processed by
    this loader—for Babel, we want js and jsx files.**'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 正则表达式确定哪些文件应该由这个加载器处理——对于Babel，我们希望是js和jsx文件。**'
- en: '***4* You can tell the loader to ignore files, Node.js packages are already
    compiled, so you don’t need to process them again.**'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 你可以告诉加载器忽略文件，Node.js包已经编译，因此不需要再次处理它们。**'
- en: '***5* Declare which loader should be used for this loader configuration.**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 声明应为此加载器配置使用哪个加载器。**'
- en: Loaders are applied during the resolver step of the webpack compile process.
    [Figure 5.4](kindle_split_016_split_004.xhtml#ch05fig04) shows how this fits into
    the overall webpack flow. Notice that this will happen many times, as each dependency
    may pass through one or many loaders.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器在 webpack 编译过程的解析步骤中应用。![图 5.4](kindle_split_016_split_004.xhtml#ch05fig04)
    展示了这如何融入整个 webpack 流程。请注意，这将会发生多次，因为每个依赖项可能通过一个或多个加载器。
- en: Figure 5.4\. Loaders are applied during the resolver phase of a webpack compile.
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 在 webpack 编译的解析阶段应用加载器。
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: Using custom extensions
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用自定义扩展
- en: Often when writing JSX and ES6, it’s nice to be able to declare your files with
    an extension other than .js. This indicates to other developers (and in some cases,
    to your IDE) that the file is of a specific syntax type.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写 JSX 和 ES6 时，能够用除 .js 之外的其他扩展名声明你的文件很方便。这向其他开发者（在某些情况下，向你的 IDE）表明该文件是特定语法类型。
- en: It can also be convenient to not have to write an extension on your `import`
    statements. This can be a requirement for some testing setups to work properly.
    In webpack, to cover these uses cases, you add the `resolve` property and declare
    an array of extensions to use. See the following listing.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以很方便地不必在 `import` 语句上编写扩展。这对于某些测试设置正常工作可能是必需的。在 webpack 中，为了覆盖这些用例，你添加 `resolve`
    属性并声明一个要使用的扩展数组。请参见以下列表。
- en: Listing 5.10\. Extension list webpack.config.js
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 扩展列表 webpack.config.js
- en: '[PRE68]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Add resolve object.**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 resolve 对象。**'
- en: '***2* Declare array of extensions—for calendar example, you need .js, .jsx,
    and .css.**'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明扩展数组——例如，对于日历，你需要 .js、.jsx 和 .css。**'
- en: 5.4.2\. Configuring the CSS loader
  id: totrans-690
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 配置 CSS 加载器
- en: Webpack can pack almost anything into your JavaScript bundle, including your
    CSS. This is awesome for development, but for many production use cases you’ll
    still want to load your CSS and other assets separately (don’t worry, webpack
    can do that too!). See the next listing.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 可以将几乎所有内容打包到你的 JavaScript 捆绑包中，包括你的 CSS。这对于开发来说很棒，但对于许多生产用途，你仍然希望单独加载你的
    CSS 和其他资源（别担心，webpack 也可以做到这一点！）请参见下一列表。
- en: Listing 5.11\. Including CSS with webpack—webpack.config.js
  id: totrans-692
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. 使用 webpack 包含 CSS—webpack.config.js
- en: '[PRE69]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* For this loader you need to process only CSS files, so regular expression
    looks for .css.**'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对于此加载器，你需要处理的是 CSS 文件，所以正则表达式查找 .css。**'
- en: '***2* This loader uses two webpack loaders, style-loader and CSS-loader—note
    the key has changed from loader to loaders because list is declared as array of
    strings.**'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此加载器使用两个 webpack 加载器，style-loader 和 CSS-loader—注意键已从 loader 更改为 loaders，因为列表被声明为字符串数组。**'
- en: This code adds two loaders. The CSS loader takes any `import` and `url()` references
    and interprets them as `require`. The style loader includes the styles in the
    bundle so your CSS is available in the browser.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了两个加载器。CSS 加载器将任何 `import` 和 `url()` 引用解释为 `require`。style loader 将样式包含在捆绑包中，以便你的
    CSS 可在浏览器中使用。
- en: By including the CSS, you can take advantage of the component style of writing
    your CSS. To do this, you create a set of styles for each component and namespace
    them. Then you don’t have to worry about overwriting common class names such as
    `.button` or `.active`.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含 CSS，你可以利用组件样式的编写方式。为此，你为每个组件创建一组样式并将它们命名空间化。然后你不必担心覆盖常见的类名，如 `.button`
    或 `.active`。
- en: Additionally, I’ve found this modular CSS to be easier to reason about for large
    development teams, though there are trade-offs. One major trade-off is you tend
    to end up with less DRY (don’t repeat yourself) CSS. But this can be combatted
    with shared global classes or mixins if you’re using PostCSS or other compiled
    CSS options (LESS, SASS, and so forth).
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我发现这种模块化 CSS 对于大型开发团队来说更容易理解，尽管有一些权衡。一个主要的权衡是你往往会得到更少的 DRY（不要重复自己）CSS。但如果你使用
    PostCSS 或其他编译 CSS 选项（LESS、SASS 等），可以通过共享全局类或混入来解决这个问题。
- en: Additional loaders
  id: totrans-699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他加载器
- en: Many more loaders can be used with webpack. You can load all kinds of files,
    including JSON, HTML, and image assets. You can also preprocess your preferred
    CSS using LESS/SASS/PostCSS.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多其他加载器与 webpack 一起使用。你可以加载各种文件，包括 JSON、HTML 和图像资源。你还可以使用 LESS/SASS/PostCSS
    预处理你首选的 CSS。
- en: You can also use loaders for linting. For example, if you want to use ESLint
    in your project, there’s a webpack loader for it (the example introduced in [chapter
    4](kindle_split_015_split_000.xhtml#ch04) uses ESLint). There are loaders for
    almost anything you can think of doing in a web app project!
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用加载器进行代码检查。例如，如果你想在你项目中使用 ESLint，有一个为它准备的 webpack 加载器（[第 4 章](kindle_split_015_split_000.xhtml#ch04)
    中介绍的示例使用了 ESLint）。几乎任何你可以在 web 应用程序项目中想到的事情都有加载器！
- en: For a list of webpack loaders, check out [https://webpack.js.org/loaders/](https://webpack.js.org/loaders/).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 webpack 加载器的列表，请访问 [https://webpack.js.org/loaders/](https://webpack.js.org/loaders/)。
- en: 5.5\. Bundling for dev and production
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 开发和生产的打包
- en: So far, you’ve used only a single configuration file for your development environment.
    But for a real-world app, you need to prepare your webpack configuration files
    for multiple environments.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只为你的开发环境使用了一个配置文件。但对于一个真实世界的应用，你需要为多个环境准备你的 webpack 配置文件。
- en: For simplicity, you’ll set up two environment-specific configuration files called
    dev.config.js and prod.config.js. Because these files are just JavaScript, you
    can create a base file, called base.config.js. All these files will live in the
    config folder.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，你将设置两个针对特定环境的配置文件，分别命名为 dev.config.js 和 prod.config.js。因为这些文件只是 JavaScript，你可以创建一个基础文件，命名为
    base.config.js。所有这些文件都将位于 config 文件夹中。
- en: The base file is identical to the webpack.config.js file you’ve already created
    in this chapter. The other two files require it and then extend the configuration.
    First you’ll add a webpack plugin to dev.config.js.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 基础文件与本章中已经创建的 webpack.config.js 文件相同。其他两个文件需要它，然后扩展配置。首先你将在 dev.config.js 中添加一个
    webpack 插件。
- en: 5.5.1\. Using webpack plugins
  id: totrans-707
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1\. 使用 webpack 插件
- en: A webpack plugin is an additional code module that you can include in the plugins
    array of your webpack configuration. The webpack library ships with several built-in
    plugins. Many plugins can also be found on npm, and you even can write your own
    plugin.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 插件是你可以包含在 webpack 配置的插件数组中的额外代码模块。webpack 库附带了一些内置插件。许多插件也可以在 npm 上找到，你甚至可以编写自己的插件。
- en: For the dev config, you need the html-webpack-plugin. This plugin autogenerates
    an HTML file that loads the bundled JavaScript. This is set up in the dev.config.js
    file, as shown in the following listing.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发配置，你需要 html-webpack-plugin。此插件自动生成一个加载打包 JavaScript 的 HTML 文件。这已在 dev.config.js
    文件中设置，如下所示。
- en: Listing 5.12\. Add a plugin—config/dev.config.js
  id: totrans-710
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 在 config/dev.config.js 中添加插件
- en: '[PRE70]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Require base configuration object.**'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要基础配置对象。**'
- en: '***2* Include html-webpack-plugin that will autogenerate a HTML file.**'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含 html-webpack-plugin 以自动生成 HTML 文件。**'
- en: '***3* Use Object.assign to merge environment-specific configuration onto baseConfig;
    keys from this configuration will override base configuration.**'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 Object.assign 将特定环境的配置合并到 baseConfig；此配置的键将覆盖基础配置。**'
- en: '***4* Declare environment-specific filename.**'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明特定环境的文件名。**'
- en: '***5* Declare plugins array.**'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 声明插件数组。**'
- en: '***6* Create new instance of HtmlWebpackPlugin.**'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 创建 HtmlWebpackPlugin 的新实例。**'
- en: '***7* Title property sets <title> tag in HTML template.**'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 标题属性设置 HTML 模板中的 <title> 标签。**'
- en: '***8* Output filename for generated HTML.**'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 生成 HTML 的输出文件名。**'
- en: 'To use this code, run the following command:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此代码，请运行以下命令：
- en: '[PRE71]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Then you can navigate to http://localhost:3050/bundle.html and see the dev bundle.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以导航到 http://localhost:3050/bundle.html 来查看开发包。
- en: Plugins can hook into a variety of webpack compiler steps. They can add code
    at the beginning of the compile step, during the optimization step, during the
    emit files stage, and at many other phases of the webpack compiler.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以钩入 webpack 编译器的各种步骤。它们可以在编译步骤的开始处添加代码，在优化步骤中，在文件输出阶段，以及在 webpack 编译器的许多其他阶段。
- en: The HTML webpack plugin does most of its work during the emit step because its
    main job is to create a file. The emit step is where the files are created based
    on all the previous compilation steps.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: HTML webpack 插件的大部分工作是在输出步骤中完成的，因为其主要任务是创建一个文件。输出步骤是基于所有之前的编译步骤创建文件的地方。
- en: 5.5.2\. Creating globals
  id: totrans-725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. 创建全局变量
- en: 'You can also use plugins to define environment variables. Webpack ships with
    a plugin called definePlugin that allows you to inject variables into your webpack
    module, as shown in [listing 5.13](kindle_split_016_split_005.xhtml#ch05ex13).
    You can then access these variables in code:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用插件来定义环境变量。Webpack 内置了一个名为 definePlugin 的插件，允许你将变量注入到 webpack 模块中，如[列表
    5.13](kindle_split_016_split_005.xhtml#ch05ex13)所示。然后你可以在代码中访问这些变量：
- en: '[PRE72]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'During the compile step, webpack converts the variable to the injected value.
    In this case, the code in the bundle will look like this:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译步骤中，webpack 将变量转换为注入的值。在这种情况下，包中的代码将看起来像这样：
- en: '[PRE73]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Listing 5.13\. Inject globals—config/dev.config.js
  id: totrans-730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. 注入全局变量—config/dev.config.js
- en: '[PRE74]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Require webpack because Define-Plugin is included with webpack.**'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 因为 Define-Plugin 是 webpack 内置的，所以需要引入 webpack。**'
- en: '***2* Create new instance of DefinePlugin.**'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建 DefinePlugin 的新实例。**'
- en: '***3* Inject any number of variables here—in this case, set environment value.**'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在这里注入任意数量的变量——在这种情况下，设置环境值。**'
- en: '***4* Load plugin in plugin array.**'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在插件数组中加载插件。**'
- en: 'One gotcha with DefinePlugin is that for strings, it’s important to use JSON.stringify.
    If you just assign a string (`__ENV__: "dev"`), then in the bundled version you’ll
    get the following output:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 'DefinePlugin 的问题之一是，对于字符串，使用 JSON.stringify 是很重要的。如果你只是分配一个字符串（`__ENV__: "dev"`），那么在打包版本中，你将得到以下输出：'
- en: '[PRE75]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: That will throw a `ReferenceError` in your browser because it’ll read `dev`
    as a JavaScript variable.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的浏览器中抛出一个 `ReferenceError`，因为它会将 `dev` 作为一个 JavaScript 变量来读取。
- en: 5.5.3\. Working with sourcemaps
  id: totrans-739
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3\. 使用 sourcemaps
- en: One of the drawbacks of developing with webpack is that the bundled code isn’t
    human readable and no longer resembles the source code. Fortunately for debugging,
    webpack provides the ability to enable sourcemaps. Without sourcemaps, it’s difficult
    to match code errors up to your file structure.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 webpack 开发的一个缺点是，打包后的代码不可读，并且不再类似于源代码。幸运的是，对于调试来说，webpack 提供了启用 sourcemaps
    的能力。没有 sourcemaps，很难将代码错误匹配到你的文件结构中。
- en: With sourcemaps enabled, webpack generates additional code (sometimes inline
    and sometimes in a separate file) that maps the generated code back to the original
    file structure. That’s helpful when debugging, because tools such as Chrome DevTools
    will allow you to inspect the original code rather than the compiled code. [Figure
    5.5](kindle_split_016_split_005.xhtml#ch05fig05) shows how Chrome DevTools loads
    the original file.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 sourcemaps 的情况下，webpack 会生成额外的代码（有时是内联的，有时是单独的文件），这些代码将生成的代码映射回原始文件结构。这在调试时很有帮助，因为像
    Chrome DevTools 这样的工具将允许你检查原始代码而不是编译后的代码。[图 5.5](kindle_split_016_split_005.xhtml#ch05fig05)
    展示了 Chrome DevTools 如何加载原始文件。
- en: Figure 5.5\. Chrome DevTools uses the generated sourcemaps to link the compiled
    code to the source file.
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. Chrome DevTools 使用生成的 sourcemaps 将编译后的代码链接到源文件。
- en: '![](Images/05fig05_alt.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05_alt.jpg)'
- en: Enabling sourcemaps is straightforward, as shown in [listing 5.14](kindle_split_016_split_005.xhtml#ch05ex14).
    You add the `devtool` property to your webpack configuration to enable sourcemaps
    from the webpack configuration file. According to the webpack docs, you can use
    this sourcemap option for production. For bigger projects, this can have performance
    impacts, so tread carefully.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 sourcemaps 很简单，如[列表 5.14](kindle_split_016_split_005.xhtml#ch05ex14)所示。你只需将
    `devtool` 属性添加到 webpack 配置中，即可从 webpack 配置文件中启用 sourcemaps。根据 webpack 文档，你可以使用此
    sourcemap 选项进行生产。对于更大的项目，这可能会对性能产生影响，所以请谨慎行事。
- en: Listing 5.14\. Adding sourcemaps—config/dev.config.js
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. 添加 sourcemaps—config/dev.config.js
- en: '[PRE76]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Several valid sourcemap options are available for webpack. Each one makes a
    trade-off between performance and developer readability. The option in dev.config.js
    outputs a separate map file and loads the full original source. But it’s on the
    slower side. If you need to adjust your sourcemap options, I recommend checking
    out webpack’s documentation for sourcemaps at [https://webpack.js.org/configuration/devtool/](https://webpack.js.org/configuration/devtool/).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 有几个有效的 sourcemap 选项可用。每个选项都在性能和开发者可读性之间做出权衡。dev.config.js 中的选项输出一个单独的映射文件并加载完整的原始源代码。但它在较慢的一侧。如果你需要调整
    sourcemap 选项，我建议查看 webpack 的 sourcemaps 文档[https://webpack.js.org/configuration/devtool/](https://webpack.js.org/configuration/devtool/)。
- en: Next we’ll use webpack plugins to create a production-ready configuration.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 webpack 插件创建一个生产就绪的配置。
- en: 5.5.4\. Preparing the build for production
  id: totrans-749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.4\. 准备生产构建
- en: 'To prepare a production build, you need to do a few things:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备生产构建，你需要做一些事情：
- en: 'Make the bundle as small as possible: add plugins for uglifying and deduping
    your code'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使包尽可能小：添加用于压缩和去重代码的插件
- en: Inject production environment variables
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入生产环境变量
- en: Output to a different output bundle
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出到不同的输出包
- en: The goal is to end up with a non-human-readable, minified file with the smallest
    footprint possible. It should look something like [figure 5.6](kindle_split_016_split_005.xhtml#ch05fig06).
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是最终生成一个尽可能小的、非人类可读的、最小化脚本的文件。它看起来可能像[图5.6](kindle_split_016_split_005.xhtml#ch05fig06)。
- en: Figure 5.6\. Production output compiled with additional webpack plugins
  id: totrans-755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. 使用额外的webpack插件编译的生产输出
- en: '![](Images/05fig06_alt.jpg)'
  id: totrans-756
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig06_alt.jpg)'
- en: In order to end up with production output, you will use some additional plugins
    to prepare the code. The following listing shows how to create a webpack configuration
    file that is ready for production.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终生成生产输出，你将使用一些额外的插件来准备代码。以下列表展示了如何创建一个为生产准备好的webpack配置文件。
- en: Listing 5.15\. Production build—config/prod.config.js
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.15\. 生产构建—config/prod.config.js
- en: '[PRE77]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Inject prod environment variable.**'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入生产环境变量。**'
- en: '***2* Change bundle name for current environment.**'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 修改当前环境的包名。**'
- en: '***3* Uglify your code—this both compresses and uglifies the code.**'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 压缩并丑化你的代码。**'
- en: '***4* Change filename of outputted HTML file.**'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 修改输出HTML文件的文件名。**'
- en: Plugins have many use cases and can help you with everything from configuration
    to uglifying your output. For this reason, several plugins ship with webpack that
    can help you prepare your build for production. In addition to the plugins shown
    in the preceding listing, you can read about other webpack plugins on the webpack
    site ([https://webpack.js.org/configuration/plugins/](https://webpack.js.org/configuration/plugins/))
    and the npm site ([www.npmjs.com/search?q=webpack+plugin](http://www.npmjs.com/search?q=webpack+plugin)).
    As of the latest version of webpack, deduping module includes and occurrence ordering
    are default behaviors.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 插件有许多用途，可以帮助你从配置到压缩你的输出。因此，webpack附带了一些插件，可以帮助你为生产准备你的构建。除了前面列表中显示的插件外，你还可以在webpack网站([https://webpack.js.org/configuration/plugins/](https://webpack.js.org/configuration/plugins/))和npm网站([www.npmjs.com/search?q=webpack+plugin](http://www.npmjs.com/search?q=webpack+plugin))上了解其他webpack插件。截至webpack的最新版本，模块包含去重和发生顺序是默认行为。
- en: Summary
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that webpack is a powerful build tool that can
    be used to compile your project into a browser bundle. You learned to use Babel
    on its own and as part of webpack via loaders. Both of these tools are useful
    in many JavaScript contexts and make great additions to your personal toolkit.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到webpack是一个强大的构建工具，可以用来将你的项目编译成浏览器包。你学习了如何单独使用Babel，以及作为webpack的一部分通过加载器使用Babel。这两个工具在许多JavaScript环境中都很有用，并且是个人工具箱中很好的补充。
- en: With webpack, you can compile your JavaScript code, including npm modules.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack，你可以编译你的JavaScript代码，包括npm模块。
- en: With the Babel compiler you can use the latest features of JavaScript and still
    run your code in all browsers and Node.js environments.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Babel编译器，你可以使用JavaScript的最新功能，同时仍然能在所有浏览器和Node.js环境中运行你的代码。
- en: Loaders are add-on modules for webpack that allow you to use additional tools
    such as Babel to bundle your code.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载器是webpack的附加模块，允许你使用额外的工具，如Babel来打包你的代码。
- en: CSS can be loaded and compiled via webpack using loaders.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS可以通过webpack使用加载器加载和编译。
- en: Plugins are powerful add-ons for the webpack compiler that give you access to
    many additional features, including preparing your build for production and automatically
    generating HTML wrappers for your webpack code.
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件是webpack编译器的强大附加组件，为你提供了访问许多额外功能的方法，包括为你的webpack代码准备构建和自动生成HTML包装器。
- en: Chapter 6\. Redux
  id: totrans-772
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. Redux
- en: '*This chapter covers*'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Managing your application state with Redux
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux管理你的应用程序状态
- en: Implementing Redux as an architecture pattern
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Redux作为架构模式实现
- en: Managing your application state with actions
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用actions管理你的应用程序状态
- en: Enforcing immutability with reducers
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用reducers强制不可变性
- en: Applying middleware for debugging and asynchronous calls
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用中间件进行调试和异步调用
- en: Using Redux with React
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux与React结合
- en: 'Redux is a library that provides an architecture for writing your business
    logic. With React apps, you can handle much of your application state within your
    root components. But as your application grows, you end up with a complex set
    of callbacks that need to be passed down to all the children in order to manage
    application state updates. Redux provides an alternative for storing your application
    state by doing the following:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是一个提供编写业务逻辑架构的库。在 React 应用中，你可以在根组件内处理大部分应用状态。但随着你的应用增长，你最终会得到一组复杂的回调，需要传递给所有子组件以管理应用状态更新。Redux
    通过以下方式提供存储应用状态的替代方案：
- en: Dictating a clear line of communication between your view and your business
    logic
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的视图和业务逻辑之间建立清晰的通信线路
- en: Allowing your view to subscribe to the application state so it can update each
    time the state updates
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你的视图订阅应用状态，以便每次状态更新时都能进行更新
- en: Enforcing an immutable application state
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制不可变的应用状态
- en: '|  |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: Immutable objects are read-only. To update an immutable object, you need to
    clone it. When you change an object in JavaScript, it affects all references to
    that object. This means mutable changes can have unintended side effects. By enforcing
    immutability in your store, you prevent this from happening in your app.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是只读的。要更新不可变对象，你需要克隆它。当你用 JavaScript 改变一个对象时，它会影响到对该对象的任何引用。这意味着可变更改可能产生意外的副作用。通过在你的存储中强制不可变性，你可以在你的应用中防止这种情况发生。
- en: '|  |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1\. Introduction to Redux
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. Redux 简介
- en: Redux dictates a single-directional flow of writing application state updates
    into a single root store. The store can be a simple or a complex JavaScript object
    depending on your app’s requirements. Redux handles wiring updates into the store.
    It also handles any subscribers to the store and notifies them of updates to the
    store object.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 规定了将应用状态更新写入单个根存储的单向流。存储可以是一个简单的或复杂的 JavaScript 对象，这取决于你的应用需求。Redux 处理将更新连接到存储。它还处理存储的任何订阅者，并在存储对象更新时通知他们。
- en: '|  |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: The Redux store is a *singleton* (only one instance per app) object that holds
    all your application state. The store can be passed into your view in order to
    display and update your app.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 存储是一个 *单例*（每个应用只有一个实例）对象，它包含所有你的应用状态。存储可以被传递到你的视图中以便显示和更新你的应用。
- en: '|  |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Redux can be hooked up to any view, but it works especially well with React.
    React’s top-down flow of props and state through nested components work well with
    Redux’s single-direction state update flow.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 可以连接到任何视图，但它与 React 的配合尤其出色。React 的自顶向下流通过嵌套组件的 props 和状态与 Redux 的单向状态更新流配合得很好。
- en: '|  |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: React state isn’t the same as Redux application state! React state is localized
    to each component in your app. It can be updated and affected within the React
    lifecycle. It should be used infrequently but is often needed in components that
    handle user input and sometimes in container components. [Chapter 3](kindle_split_014_split_000.xhtml#ch03)
    explains React state in more detail.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: React 的状态与 Redux 的应用状态不同！React 的状态是局部化的，位于你的应用中的每个组件。它可以在 React 生命周期内更新和受影响。它应该很少使用，但在处理用户输入的组件以及有时在容器组件中经常需要使用。[第
    3 章](kindle_split_014_split_000.xhtml#ch03) 更详细地解释了 React 的状态。
- en: '|  |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1.1\. Getting started with notifications example app
  id: totrans-799
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 从通知示例应用开始
- en: 'The code for this chapter can be found at [https://github.com/isomorphic-dev-js/chapter6-redux](https://github.com/isomorphic-dev-js/chapter6-redux).
    All the code is provided on the master branch, or you can follow along and build
    it yourself. To run the app:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 [https://github.com/isomorphic-dev-js/chapter6-redux](https://github.com/isomorphic-dev-js/chapter6-redux)
    找到。所有代码都位于 master 分支上，或者你可以跟随教程自己构建它。要运行应用：
- en: '[PRE78]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Then the app will be running at http://localhost:3000.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用将在 http://localhost:3000 运行。
- en: You’ll be building a notifications app that displays messages in three states
    (Error, Warning, or Success). The idea is that the app receives updates from various
    paging apps, continuous integration build tools, and other systems (think GitHub,
    TravisCI, CircleCI, VictorOps, PagerDuty, and so forth). It then displays the
    notifications in the appropriate shelf. The app also has a settings panel that
    can be updated and a debug panel that lets you dispatch notifications for testing.
    [Figure 6.1](kindle_split_017_split_001.xhtml#ch06fig01) shows the running application.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 你将构建一个显示消息处于三种状态（错误、警告或成功）的通知应用程序。想法是应用程序从各种分页应用程序、持续集成构建工具和其他系统（如 GitHub、TravisCI、CircleCI、VictorOps、PagerDuty
    等）接收更新。然后，它在适当的架子上显示通知。应用程序还有一个可以更新的设置面板和一个调试面板，允许你分发通知进行测试。[图 6.1](kindle_split_017_split_001.xhtml#ch06fig01)
    展示了正在运行的应用程序。
- en: Figure 6.1\. Notifications update app—send and receive notifications
  id: totrans-804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 通知更新应用程序—发送和接收通知
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig01_alt.jpg)'
- en: The code has some React components and webpack already set up. I’m not going
    to spend much time on these topics so you can stay focused on learning Redux.
    If you want to review React, you can review [chapters 3](kindle_split_014_split_000.xhtml#ch03)
    and [4](kindle_split_015_split_000.xhtml#ch04). For webpack, review [chapter 5](kindle_split_016_split_000.xhtml#ch05).
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中已经设置了一些 React 组件和 webpack。我不会在这些主题上花费太多时间，这样你可以专注于学习 Redux。如果你想复习 React，可以查看[第
    3 章](kindle_split_014_split_000.xhtml#ch03)和[第 4 章](kindle_split_015_split_000.xhtml#ch04)。对于
    webpack，请查看[第 5 章](kindle_split_016_split_000.xhtml#ch05)。
- en: Also note that there’s an in-memory object on the Node server that backs up
    the simple CRUD (create, read, update, delete) service for this project. If you
    were to build this in the real world, you’d want to explore using a WebSocket
    connection and connect a database. The “Send a notification” section of the interface
    allows you to emulate the app receiving alerts from services without having to
    hook it up to any real inputs.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在 Node 服务器上有一个内存对象，它为这个项目的简单 CRUD（创建、读取、更新、删除）服务提供备份。如果你要在现实世界中构建这个项目，你将想要探索使用
    WebSocket 连接并连接数据库。界面中的“发送通知”部分允许你模拟应用程序接收来自服务的警报，而无需将其连接到任何真实输入。
- en: 6.1.2\. Redux overview
  id: totrans-808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. Redux 概述
- en: 'In the first part of this chapter, we’ll walk through all the pieces of Redux
    that are required to get updates flowing in your application. [Figure 6.2](kindle_split_017_split_001.xhtml#ch06fig02)
    reviews Redux’s single-direction update flow in the context of the notifications
    app and introduces you to the three main parts of Redux:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将遍历 Redux 中所有必需的组件，以便在你的应用程序中实现更新流动。[图 6.2](kindle_split_017_split_001.xhtml#ch06fig02)
    在通知应用程序的上下文中回顾了 Redux 的单向更新流程，并介绍了 Redux 的三个主要部分：
- en: '***Actions*—** Implement business logic, things like updating settings or adding
    new notifications to the list'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***动作*—** 实现业务逻辑，例如更新设置或向列表中添加新通知'
- en: '***Reducers*—** Write state changes triggered by actions to the store'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***还原器*—** 将由动作触发的状态更改写入存储'
- en: '***Store*—** Current application state, holds the notification array and the
    values of any settings for the app'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***存储*—** 当前应用程序状态，包含通知数组和应用程序的任何设置值'
- en: Figure 6.2\. Redux single-direction flow from view
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. Redux 单向流程从视图
- en: '![](Images/06fig02_alt.jpg)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig02_alt.jpg)'
- en: Connecting React and Redux
  id: totrans-815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接 React 和 Redux
- en: In the second part of this chapter, you’ll learn how to use the React Redux
    library to connect your React view to your Redux application state. This includes
    using a top-level component provided by the library called Provider that takes
    in the store and makes it available to another component called connect. The connect
    component is a higher-order component that wraps some components in your application.
    These wrapped components are then able to receive store updates in the form of
    properties. The connect component has React state, so your other components don’t
    need to have React state! [Figure 6.3](kindle_split_017_split_001.xhtml#ch06fig03)
    illustrates how these pieces fit into your application structure.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，你将学习如何使用 React Redux 库将你的 React 视图连接到 Redux 应用程序状态。这包括使用库提供的顶层组件 Provider，它接收存储并将其提供给另一个名为
    connect 的组件。connect 组件是一个高阶组件，它包装了你的应用程序中的某些组件。这些包装组件随后能够以属性的形式接收存储更新。connect
    组件具有 React 状态，因此你的其他组件不需要有 React 状态！[图 6.3](kindle_split_017_split_001.xhtml#ch06fig03)
    展示了这些组件如何融入你的应用程序结构。
- en: Figure 6.3\. Using React Redux’s Provider and connect components to hook up
    the React view with the application state
  id: totrans-817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 使用React Redux的Provider和connect组件将React视图与应用程序状态连接起来
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig03_alt.jpg)'
- en: 6.2\. Redux as an architecture pattern
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. Redux 作为一种架构模式
- en: Often, when building web applications, you use a Model-View-Controller (MVC)
    pattern. Many common frameworks use this pattern. In this case, there’s a view,
    the HTML of the application, a model that’s some sort of representation of application
    state, and a controller that’s the interface that the user interacts with. The
    business logic is also handled by the controller.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在构建Web应用程序时，你会使用模型-视图-控制器（MVC）模式。许多常见的框架都使用这种模式。在这种情况下，有一个视图，即应用程序的HTML，一个模型，它代表应用程序状态的一种表示，以及一个控制器，它是用户与之交互的界面。业务逻辑也由控制器处理。
- en: Frameworks such as Angular 1 and Ember each have their own implementations of
    MVC but historically have used two-way binding to handle the View-Controller part
    of the framework. The flow of Angular 1 differs from the traditional MVC in that
    the view is really a View-Controller (always the same as a container component,
    as we discussed in [chapter 3](kindle_split_014_split_000.xhtml#ch03)). But the
    framework still tries to follow an MVC pattern. This leads to confusing flows
    and hard-to-debug code.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Angular 1和Ember这样的框架各自有自己的MVC实现，但历史上它们都使用双向绑定来处理框架的视图控制器部分。Angular 1的流程与传统MVC不同，因为视图实际上是一个视图控制器（始终与容器组件相同，如我们在[第3章](kindle_split_014_split_000.xhtml#ch03)中讨论的）。但框架仍然试图遵循MVC模式。这导致流程混乱和难以调试的代码。
- en: Let’s walk through what this would look like if we applied it to the app you’re
    going to build in this chapter. [Figure 6.4](kindle_split_017_split_002.xhtml#ch06fig04)
    shows how the application flow works in this case.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看，如果我们将这种模式应用到本章将要构建的应用程序中，会是什么样子。[图6.4](kindle_split_017_split_002.xhtml#ch06fig04)展示了在这种情况下应用程序流程的工作方式。
- en: Figure 6.4\. Model-View-Controller (MVC) flow in Angular 1
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. Angular 1中的模型-视图-控制器（MVC）流程
- en: '![](Images/06fig04_alt.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig04_alt.jpg)'
- en: 'Redux’s implementation has some overlap with MVC. I like to think of it as
    an evolution of MVC that works better for UI-based apps (as opposed to services/CRUD
    apps). There are a few major differences:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的实现与MVC有一些重叠。我喜欢将其视为MVC的一种演变，它更适合基于UI的应用程序（与服务/CRUD应用程序相反）。有几个主要区别：
- en: Redux insists on a single-directional data flow resulting in easier-to-follow
    code and no side effects.
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux坚持单向数据流，导致代码易于跟踪且没有副作用。
- en: There are no controllers. Rather, the views are also the controllers—called
    *view-controllers*. In this case, the View-Controller is React. This fits into
    the browser model well, where the view is rendered by the HTML and where user
    events are handled by the DOM.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有控制器。相反，视图也是控制器——称为*视图控制器*。在这种情况下，视图控制器是React。这很好地适应了浏览器模型，其中视图由HTML渲染，用户事件由DOM处理。
- en: In Redux, there’s always only one single root store, which represents the application
    state. That simplifies much of the logic, because views need to subscribe only
    to the root store and then pay attention to the specific subtrees they’re interested
    in.
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redux中，始终只有一个单一的根存储，它代表应用程序状态。这简化了大部分逻辑，因为视图只需要订阅根存储，然后关注它们感兴趣的特定子树。
- en: Redux flow relies on the store to dispatch actions. The `dispatch` function
    is a hook into the root store that allows you to trigger actions on the store.
    Sometimes you’ll be triggering synchronous updates to the store and sometimes
    you’ll be triggering an asynchronous call that will eventually update the store.
    Additionally, views are able to subscribe to the store and be notified when an
    update is complete. [Figure 6.5](kindle_split_017_split_002.xhtml#ch06fig05) illustrates
    this flow.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: Redux流程依赖于存储来分发动作。`dispatch`函数是根存储的一个钩子，允许你在存储上触发动作。有时你会触发对存储的同步更新，有时你会触发一个最终会更新存储的异步调用。此外，视图能够订阅存储，并在更新完成后收到通知。[图6.5](kindle_split_017_split_002.xhtml#ch06fig05)说明了这个流程。
- en: Figure 6.5\. Redux flow when initiated by a user action
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 由用户动作触发的Redux流程
- en: '![](Images/06fig05_alt.jpg)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig05_alt.jpg)'
- en: Redux implementation (the part of the code you’ll write) is made up of the store,
    the actions, and the reducers. The store holds your application state. The actions
    take care of your business logic. The reducers are called to update the store.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: Redux实现（您将编写的代码部分）由store、actions和reducers组成。store保存您的应用程序状态。actions负责您的业务逻辑。reducer被调用以更新store。
- en: '|  |'
  id: totrans-833
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: The *store* in Redux is the model of your application. It holds the current
    state of your application. I’ll use *store* and *state* interchangeably to talk
    about the model in Redux.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: Redux中的*store*是您的应用程序模型。它保存应用程序的当前状态。我将使用*store*和*state*互换来说明Redux中的模型。
- en: '|  |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To recap, Redux provides a concrete pattern for managing your application’s
    state that’s easy to use as a developer. It also makes reasoning about and debugging
    your application straightforward.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，Redux为管理您的应用程序状态提供了一个具体模式，这对于开发者来说易于使用。它还使推理和调试您的应用程序变得简单。
- en: 6.3\. Managing application state
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 管理应用程序状态
- en: The primary job of Redux is to allow your state (or model) and the view to communicate.
    This is achieved by allowing the view to subscribe to state updates and trigger
    updates on the state. [Figure 6.6](kindle_split_017_split_003.xhtml#ch06fig06)
    shows this flow in the context of the sample app.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的主要任务是允许您的状态（或模型）和视图进行通信。这是通过允许视图订阅状态更新并触发状态更新来实现的。[图6.6](kindle_split_017_split_003.xhtml#ch06fig06)显示了在示例应用程序上下文中的此流程。
- en: Figure 6.6\. The flow of information between the view and Redux
  id: totrans-840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 视图和Redux之间的信息流
- en: '![](Images/06fig06_alt.jpg)'
  id: totrans-841
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig06_alt.jpg)'
- en: 'Redux state can be a plain JavaScript object. The store (which contains the
    state object) has several methods that can be called on it. Here are the ones
    I’ll cover:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: Redux状态可以是普通的JavaScript对象。包含状态对象的store有多个可以在其上调用的方法。以下是我将介绍的方法：
- en: '**`dispatch(action)`—** Triggers an update on the store (step 1 in [figure
    6.6](kindle_split_017_split_003.xhtml#ch06fig06)).'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`dispatch(action)`—** 触发store上的更新（[图6.6](kindle_split_017_split_003.xhtml#ch06fig06)中的步骤1）。'
- en: '**`getState()`—** Returns the current store object ([listing 6.1](kindle_split_017_split_003.xhtml#ch06ex01)
    shows what this looks like)'
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`getState()`—** 返回当前store对象（[列表6.1](kindle_split_017_split_003.xhtml#ch06ex01)显示了其外观）'
- en: '**`subscribe()`—** Listens to changes on the store (step 2 in [figure 6.6](kindle_split_017_split_003.xhtml#ch06fig06))'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`subscribe()`—** 监听store上的变化（[图6.6](kindle_split_017_split_003.xhtml#ch06fig06)中的步骤2）。'
- en: After actions are dispatched to the store, the state will match the code in
    the following listing.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在将操作派发到store后，状态将匹配以下列表中的代码。
- en: Listing 6.1\. An example store object (application state)
  id: totrans-847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 示例存储对象（应用程序状态）
- en: '[PRE79]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* Inside root store, you can set up substores—this app has stores for notifications
    and settings.**'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在根存储中，您可以设置子存储—此应用程序有通知和设置的存储。**'
- en: '***2* The all array holds active notifications for your app.**'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 所有数组包含您应用程序的活动通知。**'
- en: '***3* Inside root store, you can set up substores—this app has stores for notifications
    and settings.**'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在根存储中，您可以设置子存储—此应用程序有通知和设置的存储。**'
- en: '***4* The refresh property lets the user set the rate of long polling for updates.**'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* refresh属性允许用户设置更新长轮询的速率。**'
- en: Redux provides a way to initialize the state (store). It manages the flow of
    updates to the store and notifies subscribers (the view). To configure the store
    in your app, you need to create your reducers and then initialize the store with
    them. The following listing shows how this works; you can find this code in src/init-redux.es6
    in the repo.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Redux提供了一种初始化状态（store）的方法。它管理store的更新流，并通知订阅者（视图）。要在您的应用程序中配置store，您需要创建您的reducer，然后使用它们初始化store。以下列表显示了这是如何工作的；您可以在repo中的src/init-redux.es6中找到此代码。
- en: Listing 6.2\. Initialize Redux—src/init-redux.es6
  id: totrans-854
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2\. 初始化Redux—src/init-redux.es6
- en: '[PRE80]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Import helper methods from Redux.**'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从Redux导入辅助方法。**'
- en: '***2* Import app reducers.**'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入应用程序reducer。**'
- en: '***3* Export function that can be called from other modules (makes it reusable
    so it can be called from browser and server in isomorphic app).**'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导出可以从其他模块调用的函数（使其可重用，因此可以从同构应用程序的浏览器和服务器调用）。**'
- en: '***4* Call combineReducers helper method from Redux; builds map of reducers
    from multiple reducers.**'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从Redux调用combineReducers辅助方法；从多个reducer构建reducer映射。**'
- en: '***5* Call createStore, pass in combined reducers—here you’ll have store.notifications
    and store.settings.**'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用createStore，传入组合的reducer—这里您将拥有store.notifications和store.settings。**'
- en: If you aren’t using Redux with React (later in the chapter you’ll learn how
    to use redux-react to wire the two libraries together), you need to subscribe
    to store updates manually. The `subscribe` function works like a standard JavaScript
    event handler. You pass in a function that gets called every time a store update
    occurs. But the store doesn’t pass its state to the update handler function; instead,
    you call `getState()` to access the current state. The following listing shows
    an example of this code, which you can find in main.jsx.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用Redux与React（本章后面你将学习如何使用redux-react将两个库连接起来），你需要手动订阅store更新。`subscribe`函数像一个标准的JavaScript事件处理器。你传入一个函数，每次store更新时都会被调用。但store不会将其状态传递给更新处理器函数；相反，你调用`getState()`来访问当前状态。以下列表显示了此代码的示例，你可以在main.jsx中找到它。
- en: Listing 6.3\. Subscribe to store, without React Redux—src/main.jsx
  id: totrans-862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 使用React Redux之外的订阅store—src/main.jsx
- en: '[PRE81]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* Initialize store (see [listing 6.2](kindle_split_017_split_003.xhtml#ch06ex02)).**'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始化store（见[列表6.2](kindle_split_017_split_003.xhtml#ch06ex02)）。**'
- en: '***2* Call the subscribe() method on the store and pass in a function to handle
    updates.**'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在store上调用subscribe()方法，并传入一个处理更新的函数。**'
- en: '***3* Log the current state of the store by calling getState().**'
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过调用getState()记录store的当前状态。**'
- en: Next you’ll write a reducer and learn about maintaining immutability in Redux.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将编写一个reducer，并了解如何在Redux中保持不可变性。
- en: '6.3.1\. Reducers: updating the state'
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '6.3.1\. Reducers: 更新状态'
- en: Reducers have a special name, but when broken down, they’re pure functions.
    Each reducer takes in the store and an action and returns a new, modified store.
    [Figure 6.7](kindle_split_017_split_003.xhtml#ch06fig07) shows the functional
    nature of a reducer function.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers有一个特殊的名字，但分解开来，它们是纯函数。每个reducer接收store和一个action，并返回一个新的、修改后的store。[图6.7](kindle_split_017_split_003.xhtml#ch06fig07)显示了reducer函数的功能性。
- en: Figure 6.7\. The input and output flow of a pure reducer function
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 纯reducer函数的输入和输出流程
- en: '![](Images/06fig07_alt.jpg)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig07_alt.jpg)'
- en: The reducers in the notifications application are the wiring between the actions
    and the store. They’re the only part of your code that should ever write updates
    to the store. Any other code that writes to the store is an antipattern. The following
    listing shows the reducer function for settings.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 通知应用中的reducer是动作和store之间的连接线。它们是唯一应该写入store更新的代码部分。任何其他写入store的代码都是反模式。以下列表显示了settings的reducer函数。
- en: Listing 6.4\. Settings reducers—src/settings-state
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 设置reducers—src/settings-state
- en: '[PRE82]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Include the string constant for the action.**'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含动作的字符串常量。**'
- en: '***2* Function definition—each reducer takes two parameters, the store state
    and action. If the state doesn’t exist, default it to empty object.**'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 函数定义—每个reducer接受两个参数，store状态和action。如果状态不存在，默认为空对象。**'
- en: '***3* Use switch statement to declare your reducer logic—always determine which
    case to run based on value of action.type.**'
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用switch语句声明你的reducer逻辑—始终根据action.type的值确定要运行的case。**'
- en: '***4* When the refresh value is updated, use the spread operator to copy and
    create new store to maintain immutability.**'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当刷新值更新时，使用扩展运算符来复制并创建新的store以保持不可变性。**'
- en: '***5* If no case matches, still return the store because this is a pure function.**'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果没有匹配的case，仍然返回store，因为这仍然是一个纯函数。**'
- en: 'There are two important points to understand about reducers:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 关于reducers，有两个重要点需要理解：
- en: '***Reducers must always be pure functions*—** They take in values, use those
    values to create a new store, and then return a store.'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Reducer必须始终是纯函数*—** 它们接收值，使用这些值创建一个新的store，然后返回一个store。'
- en: '***Reducers must enforce the immutable nature of the store*—** The store received
    by the function must be cloned if it needs to be updated.'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Reducer必须强制store的不可变性质*—** 如果需要更新，函数接收到的store必须被克隆。'
- en: Both concepts prevent unintended side effects. The next sections explain pure
    functions and immutability.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念都防止了意外的副作用。接下来的几节将解释纯函数和不可变性。
- en: Pure functions
  id: totrans-884
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 纯函数
- en: One of the most important parts of writing reducers is making sure the function
    stays pure (no side effects). *Pure* functions take in arguments that are used
    to calculate the return value—they don’t use any state or do work on state. Code
    without side effects has many benefits, including being more testable and easier
    to understand and preventing hard-to-debug issues. Let’s take a look at an example
    of a function with side effects and then compare it to a pure function. The following
    listing shows the difference between a pure and not pure function.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 编写还原器最重要的部分之一是确保函数保持纯函数（没有副作用）。*纯*函数接受用于计算返回值的参数—they 不使用任何状态或对状态进行操作。没有副作用的代码有许多好处，包括更易于测试、更容易理解和防止难以调试的问题。让我们看看一个有副作用的函数示例，然后将其与纯函数进行比较。以下列表显示了纯函数和非纯函数之间的区别。
- en: Listing 6.5\. Pure function example
  id: totrans-886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 纯函数示例
- en: '[PRE83]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* Function doesn’t return anything, but updates the value of result.**'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数不返回任何内容，但更新 result 的值。**'
- en: '***2* When add is called in this case, you can log the result to see what happened
    (global state).**'
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当在这种情况下调用 add 时，您可以记录结果以查看发生了什么（全局状态）。**'
- en: '***3* In this function, result of add is returned.**'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在这个函数中，返回 add 的结果。**'
- en: '***4* This time log result of calling add function—there’s no state.**'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这次记录调用 add 函数的结果——没有状态。**'
- en: Enforcing the immutable store
  id: totrans-892
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制不可变存储
- en: Another way to keep your code easy to understand and debug is to make sure the
    app state (or the store) is always immutable. The risk of not enforcing immutability
    is that you end up with issues that are difficult to track down and caused by
    changes in other parts of your code. By creating a new object each time, you ensure
    that other code won’t accidentally change the whole app state.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使代码易于理解和调试的方法是确保应用状态（或存储）始终是不可变的。不强制不可变性的风险是您最终会遇到难以追踪的问题，这些问题是由代码其他部分的变化引起的。通过每次创建一个新对象，您确保其他代码不会意外地更改整个应用状态。
- en: You need to pay attention to a few things in order to enforce immutability in
    your store. Let’s start with how to make sure your objects stay immutable, as
    shown in the following listing.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的存储中强制不可变性，您需要注意几个事项。让我们从如何确保您的对象保持不可变开始，如下所示。
- en: Listing 6.6\. Mutating vs. immutable object
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. 可变对象与不可变对象
- en: '[PRE84]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* Function declaration that takes three params: item, key, and state**'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数声明，接受三个参数：项目、键和状态**'
- en: '***2* In the bad example, item is inserted directly into the state object,
    then the state is returned.**'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在不良示例中，项目直接插入到状态对象中，然后返回状态。**'
- en: '***3* In the good example, the object is cloned using spread operator, which
    takes state that was passed in and creates the object with its keys. Then the
    new copied object is returned.**'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在良好示例中，使用展开运算符克隆对象，它接受传入的状态并创建具有其键的对象。然后返回新复制的对象。**'
- en: Here, you can see that the immutable way of returning the store object involves
    the JavaScript function spread operator. You create a new object by spreading
    the old object and then adding any new or updated keys. The new keys will overwrite
    the old. But if you have a deeply nested object, you need to build the full object
    here or use a helper library to manage deeply nested keys.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到不可变方式返回存储对象涉及 JavaScript 函数展开运算符。您通过展开旧对象并添加任何新或更新的键来创建一个新对象。新键将覆盖旧键。但是，如果您有一个深度嵌套的对象，您需要在这里构建完整的对象或使用辅助库来管理深度嵌套的键。
- en: Similarly, arrays need to be kept immutable. With arrays, pushing directly into
    the array is a mutation, so it’s necessary to create a new array instead. The
    following listing demonstrates the wrong and the right way to do this.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，数组也需要保持不可变。对于数组，直接将项目推入数组是一个可变操作，因此需要创建一个新数组。以下列表演示了如何正确和不正确地执行此操作。
- en: Listing 6.7\. Immutable arrays
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. 不可变数组
- en: '[PRE85]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Pushes item into array, returns original array—this is a mutation.**'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将项目推入数组，返回原始数组——这是一个可变操作。**'
- en: '***2* Shows immutable way: return brand-new array with items from original
    array and new item; uses spread operator to push items into an array.**'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示不可变方法：返回包含原始数组和新项目的全新数组；使用展开运算符将项目推入数组。**'
- en: '6.3.2\. Actions: triggering state updates'
  id: totrans-906
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 动作：触发状态更新
- en: Actions are the only way to trigger an update to your application state in a
    Redux application. This is important to ensure that your app enforces the single-direction
    flow. (It’s technically possible to update the store directly, but you should
    *never* do that). Only reducers triggered by actions should update the state.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 应用程序中，动作是触发应用程序状态更新的唯一方式。这很重要，以确保你的应用程序强制执行单向流。（技术上可以直接更新 store，但你绝对不应该这样做）。只有由动作触发的
    reducer 应该更新状态。
- en: Because actions are synchronous by default, any update that needs to be made
    can happen quickly. In fact, the dispatcher itself is completely synchronous.
    By default, Redux supports only synchronous actions. (Later in this chapter, you’ll
    learn to use middleware with Redux in order to allow asynchronous actions.)
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 因为默认情况下动作是同步的，所以任何需要进行的更新都可以快速发生。实际上，分发器本身是完全同步的。默认情况下，Redux 只支持同步动作。（在本章的后面，你将学习如何使用中间件与
    Redux 一起使用，以便允许异步动作。）
- en: '|  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can’t dispatch an action from a reducer. That breaks the single-directional
    flow of Redux and could lead to unwanted side effects. Don’t worry, Redux won’t
    let you do it, but it’s important to avoid thinking about updates in that way.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能从 reducer 中分发动作。这会破坏 Redux 的单向流，并可能导致不希望出现的副作用。不用担心，Redux 不会让你这样做，但避免以那种方式思考更新是很重要的。
- en: '|  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The simplest action is an object with one property called `type`:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的操作是一个具有一个名为 `type` 的属性的物体：
- en: '[PRE86]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Actions will often be objects that contain data to be updated in the store in
    addition to the `type` property. Because most actions in your application will
    be reused by more than one view, it’s recommended to create reusable functions
    called *action creators* that return the action you want to dispatch.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 动作通常是包含要更新 store 中的数据以及 `type` 属性的对象。因为你的应用程序中的大多数动作都将被多个视图重用，所以建议创建可重用的函数，称为
    *动作创建者*，它返回你想要分发的动作。
- en: Action creator files are also a good place to define your string constants for
    actions. This reduces errors by ensuring that the action creator dispatches the
    same action type value the reducer is looking for. This can also lead to gains
    in developer speed in some IDEs if you have static type checking or similar features
    enabled.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建者文件也是定义你的动作字符串常量的好地方。这通过确保动作创建者分发的动作类型值与 reducer 寻找的相同来减少错误。如果你启用了静态类型检查或类似功能，这也可以在某些
    IDE 中提高开发者的速度。
- en: You can see these two concepts in the next listing. This code can be found in
    the repo as well. The listing shows an action for updating the time interval for
    the long polling functionality of the app.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下一个列表中看到这两个概念。此代码可以在存储库中找到。列表显示了一个用于更新应用程序长轮询功能的超时时间间隔的动作。
- en: Listing 6.8\. Synchronous actions—src/settings-action-creators.es6
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8. 同步动作——src/settings-action-creators.es6
- en: '[PRE87]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* Setting type value to a constant reduces errors**'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将类型值设置为常量可以减少错误**'
- en: '***2* Action creator function declaration takes one parameter called time.**'
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 动作创建者函数声明接受一个名为 time 的参数。**'
- en: '***3* Returned action has two properties—type property is required and its
    value is always a string.**'
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回的动作有两个属性——type 属性是必需的，其值始终是一个字符串。**'
- en: '***4* The time property is added to the action so that the value can be used
    by the view when it updates—each action will have different data properties.**'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将时间属性添加到动作中，以便在更新时视图可以使用该值——每个动作将具有不同的数据属性。**'
- en: 'You can use the `const` in the first line from the reducer to ensure that the
    action creator and the reducer point at the same value. To dispatch this update
    to the store, all you have to do is call `dispatch` on `store` and pass in the
    action. Because you’re using an action creator, you call the action creator and
    pass the result into `dispatch`:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 reducer 的第一行使用 `const` 来确保动作创建者和 reducer 指向相同的值。要向 store 分发此更新，你只需要在 `store`
    上调用 `dispatch` 并传递动作。因为你在使用动作创建者，所以你调用动作创建者并将结果传递给 `dispatch`：
- en: '[PRE88]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The reducer will then be triggered, and the store will be updated.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，reducer 将被触发，并且 store 将被更新。
- en: Next, you’ll learn how to set up Redux with middleware so you can include additional
    functionality such as making asynchronous calls.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何设置 Redux 与中间件一起使用，这样你就可以包含额外的功能，例如进行异步调用。
- en: 6.4\. Applying middleware to Redux
  id: totrans-928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4. 将中间件应用于 Redux
- en: 'Redux includes a helper method that lets you extend the default functionality
    of the dispatcher. For every middleware you apply to the dispatcher, it adds a
    function to the chain of calls that will happen before the final default dispatch
    behavior. Here’s a simplified example of what that looks like:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 包含一个辅助方法，允许你扩展派发器的默认功能。对于你应用到派发器的每个中间件，它都会向调用链中添加一个函数，该函数将在最终默认派发行为之前发生。以下是一个简化的示例：
- en: '[PRE89]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This allows you to add functionality for debugging and making asynchronous calls.
    First, let’s look at how you add debugging.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你添加调试和异步调用的功能。首先，让我们看看如何添加调试。
- en: '6.4.1\. Middleware basics: debugging'
  id: totrans-932
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 中间件基础：调试
- en: It’s possible to add improved debugging with middleware. One example of this
    is the Redux Logger library. This library helps you see the state changes clearly
    in the console. [Figure 6.8](kindle_split_017_split_004.xhtml#ch06fig08) shows
    sample action logs.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中间件可以添加改进的调试功能。一个例子是 Redux Logger 库。这个库可以帮助你在控制台中清晰地看到状态变化。[图 6.8](kindle_split_017_split_004.xhtml#ch06fig08)
    展示了示例动作日志。
- en: Figure 6.8\. Redux Logger console output
  id: totrans-934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.8\. Redux Logger 控制台输出
- en: '![](Images/06fig08_alt.jpg)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig08_alt.jpg)'
- en: You add middleware when you instantiate your store. The following listing shows
    how to do that. The code can also be found in the repo.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 你在实例化 store 时添加中间件。以下列表显示了如何进行操作。代码也可以在仓库中找到。
- en: Listing 6.9\. Setting up middleware—src/init-redux.es6
  id: totrans-937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 设置中间件—src/init-redux.es6
- en: '[PRE90]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* Create middleware array so you can pass an arbitrary number of middleware
    and easily control the order.**'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建中间件数组，这样你可以传递任意数量的中间件并轻松控制顺序。**'
- en: '***2* Call compose and pass in the store so the middleware will be applied
    to store.**'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用 compose 并传入 store，以便中间件应用于 store。**'
- en: '***3* Call applyMiddleware on middleware array to set up middleware properly**'
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在中间件数组上调用 applyMiddleware 以正确设置中间件**'
- en: When you run the app, you’ll see the logging in the console; this is helpful
    for debugging.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用时，你会在控制台看到日志；这对于调试很有帮助。
- en: 6.4.2\. Handling asynchronous actions
  id: totrans-943
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 处理异步动作
- en: Earlier in the chapter, you dispatched actions by writing functions that return
    an action object. As stated previously, we call those functions action creators.
    *Asynchronous action creators* apply the same principles, but instead of immediately
    returning the object, they wait for something to happen (for example, a network
    call to complete) and then return the action object.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你通过编写返回动作对象的函数来分发动作。正如之前所述，我们称这些函数为动作创建器。*异步动作创建器*应用相同的原理，但它们不会立即返回对象，而是等待某个事件发生（例如，网络调用完成）然后返回动作对象。
- en: To do that, you need access to the `dispatch` object inside your action creator
    function. This requires another middleware library, called Redux Thunk. To use
    the middleware, you need to add it to the middleware array in init-redux.es6 (refer
    to [listing 6.9](kindle_split_017_split_004.xhtml#ch06ex09)). It’s already in
    the code in the repo.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要访问动作创建器函数内部的 `dispatch` 对象。这需要另一个中间件库，称为 Redux Thunk。要使用中间件，你需要将其添加到
    init-redux.es6 中的中间件数组中（参考[列表 6.9](kindle_split_017_split_004.xhtml#ch06ex09)）。它已经在代码仓库中的代码里了。
- en: 'Then to take advantage of this middleware, you write an action creator that
    looks like this:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了利用这个中间件，你编写一个看起来像这样的动作创建器：
- en: '[PRE91]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: By adding the Thunk middleware, you can now access the `dispatch` function on
    the store inside your action creator (all the middleware does is provide the `dispatch`
    parameter to your returned function). Note that you also need to export your action
    creator and the corresponding `const` for the action. This is identical to earlier
    in the chapter, when you created a synchronous action creator.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 Thunk 中间件，你现在可以在动作创建器中的 store 内访问 `dispatch` 函数（中间件所做的只是将 `dispatch` 参数提供给你的返回函数）。请注意，你还需要导出你的动作创建器和相应的动作
    `const`。这与本章早些时候创建的同步动作创建器相同。
- en: 'In the notifications app, you need three asynchronous actions: adding a notification,
    fetching the notifications, and deleting a notification. The following listing
    shows the Fetch Notifications action creator. The code can be found in the repo
    along with other action creators.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在通知应用中，你需要三个异步动作：添加通知、获取通知和删除通知。以下列表显示了获取通知的动作创建器。代码可以在仓库中找到，与其他动作创建器一起。
- en: Listing 6.10\. Asynchronous action creators—src/action-creators.es6
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 异步动作创建器—src/action-creators.es6
- en: '[PRE92]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* Use isomorphic fetch so both server and browser can handle the fetch
    call.**'
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 isomorphic fetch，以便服务器和浏览器都可以处理 fetch 调用。**'
- en: '***2* Const for action type**'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 动作类型的 Const**'
- en: '***3* The action creator returns a function instead of an object. Thunk middleware
    calls this function and injects the dispatch method from store.**'
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 动作创建器返回一个函数而不是一个对象。Thunk 中间件调用此函数并注入存储中的 dispatch 方法。**'
- en: '***4* Create headers to talk to the API.**'
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建标题以与 API 通信。**'
- en: '***5* Call fetch with URL and options.**'
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 URL 和选项调用 fetch。**'
- en: '***6* Promise handler**'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* Promise 处理器**'
- en: '***7* Get JSON out of the response—because this is also a promise, add second
    promise handler.**'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 从响应中获取 JSON—因为这也是一个 promise，添加第二个 promise 处理器。**'
- en: '***8* After you have data, dispatch the action**'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 获取数据后，分发操作**'
- en: Now that you’ve seen how the Redux reducers and actions work, let’s go over
    how to hook up React and Redux.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了 Redux 红ucer 和动作是如何工作的，让我们来看看如何将 React 和 Redux 连接起来。
- en: 6.5\. Using Redux with React components
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 在 React 组件中使用 Redux
- en: In a React app, the actions are typically dispatched from components. To have
    access to the store in a component, you need to wire up your React components
    to Redux. I recommend using the react-redux library, which is provided by the
    author of Redux as the official bindings for React. It implements all the code
    necessary to subscribe to and receive updates from the Redux store.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用中，操作通常是从组件中分发的。为了在组件中访问存储，你需要将你的 React 组件连接到 Redux。我建议使用 react-redux
    库，这是 Redux 作者提供的官方 React 绑定。它实现了订阅和接收 Redux 存储更新的所有必要代码。
- en: There are two distinct parts to this. One is a top-level root component called
    Provider. The other is a higher-order component (HOC) called connect.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个不同的部分。一个是顶级根组件，称为 Provider。另一个是高阶组件（HOC），称为 connect。
- en: 6.5.1\. Wrapping your app with provider
  id: totrans-964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1\. 使用 provider 包装你的应用
- en: First, you need to pass the store into your app. You want to pass it down as
    a React prop. Remember, React components have a property called `props`. The `props`
    object is created by passing down values from the parent React component to its
    children. This object is immutable and can be changed only from the parent component.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将存储传递到你的应用中。你希望将其作为 React 属性向下传递。记住，React 组件有一个名为 `props` 的属性。`props`
    对象是通过从父 React 组件向下传递值到其子组件而创建的。此对象是不可变的，只能从父组件中更改。
- en: Because you also want to be able to subscribe to the store, you should use the
    Provider component that comes with React Redux. This React component acts as the
    root of your application and makes the store available to the connect HOC. The
    following listing shows how to do this.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你也想能够订阅存储，所以你应该使用 React Redux 中的 Provider 组件。这个 React 组件作为你应用的根组件，使存储对 connect
    HOC 可用。以下列表显示了如何做到这一点。
- en: Listing 6.11\. Connecting Redux to React—src/main.jsx
  id: totrans-967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 将 Redux 连接到 React—src/main.jsx
- en: '[PRE93]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* The component takes in the store and properly passes it to its children.**'
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 组件接收存储并将其正确传递给其子组件。**'
- en: '***2* Render the App component inside Provider so it’ll have access to store
    and pass in store to Provider component.**'
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 Provider 内部渲染 App 组件，以便它能够访问存储并将存储传递给 Provider 组件。**'
- en: Now you have access to the store in your components. But you need to do a couple
    more things to completely connect your app to Redux.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以在你的组件中访问存储了。但是，你需要做几件事情来完全连接你的应用和 Redux。
- en: 6.5.2\. Subscribing to the store from React
  id: totrans-972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2\. 从 React 订阅存储
- en: The second part of getting store updates is wrapping your container components
    in the connect HOC. This component handles subscribing to the store for you. It
    holds all the React state that’s necessary to pass down properties to its child
    component.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 获取存储更新的第二部分是将你的容器组件包裹在 connect HOC 中。这个组件为你处理订阅存储。它持有所有必要的 React 状态，以向下传递属性给其子组件。
- en: 'The connect HOC also provides helper methods that make it easier to map the
    store to properties and easier to call actions from the view. Wrapping a component
    with connect and then exporting it for use in your app looks like this:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 HOC 还提供了辅助方法，使将存储映射到属性和从视图中调用操作变得更加容易。将组件包裹在 connect 中然后导出以供应用使用看起来是这样的：
- en: '[PRE94]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The functions `mapStateToProps` and `mapDispatchToProps` are the two helper
    callbacks that connect runs. The first one, `mapStateToProps`, is run every time
    an update occurs to the store. Inside of it, you’ll define what items from the
    store should be mapped to React `props`. The following listing shows this in action.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapStateToProps` 和 `mapDispatchToProps` 是 connect 运行的两个辅助回调函数。第一个，`mapStateToProps`，在存储更新时运行。在其内部，你将定义哪些存储项应该映射到
    React `props`。下面的列表显示了这是如何工作的。'
- en: Listing 6.12\. Connect React to Redux—src/components/app.jsx
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 将 React 连接到 Redux—src/components/app.jsx
- en: '[PRE95]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* Component accesses notifications directly on props.**'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 组件直接在 props 上访问通知。**'
- en: '***2* Using notifications array, you build an array of notification items.**'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用通知数组，构建一个通知项数组。**'
- en: '***3* The function tells connect to pull specific keys out of the store and
    put them directly on props.**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 该函数告诉 connect 从存储中提取特定的键并将其直接放在 props 上。**'
- en: '***4* Pull out relevant items (notifications and refresh); refresh is required
    by the child component.**'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 提取相关项目（通知和刷新）；刷新是子组件所需的。**'
- en: '***5* Return just the keys the component needs instead of the whole store.**'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 只返回组件需要的键，而不是整个存储。**'
- en: '***6* Pass mapStateToProps into the connect function; it will be called during
    render cycle.**'
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将 mapStateToProps 传递给 connect 函数；它将在渲染周期中被调用。**'
- en: With `mapDispatchToProps`, you’re making actions available to be dispatched
    directly from the component’s properties. Normally, you’d need to fully write
    out `dispatch(actionCreator())` every time you wanted to initiate an action. This
    helper method lets you use JavaScript’s `bind` to automatically dispatch actions
    when they’re called from the view. The following listing shows how this works.
    Note that React Redux provides another helper method to automate the bind code.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mapDispatchToProps`，你可以在组件属性中直接分发动作。通常，每次你想启动一个动作时，都需要完全写出 `dispatch(actionCreator())`。这个辅助方法让你可以使用
    JavaScript 的 `bind` 来自动在视图调用动作时分发动作。下面的列表显示了这是如何工作的。注意，React Redux 提供了另一个辅助方法来自动化绑定代码。
- en: Listing 6.13\. Connect React to Redux—src/components/app.jsx
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13\. 将 React 连接到 Redux—src/components/app.jsx
- en: '[PRE96]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* Connect is the higher-order function provided by React Redux. It subscribes
    to the store and passes the updated store down as props into the connected component.**'
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Connect 是 React Redux 提供的更高阶函数。它订阅存储并将更新的存储作为 props 传递给连接的组件。**'
- en: '***2* bindActionCreators is a helper method that takes in an action or an object
    with actions and creates a function that, when called, dispatches the requested
    action.**'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* bindActionCreators 是一个辅助方法，它接受一个动作或包含动作的对象，并创建一个函数，当调用该函数时，会分发请求的动作。**'
- en: '***3* Import action creators so you can call actions in your component.**'
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入动作创建器，以便你可以在组件中调用动作。**'
- en: '***4* Call the fetchNotifications action on a regular interval; actions are
    passed down as props by connect.**'
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 定期调用 fetchNotifications 动作；动作通过 connect 传递为 props。**'
- en: '***5* Function passed into connect so connect component can pass down bound
    actions as properties—prevents having to call dispatch every time you want to
    call an action.**'
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将函数传递给 connect，以便 connect 组件可以将绑定的动作作为属性传递下去—防止每次调用动作时都调用 dispatch。**'
- en: '***6* Call connect, passing in mapDispatchToProps and then passing in the component
    you want to connect to Redux**'
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 调用 connect，传入 mapDispatchToProps，然后传入你想要连接到 Redux 的组件**'
- en: After you’ve wired up your container component (App) to connect it to Redux,
    all you have to do is pass the properties into the children. Then the child components
    can see any state you mapped to `props` and call any actions you’ve bound to `dispatch`.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 在将容器组件（App）连接到 Redux 并配置好之后，你只需要将属性传递给子组件。然后子组件可以看到你映射到 `props` 的任何状态，并调用你绑定到
    `dispatch` 的任何动作。
- en: Summary
  id: totrans-995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how Redux works, including how to implement unidirectional
    data flow, maintain an immutable store, and connect React with Redux.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Redux 的工作原理，包括如何实现单向数据流、维护不可变存储以及将 React 连接到 Redux。
- en: Redux implements an architecture pattern that’s an evolution of the traditional
    MVC pattern.
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 实现了一种架构模式，它是传统 MVC 模式的演变。
- en: The single-directional flow of Redux, where the view dispatches actions and
    subscribes to store updates, makes reasoning about the system simpler for developers.
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 的单向数据流，其中视图分发动作并订阅存储更新，使得开发人员对系统的推理更加简单。
- en: The store, or state, of your application is a single root object that holds
    all the information for your view.
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应用程序的 store 或状态是一个根对象，它包含您视图的所有信息。
- en: Reducers are pure functions that make changes to the store. They never mutate
    the store and instead use immutable patterns to make updates to the store.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducers 是纯函数，它们会对 store 进行更改。它们永远不会修改 store，而是使用不可变模式来更新 store。
- en: Actions are used to trigger updates to the store.
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actions 用于触发 store 的更新。
- en: Middleware allows debugging tools and asynchronous actions to be used in Redux.
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Middleware 允许在 Redux 中使用调试工具和异步操作。
- en: Connecting React and Redux requires additional functionality provided by the
    React Redux library, which includes a higher-order component that subscribes to
    the store for its child component.
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接 React 和 Redux 需要由 React Redux 库提供的附加功能，该库包括一个高阶组件，该组件订阅 store 以供其子组件使用。
