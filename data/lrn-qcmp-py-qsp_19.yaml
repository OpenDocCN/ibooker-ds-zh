- en: appendix D Â Exploring the Deutschâ€“Jozsa algorithm by example
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é™„å½• D é€šè¿‡ç¤ºä¾‹æ¢ç´¢ Deutschâ€“Jozsa ç®—æ³•
- en: In this appendix, we do a deep dive on the Deutschâ€“Jozsa algorithm to show how
    it works and how we can use the skills and tools we developed in chapter 8 to
    check our understanding. We implement the Deutschâ€“Jozsa algorithm in chapter 7
    and make heavy use of QuTiP for checking our math at certain steps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé™„å½•ä¸­ï¼Œæˆ‘ä»¬å¯¹ Deutschâ€“Jozsa ç®—æ³•è¿›è¡Œæ·±å…¥ç ”ç©¶ï¼Œä»¥å±•ç¤ºå®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œä»¥åŠæˆ‘ä»¬å¦‚ä½•ä½¿ç”¨åœ¨ç¬¬ 8 ç« ä¸­å¼€å‘çš„æŠ€èƒ½å’Œå·¥å…·æ¥æ£€éªŒæˆ‘ä»¬çš„ç†è§£ã€‚æˆ‘ä»¬åœ¨ç¬¬
    7 ç« ä¸­å®ç°äº† Deutschâ€“Jozsa ç®—æ³•ï¼Œå¹¶åœ¨æŸäº›æ­¥éª¤ä¸­å¤§é‡ä½¿ç”¨ QuTiP æ¥æ£€æŸ¥æˆ‘ä»¬çš„æ•°å­¦è¿ç®—ã€‚
- en: D.1 Using our skills to try things
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.1 ä½¿ç”¨æˆ‘ä»¬çš„æŠ€èƒ½å°è¯•æ–°äº‹ç‰©
- en: In chapters 2 and 5, we learn to use NumPy and QuTiP to simulate how the states
    of qubits are transformed when we send instructions to a quantum computer. We
    effectively use these packages to do math for us to find out what happens to our
    quantum states. This is like the â€œmake the computer do the mathâ€ approach in figure
    D.1.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¬¬ 2 ç« å’Œç¬¬ 5 ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ ä½¿ç”¨ NumPy å’Œ QuTiP æ¥æ¨¡æ‹Ÿå½“æˆ‘ä»¬å‘é‡å­è®¡ç®—æœºå‘é€æŒ‡ä»¤æ—¶ï¼Œé‡å­æ¯”ç‰¹çš„çŠ¶æ€æ˜¯å¦‚ä½•è½¬æ¢çš„ã€‚æˆ‘ä»¬æœ‰æ•ˆåœ°ä½¿ç”¨è¿™äº›åŒ…æ¥ä¸ºæˆ‘ä»¬åšæ•°å­¦è¿ç®—ï¼Œä»¥æ‰¾å‡ºæˆ‘ä»¬çš„é‡å­çŠ¶æ€å‘ç”Ÿäº†ä»€ä¹ˆã€‚è¿™å°±åƒå›¾
    D.1 ä¸­çš„â€œè®©è®¡ç®—æœºåšæ•°å­¦â€æ–¹æ³•ã€‚
- en: '![](../Images/D-1.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡](../Images/D-1.png)'
- en: Figure D.1 Three different approaches to learning how a quantum program or algorithm
    works
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ D.1 ä¸‰ç§å­¦ä¹ é‡å­ç¨‹åºæˆ–ç®—æ³•å·¥ä½œåŸç†çš„ä¸åŒæ–¹æ³•
- en: When we program larger algorithms in Q#, we can use both the â€œmake the computer
    do the mathâ€ and a bit of the â€œpush all the buttonsâ€ approach to help us predict
    what a particular operation will do. The three approaches show in figure D.1,
    used together, are powerful problem-solving tools when learning quantum programming.
    If we get stuck using one approach, we can always try another to see if that helps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬åœ¨ Q# ä¸­ç¼–å†™æ›´å¤§çš„ç®—æ³•æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åŒæ—¶ä½¿ç”¨â€œè®©è®¡ç®—æœºåšæ•°å­¦â€å’Œä¸€ç‚¹â€œæŒ‰æ‰€æœ‰æŒ‰é’®â€çš„æ–¹æ³•æ¥å¸®åŠ©æˆ‘ä»¬é¢„æµ‹ç‰¹å®šæ“ä½œå°†åšä»€ä¹ˆã€‚å›¾ D.1 ä¸­æ˜¾ç¤ºçš„ä¸‰ç§æ–¹æ³•ç»“åˆä½¿ç”¨ï¼Œæ˜¯å­¦ä¹ é‡å­ç¼–ç¨‹æ—¶çš„å¼ºå¤§é—®é¢˜è§£å†³å·¥å…·ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ä¸€ç§æ–¹æ³•é‡åˆ°å›°éš¾ï¼Œæˆ‘ä»¬æ€»æ˜¯å¯ä»¥å°è¯•å¦ä¸€ç§æ–¹æ³•ï¼Œçœ‹çœ‹æ˜¯å¦æœ‰æ‰€å¸®åŠ©ã€‚
- en: Letâ€™s try to apply this combo approach to the Deutschâ€“Jozsa algorithm from chapter
    8\. The following listing shows the four steps of the algorithm.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•å°†è¿™ç§ç»„åˆæ–¹æ³•åº”ç”¨äºç¬¬ 8 ç« ä¸­çš„ Deutschâ€“Jozsa ç®—æ³•ã€‚ä»¥ä¸‹åˆ—è¡¨æ˜¾ç¤ºäº†ç®—æ³•çš„å››ä¸ªæ­¥éª¤ã€‚
- en: Listing D.1 The four steps in the Deutschâ€“Jozsa algorithm
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ D.1 Deutschâ€“Jozsa ç®—æ³•çš„å››ä¸ªæ­¥éª¤
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: â¶ Prepare the input state |+âˆ’ã€‰.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å‡†å¤‡è¾“å…¥çŠ¶æ€ |+âˆ’ã€‰ã€‚
- en: â· Apply the oracle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: â· åº”ç”¨æˆ–aclesã€‚
- en: â¸ Undo the preparation on the target qubit. the input state |+âˆ’ã€‰.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ å–æ¶ˆç›®æ ‡é‡å­æ¯”ç‰¹ä¸Šçš„å‡†å¤‡ã€‚è¾“å…¥çŠ¶æ€ |+âˆ’ã€‰ã€‚
- en: â¹ Finally, measure in the *X*-basis.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ æœ€åï¼Œåœ¨ *X*-åŸºä¸‹è¿›è¡Œæµ‹é‡ã€‚
- en: The key to understanding how the Deutschâ€“Jozsa algorithm works is understanding
    the step where we call the oracle, `oracle(control, target)`. Before we can get
    to that, though, we need to understand step 1, where we prepare our input to `oracle`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ç†è§£ Deutschâ€“Jozsa ç®—æ³•å·¥ä½œçš„å…³é”®æ˜¯ç†è§£æˆ‘ä»¬è°ƒç”¨æˆ–aclesï¼Œ`oracle(control, target)` çš„æ­¥éª¤ã€‚ä¸è¿‡ï¼Œåœ¨æˆ‘ä»¬èƒ½å¤Ÿåˆ°è¾¾é‚£é‡Œä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç†è§£æ­¥éª¤
    1ï¼Œå³æˆ‘ä»¬ä¸º `oracle` å‡†å¤‡è¾“å…¥ã€‚
- en: 'D.2 Step 1: Preparing the input state for Deutschâ€“Jozsa'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.2 æ­¥éª¤ 1ï¼šä¸º Deutschâ€“Jozsa å‡†å¤‡è¾“å…¥çŠ¶æ€
- en: 'Letâ€™s use Python to try to understand what is happening when we prepare our
    |+âˆ’ã€‰ state. The operations we use to prep the input state in Q# are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç”¨ Python å°è¯•ç†è§£å½“æˆ‘ä»¬å‡†å¤‡æˆ‘ä»¬çš„ |+âˆ’ã€‰ çŠ¶æ€æ—¶å‘ç”Ÿäº†ä»€ä¹ˆã€‚æˆ‘ä»¬åœ¨ Q# ä¸­å‡†å¤‡è¾“å…¥çŠ¶æ€çš„è¿ç®—å¦‚ä¸‹ï¼š
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each operation applied here is a single-qubit gate, so we can consider what
    happens to each qubit independently. Letâ€™s look at what happens to the control
    qubit after the Hadamard operation. We use QuTiP to model the control qubit state
    preparation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œåº”ç”¨çš„æ¯ä¸ªæ“ä½œéƒ½æ˜¯ä¸€ä¸ªå•é‡å­æ¯”ç‰¹é—¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç‹¬ç«‹è€ƒè™‘æ¯ä¸ªé‡å­æ¯”ç‰¹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚è®©æˆ‘ä»¬çœ‹çœ‹å“ˆè¾¾ç›å¾·æ“ä½œåæ§åˆ¶é‡å­æ¯”ç‰¹ä¼šå‘ç”Ÿä»€ä¹ˆã€‚æˆ‘ä»¬ä½¿ç”¨ QuTiP
    æ¥æ¨¡æ‹Ÿæ§åˆ¶é‡å­æ¯”ç‰¹çš„çŠ¶æ€å‡†å¤‡ï¼š
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: â¶ While HÂ in Q# is an instruction, hadamard_transform in QuTiP gives us a unitary
    matrix that we can use to simulate how the HÂ instruction transforms states.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ è™½ç„¶ Q# ä¸­çš„ H æ˜¯ä¸€æ¡æŒ‡ä»¤ï¼Œä½† QuTiP ä¸­çš„ hadamard_transform ç»™æˆ‘ä»¬ä¸€ä¸ªå•ä½çŸ©é˜µï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥æ¨¡æ‹Ÿ H æŒ‡ä»¤å¦‚ä½•è½¬æ¢çŠ¶æ€ã€‚
- en: â· 1 / âˆš2 â‰ˆ 0.707, so this output tells us that ![](../Images/equation_D-1.png).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: â· 1 / âˆš2 â‰ˆ 0.707ï¼Œæ‰€ä»¥è¿™ä¸ªè¾“å‡ºå‘Šè¯‰æˆ‘ä»¬![å›¾ç‰‡](../Images/equation_D-1.png)ã€‚
- en: â¸ In QuTiP, we can get the vector for the |0ã€‰ state by calling basis(2, 0).
    The 2 tells QuTiP we want a qubit (necessary dimension of |0ã€‰), while the 0 says
    we want the state to have the value |0ã€‰. Since |+ã€‰ = *H*|0ã€‰, this sets control_state
    to |+ã€‰.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ åœ¨ QuTiP ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨ basis(2, 0) è·å– |0ã€‰ çŠ¶æ€çš„å‘é‡ã€‚2 å‘Šè¯‰ QuTiP æˆ‘ä»¬æƒ³è¦ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼ˆ|0ã€‰çš„å¿…è¦ç»´åº¦ï¼‰ï¼Œè€Œ
    0 è¡¨ç¤ºæˆ‘ä»¬æƒ³è¦çŠ¶æ€å…·æœ‰ |0ã€‰çš„å€¼ã€‚ç”±äº |+ã€‰ = *H*|0ã€‰ï¼Œè¿™ä¼šå°† control_state è®¾ç½®ä¸º |+ã€‰ã€‚
- en: â¹ Using that 1 / âˆš2 â‰ˆ 0.707, we read this as telling us that |+ã€‰ = (|0ã€‰ + |1ã€‰)
    / âˆš2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ ä½¿ç”¨ 1 / âˆš2 â‰ˆ 0.707ï¼Œæˆ‘ä»¬å°†è¿™è§£è¯»ä¸ºå‘Šè¯‰æˆ‘ä»¬ |+ã€‰ = (|0ã€‰ + |1ã€‰) / âˆš2ã€‚
- en: 'Thatâ€™s a pretty easy one: the control qubit is now in the |+ã€‰ state. Now letâ€™s
    look at preparing the target qubit in the next snippet.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¾ˆç®€å•ï¼šæ§åˆ¶é‡å­æ¯”ç‰¹ç°åœ¨å¤„äº |+ã€‰ çŠ¶æ€ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•å‡†å¤‡ä¸‹ä¸€ä¸ªç‰‡æ®µä¸­çš„ç›®æ ‡é‡å­æ¯”ç‰¹ã€‚
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: â¶ Repeats the same HÂ operation as before, but this time on *X*|0ã€‰ = |1ã€‰
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ ä¸ä¹‹å‰ç›¸åŒçš„ H æ“ä½œï¼Œä½†è¿™æ¬¡æ˜¯åœ¨ *X*|0ã€‰ = |1ã€‰ ä¸Šè¿›è¡Œã€‚
- en: 'â· QuTiP tells us that |âˆ’ã€‰ = (|0ã€‰ âˆ’ |1ã€‰) / âˆš2: the same as |+ã€‰, but with the
    sign of |1ã€‰ flipped.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: â· QuTiPå‘Šè¯‰æˆ‘ä»¬ |âˆ’ã€‰ = (|0ã€‰ âˆ’ |1ã€‰) / âˆš2ï¼šä¸ |+ã€‰ ç›¸åŒï¼Œä½† |1ã€‰ çš„ç¬¦å·è¢«ç¿»è½¬äº†ã€‚
- en: Now that we have seen how to prepare each qubit, letâ€™s have QuTiP help us write
    the state of our input *register*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•å‡†å¤‡æ¯ä¸ªé‡å­æ¯”ç‰¹ï¼Œè®©æˆ‘ä»¬è®© QuTiP å¸®åŠ©æˆ‘ä»¬ç¼–å†™è¾“å…¥ *å¯„å­˜å™¨* çš„çŠ¶æ€ã€‚
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: â¶ As in chapter 4, we combine the states of different qubits to get the state
    of an entire register of qubits using the tensor function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ æ­£å¦‚ç¬¬ 4 ç« ä¸­æ‰€è¿°ï¼Œæˆ‘ä»¬ä½¿ç”¨å¼ é‡å‡½æ•°å°†ä¸åŒé‡å­æ¯”ç‰¹çš„çŠ¶æ€ç»„åˆèµ·æ¥ï¼Œä»¥è·å¾—æ•´ä¸ªé‡å­æ¯”ç‰¹å¯„å­˜å™¨çš„çŠ¶æ€ã€‚
- en: â· QuTiP tells us that |+ã€‰ âŠ— |âˆ’ã€‰ = |+âˆ’ã€‰ = (|00ã€‰ âˆ’ |01ã€‰ + |10ã€‰ âˆ’ |11ã€‰) / 2\. That
    is, we have an equal superposition over all four possible computational basis
    states, with a minus sign in front of computational basis states where the target
    qubit is in the |1ã€‰ state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: â· QuTiPå‘Šè¯‰æˆ‘ä»¬ |+ã€‰ âŠ— |âˆ’ã€‰ = |+âˆ’ã€‰ = (|00ã€‰ âˆ’ |01ã€‰ + |10ã€‰ âˆ’ |11ã€‰) / 2ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åœ¨æ‰€æœ‰å››ä¸ªå¯èƒ½çš„è®¡ç®—åŸºæ€ä¸Šæœ‰ä¸€ä¸ªç›¸ç­‰çš„å åŠ ï¼Œå½“ç›®æ ‡é‡å­æ¯”ç‰¹å¤„äº
    |1ã€‰ çŠ¶æ€æ—¶ï¼Œè®¡ç®—åŸºæ€å‰é¢æœ‰ä¸€ä¸ªè´Ÿå·ã€‚
- en: Note As we see in chapter 4, when writing the state of a multi-qubit system,
    tensor products can get a little bit verbose. Thus, we often write multi-qubit
    states like |0ã€‰ âŠ— |1ã€‰ by concatenating their labels inside a single ket, as in
    |01ã€‰. Similarly, |+âˆ’ã€‰ is the same as |+ã€‰ âŠ— |âˆ’ã€‰.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šæ­£å¦‚æˆ‘ä»¬åœ¨ç¬¬ 4 ç« ä¸­çœ‹åˆ°çš„ï¼Œåœ¨ç¼–å†™å¤šé‡å­æ¯”ç‰¹ç³»ç»Ÿçš„çŠ¶æ€æ—¶ï¼Œå¼ é‡ç§¯å¯èƒ½ä¼šå˜å¾—æœ‰ç‚¹å†—é•¿ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç»å¸¸é€šè¿‡å°†å®ƒä»¬çš„æ ‡ç­¾è¿æ¥åœ¨å•ä¸ªåŸºçŸ¢é‡å†…éƒ¨æ¥ç¼–å†™å¤šé‡å­æ¯”ç‰¹çŠ¶æ€ï¼Œä¾‹å¦‚
    |01ã€‰ã€‚åŒæ ·ï¼Œ|+âˆ’ã€‰ ä¸ |+ã€‰ âŠ— |âˆ’ã€‰ ç›¸åŒã€‚
- en: 'D.3 Step 2: Applying the oracle'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.3 æ­¥éª¤ 2ï¼šåº”ç”¨é¢„è¨€æœº
- en: 'Having prepared our input, letâ€™s get back to the core of the Deutschâ€“Jozsa
    algorithm, where we call into our oracle:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å‡†å¤‡å¥½è¾“å…¥åï¼Œè®©æˆ‘ä»¬å›åˆ° Deutsch-Jozsa ç®—æ³•çš„æ ¸å¿ƒï¼Œåœ¨é‚£é‡Œæˆ‘ä»¬è°ƒç”¨æˆ‘ä»¬çš„é¢„è¨€æœºï¼š
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just as we can understand operations like `H(control)` by writing the state
    of the `control` qubit and applying the unitary operator *H* to that state, we
    can understand what the oracle *U[f]* does by analyzing its action on the state
    we pass to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¼–å†™ `control` é‡å­æ¯”ç‰¹çš„çŠ¶æ€å¹¶åº”ç”¨å¹ºæ­£ç®—å­ *H* æ¥ç†è§£æ“ä½œ `H(control)` ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ†æå…¶å¯¹ä¼ é€’ç»™å®ƒçš„çŠ¶æ€çš„ä½œç”¨æ¥ç†è§£é¢„è¨€æœº
    *U[f]* åšäº†ä»€ä¹ˆã€‚
- en: 'Recall our game setup in chapter 8, where Nimue and Merlin are playing Kingmaker.
    Our quantum oracle operates on two qubits, which raises the question of how we
    should interpret each of those qubits. In the classical case, the interpretation
    of the input and output classical bits from *f* was clear: Nimue asked a one-bit
    question and got a one-bit answer.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: å›æƒ³ç¬¬ 8 ç« ä¸­çš„æ¸¸æˆè®¾ç½®ï¼Œå…¶ä¸­ Nimue å’Œ Merlin æ­£åœ¨ç©å›½ç‹åˆ¶é€ è€…æ¸¸æˆã€‚æˆ‘ä»¬çš„é‡å­é¢„è¨€æœºä½œç”¨äºä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼Œè¿™å¼•å‘äº†å¦‚ä½•è§£é‡Šæ¯ä¸ªé‡å­æ¯”ç‰¹çš„é—®é¢˜ã€‚åœ¨ç»å…¸æƒ…å†µä¸‹ï¼Œä»
    *f* ä¸­è¾“å…¥å’Œè¾“å‡ºçš„ç»å…¸æ¯”ç‰¹çš„è§£é‡Šæ˜¯æ¸…æ™°çš„ï¼šNimue æå‡ºä¸€ä¸ªå•æ¯”ç‰¹é—®é¢˜å¹¶å¾—åˆ°ä¸€ä¸ªå•æ¯”ç‰¹ç­”æ¡ˆã€‚
- en: 'To understand what each qubit does for us, recall that when we use a reversible
    classical function, we also need two inputs: the first acts like the question
    we ask in the irreversible case, and the second input gives us somewhere to put
    the answer (see figure D.2 for a reminder).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¦äº†è§£æ¯ä¸ªé‡å­æ¯”ç‰¹ä¸ºæˆ‘ä»¬åšäº†ä»€ä¹ˆï¼Œå›æƒ³ä¸€ä¸‹ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨å¯é€†çš„ç»å…¸å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸¤ä¸ªè¾“å…¥ï¼šç¬¬ä¸€ä¸ªåœ¨ä¸å¯é€†æƒ…å†µä¸‹ç±»ä¼¼äºæˆ‘ä»¬æå‡ºçš„é—®é¢˜ï¼Œç¬¬äºŒä¸ªè¾“å…¥ç»™æˆ‘ä»¬ä¸€ä¸ªæ”¾ç½®ç­”æ¡ˆçš„åœ°æ–¹ï¼ˆè§å›¾
    D.2 ä»¥è·å¾—æé†’ï¼‰ã€‚
- en: '![](../Images/D-2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾ç‰‡ D-2](../Images/D-2.png)'
- en: Figure D.2 Constructing reversible classical functions and unitary matrices
    from irreversible classical functions
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ D.2 ä»ä¸å¯é€†çš„ç»å…¸å‡½æ•°æ„é€ å¯é€†çš„ç»å…¸å‡½æ•°å’Œå¹ºæ­£çŸ©é˜µ
- en: 'We can think of the oracle roughly the same way: the first qubit (`control`
    in the previous snippet) represents our question, while the second qubit (`target`)
    gives us somewhere for Merlin to apply his answer. This interpretation makes sense
    when `control` starts in either the |0ã€‰ or |1ã€‰ state, but how can we interpret
    this case where we pass qubits in the |+âˆ’ã€‰ state to the oracle? Our control qubit
    starts in the |+ã€‰ state, but *f*(+) doesnâ€™t make any sense. Since *f* is a classical
    function, its input has to be either 0 or 1â€”we canâ€™t pass + to the classical function
    *f*. It may seem as though weâ€™re at a dead end, but fortunately thereâ€™s a way
    to figure it out.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å¤§è‡´ä»¥ç›¸åŒçš„æ–¹å¼æ€è€ƒé¢„è¨€æœºï¼šç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼ˆåœ¨ä¹‹å‰çš„ç‰‡æ®µä¸­ä¸º `control`ï¼‰ä»£è¡¨æˆ‘ä»¬çš„é—®é¢˜ï¼Œè€Œç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹ï¼ˆ`target`ï¼‰ä¸º Merlin
    åº”ç”¨ä»–çš„ç­”æ¡ˆæä¾›äº†ä¸€ä¸ªåœ°æ–¹ã€‚è¿™ç§è§£é‡Šåœ¨ `control` ä»¥ |0ã€‰ æˆ– |1ã€‰ çŠ¶æ€å¼€å§‹æ—¶æ˜¯æœ‰æ„ä¹‰çš„ï¼Œä½†å¦‚ä½•è§£é‡Šæˆ‘ä»¬å‘é¢„è¨€æœºä¼ é€’å¤„äº |+âˆ’ã€‰ çŠ¶æ€çš„é‡å­æ¯”ç‰¹çš„æƒ…å†µå‘¢ï¼Ÿæˆ‘ä»¬çš„æ§åˆ¶é‡å­æ¯”ç‰¹ä»¥
    |+ã€‰ çŠ¶æ€å¼€å§‹ï¼Œä½† *f*(+) æ²¡æœ‰æ„ä¹‰ã€‚ç”±äº *f* æ˜¯ä¸€ä¸ªç»å…¸å‡½æ•°ï¼Œå®ƒçš„è¾“å…¥å¿…é¡»æ˜¯ 0 æˆ– 1â€”â€”æˆ‘ä»¬ä¸èƒ½å°† + ä¼ é€’ç»™ç»å…¸å‡½æ•° *f*ã€‚è¿™ä¼¼ä¹æ˜¯ä¸€ä¸ªæ­»èƒ¡åŒï¼Œä½†å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸€ç§æ–¹æ³•å¯ä»¥æ‰¾å‡ºç­”æ¡ˆã€‚
- en: Quantum mechanics is linear, which means we can always understand what a quantum
    operation does by breaking it down into its action on a representative set of
    states.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: é‡å­åŠ›å­¦æ˜¯çº¿æ€§çš„ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†å…¶åˆ†è§£ä¸ºå…¶å¯¹ä¸€ç»„ä»£è¡¨æ€§çŠ¶æ€çš„è¡ŒåŠ¨æ¥ç†è§£é‡å­æ“ä½œçš„ä½œç”¨ã€‚
- en: Tip As we see in chapter 2, a set of states that can be used this way is called
    a *basis*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æç¤ºï¼šæ­£å¦‚æˆ‘ä»¬åœ¨ç¬¬ 2 ç« ä¸­çœ‹åˆ°çš„ï¼Œä¸€ç»„å¯ä»¥ä»¥è¿™ç§æ–¹å¼ä½¿ç”¨çš„çŠ¶æ€è¢«ç§°ä¸º *åŸº*ã€‚
- en: To understand what our oracle does when the control qubit is in the |+ã€‰ state,
    we can use the fact that |+ã€‰ = (|0ã€‰ + |1ã€‰) / âˆš2 to break the oracleâ€™s action down
    into what it does to |0ã€‰ *plus* its action on |1ã€‰ and then sum both parts back
    together (making sure to divide by âˆš2 at the end). This helps because instead
    of being confused by trying to understand what â€œ*f* (+)â€ means, we can reduce
    the action of *U f* to cases we do know how to compute, like *f*(0) and *f*(1)!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç†è§£å½“æ§åˆ¶é‡å­æ¯”ç‰¹å¤„äº |+ã€‰ çŠ¶æ€æ—¶æˆ‘ä»¬çš„å¥¥ç§˜åšäº†ä»€ä¹ˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ |+ã€‰ = (|0ã€‰ + |1ã€‰) / âˆš2 çš„äº‹å®ï¼Œå°†å¥¥ç§˜çš„ä½œç”¨åˆ†è§£ä¸ºå¯¹ |0ã€‰
    *åŠ ä¸Š* å¯¹ |1ã€‰ çš„ä½œç”¨ï¼Œç„¶åå°†ä¸¤éƒ¨åˆ†ç›¸åŠ ï¼ˆç¡®ä¿åœ¨æœ€åé™¤ä»¥ âˆš2ï¼‰ã€‚è¿™æœ‰åŠ©äºæˆ‘ä»¬é¿å…å¯¹â€œ*f* (+)â€çš„å«ä¹‰æ„Ÿåˆ°å›°æƒ‘ï¼Œæˆ‘ä»¬å¯ä»¥å°† *U f* çš„ä½œç”¨ç®€åŒ–ä¸ºæˆ‘ä»¬çŸ¥é“å¦‚ä½•è®¡ç®—çš„æƒ…å†µï¼Œå¦‚
    *f*(0) å’Œ *f*(1)ï¼
- en: Computational basis states
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—åŸºçŠ¶æ€
- en: Expanding the action of a quantum operation in terms of how it acts on |0ã€‰ and
    |1ã€‰ is very common in quantum programming. Given how useful this is, we use a
    special name for these two input states and call |0ã€‰ and |1ã€‰ the *computational
    basis* to set them apart from other bases we might use, like |+ã€‰ and |âˆ’ã€‰.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é‡å­ç¼–ç¨‹ä¸­ï¼Œæ ¹æ®é‡å­æ“ä½œå¯¹ |0ã€‰ å’Œ |1ã€‰ çš„ä½œç”¨æ¥å±•å¼€é‡å­æ“ä½œæ˜¯éå¸¸å¸¸è§çš„ã€‚é‰´äºè¿™ä¸€ç‚¹éå¸¸æœ‰ç”¨ï¼Œæˆ‘ä»¬ä¸ºè¿™ä¸¤ä¸ªè¾“å…¥çŠ¶æ€ä½¿ç”¨ä¸€ä¸ªç‰¹æ®Šçš„åç§°ï¼Œå¹¶å°† |0ã€‰
    å’Œ |1ã€‰ ç§°ä¸º *è®¡ç®—åŸº*ï¼Œä»¥å°†å®ƒä»¬ä¸å…¶ä»–æˆ‘ä»¬å¯èƒ½ä½¿ç”¨çš„åŸºï¼Œå¦‚ |+ã€‰ å’Œ |âˆ’ã€‰ åŒºåˆ†å¼€æ¥ã€‚
- en: Using linearity to understand quantum operations isnâ€™t limited to a single qubit,
    as we see in the rest of the appendix. For two qubits, for instance, the computational
    basis consists of the states |00ã€‰, |01ã€‰, |10ã€‰, and |11ã€‰.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨çº¿æ€§æ¥ç†è§£é‡å­æ“ä½œä¸ä»…é™äºå•ä¸ªé‡å­æ¯”ç‰¹ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨é™„å½•çš„å…¶ä½™éƒ¨åˆ†ä¸­çœ‹åˆ°çš„ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼Œè®¡ç®—åŸºç”±çŠ¶æ€ |00ã€‰, |01ã€‰, |10ã€‰ å’Œ
    |11ã€‰ ç»„æˆã€‚
- en: If we have even more (say, five) qubits, we can write states like |1ã€‰ âŠ— |0ã€‰
    âŠ— |0ã€‰ âŠ— |1ã€‰ âŠ— |0ã€‰ as strings in the same way, getting |10010ã€‰. We can write the
    computational basis for five qubits as {|00000ã€‰, |00001ã€‰, |00010ã€‰, ..., |11110ã€‰,
    |11111ã€‰}.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æœ‰æ›´å¤šï¼ˆæ¯”å¦‚è¯´ï¼Œäº”ä¸ªï¼‰é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬å¯ä»¥åƒå†™å­—ç¬¦ä¸²ä¸€æ ·å†™å‡º |1ã€‰ âŠ— |0ã€‰ âŠ— |0ã€‰ âŠ— |1ã€‰ âŠ— |0ã€‰ è¿™æ ·çš„çŠ¶æ€ï¼Œå¾—åˆ° |10010ã€‰ã€‚æˆ‘ä»¬å¯ä»¥å°†äº”ä¸ªé‡å­æ¯”ç‰¹çš„è®¡ç®—åŸºå†™ä¸º
    {|00000ã€‰, |00001ã€‰, |00010ã€‰, ..., |11110ã€‰, |11111ã€‰}ã€‚
- en: 'More generally, if we have *n* qubits, the computational basis consists of
    all strings of *n* classical bits, each as the label of a ket. Put differently,
    the computational basis for a multiple-qubit system is made up of all tensor products
    of |0ã€‰ and |1ã€‰: that is, all states labeled by a string of classical bits.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æ›´æ™®éåœ°è¯´ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ *n* ä¸ªé‡å­æ¯”ç‰¹ï¼Œè®¡ç®—åŸºç”±æ‰€æœ‰ *n* ä¸ªç»å…¸æ¯”ç‰¹çš„å­—ç¬¦ä¸²ç»„æˆï¼Œæ¯ä¸ªå­—ç¬¦ä¸²ä½œä¸ºåŸºçŸ¢çš„æ ‡ç­¾ã€‚æ¢å¥è¯è¯´ï¼Œå¤šé‡å­æ¯”ç‰¹ç³»ç»Ÿçš„è®¡ç®—åŸºç”±æ‰€æœ‰
    |0ã€‰ å’Œ |1ã€‰ çš„å¼ é‡ç§¯ç»„æˆï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰€æœ‰ç”±ç»å…¸æ¯”ç‰¹å­—ç¬¦ä¸²æ ‡è®°çš„çŠ¶æ€ã€‚
- en: With this approach of breaking down how the oracle works, letâ€™s look at some
    examples of the oracles we implemented in chapter 8.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡åˆ†è§£å¥¥ç§˜å¦‚ä½•å·¥ä½œçš„è¿™ç§æ–¹æ³•ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬åœ¨ç¬¬ 8 ç« ä¸­å®ç°çš„å¥¥ç§˜çš„ä¸€äº›ä¾‹å­ã€‚
- en: 'D.3.1 Example 1: The â€œidâ€ oracle'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.1 ç¤ºä¾‹ 1ï¼šâ€œidâ€å¥¥ç§˜
- en: Suppose we are given an oracle that implements the strategy where Merlin chooses
    Arthur as king (section 8.2). Recall that the classical one-bit function that
    represents this strategy is `id`. From table D.1, we know that this means *U[f]*
    is implemented by the `CNOT` instruction, so letâ€™s see what that does to `register_state`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬è¢«ç»™å®šä¸€ä¸ªå®ç°æ¢…æ—é€‰æ‹©äºšç‘Ÿä¸ºç‹çš„ç­–ç•¥ï¼ˆç¬¬ 8.2 èŠ‚ï¼‰çš„å¥¥ç§˜ã€‚å›æƒ³ä¸€ä¸‹ï¼Œä»£è¡¨è¿™ç§ç­–ç•¥çš„ç»å…¸å•æ¯”ç‰¹å‡½æ•°æ˜¯ `id`ã€‚ä»è¡¨ D.1 ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“è¿™æ„å‘³ç€
    *U[f]* æ˜¯é€šè¿‡ `CNOT` æŒ‡ä»¤å®ç°çš„ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬çœ‹çœ‹å®ƒå¯¹ `register_state` åšäº†ä»€ä¹ˆã€‚
- en: Table D.1 Representing one-bit functions as two-qubit oracles
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ D.1 å°†å•æ¯”ç‰¹å‡½æ•°è¡¨ç¤ºä¸ºåŒé‡å­æ¯”ç‰¹å¥¥ç§˜
- en: '| Function name | Function | Output of oracle | Q# operation |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•°åç§° | å‡½æ•° | å¥¥ç§˜è¾“å‡º | Q# æ“ä½œ |'
- en: '| id | *f*(*x*) = *x* | &#124;*x*ã€‰&#124;*y* âŠ• *x*ã€‰ | `CNOT(control, target)`
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| id | *f*(*x*) = *x* | &#124;*x*ã€‰&#124;*y* âŠ• *x*ã€‰ | `CNOT(control, target)`
    |'
- en: Tip Recall that the controlled-NOT instruction flips its second qubit if the
    first qubit is in |1ã€‰.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: æç¤ºï¼šå›æƒ³ä¸€ä¸‹ï¼Œå—æ§-NOT æŒ‡ä»¤åœ¨ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹å¤„äº |1ã€‰ æ—¶ç¿»è½¬å…¶ç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹ã€‚
- en: Listing D.2 How the `id` oracle transforms its input state
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ D.2 `id` å¥¥ç§˜å¦‚ä½•è½¬æ¢å…¶è¾“å…¥çŠ¶æ€
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: â¶ Asks QuTiP for a matrix that lets us simulate the CNOT instruction by using
    the cnot function. Here, the 2 indicates that we want to simulate CNOT on a two-qubit
    register, the 0 indicates that the 0th qubit is our control, and the 1 indicates
    that the first qubit is our target.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ è¯¢é—® QuTiP ä»¥ä½¿ç”¨ cnot å‡½æ•°é€šè¿‡ CNOT æŒ‡ä»¤è¿›è¡Œæ¨¡æ‹Ÿçš„çŸ©é˜µã€‚åœ¨è¿™é‡Œï¼Œ2 è¡¨ç¤ºæˆ‘ä»¬æƒ³è¦åœ¨åŒé‡å­æ¯”ç‰¹å¯„å­˜å™¨ä¸Šæ¨¡æ‹Ÿ CNOTï¼Œ0 è¡¨ç¤ºç¬¬
    0 ä¸ªé‡å­æ¯”ç‰¹æ˜¯æˆ‘ä»¬çš„æ§åˆ¶ä½ï¼Œ1 è¡¨ç¤ºç¬¬ 1 ä¸ªé‡å­æ¯”ç‰¹æ˜¯æˆ‘ä»¬çš„ç›®æ ‡ä½ã€‚
- en: â· Remember that unitary operators are for quantum computing what truth tables
    are for classical logic. Each row in this table tells us what happens to a computational
    basis state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: â· è®°ä½ï¼Œå•ä½ç®—ç¬¦å¯¹äºé‡å­è®¡ç®—æ¥è¯´ï¼Œå°±åƒçœŸå€¼è¡¨å¯¹äºç»å…¸é€»è¾‘ä¸€æ ·ã€‚è¡¨ä¸­çš„æ¯ä¸€è¡Œéƒ½å‘Šè¯‰æˆ‘ä»¬è®¡ç®—åŸºæ€ä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: â¸ For example, the row at index 2 (zero-indexed) can be written as 10 in binary.
    Thus, this row is the vector weâ€™ll get out if our input is |10ã€‰, and it tells
    us that the CNOT instruction leaves our qubits in |11ã€‰ (3 in decimal, hence thereâ€™s
    a 1 in the third column).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ä¾‹å¦‚ï¼Œç´¢å¼•ä¸º2çš„è¡Œï¼ˆé›¶ç´¢å¼•ï¼‰å¯ä»¥å†™æˆäºŒè¿›åˆ¶çš„10ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬çš„è¾“å…¥æ˜¯|10ã€‰ï¼Œè¿™å°†æ˜¯æˆ‘ä»¬å¾—åˆ°çš„å‘é‡ï¼Œå®ƒå‘Šè¯‰æˆ‘ä»¬CNOTæŒ‡ä»¤å°†æˆ‘ä»¬çš„é‡å­æ¯”ç‰¹ä¿æŒåœ¨|11ã€‰ï¼ˆåè¿›åˆ¶ä¸­çš„3ï¼Œå› æ­¤ç¬¬ä¸‰åˆ—æœ‰ä¸€ä¸ª1ï¼‰ã€‚
- en: â¹ QuTiP tells us that the register with our control and target qubits is now
    in the state (|00ã€‰ âˆ’ |01ã€‰ âˆ’ |10ã€‰ + |11ã€‰) / 2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ QuTiPå‘Šè¯‰æˆ‘ä»¬ï¼Œæˆ‘ä»¬çš„æ§åˆ¶æ¯”ç‰¹å’Œç›®æ ‡æ¯”ç‰¹çš„å¯„å­˜å™¨ç°åœ¨å¤„äºçŠ¶æ€ï¼ˆ|00ã€‰ âˆ’ |01ã€‰ âˆ’ |10ã€‰ + |11ã€‰ï¼‰/ 2ã€‚
- en: Now that we have worked out the action of the `id` oracle, letâ€™s look at what
    the `not` oracle does to our input state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»è§£å†³äº†`id`é¢„è¨€è€…çš„ä½œç”¨ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹`not`é¢„è¨€è€…å¯¹æˆ‘ä»¬çš„è¾“å…¥çŠ¶æ€åšäº†ä»€ä¹ˆã€‚
- en: 'D.3.2 Example 2: The â€œnotâ€ oracle'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.2 ç¤ºä¾‹2ï¼šâ€œnotâ€é¢„è¨€è€…
- en: Letâ€™s repeat the analysis using the `not` oracle, the other balanced function.
    The oracle representing Merlin choosing Mordred is implemented with a series of
    `X` and `CNOT` operations as in table D.2.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é‡å¤ä½¿ç”¨`not`é¢„è¨€è€…ï¼Œå¦ä¸€ä¸ªå¹³è¡¡å‡½æ•°çš„åˆ†æã€‚è¡¨ç¤ºæ¢…æ—é€‰æ‹©è«å¾·é›·å¾·çš„é¢„è¨€è€…æ˜¯é€šè¿‡ä¸€ç³»åˆ—`X`å’Œ`CNOT`æ“ä½œå®ç°çš„ï¼Œå¦‚è¡¨D.2æ‰€ç¤ºã€‚
- en: Table D.2 The one-bit function `not` as a two-qubit oracle
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨D.2 ä¸€æ¯”ç‰¹å‡½æ•°`not`ä½œä¸ºåŒæ¯”ç‰¹é¢„è¨€è€…
- en: '| Function name | Function | Output of oracle | Q# operation |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•°å | å‡½æ•° | é¢„è¨€è€…çš„è¾“å‡º | Q#æ“ä½œ |'
- en: '| not | *f*(*x*) = Â¬*x* | &#124;*x*ã€‰&#124;*y* âŠ• Â¬*x*ã€‰ | `X(control); CNOT(control,
    target); X(control);` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| not | *f*(*x*) = Â¬*x* | &#124;*x*ã€‰&#124;*y* âŠ• Â¬*x*ã€‰ | `X(control); CNOT(control,
    target); X(control);` |'
- en: Letâ€™s jump to Python to see how to break down the operation of the `not` oracle.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è·³åˆ°Pythonï¼Œçœ‹çœ‹å¦‚ä½•åˆ†è§£`not`é¢„è¨€è€…çš„æ“ä½œã€‚
- en: Listing D.3 Using QuTiP again, now with the `not` oracle
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨D.3 å†æ¬¡ä½¿ç”¨QuTiPï¼Œè¿™æ¬¡ä½¿ç”¨`not`é¢„è¨€è€…
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: â¶ Prepares the control and target qubits in the |+âˆ’ã€‰ state exactly as before
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ æ­£å¦‚ä¹‹å‰ä¸€æ ·ï¼Œå‡†å¤‡æ§åˆ¶æ¯”ç‰¹å’Œç›®æ ‡æ¯”ç‰¹åœ¨|+âˆ’ã€‰çŠ¶æ€
- en: â· As in chapter 5, itâ€™s helpful to define variables I and X as shorthand for
    the identity matrix (qt.qeye) and the matrix representing the X operation, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: â· æ­£å¦‚ç¬¬5ç« ä¸­ä¸€æ ·ï¼Œå®šä¹‰å˜é‡Iå’ŒXä½œä¸ºå•ä½çŸ©é˜µï¼ˆqt.qeyeï¼‰å’Œè¡¨ç¤ºXæ“ä½œçš„çŸ©é˜µçš„ç®€ç§°æ˜¯æœ‰å¸®åŠ©çš„ã€‚
- en: â¸ This time our oracle is the â€œnotâ€ oracle, which we implement with the sequence
    of instructions X(control); CNOT(control, target); X(control); as per table D.2.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ è¿™æ¬¡æˆ‘ä»¬çš„é¢„è¨€è€…æ˜¯â€œnotâ€é¢„è¨€è€…ï¼Œæˆ‘ä»¬æŒ‰ç…§è¡¨D.2ä¸­çš„æŒ‡ä»¤åºåˆ—X(control); CNOT(control, target); X(control);æ¥å®ç°ã€‚
- en: 'â¹ The unitary operator for the oracle operation looks a bit different this
    time: it flips the target qubit when the control qubit is a |0ã€‰.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ è¿™æ¬¡é¢„è¨€è€…æ“ä½œçš„å•ä½ç®—ç¬¦çœ‹èµ·æ¥æœ‰äº›ä¸åŒï¼šå½“æ§åˆ¶æ¯”ç‰¹æ˜¯|0ã€‰æ—¶ï¼Œå®ƒç¿»è½¬ç›®æ ‡æ¯”ç‰¹ã€‚
- en: âº For instance, row 0 (00 in binary) tells us that |00ã€‰ is transformed to |01ã€‰.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: âº ä¾‹å¦‚ï¼Œç¬¬0è¡Œï¼ˆäºŒè¿›åˆ¶ä¸­çš„00ï¼‰å‘Šè¯‰æˆ‘ä»¬|00ã€‰è¢«è½¬æ¢æˆ|01ã€‰ã€‚
- en: â» Similarly, row 2 (10 in binary) tells us that |10ã€‰ is transformed to |10ã€‰;
    the oracle leaves that input alone.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: â» ç±»ä¼¼åœ°ï¼Œç¬¬äºŒè¡Œï¼ˆäºŒè¿›åˆ¶ä¸­çš„10ï¼‰å‘Šè¯‰æˆ‘ä»¬|10ã€‰è¢«è½¬æ¢æˆ|10ã€‰ï¼›é¢„è¨€è€…ä¿æŒé‚£ä¸ªè¾“å…¥ä¸å˜ã€‚
- en: â¼ The state after applying the oracle is (â€“|00ã€‰ + |01ã€‰ + |10ã€‰ âˆ’ |11ã€‰) / 2 =
    (â€“1)|+âˆ’ã€‰, precisely the same as before, aside from a global phase of â€“1.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: â¼ åº”ç”¨é¢„è¨€è€…åçš„çŠ¶æ€æ˜¯ï¼ˆâ€“|00ã€‰ + |01ã€‰ + |10ã€‰ âˆ’ |11ã€‰ï¼‰/ 2 = ï¼ˆâ€“1ï¼‰|+âˆ’ã€‰ï¼Œä¸ä¹‹å‰å®Œå…¨ç›¸åŒï¼Œé™¤äº†å…¨å±€ç›¸ä½ä¸ºâ€“1ã€‚
- en: Looking at these two examples, we got the same output state, except the signs
    are all flipped. This means if we multiplied one of the state vectors by a âˆ’1,
    they would both be the same. Multiplying an entire vector by a constant is referred
    to as *adding a global phase*. Since global phases cannot be observed through
    measurements, we got *exactly* the same information from applying the `id` and
    `not` oracles. We learned nothing about whether we applied `id` or `not`; and
    if we were able to compare the vectors, we would only know that we applied a balanced
    oracle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹è¿™ä¸¤ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ç›¸åŒçš„è¾“å‡ºçŠ¶æ€ï¼Œé™¤äº†ç¬¦å·éƒ½åè½¬äº†ã€‚è¿™æ„å‘³ç€å¦‚æœæˆ‘ä»¬å°†ä¸€ä¸ªçŠ¶æ€å‘é‡ä¹˜ä»¥ä¸€ä¸ªâˆ’1ï¼Œå®ƒä»¬å°±ä¼šç›¸åŒã€‚å°†æ•´ä¸ªå‘é‡ä¹˜ä»¥ä¸€ä¸ªå¸¸æ•°è¢«ç§°ä¸º*æ·»åŠ å…¨å±€ç›¸ä½*ã€‚ç”±äºå…¨å±€ç›¸ä½ä¸èƒ½é€šè¿‡æµ‹é‡è§‚å¯Ÿåˆ°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»åº”ç”¨`id`å’Œ`not`é¢„è¨€è€…å¾—åˆ°äº†*å®Œå…¨ç›¸åŒ*çš„ä¿¡æ¯ã€‚æˆ‘ä»¬æ²¡æœ‰å­¦åˆ°å…³äºæˆ‘ä»¬æ˜¯å¦åº”ç”¨äº†`id`æˆ–`not`çš„ä»»ä½•ä¸œè¥¿ï¼›å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿæ¯”è¾ƒå‘é‡ï¼Œæˆ‘ä»¬åªä¼šçŸ¥é“æˆ‘ä»¬åº”ç”¨äº†ä¸€ä¸ªå¹³è¡¡é¢„è¨€è€…ã€‚
- en: For comparison, letâ€™s see what the register looks like after we apply an oracle
    representing a *constant* function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ¯”è¾ƒï¼Œè®©æˆ‘ä»¬çœ‹çœ‹åœ¨åº”ç”¨è¡¨ç¤ºä¸€ä¸ª**å¸¸æ•°**å‡½æ•°çš„é¢„è¨€è€…ä¹‹åï¼Œå¯„å­˜å™¨çœ‹èµ·æ¥åƒä»€ä¹ˆã€‚
- en: 'D.3.3 Example 3: The â€œzeroâ€ oracle'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3.3 ç¤ºä¾‹3ï¼šâ€œzeroâ€é¢„è¨€è€…
- en: 'Once more, with feeling: letâ€™s use Python to break down how an oracle representing
    the constant function `zero` works. We want to use the `zero` oracle to show what
    happens differently when we apply an oracle representing a constant function.
    This oracle is especially easy to apply since it consists of applying no instructions
    at all. You can see all the ways to represent this in table D.3.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: å†æ¬¡ï¼Œå……æ»¡æ„Ÿæƒ…ï¼šè®©æˆ‘ä»¬ç”¨ Python æ¥åˆ†è§£è¡¨ç¤ºå¸¸é‡å‡½æ•° `zero` çš„æ±‚è§£å™¨æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚æˆ‘ä»¬æƒ³ä½¿ç”¨ `zero` æ±‚è§£å™¨æ¥å±•ç¤ºå½“æˆ‘ä»¬åº”ç”¨è¡¨ç¤ºå¸¸é‡å‡½æ•°çš„æ±‚è§£å™¨æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆä¸åŒã€‚è¿™ä¸ªæ±‚è§£å™¨ç‰¹åˆ«å®¹æ˜“åº”ç”¨ï¼Œå› ä¸ºå®ƒæ ¹æœ¬ä¸åŒ…å«ä»»ä½•æŒ‡ä»¤ã€‚ä½ å¯ä»¥åœ¨è¡¨
    D.3 ä¸­çœ‹åˆ°æ‰€æœ‰è¡¨ç¤ºæ–¹æ³•ã€‚
- en: Table D.3 The one-bit function `zero` as two-qubit oracles
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ D.3 ä¸€æ¯”ç‰¹å‡½æ•° `zero` ä½œä¸ºåŒé‡å­æ¯”ç‰¹æ±‚è§£å™¨
- en: '| Function name | Function | Output of oracle | Q# operation |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•°åç§° | å‡½æ•° | æ±‚è§£å™¨è¾“å‡º | Q# æ“ä½œ |'
- en: '| zero | *f*(*x*) = 0 | &#124;*x*ã€‰&#124;*y* âŠ• 0ã€‰ = &#124;*x*ã€‰&#124;*y*ã€‰ | (empty)
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| zero | *f*(*x*) = 0 | &#124;*x*ã€‰&#124;*y* âŠ• 0ã€‰ = &#124;*x*ã€‰&#124;*y*ã€‰ | (ç©º)
    |'
- en: In listing D.4, we can see that doing nothing on the control qubit and nothing
    on the target qubit can be simulated by doing nothing on the entire register.
    Thus, the `oracle` we create is the two-qubit identity matrix ğŸ™ âŠ— ğŸ™ for the `zero`
    oracle.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åˆ—è¡¨ D.4 ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨æ§åˆ¶é‡å­æ¯”ç‰¹å’Œç›®æ ‡é‡å­æ¯”ç‰¹ä¸Šéƒ½ä¸åšä»»ä½•æ“ä½œå¯ä»¥é€šè¿‡åœ¨æ•´ä¸ªå¯„å­˜å™¨ä¸Šä¸åšä»»ä½•æ“ä½œæ¥æ¨¡æ‹Ÿã€‚å› æ­¤ï¼Œæˆ‘ä»¬åˆ›å»ºçš„ `oracle`
    å¯¹äº `zero` æ±‚è§£å™¨æ¥è¯´æ˜¯ä¸¤ä¸ªé‡å­æ¯”ç‰¹çš„å•ä½çŸ©é˜µ ğŸ™ âŠ— ğŸ™ã€‚
- en: Listing D.4 Computing the `zero` oracle transformation
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨ D.4 è®¡ç®— `zero` æ±‚è§£å™¨è½¬æ¢
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: â¶ Doing nothing on the control qubit and nothing on the target qubit can be
    simulated by doing nothing on the entire register.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ åœ¨æ§åˆ¶é‡å­æ¯”ç‰¹å’Œç›®æ ‡é‡å­æ¯”ç‰¹ä¸Šéƒ½ä¸åšä»»ä½•æ“ä½œå¯ä»¥é€šè¿‡åœ¨æ•´ä¸ªå¯„å­˜å™¨ä¸Šä¸åšä»»ä½•æ“ä½œæ¥æ¨¡æ‹Ÿã€‚
- en: â· The output state differs by more than a global phase from the id oracle. Thereâ€™s
    no scalar we can multiply by a global phase to turn the id output into the zero
    output.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: â· è¾“å‡ºçŠ¶æ€ä¸èº«ä»½æ±‚è§£å™¨çš„å…¨å±€ç›¸ä½ä¸åŒã€‚æ²¡æœ‰æ ‡é‡æˆ‘ä»¬å¯ä»¥ä¹˜ä»¥å…¨å±€ç›¸ä½å°†èº«ä»½è¾“å‡ºè½¬æ¢ä¸ºé›¶è¾“å‡ºã€‚
- en: 'Here we see our first difference from the previous listing: the minus signs
    are in different places on our state vector. Before, we used the `id` oracle and
    got that the output state was (|00ã€‰ âˆ’ |01ã€‰ âˆ’ |10ã€‰ + |11ã€‰) / 2\. Using the `zero`
    oracle, the output state is (|00ã€‰ âˆ’ |01ã€‰ + |10ã€‰ âˆ’ |11ã€‰) / 2\. There is no number
    we can multiply the entire vector by to change it into either `[[0.5],[-0.5],[-0.5],[0.5]]`
    or `[[-0.5],[0.5],[0.5], [-0.5]]`. To see how this difference leads to us telling
    for sure whether we have a balanced or constant oracle, letâ€™s continue to the
    next step of the Deutschâ€“Jozsa algorithm.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬ä¸ä¹‹å‰çš„åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªä¸åŒç‚¹ï¼šè´Ÿå·å‡ºç°åœ¨çŠ¶æ€å‘é‡ä¸­çš„ä½ç½®ä¸åŒã€‚ä¹‹å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† `id` æ±‚è§£å™¨ï¼Œå¾—åˆ°è¾“å‡ºçŠ¶æ€æ˜¯ (|00ã€‰ âˆ’ |01ã€‰
    âˆ’ |10ã€‰ + |11ã€‰) / 2ã€‚ä½¿ç”¨ `zero` æ±‚è§£å™¨ï¼Œè¾“å‡ºçŠ¶æ€æ˜¯ (|00ã€‰ âˆ’ |01ã€‰ + |10ã€‰ âˆ’ |11ã€‰) / 2ã€‚æ²¡æœ‰æ•°å­—æˆ‘ä»¬å¯ä»¥ä¹˜ä»¥æ•´ä¸ªå‘é‡æ¥å°†å…¶è½¬æ¢ä¸º
    `[[0.5],[-0.5],[-0.5],[0.5]]` æˆ– `[[-0.5],[0.5],[0.5], [-0.5]]`ã€‚ä¸ºäº†äº†è§£è¿™ç§å·®å¼‚å¦‚ä½•ä½¿æˆ‘ä»¬èƒ½å¤Ÿç¡®å®šæˆ‘ä»¬æœ‰ä¸€ä¸ªå¹³è¡¡çš„æˆ–å¸¸é‡æ±‚è§£å™¨ï¼Œè®©æˆ‘ä»¬ç»§ç»­åˆ°
    Deutsch-Jozsa ç®—æ³•çš„ä¸‹ä¸€æ­¥ã€‚
- en: 'Exercise D.1: Try the â€œoneâ€ oracle'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹  D.1ï¼šå°è¯•ä½¿ç”¨â€œoneâ€æ±‚è§£å™¨
- en: See if you can use the Python tricks we have used previously to work out how
    the states of the `target` and `control` qubits change when the `one` oracle is
    applied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰ä½¿ç”¨çš„ Python æŠ€å·§æ¥æ‰¾å‡ºå½“åº”ç”¨ `one` æ±‚è§£å™¨æ—¶ `target` å’Œ `control` é‡å­æ¯”ç‰¹çš„çŠ¶æ€æ˜¯å¦‚ä½•å˜åŒ–çš„ã€‚
- en: Exercise solutions
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ç»ƒä¹ è§£ç­”
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the appendix we are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ä¹¦æ‰€æœ‰ç»ƒä¹ çš„è§£ç­”éƒ½å¯ä»¥åœ¨é…å¥—ä»£ç ä»“åº“ä¸­æ‰¾åˆ°ï¼š[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)ã€‚åªéœ€è¿›å…¥æˆ‘ä»¬æ‰€åœ¨çš„é™„å½•æ–‡ä»¶å¤¹ï¼Œå¹¶æ‰“å¼€æåŠç»ƒä¹ è§£ç­”çš„
    Jupyter ç¬”è®°æœ¬ã€‚
- en: 'D.4 Steps 3 and 4: Undo the preparation on the target qubit, and measure'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.4 æ­¥éª¤ 3 å’Œ 4ï¼šæ’¤é”€ç›®æ ‡é‡å­æ¯”ç‰¹çš„å‡†å¤‡ï¼Œå¹¶æµ‹é‡
- en: At this point, it is much easier to make sense of the output if we undo the
    steps we used to prepare |+âˆ’ã€‰ so that everything is back in the computational
    basis (|00ã€‰ ... |11ã€‰). To review, table D.4 has the state vectors for all four
    oracles (three of which we worked out earlier).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œå¦‚æœæˆ‘ä»¬æ’¤é”€æˆ‘ä»¬ç”¨æ¥å‡†å¤‡ |+âˆ’ã€‰ çš„æ­¥éª¤ï¼Œä½¿ä¸€åˆ‡å›åˆ°è®¡ç®—åŸºï¼ˆ|00ã€‰ ... |11ã€‰ï¼‰ï¼Œé‚£ä¹ˆç†è§£è¾“å‡ºå°±æ›´å®¹æ˜“äº†ã€‚ä¸ºäº†å›é¡¾ï¼Œè¡¨ D.4 åŒ…å«äº†æ‰€æœ‰å››ä¸ªæ±‚è§£å™¨çš„çŠ¶æ€å‘é‡ï¼ˆå…¶ä¸­ä¸‰ä¸ªæ˜¯æˆ‘ä»¬ä¹‹å‰è§£å†³çš„ï¼‰ã€‚
- en: Table D.4 The state of the register after applying oracles
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ D.4 åº”ç”¨æ±‚è§£å™¨åçš„å¯„å­˜å™¨çŠ¶æ€
- en: '| Function name | State of the register after applying the oracle |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•°åç§° | åº”ç”¨æ±‚è§£å™¨åçš„å¯„å­˜å™¨çŠ¶æ€ |'
- en: '| `zero` | [[ 0.5], [â€“0.5], [ 0.5], [â€“0.5]] |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `zero` | [[ 0.5], [â€“0.5], [ 0.5], [â€“0.5]] |'
- en: '| `one` | [[â€“0.5], [ 0.5], [â€“0.5], [ 0.5]] |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `one` | [[â€“0.5], [ 0.5], [â€“0.5], [ 0.5]] |'
- en: '| `id` | [[ 0.5], [â€“0.5], [â€“0.5], [ 0.5]] |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `id` | [[ 0.5], [â€“0.5], [â€“0.5], [ 0.5]] |'
- en: '| `not` | [[â€“0.5], [ 0.5], [ 0.5], [â€“0.5]] |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `not` | [[â€“0.5], [ 0.5], [ 0.5], [â€“0.5]] |'
- en: Now we want to undo our preparation steps on the target qubit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æƒ³è¦æ’¤é”€å¯¹ç›®æ ‡é‡å­æ¯”ç‰¹çš„å‡†å¤‡æ­¥éª¤ã€‚
- en: Why do we do â€œunprepareâ€ the target qubit?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦â€œæœªå‡†å¤‡â€ç›®æ ‡é‡å­æ¯”ç‰¹ï¼Ÿ
- en: In chapter 7, we see that we need to reset our qubits to the |0ã€‰ state before
    returning them to the target machine. At this point, our target qubit is always
    in the |âˆ’ã€‰ state, *no matter which oracle we use*. This means that after applying
    the oracle, we know exactly how to put it back to |0ã€‰. As in chapter 7, this helps
    us avoid an additional measurement, which can be expensive on some quantum devices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¬¬7ç« ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°åœ¨å°†é‡å­æ¯”ç‰¹è¿”å›ç›®æ ‡æœºå™¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒä»¬é‡ç½®åˆ°|0ã€‰çŠ¶æ€ã€‚åœ¨è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬çš„ç›®æ ‡é‡å­æ¯”ç‰¹æ€»æ˜¯å¤„äº|âˆ’ã€‰çŠ¶æ€ï¼Œ*æ— è®ºä½¿ç”¨å“ªä¸ªé¢„è¨€æœº*ã€‚è¿™æ„å‘³ç€åœ¨åº”ç”¨é¢„è¨€æœºä¹‹åï¼Œæˆ‘ä»¬ç¡®åˆ‡åœ°çŸ¥é“å¦‚ä½•å°†å…¶æ”¾å›|0ã€‰çŠ¶æ€ã€‚æ­£å¦‚ç¬¬7ç« æ‰€è¿°ï¼Œè¿™æœ‰åŠ©äºæˆ‘ä»¬é¿å…é¢å¤–çš„æµ‹é‡ï¼Œè¿™åœ¨æŸäº›é‡å­è®¾å¤‡ä¸Šå¯èƒ½å¾ˆæ˜‚è´µã€‚
- en: Note that we can safely return the target qubit to |âˆ’ã€‰ without affecting the
    results when we measure the control qubit, as the oracle call is the only two-qubit
    operation in the Deutschâ€“Jozsa algorithm. As we see in chapter 5, doing single-qubit
    operations on one qubit canâ€™t affect results on another qubit; otherwise, we would
    be able to send information faster than light!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œå½“æˆ‘ä»¬æµ‹é‡æ§åˆ¶é‡å­æ¯”ç‰¹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å®‰å…¨åœ°å°†ç›®æ ‡é‡å­æ¯”ç‰¹è¿”å›åˆ°|âˆ’ã€‰çŠ¶æ€è€Œä¸å½±å“ç»“æœï¼Œå› ä¸ºé¢„è¨€æœºè°ƒç”¨æ˜¯Deutschâ€“Jozsaç®—æ³•ä¸­å”¯ä¸€çš„åŒé‡å­æ¯”ç‰¹æ“ä½œã€‚æ­£å¦‚æˆ‘ä»¬åœ¨ç¬¬5ç« ä¸­çœ‹åˆ°çš„ï¼Œå¯¹ä¸€ä¸ªé‡å­æ¯”ç‰¹æ‰§è¡Œå•é‡å­æ¯”ç‰¹æ“ä½œä¸ä¼šå½±å“å¦ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„ç»“æœï¼›å¦åˆ™ï¼Œæˆ‘ä»¬å°±èƒ½ä»¥æ¯”å…‰é€Ÿæ›´å¿«çš„é€Ÿåº¦ä¼ é€’ä¿¡æ¯ï¼
- en: Letâ€™s try this by undoing the preparation on the register from the oracle representing
    the `id` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é€šè¿‡æ’¤é”€è¡¨ç¤º`id`å‡½æ•°çš„å¯„å­˜å™¨çš„å‡†å¤‡æ­¥éª¤æ¥å°è¯•ä¸€ä¸‹ã€‚
- en: Listing D.5 The `id` oracle output in the computational basis
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—è¡¨D.5 è®¡ç®—åŸºä¸‹çš„`id`é¢„è¨€æœºè¾“å‡º
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: â¶ Itâ€™s helpful to define a shorthand for the identity matrix ğŸ™, which we use
    to represent what happens to a qubit when we donâ€™t apply any instruction to it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: â¶ å®šä¹‰ä¸€ä¸ªç®€å†™æ¥è¡¨ç¤ºå•ä½çŸ©é˜µğŸ™æ˜¯æœ‰å¸®åŠ©çš„ï¼Œæˆ‘ä»¬ç”¨å®ƒæ¥è¡¨ç¤ºå½“æˆ‘ä»¬ä¸å¯¹é‡å­æ¯”ç‰¹åº”ç”¨ä»»ä½•æŒ‡ä»¤æ—¶å®ƒä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: â· Reproduces the register for the oracle representing the id function, just
    after the oracle is applied
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: â· åœ¨é¢„è¨€æœºåº”ç”¨åç«‹å³é‡ç°è¡¨ç¤ºidå‡½æ•°çš„å¯„å­˜å™¨
- en: â¸ Since weâ€™re transforming a two-qubit state, we need to say what happens to
    each qubit to get our matrix. We do this using the tensor function again.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: â¸ ç”±äºæˆ‘ä»¬æ­£åœ¨è½¬æ¢ä¸€ä¸ªåŒé‡å­æ¯”ç‰¹çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦è¯´æ˜æ¯ä¸ªé‡å­æ¯”ç‰¹å‘ç”Ÿäº†ä»€ä¹ˆä»¥å¾—åˆ°æˆ‘ä»¬çš„çŸ©é˜µã€‚æˆ‘ä»¬å†æ¬¡ä½¿ç”¨å¼ é‡å‡½æ•°æ¥åšè¿™ä»¶äº‹ã€‚
- en: 'â¹ The output is much easier to read: the register is in the state (|01ã€‰ âˆ’ |11ã€‰)
    / âˆš2.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: â¹ è¾“å‡ºæ›´å®¹æ˜“é˜…è¯»ï¼šå¯„å­˜å™¨å¤„äºçŠ¶æ€ï¼ˆ|01ã€‰ âˆ’ |11ã€‰ï¼‰/ âˆš2ã€‚
- en: âº In our Q# program, we used the X instruction to return the target qubit to
    |0ã€‰ before releasing it, simulated by the QuTiP function sigmax().
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: âº åœ¨æˆ‘ä»¬çš„Q#ç¨‹åºä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†XæŒ‡ä»¤æ¥åœ¨é‡Šæ”¾ä¹‹å‰å°†ç›®æ ‡é‡å­æ¯”ç‰¹è¿”å›åˆ°|0ã€‰ï¼Œè¿™æ˜¯é€šè¿‡QuTiPå‡½æ•°sigmax()æ¨¡æ‹Ÿçš„ã€‚
- en: â» Since the X instruction flips its argument, applying the *X* matrix gives
    us the state (|00ã€‰ âˆ’ |10ã€‰) / âˆš2.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: â» ç”±äºXæŒ‡ä»¤ç¿»è½¬å…¶å‚æ•°ï¼Œåº”ç”¨*X*çŸ©é˜µç»™æˆ‘ä»¬çŠ¶æ€ï¼ˆ|00ã€‰ âˆ’ |10ã€‰ï¼‰/ âˆš2ã€‚
- en: â¼ We can use QuTiP to confirm that another way of writing (|00ã€‰ âˆ’ |10ã€‰) / âˆš2
    is (H|1ã€‰) âŠ— |0ã€‰ = |â€“0ã€‰.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: â¼ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨QuTiPæ¥ç¡®è®¤å¦ä¸€ç§è¡¨ç¤ºï¼ˆ|00ã€‰ âˆ’ |10ã€‰ï¼‰/ âˆš2çš„æ–¹æ³•æ˜¯ï¼ˆH|1ã€‰ï¼‰âŠ—|0ã€‰ = |â€“0ã€‰ã€‚
- en: â½ We can simulate the MResetX operation by applying HÂ and then measuring in
    the *Z*-basis.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: â½ æˆ‘ä»¬å¯ä»¥é€šè¿‡åº”ç”¨Hç„¶åæµ‹é‡åœ¨*Z*-åŸºä¸‹æ¥æ¨¡æ‹ŸMResetXæ“ä½œã€‚
- en: â¾ The state of our register immediately before measuring has a 1 in row 2 (10
    in binary), so the state of our register is |10ã€‰, and we will measure One with
    certainty.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: â¾ åœ¨æµ‹é‡ä¹‹å‰ï¼Œæˆ‘ä»¬çš„å¯„å­˜å™¨çŠ¶æ€åœ¨ç¬¬äºŒè¡Œæœ‰ä¸€ä¸ª1ï¼ˆäºŒè¿›åˆ¶ä¸­çš„10ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬çš„å¯„å­˜å™¨çŠ¶æ€æ˜¯|10ã€‰ï¼Œæˆ‘ä»¬å°†è‚¯å®šæµ‹é‡åˆ°ä¸€ä¸ªOneã€‚
- en: Tip We use the `MResetX` operation from the Q# standard libraries to measure
    in the *X*-basis. An *X*-basis measurement returns `Zero` when its argument is
    in |+ã€‰ and returns a `One` result when its argument is in |âˆ’ã€‰. Thus, we can simulate
    the `MResetX` operation by applying *H* and then measuring in the *z* -basis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: æç¤ºï¼šæˆ‘ä»¬ä½¿ç”¨Q#æ ‡å‡†åº“ä¸­çš„`MResetX`æ“ä½œæ¥åœ¨*X*-åŸºä¸‹æµ‹é‡ã€‚å½“å…¶å‚æ•°åœ¨|+ã€‰æ—¶ï¼Œ*X*-åŸºæµ‹é‡è¿”å›`Zero`ï¼Œå½“å…¶å‚æ•°åœ¨|âˆ’ã€‰æ—¶è¿”å›`One`ç»“æœã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åº”ç”¨*H*ç„¶åæµ‹é‡åœ¨*z*åŸºä¸‹æ¥æ¨¡æ‹Ÿ`MResetX`æ“ä½œã€‚
- en: Looking at the final vector in listing D.5, we can see that it represents the
    state |10ã€‰. If we were to measure the control qubit from that state, we would
    get the classical bit `One` 100% of the time. In the Algorithm.qs file we write
    in chapter 8, we return to the user that an oracle is balanced if we measured
    `One` on the control qubit, so we correctly conclude that `id` is a balanced oracle!
    The fact that we will measure `One` on the control bit every time is really cool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹åˆ—è¡¨ D.5 ä¸­çš„æœ€ç»ˆå‘é‡ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å®ƒä»£è¡¨çŠ¶æ€ |10ã€‰ã€‚å¦‚æœæˆ‘ä»¬ä»è¯¥çŠ¶æ€æµ‹é‡æ§åˆ¶é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬å°†ä¼š 100% çš„æ—¶é—´å¾—åˆ°ç»å…¸æ¯”ç‰¹ `One`ã€‚åœ¨ç¬¬å…«ç« ä¸­æˆ‘ä»¬ç¼–å†™çš„
    Algorithm.qs æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å‘ç”¨æˆ·è¿”å›ï¼Œå¦‚æœæˆ‘ä»¬åœ¨æ§åˆ¶é‡å­æ¯”ç‰¹ä¸Šæµ‹é‡åˆ° `One`ï¼Œåˆ™æˆ–ç„¶å­æ˜¯å¹³è¡¡çš„ï¼Œå› æ­¤æˆ‘ä»¬æ­£ç¡®åœ°å¾—å‡ºç»“è®ºï¼Œ`id` æ˜¯ä¸€ä¸ªå¹³è¡¡çš„æˆ–ç„¶å­ï¼æ¯æ¬¡æˆ‘ä»¬éƒ½ä¼šåœ¨æ§åˆ¶æ¯”ç‰¹ä¸Šæµ‹é‡åˆ°
    `One` çš„è¿™ä¸€äº‹å®çœŸçš„å¾ˆé…·ã€‚
- en: 'Note Although some quantum algorithms are random, like the QRNG example from
    chapter 2 or Morganaâ€™s and Lancelotâ€™s game from chapter 7, they donâ€™t need to
    be. In fact, the Deutschâ€“Jozsa algorithm is *deterministic* : we get the same
    answer every time we run it.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼šå°½ç®¡ä¸€äº›é‡å­ç®—æ³•æ˜¯éšæœºçš„ï¼Œä¾‹å¦‚ç¬¬äºŒç« ä¸­çš„ QRNG ç¤ºä¾‹æˆ–ç¬¬ä¸ƒç« ä¸­ Morgana å’Œ Lancelot çš„æ¸¸æˆï¼Œä½†å®ƒä»¬å¹¶ä¸éœ€è¦æ˜¯éšæœºçš„ã€‚äº‹å®ä¸Šï¼ŒDeutsch-Jozsa
    ç®—æ³•æ˜¯ **ç¡®å®šæ€§çš„**ï¼šæˆ‘ä»¬æ¯æ¬¡è¿è¡Œå®ƒéƒ½ä¼šå¾—åˆ°ç›¸åŒçš„ç­”æ¡ˆã€‚
- en: 'From these examples, we have an important observation (see table D.5): applying
    an oracle to the control and target qubits can affect the state of the control
    qubit.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ä»è¿™äº›ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªé‡è¦çš„è§‚å¯Ÿï¼ˆè§è¡¨ D.5ï¼‰ï¼šå°†æˆ–ç„¶å­åº”ç”¨äºæ§åˆ¶é‡å­æ¯”ç‰¹å’Œç›®æ ‡é‡å­æ¯”ç‰¹å¯ä»¥å½±å“æ§åˆ¶é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚
- en: Table D.5 The vectors representing the state of the register after applying
    the various oracles
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: è¡¨ D.5 åº”ç”¨å„ç§æˆ–ç„¶å­åå¯„å­˜å™¨çŠ¶æ€çš„å‘é‡è¡¨ç¤º
- en: '| Function name | Register state just before measurement | Result of measuring
    control qubit along *z* |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| å‡½æ•°å | æµ‹é‡å‰çš„å¯„å­˜å™¨çŠ¶æ€ | æ²¿ *z* æµ‹é‡æ§åˆ¶é‡å­æ¯”ç‰¹çš„ç»“æœ |'
- en: '| `zero` | [[ 1], [ 0], [ 0], [ 0]] | `Zero` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `zero` | [[ 1], [ 0], [ 0], [ 0]] | `Zero` |'
- en: '| `one` | [[â€“1], [ 0], [ 0], [ 0]] | `Zero` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `one` | [[â€“1], [ 0], [ 0], [ 0]] | `Zero` |'
- en: '| `id` | [[ 0], [ 0], [ 1], [ 0]] | `One` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `id` | [[ 0], [ 0], [ 1], [ 0]] | `One` |'
- en: '| `not` | [[ 0], [ 0], [â€“1], [ 0]] | `One` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `not` | [[ 0], [ 0], [â€“1], [ 0]] | `One` |'
