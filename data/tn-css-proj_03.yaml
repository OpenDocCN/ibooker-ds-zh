- en: 3 Creating a responsive animated loading screen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 创建一个响应式的动画加载界面
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating basic shapes using Scalable Vector Graphics (SVGs)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可缩放矢量图形 (SVG) 创建基本形状
- en: Finding out the difference between viewboxes and viewports in SVGs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 SVG 中 viewbox 和 viewport 的区别
- en: Understanding keyframes and animating SVGs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关键帧和动画 SVG
- en: Using animation properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画属性
- en: Styling SVGs with CSS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSS 样式化 SVG
- en: Styling an HTML progress bar element with appearance properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外观属性样式化 HTML 进度条元素
- en: We see loaders in most applications today. These loaders communicate to the
    user that something is loading, uploading, or waiting. They give the user confidence
    that something is happening.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在当今的大多数应用程序中都能看到加载器。这些加载器向用户传达正在加载、上传或等待的信息。它们给用户带来信心，表明正在发生某些事情。
- en: Without some sort of indicator to tell the user that something is happening,
    they may try reloading, click the link again, or give up and leave. We should
    be using some sort of progress indicator when an action takes longer than 1 second,
    which is when users tend to lose focus and question whether there’s a problem.
    As well as having a graphic showing that something is happening, the loader should
    be accompanied by text that tells the user what is happening to improve the accessibility
    of the web page for screen readers and other assistive technologies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有某种指示器告诉用户正在发生某些事情，他们可能会尝试重新加载，再次点击链接，或者放弃并离开。当操作超过 1 秒时，我们应该使用某种进度指示器，这时用户往往会失去注意力并质疑是否存在问题。除了显示正在发生的事情的图形外，加载器还应伴随文本，告诉用户正在发生什么，以改善屏幕阅读器和其他辅助技术的网页可访问性。
- en: For our animation, we’ll be looking into the CSS Animation Module, understanding
    the animation property, keyframes, and transitions, as well as accessibility and
    respect for user preferences.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的动画，我们将研究 CSS 动画模块，理解动画属性、关键帧和过渡，以及可访问性和对用户偏好的尊重。
- en: 3.1 Setup
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 设置
- en: In this project, we’ll be creating rectangles within an SVG. We’ll see what
    SVGs offer and understand the slight differences between styling HTML elements
    and SVG elements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将在 SVG 中创建矩形。我们将了解 SVG 提供的内容，并理解样式化 HTML 元素和 SVG 元素之间的细微差别。
- en: We’ll also create a progress bar, which shows the user how much of the task
    has been completed and how much is left to go. We’ll use the HTML `<progress>`
    element and then look at how we can edit the browser’s default styles and apply
    our own. Overall, we want to create a consistent, responsive loader that works
    across devices. Figure 3.1 shows the result.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个进度条，显示用户完成了多少任务以及还剩下多少任务。我们将使用 HTML `<progress>` 元素，然后查看我们如何编辑浏览器的默认样式并应用自己的样式。总的来说，我们希望创建一个一致、响应式的加载器，能够在各种设备上工作。图
    3.1 显示了结果。
- en: '![](../Images/03-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-01.png)'
- en: Figure 3.1 Goal for this chapter
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 本章目标
- en: The code for this project is in the GitHub repository ([https://github.com/michaelgearon/Tiny-CSS-Projects](https://github.com/michaelgearon/Tiny-CSS-Projects))
    in the chapter 3 folder. You can find a demonstration of the completed project
    on CodePen at [https://codepen.io/michaelgearon/pen/eYvVVre](https://codepen.io/michaelgearon/pen/eYvVVre).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的代码位于 GitHub 仓库中（[https://github.com/michaelgearon/Tiny-CSS-Projects](https://github.com/michaelgearon/Tiny-CSS-Projects)）的第
    3 章文件夹内。您可以在 CodePen 上找到完成项目的演示 [https://codepen.io/michaelgearon/pen/eYvVVre](https://codepen.io/michaelgearon/pen/eYvVVre)。
- en: 3.2 SVG basics
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 SVG 基础
- en: '*SVG* stands for *Scalable Vector Graphics.* SVGs are written in an XML-based
    markup language and consist of vectors on a Cartesian plane. Vector graphics can
    be coded from scratch but often are created in a graphics program such as Adobe
    Illustrator, Figma, or Sketch. Then they’re exported in the SVG file format and
    can then be opened in a code text editor.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*SVG* 代表 *可缩放矢量图形*。SVG 是一种基于 XML 的标记语言，由笛卡尔平面上的矢量组成。矢量图形可以从头开始编写，但通常是在 Adobe
    Illustrator、Figma 或 Sketch 等图形程序中创建。然后以 SVG 文件格式导出，并可以在代码文本编辑器中打开。'
- en: A *vector* is a mathematical formula that defines a geometric primitive. Lines,
    polygons, curves, circles, and rectangles are all examples of geometric primitives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量* 是一个定义了几何原初的数学公式。线条、多边形、曲线、圆和矩形都是几何原初的例子。'
- en: A *Cartesian coordinate system* in a plane is a grid-based system that defines
    a point by using a pair of numerical coordinates based on the point’s distance
    from two perpendicular axes. The location where these two axes cross is the *origin*,
    which has a coordinate value of `(0,` `0)`. Think back to math class; when you
    were asked to plot lines on a graph, you were using a Cartesian coordinate system.
    Essentially, SVGs are shapes on a coordinate plane written in XML.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 平面上的 *笛卡尔坐标系* 是一个基于网格的系统，它使用一对基于点到两条垂直轴距离的数值坐标来定义一个点。这两条轴交叉的位置是 *原点*，其坐标值为 `(0,
    0)`。回想一下数学课；当被要求在图上绘制线条时，你就是在使用笛卡尔坐标系。本质上，SVG 是用 XML 编写的坐标平面上的形状。
- en: By contrast, PNGs, JPEGs, and GIFs are *raster images*, which are created by
    using a grid of pixels. Figure 3.2 illustrates the difference between raster and
    vector graphics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，PNG、JPEG 和 GIF 是 *位图图像*，它们是通过使用像素网格创建的。图 3.2 展示了位图和矢量图形之间的区别。
- en: '![](../Images/03-02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-02.png)'
- en: Figure 3.2 Raster versus vector graphics
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 矢量图形与位图图形的比较
- en: SVGs have many advantages over raster images, including being infinitely scalable.
    We can shrink or enlarge the image as much as we want without losing quality.
    We can’t enlarge raster images without seeing *pixelation*, which results from
    enlarging the grid of pixels that renders the individual squares of the grid visible.
    By contrast, when we enlarge an SVG, we’re setting shapes and lines on a coordinate
    plane programmatically; the paths between points are redrawn, and the quality
    doesn’t degrade.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 相比于位图图像有许多优势，包括无限可缩放。我们可以将图像缩小或放大到我们想要的程度，而不会丢失质量。我们无法在不看到 *像素化* 的情况下放大位图图像，这是由于放大渲染网格中的像素网格，使得网格的各个小方块变得可见。相比之下，当我们放大
    SVG 时，我们是在坐标平面上程序化地设置形状和线条；点之间的路径被重新绘制，质量不会降低。
- en: Because SVGs are written in XML, we can place SVG code directly in our HTML
    and access, manipulate, and edit it in much the same way that we do our other
    HTML elements. SVGs are to graphics as HTML is to web pages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 SVG 是用 XML 编写的，所以我们可以直接在我们的 HTML 中放置 SVG 代码，并以与我们处理其他 HTML 元素相同的方式访问、操作和编辑它。SVG
    对于图形来说，就像 HTML 对于网页一样。
- en: Rasters, however, are a better choice for dealing with images that are highly
    complex, such as photos. It’s possible to create a photorealistic image by using
    an SVG, but it wouldn’t be practical. The file size and, therefore, load performance
    are significantly larger for vector graphics than for raster images.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于处理高度复杂的图像，如照片，位图是一个更好的选择。使用 SVG 创建逼真的图像是可能的，但这并不实用。矢量图形的文件大小和因此的加载性能比位图图像大得多。
- en: The most common use case for SVGs are logos, icons, and loaders. We use them
    for logos because logos are often simple images that need to be crisp regardless
    of the size or medium. Furthermore, it’s not uncommon for a company or product
    to have several versions of a logo for use on a dark background versus a light
    background. Recoloring, simplicity, and scaling are other reasons why we use SVGs
    for icons.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 最常见的用途是标志、图标和加载器。我们使用它们作为标志，因为标志通常是简单的图像，需要无论大小或媒介都保持清晰。此外，一个公司或产品拥有几个版本的标志，用于深色背景和浅色背景的情况并不少见。重新着色、简洁和缩放也是我们为什么使用
    SVG 作为图标的原因。
- en: We use SVGs for loaders because unlike their raster counterparts, they allow
    us to add animations inside the image itself. We can isolate an individual element
    inside the graphic and apply CSS or JavaScript to that individual piece—an exercise
    that isn’t possible with rasters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 SVG 作为加载器，因为与它们的位图对应物不同，它们允许我们在图像内部添加动画。我们可以将图形内的单个元素隔离开来，并应用 CSS 或 JavaScript
    到这个单独的部分——这是位图无法做到的。
- en: Earlier, we mentioned that SVGs are based on a Cartesian plane (a 2D coordinate
    plane). Let’s look into what that means and how it works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到 SVG 是基于笛卡尔坐标系（一个二维坐标平面）。让我们来看看这意味着什么以及它是如何工作的。
- en: 3.2.1 Positions of SVG elements
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 SVG 元素的定位
- en: When we’re working with SVG elements, the way to think about positioning is
    to imagine that we’re placing elements on a grid. Everything starts at `(0,0)`
    (the origin) which is the top-left corner of the SVG document. The higher the
    `x` or `y` value is, the farther it is from the top-left corner. Figure 3.3 expands
    on the example of the boat in figure 3.2, adding the origin and the coordinate
    values for each shape.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理SVG元素时，考虑定位的方式是想象我们在一个网格上放置元素。一切从`(0,0)`（原点）开始，这是SVG文档的左上角。`x`或`y`值越高，它离左上角就越远。图3.3在图3.2的船的例子上进行了扩展，增加了每个形状的原点和坐标值。
- en: '![](../Images/03-03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-03.png)'
- en: Figure 3.3 Positioning elements on a coordinate plane
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 在坐标平面上定位元素
- en: The loader in our project is composed of a series of 11 rectangles. To place
    them, we need to think of their positions on a coordinate plane, taking both their
    widths and the gaps between them into consideration.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中的加载器由一系列11个矩形组成。为了放置它们，我们需要考虑它们在坐标平面上的位置，包括它们的宽度和它们之间的间隙。
- en: 3.2.2 Viewport
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 视口
- en: 'The *viewport* is the area in which the user can see the SVG. It’s set by two
    attributes: `width` and `height`. Think of the viewport as being a picture frame:
    it sets the size of the frame but doesn’t affect the size of the graphic it contains.
    If we place an image inside a picture frame that’s larger than the frame, however,
    we have overflow. The same thing happens to our SVG. As in CSS positioning, viewport
    measurements have their origin in the top-left corner of the SVG (figure 3.4).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`视口`是用户可以看到SVG的区域。它由两个属性设置：`width`和`height`。将视口想象成一个画框：它设置了画框的大小，但不会影响其中图形的大小。如果我们在一个比画框大的画框内放置一个图像，那么就会发生溢出。同样的事情也会发生在我们的SVG上。在CSS定位中，视口测量值以SVG的左上角为起点（图3.4）。'
- en: '![](../Images/03-04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-04.png)'
- en: Figure 3.4 SVGs with and without a defined viewport
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 带有和没有定义视口的SVG
- en: The viewport for our loader will be
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器的视口将是
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The width is set at `100%`, but 100% of what? We’re dictating that the loader
    will take 100% of the available space it’s given by its parent item.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度设置为`100%`，但100%是指什么？我们规定加载器将占用其父项提供的100%的可用空间。
- en: The following listing shows our starting HTML. We see that our loader is nested
    inside a section; therefore, our loader will be the same width as that section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了我们的起始HTML。我们看到我们的加载器嵌套在一个部分中；因此，我们的加载器将与该部分的宽度相同。
- en: Listing 3.1 Starting HTML
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 开始使用HTML
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Loader with added viewport of 100% width by 300-pixel height
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加载器增加了100%宽度、300像素高度的视口
- en: ② The progress bar, which we address later in the chapter
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们将在本章后面讨论的进度条
- en: We have some starting CSS as well (listing 3.2). The background (`<body>`),
    `<section>`, header (`<h1>`), and paragraph (`<p>`) have been prestyled to focus
    on the loader, progress bar, and animations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些起始CSS（列表3.2）。背景（`<body>`）、`<section>`、标题（`<h1>`）和段落（`<p>`）已经被预先样式化，以关注加载器、进度条和动画。
- en: Listing 3.2 Starting CSS
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 开始使用CSS
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Start of rule styling the loader’s container
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ① 规则样式开始，用于样式化加载器的容器
- en: ② Layout using flexbox to set the child items in the column direction, centering
    horizontally and setting equal spaces between elements
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用flexbox布局，将子项设置为列方向，水平居中，并设置元素之间的等间距
- en: '③ Margin written using the shorthand property: top and bottom, 40px margin;
    left and right, auto'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用缩写属性编写的边距：顶部和底部，40像素边距；左侧和右侧，自动
- en: ④ Typography setting the font weight to light, in the Roboto font, with a fallback
    of sans-serif and centering the text
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 字体设置将字体重量设置为轻，使用Roboto字体，回退为无衬线字体，并居中文本
- en: ⑤ Sets the color to white using RGB
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用RGB设置颜色为白色
- en: ⑥ End of rule styling the loader’s container
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 规则样式结束，用于样式化加载器的容器
- en: We see that our section has its width capped at 800 pixels. `<section>` is a
    block-level element, so by default, it will take up the full width available to
    it. `<body>` and `<html>` are also block-level elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的部分宽度被限制在800像素。`<section>`是一个块级元素，因此默认情况下，它将占用其可用的全部宽度。《body》和`<html>`也是块级元素。
- en: Because we don’t specify a width, padding, or margin on `<body>` or `<html>`,
    they will take the full width of the window. `<section>` will take the full width
    of the `<body>`. But because we assigned a maximum width to the `<section>`, when
    the window reaches 800 pixels wide, the section will stop growing with the `<body>`
    and remain 800 pixels wide. Because the section element has a top and bottom margin
    of `40px`, it will slightly increase the gap between the browser window and the
    element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在`<body>`或`<html>`上指定宽度、填充或边距，它们将占据整个窗口宽度。`<section>`将占据`<body>`的整个宽度。但由于我们为`<section>`分配了最大宽度，当窗口宽度达到800像素时，部分将停止与`<body>`一起增长，并保持800像素宽。由于部分元素有顶部和底部边距为`40px`，它将略微增加浏览器窗口和元素之间的间隙。
- en: Our loader is contained within the section. The section will take the full width
    of the body until it reaches 800 pixels; therefore, our loader will do the same.
    Figure 3.5 shows how the width of the loader will be affected by the screen size.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的加载器包含在部分中。该部分将占据整个身体的宽度，直到达到800像素；因此，我们的加载器也将这样做。图3.5显示了加载器的宽度将如何受到屏幕尺寸的影响。
- en: '![](../Images/03-05.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-05.png)'
- en: Figure 3.5 Window-width effect on SVG width when using `max-width`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 使用`max-width`时SVG宽度受窗口宽度的影响
- en: With the viewport set, let’s set the viewbox so that the contents of the SVG
    can scale with its container. Remember that up to now, we’ve dealt only with the
    frame, not its innards.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了视口后，让我们设置视图框，以便SVG的内容可以与其容器一起缩放。记住，到目前为止，我们只处理了框架，而不是其内部。
- en: 3.2.3 Viewbox
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 视图框
- en: 'The *viewbox* sets the position, height, and width of the graphic within the
    viewport. Earlier, we likened the viewport to a picture frame. The viewbox allows
    us to adjust the image to fit our frame. It can position the image and also scale
    the graphic so that it fits inside the frame. We can think of the viewbox as being
    our pan and zoom tools. To set the viewbox, we apply the `viewBox` attribute to
    the SVG with the following four values and syntax: `viewBox="min-x` `min-y` `width`
    `height"`. Listing 3.3 shows `viewBox` applied to our loader.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图框*设置了图形在视口内的位置、高度和宽度。之前，我们将视口比作画框。视图框允许我们调整图像以适应我们的画框。它可以定位图像，也可以缩放图形，使其适合画框。我们可以将视图框视为我们的平移和缩放工具。要设置视图框，我们将`viewBox`属性应用于SVG，并使用以下四个值和语法：`viewBox="min-x`
    `min-y` `width` `height"`。列表3.3显示了`viewBox`应用于我们的加载器。'
- en: Dissecting the numbers in order, we start with `min-x` and `min-y`, both of
    which are set to `0`. We want the top-left corner of the graphic to be in the
    top-left corner of our frame. `min-x` and `min-y` allow us to adjust the position
    of the graphic in its frame; it’s the pan tool. Because we want it to be exactly
    in the top-left corner, we set the values to `0`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序分析数字，我们从`min-x`和`min-y`开始，它们都设置为`0`。我们希望图形的左上角位于框架的左上角。`min-x`和`min-y`允许我们调整图形在其框架中的位置；它是平移工具。由于我们希望它正好位于左上角，我们将值设置为`0`。
- en: Next, we apply the width, which is set to `710` because our loader has 11 total
    bars, each created with a width of `60`. 60 × 11 = 660, and we have 10 gaps. The
    gap width between each bar is 5 × 10 = 50; therefore, our loader’s width will
    be `660` `+` `50` `=` `710`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应用宽度，设置为`710`，因为我们的加载器有11个总条形，每个条形宽度为`60`。60 × 11 = 660，我们有10个间隙。每个条形之间的间隙宽度为5
    × 10 = 50；因此，我们的加载器宽度将是`660` `+` `50` `=` `710`。
- en: We’ll base the height of the `viewBox` on the height of the bars in our loader.
    The bars have a height value of `300`, so we also set the viewport height to `300`.
    Our loader will fit exactly inside its viewport. The next listing shows the `viewBox`
    applied to the SVG.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于加载器中条形的高度设置`viewBox`的高度。条形的高度值为`300`，因此我们也设置了视口高度为`300`。我们的加载器将正好适合其视口。下一个列表显示了应用于SVG的`viewBox`。
- en: Listing 3.3 Declaring the viewbox
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 声明视图框
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that both our viewbox and viewport heights equal `300`. This is how we
    zoom. If the viewbox figures are less than the viewport figures, we’re effectively
    zooming out of the frame, and the graphic will be smaller. If the viewbox figures
    are more than the viewport figures, we’re zooming in. Because we have equal viewport
    and viewbox heights, however, we’re not zooming.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的视图框和视口高度都等于`300`。这就是我们缩放的方式。如果视图框的数字小于视口的数字，我们实际上是在框架外缩放，图形将更小。如果视图框的数字大于视口的数字，我们是在缩放。然而，由于我们的视口和视图框高度相等，所以我们没有缩放。
- en: Now that we’ve defined the space we’ll be working in, we can start adding shapes
    to the loader.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们将在其中工作的空间，我们可以开始向加载器添加形状。
- en: 3.2.4 Shapes in SVG
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 SVG中的形状
- en: 'There are a few standard SVG shapes and elements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SVG中有一些标准的形状和元素：
- en: '`rect` (rectangle)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rect`（矩形）'
- en: '`circle`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circle`'
- en: '`ellipse`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ellipse`'
- en: '`line`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line`'
- en: '`polyline`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polyline`'
- en: '`polygon`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polygon`'
- en: If we want to create an irregular shape, we can also use `path`, but we won’t
    need it for this loader. Most often, paths are what we see when we look at the
    XML behind logos, icons, and complex animation graphics. For our project, we’ll
    use the basic rectangle shape to create the wave.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建一个不规则形状，我们也可以使用 `path`，但在这个加载器中我们不需要它。通常，路径是我们查看标志、图标和复杂动画图形背后的XML时看到的。对于我们的项目，我们将使用基本的矩形形状来创建波浪。
- en: 'To define our rectangles, which will create the bars in our loader, we’ll use
    the `<rect>` element and add four properties: `height`, `width`, `x`, and `y`.
    The `x` and `y` attributes determine the position of the top-left corner of the
    rectangle relative to the top-left corner of the SVG.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '为了定义我们的矩形，这些矩形将在加载器中创建条形，我们将使用 `<rect>` 元素并添加四个属性：`height`、`width`、`x` 和 `y`。`x`
    和 `y` 属性决定了矩形相对于SVG左上角的位置。 '
- en: We want to create 11 rectangles (listing 3.4) that have a width of `60` and
    a height of `300`, and we’ll use the `x` attribute to move the rectangles across
    the graphic. We start at `0` and increase the value by the width of our bar (`60`)
    plus an additional gap of `5`. Each rectangle’s `x` value will be `65` more than
    the previous one. Our 11th rectangle should have an `x` value of `650`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建11个矩形（列表3.4），宽度为`60`，高度为`300`，我们将使用 `x` 属性在图形中移动矩形。我们从`0`开始，并将值增加条形的宽度（`60`）加上额外的间隙`5`。每个矩形的
    `x` 值将比前一个多`65`。我们的第11个矩形的 `x` 值应该是`650`。
- en: Listing 3.4 Eleven rectangles
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 十一个矩形
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we have our rectangles positioned inside our viewport, and they’re resized
    correctly as we increase and decrease the window size by our `viewBox`. Figure
    3.6 shows our SVG in different window sizes. (We added a white border to the SVG
    and bars to make them more visible in the screenshots.) The contents shrink and
    grow within their available space without skewing the rectangles that they contain
    as the width-to-height ratio changes with the resizing of the window.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将矩形放置在视口中，并且它们随着窗口大小的增加和减少而正确地调整大小，这是通过我们的 `viewBox` 实现的。图3.6显示了不同窗口大小下的我们的SVG（我们在SVG上添加了白色边框和条形，以便在屏幕截图中更明显）。内容在其可用空间内收缩和增长，而不会扭曲它们所包含的矩形，因为随着窗口大小的调整，宽高比发生变化。
- en: '![](../Images/03-06.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-06.png)'
- en: Figure 3.6 Adding 11 rectangles inside an SVG
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 在SVG内添加11个矩形
- en: Notice that our rectangles are black. Our next order of business is to style
    them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的矩形是黑色的。我们接下来的任务是给它们添加样式。
- en: 3.3 Applying styles to SVGs
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 将样式应用于SVG
- en: 'We can apply styles to SVG elements in much the same way that we do in HTML:
    inline, internally in a `<style>` tag, or in a separate stylesheet. Some minor
    differences exist, however. First and foremost, how the SVG is imported into our
    HTML affects where the styles need to live to affect the elements.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在HTML中一样应用SVG元素的样式：内联、在 `<style>` 标签内部或在外部样式表中。然而，存在一些细微的差异。首先，SVG如何导入到我们的HTML中会影响样式需要放置的位置以影响元素。
- en: 'The easiest way to add a vector graphic to a web page is to use an image tag.
    We reference the image file the same way that we would any other image: `<img`
    `src="myImage.svg"` `alt="">`. We can also add it as a `background-image` inside
    our CSS: `background-image:` `url("myImage.svg");`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '向网页添加矢量图形最简单的方法是使用图像标签。我们引用图像文件的方式与引用任何其他图像相同：`<img src="myImage.svg" alt="">`。我们也可以将其作为
    `background-image` 添加到我们的CSS中：`background-image: url("myImage.svg");`。'
- en: In both of these cases, our HTML and styles can affect the SVG but not the elements
    within it. We can affect the size of the image, for example, but we can’t change
    the color of a particular shape inside the SVG. The image is essentially a black
    box that we can’t penetrate to make changes. To manipulate elements within the
    image, we’d have to place the styles inside the SVG itself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们的HTML和样式可以影响SVG，但不能影响其内部的元素。例如，我们可以影响图像的大小，但不能改变SVG中特定形状的颜色。图像基本上是一个黑盒，我们无法穿透以进行更改。要操纵图像内部的元素，我们必须将样式放置在SVG本身内部。
- en: Our third option—the one we’ll use in this chapter—is to place the SVG’s XML
    inline, directly in our HTML rather than in an external file, preventing the black-box
    issue we’d encounter if the code were in an external file. The drawback is that
    our concerns aren’t as well separated because now our image code is mixed in with
    our HTML.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个选项——我们将在本章中使用的是——将 SVG 的 XML 内联放置，直接在我们的 HTML 中而不是在外部文件中，防止我们遇到代码在外部文件中的黑盒问题。缺点是现在我们的图像代码与我们的
    HTML 混合在一起，我们的关注点没有很好地分离。
- en: When our SVG is placed inline in our HTML, the standard ways to apply CSS to
    any other HTML element apply. Therefore, we can place the styles we want to apply
    to our SVG inside our CSS as though the SVG were any other HTML element.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 SVG 放置在 HTML 中时，应用于任何其他 HTML 元素的标准 CSS 应用方式同样适用。因此，我们可以将想要应用到我们的 SVG 中的样式放在我们的
    CSS 中，就像 SVG 是任何其他 HTML 元素一样。
- en: SVG presentation attributes
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 展示属性
- en: In HTML, when we apply styles inline, we need to include a style attribute,
    such as `<p` `style="background:` `blue">`. SVGs, however, have styles that we
    can add directly to the element as attributes. These styles are called *presentation
    attributes*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '在 HTML 中，当我们内联应用样式时，我们需要包含一个样式属性，例如 `<p style="background: blue">`。然而，SVG 有可以直接添加到元素作为属性的样式。这些样式被称为
    *展示属性*。'
- en: 'The `fill` attribute (the SVG equivalent of `background-color`), for example,
    can be applied directly to the element without a style tag: `<rect` `fill="blue">`.
    These properties don’t have to be applied inline directly on the element. They
    can be added inside a style tag or stylesheet the same way that we apply any other
    CSS style: `rect` `{` `fill:` `blue:` `}`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`fill` 属性（SVG 中的 `background-color` 等价物），可以直接应用于元素而不需要样式标签：`<rect fill="blue">`。这些属性不必直接内联应用于元素。它们可以像应用任何其他
    CSS 样式一样添加到样式标签或样式表中：`rect { fill: blue; }`。'
- en: You can find a comprehensive list of SVG presentation attributes at [http://mng.bz/Alee](http://mng.bz/Alee).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://mng.bz/Alee](http://mng.bz/Alee) 找到 SVG 展示属性的完整列表。
- en: Although the techniques for applying styles to our SVG elements remain the same
    as those for HTML (except for the aforementioned SVG presentation attributes when
    applied inline), some of the properties we’ll use to style our elements will be
    different. Let’s take a closer look at one we’ll be using for this project.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用样式到我们的 SVG 元素的技术与 HTML 中的技术相同（除了上述内联应用的 SVG 展示属性），我们将用于样式化元素的某些属性将会有所不同。让我们更仔细地看看我们将在这个项目中使用的一个属性。
- en: To set the background color of the loader bars, instead of using `background-color`,
    we’ll use the `fill` property, as the `background-color` property doesn’t work
    for SVG elements. The `fill` property supports the same values as `background-color`,
    such as color name, RGB(a), HSL(a) and hex. So instead of `rect` `{` `background-color:`
    `blue;` `}`, we’d write `rect` `{` `fill:` `blue;` `}`. If no `fill` value is
    assigned to a particular shape, the `fill` will default to black, which is why
    our rectangles are black.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '要设置加载条背景颜色，而不是使用 `background-color`，我们将使用 `fill` 属性，因为 `background-color` 属性对
    SVG 元素不起作用。`fill` 属性支持与 `background-color` 相同的值，例如颜色名称、RGB(a)、HSL(a) 和十六进制。所以，我们不会写
    `rect { background-color: blue; }`，而是写 `rect { fill: blue; }`。如果未为特定形状分配 `fill`
    值，则 `fill` 将默认为黑色，这就是为什么我们的矩形是黑色的。'
- en: Let’s add a fill color to our rectangles. Because not all the rectangles are
    the same color (they have varying colors of blue and green to give the loader
    a bit of a gradient effect), rather than give each element a class, we’ll use
    the pseudo-class `nth-of-child(n)`, which matches elements based on their positions
    within the parent. We’ll look for the `n`th rectangle, to which we’ll apply the
    fill. Therefore, `section` `rect:nth-of-type(3)` would find the third rectangle
    of the section container. Listing 3.5 shows the fill color applied to each of
    our rectangles.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的矩形添加一个填充颜色。因为不是所有的矩形都是同一种颜色（它们有不同深浅的蓝色和绿色，给加载器带来一点渐变效果），而不是给每个元素一个类，我们将使用伪类
    `nth-of-child(n)`，它根据元素在父元素中的位置来匹配元素。我们将寻找第 `n` 个矩形，我们将对其应用填充。因此，`section rect:nth-of-type(3)`
    将找到容器中的第三个矩形。列表 3.5 展示了我们对每个矩形的填充颜色应用。
- en: NOTE A pseudo-class targets the state of an element—in this case, its position
    relative to the positions of its siblings.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：伪类针对元素的状态——在这种情况下，其相对于其兄弟元素的位置。
- en: Listing 3.5 Adding a fill color to our rectangles
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 给我们的矩形添加填充颜色
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 3.7 shows our output. We can see that the bars in the loader are no longer
    black; color has been applied to them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7显示了我们的输出。我们可以看到，加载器中的条不再为黑色；已经将颜色应用到它们上。
- en: '![](../Images/03-07.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-07.png)'
- en: Figure 3.7 Fill applied to loader rectangles
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7填充应用到加载器矩形
- en: The downside to our declarations is that if another SVG graphic had rectangles,
    our code could style the wrong graphic. To avoid this issue, we can add a class
    name to our SVG graphic as an identifier to specify the rectangle we want to style.
    But because we have only one SVG in our project, we won’t need to worry about
    that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的缺点是，如果另一个SVG图形有矩形，我们的代码可能会错误地样式化错误的图形。为了避免这个问题，我们可以在我们的SVG图形上添加一个类名作为标识符，以指定我们想要样式的矩形。但由于我们的项目中只有一个SVG，我们不需要担心这个问题。
- en: 3.4 Animating elements in CSS
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用CSS动画元素
- en: 'The CSS Animation Module allows us to animate properties using keyframes, which
    we’ll look at in section 3.4.1\. We can control aspects of the animation such
    as how long it lasts and how many times it animates. CSS provides several properties
    we can use to define our animations’ behavior, including the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CSS动画模块允许我们使用关键帧来动画化属性，我们将在3.4.1节中探讨这一点。我们可以控制动画的各个方面，例如它的持续时间以及它应该运行多少次。CSS提供了几个我们可以用来定义动画行为的属性，包括以下内容：
- en: '`animation-delay`—How long to wait before the animation starts'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-delay`—动画开始前的等待时间'
- en: '`animation-direction`—Whether the animation is played forward or backward'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-direction`—动画是向前播放还是向后播放'
- en: '`animation-duratio`n—How long it should take for the animation to run once'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-duration`—动画运行一次需要多长时间'
- en: '`animation-fill-mode`—How the element being animated should be styled when
    the animation is done executing'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-fill-mode`—动画执行完成后，被动画化的元素应该如何样式化'
- en: '`animation-iteration-count`—How many times the animation should run'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-iteration-count`—动画应该运行多少次'
- en: '`animation-name`—Name of the keyframes being applied'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-name`—应用的关键帧的名称'
- en: '`animation-play-state`—Whether the animation is running or paused'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-play-state`—动画是正在运行还是暂停'
- en: '`animation-timing-function`—How the animation progresses through the styles
    over time'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-timing-function`—动画如何随时间通过样式'
- en: 'For our animation, we’ll focus on four of these properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的动画，我们将关注以下四个属性：
- en: '`animation-name`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-name`'
- en: '`animation-duration`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-duration`'
- en: '`animation-iteration-count`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-iteration-count`'
- en: '`animation-delay`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-delay`'
- en: The effect we want to create is the rectangles shrinking and growing, but not
    in sync. At any given point in time, we want the heights of the elements to be
    slightly different. When the rectangles are shrinking and growing, we want the
    tops and bottoms of the rectangle to move toward the center and then expand back
    to full height. Essentially, we’ll be creating a squeezing effect, going from
    large to small and back to large.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建的效果是矩形缩小和放大，但不是同步的。在任何给定的时间点，我们希望元素的高度略有不同。当矩形缩小和放大时，我们希望矩形的顶部和底部向中心移动，然后恢复到完整的高度。本质上，我们将创建一个挤压效果，从大到小再回到大。
- en: Although we’ll apply the same animation to all the rectangles, to stagger their
    sizes we’ll apply a slightly different delay to the start of the animation of
    each rectangle. As each rectangle starts animating at a different time, each one
    will be in a different stage of expanding and shrinking, creating a ripple effect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将对所有的矩形应用相同的动画，但为了错开它们的大小，我们将对每个矩形的动画开始应用一个稍微不同的延迟。由于每个矩形在不同的时间开始动画，每个矩形将处于不同的扩展和收缩阶段，从而产生涟漪效果。
- en: First, we’ll create the animation itself. Then, we’ll apply it to the rectangles.
    Finally, we’ll add the individual delays to stagger the size at any given point
    in time. To create the animation, we’ll use keyframes. The `animation` property
    will reference the keyframes and dictate the duration, the delay, and how many
    times we want the animation to run.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建动画本身。然后，我们将将其应用到矩形上。最后，我们将添加个别延迟以错开任何给定时间点的大小。为了创建动画，我们将使用关键帧。`animation`属性将引用关键帧并指定持续时间、延迟以及我们希望动画运行多少次。
- en: 3.4.1 Keyframe and animation-name
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 关键帧和animation-name
- en: When we create a keyframe, we need to give it a name. The `animation-name` declaration
    value matches the keyframe name to join the two. With the `animation-name` property,
    we can list multiple animations separated by commas.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建关键帧时，我们需要给它一个名称。`animation-name`声明值与关键帧名称匹配以连接两者。使用`animation-name`属性，我们可以通过逗号分隔列出多个动画。
- en: Origins of keyframes
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关键帧的起源
- en: Keyframes come to us from the animation and motion-picture industry. When companies
    used to do animation by hand, artists composed many individual pictures, with
    a change within each picture or frame. Over time, they made changes in each frame
    and gradually got to the end frame. A simple example of this technique is flipbook
    animation. The more frames you have and the more subtle the tweak is over a short
    period, the more fluid the animation is.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关键帧来自动画和电影行业。当公司以前手工制作动画时，艺术家会创作许多单独的图片，每张图片或帧中都有变化。随着时间的推移，他们在每一帧中进行更改，并逐渐达到最终帧。这种技术的简单例子是翻页动画。你拥有的帧越多，在短时间内进行的调整越微妙，动画就越流畅。
- en: A keyframe represents the most important (key) changes in your animation (the
    frame). Then the browser works out the changes over time between defined frames.
    This process is known as *in-betweening*. Allowing the hardware to do the work,
    the browser can quickly fill the gaps between the keyframes, creating a smooth
    transition between one state and another. The in-betweening process is illustrated
    in figure 3.8.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关键帧代表了动画中最重要（关键）的变化（即帧）。然后浏览器计算出定义帧之间的时间变化。这个过程被称为*插值*。允许硬件完成这项工作，浏览器可以快速填充关键帧之间的空隙，在一种状态和另一种状态之间创建平滑的过渡。插值过程如图3.8所示。
- en: '![](../Images/03-08.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-08.png)'
- en: Figure 3.8 In-betweening
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 插值
- en: In CSS, keyframes are defined using an at-rule called `@keyframes`, which controls
    the steps within an animation sequence. *At-rules* are CSS statements that dictate
    how our styles should behave and/or when they should be applied. They begin with
    an at (`@`) symbol followed by an identifier (in our case, keyframes). We used
    an at-rule in chapter 2 to create our media query; here, we’ll use one to create
    our keyframes. The syntax is `@keyframes` `animation-name` `{` `...` `}`. The
    code inside the curly braces defines the animation’s behavior. Each keyframe inside
    the `@keyframes` at-rule block is defined by a percentage (percentage of time
    passed in the animation) and the styles applied when we reach that point in time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，使用名为`@keyframes`的at规则定义关键帧，它控制动画序列中的步骤。*at规则*是CSS语句，它规定了我们的样式应该如何表现以及何时应用。它们以一个at（`@`）符号开头，后跟一个标识符（在我们的情况下是keyframes）。我们在第二章中使用了at规则来创建我们的媒体查询；在这里，我们将使用它来创建关键帧。语法是`@keyframes`
    `animation-name` `{` `...` `}`。大括号内的代码定义了动画的行为。`@keyframes` at规则块内的每个关键帧都由一个百分比（动画中经过的时间百分比）和我们在那个时间点应用的风格定义。
- en: Before we dive into applying animations to our project, let’s look at a simpler
    scenario to get a feel for the syntax (listing 3.6). You can also find this example
    on CodePen at [https://codepen.io/michaelgearon/pen/oNyvbWX](https://codepen.io/michaelgearon/pen/oNyvbWX),
    where you can see the animation run (figure 3.9).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将动画应用到我们的项目之前，让我们先看看一个更简单的场景，以了解语法（列表3.6）。你还可以在CodePen上找到这个例子，网址为[https://codepen.io/michaelgearon/pen/oNyvbWX](https://codepen.io/michaelgearon/pen/oNyvbWX)，在那里你可以看到动画的运行情况（图3.9）。
- en: '![](../Images/03-09.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-09.png)'
- en: Figure 3.9 Simple animation scenario in CodePen
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 CodePen中的简单动画场景
- en: Listing 3.6 Example animation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 示例动画
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① First keyframe, named changeColor
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ① 第一个关键帧，命名为changeColor
- en: ② Second keyframe, named changeBorderRadius
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第二个关键帧，命名为changeBorderRadius
- en: ③ The animation-name property referencing both of the animations
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 指向两个动画的animation-name属性
- en: ④ Sets how long the animation should take to complete
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置动画完成所需的时间
- en: ⑤ Sets how many times the animation should run
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置动画应该运行多少次
- en: 'The example has two sets of keyframes: one named `changeColor` and one named
    `changeBorderRadius`. We apply both of the animations to a `div`. Then we define
    how long the animation should take to run (3 seconds) and how many times it should
    run (10 times). Inside each set of keyframes is code specifying what styles should
    be applied to the elements. So we have two different types of notation, we have
    keywords, and we have percentages. Let’s break down what we’re defining in the
    first set of keyframes.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中有两组关键帧：一组命名为`changeColor`，另一组命名为`changeBorderRadius`。我们将这两个动画应用到`div`元素上。然后我们定义动画应该运行多长时间（3秒）以及应该运行多少次（10次）。在每一组关键帧内部，都有代码指定应该应用到元素上的样式。因此，我们有两种不同的表示法，我们有关键字，还有百分比。让我们分析一下我们在第一组关键帧中定义的内容。
- en: We assert that when the animation begins (`0%`), we want to set the background
    color of the `<div>` to `blue`. By the time we reach `50%` of our animation (half
    of 3 seconds, or 1.5 seconds), our background will be `yellow`. And when the animation
    ends (`100%`, or at 3 seconds), our background will be `red`. In between the keyframes.
    the color changes smoothly from one state to the next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们断言，当动画开始时（`0%`），我们希望将`<div>`的背景色设置为`蓝色`。当我们达到动画的`50%`（3秒的一半，即1.5秒）时，我们的背景将是`黄色`。当动画结束时（`100%`，或3秒），我们的背景将是`红色`。在关键帧之间，颜色会平滑地从一种状态变化到另一种状态。
- en: In the second set of keyframes, `changeBorderRadius`, instead of percentages
    we use the keywords `from` and `to`. `from` is the equivalent of `0%`, and `to`
    is equivalent to `100%`. We can mix the notation we want to use within the same
    set of keyframes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二组关键帧中，`changeBorderRadius`，我们使用的是关键字`from`和`to`，而不是百分比。`from`等同于`0%`，而`to`等同于`100%`。我们可以在同一组关键帧中混合使用我们想要的符号。
- en: When we apply the animation to the `div` ruleset, we also set a duration and
    iteration count. Notice that these two values are being applied to both of the
    animations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将动画应用于`div`规则集时，我们还设置了持续时间和迭代次数。请注意，这两个值被应用于两个动画。
- en: Before we take a closer look at these two properties and how they work, let’s
    create the animations for our loader. For our loader, we want to grow and shrink—or
    *scale*—our rectangles over time. Therefore, we’ll call our keyframe `doScale`.
    Our at-rule will be `@keyframes` `doScale` `{` `}`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地研究这两个属性及其工作原理之前，让我们为我们的加载器创建动画。对于我们的加载器，我们希望随时间增长和缩小——或者说*缩放*——我们的矩形。因此，我们将我们的关键帧命名为`doScale`。我们的at规则将是`@keyframes`
    `doScale` `{` `}`。
- en: 'Inside the at-rule, we define the keyframes for the animation. We’ll start
    with the rectangle having its full height. Halfway through the animation, we want
    the height of the rectangle to be 20 percent of its original height. When the
    animation terminates, we want the rectangle’s height to be back to full size.
    So we have three steps to define: `from` (or `0%`), `50%`, and `to` (or `100%`).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在at规则内部，我们定义动画的关键帧。我们将从矩形具有完整高度开始。动画进行到一半时，我们希望矩形的高度是其原始高度的20%。当动画结束时，我们希望矩形的高度恢复到完整大小。因此，我们需要定义三个步骤：`from`（或`0%`）、`50%`和`to`（或`100%`）。
- en: To change the size of the rectangle, we’ll use the `transform` property, which
    allows us to change the appearance of an element (rotate, scale, distorted, move,
    and so on) without affecting the elements around it. If we were to reduce the
    height of an element by using the `height` property, the content below it would
    move up to fill the newly available space. With `transform`, the amount of space
    and the location of the element in terms of the page flow don’t change—only the
    visible aspect. Using the same scenario, if we were to decrease the height of
    that same element using `transform`, the content below it wouldn’t move up. We’d
    have a blank space.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变矩形的大小，我们将使用`transform`属性，它允许我们改变元素的外观（旋转、缩放、扭曲、移动等），而不会影响周围的元素。如果我们使用`height`属性来减少元素的高度，下面的内容会向上移动以填充新可用的空间。使用`transform`，元素的空间和页面流中的位置不会改变——只有可见的方面会改变。使用相同的场景，如果我们使用`transform`来减少相同元素的高度，下面的内容不会向上移动。我们会有一个空白空间。
- en: To affect the element, the `transform` property takes a `transform()` function.
    We’ll use `scaleY()`. (You can find a full list of available functions at [http://mng.bz/Zo1N](http://mng.bz/Zo1N).)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了影响元素，`transform`属性接受一个`transform()`函数。我们将使用`scaleY()`。（您可以在[http://mng.bz/Zo1N](http://mng.bz/Zo1N)找到可用的完整函数列表。）
- en: The `scaleY()` function resizes an element vertically without affecting its
    width or squishing or stretching it. To define how much an element should be scrunched
    or stretched, we pass the function a percentage or a number value. The number
    value maps to the decimal value of its percentage equivalent; therefore, `scaleY(.5)`
    and `scaleY(50%)` achieve the same result, decreasing the element’s height to
    50% of its original value. Values above `100%` increase the size of the element,
    and values between `0%` and `100%` shrink it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`scaleY()`函数垂直调整元素的大小，而不会影响其宽度或挤压或拉伸它。为了定义元素应该挤压或拉伸的程度，我们向函数传递一个百分比或数值。数值映射到其百分比等价的十进制值；因此，`scaleY(.5)`和`scaleY(50%)`达到相同的结果，将元素的高度减少到原始值的50%。大于`100%`的值会增加元素的大小，而介于`0%`和`100%`之间的值会缩小它。'
- en: Negative values applied to `scaleY()` flip the element vertically, so `scaleY(-0.5)`
    would flip the element upside down and shrink its height by 50%. `scaleY(-1.5)`
    flips the element upside down and makes the height 1.5 times the original value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `scaleY()` 应用的负值会垂直翻转元素，因此 `scaleY(-0.5)` 会将元素翻转过来并使其高度缩小50%。`scaleY(-1.5)`
    会将元素翻转过来，并使其高度变为原始值的1.5倍。
- en: For our loader bars, we want our rectangles to be full height at the beginning
    and the end of the animation, and 20% of the original height halfway through the
    animation. Our completed keyframe with transforms applied looks like the following
    listing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的加载条，我们希望矩形在动画开始和结束时达到满高度，在动画中途达到原始高度的20%。我们应用了变换的完成关键帧如下所示。
- en: Listing 3.7 Completed keyframe
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 完成关键帧
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Start of the doScale at-rule
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ① `doScale` at-rule 的开始
- en: ② Starts the animation at full height
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在全高度处开始动画
- en: ③ Halfway through the animation, the height should be 20% of the original value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 动画中途，高度应该是原始值的20%。
- en: ④ By the end of the animation, the rectangle returns to full height.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 到动画结束时，矩形返回到满高度。
- en: ⑤ End of the doScale at-rule
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ `doScale` at-rule 的结束
- en: ⑥ Applies the animation to the rectangles
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将动画应用于矩形
- en: If we run the code, we notice that nothing has changed; our rectangles aren’t
    growing and shrinking yet, even though we applied the keyframe to our rectangles.
    We still need to define the duration and iteration count. Let’s dig into those
    properties a bit further.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们会注意到没有任何变化；我们的矩形还没有增长和缩小，尽管我们已经为矩形应用了关键帧。我们仍然需要定义持续时间和迭代次数。让我们进一步探讨这些属性。
- en: 3.4.2 The duration property
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 持续时间属性
- en: The `duration` property sets how long we want the animation to happen from start
    to finish. The duration can be set in seconds (`s`) or milliseconds (`ms`). The
    longer the duration, the more slowly the animation completes. With accessibility
    in mind, we want to consider users who are sensitive to motion (section 3.4) and
    choose a duration that is reasonable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`duration` 属性设置动画从开始到结束的持续时间。持续时间可以用秒（`s`）或毫秒（`ms`）来设置。持续时间越长，动画完成得越慢。考虑到可访问性，我们希望考虑对运动敏感的用户（第3.4节）并选择一个合理的持续时间。'
- en: Animations, seizures, and flash rate
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 动画、抽搐和闪烁率
- en: The World Wide Web Consortium (W3C) recommends that to prevent inducing seizures
    in photosensitive users, we need to make sure that our animations don’t contain
    anything that flashes more than three times in any 1-second period ([http://mng.bz/RldR](http://mng.bz/RldR)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网联盟（W3C）建议，为了防止在光敏感用户中引起抽搐，我们需要确保我们的动画在任何1秒期间内不会闪烁超过三次（[http://mng.bz/RldR](http://mng.bz/RldR)）。
- en: A lot goes into choosing appropriate animation timing. An animation that’s too
    fast can create changes that are imperceptible or cause seizures, depending on
    its nature. An animation that’s too slow can make our application look laggy.
    Most microanimations are short and transitional; they animate the change of an
    element from one state to another, such as flipping an arrow from pointing up
    to pointing down. A generally accepted duration for this type of animation is
    around 250 milliseconds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的动画时间需要考虑很多因素。动画过快可能会产生难以察觉的变化或引起抽搐，这取决于其性质。动画过慢可能会使我们的应用程序看起来反应迟缓。大多数微动画都很短，是过渡性的；它们动画化元素从一个状态到另一个状态的变化，例如将箭头从向上指变为向下指。这类动画的普遍接受的时间大约是250毫秒。
- en: If the animation is larger or more complex, such as opening and closing a large
    panel or menu, we can increase the duration to around 500 milliseconds. A loader
    is a bit different, though. It’s not a quick change in response to a user’s action;
    it’s a large visual element that the user will focus on for some time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画更大或更复杂，例如打开和关闭一个大的面板或菜单，我们可以将持续时间增加到大约500毫秒。然而，加载器略有不同。它不是对用户动作的快速反应；它是一个用户会关注一段时间的大型视觉元素。
- en: Most often when determining the “correct” timing for a loader, we use trial
    and error to find the speed that works best with our graphic. For our project,
    we want to set the animation to happen over 2.2 seconds. To apply the amount of
    time the animation should take, we add the `animation-duration` property to our
    rectangles, as shown in the following listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定加载器的“正确”时间时，我们通常使用试错法来找到与我们的图形最匹配的速度。对于我们的项目，我们希望将动画设置为在2.2秒内完成。为了应用动画应该持续的时间，我们在矩形上添加了
    `animation-duration` 属性，如下所示。
- en: Listing 3.8 Added animation duration
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 添加动画持续时间
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we run the code, our loader animates once and then never animates again
    unless we reload the browser window. We also notice that all the bars increase
    and decrease in size at the same time. First, let’s make our loader continue to
    animate over time; then we’ll stagger the animation across our rectangles so that
    they appear to be different heights.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们的加载器动画只运行一次，然后永远不会再次动画化，除非我们重新加载浏览器窗口。我们还注意到所有条形同时增加和减少大小。首先，让我们让我们的加载器随着时间的推移继续动画化；然后我们将动画错开在我们的矩形之间，使它们看起来有不同的高度。
- en: 3.4.3 The iteration-count property
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 `iteration-count`属性
- en: To make our animation restart after it has completed, we use the `iteration-count`
    property, which sets the number of times the animation should repeat. By default,
    its value is `1`. Because we haven’t set a value yet, the browser assumes that
    we want the animation to run once and be done. We want our animation to repeat
    continuously, so we’ll use the `infinite` keyword value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的动画在完成之后重新开始，我们使用`iteration-count`属性，该属性设置动画应该重复的次数。默认情况下，其值为`1`。因为我们还没有设置值，浏览器假设我们想要动画只运行一次然后结束。我们希望我们的动画能够持续重复，所以我们将使用`infinite`关键字值。
- en: By applying this value, we’re declaring that the animation should keep playing
    forever. If we wanted to run a specific number of times, we’d use an integer value.
    After we add our iteration count, our code looks like the following listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用这个值，我们声明动画应该永远播放。如果我们想要运行特定的次数，我们将使用一个整数值。在我们添加迭代计数后，我们的代码看起来如下所示。
- en: Listing 3.9 Added animation iteration count
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 添加动画迭代计数
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we run the code, we see that all the rectangles grow and shrink in sync,
    starting from the top, and that the animation restarts after it completes. We
    still have some work to do to set the animation to start in the middle of the
    rectangle rather than at the top, as well as to stagger the animation between
    our elements. First, though, let’s take a quick pause to look at the animation
    shorthand property.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们看到所有矩形同步地增长和缩小，从顶部开始，并且动画在完成后会重新开始。我们还有一些工作要做，将动画设置在矩形的中间而不是顶部，以及使动画在我们的元素之间错开。不过，首先让我们快速暂停一下，看看动画简写属性。
- en: 3.4.4 The animation shorthand property
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 `animation`简写属性
- en: 'We currently have three declarations that define our animation: `animation-name`,
    `animation-duration`, and `animation-iteration-count`. We can simplify our code
    by combining all three declarations in the `animation` shorthand property, which
    allows us to define our animation’s behavior with a single property. In this property,
    we can define the values for any of the properties listed in section 3.3\. We
    don’t need to provide values for all the properties. If properties aren’t defined
    as part of the shorthand property or individually, they use their default values.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有三个声明定义了我们的动画：`animation-name`、`animation-duration`和`animation-iteration-count`。我们可以通过将这三个声明组合在`animation`简写属性中来简化我们的代码，这允许我们使用单个属性定义动画的行为。在这个属性中，我们可以定义3.3节中列出的任何属性的值。我们不需要为所有属性提供值。如果属性没有作为简写属性或单独定义，它们将使用默认值。
- en: 'As mentioned earlier, we’re defining three properties: `animation-name`, `animation-duration`,
    and `animation-iteration-count`. Refactored to use the animation shorthand property,
    our declaration looks like figure 3.10.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在定义三个属性：`animation-name`、`animation-duration`和`animation-iteration-count`。重构后使用动画简写属性，我们的声明看起来如图3.10所示。
- en: '![](../Images/03-10.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-10.png)'
- en: Figure 3.10 Breakdown of the animation shorthand property
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 动画简写属性的分解
- en: This code is functionally identical to the code that currently applies to our
    rectangle. Using shorthand properties makes our code more concise and can make
    it easier to read. But if you find that writing out each property is easier for
    you, either method is perfectly valid. Do what works best for you.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在功能上与目前应用于我们矩形的代码相同。使用简写属性可以使我们的代码更简洁，并且可以使其更容易阅读。但如果你发现逐个写出每个属性对你来说更容易，两种方法都是完全有效的。做对你最有利的事情。
- en: When we use the animation shorthand property, our updated CSS looks like the
    following listing. After making the change to our code, we notice that our animation
    hasn’t changed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用动画简写属性时，我们的更新后的CSS看起来如下所示。在修改我们的代码后，我们注意到我们的动画没有改变。
- en: Listing 3.10 Refactoring to use the shorthand property
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 使用简写属性重构
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, let’s address the staggering of heights for each of our rectangles.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决每个矩形的错开高度问题。
- en: 3.4.5 The animation-delay property
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5 动画延迟属性
- en: 'The `animation-delay` property does what its name implies: it allows us to
    delay an animation on an element. The delay applies to the start of the animation.
    When the animation starts, it loops normally. As with the `duration` property,
    we can use seconds (`s`) or milliseconds (`ms`) to set the delay’s duration value.
    The default value is `0`. By default, an animation doesn’t have a delay.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`animation-delay` 属性的作用正如其名称所暗示的那样：它允许我们在元素上延迟动画。延迟应用于动画的开始。当动画开始时，它将正常循环。与
    `duration` 属性一样，我们可以使用秒（`s`）或毫秒（`ms`）来设置延迟的持续时间值。默认值是 `0`。默认情况下，动画没有延迟。'
- en: To create the staggered effect in our animation, we’ll assign different delay
    values to each of our rectangles, as shown in listing 3.11\. The first rectangle’s
    animation will start immediately. We give it a delay of `0`. We could omit this
    declaration, because `0` is the default value for `animation-delay`; we added
    it here for clarity in explaining the code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的动画中创建错位效果，我们将为我们的每个矩形分配不同的延迟值，如列表 3.11 所示。第一个矩形的动画将立即开始。我们给它一个延迟值 `0`。我们可以省略这个声明，因为
    `0` 是 `animation-delay` 的默认值；我们在这里添加它是为了使代码更清晰。
- en: The second rectangle gets a `200ms` delay, and we continue to increment the
    delay by `200ms` for every rectangle thereafter. Notice that on the sixth rectangle,
    we switch to using seconds instead of milliseconds. We do this to make the code
    more readable because either second or millisecond values are acceptable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个矩形有一个 `200ms` 的延迟，并且我们继续为每个后续的矩形增加 `200ms` 的延迟。注意，在第六个矩形上，我们改为使用秒而不是毫秒。我们这样做是为了使代码更易读，因为秒或毫秒值都是可接受的。
- en: Listing 3.11 Added animation iteration count
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 添加了动画迭代次数
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After adding the delay, we see that we achieved our staggered effect (figure
    3.11). But the elements are growing and shrinking from the top rather than from
    the center.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加延迟后，我们可以看到我们实现了错位效果（图 3.11）。但是元素是从顶部而不是从中心开始增长和缩小的。
- en: '![](../Images/03-11.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-11.png)'
- en: Figure 3.11 Animated rectangles with height change emanating from the top
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 从顶部发出高度变化的动画矩形
- en: To say where we want the element to grow and shrink from, we need to tell the
    browser where on the rectangle the animation should originate. To address this
    problem, we’ll use the `transform-origin` property.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要说明我们希望元素从哪里开始增长和缩小，我们需要告诉浏览器动画应该在矩形的哪个位置开始。为了解决这个问题，我们将使用 `transform-origin`
    属性。
- en: 3.4.6 The transform-origin property
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.6 变换原点属性
- en: The `transform-origin` property sets the origin, or point, for an element’s
    transformations. If we were to rotate the object, the `transform-origin` property
    would set where on the element we want to rotate from. In our case, we’ll use
    this property to set the position the animation should start from (the point of
    origin).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform-origin` 属性设置元素变换的起点或点。如果我们旋转对象，`transform-origin` 属性将设置我们想要从元素上的哪个位置旋转。在我们的情况下，我们将使用此属性来设置动画应该开始的位罝（原点）。'
- en: If the transform is happening in three dimensions (3D), the value can be up
    to three values (`x`, `y`, and `z`); if the transform is in two dimensions (2D),
    we can have up to two values (`x` and `y`). The first value is the horizontal
    position, or the x-axis; the second value is the vertical position, or the y-axis.
    When we’re working in 3D, the third value would be forward and backward, or the
    z-axis.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变换发生在三维（3D）空间中，值可以有三个（`x`、`y` 和 `z`）；如果变换发生在二维（2D）空间中，我们可以有两个值（`x` 和 `y`）。第一个值是水平位置，或
    x 轴；第二个值是垂直位置，或 y 轴。当我们处于 3D 空间工作时，第三个值将是前后方向，或 z 轴。
- en: 'We can declare the value of the `transform-origin` property in three ways:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用三种方式声明 `transform-origin` 属性的值：
- en: Length
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度
- en: Percentage
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百分比
- en: Keywords
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键词
- en: '`top`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`right`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`'
- en: '`bottom`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`'
- en: '`left`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`'
- en: '`center`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center`'
- en: In HTML, the initial value for this property is `50%` `50%` `0`, which is `center`,
    `center`, `flat`. For SVG elements, however, the initial value is `0` `0` `0`,
    which places it in the top-left corner.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，此属性的初始值是 `50%` `50%` `0`，即 `center`、`center`、`flat`。然而，对于 SVG 元素，初始值是
    `0` `0` `0`，这将其放置在左上角。
- en: For our animation, we want the rectangle’s transform origin to be at the center.
    We want the top and bottom of the rectangles to shrink rather than having the
    top fixed and the rectangles expanding and contracting from that point. To do
    this, we can either apply the keyword value `center` or assign a value of `50%`
    to the `transform-origin` property for our rectangles. Either way, we’re saying
    that we want the point of origin to be the center of the rectangle. For our project,
    we’ll use the keyword value `center`. Listing 3.12 shows our updated `rect` rule.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的动画，我们希望矩形的变换原点位于中心。我们希望矩形的上下部分缩小，而不是顶部固定，然后矩形从这个点开始扩展和收缩。为此，我们可以应用关键字值`center`，或者将`transform-origin`属性的值设置为`50%`。无论哪种方式，我们都在说我们希望原点位于矩形的中心。对于我们的项目，我们将使用关键字值`center`。列表3.12显示了我们的更新后的`rect`规则。
- en: We mentioned earlier that when working with 2D animations, the property takes
    two values, but we passed only one. When only one value is passed, it is applied
    to both the vertical and horizontal positions; therefore, `transform-origin:`
    `center;` is equivalent to `transform-origin:` `center` `center;`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，当与2D动画一起工作时，该属性需要两个值，但我们只传递了一个。当只传递一个值时，它应用于垂直和水平位置；因此，`transform-origin:`
    `center;` 等同于 `transform-origin:` `center` `center;`。
- en: Listing 3.12 Updated `rect` rule with `transform-origin` property
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 使用`transform-origin`属性的更新后的`rect`规则
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve finished our loader animation (figure 3.12). But we still need to consider
    how accessible our design is. Section 3.4 dives into some ways we can provide
    a positive experience for all our users.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了加载动画（图3.12）。但我们仍然需要考虑我们的设计如何具有可访问性。第3.4节深入探讨了我们可以为所有用户提供积极体验的一些方法。
- en: '![](../Images/03-12.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-12.png)'
- en: Figure 3.12 Finished loader animation
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 完成的加载动画
- en: 3.5 Accessibility and the prefers-reduced-motion media query
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 可访问性和`prefers-reduced-motion`媒体查询
- en: The use of motion, parallax (an effect in which the background moves slower
    than the foreground), and animations on the web has increased as these effects
    have become easier to implement and browser support has improved. By using these
    techniques, we can create richer user interfaces that are interactive and provide
    richer user experiences.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些效果变得更容易实现和浏览器支持改进，网页上运动、视差（背景比前景移动慢的效果）和动画的使用已经增加。通过使用这些技术，我们可以创建更丰富的用户界面，它们是交互式的，并提供更丰富的用户体验。
- en: The use of these techniques comes at a cost, however. For some users, especially
    those who have vestibular disorders, movement on the screen can cause headaches,
    dizziness, and nausea. As we mentioned earlier, animations can also cause seizures,
    especially if they contain elements that flash.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这些技术的代价是。对于一些用户，特别是那些有前庭功能障碍的用户，屏幕上的运动可能引起头痛、头晕和恶心。正如我们之前提到的，动画也可能引起癫痫发作，特别是如果它们包含闪烁元素的话。
- en: 'In many operating systems, users can disable animations on their devices. In
    our applications, we need to make sure that we respect those preferences. To check
    user settings the level-5 Media Queries Module has introduced the `prefers-reduced-motion`
    media query. This query is an at-rule, which checks the user’s preferences regarding
    motion on the screen and allows us to apply conditional styles based on those
    preferences. The query has two values:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多操作系统中，用户可以在他们的设备上禁用动画。在我们的应用程序中，我们需要确保我们尊重那些偏好。为了检查用户设置，第5级媒体查询模块引入了`prefers-reduced-motion`媒体查询。这个查询是一个at-rule，它检查用户对屏幕上运动的偏好，并允许我们根据这些偏好应用条件样式。查询有两个值：
- en: '`no-preference`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-preference`'
- en: '`reduce`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`'
- en: We can choose to disable or reduce an animation when a user prefers reduced
    motion or enable it when they don’t specify a preference. A user’s preference
    for reduced motion doesn’t mean that we can’t use any animation, but we should
    be selective about which animations we keep. Aspects that may determine which
    animations to keep enabled include
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户偏好减少运动或未指定偏好时，我们可以选择禁用或减少动画。用户的减少运动偏好并不意味着我们不能使用任何动画，但我们应该选择性地保留哪些动画。可能决定保留哪些动画启用的方面包括
- en: How fast it is
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有多快
- en: How long it is
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有多长
- en: How much of the viewport it uses
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它占视口的多少
- en: What the flash rate is
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪烁频率是多少
- en: How essential it is to the functioning of the site or understanding of the content
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对于网站功能或内容理解有多重要
- en: TIP It’s worth mentioning that a user may prefer reduced or no animation but
    may not be aware of the system-preferences settings for opting out of animations.
    Providing an onsite opt-out button may be useful, depending on how much animation
    our website has.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 值得注意的是，用户可能更喜欢减少或没有动画，但可能不知道如何通过系统首选项设置来关闭动画。提供一个现场退出按钮可能是有用的，这取决于我们的网站有多少动画。
- en: Accessibility guidelines for animations
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的可访问性指南
- en: A user should be able to pause, stop, or hide animation that lasts more than
    3 seconds and isn’t considered to be essential ([http://mng.bz/RldR](http://mng.bz/RldR)).
    Loaders are a bit tricky in this respect, as they convey important information
    to the user (the application is doing something and isn’t frozen) but can be large
    and have a lot of motion.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够暂停、停止或隐藏持续时间超过3秒且不被认为是基本内容的动画（[http://mng.bz/RldR](http://mng.bz/RldR)）。在这一点上，加载器有点棘手，因为它们向用户传达重要信息（应用程序正在做某事并且没有冻结），但可能很大并且有很多动作。
- en: Our loader could be considered to be essential content, but we also provide
    a progress bar below it to give the user an indication of what the application
    is doing. Because the information is conveyed in a different medium, and because
    the animation is large, has a lot of movement, and could last more than 3 seconds,
    we’re going to disable it for users who prefer reduced motion, using the code
    in the following listing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的加载器可以被认为是基本内容，但我们还提供了一个进度条在其下方，以向用户指示应用程序正在做什么。因为信息是通过不同的媒介传达的，并且因为动画很大，有很多动作，并且可能持续超过3秒，我们将为更喜欢减少运动的用户禁用它，使用以下列表中的代码。
- en: Listing 3.13 Disabling the animation for users who prefer reduced motion
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 为更喜欢减少运动的用户禁用动画
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① Conditionally applies styles within the at-rule when the user enables prefer-reduced-motion
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ① 当用户启用prefer-reduced-motion首选项时，条件性地应用at规则内的样式
- en: ② Disables the animation previously applied to the rectangles
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ② 禁用之前应用于矩形的动画
- en: 'To check that we successfully disabled the animation, instead of editing our
    machine’s settings, in most browsers we can do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否成功禁用了动画，而不是编辑我们机器的设置，在大多数浏览器中我们可以做以下操作：
- en: Go into our browser’s developer tools.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入我们的浏览器开发者工具。
- en: In the console tab display, select the rendering tab.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台标签显示中，选择渲染标签。
- en: (In Google’s Chrome browser, if this tab isn’t already displayed, click the
    vertical ellipsis button and choose More Tools > Rendering from the drop-down
    menu.)
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （在Google的Chrome浏览器中，如果此标签尚未显示，请点击垂直省略号按钮，然后从下拉菜单中选择更多工具 > 渲染。）
- en: Enable the reduced-motion emulation.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用减少运动模拟。
- en: Figure 3.13 shows the disabled animation and developer tools in the latest version
    of Chrome ([http://mng.bz/51rZ](http://mng.bz/51rZ)) at this writing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13展示了在此写作时Chrome最新版本中禁用的动画和开发者工具（[http://mng.bz/51rZ](http://mng.bz/51rZ)）。
- en: '![](../Images/03-13.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-13.png)'
- en: Figure 3.13 Emulating reduced-motion preference using Chrome DevTools
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 使用Chrome开发者工具模拟减少运动首选项
- en: With our loader animation finished and accessibility needs handled, let’s turn
    our attention to the progress bar at the bottom of the screen.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的加载动画完成并且可访问性需求得到处理后，让我们将注意力转向屏幕底部的进度条。
- en: 3.6 Styling an HTML progress bar
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 为HTML进度条设置样式
- en: The `<progress>` HTML element can be used to show that something is loading
    or uploading, or that data has been transferred. It’s often used to show the user
    how much of a task has been completed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`<progress>` HTML元素可以用来显示某物正在加载或上传，或者数据已经被传输。它通常用来显示用户完成了多少任务。'
- en: The default styles of the `<``progress>` element vary among browsers and operating
    systems. Much of the functionality of the progress bar is handled at operating-system
    level; as a result, we have few properties available to restyle the control, especially
    when it comes to the colored progress indicator inside the bar itself. In this
    section, we’ll look at some workarounds and their pitfalls. Let’s start with an
    easy one.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`<progress>`元素的默认样式在不同浏览器和操作系统之间有所不同。进度条的大部分功能在操作系统级别处理；因此，我们可用的属性很少，可以重新设计控件，尤其是在条内彩色进度指示器方面。在本节中，我们将探讨一些解决方案及其陷阱。让我们从一个简单的开始。'
- en: Figure 3.14 shows our starting point generated by the HTML in listing 3.14\.
    At this point, no styles have been applied to the control. The figure shows the
    defaults generated by Martine’s machine.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14显示了由列表3.14中的HTML生成的起点。在此阶段，尚未应用到控件上的样式。该图显示了Martine的机器生成的默认样式。
- en: '![](../Images/03-14.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-14.png)'
- en: Figure 3.14 Progress bar starting point in Chrome
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 Chrome中进度条的起点
- en: Listing 3.14 Progress bar HTML
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 进度条HTML
- en: '[PRE14]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① The progress bar
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ① 进度条
- en: 3.6.1 Styling the progress bar
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 进度条样式
- en: Let’s start with changing the height and the width. To increase the width of
    the progress bar to match the width of the section, we’ll give its `width` property
    a value of `100%`. We also want to increase the height to `24px`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从改变高度和宽度开始。为了将进度条的宽度增加到与部分宽度相匹配，我们将它的`width`属性值设置为`100%`。我们还想将高度增加到`24px`。
- en: 'To change the color of the progress indicator (the colored portion of the control),
    we can use a fairly new property: `accent-color`. This property allows us to change
    the color of form controls such as check marks, radio inputs, and the `progress`
    element. We’ll set it to `#128688`, matching the color of the last bar of our
    loader. The following listing shows our progress rule thus far.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变进度指示器（控件的有色部分）的颜色，我们可以使用一个相当新的属性：`accent-color`。这个属性允许我们改变表单控件的颜色，如勾选标记、单选输入和`progress`元素。我们将它设置为`#128688`，与我们的加载器最后一条条的颜色相匹配。以下列表显示了我们的进度规则到目前为止的情况。
- en: Listing 3.15 Progress rule
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.15 进度规则
- en: '[PRE15]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Figure 3.15 shows the styles in listing 3.15 applied to our control.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15显示了列表3.15中应用于我们的控件的样式。
- en: '![](../Images/03-15.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-15.png)'
- en: Figure 3.15 Width, height, and accent color applied to the `progress` element
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 应用于`progress`元素的宽度、高度和突出颜色
- en: If we try to add a background color to our element (`background:` `pink`), we’ll
    notice that the addition doesn’t work. As a matter of fact, it fails spectacularly
    (figure 3.16). It radically changes the appearance of the element and alters the
    `accent-color` we previously set. Furthermore, the background color changes to
    gray rather than pink.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试给我们的元素添加背景颜色（`background:` `pink`），我们会注意到添加并没有起作用。事实上，它失败了（见图3.16）。它彻底改变了元素的外观，并改变了我们之前设置的`accent-color`。此外，背景颜色变成了灰色而不是粉色。
- en: '![](../Images/03-16.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-16.png)'
- en: Figure 3.16 `background-color` failure
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 `background-color`失败
- en: How do we get around this problem? To restyle the control, we need to ignore
    the default and re-create the styles from scratch. To do that, though, we need
    to use vendor-prefixed properties.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？为了重新设计控件样式，我们需要忽略默认样式并从头开始重新创建样式。然而，要做到这一点，我们需要使用供应商前缀属性。
- en: Vendor prefixes
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商前缀
- en: Historically, when browsers introduced new properties, they were added with
    a vendor prefix before the property name. Each browser’s prefix is based on the
    rendering engine that it uses. Table 3.1 displays major browsers and their prefixes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，当浏览器引入新属性时，它们会在属性名之前添加供应商前缀。每个浏览器的前缀都基于它所使用的渲染引擎。表3.1显示了主要浏览器及其前缀。
- en: Table 3.1 Vendor prefixes and their browsers
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 供应商前缀及其浏览器
- en: '| Prefix | Browsers |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 浏览器 |'
- en: '| `-webkit-` | Chrome, Safari, Opera, most iOS browsers (including Firefox
    for iOS), Edge |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `-webkit-` | Chrome, Safari, Opera, 大多数iOS浏览器（包括iOS的Firefox），Edge |'
- en: '| `-moz-` | Firefox |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `-moz-` | Firefox |'
- en: Vendor prefixes are often incomplete or nonstandard implementations that browsers
    may choose to remove or refactor at any time. Although this fact has been clearly
    documented for years, developers who were eager to use the latest properties regularly
    used them in production nonetheless.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商前缀通常是浏览器可能随时选择移除或重构的不完整或不标准的实现。尽管这个事实已经明确记录了多年，但那些渴望使用最新属性的开发商仍然经常在生产环境中使用它们。
- en: To prevent this continued behavior, most major browsers moved to shipping experimental
    features behind a feature flag. To enable the feature and play with it, the user
    must go into their browser settings and enable that specific flag.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种行为持续发生，大多数主要浏览器都转向在功能标志后面发布实验性功能。要启用该功能并与之互动，用户必须进入他们的浏览器设置并启用该特定标志。
- en: By moving to a flag-based method, the browsers are able to let developers play
    with experimental, cutting-edge features without fear that a nonstandard implementation
    might be used in a piece of production code. But many vendor-prefixed properties
    are still available in the wild. For more information about vendor prefixing and
    feature flags, see the appendix.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转向基于标志的方法，浏览器能够让开发者尝试实验性、前沿的功能，而不用担心非标准实现可能会被用于生产代码中。但许多供应商前缀属性仍然在野外可用。有关供应商前缀和功能标志的更多信息，请参阅附录。
- en: The first thing we’ll do to fix our `background-color` issue is to remove the
    default appearance of the control.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是修复我们的 `background-color` 问题，即移除控件默认的 appearance。
- en: The appearance property
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: appearance 属性
- en: To reset the appearance of the `<progress>` element, we use the `appearance`
    property. By setting its value to `none`, we cancel the default styles provided
    by the user agent. Because we’ll be creating all the styles from scratch, we can
    remove the `accent-color` property, as it will no longer have any effect.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重置 `<progress>` 元素的 appearance，我们使用 `appearance` 属性。通过将其值设置为 `none`，我们取消由用户代理提供的默认样式。因为我们将从零开始创建所有样式，所以我们可以移除
    `accent-color` 属性，因为它将不再有任何效果。
- en: We’ll keep our height and width, and also add a `border-radius` because we’re
    going to have a curved finish. The `appearance` property is supported by all new
    versions of major browsers, but we still need to include the vendor-prefixed versions,
    as some of the experimental properties we’ll be using require them. The following
    listing shows our updated rule.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持高度和宽度，并添加一个 `border-radius`，因为我们将会有一个曲线的结束效果。`appearance` 属性被所有主要浏览器的所有新版本支持，但我们仍然需要包含供应商前缀版本，因为我们将使用的一些实验性属性需要它们。以下列表显示了我们的更新规则。
- en: Listing 3.16 Updated progress rule
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 更新进度规则
- en: '[PRE16]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, our progress bar looks the same as when we broke it by adding
    the background color. This result is to be expected. With `appearance:none` added,
    we can start altering the control in ways we previously couldn’t. First, we’ll
    focus on browsers with a `-webkit-` prefix.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的进度条看起来与我们通过添加背景颜色而破坏它时相同。这个结果是预期的。通过添加 `appearance:none`，我们可以开始以我们之前无法做到的方式改变控件。首先，我们将关注带有
    `-webkit-` 前缀的浏览器。
- en: 3.6.2 Styling the progress bar for -webkit- browsers
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 为 -webkit- 浏览器设置进度条样式
- en: 'We can use three vendor-prefixed pseudo-elements to edit the styles of our
    progress bar:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三个供应商前缀的伪元素来编辑我们的进度条样式：
- en: '`::-webkit-progress-inner-element`—The outermost part of the progress element'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::-webkit-progress-inner-element`—进度元素的 最外层部分'
- en: '`::-webkit-progress-bar`—The entire bar of the progress element, the portion
    below the progress indicator, and the child of the `::-webkit-progress-inner-element`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::-webkit-progress-bar`—进度元素的全部条，进度指示器下方的部分，以及 `::-webkit-progress-inner-element`
    的子元素'
- en: '`::-webkit-progress-value`—The progress indicator and the child of `::-webkit-progress-bar`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::-webkit-progress-value`—进度指示器和 `::-webkit-progress-bar` 的子元素'
- en: We’ll use all three pseudo-elements to style our element. Let’s start from the
    inside and work our way out. The first part we want to style is the progress indicator,
    for which we’ll need to use `::-webkit-progress-value`. We curve the edges and
    change the color of the bar to a light blue, as shown in the following listing.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用所有三个伪元素来设置我们的元素样式。让我们从内部开始，逐步向外。我们想要设置的第一部分是进度指示器，我们需要使用 `::-webkit-progress-value`。我们将边缘弯曲并将条的颜色更改为浅蓝色，如下列所示。
- en: Listing 3.17 Styling the progress indicator in Chrome
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 在 Chrome 中设置进度指示器样式
- en: '[PRE17]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Figure 3.17 shows our output in a WebKit browser.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 显示了在 WebKit 浏览器中的输出。
- en: '![](../Images/03-17.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-17.png)'
- en: Figure 3.17 Progress value styled in Chrome
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 Chrome 中设置的进度值
- en: Next, we’ll edit the background behind the progress indicator by using `::-webkit-progress-bar`.
    We’ll also add rounded corners to the background and change the color to a linear
    gradient, going from a dark green to a light blue in keeping with the theme of
    the whole piece.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用 `::-webkit-progress-bar` 编辑进度指示器后面的背景。我们还将添加圆角并将颜色更改为线性渐变，从深绿色渐变到浅蓝色，以符合整个作品的主题。
- en: The `linear-gradient()` function takes a direction followed by a series of color
    and percentage pairs. The direction dictates the angle of the gradient; the color-percentage
    pairs dictate the points within the gradient at which we want to shift from one
    color to another. We’ll use the keyword value `to` `right` as our direction. Then
    we’ll set a starting color of `#128688` and an ending color of `#4db3ff`. Our
    gradient, therefore, will go from left to right, fading from our start color to
    our end color.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`linear-gradient()` 函数接受一个方向，后跟一系列颜色和百分比的配对。方向决定了渐变的角；颜色-百分比配对决定了我们在渐变中想要从一种颜色切换到另一种颜色的点。我们将使用关键字值
    `to` `right` 作为我们的方向。然后我们将起始颜色设置为 `#128688`，结束颜色设置为 `#4db3ff`。因此，我们的渐变将从左到右，从起始颜色渐变到结束颜色。'
- en: CSS gradient generators and vendor prefixes
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 渐变生成器和供应商前缀
- en: As gradients can be tedious to write by hand, many CSS gradient generators have
    been created and are freely available on the web. Many still include vendor prefixes
    in their generated code. These prefixes are no longer necessary, as gradients
    are now supported by all major browsers, and browsers that required them are almost
    completely nonexistent now.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于渐变手动编写可能很繁琐，因此已经创建了多个 CSS 渐变生成器，它们在网络上免费提供。许多生成器仍然在其生成的代码中包含供应商前缀。由于现在所有主流浏览器都支持渐变，并且需要这些前缀的浏览器几乎已经完全不存在，因此这些前缀不再是必要的。
- en: Finally, we add a border radius to the outermost container. The CSS for our
    progress bar is shown in the following listing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们给最外层的容器添加一个边框半径。我们的进度条 CSS 如下所示。
- en: Listing 3.18 Styling the progress indicator container in Chrome
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 Chrome 中样式化进度指示器容器
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Fallback color for the gradient
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ① 渐变的后备颜色
- en: Our progress indicator looks great in Chrome (figure 3.18). Next, let’s take
    a look at what it looks like in Firefox.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Chrome 中的进度指示器看起来很棒（图 3.18）。接下来，让我们看看它在 Firefox 中的样子。
- en: '![](../Images/03-18.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-18.png)'
- en: Figure 3.18 Styled progress indicator in Chrome
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 Chrome 中的样式化进度指示器
- en: In Firefox (figure 3.19), we see that our control remains fairly unstyled because
    instead of the `-webkit-` vendor prefix, it requires the `-moz-` prefix. Having
    written code for the `-webkit-` vendor prefix, we need to do the same for browsers
    that use the `-moz-` vendor prefix.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Firefox 中（图 3.19），我们发现我们的控件保持相对无样式，因为它需要的是 `-moz-` 前缀，而不是 `-webkit-` 前缀。因为我们已经为
    `-webkit-` 前缀编写了代码，所以我们需要为使用 `-moz-` 前缀的浏览器做同样的事情。
- en: '![](../Images/03-19.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-19.png)'
- en: Figure 3.19 Unstyled progress bar in Firefox
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 Firefox 中的无样式进度条
- en: 3.6.3 Styling the progress bar for -moz- browsers
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 为 -moz- 浏览器样式化进度条
- en: We’ll approach the styles a bit differently for Firefox because we don’t have
    as many properties to play with. The only `-moz-` prefixed property at our disposal
    is `::-moz-progress-bar`. Also a pseudo-element, it targets the progress indicator
    itself. Therefore, we’ll style it the same way that we styled `::-webkit-progress-value`
    for Chrome because we want to achieve the same look in both browsers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Firefox，我们将采取不同的样式方法，因为我们没有太多属性可以操作。我们可用的唯一 `-moz-` 前缀属性是 `::-moz-progress-bar`。它也是一个伪元素，它针对进度指示器本身。因此，我们将以与
    Chrome 中 `::-webkit-progress-value` 相同的方式对其进行样式化，因为我们希望在两个浏览器中达到相同的外观。
- en: 'Because we’re using the same styles, it’s logical to add the `-moz-` selector
    to the existing rule: `::-moz-progress-bar,` `::-webkit-progress-value` `{` `...`
    `}`. It works well in Firefox (figure 3.20), but it will break Chrome (figure
    3.21).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是相同的样式，因此将 `-moz-` 选择器添加到现有规则中是合理的：`::-moz-progress-bar,` `::-webkit-progress-value`
    `{` `...` `}`。它在 Firefox 中（图 3.20）工作得很好，但它会破坏 Chrome（图 3.21）。
- en: '![](../Images/03-20.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-20.png)'
- en: Figure 3.20 Firefox progress bar styled
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 Firefox 中的样式化进度条
- en: '![](../Images/03-21.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-21.png)'
- en: Figure 3.21 Adding both selectors in the same rule breaks Chrome.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 在同一个规则中添加两个选择器会破坏 Chrome。
- en: Having multiple selectors in the same rule shouldn’t cause this side effect,
    but we’re dealing with experimental properties, which sometimes have nonstandard
    behaviors. To prevent this unfortunate side effect, we’ll write two identical
    rules, one for each selector, as shown in the following listing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个规则中包含多个选择器不应该导致这种副作用，但我们正在处理实验性属性，它们有时会有非标准的行为。为了防止这种不幸的副作用，我们将为每个选择器编写两个相同的规则，如下面的列表所示。
- en: Listing 3.19 Styling the progress indicator container in Chrome
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 Chrome 中样式化进度指示器容器
- en: '[PRE19]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Rule for Chrome
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ① Chrome 的规则
- en: ② Rule for Firefox
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ② Firefox 的规则
- en: To change the background color for Firefox, we add a background property value
    to the progress element itself. We use the same gradient we used in the `::-webkit-progress-bar`
    rule. Figure 3.22 shows our progress in Firefox.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变 Firefox 的背景颜色，我们需要给进度元素本身添加一个背景属性值。我们使用与 `::-webkit-progress-bar` 规则中相同的渐变。图
    3.22 显示了 Firefox 中的进度。
- en: '![](../Images/03-22.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-22.png)'
- en: Figure 3.22 Firefox with background applied to the progress element
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 Firefox 中应用了背景的进度元素
- en: The last thing we need to do is remove the border, which we’ll apply to the
    `progress` rule. To achieve this effect, we set the border property value to `none`.
    The following listing shows our final progress rule.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是移除边框，我们将应用它到 `progress` 规则上。为了达到这个效果，我们将边框属性值设置为 `none`。下面的列表显示了我们的最终进度规则。
- en: Listing 3.20 Final progress rule
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 最终进度规则
- en: '[PRE20]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Gradient background
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ① 渐变背景
- en: ② Removes the border
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ② 移除边框
- en: As we can see in figure 3.23, we’ve achieved the same result in Chrome and Firefox.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图 3.23 中所看到的，我们在 Chrome 和 Firefox 中实现了相同的结果。
- en: '![](../Images/03-23.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-23.png)'
- en: Figure 3.23 Progress bar styles finished in Firefox
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 Firefox 中完成的进度条样式
- en: We must stress that the styles were achieved by using experimental features
    that are nonstandard and could change in the future. The value here is being able
    to experiment with new features before they become readily available. It’s also
    an opportunity to get involved in the community; it’s not uncommon for the working
    groups that develop browser features and specifications to request feedback before
    new standards are accepted and rolled out for general use.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须强调，这些样式是通过使用非标准且可能在未来更改的实验性功能实现的。这里的价值在于能够在新功能变得易于获取之前进行实验。这也是参与社区的机会；在开发浏览器功能和规范的工作组在新的标准被接受并推广到一般使用之前请求反馈的情况并不少见。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `animation` property is a way to animate the values of the position, color,
    or some other visual element with CSS.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation` 属性是一种使用 CSS 动画化位置、颜色或其他视觉元素值的方法。'
- en: The `@keyframes` at-rule is a way to define keyframes for your animations.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@keyframes` 规则是一种定义动画关键帧的方法。'
- en: We can delay the start of an animation by using the `animation-delay` property.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `animation-delay` 属性来延迟动画的开始。
- en: The `animation-duration` sets how long a single iteration of the animation should
    take to complete.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation-duration` 设置动画单次迭代完成所需的时间。'
- en: SVGs can be styled with CSS.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG 可以使用 CSS 进行样式化。
- en: The `prefers-reduced-motion` media query allows us to style animations conditionally
    per the user’s settings.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefers-reduced-motion` 媒体查询允许我们根据用户的设置有条件地样式化动画。'
- en: The HTML progress bar is a way to show how much of something has loaded.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML 进度条是一种显示已加载内容多少的方法。
- en: By default, the browser applies its own styling to the progress bar, but it
    can be reset by using the `appearance` property with a value of `none`.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，浏览器会应用自己的样式到进度条上，但可以通过使用 `appearance` 属性并设置值为 `none` 来重置它。
- en: Our ability to style the `progress` element is fairly restricted unless we use
    experimental properties.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非我们使用实验性属性，否则我们对 `progress` 元素的样式化能力相当有限。
- en: Some nonstandard properties are available to style the `progress` element, but
    they require the use of vendor prefixes. Vendor-prefixed properties are experimental,
    which means that they sometimes have nonstandard implementations and could change
    at any time.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些非标准属性可用于样式化 `progress` 元素，但它们需要使用供应商前缀。供应商前缀的属性是实验性的，这意味着它们有时会有非标准的实现，并且可能会随时更改。
