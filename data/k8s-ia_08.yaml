- en: 'Chapter 7\. ConfigMaps and Secrets: configuring applications'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章\. ConfigMaps和Secrets：配置应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Changing the main process of a container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改容器的主体进程
- en: Passing command-line options to the app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令行选项传递给应用程序
- en: Setting environment variables exposed to the app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置对应用暴露的环境变量
- en: Configuring apps through `ConfigMap`s
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`ConfigMap`s配置应用程序
- en: Passing sensitive information through `Secret`s
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Secret`s传递敏感信息
- en: Up to now you haven’t had to pass any kind of configuration data to the apps
    you’ve run in the exercises in this book. Because almost all apps require configuration
    (settings that differ between deployed instances, credentials for accessing external
    systems, and so on), which shouldn’t be baked into the built app itself, let’s
    see how to pass configuration options to your app when running it in Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有必要将任何类型的配置数据传递给你在本书练习中运行的应用程序。因为几乎所有的应用程序都需要配置（不同部署实例之间的设置、访问外部系统的凭证等），这些配置不应该烘焙到构建的应用程序本身中，让我们看看如何在Kubernetes中运行应用程序时传递配置选项。
- en: 7.1\. Configuring containerized applications
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 7.1\. 配置容器化应用程序
- en: Before we go over how to pass configuration data to apps running in Kubernetes,
    let’s look at how containerized applications are usually configured.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍如何将配置数据传递给在Kubernetes中运行的应用程序之前，让我们看看容器化应用程序通常是如何配置的。
- en: If you skip the fact that you can bake the configuration into the application
    itself, when starting development of a new app, you usually start off by having
    the app configured through command-line arguments. Then, as the list of configuration
    options grows, you can move the configuration into a config file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忽略了可以将配置烘焙到应用程序本身的事实，那么在开始开发新应用程序时，你通常会从通过命令行参数配置应用程序开始。然后，随着配置选项列表的增长，你可以将配置移动到一个配置文件中。
- en: Another way of passing configuration options to an application that’s widely
    popular in containerized applications is through environment variables. Instead
    of having the app read a config file or command-line arguments, the app looks
    up the value of a certain environment variable. The official MySQL container image,
    for example, uses an environment variable called `MYSQL_ROOT_PASSWORD` for setting
    the password for the root super-user account.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在容器化应用程序中广泛流行的方法是通过环境变量将配置选项传递给应用程序。而不是让应用程序读取配置文件或命令行参数，应用程序会查找某个环境变量的值。例如，官方MySQL容器镜像使用名为`MYSQL_ROOT_PASSWORD`的环境变量来设置root超级用户账户的密码。
- en: But why are environment variables so popular in containers? Using configuration
    files inside Docker containers is a bit tricky, because you’d have to bake the
    config file into the container image itself or mount a volume containing the file
    into the container. Obviously, baking files into the image is similar to hardcoding
    configuration into the source code of the application, because it requires you
    to rebuild the image every time you want to change the config. Plus, everyone
    with access to the image can see the config, including any information that should
    be kept secret, such as credentials or encryption keys. Using a volume is better,
    but still requires you to make sure the file is written to the volume before the
    container is started.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么环境变量在容器中如此受欢迎？在Docker容器内部使用配置文件有点棘手，因为你必须将配置文件烘焙到容器镜像本身中，或者将包含文件的卷挂载到容器中。显然，将文件烘焙到镜像中类似于将配置硬编码到应用程序的源代码中，因为这要求你每次想要更改配置时都必须重新构建镜像。此外，任何可以访问镜像的人都可以看到配置，包括任何应该保密的信息，如凭证或加密密钥。使用卷更好，但仍需要你确保在容器启动之前文件已写入卷。
- en: If you’ve read the previous chapter, you might think of using a `gitRepo` volume
    as a configuration source. That’s not a bad idea, because it allows you to keep
    the config nicely versioned and enables you to easily rollback a config change
    if necessary. But a simpler way allows you to put the configuration data into
    a top-level Kubernetes resource and store it and all the other resource definitions
    in the same Git repository or in any other file-based storage. The Kubernetes
    resource for storing configuration data is called a ConfigMap. We’ll learn how
    to use it in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了上一章，你可能会考虑使用`gitRepo`卷作为配置源。这并不是一个坏主意，因为它允许你保持配置的版本控制良好，并在必要时轻松回滚配置更改。但有一个更简单的方法，允许你将配置数据放入顶级Kubernetes资源中，并将所有其他资源定义存储在同一Git仓库或任何其他基于文件的存储中。用于存储配置数据的Kubernetes资源称为ConfigMap。我们将在本章中学习如何使用它。
- en: Regardless if you’re using a ConfigMap to store configuration data or not, you
    can configure your apps by
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否使用ConfigMap来存储配置数据，你都可以通过以下方式配置你的应用程序：
- en: Passing command-line arguments to containers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向容器传递命令行参数
- en: Setting custom environment variables for each container
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个容器设置自定义环境变量
- en: Mounting configuration files into containers through a special type of volume
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过特殊类型的卷将配置文件挂载到容器中
- en: We’ll go over all these options in the next few sections, but before we start,
    let’s look at config options from a security perspective. Though most configuration
    options don’t contain any sensitive information, several can. These include credentials,
    private encryption keys, and similar data that needs to be kept secure. This type
    of information needs to be handled with special care, which is why Kubernetes
    offers another type of first-class object called a Secret. We’ll learn about it
    in the last part of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中详细讨论所有这些选项，但在开始之前，让我们从安全的角度来审视配置选项。尽管大多数配置选项不包含任何敏感信息，但其中一些确实包含。这些包括凭证、私有加密密钥以及需要保持安全的数据。这类信息需要特别小心处理，这也是为什么Kubernetes提供了一种称为Secret的一类一等对象。我们将在本章的最后部分了解它。
- en: 7.2\. Passing command-line arguments to containers
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2. 向容器传递命令行参数
- en: In all the examples so far, you’ve created containers that ran the default command
    defined in the container image, but Kubernetes allows overriding the command as
    part of the pod’s container definition when you want to run a different executable
    instead of the one specified in the image, or want to run it with a different
    set of command-line arguments. We’ll look at how to do that now.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有示例中，你创建的容器都运行了容器镜像中定义的默认命令，但Kubernetes允许在你想运行不同于镜像中指定的可执行文件，或者想用不同的命令行参数运行它时，作为pod容器定义的一部分来覆盖命令。我们现在将看看如何做到这一点。
- en: 7.2.1\. Defining the command and arguments in Docker
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2.1. 在Docker中定义命令和参数
- en: 'The first thing I need to explain is that the whole command that gets executed
    in the container is composed of two parts: the command and the arguments.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要首先解释的是，在容器中执行的整体命令由两部分组成：命令和参数。
- en: Understanding ENTRYPOINT and CMD
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 理解ENTRYPOINT和CMD
- en: 'In a Dockerfile, two instructions define the two parts:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile中，两条指令定义了两个部分：
- en: '`ENTRYPOINT` defines the executable invoked when the container is started.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`定义了容器启动时调用的可执行文件。'
- en: '`CMD` specifies the arguments that get passed to the `ENTRYPOINT`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`指定传递给`ENTRYPOINT`的参数。'
- en: Although you can use the `CMD` instruction to specify the command you want to
    execute when the image is run, the correct way is to do it through the `ENTRYPOINT`
    instruction and to only specify the `CMD` if you want to define the default arguments.
    The image can then be run without specifying any arguments
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用`CMD`指令来指定在运行镜像时要执行的命令，但正确的方式是通过`ENTRYPOINT`指令来执行，并且只有当你想定义默认参数时才指定`CMD`。然后可以不指定任何参数来运行镜像
- en: '`$ docker run <image>`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run <image>`'
- en: 'or with additional arguments, which override whatever’s set under `CMD` in
    the Dockerfile:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用额外的参数，这些参数将覆盖在Dockerfile中`CMD`下设置的任何内容：
- en: '`$ docker run <image> <arguments>`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run <image> <arguments>`'
- en: Understanding the difference between the shell and exec forms
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 理解shell和exec形式的区别
- en: 'But there’s more. Both instructions support two different forms:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有更多。这两条指令支持两种不同的形式：
- en: '`shell` form—For example, `ENTRYPOINT node app.js.`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell`形式——例如，`ENTRYPOINT node app.js.`。'
- en: '`exec` form—For example, `ENTRYPOINT ["node", "app.js"]`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`形式——例如，`ENTRYPOINT ["node", "app.js"]`。'
- en: The difference is whether the specified command is invoked inside a shell or
    not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于指定的命令是否在shell内部调用。
- en: 'In the `kubia` image you created in [chapter 2](index_split_022.html#filepos185841),
    you used the `exec` form of the `ENTRYPOINT` instruction:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建的[kubia](index_split_022.html#filepos185841)镜像中，你使用了`ENTRYPOINT`指令的`exec`形式：
- en: '`ENTRYPOINT ["node", "app.js"]`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT ["node", "app.js"]`'
- en: 'This runs the node process directly (not inside a shell), as you can see by
    listing the processes running inside the container:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接运行node进程（不在shell内部），正如你可以通过列出容器内部正在运行的过程所看到的那样：
- en: '`$ docker exec 4675d ps x` `PID TTY      STAT   TIME COMMAND     1 ?       
    Ssl    0:00 node app.js    12 ?        Rs     0:00 ps x`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker exec 4675d ps x` `PID TTY      STAT   TIME COMMAND     1 ?       
    Ssl    0:00 node app.js    12 ?        Rs     0:00 ps x`'
- en: 'If you’d used the `shell` form (`ENTRYPOINT node app.js`), these would have
    been the container’s processes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了`shell`形式（`ENTRYPOINT node app.js`），这些将是容器的进程：
- en: '`$ docker exec -it e4bad ps x` `PID TTY      STAT   TIME COMMAND     1 ?       
    Ss     0:00 /bin/sh -c node app.js     7 ?        Sl     0:00 node app.js    13
    ?        Rs+    0:00 ps x`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker exec -it e4bad ps x` `PID TTY      STAT   TIME COMMAND` `1 ?       
    Ss     0:00 /bin/sh -c node app.js` `7 ?        Sl     0:00 node app.js` `13 ?       
    Rs+    0:00 ps x`'
- en: As you can see, in that case, the main process (`PID 1`) would be the `shell`
    process instead of the node process. The node process (`PID 7`) would be started
    from that shell. The `shell` process is unnecessary, which is why you should always
    use the `exec` form of the ENTRYPOINT instruction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，主进程（`PID 1`）将是`shell`进程而不是node进程。node进程（`PID 7`）将从该shell启动。`shell`进程是不必要的，这就是为什么您应该始终使用`ENTRYPOINT`指令的`exec`形式。
- en: Making the interval configurable in your fortune image
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的fortune镜像中使间隔可配置
- en: Let’s modify your fortune script and image so the delay interval in the loop
    is configurable. You’ll add an `INTERVAL` variable and initialize it with the
    value of the first command-line argument, as shown in the following listing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改您的fortune脚本和镜像，以便循环中的延迟间隔可配置。您将添加一个`INTERVAL`变量，并将其初始化为第一个命令行参数的值，如下所示。
- en: 'Listing 7.1\. Fortune script with interval configurable through argument: fortune-args/fortuneloop.sh'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1. 通过参数可配置间隔的fortune脚本：fortune-args/fortuneloop.sh
- en: '`#!/bin/bash trap "exit" SIGINT` `INTERVAL=$1``echo Configured to generate
    new fortune every $INTERVAL seconds` `mkdir -p /var/htdocs while : do   echo $(date)
    Writing fortune to /var/htdocs/index.html   /usr/games/fortune > /var/htdocs/index.html`
    `sleep $INTERVAL` `done`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`#!/bin/bash trap "exit" SIGINT` `INTERVAL=$1` `echo Configured to generate
    new fortune every $INTERVAL seconds` `mkdir -p /var/htdocs while : do echo $(date)
    Writing fortune to /var/htdocs/index.html /usr/games/fortune > /var/htdocs/index.html`
    `sleep $INTERVAL` `done`'
- en: You’ve added or modified the lines in bold font. Now, you’ll modify the Dockerfile
    so it uses the `exec` version of the `ENTRYPOINT` instruction and sets the default
    interval to 10 seconds using the `CMD` instruction, as shown in the following
    listing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您已添加或修改了粗体字体的行。现在，您将修改Dockerfile，使其使用`ENTRYPOINT`指令的`exec`版本，并使用`CMD`指令将默认间隔设置为10秒，如下所示。
- en: 'Listing 7.2\. Dockerfile for the updated `fortune` image: fortune-args/Dockerfile'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2. 更新后的`fortune`镜像的Dockerfile：fortune-args/Dockerfile
- en: '`FROM ubuntu:latest RUN apt-get update ; apt-get -y install fortune ADD fortuneloop.sh
    /bin/fortuneloop.sh ENTRYPOINT ["/bin/fortuneloop.sh"]` `1` `CMD ["10"]` `2`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM ubuntu:latest RUN apt-get update ; apt-get -y install fortune ADD fortuneloop.sh
    /bin/fortuneloop.sh ENTRYPOINT ["/bin/fortuneloop.sh"]` `1` `CMD ["10"]` `2`'
- en: 1 The exec form of the ENTRYPOINT instruction
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1. `ENTRYPOINT`指令的exec形式
- en: 2 The default argument for the executable
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2. 可执行文件的默认参数
- en: 'You can now build and push the image to Docker Hub. This time, you’ll tag the
    image as `args` instead of `latest`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以构建并将镜像推送到Docker Hub。这次，您将使用`args`而不是`latest`标记镜像：
- en: '`$ docker build -t docker.io/luksa/fortune:args .``$ docker push docker.io/luksa/fortune:args`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker build -t docker.io/luksa/fortune:args .` `$ docker push docker.io/luksa/fortune:args`'
- en: 'You can test the image by running it locally with Docker:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在本地使用Docker运行它来测试镜像：
- en: '`$ docker run -it docker.io/luksa/fortune:args` `Configured to generate new
    fortune every 10 seconds Fri May 19 10:39:44 UTC 2017 Writing fortune to /var/htdocs/index.html`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run -it docker.io/luksa/fortune:args` `Configured to generate new
    fortune every 10 seconds Fri May 19 10:39:44 UTC 2017 Writing fortune to /var/htdocs/index.html`'
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can stop the script with Control+C.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Control+C停止脚本。
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'And you can override the default sleep interval by passing it as an argument:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递它作为参数来覆盖默认的睡眠间隔：
- en: '`$ docker run -it docker.io/luksa/fortune:args 15` `Configured to generate
    new fortune every 15 seconds`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run -it docker.io/luksa/fortune:args 15` `Configured to generate
    new fortune every 15 seconds`'
- en: Now that you’re sure your image honors the argument passed to it, let’s see
    how to use it in a pod.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您确信您的镜像尊重传递给它的参数，让我们看看如何在pod中使用它。
- en: 7.2.2\. Overriding the command and arguments in Kubernetes
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2.2. 覆盖Kubernetes中的命令和参数
- en: In Kubernetes, when specifying a container, you can choose to override both
    `ENTRYPOINT` and `CMD`. To do that, you set the properties `command` and `args`
    in the container specification, as shown in the following listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，当指定容器时，您可以选择覆盖`ENTRYPOINT`和`CMD`。为此，您在容器规范中设置`command`和`args`属性，如下所示。
- en: Listing 7.3\. A pod definition specifying a custom command and arguments
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3. 指定自定义命令和参数的pod定义
- en: '`kind: Pod spec:   containers:   - image: some/image` `command: ["/bin/command"]``args:
    ["arg1", "arg2", "arg3"]`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind: Pod spec:   containers:   - image: some/image` `command: ["/bin/command"]``args:
    ["arg1", "arg2", "arg3"]`'
- en: In most cases, you’ll only set custom arguments and rarely override the command
    (except in general-purpose images such as `busybox`, which doesn’t define an `ENTRYPOINT`
    at all).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你只会设置自定义参数，很少会覆盖命令（除非是在通用镜像，如 `busybox`，它根本未定义 `ENTRYPOINT`）。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `command` and `args` fields can’t be updated after the pod is created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`command` 和 `args` 字段在 Pod 创建后不能更新。'
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The two Dockerfile instructions and the equivalent pod spec fields are shown
    in [table 7.1](#filepos701678).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 Dockerfile 指令及其等效的 Pod 规范字段显示在[表 7.1](#filepos701678)中。
- en: Table 7.1\. Specifying the executable and its arguments in Docker vs Kubernetes
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1\. 在 Docker 与 Kubernetes 中指定可执行文件及其参数
- en: '| Docker | Kubernetes | Description |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| Docker | Kubernetes | 描述 |'
- en: '| ENTRYPOINT | command | The executable that’s executed inside the container
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| ENTRYPOINT | command | 在容器内执行的可执行文件 |'
- en: '| CMD | args | The arguments passed to the executable |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| CMD | args | 传递给可执行文件的参数 |'
- en: Running the fortune pod with a custom interval
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义间隔运行 fortune Pod
- en: To run the fortune pod with a custom delay interval, you’ll copy your fortune-pod.yaml
    into fortune-pod-args.yaml and modify it as shown in the following listing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义延迟间隔运行 fortune Pod，你需要将你的 fortune-pod.yaml 复制到 fortune-pod-args.yaml 并按以下列表进行修改。
- en: 'Listing 7.4\. Passing an argument in the pod definition: fortune-pod-args.yaml'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4\. 在 Pod 定义中传递参数：fortune-pod-args.yaml
- en: '`apiVersion: v1 kind: Pod metadata:` `name: fortune2s``1` `spec:   containers:`
    `- image: luksa/fortune:args``2``args: ["2"]``3` `name: html-generator     volumeMounts:
        - name: html       mountPath: /var/htdocs ...`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:` `name: fortune2s``1` `spec:   containers:`
    `- image: luksa/fortune:args``2``args: ["2"]``3` `name: html-generator     volumeMounts:
        - name: html       mountPath: /var/htdocs ...`'
- en: 1 You changed the pod’s name.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你更改了 Pod 的名称。
- en: 2 Using fortune:args instead of fortune:latest
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 使用 fortune:args 而不是 fortune:latest
- en: 3 This argument makes the script generate a new fortune every two seconds.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 此参数使脚本每两秒生成一个新的 fortune。
- en: You added the `args` array to the container definition. Try creating this pod
    now. The values of the array will be passed to the container as command-line arguments
    when it is run.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你已将 `args` 数组添加到容器定义中。现在尝试创建此 Pod。数组中的值将在容器运行时作为命令行参数传递。
- en: 'The array notation used in this listing is great if you have one argument or
    a few. If you have several, you can also use the following notation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中使用的数组表示法，如果你只有一个或几个参数时非常好用。如果你有多个参数，你也可以使用以下表示法：
- en: '`    args:     - foo     - bar     - "15"`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`    args:     - foo     - bar     - "15"`'
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don’t need to enclose string values in quotations marks (but you must enclose
    numbers).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要将字符串值用引号括起来（但必须将数字括起来）。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Specifying arguments is one way of passing config options to your containers
    through command-line arguments. Next, you’ll see how to do it through environment
    variables.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 指定参数是向容器通过命令行参数传递配置选项的一种方式。接下来，你将看到如何通过环境变量来实现。
- en: 7.3\. Setting environment variables for a container
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3\. 为容器设置环境变量
- en: As I’ve already mentioned, containerized applications often use environment
    variables as a source of configuration options. Kubernetes allows you to specify
    a custom list of environment variables for each container of a pod, as shown in
    [figure 7.1](#filepos705947). Although it would be useful to also define environment
    variables at the pod level and have them be inherited by its containers, no such
    option currently exists.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，容器化应用程序通常使用环境变量作为配置选项的来源。Kubernetes 允许你为 Pod 的每个容器指定一个自定义的环境变量列表，如图
    7.1 所示。[图 7.1](#filepos705947)。虽然定义 Pod 级别的环境变量并使其被其容器继承将非常有用，但目前尚无此选项。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Like the container’s command and arguments, the list of environment variables
    also cannot be updated after the pod is created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器的命令和参数一样，环境变量列表在创建 Pod 之后也不能更新。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 7.1\. Environment variables can be set per container.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1\. 可以为每个容器设置环境变量。
- en: '![](images/00092.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00092.jpg)'
- en: Making the interval in your fortune image configurable through an- n environment
    variable
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过环境变量使 fortune 镜像的间隔可配置
- en: Let’s see how to modify your fortuneloop.sh script once again to allow it to
    be configured from an environment variable, as shown in the following listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看如何修改你的 fortuneloop.sh 脚本，以便它可以从环境变量中进行配置，如下面的列表所示。
- en: 'Listing 7.5\. Fortune script with interval configurable through env var: fortune-env/fortuneloop.sh'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5\. 通过环境变量配置间隔的 fortune 脚本：fortune-env/fortuneloop.sh
- en: '`#!/bin/bash trap "exit" SIGINT echo Configured to generate new fortune every
    $INTERVAL seconds mkdir -p /var/htdocs while : do   echo $(date) Writing fortune
    to /var/htdocs/index.html   /usr/games/fortune > /var/htdocs/index.html   sleep
    $INTERVAL done`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`#!/bin/bash trap "exit" SIGINT echo Configured to generate new fortune every
    $INTERVAL seconds mkdir -p /var/htdocs while : do   echo $(date) Writing fortune
    to /var/htdocs/index.html   /usr/games/fortune > /var/htdocs/index.html   sleep
    $INTERVAL done`'
- en: All you had to do was remove the row where the `INTERVAL` variable is initialized.
    Because your “app” is a simple bash script, you didn’t need to do anything else.
    If the app was written in Java you’d use `System.getenv("INTERVAL")`, whereas
    in Node.JS you’d use `process.env.INTERVAL`, and in Python you’d use `os.environ['INTERVAL']`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是删除初始化 `INTERVAL` 变量的那一行。因为你的“应用”是一个简单的 bash 脚本，所以你不需要做其他任何事情。如果应用是用
    Java 编写的，你会使用 `System.getenv("INTERVAL")`，而在 Node.JS 中你会使用 `process.env.INTERVAL`，在
    Python 中你会使用 `os.environ['INTERVAL']`。
- en: 7.3.1\. Specifying environment variables in a container definition
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3.1\. 在容器定义中指定环境变量
- en: After building the new image (I’ve tagged it as `luksa/fortune:env` this time)
    and pushing it to Docker Hub, you can run it by creating a new pod, in which you
    pass the environment variable to the script by including it in your container
    definition, as shown in the following listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新的镜像（这次我将其标记为 `luksa/fortune:env`）并将其推送到 Docker Hub 后，你可以通过创建一个新的 pod 来运行它，在容器定义中包含环境变量，如下面的列表所示。
- en: 'Listing 7.6\. Defining an environment variable in a pod: fortune-pod-env.yaml'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6\. 在 pod 中定义环境变量：fortune-pod-env.yaml
- en: '`kind: Pod spec: containers: - image: luksa/fortune:env` `env:``1``- name:
    INTERVAL``1``value: "30"``1` `name: html-generator ...`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind: Pod spec: containers: - image: luksa/fortune:env` `env:``1``- name:
    INTERVAL``1``value: "30"``1` `name: html-generator ...`'
- en: 1 Adding a single variable to the environment variable list
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 向环境变量列表中添加单个变量
- en: As mentioned previously, you set the environment variable inside the container
    definition, not at the pod level.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你是在容器定义中设置环境变量，而不是在 pod 层级上。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t forget that in each container, Kubernetes also automatically exposes environment
    variables for each service in the same namespace. These environment variables
    are basically auto-injected configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，在每个容器中，Kubernetes 还会自动为同一命名空间中的每个服务暴露环境变量。这些环境变量基本上是自动注入的配置。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.2\. Referring to other environment variables in a variable’s value
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3.2\. 在变量的值中引用其他环境变量
- en: In the previous example, you set a fixed value for the environment variable,
    but you can also reference previously defined environment variables or any other
    existing variables by using the `$(VAR)` syntax. If you define two environment
    variables, the second one can include the value of the first one as shown in the
    following listing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你为环境变量设置了一个固定值，但你也可以通过使用 `$(VAR)` 语法来引用先前定义的环境变量或任何其他现有变量。如果你定义了两个环境变量，第二个可以包含第一个的值，如下面的列表所示。
- en: Listing 7.7\. Referring to an environment variable inside another one
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7\. 在另一个环境变量中引用环境变量
- en: '`env: - name:` `FIRST_VAR` `value: "foo" - name: SECOND_VAR   value:` `"$(FIRST_VAR)bar"`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`env: - name:` `FIRST_VAR` `value: "foo" - name: SECOND_VAR   value:` `"$(FIRST_VAR)bar"`'
- en: In this case, the `SECOND_VAR`’s value will be `"foobar"`. Similarly, both the
    `command` and `args` attributes you learned about in [section 7.2](index_split_065.html#filepos692510)
    can also refer to environment variables like this. You’ll use this method in [section
    7.4.5](index_split_067.html#filepos729028).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`SECOND_VAR` 的值将是 `"foobar"`。同样，你曾在 [第 7.2 节](index_split_065.html#filepos692510)
    中学到的 `command` 和 `args` 属性也可以这样引用环境变量。你将在 [第 7.4.5 节](index_split_067.html#filepos729028)
    中使用这种方法。
- en: 7.3.3\. Understanding the drawback of hardcoding environment variables
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3.3\. 理解硬编码环境变量的缺点
- en: Having values effectively hardcoded in the pod definition means you need to
    have separate pod definitions for your production and your development pods. To
    reuse the same pod definition in multiple environments, it makes sense to decouple
    the configuration from the pod descriptor. Luckily, you can do that using a ConfigMap
    resource and using it as a source for environment variable values using the `valueFrom`
    instead of the `value` field. You’ll learn about this next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将值硬编码在Pod定义中实际上意味着你需要为生产环境和开发环境分别拥有不同的Pod定义。为了在多个环境中重用相同的Pod定义，将配置与Pod描述符解耦是有意义的。幸运的是，你可以使用ConfigMap资源来实现这一点，并使用`valueFrom`字段而不是`value`字段作为环境变量值的来源。你将在下一节中了解这一点。
- en: 7.4\. Decoupling configuration with a ConfigMap
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4\. 使用ConfigMap解耦配置
- en: The whole point of an app’s configuration is to keep the config options that
    vary between environments, or change frequently, separate from the application’s
    source code. If you think of a pod descriptor as source code for your app (and
    in microservices architectures that’s what it really is, because it defines how
    to compose the individual components into a functioning system), it’s clear you
    should move the configuration out of the pod description.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置的整个目的是将不同环境之间或频繁变化的配置选项与应用程序的源代码分开。如果你将Pod描述符视为应用程序的源代码（在微服务架构中这确实是如此，因为它定义了如何将单个组件组合成一个功能系统），那么很明显你应该将配置从Pod描述符中移出。
- en: 7.4.1\. Introducing ConfigMaps
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.1\. 介绍ConfigMap
- en: Kubernetes allows separating configuration options into a separate object called
    a ConfigMap, which is a map containing key/value pairs with the values ranging
    from short literals to full config files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes允许将配置选项分离到称为ConfigMap的单独对象中，它是一个包含键/值对的映射，其值范围从简短的字面量到完整的配置文件。
- en: An application doesn’t need to read the ConfigMap directly or even know that
    it exists. The contents of the map are instead passed to containers as either
    environment variables or as files in a volume (see [figure 7.2](#filepos712599)).
    And because environment variables can be referenced in command-line arguments
    using the `$(ENV_VAR)` syntax, you can also pass ConfigMap entries to processes
    as command-line arguments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不需要直接读取ConfigMap或甚至知道它的存在。映射的内容作为环境变量或作为卷中的文件传递给容器（见[图7.2](#filepos712599)）。并且因为可以使用`$(ENV_VAR)`语法在命令行参数中引用环境变量，所以你还可以将ConfigMap条目作为命令行参数传递给进程。
- en: Figure 7.2\. Pods use ConfigMaps through environment variables and `configMap`
    volumes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2\. Pods通过环境变量和`configMap`卷使用ConfigMap。
- en: '![](images/00109.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00109.jpg)'
- en: Sure, the application can also read the contents of a ConfigMap directly through
    the Kubernetes REST API endpoint if needed, but unless you have a real need for
    this, you should keep your app Kubernetes-agnostic as much as possible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果需要，应用程序也可以直接通过Kubernetes REST API端点读取ConfigMap的内容，但除非你真的有这个需求，否则你应该尽可能保持你的应用程序与Kubernetes无关。
- en: Regardless of how an app consumes a ConfigMap, having the config in a separate
    standalone object like this allows you to keep multiple manifests for ConfigMaps
    with the same name, each for a different environment (development, testing, QA,
    production, and so on). Because pods reference the ConfigMap by name, you can
    use a different config in each environment while using the same pod specification
    across all of them (see [figure 7.3](#filepos713688)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无论应用程序如何消费ConfigMap，将配置保存在这样的独立对象中，都允许你为具有相同名称的ConfigMap保留多个清单，每个清单针对不同的环境（开发、测试、QA、生产等）。因为Pod通过名称引用ConfigMap，所以你可以在每个环境中使用不同的配置，同时在所有环境中使用相同的Pod规范（见[图7.3](#filepos713688)）。
- en: Figure 7.3\. Two different ConfigMaps with the same name used in different environments
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3\. 在不同环境中使用相同名称的两种不同的ConfigMap
- en: '![](images/00129.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00129.jpg)'
- en: 7.4.2\. Creating a ConfigMap
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.2\. 创建ConfigMap
- en: Let’s see how to use a ConfigMap in one of your pods. To start with the simplest
    example, you’ll first create a map with a single key and use it to fill the `INTERVAL`
    environment variable from your previous example. You’ll create the ConfigMap with
    the special `kubectl create configmap` command instead of posting a YAML with
    the generic `kubectl create -f` command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在您的Pod中使用ConfigMap。首先，从最简单的例子开始，你将首先创建一个包含单个键的映射，并使用它来填充您之前示例中的`INTERVAL`环境变量。你将使用特殊的`kubectl
    create configmap`命令来创建ConfigMap，而不是使用通用的`kubectl create -f`命令来发布YAML。
- en: Using the kubectl create configmap command
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kubectl create configmap命令
- en: 'You can define the map’s entries by passing literals to the `kubectl` command
    or you can create the ConfigMap from files stored on your disk. Use a simple literal
    first:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 `kubectl` 命令传递字面量来定义映射的条目，或者你可以从你的磁盘上的文件创建 ConfigMap。首先使用一个简单的字面量：
- en: '`$ kubectl create configmap fortune-config --from-literal=sleep-interval=25`
    `configmap "fortune-config" created`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create configmap fortune-config --from-literal=sleep-interval=25`
    `configmap "fortune-config" created`'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: ConfigMap keys must be a valid DNS subdomain (they may only contain alphanumeric
    characters, dashes, underscores, and dots). They may optionally include a leading
    dot.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 键必须是有效的 DNS 子域（它们只能包含字母数字字符、破折号、下划线和点）。它们可以可选地包含一个前导点。
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This creates a ConfigMap called `fortune-config` with the single-entry `sleep-interval
    =25` ([figure 7.4](#filepos715543)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `fortune-config` 的 ConfigMap，包含单个条目 `sleep-interval =25` ([图 7.4](#filepos715543))。
- en: Figure 7.4\. The `fortune-config` ConfigMap containing a single entry
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4\. 包含单个条目的 `fortune-config` ConfigMap
- en: '![](images/00144.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00144.jpg)'
- en: 'ConfigMaps usually contain more than one entry. To create a ConfigMap with
    multiple literal entries, you add multiple `--from-literal` arguments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 通常包含多个条目。要创建包含多个字面条目的 ConfigMap，你需要在命令中添加多个 `--from-literal` 参数：
- en: '`$ kubectl create configmap myconfigmap`![](images/00006.jpg)`--from-literal=foo=bar
    --from-literal=bar=baz --from-literal=one=two`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create configmap myconfigmap`![](images/00006.jpg)`--from-literal=foo=bar
    --from-literal=bar=baz --from-literal=one=two`'
- en: Let’s inspect the YAML descriptor of the ConfigMap you created by using the
    `kubectl get` command, as shown in the following listing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查使用 `kubectl get` 命令创建的 ConfigMap 的 YAML 描述符，如下所示。
- en: Listing 7.8\. A ConfigMap definition
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8\. 一个 ConfigMap 定义
- en: '`$ kubectl get configmap fortune-config -o yaml` `apiVersion: v1 data:   sleep-interval:
    "25"` `1` `kind: ConfigMap` `2` `metadata:   creationTimestamp: 2016-08-11T20:31:08Z
      name: fortune-config` `3` `namespace: default   resourceVersion: "910025"  
    selfLink: /api/v1/namespaces/default/configmaps/fortune-config   uid: 88c4167e-6002-11e6-a50d-42010af00237`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get configmap fortune-config -o yaml` `apiVersion: v1 data:   sleep-interval:
    "25"` `1` `kind: ConfigMap` `2` `metadata:   creationTimestamp: 2016-08-11T20:31:08Z
      name: fortune-config` `3` `namespace: default   resourceVersion: "910025"  
    selfLink: /api/v1/namespaces/default/configmaps/fortune-config   uid: 88c4167e-6002-11e6-a50d-42010af00237`'
- en: 1 The single entry in this map
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 该映射中的单个条目
- en: 2 This descriptor describes a ConfigMap.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 此描述符描述了一个 ConfigMap。
- en: 3 The name of this map (you’re referencing it by this name)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 该映射的名称（你将通过此名称引用它）
- en: Nothing extraordinary. You could easily have written this YAML yourself (you
    wouldn’t need to specify anything but the name in the `metadata` section, of course)
    and posted it to the Kubernetes API with the well-known
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别之处。你很容易就能自己编写这个 YAML（当然，你不需要在 `metadata` 部分指定任何内容，除了名称之外）并将其发布到 Kubernetes
    API 中，使用众所周知的
- en: '`$ kubectl create -f fortune-config.yaml`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f fortune-config.yaml`'
- en: Creating a ConfigMap entry from the contents of a file
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件内容创建 ConfigMap 条目
- en: 'ConfigMaps can also store coarse-grained config data, such as complete config
    files. To do this, the `kubectl create configmap` command also supports reading
    files from disk and storing them as individual entries in the ConfigMap:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 还可以存储粗粒度的配置数据，例如完整的配置文件。为此，`kubectl create configmap` 命令还支持从磁盘读取文件并将它们作为
    ConfigMap 中的单独条目存储：
- en: '`$ kubectl create configmap my-config --from-file=config-file.conf`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create configmap my-config --from-file=config-file.conf`'
- en: 'When you run the previous command, kubectl looks for the file `config-file.conf`
    in the directory you run `kubectl` in. It will then store the contents of the
    file under the key `config-file.conf` in the ConfigMap (the filename is used as
    the map key), but you can also specify a key manually like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的命令时，kubectl 会查找你在其中运行 `kubectl` 的目录中的 `config-file.conf` 文件。然后，它将在 ConfigMap
    中以 `config-file.conf` 为键存储文件的全部内容（文件名用作映射键），但你也可以像这样手动指定键：
- en: '`$ kubectl create configmap my-config --from-file=customkey=config-file.conf`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create configmap my-config --from-file=customkey=config-file.conf`'
- en: This command will store the file’s contents under the key `customkey`. As with
    literals, you can add multiple files by using the `--from-file` argument multiple
    times.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在键 `customkey` 下存储文件的全部内容。与字面量一样，你可以通过多次使用 `--from-file` 参数添加多个文件。
- en: Creating a ConfigMap from files in a directory
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录中的文件创建 ConfigMap
- en: 'Instead of importing each file individually, you can even import all files
    from a file directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以导入文件目录中的所有文件，而不是逐个导入每个文件：
- en: '`$ kubectl create configmap my-config --from-file=/path/to/dir`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create configmap my-config --from-file=/path/to/dir`'
- en: In this case, `kubectl` will create an individual map entry for each file in
    the specified directory, but only for files whose name is a valid ConfigMap key.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`kubectl`将为指定目录中的每个文件创建单独的映射条目，但仅限于文件名是有效的ConfigMap键。
- en: Combining different options
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结合不同的选项
- en: 'When creating ConfigMaps, you can use a combination of all the options mentioned
    here (note that these files aren’t included in the book’s code archive—you can
    create them yourself if you’d like to try out the command):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建ConfigMap时，你可以使用这里提到的所有选项的组合（请注意，这些文件不包括在本书的代码存档中——如果你想要尝试命令，你可以自己创建它们）：
- en: '`$ kubectl create configmap my-config` ![](images/00006.jpg)`--from-file=foo.json`
    `1`![](images/00006.jpg)`--from-file=bar=foobar.conf` `2`![](images/00006.jpg)`--from-file=config-opts/`
    `3`![](images/00006.jpg)`--from-literal=some=thing` `4`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create configmap my-config` ![图片](images/00006.jpg)`--from-file=foo.json`
    `1`![图片](images/00006.jpg)`--from-file=bar=foobar.conf` `2`![图片](images/00006.jpg)`--from-file=config-opts/`
    `3`![图片](images/00006.jpg)`--from-literal=some=thing` `4`'
- en: 1 A single file
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 一个单独的文件
- en: 2 A file stored under a custom key
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 存储在自定义键下的文件
- en: 3 A whole directory
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 整个目录
- en: 4 A literal value
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 一个字面值
- en: 'Here, you’ve created the ConfigMap from multiple sources: a whole directory,
    a file, another file (but stored under a custom key instead of using the filename
    as the key), and a literal value. [Figure 7.5](#filepos721671) shows all these
    sources and the resulting ConfigMap.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已从多个来源创建了ConfigMap：整个目录、一个文件、另一个文件（但存储在自定义键下而不是使用文件名作为键），以及一个字面值。[图7.5](#filepos721671)显示了所有这些来源和生成的ConfigMap。
- en: Figure 7.5\. Creating a ConfigMap from individual files, a directory, and a
    literal value
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5\. 从单个文件、目录和字面值创建ConfigMap
- en: '![](images/00164.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00164.jpg)'
- en: 7.4.3\. Passing a ConfigMap entry to a container as an environment variable
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.3\. 将ConfigMap条目作为环境变量传递给容器
- en: How do you now get the values from this map into a pod’s container? You have
    three options. Let’s start with the simplest—setting an environment variable.
    You’ll use the `valueFrom` field I mentioned in [section 7.3.3](index_split_066.html#filepos710540).
    The pod descriptor should look like the following listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在如何将这个映射的值放入一个容器的容器中？你有三个选项。让我们从最简单的开始——设置一个环境变量。你将使用我提到的`valueFrom`字段，在[第7.3.3节](index_split_066.html#filepos710540)。Pod描述符应该看起来像以下列表。
- en: 'Listing 7.9\. Pod with `env var` from a config map: fortune-pod-env-configmap.yaml'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9\. 从ConfigMap获取`env var`的Pod：fortune-pod-env-configmap.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: fortune-env-from-configmap spec:
      containers:   - image: luksa/fortune:env     env:` `1` `- name: INTERVAL` `1`
    `valueFrom:` `2` `configMapKeyRef:` `2` `name: fortune-config` `3` `key: sleep-interval`
    `4` `...`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata: name: fortune-env-from-configmap spec:
    containers: - image: luksa/fortune:env env: `1` - name: INTERVAL `1` valueFrom:
    `2` configMapKeyRef: `2` name: fortune-config `3` key: sleep-interval `4` `...`'
- en: 1 You’re setting the environment variable called INTERVAL.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你正在设置名为INTERVAL的环境变量。
- en: 2 Instead of setting a fixed value, you’re initializing it from a ConfigMap
    key.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 你不是设置一个固定值，而是从ConfigMap键初始化它。
- en: 3 The name of the ConfigMap you’re referencing
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 引用的ConfigMap的名称
- en: 4 You’re setting the variable to whatever is stored under this key in the ConfigMap.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 你正在将变量设置为ConfigMap中此键下存储的任何内容。
- en: You defined an environment variable called `INTERVAL` and set its value to whatever
    is stored in the `fortune-config` ConfigMap under the key `sleep-interval`. When
    the process running in the `html-generator` container reads the `INTERVAL` environment
    variable, it will see the value `25` (shown in [figure 7.6](#filepos724431)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个名为`INTERVAL`的环境变量，并将其值设置为存储在`fortune-config` ConfigMap中`sleep-interval`键下的任何内容。当在`html-generator`容器中运行的进程读取`INTERVAL`环境变量时，它将看到值`25`（如[图7.6](#filepos724431)所示）。
- en: Figure 7.6\. Passing a ConfigMap entry as an environment variable to a container
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6\. 将ConfigMap条目作为环境变量传递给容器
- en: '![](images/00180.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00180.jpg)'
- en: Referencing non-existing ConfigMaps in a pod
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod中引用不存在的ConfigMap
- en: You might wonder what happens if the referenced ConfigMap doesn’t exist when
    you create the pod. Kubernetes schedules the pod normally and tries to run its
    containers. The container referencing the non-existing ConfigMap will fail to
    start, but the other container will start normally. If you then create the missing
    ConfigMap, the failed container is started without requiring you to recreate the
    pod.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，当您创建 pod 时，如果引用的 ConfigMap 不存在会发生什么。Kubernetes 会正常调度 pod 并尝试运行其容器。引用不存在
    ConfigMap 的容器将无法启动，但其他容器将正常启动。如果您随后创建了缺失的 ConfigMap，失败的容器将启动，而无需您重新创建 pod。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also mark a reference to a ConfigMap as optional (by setting `configMapKeyRef.optional:
    true`). In that case, the container starts even if the ConfigMap doesn’t exist.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '您还可以将 ConfigMap 的引用标记为可选（通过设置 `configMapKeyRef.optional: true`）。在这种情况下，即使 ConfigMap
    不存在，容器也会启动。'
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This example shows you how to decouple the configuration from the pod specification.
    This allows you to keep all the configuration options closely together (even for
    multiple pods) instead of having them splattered around the pod definition (or
    duplicated across multiple pod manifests).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何将配置与 pod 规范解耦。这允许您将所有配置选项紧密地放在一起（即使对于多个 pod），而不是让它们散布在 pod 定义中（或在多个
    pod 清单中重复）。
- en: 7.4.4\. Passing all entries of a ConfigMap as environment variables at once
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.4\. 一次性将 ConfigMap 的所有条目作为环境变量传递
- en: When your ConfigMap contains more than just a few entries, it becomes tedious
    and error-prone to create environment variables from each entry individually.
    Luckily, Kubernetes version 1.6 provides a way to expose all entries of a ConfigMap
    as environment variables.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的 ConfigMap 包含的条目不止几个时，从每个条目单独创建环境变量变得既繁琐又容易出错。幸运的是，Kubernetes 版本 1.6 提供了一种方法，可以将
    ConfigMap 的所有条目作为环境变量暴露。
- en: Imagine having a ConfigMap with three keys called `FOO`, `BAR`, and `FOO-BAR`.
    You can expose them all as environment variables by using the `envFrom` attribute,
    instead of `env` the way you did in previous examples. The following listing shows
    an example.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有一个名为 `FOO`、`BAR` 和 `FOO-BAR` 的三个键的 ConfigMap。您可以通过使用 `envFrom` 属性将它们全部暴露为环境变量，而不是像之前示例中那样使用
    `env`。以下列表显示了一个示例。
- en: Listing 7.10\. Pod with env vars from all entries of a ConfigMap
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10\. 包含 ConfigMap 所有条目的 env 变量的 Pod
- en: '`spec:   containers:   - image: some-image` `envFrom:``1` `- prefix: CONFIG_`
    `2` `configMapRef:` `3` `name: my-config-map` `3` `...`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec:    containers:    - image: some-image` `envFrom:` `- prefix: CONFIG_`
    `1` `configMapRef:` `2` `name: my-config-map` `2` `...`'
- en: 1 Using envFrom instead of env
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 使用 envFrom 而不是 env
- en: 2 All environment variables will be prefixed with CONFIG_.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 所有环境变量都将带有前缀 CONFIG_。
- en: 3 Referencing the ConfigMap called my-config-map
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 引用名为 my-config-map 的 ConfigMap
- en: 'As you can see, you can also specify a prefix for the environment variables
    (`CONFIG_` in this case). This results in the following two environment variables
    being present inside the container: `CONFIG_FOO` and `CONFIG_BAR`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您还可以为环境变量指定一个前缀（在这种情况下为 `CONFIG_`）。这导致以下两个环境变量存在于容器内部：`CONFIG_FOO` 和 `CONFIG_BAR`。
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The prefix is optional, so if you omit it the environment variables will have
    the same name as the keys.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀是可选的，所以如果您省略它，环境变量将与键具有相同的名称。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Did you notice I said two variables, but earlier, I said the ConfigMap has three
    entries (`FOO`, `BAR`, and `FOO-BAR`)? Why is there no environment variable for
    the `FOO-BAR` ConfigMap entry?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我说了两个变量，但之前我说 ConfigMap 有三个条目（`FOO`、`BAR` 和 `FOO-BAR`）吗？为什么没有 `FOO-BAR`
    ConfigMap 条目的环境变量？
- en: The reason is that `CONFIG_FOO-BAR` isn’t a valid environment variable name
    because it contains a dash. Kubernetes doesn’t convert the keys in any way (it
    doesn’t convert dashes to underscores, for example). If a ConfigMap key isn’t
    in the proper format, it skips the entry (but it does record an event informing
    you it skipped it).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 `CONFIG_FOO-BAR` 不是一个有效的环境变量名称，因为它包含一个连字符。Kubernetes 不会以任何方式转换键（例如，它不会将连字符转换为下划线）。如果
    ConfigMap 键不是正确的格式，它会跳过该条目（但它会记录一个事件通知您它跳过了它）。
- en: 7.4.5\. Passing a ConfigMap entry as a command-line argument
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.5\. 将 ConfigMap 条目作为命令行参数传递
- en: Now, let’s also look at how to pass values from a ConfigMap as arguments to
    the main process running in the container. You can’t reference ConfigMap entries
    directly in the `pod.spec.containers.args` field, but you can first initialize
    an environment variable from the ConfigMap entry and then refer to the variable
    inside the arguments as shown in [figure 7.7](#filepos729564).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也看看如何将ConfigMap的值作为参数传递给容器中运行的主进程。你无法直接在`pod.spec.containers.args`字段中引用ConfigMap条目，但你可以首先从ConfigMap条目初始化一个环境变量，然后像[图7.7](#filepos729564)中所示的那样在参数中引用该变量。
- en: Figure 7.7\. Passing a ConfigMap entry as a command-line argument
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7\. 将ConfigMap条目作为命令行参数传递
- en: '![](images/00002.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00002.jpg)'
- en: '[Listing 7.11](#filepos729918) shows an example of how to do this in the YAML.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.11](#filepos729918)展示了如何在YAML中完成这个例子。'
- en: 'Listing 7.11\. Using ConfigMap entries as arguments: fortune-pod-args-configmap.yaml'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11\. 使用ConfigMap条目作为参数：fortune-pod-args-configmap.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: fortune-args-from-configmap spec:
      containers:   - image: luksa/fortune:args` `1` `env:` `2` `- name: INTERVAL`
    `2` `valueFrom:` `2` `configMapKeyRef:` `2` `name: fortune-config` `2` `key: sleep-interval`
    `2` `args: ["$(INTERVAL)"]` `3` `...`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: fortune-args-from-configmap spec:  
    containers:   - image: luksa/fortune:args` `1` `env:` `2` `- name: INTERVAL` `2`
    `valueFrom:` `2` `configMapKeyRef:` `2` `name: fortune-config` `2` `key: sleep-interval`
    `2` `args: ["$(INTERVAL)"]` `3` `...`'
- en: 1 Using the image that takes the interval from the first argument, not from
    an environment variable
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 使用从第一个参数而不是从环境变量获取间隔的镜像
- en: 2 Defining the environment variable exactly as before
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 正如之前定义环境变量一样
- en: 3 Referencing the environment variable in the argument
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 在参数中引用环境变量
- en: You defined the environment variable exactly as you did before, but then you
    used the `$(ENV_VARIABLE_NAME)` syntax to have Kubernetes inject the value of
    the variable into the argument.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义环境变量的方式与之前完全相同，但之后你使用了`$(ENV_VARIABLE_NAME)`语法来让Kubernetes将变量的值注入到参数中。
- en: 7.4.6\. Using a configMap volume to expose ConfigMap entries as files
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.6\. 使用configMap卷将ConfigMap条目作为文件暴露
- en: Passing configuration options as environment variables or command-line arguments
    is usually used for short variable values. A ConfigMap, as you’ve seen, can also
    contain whole config files. When you want to expose those to the container, you
    can use one of the special volume types I mentioned in the previous chapter, namely
    a `configMap` volume.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置选项作为环境变量或命令行参数传递通常用于短变量值。正如你所见，ConfigMap也可以包含整个配置文件。当你想要将这些暴露给容器时，你可以使用我在上一章中提到的特殊卷类型之一，即`configMap`卷。
- en: A `configMap` volume will expose each entry of the ConfigMap as a file. The
    process running in the container can obtain the entry’s value by reading the contents
    of the file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`configMap`卷将ConfigMap的每个条目都暴露为一个文件。容器中运行的进程可以通过读取文件的 内容来获取条目的值。'
- en: Although this method is mostly meant for passing large config files to the container,
    nothing prevents you from passing short single values this way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法主要用于将大型配置文件传递到容器中，但没有任何东西阻止你以这种方式传递短的单个值。
- en: Creating the ConfigMap
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ConfigMap
- en: Instead of modifying your fortuneloop.sh script once again, you’ll now try a
    different example. You’ll use a config file to configure the Nginx web server
    running inside the `fortune` pod’s web-server container. Let’s say you want your
    Nginx server to compress responses it sends to the client. To enable compression,
    the config file for Nginx needs to look like the following listing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 代替再次修改你的`fortuneloop.sh`脚本，你现在将尝试一个不同的例子。你将使用一个配置文件来配置运行在`fortune` pod的web-server容器内的Nginx
    web服务器。假设你希望你的Nginx服务器压缩它发送给客户端的响应。为了启用压缩，Nginx的配置文件需要看起来像以下列表。
- en: 'Listing 7.12\. An Nginx config with enabled gzip compression: my-nginx-config.conf'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.12\. 启用gzip压缩的Nginx配置：my-nginx-config.conf
- en: '`server {   listen              80;   server_name         www.kubia-example.com;   
    gzip on;` `1` `gzip_types text/plain application/xml;` `1` `location / {     root  
    /usr/share/nginx/html;     index  index.html index.htm;   } }`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`server {   listen              80;   server_name         www.kubia-example.com;   
    gzip on;` `1` `gzip_types text/plain application/xml;` `1` `location / {      
    root   /usr/share/nginx/html;       index  index.html index.htm;   } }`'
- en: 1 This enables gzip compression for plain text and XML files.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这将启用纯文本和XML文件的gzip压缩。
- en: Now delete your existing `fortune-config` ConfigMap with `kubectl delete configmap
    fortune-config`, so that you can replace it with a new one, which will include
    the Nginx config file. You’ll create the ConfigMap from files stored on your local
    disk.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在删除现有的 `fortune-config` ConfigMap，使用 `kubectl delete configmap fortune-config`，以便你可以用包含
    Nginx 配置文件的新一个替换它。你将从存储在本地磁盘上的文件创建 ConfigMap。
- en: Create a new directory called configmap-files and store the Nginx config from
    the previous listing into configmap-files/my-nginx-config.conf. To make the ConfigMap
    also contain the `sleep-interval` entry, add a plain text file called sleep-interval
    to the same directory and store the number 25 in it (see [figure 7.8](#filepos734707)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 configmap-files 的新目录，并将前一个列表中的 Nginx 配置存储到 configmap-files/my-nginx-config.conf
    中。为了使 ConfigMap 也包含 `sleep-interval` 条目，在同一个目录中添加一个名为 sleep-interval 的纯文本文件，并在其中存储数字
    25（参见[图 7.8](#filepos734707)）。
- en: Figure 7.8\. The contents of the configmap-files directory and its files
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8. configmap-files 目录及其文件的内容
- en: '![](images/00020.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00020.jpg)'
- en: 'Now create a ConfigMap from all the files in the directory like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个 ConfigMap，如下所示：
- en: '`$ kubectl create configmap fortune-config --from-file=configmap-files` `configmap
    "fortune-config" created`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create configmap fortune-config --from-file=configmap-files` `configmap
    "fortune-config" created`'
- en: The following listing shows what the YAML of this ConfigMap looks like.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了此 ConfigMap 的 YAML 格式。
- en: Listing 7.13\. YAML definition of a config map created from a file
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13. 从文件创建的 ConfigMap 的 YAML 定义
- en: '`$ kubectl get configmap fortune-config -o yaml` `apiVersion: v1 data:   my-nginx-config.conf:
    |` `1` `server {` `1` `listen              80;` `1` `server_name         www.kubia-example.com;`
    `1` `gzip on;` `1` `gzip_types text/plain application/xml;` `1` `location / {`
    `1` `root   /usr/share/nginx/html;` `1` `index  index.html index.htm;` `1` `}`
    `1` `}` `1` `sleep-interval: |` `2` `25` `2` `kind: ConfigMap ...`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get configmap fortune-config -o yaml` `apiVersion: v1 data:   my-nginx-config.conf:
    |` `1` `server {` `1` `listen              80;` `1` `server_name         www.kubia-example.com;`
    `1` `gzip on;` `1` `gzip_types text/plain application/xml;` `1` `location / {`
    `1` `root   /usr/share/nginx/html;` `1` `index  index.html index.htm;` `1` `}`
    `1` `}` `1` `sleep-interval: |` `2` `25` `2` `kind: ConfigMap ...`'
- en: 1 The entry holding the Nginx config file’s contents
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 保存 Nginx 配置文件内容的条目
- en: 2 The sleep-interval entry
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 保存 sleep-interval 条目的条目
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The pipeline character after the colon in the first line of both entries signals
    that a literal multi-line value follows.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个条目的第一行冒号后面的管道字符表示后面跟着一个字面多行值。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The ConfigMap contains two entries, with keys corresponding to the actual names
    of the files they were created from. You’ll now use the ConfigMap in both of your
    pod’s containers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 包含两个条目，其键对应于它们创建的文件的实际名称。你现在将使用 ConfigMap 中的两个容器。
- en: Using the ConfigMap’s entries in a volume
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在卷中使用 ConfigMap 的条目
- en: Creating a volume populated with the contents of a ConfigMap is as easy as creating
    a volume that references the ConfigMap by name and mounting the volume in a container.
    You already learned how to create volumes and mount them, so the only thing left
    to learn is how to initialize the volume with files created from a ConfigMap’s
    entries.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含 ConfigMap 内容的卷与通过名称引用 ConfigMap 并在容器中挂载卷一样简单。你已经学习了如何创建卷和挂载它们，所以剩下要学习的就是如何使用
    ConfigMap 的条目初始化卷。
- en: Nginx reads its config file from /etc/nginx/nginx.conf. The Nginx image already
    contains this file with default configuration options, which you don’t want to
    override, so you don’t want to replace this file as a whole. Luckily, the default
    config file automatically includes all .conf files in the /etc/nginx/conf.d/ subdirectory
    as well, so you should add your config file in there. [Figure 7.9](#filepos739163)
    shows what you want to achieve.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 从 /etc/nginx/nginx.conf 读取其配置文件。Nginx 镜像已经包含了这个文件，并带有默认配置选项，你不希望覆盖这些选项，因此你不想替换整个文件。幸运的是，默认配置文件自动包含
    /etc/nginx/conf.d/ 子目录下的所有 .conf 文件，所以你应该在那里添加你的配置文件。[图 7.9](#filepos739163) 显示了你想要实现的内容。
- en: Figure 7.9\. Passing ConfigMap entries to a pod as files in a volume
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9. 将 ConfigMap 条目作为卷中的文件传递给 pod
- en: '![](images/00041.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00041.jpg)'
- en: The pod descriptor is shown in [listing 7.14](#filepos739596) (the irrelevant
    parts are omitted, but you’ll find the complete file in the code archive).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: pod 描述符在[列表 7.14](#filepos739596)中显示（省略了无关部分，但你可以从代码存档中找到完整的文件）。
- en: 'Listing 7.14\. A pod with ConfigMap entries mounted as files: fortune-pod-configmap-volume.yaml'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14. 将 ConfigMap 条目挂载为文件的 pod：fortune-pod-configmap-volume.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: fortune-configmap-volume spec:
      containers:   - image: nginx:alpine     name: web-server     volumeMounts:    
    ...     - name: config       mountPath: /etc/nginx/conf.d` `1` `readOnly: true
        ...   volumes:   ...   - name: config     configMap:` `2` `name: fortune-config`
    `2` `...`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: fortune-configmap-volume spec:
      containers:   - image: nginx:alpine     name: web-server     volumeMounts:    
    ...     - name: config       mountPath: /etc/nginx/conf.d` `1` `readOnly: true
        ...   volumes:   ...   - name: config     configMap:` `2` `name: fortune-config`
    `2` `...`'
- en: 1 You’re mounting the configMap volume at this location.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你正在将 configMap 卷挂载到这个位置。
- en: 2 The volume refers to your fortune-config ConfigMap.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 该卷指的是你的 fortune-config ConfigMap。
- en: This pod definition includes a volume, which references your `fortune-config`
    Config-Map. You mount the volume into the /etc/nginx/conf.d directory to make
    Nginx use it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pod 定义包括一个卷，它引用了你的 `fortune-config` Config-Map。你将卷挂载到 /etc/nginx/conf.d 目录，以便
    Nginx 使用它。
- en: Verifying Nginx is using the mounted config file
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 Nginx 是否正在使用挂载的配置文件
- en: The web server should now be configured to compress the responses it sends.
    You can verify this by enabling port-forwarding from localhost:8080 to the pod’s
    port 80 and checking the server’s response with `curl`, as shown in the following
    listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Web服务器应该被配置为压缩它发送的响应。你可以通过从 localhost:8080 到 pod 的端口 80 启用端口转发，并使用 `curl`
    检查服务器的响应来验证这一点，如下面的列表所示。
- en: Listing 7.15\. Seeing if nginx responses have compression enabled
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15\. 检查 nginx 响应是否启用了压缩
- en: '`$ kubectl port-forward fortune-configmap-volume 8080:80 &` `Forwarding from
    127.0.0.1:8080 -> 80 Forwarding from [::1]:8080 -> 80` `$ curl -H "Accept-Encoding:
    gzip" -I localhost:8080` `HTTP/1.1 200 OK Server: nginx/1.11.1 Date: Thu, 18 Aug
    2016 11:52:57 GMT Content-Type: text/html Last-Modified: Thu, 18 Aug 2016 11:52:55
    GMT Connection: keep-alive ETag: W/"57b5a197-37" Content-Encoding: gzip` `1`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl port-forward fortune-configmap-volume 8080:80 &` `Forwarding from
    127.0.0.1:8080 -> 80 Forwarding from [::1]:8080 -> 80` `$ curl -H "Accept-Encoding:
    gzip" -I localhost:8080` `HTTP/1.1 200 OK Server: nginx/1.11.1 Date: Thu, 18 Aug
    2016 11:52:57 GMT Content-Type: text/html Last-Modified: Thu, 18 Aug 2016 11:52:55
    GMT Connection: keep-alive ETag: W/"57b5a197-37" Content-Encoding: gzip` `1`'
- en: 1 This shows the response is compressed.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这表明响应已被压缩。
- en: Examining the mounted configMap volume’s contents
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 检查挂载的 configMap 卷的内容
- en: 'The response shows you achieved what you wanted, but let’s look at what’s in
    the /etc/nginx/conf.d directory now:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 响应显示你已经实现了想要的结果，但现在让我们看看 /etc/nginx/conf.d 目录现在有什么：
- en: '`$ kubectl exec fortune-configmap-volume -c web-server ls /etc/nginx/conf.d`
    `my-nginx-config.conf sleep-interval`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec fortune-configmap-volume -c web-server ls /etc/nginx/conf.d`
    `my-nginx-config.conf sleep-interval`'
- en: Both entries from the ConfigMap have been added as files to the directory. The
    `sleep-interval` entry is also included, although it has no business being there,
    because it’s only meant to be used by the `fortuneloop` container. You could create
    two different ConfigMaps and use one to configure the `fortuneloop` container
    and the other one to configure the `web-server` container. But somehow it feels
    wrong to use multiple ConfigMaps to configure containers of the same pod. After
    all, having containers in the same pod implies that the containers are closely
    related and should probably also be configured as a unit.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 中的两个条目已经被添加到目录中。`sleep-interval` 条目也被包括在内，尽管它不应该在那里，因为它仅意味着要由 `fortuneloop`
    容器使用。你可以创建两个不同的 ConfigMap，并使用一个来配置 `fortuneloop` 容器，另一个来配置 `web-server` 容器。但不知何故，使用多个
    ConfigMap 来配置同一 pod 的容器感觉是错误的。毕竟，同一个 pod 中的容器意味着它们紧密相关，可能也应该作为一个单元来配置。
- en: Exposing certain ConfigMap entries in the volume
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在卷中暴露某些 ConfigMap 条目
- en: Luckily, you can populate a `configMap` volume with only part of the ConfigMap’s
    entries—in your case, only the `my-nginx-config.conf` entry. This won’t affect
    the `fortuneloop` container, because you’re passing the `sleep-interval` entry
    to it through an environment variable and not through the volume.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以只使用 ConfigMap 条目的一部分来填充 `configMap` 卷——在你的情况下，只有 `my-nginx-config.conf`
    条目。这不会影响 `fortuneloop` 容器，因为你通过环境变量而不是通过卷将 `sleep-interval` 条目传递给它。
- en: To define which entries should be exposed as files in a `configMap` volume,
    use the volume’s `items` attribute as shown in the following listing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义哪些条目应作为文件在 `configMap` 卷中暴露，请使用卷的 `items` 属性，如下面的列表所示。
- en: 'Listing 7.16\. A pod with a specific ConfigMap entry mounted into a file directory:
    fortune-pod-configmap-volume-with-items.yaml'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.16\. 将特定的 ConfigMap 条目挂载到文件目录中的 pod：fortune-pod-configmap-volume-with-items.yaml
- en: '`volumes:   - name: config     configMap:       name: fortune-config      
    items:` `1` `- key: my-nginx-config.conf` `2` `path: gzip.conf` `3`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes:    - name: config      configMap:        name: fortune-config       
    items:` `1` `- key: my-nginx-config.conf` `2` `path: gzip.conf` `3`'
- en: 1 Selecting which entries to include in the volume by listing them
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 通过列出条目来选择要包含在卷中的条目
- en: 2 You want the entry under this key included.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 你希望包含此键下的条目。
- en: 3 The entry’s value should be stored in this file.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 条目的值应存储在此文件中。
- en: When specifying individual entries, you need to set the filename for each individual
    entry, along with the entry’s key. If you run the pod from the previous listing,
    the /etc/nginx/conf.d directory is kept nice and clean, because it only contains
    the gzip.conf file and nothing else.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定单个条目时，你需要为每个单个条目设置文件名以及条目的键。如果你从上一个列表中运行 pod，/etc/nginx/conf.d 目录将保持整洁，因为它只包含
    gzip.conf 文件，没有其他文件。
- en: Understanding that mounting a directory hides existing files in that directory
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 理解挂载目录会隐藏该目录中的现有文件
- en: There’s one important thing to discuss at this point. In both this and in your
    previous example, you mounted the volume as a directory, which means you’ve hidden
    any files that are stored in the /etc/nginx/conf.d directory in the container
    image itself.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，有一件重要的事情需要讨论。在这两个例子中，你都将卷挂载为目录，这意味着你隐藏了存储在容器镜像中的 /etc/nginx/conf.d 目录中的任何文件。
- en: This is generally what happens in Linux when you mount a filesystem into a nonempty
    directory. The directory then only contains the files from the mounted filesystem,
    whereas the original files in that directory are inaccessible for as long as the
    filesystem is mounted.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是在 Linux 中将文件系统挂载到非空目录时发生的情况。然后该目录只包含挂载的文件系统中的文件，而该目录中原有的文件在文件系统挂载期间无法访问。
- en: In your case, this has no terrible side effects, but imagine mounting a volume
    to the /etc directory, which usually contains many important files. This would
    most likely break the whole container, because all of the original files that
    should be in the /etc directory would no longer be there. If you need to add a
    file to a directory like /etc, you can’t use this method at all.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，这没有严重的副作用，但想象一下将卷挂载到通常包含许多重要文件的 /etc 目录。这很可能会破坏整个容器，因为应该位于 /etc 目录中的所有原始文件将不再存在。如果你需要将文件添加到像
    /etc 这样的目录中，你根本不能使用这种方法。
- en: Mounting individual ConfigMap entries as files without hiding oth- her files
    in the directory
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个 ConfigMap 条目作为文件挂载，而不隐藏目录中的其他文件
- en: Naturally, you’re now wondering how to add individual files from a ConfigMap
    into an existing directory without hiding existing files stored in it. An additional
    `subPath` property on the `volumeMount` allows you to mount either a single file
    or a single directory from the volume instead of mounting the whole volume. Perhaps
    this is easier to explain visually (see [figure 7.10](#filepos747267)).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你现在想知道如何将 ConfigMap 中的单个文件添加到现有目录中，而不会隐藏其中存储的现有文件。`volumeMount` 上的附加 `subPath`
    属性允许你挂载卷中的单个文件或单个目录，而不是挂载整个卷。也许这通过视觉方式更容易解释（见图 7.10）。
- en: Figure 7.10\. Mounting a single file from a volume
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10\. 从卷中挂载单个文件
- en: '![](images/00059.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00059.jpg)'
- en: Say you have a `configMap` volume containing a myconfig.conf file, which you
    want to add to the /etc directory as someconfig.conf. You can use the `subPath`
    property to mount it there without affecting any other files in that directory.
    The relevant part of the pod definition is shown in the following listing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含 myconfig.conf 文件的 `configMap` 卷，你希望将其添加到 /etc 目录中作为 someconfig.conf。你可以使用
    `subPath` 属性将其挂载到那里，而不会影响该目录中的其他任何文件。pod 定义的相应部分如下所示。
- en: Listing 7.17\. A pod with a specific config map entry mounted into a specific
    file
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.17\. 将特定的 ConfigMap 条目挂载到特定文件中的 pod
- en: '`spec:   containers:   - image: some/image     volumeMounts:     - name: myvolume
          mountPath: /etc/someconfig.conf` `1` `subPath: myconfig.conf` `2`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec:    containers:    - image: some/image      volumeMounts:      - name:
    myvolume        mountPath: /etc/someconfig.conf` `1` `subPath: myconfig.conf`
    `2`'
- en: 1 You’re mounting into a file, not a directory.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你正在挂载到文件，而不是目录。
- en: 2 Instead of mounting the whole volume, you’re only mounting the myconfig.conf
    entry.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 你不是挂载整个卷，而是只挂载 myconfig.conf 条目。
- en: The `subPath` property can be used when mounting any kind of volume. Instead
    of mounting the whole volume, you can mount part of it. But this method of mounting
    individual files has a relatively big deficiency related to updating files. You’ll
    learn more about this in the following section, but first, let’s finish talking
    about the initial state of a `configMap` volume by saying a few words about file
    permissions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当挂载任何类型的卷时，可以使用`subPath`属性。您不必挂载整个卷，而是可以挂载其一部分。但是，这种方法挂载单个文件与文件更新相关联的缺点相对较大。您将在下一节中了解更多关于此信息，但首先，让我们通过简要说明文件权限来结束对`configMap`卷初始状态的讨论。
- en: Setting the file permissions for files in a configMap volume
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 设置configMap卷中文件的文件权限
- en: By default, the permissions on all files in a `configMap` volume are set to
    644 (`-rw-r—r--`). You can change this by setting the `defaultMode` property in
    the volume spec, as shown in the following listing.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`configMap`卷中所有文件的权限设置为644（`-rw-r--r--`）。您可以通过在卷规范中设置`defaultMode`属性来更改此设置，如下所示。
- en: 'Listing 7.18\. Setting file permissions: fortune-pod-configmap-volume-defaultMode.yaml'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.18\. 设置文件权限：fortune-pod-configmap-volume-defaultMode.yaml
- en: '`volumes:   - name: config     configMap:       name: fortune-config      
    defaultMode: "6600"` `1`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes:   - name: config   configMap:     name: fortune-config     defaultMode:
    "6600"` `1`'
- en: 1 This sets the permissions for all files to -rw-rw-----.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这将设置所有文件的权限为-rw-rw-----。
- en: Although ConfigMaps should be used for non-sensitive configuration data, you
    may want to make the file readable and writable only to the user and group the
    file is owned by, as the example in the previous listing shows.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ConfigMaps应用于非敏感配置数据，但您可能只想让文件对其所属的用户和组可读和可写，正如前一个示例所示。
- en: 7.4.7\. Updating an app’s config without having to restart the app
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4.7\. 无需重启应用程序即可更新应用程序的配置
- en: We’ve said that one of the drawbacks of using environment variables or command-line
    arguments as a configuration source is the inability to update them while the
    process is running. Using a ConfigMap and exposing it through a volume brings
    the ability to update the configuration without having to recreate the pod or
    even restart the container.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，使用环境变量或命令行参数作为配置源的一个缺点是，在进程运行时无法更新它们。使用ConfigMap并通过卷公开它，可以在不重新创建Pod或甚至重启容器的情况下更新配置。
- en: When you update a ConfigMap, the files in all the volumes referencing it are
    updated. It’s then up to the process to detect that they’ve been changed and reload
    them. But Kubernetes will most likely eventually also support sending a signal
    to the container after updating the files.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当您更新ConfigMap时，所有引用它的卷中的文件都会更新。然后，取决于进程检测到它们已更改并重新加载它们。但Kubernetes最终可能也会支持在更新文件后向容器发送信号。
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Be aware that as I’m writing this, it takes a surprisingly long time for the
    files to be updated after you update the ConfigMap (it can take up to one whole
    minute).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我撰写本文时，在更新ConfigMap后，文件更新所需的时间出奇地长（可能需要整整一分钟）。
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Editing a ConfigMap
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑ConfigMap
- en: 'Let’s see how you can change a ConfigMap and have the process running in the
    pod reload the files exposed in the `configMap` volume. You’ll modify the Nginx
    config file from your previous example and make Nginx use the new config without
    restarting the pod. Try switching gzip compression off by editing the `fortune-config`
    ConfigMap with `kubectl edit`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您如何更改ConfigMap，并让在Pod中运行的进程重新加载`configMap`卷中公开的文件。您将修改之前示例中的Nginx配置文件，并让Nginx使用新的配置而不重启Pod。尝试通过使用`kubectl
    edit`编辑`fortune-config` ConfigMap来关闭gzip压缩：
- en: '`$ kubectl edit configmap fortune-config`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl edit configmap fortune-config`'
- en: 'Once your editor opens, change the `gzip on` line to `gzip off`, save the file,
    and then close the editor. The ConfigMap is then updated, and soon afterward,
    the actual file in the volume is updated as well. You can confirm this by printing
    the contents of the file with `kubectl exec`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的编辑器打开，将`gzip on`行更改为`gzip off`，保存文件，然后关闭编辑器。然后ConfigMap将被更新，不久之后，卷中的实际文件也将更新。您可以通过使用`kubectl
    exec`打印文件的 内容来确认这一点：
- en: '`$ kubectl exec fortune-configmap-volume -c web-server`![](images/00006.jpg)`cat
    /etc/nginx/conf.d/my-nginx-config.conf`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec fortune-configmap-volume -c web-server`![图片 00006](images/00006.jpg)`cat
    /etc/nginx/conf.d/my-nginx-config.conf`'
- en: If you don’t see the update yet, wait a while and try again. It takes a while
    for the files to get updated. Eventually, you’ll see the change in the config
    file, but you’ll find this has no effect on Nginx, because it doesn’t watch the
    files and reload them automatically.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有看到更新，请稍等片刻再试一次。文件更新需要一段时间。最终，你会在配置文件中看到变化，但你可能会发现这并没有对 Nginx 产生影响，因为它不会监视文件并自动重新加载它们。
- en: Signaling Nginx to reload the config
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Nginx 发送信号以重新加载配置
- en: 'Nginx will continue to compress its responses until you tell it to reload its
    config files, which you can do with the following command:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 将继续压缩其响应，直到你告诉它重新加载其配置文件，你可以使用以下命令来完成：
- en: '`$ kubectl exec fortune-configmap-volume -c web-server -- nginx -s reload`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec fortune-configmap-volume -c web-server -- nginx -s reload`'
- en: 'Now, if you try hitting the server again with `curl`, you should see the response
    is no longer compressed (it no longer contains the `Content-Encoding: gzip` header).
    You’ve effectively changed the app’s config without having to restart the container
    or recreate the pod.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，如果你再次使用 `curl` 尝试访问服务器，你应该会看到响应不再被压缩（不再包含 `Content-Encoding: gzip` 标头）。你实际上已经更改了应用的配置，而无需重新启动容器或重新创建
    pod。'
- en: Understanding how the files are updated atomically
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 理解文件是如何原子性地更新的
- en: You may wonder what happens if an app can detect config file changes on its
    own and reloads them before Kubernetes has finished updating all the files in
    the `configMap` volume. Luckily, this can’t happen, because all the files are
    updated atomically, which means all updates occur at once. Kubernetes achieves
    this by using symbolic links. If you list all the files in the mounted `configMap`
    volume, you’ll see something like the following listing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果一个应用能够自己检测配置文件的变化并在 Kubernetes 完成更新 `configMap` 卷中的所有文件之前重新加载它们，会发生什么。幸运的是，这种情况不会发生，因为所有文件都是原子性地更新的，这意味着所有更新都是同时发生的。Kubernetes
    通过使用符号链接来实现这一点。如果你列出挂载的 `configMap` 卷中的所有文件，你会看到如下类似的列表。
- en: Listing 7.19\. Files in a mounted `configMap` volume
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.19\. 挂载的 `configMap` 卷中的文件
- en: '`$ kubectl exec -it fortune-configmap-volume -c web-server -- ls -lA`![](images/00006.jpg)`/etc/nginx/conf.d`
    `total 4 drwxr-xr-x  ... 12:15 ..4984_09_04_12_15_06.865837643 lrwxrwxrwx  ...
    12:15 ..data -> ..4984_09_04_12_15_06.865837643 lrwxrwxrwx  ... 12:15 my-nginx-config.conf
    -> ..data/my-nginx-config.conf lrwxrwxrwx  ... 12:15 sleep-interval -> ..data/sleep-interval`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it fortune-configmap-volume -c web-server -- ls -lA`![](images/00006.jpg)`/etc/nginx/conf.d`
    `total 4 drwxr-xr-x  ... 12:15 ..4984_09_04_12_15_06.865837643 lrwxrwxrwx  ...
    12:15 ..data -> ..4984_09_04_12_15_06.865837643 lrwxrwxrwx  ... 12:15 my-nginx-config.conf
    -> ..data/my-nginx-config.conf lrwxrwxrwx  ... 12:15 sleep-interval -> ..data/sleep-interval`'
- en: As you can see, the files in the mounted `configMap` volume are symbolic links
    pointing to files in the `..data` dir. The `..data` dir is also a symbolic link
    pointing to a directory called `..4984_09_04_something`. When the ConfigMap is
    updated, Kubernetes creates a new directory like this, writes all the files to
    it, and then re-links the `..data` symbolic link to the new directory, effectively
    changing all files at once.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，挂载的 `configMap` 卷中的文件是符号链接，指向 `..data` 目录中的文件。`..data` 目录也是一个符号链接，指向一个名为
    `..4984_09_04_something` 的目录。当 ConfigMap 被更新时，Kubernetes 创建一个这样的新目录，将所有文件写入其中，然后重新链接
    `..data` 符号链接到新目录，从而一次性更改所有文件。
- en: Understanding that files mounted into existing directories don’t get updated
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 理解挂载到现有目录中的文件不会更新
- en: One big caveat relates to updating ConfigMap-backed volumes. If you’ve mounted
    a single file in the container instead of the whole volume, the file will not
    be updated! At least, this is true at the time of writing this chapter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大问题是关于更新由 ConfigMap 支持的卷。如果你在容器中挂载了一个单独的文件而不是整个卷，该文件将不会被更新！至少，在撰写本章时是这样的。
- en: For now, if you need to add an individual file and have it updated when you
    update its source ConfigMap, one workaround is to mount the whole volume into
    a different directory and then create a symbolic link pointing to the file in
    question. The symlink can either be created in the container image itself, or
    you could create the symlink when the container starts.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你需要添加一个单独的文件，并在更新其源 ConfigMap 时更新它，一个解决方案是将整个卷挂载到不同的目录中，然后创建一个指向该文件的符号链接。这个符号链接可以在容器镜像本身中创建，或者你可以在容器启动时创建这个符号链接。
- en: Understanding the consequences of updating a ConfigMap
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 理解更新 ConfigMap 的后果
- en: One of the most important features of containers is their immutability, which
    allows us to be certain that no differences exist between multiple running containers
    created from the same image, so is it wrong to bypass this immutability by modifying
    a ConfigMap used by running containers?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 容器最重要的特性之一是不可变性，这使我们确信从同一镜像创建的多个运行容器之间不存在差异，那么通过修改运行容器使用的ConfigMap来绕过这种不可变性是否正确呢？
- en: The main problem occurs when the app doesn’t support reloading its configuration.
    This results in different running instances being configured differently—those
    pods that are created after the ConfigMap is changed will use the new config,
    whereas the old pods will still use the old one. And this isn’t limited to new
    pods. If a pod’s container is restarted (for whatever reason), the new process
    will also see the new config. Therefore, if the app doesn’t reload its config
    automatically, modifying an existing ConfigMap (while pods are using it) may not
    be a good idea.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题发生在应用程序不支持重新加载其配置时。这导致不同的运行实例配置不同——在ConfigMap更改后创建的Pod将使用新的配置，而旧的Pod仍然使用旧的配置。这并不限于新的Pod。如果Pod的容器重新启动（无论什么原因），新的进程也会看到新的配置。因此，如果应用程序不自动重新加载其配置，修改正在使用的现有ConfigMap（同时Pod正在使用它）可能不是一个好主意。
- en: If the app does support reloading, modifying the ConfigMap usually isn’t such
    a big deal, but you do need to be aware that because files in the ConfigMap volumes
    aren’t updated synchronously across all running instances, the files in individual
    pods may be out of sync for up to a whole minute.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序支持重新加载，修改ConfigMap通常不是什么大问题，但你确实需要意识到，由于ConfigMap卷中的文件不会在所有运行实例之间同步更新，单个Pod中的文件可能最多会有一分钟的同步问题。
- en: 7.5\. Using Secrets to pass sensitive data to containers
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5. 使用秘密将敏感数据传递到容器中
- en: All the information you’ve passed to your containers so far is regular, non-sensitive
    configuration data that doesn’t need to be kept secure. But as we mentioned at
    the start of the chapter, the config usually also includes sensitive information,
    such as credentials and private encryption keys, which need to be kept secure.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止传递给容器的所有信息都是常规的非敏感配置数据，不需要保持安全。但如我们在本章开头提到的，配置通常还包括敏感信息，如凭证和私有加密密钥，这些信息需要保持安全。
- en: 7.5.1\. Introducing Secrets
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5.1. 介绍秘密
- en: To store and distribute such information, Kubernetes provides a separate object
    called a Secret. Secrets are much like ConfigMaps—they’re also maps that hold
    key-value pairs. They can be used the same way as a ConfigMap. You can
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储和分发此类信息，Kubernetes提供了一个名为Secret的单独对象。秘密与ConfigMap非常相似——它们也是包含键值对的映射。它们可以像ConfigMap一样使用。你可以
- en: Pass Secret entries to the container as environment variables
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密条目作为环境变量传递给容器
- en: Expose Secret entries as files in a volume
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密条目作为卷中的文件暴露
- en: Kubernetes helps keep your Secrets safe by making sure each Secret is only distributed
    to the nodes that run the pods that need access to the Secret. Also, on the nodes
    themselves, Secrets are always stored in memory and never written to physical
    storage, which would require wiping the disks after deleting the Secrets from
    them.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes通过确保每个秘密只分发给需要访问秘密的Pod运行的节点来帮助保护你的秘密。此外，在节点本身上，秘密始终存储在内存中，永远不会写入物理存储，这需要在从它们中删除秘密后擦除磁盘。
- en: 'On the master node itself (more specifically in etcd), Secrets used to be stored
    in unencrypted form, which meant the master node needs to be secured to keep the
    sensitive data stored in Secrets secure. This didn’t only include keeping the
    etcd storage secure, but also preventing unauthorized users from using the API
    server, because anyone who can create pods can mount the Secret into the pod and
    gain access to the sensitive data through it. From Kubernetes version 1.7, etcd
    stores Secrets in encrypted form, making the system much more secure. Because
    of this, it’s imperative you properly choose when to use a Secret or a ConfigMap.
    Choosing between them is simple:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在主节点本身（更具体地说在etcd中），秘密以前是以未加密的形式存储的，这意味着需要确保主节点安全，以保持存储在秘密中的敏感数据安全。这不仅包括确保etcd存储安全，还包括防止未经授权的用户使用API服务器，因为任何可以创建Pod的人都可以将秘密挂载到Pod中并通过它访问敏感数据。从Kubernetes版本1.7开始，etcd以加密形式存储秘密，使系统更加安全。正因为如此，正确选择何时使用秘密或ConfigMap至关重要。在它们之间进行选择很简单：
- en: Use a ConfigMap to store non-sensitive, plain configuration data.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ConfigMap来存储非敏感的纯配置数据。
- en: Use a Secret to store any data that is sensitive in nature and needs to be kept
    under key. If a config file includes both sensitive and not-sensitive data, you
    should store the file in a Secret.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥来存储任何本质上是敏感的并且需要保密的数据。如果一个配置文件同时包含敏感和非敏感数据，你应该将文件存储在密钥中。
- en: You already used Secrets in [chapter 5](index_split_046.html#filepos469093),
    when you created a Secret to hold the TLS certificate needed for the Ingress resource.
    Now you’ll explore Secrets in more detail.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[第5章](index_split_046.html#filepos469093)中使用了密钥，当时你创建了一个密钥来存储Ingress资源所需的TLS证书。现在你将更详细地探索密钥。
- en: 7.5.2\. Introducing the default token Secret
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5.2\. 介绍默认令牌密钥
- en: 'You’ll start learning about Secrets by examining a Secret that’s mounted into
    every container you run. You may have noticed it when using `kubectl describe`
    on a pod. The command’s output has always contained something like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过检查每个运行的容器中安装的密钥来开始学习关于密钥的知识。你可能在使用`kubectl describe`命令查看pod时注意到了它。命令的输出始终包含类似以下内容：
- en: '`Volumes:   default-token-cfee9:     Type:       Secret (a volume populated
    by a Secret)     SecretName: default-token-cfee9`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`卷:   default-token-cfee9:   类型:       密钥（由密钥填充的卷）   密钥名称: default-token-cfee9`'
- en: 'Every pod has a `secret` volume attached to it automatically. The volume in
    the previous `kubectl describe` output refers to a Secret called `default-token-cfee9`.
    Because Secrets are resources, you can list them with `kubectl get secrets` and
    find the `default-token` Secret in that list. Let’s see:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 每个pod都会自动附加一个`secret`卷。前面的`kubectl describe`输出中的卷指的是名为`default-token-cfee9`的密钥。因为密钥是资源，你可以使用`kubectl
    get secrets`来列出它们，并在列表中找到`default-token`密钥。让我们看看：
- en: '`$ kubectl get secrets` `NAME                  TYPE                                 
    DATA      AGE default-token-cfee9   kubernetes.io/service-account-token   3        
    39d`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get secrets` `名称                  类型                                 
    数据      年龄 default-token-cfee9   kubernetes.io/service-account-token   3        
    39d`'
- en: You can also use `kubectl describe` to learn a bit more about it, as shown in
    the following listing.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`kubectl describe`来了解更多关于它的信息，如下面的列表所示。
- en: Listing 7.20\. Describing a Secret
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.20\. 描述密钥
- en: '`$ kubectl describe secrets` `Name:        default-token-cfee9 Namespace:  
    default Labels:      <none> Annotations: kubernetes.io/service-account.name=default
                 kubernetes.io/service-account.uid=cc04bb39-b53f-42010af00237 Type:       
    kubernetes.io/service-account-token  Data ==== ca.crt:      1139 bytes` `1` `namespace:  
    7 bytes` `1` `token:       eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...` `1`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl describe secrets` `名称:        default-token-cfee9 名称空间:   default
    标签:      <无> 注解: kubernetes.io/service-account.name=default   kubernetes.io/service-account.uid=cc04bb39-b53f-42010af00237
    类型:        kubernetes.io/service-account-token  数据 ==== ca.crt:      1139 字节`
    `1` `namespace:   7 字节` `1` `token:       eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...`
    `1`'
- en: 1 This secret contains three entries.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此密钥包含三个条目。
- en: You can see that the Secret contains three entries—`ca.crt`, `namespace`, and
    `token`—which represent everything you need to securely talk to the Kubernetes
    API server from within your pods, should you need to do that. Although ideally
    you want your application to be completely Kubernetes-agnostic, when there’s no
    alternative other than to talk to Kubernetes directly, you’ll use the files provided
    through this `secret` volume.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，密钥包含三个条目——`ca.crt`、`namespace`和`token`——这些代表了你从你的pod中安全地与Kubernetes API服务器通信所需的一切。尽管理想情况下你希望你的应用程序完全与Kubernetes无关，但在没有其他选择只能直接与Kubernetes通信的情况下，你将使用通过此`secret`卷提供的文件。
- en: 'The `kubectl describe pod` command shows where the `secret` volume is mounted:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl describe pod`命令显示了`secret`卷的挂载位置：'
- en: '`Mounts:` `/var/run/secrets/kubernetes.io/serviceaccount` `from default-token-cfee9`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`挂载点:` `/var/run/secrets/kubernetes.io/serviceaccount` `来自 default-token-cfee9`'
- en: '|  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the `default-token` Secret is mounted into every container, but
    you can disable that in each pod by setting the `automountService-AccountToken`
    field in the pod spec to `false` or by setting it to `false` on the service account
    the pod is using. (You’ll learn about service accounts later in the book.)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`default-token`密钥会被挂载到每个容器中，但你可以在每个pod的规范中设置`automountService-AccountToken`字段为`false`，或者将服务账户设置为`false`来禁用这一功能。（你将在本书的后面学习到服务账户。）
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To help you visualize where and how the default token Secret is mounted, see
    [figure 7.11](#filepos764600).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你可视化默认令牌密钥在哪里以及如何挂载，请参阅[图7.11](#filepos764600)。
- en: Figure 7.11\. The `default-token` Secret is created automatically and a corresponding
    volume is mounted in each pod automatically.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11\. `default-token` 秘密会自动创建，并且每个 pod 都会自动挂载相应的卷。
- en: '![](images/00079.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00079.jpg)'
- en: 'We’ve said Secrets are like ConfigMaps, so because this Secret contains three
    entries, you can expect to see three files in the directory the `secret` volume
    is mounted into. You can check this easily with `kubectl exec`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过秘密就像 ConfigMaps，所以因为这个秘密包含三个条目，你可以预期在挂载 `secret` 卷的目录中看到三个文件。你可以用 `kubectl
    exec` 轻松检查：
- en: '`$ kubectl exec mypod ls /var/run/secrets/kubernetes.io/serviceaccount/` `ca.crt
    namespace token`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec mypod ls /var/run/secrets/kubernetes.io/serviceaccount/` `ca.crt
    namespace token`'
- en: You’ll see how your app can use these files to access the API server in the
    next chapter.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章中看到你的应用程序如何使用这些文件来访问 API 服务器。
- en: 7.5.3\. Creating a Secret
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5.3\. 创建一个Secret
- en: Now, you’ll create your own little Secret. You’ll improve your fortune-serving
    Nginx container by configuring it to also serve HTTPS traffic. For this, you need
    to create a certificate and a private key. The private key needs to be kept secure,
    so you’ll put it and the certificate into a Secret.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将创建自己的小秘密。你将通过配置 Nginx 容器以也服务 HTTPS 流量来改进你的 fortune-serving Nginx 容器。为此，你需要创建一个证书和私钥。私钥需要保持安全，所以你会将它们和证书放入一个秘密中。
- en: 'First, generate the certificate and private key files (do this on your local
    machine). You can also use the files in the book’s code archive (the cert and
    key files are in the `fortune-https` directory):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成证书和私钥文件（在你的本地机器上执行此操作）。你也可以使用书中的代码存档中的文件（证书和密钥文件位于 `fortune-https` 目录中）：
- en: '`$ openssl genrsa -out https.key 2048``$ openssl req -new -x509 -key https.key
    -out https.cert -days 3650 -subj``/CN=www.kubia-example.com`'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ openssl genrsa -out https.key 2048``$ openssl req -new -x509 -key https.key
    -out https.cert -days 3650 -subj``/CN=www.kubia-example.com`'
- en: 'Now, to help better demonstrate a few things about Secrets, create an additional
    dummy file called foo and make it contain the string `bar`. You’ll understand
    why you need to do this in a moment or two:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地演示关于 Secrets 的几个方面，创建一个额外的名为 foo 的虚拟文件，并使其包含字符串 `bar`。你将在几分钟后理解为什么需要这样做：
- en: '`$ echo bar > foo`'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ echo bar > foo`'
- en: 'Now you can use `kubectl create secret` to create a Secret from the three files:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `kubectl create secret` 从三个文件创建一个秘密：
- en: '`$ kubectl create secret generic fortune-https --from-file=https.key`![](images/00006.jpg)`--from-file=https.cert
    --from-file=foo` `secret "fortune-https" created`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create secret generic fortune-https --from-file=https.key`![](images/00006.jpg)`--from-file=https.cert
    --from-file=foo` `secret "fortune-https" created`'
- en: This isn’t very different from creating ConfigMaps. In this case, you’re creating
    a `generic` Secret called `fortune-https` and including two entries in it (https.key
    with the contents of the https.key file and likewise for the https.cert key/file).
    As you learned earlier, you could also include the whole directory with `--from-file=fortune-https`
    instead of specifying each file individually.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这与创建 ConfigMaps 并没有太大区别。在这种情况下，你正在创建一个名为 `fortune-https` 的 `generic` 秘密，并在其中包含两个条目（https.key
    包含 https.key 文件的内容，同样适用于 https.cert 密钥/文件）。正如你之前所学的，你也可以使用 `--from-file=fortune-https`
    包括整个目录，而不是逐个指定每个文件。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You’re creating a generic Secret, but you could also have created a `tls` Secret
    with the `kubectl create secret tls` command, as you did in [chapter 5](index_split_046.html#filepos469093).
    This would create the Secret with different entry names, though.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在创建一个通用的秘密，但你也可以使用 `kubectl create secret tls` 命令创建一个 `tls` 秘密，就像你在第 5 章（index_split_046.html#filepos469093）中所做的那样。这将创建具有不同条目名称的秘密。
- en: '|  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.5.4\. Comparing ConfigMaps and Secrets
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5.4\. 比较ConfigMaps和Secrets
- en: Secrets and ConfigMaps have a pretty big difference. This is what drove Kubernetes
    developers to create ConfigMaps after Kubernetes had already supported Secrets
    for a while. The following listing shows the YAML of the Secret you created.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets 和 ConfigMaps 有很大的不同。这是 Kubernetes 开发者在 Kubernetes 已经支持 Secrets 一段时间后创建
    ConfigMaps 的原因。以下列表显示了您创建的秘密的 YAML。
- en: Listing 7.21\. A Secret’s YAML definition
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.21\. 秘密的 YAML 定义
- en: '`$ kubectl get secret fortune-https -o yaml` `apiVersion: v1 data:   foo: YmFyCg==
      https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...   https.key:
    LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE... kind: Secret ...`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get secret fortune-https -o yaml` `apiVersion: v1 data:   foo: YmFyCg==
      https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...   https.key:
    LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE... kind: Secret ...`'
- en: Now compare this to the YAML of the ConfigMap you created earlier, which is
    shown in the following listing.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此与前面创建的 ConfigMap 的 YAML 进行比较，如下所示。
- en: Listing 7.22\. A ConfigMap’s YAML definition
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.22\. ConfigMap 的 YAML 定义
- en: '`$ kubectl get configmap fortune-config -o yaml` `apiVersion: v1 data:   my-nginx-config.conf:
    |     server {       ...     }   sleep-interval: |     25 kind: ConfigMap ...`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get configmap fortune-config -o yaml` `apiVersion: v1 data:   my-nginx-config.conf:
    |     server {       ...     }   sleep-interval: |     25 kind: ConfigMap ...`'
- en: Notice the difference? The contents of a Secret’s entries are shown as Base64-encoded
    strings, whereas those of a ConfigMap are shown in clear text. This initially
    made working with Secrets in YAML and JSON manifests a bit more painful, because
    you had to encode and decode them when setting and reading their entries.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到区别了吗？Secret 条目的内容以 Base64 编码的字符串形式显示，而 ConfigMap 的内容以明文形式显示。这最初使得在 YAML 和
    JSON 清单中使用 Secret 有点痛苦，因为你在设置和读取它们的条目时必须进行编码和解码。
- en: Using Secrets for binary data
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Secret 存储二进制数据
- en: The reason for using Base64 encoding is simple. A Secret’s entries can contain
    binary values, not only plain-text. Base64 encoding allows you to include the
    binary data in YAML or JSON, which are both plain-text formats.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Base64 编码的原因很简单。Secret 的条目可以包含二进制值，而不仅仅是纯文本。Base64 编码允许你在 YAML 或 JSON 中包含二进制数据，这两种格式都是纯文本格式。
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use Secrets even for non-sensitive binary data, but be aware that the
    maximum size of a Secret is limited to 1MB.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用 Secret 存储非敏感的二进制数据，但请注意，Secret 的最大大小限制为 1MB。
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Introducing the stringData field
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 stringData 字段
- en: Because not all sensitive data is in binary form, Kubernetes also allows setting
    a Secret’s values through the `stringData` field. The following listing shows
    how it’s used.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因为并非所有敏感数据都是二进制形式，Kubernetes 也允许通过 `stringData` 字段设置 Secret 的值。以下列表显示了如何使用它。
- en: Listing 7.23\. Adding plain text entries to a `Secret` using the `stringData`
    field
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.23\. 使用 `stringData` 字段向 `Secret` 添加纯文本条目
- en: '`kind: Secret apiVersion: v1 stringData:` `1` `foo: plain text` `2` `data:
      https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...   https.key:
    LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind: Secret apiVersion: v1 stringData:` `1` `foo: plain text` `2` `data:
      https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...   https.key:
    LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...`'
- en: 1 The stringData can be used for non-binary Secret data.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 可以使用 `stringData` 来存储非二进制 Secret 数据。
- en: 2 See, “plain text” is not Base64-encoded.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 注意，“纯文本”不是 Base64 编码的。
- en: 'The `stringData` field is write-only (note: write-only, not read-only). It
    can only be used to set values. When you retrieve the Secret’s YAML with `kubectl
    get -o yaml`, the `stringData` field will not be shown. Instead, all entries you
    specified in the `stringData` field (such as the `foo` entry in the previous example)
    will be shown under `data` and will be Base64-encoded like all the other entries.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringData` 字段是只写的（注意：只写，不是只读）。它只能用来设置值。当你使用 `kubectl get -o yaml` 获取 Secret
    的 YAML 时，`stringData` 字段将不会显示。相反，你指定在 `stringData` 字段中的所有条目（如前一个示例中的 `foo` 条目）将显示在
    `data` 下，并且像所有其他条目一样进行 Base64 编码。'
- en: Reading a Secret’s entry in a pod
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pod 中读取 Secret 的条目
- en: When you expose the Secret to a container through a `secret` volume, the value
    of the Secret entry is decoded and written to the file in its actual form (regardless
    if it’s plain text or binary). The same is also true when exposing the Secret
    entry through an environment variable. In both cases, the app doesn’t need to
    decode it, but can read the file’s contents or look up the environment variable
    value and use it directly.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 `secret` 卷将 Secret 暴露给容器时，Secret 条目的值将被解码并以其实际形式写入文件（无论它是纯文本还是二进制）。同样，当通过环境变量暴露
    Secret 条目时也是如此。在这两种情况下，应用程序不需要对其进行解码，可以直接读取文件的正文或查找环境变量的值并直接使用它。
- en: 7.5.5\. Using the Secret in a pod
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5.5\. 在 pod 中使用 Secret
- en: With your fortune-https Secret containing both the cert and key files, all you
    need to do now is configure Nginx to use them.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 fortune-https Secret 包含证书和密钥文件后，你现在需要做的只是配置 Nginx 使用它们。
- en: Modifying the fortune-config ConfigMap to enable HTTPS
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 fortune-config ConfigMap 以启用 HTTPS
- en: 'For this, you need to modify the config file again by editing the ConfigMap:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要再次修改配置文件，通过编辑 ConfigMap：
- en: '`$ kubectl edit configmap fortune-config`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl edit configmap fortune-config`'
- en: After the text editor opens, modify the part that defines the contents of the
    `my-nginx-config.conf` entry so it looks like the following listing.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器打开后，修改定义 `my-nginx-config.conf` 条目内容的部分，使其看起来如下所示。
- en: Listing 7.24\. Modifying the `fortune-config` ConfigMap’s data
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.24\. 修改 `fortune-config` ConfigMap 的数据
- en: '`... data:   my-nginx-config.conf: |     server {       listen             
    80;       listen              443 ssl;       server_name         www.kubia-example.com;
          ssl_certificate     certs/https.cert;` `1` `ssl_certificate_key certs/https.key;`
    `1` `ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;       ssl_ciphers         HIGH:!aNULL:!MD5;       
    location / {         root   /usr/share/nginx/html;         index  index.html index.htm;
          }     }   sleep-interval: | ...`'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`... data: my-nginx-config.conf: | server { listen 80; listen 443 ssl; server_name
    www.kubia-example.com; ssl_certificate certs/https.cert; ssl_certificate_key certs/https.key;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; location /
    { root /usr/share/nginx/html; index index.html index.htm; } } sleep-interval:
    | ...`'
- en: 1 The paths are relative to /etc/nginx.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 路径相对于 /etc/nginx。
- en: This configures the server to read the certificate and key files from /etc/nginx/certs,
    so you’ll need to mount the `secret` volume there.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这配置了服务器从 /etc/nginx/certs 读取证书和密钥文件，因此你需要将 `secret` 卷挂载在那里。
- en: Mounting the fortune-https Secret in a pod
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pod 中挂载 fortune-https Secret
- en: Next, you’ll create a new fortune-https pod and mount the `secret` volume holding
    the certificate and key into the proper location in the `web-server` container,
    as shown in the following listing.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个新的 fortune-https 容器，并将包含证书和密钥的 `secret` 卷挂载到 `web-server` 容器中的正确位置，如下所示。
- en: 'Listing 7.25\. YAML definition of the `fortune-https` pod: fortune-pod-https.yaml'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.25\. `fortune-https` 容器的 YAML 定义：fortune-pod-https.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: fortune-https spec:   containers:
      - image: luksa/fortune:env     name: html-generator     env:     - name: INTERVAL
          valueFrom:         configMapKeyRef:           name: fortune-config          
    key: sleep-interval     volumeMounts:     - name: html       mountPath: /var/htdocs
      - image: nginx:alpine     name: web-server     volumeMounts:     - name: html
          mountPath: /usr/share/nginx/html       readOnly: true     - name: config
          mountPath: /etc/nginx/conf.d       readOnly: true     - name: certs` `1`
    `mountPath: /etc/nginx/certs/` `1` `readOnly: true` `1` `ports:     - containerPort:
    80     - containerPort: 443   volumes:   - name: html     emptyDir: {}   - name:
    config     configMap:       name: fortune-config       items:       - key: my-nginx-config.conf
            path: https.conf   - name: certs` `2` `secret:` `2` `secretName: fortune-https`
    `2`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata: name: fortune-https spec: containers: -
    image: luksa/fortune:env name: html-generator env: - name: INTERVAL valueFrom:
    configMapKeyRef: name: fortune-config key: sleep-interval volumeMounts: - name:
    html mountPath: /var/htdocs - image: nginx:alpine name: web-server volumeMounts:
    - name: html mountPath: /usr/share/nginx/html readOnly: true - name: config mountPath:
    /etc/nginx/conf.d readOnly: true - name: certs mountPath: /etc/nginx/certs readOnly:
    true ports: - containerPort: 80 - containerPort: 443 volumes: - name: html emptyDir:
    {} - name: config configMap: name: fortune-config items: - key: my-nginx-config.conf
    path: https.conf - name: certs secret: secretName: fortune-https'
- en: 1 You configured Nginx to read the cert and key file from /etc/nginx/certs,
    so you need to mount the Secret volume there.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你已配置 Nginx 从 /etc/nginx/certs 读取证书和密钥文件，因此需要将 Secret 卷挂载在那里。
- en: 2 You define the secret volume here, referring to the fortune-https Secret.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 你在这里定义了 secret 卷，引用了 fortune-https Secret。
- en: Much is going on in this pod descriptor, so let me help you visualize it. [Figure
    7.12](#filepos778353) shows the components defined in the YAML. The `default-token`
    Secret, volume, and volume mount, which aren’t part of the YAML, but are added
    to your pod automatically, aren’t shown in the figure.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 pod 描述符中有很多内容，让我帮你可视化它。[图 7.12](#filepos778353) 显示了在 YAML 中定义的组件。`default-token`
    Secret、卷和卷挂载，虽然不是 YAML 的一部分，但会自动添加到你的 pod 中，在图中没有显示。
- en: Figure 7.12\. Combining a ConfigMap and a Secret to run your fortune-https pod
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12\. 结合 ConfigMap 和 Secret 运行 fortune-https pod
- en: '![](images/00097.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00097.jpg)'
- en: '|  |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Like `configMap` volumes, `secret` volumes also support specifying file permissions
    for the files exposed in the volume through the `defaultMode` property.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `configMap` 卷类似，`secret` 卷也支持通过 `defaultMode` 属性指定在卷中暴露的文件的文件权限。
- en: '|  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Testing whether Nginx is using the cert and key from the Secret
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Nginx 是否正在使用 Secret 中的证书和密钥
- en: 'Once the pod is running, you can see if it’s serving HTTPS traffic by opening
    a port-forward tunnel to the pod’s port 443 and using it to send a request to
    the server with `curl`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pod 运行后，你可以通过打开到 pod 的端口 443 的端口转发隧道，并使用 `curl` 向服务器发送请求来查看它是否正在服务 HTTPS 流量：
- en: '`$ kubectl port-forward fortune-https 8443:443 &` `Forwarding from 127.0.0.1:8443
    -> 443 Forwarding from [::1]:8443 -> 443` `$ curl https://localhost:8443 -k`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl port-forward fortune-https 8443:443 &` `转发自 127.0.0.1:8443 -> 443`
    `转发自 [::1]:8443 -> 443` `$ curl https://localhost:8443 -k`'
- en: If you configured the server properly, you should get a response. You can check
    the server’s certificate to see if it matches the one you generated earlier. This
    can also be done with `curl` by turning on verbose logging using the `-v` option,
    as shown in the following listing.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确配置了服务器，您应该会收到响应。您可以通过检查服务器的证书来查看它是否与您之前生成的证书匹配。这也可以通过使用 `-v` 选项打开详细日志记录来使用
    `curl` 完成，如下面的列表所示。
- en: Listing 7.26\. Displaying the server certificate sent by Nginx
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.26\. 显示 Nginx 发送的服务器证书
- en: '`$ curl https://localhost:8443 -k -v` `* About to connect() to localhost port
    8443 (#0) *   Trying ::1... * Connected to localhost (::1) port 8443 (#0) * Initializing
    NSS with certpath: sql:/etc/pki/nssdb * skipping SSL peer certificate verification
    * SSL connection using TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 * Server certificate:
    *   subject: CN=www.kubia-example.com` `1` `*   start date: aug 16 18:43:13 2016
    GMT` `1` `*   expire date: aug 14 18:43:13 2026 GMT` `1` `*   common name: www.kubia-example.com`
    `1` `*   issuer: CN=www.kubia-example.com` `1`'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl https://localhost:8443 -k -v` `* 即将连接()到 localhost 端口 8443 (#0)` `*   尝试
    ::1...` `*   连接到 localhost (::1) 端口 8443 (#0)` `*   使用 certpath: sql:/etc/pki/nssdb
    初始化 NSS` `*   跳过 SSL 证书验证` `*   使用 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 的 SSL
    连接` `*   服务器证书:` `*   *   主题: CN=www.kubia-example.com` `1` `*   *   开始日期: aug
    16 18:43:13 2016 GMT` `1` `*   *   过期日期: aug 14 18:43:13 2026 GMT` `1` `*   *   公共名称:
    www.kubia-example.com` `1` `*   *   发行者: CN=www.kubia-example.com` `1`'
- en: 1 The certificate matches the one you created and stored in the Secret.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 证书与您创建并存储在 Secret 中的证书匹配。
- en: Understanding secret volumes are stored in memory
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Secret 卷存储在内存中
- en: 'You successfully delivered your certificate and private key to your container
    by mounting a `secret` volume in its directory tree at /etc/nginx/certs. The `secret`
    volume uses an in-memory filesystem (tmpfs) for the Secret files. You can see
    this if you list mounts in the container:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过在 /etc/nginx/certs 目录树中挂载 `secret` 卷，成功将证书和私钥传递到容器中。`secret` 卷使用内存文件系统 (tmpfs)
    来存储 Secret 文件。如果您列出容器中的挂载点，您可以看到这一点：
- en: '`$ kubectl exec fortune-https -c web-server -- mount | grep certs` `tmpfs on
    /etc/nginx/certs type` `tmpfs` `(ro,relatime)`'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec fortune-https -c web-server -- mount | grep certs` `tmpfs on
    /etc/nginx/certs type` `tmpfs` `(ro,relatime)`'
- en: Because tmpfs is used, the sensitive data stored in the Secret is never written
    to disk, where it could be compromised.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了 tmpfs，存储在 Secret 中的敏感数据永远不会写入磁盘，这可能会被泄露。
- en: Exposing a Secret’s entries through environment variables
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 通过环境变量暴露 Secret 的条目
- en: Instead of using a volume, you could also have exposed individual entries from
    the `secret` as environment variables, the way you did with the `sleep-interval`
    entry from the ConfigMap. For example, if you wanted to expose the `foo` key from
    your Secret as environment variable `FOO_SECRET`, you’d add the snippet from the
    following listing to the container definition.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用卷之外，您还可以将 `secret` 中的单个条目作为环境变量暴露，就像您处理 ConfigMap 中的 `sleep-interval` 条目那样。例如，如果您想将
    Secret 中的 `foo` 键作为环境变量 `FOO_SECRET` 暴露，您将需要将以下列表中的片段添加到容器定义中。
- en: Listing 7.27\. Exposing a Secret’s entry as an environment variable
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.27\. 将 Secret 的条目作为环境变量暴露
- en: '`env:     - name: FOO_SECRET       valueFrom:` `1` `secretKeyRef:` `1` `name:
    fortune-https` `2` `key: foo` `3`'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`env:   - name: FOO_SECRET     valueFrom:` `1` `secretKeyRef:` `1` `name: fortune-https`
    `2` `key: foo` `3`'
- en: 1 The variable should be set from the entry of a Secret.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 变量应从 Secret 的条目中设置。
- en: 2 The name of the Secret holding the key
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 存有密钥的 Secret 名称
- en: 3 The key of the Secret to expose
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 要暴露的 Secret 的密钥
- en: This is almost exactly like when you set the INTERVAL environment variable,
    except that this time you’re referring to a Secret by using `secretKeyRef` instead
    of `configMapKeyRef`, which is used to refer to a ConfigMap.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与您设置 INTERVAL 环境变量时的情况完全相同，只是这次您使用 `secretKeyRef` 而不是 `configMapKeyRef` 来引用
    Secret，后者用于引用 ConfigMap。
- en: Even though Kubernetes enables you to expose Secrets through environment variables,
    it may not be the best idea to use this feature. Applications usually dump environment
    variables in error reports or even write them to the application log at startup,
    which may unintentionally expose them. Additionally, child processes inherit all
    the environment variables of the parent process, so if your app runs a third-party
    binary, you have no way of knowing what happens with your secret data.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Kubernetes允许你通过环境变量来暴露Secret，但这可能不是最好的主意。应用程序通常会在错误报告中丢弃环境变量，甚至在启动时将它们写入应用程序日志，这可能会无意中暴露它们。此外，子进程继承了父进程的所有环境变量，所以如果你的应用程序运行第三方二进制文件，你无法知道你的秘密数据发生了什么。
- en: '|  |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Think twice before using environment variables to pass your Secrets to your
    container, because they may get exposed inadvertently. To be safe, always use
    `secret` volumes for exposing Secrets.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用环境变量将你的Secret传递给容器之前，请三思，因为它们可能会无意中暴露。为了安全起见，始终使用`secret`卷来暴露Secret。
- en: '|  |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.5.6\. Understanding image pull Secrets
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5.6. 理解镜像拉取Secret
- en: You’ve learned how to pass Secrets to your applications and use the data they
    contain. But sometimes Kubernetes itself requires you to pass credentials to it—for
    example, when you’d like to use images from a private container image registry.
    This is also done through Secrets.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何将Secret传递给你的应用程序并使用它们包含的数据。但有时Kubernetes本身也需要你向它传递凭证——例如，当你想使用私有容器镜像仓库中的镜像时。这也是通过Secret完成的。
- en: Up to now all your container images have been stored on public image registries,
    which don’t require any special credentials to pull images from them. But most
    organizations don’t want their images to be available to everyone and thus use
    a private image registry. When deploying a pod, whose container images reside
    in a private registry, Kubernetes needs to know the credentials required to pull
    the image. Let’s see how to do that.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的所有容器镜像都存储在公共镜像仓库中，这些仓库不需要任何特殊凭证来拉取镜像。但大多数组织都不希望他们的镜像对每个人可用，因此使用私有镜像仓库。当部署一个容器镜像位于私有仓库中的pod时，Kubernetes需要知道拉取镜像所需的凭证。让我们看看如何做到这一点。
- en: Using a private image repository on Docker Hub
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Hub上使用私有镜像仓库
- en: Docker Hub, in addition to public image repositories, also allows you to create
    private repositories. You can mark a repository as private by logging in at [http://hub.docker.com](http://hub.docker.com)
    with your web browser, finding the repository and checking a checkbox.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 除了公共镜像仓库外，Docker Hub还允许你创建私有仓库。你可以通过在浏览器中登录[http://hub.docker.com](http://hub.docker.com)，找到仓库并勾选复选框来标记仓库为私有。
- en: 'To run a pod, which uses an image from the private repository, you need to
    do two things:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行使用私有仓库中镜像的pod，你需要做两件事：
- en: Create a Secret holding the credentials for the Docker registry.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含Docker注册表凭证的Secret。
- en: Reference that Secret in the `imagePullSecrets` field of the pod manifest.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在pod清单的`imagePullSecrets`字段中引用该Secret。
- en: Creating a Secret for authenticating with a Docker registry
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为与Docker注册表进行身份验证创建Secret
- en: 'Creating a Secret holding the credentials for authenticating with a Docker
    registry isn’t that different from creating the generic Secret you created in
    [section 7.5.3](#filepos765532). You use the same `kubectl create secret` command,
    but with a different type and options:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为与Docker注册表进行身份验证创建Secret与你在[第7.5.3节](#filepos765532)中创建的通用Secret没有太大区别。你使用相同的`kubectl
    create secret`命令，但使用不同的类型和选项：
- en: '`$ kubectl create secret docker-registry mydockerhubsecret \``--docker-username=myusername
    --docker-password=mypassword \``--docker-email=my.email@provider.com`'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create secret docker-registry mydockerhubsecret --docker-username=myusername
    --docker-password=mypassword --docker-email=my.email@provider.com`'
- en: Rather than create a `generic` secret, you’re creating a `docker-registry` Secret
    called `mydockerhubsecret`. You’re specifying your Docker Hub username, password,
    and email. If you inspect the contents of the newly created Secret with `kubectl
    describe`, you’ll see that it includes a single entry called `.dockercfg`. This
    is equivalent to the .dockercfg file in your home directory, which is created
    by Docker when you run the `docker login` command.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是创建一个`generic` Secret，而是创建一个名为`mydockerhubsecret`的`docker-registry` Secret。你指定了你的Docker
    Hub用户名、密码和电子邮件。如果你使用`kubectl describe`检查新创建的Secret的内容，你会看到一个名为`.dockercfg`的单个条目。这相当于你家目录中的.dockercfg文件，它是当你运行`docker
    login`命令时Docker创建的。
- en: Using the docker-registry Secret in a pod definition
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在pod定义中使用docker-registry Secret
- en: To have Kubernetes use the Secret when pulling images from your private Docker
    Hub repository, all you need to do is specify the Secret’s name in the pod spec,
    as shown in the following listing.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Kubernetes在从你的私有Docker Hub仓库拉取镜像时使用Secret，你只需要在Pod规范中指定Secret的名称，如下面的列表所示。
- en: 'Listing 7.28\. A pod definition using an image pull Secret: pod-with-private-image.yaml'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.28\. 使用镜像拉取Secret的Pod定义：pod-with-private-image.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: private-pod spec:   imagePullSecrets:`
    `1` `- name: mydockerhubsecret` `1` `containers:   - image: username/private:tag
        name: main`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: private-pod spec:   imagePullSecrets:`
    `1` `- name: mydockerhubsecret` `1` `containers:   - image: username/private:tag
        name: main`'
- en: 1 This enables pulling images from a private image registry.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这使得可以从私有镜像仓库拉取镜像。
- en: In the pod definition in the previous listing, you’re specifying the `mydockerhubsecret`
    Secret as one of the `imagePullSecrets`. I suggest you try this out yourself,
    because it’s likely you’ll deal with private container images soon.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列表中的Pod定义中，你指定了`mydockerhubsecret` Secret作为`imagePullSecrets`之一。我建议你自己尝试一下，因为你很可能很快就会处理私有容器镜像。
- en: Not having to specify image pull Secrets on every pod
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要在每个Pod上指定镜像拉取Secret
- en: Given that people usually run many different pods in their systems, it makes
    you wonder if you need to add the same image pull Secrets to every pod. Luckily,
    that’s not the case. In [chapter 12](index_split_095.html#filepos1145244) you’ll
    learn how image pull Secrets can be added to all your pods automatically if you
    add the Secrets to a ServiceAccount.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到人们通常在系统中运行许多不同的Pod，这让你想知道是否需要将相同的镜像拉取Secret添加到每个Pod中。幸运的是，情况并非如此。在[第12章](index_split_095.html#filepos1145244)中，你将学习如果将Secret添加到ServiceAccount中，如何自动将镜像拉取Secret添加到所有Pod中。
- en: 7.6\. Summary
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 7.6\. 总结
- en: This wraps up this chapter on how to pass configuration data to containers.
    You’ve learned how to
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容总结了如何将配置数据传递给容器。你学习了如何
- en: Override the default command defined in a container image in the pod definition
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pod定义中覆盖容器镜像中定义的默认命令
- en: Pass command-line arguments to the main container process
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令行参数传递给主容器进程
- en: Set environment variables for a container
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器设置环境变量
- en: Decouple configuration from a pod specification and put it into a ConfigMap
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置与Pod规范解耦并将其放入ConfigMap中
- en: Store sensitive data in a Secret and deliver it securely to containers
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Secret中存储敏感数据并将其安全地传递给容器
- en: Create a `docker-registry` Secret and use it to pull images from a private image
    registry
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`docker-registry` Secret并使用它从私有镜像仓库拉取镜像
- en: In the next chapter, you’ll learn how to pass pod and container metadata to
    applications running inside them. You’ll also see how the default token Secret,
    which we learned about in this chapter, is used to talk to the API server from
    within a pod.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何将Pod和容器元数据传递给运行在其内部的程序。你还将看到我们在这章中学到的默认token Secret是如何在Pod内部与API服务器通信的。
