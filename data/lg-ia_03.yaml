- en: 2 Concepts, architecture, and deployment of Fluentd
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Fluentd的概念、架构和部署
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Outlining Fluentd’s architecture and core concepts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述Fluentd的架构和核心概念
- en: Reviewing prerequisites and deployment of Fluentd, Fluent Bit, and Fluent UI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查Fluentd、Fluent Bit和Fluent UI的先决条件和部署
- en: Executing basic configurations of Fluentd and Fluent Bit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Fluentd和Fluent Bit的基本配置
- en: Introducing configuration file structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍配置文件结构
- en: Chapter 1 looked at the theory, industry trends, and use cases that Fluentd
    can help us with. This chapter discusses how Fluentd works, including deploying
    and running the simplest of configurations to implement the traditional developer’s
    “Hello World.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章探讨了Fluentd可以帮助我们的理论、行业趋势和用例。本章讨论了Fluentd的工作方式，包括部署和运行最简单的配置以实现传统开发者的“Hello
    World”。
- en: 2.1 Architecture and core concepts
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 架构和核心概念
- en: When you’re driving a car, it is a lot easier when you have some basic appreciation
    of how the vehicle is powered (e.g., gas, diesel, electric, liquefied petroleum
    gas). The mental models that come with such understanding mean we can learn what
    to expect—whether we can expect to hear the engine rev, whether it’s possible
    for the engine to stall, and how the gears work (if there are any). For the same
    reason, before we start working with Fluentd and Fluent Bit, it is worth investing
    time in understanding how these tools work. Based on this, we should run through
    some of the building blocks of Fluentd that will help with the mental models.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你驾驶汽车时，如果你对车辆的动力方式（例如，汽油、柴油、电力、液化石油气）有一些基本的了解，那么驾驶会容易得多。这种理解带来的心智模型意味着我们可以学习预期什么——我们是否可以预期听到发动机的轰鸣声，发动机是否可能熄火，以及齿轮如何工作（如果有）。同样地，在我们开始使用Fluentd和Fluent
    Bit之前，花时间了解这些工具的工作原理是值得的。基于此，我们应该熟悉Fluentd的一些构建块，这将有助于心智模型的形成。
- en: 2.1.1 The makeup of a log event
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 日志事件的组成
- en: 'Chapter 1 introduced the concept of log events. Understanding how Fluentd defines
    a log event is the most crucial thing in appreciating how Fluentd works, so let’s
    look at its composition. Each log event is managed as a single JSON object comprised
    of three mandatory, nonrepeating elements, as described here and shown in figure
    2.1:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章介绍了日志事件的概念。理解Fluentd如何定义日志事件是欣赏Fluentd工作方式中最关键的事情，因此让我们看看它的组成。每个日志事件都作为一个单独的JSON对象进行管理，该对象由三个必需的、不重复的元素组成，如这里所述并在图2.1中所示：
- en: '*Tag*—Each log event has a tag associated with it. The tags are typically linked
    to the source initially through the configuration but can be subsequently manipulated
    within the configuration. Fluentd can apply conditional operations (routing, filtering,
    etc.) to the log events as necessary by using the tags. When using the HTTP interface,
    the tag can be defined in the call, as we will see.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标签*——每个日志事件都与一个标签相关联。标签通常最初通过配置与源相关联，但可以在配置中进一步操作。Fluentd可以通过使用标签对日志事件应用必要的条件操作（路由、过滤等）。当使用HTTP接口时，标签可以在调用中定义，正如我们将会看到的。'
- en: '*Timestamp* *—*This is derived from the log information or is applied by the
    input plugin. This ensures that the events are kept in series, an essential consideration
    when unifying multiple log sources and potentially trying to understand the sequence
    of events across components. This data is held as nanoseconds from epoch (1 January
    1970 00:00:00 UTC).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间戳*——这来自日志信息或由输入插件应用。这确保了事件按顺序保持，这是统一多个日志源和尝试理解组件之间事件序列时的一个基本考虑因素。这些数据以自纪元（1970年1月1日00:00:00
    UTC）以来的纳秒数存储。'
- en: '*Record*—The record is the core event information after separating out the
    time. This means we can address the log content without worrying about locating
    the timestamp for the event and the tag needed for basic controls, as we’ll see
    later in the book. This provides an immediate benefit; whenever a log event is
    passed in from a Fluentd-aware adaptor, we can avoid initial parsing for the time.
    It is possible to translate the record into further detailed structures to make
    it easier to process. We see how to apply more meaning to the data later in the
    book.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记录*——记录是在分离出时间后的核心事件信息。这意味着我们可以在不担心定位事件的时间戳和基本控制所需的标签的情况下处理日志内容，正如我们在本书后面的内容中将会看到的。这提供了即时的好处；每当从Fluentd感知适配器传入日志事件时，我们可以避免对时间的初始解析。可以将记录转换为更详细的结构，使其更容易处理。我们将在本书后面的内容中看到如何给数据赋予更多意义。'
- en: '![](../Images/CH02_F01_Wilkins.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Wilkins.png)'
- en: Figure 2.1 Makeup of log event
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 日志事件的组成
- en: Once captured, other plugins can then work with the existing tags to modify,
    add, and extend them as necessary. When working with the tags, they can have wildcards
    and other logic applied to them. For example, if we have several separate logs
    associated with one solution (call them subsystems 1, 2, and 3), we could tag
    each log file as App .Subsystem1, App.Subsystem2, and App.Subsystem3\. The processing
    of the logs could then be addressed by using a wildcard (e.g., App.*). We can
    set the filter to be more specific for handling only a specific subsystem’s log
    events (e.g., App.Subsystem2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦捕获，其他插件就可以与现有的标签一起工作，根据需要对其进行修改、添加和扩展。在处理标签时，可以应用通配符和其他逻辑。例如，如果我们有与一个解决方案（称为子系统1、2和3）相关的几个单独的日志（我们可以称它们为子系统1、2和3），我们可以将每个日志文件标记为App.Subsystem1、App.Subsystem2和App.Subsystem3。然后可以通过使用通配符（例如，App.*）来处理日志的处理。我们可以设置过滤器以更具体地处理特定子系统的日志事件（例如，App.Subsystem2）。
- en: 2.1.2 Handling time
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 处理时间
- en: Given the importance of timestamps in the logs, all systems that need to work
    together must report against a common clock/time. In addition, the time must not
    be subject to movements for daylight savings. Without this, every time the clocks
    go back, logs will get out of sync. When clocks are moved forward, the logs will
    see an irregular period of no log events being recorded. This can trigger anomalies
    if any time-based analysis (analysis for event throughput, measurement of meant
    time between errors, watching for heartbeat events, etc.) is performed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到时间戳在日志中的重要性，所有需要协同工作的系统都必须针对一个共同的时钟/时间进行报告。此外，时间不应受夏令时调整的影响。如果没有这一点，每次时钟回拨时，日志就会失去同步。当时钟向前移动时，日志将看到没有记录日志事件的异常期。这可能会触发任何基于时间的分析（例如事件吞吐量分析、错误之间平均时间的测量、监视心跳事件等）的异常。
- en: This consideration is compounded by the fact that systems may be working together
    across multiple time zones. Therefore, all systems need to run against a collectively
    agreed upon time. The typical solution to this is to link systems to Coordinated
    Universal Time (UTC). However, when we need to have millisecond precision on the
    timestamps across multiple servers to ensure correct order, something is required
    to keep them in sync.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统可能跨越多个时区协同工作，这一考虑因素更加复杂。因此，所有系统都需要运行在共同同意的时间上。解决这个问题的典型方法是将系统链接到协调世界时（UTC）。然而，当我们需要在多个服务器上对时间戳有毫秒级的精度以确保正确顺序时，需要某种东西来保持它们同步。
- en: Time synchronization is handled by linking servers to a common time source and
    then using a protocol to request a time to align. This protocol is known as *Network
    Time Protocol* (*NTP*). When configuring a server, it is highly recommended to
    ensure that NTP is configured. Many technologies and service providers offer a
    free standard NTP service to synchronize with. There is a limit to this; the duration
    for the current time to reach different servers can differ by a few milliseconds
    or nanoseconds (depending on the location of the NTP service). This is known as
    *clock* or *time skew*. Despite best efforts, log entries may very occasionally
    appear out of step when aggregating across multiple servers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 时间同步是通过将服务器链接到一个公共时间源，然后使用协议请求时间以进行对齐来处理的。这个协议被称为*网络时间协议*（*NTP*）。在配置服务器时，强烈建议确保NTP已配置。许多技术和服务提供商提供免费的标准NTP服务以进行同步。但这有一个限制；当前时间到达不同服务器的时间可能相差几毫秒或纳秒（取决于NTP服务的位置）。这被称为*时钟*或*时间偏移*。尽管尽了最大努力，但在跨多个服务器聚合时，日志条目偶尔可能会出现不一致的情况。
- en: NTP and clock skew
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: NTP和时钟偏移
- en: More specific detail on NTP and clock skew can be found at [www.ietf.org/rfc/rfc1305.txt](https://www.ietf.org/rfc/rfc1305.txt).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于NTP和时钟偏移的更详细信息可以在[www.ietf.org/rfc/rfc1305.txt](https://www.ietf.org/rfc/rfc1305.txt)找到。
- en: Most operating systems provide an NTP client process (or daemon) that can be
    activated (if not defaulted to be active) and configured to sync with an NTP server.
    The closer the NTP server, the lower the risk of skew.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都提供了一个可以激活（如果默认不是激活状态）并配置为与NTP服务器同步的NTP客户端进程（或守护进程）。NTP服务器越近，时钟偏移的风险就越低。
- en: 2.1.3 Architecture of Fluentd
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 Fluentd的架构
- en: Fluentd’s operations are prescribed by a configuration file (which may include
    other configuration files, but this will be addressed later in the book). The
    configuration file describes how and, in some cases, when a plugin should be applied.
    A good number of plugins are incorporated into the core of Fluentd, so they require
    no additional installation—for example, the tail plugin that operates a bit like
    the Linux `tail -f` command. For those less familiar with Linux/Unix utilities,
    the `tail -f` command provides the means to see on the console what is being added
    to a file as it occurs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd 的操作由一个配置文件指定（该配置文件可能包含其他配置文件，但这一点将在本书的后续部分进行说明）。配置文件描述了何时以及在某些情况下如何应用插件。Fluentd
    的核心中集成了大量插件，因此无需额外安装——例如，类似于 Linux `tail -f` 命令的 tail 插件。对于那些不太熟悉 Linux/Unix 工具的用户，`tail
    -f` 命令提供了在文件被添加时在控制台上查看其内容的手段。
- en: In chapter 1, we introduced the idea of plugins and illustrated them with some
    examples. Before we build on this and examine the types of plugins in more detail,
    we should clarify a point of terminology. If you read the Fluentd documentation,
    it refers to *directives*; these can overlap with plugin types. But the relationship
    between types of plugins and a directive is not one-to-one in nature, as plugins
    can have supporting or helper relationships and therefore not a directive. Later
    in the chapter, as we look at the “Hello World” example, we’ll see the directives
    and plugins, and how Fluentd knows where to pick up a configuration file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 章，我们介绍了插件的概念，并通过一些示例进行了说明。在我们在此基础上进一步探讨并更详细地检查插件类型之前，我们应该明确一个术语问题。如果你阅读
    Fluentd 文档，它提到了 *directives*；这些可以与插件类型重叠。但插件类型与指令之间的关系并非一对一，因为插件可以有支持或辅助关系，因此并非指令。在本章的后续部分，当我们查看“Hello
    World”示例时，我们将看到指令和插件，以及 Fluentd 如何知道从哪里获取配置文件。
- en: 'The following list focuses on the core plugin types and where they map to directives
    we have identified. In addition to this, we have highlighted the more common plugin
    interrelationships:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表侧重于核心插件类型及其与我们所识别的指令的映射。除此之外，我们还突出了更常见的插件互相关系：
- en: '*Input*—In terms of the configuration file, the input plugins will correlate
    to a *source* directive. An input can leverage *parser* plugins that can take
    the raw log text and assert structural meaning. For example, they can extract
    key values from the message text, such as log event classifications needed for
    later processing. Inputs range from files to data stores to direct API integrations.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入*—在配置文件的术语中，输入插件将与 *源* 指令相关联。输入可以利用 *解析器* 插件，这些插件可以从原始日志文本中提取结构化意义。例如，它们可以从消息文本中提取关键值，如后续处理所需的日志事件分类。输入范围从文件到数据存储到直接
    API 集成。'
- en: '*Output* *—*As a type of plugin, these provide us with the means to store (e.g.,
    file, database) or connect to another system (including another Fluentd node)
    to pass on the log events. The output plugin aligns with the *match* directive
    within the configuration file—something that is not obvious at this stage but,
    as we illustrate the use of Fluentd, will become more apparent. The output plugin
    can leverage *formatter*, *filter*, *buffer,* and *service discovery* plugins.
    The more generic input plugins have an equivalent output.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输出* *——*作为插件类型，这些为我们提供了存储（例如，文件、数据库）或连接到另一个系统（包括另一个 Fluentd 节点）以传递日志事件的手段。输出插件与配置文件中的
    *match* 指令相匹配——这一点在此阶段可能并不明显，但当我们展示 Fluentd 的使用时，将会变得更加明显。输出插件可以利用 *格式化器*、*过滤器*、*缓冲区*
    和 *服务发现* 插件。更通用的输入插件有相应的输出。'
- en: '*Buffer* *—*The buffer plugin type focuses on the batching up and temporary
    caching of log events so that the I/O workload can be optimized. This issue will
    be addressed in more depth as we progress through the book.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓冲区* *——*缓冲区插件类型专注于批量收集和临时缓存日志事件，以便优化 I/O 工作量。随着我们继续阅读本书，我们将更深入地探讨这个问题。'
- en: '*Filter* *—*This plugin type applies rules through which we can control where
    log events can go. This plugin is engaged with the *output* plugin.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤器* *——*这种插件类型通过应用规则来控制日志事件可以流向何处。此插件与 *输出* 插件相关联。'
- en: '*Parser* *—*This plugin’s task is to take the log event, extract key values,
    and apply additional needed structure to the captured content. This is key when
    taking content from sources such as log files, which will start effectively as
    a single line of text. This can range from *regex* and *grok* to domain-specific
    logic.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解析器* *—*此插件的任务是从日志事件中提取关键值，并应用到捕获的内容中。当从日志文件等来源获取内容时，这是关键，这些内容将有效作为单行文本开始。这可以从*正则表达式*和*grok*到特定领域的逻辑。'
- en: '*Formatter* *—*When content is output, it needs to be produced so that the
    data can be handled by the consuming component. For example, structure the content
    so it can be consumed by Prometheus or Grafana, which expect specific structures
    or a humanly readable message for PagerDuty. As a result, the formatter plugin
    gets used by the output plugins within the *match* directives.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*格式化器* *—*当内容输出时，需要以数据可以被消费组件处理的方式生成。例如，结构化内容以便Prometheus或Grafana可以消费，它们期望特定的结构或用于PagerDuty的易于阅读的消息。因此，格式化器插件在*match*指令中由输出插件使用。'
- en: '*Storage* *—*As we will see shortly, the performance and efficiency of Fluentd
    is a tradeoff with the way we need to handle log events. Storing log events means
    we can keep the events (often temporarily) until they need to be processed. Temporary
    storage, such as caches, can give us performance gains, but at the risk of losing
    the event in a failure. Some storage options are therefore more durable to mitigate
    such a risk. We will use storage plugins in several different ways throughout
    the book.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储* *—*正如我们很快将看到的，Fluentd的性能和效率是我们处理日志事件的方式的一种权衡。存储日志事件意味着我们可以保留事件（通常是临时性的）直到它们需要被处理。临时存储，如缓存，可以给我们带来性能提升，但存在在故障中丢失事件的风险。因此，一些存储选项因此更具持久性以减轻这种风险。本书中我们将以几种不同的方式使用存储插件。'
- en: '*Service discovery* *—*When this plugin is used, it typically works in tandem
    with the output plugin. Its purpose is to help connect to other Fluentd nodes,
    as we will explore later in the book. This type of plugin addresses how the target
    servers are identified/found within a network, from a list of server IPs in a
    reloadable config to using specific parts of a DNS record.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务发现* *—*当使用此插件时，它通常与输出插件协同工作。其目的是帮助连接到其他Fluentd节点，正如我们将在本书后面探讨的那样。此类插件解决如何在网络中识别/找到目标服务器，从可重载配置中的服务器IP列表到使用DNS记录的特定部分。'
- en: In figure 2.2, we represent the core Fluentd building blocks, along with supporting
    elements that exist to help the extension, adoption, and use of Fluentd. Note
    that the specific plugins implemented in the diagram are only a subset of those
    built in the standard deployment and a fraction of those deployable and used by
    Fluentd. As we progress through the book, all of these building blocks will be
    examined in depth, from configurations to tune the engine to how the plugin base
    provides the foundations for controlling all plugin behavior. But appreciating
    the different blocks and their relationships will help from the outset.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在图2.2中，我们展示了Fluentd的核心构建块，以及存在以帮助扩展、采用和使用Fluentd的支持元素。请注意，图中实现的特定插件只是标准部署中构建的插件的一个子集，以及Fluentd可部署和使用的那些插件的一小部分。随着我们继续阅读本书，所有这些构建块都将被深入探讨，从调整引擎的配置到插件基础如何为控制所有插件行为提供基础。但理解不同的构建块及其关系从一开始就会有所帮助。
- en: '![](../Images/CH02_F02_Wilkins.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Wilkins.png)'
- en: Figure 2.2 View of the Fluentd architecture illustrating the core building blocks
    and optional support resources available depending on your context
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 Fluentd架构视图，展示了核心构建块和根据您的环境可用的可选支持资源
- en: 2.1.4 Fluent configuration execution order
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 Fluent配置执行顺序
- en: '*Log events are consumed only once* within a Fluentd or Fluent Bit instance
    unless Fluentd is told to explicitly copy the log event (using a feature within
    the core of Fluentd, which we will address later in the book). This sequencing
    is illustrated in figure 2.3.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志事件在Fluentd或Fluent Bit实例中仅被消费一次*，除非Fluentd被明确告知复制日志事件（使用Fluentd核心中的功能，我们将在本书后面讨论）。这种排序在图2.3中得到了说明。'
- en: '![](../Images/CH02_F03_Wilkins.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F03_Wilkins.png)'
- en: Figure 2.3 Illustration of order impact in a Fluentd configuration
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 Fluentd配置中顺序影响示意图
- en: '*The order in which operations are defined within a configuration file is significant*.
    The first directive that matches an event will become the consumer unless that
    event is copied. Therefore, as a general practice'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在配置文件中定义操作顺序是重要的*。除非事件被复制，否则第一个匹配事件的指令将成为消费者。因此，作为一个一般实践'
- en: When you want all log events to undergo common operations, define those directives
    early in the configuration, but copy them for later targeted directives.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你希望所有日志事件都执行共同操作时，在配置中尽早定义这些指令，但为后续的定向指令复制它们。
- en: Catch-all directives should be late in the configuration.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符指令应在配置的后期定义。
- en: Targeted directives should precede the catch-all directives[.](https://hub.docker.com/u/fluent)
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标指令应先于通配符指令[。](https://hub.docker.com/u/fluent)
- en: '*Fluentd by default is single-threaded*. This helps to ensure that time series
    is not compromised. Fluentd can be configured to run in a concurrent manner (multiprocess
    rather than threaded) by changing the configuration, and we will look at that
    later in chapter 7\. It does mean that if you create a complex series of log event
    operations, it’s possible that Fluentd cannot process events as fast as they are
    created. This means a bottleneck has been made. There are strategies for avoiding
    this, but this will further complicate the whole process.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fluentd默认是单线程的*。这有助于确保时间序列不受损害。可以通过更改配置将Fluentd配置为并发运行（多进程而不是多线程），我们将在第7章中探讨这一点。这意味着，如果你创建了一系列复杂的日志事件操作，Fluentd可能无法像事件创建那样快速处理事件。这意味着已经形成了瓶颈。有避免这种情况的策略，但这将进一步复杂整个过程。'
- en: Single vs. Multithreaded
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程与多线程
- en: The challenges of multithreading are varied, from coordination overhead when
    more threads are running than processor cores to mutual thread-locks (two threads
    waiting for each other). When it comes to time-series events, keeping things in
    sequence or correcting order is important. If not carefully applied, multithreading
    can create race conditions that may lead to events getting out of sequence. To
    better understand race conditions, an excellent source is [https://devopedia.org/race-condition
    -software.](https://devopedia.org/race-condition-software)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程的挑战多种多样，从运行线程多于处理器核心时的协调开销到互斥线程锁（两个线程互相等待）。当涉及到时间序列事件时，保持顺序或纠正顺序是很重要的。如果不小心应用，多线程可能会创建可能导致事件顺序错乱的竞争条件。为了更好地理解竞争条件，一个很好的资源是[https://devopedia.org/race-condition-software
    -软件竞争条件](https://devopedia.org/race-condition-software)。
- en: 2.1.5 Directives
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 指令
- en: Previously, we mentioned directives within Fluentd, and it is easy to mix up
    directives and plugins. Directives provide a framework for grouping plugins to
    achieve a logical task, such as outputting log events to a destination. You’ll
    see that directives are declared in the same way as XML elements by being started
    and ended with angle brackets. It is possible to supply attributes within the
    element, such as tag filtering, as is the case with of the `match` example. Within
    the directive, we then identify the plugin and supply its configuration as name-value
    pairs. As we get to more sophisticated examples, you’ll see that we can nest things,
    including helper plugins.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到了Fluentd中的指令，很容易混淆指令和插件。指令提供了一个框架，用于将插件分组以实现逻辑任务，例如将日志事件输出到目的地。你会看到指令的声明方式与XML元素相同，通过使用尖括号开始和结束。在元素内，可以提供属性，例如标签过滤，就像`match`示例那样。在指令中，我们随后识别插件并以其名称-值对的形式提供其配置。随着我们接触到更复杂的示例，你会看到我们可以嵌套事物，包括辅助插件。
- en: If a command or plugin must be called directly by the logic that makes Fluentd
    process a stream of log events, then it is a directive. While this is very abstract
    at this stage, the idea and subtlety will become more apparent as we progress
    through the book and its examples. As figure 2.4 illustrates, we can visualize
    the directives, plugins, and helper plugins that appear in configuration files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个命令或插件必须直接由使Fluentd处理日志事件流逻辑调用，那么它就是一个指令。虽然在这个阶段这个概念非常抽象，但随着我们通过本书及其示例的进展，这个想法和微妙之处将变得更加明显。如图2.4所示，我们可以可视化配置文件中出现的指令、插件和辅助插件。
- en: '![](../Images/CH02_F04_Wilkins.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F04_Wilkins.png)'
- en: Figure 2.4 Relationships between Fluentd directives in the context of Fluentd’s
    execution order (central column—Source, Filter, Match) and native plugins (parser,
    buffer, formatter)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 在Fluentd执行顺序的上下文中，Fluentd指令（中间列—源、过滤器、匹配）与原生插件（解析器、缓冲区、格式化器）之间的关系
- en: The directives illustrated in figure 2.4 are summarized in table 2.1\. We will
    examine each of these directives in depth in part 2 of this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4中展示的指令总结在表2.1中。我们将在本书的第二部分深入探讨这些指令。
- en: Table 2.1 Fluentd directives
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 Fluentd指令
- en: '| Directive | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| *source* | The source directive tells Fluentd to receive/source log events,
    as we’ve just seen. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| *源* | 源指令告诉Fluentd接收/源日志事件，正如我们刚才看到的。|'
- en: '| *match* | This is about matching log events to other operations, including
    the output of log events. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| *匹配* | 这涉及将日志事件与其他操作匹配，包括日志事件的输出。|'
- en: '| *filter* | This controls which events should be handled by one or more processes—typically
    referred to as a pipeline. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| *过滤器* | 这控制哪些事件应由一个或多个进程处理—通常称为管道。|'
- en: '| *@include* | This tells Fluentd to bring in other configuration files to
    assemble a complete set of operations, just as import or include statements do
    in conventional code. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| *@include* | 这告诉Fluentd引入其他配置文件以组装一组完整的操作，就像传统代码中的导入或包含语句一样。|'
- en: '| *label* | The label provides a grouping mechanism for log events, which provides
    significantly more capability than just using tags. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| *标签* | 标签为日志事件提供了一种分组机制，这比仅使用标签提供了显著更多的功能。|'
- en: '| *system* | This tells Fluentd how to configure and behave internally (e.g.,
    the setting of log levels). |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| *系统* | 这告诉Fluentd如何配置和内部行为（例如，日志级别的设置）。|'
- en: 2.1.6 Putting timing requirements into action
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.6 将时间要求付诸实践
- en: If you want to see how much you have absorbed so far, try answering these questions.
    The answers follow these questions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看自己到目前为止吸收了多少，试着回答这些问题。答案将跟随这些问题。
- en: What are the three key elements of a log event within Fluentd/Fluent Bit?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fluentd/Fluent Bit中日志事件的三个关键元素是什么？
- en: What is the recommended time zone to connect time servers with?
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推荐将时区连接到哪个时间服务器？
- en: Answers
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: We introduced these in section 2.1.1; the elements of a log event are
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在第2.1.1节中介绍了这些内容；日志事件的元素是
- en: '*Timestamp* *—*Representation of the log event occurrence'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间戳* *—*日志事件发生的表示'
- en: '*Record* *—*The body of the log event'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记录* *—*日志事件的主体'
- en: Tag—Associated with each log entry and used to route the log event
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签—与每个日志条目相关联并用于路由日志事件
- en: As you may recall, in section 2.1.2, we recommend linking your NTP servers using
    UTC.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所忆，在第2.1.2节中，我们建议使用UTC链接您的NTP服务器。
- en: 2.2 Deployment of Fluentd
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 Fluentd的部署
- en: In this section, we will deploy Fluentd and tools such as the LogGenerator (sometimes
    referred to as the LogSimulator) to enable us to run the “Hello World” scenario
    and
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将部署Fluentd和LogGenerator（有时称为LogSimulator）等工具，以便我们能够运行“Hello World”场景。
- en: the subsequent examples and exercises. All the configuration files for Fluentd
    and the simulator can be found in the book’s GitHub repository ([http://mng.bz/Axyo](http://mng.bz/Axyo)).
    Within the repository, each chapter has its own set of folders. Note that the
    configuration files in the repository will differ slightly from those shown in
    the configuration examples in the book, so they can include helpful additional
    comments. We assume that the complete code and configuration samples will be downloaded
    either from Manning or via our GitHub repository for the book. Each chapter folder
    contains subfolders for code, configurations, and solutions. The LogGenerator
    (more on this later) has been downloaded from GitHub ([https://github.com/mp3monster/LogGenerator](https://github.com/mp3monster/LogGenerator))
    and copied into the root folder for the chapters (e.g., the root shown in figure
    2.5).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的示例和练习。Fluentd和模拟器的所有配置文件都可以在本书的GitHub仓库中找到（[http://mng.bz/Axyo](http://mng.bz/Axyo)）。在仓库中，每个章节都有自己的文件夹集。请注意，仓库中的配置文件将与书中配置示例中显示的略有不同，因此它们可以包含有用的附加注释。我们假设完整的代码和配置示例将来自Manning或通过我们为本书的GitHub仓库下载。每个章节文件夹包含代码、配置和解决方案的子文件夹。LogGenerator（稍后将详细介绍）已从GitHub下载（[https://github.com/mp3monster/LogGenerator](https://github.com/mp3monster/LogGenerator)）并复制到章节的根文件夹中（例如，图2.5中显示的根文件夹）。
- en: '![](../Images/CH02_F05_Wilkins.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F05_Wilkins.png)'
- en: Figure 2.5 Directory structure used in the book for examples and solutions
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 书中用于示例和解决方案的目录结构
- en: NOTE As Fluentd, Fluent Bit, and the LogSimulator are used throughout the book,
    we have incorporated the instructions within the chapter. In later chapters, where
    we use other utilities and products for one or possibly two chapters, we have
    provided the instructions in appendix A.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于本书中使用了 Fluentd、Fluent Bit 和 LogSimulator，我们已经在章节中包含了相应的指令。在后续章节中，当我们使用其他工具和产品，可能是一章或两章，我们将在附录
    A 中提供指令。
- en: 2.2.1 Deploying Fluentd for the book’s examples
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 为本书示例部署 Fluentd
- en: We already established in chapter 1 that Fluentd and Fluent Bit are both very
    capable when it comes to the means to deploy onto diverse platforms. That creates
    an interesting challenge for this book. Do we describe deploying Fluentd and Fluent
    Bit onto the widest variety of platforms or focus on just one? Do we make you
    work with Docker and bundle everything up in an image?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第 1 章中确立，Fluentd 和 Fluent Bit 在部署到各种平台方面都非常强大。这给本书提出了一个有趣的挑战。我们是描述将 Fluentd
    和 Fluent Bit 部署到最广泛的各种平台，还是只关注其中一种？我们是让你使用 Docker 并将所有内容打包成一个镜像吗？
- en: The approach we took in this book was to support Windows first; this is predicated
    on the fact that in trying, prototyping, and experimenting with Fluentd, you are
    likely using a desktop or laptop computer rather than an enterprise server. Windows
    is the most dominant OS on desktop and laptop machines, so it makes sense to focus
    on that environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本书采取的方法是首先支持 Windows；这是基于这样一个事实，即在尝试、原型设计和实验 Fluentd 的过程中，你很可能会使用台式机或笔记本电脑而不是企业服务器。Windows
    是台式机和笔记本电脑上最占主导地位的操作系统，因此专注于这个环境是有意义的。
- en: However, to make it easier to take the guidance in this book to enterprise servers,
    or if you’re fortunate enough to have a Mac or you’re a committed Linux fan and
    have installed your favorite flavor of Linux OS, we have highlighted differences
    between Linux and Windows. The majority of instructions will include the Linux
    equivalent. Those working with Linux or macOS will most likely know that Linux
    is just the kernel and that the layers above this, such as the UI layer, and installation
    managers differ across the Linux flavors. This means you may need to tweak the
    commands provided to work on your particular flavor of OS.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了让这本书中的指导更容易应用于企业服务器，或者如果你足够幸运拥有 Mac，或者你是一个忠实的 Linux 粉丝并且已经安装了你喜欢的 Linux
    操作系统版本，我们已经突出了 Linux 和 Windows 之间的差异。大多数指令将包括 Linux 的等效指令。那些使用 Linux 或 macOS 的人很可能会知道，Linux
    只是内核，而在此之上的层，例如 UI 层和安装管理器，在 Linux 各版本之间是不同的。这意味着你可能需要调整提供的命令，以便在你的特定操作系统版本上工作。
- en: Docker image
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像
- en: It is possible to also download a prepared Docker image made available via *Docker
    Hub* ([https://hub.docker.com/r/fluent/fluentd/](https://hub.docker.com/r/fluent/fluentd/))
    or directly from the Fluentd GitHub site ([https://github.com/fluent/fluentd-docker-image](https://github.com/fluent/fluentd-docker-image)).
    For production environments, this approach is worth considering and is explored
    further in chapter 8\. In most of the book, utilizing Docker will simply add additional
    effort unless you’re entirely conversant with using Docker.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从 *Docker Hub* ([https://hub.docker.com/r/fluent/fluentd/](https://hub.docker.com/r/fluent/fluentd/))
    或直接从 Fluentd 的 GitHub 网站下载一个准备好的 Docker 镜像 ([https://github.com/fluent/fluentd-docker-image](https://github.com/fluent/fluentd-docker-image))。对于生产环境，这种方法值得考虑，并在第
    8 章中进一步探讨。在本书的大部分内容中，除非你完全熟悉使用 Docker，否则利用 Docker 只会增加额外的努力。
- en: 2.2.2 Deployment considerations for Fluentd
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 Fluentd 的部署注意事项
- en: 'When considering the deployment of Fluentd into production, we need to consider
    *volume metrics*—that is, the amount of log data needing to be captured, filtered,
    routed, and stored. In part 3 of the book, we will focus on the ability of Fluentd
    and Fluent Bit to be scaled out and distributed. But to start with, let us assume
    that we are working in an environment that does not demand such levels of scaling.
    Even in a simple deployment, we should be aware that the computing effort for
    log processing should be less than the computing effort for the core application.
    Remember, each time log events are stored or transmitted, the operation generates
    a lot of I/O activity, which carries a computational overhead. If you are familiar
    with low-level computer operations, you will appreciate that every process comes
    with an overhead:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑将Fluentd部署到生产环境时，我们需要考虑*体积指标*——也就是说，需要捕获、过滤、路由和存储的日志数据量。在本书的第三部分，我们将关注Fluentd和Fluent
    Bit的可扩展性和分布式能力。但首先，让我们假设我们在一个不需要这种水平扩展的环境中工作。即使在简单的部署中，我们也应该意识到日志处理的计算工作量应该小于核心应用的计算工作量。记住，每次日志事件被存储或传输时，操作都会产生大量的I/O活动，这会带来计算开销。如果你熟悉底层计算机操作，你会欣赏到每个进程都伴随着开销：
- en: Every network message is topped and tailed with routing, verification, and details
    such as the size of the message.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个网络消息都带有路由、验证和诸如消息大小之类的详细信息。
- en: Every file write requires the use of the hardware to locate a chunk of physical
    storage that can be used, record the details of the block of storage used, and
    mechanically position the writing device for physical media.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次文件写入都需要使用硬件来定位一块可用于存储的物理存储空间，记录所使用存储块的详细信息，并机械地将写入设备定位到物理媒体上。
- en: The more we can group log events in a cache and transmit them as a block, the
    more efficient the use of resources is. Like all things in life, there is a tradeoff.
    We cache before writing to storage, which means the data is slower reaching the
    end of the log event processing. The longer data is working through a process,
    the more likely that a power loss or component failure will result in data loss.
    For this chapter, we only need to make sure our environment has enough resources
    to run; considerations of performance versus the risk of data loss aren’t necessary.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能在缓存中分组更多日志事件并将它们作为一个块传输，资源的使用效率就越高。就像生活中的所有事物一样，这里也有一个权衡。我们在写入存储之前进行缓存，这意味着数据到达日志事件处理末尾的速度会变慢。数据在处理过程中停留的时间越长，发生断电或组件故障导致数据丢失的可能性就越大。对于本章，我们只需要确保我们的环境有足够的资源来运行；在性能与数据丢失风险之间的权衡是不必要的。
- en: 2.2.3 Fluentd minimum footprint
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 Fluentd最小占用
- en: Fluentd resource requirements are minimal (see table 2.2) by modern machine
    specs, but are worth noting when dealing with small footprint setups.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd的资源需求在现代机器规格下是最小的（见表2.2），但在处理小尺寸设置时仍值得注意。
- en: Table 2.2 Fluentd minimum hardware footprint
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 Fluentd最小硬件占用
- en: '| RubyInstaller size | 130 MB |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| RubyInstaller大小 | 130 MB |'
- en: '| Ruby installed storage needs (with DevKit) | (80 MB for basic Ruby, plus
    820 MB for the DevKit 1 GB) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Ruby安装存储需求（含DevKit）| (基本Ruby 80 MB，加上DevKit的820 MB，总计1 GB) |'
- en: '| Memory required | ~20 MB |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 内存需求 | ~20 MB |'
- en: '| Fluentd additional storage | 300 KB |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Fluentd额外存储 | 300 KB |'
- en: '| Ruby minimum version | Ruby 2.x (against Fluentd v1.x) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| Ruby最低版本 | Ruby 2.x（针对Fluentd v1.x）|'
- en: 2.2.4 Simple deployment of Ruby
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 Ruby简单部署
- en: To get ready to run Fluentd, we need to first install Ruby. This is best done
    with the latest stable version of Ruby using your operating system’s package framework.
    Links to the different installation packages can be found via [www.ruby-lang.org](https://www.ruby-lang.org).
    For Windows, we do this by going to the Downloads page that has links to the relevant
    artifact. For Windows, we get taken to [https://rubyinstaller.org](https://rubyinstaller.org)
    to retrieve the RubyInstaller. When we get to chapter 8, we will need to do a
    bit of development, so we should install the software development kit (*SDK*)
    version of Ruby (shown as Ruby+DevKit on the website).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备运行Fluentd，我们首先需要安装Ruby。这最好使用操作系统的最新稳定版本的Ruby包框架来完成。不同安装包的链接可以通过[www.ruby-lang.org](https://www.ruby-lang.org)找到。对于Windows，我们通过访问包含相关链接的下载页面来完成此操作。对于Windows，我们会转到[https://rubyinstaller.org](https://rubyinstaller.org)以获取RubyInstaller。当我们进入第8章时，我们需要进行一些开发工作，因此我们应该安装Ruby的软件开发工具包（SDK）版本（在网站上显示为Ruby+DevKit）。
- en: Once downloaded, run the installer; it will then take you through the steps
    to define the preferred location, and it will also ask if you want to install
    Mysys—say yes. Mysys is needed for RubyGems with a low-level C dependency, such
    as plugins interacting with the OS. Several development-related tools, such as
    MinGW, allow Ruby development to use Windows C native libraries. This means we
    should have Mysys, and we recommend taking the complete installation with MinGW
    to support any possible development requirements later.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，运行安装程序；它将引导您定义首选位置，并询问您是否想安装 Mysys——回答是。Mysys 对于具有底层 C 依赖关系的 RubyGems（如与操作系统交互的插件）是必需的。几个与开发相关的工具，如
    MinGW，允许 Ruby 开发使用 Windows 本地库。这意味着我们应该有 Mysys，我们建议使用 MinGW 完整安装来支持未来可能出现的任何开发需求。
- en: NOTE Additional information about DevKit is available in the liveBook version
    of Rails4 in Action by Ryan Bigg, et al. (Manning, 2015) at [http://mng.bz/ZzAR](http://mng.bz/ZzAR).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于 DevKit 的更多信息可在 Ryan Bigg 等人编写的 liveBook 版本的《Rails4实战》（Manning，2015）中找到，网址为
    [http://mng.bz/ZzAR](http://mng.bz/ZzAR)。
- en: The installer should add *Ruby* to the Windows `PATH` environment variable.
    (Appendix A provides details on the `PATH` environment variable.) When checking,
    you need to confirm that the `bin` folder for Ruby is included. If the Ruby directory
    path is not in the `PATH` environment variable, we need to follow the instructions
    in appendix A to add the full Ruby path. Once set, it should be possible to execute
    the command `ruby –version`, and Ruby will display the installed version once
    the path has been amended.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序应将 *Ruby* 添加到 Windows 的 `PATH` 环境变量中。（附录A提供了关于 `PATH` 环境变量的详细信息。）在检查时，您需要确认
    Ruby 的 `bin` 文件夹已被包含。如果 Ruby 目录路径不在 `PATH` 环境变量中，我们需要按照附录A中的说明添加完整的 Ruby 路径。一旦设置好，应该可以执行命令
    `ruby –version`，一旦路径被修改，Ruby 将显示已安装的版本。
- en: NOTE It is worth noting an open source package manager for Windows called Chocolatey
    ([https://chocolatey.org/](https://chocolatey.org/)), which feels more like a
    Linux package manager. Chocolatey can be used as an alternative means to install
    Ruby.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：值得注意的一个名为 Chocolatey 的 Windows 开源软件包管理器（[https://chocolatey.org/](https://chocolatey.org/)），它感觉更像是一个
    Linux 软件包管理器。Chocolatey 可以用作安装 Ruby 的替代方法。
- en: 'For Linux users, all the major Linux OSes have a relevant package manager with
    a recent stable installation—from Homebrew for macOS to apt, yum, pkg, and others.
    When there is an option, as with Windows, it is worth installing everything to
    support the development activities undertaken in chapter 9\. Like Windows, we
    need to confirm the path has been correctly set using the instructions in appendix
    A. We also can verify Ruby using the same command, `ruby –version`. In addition,
    we need to verify whether the package manager has included the RubyGems package
    manager. Check this by running the command `gems help`. This will return the gems
    help information or fail. If this fails, then the following steps are needed (replacing
    `x.y.z` in the next steps with the latest stable version):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 用户，所有主要的 Linux 操作系统都有一个相关的软件包管理器，并安装了最新的稳定版本——从 macOS 的 Homebrew 到
    apt、yum、pkg 等。当有选择时，就像 Windows 一样，安装所有内容以支持第9章中进行的开发活动是值得的。与 Windows 一样，我们需要使用附录A中的说明确认路径已被正确设置。我们还可以使用相同的命令
    `ruby –version` 验证 Ruby。此外，我们需要验证软件包管理器是否已包含 RubyGems 软件包管理器。通过运行命令 `gems help`
    来检查这一点。这将返回 gems 帮助信息或失败。如果失败，则需要以下步骤（在以下步骤中将 `x.y.z` 替换为最新的稳定版本）：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 2.2.5 Simple deployment of Fluentd
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.5 Fluentd 的简单部署
- en: Fluentd can be installed in a variety of different ways. Treasure Data (introduced
    in chapter 1) provides a Windows installer for Fluentd, but it should be noted
    that the installer introduces a prefix of *td* into file and folder names. The
    Treasure Data installer also includes additional plugins not included in the standard
    installer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd 可以通过多种不同的方式进行安装。Treasure Data（在第1章中介绍）为 Fluentd 提供了一个 Windows 安装程序，但需要注意的是，安装程序会在文件和文件夹名称中引入一个
    *td* 前缀。Treasure Data 安装程序还包括了标准安装程序中未包含的额外插件。
- en: 'There is a wealth of ways to install Fluentd and its dependencies with different
    benefits and nuances. We will install Fluentd using RubyGems for the following
    reasons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RubyGems 安装 Fluentd 及其依赖项有丰富的途径，各有其优势和细微差别。我们将使用以下原因使用 RubyGems 安装 Fluentd：
- en: Gems package installer is platform-neutral, so the installation process is the
    same for Linux, Windows, and many other environments.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gems 软件包安装器是平台无关的，因此安装过程对 Linux、Windows 和许多其他环境都是相同的。
- en: Gems are the easiest way to install plugins not included in the core of Fluentd.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gems 是安装 Fluentd 核心未包含的插件的最简单方式。
- en: We have Gems installed (needed to help install Ruby dependencies), so we can
    keep our approach consistent.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已安装 Gems（用于帮助安装 Ruby 依赖项），因此我们可以保持我们的方法一致。
- en: 'To install Fluentd this way, we simply need to run the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式安装 Fluentd，我们只需运行以下命令：
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As long as you have connectivity to [https://rubygems.org/](https://rubygems.org/),
    then relevant Gems, including dependencies, will safely download and install.
    These sites may need to be accessed through a proxy server or a local gems server
    in enterprise environments. The installation can be tested by running the following
    command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您连接到 [https://rubygems.org/](https://rubygems.org/)，相关的 Gems（包括依赖项）就会安全地下载和安装。在企业环境中，这些站点可能需要通过代理服务器或本地
    gems 服务器访问。可以通过运行以下命令来测试安装：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will display the help information for Fluentd. It should also be possible
    to see the Fluentd and other gems installed in the deployment location `lib\ruby\gems\
    2.7.0\gems\` (and the equivalent path for other OSes).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示 Fluentd 的帮助信息。它还应该能够看到在部署位置 `lib\ruby\gems\ 2.7.0\gems\`（以及其他操作系统的等效路径）中安装的
    Fluentd 和其他 gems。
- en: In addition to the core Fluentd, the installation also provides some secondary
    tools, some of which we will use throughout the book. The major tools provided
    are summarized in table 2.3
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心 Fluentd，安装还提供了一些辅助工具，其中一些我们将贯穿整本书使用。主要提供的工具总结在表 2.3 中。
- en: Table 2.3 Fluentd support tools provided with an installation
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 安装时提供的 Fluentd 支持工具
- en: '| Fluentd tool | Tool description |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Fluentd 工具 | 工具描述 |'
- en: '| `fluent-binlog-reader` | Fluentd can create binary log files (giving compression
    and performance benefits)—for example, when file caching. This utility can be
    used to read the file and generate readable content. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `fluent-binlog-reader` | Fluentd 可以创建二进制日志文件（提供压缩和性能优势）——例如，在文件缓存时。此实用工具可用于读取文件并生成可读内容。|'
- en: '| `fluent-ca-generate` | This is a utility for creating basic (self-signed)
    certificates that can be used to encrypt communications between Fluentd/Fluent
    Bit nodes. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `fluent-ca-generate` | 这是一个用于创建基本（自签名）证书的实用工具，可用于加密 Fluentd/Fluent Bit 节点之间的通信。|'
- en: '| `fluent-cat` | The `fluent-cat` tool provides a means to inject a single
    log message into Fluentd; it does require the forward plugin to be configured.
    For example:`echo ''{"message":"hello"}'' &#124; fluent-cat debug.log --host localhost
    --port 24224`This command would send a log event to the local Fluentd instance
    configured to listen on port 24224 using the forward plugin. We can use this to
    help test the routing, filtering, and output steps. But, crucially, it does not
    allow us to check the input plugin configurations (hence the LogSimulator). |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `fluent-cat` | `fluent-cat` 工具提供了一种将单个日志消息注入 Fluentd 的方法；它确实需要配置前向插件。例如：`echo
    ''{"message":"hello"}'' | fluent-cat debug.log --host localhost --port 24224`
    此命令将发送一个日志事件到配置为在端口 24224 上监听的本地 Fluentd 实例，使用前向插件。我们可以使用此功能来帮助测试路由、过滤和输出步骤。但，关键的是，它不允许我们检查输入插件配置（因此需要
    LogSimulator）。|'
- en: '| `fluent-debug` | This is a utility to help with remote debugging, used in
    conjunction with the Ruby tooling. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `fluent-debug` | 这是一个用于远程调试的实用工具，与 Ruby 工具配合使用。|'
- en: '| `fluent-gem` | This is essentially an alias to the Ruby `gem` command, which
    will list all the gems available. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `fluent-gem` | 这实际上是对 Ruby `gem` 命令的别名，它将列出所有可用的 gems。|'
- en: '| `fluent-plugin-config-format` | This provides the means to interrogate a
    plugin to obtain details of the configuration parameters the plugin will support.
    The output could be characterized as a README document. As some plugin implementations
    may support multiple types of plugin (e.g., input and output), it is necessary
    to specify the plugin type. For example (on both Windows and Linux), the command`fluent-plugin-config-format
    -f txt input tail`will retrieve the text format of the tail output plugin’s configuration
    details. This utility is ideal for being included within a continuous integration
    pipeline for custom-built plugins, as it can generate documentation in several
    formats. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `fluent-plugin-config-format` | 这提供了一种查询插件以获取插件将支持的配置参数细节的方法。输出可以被视为一个 README
    文档。由于某些插件实现可能支持多种类型的插件（例如，输入和输出），因此需要指定插件类型。例如（在 Windows 和 Linux 上），命令 `fluent-plugin-config-format
    -f txt input tail` 将检索 tail 输出插件配置细节的文本格式。此实用工具非常适合包含在自定义构建插件的持续集成管道中，因为它可以生成多种格式的文档。|'
- en: '| `fluent-plugin-generate` | This generates a code skeleton for plugin development.
    The template includes a Gem file, README, stubbed Ruby code for the plugin, and
    a skeleton test framework. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `fluent-plugin-generate` | 这为插件开发生成代码框架。模板包括 Gem 文件、README、插件的占位 Ruby 代码和一个骨架测试框架。|'
- en: A couple of OS differences
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 几个操作系统差异
- en: Linux- and Unix-based operating systems support a framework of *interrupt signals*.
    These signals can be sent to an application to control their behavior. Perhaps
    the most commonly known of these is SIGHUP. Fluentd can use these signals to trigger
    operations such as reloading the configuration file without needing to restart.
    Table 2.4 summarizes the essential interrupts and their impact.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Linux 和 Unix 的操作系统支持一个 *中断信号* 的框架。这些信号可以发送到应用程序以控制其行为。其中最广为人知的是 SIGHUP。Fluentd
    可以使用这些信号来触发操作，如重新加载配置文件，而无需重新启动。表 2.4 总结了基本的中断及其影响。
- en: Table 2.4 Linux signals and how Fluentd will react to them
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.4 Linux 信号及其对 Fluentd 的响应
- en: '| Linux signal | Effect on Fluentd |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| Linux 信号 | 对 Fluentd 的影响 |'
- en: '| SIGINT or SIGTERM | This tells Fluentd to gracefully shut down so that it
    clears everything in memory, and any file buffering is left in a clean state.
    If another process is calling Fluentd, it is better to stop that process first,
    as it can prevent the shutdown from completing. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| SIGINT 或 SIGTERM | 这告诉 Fluentd 优雅地关闭，以便清除内存中的所有内容，并将任何文件缓冲区保留在干净的状态。如果另一个进程正在调用
    Fluentd，最好先停止该进程，因为它可以防止关闭操作完成。|'
- en: '| SIGUSR1 | This tells Fluentd to ensure that all of its cached values, including
    its log events, are flushed to storage and then refresh the file handles to the
    file storage. This is then repeated based on a system environment variable called
    flush_interval. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| SIGUSR1 | 这告诉 Fluentd 确保所有缓存的值，包括其日志事件，都被刷新到存储中，然后刷新文件句柄到文件存储。这然后基于一个名为 flush_interval
    的系统环境变量重复进行。|'
- en: '| SIGUSR2 | Secures and gracefully handles the reloading of the configuration.
    It can be considered graceful as it ensures any cache is safely stored before
    reloading the configuration, so no log events are lost. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| SIGUSR2 | 保护和优雅地处理配置的重新加载。它可以被认为是优雅的，因为它确保在重新加载配置之前任何缓存都安全地存储，因此不会丢失任何日志事件。|'
- en: '| SIGHUP | This interrupt is most known for forcing a configuration to reload.
    It performs the same operations as SIGUSR2 but also flushes its internal logs,
    so no internal log information is lost. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| SIGHUP | 这种中断最著名的是强制配置重新加载。它执行与 SIGUSR2 相同的操作，但还会刷新其内部日志，因此不会丢失任何内部日志信息。|'
- en: '| SIGCONT | This signal will get Fluentd to record its internal status—thread
    information, memory allocation, and so on. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| SIGCONT | 此信号将使 Fluentd 记录其内部状态——线程信息、内存分配等。|'
- en: Sending Linux kill commands to a Fluentd process—for example, `kill -s USR1
    3699`, where `3699` represents the process ID for Fluentd—will result in Fluentd
    interpreting the signal as a SIGUSR1 signal. At present, there is no Windows-equivalent
    way to send these signals, although several change requests have been submitted
    to the project for such features.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Fluentd 进程发送 Linux 杀死命令——例如，`kill -s USR1 3699`，其中 `3699` 代表 Fluentd 的进程 ID——将导致
    Fluentd 将该信号解释为 SIGUSR1 信号。目前，没有 Windows 相当的发送这些信号的方法，尽管已经向项目提交了几个更改请求以实现这些功能。
- en: File handles
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 文件句柄
- en: Within a Linux file system, the number of file handles that can be used at any
    one time can be controlled, unlike Windows, which has these limits driven entirely
    by the OS version and architecture (e.g., 32 or 64 bit). Additionally, Linux uses
    file handles for real files, but these handles also represent things like network
    connections. *The default number of file handles can be restrictive for Fluentd*.
    It is not unusual to adjust the number of file handles held open in production
    environments. Manipulating the file-handle limits can be done by editing configuration
    files or using the Linux `ulimit` command. More detail can be found at [https://linuxhint.com/linux_ulimit_command/](https://linuxhint.com/linux_ulimit_command/).
    The number of file handles shouldn’t be a problem for the examples and scenarios
    provided, but when ramping up the volume in a production context, it is something
    to be aware of. The correct number of file handles depends on the number and speed
    of files being written, the number of network ports being supported, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 文件系统中，任何时刻可以使用的文件句柄数量可以控制，与 Windows 不同，Windows 的这些限制完全由操作系统版本和架构（例如，32
    位或 64 位）驱动。此外，Linux 使用文件句柄来表示真实文件，但这些句柄也代表诸如网络连接等事物。*默认的文件句柄数量可能对 Fluentd 来说过于限制性*。在生产环境中调整保持打开的文件句柄数量并不罕见。可以通过编辑配置文件或使用
    Linux 的 `ulimit` 命令来操作文件句柄限制。更多详细信息可以在 [https://linuxhint.com/linux_ulimit_command/](https://linuxhint.com/linux_ulimit_command/)
    找到。文件句柄的数量不应该成为提供的示例和场景的问题，但在生产环境中增加流量时，这是一个需要注意的事项。正确的文件句柄数量取决于正在写入的文件的数量和速度、支持的网络端口的数量等。
- en: 2.2.6 Deploying a log generator
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.6 部署日志生成器
- en: 'Ideally, we want to prove our configuration for input plugins and confirm configuration
    for things like log rotation. We want a configuration-driven utility that can
    continuously send log events. We have one available at [https://github.com/mp3monster/LogGenerator](https://github.com/mp3monster/LogGenerator)
    and will be using this in the subsequent chapters. This tool provides several
    helpful features for us:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望验证输入插件的配置，并确认诸如日志轮转等事物的配置。我们希望有一个配置驱动的实用工具，可以持续发送日志事件。我们有一个可用的工具在
    [https://github.com/mp3monster/LogGenerator](https://github.com/mp3monster/LogGenerator)，将在后续章节中使用这个工具。此工具为我们提供了几个有用的功能：
- en: Take an existing log file, replay the log events from an existing log file,
    write them with current timestamps, and write the logs with the same time intervals
    as the logs had when originally written.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取一个现有的日志文件，从现有的日志文件中回放日志事件，用当前的时间戳写入，并按照日志最初编写时的相同时间间隔写入日志。
- en: Take a test log file that describes the time gap and log body, and play it back
    with the correct intervals between events.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取一个测试日志文件，描述时间间隔和日志正文，并按照事件之间的正确间隔回放。
- en: Write log files based on a pattern, meaning different log formats can be generated.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据模式编写日志文件，这意味着可以生成不同的日志格式。
- en: Send the logs via the Java logging framework to simulate an application using
    a logging framework.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Java 日志框架发送日志以模拟使用日志框架的应用程序。
- en: The LogGenerator GitHub repository includes extended documentation on how the
    tool can be used. The utility is written using Groovy, which means at its heart
    is Java and the use of standard Java classes and libraries. Groovy adds several
    conveniences over Java. Specifically, it executes as a script to keep development
    quick and easy, meaning tweaking it for your own needs is easy; it includes some
    convenience classes that make working with REST and JSON very easy. Not everyone
    wants to install Groovy or modify the script. As a result, we have taken advantage
    of Groovy’s relationship with Java to compile and package it to a JAR file, making
    it possible to be executed without installing Groovy if preferred. The JAR is
    available to download from GitHub as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: LogGenerator GitHub 仓库包含了关于如何使用该工具的扩展文档。该实用工具是用 Groovy 编写的，这意味着其核心是 Java，并且使用了标准的
    Java 类和库。Groovy 相比 Java 增加了一些便利性。具体来说，它作为脚本执行以保持开发快速便捷，这意味着根据您的需求进行调整很容易；它包含了一些方便的类，使得处理
    REST 和 JSON 非常容易。并不是每个人都想安装 Groovy 或修改脚本。因此，我们利用 Groovy 与 Java 的关系，将其编译并打包成 JAR
    文件，使得在没有安装 Groovy 的情况下也可以执行。JAR 文件可以从 GitHub 下载。The JAR is available to download
    from GitHub as well.
- en: Java installation
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Java 安装
- en: To install Java, you can either use a package manager or retrieve and download
    from [www.java.com/en/download/](https://www.java.com/en/download/). The tool’s
    implementation has been done so that Java 8 or later will work. Still, you need
    the Java Development Kit (JDK) rather than the Java Runtime Environment (JRE).
    Once Java is downloaded and installed, you need to ensure that the correct version
    is set up in your `PATH` environment variable and `JAVA_HOME`. We assume that
    you do not have any other applications using Java and are dependent on a different
    Java version. If this is the case, we recommend writing a script to set these
    variables each time you start a new console to run the LogGenerator; this approach
    is illustrated for the Groovy setup. You can check which version of Java is in
    use with the command `java –version`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Java，你可以使用包管理器或从[www.java.com/en/download/](https://www.java.com/en/download/)检索并下载。工具的实现已经完成，以便Java
    8或更高版本可以工作。然而，你需要Java开发工具包（JDK）而不是Java运行时环境（JRE）。一旦Java下载并安装，你需要确保正确的版本已设置在你的`PATH`环境变量和`JAVA_HOME`中。我们假设你没有其他应用程序使用Java，并且依赖于不同的Java版本。如果是这种情况，我们建议编写一个脚本，每次你启动一个新的控制台来运行LogGenerator时设置这些变量；这种方法在Groovy设置中得到了说明。你可以使用命令`java
    –version`来检查正在使用的Java版本。
- en: Groovy installation
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy安装
- en: 'If you want to use the LogSimulator from the prepared JAR, you can skip this
    section, but if you want to use the Groovy version, see how it works, or modify
    it, you’ll need the following steps. With the prerequisite Java installed, we
    can now install Groovy (download from [https://groovy.apache.org/download.html](https://groovy.apache.org/download.html)
    or install it using a package manager). As with Java, you also want Groovy to
    be set on the `PATH` environment variable and `GROOVY_HOME` setup. You can confirm
    whether Groovy is suitably installed using the command `groovy -–version`. The
    following code fragments are example scripts for ensuring environment variables
    are set up. This is the Windows setup:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用已准备好的JAR版本的LogSimulator，你可以跳过这一节，但如果你想要使用Groovy版本，了解其工作方式或对其进行修改，你需要以下步骤。在安装了先决条件Java之后，我们现在可以安装Groovy（从[https://groovy.apache.org/download.html](https://groovy.apache.org/download.html)下载或使用包管理器安装）。与Java一样，你也需要将Groovy设置在`PATH`环境变量和`GROOVY_HOME`中。你可以使用命令`groovy
    -–version`来确认Groovy是否已适当地安装。以下是一些示例代码片段，用于确保环境变量已设置。这是Windows的设置：
- en: '[PRE3]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Linux version of this script would be
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的Linux版本将是
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The simulator uses a properties file to control its behavior and uses a file
    that describes a series of log entries to replay. We will use this in later chapters
    to see how log rotation and other behaviors can work. Each book chapter has a
    folder containing the relevant properties files and log sources to help with that
    chapter, as shown in figure 2.5\. With the LogSimulator copied into the download
    root folder as previously recommended, run this command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器使用一个属性文件来控制其行为，并使用一个描述一系列日志条目的文件来重放。我们将在后面的章节中使用这个文件来查看日志轮转和其他行为是如何工作的。每一本书的章节都有一个包含相关属性文件和日志源的文件夹，以帮助理解该章节，如图2.5所示。按照之前推荐的方式，将LogSimulator复制到下载根文件夹中，然后运行以下命令：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see an example of the console output when running the LogSimulator as
    a Groovy application in figure 2.6.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图2.6中看到一个示例，展示了将LogSimulator作为Groovy应用程序运行时的控制台输出。
- en: '![](../Images/CH02_F06_Wilkins.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F06_Wilkins.png)'
- en: Figure 2.6 LogSimulator example output when in verbose mode, using the HelloWorld-Verbose.properties
    file and Fluentd running with the associated HelloWorld.conf file
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 LogSimulator在详细模式下使用HelloWorld-Verbose.properties文件和与相关HelloWorld.conf文件一起运行的Fluentd的示例输出
- en: Running LogSimulator as a JAR
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将LogSimulator作为JAR运行
- en: To use the JAR version of the LogSimulator, the JAR file needs to be downloaded
    into the parent directory of all the chapter resource folders. Then the command
    can have the Groovy LogSimulator.groovy element replaced with `java -jar LogSimulator
    .jar`, so the command would appear as
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用LogSimulator的JAR版本，需要将JAR文件下载到所有章节资源文件夹的父目录中。然后，可以将命令中的Groovy LogSimulator.groovy元素替换为`java
    -jar LogSimulator .jar`，因此命令将显示为
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will assume you’ve installed Groovy and run the LogGenerator using the Groovy
    command for the rest of the book. But as you can see, the only difference is the
    part of the command that uses Java or Groovy and the JAR or Groovy file. The GitHub
    repository includes all the details on how the JAR file is generated if you wish
    to extend the tool and re-create the jar file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设你已经安装了 Groovy，并使用 Groovy 命令运行 LogGenerator，本书的其余部分将如此进行。但正如你所见，唯一的区别是命令中用于
    Java 或 Groovy 以及 JAR 或 Groovy 文件的那个部分。如果你希望扩展工具并重新创建 jar 文件，GitHub 仓库包含了所有关于如何生成
    JAR 文件的详细信息。
- en: LogSimulator in more detail
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地了解 LogSimulator
- en: If you would like to know what is going on in more depth, then edit the tool.properties
    file and change the `verbose` property from `false` to `true`. This will display
    to the console log entries that are defined in the file small-source.txt. All
    the properties for the simulator are explained in the documentation at [https://github.com/mp3
    monster/LogGenerator](https://github.com/mp3monster/LogGenerator).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解正在发生的事情，那么请编辑 tool.properties 文件，将 `verbose` 属性从 `false` 更改为 `true`。这将显示在控制台日志中定义在文件
    small-source.txt 中的日志条目。关于模拟器的所有属性都在[https://github.com/mp3 monster/LogGenerator](https://github.com/mp3monster/LogGenerator)的文档中解释。
- en: 2.2.7 Installing Postman
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.7 安装 Postman
- en: An easy-to-use tool is needed to send single log events to exercise the Fluentd
    configuration in our “Hello World” scenario. While utilities such as cURL can
    be used, we have elected to use Postman with its friendly UI and ability to work
    across multiple platforms. Postman is a well-known tool that supports most environments
    (Windows, macOS, Linux, etc.). Postman is free for individual use, and the binary
    can be retrieved from [www.postman.com/downloads/](https://www.postman.com/downloads/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“Hello World”场景中，需要一个易于使用的工具来发送单个日志事件以练习 Fluentd 配置。虽然可以使用 cURL 等工具，但我们选择使用具有友好
    UI 和跨多平台工作能力的 Postman。Postman 是一个广为人知的工具，支持大多数环境（Windows、macOS、Linux 等）。Postman
    对个人用户免费，可以从 [www.postman.com/downloads/](https://www.postman.com/downloads/) 获取二进制文件。
- en: For Windows, this is an installer that will resolve the appropriate file locations.
    For Linux, the download is a tarred gzip file that will need to be unpacked (e.g.,
    `tar -xvf Postman-linux-x64-8.6.2.tar.gz`). Once Postman is installed/untarred,
    ensure that it can be started—for Windows, this can be done with the installed
    links.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，这是一个安装程序，将解决适当的文件位置。对于 Linux，下载的是一个 tarred gzip 文件，需要解压缩（例如，`tar
    -xvf Postman-linux-x64-8.6.2.tar.gz`）。一旦 Postman 安装/解压缩完成，请确保它可以启动——对于 Windows，可以使用安装的链接来完成。
- en: 2.3 Bringing Fluentd to life with “Hello World”
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用 “Hello World” 使 Fluentd 生机勃勃
- en: Now that we’ve looked at the architecture of Fluentd and deployed it into an
    environment, let’s bring this to life.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Fluentd 的架构并将其部署到环境中，让我们让它变得生动起来。
- en: 2.3.1 “Hello World” scenario
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 “Hello World” 场景
- en: The “Hello World” scenario is very simple. We will use the fact that Fluentd
    can receive log events through HTTP and simply see the console record the events.
    To start with, we will push the HTTP events using Postman. The next step will
    be to extend this slightly to send log events using the LogSimulator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello World” 场景非常简单。我们将利用 Fluentd 可以通过 HTTP 接收日志事件的事实，简单地查看控制台记录事件。首先，我们将使用
    Postman 推送 HTTP 事件。下一步将是稍微扩展这个操作，使用 LogSimulator 发送日志事件。
- en: 2.3.2 “Hello World” configuration
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 “Hello World” 配置
- en: Before running the example, let us quickly look at the configuration file (see
    listing 2.1). As you can see, we have provided some comments within the configuration
    file. Within a configuration file, we can comment anywhere by leading with a hash
    (#) character. The configuration between `<system>` and `</system>` are instructions
    to Fluentd on how its internals should work; in this case, use `Info`-level logging.
    Then we have used a *source* directive to define the origins of log events using
    the built-in HTTP plugin capability that the `@type` identifies. The following
    name-value pairs are then treated as attributes or properties for that plugin.
    For example, here we have defined the use of `port 18080` to receive log events.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例之前，让我们快速查看配置文件（见列表 2.1）。正如你所见，我们在配置文件中提供了一些注释。在配置文件中，我们可以通过在前面加上哈希（#）字符来在任何地方添加注释。在
    `<system>` 和 `</system>` 之间的配置是 Fluentd 内部应该如何工作的指令；在这种情况下，使用 `Info` 级别日志。然后我们使用一个
    *source* 指令来定义日志事件的来源，使用的是 `@type` 识别的内置 HTTP 插件功能。接下来的名称-值对被视为该插件的属性或属性。例如，在这里我们定义了使用
    `port 18080` 来接收日志事件。
- en: We then define an output using the *match* directive. The asterisk in the *match*
    directive is a wildcard, telling the *match* directive that any tag can be processed
    by the output plugin, in this case, standard out, which will appear in the console.
    The configuration file used in this example is stripped to the bare minimum, defining
    just the input and output parameters for each plugin and a couple of illustrative
    comments.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用*match*指令定义一个输出。在*match*指令中的星号是一个通配符，告诉*match*指令任何标签都可以由输出插件处理，在这种情况下，标准输出，它将出现在控制台上。在这个示例中使用的配置文件被简化到最基本的形式，仅定义了每个插件的输入和输出参数以及一些说明性注释。
- en: Listing 2.1 Chapter2/Fluentd/HelloWorld.conf
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 Chapter2/Fluentd/HelloWorld.conf
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Set the default log level for Fluentd—because we have set the level to info,
    this is not strictly necessary, as that is the default.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置Fluentd的默认日志级别——因为我们已将级别设置为info，这并不是严格必要的，因为那是默认值。
- en: ❷ This is a source directive.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是一个源指令。
- en: ❸ @type indicates the plugin type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ @type表示插件类型。
- en: ❹ Lines following a plugin define configuration parameters for that plugin.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在插件后面的行定义了该插件的配置参数。
- en: ❺ The match directive defines which log events will be allowed into the plugin.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 匹配指令定义了哪些日志事件将被允许进入插件。
- en: 2.3.3 Starting Fluentd
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 启动Fluentd
- en: 'As the Fluentd service is in our `PATH`, we can launch the process with the
    command `fluentd` anywhere. However, the tool will look in different places without
    a parameter defining the config location, depending on the environment and installation
    process. For Windows and Linux, Fluentd will try to resolve the location /etc/fluent/fluent.conf.
    For Windows, this will fail unless the command is run within a Linux subsystem.
    We are not using the default to start Fluentd. We need to navigate the shell to
    wherever you have downloaded the configuration file or include the full path to
    the configuration file as the parameter. Then run the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Fluentd服务在我们的`PATH`中，我们可以在任何地方使用命令`fluentd`启动进程。然而，如果没有参数定义配置位置，工具将根据环境和安装过程在不同的位置查找。对于Windows和Linux，Fluentd将尝试解析位置`/etc/fluent/fluent.conf`。对于Windows，除非在Linux子系统内运行命令，否则这将失败。我们不使用默认设置来启动Fluentd。我们需要在shell中导航到您下载配置文件的位置，或者将配置文件的完整路径作为参数包含在内。然后运行以下命令：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To run the Fluentd command from the root of the downloaded resources, which
    will be the norm for the rest of the book, the command would be
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要从下载资源的根目录运行Fluentd命令，这将是本书余下的标准，命令将是
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command will start Fluentd, and we will see the information displayed on
    the console as things start up, including the configuration being loaded and checked.
    When running Fluentd or Fluent Bit on Windows, depending upon the permissions
    for your user account, you may get a prompt, as shown in figure 2.7\. This prompt
    occurs because Fluentd and Fluent Bit will, by default, expose access points to
    the network.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将启动Fluentd，我们将在控制台上看到启动时显示的信息，包括正在加载和检查的配置。当在Windows上运行Fluentd或Fluent Bit时，根据您的用户账户的权限，您可能会收到如图2.7所示的提示。这个提示发生是因为Fluentd和Fluent
    Bit默认会向网络公开访问点。
- en: '![](../Images/CH02_F07_Wilkins.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F07_Wilkins.png)'
- en: Figure 2.7 Windows prompting to allow Fluentd or Fluent Bit (depending on what
    is being started) access to use the network
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/CH02_F07_Wilkins.png)'
- en: We should, of course, allow access. Without it, both Fluentd and Fluent Bit
    will fail. Within a Linux environment, the equivalent security controls are established
    through IPTables rules and possible SELinux configuration. As Linux environments
    can vary more than Windows, it is worth having a good Linux reference to help
    set up and troubleshoot any restrictions. Manning has several such titles, such
    as *Linux in Motion* by David Clinton ([www.manning.com/livevideo/linux-in-motion](https://www.manning.com/livevideo/linux-in-motion)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该允许访问。没有它，Fluentd和Fluent Bit都将失败。在Linux环境中，等效的安全控制是通过IPTables规则和可能的SELinux配置来建立的。由于Linux环境比Windows环境变化更多，因此拥有一个好的Linux参考以帮助设置和排除任何限制是值得的。Manning有几本这样的书籍，例如David
    Clinton的*Linux in Motion*([www.manning.com/livevideo/linux-in-motion](https://www.manning.com/livevideo/linux-in-motion))。
- en: The next step is to send a log event using Postman. Once Postman has started,
    we need to configure it to send a simple JSON payload to Fluentd. Figure 2.8 shows
    the settings in the header.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用Postman发送日志事件。一旦Postman启动，我们需要配置它向Fluentd发送简单的JSON有效负载。图2.8显示了标题中的设置。
- en: '![](../Images/CH02_F08_Wilkins.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F08_Wilkins.png)'
- en: Figure 2.8 Defined JSON payload to send to Fluentd using Postman
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 定义JSON有效载荷，使用Postman发送到Fluentd
- en: 'We also need to set the Body content, as we’re going to use a POST operation.
    By selecting Body (and the Raw option) on the screen, we can then key into the
    body field `{"Hello" : "World"}`. With this done, we’re ready now to send. We
    see this configuration in figure 2.9.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还需要设置Body内容，因为我们将要使用POST操作。通过在屏幕上选择Body（以及原始选项），我们就可以键入body字段`{"Hello" :
    "World"}`。完成这些后，我们现在就可以发送了。我们在图2.9中看到了这个配置。'
- en: '![](../Images/CH02_F09_Wilkins.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F09_Wilkins.png)'
- en: Figure 2.9 Setting the message body in Postman
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 在Postman中设置消息体
- en: Click the Send button in Postman. Figure 2.10 shows the result. You may have
    noticed that in the API call, we have not defined a time for the log event; therefore,
    the Fluentd instance will apply the current system time.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中点击发送按钮。图2.10显示了结果。你可能已经注意到，在API调用中，我们没有为日志事件定义时间；因此，Fluentd实例将应用当前系统时间。
- en: '![](../Images/CH02_F10_Wilkins.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F10_Wilkins.png)'
- en: Figure 2.10 Fluentd output after sending the REST event—note the last line showing
    the output of the received event
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 发送REST事件后的Fluentd输出——注意显示接收事件输出的最后一行
- en: While this configuration is as “useful as a chocolate teapot,” as the expression
    goes, it does illustrate the basic idea of Fluentd—the ability to take log events
    and direct them (explicitly or implicitly) to an output. Let’s finish this illustration
    by using the LogSimulator to create a stream of log events.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如俗语所说，“这个配置就像一个巧克力茶壶一样有用”，但它确实说明了Fluentd的基本理念——能够接收日志事件并将它们（显式或隐式地）导向输出。让我们通过使用LogSimulator创建日志事件流来完成这个说明。
- en: A new shell window is required to run the LogSimulator. Within the shell, you
    will need to navigate to where the configurations have been downloaded. Within
    each of the chapter’s folders is a folder called SimulatorConfig. Depending upon
    the chapter, you will find one or more property files. Inside the property file,
    you’ll find a series of key-value pairs that will control the LogSimulator’s behavior.
    This includes referencing the log file to replay or test data. These references
    are relative, meaning we need to be in the correct folder—the parent folder to
    the chapters—to start the simulator successfully. We can then start the LogSimulator
    with the command
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行LogSimulator需要一个新的shell窗口。在shell中，你需要导航到配置已下载的位置。每个章节文件夹中都有一个名为SimulatorConfig的文件夹。根据章节的不同，你将找到一个或多个属性文件。在属性文件中，你会找到一系列键值对，这些键值对将控制LogSimulator的行为。这包括引用要回放或测试数据的日志文件。这些引用是相对的，这意味着我们需要在正确的文件夹中——章节的父文件夹中——才能成功启动模拟器。然后我们可以使用以下命令启动LogSimulator
- en: '[PRE10]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: or, if you choose to use the JAR file
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你选择使用JAR文件
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember to correct the slashes in the file path for Linux environments. The
    LogSimulator is provided with a configuration that will send log events using
    a log file source using the same HTTP endpoint. This will result in each of the
    log events being displayed on the console.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在Linux环境中纠正文件路径中的斜杠。LogSimulator提供了一个配置，将使用相同的HTTP端点通过日志文件源发送日志事件。这将导致每个日志事件都在控制台上显示。
- en: 2.4 “Hello World” with Fluent Bit
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用Fluent Bit的“Hello World”
- en: Fluent Bit, as previously mentioned, is written in C/C++, making the footprint
    very compact. The downside of this is that it requires more effort to build Fluent
    Bit for your environment. You will need to be comfortable with the Gnu Compiler
    Collection (GCC) ([https://gcc.gnu.org/](https://gcc.gnu.org/)), which is typically
    available on Linux platforms, or the cross-platform C compiler Clang ([https://clang.llvm.org/](https://clang.llvm.org/)),
    which can work in a GCC mode. For this book, we aren’t going to delve any further
    into the world of C/C++ compilation. This means downloading one of the prebuilt
    binaries or using one of the supported package managers, such as apt and yum.
    For Windows, Treasure Data has provided Windows binaries (available at [https://docs.fluentbit.io/manual/installation
    /windows](https://docs.fluentbit.io/manual/installation/windows)). Because the
    binaries are provided by Treasure Data, the created artifacts make use of the
    prefix *td*. For simplicity and alignment to the basic version of Fluent Bit,
    we recommend downloading the zip version. We have used the zip download approach
    for our examples.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Fluent Bit 是用 C/C++ 编写的，这使得它的体积非常紧凑。这种做法的缺点是，为您的环境构建 Fluent Bit 需要更多的努力。您需要熟悉
    Gnu 编译器集合（GCC）([https://gcc.gnu.org/](https://gcc.gnu.org/))，它通常在 Linux 平台上可用，或者跨平台的
    C 编译器 Clang ([https://clang.llvm.org/](https://clang.llvm.org/))，它可以在 GCC 模式下工作。对于本书，我们不会进一步深入
    C/C++ 编译的世界。这意味着下载一个预构建的二进制文件或使用支持的包管理器，如 apt 和 yum。对于 Windows，Treasure Data 提供了
    Windows 二进制文件（可在 [https://docs.fluentbit.io/manual/installation /windows](https://docs.fluentbit.io/manual/installation/windows)
    获取）。由于二进制文件由 Treasure Data 提供，创建的工件使用了前缀 *td*。为了简单起见，并与 Fluent Bit 的基本版本保持一致，我们建议下载
    zip 版本。我们已经在我们的示例中使用了 zip 下载方法。
- en: Unpack the zip file to a suitable location (we will assume `C:\td-agent`) as
    the location. To make life easier, it is worth adding the bin folder (e.g., `C:\td-agent\bin`)
    into the `PATH` environmental variables, as we did with Fluentd.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将 zip 文件解压到合适的位置（我们将假设为 `C:\td-agent`），作为安装位置。为了简化操作，值得将 bin 文件夹（例如，`C:\td-agent\bin`）添加到
    `PATH` 环境变量中，就像我们之前对 Fluentd 所做的那样。
- en: 'We can check that Fluent Bit has been deployed with the following simple command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下简单的命令来检查 Fluent Bit 是否已部署：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will prompt Fluent Bit to display its help information on the console.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示 Fluent Bit 在控制台上显示其帮助信息。
- en: 2.4.1 Starting Fluent Bit
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 启动 Fluent Bit
- en: The obvious assumption would be that as long as we limit our Fluentd configuration
    file to the plugins available in a Fluent Bit deployment, we can use the same
    configuration file. Unfortunately not—while the configuration files are similar,
    they aren’t the same. We’ll explore the difference in a while. But to get Fluent
    Bit running with our “Hello World” example, let’s start things with a configuration
    file previously prepared, using the command
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的假设是，只要我们将 Fluentd 的配置文件限制在 Fluent Bit 部署中可用的插件范围内，我们就可以使用相同的配置文件。不幸的是并非如此——虽然配置文件相似，但它们并不相同。我们稍后会探讨它们之间的差异。但为了使用我们的“Hello
    World”示例运行 Fluent Bit，让我们从一个之前准备好的配置文件开始，使用以下命令
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a result, Fluent Bit will start up with the configuration provided. Unlike
    Fluentd, Fluent Bit’s support for HTTP is more recent and may not have all the
    features you want, depending on when you read this. Therefore, it is possible
    to match Fluentd for HTTP in our scenario of sending JSON. If you bump up against
    HTTP feature restrictions, then you can at least drop down to using the TCP plugin
    (HTTP is a layer over the TCP protocols). Both Fluent Bit and Fluentd support
    HTTP operations for capturing status information and HTTP forwarding. The only
    downside of working at the TCP layer is that we can’t use Postman to send the
    calls. You can create the same effect with other tools that know how to send text
    content to TCP sockets. For Linux, utilities such as *tc* can do this. In a Windows
    environment, there isn’t the same native tooling. It is possible to create a Telnet
    session using tools such as PuTTY ([www.putty.org](https://www.putty.org)), and
    LogSimulator includes the ability to send text log events to a TCP port. For Fluent
    Bit, let’s use Postman for HTTP and use the LogSimulator for TCP. Starting with
    TCP, the following command will start the LogSimulator, providing it with a properties
    file and a file of log events to send. As we have already installed this tool,
    we can start it up. Using a separate shell (with the correct Java and Groovy versions),
    we can run the command
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Fluent Bit 将使用提供的配置启动。与 Fluentd 不同，Fluent Bit 对 HTTP 的支持较新，可能不会包含你想要的所有功能，具体取决于你阅读本书的时间。因此，在我们的发送
    JSON 的场景中，我们可以匹配 Fluentd 的 HTTP 功能。如果你遇到 HTTP 功能限制，那么至少可以降级到使用 TCP 插件（HTTP 是 TCP
    协议之上的一个层）。Fluent Bit 和 Fluentd 都支持 HTTP 操作以捕获状态信息和 HTTP 转发。在 TCP 层工作唯一的缺点是我们不能使用
    Postman 发送调用。你可以使用其他知道如何向 TCP 套接字发送文本内容的工具来创建相同的效果。对于 Linux，*tc* 等实用程序可以做到这一点。在
    Windows 环境中，没有相同的原生工具。你可以使用 PuTTY 等工具创建 Telnet 会话（[www.putty.org](https://www.putty.org)），而
    LogSimulator 包含将文本日志事件发送到 TCP 端口的能力。对于 Fluent Bit，让我们使用 Postman 进行 HTTP，并使用 LogSimulator
    进行 TCP。从 TCP 开始，以下命令将启动 LogSimulator，向它提供一个属性文件和一个要发送的日志事件文件。由于我们已经安装了这个工具，我们可以启动它。使用具有正确
    Java 和 Groovy 版本的单独壳，我们可以运行以下命令
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can now expect to see the shell running the LogSimulator reporting the sent
    events to the console. The log events will be sent at varying time intervals (the
    console should look something like the screenshot in figure 2.11).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以期待看到运行 LogSimulator 的壳正在将发送的事件报告到控制台。日志事件将以不同的时间间隔发送（控制台应该看起来像图 2.11 中的截图）。
- en: '![](../Images/CH02_F11_Wilkins.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F11_Wilkins.png)'
- en: Figure 2.11 Simulator console output at the end of the log event transmission
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 日志事件传输结束时的模拟器控制台输出
- en: At the same time, Fluent Bit in the other console will start reporting the receipt
    and sending to its console the JSON payloads received. This is shown in figure
    2.12.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，另一个控制台中的 Fluent Bit 将开始报告接收事件，并将接收到的 JSON 有效载荷发送到其控制台。这如图 2.12 所示。
- en: '![](../Images/CH02_F12_Wilkins.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F12_Wilkins.png)'
- en: Figure 2.12 Example Fluent Bit console output
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 Fluent Bit 控制台输出示例
- en: You may have noticed a lag between the simulator starting and seeing Fluent
    Bit displaying events. This reflects that one of the configuration options is
    the time interval when the cache of received log messages is flushed to the output.
    As we will discover later in the book, this is one of the areas that we can tune
    to help performance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在模拟器启动和看到 Fluent Bit 显示事件之间存在延迟。这反映了配置选项之一是接收到的日志消息缓存刷新到输出的时间间隔。正如我们将在本书后面发现的那样，这是我们可以在其中调整以帮助性能的领域之一。
- en: Now with HTTP
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 HTTP
- en: 'The difference between the TCP and HTTP configurations is small, so you can
    either make the changes to the `Chapter2/FluentBit/HelloWorld.conf` or use the
    provided configuration file `Chapter2/FluentBit/HelloWorld-HTTP.conf`. The following
    shows the changes that need to be applied:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 和 HTTP 配置之间的差异很小，因此你可以对 `Chapter2/FluentBit/HelloWorld.conf` 进行更改，或者使用提供的配置文件
    `Chapter2/FluentBit/HelloWorld-HTTP.conf`。以下是需要应用的变化：
- en: In the Input section, change the `Name tcp` to `Name http`.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入部分，将 `Name tcp` 更改为 `Name http`。
- en: As we have been using port 18080 for HTTP in Postman, let’s correct the port
    in the configuration, replacing `port 28080` with `port 18080`.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们一直在 Postman 中使用 18080 端口进行 HTTP，让我们在配置中更正端口，将 `port 28080` 替换为 `port 18080`。
- en: Save these changes once applied. To see how Fluent Bit will work now, stop the
    current Fluent Bit process if it’s still running. Then restart as before, or using
    the provided changes, start with
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 保存应用后的这些更改。要查看 Fluent Bit 现在将如何工作，如果它仍在运行，请停止当前的 Fluent Bit 进程。然后像之前一样重新启动，或者使用提供的更改，从以下命令开始：
- en: '[PRE15]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once running, use the same Postman settings to send the events as we did for
    Fluentd.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，使用与 Fluentd 相同的 Postman 设置发送事件，就像我们之前做的那样。
- en: 2.4.2 Alternate Fluent Bit startup options
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 交替的 Fluent Bit 启动选项
- en: Fluent Bit can also be configured entirely through the command line. This makes
    an effective way to configure Fluent Bit, as it simplifies the deployment (no
    mapping of configuration files needed). However, this does come at the price of
    readability. For example, we could repeat the same configuration of Fluent Bit
    with
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Fluent Bit 也可以完全通过命令行进行配置。这使得配置 Fluent Bit 成为一个有效的方法，因为它简化了部署（不需要映射配置文件）。然而，这确实是以可读性为代价的。例如，我们可以使用以下方式重复相同的
    Fluent Bit 配置：
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you run this command with the simulator as previously set up, the outcomes
    will be the same as before. Fluent Bit, like Fluentd, isn’t tied to working with
    a single source of log events. We can illustrate this by adding additional input
    definitions into the command line. While running in a Windows environment, let’s
    add the `winlog` events to our inputs. For Linux users, you could replace the
    `winlog` source with `cpu` and ask Fluent Bit to tell us a bit more about what
    it is doing by repeating the same exercise, but with the command
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用之前设置的模拟器运行此命令，结果将与之前相同。Fluent Bit，就像 Fluentd 一样，并不局限于与单个日志事件源一起工作。我们可以通过向命令行添加额外的输入定义来展示这一点。在
    Windows 环境中运行时，让我们将 `winlog` 事件添加到我们的输入中。对于 Linux 用户，你可以用 `cpu` 替换 `winlog` 源，并通过重复相同的练习，但使用以下命令来让
    Fluent Bit 告诉我们更多关于它在做什么的信息：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time we will see several differences. First, when Fluent Bit starts up,
    it will give us a lot more information, including clearly showing the inputs and
    outputs being hand-led. This results from the `-vv` (more on this in the next
    section). As the log events occur, in addition to our log simulator events, the
    `winlog` information will be interleaved.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将看到几个不同之处。首先，当 Fluent Bit 启动时，它将给我们提供更多信息，包括清楚地显示正在手动管理的输入和输出。这是由于 `-vv`（更多内容将在下一节中介绍）。随着日志事件的发生，除了我们的日志模拟器事件外，`winlog`
    信息将被交错。
- en: Fluentd and Fluent Bit internal logging levels
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd 和 Fluent Bit 内部日志级别
- en: Both Fluentd and Fluent Bit support the same command-line parameters that can
    control how much information they log about their activities (as opposed to any
    log-level information associated with a log event received). In addition to being
    controlled by the command line, this configuration can be set via the configuration
    file. Both tools recognize five levels of logs, and when no parameter or configuration
    is applied, the midlevel (info) is used as the default log level. Table 2.5 shows
    the log levels, the command-line parameters, and the equivalent configuration
    setting. The easiest way to remember the command line is `-v` is for *verbose*
    and `-q` is for *quiet*; more letters increase verbosity or quietness.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd 和 Fluent Bit 都支持相同的命令行参数，可以控制它们记录关于其活动多少信息（与接收到的任何与日志事件相关的日志级别信息相对）。除了由命令行控制外，此配置还可以通过配置文件设置。这两个工具都识别五个日志级别，并且当没有参数或配置应用时，中等级别（信息）用作默认日志级别。表
    2.5 显示了日志级别、命令行参数和等效的配置设置。记住命令行参数的最简单方法是 `-v` 代表 *详细*，`-q` 代表 *安静*；更多的字母会增加详细程度或安静程度。
- en: Table 2.5 Log levels recognized by Fluentd and Fluent Bit
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.5 Fluentd 和 Fluent Bit 识别的日志级别
- en: '| Log level | Command line | Configuration setting |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 日志级别 | 命令行 | 配置设置 |'
- en: '| Trace | `-vv` | `Log_Level trace` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪 | `-vv` | `Log_Level trace` |'
- en: '| Debug | `-v` | `Log_Level debug` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | `-v` | `Log_Level debug` |'
- en: '| Info |  | `Log_Level info` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 信息 |  | `Log_Level info` |'
- en: '| Warning | `-q` | `Log_Level warn` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | `-q` | `Log_Level warn` |'
- en: '| Error | `-qq` | `Log_Level error` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | `-qq` | `Log_Level error` |'
- en: Note Trace level setting will occur only if Fluent Bit has been compiled with
    the *build flag* set to enable trace. This can be checked using the Fluent Bit
    help command (`fluent-bit -h` or `fluent-bit -–help`) to display a list of the
    build flags and their settings. Trace-level logging should be needed only while
    developing a plugin.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：只有当 Fluent Bit 编译时设置了 *构建标志* 以启用跟踪时，才会发生跟踪级别的设置。这可以通过 Fluent Bit 帮助命令（`fluent-bit
    -h` 或 `fluent-bit -–help`）来检查，以显示构建标志及其设置。跟踪级别的日志记录通常只在开发插件时需要。
- en: 2.4.3 Fluent Bit configuration file comparison
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 Fluent Bit 配置文件比较
- en: Previously we mentioned that the Fluentd and Fluent Bit configurations differ.
    To help illustrate the differences, table 2.6 offers the configuration side by
    side.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到 Fluentd 和 Fluent Bit 配置不同。为了帮助说明差异，表 2.6 提供了并排的配置。
- en: Table 2.6 Fluentd and Fluent Bit configuration comparison (using the HTTP configuration
    of Fluent Bit)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.6 Fluentd 和 Fluent Bit 配置比较（使用 Fluent Bit 的 HTTP 配置）
- en: '| Fluent Bit | Fluentd |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Fluent Bit | Fluentd |'
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If you want to play spot the difference, then you should have observed the
    following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想找出差异，那么你应该已经观察到了以下内容：
- en: Rather than directives being defined by opening and closing angle brackets (`<>`),
    the directive is in square brackets (`[]`), and the termination is implicit by
    the following directive or end of the file.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与通过打开和关闭尖括号 (`<>`) 定义指令不同，指令在方括号 (`[]`) 中，终止是通过后续指令或文件末尾隐式完成的。
- en: '`SERVICE` replaces the *system* for defining the general configuration.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERVICE` 替换了 *system* 用于定义通用配置。'
- en: '`@type` *is replaced by the* `Name` *attribute to define the plugin to be used.*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@type` 被替换为 `Name` 属性来定义要使用的插件。'
- en: '*Match*, rather than being the name of the directive with a parameter in the
    directive, becomes `Output`*.* The *match* clause is then defined by another name-value
    pair in the attributes.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Match*，而不是指令中带有参数的指令名称，变成了 `Output`。*match* 子句随后由属性中的另一个名称-值对定义。'
- en: Older versions of Fluent Bit didn’t support HTTP, so events would need to be
    sent using events using TCP, but the events received can still be in JSON format.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧版本的 Fluent Bit 不支持 HTTP，因此事件需要通过 TCP 发送，但接收的事件仍然可以是 JSON 格式。
- en: When looking at the configurations side by side, the details aren’t too radically
    different, but they are significant enough to catch people out.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当并排查看配置时，细节并不太激进地不同，但它们足够显著，足以让人注意到。
- en: 2.4.4 Fluent Bit configuration file in detail
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 Fluent Bit 配置文件详细说明
- en: Looking more closely at the configuration file and the rules that are applied,
    we’ve just seen there are some similarities, and there are some differences. In
    the following listing, we have highlighted a few key rules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看配置文件和应用的规则，我们刚刚看到有一些相似之处，也有一些不同之处。在下面的列表中，我们突出了一些关键规则。
- en: Listing 2.2 Chapter2/FluentBit/HelloWorld.conf
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 第 2 章/FluentBit/HelloWorld.conf
- en: '[PRE20]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ All the Fluent Bit general configuration values are set in this section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有 Fluent Bit 通用配置值都设置在本节中。
- en: ❷ The Flush attribute controls how frequently Fluent Bit flushes its log cache
    to the output channels (stdout and stderr). In this case, we have set it to 1
    second.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Flush 属性控制 Fluent Bit 多频繁地将日志缓存刷新到输出通道（stdout 和 stderr）。在这种情况下，我们将其设置为 1 秒。
- en: ❸ This tells the Fluent Bit startup whether the process should run as a daemon
    process.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这告诉 Fluent Bit 启动时进程是否应以守护进程运行。
- en: ❹ Indentation is important in a configuration file and must be consistent. Recommended
    indentation is four space characters. Indentation, just like in a YAML file, indicates
    parent and child relationships. In this case, all these values are subservient
    to this input.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在配置文件中，缩进很重要，并且必须一致。建议的缩进是四个空格字符。与 YAML 文件一样，缩进表示父级和子级关系。在这种情况下，所有这些值都是这个输入的从属。
- en: ❺ Rather than sources, Fluent Bit configuration uses the terminology of input
    and output.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 与源不同，Fluent Bit 配置使用输入和输出的术语。
- en: ❻ In Fluent Bit, the controls on which log events pass through the plugin are
    determined not in the output declaration, as illustrated with Fluentd, but by
    a separate match attribute.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在 Fluent Bit 中，控制哪些日志事件通过插件传递不是在输出声明中确定的，如 Fluentd 所示，而是通过一个单独的匹配属性。
- en: 'As with Fluentd, ordering within the configuration file is important, particularly
    in `match` statements—for example, if we added the following configuration fragment
    immediately before the current `OUTPUT` declaration:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Fluentd 一样，配置文件中的顺序很重要，尤其是在 `match` 语句中——例如，如果我们立即在当前的 `OUTPUT` 声明之前添加以下配置片段：
- en: '[PRE21]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Suppose the configuration appeared as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设配置如下所示：
- en: '[PRE22]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Should we expect logs to appear in the log file, stdout (i.e., console), or
    both? The answer is that events will appear only in the file. This is because
    we match all events in both outputs; then it is the first output definition in
    the configuration that gets the events (i.e., the log file, with a wildcard `match`
    attribute; no log events will make it to `stdout`).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该期待日志出现在日志文件、stdout（即控制台）或两者都出现？答案是事件只会出现在文件中。这是因为我们在两个输出中都匹配了所有事件；然后是配置中的第一个输出定义获取了事件（即带有通配符
    `match` 属性的日志文件；没有日志事件会到达 `stdout`）。
- en: 2.4.5 Putting the dummy plugin into action
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.5 将 dummy 插件投入实际应用
- en: To test out some of the details, see if you can implement the following configuration
    change. Within both Fluentd and Fluent Bit is a built-in input plugin called *dummy*.
    Modify the respective HelloWorld.conf files and incorporate the source, and then
    start up Fluentd and Fluent Bit, in turn, to see what outcomes you get. The result
    of the exercise is included at the end of the chapter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一些细节，看看你是否能实现以下配置更改。在 Fluentd 和 Fluent Bit 中都有一个内置的输入插件，称为 *dummy*。修改相应的
    HelloWorld.conf 文件，并包含源，然后依次启动 Fluentd 和 Fluent Bit，看看你得到什么结果。练习的结果包含在本章末尾。
- en: Answer
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: Rather than filling the pages with configuration files, the answer configurations
    can be found in the downloaded folders Chapter2/ExerciseResults/Fluentd/HelloWorld-Answer.conf
    and Chapter2/ExerciseResults/FluentBit/HelloWorld-Answer.conf.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与在页面上填充配置文件不同，答案配置可以在下载的文件夹中找到，位于 Chapter2/ExerciseResults/Fluentd/HelloWorld-Answer.conf
    和 Chapter2/ExerciseResults/FluentBit/HelloWorld-Answer.conf。
- en: 2.5 Fluentd deployment with Kubernetes and containers
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 使用 Kubernetes 和容器部署 Fluentd
- en: So far, we have looked at the deployment of Fluentd and Fluent Bit as you might
    approach the requirement with only minimal consideration to how the host is working
    (native deployments, virtualization, and containerization). We have referenced
    some of the mechanisms that would allow us to further automate or containerize
    these tools. As discussed in chapter 1, Fluentd has a strong association with
    containerization and the use of Kubernetes. We’ll briefly look at how Fluentd
    is configured in a Kubernetes context; when we get to part 3 of the book, we’ll
    look at details such as scaling and containerization in depth.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 Fluentd 和 Fluent Bit 的部署，你可能只是对主机的工作方式（原生部署、虚拟化和容器化）进行了最少的考虑。我们已经引用了一些机制，这些机制可以让我们进一步自动化或容器化这些工具。正如第
    1 章所讨论的，Fluentd 与容器化和 Kubernetes 的使用有着紧密的联系。我们将简要地看看 Fluentd 在 Kubernetes 上下文中的配置方式；当我们到达本书的第三部分时，我们将深入探讨诸如扩展和容器化等细节。
- en: Establishing a deployment of a Kubernetes environment and containerization warrants
    its own book (we recommend *Kubernetes in Action*, 2nd edition by Marko Lukša;
    [www.manning.com/books/kubernetes-in-action-second-edition](https://www.manning.com/books/kubernetes-in-action-second-edition)).
    It is, however, worth looking at how things operate in principle; as we work through
    the configuration of Fluentd in the following chapters, you will be able to appreciate
    how the configuration could relate to a Kubernetes deployment. It may also prompt
    ideas on how and what you may wish to monitor with Fluentd when it comes to the
    microservices themselves.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 建立 Kubernetes 环境的部署和容器化需要一本自己的书（我们推荐 Marko Lukša 的《Kubernetes in Action》，第 2
    版；[www.manning.com/books/kubernetes-in-action-second-edition](https://www.manning.com/books/kubernetes-in-action-second-edition)）。然而，了解其基本操作原理是值得的；在我们接下来的章节中配置
    Fluentd 时，你将能够欣赏到配置如何与 Kubernetes 部署相关联。它也可能激发你关于如何以及使用 Fluentd 监控微服务的想法。
- en: 2.5.1 Fluentd DaemonSet
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 Fluentd DaemonSet
- en: Fluentd is one of the options for incorporating log management into a Kubernetes
    environment. This is typically achieved by defining configuration files. The Kubernetes
    configuration files tell Kubernetes how pods (collections of containers that work
    together) and containers should be run across one or more worker nodes (servers
    providing compute power to a Kubernetes cluster). Within Kubernetes, we can describe
    different ways for pods to be deployed, such as ReplicaSets, Jobs, and DaemonSets.
    For example, it is possible to define things such that a Fluentd container will
    be executed on each worker node to collect log events from all the local containers
    running on that node. This type of configuration within Kubernetes is known as
    a *DaemonSet* and is a typical configuration for Kubernetes to have for Fluentd.
    As we’ll see later in the book, this isn’t the only way to deploy Fluentd, nor
    are we limited to one deployment model. In the next listing, we can see an example
    DaemonSet configuration for applying a configuration file and parameters for routing
    log events to another Fluentd node.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd 是将日志管理集成到 Kubernetes 环境的选项之一。这通常是通过定义配置文件来实现的。Kubernetes 配置文件告诉 Kubernetes
    如何在单个或多个工作节点（为 Kubernetes 集群提供计算能力的服务器）上运行 pod（协同工作的容器集合）和容器。在 Kubernetes 中，我们可以描述
    pod 部署的不同方式，例如 ReplicaSets、Jobs 和 DaemonSets。例如，可以定义一些事情，使得 Fluentd 容器将在每个工作节点上执行，以收集该节点上所有本地容器运行的日志事件。这种
    Kubernetes 中的配置类型被称为 *DaemonSet*，并且是 Kubernetes 为 Fluentd 常见的配置。正如我们将在本书后面看到的那样，这并不是部署
    Fluentd 的唯一方法，我们也不限于一种部署模型。在下一个列表中，我们可以看到一个示例 DaemonSet 配置，用于应用配置文件和将日志事件路由到另一个
    Fluentd 节点的参数。
- en: Listing 2.3 Chapter2/Out-of-the-box Fluentd DaemonSet designed for forwarding
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 第 2 章/开箱即用的 Fluentd DaemonSet，用于转发
- en: '[PRE23]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Tells Kubernetes whether the pod should run on the master (controlling node)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 告诉 Kubernetes 是否应该在主节点（控制节点）上运行 pod
- en: ❷ Tells Kubernetes this is something that must run continuously, rather than
    on a schedule
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 告诉 Kubernetes 这是一项必须持续运行的任务，而不是按计划运行
- en: ❸ Identifies to Kubernetes the container image to be used, which will run Fluentd
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 识别 Kubernetes 将要使用的容器镜像，该镜像将运行 Fluentd
- en: ❹ This is where we start defining the containers within the pod. In addition
    to what is shown here, each container can have things done, such as defined startup
    commands—for example, tailoring each Fluentd instance.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这是我们开始定义 pod 内部容器的地方。除了这里显示的内容外，每个容器还可以执行一些操作，例如定义启动命令——例如，定制每个 Fluentd 实例。
- en: ❺ It is also possible to have environment variables within the container instance
    set using these name-value pairs. In this case, several variables are being defined,
    which are then referenced within a configuration file to direct the forwarding
    plugin.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 还可以通过这些名称-值对在容器实例内设置环境变量。在这种情况下，定义了几个变量，然后在配置文件中引用这些变量以指导转发插件。
- en: ❻ Resource quotas can be defined, so Fluentd doesn’t starve other processes
    running on a node of time. But this can have other consequences.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 可以定义资源配额，这样 Fluentd 就不会耗尽节点上其他进程的时间。但这可能会有其他后果。
- en: ❼ Describes a mount point within the container that can be used to access externalized
    storage
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 描述容器内的一个挂载点，可以用来访问外部化存储
- en: ❽ Describes where the container’s external storage would be on the underlying
    Kubernetes infrastructure. In an enterprise scenario, this could be a network
    storage device such as a SAN, or in the cloud it would be mapped to some form
    of block storage. This means we could map the logs that Fluentd generates to a
    shared location, and we could direct Fluentd instances to pick up a common configuration
    file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 描述容器的外部存储在底层 Kubernetes 基础设施上的位置。在企业场景中，这可能是一个网络存储设备，如 SAN，或者在云中它将被映射到某种形式的块存储。这意味着我们可以将
    Fluentd 生成的日志映射到共享位置，并且我们可以指导 Fluentd 实例去获取一个公共配置文件。
- en: NOTE The DaemonSet comes from [http://mng.bz/nYea](http://mng.bz/nYea).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：DaemonSet 来自 [http://mng.bz/nYea](http://mng.bz/nYea)。
- en: It should be noted that it is possible within an infrastructure hosting Kubernetes
    nodes to run processes such as Fluentd directly on the underlying platform. While
    this eliminates the abstraction layer of Kubernetes (and the associated overhead),
    it also removes the opportunity to use Kubernetes to manage and monitor that Fluentd
    is running. We recommend this only in very unusual circumstances.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在托管Kubernetes节点的基础设施中，可以直接在底层平台上运行Fluentd等进程。虽然这消除了Kubernetes的抽象层（及其相关开销），但也消除了使用Kubernetes管理和监控Fluentd运行的机会。我们仅在非常特殊的情况下推荐这样做。
- en: NOTE DaemonSets are defined to provide basic operations on every worker node.
    This could be sending log events directly to Elasticsearch (as part of an EFK
    stack as discussed in chapter 1) or forwarding logs to various cloud vendor log
    analytics solutions, such as AWS CloudWatch. These can be found in the Fluentd
    GitHub ([http://mng.bz/2jng](http://mng.bz/2jng)).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：DaemonSets被定义为在每个工作节点上提供基本操作。这可以是将日志事件直接发送到Elasticsearch（如第1章中讨论的EFK堆栈的一部分）或将日志转发到各种云供应商的日志分析解决方案，例如AWS
    CloudWatch。这些可以在Fluentd GitHub([http://mng.bz/2jng](http://mng.bz/2jng))中找到。
- en: Figure 2.13 illustrates how the Kubernetes configuration can work using a DaemonSet.
    Typically, the DaemonSet configuration would be held in a shared configuration
    repository or file system and then passed to Kubernetes through a tool like kubectl,
    the standard Kubernetes CLI tool. We have assumed that the Fluentd configuration
    resides on a shared file system and is therefore mounted by the Fluentd container
    to allow access. Another approach would be to pass the configuration using the
    DaemonSet YAML file or simply wire directly into the Docker image. The log consumers
    that the Fluentd configuration has within the DaemonSet could direct the log events
    to Elasticsearch, or to a file system outside the cluster that the Kubernetes
    configuration has made accessible. We will explore more about this when we get
    to scaling Fluentd.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13说明了如何使用DaemonSet使用Kubernetes配置。通常，DaemonSet配置会存储在共享配置仓库或文件系统中，然后通过像kubectl这样的工具传递给Kubernetes，kubectl是标准的Kubernetes
    CLI工具。我们假设Fluentd配置位于共享文件系统中，因此由Fluentd容器挂载以允许访问。另一种方法是通过DaemonSet YAML文件传递配置，或者直接将配置直接连接到Docker镜像。在DaemonSet中，Fluentd配置具有的日志消费者可以将日志事件直接发送到Elasticsearch，或者发送到Kubernetes配置使其可访问的集群外部的文件系统。当我们到达扩展Fluentd时，我们将进一步探讨这一点。
- en: '![](../Images/CH02_F13_Wilkins.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F13_Wilkins.png)'
- en: Figure 2.13 A deployment model of Fluentd within Kubernetes as a DaemonSet.
    Each distinct server in the Kubernetes cluster has its own pod with a container
    running Fluentd.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13展示了Fluentd在Kubernetes中作为DaemonSet的部署模型。Kubernetes集群中的每个独立服务器都有自己的pod，运行着Fluentd容器。
- en: 2.5.2 Dockerized Fluentd
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 Docker化Fluentd
- en: Like just about any application, in addition to manually installing or automating
    a manual install through tools like Ansible ([www.ansible.com](https://www.ansible.com)),
    it is possible to deploy Fluentd or Fluent Bit using the Docker container engine.
    Predefined Fluentd Docker files (i.e., the files that tell Docker how to build
    an executable image) are provided in the GitHub repository ([https://github.com/fluent/fluentd-docker-image](https://github.com/fluent/fluentd-docker-image)),
    which include addressing different host OS factors (e.g., Debian to Windows).
    Fluent Bit also has a smaller set of predefined Docker files in GitHub ([https://github.com/fluent/fluent-bit](https://github.com/fluent/fluent-bit)).
    The GitHub repositories contain the configuration files and scripts. The realized
    images are held in Docker Hub and can be found at [https://hub.docker.com/u/fluent](https://hub.docker.com/u/fluent)
    for Fluentd and [https://hub.docker.com/r/fluent/fluent-bit](https://hub.docker.com/r/fluent/fluent-bit)
    for Fluent Bit.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就像几乎所有应用程序一样，除了手动安装或通过像Ansible ([www.ansible.com](https://www.ansible.com))这样的工具自动化安装外，还可以使用Docker容器引擎部署Fluentd或Fluent
    Bit。预定义的Fluentd Docker文件（即告诉Docker如何构建可执行镜像的文件）在GitHub仓库([https://github.com/fluent/fluentd-docker-image](https://github.com/fluent/fluentd-docker-image))中提供，包括解决不同的主机操作系统因素（例如，Debian到Windows）。Fluent
    Bit在GitHub上也有更小的一组预定义Docker文件([https://github.com/fluent/fluent-bit](https://github.com/fluent/fluent-bit))。GitHub仓库包含配置文件和脚本。已实现的镜像存储在Docker
    Hub上，可以在[https://hub.docker.com/u/fluent](https://hub.docker.com/u/fluent)找到Fluentd，以及[https://hub.docker.com/r/fluent/fluent-bit](https://hub.docker.com/r/fluent/fluent-bit)找到Fluent
    Bit。
- en: 2.6 Using Fluentd UI
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 使用Fluentd UI
- en: We have managed to install and run Fluentd and Fluent Bit. But in both cases,
    the control has been through the command line. Fluentd can also run with a web
    UI. The web UI is served from the same process that executes Fluentd’s core logic
    if it is installed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功安装并运行了Fluentd和Fluent Bit。但在两种情况下，控制都是通过命令行进行的。如果安装了Web UI，Fluentd也可以运行。Web
    UI由执行Fluentd核心逻辑的同一进程提供服务。
- en: 2.6.1 Installing Fluentd with UI
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.1 使用UI安装Fluentd
- en: The installation will trigger Fluentd to download and install a series of additional
    gems. This is because it provides the means to incorporate several plugins beyond
    the basic ones provided. This does mean the installation takes longer than just
    installing Fluentd. The commands to install the UI are
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 安装将触发Fluentd下载并安装一系列额外的gem。这是因为它提供了将多个插件（除了基本提供的插件之外）纳入其中的手段。这意味着安装时间比仅安装Fluentd要长。安装UI的命令是
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the installation is complete, we can start the UI up with the following
    command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以使用以下命令启动UI：
- en: '[PRE25]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will start up a Fluentd node, which includes a web server. The web UI can
    be accessed by opening port 9292 (i.e., pointing your browser to `localhost:9292`
    will present you with the login screen).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个Fluentd节点，其中包含一个Web服务器。可以通过打开端口9292来访问Web UI（即，将浏览器指向`localhost:9292`将显示登录界面）。
- en: Securing Fluent-UI with HTTPS
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPS保护Fluent-UI
- en: 'The Fluentd UI is run using HTTP; no SSL/TLS certificate is used on a default
    installation. This is unlikely to be an issue in development/experiment environments.
    But running without SSL/TLS and at least basic credentials is far from recommended
    when it comes to production. This can be addressed in several ways:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Fluentd UI通过HTTP运行；默认安装中不使用SSL/TLS证书。在开发/实验环境中这不太可能成为问题。但是，在生产环境中，不使用SSL/TLS和至少基本凭证运行则远非推荐的做法。这可以通过几种方式来解决：
- en: Implement a reverse proxy in front of Fluentd-ui using Nginx or the Apache Server—a
    common approach to securing web content not protected by SSL/TLS certificates
    (documentation on how to do this is available at [http://mng.bz/Ywne)](http://mng.bz/Ywne).
    It also means an additional process is running in your environment, with the need
    to have networking configured so that the reverse proxy isn’t bypassed.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fluentd-ui前面使用Nginx或Apache服务器实现反向代理——这是一种常见的保护未由SSL/TLS证书保护的Web内容的方法（有关如何操作的文档可在[http://mng.bz/Ywne](http://mng.bz/Ywne)找到）。这也意味着您的环境中将运行一个额外的进程，需要配置网络，以确保反向代理不会被绕过。
- en: For its web layers, Fluentd UI uses the Ruby on Rails framework ([https://ruby
    onrails.org/](https://rubyonrails.org/)) and the Ruby application server Puma
    ([https://puma.io](https://puma.io)). Therefore, it is possible to configure Puma
    with an SSL/TLS certificate. Applying the configuration needs Ruby code changes
    and startup parameters with a knock-on for the Fluent code base. This is undesirable,
    as any update will mean reapplying those changes.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其网络层，Fluentd UI使用Ruby on Rails框架([https://ruby onrails.org/](https://rubyonrails.org/))和Ruby应用程序服务器Puma([https://puma.io](https://puma.io))。因此，可以配置Puma使用SSL/TLS证书。应用配置需要Ruby代码更改和启动参数，这将对Fluent代码库产生影响。这并不理想，因为任何更新都意味着需要重新应用这些更改。
- en: We wouldn’t recommend the use of Fluentd UI in production. This may seem like
    avoiding a problem rather than addressing it. However, there is a lot of merit
    in this. For production environments, you want to have Fluentd configuration files
    controlled through tools such as Git. This means not empowering users with a UI
    in production that can make configuration changes. It is better to get users to
    make controlled changes that can then be rolled out securely. If you’re running
    Fluentd in a microservices or distributed environment, allowing changes only from
    the controlled configuration file provides the means to drive environment consistency
    and reduce the chance of “configuration drift.”
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不推荐在生产环境中使用Fluentd UI。这看起来像是回避问题而不是解决问题。然而，这确实有很多优点。对于生产环境，您希望通过Git等工具控制Fluentd配置文件。这意味着不赋予用户在生产环境中使用UI进行配置更改的权限。更好的做法是让用户进行受控的更改，然后可以安全地部署。如果您在微服务或分布式环境中运行Fluentd，仅允许从受控配置文件进行更改，这提供了驱动环境一致性和减少“配置漂移”机会的手段。
- en: Again, we recommend using Fluentd UI only for experimentation purposes and not
    in production. Given this, the following will provide enough insight to enable
    you to appreciate what the UI supports.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，我们只推荐将Fluentd UI用于实验目的，而不是在生产环境中使用。鉴于这一点，以下内容将提供足够的见解，使您能够欣赏UI支持的功能。
- en: By default, the login username is *admin*, and the password is *changeme*. Once
    logged in, the UI presented will look something like figure 2.14\. Differences
    can occur as the UI has reactive and responsive characteristics, resulting in
    the layout adjusting based on the device used to view the UI.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，登录用户名为 *admin*，密码为 *changeme*。一旦登录，UI 所展示的界面将类似于图 2.14。由于 UI 具有反应性和响应性，可能会出现差异，导致布局根据查看
    UI 的设备进行调整。
- en: '![](../Images/CH02_F14_Wilkins.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F14_Wilkins.png)'
- en: Figure 2.14 UI when Fluentd UI starts without any configuration
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 Fluentd UI 在没有任何配置的情况下启动
- en: We need to provide some configuration values for the Fluentd node to perform
    with. Clicking Setup Fluentd will take us to a UI through which we can configure
    the behavior. Figure 2.15 illustrates some of the relevant configuration needed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 Fluentd 节点提供一些配置值以执行。点击设置 Fluentd 将带我们到一个 UI，通过该 UI 我们可以配置其行为。图 2.15 展示了一些相关的配置需求。
- en: '![](../Images/CH02_F15_Wilkins.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F15_Wilkins.png)'
- en: Figure 2.15 Fluentd UI for setting the configuration locations
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 Fluentd UI 设置配置位置
- en: The configuration fields are set with default values. Switch the Config File
    option to point to the existing HelloWorld.conf file used to run Fluentd. You
    may wish to also provide alternative locations for the process identifier (PID)
    and log files. As soon as we click the Create button in the UI, the server process
    will start if the locations and files can be written to and read from. The UI
    then switches to a different home page, as shown in figure 2.16.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 配置字段使用默认值设置。将 Config File 选项切换到指向用于运行 Fluentd 的现有 HelloWorld.conf 文件。您可能还希望提供进程标识符（PID）和日志文件的备用位置。一旦我们在
    UI 中点击创建按钮，如果位置和文件可以写入和读取，服务器进程将启动。然后 UI 将切换到不同的主页，如图 2.16 所示。
- en: '![](../Images/CH02_F16_Wilkins.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F16_Wilkins.png)'
- en: Figure 2.16 Fluentd UI once the backend is running
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 后端运行后的 Fluentd UI
- en: The navigation menu on the left is now a lot richer. The Fluentd submenu provides
    options for working with the configuration file, accessing logs, and any error
    logs. The logs shown are the same as the console output. The navigation menu lets
    us see the details of Installed Plugins, Recommended Plugins, and Updated Plugins.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的导航菜单现在要丰富得多。Fluentd 子菜单提供了用于处理配置文件、访问日志以及任何错误日志的选项。显示的日志与控制台输出相同。导航菜单让我们可以看到已安装插件、推荐插件和更新插件的详细信息。
- en: The core of the screen is given over to the live log being produced by the server
    with controls for starting and stopping operations and the current configuration.
    The Config File options will show us the configuration file being used and the
    ability to edit the configuration file directly. If the UI options for configuration
    become an issue, you can resort to traditional editing. The Add Source and Output
    options allow web pages that capture plugin configurations using the UI as a guided,
    form-based presentation for modifying configuration values. As figure 2.17 illustrates,
    the UI does provide a nice logical flow for setting up the plugins and their configuration
    values.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕的核心部分留给了服务器产生的实时日志，以及用于启动和停止操作以及当前配置的控制。Config File 选项将显示正在使用的配置文件，并允许直接编辑配置文件。如果配置的
    UI 选项出现问题，您可以求助于传统的编辑。添加源和输出选项允许使用 UI 作为引导的、基于表单的演示来捕获插件配置，以修改配置值。如图 2.17 所示，UI
    为设置插件及其配置值提供了一个良好的逻辑流程。
- en: '![](../Images/CH02_F17_Wilkins.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F17_Wilkins.png)'
- en: Figure 2.17 Fluentd UI defining inputs and outputs
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 Fluentd UI 定义输入和输出
- en: Clicking on one of the Source, Filter, or Output elements will navigate you
    to a UI for configuring that type of plugin. For example, selecting a File source
    presents you with a file picker UI (as shown in figure 2.18).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 点击源、过滤器或输出元素之一将导航到配置该类型插件的 UI。例如，选择文件源将向您提供一个文件选择器 UI（如图 2.18 所示）。
- en: '![](../Images/CH02_F18_Wilkins.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F18_Wilkins.png)'
- en: Figure 2.18 Fluentd UI file picker as part of the File plugin configuration
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 Fluentd UI 文件选择器作为文件插件配置的一部分
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Log events are composed of a tag, a timestamp, and a record that holds the core
    log event.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志事件由一个标签、一个时间戳和一个包含核心日志事件的记录组成。
- en: Using NTP for machine time synchronization is crucial when bringing multiple
    server logs together to ensure correct log ordering.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将多个服务器日志合并在一起以确保正确日志顺序时，使用 NTP 进行机器时间同步至关重要。
- en: Fluentd and Fluent Bit can be deployed in most environments, as infrastructure
    requirements are very small and application dependencies are minimal. If necessary,
    you can compile these tools to work in niche situations.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 和 Fluent Bit 可以部署在大多数环境中，因为基础设施需求非常小，应用程序依赖性最小。如有必要，您可以编译这些工具以在特定情况下工作。
- en: There are a variety of ways for deploying Fluentd, including deploying Ruby
    and RubyGems and then retrieving Fluentd as a gem.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 Fluentd 有多种方式，包括部署 Ruby 和 RubyGems，然后作为 gem 获取 Fluentd。
- en: Deployment of the LogSimulator to quickly mimic sources of log events just requires
    Java, but to customize the tool, you need Groovy as well.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 LogSimulator 部署以快速模拟日志事件源只需要 Java，但若要自定义此工具，则需要 Groovy。
- en: Fluentd can be used with Kubernetes and Docker logging, as well as with traditional
    environments. We can retrieve standard configurations for this for Kubernetes
    deployment.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 可以与 Kubernetes 和 Docker 日志记录一起使用，也可以与传统的环境一起使用。我们可以为 Kubernetes 部署检索标准配置。
- en: When deployed on a Linux host, Fluentd can respond to signals such as SIGINT
    to shut down gracefully and SIGUSR2 to reload the configuration file.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当部署在 Linux 主机上时，Fluentd 可以响应如 SIGINT 的信号以优雅地关闭，以及 SIGUSR2 信号以重新加载配置文件。
- en: Fluentd UI is one of the additional tools available with Fluentd. This provides
    a web front to visualize the configuration of a Fluentd environment and observe
    what Fluentd is doing. Other tools include the ability to generate certificates
    and list available plugins.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd UI 是 Fluentd 提供的附加工具之一。这提供了一个网页前端来可视化 Fluentd 环境的配置并观察 Fluentd 正在做什么。其他工具包括生成证书和列出可用插件的功能。
- en: The order of how configurations are defined in a configuration file is important.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件中定义配置的顺序很重要。
- en: Fluentd’s and Fluent Bit’s own logging can be configured to different log levels.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 和 Fluent Bit 的自用日志可以配置为不同的日志级别。
- en: Fluentd and Fluent Bit configurations are similar but not the same.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd 和 Fluent Bit 的配置相似但并不相同。
