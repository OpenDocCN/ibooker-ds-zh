- en: 14 Intermediate and advanced modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 中级和高级建模
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Fitting and evaluating analysis of variance models and logistic regressions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拟合和评估方差分析和逻辑回归模型
- en: Computing probabilities, odds ratios, and log odds
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算概率、优势比和对数优势
- en: Computing and plotting sensitivity and specificity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算和绘制敏感性和特异性
- en: Running correlation tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行相关测试
- en: Creating new and improved boxplots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的和改进的箱线图
- en: The idea that “defense wins championships” might have come from legendary college
    football coach Paul “Bear” Bryant, who led the Alabama Crimson Tide to six national
    titles in the 1960s and 1970s. The same idea then extended into basketball, especially
    the NBA. Despite the fact that NBA teams spend roughly half their time and effort
    playing offense and the other half playing defense, the view that defense matters
    more than offense took hold and remains part of the sport’s conventional wisdom.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “防守赢得冠军”这一理念可能源自传奇大学橄榄球教练保罗·“熊”布莱恩特，他在20世纪60年代和70年代带领阿拉巴马红潮队赢得了六次全国冠军。同样的理念随后扩展到篮球领域，尤其是NBA。尽管NBA球队大约一半的时间和精力用于进攻，另一半用于防守，但防守比进攻更重要的观点占据了主导地位，并成为体育界传统智慧的一部分。
- en: Our purpose here is to repeatedly test the idea that defense, *much* more than
    offense, influences regular season wins and playoff appearances in the NBA. We’ll
    compute correlation coefficients; run correlation tests; demonstrate how to fit
    and evaluate an analysis of variance (ANOVA) model, which is a type of statistical
    model used to analyze the differences between *three or more* group means and
    determine the significance of these differences; and show how to fit and evaluate
    a logistic regression, which is the most popular method of solving classification
    problems—all while comparing and contrasting the effects of defense versus offense.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的目的就是要反复测试这样一个观点：在NBA中，防守比进攻更能影响常规赛的胜利和季后赛的出场。我们将计算相关系数；运行相关测试；展示如何拟合和评估方差分析（ANOVA）模型，这是一种用于分析三个或更多组均值差异的统计模型，并确定这些差异的显著性；以及展示如何拟合和评估逻辑回归，这是解决分类问题最流行的方法——同时比较和对比防守与进攻的影响。
- en: We have several packages to load, including quite a few we haven’t used yet.
    We’ll start there.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个包需要加载，包括许多我们尚未使用的包。我们将从这里开始。
- en: 14.1 Loading packages
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 加载包
- en: 'As usual, we’ll use a combination of built-in and packaged functions to accomplish
    our goals; no doubt, you’re familiar with the `tidyverse` and `patchwork` packages
    by now, but here are the other packages we’ll need throughout this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将使用内置和包装函数的组合来实现我们的目标；毫无疑问，你现在应该已经熟悉了`tidyverse`和`patchwork`包，但以下是我们将在本章中需要的其他包：
- en: Graphical displays of model outputs—diagnostic plots from our ANOVAs and a pair
    of receiver operating characteristic (ROC) curves from our logistic regressions—will
    be created from base R functionality. The remaining plots will be created from
    the `ggplot2` package, which is part of `tidyverse`. Additionally, we’ll extend
    `ggplot2` by calling the `ggpaired()` function from the `ggpubr` package to create
    paired boxplots that are very different from our previous boxplots. You might
    recall that we previously loaded the `ggpubr` package in chapter 7, from which
    we called the `stat_compare_means()` function to automatically add p-values to
    paired `ggplot2` boxplots.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型输出的图形展示——来自ANOVA的诊断图和来自逻辑回归的一对受试者工作特征（ROC）曲线——将使用基础R功能创建。其余的图形将使用`ggplot2`包创建，它是`tidyverse`的一部分。此外，我们将通过调用`ggpubr`包中的`ggpaired()`函数来扩展`ggplot2`，以创建与之前的箱线图非常不同的成对箱线图。你可能还记得，我们在第7章中加载了`ggpubr`包，并从中调用了`stat_compare_means()`函数，以自动将p值添加到成对的`ggplot2`箱线图中。
- en: We’ll fit our logistic regressions from the base R `glm()` function. We’ll then
    make calls to functions from the `pscl`, `SciViews`, `questionr`, `caret`, and
    `pROC` packages to return model results and provide other insights.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从基础R的`glm()`函数拟合逻辑回归。然后我们将调用`pscl`、`SciViews`、`questionr`、`caret`和`pROC`包中的函数来返回模型结果并提供其他见解。
- en: 'Rather than incrementally loading these packages by making eight successive
    calls to the base R `library()` function, we’ll instead create a vector called
    packages and then pass it to the base R `lapply()` function (you may recall that
    we first called the `lapply()` function back in chapter 3):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会通过连续调用基础R的`library()`函数来逐步加载这些包，而是创建一个名为`packages`的向量，然后将其传递给基础R的`lapply()`函数（你可能还记得我们第一次在第3章中调用`lapply()`函数）：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll import and wrangle our data next, starting with the salaries data set
    we first introduced back in chapter 10\. Remember that the salaries data set contains
    much more than the sum of player salaries for every NBA team between the 2000
    and 2017 seasons; it also includes regular season wins and end-of-season disposition
    for the same.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入并处理我们的数据，从第 10 章中首次介绍的工作薪资数据集开始。记住，薪资数据集包含的不仅仅是 2000 年至 2017 年间每个NBA球队球员薪资的总和；它还包括常规赛胜利和赛季结束情况。
- en: 14.2 Importing and wrangling data
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 导入和数据处理
- en: 'The salaries data set is a .csv file saved in our default working directory;
    the file contains the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 薪资数据集是一个保存在我们默认工作目录的 .csv 文件；文件包含以下内容：
- en: Real and inflation-adjusted team payrolls for every NBA team between the 2000
    and 2017 seasons. The real payrolls were obtained from a Boston Celtics fan site
    and the inflation-adjusted payrolls were computed using a tool from [www.usinflationcalculator.com](https://www.usinflationcalculator.com/).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2000 年至 2017 年间每个NBA球队的实付和通胀调整后的薪资。实付薪资是从波士顿凯尔特人球迷网站获得的，而通胀调整后的薪资是使用 [www.usinflationcalculator.com](https://www.usinflationcalculator.com/)
    的工具计算的。
- en: Regular season win totals and postseason results for every team between these
    same seasons. These were scraped from [www.basketball-reference.com](https://www.basketball-reference.com/).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些相同赛季间每个球队的常规赛胜利总数和季后赛结果。这些数据是从 [www.basketball-reference.com](https://www.basketball-reference.com/)
    爬取的。
- en: 'We make a call to the `read_csv()` function from the `readr` package to import
    the salaries data set:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `read_csv()` 函数从 `readr` 包中导入薪资数据集：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The salaries data set contains more data than we need and, at the same time,
    not enough data; furthermore, it isn’t even formatted in a way that best suits
    our needs. Thus, we need to run a series of data wrangling operations—subsetting
    data, reshaping data sets, creating derived variables, and joining salaries with
    other data sets—before we can run any statistical tests and fit any models.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 薪资数据集包含比我们所需更多的数据，同时也不够用；此外，它甚至没有以最适合我们需求的方式格式化。因此，在我们能够运行任何统计测试和拟合任何模型之前，我们需要运行一系列数据处理操作——数据子集、数据集重塑、创建派生变量以及将薪资与其他数据集合并。
- en: 14.2.1 Subsetting and reshaping our data
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 数据子集和重塑
- en: 'We begin by making a pair of calls to the `select()` function from the `dplyr`
    package to subset salaries into two new data sets named first_salaries and second_salaries:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 `dplyr` 包中的 `select()` 函数，对薪资进行子集化，创建两个新的数据集，分别命名为 first_salaries 和 second_salaries：
- en: The first_salaries data set contains the variable `Team`, as well as the variables
    `w2017` through `w2008`. `Team` is a character string that includes the full name
    of every NBA team, and `w2017` through `w2008` are numeric variables that include
    their regular season win totals.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一份薪资数据集包含变量 `Team` 以及变量 `w2017` 到 `w2008`。`Team` 是一个包含每个NBA球队全名的字符串，而 `w2017`
    到 `w2008` 是包含它们常规赛胜利总数的数值变量。
- en: 'The second_salaries data set contains the variable `Team` plus the variables
    `pc2017` through `pc2008`. For now, `pc2017` through `pc2008` are numeric variables,
    but their cells are actually populated with one of just three season-ending, or
    postseason, result factors:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二份薪资数据集包含变量 `Team` 以及变量 `pc2017` 到 `pc2008`。目前，`pc2017` 到 `pc2008` 是数值变量，但它们的单元格实际上填充了三种季节结束或季后赛结果因素之一。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we make a pair of calls to the `tidyr pivot_longer()` function to transpose
    the first_salaries and second_salaries data sets from wide to long formats.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `tidyr pivot_longer()` 函数，将 first_salaries 和 second_salaries 数据集从宽格式转换为长格式。
- en: In the first chunk of the following code, we pass first_salaries to the `pivot_longer()`
    function, where the variables `w2017` through `w2008` are converted to factors
    within a new variable called `year`, and their former values roll up under another
    a new variable called `wins`. The results are cast to a tibble called first_stats.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码的第一个代码块中，我们将 first_salaries 传递给 `pivot_longer()` 函数，其中 `w2017` 到 `w2008`
    变量被转换成名为 `year` 的新变量中的因素，并且它们的旧值汇总到另一个名为 `wins` 的新变量中。结果被转换成名为 first_stats 的 tibble。
- en: 'In the second code chunk, the second_salaries data set is passed to the `pivot_
    longer()` function, where new variables called `season` and `playoffs` take the
    place of `pc2017` through `pc2008`. These results are then cast to yet another
    tibble called second_stats:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个代码块中，second_salaries 数据集被传递给 `pivot_longer()` 函数，其中新的变量 `season` 和 `playoffs`
    取代了 `pc2017` 到 `pc2008`。然后，这些结果被转换成另一个名为 second_stats 的 tibble。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The base `R dim()` function returns the row and column counts for first_stats;
    it contains 300 rows, or one row for every unique team and year combination, and
    three columns. The `head``()` and `tail()` functions, also from base R, return
    the first three and last three observations, respectively, from first_stats. By
    default, R returns six records, but you can tell R to return any number of records
    you want. Here, we’re instructing R to just return three records each time:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R的`dim()`函数返回`first_stats`的行和列数；它包含300行，即每个独特的队伍和年份组合一行，以及三列。`head()`和`tail()`函数，同样来自基础R，分别返回`first_stats`中的前三个和最后三个观测值。默认情况下，R返回六条记录，但你可以告诉R返回你想要的任何数量的记录。在这里，我们指示R每次只返回三条记录：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then run these same three commands a second time, but we swap out the first_
    stats tibble in favor of second_stats in the process:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着再次运行这三个相同的命令，但在过程中用第二个_stats替换了第一个_stats：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As a result, we now have two working data sets that are longer than their predecessors;
    each record in each object now contains a unique team and season combination complemented
    by regular season wins (in the case of first_stats) or season-ending results (in
    the case of second_stats). These are objects from which we can create derived
    variables, join with other data sets, and then ultimately drop into statistical
    tests and statistical models.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有两个比前辈更长的有效数据集；每个对象中的每条记录现在都包含一个独特的队伍和赛季组合，并辅以常规赛胜利（在`first_stats`的情况下）或赛季结束结果（在`second_stats`的情况下）。这些是从中可以创建派生变量、与其他数据集合并，然后最终用于统计测试和统计模型的对象。
- en: 14.2.2 Extracting a substring to create a new variable
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 提取子字符串以创建新变量
- en: In our next upcoming code chunk, we call the `dplyr mutate()` function in tandem
    with the `str_sub()` function from the `stringr` package, which is part of the
    `tidyverse,` to convert all the elements in the variable `year` to a more readable
    and practical format where, for instance, `w2017` becomes simply `2017`. If for
    no other reason, our plots will make that much more sense if they include just
    the year rather than the year preceded by a single-byte character that once indicated
    regular season wins but has since been repurposed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将到来的代码块中，我们同时调用`dplyr mutate()`函数和`stringr`包中的`str_sub()`函数，后者是`tidyverse`的一部分，将变量`year`中的所有元素转换为更易读和实用的格式，例如，`w2017`变为简单的`2017`。如果只是为了这个原因，我们的图表如果只包含年份而不是前面跟着一个单字节字符的年份，那么它们就会更有意义，这个字符曾经表示常规赛胜利，但现在已经重新分配了用途。
- en: 'The `mutate()` function is called to create a new variable called `season`
    derived from the variable `year`, which is a character string. Then, we call the
    `str_sub()` function so that our new variable is a character vector but also a
    substring of `year`. The `str_sub()` function takes three arguments: the first
    is the name of the character string that requires manipulation; the second and
    third arguments are the start and end positions, going from right to left, that
    require extraction. We’re extracting the first through the fourth characters,
    so `-4` and `-1` are therefore our next two arguments. Then we call the `select()`
    function to subset the first_stats data set on every variable but `year`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`mutate()`函数创建一个名为`season`的新变量，该变量是从字符字符串变量`year`派生出来的。然后，我们调用`str_sub()`函数，使我们的新变量成为一个字符向量，同时也是`year`的子字符串。`str_sub()`函数接受三个参数：第一个是需要操作的字符字符串的名称；第二个和第三个参数是需要从右到左提取的起始和结束位置。我们提取的是第一个到第四个字符，因此`-4`和`-1`是我们的下一个两个参数。然后我们调用`select()`函数，对除了`year`之外的所有变量对`first_stats`数据集进行子集化。
- en: 'Finally, we call the base R `as.factor()` function to convert our new variable
    from a character string to a factor variable. The `head()` function returns the
    first three records in the new and improved first_stats data set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用基础R的`as.factor()`函数将我们的新变量从字符字符串转换为因子变量。`head()`函数返回新改进的`first_stats`数据集中的前三条记录：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After all that, we merely replaced the variable `year`, which was a character
    string (e.g., `w2017`, `w2016`, etc.), with the variable `season`, which is a
    factor variable (e.g., `2017`, `2016`, etc.).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们仅仅将变量`year`（例如，`w2017`、`w2016`等，是一个字符字符串）替换为变量`season`（例如，`2017`、`2016`等，是一个因子变量）。
- en: 14.2.3 Joining data
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 合并数据
- en: 'With respect to second_stats, we again make a call to the `dplyr select()`
    function to reduce it to only contain the variable `playoffs`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`second_stats`，我们再次调用`dplyr select()`函数，将其缩减为只包含`playoffs`变量：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can join first_stats and second_stats and make a new data set by calling
    the `cbind()` function from base R. Whereas first_stats has a 300 × 3 dimension
    and second_ stats now has a 300 × 1 dimension, our new data set, stats, contains
    300 rows and four columns. We then call the `head()` function so that R returns
    the first three records:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用基础R的`cbind()`函数将first_stats和second_stats连接起来，并通过调用`cbind()`函数创建一个新的数据集。由于first_stats具有300
    × 3的维度，而second_stats现在具有300 × 1的维度，我们的新数据集stats包含300行和四列。然后我们调用`head()`函数，以便R返回前三条记录：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have a single data set that contains regular season wins and season-end
    results for every unique team and season combination.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含每个独特球队和赛季组合常规赛胜利和赛季末结果的单一数据集。
- en: 14.2.4 Importing and wrangling additional data sets
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.4 导入和整理额外的数据集
- en: 'We have 10 additional .csv files to import. Each .csv file contains a season’s
    worth of team-level statistics such as wins and losses, points scored per game,
    and the average difference between points scored and points allowed. The data
    was scraped and copied from the NBA’s official website and pasted into Microsoft
    Excel; the files were then saved with .csv extensions and subsequently stored
    in our default working directory. We therefore call the `read_csv()` function
    10 times to import these 10 files:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有10个额外的.csv文件需要导入。每个.csv文件包含一个赛季的团队级统计数据，例如胜负、每场比赛得分以及得分与失分的平均差。数据是从NBA官方网站抓取并复制到Microsoft
    Excel中的；然后文件以.csv扩展名保存，并随后存储在我们的默认工作目录中。因此我们调用`read_csv()`函数10次来导入这10个文件：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Each of these files contains 30 rows, or one row per team, and 27 columns of
    data. We then call the base R `rbind()` function to merge these 10 data sets into
    one data set called nba:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的每一个都包含30行，即每个球队一行，以及27列的数据。然后我们调用基础R的`rbind()`函数将这些10个数据集合并成一个名为nba的数据集：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A call to the `dim()` function then returns the row and column counts. This
    confirms that (1) while we previously had 30 records for each of the 10 data sets,
    we now have one data set that contains 300 rows (30 records × 10 data sets); and
    (2) we still have 27 columns, or variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`dim()`函数后返回行和列计数。这证实了（1）虽然我们之前每个数据集都有30条记录，但我们现在有一个包含300行（30条记录 × 10个数据集）的数据集；并且（2）我们仍然有27列，或变量：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then we call the `mutate()` function to create a new nba variable called `season`.
    The `rep``()` and `c()` functions populate our new variable, starting at the top,
    with 30 instances of 2017, then 30 instances of 2016, 30 instances of 2015, and
    so on, through 2008\. A subsequent call to the `as.factor()` function converts
    `season` to a factor variable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`mutate()`函数来创建一个新的名为`season`的nba变量。`rep()`和`c()`函数从顶部开始填充我们的新变量，首先是30个2017年的实例，然后是30个2016年的实例，接着是30个2015年的实例，以此类推，直到2008年。随后的调用`as.factor()`函数将`season`转换为因子变量。
- en: 'As stated in previous chapters, it’s always a good practice to validate the
    integrity of infrequent operations *before* calling other data wrangling functions.
    First, we call the `head``()` and `tail()` functions to print the first three
    and last three values in the variable `season`; we should get three instances
    of 2017 and then three instances of 2008\. Then, we call the base R `summary()`
    function where `season`, rather than the entire nba data set, is passed as an
    argument. Because `season` is a factor variable, R will return the row counts
    for each level. We should, of course, get 10 counts of 30 rows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，在调用其他数据处理函数之前验证不频繁操作的完整性总是一个好的做法。首先，我们调用`head()`和`tail()`函数来打印变量`season`中的前三个和最后三个值；我们应该得到三个2017年的实例，然后是三个2008年的实例。然后，我们调用基础R的`summary()`函数，其中`season`而不是整个NBA数据集作为参数传递。因为`season`是一个因子变量，R将返回每个级别的行数。我们当然应该得到30行的10个计数：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Everything checks out, which means we can move forward with further data wrangling
    operations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都检查无误，这意味着我们可以继续进行进一步的数据整理操作。
- en: 'We again call the `mutate()` function to create a derived variable called `O_PTS`,
    which represents the average number of points *allowed* per game. Our data set
    contains a variable called `PTS`, which represents the average number of points
    *scored* per game, and another variable called `PTS_DIFF`, which is the difference
    between points scored and points allowed. So `O_PTS` equals the difference between
    `PTS` and `PTS_DIFF`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次调用`mutate()`函数来创建一个名为`O_PTS`的派生变量，它表示每场比赛允许的平均得分。我们的数据集中有一个名为`PTS`的变量，表示每场比赛的平均得分，还有一个名为`PTS_DIFF`的变量，表示得分和允许得分的差值。因此`O_PTS`等于`PTS`和`PTS_DIFF`之间的差值：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we call the `select()` function to subset nba on the variables `Team`,
    `PTS`, `PTS_DIFF`, `season`, and `O_PTS`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`select()`函数对变量`Team`、`PTS`、`PTS_DIFF`、`season`和`O_PTS`进行子集化nba：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A call the `dplyr glimpse()` function returns the reduced dimension of the
    nba data set as well as a transposed view of the data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`dplyr glimpse()`函数会返回nba数据集的降维视图以及数据的转置视图：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because the remaining columns in nba aren’t necessarily arranged in the most
    logical order, we’ll next demonstrate just one way to reorder columns in R. We’ve
    previously called the `select()` function from the `dplyr` package to subset a
    data set; here, by passing every remaining column in the nba data set, the `select()`
    function rearranges the columns in the order by which they’re passed. Another
    call to the `glimpse()` function returns the results:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为nba中剩余的列不一定按照最合理的顺序排列，所以我们将演示在R中重新排列列的一种方法。我们之前已经调用过`dplyr`包中的`select()`函数来对数据集进行子集化；在这里，通过传递nba数据集中剩余的所有列，`select()`函数按照传递的顺序重新排列列。再次调用`glimpse()`函数返回结果：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `glimpse()` function always returns, from top to bottom, the complete list
    of variables that otherwise run from left to right.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`glimpse()`函数总是从上到下返回完整的变量列表，否则这些变量从左到右排列。'
- en: 14.2.5 Joining data (one more time)
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.5 再次进行数据连接
- en: 'Going back to the stats data set, we call the `as.factor()` function to convert
    the variable `playoffs`, where every record can take on just one of three values,
    to a factor variable. The variable `playoffs` equals `0` when teams failed to
    qualify for postseason play; `playoffs` equals `10` when teams qualified for postseason
    play but were then eliminated; and `playoffs` equals `11` when teams won the NBA
    championship:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回到stats数据集，我们调用`as.factor()`函数将变量`playoffs`转换为因子变量。当球队未能晋级季后赛时，`playoffs`等于`0`；当球队晋级季后赛但随后被淘汰时，`playoffs`等于`10`；当球队赢得NBA冠军时，`playoffs`等于`11`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we call the `dplyr left_join()` function to join the nba and stats data
    sets by the two variables, `Team` and `season`, which they have in common:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`dplyr left_join()`函数，通过两个变量`Team`和`season`（它们在两个数据集中都有）来连接nba和stats数据集：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As a result, nba_stats contains seven columns, or every unique column between
    the nba and stats data sets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，nba_stats包含七个列，或者说nba和stats数据集之间每个唯一的列。
- en: 'Although a left join was used here, any of the join operations, described in
    the following list, would have worked with nba and stats and produced the same
    results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里使用了左连接，但以下列表中描述的任何连接操作都可以与nba和stats一起使用并产生相同的结果：
- en: A left join, or left outer join (as used in the preceding code), merges every
    row in one data set with only matching rows from another data set.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左连接或左外连接（如前述代码所示）将一个数据集中的每一行与另一个数据集中匹配的行合并。
- en: A right join, or right outer join, does the same, but the data sets are switched.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右连接或右外连接做的是同样的事情，但数据集的顺序被交换了。
- en: An outer join, or full outer join, keeps every row from both data sets.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外连接或全外连接保留两个数据集中的每一行。
- en: A natural join, or inner join, keeps only matching rows from both data sets.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然连接或内连接只保留两个数据集中匹配的行。
- en: 'We’ll demonstrate this by successively calling the `dplyr right_join``()`,
    `inner_join``()`, and `full_join` functions and then calling the `head()` function
    four times to return the top three records from each operation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过依次调用`dplyr right_join()`、`inner_join()`和`full_join`函数，然后四次调用`head()`函数来返回每个操作的顶部三条记录：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the results are exactly the same, regardless of what join operation
    was called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，无论调用的是哪种连接操作，结果都是完全相同的。
- en: 14.2.6 Creating standardized variables
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.6 创建标准化变量
- en: Finally, we make three successive calls to the `dplyr group_by``()` and `mutate()`
    functions to standardize three of the four numeric variables in the nba_stats
    data set. Once more, standardization is the process of converting variables to
    the same scale; when these same variables also span several years—and in our case,
    10 NBA seasons, where periodic rule changes and style of play transformations
    make it difficult, even unsound, to compare year-over-year results—standardization
    just makes sense. Furthermore, by standardizing key measures, we get context that
    we can’t get from the raw figures. From a more practical perspective, standardization
    corrects the 2012 regular season win totals because teams didn’t play an 82-game
    regular season schedule that year due to a player strike.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们连续三次调用`dplyr group_by()`和`mutate()`函数，以标准化`nba_stats`数据集中的四个数值变量中的三个。再次强调，标准化是将变量转换为相同尺度的过程；当这些相同的变量还跨越几个年份——在我们的案例中，是10个NBA赛季，其中周期性规则变化和比赛风格的变化使得跨年度比较变得困难，甚至不切实际——标准化就变得很有意义。此外，通过标准化关键指标，我们可以获得从原始数据中无法获得的信息。从更实际的角度来看，标准化纠正了2012年常规赛的胜利总数，因为那年由于球员罢工，球队没有进行82场常规赛。
- en: Variables are standardized by computing their z-scores, which equal the number
    of standard deviations a data point is above or below a population mean. Let’s
    use the variable `wins` as an example. By calling the `mutate()` function, we’re
    creating a new variable called `z_wins`, which is the z-score for regular season
    wins. A z-score is computed by subtracting the mean for wins from actual wins
    and dividing that difference by the standard deviation. By first calling the `group_by()`
    function, we’re instructing R to compute the z-scores annually. Subsequent calls
    to the `round()` function from base R reduce our z-scores to just two digits right
    of the decimal point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算数据点的z分数来标准化变量，这些z分数等于数据点相对于总体平均值的正负标准差数。让我们以变量`wins`为例。通过调用`mutate()`函数，我们创建了一个名为`z_wins`的新变量，它是常规赛胜利的z分数。z分数是通过从胜利的平均值中减去实际胜利数，然后除以这个差值来计算的。通过首先调用`group_by()`函数，我们指示R每年计算z分数。随后的`round()`函数调用从基础R中将我们的z分数减少到小数点后两位。
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `head()` function returns the first three records:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`head()`函数返回前三条记录：'
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s now take a look at the 2017 Atlanta Hawks for a representative example.
    Their 43 regular season wins were 0.18 standard deviations above the mean in 2017,
    which makes sense considering every team played an 82-game regular season schedule
    that year. Their 103.2 points scored per game were 0.58 standard deviations below
    the 2017 mean, so the Hawks finished the 2016-17 season with a winning record
    while scoring fewer points per game than the league average. But the Hawks were
    a much better defensive team; they allowed 104.1 points per game, which was 0.37
    standard deviations below the 2017 mean. This means the 2017 Hawks allowed almost
    one more point per game than they scored.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以2017年的亚特兰大老鹰队为例。他们的43场常规赛胜利比2017年的平均值高出0.18个标准差，这在当年每个球队都进行了82场常规赛的情况下是有道理的。他们的每场比赛得分103.2分，比2017年的平均值低0.58个标准差，因此老鹰队在2016-17赛季以胜利结束，但每场比赛的得分低于联盟平均水平。但老鹰队是一支防守更好的球队；他们每场比赛允许得104.1分，比2017年的平均值低0.37个标准差。这意味着2017年的老鹰队每场比赛允许的得分几乎比他们自己得分多一个。
- en: Next, we’ll create a `ggplot2` bar chart and a `ggplot2` histogram to provide
    some initial insights into our data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`ggplot2`条形图和一个`ggplot2`直方图，以提供对我们数据的初步洞察。
- en: 14.3 Exploring data
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 探索数据
- en: 'To create a bar chart, we first need to summarize our data. We therefore call
    the `group_by``()` and `summarize()` functions from the `dplyr` package to compute
    the mean for the numeric variable `PTS` for each of the 10 NBA seasons in the
    nba_stats data set. Our intent is to display the average points scored per game
    for every NBA season in our data set and to discover any trends during the same.
    The results are rounded to two digits right of the decimal point and then cast
    to a tibble called first_tibble:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建条形图，我们首先需要总结我们的数据。因此，我们调用`dplyr`包中的`group_by()`和`summarize()`函数，计算`nba_stats`数据集中每个10个NBA赛季的数值变量`PTS`的平均值。我们的目的是显示数据集中每个NBA赛季每场比赛的平均得分，并发现任何趋势。结果四舍五入到小数点后两位，然后转换为名为`first_tibble`的tibble：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our `ggplot2` bar chart takes first_tibble as a data source and plots the variable
    `season` along the x-axis and the variable `pts_avg` along the y-axis (see figure
    14.1).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ggplot2`条形图以first_tibble作为数据源，并在x轴上绘制变量`season`，在y轴上绘制变量`pts_avg`（见图14.1）。
- en: '![CH14_F01_Sutton](../../OEBPS/Images/CH14_F01_Sutton.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F01_Sutton](../../OEBPS/Images/CH14_F01_Sutton.png)'
- en: Figure 14.1 The average points scored per game and per team for every NBA season
    between 2008 and 2017
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 2008年至2017年间每个NBA赛季每场比赛和每支球队的平均得分
- en: The `geom_bar()` function instructs R to create a bar chart. By default, R will
    compute and visualize row counts for each value of x; we override that and, in
    the process, tell R to tie each value of x to our y-axis variable by adding the
    `stat = "identity"` argument. Otherwise, the bars are half the default width and
    colored and filled with different shades of steel blue.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_bar()`函数指示R创建一个条形图。默认情况下，R将为每个x值的行计数进行计算和可视化；我们覆盖了这一点，并在过程中通过添加`stat
    = "identity"`参数告诉R将每个x值与我们的y轴变量绑定。否则，条形图的宽度是默认宽度的一半，并且用不同深度的钢蓝色着色和填充。'
- en: 'The `geom_text()` function affixes the y values atop the bars. Because of this
    add, we then need to call the `ylim()` function to extend the length of the y-axis:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_text()`函数将y值附加到条形图的顶部。由于这个添加，我们随后需要调用`ylim()`函数来扩展y轴的长度：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On one hand, we don’t see a tremendous amount of year-over-year variation in
    points scored per game—which, of course, must also equal points allowed per game.
    On the other hand, however, we see a low of 96.26 in 2012 and a high of 105.59
    in 2017, and that difference is significant.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们没有看到每场比赛得分在年与年之间的巨大变化——当然，这也必须等于每场比赛的失分。另一方面，然而，我们看到2012年的最低得分是96.26，2017年的最高得分是105.59，这种差异是显著的。
- en: Next, we plot a histogram to visualize the distribution of the variable `PTS`
    across the entire nba_stats data set (see figure 14.2). Therefore, nba_stats is
    our data source, and `PTS` is our x-axis variable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们绘制一个直方图来可视化整个nba_stats数据集中变量`PTS`的分布（见图14.2）。因此，nba_stats是我们的数据源，`PTS`是我们的x轴变量。
- en: '![CH14_F02_Sutton](../../OEBPS/Images/CH14_F02_Sutton.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F02_Sutton](../../OEBPS/Images/CH14_F02_Sutton.png)'
- en: Figure 14.2 The distribution of points per game for every NBA team between 2008
    and 2017
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 2008年至2017年间每个NBA球队的每场比赛得分分布
- en: Our histogram will contain 15 bins. The number of bins should scale with the
    record count in your data. One rule of thumb suggests the number of bins should
    approximately equal the square root of the record count, with a not-to-exceed
    equal to 20\. We have 300 observations in the nba_stats data set; the square root
    of 300 equals 17.3, so 15 bins by this rule seems appropriate enough.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的历史图将包含15个箱。箱的数量应该与你的数据中的记录数成比例。一个经验法则建议箱的数量应该大约等于记录数的平方根，不超过20。我们在nba_stats数据集中有300个观测值；300的平方根等于17.3，所以按照这个规则，15个箱似乎足够合适。
- en: 'A pair of calls to the `geom_line()` function tells R to draw two vertical
    lines, a dashed line that represents the population mean and a solid line—`ggplot2`
    lines default to solid—that represents the population median:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`geom_line()`函数两次指示R绘制两条垂直线，一条表示人口平均值的虚线，另一条表示人口中位数——`ggplot2`的线条默认为实线：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It appears that the variable `PTS` takes on a normal, or Gaussian, distribution.
    In other words, the distribution is symmetric about the mean, where the most frequent
    occurrences in the data are near the mean and the most infrequent occurrences
    are farthest from the mean.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来变量`PTS`具有正态分布，或者说高斯分布。换句话说，分布关于平均值对称，数据中最频繁出现的值接近平均值，最不频繁出现的值离平均值最远。
- en: 'But visual inspection isn’t always reliable. Therefore, we next call the `shapiro.test()`
    function from base R to run a Shapiro-Wilk test, which is probably the most common
    normality test. In the case of a Shapiro-Wilk test, we’re looking for a p-value
    above 0.05 to assume normality:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但视觉检查并不总是可靠的。因此，我们接下来调用基础R中的`shapiro.test()`函数来运行Shapiro-Wilk测试，这可能是最常见的正态性测试。在Shapiro-Wilk测试的情况下，我们寻找的p值高于0.05以假设正态性：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because the p-value is less than the 0.05 significance cutoff, we should assume
    the distribution of the variable `PTS` from the nba_stats data set isn’t (quite)
    normal, despite appearances to the contrary. This is something to keep in mind
    as we conduct our tests, which we’ll turn to next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于p值小于0.05的显著性阈值，我们应该假设来自nba_stats数据集的变量`PTS`的分布不是（相当）正态分布，尽管表面上看起来相反。这是我们进行测试时需要注意的事情，我们将在下一部分进行讨论。
- en: 14.4 Correlations
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 相关性
- en: We begin by computing and comparing the correlation coefficients between `z_wins`
    and `z_o_pts` versus `z_wins` and `z_pts`. So we’re first computing the correlation
    coefficient between the standardized versions of regular season wins and points
    allowed and then computing the same between the standardized versions of wins
    and points scored. If points allowed matters more in terms of regular season wins
    than does points scored, or if defense matters more than offense, `z_o_pts` should
    have a stronger correlation with `z_wins` than `z_pts` has with `z_wins`. Then,
    we’ll run a pair of correlation tests with the same combination of variables—and
    make similar assumptions based on a comparison of the p-values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算并比较`z_wins`和`z_o_pts`与`z_wins`和`z_pts`之间的相关系数。因此，我们首先计算常规赛胜利和让分标准化的相关系数，然后计算胜利和得分的标准化版本之间的相同系数。如果让分在常规赛胜利方面比得分更重要，或者如果防守比进攻更重要，`z_o_pts`与`z_wins`的相关性应该比`z_pts`与`z_wins`的相关性更强。然后，我们将运行一对相关系数测试，使用相同的变量组合，并基于p值的比较做出类似的假设。
- en: 14.4.1 Computing and plotting correlation coefficients
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.1 计算和绘制相关系数
- en: 'Computing correlation coefficients in R is easy enough; we simply call the
    `cor()` function from base R and pass two numeric variables:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中计算相关系数足够简单；我们只需从基础R调用`cor()`函数，并传递两个数值变量：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So points allowed does have a stronger correlation with wins (-0.58) than does
    points scored (0.53), but the difference in the two correlation coefficients is
    negligible. They are, in fact, almost equally distant from being perfectly neutral,
    which doesn’t at all suggest that defense matters materially more than offense,
    at least as far as regular season wins between 2008 and 2017 are concerned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让分与胜利的相关性（-0.58）确实比得分（0.53）更强，但这两个相关系数的差异是可以忽略不计的。实际上，它们几乎同样远离完全中性的状态，这根本不表明防守在物质上比进攻更重要，至少就2008年至2017年间的常规赛胜利而言。
- en: Correlation coefficients are well visualized with correlation plots, often called
    scatterplots. These are constructed in `ggplot2` by passing the data source and
    two numeric variables as arguments to the `ggplot()` function and then calling
    the `geom_point()` function (see figure 14.3).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数可以通过相关图（通常称为散点图）很好地可视化。这些图在`ggplot2`中通过将数据源和两个数值变量作为参数传递给`ggplot()`函数，然后调用`geom_point()`函数来构建（见图14.3）。
- en: '![CH14_F03_Sutton](../../OEBPS/Images/CH14_F03_Sutton.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F03_Sutton](../../OEBPS/Images/CH14_F03_Sutton.png)'
- en: Figure 14.3 The correlation between points allowed and wins is visualized on
    the left; the correlation between points scored and wins is visualized on the
    right.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 左侧可视化展示了让分与胜利的相关性；右侧可视化展示了得分与胜利的相关性。
- en: 'The `geom_smooth()` function adds a linear regression line and, by default,
    95% confidence intervals above and below the line—which we’re overriding by adding
    the argument `se = FALSE` to `geom_smooth()`. The `xlim()` function ensures that
    the x-axes of both plots match one another. The first of our two correlation plots,
    p1, visualizes the correlation between points allowed and wins, while our second
    correlation plot, p2, visualizes the correlation between points scored and wins:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`geom_smooth()`函数添加了一条线性回归线，并且默认情况下，在线上和线下添加了95%的置信区间——我们通过向`geom_smooth()`添加参数`se
    = FALSE`来覆盖这些置信区间。`xlim()`函数确保两个图表的x轴相互匹配。我们两个相关系数图表中的第一个，p1，可视化展示了让分与胜利的相关性，而我们的第二个相关系数图表，p2，可视化展示了得分与胜利的相关性：'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then call the `plot_layout()` function from the `patchwork` package to bundle
    p1 and p2 into a single object where the two plots are placed side by side for
    easy purposes of comparison (see figure 14.3):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后从`patchwork`包中调用`plot_layout()`函数，将p1和p2组合成一个单一的对象，这样两个图表就可以并排放置，便于比较（见图14.3）：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These two plots are basically mirror images of each other.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个图表基本上是彼此的镜像。
- en: Let’s plot the net correlation coefficient between `O_PTS` and `wins` and `PTS`
    and `wins` by season. We’ll first need to create another summarization of the
    nba_stats data set. Therefore, we make another call to the `dplyr group_by``()`
    and `summarize()` functions which, together, compute the absolute difference—note
    the calls to the base R `abs()` function—between the `PTS` and `wins` correlation
    coefficient and the `O_PTS` and `wins` correlation coefficient for each NBA season
    in the nba_stats data set. Because we’re subsetting these results by season, it’s
    perfectly appropriate to use the raw data rather than their standardized equivalents
    (e.g., `wins` rather than `z_wins`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按赛季绘制`O_PTS`和`wins`以及`PTS`和`wins`之间的净相关系数。首先，我们需要创建nba_stats数据集的另一个汇总。因此，我们再次调用`dplyr
    group_by()`和`summarize()`函数，这两个函数一起计算了每个NBA赛季在nba_stats数据集中`PTS`和`wins`的相关系数与`O_PTS`和`wins`的相关系数之间的绝对差异——注意调用基础R的`abs()`函数。由于我们按赛季子集化这些结果，使用原始数据而不是它们的标准化等效值（例如，`wins`而不是`z_wins`）是完全可以接受的。
- en: 'The results are rounded to two digits right of the decimal point and then cast
    to a tibble called second_tibble:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结果四舍五入到小数点后两位，然后转换为一个名为second_tibble的tibble：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We then visualize these results with a second `ggplot2` bar chart (see figure
    14.4). Once again, we call the `geom_text()` function to add labels just beyond
    the “height” of the bars that tie back to our y-axis variable, `cor_dif`, which
    we just created and threw into second_tibble.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用第二个`ggplot2`柱状图可视化这些结果（见图14.4）。再次调用`geom_text()`函数，在柱子“高度”之外添加标签，这些标签与我们的y轴变量`cor_dif`相关，这是我们刚刚创建并放入second_tibble中的。
- en: '![CH14_F04_Sutton](../../OEBPS/Images/CH14_F04_Sutton.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F04_Sutton](../../OEBPS/Images/CH14_F04_Sutton.png)'
- en: Figure 14.4 Annual differences in correlation coefficients between points scored
    and wins versus points allowed and wins
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4得分与胜利以及得分允许与胜利之间的相关系数的年度差异
- en: Because our bar chart contains a combination of positive and negative results,
    the alignment of our labels, which we control by calling the `vjust``()` and `hjust()`
    functions, requires some additional logic. We therefore make two calls to the
    base R `ifelse()` function to control, or customize, the alignment of our labels
    contingent upon the variable `cor_dif` being a nonnegative or negative number.
    If `cor_dif` is equal to or greater than `0`, the vertical adjustment of our labels
    should equal `-0.5`, and the horizontal adjustment of the same should equal `0.5`;
    if that condition isn’t met, the vertical and horizontal adjustments should equal
    `1.3` and `0.5`, respectively.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的柱状图包含正负结果组合，我们通过调用`vjust()`和`hjust()`函数来控制的标签对齐，需要一些额外的逻辑。因此，我们调用两次基础R的`ifelse()`函数来控制或自定义标签的对齐，这取决于变量`cor_dif`是否为非负数或负数。如果`cor_dif`等于或大于`0`，我们标签的垂直调整应等于`-0.5`，而水平调整应等于`0.5`；如果该条件不满足，垂直和水平调整应分别等于`1.3`和`0.5`。
- en: 'To fit the labels inside our bar chart, we need to make a call to the `ylim()`
    function and thereby extend the length of the y-axis:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将标签放入我们的柱状图中，我们需要调用`ylim()`函数，从而延长y轴的长度：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each bar represents the absolute difference in the correlation coefficients
    between `PTS` and `wins` and between `O_PTS` and `wins`. Take the 2010 season
    as an example—the correlation coefficient between `PTS` and `wins` minus the correlation
    coefficient between `O_PTS` and `wins` equals `-0.16`. In other words, in 2010,
    `O_PTS` had a stronger correlation with `wins` than did `PTS`, which suggests
    that defense then mattered more than offense. In fact, points allowed had stronger
    correlations with regular season wins every year between 2008 and 2011, but then
    points scored had stronger correlations with wins than points allowed in four
    of the next six NBA seasons.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个柱子代表`PTS`和`wins`以及`O_PTS`和`wins`之间的相关系数的绝对差异。以2010赛季为例——`PTS`和`wins`之间的相关系数减去`O_PTS`和`wins`之间的相关系数等于`-0.16`。换句话说，在2010年，`O_PTS`与`wins`的相关性比`PTS`更强，这表明当时的防守比进攻更重要。事实上，从2008年到2011年，每年允许的得分与常规赛胜利的相关性都更强，但在接下来的六个NBA赛季中，得分与胜利的相关性比允许的得分与胜利的相关性更强。
- en: Our bar chart gives us a year-over-year view of what might be the relative significance
    between points scored versus points allowed with respect to regular season wins;
    this is a perspective we don’t get merely by computing the correlation coefficients
    across the entire data series. Our results suggest that, more recently, offense
    has actually mattered more than defense. But the differences are usually negligible
    either way; at the very least, between 2012 and 2017, we haven’t seen differences
    in correlation coefficients like those in 2009 and 2011.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的条形图给出了得分与允许得分相对于常规赛胜利的相对重要性的年度视图；这是仅仅通过在整个数据系列中计算相关系数所无法获得的视角。我们的结果表明，最近，进攻实际上比防守更重要。但差异通常是可以忽略不计的；至少在2012年至2017年之间，我们没有看到像2009年和2011年那样的相关系数差异。
- en: 14.4.2 Running correlation tests
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.2 运行相关测试
- en: Even when a correlation coefficient equals some number other than 0, it may
    or may not be significantly different from 0, at least in any statistical sense,
    which is why a correlation test adds value. A correlation test, like other statistical
    tests, returns a p-value that, based on a predefined 5% significance level, we
    can either reject or fail to reject a null hypothesis of no correlation. Our null
    hypothesis is that there is no meaningful relationship or correlation; we’ll reject
    this hypothesis if the returned p-value is less than or equal to 0.05 or fail
    to reject it if otherwise.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使相关系数等于除0以外的某个数字，它可能或可能不显著地不同于0，至少在统计意义上是这样，这就是为什么相关测试能增加价值。与其它统计测试一样，相关测试返回一个p值，基于预定义的5%显著性水平，我们可以拒绝或无法拒绝无相关性的零假设。我们的零假设是没有任何有意义的关系或相关性；如果返回的p值小于或等于0.05，我们将拒绝这个假设；否则，我们将无法拒绝它。
- en: We therefore call the base R `cor.test()` function twice to run a pair of correlation
    tests, the first between `z_wins` and `z_o_pts` and the second between `z_wins`
    and `z_pts`. Our purpose here is to compare and contrast the results between points
    allowed and points scored versus regular season wins. If defense matters more
    than offense, we should expect our first correlation test to return a lower p-value
    than our second correlation test.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们调用基础R的`cor.test()`函数两次来运行一对相关测试，第一次是`z_wins`和`z_o_pts`之间的相关测试，第二次是`z_wins`和`z_pts`之间的相关测试。我们的目的是比较和对比允许得分与得分以及常规赛胜利之间的结果。如果防守比进攻更重要，我们预计我们的第一次相关测试将返回比第二次相关测试更低的p值。
- en: 'But first, we call the `options()` function from base R and pass the `scipen
    = 999` argument to disable scientific notation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们调用基础R的`options()`函数，并传递`scipen = 999`参数来禁用科学记数法：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Both correlations are statistically significant due to the fact that the p-value
    for both tests is less than the 0.05 significance threshold; in fact, the p-values
    are exactly the same between the two correlation tests, thereby suggesting no
    material difference between points allowed and points scored versus regular season
    wins.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个测试的p值都小于0.05的显著性阈值，因此两个相关测试都是统计显著的；事实上，两个相关测试之间的p值完全相同，这表明允许得分与得分以及常规赛胜利之间没有实质性的差异。
- en: Based on these results—and these results alone, for we have additional tests
    to perform—we can’t conclude that points allowed are more significant than points
    scored or that defense matters more than offense when it comes to regular season
    wins. Next, we’ll fit a pair of one-way ANOVA models.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些结果——仅基于这些结果，因为我们还有额外的测试要执行——我们不能得出结论说允许得分比得分更重要，或者防守在常规赛胜利中比进攻更重要。接下来，我们将拟合一对单因素ANOVA模型。
- en: 14.5 Analysis of variance models
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5 方差分析模型
- en: Whereas a t-test is a statistical test that determines whether or not the means
    from *two* data series are significantly different, analysis of variance (ANOVA)
    is a method that determines if the means from *three or more* data series are
    statistically different from each other. We’ll wrangle our data some first, visualize
    the same, and then fit and evaluate a pair of ANOVA models. Otherwise, we’ll continue
    evaluating regular season wins and points scored versus points allowed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 而t测试是一种统计测试，用于确定两个数据系列的平均值是否有显著差异，方差分析（ANOVA）是一种方法，用于确定三个或更多数据系列的平均值是否在统计上彼此不同。我们首先整理数据，进行可视化，然后拟合并评估一对ANOVA模型。否则，我们将继续评估常规赛胜利与得分以及允许得分。
- en: 14.5.1 Data wrangling and data visualization
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.1 数据处理和可视化
- en: 'ANOVAs require a categorical predictor variable and a quantitative target variable.
    We have a quantitative dependent variable in `z_wins`, but we don’t *yet* have
    any categorical predictor variables. In the following chunk of code, we call the
    `dplyr mutate``()` and `case_when()` functions to create a new categorical variable,
    `o_pts_cat`, derived from the variable `z_o_points`. When `z_o_pts` is less than
    -1, `o_pts_cat` equals `A`; when `z_o_pts` is greater than or equal to -1 and
    less than 0, `o_pts_cat` equals `B`; when `z_o_pts` is equal to or greater than
    0 and less than or equal to 1, `o_pts_cat` equals `C`; and when `z_o_pts` is greater
    than 1, `o_pts_cat` equals `D`. Our new variable is then converted to a factor
    by calling the base R `as.factor()` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ANOVA需要分类预测变量和定量目标变量。我们在`z_wins`中有一个定量因变量，但我们还没有*任何*分类预测变量。在下面的代码块中，我们调用`dplyr
    mutate()`和`case_when()`函数来创建一个新分类变量`o_pts_cat`，该变量是从`z_o_points`变量派生出来的。当`z_o_pts`小于-1时，`o_pts_cat`等于`A`；当`z_o_pts`大于或等于-1且小于0时，`o_pts_cat`等于`B`；当`z_o_pts`等于或大于0且小于或等于1时，`o_pts_cat`等于`C`；当`z_o_pts`大于1时，`o_pts_cat`等于`D`。然后，我们通过调用基础R的`as.factor()`函数将新变量转换为因子：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we call the `mutate``()` and `case_when()` functions again to create
    a like variable derived from `z_pts`. This variable, too, is then converted to
    a factor by again calling the `as.factor()` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次调用`mutate()`和`case_when()`函数，从`z_pts`创建一个类似变量。这个变量也是通过再次调用`as.factor()`函数转换为因子的：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then make a pair of calls to the base R `summary()` function to return the
    record counts for each factor level, or category, in the variables `o_pts_cat`
    and `pts_cat`. For numeric variables, the `summary()` function returns a series
    of basic, or descriptive, statistics, but for factor variables such as the two
    we just created, `summary()` instead returns the record counts:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用基础R的`summary()`函数两次，以返回变量`o_pts_cat`和`pts_cat`中每个因子级别或类别的记录数。对于数值变量，`summary()`函数返回一系列基本或描述性统计量，但对于我们刚刚创建的两个因子变量，`summary()`函数则返回记录数：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Most significantly, there are no Not Availables (NAs, or missing data), so we’ve
    successfully assigned a `o_pts_cat` and `pts_cat` category to every record in
    the nba_stats data set. Otherwise, these variables equal `B` or `C` for more than
    two-thirds of the 300 observations in our data set, which means more than two-thirds
    of the NBA teams between the 2008 and 2017 seasons were within ± one standard
    deviation from the league mean in points allowed and points scored.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，没有不可用（NAs，或缺失数据），因此我们已经成功地为`nba_stats`数据集中的每个记录分配了`o_pts_cat`和`pts_cat`类别。否则，这些变量在300个观测值中的三分之二以上等于`B`或`C`，这意味着在2008年至2017赛季之间，超过三分之二的NBA球队在得分和失分上与联盟平均值的±一个标准差范围内。
- en: 'Let’s plot how well, or not so well, `o_pts_cat` and `pts_cat` are associated
    with the variable `z_wins` through two series of boxplots. But first, here’s a
    quick refresher on boxplots, which are sometimes referred to as box and whisker
    plots:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过两个系列的箱线图来绘制`o_pts_cat`和`pts_cat`与变量`z_wins`的相关性，或者不相关性。但首先，这里有一个关于箱线图的快速复习，箱线图有时也被称为箱线和胡须图：
- en: The box represents the Interquartile Range (IQR), or every data point between
    the 25th and 75th percentiles; the IQR therefore contains the middle 50% of the
    data.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱子代表四分位距（IQR），或位于第25百分位数和第75百分位数之间的每个数据点；因此，IQR包含了数据中间的50%。
- en: The whiskers, or the lines extending from the top and bottom of the box, represent
    the upper and lower quartiles.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胡须，或从箱子顶部和底部延伸出的线条，代表上四分位数和下四分位数。
- en: Any data points beyond the whiskers are considered outliers; this data is approximately
    three standard deviations or more from the population median.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何超出胡须的数据点都被认为是异常值；这些数据点与总体中位数相比大约有三个标准差或更多。
- en: The horizontal line in each box represents the population median; R automatically
    draws this line for us.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个箱子中的水平线代表总体中位数；R会自动为我们绘制这条线。
- en: 'Our first series of boxplots, p3, points to the nba_stats data set. These box
    plots are a bit different from those we have previously created; here’s what you
    need to know before we introduce the code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一系列箱线图，p3，指向`nba_stats`数据集。这些箱线图与我们之前创建的不同；在我们介绍代码之前，你需要了解以下内容：
- en: Inside the `aes()` function, we’re passing `o_pts_cat` as our x-axis variable
    and `z_wins` as our y-axis variable, so we’re visualizing the distribution of
    standardized regular season wins by each factor level in `o_pts_cat`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`aes()`函数内部，我们传递`o_pts_cat`作为我们的x轴变量，`z_wins`作为我们的y轴变量，因此我们正在通过`o_pts_cat`中的每个因素水平可视化标准化的常规赛胜利数的分布。
- en: Additionally, we’re passing `o_pts_cat` to equal the fill, which means our boxplots
    will take on the default `ggplot2` palette rather than a designated or uniform
    fill. Recall that `fill` defines the color by which a geom is filled, whereas
    the color argument defines the boundary color.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们将`o_pts_cat`传递给填充，这意味着我们的箱线图将采用默认的`ggplot2`调色板，而不是指定的或统一的填充。回想一下，`fill`通过几何形状的填充颜色来定义，而颜色参数定义了边界颜色。
- en: 'We’ve added two optional arguments to the `geom_boxplot()` function:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向`geom_boxplot()`函数添加了两个可选参数：
- en: When `notch` equals `TRUE` (the default is `FALSE`), we’re instructing R to
    draw notched, rather than standard, boxplots. From a visual perspective, the notch
    “squeezes” the box around the median; from a statistical perspective, the notch
    is a display of the confidence interval around the median. The value added is
    that notches are used to compare groups; if and when the notches of two or more
    boxes do *not* overlap, we have strong evidence that the medians are significantly
    different. And while we’re more interested in group means than medians, the two
    measures are in fact very close to each other, regardless of the `o_pts_cat` factor
    level.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`notch`等于`TRUE`（默认为`FALSE`）时，我们指示R绘制带凹槽的箱线图而不是标准箱线图。从视觉角度来看，凹槽“挤压”了中位数周围的箱子；从统计角度来看，凹槽是中位数周围置信区间的显示。其附加价值在于凹槽用于比较组别；如果两个或更多箱子的凹槽没有重叠，我们就有了强有力的证据表明中位数有显著差异。尽管我们更感兴趣的是组均值而不是中位数，但这两个度量实际上非常接近，无论`o_pts_cat`因素水平如何。
- en: The second argument inside the `boxplot()` function, `alpha`, adjusts the opacity
    of the boxes; in fact, the `alpha` argument can be passed to adjust the opacity
    of any geom. Values must range from `0` to `1`, where lower values equal more
    opacity.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boxplot()`函数中的第二个参数`alpha`调整了箱子的不透明度；实际上，`alpha`参数可以被传递来调整任何几何形状的不透明度。值必须在`0`到`1`之间，其中较低的值等于更高的不透明度。'
- en: By calling the `stat_summary()` function, we’re adding a solid white dot to
    each box that represents the mean.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`stat_summary()`函数，我们在每个代表均值的箱中添加了一个实心白色点。
- en: We’re adding a legend and positioning it at the bottom of each plot. Legends
    can be placed almost anywhere, including inside the plot itself.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个图例并将其放置在每个图的底部。图例几乎可以放置在任何地方，包括在图内部。
- en: Finally, a call to the `scale_fill_discrete()` function allows us to customize
    the legend name and legend labels. By default, our legend would otherwise be named
    `o_pts_cat`, and the labels would equal the `o_pts_cat` factor levels—neither
    of which would be very intuitive.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，调用`scale_fill_discrete()`函数允许我们自定义图例名称和图例标签。默认情况下，我们的图例将被命名为`o_pts_cat`，标签将与`o_pts_cat`因素水平相等——这两者都不太直观。
- en: 'The code chunk just described follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前描述的代码块所示：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our second series of boxplots, p4, is similar to p3, except that we’ve swapped
    out `o_pts_cat` in favor of `pts_cat` as our x-axis variable and fill. So here,
    we’re plotting the distribution of standardized regular season wins against each
    factor level in `pts_cat`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个箱线图系列，p4，与p3相似，除了我们将`o_pts_cat`替换为`pts_cat`作为我们的x轴变量和填充。因此，在这里，我们正在绘制标准化的常规赛胜利数的分布与`pts_cat`中的每个因素水平的对比：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our two plots have been held in memory. We then bundle p3 and p4 together by
    calling the `plot_layout()` function from the `patchwork` package and print our
    boxplots as one graphical object (see figure 14.5):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个图已经被保存在内存中。然后我们通过调用`patchwork`包中的`plot_layout()`函数将p3和p4捆绑在一起，并将我们的箱线图打印为一个图形对象（见图14.5）：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![CH14_F05_Sutton](../../OEBPS/Images/CH14_F05_Sutton.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F05_Sutton](../../OEBPS/Images/CH14_F05_Sutton.png)'
- en: Figure 14.5 On the left, four standardized points allowed categories are plotted
    against standardized regular season wins; on the right, four standardized points
    scored categories are plotted against standardized regular season wins.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 在左侧，四个标准化的允许类别点与标准化的常规赛胜利数进行对比；在右侧，四个标准化的得分类别点与标准化的常规赛胜利数进行对比。
- en: Clearly, teams that were more successful on defense or offense between the 2008
    and 2017 NBA seasons were generally more successful in the regular season. Furthermore,
    it appears that we don’t have overlapping notches in either plot, thereby suggesting
    the potential for variances that are statistically significant.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在 2008 年至 2017 年 NBA 赛季中防守或进攻表现更成功的队伍在常规赛中通常也表现更出色。此外，两个图中似乎都没有重叠的凹槽，这表明可能存在统计上显著的方差。
- en: 14.5.2 One-way ANOVAs
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5.2 单因素 ANOVA
- en: Let’s now conduct a pair of one-way ANOVAs—“one-way” because we’re analyzing
    how just *one* predictor variable, `o_pts_cat` and then `pts_cat`, affects a target
    variable, `z_wins`. Our purpose is to determine whether there is a statistically
    significant difference between the factor levels in `o_pts_cat` and `pts_cat`
    *and* then to establish if one group of factor levels has a greater effect on
    `z_wins` than the other group of factor levels.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一对单因素 ANOVA——“单因素”是因为我们正在分析只有一个预测变量 `o_pts_cat` 以及随后 `pts_cat` 对目标变量
    `z_wins` 的影响。我们的目的是确定 `o_pts_cat` 和 `pts_cat` 的因子水平之间是否存在统计上的显著差异，并且确定一个因子水平组对
    `z_wins` 的影响是否比另一个因子水平组更大。
- en: 'We fit a one-way ANOVA similarly to fitting a simple linear regression, except
    that we call the base R `aov()` function rather than the `lm()` function. We then
    pass the target and predictor variables, separated by a tilde, and a pointer to
    our data source, nba_stats, as arguments:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拟合单因素 ANOVA 的方式与拟合简单线性回归类似，只是我们调用基础 R 的 `aov()` 函数而不是 `lm()` 函数。然后我们通过一个波浪线分隔目标变量和预测变量，并将指向我们的数据源
    nba_stats 的指针作为参数传递：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we call the `summary()` function to return the results:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `summary()` 函数以返回结果：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The p-value is essentially equal to 0, which means there is a statistically
    significant difference in the mean for `z_wins` that ties back to the four factor
    levels in the variable `o_pts_cat`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: p 值基本上等于 0，这意味着 `z_wins` 的均值在统计上存在显著差异，这与变量 `o_pts_cat` 的四个因子水平相关联。
- en: 'Let’s now examine a pair of diagnostic plots by calling the base R `plot()`
    function (see figure 14.6). Diagnostic plots are used to assess model integrity.
    By default, R returns up to four diagnostic plots, but we’re interested in checking
    for equal variances across groups and normality in the residuals, so just two
    of the four diagnostic plots, Residuals vs. Fitted and Normal QQ, are sufficient.
    As such, we pass the `which` argument to the base R `plot()` function to print
    just two plots (in one column) rather than four:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过调用基础 R 的 `plot()` 函数来检查一对诊断图（见图 14.6）。诊断图用于评估模型完整性。默认情况下，R 返回最多四个诊断图，但我们只对检查组间方差相等和残差正态性感兴趣，因此只需要两个诊断图（Residuals
    vs. Fitted 和 Normal QQ），所以我们将 `which` 参数传递给基础 R 的 `plot()` 函数，只打印两个图（在一列中）而不是四个：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![CH14_F06_Sutton](../../OEBPS/Images/CH14_F06_Sutton.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F06_Sutton](../../OEBPS/Images/CH14_F06_Sutton.png)'
- en: Figure 14.6 Diagnostic plots for our first ANOVA model
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 我们第一个 ANOVA 模型的诊断图
- en: The Residuals vs. Fitted plot displays the relationship between residuals and
    fitted values, that is, the relationship between each team’s standardized regular
    season wins and the `z_wins` mean for their respective `o_pts_cat` factor level.
    Teams that had more regular season wins than their group or category mean have
    positive residuals; teams that had fewer regular season wins than their group
    or category mean have negative residuals.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Residuals vs. Fitted plot 展示了残差与拟合值之间的关系，即每个队伍标准化的常规赛胜利数与各自 `o_pts_cat` 因子水平的
    `z_wins` 均值之间的关系。那些常规赛胜利数超过其组或类别平均值的队伍有正残差；那些常规赛胜利数少于其组或类别平均值的队伍有负残差。
- en: For fit1 to perfectly satisfy the one-way ANOVA assumption for equal variances
    across groups, the residuals should be equally dispersed for each level of fitted
    values. However, we can clearly see that the residuals are less dispersed at the
    highest fitted values versus the other levels, so the equal variances across groups
    assumption has likely been violated, albeit not significantly so.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 fit1 完全满足单因素 ANOVA 对组间方差相等的假设，残差应该在每个拟合值水平上均匀分散。然而，我们可以清楚地看到，残差在最高拟合值水平上比其他水平分散得更少，因此组间方差相等的假设可能已被违反，尽管不是显著违反。
- en: The Normal QQ plot does not, per se, display the distribution of the residuals,
    but it does provide a visual clue as to whether or not the residuals are normally
    distributed. If the residuals were normally distributed, the Normal QQ points
    would overlay the diagonal line; if not, we would instead see serious deviations
    from the diagonal line, most likely at one or both of the tails. In our case,
    the points deviate slightly at both tails, but on the whole, they overlay the
    diagonal line very well. In conclusion, while fit1 might be a model of less-than-perfect
    integrity, it does *not* qualify as a “bad” model that requires corrective action
    and a do-over.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正态Q-Q图本身并不显示残差的分布，但它确实提供了一个视觉线索，说明残差是否呈正态分布。如果残差呈正态分布，正态Q-Q点将重叠在对角线上；如果不呈正态分布，我们将会看到严重的偏离对角线，最可能出现在一个或两个尾部。在我们的案例中，点在两个尾部都有轻微的偏离，但总体上，它们很好地重叠在对角线上。结论是，虽然fit1可能是一个不太完美的模型，但它**并不**是一个需要纠正行动和重做的“坏”模型。
- en: 'Let’s now fit a second ANOVA by which we swap out predictor variables: fit2
    therefore tests the effect of the categorical variable `pts_cat` on the numeric
    variable `z_wins`. We call the `aov()` function to run our ANOVA and then the
    `summary()` function to return the results:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过交换预测变量来拟合第二个ANOVA：因此，fit2测试了分类变量`pts_cat`对数值变量`z_wins`的影响。我们调用`aov()`函数来运行我们的ANOVA，然后调用`summary()`函数来返回结果：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once again, the p-value essentially equals 0, which means there is also a statistically
    significant difference in the mean for `z_wins` that can be attributed to the
    four factor levels in `pts_cat`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，p值基本上等于0，这意味着对于`z_wins`的均值差异也可以归因于`pts_cat`的四个因素水平，这在统计上也是显著的。
- en: 'Let’s print the fit2 diagnostics and compare to our first ANOVA by again calling
    the `plot()` function (see figure 14.7):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次调用`plot()`函数来打印fit2诊断结果，并与我们的第一次方差分析进行比较（见图14.7）：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![CH14_F07_Sutton](../../OEBPS/Images/CH14_F07_Sutton.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F07_Sutton](../../OEBPS/Images/CH14_F07_Sutton.png)'
- en: Figure 14.7 Diagnostic plots for our second analysis of variance
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 第二次方差分析的诊断图
- en: First, with respect to the Residuals vs. Fitted plot, the fit2 residuals appear
    to be more equally dispersed for each level of fitted values than they were for
    fit1, thereby suggesting equal variances across groups. Second, with respect to
    the Normal QQ plot, the points appear to overlay the diagonal line more than the
    fit1 residuals, thereby suggesting a more normal distribution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关于残差与拟合值图，fit2的残差似乎在拟合值每个水平上的分布比fit1更均匀，这表明组间方差相等。其次，关于正态Q-Q图，点似乎比fit1的残差更多地重叠在对角线上，这表明分布更接近正态分布。
- en: 'Finally, we pass fit1 and fit2 to the base R `AIC()` function so as to compute
    the Akaike Information Criterion (AIC) for both ANOVAs. AIC weighs the variation
    explained against the number of predictors and returns a score. For a single model,
    AIC means nothing, but for the purposes of model selection—especially fit1 versus
    fit2, where we have equal p-values—AIC is a popular best-fit measure where the
    lower AIC score the better:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将fit1和fit2传递给基础R的`AIC()`函数，以便计算两个ANOVA的赤池信息准则（AIC）。AIC权衡了解释的变异与预测变量的数量，并返回一个分数。对于单个模型，AIC没有意义，但为了模型选择的目的——特别是fit1与fit2的比较，其中我们具有相同的p值——AIC是一个流行的最佳拟合度量，其中AIC分数越低越好：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It would appear, at least based on these two AIC scores, that fit1 better explains
    variations in `z_wins` than does fit2; in other words, defense explains variances
    in regular season wins better than offense. This may certainly be true, but the
    advantage is negligible at best and therefore hardly overwhelming.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 至少基于这两个AIC分数，fit1似乎比fit2更好地解释了`z_wins`的变化；换句话说，防守比进攻更好地解释了常规赛的方差。这当然可能是真的，但优势至多微不足道，因此几乎不具有压倒性。
- en: Thus, based on correlation tests and ANOVA models, we can confidently conclude
    that defense has, at best, a small advantage over offense in terms of affecting
    regular season wins. Next, we’ll run a pair of logistic regressions to determine
    if defense or offense better predicts which teams qualify, or don’t qualify, for
    postseason play.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于相关性测试和方差分析模型，我们可以自信地得出结论，在影响常规赛胜利方面，防守至多只有微小的优势。接下来，我们将运行一对逻辑回归，以确定防守或进攻哪个更好地预测哪些球队能进入或不能进入季后赛。
- en: 14.6 Logistic regressions
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 逻辑回归
- en: Back in chapter 5, we fit a pair of *linear* regressions to identify which hustle
    statistics might have a statistically significant influence on wins and by how
    much; put differently, we regressed a continuous variable against other continuous
    variables. Logistic regression, on the other hand, is a method by which we regress
    a binary target variable against one or more (usually) continuous predictor variables.
    Our purpose here is to run a pair of simple logistic regressions—simple because
    each model will contain just one predictor variable, either `z_o_pts` or `z_pts`,
    rather than multiple predictors—to compare and contrast the offensive and defensive
    influence on postseason qualification.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第 5 章，我们拟合了一对 *线性* 回归，以确定哪些 hustle 统计量可能对胜利有统计学上的显著影响以及影响的程度；换句话说，我们回归了一个连续变量与其他连续变量。另一方面，逻辑回归是一种通过将二元目标变量与一个或多个（通常是）连续预测变量回归的方法。我们在这里的目的是通过运行一对简单的逻辑回归来实现这一点——简单是因为每个模型将只包含一个预测变量，即
    `z_o_pts` 或 `z_pts`，而不是多个预测变量，以便比较和对比进攻和防守对季后赛资格的影响。
- en: Before we get into the nuts and bolts of logistic regression—which, be warned,
    is more complex than linear regression—let’s wrangle the nba_stats data set by
    creating a derived target variable and then split nba_stats into two mutually
    exclusive subsets for training and predicting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨逻辑回归的细节之前——警告：逻辑回归比线性回归更复杂——让我们通过创建一个派生目标变量来整理 `nba_stats` 数据集，然后将其拆分为两个互斥的子集，用于训练和预测。
- en: 14.6.1 Data wrangling
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.1 数据整理
- en: First, we pass nba_stats to the `dplyr mutate()` function and base R `ifelse()`
    function to create a new variable called `playoffs2`. If the variable `playoffs`—which
    is a factor variable with levels `0`, `10`, and `11`—equals `0`, then `playoffs2`
    should also equal `0`; if `playoffs` equals anything other than `0`, then `playoffs2`
    should instead equal `1`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `nba_stats` 传递给 `dplyr mutate()` 函数和基础 R 的 `ifelse()` 函数，创建一个名为 `playoffs2`
    的新变量。如果变量 `playoffs`（它是一个具有水平 `0`、`10` 和 `11` 的因子变量）等于 `0`，则 `playoffs2` 也应等于
    `0`；如果 `playoffs` 等于除 `0` 以外的任何值，则 `playoffs2` 应该改为等于 `1`。
- en: 'The base R `head``()` and `tail()` functions return the first 10 and last 10
    observations in nba_stats, respectively, but with a slight twist. Rather than
    return every column in nba_stats, we instead instruct R to only return those variables
    in positions 1, 3, 4, and 13\. Note that we must include the position numbers
    in order for this code to run; if we were to instead apply the variable names,
    R would throw an error:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 R 的 `head()` 和 `tail()` 函数分别返回 `nba_stats` 中的前 10 个和最后 10 个观测值，但略有不同。我们不是返回
    `nba_stats` 中的每一列，而是指示 R 只返回位置 1、3、4 和 13 的变量。请注意，我们必须包含位置编号，以便此代码能够运行；如果我们使用变量名而不是位置编号，R
    将引发错误：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we pass nba_stats to the `dplyr filter``()` and `row_number()` functions
    to divert approximately one out of every four records into a subset called test.
    Next, by calling the `dplyr anti_join()` function, we throw every nba_stats record
    *not* in test into another subset called train:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `nba_stats` 传递给 `dplyr filter()` 和 `row_number()` 函数，将大约每四条记录中的一条转移到名为
    test 的子集中。接下来，通过调用 `dplyr anti_join()` 函数，我们将不在 test 中的所有 `nba_stats` 记录抛入另一个名为
    train 的子集中：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We’ll train our logistic regressions on train and then predict on test. This
    is the exact same approach we took back in chapter 5 with respect to our multiple
    linear regressions; in fact, this is the same code we first used in that chapter
    to split our data into train and test.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 train 上训练我们的逻辑回归，然后在 test 上进行预测。这正是我们在第 5 章中针对我们的多元线性回归所采取的方法；事实上，这正是我们在那一章中首次使用来将我们的数据拆分为
    train 和 test 的相同代码。
- en: 'Successive calls to the base R `dim()` function return the row and column counts
    for train and test:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 连续调用基础 R 的 `dim()` 函数返回 train 和 test 的行数和列数：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We see that train contains 220 of the 300 records from nba_stats, or about 73%
    of the total record count, and that test contains the remaining 80 records.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，train 包含了 `nba_stats` 中的 300 条记录中的 220 条，即大约 73% 的总记录数，而 test 包含剩余的 80
    条记录。
- en: 14.6.2 Model development
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6.2 模型开发
- en: 'First, let’s consider a few critical details about logistic regression:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑关于逻辑回归的一些关键细节：
- en: The response, or target, variable must be binary where the factor levels usually
    equal 0 or 1, or 0 for No and 1 for Yes. In fact, we just created a binary target
    variable called `playoffs2` where `0` means a team failed to qualify for postseason
    play and `1` means a team did qualify for postseason play.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应变量或目标变量必须是二元的，其中因素水平通常等于0或1，或者0代表否，1代表是。实际上，我们刚刚创建了一个名为`playoffs2`的二值目标变量，其中`0`表示一支球队未能晋级季后赛，`1`表示一支球队确实晋级了季后赛。
- en: Logistic regression is a method by which we predict the probability of a target
    variable equaling 1\. For example, we could run a logistic regression to predict
    the probability of a high school senior getting accepted into Harvard, the probability
    of rain tomorrow, or the probability of an NBA team making the playoffs.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑回归是一种预测目标变量等于1的概率的方法。例如，我们可以运行逻辑回归来预测一名高中生被哈佛大学录取的概率、明天下雨的概率，或者一支NBA球队进入季后赛的概率。
- en: Our logistic regressions will model the probability of qualifying for postseason
    play given the standardized scores between points allowed and then points scored.
    For instance, the probability of qualifying for postseason play given the value
    of the predictor variable `z_o_pts` can be written as Pr(playoffs2 = Yes|z_o_pts),
    or *p*(playoffs2) for short.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的逻辑回归将根据允许得分和得分之间的标准化分数来建模晋级季后赛的概率。例如，给定预测变量`z_o_pts`的值的晋级季后赛的概率可以写成Pr(playoffs2
    = Yes|z_o_pts)，或简称为*p*(playoffs2)。
- en: The probability will always equal some number between 0 and 1\. We’ll then predict
    playoffs2 = Yes for any team where *p*(playoffs2) is equal to or greater than
    0.50.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率始终等于0和1之间的某个数字。然后，我们将预测任何*p*(playoffs2)等于或大于0.50的球队的playoffs2 = 是。
- en: This is why we can’t run a linear regression to solve a classification problem;
    a linear model is actually capable of predicting probabilities less than 0 and
    greater than 1 when the predictor variable equals a relatively extreme value.
    To avoid mathematically impossible results, logistic regression uses a method
    known as *maximum likelihood estimation* to predict probabilities that will always
    fall between 0 and 1.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也是为什么我们不能用线性回归来解决分类问题；当预测变量等于相对极端值时，线性模型实际上能够预测小于0和大于1的概率。为了避免数学上不可能的结果，逻辑回归使用一种称为*最大似然估计*的方法来预测始终介于0和1之间的概率。
- en: 'The maximum likelihood estimation predicts probabilities from the following
    equation: log[p(X) / (1 - p(X))] = *B*[0] + *B*[1]X[1]. The left-hand side of
    this equation is called the log odds, or logit; the right-hand side therefore
    is how we compute the log odds, where *X*[1] equals the predictor variable and
    *B*[1] equals the predictor variable’s coefficient. We’ll talk much more on this
    when we get around to evaluating the results of our first model.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大似然估计从以下方程预测概率：log[p(X) / (1 - p(X))] = *B*[0] + *B*[1]X[1]。这个方程的左边称为对数几率，或logit；因此，右边是我们计算对数几率的方法，其中*X*[1]等于预测变量，*B*[1]等于预测变量的系数。当我们开始评估第一个模型的结果时，我们将对此进行更多讨论。
- en: Let’s now fit the first of our two regressions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来拟合我们两个回归模型中的第一个。
- en: Fitting our first of two models
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合我们两个模型中的第一个
- en: To fit a logistic regression, we call the base R `glm()` function, short for
    generalized linear models, which represents a class of models that includes logistic
    regression. The syntax for a logistic regression is otherwise similar to a linear
    model and the base R `lm()` function, except that we need to pass the `family
    = "binomial"` argument to tell R to run a logistic regression versus some other
    generalized linear model. Note that we’re fitting the model against train and
    not nba_stats.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要拟合逻辑回归，我们调用基础R的`glm()`函数，即广义线性模型，它代表一类包括逻辑回归的模型。逻辑回归的语法与线性模型和基础R的`lm()`函数类似，除了我们需要传递`family
    = "binomial"`参数来告诉R运行逻辑回归而不是其他广义线性模型。请注意，我们是在train上拟合模型，而不是在nba_stats上。
- en: 'We regress the target binary variable `playoffs2` against the continuous predictor
    variable `z_o_pts`. Then, we call the base R `summary()` function and pass the
    model name, fit3, to return the results:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将目标二值变量`playoffs2`对连续预测变量`z_o_pts`进行回归。然后，我们调用基础R的`summary()`函数并传递模型名称fit3，以返回结果：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let’s alternately review a subset of these results and fetch some additional
    metrics. First, the p-value for `z_o_pts` essentially equals `0`, which means
    it has a statistically significant effect on `playoffs2`; that is, points allowed
    definitely have an effect on whether or not an NBA team qualifies for the postseason.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们交替回顾这些结果的一部分并获取一些额外的指标。首先，`z_o_pts` 的 p 值几乎等于 `0`，这意味着它对 `playoffs2` 有统计学上的显著影响；也就是说，允许的得分确实对
    NBA 球队是否进入季后赛有影响。
- en: 'Second, whereas a linear regression returns R² and Adjusted R² statistics that
    measure the amount of collective variance explained by the model’s predictors,
    a logistic regression has no such equivalent. However, the `pR2()` function from
    the `pscl` package returns what’s called a McFadden’s pseudo-R² measure for generalized
    linear models. It otherwise measures the goodness of fit in logistic regression
    models. It quantifies the proportion of variance explained by the model by comparing
    the log-likelihood of the fitted model with that of a null model by returning
    some value between 0 and 1, where the higher the number, the more predictive power.
    A pseudo-R² as “low” as 0.4 or even 0.2 is generally considered to indicate a
    good fit. In the following code, we pass the model name, fit3, to the `pR2()`
    function to get McFadden’s pseudo-R²:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，虽然线性回归返回 R² 和调整 R² 统计量，这些量度模型预测因子解释的集体方差，但逻辑回归没有这样的等效量度。然而，`pscl` 包中的 `pR2()`
    函数返回广义线性模型中所谓的 McFadden 伪 R² 测量值。它否则测量逻辑回归模型中的拟合优度。它通过比较拟合模型的似然值与零模型（null model）的似然值来量化模型解释的方差比例，返回介于
    0 和 1 之间的某个值，数值越高，预测能力越强。伪 R² 低至 0.4 或甚至 0.2 通常被认为表示拟合良好。在下面的代码中，我们将模型名称 fit3
    传递给 `pR2()` 函数以获取 McFadden 伪 R²：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because McFadden’s pseudo-R² equals 0.31, we can therefore conclude that `z_o_pts`
    is a good fit for the data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 McFadden 伪 R² 等于 0.31，因此我们可以得出结论，`z_o_pts` 对数据是一个良好的拟合。
- en: 'Third, the `caret` package includes a function called `varImp``()`, which quantitatively
    measures the importance or relevance of model predictors. The metric means nothing
    by itself, but when compared to other predictors in the same model or another
    predictor in a competing simple regression, it allows us to compare and contrast
    their influence on the same target variable. All we then need to do is pass fit3
    to the `varImp()` function. We’ll return to these results after running our second
    logistic regression:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`caret` 包包含一个名为 `varImp()` 的函数，该函数定量测量模型预测因子的重要性或相关性。这个度量本身没有意义，但当我们将其与同一模型中的其他预测因子或竞争简单回归中的另一个预测因子进行比较时，它允许我们比较和对比它们对同一目标变量的影响。我们只需要将
    fit3 传递给 `varImp()` 函数。我们将在运行第二个逻辑回归后返回这些结果：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Fourth, the fit3 AIC equals 214.91; the `summary()` function returns this measure
    for generalized linear models, whereas for linear regressions and ANOVAs, we need
    to run the `AIC()` function to get the AIC. Once again, the AIC doesn’t mean anything
    until we’re comparing competing models, so we’ll keep the AIC in our back pocket
    for the time being.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，fit3 的 AIC 等于 214.91；`summary()` 函数为广义线性模型返回此度量，而对于线性回归和方差分析（ANOVA），我们需要运行
    `AIC()` 函数来获取 AIC。同样，AIC 在比较竞争模型之前没有任何意义，所以我们将 AIC 放在一边暂时不谈。
- en: 'Fifth, we now need to continue our conversation about the predictor variable’s
    coefficient; in fit3, the `z_o_pts` coefficient equals `-1.72`. First and foremost,
    it’s important to understand how a probability is converted to log odds and vice
    versa:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第五，我们现在需要继续讨论预测变量系数的话题；在 fit3 中，`z_o_pts` 系数等于 `-1.72`。首先，重要的是要理解概率是如何转换为对数几率以及反过来：
- en: Probability is the likelihood of some event occurring. For example, there might
    be a 70% probability of our flight from New York to London departing on time.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率是某个事件发生的可能性。例如，从纽约到伦敦的航班准时起飞的概率可能是 70%。
- en: Odds, or more accurately the odds of success, equals the probability of success
    divided by the probability of failure. So the odds of our flight departing on
    time equals the odds ratio, or 0.70 divided by 0.30, which equals 2.33.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几率，或者更准确地说，成功的几率，等于成功的概率除以失败的概率。因此，我们的航班准时起飞的几率等于几率比，即 0.70 除以 0.30，等于 2.33。
- en: 'The log odds is merely the natural logarithm of the odds ratio. One way of
    computing the natural logarithm in R is by calling the `ln()` function from the
    `SciViews` package and passing the odds ratio:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数几率仅仅是几率比的自然对数。在 R 中计算自然对数的一种方法是通过调用 `SciViews` 包中的 `ln()` 函数并将几率比传递给它：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'More importantly for our purposes, here’s how to convert a log odds to an odds
    ratio and an odds ratio to a probability that we can all understand:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说更为重要的是，以下是如何将对数优势转换为优势比，以及如何将优势比转换为我们可以理解的概率：
- en: 'The odds ratio equals e^(log) odds, where *e* is a mathematical constant equal
    to 2.72, and, in our example, the log odds equals 0.85\. R makes this easy for
    us—we simply call the base R `exp()` function and pass the log odds to convert
    the log odds to the odds ratio:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优势比等于自然对数的指数，其中*e*是一个数学常数，等于2.72，在我们的例子中，对数优势等于0.85。R使我们很容易做到这一点——我们只需调用基础R的`exp()`函数并将对数优势传递给它以将其转换为优势比：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The probability equals the odds ratio, or 2.34 in our example, divided by the
    sum of 1 and 2.34, or 3.34:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率等于优势比，即我们的例子中的2.34，除以1和2.34之和，即3.34：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: After all that, we’re back to a 70% probability of our New York to London flight
    departing on time.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这一切，我们回到了70%的概率，即我们的纽约至伦敦航班准时起飞。
- en: Now, with respect to our logistic regression model, we can convert the `z_o_pts`
    coefficient from log odds to a probability and then evaluate the average change
    in our dependent variable, `playoffs2`, when the `z_o_pts` coefficient increases
    or decreases by one unit.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于我们的逻辑回归模型，我们可以将`z_o_pts`系数从对数优势转换为概率，然后评估当`z_o_pts`系数增加或减少一个单位时，我们的因变量`playoffs2`的平均变化。
- en: 'Rather than convert the log odds to an odd ratio and then convert the odds
    ratio to a probability, we’ll merely pass the log odds to the base R `plogis()`
    function to compute the probability directly from the log odds:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将对数优势转换为优势比，然后再将优势比转换为概率，我们只需将对数优势传递给基础R的`plogis()`函数，直接从对数优势计算概率：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So a one-unit increase or decrease in `z_o_pts` will correspond to a roughly
    15% change in the probability of qualifying for the playoffs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`z_o_pts`的一个单位增加或减少将对应于季后赛资格概率的大约15%的变化。
- en: Now that we’ve fit our logistic regression on the train data set, we can use
    it to make predictions against the test data set. We therefore pass our model
    and our data to the base R `predict()` function. By adding `type = "response"`
    as a third argument to the `predict()` function, we’re instructing R to return
    the predicted probabilities in the form Pr(playoffs2 = Yes|z_o_pts).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在训练数据集上拟合了逻辑回归模型，我们可以使用它来对测试数据集进行预测。因此，我们将我们的模型和数据传递给基础R的`predict()`函数。通过将`type
    = "response"`作为`predict()`函数的第三个参数添加，我们指示R以Pr(playoffs2 = Yes|z_o_pts)的形式返回预测概率。
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we were to then call the `print()` function, R would return a matrix of
    probabilities, all equaling some number between 0 and 1, for all 80 records in
    test. Instead, we’ll pass test to the `dplyr select()` function to create a subset
    called actuals that just includes the variable `playoffs2`. However, we first
    make a call to the `dplyr ungroup()` function to decouple the variables `playoffs2`
    and `season`; otherwise, actuals would unnecessarily include both variables:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`print()`函数，R将返回一个概率矩阵，其中所有概率都在0到1之间，对应于测试中的80条记录。相反，我们将测试传递给`dplyr select()`函数以创建一个名为actuals的子集，它仅包括变量`playoffs2`。然而，我们首先调用`dplyr
    ungroup()`函数来解除`playoffs2`和`season`变量之间的耦合；否则，actuals将不必要地包含这两个变量：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we pass actuals to the `dplyr` `rename()` function; `rename``()` takes
    the variable on the right side of the assignment operator and renames it to whatever
    is on the left side:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将actuals传递给`dplyr`的`rename()`函数；`rename()`函数将赋值运算符右侧的变量重命名为左侧的内容：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Switching gears somewhat, we then create a new object called predictions, which
    equals predicted_fit3 that’s been converted from a matrix to a data frame by making
    a call to the base R `as.data.frame()` function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 转换话题，我们接下来创建一个新的对象，称为predictions，它等于通过调用基础R的`as.data.frame()`函数将predicted_fit3从矩阵转换为数据框的predicted_fit3：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We then pass predictions to the `rename()` function; as a matrix and then as
    a data frame, the one variable in predicted_fit3 is actually `predicted_fit3`.
    By calling the `rename()` function, we change that to instead equal `predicted_values`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将predictions传递给`rename()`函数；作为一个矩阵和一个数据框，predicted_fit3中的单个变量实际上是`predicted_fit3`。通过调用`rename()`函数，我们将它改为等于`predicted_values`：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we pass predictions to the `dplyr mutate``()` and base R `ifelse()` functions
    to create a derived variable based on conditional logic. When the variable `predicted_values`
    is equal to or greater than `0.50`, `predicted_values2` should equal `1`; otherwise,
    it should equal `0`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将预测值传递给`dplyr mutate()`和基础R的`ifelse()`函数，根据条件逻辑创建一个派生变量。当变量`predicted_values`等于或大于`0.50`时，`predicted_values2`应等于`1`；否则，它应等于`0`：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now we have a pair of single-variable objects that both tie back to test—actuals
    contains a binary variable called `actual_values`, which indicates whether an
    NBA team qualified for postseason play, and predictions contains a binary variable
    called `predicted_values`, which indicates whether predicted_fit3 predicted those
    same teams to make the playoffs.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一对单变量对象，它们都与测试相关联——`actual_values`包含一个二进制变量，表示NBA球队是否进入季后赛，而`predictions`包含一个二进制变量`predicted_values`，表示预测拟合3是否预测这些球队进入季后赛。
- en: 'We then pass both those variables to the base R `table()` function to create
    what’s called a confusion matrix. The `print()` function returns the results.
    The passed variables must absolutely be binary in order for this to run:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这两个变量传递给基础R的`table()`函数，创建所谓的混淆矩阵。`print()`函数返回结果。传递的变量必须绝对为二进制，才能使此操作运行：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our confusion matrix is both like and unlike the contingency table we created
    back in chapter 9, as explained here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的混淆矩阵既类似于我们在第9章创建的列联表，又不同于它，正如以下解释所示：
- en: A confusion matrix is a table that summarizes the performance of a classification
    model by displaying the counts of true positives (TP), true negatives (TN), false
    positives (FP), and false negatives (FN). The confusion matrix is the source from
    which we can then derive critical predicted_fit3 performance measures.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混淆矩阵是一个表格，通过显示真正例（TP）、真正负（TN）、假正例（FP）和假负例（FN）的计数来总结分类模型的性能。混淆矩阵是我们从中可以推导出关键预测拟合3性能指标的来源。
- en: A true positive refers to a case in which the model correctly predicted a positive
    outcome. Where a positive outcome is the equivalent of an NBA team qualifying
    for the postseason, we have 40 such instances.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真阳性指的是模型正确预测了正面结果的情况。当一个正面结果相当于一支NBA球队进入季后赛时，我们有40个这样的实例。
- en: A true negative refers to a case in which the model correctly predicted a negative
    outcome. Where a negative outcome is the equivalent of an NBA team not qualifying
    for postseason play, we have 19 such instances.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真阴性指的是模型正确预测了负面结果的情况。当一个负面结果相当于一支NBA球队未能进入季后赛时，我们有19个这样的实例。
- en: A false positive refers to a case where the model incorrectly predicted a positive
    outcome. We have 11 such instances.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假阳性指的是模型错误地预测了正面结果的情况。我们有11个这样的实例。
- en: A false negative refers to a case where the model incorrectly predicted a negative
    outcome. We have 10 such instances.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假阴性指的是模型错误地预测了负面结果的情况。我们有10个这样的实例。
- en: Sensitivity, otherwise known as the true positive rate, is a measure of the
    proportion of true positives correctly identified by a classification model out
    of all positive instances.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感性，也称为真正率，是衡量分类模型在所有正例中正确识别的真正例比例的指标。
- en: Sensitivity = TP / (TP + FN)
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感性 = TP / (TP + FN)
- en: Specificity, also known as the true negative rate, is a measure of the proportion
    of true negatives correctly identified by a classification model out of all negative
    instances.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特异性，也称为真正负率，是衡量分类模型在所有负例中正确识别的真正负例比例的指标。
- en: Specificity = TN / (TN + FP)
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特异性 = TN / (TN + FP)
- en: The relative importance of sensitivity versus specificity usually depends on
    the context. Consider tests for a rare but highly aggressive form of cancer. False
    negatives can possibly lead to severe consequences because they could delay or
    even prevent treatments, resulting in fatal outcomes. Maximizing true positives
    and minimizing false negatives are much more important than minimizing false positives.
    Another example to consider is law and order, particularly in democracies, where
    it’s so important to minimize wrongful convictions, or false positives. In other
    cases, such as whether NBA teams are successful in qualifying for postseason play,
    sensitivity and specificity might be of equal importance.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感性相对于特异性的相对重要性通常取决于上下文。考虑对一种罕见但高度侵袭性的癌症进行的检测。假阴性可能导致严重后果，因为它们可能会延迟或甚至阻止治疗，导致致命结果。最大化真阳性并最小化假阴性比最小化假阳性更为重要。另一个需要考虑的例子是法律和秩序，特别是在民主国家，在那里最大限度地减少错误定罪，或假阳性，非常重要。在其他情况下，例如，NBA球队是否成功晋级季后赛，敏感性和特异性可能具有同等的重要性。
- en: Misclassification error, sometimes called the classification error or just the
    error rate, is a measure of misclassified instances in a classification model.
    It therefore represents the percentage of incorrect predictions.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 误分类错误率，有时也称为分类错误或只是错误率，是分类模型中误分类实例的度量。因此，它代表了错误预测的百分比。
- en: Misclassification error = (FP + FN) / *n*
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 误分类错误率 = (FP + FN) / *n*
- en: Model accuracy is the inverse of the error rate; it therefore represents the
    percentage of correct predictions.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型准确率是错误率的倒数；因此，它代表了正确预测的百分比。
- en: Model accuracy = (TP + TN) / *n* or 1 - (FP + FN) / *n*
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型准确率 = (TP + TN) / *n* 或 1 - (FP + FN) / *n*
- en: 'It’s easy enough in R to compute the sensitivity and specificity rates; we
    simply pass our binary variables, `actual_values` and `predicted_values2`, to
    the `sensitivity``()` and `specificity()` functions from the `caret` package.
    To get correct results, you must pass the variables in the same sequence in which
    they were previously passed to the `table()` function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中计算敏感性和特异性率很容易；我们只需将我们的二元变量`actual_values`和`predicted_values2`传递给`caret`包中的`sensitivity()`和`specificity()`函数。为了得到正确的结果，你必须以与之前传递给`table()`函数相同的顺序传递变量：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Because the sensitivity rate is higher than the specificity rate, we can therefore
    conclude that our first logistic regression, predicted_fit3, is better at identifying
    true positives than true negatives.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于敏感性率高于特异性率，因此我们可以得出结论，我们的第一个逻辑回归，predicted_fit3，在识别真阳性方面比识别真阴性更好。
- en: 'Then, we use arithmetic operations to calculate the error rate and to derive
    model accuracy. Once more, the misclassification error, or simply the error rate,
    is equal to the sum of false positives and false negatives divided by the record
    count:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用算术运算来计算错误率并推导出模型准确率。再次强调，误分类错误率，或简称为错误率，等于假阳性和假阴性之和除以记录数：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Model accuracy is simply the inverse of the error rate:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 模型准确率仅仅是错误率的倒数：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: An accuracy rate this high indicates that predicted_fit3 has fairly strong predictive
    power.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如此高的准确率表明predicted_fit3具有相当强的预测能力。
- en: Finally, we’ll combine the `roc()` function from the `pROC` package and the
    `plot()` function from base R to compute what’s called the area under the curve
    (AUC) and then draw the ROC curve, which was discussed earlier in this chapter.
    The AUC quantifies the predictive power of a classification model by equally considering
    the sensitivity and specificity rates. When the AUC equals a maximum of 1, a model
    perfectly distinguishes both positive and negative instances; when equal to 0.5,
    the model performs no better than random chance. Thus, the higher the AUC, the
    better. A ROC curve visualizes the same by plotting the specificity rate along
    the x-axis and the sensitivity rate along the y-axis.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将结合`pROC`包中的`roc()`函数和基础R中的`plot()`函数来计算所谓的曲线下面积（AUC），然后绘制ROC曲线，这在本章前面已经讨论过。AUC通过同等考虑敏感性和特异性率来量化分类模型的预测能力。当AUC等于1的最大值时，模型可以完美地区分正例和负例；当等于0.5时，模型的性能不比随机机会更好。因此，AUC越高，越好。ROC曲线通过在x轴上绘制特异性率，在y轴上绘制敏感性率来可视化这一点。
- en: Whereas the error rate measures the proportion of misclassified instances from
    the total record count, and therefore focuses on individual predictions, the AUC
    measures the overall discriminatory power of a classified model from how well
    it distinguishes positive versus negative instances. Though the measures are thus
    different, they usually align very well with one another.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 而错误率衡量的是从总记录数中误分类实例的比例，因此关注的是单个预测，而AUC衡量的是分类模型的整体判别能力，即它区分正例和负例的能力。尽管这两个度量不同，但它们通常非常一致。
- en: 'In the following code, we pass `actual_values` and `predicted_values2`—in that
    order—to the `roc()` function and `print()` function to get the AUC:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们按照顺序将`actual_values`和`predicted_values2`传递给`roc()`函数和`print()`函数以获取AUC：
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: An AUC equal to 0.73 is an indication of a fairly strong model.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: AUC等于0.73表明模型相当强大。
- en: 'We then get an ROC curve by making a call to the `plot()` function (see figure
    14.8). Base R plots are more functional than they are elegant, yet we can color-code
    the curve and customize the title and axis labels:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`plot()`函数来得到ROC曲线（见图14.8）。Base R的绘图功能比其优雅性更实用，但我们仍然可以给曲线着色并自定义标题和轴标签：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![CH14_F08_Sutton](../../OEBPS/Images/CH14_F08_Sutton.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F08_Sutton](../../OEBPS/Images/CH14_F08_Sutton.png)'
- en: Figure 14.8 ROC curve for our first of two logistic regressions that plot true
    negatives along the x-axis and true positives along the y-axis
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8展示了我们的第一个逻辑回归的ROC曲线，其中x轴表示真正的负例，y轴表示真正的正例。
- en: Let’s fit a second regression and then compare and contrast our two models.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拟合第二个回归，然后比较和对比我们的两个模型。
- en: Fitting our second of two models
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合我们的第二个模型
- en: 'Our second and last model, fit4, regresses `playoffs2` against `z_pts`. We
    plot a second ROC curve at the end (see figure 14.9):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第二个也是最后一个模型fit4，将`playoffs2`对`z_pts`进行回归。我们在最后绘制了第二个ROC曲线（见图14.9）：
- en: '[PRE66]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '![CH14_F09_Sutton](../../OEBPS/Images/CH14_F09_Sutton.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F09_Sutton](../../OEBPS/Images/CH14_F09_Sutton.png)'
- en: Figure 14.9 ROC curve for our second of two logistic regressions that plot true
    negatives along the x-axis and true positives along the y-axis. Whereas our first
    model returned a higher sensitivity rate than specificity rate, our second model
    returned just the opposite. However, the respective AUCs are essentially equal.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9展示了我们的第二个逻辑回归的ROC曲线，其中x轴表示真正的负例，y轴表示真正的正例。虽然我们的第一个模型返回的灵敏度率高于特异性率，但第二个模型返回的正好相反。然而，相应的AUC基本相等。
- en: Let’s review the results and evaluate the same against fit3 and predicted_fit3
    (see table 14.1).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下结果，并将它们与fit3和predicted_fit3进行比较（见表14.1）。
- en: Table 14.1 Side-by-side results from our logistic regression models
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1展示了我们的逻辑回归模型的并列结果
- en: '| Metric | fit3 | fit4 | Notes |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 度量 | fit3 | fit4 | 备注 |'
- en: '| Predictor p-value | 0.00000000000011 | 0.0000321 | Both `z_o_pts` and `z_pts`
    have statistically significant influences on `playoffs2`. `z_o_pts` has a lower
    p-value than `z_pts`, however. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 预测因子p值 | 0.00000000000011 | 0.0000321 | `z_o_pts`和`z_pts`都对`playoffs2`有显著的统计影响。然而，`z_o_pts`的p值低于`z_pts`。|'
- en: '| pseudo-R² | 0.31 | 0.06 | `z_o_pts` is the better of the two predictors.
    |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|伪R² | 0.31 | 0.06 | `z_o_pts`是两个预测因子中更好的。|'
- en: '| AIC | 214.91 | 289.32 | AIC evaluates models on a combination of fit and
    complexity, where the lower the AIC, the better. Because both models are simple
    regressions, the AIC scores otherwise suggest that fit3 is a better fit for the
    data. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| AIC | 214.91 | 289.32 | AIC根据拟合和复杂性的组合来评估模型，AIC越低，越好。由于这两个模型都是简单的回归，AIC分数否则表明fit3是更好的数据拟合。|'
- en: '| Variable importance | 7.43 | 4.16 | `z_o_pts` is the more important contributor
    to differences in the target variable `playoffs2`. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 变量重要性 | 7.43 | 4.16 | `z_o_pts`是目标变量`playoffs2`差异中更重要的贡献者。|'
- en: '| Sensitivity | 0.80 | 0.56 | predicted_fit3 is the stronger of the two models
    with respect to true positive rates. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 灵敏度 | 0.80 | 0.56 | predicted_fit3在真正例率方面是两个模型中更强的。|'
- en: '| Specificity | 0.63 | 0.90 | predicted_fit4 is the stronger of the two models
    with respect to true negative rates. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 特异性 | 0.63 | 0.90 | predicted_fit4在真正例率方面是两个模型中更强的。|'
- en: '| Error rate | 0.26 | 0.31 | predicted_fit3 has the lower error rate. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 错误率 | 0.26 | 0.31 | predicted_fit3的错误率更低。|'
- en: '| Model accuracy | 0.74 | 0.69 | predicted_fit3 therefore has the higher model
    accuracy rate. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 模型准确率 | 0.74 | 0.69 | 因此，predicted_fit3具有更高的模型准确率。|'
- en: '| AUC | 0.73 | 0.73 | predicted_fit4 has a slightly higher AUC. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| AUC | 0.73 | 0.73 | predicted_fit4的AUC略高。|'
- en: All things considered, based on our logistic regressions alone, we have to conclude
    that points allowed has a larger effect on whether NBA teams, at least between
    the 2007 and 2018 seasons, qualify for postseason play.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的逻辑回归，我们必须得出结论，失分对 NBA 球队是否至少在 2007 年至 2018 年赛季期间进入季后赛有更大的影响。
- en: But as in our correlation tests and ANOVA models, any advantage `z_o_pts` might
    have over `z_pts` is negligible at best. In fact, the best overall conclusion
    is that points allowed and points scored have roughly equal influences on regular
    season wins and whether teams qualify for postseason play. In other words, defense
    doesn’t matter *much* more than offense.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们的相关性和 ANOVA 模型测试一样，`z_o_pts` 可能比 `z_pts` 具有的任何优势至多是可以忽略不计的。事实上，最好的总体结论是，失分和得分对常规赛胜利以及球队是否进入季后赛的影响大致相等。换句话说，防守并不比进攻重要得多。
- en: That being said, why do so many people—players, coaches, and general managers
    included—still cling to the idea that defense clearly and unmistakably matters
    more than offense? We might actually have an answer for that next.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，为什么那么多人——包括球员、教练和总经理——仍然坚持认为防守显然且毫无疑问比进攻更重要？我们可能真的有下一个答案。
- en: 14.7 Paired data before and after
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.7 配对数据前后
- en: The answer might tie back to the regular season and postseason differences in
    points scored and especially points allowed for most NBA championship-winning
    teams. Let’s explore this possibility.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 答案可能追溯到常规赛和季后赛中大多数 NBA 冠军球队的得分和失分差异。让我们探索这个可能性。
- en: 'We begin by passing the nba_stats data set to the `dplyr filter()` function
    to subset nba_stats on the 10 records where the factor variable `playoffs` equals
    `11`. The factor level equals 11 for league champions only. Then, nba_stats is
    passed to the `dplyr select()` function to subset it on the variables `Team`,
    `season`, `PTS`, and `O_PTS`. Finally, we make a call to the dplyr `arrange()`
    function to sort nba_stats on the variable `season`. The results are cast to a
    10 × 3 tibble called df1:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 nba_stats 数据集传递给 `dplyr filter()` 函数，以子集化 `playoffs` 因子变量等于 `11` 的 10
    条记录。因子级别等于 11 仅适用于联赛冠军。然后，将 nba_stats 传递给 `dplyr select()` 函数，以 `Team`、`season`、`PTS`
    和 `O_PTS` 变量对其进行子集化。最后，我们调用 dplyr 的 `arrange()` 函数按 `season` 变量对 nba_stats 进行排序。结果被转换为一个
    10 × 3 的 tibble，称为 df1：
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we make another call to the `select()` function to subset df1 on every
    variable except `Team`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次调用 `select()` 函数，对 df1 中的除 `Team` 之外的所有变量进行子集化：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We now have a tidy object that contains the regular season points scored and
    points allowed averages for the 10 NBA champions from nba_stats. Next, we call
    the base R `data.frame()` function to create a postseason equivalent of df1.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个整洁的对象，其中包含了 nba_stats 中 10 个 NBA 冠军球队的常规赛得分和失分平均数。接下来，我们调用基础 R 的 `data.frame()`
    函数来创建 df1 的季后赛等价物。
- en: 'Our new object, df2, contains three vectors: a factor variable called `season`,
    which equals 2008 through 2017; a numeric variable called `PTS`, which equals
    points scored per game; and a numeric variable called `O_PTS`, which equals points
    allowed per game (postseason results were grabbed from [www.basketball-reference.com](https://www.basketball-reference.com/)):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新对象 df2 包含三个向量：一个名为 `season` 的因子变量，等于 2008 年至 2017 年；一个名为 `PTS` 的数值变量，等于每场比赛的得分；以及一个名为
    `O_PTS` 的数值变量，等于每场比赛的失分（季后赛结果是从 [www.basketball-reference.com](https://www.basketball-reference.com/)
    获取的）：
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We then pass df1 and df2 to the `rbind()` function, which concatenates data
    objects by rows. In the process, we create a 20 × 4 tibble called df3:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将 df1 和 df2 传递给 `rbind()` 函数，该函数通过行将数据对象连接起来。在这个过程中，我们创建了一个 20 × 4 的 tibble，称为
    df3：
- en: '[PRE70]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Lastly, we append a new variable to df3 called `Season` (once more, R is a
    case-sensitive programming language, so `Season` is different than `season`),
    where the first 10 records equal `Regular Season` and the last 10 records equal
    `Playoffs`. We then call the `print()` function to return df3 in its entirety:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 df3 中添加一个新的变量 `Season`（再次强调，R 是一个区分大小写的编程语言，所以 `Season` 与 `season` 不同），其中前
    10 条记录等于 `Regular Season`，后 10 条记录等于 `Playoffs`。然后我们调用 `print()` 函数以完整的形式返回 df3：
- en: '[PRE71]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We then pass df3, and specifically the variables `Season` and `O_PTS`, to the
    `ggpaired()` function from the `ggpubr` package to plot regular season and postseason
    points allowed. The `ggpaired()` function creates a pair of before and after boxplots
    that displays the regular season and postseason points allowed distributions *and*
    draws connecting lines between the same teams so that we can compare each team’s
    performance (see figure 14.10).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将df3以及特定的变量`Season`和`O_PTS`传递给`ggpubr`包中的`ggpaired()`函数来绘制常规赛和季后赛允许的得分图。`ggpaired()`函数创建了一对前后箱线图，显示了常规赛和季后赛允许的得分分布，并在相同的球队之间绘制连接线，以便我们可以比较每支球队的业绩（见图14.10）。
- en: '![CH14_F10_Sutton](../../OEBPS/Images/CH14_F10_Sutton.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F10_Sutton](../../OEBPS/Images/CH14_F10_Sutton.png)'
- en: Figure 14.10 Paired boxplots displaying the per-game points allowed between
    the regular season and postseason for all NBA championship-winning teams between
    the 2008 and 2017 seasons. Most teams allowed fewer points per game in the postseason
    than they did during the regular season.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10展示了2008年至2017赛季所有NBA冠军球队在常规赛和季后赛期间每场比赛允许的得分对比的配对箱线图。大多数球队在季后赛中每场比赛允许的得分比常规赛中要少。
- en: 'We can also customize the color and width of the connecting lines and choose
    a color scheme for the boxes and whiskers from several `ggplot2` palettes (`aaas`,
    short for the American Association for the Advancement of Science, is one of many
    scientific journal color palettes):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以自定义连接线的颜色和宽度，并从几个`ggplot2`调色板（`aaas`，代表美国科学促进会，是众多科学期刊调色板之一）中选择颜色方案：
- en: '[PRE72]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here’s the key takeaway: 8 of the 10 NBA champions between the 2008 and 2017
    seasons allowed fewer points in the postseason than they did during the regular
    season.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关键要点：在2008年至2017赛季的10支NBA冠军球队中，有8支球队在季后赛中允许的得分比常规赛中要少。
- en: 'But most of these same teams also *scored* fewer points per game in the playoffs
    then they did in the regular season (see figure 14.11); this therefore suggests
    their opponents also played better defense in the postseason:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但大多数这些球队在季后赛中每场比赛的得分也比常规赛中要少（见图14.11）；这因此表明他们的对手在季后赛中防守也更好：
- en: '[PRE73]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![CH14_F11_Sutton](../../OEBPS/Images/CH14_F11_Sutton.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F11_Sutton](../../OEBPS/Images/CH14_F11_Sutton.png)'
- en: Figure 14.11 Paired boxplots displaying the per-game points scored between the
    regular season and postseason for all NBA championship-winning teams between the
    2008 and 2017 seasons. Most teams also scored fewer points per game during the
    postseason than they did during the regular season.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11展示了2008年至2017赛季所有NBA冠军球队在常规赛和季后赛期间每场比赛得分的配对箱线图。大多数球队在季后赛中每场比赛的得分也比常规赛中要少。
- en: The fact that fewer points are scored in most postseason games than in most
    regular season games may very well be responsible for creating the *impression*
    that defense, much more so than offense, wins championships. But at the end of
    the day, defense doesn’t win championships; based on our series of test results,
    defense at best is marginally more of a differentiator than offense, and that’s
    hardly the equivalent of today’s conventional wisdom. We’re drawing this conclusion
    based on the consistency of our analysis between computing correlation coefficients,
    running correlation tests, fitting ANOVA models, and then fitting a pair of logistic
    regressions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数季后赛比赛中得分的数量比大多数常规赛比赛中要少，这很可能导致了这样的印象：防守，而不是进攻，赢得了冠军。但最终，防守并不能赢得冠军；根据我们的测试结果系列，防守最多只是比进攻略多一点区分度，而这远远不能等同于今天的传统智慧。我们基于计算相关系数、运行相关测试、拟合方差分析模型，然后拟合一对逻辑回归的一致性得出这个结论。
- en: In the next chapter, we’ll explore the 80-20 rule and demonstrate how to create
    charts, really Pareto charts, that contain two y-axes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨80-20法则，并展示如何创建包含两个y轴的图表，即帕累托图。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We applied three statistical techniques—correlation tests, ANOVAs, and logistic
    regressions—alternately testing the effects of points allowed and points scored
    on regular season wins and postseason qualification against a 10-season NBA data
    set. All of our tests returned statistically significant results, and all strongly
    suggest that defense might be *slightly* more important than offense, which is
    hardly equivalent to the conventional wisdom that defense matters much more than
    offense.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用了三种统计技术——相关性测试、方差分析和逻辑回归——交替测试了允许的得分和得分的效应，对常规赛胜利和季后赛资格的影响，针对10个赛季的NBA数据集。我们所有的测试都返回了具有统计学意义的成果，并且所有测试都强烈表明防守可能*略微*比进攻更重要，这几乎与传统的观点——防守比进攻更重要——不相符。
- en: Points allowed and points scored per game are almost equally *correlated* with
    regular season wins. Furthermore, correlation tests between the two paired with
    wins returned like results where the p-values were well below the predefined 5%
    threshold for significance.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每场比赛允许的得分和每场比赛的得分几乎与常规赛的胜利数同样*相关*。此外，与胜利数配对的两个变量之间的相关性测试结果显示，p值远低于预定义的5%显著性阈值。
- en: Points allowed and points scored have similar *effects* on regular season wins,
    based on our one-way ANOVAs where, again, our models returned equal p-values well
    below the threshold for significance.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们的单因素方差分析，允许的得分和得分的效应对常规赛胜利相似，我们的模型再次返回了低于显著性阈值的相等p值。
- en: Based on our logistic regressions, points allowed and points scored per regular
    season game are, by and large, equally effective predictors (or at least roughly
    so) for who will qualify, or not qualify, for postseason play when we net out
    the results of our two models. One predictive model had a lower error rate and
    therefore a higher model accuracy rate, but the other had a higher AUC.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们的逻辑回归分析，每场常规赛允许的得分和每场常规赛的得分总体上都是同等有效的预测因子（或者至少大致如此），用于预测谁将或不会获得季后赛资格。一个预测模型的错误率较低，因此模型准确率较高，但另一个模型的AUC值更高。
- en: Once more, all of our tests produced statistically significant results, but
    there’s no evidence that defense *clearly and unmistakably* matters more than
    offense.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，我们所有的测试都产生了具有统计学意义的成果，但没有证据表明防守*明显且无疑*比进攻更重要。
- en: Otherwise, it’s absolutely necessary to standardize variables when they’re on
    different scales; at other times, it’s a best practice to standardize the same
    variables when the data spans several years. Converting raw data to z-scores is
    probably the most common standardization method, but we’ll introduce other standardization
    techniques in chapter 19.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，当变量处于不同尺度时，标准化变量绝对是必要的；在其他时候，当数据跨越数年时，标准化相同的变量是一种最佳实践。将原始数据转换为z分数可能是最常见的标准化方法，但我们在第19章中还将介绍其他标准化技术。
- en: It’s critical to understand which statistical test to run under which conditions.
    In prior chapters, we’ve run t-tests and chi-square tests; however, ANOVAs should
    be your method of choice when comparing three or more data series when there is
    a quantitative target variable and categorical predictor variables. Linear regressions
    should be fit when working with a continuous target variable; logistic regressions
    should be fit instead when working with a binary target variable.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解在何种条件下运行哪种统计测试是至关重要的。在前几章中，我们运行了t检验和卡方检验；然而，当比较三个或更多数据系列，并且存在定量目标变量和分类预测变量时，方差分析应该是你的首选方法。当处理连续目标变量时，应拟合线性回归；当处理二元目标变量时，应拟合逻辑回归。
- en: Logistic regression is probably the most common of classification models. To
    understand and apply the results correctly, it’s absolutely critical to know the
    differences between probabilities, odds ratios, and log odds, and to understand
    how to convert values from one to the other. It’s equally critical to know how
    to create and interpret a confusion matrix and how to derive key measures from
    it to accurately assess model fit.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑回归可能是最常见的分类模型。为了正确理解和应用结果，了解概率、优势比和log odds之间的差异，以及如何将值从一种转换为另一种，是绝对关键的。同样关键的是了解如何创建和解释混淆矩阵，以及如何从中推导出关键指标以准确评估模型拟合度。
