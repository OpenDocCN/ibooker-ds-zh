- en: Part 2\. Building a Node web application
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分\. 构建Node网络应用程序
- en: Node.js underpins any MEAN application, so that’s where you’ll start. Throughout
    [part 2](#part02), you’ll build a data-driven web application by using Node.js,
    Express, and MongoDB. You’ll learn the individual technologies as you go, steadily
    building up the application to a point where you have a fully functioning Node
    web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是任何MEAN应用程序的基础，因此您将从这里开始。在整个[第2部分](#part02)中，您将通过使用Node.js、Express和MongoDB来构建一个数据驱动的Web应用程序。您将在学习过程中了解这些技术，并逐步构建应用程序，直到您拥有一个完全功能的Node网络应用程序。
- en: In [chapter 3](kindle_split_014.xhtml#ch03), you’ll get going by creating and
    setting up a MEAN project, getting acquainted with Express before getting a much
    deeper understanding of Express by building out a static version of the application
    in [chapter 4](kindle_split_015.xhtml#ch04). Taking what you’ve learned about
    the application so far, in [chapter 5](kindle_split_016.xhtml#ch05) you’ll work
    with MongoDB and Mongoose to design and build the data model you’ll need.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_014.xhtml#ch03)中，您将通过创建和设置一个MEAN项目开始，在深入了解Express之前先熟悉Express，然后在[第4章](kindle_split_015.xhtml#ch04)中通过构建应用程序的静态版本来获得更深入的理解。在[第5章](kindle_split_016.xhtml#ch05)中，您将使用MongoDB和Mongoose来设计和构建您需要的数据库模型。
- en: Good application architecture should include a data API rather than tightly
    couple database interactions with application logic. In [chapter 6](kindle_split_017.xhtml#ch06),
    you’ll create a REST API by using Express, MongoDB, and Mongoose before tying
    it back into the application in [chapter 7](kindle_split_018.xhtml#ch07) by consuming
    the REST API from your static application. As you get to the end of [part 2](#part02),
    you’ll have a data-driven website using Node.js, MongoDB, and Express, as well
    as a fully functioning REST API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的应用程序架构应包括数据API，而不是将数据库交互与应用程序逻辑紧密耦合。在[第6章](kindle_split_017.xhtml#ch06)中，您将使用Express、MongoDB和Mongoose创建一个REST
    API，然后在[第7章](kindle_split_018.xhtml#ch07)中将它连接回应用程序，通过从静态应用程序中消费REST API来实现。当您到达[第2部分](#part02)的结尾时，您将拥有一个使用Node.js、MongoDB和Express构建的数据驱动网站，以及一个完全功能的REST
    API。
- en: Chapter 3\. Creating and setting up a MEAN project
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 创建和设置MEAN项目
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Managing dependencies by using npm and package.json
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm和package.json管理依赖项
- en: Creating and configuring Express projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置Express项目
- en: Setting up an MVC environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置MVC环境
- en: Adding Twitter Bootstrap for layout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Twitter Bootstrap进行布局
- en: Publishing to a live URL, and using Git and Heroku
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到实时URL，并使用Git和Heroku
- en: In this chapter, you’ll start building your application. Remember from [chapters
    1](kindle_split_011.xhtml#ch01) and [2](kindle_split_012.xhtml#ch02) that, throughout
    this book, you’re going to build an application called Loc8r—a location-aware
    web application that displays listings near users and invites people to log in
    and leave reviews.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将开始构建您的应用程序。记住，从[第1章](kindle_split_011.xhtml#ch01)和[第2章](kindle_split_012.xhtml#ch02)中，在整个本书中，您将构建一个名为Loc8r的应用程序——一个位置感知的Web应用程序，它显示用户附近的列表，并邀请人们登录并留下评论。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Getting the source code**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取源代码**'
- en: 'The source code for this application is on GitHub at [https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2).
    Each chapter with a significant update will have its own branch. We encourage
    you to build it up from scratch through the course of the book, but if you want
    to, you can get the code that you’ll be building throughout this chapter from
    the chapter-03 branch on GitHub. In a fresh folder in terminal, if you already
    have Git installed, the following two commands will clone it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的源代码位于GitHub上的[https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2)。每个有重大更新的章节都将有自己的分支。我们鼓励您从头开始构建，但如果您愿意，您可以从GitHub上的chapter-03分支获取本章中将要构建的代码。在终端的新文件夹中，如果您已经安装了Git，以下两个命令将克隆它：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives you a copy of the code that’s stored on GitHub. To run the application,
    you need to install some dependencies with the following commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了存储在GitHub上的代码副本。要运行应用程序，您需要使用以下命令安装一些依赖项：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don’t worry if some of this doesn’t make sense yet or if some of the commands
    aren’t working. During this chapter, you’ll install these technologies as you
    go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一些内容现在还不明白，或者一些命令不起作用，请不要担心。在本章中，您将在学习过程中安装这些技术。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the MEAN stack, Express is the Node web application framework. Together,
    Node.js and Express underpin the entire stack, so you’ll start there. In terms
    of building up the application architecture, [figure 3.1](#ch03fig01) shows where
    this chapter focuses. You’ll do two things:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MEAN 堆栈中，Express 是 Node 网络应用程序框架。Node.js 和 Express 一起构成了整个堆栈的基础，所以你将从那里开始。在构建应用程序架构方面，[图
    3.1](#ch03fig01) 显示了本章的重点。你将做两件事：
- en: Create the project and the encapsulating Express application that will house
    everything except the database.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目以及封装的 Express 应用程序，该应用程序将包含除数据库之外的所有内容。
- en: Set up the main Express application.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置主 Express 应用程序。
- en: Figure 3.1\. Creating the encapsulating Express application and starting to
    set up the main Express application
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. 创建封装的 Express 应用程序并开始设置主 Express 应用程序
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig01_alt.jpg)'
- en: You’ll start with a bit of groundwork by looking at Express and seeing how you
    can manage dependencies and modules by using npm and a package.json file. You’ll
    need this background knowledge to get going and set up an Express project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从一些基础工作开始，通过查看 Express 来了解如何使用 npm 和 package.json 文件来管理依赖项和模块。你需要这些背景知识来开始并设置一个
    Express 项目。
- en: Before you do anything, make sure that you have everything you need installed
    on your machine. When that’s done, look at creating new Express projects from
    the command line and the various options you can specify at this point.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在你做任何事情之前，确保你的机器上已经安装了所有你需要的东西。当这一切都准备好了，看看如何从命令行创建新的 Express 项目以及你可以在此时指定的各种选项。
- en: Express is great, but you can make it better—and get to know it better—by tinkering
    a little and changing some things around. This involves a quick look at model-view-controller
    (MVC) architecture. Here is where you get under the hood of Express a little and
    see what it’s doing by modifying it to have a clear MVC setup.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Express 很好，但你可以通过稍微调整一些东西来使其更好，并更好地了解它。这涉及到对模型-视图-控制器（MVC）架构的快速了解。这里你可以稍微深入
    Express 的内部，通过修改它来获得一个清晰的 MVC 设置。
- en: When the framework of Express is set up as you want it, you’ll then include
    Twitter’s Bootstrap framework and make the site responsive by updating the Pug
    templates. In the final step of this chapter, you’ll push the modified, responsive,
    MVC Express application to a live URL using Heroku and Git.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Express 框架按照你的意愿设置好时，你将包括 Twitter 的 Bootstrap 框架，并通过更新 Pug 模板使网站响应式。在本章的最后一步，你将使用
    Heroku 和 Git 将修改后的、响应式的 MVC Express 应用程序推送到一个实时 URL。
- en: 3.1\. A brief look at Express, Node, and npm
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 简要了解 Express、Node 和 npm
- en: As previously mentioned, Express is a web application framework for Node. In
    basic terms, an Express application is a Node application that happens to use
    Express as the framework. Remember from [chapter 1](kindle_split_011.xhtml#ch01)
    that npm is a package manager that gets installed when you install Node, which
    enables you to download Node modules or packages to extend the functionality of
    your application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Express 是 Node 的一个网络应用程序框架。在基本术语中，一个 Express 应用程序是一个恰好使用 Express 作为框架的
    Node 应用程序。记得从[第 1 章](kindle_split_011.xhtml#ch01)中提到的 npm 是一个包管理器，当你安装 Node 时会自动安装，这使你能够下载
    Node 模块或包来扩展应用程序的功能。
- en: But how do these things work together, and how do you use them? A key piece
    of this puzzle is the package.json file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些是如何协同工作的，以及你如何使用它们呢？这个谜题的关键部分是 package.json 文件。
- en: 3.1.1\. Defining packages with package.json
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. 使用 package.json 定义包
- en: In every Node application, you should have a file in the root folder of the
    application called package.json. This file can contain various metadata about
    a project, including the packages that it depends on to run. The following listing
    shows an example package.json file that you might find in the root of an Express
    project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 Node 应用程序中，你都应该在应用程序的根目录中有一个名为 package.json 的文件。此文件可以包含有关项目的一些元数据，包括它运行所依赖的包。以下列表显示了一个你可能在
    Express 项目的根目录中找到的示例 package.json 文件。
- en: Listing 3.1\. Example package.json file in a new Express project
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 新 Express 项目中的示例 package.json 文件
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Various metadata defining the application**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义应用程序的各种元数据**'
- en: '***2*** **Package dependencies needed for the application to run**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **应用程序运行所需的包依赖项**'
- en: This listing is the file in its entirety, so it’s not particularly complex.
    Various metadata at the top of the file is followed by the dependencies section.
    In this default installation of an Express project, quite a few dependencies are
    required for Express to run, but you don’t need to worry about what each one does.
    Express itself is modular so that you can add components or upgrade them individually.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表是文件的完整内容，因此它并不特别复杂。文件顶部的各种元数据后面跟着依赖项部分。在这个 Express 项目的默认安装中，Express 运行需要许多依赖项，但您不必担心每个依赖项的作用。Express
    本身是模块化的，这样您可以单独添加组件或升级它们。
- en: 3.1.2\. Working with dependency versions in package.json
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 在 package.json 中处理依赖项版本
- en: Alongside the name of each dependency is the version number that the application
    will use. Notice that they’re prefixed with either a tilde (`~)` or a caret (^).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个依赖项的名称旁边是应用程序将使用的版本号。请注意，它们前面带有 tilde (`~`) 或 caret (^)。
- en: 'Take a look at the dependency definition for Express 4.16.3, which specifies
    a particular version at three levels:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Express 4.16.3的依赖项定义，它指定了三个级别的特定版本：
- en: Major version (4)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主版本 (4)
- en: Minor version (16)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要版本 (16)
- en: Patch version (3)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁版本 (3)
- en: 'Prefixing the whole version number with a ~ is like replacing the patch version
    with a wildcard, which means that the application will use the latest patch version
    available. Similarly, prefixing the version with a caret (^) is like replacing
    the minor version with a wildcard. This has become best practice, because patches
    and minor versions should contain only fixes that won’t have any effect on the
    application. But new major versions are released when a breaking change is made,
    so you want to avoid automatically using later versions of these in case the breaking
    change affects your application. If you find a module that breaks these rules,
    it’s easy to specify an exact version to use by removing any prefixes. Note that
    it’s good practice to always specify the full version and not use wildcards for
    this reason: you always have a reference for a specific version that you *know*
    works.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个版本号前加上 ~ 就像用通配符替换了补丁版本，这意味着应用程序将使用可用的最新补丁版本。同样，在版本前加上一个 caret (^) 就像用通配符替换了次要版本。这已成为最佳实践，因为补丁和次要版本应只包含不会对应用程序产生任何影响的修复。但是，当进行破坏性更改时，会发布新的主要版本，因此您希望避免自动使用这些版本的后续版本，以防破坏性更改影响您的应用程序。如果您发现一个违反这些规则的模块，可以通过移除任何前缀来轻松指定要使用的确切版本。请注意，出于这个原因，始终指定完整版本而不使用通配符是良好的实践：您始终有一个您
    *知道* 可以正常工作的特定版本的参考。
- en: 3.1.3\. Installing Node dependencies with npm
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3\. 使用 npm 安装 Node 依赖项
- en: Any Node application or module can have dependencies defined in a package.json
    file. Installing them is easy and is done the same way regardless of the application
    or module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Node 应用程序或模块都可以在 package.json 文件中定义依赖项。安装它们很容易，并且无论应用程序或模块如何，都是用相同的方式进行安装。
- en: 'Using a terminal prompt in the same folder as the package.json file, run the
    following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 package.json 文件相同的文件夹中使用终端提示符，运行以下命令：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command tells npm to install all the dependencies listed in the package.json
    file. When you run it, npm downloads all the packages listed as dependencies and
    installs them in a specific folder in the application, called node_modules. [Figure
    3.2](#ch03fig02) illustrates the three key parts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉 npm 安装 package.json 文件中列出的所有依赖项。当您运行它时，npm 下载所有列出的依赖项包，并将它们安装到应用程序的特定文件夹中，该文件夹称为
    node_modules。[图 3.2](#ch03fig02) 说明了三个关键部分。
- en: Figure 3.2\. The npm modules defined in a package.json file are downloaded and
    installed in the application’s node_modules folder when you run the `npm install`
    terminal command.
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 当您运行 `npm install` 终端命令时，package.json 文件中定义的 npm 模块将被下载并安装到应用程序的 node_modules
    文件夹中。
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig02_alt.jpg)'
- en: npm installs each package into its own subfolder because each one is effectively
    a Node package in its own right. As such, each package also has its own package.json
    file defining the metadata, including the specific dependencies. It’s quite common
    for a package to have its own node_modules folder. You don’t need to worry about
    manually installing all the nested dependencies, though, because this task is
    handled by the original `npm install` command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: npm 将每个包安装到其自己的子文件夹中，因为每个包本身就是一个 Node 包。因此，每个包也有自己的 package.json 文件，定义了元数据，包括特定的依赖项。一个包拥有自己的
    node_modules 文件夹是很常见的。尽管如此，您不必担心手动安装所有嵌套依赖项，因为这项任务由原始的 `npm install` 命令处理。
- en: Adding more packages to an existing project
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向现有项目添加更多包
- en: You’re unlikely to have the full list of dependencies for a project right from
    the outset. It’s far more likely that you’ll start with a few key ones that you
    know you’ll need and perhaps some that you always use in your workflow.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能一开始就不会有一个项目的完整依赖项列表。更有可能的是，你会从几个关键依赖项开始，这些依赖项你知道你需要，也许还有一些你在工作流程中总是使用的依赖项。
- en: 'Using npm, it’s easy to add more packages to the application whenever you want.
    Find the name of the package you want to install, open a command prompt in the
    same folder as the package.json file, and then run a simple command like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm，你可以随时轻松地向应用程序添加更多包。找到你想要安装的包的名称，在同一文件夹中打开package.json文件所在的命令提示符，然后运行一个简单的命令，例如：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this command, npm downloads and installs the new package in the node_modules
    folder. The `--save` flag tells npm to add this package to the list of dependencies
    in the package.json file. As of npm version 5, the `--save` flag is no longer
    required, as NPM saves changes to the package.json file automatically. We’ve added
    it here for completeness. When this command is run, npm generates a package-lock.json
    file to maintain versions of dependencies between environments, which is helpful
    when you’re deploying from development to a live server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，npm将下载并安装node_modules文件夹中的新包。`--save`标志告诉npm将此包添加到package.json文件中的依赖项列表中。从npm版本5开始，`--save`标志不再需要，因为NPM会自动将更改保存到package.json文件中。我们在这里添加它是为了完整性。当运行此命令时，npm会生成一个package-lock.json文件，以在环境之间维护依赖项的版本，这在从开发环境部署到实时服务器时非常有用。
- en: Updating packages to later versions
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新包到较新版本
- en: 'The only time npm downloads and reinstalls existing packages is when you upgrade
    to a new version. When you run `npm install`, npm goes through all the dependencies
    and checks the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: npm下载并重新安装现有包的唯一情况是你升级到新版本。当你运行`npm install`时，npm会遍历所有依赖项并检查以下内容：
- en: The version defined in the package-lock.json file (if it exists) or package.json
    (if it doesn’t)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: package-lock.json文件中定义的版本（如果存在）或package.json（如果不存在）
- en: The latest matching version on npm (which may be different if you used `~` or
    `^`)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm上的最新匹配版本（这可能与你使用了`~`或`^`不同）
- en: The version of the module (if there is one) in the node_modules folder
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: node_modules文件夹中模块的版本（如果有的话）
- en: If your installed version is different from the definition in the package.json
    (or package-lock.json) file, npm downloads and installs the defined version. Similarly,
    if you’re using a wildcard, and a later matching version is available, npm downloads
    and installs it in place of the previous version.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的安装版本与package.json（或package-lock.json）文件中的定义不同，npm将下载并安装定义的版本。同样，如果你正在使用通配符，并且有更晚的匹配版本可用，npm将下载并安装它以替换之前的版本。
- en: With that knowledge under your belt, you can start creating your first Express
    project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这些知识的基础上，你可以开始创建你的第一个Express项目。
- en: 3.2\. Creating an Express project
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 创建Express项目
- en: 'All journeys must have a starting point, which for building a MEAN application
    is creating a new Express project. To create an Express project, you’ll need to
    have five key things installed on your development machine:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有旅程都必须有一个起点，对于构建MEAN应用程序来说，这个起点就是创建一个新的Express项目。要创建一个Express项目，你需要在你的开发机器上安装以下五个关键组件：
- en: Node and npm
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node和npm
- en: The Express generator installed globally
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局安装的Express生成器
- en: Git
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Heroku
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku
- en: Suitable command-line interface (CLI) or terminal
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合的命令行界面（CLI）或终端
- en: 3.2.1\. Installing the pieces
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 安装组件
- en: If you don’t have Node, npm, or the Express generator installed yet, see [appendix
    A](kindle_split_026.xhtml#app01) for instructions and pointers to online resources.
    All can be installed on Windows, macOS, and all mainstream Linux distributions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装Node、npm或Express生成器，请参阅[附录A](kindle_split_026.xhtml#app01)中的说明和在线资源指南。所有这些都可以安装在Windows、macOS和所有主流Linux发行版上。
- en: By the end of this chapter, you’ll also have used Git to manage the source control
    of your Loc8r application and pushed it to a live URL hosted by Heroku. Please
    take a look through [appendix B](kindle_split_031.xhtml#app02), which guides you
    through setting up Git and Heroku.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '到本章结束时，你还将使用Git来管理Loc8r应用程序的源代码控制，并将其推送到由Heroku托管的实时URL。请参阅[附录B](kindle_split_031.xhtml#app02)，其中将指导你设置Git和Heroku。 '
- en: Depending on your operating system, you may need to install a new CLI or terminal.
    See [appendix B](kindle_split_031.xhtml#app02) to find out whether this requirement
    applies to you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，您可能需要安装一个新的 CLI 或终端。请参阅[附录B](kindle_split_031.xhtml#app02)以了解此要求是否适用于您。
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, we’ll often refer to the CLI as *terminal*. When we say
    “Run this command in terminal,” we mean run it in whichever CLI you’re using.
    When terminal commands are included as code snippets throughout this book, they
    start with a `$`. You shouldn’t type this symbol in terminal; it’s simply there
    to denote a command-line statement. If you’re entering the echo command `$ echo
    'Welcome to Getting MEAN'`, for example, type `echo 'Welcome to Getting MEAN'`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们经常将 CLI 称为*终端*。当我们说“在终端中运行此命令”时，意味着在您使用的任何 CLI 中运行它。当终端命令作为本书中的代码片段包含时，它们以
    `$` 开头。您不应在终端中键入此符号；它只是用来表示命令行语句。例如，如果您输入 echo 命令 `$ echo 'Welcome to Getting
    MEAN'`，则键入 `echo 'Welcome to Getting MEAN'`。
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.2.2\. Verifying the installations
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 验证安装
- en: 'To create a new Express project, you must have Node and npm installed, and
    you must also have the Express generator installed globally. You can verify by
    checking for the version numbers in terminal, using the following commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 Express 项目，你必须已安装 Node 和 npm，并且还必须全局安装 Express 生成器。您可以通过在终端中检查版本号来验证，使用以下命令：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each of these commands should output a version number to terminal. If one of
    them fails, head to [appendix A](kindle_split_026.xhtml#app01) for details on
    how to install it again.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些命令都应该在终端输出一个版本号。如果其中之一失败，请转到[附录A](kindle_split_026.xhtml#app01)以获取如何重新安装的详细信息。
- en: 3.2.3\. Creating a project folder
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3\. 创建项目文件夹
- en: Assuming that all is good, start by creating a new folder on your machine called
    loc8r. This folder can be on your desktop, in your documents, or in a Dropbox
    folder; the location doesn’t matter as long as you have full read and write access
    rights to the folder.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，首先在您的机器上创建一个名为 loc8r 的新文件夹。这个文件夹可以放在您的桌面上、您的文档中或 Dropbox 文件夹中；位置不重要，只要您有对该文件夹的完整读写权限即可。
- en: Simon personally does a lot of his MEAN development in Dropbox folders so that
    his work is immediately backed up and accessible on any of his machines. If you’re
    in a corporate environment, however, this approach may not be suitable for you,
    so create the folder wherever you think is best.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 西蒙在他的 Dropbox 文件夹中进行了大量的 MEAN 开发，以便他的工作可以立即备份并在他的任何机器上访问。然而，如果您处于企业环境中，这种方法可能不适合您，因此请创建您认为最好的文件夹。
- en: 3.2.4\. Configuring an Express installation
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. 配置 Express 安装
- en: An Express project is installed from the command line, and the configuration
    is passed in with parameters of the command you use. If you’re not familiar with
    using the command line, don’t worry; none of what we’ll go through in the book
    is particularly complex, and it’s all easy to remember. Once you’ve started using
    it, you’ll probably love how it makes some operations so fast.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Express 项目是通过命令行安装的，配置是通过你使用的命令的参数传递的。如果你不熟悉使用命令行，不要担心；本书中我们将要讨论的内容并不特别复杂，而且都很容易记住。一旦你开始使用它，你可能会爱上它使某些操作变得如此快速。
- en: 'You can install Express in a folder with a simple command (but don’t do this
    yet):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用简单的命令在文件夹中安装 Express（但不要现在这样做）：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command installs the framework with default settings in your current folder.
    This step probably is a good start, but take a look at some configuration options
    first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用默认设置在当前文件夹中安装框架。这一步可能是一个好的开始，但首先看看一些配置选项。
- en: Configuration options when creating an Express project
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 Express 项目时的配置选项
- en: 'What can you configure when creating an Express project this way? You can specify
    the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建 Express 项目时可以配置什么？您可以指定以下内容：
- en: Which HTML template engine to use
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用哪个 HTML 模板引擎
- en: Which CSS preprocessor to use
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用哪个 CSS 预处理器
- en: Whether to create a .gitignore file
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否创建一个 .gitignore 文件
- en: A default installation uses the Jade template engine, but it has no CSS preprocessing
    or session support. You can specify a few options, as laid out in [table 3.1](#ch03table01).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认安装使用 Jade 模板引擎，但它没有 CSS 预处理或会话支持。你可以指定一些选项，如[表3.1](#ch03table01)中所述。
- en: Table 3.1\. Command-line configuration options for creating a new Express project
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1\. 创建新的 Express 项目的命令行配置选项
- en: '| Configuration command | Effect |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 配置命令 | 影响 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| --css=less&#124;stylus | Adds a CSS preprocessor to your project, either
    Less or Stylus, depending on which you type in the command |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --css=less&#124;stylus | 根据你在命令中输入的内容，将 CSS 预处理器添加到你的项目中，无论是 Less 还是 Stylus
    |'
- en: '| --view=ejs&#124;hbs&#124;pug | Changes the HTML template engine from Jade
    to EJS, Handlebars, or Pug, depending on which you type |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --view=ejs&#124;hbs&#124;pug | 根据你输入的选项，将 HTML 模板引擎从 Jade 更改为 EJS、Handlebars
    或 Pug |'
- en: '| --git | Adds a .gitignore file to the directory |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --git | 在目录中添加一个 .gitignore 文件 |'
- en: 'You aren’t going to do that here, but if you want to create a project that
    uses the Less CSS preprocessor and the Handlebars template engine and includes
    a .gitignore file, you’d run the following command in terminal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里不会这样做，但如果你想创建一个使用 Less CSS 预处理器和 Handlebars 模板引擎并包含 .gitignore 文件的项目，你将在终端中运行以下命令：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To keep things simple in your project, you won’t use CSS preprocessing, so you
    can stick with the default of plain CSS. But you do need to use a template engine,
    so in the next section, you’ll take a quick look at the options.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的项目保持简单，你不会使用 CSS 预处理器，因此你可以坚持使用默认的纯 CSS。但是，你需要使用一个模板引擎，所以在下文中，你会快速浏览一下选项。
- en: Different template engines
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不同的模板引擎
- en: When you’re using Express in this way, a few template options are available,
    including Jade, EJS, Handlebars, and Pug. The basic workflow of a template engine
    is creating the HTML template, including placeholders for data, and then passing
    it some data. Then the engine compiles the template and data together to create
    the final HTML markup that the browser will receive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式使用 Express 时，有一些模板选项可供选择，包括 Jade、EJS、Handlebars 和 Pug。模板引擎的基本工作流程是创建
    HTML 模板，包括数据占位符，然后传递一些数据。然后引擎将模板和数据一起编译，以创建浏览器将接收的最终 HTML 标记。
- en: All engines have their own merits and quirks, and if you already have a preferred
    one, that’s fine. In this book, you’ll use Pug. Pug is powerful and provides all
    the functionality you’re going to need. Pug is the next evolution of Jade; due
    to trademark issues, the creators of Jade had to rename it, and they chose Pug.
    Jade still exists, so existing projects won’t break, but all new releases are
    under the name Pug. Jade was (and still is) the default template engine in Express,
    so you’ll find that most examples and projects online use it, which means that
    it’s helpful to be familiar with the syntax. Finally, the minimal style of Jade
    and Pug make them ideal for code samples in a book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引擎都有自己的优点和特性，如果你已经有一个偏好的引擎，那很好。在这本书中，你将使用 Pug。Pug 功能强大，提供了你将要需要的所有功能。Pug 是
    Jade 的下一代；由于商标问题，Jade 的创造者不得不将其重命名，他们选择了 Pug。Jade 仍然存在，所以现有的项目不会中断，但所有的新版本都使用
    Pug 命名。Jade 曾经（并且仍然是）Express 的默认模板引擎，所以你会发现大多数在线的示例和项目都使用它，这意味着熟悉语法是有帮助的。最后，Jade
    和 Pug 的最小化风格使它们非常适合在书中展示代码示例。
- en: A quick look at Pug
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速了解 Pug
- en: Pug is unusual compared with the other template engines, in that it doesn’t
    contain HTML tags in the templates. Instead, Pug takes a rather minimalist approach,
    using tag names, indentation, and a CSS-inspired reference method to define the
    structure of the HTML. The exception is the `<div>` tag. Because it’s so common,
    if the tag name is omitted from the template, Pug assumes that you want a `<div>`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模板引擎相比，Pug 很不寻常，因为它在模板中不包含 HTML 标签。相反，Pug 采用了一种相当简约的方法，使用标签名称、缩进和受 CSS 启发的引用方法来定义
    HTML 的结构。例外的是 `<div>` 标签。因为它非常常见，如果模板中省略了标签名称，Pug 假设你想要一个 `<div>`。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Pug templates must be indented with spaces, not tabs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 模板必须使用空格缩进，而不是制表符。
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following code snippet shows a simple example of a Pug template:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个简单的 Pug 模板示例：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Pug template contains no HTML tags**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **Pug 模板不包含 HTML 标签**'
- en: 'This snippet shows the compiled output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段显示了编译后的输出：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Compiled output is recognizable HTML**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **编译后的输出是可识别的 HTML**'
- en: From the first lines of the input and output, you should be able to see that
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入和输出的第一行，你应该能够看到：
- en: With no tag name specified, a `<div>` is created.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有指定标签名称，将创建一个 `<div>`。
- en: '`#banner` in Pug becomes `id="banner"` in HTML.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pug 中 `#banner` 变成 HTML 中的 `id="banner"`。
- en: '`.page-header` in Pug becomes `class="page-header"` in HTML.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pug 中 `.page-header` 变成 HTML 中的 `class="page-header"`。
- en: Note also that the indentation in Pug is important, as it defines the nesting
    of the HTML output. Remember that the indentation must be done with spaces, not
    tabs!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Pug 中的缩进很重要，因为它定义了 HTML 输出的嵌套。记住，缩进必须使用空格，而不是制表符！
- en: To recap, you don’t need a CSS preprocessor, but you do want the Pug template
    engine. How about the .gitignore file?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，你不需要CSS预处理器，但确实想要Pug模板引擎。那么.gitignore文件呢？
- en: A quick intro to .gitignore files
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: .gitignore文件的快速介绍
- en: A .gitignore file is a simple configuration file that sits in the root of your
    project folder. This file specifies which files and folders Git commands should
    ignore. In essence, it says, “Pretend these files don’t exist, and don’t track
    them,” meaning that they won’t end up in source control.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: .gitignore文件是一个简单的配置文件，位于项目文件夹的根目录。此文件指定Git命令应忽略哪些文件和文件夹。本质上，它说，“假装这些文件不存在，不要跟踪它们”，这意味着它们不会出现在源控制中。
- en: Common examples include log files and the node_modules folder. Log files don’t
    need to be up on GitHub for everyone to see, and your Node dependencies should
    be installed from npm whenever your application is downloaded. You’ll be using
    Git in section [3.5](#ch03lev1sec5), so ask the Express generator to create a
    file for you.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的例子包括日志文件和node_modules文件夹。日志文件不需要上传到GitHub供每个人查看，而且你的Node依赖项应该在应用程序下载时从npm安装。你将在第[3.5节](#ch03lev1sec5)中使用Git，所以请让Express生成器为你创建一个文件。
- en: With that starting knowledge behind you, it’s time to create a project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你掌握这些基础知识之后，是时候创建一个项目了。
- en: 3.2.5\. Creating an Express project and trying it out
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.5. 创建Express项目并尝试运行
- en: 'You know the basic command for creating an Express project and have decided
    to use the Pug template engine. You’ll also let it generate a .gitignore file
    for you. Now create a new project. In section [3.2.3](#ch03lev2sec6), you should
    have created a new folder called loc8r. Navigate to this folder in terminal, and
    run the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道了创建Express项目的基本命令，并决定使用Pug模板引擎。你还将让它为你生成一个.gitignore文件。现在创建一个新的项目。在第[3.2.3节](#ch03lev2sec6)中，你应该创建了一个名为loc8r的新文件夹。在终端中导航到这个文件夹，并运行以下命令：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command creates a bunch of folders and files inside the loc8r folder that
    form the basis of your Loc8r application. But you’re not quite ready yet. Next,
    you need to install the dependencies. As you may remember, you do this by running
    the following command from a terminal prompt in the same folder as the package.json
    file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在loc8r文件夹内创建了一系列文件夹和文件，这些文件构成了你的Loc8r应用程序的基础。但你现在还没有完全准备好。接下来，你需要安装依赖项。你可能还记得，你可以通过在package.json文件所在的文件夹中的终端提示符下运行以下命令来完成此操作：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As soon as you run it, your terminal window lights up with all the things it’s
    downloading. When it finishes, the application is ready for a test drive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，你的终端窗口就会亮起，显示所有正在下载的内容。当它完成后，应用程序就准备好测试了。
- en: Trying it out
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试运行
- en: Make sure that everything works as expected. In section [3.2.6](#ch03lev2sec9),
    we’ll show you a better way of running the project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一切按预期工作。在第[3.2.6节](#ch03lev2sec9)中，我们将向您展示运行项目的更好方法。
- en: 'In terminal, in the loc8r folder, run the following command (but if your application
    is in a folder with a different name, swap out `loc8r` accordingly):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，在loc8r文件夹中，运行以下命令（但如果你的应用程序在一个不同名称的文件夹中，相应地替换`loc8r`）：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see a confirmation similar to this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似的确认信息：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This confirmation means that the Express application is running. You can see
    it in action by opening a browser and heading over to localhost:3000\. We hope
    that you’ll see something like the screenshot in [figure 3.3](#ch03fig03).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个确认意味着Express应用程序正在运行。你可以通过打开浏览器并转到localhost:3000来看到它在行动。我们希望你会看到类似于[图3.3](#ch03fig03)中的截图。
- en: Figure 3.3\. Landing page for a bare-bones Express project
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3. 纯粹的Express项目的着陆页
- en: '![](Images/03fig03_alt.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片3.3的替代文本](Images/03fig03_alt.jpg)'
- en: Admittedly, this isn’t exactly ground-breaking stuff, but getting the Express
    application up and running to the point of working in a browser was easy, right?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不完全是开创性的东西，但将Express应用程序运行起来并在浏览器中工作是非常容易的，对吧？
- en: If you head back to terminal now, you should see a couple of log statements
    confirming that the page has been requested and that a stylesheet has been requested.
    To get to know Express a little better, take a look at what’s going on here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在回到终端，你应该会看到一些日志语句确认页面已被请求，并且样式表已被请求。为了更好地了解Express，看看这里发生了什么。
- en: How Express handles the requests
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Express如何处理请求
- en: The default Express landing page is simple. The page contains a small amount
    of HTML, of which some of the text content is pushed as data by the Express route.
    There’s also a CSS file. The logs in terminal should confirm that this is what
    Express requested and has returned to the browser. But how?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Express着陆页很简单。页面包含少量HTML，其中一些文本内容是通过Express路由推送到数据中的。还有一个CSS文件。终端中的日志应该确认这是Express请求并返回给浏览器的内容。但这是如何实现的呢？
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About Express middleware**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于Express中介件**'
- en: The app.js file contains a bunch of lines that start with `app.use` somewhere
    in the middle. These lines are known as *middleware*. When a request comes in
    to the application, it passes through each piece of middleware in turn. Each piece
    of middleware may or may not do something with the request, but it’s always passed
    on to the next one until it reaches the application logic itself, which returns
    a response.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: app.js文件中包含一些以`app.use`开头的行。这些行被称为*中介件*。当请求进入应用程序时，它会依次通过每一块中介件。每一块中介件可能会也可能不会对请求进行操作，但它总是传递给下一块，直到达到应用程序逻辑本身，然后返回一个响应。
- en: Take `app.use(express.cookieParser());`, for example. This line takes an incoming
    request, parses out any of the cookie information, and attaches the data to the
    request in a way that makes it easy to reference in the controller code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以`app.use(express.cookieParser());`为例。这一行接收一个传入的请求，解析出任何cookie信息，并以一种便于在控制器代码中引用的方式将数据附加到请求上。
- en: You don’t need to know what each piece of middleware does right now, but you
    may well find yourself adding to this list as you build out applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不需要知道每块中介件具体做什么，但随着你构建应用程序，你可能会发现自己正在添加到这个列表中。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: All requests to the Express server run through the middleware defined in the
    app.js file (see the sidebar “[About Express middleware](#ch03sb03)”). As well
    as doing other things, a default piece of middleware looks for paths to static
    files. When the middleware matches the path against a file, Express returns this
    asynchronously, ensuring that the Node.js process isn’t tied up with this operation
    and therefore blocking other operations. When a request runs through all the middleware,
    Express attempts to match the path of the request against a defined route. We’ll
    get into this topic in a bit more detail in section [3.3.3](#ch03lev2sec12).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对Express服务器的请求都会通过在app.js文件中定义的中介件（见侧边栏“[关于Express中介件](#ch03sb03)”）。除了做其他事情外，默认的中介件会查找静态文件的路径。当中介件将路径与文件匹配时，Express会异步返回该文件，确保Node.js进程不会被此操作占用，从而阻止其他操作。当请求通过所有中介件后，Express会尝试将请求的路径与定义的路由匹配。我们将在3.3.3节（#ch03lev2sec12）中更详细地介绍这个主题。
- en: '[Figure 3.4](#ch03fig04) illustrates this flow, using the example of the default
    Express homepage from [figure 3.3](#ch03fig03). The flow in [figure 3.4](#ch03fig04)
    shows the separate requests made and how Express handles them differently. Both
    requests run through the middleware as a first action, but the outcomes are different.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.4](#ch03fig04)展示了这个流程，使用的是来自[图3.3](#ch03fig03)的默认Express主页的示例。图3.4中的流程显示了分别发出的请求以及Express如何不同地处理它们。两个请求都作为第一个动作通过中介件，但结果却不同。'
- en: Figure 3.4\. The key interactions and processes that Express goes through when
    responding to the request for the default landing page. The HTML page is processed
    by Node to compile data and a view template, and the CSS file is served asynchronously
    from a static folder.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4. Express在响应默认着陆页请求时经历的关键交互和过程。HTML页面由Node处理以编译数据和视图模板，CSS文件则从静态文件夹异步提供。
- en: '![](Images/03fig04_alt.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig04_alt.jpg)'
- en: 3.2.6\. Restarting the application
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.6. 重启应用程序
- en: A Node application compiles before running, so if you make changes to the application
    code while it’s running, they won’t be picked up until the Node process is stopped
    and restarted. Note that this is true only for application code; Jade templates,
    CSS files, and client-side JavaScript can all be updated on the fly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Node应用程序在运行前会进行编译，因此如果你在应用程序运行时修改了代码，这些更改将不会在Node进程停止并重新启动之前被捕获。请注意，这仅适用于应用程序代码；Jade模板、CSS文件和客户端JavaScript都可以在运行时更新。
- en: 'Restarting the Node process is a two-step procedure. First, you have to stop
    the running process in terminal by pressing Ctrl-C. Then, you have to start the
    process again in terminal, using the same command as before: `DEBUG=loc8r:* npm
    start`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 Node 进程是一个两步过程。首先，你必须通过按 Ctrl-C 在终端中停止正在运行的过程。然后，你必须使用之前的相同命令在终端中再次启动该过程：`DEBUG=loc8r:*
    npm start`。
- en: This process doesn’t sound problematic, but when you’re actively developing
    and testing an application, having to do these two steps every time you want to
    check an update becomes quite frustrating. Fortunately, there’s a better way.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程听起来并不成问题，但当你积极开发和测试应用程序时，每次想要检查更新时都必须执行这两个步骤，这会变得相当令人沮丧。幸运的是，有一个更好的方法。
- en: Automatically restarting the application with nodemon
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 nodemon 自动重启应用程序
- en: Some services have been developed to monitor application code and restart the
    process when they detect that changes have been made. One such service, and the
    one you’ll use in this book, is nodemon. nodemon wraps the Node application and,
    other than monitoring for changes, causes no interference.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务已被开发出来以监控应用程序代码，并在检测到更改时重启进程。其中一个这样的服务，也是你将在本书中使用的服务，是 nodemon。nodemon 包装
    Node 应用程序，除了监控更改外，不会造成干扰。
- en: 'To use nodemon, start by installing it globally, much as you did with Express.
    Use npm in terminal:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 nodemon，首先全局安装它，就像你安装 Express 一样。在终端中使用 npm：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the installation is finished, you’ll be able to use nodemon wherever you
    want. Using it is simple. Instead of typing `node` to start the application, you
    type `nodemon`. So, making sure that you’re in the loc8r folder in terminal and
    that you’ve stopped the Node process, if it’s still running, enter the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将能够在任何地方使用 nodemon。使用它很简单。你不需要输入 `node` 来启动应用程序，而是输入 `nodemon`。所以，确保你在终端中位于
    loc8r 文件夹中，并且已经停止了 Node 进程（如果它仍在运行），然后输入以下命令：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should see a few extra lines output to terminal, confirming that nodemon
    is running and that it has started `node ./bin/www`. If you head back over to
    your browser and refresh, you should see that the application is still there.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端中看到几行额外的输出，确认 nodemon 正在运行，并且它已经启动了 `node ./bin/www`。如果你回到浏览器并刷新，你应该看到应用程序仍然在那里。
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: nodemon is intended only for easing the development process in your development
    environment and shouldn’t be used in a live production environment. Projects like
    pm2 or foreman are designed for production use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: nodemon 仅用于简化开发环境中的开发过程，不应在实时生产环境中使用。像 pm2 或 foreman 这样的项目是为生产使用而设计的。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using the supplied Docker environment
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用提供的 Docker 环境
- en: Each chapter comes with a Dockerfile set up. Head over to [appendix B](kindle_split_031.xhtml#app02)
    to see how to install and use the Docker containers. You don’t have to use Docker
    to benefit from this book; it’s been added as a convenience.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都附带一个 Dockerfile 设置。前往[附录 B](kindle_split_031.xhtml#app02)查看如何安装和使用 Docker
    容器。你不必使用 Docker 就能从这本书中受益；它已被添加为便利功能。
- en: 3.3\. Modifying Express for MVC
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 修改 Express 以支持 MVC
- en: Firstly, what is MVC architecture? MVC architecture separates the data (model),
    the display (view) and the application logic (controller). This separation aims
    to remove any tight coupling between the components, theoretically making code
    more maintainable and reusable. A bonus is that these components fit nicely into
    your rapid prototype development approach and allow you to concentrate on one
    aspect at a time as we discuss each part of the MEAN stack.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是 MVC 架构？MVC 架构将数据（模型）、显示（视图）和应用程序逻辑（控制器）分开。这种分离旨在消除组件之间的紧密耦合，从理论上讲，使代码更易于维护和重用。一个额外的好处是，这些组件非常适合你的快速原型开发方法，并允许你一次专注于一个方面，正如我们讨论
    MEAN 栈的每个部分时那样。
- en: Whole books are dedicated to the nuances of MVC, but we won’t go to that depth
    here. We’ll keep the discussion of MVC at a high level and show you how to use
    it with Express to build your Loc8r application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书都是关于 MVC 的细微差别，但在这里我们不会深入探讨。我们将保持对 MVC 的讨论在较高层次，并展示如何使用 Express 来构建你的 Loc8r
    应用程序。
- en: 3.3.1\. A bird’s-eye view of MVC
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. MVC 的鸟瞰图
- en: 'Most applications or sites that you build are designed to take an incoming
    request, do something with it, and return a response. At a simple level, this
    loop in an MVC architecture works like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的大多数应用程序或网站都是设计用来接收传入的请求，对其进行处理，并返回响应。在简单的层面上，MVC 架构中的这个循环是这样工作的：
- en: A request comes into the application.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个请求进入应用程序。
- en: The request gets routed to a controller.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求被路由到控制器。
- en: The controller, if necessary, makes a request to the model.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，控制器会向模型发出请求。
- en: The model responds to the controller.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型响应控制器的请求。
- en: The controller merges the view and the data to form a response.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器将视图和数据合并以形成响应。
- en: The controller sends the generated response to the original requester.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器将生成的响应发送给原始请求者。
- en: In reality, depending on your setup, the controller may compile the view before
    sending the response to the visitor. The effect is the same, though, so keep this
    simple flow in mind as a visual for what will happen in your Loc8r application.
    See [figure 3.5](#ch03fig05) for an illustration of this loop.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，根据您的配置，控制器可能会在向访客发送响应之前编译视图。效果是相同的，所以请记住这个简单的流程，作为您 Loc8r 应用程序中将要发生的事情的视觉参考。参见
    [图 3.5](#ch03fig05) 以了解这个循环的说明。
- en: Figure 3.5\. Request-response flow of a basic MVC architecture
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5\. 基本MVC架构的请求-响应流程
- en: '![](Images/03fig05_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig05_alt.jpg)'
- en: '[Figure 3.5](#ch03fig05) highlights the parts of the MVC architecture and shows
    how they link together. It also illustrates the need for a routing mechanism along
    with the model, view, and controller components.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.5](#ch03fig05) 强调了MVC架构的各个部分，并展示了它们是如何相互连接的。它还说明了需要一个路由机制，以及模型、视图和控制器组件。'
- en: Now that you’ve seen how you want the basic flow of your Loc8r application to
    work, it’s time to modify the Express setup to make this happen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了您希望 Loc8r 应用程序的基本流程如何工作，是时候修改 Express 设置以使其发生。
- en: 3.3.2\. Changing the folder structure
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 修改文件夹结构
- en: 'If you look inside the newly created Express project in the loc8r folder, you
    should see a file structure including a views folder and even a routes folder,
    but no mention of models or controllers. Rather than cluttering the root level
    of the application with some new folders, keep things tidy by creating one new
    folder for all your MVC architecture. Follow these three quick steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看位于 loc8r 文件夹中的新创建的 Express 项目内部，您应该会看到一个包括视图文件夹甚至路由文件夹的文件结构，但没有提到模型或控制器。与其在应用程序的根级别添加一些新文件夹而使事情变得混乱，不如通过创建一个新文件夹来整理所有
    MVC 架构。遵循以下三个快速步骤：
- en: Create a new folder called app_server.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 app_server 的新文件夹。
- en: In app_server, create two new folders called models and controllers.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 app_server 中，创建两个新的文件夹，分别命名为 models 和 controllers。
- en: Move the views and routes folders from the root of the application into the
    app_server folder.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图和路由文件夹从应用程序的根目录移动到 app_server 文件夹。
- en: '[Figure 3.6](#ch03fig06) illustrates these changes and shows the folder structures
    before and after modification.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.6](#ch03fig06) 阐述了这些更改，并显示了修改前后的文件夹结构。'
- en: Figure 3.6\. Changing the folder structure of an Express project into an MVC
    architecture
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.6\. 将 Express 项目的文件夹结构修改为 MVC 架构
- en: '![](Images/03fig06_alt.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig06_alt.jpg)'
- en: Now you have an obvious MVC setup in the application, which makes it easier
    to separate your concerns. But if you try to run the application now, it won’t
    work, as you’ve just broken it. So fix it. Express doesn’t know that you’ve added
    some new folders or have any idea what you want to use them for, so you need to
    tell it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您在应用程序中有一个明显的 MVC 设置，这使得分离您的关注点更容易。但如果你现在尝试运行应用程序，它将不会工作，因为您刚刚破坏了它。所以修复它。Express
    不了解您已经添加了一些新文件夹或对它们有何用途有任何想法，所以您需要告诉它。
- en: 3.3.3\. Using the views and routes relocated folders
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 使用重新定位的视图和路由文件夹
- en: The first thing you need to do is tell Express that you’ve moved the views and
    routes folders, because Express will be looking for them in their old location.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是告诉 Express 您已经移动了视图和路由文件夹，因为 Express 将会在它们旧的位置寻找它们。
- en: Using the new views folder location
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用新的视图文件夹位置
- en: 'Express will be looking for /views, but it needs to look for /app_server/views.
    Changing the path is simple. In app.js, find the following line:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Express 将会寻找 /views，但它需要寻找 /app_server/views。修改路径很简单。在 app.js 中，找到以下行：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Change it to the following (modifications in bold):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 修改如下（加粗部分）：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Your application still won’t work, because you’ve moved the routes, so tell
    Express about them too.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序仍然无法工作，因为您已经移动了路由，所以您也需要告诉 Express 关于它们。
- en: Using the new routes folder location
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用新的路由文件夹位置
- en: 'Express will be looking for /routes, but it needs to look for /app_server/routes.
    Changing this path is also simple. In app.js, find the following lines:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Express 将会寻找 /routes，但它需要寻找 /app_server/routes。修改这个路径也很简单。在 app.js 中，找到以下行：
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change these lines to the following (modifications in bold):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行更改为以下内容（加粗部分为修改）：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Defining variables in ES2015**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 ES2015 中定义变量**'
- en: 'One of the most fundamental changes in ES2015 is deprecation of the `var` keyword
    to define variables. It still works, but instead, you should use one of the two
    new keywords: `const` and `let`. Variables defined with `const` *can’t* be changed
    at a later point in the code, whereas variables defined with `let` *can* be changed.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 中最基本的变化之一是废弃了 `var` 关键字来定义变量。它仍然有效，但你应该使用这两个新关键字之一：`const` 和 `let`。使用
    `const` 定义的变量在代码的后续部分*不能*被更改，而使用 `let` 定义的变量*可以*被更改。
- en: Best practice is to define variables with `const` unless their values are going
    to change. All instances of `var` in app.js can be changed to `const`. We’ve done
    this in the source code for this book; feel free to do it too.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用 `const` 来定义变量，除非它们的值将要改变。app.js 中的所有 `var` 实例都可以更改为 `const`。我们已经在本书的源代码中这样做过；你也可以这样做。
- en: One other thing to bear in mind is that `const` and `let` are block-level variable
    initializers, whereas `var` is a context-level variable initializer. If these
    terms mean nothing to you, read [appendix D](kindle_split_041.xhtml#app04), available
    with the e-book or online from manning.com.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一点需要记住的是，`const` 和 `let` 是块级变量初始化器，而 `var` 是上下文级变量初始化器。如果这些术语对你来说毫无意义，请阅读[附录
    D](kindle_split_041.xhtml#app04)，该附录可在电子书或从 manning.com 在线获取。
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note that you also changed `var` to `const` to upgrade to ES2015\. Check out
    the sidebar “[Defining variables in ES2015](#ch03sb04)” if this concept is new
    to you. If you save your changes and run the application again, you’ll find that
    it works once more!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还将 `var` 更改为 `const` 以升级到 ES2015。如果你对这一概念感到陌生，请查看侧边栏“[在 ES2015 中定义变量](#ch03sb04)”。如果你保存更改并再次运行应用程序，你会发现它再次工作！
- en: 3.3.4\. Splitting controllers from routes
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4\. 从路由中分离控制器
- en: In a default Express setup, controllers are part of the routes, but you want
    to separate them out. Controllers should manage the application logic, and routing
    should map URL requests to controllers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的 Express 设置中，控制器是路由的一部分，但你希望将它们分离出来。控制器应管理应用程序逻辑，而路由应将 URL 请求映射到控制器。
- en: Understanding route definition
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解路由定义
- en: 'To understand how routes work, take a look at the route already set up for
    delivering the default Express homepage. Inside index.js in app_server/routes,
    you should see the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解路由是如何工作的，请查看用于提供默认 Express 主页的路由。在 app_server/routes 的 index.js 内，你应该看到以下代码片段：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Where the router looks for the URL**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **路由器查找 URL 的位置**'
- en: '***2*** **Controller content, albeit very basic right now**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **控制器内容，尽管目前非常基础**'
- en: In the code at ***1*** you can see `router.get('/'`. The router checks internally
    for GET requests that map to the homepage URL path, which is `'/'`. The anonymous
    function that runs the code ***1*** is the controller. This basic example has
    no application code to speak of. So ***1*** and ***2*** are the pieces you want
    to separate here.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的 ***1*** 处你可以看到 `router.get('/')`。路由器内部检查映射到主页 URL 路径的 GET 请求，该路径是 `'/'`。运行代码
    ***1*** 的匿名函数是控制器。这个基本示例没有任何应用程序代码。所以 ***1*** 和 ***2*** 是你想要在这里分离的部分。
- en: Rather than dive straight in and put the controller code in the controllers
    folder, test the approach in the same file first. To do this, you can define the
    anonymous function from the route definition as a named function. Then pass the
    name of this function through as the callback in the route definition. Both of
    these steps are in the following listing, which you can put in place inside app_server/routes/index.js.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接将控制器代码放入控制器文件夹，而是首先在同一个文件中测试这种方法。为此，你可以将路由定义中的匿名函数定义为命名函数。然后，将此函数的名称作为回调传递到路由定义中。这两个步骤在下面的列表中都有，你可以将其放在
    app_server/routes/index.js 内部。
- en: 'Listing 3.2\. Taking the controller code out of the route: step 1'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 将控制器代码从路由中移除：步骤 1
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Gives a name to the arrow function**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **为箭头函数命名**'
- en: '***2*** **Passes the name of the function through as a callback in the route
    definition**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在路由定义中将函数名称作为回调传递**'
- en: If you refresh your homepage now, it should still work as before. You haven’t
    changed anything in how the site works—only moved a step toward separating concerns.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在刷新你的主页，它应该仍然像以前一样工作。你没有改变网站工作的任何方面——只是朝着分离关注点迈出一步。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Understanding res.render**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解 res.render**'
- en: 'You’ll look at this topic more in [chapter 4](kindle_split_015.xhtml#ch04),
    but `render` is the Express function for compiling a view template to send as
    the HTML response that the browser will receive. The `render` method takes the
    name of the view template and a JavaScript data object in the following construct:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第 4 章中更详细地了解这个主题，但`render`是 Express 函数，用于将视图模板编译为发送给浏览器的 HTML 响应。`render`方法接受视图模板的名称和一个
    JavaScript 数据对象，如下所示：
- en: '![](Images/p0069-01_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0069-01_alt.jpg)'
- en: Note that the template file doesn’t need to have the file extension suffix,
    so index.pug can be referenced as index. You also don’t need to specify the path
    to the view folder, because you’ve already done this in the main Express setup.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模板文件不需要文件扩展名后缀，所以index.pug可以引用为index。你也不需要指定视图文件夹的路径，因为你已经在 Express 的主设置中这样做过了。
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’re clear about how route definition works, it’s time to put the
    controller code in its proper place.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经清楚了解路由定义的工作原理，是时候将控制器代码放到合适的位置了。
- en: Moving the controller out of the routes file
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将控制器从路由文件中移出
- en: In Node, to reference code in an external file, you create a module in your
    new file, and then `require` it in the original file. See the sidebar “[Creating
    and using Node modules](#ch03sb06)” for some overarching principles behind this
    process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，要引用外部文件中的代码，你需要在你的新文件中创建一个模块，然后在原始文件中`require`它。有关此过程的总体原则，请参阅侧边栏“[创建和使用
    Node 模块](#ch03sb06)”。
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Creating and using Node modules**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建和使用 Node 模块**'
- en: Taking some code out of a Node file to create an external module is, fortunately,
    simple. In essence, you create a new file for your code, choose which bits of
    it you want to expose to the original file, and then `require` your new file in
    your original file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些代码从 Node 文件中提取出来创建外部模块，幸运的是，这个过程很简单。本质上，你为你的代码创建一个新文件，选择你想要公开给原始文件的部分，然后在原始文件中`require`你的新文件。
- en: 'In your new module file, you expose the parts of the code that you want to
    by using the `module.exports` method, like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新模块文件中，你可以使用`module.exports`方法公开你想要的代码部分，如下所示：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then you `require` this in your main file, like so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在你的主文件中这样`require`它：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want your module to have separate named methods exposed, you can do
    so by defining them in your new file in the following way:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的模块公开具有单独命名的函数，你可以通过以下方式在你的新文件中定义它们：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Even better is to define a named function and export it at the end of the file.
    This lets you expose all the functions you need to in one place, creating a handy
    list for your future self (or subsequent developers).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的做法是在文件末尾定义一个命名函数并导出它。这让你可以在一个地方公开所有需要的函数，为你的未来（或后续的开发者）创建一个方便的列表。
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To reference this in your original file, you need to assign your module to
    a variable name, and then invoke the method. You might enter this in your main
    file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要在原始文件中引用此内容，你需要将你的模块分配给一个变量名，然后调用该方法。你可以在主文件中输入以下内容：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code assigns your new module to the variable `yourModule`. The exported
    function `logThis` is now available as a method of `yourModule`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将你的新模块分配给变量`yourModule`。导出的函数`logThis`现在作为`yourModule`的方法可用。
- en: 'Note that, when using the `require` function, you don’t need to specify a file
    extension. The `require` function looks for a couple of things: an npm module,
    a JavaScript file of the same name, or an index.js file inside a folder of the
    given name.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用`require`函数时，你不需要指定文件扩展名。`require`函数会查找几件事情：一个 npm 模块、同名的 JavaScript 文件，或者给定名称文件夹内的
    index.js 文件。
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The first thing you need to do is create a file to hold the controller code.
    Create a new file called main.js in app_server/controllers. In this file, create
    and export a method called `index`, and use it to house the `res.render` code,
    as shown in the following listing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是创建一个文件来保存控制器代码。在 app_server/controllers 中创建一个名为 main.js 的新文件。在这个文件中，创建并导出一个名为`index`的方法，并使用它来存放`res.render`代码，如下所示。
- en: Listing 3.3\. Setting up the homepage controller in app_server/controllers/main.js
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 在 app_server/controllers/main.js 中设置主页控制器
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Creates an index function**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个 index 函数**'
- en: '***2*** **Includes controller code for the homepage**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **包含主页的控制器代码**'
- en: '***3*** **Exposes the index function as a method**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **公开 index 函数作为方法**'
- en: That’s all there is to exporting the controller. The next step is to `require`
    this controller module in the routes file so that you can use the exposed method
    in the route definition. The following listing shows how the index.js file in
    app_server/routes should look.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 导出控制器就这些了。下一步是在路由文件中`require`这个控制器模块，这样你就可以在路由定义中使用暴露的方法。以下列表显示了`app_server/routes`中的index.js文件应该看起来像什么。
- en: Listing 3.4\. Updating the routes file to use external controllers
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. 更新路由文件以使用外部控制器
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** **Requires the main controllers file**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **require 主控制器文件**'
- en: '***2*** **References the index method of the controllers in the route definition**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在路由定义中引用控制器的 index 方法**'
- en: This code links the route to the new controller by “requiring” the controller
    file ***1*** and referencing the controller function in the second parameter of
    the `router.get` function ***2***.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过“require”控制器文件***1***并在`router.get`函数的第二参数中引用控制器函数***2***来将路由链接到新的控制器。
- en: Now you have the routing and controller architecture, as illustrated in [figure
    3.7](#ch03fig07), where app.js `require`s routes/index.js, which in turn `require`s
    controllers/main.js. If you test this now in your browser, you should see that
    the default Express homepage displays correctly once again.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了路由和控制器架构，如图3.7所示，其中app.js `require`s routes/index.js，而routes/index.js又`require`s
    controllers/main.js。如果你现在在浏览器中测试，你应该会看到默认的Express主页再次正确显示。
- en: Figure 3.7\. Separating the controller logic from the route definitions
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7\. 将控制器逻辑与路由定义分离
- en: '![](Images/03fig07_alt.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig07_alt.jpg)'
- en: Everything is set up with Express for now, so it’s almost time to start the
    building process. But you need to do a couple more things. The first is adding
    Twitter Bootstrap to the application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 目前一切都已经用 Express 设置好了，所以差不多是时候开始构建过程了。但是你还需要做几件事情。第一件事是将 Twitter Bootstrap 添加到应用程序中。
- en: 3.4\. Importing Bootstrap for quick, responsive layouts
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 导入 Bootstrap 以实现快速、响应式布局
- en: As discussed in [chapter 1](kindle_split_011.xhtml#ch01), your Loc8r application
    uses Twitter’s Bootstrap framework to speed the development of a responsive design.
    You’ll also make the application stand out by adding some font icons and custom
    styles. The aim is to help you keep moving forward quickly with building the application
    and not get sidetracked with the semantics of developing a responsive interface.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](kindle_split_011.xhtml#ch01)中所述，你的 Loc8r 应用程序使用 Twitter 的 Bootstrap 框架来加速响应式设计的开发。你还将通过添加一些字体图标和自定义样式来使应用程序脱颖而出。目的是帮助你快速构建应用程序，而不会因为开发响应式界面的语义而分心。
- en: 3.4.1\. Downloading Bootstrap and adding it to the application
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 下载 Bootstrap 并将其添加到应用程序中
- en: 'Instructions for downloading Bootstrap, downloading the font icons (by Font
    Awesome), creating a custom style, and adding the files to the project folder
    are in [appendix B](kindle_split_031.xhtml#app02). Note that you use Bootstrap
    4.1\. A key point is that the downloaded files are all static files to be sent
    directly to the browser; they don’t need any processing by the Node engine. Your
    Express application already has a folder for this purpose: the public folder.
    When you have it ready, the public folder should look something like [figure 3.8](#ch03fig08).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有关下载 Bootstrap、下载字体图标（通过 Font Awesome）、创建自定义样式以及将文件添加到项目文件夹的说明请见[附录B](kindle_split_031.xhtml#app02)。请注意，你使用的是
    Bootstrap 4.1。一个关键点是下载的文件都是直接发送到浏览器的静态文件；它们不需要 Node 引擎的任何处理。你的 Express 应用程序已经有一个用于此目的的文件夹：public
    文件夹。当你准备好时，public 文件夹应该看起来像[图3.8](#ch03fig08)。
- en: Figure 3.8\. Structure of the public folder in the Express application after
    adding Bootstrap
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8\. 添加 Bootstrap 后 Express 应用程序中 public 文件夹的结构
- en: '![](Images/03fig08.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig08.jpg)'
- en: Bootstrap also requires jQuery and Popper.js for some of the interactive components
    to work. Because they aren’t core to your application, you’ll reference them from
    a content delivery network (CDN) in the next step.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 还需要 jQuery 和 Popper.js 来使一些交互组件正常工作。因为它们不是你应用程序的核心，所以你将在下一步从内容分发网络（CDN）中引用它们。
- en: 3.4.2\. Using Bootstrap in the application
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 在应用程序中使用 Bootstrap
- en: Now that all of the Bootstrap pieces are sitting in the application, it’s time
    to hook it up to the front end, which means taking a look at the Pug templates.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的 Bootstrap 零件都放在了应用程序中，是时候将其连接到前端了，这意味着查看 Pug 模板。
- en: Working with Pug templates
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Pug 模板
- en: Pug templates often have a main layout file that has defined areas for other
    Pug files to extend. This makes a great deal of sense when you’re building a web
    application, because many screens or pages have the same underlying structure
    with different content on top.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 模板通常有一个主布局文件，该文件为其他 Pug 文件定义了扩展区域。当你构建一个网络应用程序时，这非常有意义，因为许多屏幕或页面具有相同的底层结构，但顶部内容不同。
- en: 'This is how Pug appears in a default Express installation: If you look in the
    views folder in the application, you see three files—layout.pug, index.pug, and
    error.pug. The index.pug file is controlling the content for the index page of
    the application. Open it, and you see that not much is in there. The entire contents
    are shown in the following listing.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Pug 在默认 Express 安装中的样子：如果你查看应用程序中的 views 文件夹，你会看到三个文件——layout.pug、index.pug
    和 error.pug。index.pug 文件控制着应用程序索引页的内容。打开它，你会看到里面没有多少内容。整个内容在下面的列表中显示。
- en: Listing 3.5\. The complete index.pug file
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. 完整的 index.pug 文件
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **Declares that this file is extending the layout file**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **声明此文件正在扩展布局文件**'
- en: '***2*** **Declares that the following section goes into an area of the layout
    file called content**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **声明以下部分将进入布局文件中的 content 区域**'
- en: '***3*** **Outputs h1 and p tags to the content area**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **输出 h1 和 p 标签到内容区域**'
- en: 'There’s more going on here than meets the eye. Right at the top of the file
    is a statement declaring that this file is an extension of another file ***1***—in
    this case, the layout file. Following is a statement defining a block of code
    ***2*** that belongs to a specific area of the layout file: an area called `content`.
    Finally, there’s the minimal content displayed on the Express index page: a single
    `<h1>` tag and a single `<p>` tag ***3***.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情比表面看起来要多。在文件顶部有一个声明，表明此文件是另一个文件的扩展 ***1***——在这种情况下，是布局文件。接下来是一个定义属于布局文件特定区域（称为
    `content` 的区域）的代码块的声明 ***2***。最后，是 Express 索引页上显示的最小内容：一个 `<h1>` 标签和一个 `<p>` 标签
    ***3***。
- en: There are no references to `<head>` or `<body>` tags here, or any stylesheet
    references. These are handled in the layout file, so that’s where you want to
    go to add global scripts and stylesheets to the application. Open layout.pug,
    and you should see something similar to the following listing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有对 `<head>` 或 `<body>` 标签的引用，也没有任何样式表引用。这些都在布局文件中处理，所以你想要去的地方是添加全局脚本和样式表到应用程序中。打开
    layout.pug，你应该会看到类似于以下列表的内容。
- en: Listing 3.6\. Default layout.pug file
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 默认布局.pug 文件
- en: '[PRE30]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Empty named block can be used by other templates**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **空命名块可以被其他模板使用**'
- en: This shows the layout file being used for the basic index page in the default
    Express installation. There’s a `head` section and a `body` section, and within
    the `body` section, there’s a `block content` line with nothing inside it. This
    named `block` can be referenced by other Pug templates, such as the index.pug
    file in [listing 3.5](#ch03ex05). The `block content` from the index file gets
    pushed into the `block content` area of the layout file when the views are compiled.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了用于默认 Express 安装的基本索引页的布局文件。有一个 `head` 部分和一个 `body` 部分，在 `body` 部分内部有一个没有任何内容的
    `block content` 行。这个名为 `block` 的内容可以被其他 Pug 模板引用，例如 [列表 3.5](#ch03ex05) 中的 index.pug
    文件。当视图被编译时，index 文件中的 `block content` 被推入布局文件的 `block content` 区域。
- en: Adding Bootstrap to the entire application
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将 Bootstrap 添加到整个应用程序中
- en: 'If you want to add some external reference files to the entire application,
    using the layout file makes sense in the current setup. In layout.pug, you need
    to accomplish four things:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将一些外部引用文件添加到整个应用程序中，在当前设置中使用布局文件是有意义的。在 layout.pug 中，你需要完成以下四件事：
- en: Reference the Bootstrap and Font Awesome CSS files.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用 Bootstrap 和 Font Awesome CSS 文件。
- en: Reference the Bootstrap JavaScript file.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用 Bootstrap JavaScript 文件。
- en: Reference jQuery and Popper.js, which Bootstrap requires.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用 jQuery 和 Popper.js，这是 Bootstrap 所需要的。
- en: Add viewport metadata so that the page scales nicely on mobile devices.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加视口元数据，以便页面在移动设备上良好缩放。
- en: The CSS file and the viewport metadata should both be in the head of the document,
    and the two script files should be at the end of the body section. The following
    listing shows all this in place in layout.pug, with the new lines in bold.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 文件和视口元数据都应该在文档的 `head` 部分，而两个脚本文件应该在 `body` 部分的末尾。以下列表显示了 layout.pug 中的所有这些内容，新行以粗体显示。
- en: Listing 3.7\. Updated layout.pug including Bootstrap references
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 包含 Bootstrap 引用的更新布局.pug 文件
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **Sets the viewport metadata for better display on mobile devices**'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置视口元数据，以在移动设备上更好地显示**'
- en: '***2*** **Includes Bootstrap and Font Awesome CSS**'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **包含 Bootstrap 和 Font Awesome CSS**'
- en: '***3*** **Brings in jQuery and Popper, needed by Bootstrap. Make sure that
    the script tags are all at the same indentation.**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **引入 jQuery 和 Popper，Bootstrap 所需。确保所有的脚本标签都有相同的缩进。**'
- en: '***4*** **Brings in the Bootstrap JavaScript file**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **引入 Bootstrap JavaScript 文件**'
- en: With that done, any new template that you create automatically has Bootstrap
    included and will scale on mobile devices—as long as your new templates extend
    the layout template, of course. Should you have any problems or unexpected results
    at this stage, remember that Pug is sensitive to indentation, spacing, and newlines.
    All indentation must be done with spaces to get the correct nesting in the HTML
    output.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你创建的任何新模板都会自动包含 Bootstrap，并且可以在移动设备上缩放——当然，前提是你的新模板扩展了布局模板。如果你在这个阶段遇到任何问题或意外结果，请记住
    Pug 对缩进、间距和换行很敏感。所有缩进都必须使用空格来完成，以在 HTML 输出中获得正确的嵌套。
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you followed along in [appendix B](kindle_split_031.xhtml#app02), you’ll
    also have some custom styles in the style.css file in /public/stylesheets to prevent
    the default Express styles from overriding the Bootstrap files and help you get
    the look you want.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照[附录 B](kindle_split_031.xhtml#app02)中的说明进行操作，你也会在 /public/stylesheets 目录下的
    style.css 文件中找到一些自定义样式，以防止默认 Express 样式覆盖 Bootstrap 文件并帮助你获得你想要的样式。
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now you’re ready to test.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好测试了。
- en: Verifying that it works
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证其是否工作
- en: If the application isn’t already running with nodemon, start it, and view it
    in your browser. The content hasn’t changed, but the appearance should have. You
    should have something that looks like [figure 3.9](#ch03fig09).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序还没有用 nodemon 运行，请启动它，并在浏览器中查看。内容没有变化，但外观应该有所改变。你应该有一个看起来像[图 3.9](#ch03fig09)的东西。
- en: Figure 3.9\. Bootstrap and your styles having an effect on the default Express
    index page
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.9. Bootstrap 和你的样式对默认 Express 索引页的影响
- en: '![](Images/03fig09_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig09_alt.jpg)'
- en: 'If yours doesn’t look like this, make sure that you’ve added the custom styles
    as outlined in [appendix B](kindle_split_031.xhtml#app02). Remember that you can
    get the source code of the application so far from the chapter-03 branch on GitHub.
    In a fresh folder in terminal, use the following command to clone it:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的样子不像这样，请确保你已经按照[附录 B](kindle_split_031.xhtml#app02)中概述的方式添加了自定义样式。记住，你可以从
    GitHub 上的 chapter-03 分支获取到目前为止的应用程序源代码。在终端的新文件夹中，使用以下命令克隆它：
- en: '[PRE32]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now you’ve got something working locally. In the next section, you’ll see how
    you can get it running on a live production server.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在本地有了些东西在运行。在下一节中，你将了解如何将其部署到实时生产服务器。
- en: 3.5\. Making it live on Heroku
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 将其部署到 Heroku
- en: A common perceived headache with Node applications is deploying them to a live
    production server. You’re going to get rid of that headache early and push your
    Loc8r application to a live URL right away. As you iterate and build it up, you
    can keep pushing out the updates. For prototyping, this approach is great, because
    it makes showing your progress to others easy.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Node 应用程序的一个常见问题是将它们部署到实时生产服务器。你将尽早解决这个问题，并将 Loc8r 应用程序直接推送到实时 URL。随着你迭代和构建它，你可以继续推送更新。对于原型设计，这种方法很棒，因为它使得向他人展示你的进度变得容易。
- en: As mentioned in [chapter 1](kindle_split_011.xhtml#ch01), there are a few PaaS
    providers such as Google Cloud Platform, Nodejitsu, OpenShift, and Heroku. You’ll
    use Heroku here, but there’s nothing to stop you from trying other options. Next,
    you’ll get Heroku up and running, and walk through a few basic Git commands to
    deploy your application to a live server.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 1 章](kindle_split_011.xhtml#ch01)中所述，有一些 PaaS 提供商，如 Google Cloud Platform、Nodejitsu、OpenShift
    和 Heroku。这里你将使用 Heroku，但没有任何阻止你尝试其他选项的理由。接下来，你将启动 Heroku 并运行它，然后通过几个基本的 Git 命令将你的应用程序部署到实时服务器。
- en: 3.5.1\. Getting Heroku set up
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1. 设置 Heroku 的准备工作
- en: Before you can use Heroku, you need to sign up for a free account and install
    the Heroku CLI on your development machine. [Appendix B](kindle_split_031.xhtml#app02)
    has more detailed information on how to do this. You also need a bash-compatible
    terminal; the default terminal for Mac users is fine, but the default CLI for
    Windows users won’t do. If you’re on Windows, you need to download something like
    the GitHub terminal, which comes as part of the GitHub desktop application. When
    you have everything set up, you can continue getting the application ready to
    push live.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用Heroku之前，您需要注册一个免费账户并在您的开发机器上安装Heroku CLI。[附录B](kindle_split_031.xhtml#app02)提供了更多关于如何进行此操作的信息。您还需要一个兼容bash的终端；Mac用户的默认终端是好的，但Windows用户的默认CLI不行。如果您使用Windows，您需要下载类似GitHub终端的东西，它是GitHub桌面应用程序的一部分。当您设置好一切后，您可以继续准备将应用程序推送到线上。
- en: Updating package.json
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新package.json
- en: Heroku can run applications on various types of codebases, so you need to tell
    it what your application is running. Besides telling it that you’re running a
    Node application using npm as the package manager, you also need to tell it which
    version you’re running to ensure that the production setup is the same as the
    development setup.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku可以在各种类型的代码库上运行应用程序，因此您需要告诉它您的应用程序正在运行什么。除了告诉它您正在使用npm作为包管理器运行Node应用程序之外，您还需要告诉它您正在运行哪个版本，以确保生产环境设置与开发环境设置相同。
- en: 'If you’re not sure which versions of Node and npm you’re running, you can find
    out with a couple of terminal commands:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定您正在运行哪个版本的Node和npm，您可以使用几个终端命令来找出：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Currently, these commands return `v11.0.0` and `6.4.1`, respectively. Using
    the `~` syntax to add a wildcard for a minor version, as you’ve seen previously,
    you need to add these to a new engines section in the package.json file. The complete
    updated package.json file is shown in the following listing, with the added section
    in bold.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些命令分别返回`v11.0.0`和`6.4.1`。使用`~`语法添加一个用于次要版本的通配符，如您之前所见，您需要将这些添加到package.json文件中的新engines部分。完整的更新后的package.json文件如下所示，其中添加的部分用粗体表示。
- en: Listing 3.8\. Adding an engines section to package.json
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8\. 在package.json中添加engines部分
- en: '[PRE34]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1*** **Adds an engines section to package.json to tell Heroku which platform
    your application is on and which version to use**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在package.json中添加engines部分，以告诉Heroku您的应用程序所在的平台以及要使用的版本**'
- en: When pushed up to Heroku, this code tells Heroku that your application uses
    the latest minor version of Node 11 and the latest minor version of npm 6.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码被推送到Heroku时，这段代码会告诉Heroku您的应用程序使用Node 11的最新次要版本和npm 6的最新次要版本。
- en: Creating a Procfile
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建Procfile
- en: The package.json file tells Heroku that the application is a Node application
    but doesn’t tell it how to start it. For this task, you need a Procfile, which
    is used to declare the process types used by your application and the commands
    used to start them.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: package.json文件告诉Heroku该应用程序是一个Node应用程序，但没有告诉它如何启动它。对于这个任务，您需要一个Procfile，它用于声明应用程序使用的进程类型以及启动它们的命令。
- en: 'For Loc8r, you want a web process, and you want it to run the Node application.
    In the root folder of the application, create a file called Procfile. (The name
    is case sensitive and has no file extension.) Enter the following line in the
    Procfile:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Loc8r，您需要一个Web进程，并且希望它运行Node应用程序。在应用程序的根目录中创建一个名为Procfile的文件。（文件名区分大小写，没有文件扩展名。）在Procfile中输入以下行：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When pushed up to Heroku, this file tells Heroku that the application needs
    a web process and that it should run `npm start`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码被推送到Heroku时，此文件会告诉Heroku应用程序需要一个Web进程，并且应该运行`npm start`。
- en: Testing it locally with Heroku Local
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Heroku Local进行本地测试
- en: 'The Heroku CLI comes with a utility called Heroku Local. You can use this utility
    to verify your setup and run your application locally before pushing the application
    up to Heroku. If the application is currently running, stop it by pressing Ctrl-C
    in the terminal window that’s running the process. Then, in the terminal window,
    make sure you’re in your application folder, and enter the following command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku CLI附带一个名为Heroku Local的实用工具。您可以使用此实用工具验证您的设置，在将应用程序推送到Heroku之前在本地运行您的应用程序。如果应用程序当前正在运行，请按终端窗口中运行进程的Ctrl-C停止它。然后，在终端窗口中，确保您位于应用程序文件夹中，并输入以下命令：
- en: '[PRE36]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If all is well with the setup, this command starts the application running
    on localhost again, but this time on a different port: 5000\. The confirmation
    you get in terminal should be along these lines:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置一切顺利，这个命令将再次在 localhost 上启动应用程序，但这次是在不同的端口：5000。你在终端中获得的确认信息应该是这样的：
- en: '[PRE37]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You’ll probably also see the warning `No ENV file found`. This message is nothing
    to worry about at this stage. If you fire up a browser and head over to localhost:5000
    (note that the port is 5000 instead of 3000), you should see the application up
    and running again.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会看到警告“未找到 ENV 文件”。在这个阶段，这条消息没有什么好担心的。如果你打开浏览器并访问 localhost:5000（注意端口号是 5000
    而不是 3000），你应该会看到应用程序再次运行起来。
- en: Now that you know the setup is working, it’s time to push your application up
    to Heroku.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道设置是有效的，是时候将你的应用程序推送到 Heroku 了。
- en: 3.5.2\. Pushing the site live using Git
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 使用 Git 将网站上线
- en: Heroku uses Git as the deployment method. If you already use Git, you’ll love
    this approach; if you haven’t, you may feel a bit apprehensive about it, because
    the world of Git can be complex. But it doesn’t need to be, and when you get going,
    you’ll love this approach too!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 使用 Git 作为部署方法。如果你已经使用 Git，你会喜欢这种方法；如果你还没有，你可能会对它感到有点不安，因为 Git 的世界可能很复杂。但事实并非如此，当你开始使用时，你也会喜欢这种方法！
- en: Storing the application in Git
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Git 中存储应用程序
- en: 'The first action is storing the application in Git on your local machine. This
    process involves the following three steps:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在你的本地机器上使用 Git 存储应用程序。这个过程涉及以下三个步骤：
- en: Initialize the application folder as a Git repository.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序文件夹初始化为 Git 仓库。
- en: Tell Git which files you want to add to the repository.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 Git 你想要添加到仓库中的文件。
- en: Commit these changes to the repository.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些更改提交到仓库中。
- en: 'This process may sound complex but isn’t. You need a single, short terminal
    command for each step. If the application is running locally, stop it in terminal
    (Ctrl-C). Then, ensuring you’re still in the root folder of the application, stay
    in terminal, and run the following commands:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程听起来可能很复杂，但实际上并不复杂。你需要为每个步骤输入一个简单、短的终端命令。如果应用程序正在本地运行，请在终端中停止它（Ctrl-C）。然后，确保你仍然位于应用程序的根目录中，保持在终端中，并运行以下命令：
- en: '[PRE38]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1*** **Initializes folder as a local Git repository**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **初始化文件夹为本地 Git 仓库**'
- en: '***2*** **Adds everything in folder to the repository**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将文件夹中的所有内容添加到仓库中**'
- en: '***3*** **Commits changes to the repository with a message**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **提交更改到仓库并附上消息**'
- en: These three things together create a local Git repository containing the entire
    codebase for the application. When you update the application later and want to
    push some changes live, you’ll use the second two commands, with a different message,
    to update the repository. Your local repository is ready. It’s time to create
    the Heroku application.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这三件事一起创建了一个包含应用程序整个代码库的本地 Git 仓库。当你稍后更新应用程序并想要将一些更改实时推送到线上时，你将使用后两个命令，并附上不同的消息来更新仓库。你的本地仓库已经准备好了。现在是时候创建
    Heroku 应用程序了。
- en: Creating the Heroku application
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 Heroku 应用程序
- en: 'This next step creates an application on Heroku as a remote Git repository
    of your local repository. You do all this with a single terminal command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此下一步是在 Heroku 上创建一个本地仓库的远程 Git 仓库的应用程序。你可以通过单个终端命令完成所有这些操作：
- en: '[PRE39]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You’ll see a confirmation in terminal of the URL that the application is on,
    the Git repository address, and the name of the remote repository, as in this
    example:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在终端中看到一个确认信息，包括应用程序所在的 URL、Git 仓库地址和远程仓库的名称，如下例所示：
- en: '[PRE40]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you log in to your Heroku account in a browser, you’ll also see that the
    application exists there. Now that you have a place on Heroku for the application,
    the next step is pushing the application code up.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过浏览器登录到你的 Heroku 账户，你也会看到应用程序在那里。现在你已经在 Heroku 上为应用程序找到了一个位置，下一步是将应用程序代码推送到那里。
- en: Deploying the application to Heroku
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Heroku
- en: You have the application stored in a local Git repository, and you’ve created
    a new remote repository on Heroku. The remote repository is empty, so you need
    to push the contents of your local repository to the `heroku` remote repository.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将应用程序存储在本地 Git 仓库中，并在 Heroku 上创建了一个新的远程仓库。远程仓库是空的，因此你需要将本地仓库的内容推送到 `heroku`
    远程仓库。
- en: 'If you don’t know Git, there’s a single command for this purpose, which has
    the following construct:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道 Git，有一个用于此目的的单个命令，其结构如下：
- en: '![](Images/p0079-01.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/p0079-01.jpg)'
- en: This command pushes the contents of your local Git repository to the `heroku`
    remote repository. Currently, you only have a single branch in your repository—the
    master branch—so that’s what you’ll push to Heroku. See the sidebar “[What are
    Git branches?](#ch03sb07)” for more information on Git branches.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将您本地 Git 仓库的内容推送到 `heroku` 远程仓库。目前，您的仓库中只有一个分支——主分支——所以您将推送到 Heroku。有关 Git
    分支的更多信息，请参阅侧边栏“[什么是 Git 分支？](#ch03sb07)”。
- en: 'When you run this command, terminal displays a load of log messages as it goes
    through the process, eventually showing (about five lines from the end) a confirmation
    that the application has been deployed to Heroku. This confirmation is something
    like the following except that, of course, you’ll have a different URL:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，终端会显示大量日志消息，在处理过程中最终会显示（从末尾大约五行）一个确认信息，表明应用程序已部署到 Heroku。这个确认信息类似于以下内容，但当然，您会有一个不同的
    URL：
- en: '[PRE41]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**What are Git branches?**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 Git 分支？**'
- en: If you work on the same version of the code and push it up to a remote repository
    like Heroku or GitHub periodically, you’re working on the *master* branch. This
    process is absolutely fine for linear development with one developer. If you have
    multiple developers, however, or your application is already published, you don’t
    want to be doing your development on the master branch. Instead, you start a new
    branch from the master code in which you can continue development, add fixes,
    or build a new feature. When work on a branch is complete, it can be merged back
    into the master branch.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在相同的代码版本上工作，并定期将其推送到像 Heroku 或 GitHub 这样的远程仓库，您正在 *master* 分支上工作。这个过程对于只有一个开发者的线性开发来说绝对是可以的。但是，如果您有多个开发者，或者您的应用程序已经发布，您不希望在主分支上进行开发。相反，您可以从主代码中启动一个新的分支，在那里您可以继续开发、添加修复或构建新功能。当分支上的工作完成后，它可以合并回主分支。
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: About web dynos on Heroku
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于 Heroku 上的 web dynos
- en: Heroku uses the concept of *dynos* for running and scaling an application. The
    more dynos you have, the more system resources and processes you have available
    to your application. Adding more dynos when your application gets bigger and more
    popular is easy.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 使用 *dynos* 的概念来运行和扩展应用程序。您拥有的 dynos 越多，您为应用程序可用的系统资源和进程就越多。当您的应用程序变得更大、更受欢迎时，添加更多
    dynos 是很容易的。
- en: Heroku also has a great free tier, which is perfect for application prototyping
    and building a proof of concept. You get one web dyno free with each application,
    which is more than adequate for your purposes here. If you have an application
    that needs more resources, you can always log in to your account and pay for more.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 还有一个出色的免费层，非常适合应用程序原型设计和构建概念验证。每个应用程序您都免费获得一个 web dyno，这对于您在这里的目的来说已经足够了。如果您有需要更多资源的应用程序，您始终可以登录您的账户并支付更多。
- en: In the following section, you’ll check out the live URL.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将检查实时 URL。
- en: Viewing the application on a live URL
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在实时 URL 上查看应用程序
- en: 'Everything is in place, and the application is live on the internet! You can
    see it by typing the URL given to you in the confirmation, via your account on
    the Heroku website, or by using the following terminal command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪，应用程序已经在互联网上上线了！您可以通过在确认信息中输入给您的 URL、通过 Heroku 网站的您的账户，或者使用以下终端命令来查看它：
- en: '[PRE42]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This command launches the application in your default browser, and you should
    see something like [figure 3.10](#ch03fig10).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在您的默认浏览器中启动应用程序，您应该会看到类似于 [图 3.10](#ch03fig10) 的内容。
- en: Figure 3.10\. MVC Express application running on a live URL
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.10\. 在实时 URL 上运行的 MVC Express 应用程序
- en: '![](Images/03fig10_alt.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.10](Images/03fig10_alt.jpg)'
- en: Your URL will be different, of course, and within Heroku, you can change it
    to use your domain name instead of the address it gave you. In the application
    settings on the Heroku website, you can change it to the more meaningful subdomain
    herokuapp.com.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 URL 当然会不同，在 Heroku 中，您可以将它更改为使用您的域名而不是它提供的地址。在 Heroku 网站的“应用程序设置”中，您可以将它更改为更有意义的子域名
    herokuapp.com。
- en: Having your prototype on an accessible URL is handy for cross-browser and cross-device
    testing, as well as for sending it to colleagues and partners.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 将原型放在可访问的 URL 上对于跨浏览器和跨设备测试很有用，以及用于发送给同事和合作伙伴。
- en: A simple update process
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单的更新过程
- en: 'Now that the Heroku application is set up, updating it is easy. Every time
    you want to push some new changes through, you need three terminal commands:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Heroku应用程序已经设置好了，更新它很容易。每次您想要通过推送一些新更改时，您都需要三个终端命令：
- en: '[PRE43]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1*** **Adds all changes to the local Git repository**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将所有更改添加到本地 Git 仓库**'
- en: '***2*** **Commits changes to the local repository with a useful message**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用有用的消息提交更改到本地仓库**'
- en: '***3*** **Pushes changes to the Heroku repository**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将更改推送到 Heroku 仓库**'
- en: That’s all there is to it, for now at least. Things may get a bit more complex
    if you have multiple developers and branches to deal with, but the process of
    pushing the code to Heroku using Git remains the same.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 至少目前就是这样。如果你要处理多个开发人员和分支，事情可能会变得稍微复杂一些，但使用 Git 将代码推送到 Heroku 的过程保持不变。
- en: In [chapter 4](kindle_split_015.xhtml#ch04), you’ll get to know Express even
    more when you build out a prototype of the Loc8r application.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](kindle_split_015.xhtml#ch04) 中，当你构建 Loc8r 应用程序的原型时，你会更深入地了解 Express。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: How to create a new Express application
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个新的 Express 应用程序
- en: How to manage application dependencies with npm and the package.json file
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 npm 和 package.json 文件管理应用程序依赖
- en: How a standard Express project can be changed to meet an MVC approach to architecture
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将标准的 Express 项目更改为满足 MVC 架构方法
- en: How routes and controllers fit together
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由和控制器如何配合
- en: The simplest way to publish an Express application live to Heroku using Git
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 将 Express 应用程序以最简单的方式实时发布到 Heroku
- en: Chapter 4\. Building a static site with Node and Express
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4 章\. 使用 Node 和 Express 构建静态网站
- en: '*This chapter covers*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Prototyping an application by building a static version
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建静态版本来原型化应用程序
- en: Defining routes for application URLs
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序 URL 的路由
- en: Creating views in Express by using Pug and Bootstrap
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pug 和 Bootstrap 在 Express 中创建视图
- en: Using controllers in Express to tie routes to views
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Express 中使用控制器将路由绑定到视图
- en: Passing data from controllers to views
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从控制器传递数据到视图
- en: By the end of [chapter 3](kindle_split_014.xhtml#ch03), you should have had
    an Express application running, set up in an MVC way, with Bootstrap included
    to help with building page layouts. Your next step is building on this base, creating
    a static site that you can click through. This step is critical in putting together
    any site or application. Even if you’ve been given a design or some wireframes
    to work from, there’s no substitute for rapidly creating a realistic prototype
    that you can use in the browser. Something always comes to light in terms of layout
    or usability that you hadn’t noticed before. From this static prototype, you’ll
    take the data out from the views and put it into the controllers. By the end of
    this chapter, you’ll have intelligent views that can display data passed to them
    and controllers passing hardcoded data to the views.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [第 3 章](kindle_split_014.xhtml#ch03) 的结尾，你应该已经有一个运行中的 Express 应用程序，以 MVC 方式设置，Bootstrap
    已包含在内，有助于构建页面布局。你的下一步是在这个基础上构建，创建一个可以点击的静态网站。这一步对于构建任何网站或应用程序至关重要。即使你已经得到了一些设计或线框来工作，也没有什么可以替代快速创建一个可以在浏览器中使用的真实原型。在布局或可用性方面，总会有一些你没有注意到的细节。从这个静态原型中，你将从视图中提取数据并将其放入控制器中。到本章结束时，你将拥有智能视图，可以显示传递给它们的
    数据，并且控制器将硬编码的数据传递到视图中。
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Getting the source code**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取源代码**'
- en: 'If you haven’t yet built the application from [chapter 3](kindle_split_014.xhtml#ch03),
    you can get the code from the chapter-03 branch on GitHub at [https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2).
    In a fresh folder in terminal, enter the following commands to clone it and install
    the npm module dependencies:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有从[第 3 章](kindle_split_014.xhtml#ch03)构建应用程序，你可以从 GitHub 上的 chapter-03
    分支获取代码，网址为 [https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2)。在终端的新文件夹中，输入以下命令以克隆它并安装
    npm 模块依赖项：
- en: '[PRE44]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In terms of building up the application architecture, this chapter focuses on
    the Express application as shown in [figure 4.1](#ch04fig01).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序架构方面，本章重点介绍了如图 4.1 所示的 Express 应用程序。
- en: Figure 4.1\. Using Express and Node to build a static site for testing views
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 使用 Express 和 Node 构建用于测试视图的静态网站
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig01_alt.jpg)'
- en: Two main steps are accomplished in this chapter, so two versions of the source
    code are available. The first version contains all the data in the views and represents
    the application as it stands at the end of section [4.4](#ch04lev1sec4). This
    code is available from the chapter-04-views branch on GitHub.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了两个主要步骤，因此提供了两种源代码版本。第一个版本包含所有视图中的数据，代表了在[4.4](#ch04lev1sec4)节结束时的应用程序状态。此代码可在GitHub上的chapter-04-views分支找到。
- en: The second version has the data in the controllers, in the state in which the
    application will be at the end of this chapter. This code is available from the
    chapter-04 branch on GitHub.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本具有控制器中的数据，代表了在章节结束时的应用程序状态。此代码可在GitHub上的chapter-04分支找到。
- en: 'To get one of these versions, use the following commands in a fresh folder
    in terminal, remembering to specify the branch that you want:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这些版本之一，请在终端的新文件夹中使用以下命令，记得指定你想要的分支：
- en: '[PRE45]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you want to run the Docker environment, see [appendix B](kindle_split_031.xhtml#app02).
    Now you’re ready to get back to Express.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要运行Docker环境，请参阅[附录B](kindle_split_031.xhtml#app02)。现在你准备好回到Express了。
- en: 4.1\. Defining the routes in Express
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 在Express中定义路由
- en: In [chapter 2](kindle_split_012.xhtml#ch02) you planned the application and
    decided on the four pages you’re going to build. You have a collection of Locations
    pages and a page in the Others collection, as shown in [figure 4.2](#ch04fig02).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_012.xhtml#ch02)中，你规划了应用程序并确定了你要构建的四页内容。你有一系列位置页面和“其他”集合中的一个页面，如图[4.2](#ch04fig02)所示。
- en: Figure 4.2\. Collections of screens you’ll build for the Loc8r application
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2\. 你将为Loc8r应用程序构建的屏幕集合
- en: '![](Images/04fig02_alt.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig02_alt.jpg)'
- en: Having a set of screens is great, but these screens need to relate to incoming
    URLs. Before you do any coding, it’s a good idea to map out the links between
    screens and URLs and to get a good standard in place. Take a look at [table 4.1](#ch04table01),
    which shows a simple mapping of the screens against URLs. These mappings will
    form the basis of the routing for your application.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一组屏幕很棒，但这些屏幕需要与传入的URL相关联。在你开始任何编码之前，制定屏幕和URL之间的链接图，并建立一个良好的标准是个好主意。看看[表4.1](#ch04table01)，它展示了屏幕与URL的简单映射。这些映射将构成你应用程序路由的基础。
- en: Table 4.1\. Defining a URL path, or route, for each of the screens in the prototype
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.1\. 为原型中每个屏幕定义URL路径或路由
- en: '| Collection | Screen | URL path |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 屏幕 | URL路径 |'
- en: '| --- | --- | --- |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Locations | List of locations (the homepage) | / |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | 位置列表（主页） | / |'
- en: '| Locations | Location detail | /location |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | 位置详情 | /location |'
- en: '| Locations | Location review form | /location/review/new |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | 位置评论表单 | /location/review/new |'
- en: '| Others | About Loc8r | /about |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 其他 | 关于Loc8r | /about |'
- en: When somebody visits the homepage, for example, you want to show them a list
    of places, but when somebody visits the /about URL path, you want to show them
    information about Loc8r.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人访问主页时，例如，你希望向他们展示地点列表，但当有人访问/about URL路径时，你希望向他们展示Loc8r的信息。
- en: 4.1.1\. Different controller files for different collections
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 不同集合的控制器文件
- en: In [chapter 3](kindle_split_014.xhtml#ch03), you moved any sense of controller
    logic out of the route definitions and into an external file. Looking to the future,
    you know that your application will grow, and you don’t want to have all the controllers
    in one file. A logical starting point for splitting them up is dividing them by
    collections.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_014.xhtml#ch03)中，你将控制器逻辑从路由定义中移出，放入外部文件。展望未来，你知道你的应用程序将会增长，你不想所有控制器都在一个文件中。将它们分开的逻辑起点是按集合划分它们。
- en: Looking at the collections you’ve decided on, you decide to split the controllers
    into Locations and Others. To see how this approach might work from a file-architecture
    point of view, you can sketch something like [figure 4.3](#ch04fig03). Here, the
    application includes the routes file, which in turn includes multiple controller
    files, each named according to the relevant collection.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你已决定采用的集合，你决定将控制器分为“位置”和“其他”。为了从文件架构的角度了解这种方法可能如何工作，你可以绘制类似[图4.3](#ch04fig03)的东西。在这里，应用程序包括路由文件，该文件反过来又包括多个控制器文件，每个文件都根据相关的集合命名。
- en: Figure 4.3\. Proposed file architecture for routes and controllers in your application
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3\. 应用程序中路由和控制器建议的文件架构
- en: '![](Images/04fig03_alt.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03_alt.jpg)'
- en: You have a single route file, as well as one controller file for each logical
    collection of screens. This setup is designed to help you organize your code in
    line with how your application is organized. You’ll look at the controllers shortly,
    but first, you’ll deal with the routes.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个单独的路由文件，以及每个逻辑屏幕集合的一个控制器文件。这种设置旨在帮助你根据应用程序的组织方式来组织代码。你将很快查看控制器，但首先，你需要处理路由。
- en: The time for planning is over; now it’s time for action! Head back to your development
    environment and open the application. You’ll start by working in the routes file
    index.js.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 规划的时间已经结束；现在是采取行动的时候了！回到你的开发环境并打开应用程序。你将从在routes文件index.js中工作开始。
- en: Requiring the controller files
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 引入控制器文件
- en: As shown in [figure 4.3](#ch04fig03), you want to reference two controller files
    in this routes file. You haven’t created these controller files yet; you’ll do
    that shortly.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图4.3](#ch04fig03)所示，你想要在这个路由文件中引用两个控制器文件。你还没有创建这些控制器文件；你将在稍后完成这项任务。
- en: These files will be called locations.js and others.js. They will be saved in
    app_server/controllers. In index.js you’ll `require` both of these files and assign
    each to a relevant variable name, as shown in the following listing.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件将被命名为locations.js和others.js。它们将被保存在app_server/controllers目录中。在index.js中，你需要`require`这两个文件并将它们分别分配给相关的变量名，如下面的列表所示。
- en: Listing 4.1\. Requiring the controller files in app_server/routes/index.js
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1\. 在app_server/routes/index.js中引入控制器文件
- en: '[PRE46]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1*** **Replaces existing ctrlMain reference with two new requires**'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **用两个新的require替换现有的ctrlMain引用**'
- en: Now you have two variables that you can reference in the route definitions,
    containing different collections of routes.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个可以在路由定义中引用的变量，它们包含不同的路由集合。
- en: Setting up the routes
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置路由
- en: In index.js, you need to have the routes for the three screens in the Locations
    collection and the About page in the Others collection. Each route will also need
    a reference to a controller. Remember that routes serve as a mapping service,
    taking the URL of an incoming request and mapping it to a specific piece of application
    functionality.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在index.js中，你需要为Locations集合中的三个屏幕和Others集合中的关于页面设置路由。每个路由还需要一个控制器引用。记住，路由充当映射服务，将传入请求的URL映射到特定的应用程序功能。
- en: From [table 4.1](#ch04table01), you already know which paths you want to map,
    so you need to put everything together into the routes/index.js file. What you
    need to have in the file is shown in entirety in the following listing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 从[表4.1](#ch04table01)中，你已经知道你想要映射哪些路径，所以你需要将所有内容组合到routes/index.js文件中。文件中需要的内容在下面的列表中完整显示。
- en: Listing 4.2\. Defining the routes and mapping them to controllers
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2\. 定义路由并将它们映射到控制器
- en: '[PRE47]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1*** **Requires controller files**'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入控制器文件**'
- en: '***2*** **Defines location routes and maps them to controller functions**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **定义位置路由并将它们映射到控制器函数**'
- en: '***3*** **Defines other routes**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **定义其他路由**'
- en: This routing file maps the defined URLs to some specific controllers, although
    you haven’t created those yet. You’ll take care of that task in the following
    section.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由文件将定义的URL映射到一些特定的控制器，尽管你还没有创建它们。你将在下一节中处理这个任务。
- en: 4.2\. Building basic controllers
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 构建基本控制器
- en: At this point, you’ll keep the controllers basic so that your application will
    run, and you can test the URLs and routing.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你将保持控制器的基本性，以便你的应用程序可以运行，并且你可以测试URL和路由。
- en: 4.2.1\. Setting up controllers
  id: totrans-470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 设置控制器
- en: 'You currently have one file: the main.js file in the controllers folder (in
    the app_server folder), which has a single function that’s controlling the homepage.
    This function is shown in the following code snippet:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你目前有一个文件：位于app_server文件夹中的controllers文件夹中的main.js文件，它包含一个控制主页的单个函数。这个函数在下面的代码片段中显示：
- en: '[PRE48]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You don’t want a “main” controller file anymore, but you can use this one as
    a template. Start by renaming this file others.js.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再需要“主要”控制器文件，但你可以使用这个文件作为模板。首先，将此文件重命名为others.js。
- en: Adding the Others controllers
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加其他控制器
- en: Recall from [listing 4.2](#ch04ex02) that you want one controller in others.js
    called `about`. Rename the existing `index` controller `about`; keep the same
    view template for now; and update the `title` property to something relevant.
    This approach makes it easy to test whether the route is working as expected.
    The following listing shows the full content of the others.js controller file
    after these little changes.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表4.2](#ch04ex02)回忆一下，你想要在others.js中有一个名为`about`的控制器。将现有的`index`控制器重命名为`about`；现在保持相同的视图模板；并将`title`属性更新为相关的内容。这种方法使得测试路由是否按预期工作变得容易。以下列表显示了经过这些小改动后others.js控制器文件的完整内容。
- en: Listing 4.3\. Others controller file
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3\. 其他控制器文件
- en: '[PRE49]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1*** **Defines the route, using the same view template but changing the
    title to About**'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义路由，使用相同的视图模板，但将标题改为关于**'
- en: '***2*** **Updates the export to reflect the name change**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **更新导出以反映名称更改**'
- en: That’s the first controller done, but the application still won’t work, as there
    aren’t any controllers for the Locations routes yet.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 那是第一个完成的控制器，但应用程序仍然无法工作，因为没有为位置路由添加任何控制器。
- en: Adding the Locations controllers
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加位置控制器
- en: Adding the controllers for the Locations routes is going to be pretty much the
    same process. In the routes file, you specified the name of the controller file
    to look for and the name of the three controller functions.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 为位置路由添加控制器的过程基本上是相同的。在路由文件中，你指定了要查找的控制器文件名以及三个控制器函数的名称。
- en: 'In the controllers folder, create a file called locations.js, and create and
    export three basic controller functions: `homelist`, `locationInfo`, and `addReview`.
    The following listing shows how this file should look.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器文件夹中，创建一个名为locations.js的文件，并创建和导出三个基本控制器函数：`homelist`、`locationInfo`和`addReview`。以下列表显示了该文件应该如何看起来。
- en: Listing 4.4\. Locations controller file
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.4\. 位置控制器文件
- en: '[PRE50]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Everything is in place, so you’re ready to test it.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪，你现在可以开始测试了。
- en: 4.2.2\. Testing the controllers and routes
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 测试控制器和路由
- en: 'Now that the routes and basic controllers are in place, you should be able
    to start and run the application. If you don’t already have it running with nodemon,
    head to the root folder of the application in the terminal and start it:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在路由和基本控制器已经就位，你应该能够启动并运行应用程序。如果你还没有用nodemon启动它，请在终端中转到应用程序的根目录并启动它：
- en: '[PRE51]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Troubleshooting**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障排除**'
- en: 'If you’re having problems restarting the application at this point, the main
    thing to check is that all the files, functions, and references are named correctly.
    Look at the error messages you’re getting in the terminal window to see whether
    they give you any clues. Some messages are more helpful than others. Take a look
    at the following possible error and pick out the parts that are interesting to
    you:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候遇到重启应用程序的问题，主要需要检查的是所有文件、函数和引用的命名是否正确。查看终端窗口中的错误消息，看看是否提供了任何线索。一些消息比其他消息更有帮助。看看以下可能的错误，并挑选出对你有意义的部分：
- en: '[PRE52]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1*** **Clue 1: A module can’t be found.**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **线索1：找不到模块。**'
- en: '***2*** **Clue 2: A file-throwing error occurred.**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **线索2：发生了文件抛出错误。**'
- en: First, you see that a module called `other` can’t be found ***1***. Farther
    down the stack trace, you see the file where the error originated ***2***. Open
    the routes/index.js file, and you’ll discover that you wrote `require('../controllers/other')`,
    when the file you want to require is others.js. To fix the problem, correct the
    reference by changing it to `require('../controllers/others')`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会看到无法找到名为`other`的模块 ***1***。在堆栈跟踪的更下方，你会看到错误起源的文件 ***2***。打开routes/index.js文件，你会发现你写了`require('../controllers/other')`，而你想要导入的文件是others.js。为了解决这个问题，通过将其更改为`require('../controllers/others')`来纠正引用。
- en: '|  |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: All being well, this run should give you no errors, meaning that the routes
    are pointing to controllers. At this point, you can head over to your browser
    and check each of the four routes you’ve created, such as localhost:3000 for the
    homepage and localhost:3000/location for the location information page. Because
    you changed the data being sent to the view template by each of the controllers,
    you can easily see that each one is running correctly—the title and heading should
    be different on each page. [Figure 4.4](#ch04fig04) shows a collection of screenshots
    of the newly created routes and controllers. You can see that each route is getting
    unique content, so you know that the routing and controller setup has worked.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，这次运行应该不会出现错误，这意味着路由已指向控制器。此时，您可以前往浏览器并检查您创建的四个路由，例如主页的localhost:3000和位置信息页的localhost:3000/location。因为您已经更改了每个控制器发送到视图模板的数据，所以您可以轻松地看到每个都在正确运行——每个页面的标题和标题应该不同。[图4.4](#ch04fig04)显示了新创建的路由和控制器的截图集合。您可以看到每个路由都获得了独特的内容，因此您知道路由和控制器设置已经成功。
- en: Figure 4.4\. Screenshots of the four routes created so far, with different heading
    text coming through from the specific controllers associated with each route
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4\. 到目前为止创建的四个路由的截图，其中包含来自与每个路由关联的特定控制器的不同标题文本
- en: '![](Images/04fig04_alt.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig04_alt.jpg)'
- en: The next stage in this prototyping process is putting some HTML, layout, and
    content on each screen. You’ll do this by using views.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原型制作过程的下一阶段，是在每个屏幕上放置一些HTML、布局和内容。您将通过使用视图来完成这项工作。
- en: 4.3\. Creating some views
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 创建一些视图
- en: When you have your empty pages, paths, and routes sorted out, it’s time to get
    some content and layout into your application. This step is where you bring the
    application to life and start to see your idea become reality. For this step,
    the technologies that you’ll use are Pug and Bootstrap. Pug is the template engine
    you’re using in Express (although you can use others if you prefer), and Bootstrap
    is a front-end layout framework that makes it easy to build a responsive website
    that looks different on desktop and mobile devices.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当您已经整理好空页面、路径和路由后，是时候将一些内容和布局添加到您的应用程序中。这一步是将应用程序激活并开始看到您的想法变为现实的地方。为此步骤，您将使用的科技是Pug和Bootstrap。Pug是您在Express中使用的模板引擎（尽管如果您愿意，您也可以使用其他引擎），Bootstrap是一个前端布局框架，它使得构建在不同桌面和移动设备上看起来不同的响应式网站变得容易。
- en: 4.3.1\. A look at Bootstrap
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. Bootstrap的概述
- en: Before getting started, let’s take a quick look at Bootstrap. We won’t go into
    all the details about Bootstrap and everything it can do, but it’s useful for
    you to see some of the key concepts before you try to throw it into a template
    file.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们快速了解一下Bootstrap。我们不会深入探讨Bootstrap的所有细节以及它能做什么，但在您尝试将其放入模板文件之前，看到一些关键概念是有用的。
- en: Bootstrap uses a 12-column grid. No matter the size of the display you’re using,
    there will always be these 12 columns. On a phone, each column is narrow, and
    on a large external monitor, each column is wide. The fundamental concept of Bootstrap
    is that you can define how many columns an element uses, and this number can be
    different for different screen sizes.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap使用12列网格。无论您使用的显示器的尺寸如何，总会存在这12列。在手机上，每列都很窄，而在大外部显示器上，每列都很宽。Bootstrap的基本概念是您可以定义元素使用多少列，并且这个数字可以针对不同的屏幕尺寸不同。
- en: Bootstrap has various CSS references that let you target up to five different
    pixel-width breakpoints for your layouts. These breakpoints are noted in [table
    4.2](#ch04table02), along with the example device that each size targets.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap提供了各种CSS参考，允许您为布局设置多达五个不同像素宽度的断点。这些断点在[表4.2](#ch04table02)中有说明，同时列出了每个尺寸针对的示例设备。
- en: Table 4.2\. Breakpoints that Bootstrap sets to target different types of devices
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.2\. Bootstrap为针对不同类型设备设置的断点
- en: '| Breakpoint name | CSS reference | Example device | Width |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 断点名称 | CSS参考 | 示例设备 | 宽度 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Extra-small devices | (none) | Small phones | Fewer than 576 |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| 超小型设备 | (无) | 小型手机 | 少于576像素 |'
- en: '| Small devices | sm | Smartphones | 576 or more |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 小型设备 | sm | 智能手机 | 576像素或以上 |'
- en: '| Medium devices | md | Tablets | 768 or more |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 中型设备 | md | 平板电脑 | 768像素或以上 |'
- en: '| Large devices | lg | Laptops | 992 or more |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| 大型设备 | lg | 笔记本电脑 | 992像素或以上 |'
- en: '| Extra-large devices | xl | External monitors | 1,200 or more |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| 超大设备 | xl | 外部显示器 | 1,200像素或以上 |'
- en: 'To define the width of an element, you combine a CSS reference from [table
    4.2](#ch04table02) with the number of columns you want it to span. A class denoting
    a column is constructed like this:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个元素的宽度，你需要将来自[表4.2](#ch04table02)的CSS引用与你想让它跨越的列数结合起来。一个表示列的类可以这样构建：
- en: '![](Images/p0089-01.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/p0089-01.jpg)'
- en: This class of `col-sm-6` makes the element it’s applied to take up six columns
    on screens of size `sm` and larger. On tablets, laptops, and monitors, this column
    will take up half the available width.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`col-sm-6`类使得应用到的元素在`sm`尺寸及更大的屏幕上占据六个列。在平板电脑、笔记本电脑和显示器上，这个列将占据可用宽度的一半。
- en: 'To get the responsive side of things to work, you can apply multiple classes
    to a single element. If you wanted a `div` to span the entire width or the screen
    on phones but only half the width on tablets and larger devices, you could use
    the following code snippet:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 要使响应式功能正常工作，你可以将多个类应用到单个元素上。如果你想让一个`div`在手机上占据整个屏幕宽度，但在平板电脑和更大设备上只占据一半宽度，你可以使用以下代码片段：
- en: '[PRE53]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `col-12` class tells the layout to use 12 columns on extra-small devices,
    and the `col-md-6` class tells the layout to use 6 columns for medium devices
    and larger. [Figure 4.5](#ch04fig05) illustrates the effect of this class on different
    devices if you have two of them on the page, one after another, like this:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`col-12`类告诉布局在超小设备上使用12列，而`col-md-6`类告诉布局在中型设备及更大设备上使用6列。[图4.5](#ch04fig05)展示了如果页面上有两个这样的类，一个接一个，它们在不同设备上的效果。'
- en: '[PRE54]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Figure 4.5\. Bootstrap’s responsive column system on a desktop and mobile device.
    CSS classes are used to determine the number of columns (out of 12) that each
    element should take up at different screen resolutions.
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5\. 在桌面设备和移动设备上Bootstrap的响应式列系统。CSS类用于确定每个元素在不同屏幕分辨率下应占用的列数（12列中的几列）。
- en: '![](Images/04fig05_alt.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig05_alt.jpg)'
- en: This approach allows for a semantic way of putting together responsive templates,
    and you’ll rely heavily on it for the Loc8r pages. Speaking of which, you’ll make
    a start in the next section.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许以语义化的方式组合响应式模板，你将大量依赖它来构建Loc8r页面。说到这一点，你将在下一节开始着手。
- en: 4.3.2\. Setting up the HTML framework with Pug templates and Bootstrap
  id: totrans-526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 使用Pug模板和Bootstrap设置HTML框架
- en: The pages you’ll have in the application have some common requirements. At the
    top of each page, you’ll want a navigation bar and logo; at the bottom of the
    page, you’ll have a copyright notice in the footer; and you’ll have a content
    area in the middle. What you’re aiming for is something like [figure 4.6](#ch04fig06).
    This framework for a layout is simple, but it suits your needs. It provides a
    consistent look and feel while allowing for different layouts to go in the middle.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的页面有一些共同的要求。在每一页的顶部，你将需要一个导航栏和标志；在页面的底部，你将在页脚中有一个版权声明；中间将有一个内容区域。你追求的是类似于[图4.6](#ch04fig06)的东西。这个布局框架很简单，但能满足你的需求。它提供了统一的视觉和感觉，同时允许中间有不同布局。
- en: Figure 4.6\. Basic structure of the reusable layout, comprising a standard navigation
    bar and footer with an extendable, changeable content area in between
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6\. 可重复使用的布局的基本结构，包括一个标准的导航栏和页脚，以及中间的可扩展、可更改的内容区域
- en: '![](Images/04fig06.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig06.jpg)'
- en: As you saw in [chapter 3](kindle_split_014.xhtml#ch03), Pug templates use the
    concept of extendable layouts, enabling you to define this type of repeatable
    structure once in a layout file. In the layout file, you can specify which parts
    can be extended; when you have this layout file set up, you can extend it as many
    times as you want. Creating the framework in a layout file means that you only
    have to do it once, and you can maintain it in only one place.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第3章](kindle_split_014.xhtml#ch03)中看到的，Pug模板使用可扩展布局的概念，使你能够在布局文件中定义这种可重复的结构一次。在布局文件中，你可以指定哪些部分可以扩展；当你设置了这种布局文件，你可以根据需要多次扩展它。在布局文件中创建框架意味着你只需做一次，你可以在一个地方维护它。
- en: Looking at the layout
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看布局
- en: 'To build the common framework, you’ll work mainly with the layout.pug file
    in the app_server/views folder. This file is minimal and looks like this code
    snippet:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建通用框架，你主要会在`app_server/views`文件夹中的`layout.pug`文件上工作。这个文件很简单，看起来像以下代码片段：
- en: '[PRE55]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There isn’t any HTML content in the body area yet—only a single extendable block
    called `content` and a couple of script references. You want to keep all this
    but add a navigation section above the `content` block and a footer below it.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在主体区域还没有任何 HTML 内容——只有一个名为 `content` 的可扩展块和一些脚本引用。你想要保留所有这些，但在 `content` 块上方添加一个导航部分，在其下方添加一个页脚。
- en: Building the navigation
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建导航
- en: Bootstrap offers a collection of elements and classes that you can use to create
    a sticky navigation bar that’s fixed to the top and collapses the options into
    a drop-down menu on mobile devices. We won’t explore the details of Bootstrap’s
    CSS classes here. All you need to do is grab the example code from the Bootstrap
    website, tweak it a little, and update it with the correct links.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 提供了一系列元素和类，你可以使用它们来创建一个固定在顶部并可在移动设备上折叠选项的下拉菜单的粘性导航栏。我们在这里不会探讨 Bootstrap
    CSS 类的细节。你所需要做的就是从 Bootstrap 网站获取示例代码，稍作修改，并更新为正确的链接。
- en: In the navigation, you want to have
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航中，你想要有
- en: The Loc8r logo linking to the homepage
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到主页的 Loc8r 标志
- en: An About link on the left, pointing to the /about URL page
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧的一个关于链接，指向 /about URL 页面
- en: 'The code that does these things is in the following snippet and can be placed
    in the layout.pug file above the `block content` line:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些操作的代码在以下片段中，并且可以放置在 layout.pug 文件中 `block content` 行上方：
- en: '[PRE56]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1*** **Sets up a Bootstrap navigation bar fixed to the top of the window**'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置一个固定在窗口顶部的 Bootstrap 导航栏**'
- en: '***2*** **Adds a brand-styled link to the homepage**'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为主页添加一个品牌风格的链接**'
- en: '***3*** **Sets up collapsing navigation for smaller screen resolutions**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **为较小的屏幕分辨率设置可折叠的导航**'
- en: '***4*** **Adds an About link to the left side of the bar**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将关于链接添加到栏的左侧**'
- en: If you pop that code in and run it, you’ll notice that the navigation now overlays
    the page heading. You’ll fix this problem when you build the layouts for the content
    area in sections [4.3.3](#ch04lev2sec6) and [4.4](#ch04lev1sec4), so it’s nothing
    to worry about.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段代码放入并运行，你会注意到导航现在覆盖了页面标题。当你构建内容区域的布局时，你将在第 [4.3.3](#ch04lev2sec6) 和 [4.4](#ch04lev1sec4)
    节中修复这个问题，所以不用担心。
- en: '|  |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that Pug doesn’t include any HTML tags and that correct indentation
    is critical for providing the expected outcome.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 Pug 不包含任何 HTML 标签，并且正确的缩进对于提供预期的结果至关重要。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That’s it for the navigation bar, which is all you need for a while. If Pug
    and Bootstrap are new to you, it may take a little while to get used to the approach
    and the syntax, but as you can see, you can achieve a lot with little code.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是导航栏的全部内容，目前你只需要这些。如果你对 Pug 和 Bootstrap 还不熟悉，可能需要一点时间来习惯这种方法和语法，但正如你所看到的，你可以用很少的代码实现很多功能。
- en: Wrapping the content
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包装内容
- en: Working down the page from top to bottom, the next area is the `content` block.
    You don’t have much to do with this block, as other Pug files decide the contents.
    As it stands, though, the `content` block is anchored to the left margin and is
    unconstrained, meaning that it stretches the full width of any device.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 从页面顶部向下工作，下一个区域是 `content` 块。你不需要对这个块做太多，因为其他 Pug 文件决定了内容。然而，目前 `content` 块固定在左边缘，并且不受限制，这意味着它扩展到任何设备的全宽度。
- en: 'Addressing this situation is easy with Bootstrap. Still in layout.pug, wrap
    the `content` block in a container `div` like so, remembering to ensure that the
    indentation is correct:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Bootstrap 解决这种情况很容易。仍然在 layout.pug 中，像这样将 `content` 块包裹在一个容器 `div` 中，同时确保缩进正确：
- en: '[PRE57]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `div` with a class of `container` is centered in the window and constrained
    to sensible maximum widths on large displays. The contents of a container `div`
    remains aligned to the left as normal, though.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 具有类名为 `container` 的 `div` 在窗口中居中，并在大屏幕上限制在合理的最大宽度内。容器 `div` 的内容仍然按照常规向左对齐。
- en: Adding the footer
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加页脚
- en: At the bottom of the page, you want to add a standard footer. You could add
    a bunch of links in here, or terms and conditions, or a privacy policy. For now,
    to keep things simple, you’ll add a copyright notice. As this change is going
    in the layout file, it’ll be easy to update this notice across all the pages should
    you need to at a later date.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面底部，你想要添加一个标准的页脚。你可以在这里添加一些链接，或者条款和条件，或者隐私政策。为了保持简单，你将添加一个版权声明。因为这个更改是在布局文件中进行的，所以如果你稍后需要更新这个通知，将很容易跨所有页面进行更新。
- en: 'The following code snippet shows all the code needed for your simple footer
    in layout.pug:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了在 layout.pug 中创建简单页脚所需的所有代码：
- en: '[PRE58]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This code is placed inside the container `div` that holds the `content` block,
    so when you add it, make sure that the `footer` line is at the same level of indentation
    as the `block content` line.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被放置在包含`content`块的容器`div`中，所以当你添加它时，确保`footer`行与`block content`行的缩进级别相同。
- en: All together now
  id: totrans-562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一同完成
- en: Now that the navigation bar, content area, and footer have been dealt with,
    you have the complete layout file. The full code for layout.pug is shown in the
    following listing.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经处理了导航栏、内容区域和页脚，你有了完整的布局文件。layout.pug的完整代码如下所示。
- en: Listing 4.5\. Final code for the layout framework in app_server/views/layout.pug
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5. app_server/views/layout.pug中布局框架的最终代码
- en: '[PRE59]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1*** **Starting layout with a fixed navigation bar**'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从固定导航栏开始布局**'
- en: '***2*** **Extendable content block is now wrapped in a container div**'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **可扩展的内容块现在被包裹在一个容器div中**'
- en: '***3*** **Simple copyright footer in the same container as the content block**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **简单的版权页脚在内容块相同的容器中**'
- en: That’s all it takes to create a responsive layout framework with Bootstrap,
    Pug, and Express. If you’ve got everything in place, when you run the application,
    you should see something like the screenshots in [figure 4.7](#ch04fig07), depending
    on your device.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bootstrap、Pug和Express创建响应式布局框架，只需做这些就足够了。如果你已经一切准备就绪，当你运行应用程序时，你应该能看到类似[图4.7](#ch04fig07)中的截图，这取决于你的设备。
- en: Figure 4.7\. The homepage after the layout template has been set up. Bootstrap
    automatically collapsed the navigation on the small screen size of the phone.
    The navigation bar overlaps the content, but that problem will be fixed when the
    content layouts are created.
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7. 布局模板设置后的主页。Bootstrap自动折叠了手机小屏幕尺寸下的导航。导航栏覆盖了内容，但这个问题将在创建内容布局时得到解决。
- en: '![](Images/04fig07_alt.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig07_alt.jpg)'
- en: 'You see that the navigation still overlays the content, but you’ll address
    that problem when you start looking at the content layouts. It’s a good indication
    that the navigation is working as you want it to, though: you want the navigation
    to be ever present, fixed to the top of the window. Also notice that Bootstrap
    has collapsed the navigation into a drop-down menu on the smaller screen of the
    phone—a nice result for little effort on your part.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到导航仍然覆盖了内容，但当你开始查看内容布局时，你会解决那个问题。这是一个很好的迹象，表明导航正在按你的意愿工作：你希望导航始终存在，固定在窗口顶部。同时请注意，Bootstrap已经将导航折叠成下拉菜单，这是在你手机较小的屏幕上——这是你付出很少努力就能得到的好结果。
- en: '|  |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you can’t access your development site on a phone, you can always try resizing
    your browser window. All major web browsers allow you to emulate various mobile
    devices and screen sizes through their built-in developer tools.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法在手机上访问你的开发网站，你可以尝试调整浏览器窗口的大小。所有主流的网页浏览器都允许你通过内置的开发者工具模拟各种移动设备和屏幕尺寸。
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that the generic layout template is complete, it’s time to start building
    the actual pages of your application.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通用布局模板已经完成，是时候开始构建你应用程序的实际页面了。
- en: 4.3.3\. Building a template
  id: totrans-578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3. 构建模板
- en: When you’re building templates, start with whichever one makes the most sense
    to you. This template may be the most complicated or the simplest, or the first
    in the main user journey. For Loc8r, a good place to start is the homepage, which
    is the example we’ll go through in the most detail.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建模板时，从对你最有意义的一个开始。这个模板可能是最复杂或最简单的，或者是主要用户旅程中的第一个。对于Loc8r来说，一个好的起点是主页，这是我们将会最详细地讨论的例子。
- en: Defining a layout
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义布局
- en: The primary aim for the homepage is to display a list of locations. Each location
    needs to have a name, an address, the distance away from the user, user ratings,
    and a facilities list. You also want to add a header to the page and some text
    to put the list in context, so that users know what they’re looking at when they
    visit.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 主页的主要目的是显示位置列表。每个位置都需要有名称、地址、距离用户的距离、用户评分和设施列表。你还需要添加一个页眉和一些文本，以便将列表置于上下文中，这样用户在访问时就知道他们在看什么。
- en: You may find it useful, as we do, to sketch a layout or two on a piece of paper
    or a whiteboard. We find this sketch helpful for creating a starting point for
    the layout, making sure that we’ve got all the pieces we need on a page without
    getting bogged down in the technicalities of code. [Figure 4.8](#ch04fig08) shows
    what you might sketch for the homepage of Loc8r.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得，像我们一样，在一张纸或白板上草拟一个或两个布局是有用的。我们发现这个草图对于创建布局的起点很有帮助，确保我们在页面上拥有所有需要的组件，而不会陷入代码的技术细节。![图4.8](#ch04fig08)展示了你可能为Loc8r的首页草拟的内容。
- en: Figure 4.8\. Desktop and mobile layout sketches for the homepage. Sketching
    the layouts for a page can give you a quick idea of what you’re going to build
    without getting distracted by the intricacies of Adobe Photoshop or the technicalities
    of code.
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8. 首页的桌面和移动布局草图。为页面绘制布局可以快速了解你将要构建的内容，而不会因为Adobe Photoshop的复杂性或代码的技术细节而分心。
- en: '![](Images/04fig08_alt.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![Images/04fig08_alt.jpg]'
- en: 'You’ll see that there are two layouts: one for a desktop and one for a phone.
    It’s worth making the distinction at this point, with your understanding of what
    Bootstrap can do and how it works. This is the beginning of starting to think
    about response design.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到有两种布局：一种用于桌面，另一种用于手机。在这个阶段，理解Bootstrap能做什么以及它是如何工作的，区分这两种布局是有意义的。这是开始思考响应式设计的起点。
- en: At this stage, the layouts are by no means final, and you may well tweak and
    change them as you build the code. But any journey is easier if you have a destination
    and a map, which the sketch gives you. You can start your code off in the right
    direction. The few minutes it takes to create a sketch can save you hours, if
    you find that you need to move parts around or even throw them out and start again.
    The process is much easier with a sketch than with a load of code.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，布局绝对不是最终的，你完全可以在构建代码的过程中调整和更改它们。但如果你有一个目的地和一张地图，旅程就会容易得多，草图为你提供了这些。你可以从正确的方向开始编写代码。创建草图所花费的几分钟可以节省你几个小时的时间，尤其是当你发现需要移动部分内容或甚至完全放弃并重新开始时。与一大堆代码相比，这个过程有了草图会容易得多。
- en: Now that you have an idea of the layout and the pieces of content required,
    it’s time to put everything together in a new template.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对布局和所需的内容组件有了概念，是时候将所有内容组合到一个新的模板中。
- en: Setting up the view and the controller
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置视图和控制器
- en: The first step is creating a new view file and linking it to the controller.
    In the app_server/views folder, make a copy of the index.pug view, and save it
    in the same folder as locations-list.pug. It’s best not to call the file homepage
    or something similar, as at some point, you may change your mind about what should
    be displayed on the homepage. This way, the name of the view clearly identifies
    it, and it can be used anywhere without confusion.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的视图文件并将其链接到控制器。在app_server/views文件夹中，复制index.pug视图文件，并将其保存到与locations-list.pug相同的文件夹中。最好不要将文件命名为homepage或类似名称，因为某个时候，你可能会改变主意，不知道首页应该显示什么。这样，视图的名称可以清楚地标识它，并且可以在任何地方使用而不会引起混淆。
- en: 'The second step is telling the controller for the homepage that you want to
    use this new view. The controller for the homepage is in the locations.js file
    in app_server/controllers. Update this file to change the view called by the `homelist`
    controller, as shown in the following code snippet (modifications in bold):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是告诉首页的控制器你想要使用这个新的视图。首页的控制器位于app_server/controllers中的locations.js文件。更新此文件以更改由`homelist`控制器调用的视图，如下面的代码片段所示（加粗部分为修改）：
- en: '[PRE60]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now you’re ready to build the view template.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好构建视图模板了。
- en: 'Coding the template: Page layout'
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写模板：页面布局
- en: When we write the code for layouts, we prefer to start with the big pieces and
    then move toward the detail. As you extend the layout file, the navigation bar
    and footer are already done, but you still have the page header, the main area
    for the list, and the sidebar to consider.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写布局的代码时，我们更喜欢从大的组件开始，然后逐步细化。随着布局文件的扩展，导航栏和页脚已经完成，但你仍然需要考虑页面标题、列表的主要区域和侧边栏。
- en: 'At this point, you need to take a first stab at how many of the 12 Bootstrap
    columns you want each element to take up on different devices. The following code
    snippet shows the layout of the three distinct areas of the Loc8r List page in
    locations-list.pug:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你需要尝试确定每个元素在不同设备上想要占用多少个Bootstrap列。以下代码片段显示了locations-list.pug中Loc8r列表页面的三个不同区域的布局：
- en: '[PRE61]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1*** **Page header that fills the entire width of the screen**'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **填充整个屏幕宽度的页面标题**'
- en: '***2*** **Container for the list of locations, spanning all 12 columns on extra-small
    and small devices, and 8 columns on medium devices and larger**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **位置列表的容器，在超小号和小号设备上跨越所有 12 列，在中号设备和大号设备上跨越 8 列**'
- en: '***3*** **Container for secondary or sidebar information, spanning all 12 columns
    on extra-small and small devices, and 4 columns on medium devices and larger**'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **次要信息或侧边栏信息的容器，在超小号和小号设备上跨越所有 12 列，在中号设备和大号设备上跨越 4 列**'
- en: You might go back and forth a bit, testing the columns at various resolutions
    until you’re happy with them. Having device simulators can make this process easier,
    but a simple method is to change the width of your browser window to force the
    different Bootstrap breakpoints. When you’ve got something that you think is probably
    okay, you can push it up to Heroku and test it for real on your phone or tablet.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要来回测试几次，调整不同分辨率下的列，直到你对它们满意。拥有设备模拟器可以使这个过程更容易，但一个简单的方法是改变浏览器窗口的宽度，以强制不同的
    Bootstrap 断点。当你认为某个布局可能合适时，你可以将其推送到 Heroku 上，并在你的手机或平板电脑上实际测试。
- en: 'Coding the template: Locations list'
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编码模板：位置列表
- en: Now that the containers for the homepage are defined, it’s time for the main
    area. You have an idea of what you want here from the sketches you drew for the
    page layout. Each place should show the name, address, rating, distance from the
    user, and key facilities.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 现在主页的容器已经定义好了，接下来是主要区域。你可以从为页面布局绘制的草图中获得这里想要的内容的想法。每个地方都应该显示名称、地址、评分、用户距离以及关键设施。
- en: Because you’re creating a clickable prototype, all the data will be hardcoded
    into the template for now. This approach is the quickest way of putting a template
    together and ensuring that you have the information you want displayed the way
    you want. You’ll worry about the data side later. If you’re working from an existing
    data source or have constraints on what data you can use, naturally you’ll have
    to bear those facts in mind when creating the layouts.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在创建一个可点击的原型，所以现在所有数据都将硬编码到模板中。这种方法是快速组合模板并确保你以你想要的方式显示所需信息的最快方式。你将在稍后处理数据方面的问题。如果你从一个现有的数据源工作或对可以使用的数据有约束，那么在创建布局时，你自然需要考虑这些事实。
- en: 'Again, getting a layout you’re happy with may take a bit of testing, but Pug
    and Bootstrap working together make the process considerably easier than it might
    be. The following code snippet shows what you might come up with for a single
    location to replace the `p List area` placeholder in locations-list.pug:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，获得你满意的布局可能需要一些测试，但 Pug 和 Bootstrap 的结合使得这个过程比单独使用它们要容易得多。以下代码片段显示了你可以为单个位置提供的，以替换
    locations-list.pug 中的 `p List area` 占位符：
- en: '[PRE62]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1*** **Creates a new Bootstrap card and card block to wrap the content**'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个新的 Bootstrap 卡片和卡片块来包裹内容**'
- en: '***2*** **Name of the listing and a link to the location**'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **列表名称及其位置链接**'
- en: '***3*** **Uses Font Awesome icons to output a star rating**'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用 Font Awesome 图标输出星级评分**'
- en: '***4*** **Uses Bootstrap’s badge helper class to display the distance away**'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用 Bootstrap 的徽章辅助类来显示距离**'
- en: '***5*** **Address of the location**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **位置的地址**'
- en: '***6*** **Facilities of the location, output using Bootstrap’s badge classes**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **位置设施，使用 Bootstrap 的徽章类输出**'
- en: Once again, you can see how much you can achieve with relatively little effort
    and code, all thanks to the combination of Pug and Bootstrap. Remember that some
    custom classes to help with styling are in the styles.css file in public/stylesheets,
    available in the GitHub repo. Without these classes, your visuals will look much
    different. To get an idea of what the preceding code snippet does, take a look
    at [figure 4.9](#ch04fig09).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你可以看到，通过相对较少的努力和代码，你可以实现多少。这都要归功于 Pug 和 Bootstrap 的结合。记住，一些用于美化的自定义类在 public/stylesheets
    下的 styles.css 文件中，可在 GitHub 仓库中找到。没有这些类，你的视觉效果将大不相同。要了解前面的代码片段做了什么，请查看[图 4.9](#ch04fig09)。
- en: Figure 4.9\. Onscreen rendering of a single location on the List page
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9\. 列表页面上单个位置的屏幕渲染
- en: '![](Images/04fig09_alt.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig09_alt.jpg)'
- en: 'This section is set to go across the full width of the available area: 12 columns
    on all devices. Remember, though, that this section is nested inside a responsive
    column, so “full width” is the full width of the containing column, not necessarily
    that of the browser viewport. This explanation will make more sense when you put
    everything together and see the application in action.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分设置为跨越可用区域的全部宽度：所有设备上的12列。但请记住，尽管这个部分嵌套在响应式列中，所以“全宽”是包含列的全宽，而不是浏览器视口的宽度。当您将所有内容组合在一起并看到应用程序的实际运行时，这个解释将更有意义。
- en: 'Coding the template: Putting it together'
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编码模板：将其组合在一起
- en: You have the layout of page elements, the structure of the list area, and some
    hardcoded data, so it’s time to see what everything looks like. To get a better
    feel for the layout in the browser, it’s a good idea to duplicate and modify the
    List page so that several locations show up. The code, including a single location
    for brevity, is shown in the following listing.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经有了页面元素布局、列表区域的结构和一些硬编码的数据，现在是时候看看一切看起来是什么样子了。为了更好地感受浏览器中的布局，复制并修改列表页面以显示多个位置是个好主意。以下列出的是包括单个位置以节省篇幅的代码。
- en: Listing 4.6\. Complete template for app_server/views/locations-list.pug
  id: totrans-618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6. app_server/views/locations-list.pug 的完整模板
- en: '[PRE63]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1*** **Starts header area**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **开始标题区域**'
- en: '***2*** **Starts responsive main listing column section**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **开始响应式主列表列部分**'
- en: '***3*** **An individual listing; duplicates this section to create a list of
    multiple items**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **单个列表；复制此部分以创建多个项目的列表**'
- en: '***4*** **Sets up sidebar area and populates it with some content**'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **设置侧边栏区域并填充一些内容**'
- en: When you’ve got this code in place, you’ve got the homepage listing template
    done. If you run the application and head to localhost:3000, you should see something
    like [figure 4.10](#ch04fig10).
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将此代码放置到位后，您就完成了主页列表模板。如果您运行应用程序并转到localhost:3000，您应该会看到类似于[图 4.10](#ch04fig10)
    的内容。
- en: Figure 4.10\. Responsive template for the homepage in action on different devices
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10. 在不同设备上运行的首页响应式模板
- en: '![](Images/04fig10_alt.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig10_alt.jpg)'
- en: See how the layout changes between a desktop view and a mobile view? That change
    is thanks to Bootstrap’s responsive framework and your choice of CSS classes.
    Scrolling down in the mobile view, you see the sidebar text content between the
    main list and the footer. On the smaller screen, it’s more important to display
    the list in the available space than the text.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到桌面视图和移动视图之间的布局如何变化吗？这种变化归功于Bootstrap的响应式框架和您选择的CSS类。在移动视图中向下滚动，您会在主列表和页脚之间看到侧边栏的文本内容。在较小的屏幕上，显示列表在可用空间中比显示文本更重要。
- en: Great; you created got a responsive layout for the homepage by using Pug and
    Bootstrap in Express and Node. Next, you’ll add the other views.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 很好；您通过在Express和Node中使用Pug和Bootstrap创建了一个响应式布局的主页。接下来，您将添加其他视图。
- en: 4.4\. Adding the rest of the views
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 添加其余视图
- en: 'The Locations List page is built, so you need to create the other pages to
    give users a site that they can click through. In this section, we’ll cover adding
    these pages:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 位置列表页面已构建，因此您需要创建其他页面，以便用户可以点击浏览。在本节中，我们将介绍添加这些页面：
- en: Details
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详情
- en: Add Review
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加评论
- en: About
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于
- en: We won’t go through the process in much detail for all of them, though—only
    a bit of explanation, the code, and the output. You can always download the source
    code from GitHub if you prefer.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会对所有这些过程进行详细说明，但只会提供一些解释、代码和输出。如果您更喜欢，可以始终从GitHub下载源代码。
- en: 4.4.1\. Details page
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1. 详细信息页面
- en: The logical step, and arguably the next-most-important page to look at, is the
    Details page for an individual location.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的步骤，并且可以说是查看下一个最重要的页面，即单个位置的详细信息页面。
- en: This page needs to display all the information about a location, including
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面需要显示有关位置的所有信息，包括
- en: Name
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Address
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: Rating
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分
- en: Opening hours
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营业时间
- en: Facilities
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设施
- en: Location map
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置地图
- en: Reviews, each with
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论，每个都有
- en: Rating
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分
- en: Reviewer name
  id: totrans-646
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论者姓名
- en: Review date
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论日期
- en: Review text
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论文本
- en: Button to add a new review
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新评论的按钮
- en: Text to set the context of the page
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置页面上下文的文本
- en: That’s quite a lot of information! This template is the single most complicated
    one in your application.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当多的信息！这个模板是您应用程序中最复杂的一个。
- en: Preparation
  id: totrans-652
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 准备
- en: 'The first step is updating the controller for this page to use a different
    view. Look for the `locationInfo` controller in the locations.js file in app_server/controllers.
    Change the name of the view to `location-info`, as shown in the following code
    snippet:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新此页面的控制器以使用不同的视图。在app_server/controllers中的locations.js文件中查找`locationInfo`控制器。将视图的名称更改为`location-info`，如下代码片段所示：
- en: '[PRE64]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The next step is obtaining a key to access the Google Maps API. To get your
    keys, you need to sign up for an account, if you don’t already have one, at the
    following address:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取访问谷歌地图API的密钥。如果你还没有账户，你需要在该地址注册一个账户：
- en: '[PRE65]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Make sure that you keep your API key safe; you’ll need it for the next listing.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你保管好你的API密钥；你将在下一个列表中需要它。
- en: Remember, if you run the application at this point, it won’t work, because Express
    can’t find the view template—not surprising, as you haven’t created it yet. That’s
    the next part.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你在这个时候运行应用程序，它将无法工作，因为Express找不到视图模板——这并不奇怪，因为你还没有创建它。这就是下一个部分。
- en: The view
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图
- en: Create a new file in app_server/views and save it as location-info.pug. The
    content of this file is shown in [listing 4.7](#ch04ex07), which is the largest
    listing in this book. Remember that for the purposes of this stage in the prototype
    development, you’re generating clickable pages with the data hardcoded directly
    into them.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在app_server/views中创建一个新文件，并将其保存为location-info.pug。该文件的内容显示在[列表4.7](#ch04ex07)中，这是本书中最大的列表。记住，在原型开发的这个阶段，你是在生成带有直接硬编码数据的可点击页面。
- en: Listing 4.7\. View for the Details page, app_server/views/location-info.pug
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 详情页面的视图，app_server/views/location-info.pug
- en: '[PRE66]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1*** **Starts with page header**'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从页面标题开始**'
- en: '***2*** **Sets up nested responsive columns needed for the template**'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置模板所需的嵌套响应式列**'
- en: '***3*** **One of several Bootstrap card components used to define information
    areas—in this case, opening hours**'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **用于定义信息区域（在本例中为营业时间）的多个Bootstrap卡片组件之一**'
- en: '***4*** **The &nbsp; entity is being used because Pug doesn’t always understand
    whitespace and has a habit of trimming it away.**'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用 &nbsp; 实体是因为Pug并不总是理解空白，并且有删除它的习惯。**'
- en: '***5*** **Uses a static Google Maps image, including coordinates in the query
    string 51.455041,-0.9690884\. Remember to replace the <APIKey> with the Google
    API Key that you obtained earlier.**'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **使用静态谷歌地图图像，包括查询字符串中的坐标51.455041,-0.9690884。记得用你之前获得的Google API Key替换<APIKey>。**'
- en: '***6*** **Creates a link to the Add Review page, using Bootstrap’s button helper
    class**'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **使用Bootstrap的按钮辅助类创建到添加评论页面的链接**'
- en: '***7*** **Final responsive column for sidebar contextual information**'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **侧边栏上下文信息的最后一个响应式列**'
- en: That’s a long template, and you’ll look at how to shorten it soon. But the page
    itself is complex, containing a lot of information and a few nested responsive
    columns. Imagine how much longer it would be if it were written in full HTML!
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的模板，你很快就会看到如何缩短它。但页面本身很复杂，包含大量信息和几个嵌套的响应式列。想象一下，如果它完全用HTML编写，将会多么长！
- en: Make sure that you have the full version of style.css from GitHub included,
    as you’re using it to add a bit of life to the standard Bootstrap theme.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你包含了GitHub上的完整版本style.css，因为你正在使用它为标准的Bootstrap主题添加一些活力。
- en: With that all done, the Details page layout is complete; you can head over to
    localhost:3000/location to check it out. [Figure 4.11](#ch04fig11) shows how this
    layout looks in a browser and on a mobile device.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，详情页面布局就完成了；你可以转到localhost:3000/location查看。![图4.11](Images/04fig11_alt.jpg)显示了在浏览器和移动设备上此布局的外观。
- en: Figure 4.11\. Details page layout on desktop and mobile devices
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.11\. 桌面和移动设备上的详情页面布局
- en: '![](Images/04fig11_alt.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig11_alt.jpg)'
- en: The next step in this user journey is the Add Review page, which has much simpler
    requirements.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 用户旅程的下一步是添加评论页面，它有更简单的要求。
- en: 4.4.2\. Adding the Review page
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 添加评论页面
- en: This page is straightforward, holding a form that contains the user’s name and
    a couple of input fields for the rating and review.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面很简单，包含一个包含用户姓名和评分及评论输入字段的表单。
- en: 'The first step is updating the controller to reference a new view. In app_server/controllers/locations.js,
    change the `addReview` controller to use the new view `location-review-form`,
    as in the following code snippet:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新控制器以引用新的视图。在app_server/controllers/locations.js中，将`addReview`控制器更改为使用新的视图`location-review-form`，如下代码片段所示：
- en: '[PRE67]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The second step is creating the view itself. In the views folder app_server/views,
    create a new file called location-review-form.pug. Because this page is designed
    to be a clickable prototype, you’re not going to be posting the form data anywhere,
    so the aim is to get the action to redirect to the Details page that displays
    the review data. In the form, then, set the action to `/location` and the method
    to `get`. Later, you’ll change this to a `post` method, but this form will give
    you the functionality you need for now. The entire code for the review form page
    is shown in the following listing.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是创建视图本身。在`app_server/views`目录下的`views`文件夹中，创建一个名为`location-review-form.pug`的新文件。因为这个页面被设计成可点击的原型，所以您不会将表单数据提交到任何地方，所以目标是让动作重定向到显示评论数据的详情页面。在表单中，然后设置动作为`/location`，方法为`get`。稍后，您将将其更改为`post`方法，但这个表单将为您提供目前需要的功能。评论表单页面的全部代码如下所示。
- en: Listing 4.8\. View for the Add Review page, app_server/views/location-review-form.pug
  id: totrans-681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. 添加评论页面的视图，`app_server/views/location-review-form.pug`
- en: '[PRE68]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1*** **Sets the form action to /location, and the method to get**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置表单动作到 /location，方法到 get**'
- en: '***2*** **Input field for reviewer to leave their name**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **输入框供评论者留下他们的名字**'
- en: '***3*** **Drop-down select box for rating 1 to**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **用于评分1到...的下拉选择框**'
- en: '***4*** **Text area for the text content of the review**'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **用于评论文本内容的文本区域**'
- en: '***5*** **Submit button for the form**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **表单的提交按钮**'
- en: Bootstrap has a lot of helper classes for dealing with forms, which are evident
    in [listing 4.8](#ch04ex08). But the page is simple, and when you run it, it should
    look like [figure 4.12](#ch04fig12).
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap提供了许多处理表单的辅助类，这在[列表4.8](#ch04ex08)中很明显。但页面很简单，当您运行它时，它应该看起来像[图4.12](#ch04fig12)。
- en: Figure 4.12\. Complete Add Review page in desktop and mobile view
  id: totrans-689
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.12\. 桌面和移动视图中的完整添加评论页面
- en: '![](Images/04fig12_alt.jpg)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig12_alt.jpg)'
- en: The Add Review page marks the end of the user’s journey through the Locations
    collection of screens. There’s only the About page left to do.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 添加评论页面的标记是用户通过屏幕集合的“位置”结束旅程。只剩下关于页面需要完成。
- en: 4.4.3\. Adding the About page
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 添加关于页面
- en: The final page of the static prototype is the About page, which has a header
    and some content—nothing complicated. The layout may be useful for other pages
    farther down the line, such as a privacy policy, or a terms and conditions page,
    so you’re best off creating a generic, reusable view.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 静态原型的最后一页是关于页面，它有一个页眉和一些内容——没有复杂的东西。布局可能对后续的其他页面有用，例如隐私政策或条款和条件页面，因此最好创建一个通用、可重用的视图。
- en: 'The controller for the About page is in the others.js file in app_server/controllers.
    You’re looking for the controller called `about`, and you want to change the name
    of the view to `generic-text`, as in the following code snippet:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 关于页面的控制器位于`app_server/controllers`目录下的`others.js`文件中。您正在寻找名为`about`的控制器，并且想要将视图的名称更改为`generic-text`，如下代码片段所示：
- en: '[PRE69]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, create the view `generic-text.pug` in app_server/views. This template
    is small and should look like the following listing.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`app_server/views`中创建名为`generic-text.pug`的视图。这个模板很小，应该看起来如下所示。
- en: 'Listing 4.9\. View for text-only pages: app_server/views/generic-text.pug'
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. 仅文本页面的视图：`app_server/views/generic-text.pug`
- en: '[PRE70]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1*** **Use | to create lines of plain text within a <p> tag.**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用|在<p>标签内创建普通文本行。**'
- en: This is a simple layout. Don’t worry about including page-specific content in
    a generic view at this point; you’ll take that task on soon and make the page
    reusable. For the purposes of finishing the clickable static prototype, it’s okay.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的布局。现在不要担心在通用视图中包含特定页面的内容；您很快就会承担这项任务并使页面可重用。为了完成可点击的静态原型，这是可以的。
- en: You’ll probably want some additional lines so that the page appears to have
    real content. Notice that the lines starting with the pipe character (`|)`can
    contain HTML tags if you want them to. [Figure 4.13](#ch04fig13) shows how the
    page might look in a browser with a bit more content.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要一些额外的行，以便页面看起来有真实的内容。注意，以竖线字符（`|`）开头的行可以包含HTML标签，如果您想的话。[图4.13](#ch04fig13)显示了页面在浏览器中带有更多内容时的样子。
- en: Figure 4.13\. Generic text template rendering the About page
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.13\. 渲染关于页面的通用文本模板
- en: '![](Images/04fig13_alt.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04fig13_alt.jpg)'
- en: 'That’s the last of the four pages you need for the static site. You can push
    this page up to Heroku and have people visit the URL and click around. If you’ve
    forgotten how, the following code snippet shows the terminal commands you need,
    assuming that you’ve already set up Heroku. In terminal, you need to be in the
    root folder of the application. Then issue these commands:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是静态网站所需的最后四页之一。你可以将此页面推送到Heroku，让人们访问URL并四处点击。如果你忘记了如何操作，以下代码片段显示了你需要使用的终端命令，假设你已经设置了Heroku。在终端中，你需要位于应用程序的根目录。然后发出以下命令：
- en: '[PRE71]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '|  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Get the source code**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取源代码**'
- en: 'The source code for the application as it stands at this point is available
    in the chapter-04-views branch on GitHub. In a fresh folder in terminal, enter
    the following commands to clone it and install the npm module dependencies:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 目前应用程序的源代码可在GitHub上的chapter-04-views分支中找到。在终端的新文件夹中，输入以下命令以克隆它并安装npm模块依赖项：
- en: '[PRE72]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|  |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What’s next? The routes, views, and controllers are set up for a static site
    that you can click through, and you’ve pushed it up to Heroku so that others can
    also try it. In some ways, you’ve reached the goal for this stage; you can stop
    here while you play with the journeys and get feedback. This stage is definitely
    the easiest point in the process to make large, sweeping changes.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？路由、视图和控制器已设置好，你可以点击浏览静态网站，并且你已经将其推送到Heroku，以便其他人也可以尝试。在某种程度上，你已经达到了这个阶段的目标；你可以在这里停下来，同时玩转旅程并获得反馈。这个阶段无疑是整个过程中最容易进行大规模、全面更改的点。
- en: If you definitely plan to build an Angular SPA, and assuming that you’re happy
    with what you’ve done to this point, you probably wouldn’t go any further with
    creating a static prototype. Instead, you’d start to create an application in
    Angular.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实计划构建一个Angular SPA，并且假设你对到目前为止所做的工作感到满意，你可能不会进一步创建静态原型。相反，你将开始创建一个Angular应用程序。
- en: But the next step you’ll take now continues down the road of creating the Express
    application. So while keeping with the static site, you’ll remove the data from
    the views and put it in the controllers.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 但你现在将要采取的下一步将继续沿着创建Express应用程序的道路前进。所以，尽管保持静态网站，你将把数据从视图中移除，放入控制器中。
- en: 4.5\. Taking the data out of the views and making them smarter
  id: totrans-714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 从视图中移除数据并使它们更智能
- en: At the moment, all the content and data are held in the views. This arrangement
    is perfect for testing stuff and moving things around, but you need to move forward.
    A goal of the MVC architecture is to have views without content or data. The views
    should be fed data that they present to the end user while being agnostic about
    the data they’re fed. The views need a data structure, but what’s inside the data
    doesn’t matter to the view itself.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有内容和数据都存储在视图中。这种安排非常适合测试和移动内容，但你需要继续前进。MVC架构的一个目标是拥有没有内容或数据的视图。视图应该提供数据给最终用户，同时对于提供的数据保持无知。视图需要一个数据结构，但数据本身的内容对视图本身并不重要。
- en: 'Consider the MVC architecture: the model holds the data; the controller processes
    the data; and, finally, the view renders the processed data. You’re not dealing
    with the model yet; you’ll do that starting in [chapter 5](kindle_split_016.xhtml#ch05).
    For now, you’re working with the views and controllers.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑MVC架构：模型持有数据；控制器处理数据；最后，视图渲染处理后的数据。你现在还没有处理模型；你将在[第5章](kindle_split_016.xhtml#ch05)开始处理。现在，你正在处理视图和控制器。
- en: To make the views smarter and do what they’re intended to do, you need to take
    the data and content out of the views and put it in the controllers. [Figure 4.14](#ch04fig14)
    illustrates the data flow in an MVC architecture and the changes you want to make.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 要使视图更智能并执行它们预期的功能，你需要将数据和内容从视图中移除，并将其放入控制器中。[图4.14](#ch04fig14)说明了MVC架构中的数据流以及你想要进行的更改。
- en: Figure 4.14\. How the data should flow in an MVC pattern, from the model through
    the controller to the view. At this point in the prototype, your data is in the
    view, but you want to move it a step back into the controller.
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.14\. MVC模式中数据应该如何流动，从模型通过控制器到视图。在这个原型阶段，你的数据在视图中，但你希望将其退回一步到控制器中。
- en: '![](Images/04fig14_alt.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig14_alt.jpg)'
- en: Making these changes now allows you to finalize the views so that you’re ready
    for the next step. As a bonus, you’ll start thinking about how the processed data
    should look in the controllers. Rather than starting with a data structure, start
    with the ideal front end and slowly reverse-engineer the data back through the
    MVC steps as your understanding of the requirements solidifies.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做出这些更改，可以使你最终确定视图，以便为下一步做好准备。作为奖励，你将开始思考处理后的数据在控制器中应该是什么样子。与其从数据结构开始，不如从理想的前端开始，随着你对需求理解的加深，逐步逆向工程数据，通过
    MVC 步骤返回。
- en: How are you going to do these things? Starting with the homepage, you’ll take
    every piece of content out of the Pug view. You’ll update the Pug file to contain
    variables in place of the content and put the content as variables in the controller.
    Then the controller can pass these values into the view. The result should look
    the same in the browser, and users shouldn’t be able to spot a difference. The
    roles of the various parts and the movement and use of data are shown in [figure
    4.15](#ch04fig15).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何做这些事情？从主页开始，你将把每一块内容从 Pug 视图中移除。你将更新 Pug 文件，用变量替换内容，并将内容作为变量放入控制器。然后控制器可以将这些值传递给视图。在浏览器中，结果应该看起来相同，用户不应该能够发现差异。各种部分的作用以及数据的移动和使用方式在
    [图 4.15](#ch04fig15) 中展示。
- en: Figure 4.15\. When the controller specifies the data, it passes the data to
    the view as variables; the view uses that data to generate the final HTML that’s
    delivered to the user.
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.15\. 当控制器指定数据时，它将数据作为变量传递给视图；视图使用这些数据生成最终发送给用户的 HTML。
- en: '![](Images/04fig15_alt.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig15_alt.jpg)'
- en: At the end of this stage, the data is still hardcoded, but in the controllers
    instead of the views. The views are now smarter and able to accept and display
    whatever data is sent to them (provided that the data is in the correct format,
    of course).
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段结束时，数据仍然是硬编码的，但现在是控制器而不是视图。现在视图更智能，能够接受并显示发送给它们的任何数据（当然，前提是数据格式正确）。
- en: 4.5.1\. Moving data from the view to the controller
  id: totrans-725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1\. 从视图中移动数据到控制器
- en: 'You’ll start with the homepage and move the data out of the `locations-list.pug`
    view into the `homelist` function in the locations.js controllers file. Start
    at the top with something simple: the page header. The following code snippet
    shows the page header section of the `locations-list.pug` view, which has two
    pieces of content:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从主页开始，将 `locations-list.pug` 视图中的数据移出，放入 `locations.js` 控制器文件中的 `homelist`
    函数。从顶部开始，做一些简单的事情：页面标题。以下代码片段显示了 `locations-list.pug` 视图的页面标题部分，其中包含两块内容：
- en: '[PRE73]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1*** **Large-font page title**'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **大字体页面标题**'
- en: '***2*** **Smaller-font strapline for page**'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **页面的小字体标语**'
- en: 'These two pieces of content are the first that you’ll move into the controller.
    The homepage controller currently looks like the following:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这两块内容是你首先将移入控制器的。当前的主页控制器看起来如下所示：
- en: '[PRE74]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This controller is already sending one piece of data to the view. Remember
    that the second parameter in the `render` function is a JavaScript object containing
    the data to send to the view. Here, the `homelist` controller sends the data object
    `{ title: ''Home'' }` to the view. This object is being used by the layout file
    to put the string `Home` in the HTML `<title>`, which isn’t necessarily the best
    choice of text.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '这个控制器已经向视图发送了一块数据。记住，`render` 函数中的第二个参数是一个包含要发送到视图的数据的 JavaScript 对象。在这里，`homelist`
    控制器发送了数据对象 `{ title: ''Home'' }` 到视图。这个对象被布局文件用来在 HTML `<title>` 中放置字符串 `Home`，这并不一定是最佳文本选择。'
- en: Updating the controller
  id: totrans-733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新控制器
- en: 'Change the title to something more appropriate for the page, and also add the
    two data items for the page header. Make these changes to the controller first,
    as follows (modifications in bold):'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 将标题更改为更适合页面的内容，并添加两个页面标题数据项。首先对这些更改进行控制器更新，如下（加粗部分）：
- en: '[PRE75]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1*** **New nested pageHeader object containing properties for the title
    and the strapline of the page**'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **包含页面标题和标语属性的新的嵌套 pageHeader 对象**'
- en: For neatness and future manageability, the title and the strapline are grouped
    within a `pageHeader` object. This approach is a good habit to get into and will
    make the controllers easier to update and maintain.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 为了整洁和未来的可管理性，标题和标语被组合在一个 `pageHeader` 对象中。这种做法是一个好习惯，会使控制器更容易更新和维护。
- en: Updating the view
  id: totrans-738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新视图
- en: 'Now that the controller is passing these pieces of data to the view, you can
    update the view to reference them in place of the hardcoded content. Nested data
    items like these are referenced using dot syntax, as you do when getting data
    out of objects in JavaScript. To reference the page header strapline in the `locations-list.pug`
    view, use `pageHeader.strapline`. The following code snippet shows the page header
    section of the view (modifications in bold):'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在控制器将这些数据片段传递给视图后，你可以更新视图以在适当位置引用它们，而不是使用硬编码的内容。像这样的嵌套数据项使用点符号引用，就像你在 JavaScript
    中从对象中获取数据时那样。要引用 `locations-list.pug` 视图中的页面标题标语，请使用 `pageHeader.strapline`。以下代码片段显示了视图的页面标题部分（加粗的部分）：
- en: '[PRE76]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1*** **= signifies that the following content is buffered code—in this case,
    a JavaScript object.**'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **= 表示以下内容是缓冲代码——在这种情况下，是一个 JavaScript 对象。**'
- en: '***2*** **#{} delimiters are used to insert data into a specific place, such
    as part of a piece of text.**'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **#{} 定界符用于将数据插入到特定位置，例如文本的一部分。**'
- en: The code outputs `pageHeader.title` and `pageHeader.strapline` in the relevant
    places in the view. See the sidebar “[Referencing data in Pug templates](#ch04sb05)”
    for more details.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在视图的相关位置输出 `pageHeader.title` 和 `pageHeader.strapline`。有关更多详细信息，请参阅侧边栏“[在
    Pug 模板中引用数据](#ch04sb05)”。
- en: '|  |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Referencing data in Pug templates**'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 Pug 模板中引用数据**'
- en: 'There are two key syntaxes for referencing data in Pug templates. The first
    syntax is called *interpolation*, and it’s typically used to insert data into
    the middle of some other content. Interpolated data is defined by the opening
    delimiter `#{` and the end delimiter `}`. You normally use it like this:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pug 模板中引用数据有两种主要的语法。第一种语法称为 *插值*，通常用于将数据插入到其他内容中间。插值数据由开始定界符 `#{` 和结束定界符 `}`
    定义。你通常像这样使用它：
- en: '[PRE77]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If your data contains HTML, this is escaped for security reasons; end users
    won’t see any HTML tags displayed as text, and the browser won’t interpret them
    as HTML. If you want the browser to render any HTML contained in the data, you
    can use the following syntax:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据包含 HTML，出于安全考虑，它会进行转义；最终用户不会看到任何 HTML 标签作为文本显示，浏览器也不会将它们解释为 HTML。如果你想让浏览器渲染数据中包含的任何
    HTML，可以使用以下语法：
- en: '[PRE78]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This syntax poses potential security risks, however, and should be done only
    for data sources that you trust. You shouldn’t allow user inputs to display like
    this without some additional security checks.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种语法存在潜在的安全风险，并且仅应针对你信任的数据源进行。你不应该允许用户输入以这种方式显示，除非进行一些额外的安全检查。
- en: 'The second method of outputting the data is with *buffered code*. Instead of
    inserting the data into a string, you build the string with JavaScript, using
    the `=` sign directly after the tag declaration, like this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数据的第二种方法是使用 *缓冲代码*。不是将数据插入到字符串中，而是使用 JavaScript 直接在标签声明后使用等号 `=` 来构建字符串，如下所示：
- en: '[PRE79]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Again, this escapes any HTML for security reasons. If you want to have unescaped
    HTML in your output, you can use slightly different syntax:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是出于安全考虑而转义任何 HTML。如果你想在输出中包含未转义的 HTML，可以使用稍微不同的语法：
- en: '[PRE80]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Once again, be careful. Whenever possible, you should use one of the escaped
    methods to be on the safe side.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，请小心。只要有可能，你应该使用其中一种转义方法以确保安全。
- en: 'For this buffered code approach, you can also use JavaScript template strings,
    like this:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种缓冲代码方法，你还可以使用 JavaScript 模板字符串，如下所示：
- en: '[PRE81]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|  |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you run the application now and head back to the homepage, the only change
    you should notice is that the `<title>` has been updated. Everything else still
    looks the same, but some of the data is now coming from the controller.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序并返回主页，你应该注意到的唯一变化是 `<title>` 已被更新。其他一切看起来都一样，但一些数据现在来自控制器。
- en: This section serves as a simple example of what you’re doing at this point and
    how you’re doing it. The complicated part of the homepage is the listing section,
    so in the next section, you’ll look at how you can approach that task.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分是一个简单的例子，说明你现在正在做什么以及你是如何做的。主页的复杂部分是列表部分，所以在下一段中，你将了解如何处理这项任务。
- en: 4.5.2\. Dealing with complex, repeating data patterns
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2. 处理复杂、重复的数据模式
- en: The first thing to bear in mind about the listing section is that it has multiple
    entries, all following the same data pattern and layout pattern. Like you’ve just
    done with the page header, start with the data, taking it from the view to the
    controller.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表部分，首先要注意的是它有多个条目，所有条目都遵循相同的数据模式和布局模式。就像你刚刚对页面标题所做的那样，从数据开始，从视图到控制器获取数据。
- en: In terms of JavaScript data, a repeatable pattern lends itself nicely to the
    idea of an array of objects. You want one array to hold multiple objects, with
    each object containing all the relevant information for an individual listing.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript数据方面，一个可重复的模式非常适合作为对象数组的想法。你想要一个数组来存储多个对象，每个对象都包含单个列表的所有相关信息。
- en: Analyzing the data in the view
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分析视图中的数据
- en: Take a look at a listing to see what information you need the controller to
    send. [Figure 4.16](#ch04fig16) reminds you how a listing looks in the homepage
    view.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 看看列表以确定控制器需要发送哪些信息。[图4.16](#ch04fig16)提醒你列表在主页视图中的样子。
- en: Figure 4.16\. An individual listing, showing the data that you need
  id: totrans-766
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.16\. 单个列表，显示你需要的数据
- en: '![](Images/04fig16_alt.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig16_alt.jpg)'
- en: 'From this screenshot, you can see that an individual listing on the homepage
    has the following data requirements:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个屏幕截图，你可以看到主页上的单个列表需要以下数据要求：
- en: Name
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Rating
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分
- en: Distance away
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离
- en: Address
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址
- en: List of facilities
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设施列表
- en: 'Taking the data from the screenshot in [figure 4.16](#ch04fig16) and creating
    a JavaScript object from it, you could come up with something simple, like the
    following code snippet:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图4.16](#ch04fig16)中的屏幕截图获取数据，并从中创建一个JavaScript对象，你可以得到一个简单的代码片段，如下所示：
- en: '[PRE82]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1*** **List of facilities is sent as an array of string values**'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设施列表作为字符串值数组发送**'
- en: That’s all you need to represent a single location as an object. For multiple
    locations, you need an array of these objects.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是表示单个位置作为对象所需的所有内容。对于多个位置，你需要这些对象的数组。
- en: Adding the repeating data array to the controller
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将重复数据数组添加到控制器
- en: 'You need to create an array of the single-location objects—using the data that
    you currently have in the view, if you want—and add it to the data object passed
    to the `render` function in the controller. The following code snippet shows the
    updated `homelist` controller, including the array of locations:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用视图中的现有数据创建一个单位置对象的数组，并将其添加到控制器中传递给`render`函数的数据对象中。以下代码片段显示了更新的`homelist`控制器，包括位置数组：
- en: '[PRE83]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1*** **Array of locations being passed as locations to the view for rendering**'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将位置数组作为渲染的参数传递给视图**'
- en: Here, you’ve got the details for three locations being sent in the array. You
    can add many more, of course, but this code is as good a start as any. Now you
    need to get the view to render this information instead of the data currently
    hardcoded inside it.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有三个位置的详细信息被发送到数组中。当然，你可以添加更多，但这段代码是一个很好的开始。现在你需要让视图渲染这些信息，而不是目前硬编码在其中的数据。
- en: Looping through arrays in a Pug view
  id: totrans-783
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在Pug视图中遍历数组
- en: 'The controller is sending an array to Pug as the variable `locations`. Pug
    offers a simple syntax for looping through an array. In one line, you specify
    which array to use and what variable name you want to use as the key. The key
    is a named reference to the current item in the array, so its contents change
    as the loop iterates through the array. The construct of a Pug loop is like so:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器正在将一个数组发送到Pug作为变量`locations`。Pug提供了一种简单的语法来遍历数组。在一行中，你指定要使用哪个数组以及你想要用作键的变量名。键是对数组中当前项的命名引用，因此其内容在循环遍历数组时会改变。Pug循环的结构如下：
- en: '![](Images/p0112-01.jpg)'
  id: totrans-785
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0112-01.jpg)'
- en: 'Anything nested inside this line in Pug is iterated through for each item in
    the array. Take a look at an example using the locations data and part of the
    view you want. In the view file, locations-list.pug, each location starts with
    the code in the following snippet, with a different name each time:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pug中，任何嵌套在这行内的内容都会针对数组中的每个项目进行迭代。看看使用位置数据和部分视图的示例。在视图文件`locations-list.pug`中，每个位置都以以下代码片段开始，每次使用不同的名字：
- en: '[PRE84]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You can use Pug’s `each`/`in` syntax to loop through all the locations in the
    `locations` array and output the name of each location. How this works is shown
    in the next code snippet:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Pug的`each`/`in`语法遍历`locations`数组中的所有位置，并输出每个位置的名字。这是如何工作的，下一代码片段将展示：
- en: '[PRE85]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1*** **Sets up a loop, defining a variable location as key**'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置循环，定义一个变量位置作为键**'
- en: '***2*** **Nested items are all looped through.**'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **嵌套项都会被遍历。**'
- en: '***3*** **Outputs the name of each location, accessing the name property of
    each location**'
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **输出每个位置的名字，访问每个位置的名字属性**'
- en: 'Given the controller data you’ve got, with three locations in it, using that
    data with the preceding code would result in the following HTML:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 给定你拥有的控制器数据，其中包含三个位置，使用前面的代码与这些数据结合将产生以下HTML：
- en: '[PRE86]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, the HTML construct—the `div`s and the `h4` and `a` tags—are
    repeated three times. But the name of the location is different in each one, corresponding
    to the data in the controller.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，HTML结构——`div`元素和`h4`以及`a`标签——被重复了三次。但每个位置的名称都不同，对应控制器中的数据。
- en: Looping through arrays is easy, and with that little test, you’ve already got
    the first few lines of the updated view text you need. Now you need to follow
    through with the rest of the data used in the listings. You can’t deal with the
    rating stars this way, so you’ll ignore them for now and deal with them soon.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组很容易，通过这个小测试，你已经得到了更新视图文本所需的前几行。现在你需要继续处理列表中使用的其余数据。你不能用这种方式处理评分星标，所以现在先忽略它们，稍后再处理。
- en: 'Dealing with the rest of the data, you can produce the following code snippet,
    which outputs all the data for each listing. As the facilities are being passed
    as an array, you need to loop through that array for each listing:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 处理其余的数据，你可以生成以下代码片段，它输出每个列表的所有数据。由于设施作为数组传递，你需要为每个列表遍历该数组：
- en: '[PRE87]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1*** **Looping through a nested array to output facilities for each location**'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **遍历嵌套数组以输出每个位置的设施**'
- en: Looping through the `facilities` array is no problem, and Pug handles this with
    ease. Pulling out the rest of the data, the distance and the address, is straightforward,
    using the techniques you’ve already used.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历`facilities`数组没有问题，Pug可以轻松处理这一点。提取其余的数据，如距离和地址，使用你已经使用过的技术是直接的。
- en: The only part left to deal with is the rating stars. For that task, you’ll need
    a bit of inline JavaScript code.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要处理的部分就是评分星标。为此任务，你需要一点内联JavaScript代码。
- en: 4.5.3\. Manipulating the data and view with code
  id: totrans-802
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.3\. 使用代码操作数据和视图
- en: For the star ratings, the view is outputting `span`s with different classes,
    using Font Awesome’s icon system. The rating system has a total of five stars,
    which are either solid or empty depending on the rating. A rating of five, for
    example, shows five solid stars; a rating of three shows three solid stars and
    two empty stars, as shown in [figure 4.17](#ch04fig17); and a rating of zero shows
    five empty stars.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 对于星标评分，视图正在输出带有不同类的`span`元素，使用Font Awesome的图标系统。评分系统总共有五颗星，根据评分是实心还是空心。例如，五颗星的评分显示五颗实心星；三颗星的评分显示三颗实心星和两颗空心星，如图[4.17](#ch04fig17)所示；零颗星的评分显示五颗空心星。
- en: Figure 4.17\. The Font Awesome star-rating system in action, showing a rating
    of three out of five stars
  id: totrans-804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.17\. Font Awesome星标系统在实际应用中的效果，显示五颗星中的三颗星
- en: '![](Images/04fig17.jpg)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig17.jpg)'
- en: To generate this type of output, you’ll use some code inside the Pug template.
    The code is essentially JavaScript, with some Pug-specific conventions thrown
    in. To add a line of inline code to a Pug template, prefix the line with a dash
    (hyphen). This prefix tells Pug to run the JavaScript code rather than pass it
    through to the browser.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成这种类型的输出，你将在Pug模板中使用一些代码。代码基本上是JavaScript，加入了一些Pug特定的约定。要在Pug模板中添加一行内联代码，请在行前加上一个连字符（hyphen）。这个前缀告诉Pug运行JavaScript代码而不是将其传递到浏览器。
- en: 'To generate the output for the stars, you’ll use a couple of `for` loops. The
    first loop outputs the correct number of solid stars, and the second loop outputs
    any remaining empty stars. The following code snippet shows how these loops look
    and work in Pug:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成星标的输出，你将使用几个`for`循环。第一个循环输出正确数量的实心星，第二个循环输出任何剩余的空心星。以下代码片段显示了这些循环在Pug中的外观和工作方式：
- en: '[PRE88]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Notice that the syntax is familiar JavaScript, but with no curly brackets defining
    the block of code to run. Instead, the block of code is defined by indentation,
    like the rest of Pug. Also notice the mixture of code and Pug. The lines of code
    are saying, “Every time I evaluate as `true`, render the indented Pug content.”
    This design is nice, as you don’t have to try to construct your HTML with JavaScript.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，语法看起来很熟悉，是JavaScript，但没有用花括号定义代码块来运行。相反，代码块是通过缩进来定义的，就像Pug的其他部分一样。还要注意代码和Pug的混合。代码行表示，“每次评估为`true`时，渲染缩进的Pug内容。”这种设计很好，因为你不需要尝试用JavaScript构建你的HTML。
- en: That’s all the content and layout for the homepage sorted, so you can move on.
    You can do one more thing to improve what you’ve got and make some of the code
    reusable.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，主页的内容和布局就整理好了，你可以继续进行。你还可以做一件事来改进你已有的内容，并使一些代码可重用。
- en: 4.5.4\. Using includes and mixins to create reusable layout components
  id: totrans-811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.4. 使用includes和mixins创建可重用的布局组件
- en: The star-rating code will be useful in other layouts. You’re going to want it
    on the Details page, for example, and maybe in more places in the future. You
    don’t want to have to add it to every page manually. What if you decide that you
    don’t like the Font Awesome icons anymore and want to change the markup? You certainly
    don’t want to have to make changes on every single page that shows a rating—not
    if you can help it.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 星级评分代码在其他布局中也会很有用。你可能想在详情页上使用它，也许未来还会在更多的地方使用。你不想手动添加到每个页面上。如果你决定不再喜欢Font Awesome图标并想更改标记，你当然不希望不得不在每个显示评分的页面上进行更改——如果你能避免的话。
- en: Fortunately, Pug enables you to create reusable components by using mixins and
    includes.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Pug允许你通过使用mixin和includes来创建可重用的组件。
- en: Defining Pug mixins
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义Pug mixins
- en: 'A *mixin* in Pug is essentially a function. You can define a mixin at the top
    of your file and use it in multiple places. A mixin definition is straightforward:
    you define the name of the mixin, and then nest the content of it with indentation.
    The following code snippet shows a basic mixin definition:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: Pug中的*mixin*本质上是一个函数。你可以在文件的顶部定义一个mixin并在多个地方使用它。mixin的定义很简单：你定义mixin的名称，然后通过缩进来嵌套其内容。以下代码片段展示了基本的mixin定义：
- en: '[PRE89]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This definition outputs the `Welcome` text inside a `<p>` tag wherever it’s
    invoked.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义在调用它的任何地方输出`Welcome`文本到`<p>`标签中。
- en: 'Mixins can also accept parameters, as JavaScript functions do. This feature
    will be useful for creating the mixin you need to display the rating, as the HTML
    output will be different depending on the actual rating. The following code snippet
    shows how this process can work, defining the mixin you want to use on the homepage
    to output the rating stars:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins也可以接受参数，就像JavaScript函数一样。这个特性对于创建显示评分所需的mixin非常有用，因为HTML输出会根据实际评分而有所不同。以下代码片段展示了这个过程是如何工作的，定义了在主页上输出评分星级的mixin：
- en: '[PRE90]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1*** **Defines mixin outputRating, expecting a single parameter rating**'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 定义期望单个参数rating的mixin outputRating'
- en: '***2*** **Uses the rating parameter inside for loops to output correct HTML**'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用评分参数在for循环中输出正确的HTML'
- en: In a sense, this mixin works like a JavaScript function. When you define the
    mixin, you can specify the parameters that it expects. You can use these parameters
    in the mixin. You can take the preceding code snippet and pop it into the top
    of the locations-list.pug file, between the `extends layout` and `block content`
    lines.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，这个mixin的工作方式就像一个JavaScript函数。当你定义mixin时，你可以指定它期望的参数。你可以在mixin中使用这些参数。你可以将前面的代码片段放入locations-list.pug文件的顶部，在`extends
    layout`和`block content`行之间。
- en: Calling Pug mixins
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用Pug mixins
- en: 'After defining the mixin, you’ll want to use it, of course. The syntax for
    calling a mixin is to place a `+` before its name. If you have no parameters,
    such as the `welcome` mixin, this syntax looks like the following:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义mixin之后，你当然会想要使用它。调用mixin的语法是在其名称前放置一个`+`。如果你没有参数，例如`welcome`mixin，这个语法看起来如下所示：
- en: '[PRE91]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This syntax calls the `welcome` mixin and outputs the text `Welcome` inside
    a `<p>` tag.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法调用`welcome`mixin并在`<p>`标签内输出文本`Welcome`。
- en: 'Calling a mixin with parameters is equally easy. You send the values of the
    parameters inside parentheses, as you do when calling a JavaScript function. In
    the locations-list.pug file, at the point where you’re outputting the ratings,
    the value of the rating is held in the variable `location.rating`, as shown here:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数调用mixin同样简单。你需要在括号内发送参数的值，就像调用JavaScript函数时一样。在locations-list.pug文件中，在你输出评分的地方，评分的值存储在变量`location.rating`中，如下所示：
- en: '[PRE92]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You can replace this code with a call to your new mixin `outputRating`, sending
    the `location.rating` variable as the parameter. This call looks like the following
    code snippet:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用调用你新创建的mixin `outputRating`来替换这段代码，发送`location.rating`变量作为参数。这个调用看起来如下代码片段：
- en: '[PRE93]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This code outputs exactly the same HTML as before, but you’ve taken part of
    the code outside the contents of the layout. Right now, this code is reusable
    only within the same file, but next, you’ll use includes to make it accessible
    to other files.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出的 HTML 与之前完全相同，但你已经将部分代码移出了布局的内容。目前，这段代码只能在同一文件内重用，但接下来，你将使用包含来使其对其他文件可用。
- en: Using includes in Pug
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Pug 中使用包含
- en: To allow your new mixin to be called from other Pug templates, you need to make
    it an include file, which is easy.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许你的新 mixin 可以从其他 Pug 模板中调用，你需要将其制作成一个包含文件，这很简单。
- en: 'Within the app_server/views folder, create a subfolder called _includes. (The
    _ prefix is a convention that we find useful for keeping folders like this one
    at the top.) Within this folder, create a new file called sharedHTMLfunctions.pug,
    and paste the `outputRating` mixin definition into it, as follows:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 在 app_server/views 文件夹内，创建一个名为 _includes 的子文件夹。（_ 前缀是我们发现对保持此类文件夹在顶部有用的约定。）在这个文件夹内，创建一个名为
    sharedHTMLfunctions.pug 的新文件，并将 `outputRating` mixin 定义粘贴进去，如下所示：
- en: '[PRE94]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Save the file, and you’ve created the include. Pug provides a simple syntax
    for using include files in layouts: use the keyword `include`, followed by the
    relative path to the include file. The following code snippet shows how you might
    do this. This line should go immediately after the `extends layout` line at the
    top of locations-list.pug:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，你就创建了一个包含文件。Pug 提供了一种简单的语法来在布局中使用包含文件：使用关键字 `include`，后跟包含文件的相对路径。以下代码片段显示了如何进行操作。这一行应立即跟在
    locations-list.pug 顶部的 `extends layout` 行之后：
- en: '[PRE95]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Now, rather than having the mixin code inline in the template, you’re calling
    it in from an include file. Notice that you can omit the .pug file extension when
    calling the include. From now on, when you create a new template that needs to
    have rating stars, you can easily reference this include file and call the `outputRatings`
    mixin.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不再需要在模板中内联 mixin 代码，而是从包含文件中调用它。注意，在调用包含文件时可以省略 .pug 文件扩展名。从现在开始，当你创建一个需要包含评分星的新模板时，你可以轻松地引用这个包含文件并调用
    `outputRatings` mixin。
- en: Now you’re done with the homepage!
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 现在主页已经完成了！
- en: 4.5.5\. Viewing the finished homepage
  id: totrans-840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.5\. 查看完成的主页
- en: You made quite a lot of changes to the homepage template throughout this chapter.
    Now, take a look at what you’ve ended up with. First, look at the updated controller.
    The following listing shows the final `homelist` controller, incorporating the
    hardcoded data for the title, page header, sidebar, and locations list.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你对主页模板进行了相当多的修改。现在，看看你最终得到了什么。首先，看看更新的控制器。以下列表显示了最终的 `homelist` 控制器，它包含了标题、页面标题、侧边栏和位置列表的硬编码数据。
- en: Listing 4.10\. The `homelist` controller, passing hardcoded data to the view
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 将硬编码数据传递给视图的 `homelist` 控制器
- en: '[PRE96]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1*** **Updates text for the HTML <title>**'
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **更新 HTML <title> 的文本**'
- en: '***2*** **Adds text for the page header as two items inside an object**'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在对象内部添加页面标题的文本作为两个条目**'
- en: '***3*** **Adds text for the sidebar**'
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加侧边栏的文本**'
- en: '***4*** **Creates an array of one object for each location in the list**'
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **为列表中的每个位置创建一个对象的数组**'
- en: Seeing all this code together, you can start to appreciate where you’re going
    with this approach. You’ve got a clear picture of all the data required for the
    homepage of Loc8r, which will come in handy in [chapter 5](kindle_split_016.xhtml#ch05).
    This controller contains the text for the sidebar. We didn’t talk about this step,
    but taking this text from the view to the controller is as simple as creating
    a new variable for it in the controller and referencing it in the view.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 看到所有这些代码放在一起，你可以开始欣赏这种方法的走向。你对 Loc8r 主页所需的所有数据有一个清晰的了解，这在第 5 章（[kindle_split_016.xhtml#ch05](https://kindle_split_016.xhtml#ch05)）中会很有用。这个控制器包含了侧边栏的文本。我们没有讨论这一步，但从视图中将文本移到控制器中就像在控制器中为它创建一个新变量并在视图中引用它一样简单。
- en: Something important that you achieved through this process is removing data
    from the view. Building the view with data was great as a first step, as it allowed
    you to focus on the end-user experience without getting distracted by technicalities.
    Now that you’ve moved the data from the view into the controller, you have a much
    smarter, dynamic view. The view knows what pieces of data it needs, but it doesn’t
    care what’s in those pieces of data. The following listing shows the final view
    for the homepage.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个过程，你实现了一个重要的事情，那就是从视图中移除了数据。用数据构建视图是一个很好的第一步，因为它允许你专注于最终用户体验，而不会被技术细节所分散。现在，你已经将数据从视图移到控制器中，你有一个更智能、更动态的视图。视图知道它需要哪些数据片段，但它不关心这些片段中的内容。以下列表显示了首页的最终视图。
- en: 'Listing 4.11\. Final view for the homepage: app_server/views/locations-list.pug'
  id: totrans-850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.11\. 首页的最终视图：app_server/views/locations-list.pug
- en: '[PRE97]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '***1*** **Brings in the external include file containing outputRating mixin**'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入包含outputRating混入的外部包含文件**'
- en: '***2*** **Outputs the page header text using different methods**'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用不同的方法输出页面标题文本**'
- en: '***3*** **Loops through the array of locations**'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **遍历位置数组**'
- en: '***4*** **Calls the outputRating mixin for each location, passing the value
    of the current location’s rating**'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **为每个位置调用outputRating混入，传递当前位置评分的值**'
- en: '***5*** **References the sidebar content from the controller**'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **从控制器引用侧边栏内容**'
- en: That’s a small template, especially considering everything it’s doing. This
    is a testament to the power of Pug and Bootstrap working together, combined with
    removing all the content.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小模板，尤其是考虑到它所做的一切。这是Pug和Bootstrap共同作用的力量的证明，结合了移除所有内容。
- en: You’re one step closer to the MVC—and general development—goal of separation
    of concerns, with the homepage at least.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经接近了MVC——以及一般开发——的目标，即关注点的分离，至少对于首页来说是这样。
- en: 4.5.6\. Updating the rest of the views and controllers
  id: totrans-859
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.6\. 更新其余的视图和控制器
- en: We walked you through the process for the homepage in some detail, but we won’t
    spend so much time on the other pages. Before you can move to the next stage of
    development—building the data model—you need to go through the process on all
    the pages. The goal is to have no data in any of the views; instead, the views
    will be smarter, and the data will be hardcoded into the relevant controllers.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细地介绍了首页的过程，但不会在其他页面上花费太多时间。在你可以进入开发下一阶段——构建数据模型——之前，你需要对所有页面进行处理。目标是所有视图中都没有数据；相反，视图将更智能，数据将硬编码到相关的控制器中。
- en: 'The process for each page is this:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面的处理过程如下：
- en: Look at the data in the view.
  id: totrans-862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看视图中的数据。
- en: Create a structure for that data in the controller.
  id: totrans-863
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中为该数据创建一个结构。
- en: Replace the data in the view with references to the controller data.
  id: totrans-864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图中的数据替换为对控制器数据的引用。
- en: Look for opportunities to reuse code.
  id: totrans-865
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找代码重用的机会。
- en: '[Appendix C](kindle_split_038.xhtml#app03) goes through the process for each
    of the three remaining pages, showing what the controller and view code should
    look like for each one. When you’ve finished, none of your views should contain
    any hardcoded data; the controller for each page should be passing the required
    data. [Figure 4.18](#ch04fig18) shows a collection of screenshots of the final
    pages you should have at the end of this stage.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录C](kindle_split_038.xhtml#app03) 讲解了剩余三个页面的处理过程，展示了每个控制器和视图代码应该是什么样子。当你完成时，你的视图不应包含任何硬编码的数据；每个页面的控制器应传递所需的数据。[图4.18](#ch04fig18)
    展示了本阶段结束时你应该拥有的最终页面的截图集合。'
- en: Figure 4.18\. Screenshots of all four pages in the static prototype, using smart
    views and data hardcoded into the controllers
  id: totrans-867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.18\. 使用智能视图和控制器中硬编码的数据的静态原型中所有四个页面的截图
- en: '![](Images/04fig18_alt.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig18_alt.jpg)'
- en: You’ve reached the end of the first phase of your rapid prototype development
    and are primed to start the next phase.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了快速原型开发的第一个阶段，并准备好开始下一阶段。
- en: '|  |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Get the source code**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取源代码**'
- en: 'The source code of the application so far is available on the chapter-04 branch
    of GitHub’s gettingMean-2 repository. In a fresh folder in terminal, enter the
    following commands to clone it and install the dependencies:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序到目前为止的源代码可在GitHub的gettingMean-2仓库的chapter-04分支上找到。在终端的新文件夹中，输入以下命令以克隆它并安装依赖项：
- en: '[PRE98]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '|  |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In [chapter 5](kindle_split_016.xhtml#ch05), you’ll continue the journey of
    moving the data back up through the MVC architecture by using MongoDB and Mongoose
    to create a data model. That’s right; it’s database time!
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_016.xhtml#ch05)中，您将继续通过使用 MongoDB 和 Mongoose 创建数据模型来将数据回移到
    MVC 架构中的旅程。没错；现在是数据库时间！
- en: Summary
  id: totrans-876
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了
- en: Simple ways of defining and organizing routes in Express
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Express 中定义和组织路由的简单方法
- en: How to use Node modules to hold the controllers
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Node 模块来存储控制器
- en: The best ways to set up multiple sets of controllers by proper definition of
    the routes
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过正确定义路由来设置多个控制器集的最佳方法
- en: Prototyping views with Pug and Bootstrap
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pug 和 Bootstrap 原型化视图
- en: Making reusable Pug components and mixins
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用 Pug 组件和混入
- en: Displaying dynamic data in Pug templates
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pug 模板中显示动态数据
- en: Passing data from controllers to views
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据从控制器传递到视图
- en: Chapter 5\. Building a data model with MongoDB and Mongoose
  id: totrans-885
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 使用 MongoDB 和 Mongoose 构建数据模型
- en: '*This chapter covers*'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Connecting Express/Node applications to MongoDB using Mongoose
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mongoose 将 Express/Node 应用程序连接到 MongoDB
- en: Defining schemas for a data model using Mongoose
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mongoose 定义数据模型的模式
- en: Connecting an application to a database
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序连接到数据库
- en: Managing databases using the MongoDB shell
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoDB shell 管理数据库
- en: Pushing a database into a live environment
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库推送到实时环境
- en: In [chapter 4](kindle_split_015.xhtml#ch04), you moved your data out of the
    views and back the MVC path into the controllers. Ultimately, the controllers
    will pass data to the views, but they shouldn’t store it. [Figure 5.1](#ch05fig01)
    recaps the data flow in an MVC pattern.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_015.xhtml#ch04)中，您将数据从视图移出，并将 MVC 路径回退到控制器。最终，控制器将数据传递给视图，但它们不应该存储它。[图5.1](#ch05fig01)回顾了
    MVC 模式中的数据流。
- en: Figure 5.1\. In an MVC pattern, data is held in the model, processed by a controller,
    and then rendered by a view.
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 在 MVC 模式中，数据存储在模型中，由控制器处理，然后由视图渲染。
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-894
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: 'For storing the data, you’ll need a database—specifically, MongoDB. This step
    is the next one in the process: creating a database and a data model.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储数据，您需要一个数据库——具体来说，是 MongoDB。这一步是过程中的下一步：创建数据库和数据模型。
- en: '|  |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you haven’t yet built the application from [chapter 4](kindle_split_015.xhtml#ch04),
    you can get the code on the chapter-04 branch at [https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2).
    In a fresh folder in terminal, enter the following command to clone it:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有从[第4章](kindle_split_015.xhtml#ch04)构建应用程序，您可以在[https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2)的
    chapter-04 分支上获取代码。在终端的新文件夹中，输入以下命令以克隆它：
- en: '[PRE99]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '|  |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You’ll start by connecting your application to a database before using Mongoose
    to define schemas and models. When you’re happy with the structure, you can add
    some test data directly to the MongoDB database. The final step is making sure
    that access to the data store also works when pushed up to Heroku. [Figure 5.2](#ch05fig02)
    shows the flow of these four steps.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先连接应用程序到数据库，然后使用 Mongoose 定义模式和模型。当您对结构满意时，可以直接向 MongoDB 数据库添加一些测试数据。最后一步是确保当推送到
    Heroku 时，对数据存储的访问也能正常工作。[图5.2](#ch05fig02)显示了这四个步骤的流程。
- en: Figure 5.2\. Four main steps in this chapter, from connecting your application
    to a database to pushing the whole thing into a live environment
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 本章的四个主要步骤，从将应用程序连接到数据库到将整个内容推送到实时环境
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-903
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: For those of you who are worried that you’ve missed a section or two, don’t
    worry; you haven’t created a database yet. And you don’t need to. In various other
    technology stacks, this situation can present an issue and throw errors. But with
    MongoDB, you don’t need to create a database before connecting to it. MongoDB
    creates a database when you first try to use it. [Figure 5.3](#ch05fig03) shows
    where this chapter focuses in terms of overall architecture.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些担心遗漏了一两个部分的人，不用担心；您还没有创建数据库。而且您不需要。在各种其他技术堆栈中，这种情况可能会引发问题并抛出错误。但与 MongoDB
    一起，您在尝试使用它之前不需要创建数据库。[图5.3](#ch05fig03)显示了本章在整体架构方面的重点。
- en: Figure 5.3\. Viewing the MongoDB database and using Mongoose inside Express
    to model the data and manage the connection to the database
  id: totrans-905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 查看 MongoDB 数据库，并在 Express 中使用 Mongoose 模型数据和管理数据库连接
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-906
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: You’ll be working with a MongoDB database, but most of the work will be in Express
    and Node. In [chapter 2](kindle_split_012.xhtml#ch02), we discussed the benefits
    of decoupling the data integration by creating an API rather than tightly integrating
    data into the main Express app. Although you’ll be working in Express and Node
    and still within the same encapsulating application, you’ll be starting the foundations
    of your API layer.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 MongoDB 数据库，但大部分工作将在 Express 和 Node 中完成。在[第 2 章](kindle_split_012.xhtml#ch02)中，我们讨论了通过创建
    API 而不是将数据紧密集成到主 Express 应用程序中来解耦数据集成的好处。尽管你将在 Express 和 Node 中工作，并且仍然在同一个封装的应用程序中，但你将开始构建你的
    API 层的基础。
- en: '|  |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-909
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'To follow through this chapter, you need to have MongoDB installed. If you
    haven’t done so already, you can find the instructions in [appendix A](kindle_split_026.xhtml#app01).
    The source code of the application as it will be at the end of this chapter is
    available on the chapter-05 branch on GitHub. In a fresh folder in terminal, enter
    the following commands to clone it and install the npm module dependencies:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章的学习，你需要安装 MongoDB。如果你还没有安装，可以在[附录 A](kindle_split_026.xhtml#app01)中找到安装说明。本章末尾应用程序的源代码可在
    GitHub 的 chapter-05 分支上找到。在终端的新文件夹中，输入以下命令以克隆它并安装 npm 模块依赖项：
- en: '[PRE100]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '|  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.1\. Connecting the Express application to MongoDB by using Mongoose
  id: totrans-913
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 通过 Mongoose 将 Express 应用程序连接到 MongoDB
- en: You could connect your application directly to MongoDB and have the two interact
    by using the native driver. Although the native MongoDB driver is powerful, it
    isn’t particularly easy to work with. It also doesn’t offer a built-in way of
    defining and maintaining data structures. Mongoose exposes most of the functionality
    of the native driver, but in a more convenient way, designed to fit into the flow
    of application development.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接将应用程序连接到 MongoDB，并使用原生驱动程序使两者交互。尽管原生 MongoDB 驱动程序功能强大，但使用起来并不特别容易。它也没有提供一种内置的方式来定义和维护数据结构。Mongoose
    提供了原生驱动程序的大部分功能，但以更方便的方式提供，旨在适应应用程序开发的流程。
- en: Where Mongoose really excels is in the way it enables you to define data structures
    and models, maintain them, and use them to interact with your database, all from
    the comfort of your application code. As part of this approach, Mongoose includes
    the ability to add validation to your data definitions, meaning that you don’t
    have to write validation code in every place in your application where you send
    data back to the database.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 真正出色之处在于它使你能够定义数据结构和管理模型，并使用它们从应用程序代码中与数据库交互。作为这种方法的一部分，Mongoose 包括向你的数据定义添加验证的能力，这意味着你不需要在应用程序中每个发送数据回数据库的地方都编写验证代码。
- en: Mongoose fits into the stack inside the Express application by being the liaison
    between the application and the database, as shown in [figure 5.4](#ch05fig04).
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 通过作为应用程序和数据库之间的联络人而融入 Express 应用程序中，如图 5.4 所示。
- en: Figure 5.4\. The data interactions in the MEAN stack and where Mongoose fits
    in. The Node/ Express application interacts with MongoDB through Mongoose; Node
    and Express can also talk to Angular.
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. MEAN 栈中的数据交互以及 Mongoose 的位置。Node/Express 应用程序通过 Mongoose 与 MongoDB 交互；Node
    和 Express 也可以与 Angular 通信。
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-918
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: MongoDB talks only to Mongoose, and Mongoose in turn talks to Node and Express.
    Angular won’t talk directly to MongoDB or Mongoose—only to the Express application.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 只与 Mongoose 通信，而 Mongoose 又与 Node 和 Express 通信。Angular 不会直接与 MongoDB
    或 Mongoose 通信——只与 Express 应用程序通信。
- en: You should already have MongoDB installed on your system (covered in [appendix
    A](kindle_split_026.xhtml#app01)), but not Mongoose. Mongoose isn’t installed
    globally but is instead added directly to your application. You’ll do that in
    the next section.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在系统上安装了 MongoDB（在[附录 A](kindle_split_026.xhtml#app01)中有介绍），但没有安装 Mongoose。Mongoose
    不是全局安装，而是直接添加到你的应用程序中。你将在下一节中这样做。
- en: 5.1.1\. Adding Mongoose to your application
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 将 Mongoose 添加到你的应用程序中
- en: Mongoose is available as an npm module. As you saw in [chapter 3](kindle_split_014.xhtml#ch03),
    the quickest and easiest way to install an npm module is through the command line.
    You can install Mongoose and add it to your list of dependencies in package.json
    with one command.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 可作为 npm 模块使用。正如你在[第 3 章](kindle_split_014.xhtml#ch03)中看到的，安装 npm 模块最快、最简单的方法是通过命令行。你可以使用一条命令安装
    Mongoose 并将其添加到 package.json 中的依赖列表中。
- en: 'Head over to terminal, and make sure that the prompt is at the root folder
    of the application, where the package.json file is. Then run the following command:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 转到终端，并确保提示符位于应用程序的根目录，即 package.json 文件所在的目录。然后运行以下命令：
- en: '[PRE101]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here, we’re using an alternative version; this version saves typing. When that
    command has finished running, you’ll see a new mongoose folder inside the node_modules
    folder of the application, and the dependencies section of the package.json file
    should look like the following code snippet:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个替代版本；这个版本可以节省输入。当该命令运行完成后，你将在应用程序的 node_modules 文件夹内看到一个名为 mongoose
    的新文件夹，package.json 文件中的依赖项部分应该看起来像以下代码片段：
- en: '[PRE102]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You may have slightly different version numbers, of course, but currently, the
    latest stable version of Mongoose is 5.3.11. Now that Mongoose is installed, you’re
    ready to get it connected.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会有略微不同的版本号，但截至目前，Mongoose 的最新稳定版本是 5.3.11。现在 Mongoose 已经安装，你就可以准备将其连接到应用程序了。
- en: 5.1.2\. Adding a Mongoose connection to your application
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 将 Mongoose 连接添加到你的应用程序
- en: 'At this stage, you’ll connect your application to a database. You haven’t created
    a database yet, but that doesn’t matter, because MongoDB creates a database when
    you first try to use it. This can seem a little odd, but for putting an application
    together, it’s a great advantage: you don’t need to leave your application code
    to mess around in a different environment.'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你将连接应用程序到数据库。你还没有创建数据库，但这没关系，因为当你首次尝试使用 MongoDB 时，它会自动创建一个数据库。这可能会有些奇怪，但对于构建应用程序来说，这是一个巨大的优势：你不需要在应用程序代码中留下混乱，去操作不同的环境。
- en: MongoDB and Mongoose connection
  id: totrans-930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: MongoDB 和 Mongoose 连接
- en: Mongoose opens a pool of five reusable connections when it connects to a MongoDB
    database. This pool of connections is shared among all requests. Five is the default
    number; you can increase or decrease the connection options if you need to.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Mongoose 连接到 MongoDB 数据库时，它会打开一个包含五个可重用连接的池。这个连接池被所有请求共享。五个是默认数量；如果你需要，可以增加或减少连接选项。
- en: '|  |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Best Practice Tip
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最佳实践提示
- en: Opening and closing connections to databases can take a little bit of time,
    especially if your database is on a separate server or service. It’s best to run
    these operations only when you need to. The best practice is to open the connection
    when your application starts and to leave it open until your application restarts
    or shuts down. This approach is the one you’re going to take.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 打开和关闭数据库连接可能需要一点时间，尤其是如果你的数据库位于单独的服务器或服务上。最好只在需要时运行这些操作。最佳实践是在应用程序启动时打开连接，并在应用程序重启或关闭时保持连接打开。这就是你将要采取的方法。
- en: '|  |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Setting up the connection file
  id: totrans-936
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置连接文件
- en: 'When you first sorted out the file structure for the application, you created
    three folders inside the app_server folder: models, views, and controllers. For
    working with data and models, you’ll be predominantly located in the app_server/models
    folder. Setting up the connection file is a two-part process—creating the file
    and requiring it into the application so that it can be used:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次整理应用程序的文件结构时，你在 app_server 文件夹内创建了三个文件夹：models、views 和 controllers。对于处理数据和模型，你将主要位于
    app_server/models 文件夹。设置连接文件是一个两步过程——创建文件并将其引入应用程序以便使用：
- en: 'Step 1: Create a file called db.js in app_server/models, and save it. For now,
    you’ll `require` Mongoose in this file with the following single command line:'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 1 步：在 app_server/models 中创建一个名为 db.js 的文件，并保存它。目前，你将使用以下单个命令行在文件中 `require`
    Mongoose：
- en: '[PRE103]'
  id: totrans-939
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Step 2: Bring this file into the application by requiring it in app.js. As
    the actual process of creating a connection between the application and the database
    can take a little while, you want to do this early in the setup. Amend the top
    part of app.js to look like the following code snippet (modifications in bold):'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 2 步：通过在 app.js 中引入此文件将此文件引入应用程序。由于创建应用程序和数据库之间的连接可能需要一点时间，因此你希望在设置初期就完成这项操作。修改
    app.js 的顶部部分，使其看起来像以下代码片段（粗体表示修改）：
- en: '[PRE104]'
  id: totrans-941
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: You’re not going to export any functions from db.js, so you don’t need to assign
    it to a variable when you `require` it. You need it to be there in the application,
    but you won’t need to hook into any of its methods from within app.js.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要从 db.js 导出任何函数，因此你不需要在 `require` 它时将其分配给变量。你需要它在应用程序中存在，但你不需要在 app.js 中调用其任何方法。
- en: If you restart the application, it should run as before, but now you have Mongoose
    in the application. If you get an error, check that the path in the `require`
    statement matches the path to the new file, that your package.json includes the
    Mongoose dependency, and that you’ve run `npm install` from terminal in the root
    folder of the application.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新启动应用程序，它应该像以前一样运行，但现在您在应用程序中有了Mongoose。如果您遇到错误，请检查`require`语句中的路径是否与新文件的路径匹配，您的package.json是否包含Mongoose依赖项，并且您是否已从应用程序根目录的终端中运行了`npm
    install`。
- en: Creating the Mongoose connection
  id: totrans-944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建Mongoose连接
- en: 'Creating a Mongoose connection can be as simple as declaring the URI for your
    database and passing it to Mongoose’s `connect` method. A database URI is a string
    following this construct:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Mongoose连接可以像声明数据库的URI并将其传递给Mongoose的`connect`方法一样简单。数据库URI是一个遵循以下结构的字符串：
- en: '![](Images/p0124-01_alt.jpg)'
  id: totrans-946
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0124-01_alt.jpg)'
- en: 'The username, password, and port are optional. On your local machine, your
    database URI will be simple. For now, assuming that you have MongoDB installed
    on your local machine, adding the following code snippet to db.js is all you need
    to create a connection:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名、密码和端口是可选的。在您的本地机器上，您的数据库URI将很简单。目前，假设您已经在本地机器上安装了MongoDB，将以下代码片段添加到db.js中就足够创建一个连接：
- en: '[PRE105]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The second argument to `connect()` tells Mongoose to use its new internal URL
    parser, which avoids deprecation warnings due to MongoDB deprecating but leaves
    available the older connection string parser. If you run the application with
    this addition to db.js, it should start and function as before. So how do you
    know that your connection is working correctly? The answer lies in connection
    events.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()`的第二个参数告诉Mongoose使用其新的内部URL解析器，这避免了由于MongoDB弃用而产生的弃用警告，但仍然保留了旧的连接字符串解析器。如果您在db.js中添加此修改后运行应用程序，它应该像以前一样启动并运行。那么您如何知道您的连接是否正常工作呢？答案在于连接事件。'
- en: Monitoring the connection with Mongoose connection events
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Mongoose连接事件监控连接
- en: 'Mongoose publishes events based on the status of the connection, and these
    events are easy to hook into so that you can see what’s going on. You’ll use events
    to see when the connection is made, when there’s an error, and when the connection
    is disconnected. When any one of these events occurs, you’ll log a message to
    the console. The following code snippet shows the required code:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose根据连接的状态发布事件，并且这些事件很容易挂钩，以便您可以查看正在发生的事情。您将使用事件来查看何时建立连接、何时出现错误以及何时断开连接。当这些事件中的任何一个发生时，您将在控制台记录一条消息。以下代码片段显示了所需的代码：
- en: '[PRE106]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1* Monitors for a successful connection through Mongoose**'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 监听通过Mongoose的成功连接**'
- en: '***2* Checks for a connection error**'
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查连接错误**'
- en: '***3* Checks for a disconnection event**'
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查断开连接事件**'
- en: 'With this code added to db.js, when you restart the application, you should
    see the following confirmations logged to the terminal window:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在db.js中添加此代码后，当您重新启动应用程序时，您应该在终端窗口中看到以下确认信息：
- en: '[PRE107]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If you restart the application again, however, you’ll notice that you don’t
    get any disconnection messages, because the Mongoose connection doesn’t automatically
    close when the application stops or restarts. You need to listen for changes in
    the Node process to deal with this situation.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您再次重新启动应用程序，您会注意到您没有收到任何断开连接的消息，因为当应用程序停止或重新启动时，Mongoose连接不会自动关闭。您需要监听Node进程的变化来处理这种情况。
- en: Closing a Mongoose connection
  id: totrans-959
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关闭Mongoose连接
- en: 'Closingthe Mongoose connection when the application stops is as much a part
    of best practices as opening the connection when it starts. The connection has
    two ends: one in your application and one in MongoDB. MongoDB needs to know when
    you want to close the connection so that it doesn’t keep redundant connections
    open.'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序停止时关闭mongoose连接与在启动时打开连接一样，是最佳实践的一部分。连接有两个端点：一个在您的应用程序中，一个在MongoDB中。MongoDB需要知道您何时想要关闭连接，以便它不会保持冗余的连接打开。
- en: To monitor when the application stops, you need to listen to the Node.js process
    for an event called SIGINT.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 要监听应用程序停止时的情况，您需要监听Node.js进程的名为SIGINT的事件。
- en: '|  |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Listening for SIGINT on Windows**'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Windows上监听SIGINT**'
- en: 'SIGINT is an operating system–level signal that fires on UNIX-based systems
    such as Linux and macOS. It also fires on some later versions of Windows. If you’re
    running on Windows and the disconnection events don’t fire, you can emulate them.
    If you need to emulate this behavior on Windows, first add a new npm package,
    `readline`, to your application. As before, use the `npm install` command in the
    command line like this:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: SIGINT 是操作系统级别的信号，在基于 UNIX 的系统（如 Linux 和 macOS）上触发。它也在一些 Windows 的较新版本上触发。如果你在
    Windows 上运行，并且断开连接事件没有触发，你可以模拟它们。如果你需要在 Windows 上模拟此行为，首先向你的应用程序添加一个新的 npm 包，`readline`。像之前一样，使用命令行中的
    `npm install` 命令，如下所示：
- en: '[PRE108]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'When that’s done, in the db.js file, above the event listener code, add the
    following:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在 db.js 文件中，在事件监听器代码上方添加以下内容：
- en: '[PRE109]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This code emits the SIGINT signal on Windows machines, allowing you to capture
    it and gracefully close down anything else you need to before the process ends.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在 Windows 机器上发出 SIGINT 信号，允许你捕获它，并在进程结束前优雅地关闭其他任何需要关闭的内容。
- en: '|  |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you’re using nodemon to automatically restart the application, you’ll also
    have to listen to a second event on the Node process: SIGUSR2\. Heroku uses a
    different event, SIGTERM, so you need to listen for that event as well.'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 nodemon 自动重新启动应用程序，你还需要监听 Node 进程上的第二个事件：SIGUSR2。Heroku 使用不同的事件，SIGTERM，因此你需要监听该事件。
- en: Capturing the process termination events
  id: totrans-971
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 捕获进程终止事件
- en: Capturing these events prevents the default behavior from happening. You need
    to make sure that you manually restart the behavior required (after closing the
    Mongoose connection, of course).
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获这些事件可以防止默认行为发生。你需要确保手动重新启动所需的操作（当然是在关闭 Mongoose 连接之后）。
- en: 'To do this, you need three event listeners and one function to close the database
    connection. Closing the database is an asynchronous activity, so you need to pass
    through whatever function is required to restart or end the Node process as a
    callback. While you’re at it, you can output a message to the console confirming
    that the connection is closed and the reason why. You can wrap all this in a function
    called `gracefulShutdown` in db.js:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要三个事件监听器和一個用于关闭数据库连接的函数。关闭数据库是一个异步操作，因此你需要传递一个回调函数来重启或结束 Node 进程。同时，你可以在控制台输出一条消息，确认连接已关闭以及关闭的原因。你可以在
    db.js 中将这些内容包装在一个名为 `gracefulShutdown` 的函数中：
- en: '[PRE110]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '***1* Defines a function to accept a message and a callback function**'
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个函数以接受消息和回调函数**'
- en: '***2* Closes the Mongoose connection, passing through an anonymous function
    to run when it’s closed**'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 关闭 Mongoose 连接，通过匿名函数在关闭时运行**'
- en: '***3* Outputs a message and calls a callback when the Mongoose connection is
    closed**'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 输出消息并在 Mongoose 连接关闭时调用回调函数**'
- en: 'You need to call this function when the application terminates or when nodemon
    restarts it. The following code snippet shows the two event listeners you need
    to add to db.js for this to happen:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序终止或 nodemon 重新启动它时，你需要调用此函数。以下代码片段显示了你需要添加到 db.js 中的两个事件监听器，以便实现此功能：
- en: '[PRE111]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '***1* Listens for SIGUSR2, which is what nodemon uses**'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 监听 SIGUSR2，这是 nodemon 使用的**'
- en: '***2* Sends a message to graceful-Shutdown and a callback to kill the process,
    emitting SIGUSR2 again**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 向 graceful-Shutdown 发送消息，向终止进程发送回调函数，再次发出 SIGUSR2**'
- en: '***3* Listens for SIGINT to be emitted upon application termination**'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 监听应用程序终止时发出的 SIGINT 信号**'
- en: '***4* Sends a message to gracefulShutdown and a callback to exit the Node process**'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 向 gracefulShutdown 发送消息，向退出 Node 进程发送回调函数**'
- en: '***5* Listens for SIGTERM to be emitted when Heroku shuts down the process**'
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 监听 Heroku 关闭进程时发出的 SIGTERM 信号**'
- en: '***6* Sends a message to gracefulShutdown and a callback to exit the Node process**'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 向 gracefulShutdown 发送消息，向退出 Node 进程发送回调函数**'
- en: Now when the application terminates, it gracefully closes the Mongoose connection
    before it ends. Similarly, when nodemon restarts the application due to changes
    in the source files, the application closes the current Mongoose connection first.
    The nodemon listener is using `process.once` as opposed to `process.on`, as you
    want to listen for the SIGUSR2 event only once. nodemon also listens for the same
    event, and you don’t want to capture it each time, preventing nodemon from working.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当应用程序终止时，它会在结束前优雅地关闭 Mongoose 连接。同样，当 nodemon 由于源文件更改而重新启动应用程序时，应用程序首先关闭当前的
    Mongoose 连接。nodemon 监听器使用 `process.once` 而不是 `process.on`，因为你只想监听 SIGUSR2 事件一次。nodemon
    也监听相同的事件，你不希望每次都捕获它，以防止 nodemon 无法工作。
- en: '|  |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-988
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: It’s important to manage opening and closing your database connections properly
    in every application you create. If you use an environment with different process
    termination signals, you should ensure that you listen to them all.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建的每个应用程序中正确管理打开和关闭数据库连接非常重要。如果你使用具有不同进程终止信号的环境，你应该确保你监听所有这些信号。
- en: '|  |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Complete connection file
  id: totrans-991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完整的连接文件
- en: That’s quite a lot of stuff you’ve added to the db.js file, so take a moment
    to recap. So far, you’ve
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经向db.js文件添加了很多内容，所以花点时间回顾一下。到目前为止，你已经
- en: Defined a database connection string
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了数据库连接字符串
- en: Opened a Mongoose connection at application startup
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序启动时打开了Mongoose连接
- en: Monitored the Mongoose connection events
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控了Mongoose连接事件
- en: Monitored some Node process events so that you can close the Mongoose connection
    when the application ends
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控了一些Node进程事件，以便在应用程序结束时关闭Mongoose连接
- en: Altogether, the db.js file should look like the following listing. Note that
    it includes the extra code required by Windows to emit the SIGINT event.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，db.js文件应如下所示。注意，它包括Windows生成SIGINT事件所需的额外代码。
- en: Listing 5.1\. Complete database connection file db.js in app_server/models
  id: totrans-998
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. 完整数据库连接文件db.js在app_server/models
- en: '[PRE112]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '***1* Defines a database connection string and uses it to open a Mongoose connection**'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义数据库连接字符串并使用它打开Mongoose连接**'
- en: '***2* Listens for Mongoose connection events and outputs statuses to the console**'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 监听Mongoose连接事件并将状态输出到控制台**'
- en: '***3* Reusable function to close the Mongoose connection**'
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 可重用函数用于关闭Mongoose连接**'
- en: '***4* Listens to Node processes for termination or restart signals and calls
    the gracefulShutdown function when appropriate, passing a continuation callback**'
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 监听Node进程的终止或重启信号，并在适当的时候调用gracefulShutdown函数，传递一个延续回调**'
- en: When you have a file like this one, you can easily copy it from application
    to application, because the events you’re listening for are always the same. All
    you have to do each time is change the database connection string. Remember that
    you also `require`d this file into app.js, right near the top, so that the connection
    opens up early in the application’s life.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个这样的文件时，你可以轻松地从应用程序复制到另一个应用程序，因为你正在监听的事件总是相同的。每次你只需要更改数据库连接字符串。记住，你也在app.js中`require`了这个文件，就在顶部附近，这样连接就可以在应用程序的生命周期早期打开。
- en: '|  |'
  id: totrans-1005
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using multiple databases**'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用多个数据库**'
- en: 'What you’ve seen so far is known as the default connection and is well suited
    to keeping a single connection open throughout the uptime of an application. But
    if you want to connect to a second database, perhaps for logging or managing user
    sessions, you can use a named connection. In place of the `mongoose.connect` method,
    you’d use a method called `mongoose.createConnection` and assign it to a variable.
    You can see this in the following code snippet:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止看到的是默认连接，非常适合在整个应用程序运行期间保持单个连接打开。但如果你想要连接到第二个数据库，比如用于日志记录或管理用户会话，你可以使用命名连接。在`mongoose.connect`方法的地方，你会使用一个名为`mongoose.createConnection`的方法，并将其分配给一个变量。你可以在下面的代码片段中看到这一点：
- en: '[PRE113]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This snippet creates a new Mongoose connection object called `logDB`. You can
    interact with it in the same way as you would with `mongoose.connection` for the
    default connection. Here are a couple of examples:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段创建了一个名为`logDB`的新Mongoose连接对象。你可以像与`mongoose.connection`默认连接一样与之交互。这里有一些例子：
- en: '[PRE114]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '***1* Monitoring a connection event for a named connection**'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 监听命名连接的连接事件**'
- en: '***2* Closing a named connection**'
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 关闭命名连接**'
- en: '|  |'
  id: totrans-1013
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.2\. Why model the data?
  id: totrans-1014
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 为什么对数据进行建模？
- en: In [chapter 1](kindle_split_011.xhtml#ch01), we talked about how MongoDB is
    a document store rather than a traditional table-based database using rows and
    columns. This fact gives MongoDB great freedom and flexibility, but sometimes
    you want—or *need*—structure to your data.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](kindle_split_011.xhtml#ch01)中，我们讨论了MongoDB是一个文档存储，而不是使用行和列的传统表式数据库。这一事实赋予了MongoDB极大的自由度和灵活性，但有时你希望——或者*需要*——对数据进行结构化。
- en: Take the Loc8r homepage, for example. The listing section shown in [figure 5.5](#ch05fig05)
    contains a specific dataset that’s common to all locations.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 以Loc8r首页为例。如图5.5所示，列表部分包含一个对所有位置都通用的特定数据集。
- en: Figure 5.5\. Listing section of the homepage has defined data requirements and
    structure
  id: totrans-1017
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5\. 首页列表部分已定义数据需求和结构
- en: '![](Images/05fig05_alt.jpg)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05_alt.jpg)'
- en: 'The page needs these data items for all locations, and the data record for
    each location must have a consistent naming structure. Without this structure,
    the application wouldn’t be able to find the data and use it. At this point in
    development, the data is held in the controller and passed into the view. In terms
    of MVC architecture, you started with the data in the *view* and then moved it
    back a step to the *controller*. Now what you need to do is move it back one final
    step to where it should belong: in the *model*. [Figure 5.6](#ch05fig06) illustrates
    your current position, highlighting the goal.'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 页面需要所有位置的数据项，并且每个位置的数据记录必须有一个一致的命名结构。没有这个结构，应用程序将无法找到并使用数据。在开发的这个阶段，数据被保存在控制器中，并传递到视图中。从MVC架构的角度来看，你从*视图*中的数据开始，然后将其退回一步到*控制器*。现在你需要做的是将其退回最后一步到它应该属于的地方：在*模型*中。[图5.6](#ch05fig06)说明了你当前的位置，突出了目标。
- en: Figure 5.6\. How data should flow in an MVC pattern, from the model through
    the controller and into the view. At this point in your prototype, your data is
    in the controller, so you want to move it a step back into the model.
  id: totrans-1020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. MVC模式中数据应该如何流动，从模型通过控制器到视图。在你当前的原型中，你的数据在控制器中，所以你想要将其退回一步到模型。
- en: '![](Images/05fig06_alt.jpg)'
  id: totrans-1021
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig06_alt.jpg)'
- en: One outcome of moving the data back through the MVC flow step by step as you’ve
    done so far is that it helps solidify the requirements of the data structure,
    ensuring that the data structure accurately reflects the needs of your application.
    If you try to define your model first, you end up second-guessing what the application
    will look like and how it will work.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据逐步通过MVC流程，正如你迄今为止所做的那样，一个结果是它有助于巩固数据结构的要求，确保数据结构准确地反映了你应用程序的需求。如果你首先尝试定义模型，你最终会猜测应用程序的外观和工作方式。
- en: When you talk about modeling data, you’re describing how you want the data to
    be structured. In your application, you could create and manage the definitions
    manually and do the heavy lifting yourself, or you could use Mongoose and let
    it do the hard work.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 当你谈论数据建模时，你是在描述你希望数据如何结构化。在你的应用程序中，你可以手动创建和管理定义，并自己进行大量工作，或者你可以使用Mongoose并让它做艰苦的工作。
- en: 5.2.1\. What is Mongoose and how does it work?
  id: totrans-1024
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 什么是Mongoose以及它是如何工作的？
- en: Mongoose was built specifically as a MongoDB Object Document Modeler (ODM) for
    Node applications. One key principle is that you can manage your data model from
    within your application. You don’t have to mess around directly with databases
    or external frameworks or relational mappers; you can define your data model in
    the comfort of your application.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose专门为Node应用程序构建，作为MongoDB对象文档模型器（ODM）。一个关键原则是你可以从你的应用程序内部管理你的数据模型。你不必直接与数据库或外部框架或关系型映射器打交道；你可以在应用程序的舒适环境中定义你的数据模型。
- en: 'First, we’ll get some naming conventions out of the way:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将解决一些命名约定：
- en: In MongoDB, each entry in a database is called a *document*.
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MongoDB中，数据库中的每个条目被称为*文档*。
- en: In MongoDB, a group of documents is called a *collection*. (Think *table* if
    you’re used to relational databases.)
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MongoDB中，一组文档被称为*集合*。（如果你习惯于关系型数据库，可以将其视为*表*。）
- en: In Mongoose, the definition of a document is called a *schema*.
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mongoose中，文档的定义被称为*模式*。
- en: Each individual data entity defined in a schema is called a *path*.
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模式中定义的每个单独的数据实体被称为*路径*。
- en: Using the example of a stack of business cards, [figure 5.7](#ch05fig07) illustrates
    these naming conventions and how each is related to the others.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 以名片堆叠为例，[图5.7](#ch05fig07)展示了这些命名约定以及它们是如何相互关联的。
- en: Figure 5.7\. Relationships among collections, documents, schemas, and paths
    in MongoDB and Mongoose, using a business card metaphor
  id: totrans-1032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7\. MongoDB和Mongoose中集合、文档、模式和路径之间的关系，使用名片隐喻
- en: '![](Images/05fig07_alt.jpg)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig07_alt.jpg)'
- en: One final definition is for models. A *model* is the compiled version of a schema.
    All data interactions using Mongoose go through the model. You’ll work with models
    more in [chapter 6](kindle_split_017.xhtml#ch06), but for now, you’re focusing
    on building them.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个定义是针对模型的。*模型*是模式的编译版本。所有使用Mongoose的数据交互都通过模型进行。你将在[第6章](kindle_split_017.xhtml#ch06)中更多地使用模型，但就目前而言，你正专注于构建它们。
- en: 5.2.2\. How does Mongoose model data?
  id: totrans-1035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. Mongoose如何建模数据？
- en: 'If you’re defining your data in the application, how are you going to do it?
    In JavaScript, of course—JavaScript objects, to be precise. You’ve already had
    a sneak peek in [figure 5.7](#ch05fig07), but now take a look at a simple MongoDB
    document to see what the Mongoose schema for it might look like. The following
    code snippet shows a MongoDB document, followed by the Mongoose schema:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用程序中定义数据，您将如何做？当然是在JavaScript中——更确切地说，是JavaScript对象。您已经在[图5.7](#ch05fig07)中瞥见了，但现在请看看一个简单的MongoDB文档，看看它的Mongoose模式可能是什么样子。以下代码片段显示了一个MongoDB文档，后面跟着相应的Mongoose模式：
- en: '[PRE115]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '***1* Example MongoDB document**'
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 示例MongoDB文档**'
- en: '***2* Corresponding Mongoose schema**'
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对应的Mongoose模式**'
- en: As you can see, the schema has a strong resemblance to the data itself. The
    schema defines the name for each data path and the data type it will contain.
    In this example, you’ve simply declared the paths `firstname` and `surname` as
    strings.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模式与数据本身有很强的相似性。模式定义了每个数据路径的名称及其将包含的数据类型。在这个例子中，您只是简单地将路径`firstname`和`surname`声明为字符串。
- en: '|  |'
  id: totrans-1041
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**About the _id path**'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于_id路径**'
- en: You may have noticed that you haven’t declared the `id` path in the schema.
    _`id` is the unique identifier—the primary key, if you like—for each document.
    MongoDB automatically creates this path when each document is created and assigns
    it a unique `ObjectId` value. The value is designed to always be unique by combining
    the time since the UNIX epoch with machine and process identifiers and a counter.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，您在模式中没有声明`id`路径。`_id`是唯一标识符——如果您愿意，可以称为主键——对于每个文档。MongoDB在创建每个文档时自动创建此路径，并分配一个唯一的`ObjectId`值。该值的设计是通过结合自UNIX纪元以来的时间、机器和进程标识符以及一个计数器来确保始终唯一。
- en: It’s possible to use your own unique key system if you prefer (if you have a
    preexisting database, for example). In this book and the Loc8r application, you’ll
    stick with the default `ObjectId`.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用自己的唯一键系统（例如，如果您有一个现有的数据库），这是可能的。在这本书和Loc8r应用程序中，您将坚持使用默认的`ObjectId`。
- en: '|  |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2.3\. Breaking down a schema path
  id: totrans-1046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 拆分模式路径
- en: 'The basic construct for an individual path definition is the pathname followed
    by a properties object. In the previous example, you looked at a Mongoose schema,
    which demonstrates a kind of shorthand for defining a data path and its data type.
    A schema path is constructed of the pathname and the properties object, like so:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 单个路径定义的基本结构是路径名称后跟一个属性对象。在前面的例子中，您查看了一个Mongoose模式，它展示了定义数据路径及其数据类型的一种简写方式。模式路径由路径名称和属性对象组成，如下所示：
- en: '![](Images/p0132-01.jpg)'
  id: totrans-1048
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0132-01.jpg)'
- en: '|  |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Allowed schema types**'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许的模式类型**'
- en: 'The schema type is the property that defines the data type for a given path.
    It’s required for all paths. If the only property of a path is the type, you can
    use the shorthand definition. There are eight schema types that you can use:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 模式类型是定义给定路径数据类型的属性。对于所有路径都是必需的。如果路径的唯一属性是类型，您可以使用简写定义。您可以使用以下八种模式类型：
- en: '`String—`Any string, UTF-8 encoded.'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String—`任何字符串，UTF-8编码。'
- en: '`Number—`Mongoose doesn’t support long or double numbers, but it can be extended
    using Mongoose plugins; the default support is enough in most cases.'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number—`Mongoose不支持长或双精度数字，但可以使用Mongoose插件进行扩展；在大多数情况下，默认支持已经足够。'
- en: '`Date—`Typically returned from MongoDB as an `ISODate` object.'
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date—`通常由MongoDB作为`ISODate`对象返回。'
- en: '`Boolean—`True or false.'
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean—`真或假。'
- en: '`Buffer—`For binary information such as images.'
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buffer—`用于二进制信息，如图像。'
- en: '`Mixed—`Any data type.'
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mixed—`任何数据类型。'
- en: '`Array—`Can be an array of the same data type or an array of nested subdocuments.'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array—`可以是相同数据类型的数组或嵌套子文档的数组。'
- en: '`ObjectId—`For a unique ID in a path other than `_id`; typically used to reference
    `_id` paths in other documents.'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectId—`用于除_id之外的路径的唯一ID；通常用于引用其他文档中的_id路径。'
- en: If you need to use a different schema type, it’s possible to write your own
    custom schema types or to use an existing Mongoose plugin from [http://plugins.mongoosejs.io](http://plugins.mongoosejs.io).
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要使用不同的模式类型，您可以编写自己的自定义模式类型，或者使用来自[http://plugins.mongoosejs.io](http://plugins.mongoosejs.io)的现有Mongoose插件。
- en: '|  |'
  id: totrans-1061
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The pathname follows JavaScript object definition conventions and requirements.
    There are no spaces or special characters, and you should try to avoid reserved
    words. Our convention is to use camelCase for pathnames. If you’re using an existing
    database, use the names of the paths already in the documents. If you’re creating
    a new database, the pathnames in the schema will be used in the documents, so
    think carefully.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名遵循JavaScript对象定义的约定和要求。没有空格或特殊字符，你应该尽量避免使用保留词。我们的约定是使用camelCase作为路径名。如果你正在使用现有的数据库，请使用文档中已经存在的路径名。如果你正在创建一个新的数据库，模式中的路径名将用于文档，所以请仔细思考。
- en: The properties object is essentially another JavaScript object. This one defines
    the characteristics of the data held in the path. At a minimum, this object contains
    the data type, but it can include validation characteristics, boundaries, default
    values, and more. You’ll explore and use some of these options over the next few
    chapters as you turn Loc8r into a data-driven application.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 属性对象本质上是一个JavaScript对象。这个对象定义了路径中包含的数据的特征。至少，这个对象包含数据类型，但它可以包括验证特征、边界、默认值等。在接下来的几章中，当你将Loc8r转变为一个数据驱动应用程序时，你将探索并使用这些选项中的一些。
- en: In the next section, you’ll get moving and start defining the schemas you want
    in the application.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将开始定义应用程序中需要的模式。
- en: 5.3\. Defining simple Mongoose schemas
  id: totrans-1065
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. 定义简单的Mongoose模式
- en: We’ve discussed the fact that a Mongoose schema is essentially a JavaScript
    object, which you define from within the application. Start by setting up and
    including the file so that it’s done and out of the way, leaving you free to concentrate
    on the schema.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了这样一个事实，即Mongoose模式本质上是一个JavaScript对象，你可以在应用程序内部定义它。首先，设置并包含该文件，以便完成并移除它，这样你就可以自由地专注于模式。
- en: 'As you’d expect, you’ll define the schema in the model folder alongside db.js.
    In fact, you’re going to `require` it into db.js to expose it to the application.
    Inside the models folder in app_server, create a new empty file called locations.js.
    You need Mongoose to define a Mongoose schema, naturally, so enter the following
    line to locations.js:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，你将在模型文件夹中定义模式，与db.js文件并列。实际上，你将把它`require`到db.js中，以便将其暴露给应用程序。在app_server/models文件夹中，创建一个名为locations.js的新空文件。你需要Mongoose来定义一个Mongoose模式，这是自然的，所以进入以下行到locations.js：
- en: '[PRE116]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'You’ll bring this file into the application by adding a require in db.js for
    it. At the end of db.js, add the following line:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过在db.js中添加一个`require`来将此文件引入应用程序。在db.js的末尾添加以下行：
- en: '[PRE117]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: And with that, you’re set up and ready to go.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你就已经设置好了，准备出发了。
- en: 5.3.1\. The basics of setting up a schema
  id: totrans-1072
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1. 设置模式的基本知识
- en: 'Mongoose gives you a constructor function for defining new schemas, which you
    typically assign to a variable so that you can access it later. This function
    looks like the following line:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose为你提供了一个用于定义新模式的构造函数，你通常将其分配给一个变量，以便以后可以访问它。这个函数看起来像以下行：
- en: '[PRE118]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In fact, that’s exactly the construct you’re going to use. Add it to the locations.js
    model, below the line requiring Mongoose. The empty object inside the `mongoose-Schema({
    })` brackets is where you’ll define the schema.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这正是你将要使用的结构。将其添加到locations.js模型中，在`require` Mongoose的行下面。`mongoose-Schema({
    })`括号内的空对象是你要定义模式的地方。
- en: Defining a schema from controller data
  id: totrans-1076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从控制器数据定义模式
- en: One of the outcomes of moving the data back from the view to the controller
    is that the controller can give you a good idea of the data structure you need.
    Start simple by taking a look at the `homelist` controller in app_server/controllers/locations.js.
    The `homelist` controller passes the data to be shown on the homepage into the
    view. [Figure 5.8](#ch05fig08) shows how one of the locations looks on the homepage.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从视图移回到控制器的一个结果是你将能够很好地了解你需要的数据结构。从查看app_server/controllers/locations.js中的`homelist`控制器开始，简单起见。`homelist`控制器将要在主页上显示的数据传递给视图。[图5.8](#ch05fig08)显示了主页上某个位置的外观。
- en: Figure 5.8\. A single location as displayed in the homepage list
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8. 主页列表中显示的单个位置
- en: '![](Images/05fig08_alt.jpg)'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![Images/05fig08_alt.jpg](Images/05fig08_alt.jpg)'
- en: 'The following code snippet shows the data for this location, as found in the
    controller:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了控制器中找到的此位置的数据：
- en: '[PRE119]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '***1* name is a string.**'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 级名称是一个字符串。'
- en: '***2* address is another string.**'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 级地址是另一个字符串。'
- en: '***3* rating is a number.**'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 级评分是一个数字。'
- en: '***4* facilities is an array of strings.**'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** 级设施是一个字符串数组。'
- en: 'You’ll come back to the distance a bit later, as that needs to be calculated.
    The other four data items are fairly straightforward: two strings, one number,
    and one array of strings. Taking what you know so far, you can use this information
    to define a basic schema like the following:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 你稍后会回到距离，因为那需要计算。其他四个数据项相当直接：两个字符串，一个数字和一个字符串数组。根据你目前所知，你可以使用这些信息来定义一个基本的模式，如下所示：
- en: '[PRE120]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Declares an array of the same schema type by declaring that type inside
    square brackets**'
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过在方括号内声明类型来声明相同模式类型的数组**'
- en: Note the simple approach to declaring facilities as an array ***1***. If your
    array will contain only one schema type, such as `String`, you can define it by
    wrapping the schema type in square brackets.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 注意声明设施为数组的简单方法 ***1***。如果你的数组将只包含一种模式类型，例如 `String`，你可以通过将模式类型括在方括号中来定义它。
- en: Assigning default values
  id: totrans-1090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分配默认值
- en: In some cases, it’s useful to set a default value when a new MongoDB document
    is created based on your schema. In the `locationSchema`, the `rating` path is
    a good candidate. When a new location is added to the database, it won’t have
    had any reviews, so it won’t have a rating. But your view expects a rating between
    zero and five stars, which is what the controller needs to pass through.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当根据你的模式创建新的 MongoDB 文档时设置默认值是有用的。在 `locationSchema` 中，`rating` 路径是一个很好的候选者。当新的位置添加到数据库中时，它还没有任何评论，因此没有评分。但你的视图期望评分在零到五星级之间，这正是控制器需要传递的。
- en: 'What you’d like to do is set a default value of `0` for the rating on each
    new document. Mongoose lets you do this from within the schema. Remember that
    `rating: Number` is shorthand for `rating: {type: Number}`? Well, you can add
    other options to the definition object, including a default value. This means
    that you can update the rating path in the schema as follows:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '你想要做的是为每个新文档的评分设置默认值 `0`。Mongoose 允许你在模式内部这样做。记住 `rating: Number` 是 `rating:
    {type: Number}` 的简写吗？嗯，你可以在定义对象中添加其他选项，包括默认值。这意味着你可以像以下这样更新模式中的评分路径：'
- en: '[PRE121]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The word `default` doesn’t *have* to be in quotes, but it’s a reserved word
    in JavaScript; therefore, it’s a good idea to use them.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 `default` 不 *必须* 用引号括起来，但在 JavaScript 中是一个保留字；因此，使用引号是一个好主意。
- en: 'Adding some basic validation: required fields'
  id: totrans-1095
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加一些基本验证：必需字段
- en: Through Mongoose, you can quickly add some basic validation at the schema level.
    This practice helps maintain data integrity and can protect your database from
    missing or malformed data. Mongoose’s helpers make it easy to add some of the
    most common validation tasks, meaning that you don’t have to write or import the
    code each time.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Mongoose，你可以在模式级别快速添加一些基本验证。这种做法有助于维护数据完整性，并可以保护你的数据库免受缺失或格式错误的数据的影响。Mongoose
    的助手使得添加一些最常见的验证任务变得容易，这意味着你不必每次都编写或导入代码。
- en: 'The first example of this type of validation ensures that required fields aren’t
    empty before saving the document to the database. Rather than writing the checks
    for each required field in code, you can add a `required: true` flag to the definition
    objects of each path that you decide should be mandatory. In the `locationSchema`,
    you certainly want to ensure that each location has a name, so you can update
    the name path like this:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '这种类型验证的第一个例子确保在将文档保存到数据库之前，所需的字段不为空。你不必在代码中为每个所需的字段编写检查，而是可以在你决定应强制执行的每个路径的定义对象中添加
    `required: true` 标志。在 `locationSchema` 中，你当然想确保每个位置都有一个名称，因此你可以像这样更新名称路径：'
- en: '[PRE122]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If you try to save a location without a name, Mongoose returns a validation
    error that you can capture immediately in your code without making a round trip
    to the database.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试保存一个没有名称的位置，Mongoose 会返回一个验证错误，你可以在代码中立即捕获它，而无需往返数据库。
- en: 'Adding some basic validation: number boundaries'
  id: totrans-1100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加一些基本验证：数字边界
- en: 'You can use a similar technique to define the maximum and minimum values you
    want for a number path. These validators are called `max` and `min`. Each location
    you have has a rating assigned to it, which you’ve given a default value of `0`.
    The value should never be less than `0` or greater than `5`. Update the `rating`
    path as follows:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的技术来定义你想要为数字路径设置的最大和最小值。这些验证器称为 `max` 和 `min`。你拥有的每个位置都有一个评分分配给它，你给它设置了默认值
    `0`。该值不应小于 `0` 或大于 `5`。如下更新 `rating` 路径：
- en: '[PRE123]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: With this update, Mongoose won’t let you save a rating value less than `0` or
    greater than `5`. If you try, it returns a validation error that you can handle
    in your code. One great thing about this approach is that the application doesn’t
    have to make a round trip to the database to check the boundaries. Another bonus
    is that you don’t have to write validation code in every place in the application
    where you might add, update, or calculate a rating value.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次更新，Mongoose不会让你保存小于`0`或大于`5`的评分值。如果你尝试这样做，它会返回一个验证错误，你可以在代码中处理。这种方法的一个优点是，应用程序不需要往返数据库来检查边界。另一个优点是，你不需要在应用程序中可能添加、更新或计算评分值的每个地方编写验证代码。
- en: 5.3.2\. Using geographic data in MongoDB and Mongoose
  id: totrans-1104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 在MongoDB和Mongoose中使用地理数据
- en: When you started to map your application’s data from the controller into a Mongoose
    schema, you left the question of distance until later. Now it’s time to discuss
    how you’re going to handle geographic information.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始将应用程序的数据从控制器映射到Mongoose模式时，你将距离问题留到了以后。现在，我们来讨论你将如何处理地理信息。
- en: MongoDB can store geographic data as longitude and latitude coordinates and
    can even create and manage an index based on this data. This ability enables users
    to do fast searches of places that are near one another or near a specific longitude
    and latitude—helpful indeed for building a location-based application!
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB可以将地理数据存储为经纬度坐标，甚至可以根据这些数据创建和管理索引。这种能力使用户能够快速搜索彼此靠近或靠近特定经纬度的地点——这对于构建基于位置的应用程序非常有帮助！
- en: '|  |'
  id: totrans-1107
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About MongoDB indexes**'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于MongoDB索引**'
- en: Indexes in any database system enable faster and more efficient query, and MongoDB
    is no different. When a path is indexed, MongoDB can use this index to quickly
    grab subsets of data without having to scan through all documents in a collection.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据库系统中的索引都能使查询更快、更高效，MongoDB也不例外。当一个路径被索引时，MongoDB可以使用这个索引快速获取数据子集，而无需扫描集合中的所有文档。
- en: Think of a filing system you might have at home. Suppose that you need to find
    a particular credit card statement. You might keep all your paperwork in one drawer
    or cabinet. If everything is thrown in there randomly, you’ll have to sort through
    all types of irrelevant documents until you find what you’re looking for. If you’ve
    indexed your paperwork into folders, however, you can quickly find your credit
    card folder. When you’ve picked out this folder, you look through this one set
    of documents, making your search much more efficient.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你可能在家的文件系统。假设你需要找到一张特定的信用卡对账单。你可能把所有的文件都放在一个抽屉或柜子里。如果所有东西都是随机放入的，你将不得不翻阅所有类型的无关文件，直到找到你想要的东西。然而，如果你已经将文件索引到文件夹中，你可以快速找到你的信用卡文件夹。当你挑选出这个文件夹后，你只需查看这一组文件，这使得你的搜索更加高效。
- en: This scenario is akin to how indexing works in a database. In a database, though,
    you can have more than one index for each document, enabling you to search efficiently
    on different queries.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景类似于数据库中索引的工作方式。然而，在数据库中，每个文档可以有多个索引，这使你能够针对不同的查询进行高效搜索。
- en: Indexes do take maintenance and database resources, though, as it takes time
    to file your paperwork correctly. For best overall performance, try to limit your
    database indexes to the paths that most need indexing and are used for most queries.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 索引确实需要维护和数据库资源，因为正确归档文件需要时间。为了获得最佳的整体性能，尽量将数据库索引限制在需要索引且用于大多数查询的路径上。
- en: '|  |'
  id: totrans-1113
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The data for a single geographical location is stored according to the GeoJSON
    format specification, which you’ll see in action shortly. Mongoose supports this
    data type, allowing you to define a geospatial path inside a schema. As Mongoose
    is an abstraction layer on top of MongoDB, it strives to make things easier for
    you. All you have to do to add a GeoJSON path in your schema:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 单个地理位置的数据根据GeoJSON格式规范存储，你很快就会看到它的实际应用。Mongoose支持这种数据类型，允许你在模式中定义地理空间路径。由于Mongoose是MongoDB之上的抽象层，它努力使事情变得更容易。你只需在模式中添加GeoJSON路径：
- en: Define the path as an array of the `Number` type.
  id: totrans-1115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径定义为数字类型的数组。
- en: Define the path as having a `2dsphere` index.
  id: totrans-1116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径定义为具有`2dsphere`索引。
- en: 'To put this into action, you can add a `coords` path to your location schema.
    If you follow the two preceding steps, your schema should look like this:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此付诸实践，你可以在位置模式中添加一个`coords`路径。如果你遵循前两个步骤，你的模式应该看起来像这样：
- en: '[PRE124]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The `2dsphere` here is the critical part because it enables MongoDB to do the
    correct calculations when running queries and returning results. It allows MongoDB
    to calculate geometries based on a spherical object. You’ll work more with this
    feature in [chapter 6](kindle_split_017.xhtml#ch06) when you build your API and
    start to interact with the data.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`2dsphere`是关键部分，因为它使得MongoDB在运行查询和返回结果时能够进行正确的计算。它允许MongoDB根据球形对象计算几何形状。当你构建API并开始与数据交互时，你将在[第6章](kindle_split_017.xhtml#ch06)中更多地使用这个功能。
- en: '|  |'
  id: totrans-1120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To meet the GeoJSON specification, a coordinate pair must be entered into the
    array in the correct order: longitude, then latitude. Valid longitude values range
    from -180 to 180, whereas valid latitude values range from -90 to 90\. Getting
    your coordinates in the wrong order is an easy mistake to make, so keep this in
    mind when saving location data to the collection.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足GeoJSON规范，坐标对必须按照正确的顺序输入到数组中：经度，然后是纬度。有效的经度值范围从-180到180，而有效的纬度值范围从-90到90。将坐标顺序搞错是一个容易犯的错误，所以在保存位置数据到集合时请记住这一点。
- en: '|  |'
  id: totrans-1123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve got the basics covered, and your schema for Loc8r currently holds everything
    needed to satisfy the homepage requirements. Next, it’s time to take a look at
    the Details page. This page has more complex data requirements, and you’ll see
    how to handle them with Mongoose schemas.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经掌握了基础知识，Loc8r的当前模式包含了满足主页需求所需的所有内容。接下来，是时候看看详情页面了。这个页面有更复杂的数据需求，你将看到如何使用Mongoose模式来处理它们。
- en: 5.3.3\. Creating more complex schemas with subdocuments
  id: totrans-1125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3\. 使用子文档创建更复杂的模式
- en: The data you’ve used up until now has been simple and can be held in a fairly
    flat schema. You’ve used a couple of arrays for the facilities and location coordinates,
    but again, those arrays are simple, containing only a single data type each. Now
    you’ll look at what happens when you have a slightly more complicated dataset
    to work with.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止使用的数据很简单，可以放在一个相当扁平的模式中。你已经使用了一些数组来存储设施和位置坐标，但同样，这些数组很简单，每个数组只包含单一的数据类型。现在，你将看看当你处理一个稍微复杂的数据集时会发生什么。
- en: Start by reacquainting yourself with the Details page and the data that it shows.
    [Figure 5.9](#ch05fig09) shows a screenshot of the page with all the different
    areas of information. The name, rating, and address are right at the top; a little
    farther down are the facilities. On the right side is a map, based on the geographic
    coordinates. You’ve already covered these elements with the basic schema. The
    two areas that you don’t have anything for are opening hours and customer reviews.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重新熟悉一下详情页面以及它显示的数据。[图5.9](#ch05fig09)显示了包含所有不同信息区域的页面截图。名称、评分和地址位于顶部；稍低一些是设施。右侧是一张基于地理坐标的地图。你已经用基本模式覆盖了这些元素。你还没有为营业时间和客户评论准备任何内容。
- en: Figure 5.9\. The information displayed for a single location on the Details
    page
  id: totrans-1128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.9\. 详情页面显示的单个位置的信息
- en: '![](Images/05fig09_alt.jpg)'
  id: totrans-1129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig09_alt.jpg)'
- en: The data powering this view is currently held in the `locationInfo` controller
    in app_server/controllers/locations.js. The following listing shows the relevant
    portion of the data in this controller.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这个视图的数据目前保存在`locationInfo`控制器中，位于`app_server/controllers/locations.js`。以下列表显示了该控制器中的相关数据部分。
- en: Listing 5.2\. Data in the controller powering the Details page
  id: totrans-1131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2\. 驱动详情页面的控制器中的数据
- en: '[PRE125]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '***1* Already covered with the existing schema**'
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 已经用现有模式覆盖**'
- en: '***2* Data for opening hours is held as an array of objects.**'
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 营业时间的数据被存储为对象数组。**'
- en: '***3* Reviews are also passed to the view as an array of objects.**'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 评论也作为对象数组传递给视图。**'
- en: Here, you have arrays of objects for the opening hours and for the reviews.
    In a relational database, you’d create these as separate tables and `join` them
    in a query when you need the information. But that’s not how document databases
    work, including MongoDB. In a document database, anything that belongs specifically
    to a parent document should be contained *within* that document. [Figure 5.10](#ch05fig10)
    illustrates the conceptual difference between the two approaches.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你拥有用于营业时间的对象数组和用于评论的对象数组。在一个关系型数据库中，你会创建这些作为单独的表，并在需要信息时在查询中`join`它们。但文档数据库（包括MongoDB）并不是这样工作的。在文档数据库中，任何特定于父文档的内容都应该包含在**该文档**内。[图5.10](#ch05fig10)说明了这两种方法之间的概念差异。
- en: Figure 5.10\. Difference between how a relational database and a document database
    store repeating information relating to a parent element
  id: totrans-1137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.10\. 关系型数据库和文档数据库在存储与父元素相关的重复信息方面的区别
- en: '![](Images/05fig10_alt.jpg)'
  id: totrans-1138
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig10_alt.jpg)'
- en: MongoDB offers the concept of *subdocuments* to store this repeating, nested
    data. Subdocuments are much like documents in that they have their own schema;
    each is given a unique `_id` by MongoDB when created. But subdocuments are nested
    inside a document, and they can be accessed only as a path of that parent document.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 提供了 *子文档* 的概念来存储这种重复的嵌套数据。子文档与文档非常相似，它们都有自己的模式；每个子文档在创建时都会由 MongoDB
    分配一个唯一的 `_id`。但是子文档嵌套在文档内部，并且只能通过父文档的路径来访问。
- en: Using nested schemas in Mongoose to define subdocuments
  id: totrans-1140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Mongoose 中使用嵌套模式来定义子文档
- en: 'Subdocuments are defined in Mongoose by nested schemas—one schema nested inside
    another. In this section, you’ll create one to see how it works in code. The first
    step is defining a new schema for a subdocument. Start with the opening times,
    and create the following schema. Note that this schema needs to be in the same
    file as the `locationSchema` definition and (important) must be *before* the `locationSchema`
    definition:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 通过嵌套模式定义子文档——一个模式嵌套在另一个模式内部。在本节中，你将创建一个子文档模式来查看它在代码中的工作方式。第一步是定义一个子文档的新模式。从营业时间开始，创建以下模式。请注意，此模式需要与
    `locationSchema` 定义在同一文件中，并且（重要的是）必须在 `locationSchema` 定义之前：
- en: '[PRE126]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '|  |'
  id: totrans-1143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Options for storing time information**'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储时间信息的选项**'
- en: 'In the opening-time schema, you have an interesting situation: you want to
    save time information, such as 7:30 a.m., but without a date associated with it.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 在营业时间模式中，你有一个有趣的情况：你想要保存时间信息，如早上 7:30，但不需要与之关联的日期。
- en: Here, you’re using a `String` method, as it doesn’t require any processing before
    being put into the database or after being retrieved. It also makes each record
    easy to understand. The downside is that it makes doing any computational processing
    with it harder.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用的是 `String` 方法，因为它在放入数据库或检索后不需要任何处理。这也使得每条记录都很容易理解。缺点是它使得对数据进行任何计算处理变得更加困难。
- en: One option is to create a date object with an arbitrary data value assigned
    to it and manually set the hours and minutes, such as
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选项是创建一个带有任意数据值的数据对象，并手动设置小时和分钟，例如
- en: '[PRE127]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '***1* d is now Sun Mar 12 2017 15:30:40 GMT+0000 (GMT).**'
  id: totrans-1149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* d 现在是 Sun Mar 12 2017 15:30:40 GMT+0000 (GMT)。**'
- en: Using this method, you could easily extract the time from the data. The downsides
    are that you store unnecessary data, and that this method is technically incorrect.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以轻松地从数据中提取时间。缺点是你会存储不必要的数据，并且这种方法在技术上是不正确的。
- en: A second option is to store the number of minutes since midnight. So 7:30 a.m.
    is (7 × 60) + 30 = 450\. This computation is a fairly simple one to make when
    you’re putting data into the database and pulling it out again. But the data at
    a glance is meaningless.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选项是存储午夜以来的分钟数。所以早上 7:30 是 (7 × 60) + 30 = 450。当你将数据放入数据库并再次检索时，这个计算相当简单。但数据看起来没有意义。
- en: This second option, however, would be our preference for making the dates smarter
    and could be a good extension if you want to try something new. For the sake of
    readability and avoiding distractions, you’ll keep using the String method through
    the book.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个第二种选项是我们更倾向于使用的，可以使日期更智能，如果想要尝试新事物，这也可以是一个很好的扩展。为了提高可读性和避免干扰，你将保持使用字符串方法贯穿整本书。
- en: '|  |'
  id: totrans-1153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This schema definition is simple and maps over from the data in the controller.
    You have two required fields: the `closed` Boolean flag and the `days` each subdocument
    is referring to.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式定义很简单，并映射来自控制器中的数据。你有两个必填字段：`closed` 布尔标志和每个子文档引用的 `days`。
- en: 'Nesting this schema inside the location schema is another straightforward task.
    You need to add a new path to the parent schema and define it as an array of your
    subdocument schema. The following code snippet shows how to nest the `openingTimeSchema`
    inside the `locationSchema`:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置模式内部嵌套此模式是另一个简单的任务。你需要向父模式添加一个新的路径，并将其定义为子文档模式的数组。以下代码片段显示了如何在 `locationSchema`
    内部嵌套 `openingTimeSchema`：
- en: '[PRE128]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '***1* Adds nested schema by referencing another schema object as an array**'
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过引用另一个模式对象作为数组添加嵌套模式**'
- en: 'With this in place, you can add multiple opening-time subdocuments to a given
    location, and these subdocuments are stored within that location document. An
    example document from MongoDB based on this schema is shown in the following code
    snippet, with the subdocuments for the opening times in bold:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，您可以为特定位置添加多个开馆时间子文档，这些子文档存储在该位置文档中。以下代码片段展示了基于此模式的 MongoDB 示例文档，其中开馆时间的子文档以粗体显示：
- en: '[PRE129]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '***1* In a MongoDB document, nested opening-times subdocuments live inside
    the location document.**'
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 MongoDB 文档中，嵌套的开馆时间子文档位于位置文档内部。**'
- en: With the schema for the opening times taken care of, next you’ll look at adding
    a schema for the review subdocuments.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理开馆时间的方案得到妥善处理后，接下来您将查看添加评论子文档方案的步骤。
- en: Adding a second set of subdocuments
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加第二组子文档
- en: 'Neither MongoDB nor Mongoose limits the number of subdocument paths in a document,
    so you’re free to use what you’ve done for the opening times and replicate the
    process for the reviews:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 和 Mongoose 都不限制文档中子文档路径的数量，因此您可以自由地使用您为开馆时间所做的工作，并复制此过程用于评论：
- en: 'Step 1: Look at the data used in a review:'
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步：查看评论中使用的数据：
- en: '[PRE130]'
  id: totrans-1165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Step 2: Map this code into a new `reviewSchema` in app_server/models/ location.js:'
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步：将此代码映射到 app_server/models/ location.js 中的新 `reviewSchema`：
- en: '[PRE131]'
  id: totrans-1167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Step 3: Add this `reviewSchema` as a new path to `locationSchema`:'
  id: totrans-1168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三步：将此 `reviewSchema` 作为新路径添加到 `locationSchema`：
- en: '[PRE132]'
  id: totrans-1169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When you’ve defined the schema for reviews and added it to your main location
    schema, you have everything you need to hold the data for all locations in a structured
    way.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 当您已定义评论的方案并将其添加到主位置方案中，您就有了一切所需，以结构化的方式存储所有位置的数据。
- en: 5.3.4\. Final schema
  id: totrans-1171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4\. 最终方案
- en: Throughout this section, you’ve done quite a bit in the file, so take a look
    at it all together to see what’s what. The following listing shows the contents
    of the locations.js file in app_server/models, defining the schema for the location
    data.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您在文件中做了很多工作，所以一起看看，以了解发生了什么。以下列表显示了 app_server/models 中 locations.js 文件的全部内容，定义了位置数据的方案。
- en: Listing 5.3\. Final location schema definition, including nested schemas
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 最终位置方案定义，包括嵌套方案
- en: '[PRE133]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '***1* Requires Mongoose so that you can use its methods**'
  id: totrans-1175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要 Mongoose 以便使用其方法**'
- en: '***2* Defines a schema for opening times**'
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义开馆时间的方案**'
- en: '***3* Defines a schema for reviews**'
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义评论的方案**'
- en: '***4* Starts the main location schema definition**'
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 开始主要位置方案的定义**'
- en: '***5* Uses 2dsphere to add support for GeoJSON longitude and latitude coordinate
    pairs**'
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 2dsphere 以添加对 GeoJSON 经纬度坐标对的支撑**'
- en: '***6* References the opening times and reviews schemas to add nested subdocuments**'
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 引用开馆时间和评论方案以添加嵌套子文档**'
- en: Documents and subdocuments all have a schema defining their structure, and you’ve
    also added some default values and basic validation. To make this scenario a bit
    more real, the following listing shows an example MongoDB document based on this
    schema.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 文档和子文档都有定义其结构的方案，您还添加了一些默认值和基本验证。为了使这个场景更真实，以下列表展示了基于此方案的示例 MongoDB 文档。
- en: Listing 5.4\. Example MongoDB document based on the location schema
  id: totrans-1182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 基于位置方案的示例 MongoDB 文档
- en: '[PRE134]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '***1* Coordinates are stored as a GeoJSON pair [longitude, latitude].**'
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 坐标存储为 GeoJSON 对 [经度，纬度]。**'
- en: '***2* Opening times are stored as nested array of objects (subdocuments).**'
  id: totrans-1185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 开馆时间存储为嵌套对象数组（子文档）。**'
- en: '***3* Reviews are also arrays of subdocuments.**'
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 评论也是子文档的数组。**'
- en: That listing should give you an idea of what a MongoDB document looks like,
    including subdocuments, when based on a known schema. In readable form like this,
    it’s a JSON object, although technically, MongoDB stores it as BSON, which is
    Binary JSON.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表应能给您一个关于基于已知方案的 MongoDB 文档外观的概念，包括子文档。以这种可读的形式，它是一个 JSON 对象，尽管技术上 MongoDB
    以 BSON（二进制 JSON）的形式存储它。
- en: 5.3.5\. Compiling Mongoose schemas into models
  id: totrans-1188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.5\. 编译 Mongoose 方案到模型
- en: An application doesn’t interact with the schema directly when working with data;
    data interaction is done through models.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据交互时，应用程序不会直接与方案交互；数据交互是通过模型完成的。
- en: In Mongoose, a model is a compiled version of the schema. When it’s compiled,
    a single instance of the model maps directly to a single document in your database.
    It’s through this direct one-to-one relationship that the model can create, read,
    save, and delete data. [Figure 5.11](#ch05fig11) illustrates this arrangement.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mongoose中，模型是模式的编译版本。当它被编译时，模型的单个实例直接映射到数据库中的单个文档。正是通过这种直接的一对一关系，模型可以创建、读取、保存和删除数据。[图5.11](#ch05fig11)说明了这种安排。
- en: Figure 5.11\. The application and the database talk to each other through models.
    A single instance of a model has a one-to-one relationship with a single document
    in the database. It’s through this relationship that the creating, reading, updating,
    and deleting of data are managed.
  id: totrans-1191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11\. 应用程序和数据库通过模型进行交互。模型的单个实例与数据库中的单个文档有一对一的关系。正是通过这种关系，管理数据的创建、读取、更新和删除。
- en: '![](Images/05fig11_alt.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig11_alt.jpg)'
- en: This approach makes Mongoose a breeze to work with, and you’ll get your teeth
    into it in [chapter 6](kindle_split_017.xhtml#ch06) when you build the internal
    API for the application.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得Mongoose易于使用，你将在[第6章](kindle_split_017.xhtml#ch06)中构建应用程序的内部API时深入了解它。
- en: Compiling a model from a schema
  id: totrans-1194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从模式编译模型
- en: 'Anything with the word *compiling* in it tends to sound a bit complicated.
    In reality, compiling a Mongoose model from a schema is a simple one-line task.
    You need to ensure that the schema is complete before you invoke the `model` command.
    The `model` command follows this construct:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含单词*compiling*的东西听起来可能有点复杂。实际上，从模式编译Mongoose模型是一个简单的单行任务。在调用`model`命令之前，你需要确保模式是完整的。`model`命令遵循以下结构：
- en: '![](Images/p0145-01_alt.jpg)'
  id: totrans-1196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/p0145-01_alt.jpg)'
- en: '|  |'
  id: totrans-1197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The MongoDB collection name is optional. If you exclude it, Mongoose uses a
    lowercase pluralized version of the model name. A model name of `Location`, for
    example, would look for a collection name of locations unless you specify something
    different.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB集合名称是可选的。如果你省略了它，Mongoose将使用模型名称的小写复数形式。例如，模型名称为`Location`时，它会寻找名为locations的集合名称，除非你指定了不同的名称。
- en: '|  |'
  id: totrans-1200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As you’re creating a database and not hooking into an existing data source,
    you can use a default collection name, so you don’t need to include that parameter
    in the `model` command. To build a model of your location schema, you can add
    the following line to the code below the `locationSchema` definition:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在创建数据库而不是连接到现有的数据源，你可以使用默认的集合名称，因此你不需要在`model`命令中包含该参数。要构建你的位置模式模型，你可以在`locationSchema`定义下面的代码中添加以下行：
- en: '[PRE135]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: That’s all there is to it. You’ve defined a data schema for the locations and
    compiled the schema into a model that you can use in the application. What you
    need now is some data.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。你已经为位置定义了数据模式，并将模式编译成了可以在应用程序中使用的模型。你现在需要一些数据。
- en: 5.4\. Using the MongoDB shell to create a MongoDB database and add data
  id: totrans-1204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 使用MongoDB shell创建MongoDB数据库并添加数据
- en: To build the Loc8r app, you’ll create a new database and manually add some test
    data. You get to create your own personal version of Loc8r for testing and at
    the same time play directly with MongoDB.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Loc8r应用程序，你需要创建一个新的数据库并手动添加一些测试数据。你可以创建自己的Loc8r个人版本进行测试，同时直接与MongoDB交互。
- en: 5.4.1\. MongoDB shell basics
  id: totrans-1206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. MongoDB shell基础
- en: The MongoDB shell is a command-line utility that gets installed with MongoDB
    and allows you to interact with any MongoDB databases on your system. It’s powerful
    and can do a lot. You’re only going to get acquainted with the basics to get up
    and running.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB shell是一个与MongoDB一起安装的命令行实用程序，允许你与系统上的任何MongoDB数据库交互。它功能强大，可以做很多事情。你只需要熟悉基础知识来启动和运行。
- en: Starting the MongoDB shell
  id: totrans-1208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启动MongoDB shell
- en: 'Drop into the shell by running the following line in terminal:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下行进入shell：
- en: '[PRE136]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This command should respond in terminal with a few lines confirming
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应在终端中响应几行确认
- en: The shell version
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell版本
- en: The server and port that it’s connecting to
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它连接到的服务器和端口
- en: The server version it has connected to
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它连接到的服务器版本
- en: 'These confirmation lines should look similar to this, so long as the version
    is equal to or later than 4:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些确认行应该看起来像这样，只要版本等于或高于4：
- en: '[PRE137]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: If you’re using an older version of MongoDB, you may see different messages,
    but it’s normally obvious if the command has worked or failed. You might also
    see a few lines starting with `Server has startup warnings` going on to state
    `Access control is not enabled for the database`. This isn’t anything to worry
    about on your local development machine.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 MongoDB 的较旧版本，您可能会看到不同的消息，但通常如果命令已成功或失败是显而易见的。您也可能看到一些以 `Server has
    startup warnings` 开头并继续说明 `Access control is not enabled for the database` 的几行。在您的本地开发机器上，这并不是什么需要担心的事情。
- en: '|  |'
  id: totrans-1218
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you’re in the shell, newlines start with a `>` to differentiate from the
    standard command-line entry point. The shell commands printed in this section
    start with `>` instead of `$` to make it clear that you’re using the shell, but
    like `$`, you don’t need to type it.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 shell 中时，新行以 `>` 开头，以区分标准命令行入口点。本节中打印的 shell 命令以 `>` 开头而不是 `$`，以清楚地表明您正在使用
    shell，但与 `$` 一样，您不需要输入它。
- en: '|  |'
  id: totrans-1221
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing all local databases
  id: totrans-1222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列出所有本地数据库
- en: 'Next is a simple command that shows a list of all the local MongoDB databases.
    Enter the following line in the shell:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个简单的命令，显示了所有本地 MongoDB 数据库的列表。在 shell 中输入以下行：
- en: '[PRE138]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This line returns a list of the local MongoDB database names and their sizes.
    If you haven’t created any databases at this point, you still see the two default
    ones, which look something like this:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 这行返回了本地 MongoDB 数据库名称及其大小的列表。如果您在此点还没有创建任何数据库，您仍然会看到两个默认数据库，它们看起来像这样：
- en: '[PRE139]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Using a specific database
  id: totrans-1227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用特定数据库
- en: 'If you want to use a specific database, such as the default one called local,
    you can use the `use` command, like this:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用特定数据库，例如默认的名为 local 的数据库，您可以使用 `use` 命令，如下所示：
- en: '[PRE140]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The shell responds with a message along these lines:'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: shell 会响应如下信息：
- en: '[PRE141]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This message confirms the name of the database the shell has connected to.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息确认了shell连接到的数据库的名称。
- en: Listing the collections in a database
  id: totrans-1233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列出数据库中的集合
- en: 'When you’re using a particular database, it’s easy to output a list of its
    collections by using the following command:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用特定数据库时，使用以下命令很容易输出其集合列表：
- en: '[PRE142]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If you’re using the local database, you’ll probably see a single collection
    name output to terminal: `startup_log`.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用本地数据库，您可能会在终端看到一个单独的集合名称输出：`startup_log`。
- en: Seeing the contents of a collection
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看集合的内容
- en: 'The MongoDB shell also lets you query the collections in a database. The construct
    for a query or find operation is as follows:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB shell 还允许您查询数据库中的集合。查询或查找操作的构造如下：
- en: '![](Images/p0148-01_alt.jpg)'
  id: totrans-1239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0148-01_alt.jpg)'
- en: 'The `query` object is used to specify what you’re trying to find in the collection,
    and you’ll look at examples of this `query` object later in [chapter 6](kindle_split_017.xhtml#ch06).
    (Mongoose also uses the `query` object.) The simplest query is an empty query,
    which returns all the documents in a collection. Don’t worry if your collection
    is large, as MongoDB returns a subset of documents that you can page through.
    Using the `startup_log` collection as an example, you can run the following command:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '`query` 对象用于指定您在集合中试图查找的内容，您将在第6章中查看这个 `query` 对象的示例。（Mongoose 也使用 `query`
    对象。）最简单的查询是一个空查询，它返回集合中的所有文档。如果您的集合很大，请不要担心，因为 MongoDB 会返回一个您可以分页查看的文档子集。以 `startup_log`
    集合为例，您可以运行以下命令：'
- en: '[PRE143]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: This command returns several documents from the MongoDB startup log, the content
    of which isn’t interesting enough to show here. This command is useful when you’re
    getting your database up and running and making sure that things are being saved
    as you expect.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令返回 MongoDB 启动日志中的几个文档，其内容在这里展示并不足够有趣。当您在设置数据库并确保一切按预期保存时，此命令非常有用。
- en: 5.4.2\. Creating a MongoDB database
  id: totrans-1243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 创建 MongoDB 数据库
- en: 'You don’t have to *create* a MongoDB database; you only need to start using
    it. For the Loc8r application, it makes sense to have a database called Loc8r.
    In the shell, you use it with the following command:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要 *创建* MongoDB 数据库；您只需要开始使用它。对于 Loc8r 应用程序，拥有一个名为 Loc8r 的数据库是有意义的。在 shell
    中，您可以使用以下命令使用它：
- en: '[PRE144]'
  id: totrans-1245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: If you run the `show collections` command, it won’t return anything yet, and
    you won’t even see it if you run `show dbs`. But you’ll be able to see it after
    saving some data to it.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行 `show collections` 命令，它目前不会返回任何内容，即使您运行 `show dbs`，您也看不到它。但是，在向其中保存一些数据后，您将能够看到它。
- en: Creating a collection and documents
  id: totrans-1247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建集合和文档
- en: Similarly, you don’t have to explicitly create a collection, as MongoDB creates
    it for you when you first save data to it.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你不需要显式创建集合，因为当你第一次向其中保存数据时，MongoDB 会为你创建它。
- en: '|  |'
  id: totrans-1249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Location data more personal to you**'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '**更符合你个人需求的地理位置数据**'
- en: Loc8r is all about location-based data, and the examples are all fictitious
    places, geographically close to where Simon lives in the United Kingdom. You can
    make your version more personal to you by changing the names, addresses, and coordinates.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: Loc8r 是关于基于位置的数据，示例中的地点都是虚构的，地理位置上靠近西蒙在英国的居住地。你可以通过更改名称、地址和坐标来使你的版本更加个性化。
- en: To get your current coordinates, visit [https://whatsmylatlng.com](https://whatsmylatlng.com).
    There’s a button on the page to find your location by using JavaScript, which
    gives you a much more accurate location than the first attempt. Note that the
    coordinates are shown to you in latitude–longitude order, and you need to flip
    them around for the database so that longitude is first.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取您的当前坐标，请访问 [https://whatsmylatlng.com](https://whatsmylatlng.com)。页面上有一个按钮，可以通过
    JavaScript 查找您的位置，这比第一次尝试更准确。请注意，坐标以纬度-经度顺序显示给您，您需要将它们翻转以便数据库中经度在前。
- en: To get the coordinates of any address, you can use [http://mygeoposition.com](http://mygeoposition.com).
    This site lets you enter an address or drag and drop a pointer to give you the
    geographic coordinates. Again, remember that the pairs in MongoDB must be longitude
    and then latitude.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取任何地址的坐标，你可以使用 [http://mygeoposition.com](http://mygeoposition.com)。此网站允许你输入地址或拖放指针以获取地理坐标。再次提醒，MongoDB
    中的对必须先经度后纬度。
- en: '|  |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To match the `Location` model, you’ll want a `locations` collection. Remember
    that the default collection name is a lowercase pluralized version of the model
    name. You can create and save a new document by passing a data object into the
    `save` command of a collection, as in the following code snippet:'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配 `Location` 模型，你将需要一个 `locations` 集合。记住，默认的集合名称是模型名称的复数小写版本。你可以通过将数据对象传递给集合的
    `save` 命令来创建和保存一个新的文档，如下面的代码片段所示：
- en: '[PRE145]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '***1* Note collection name specified as part of the save command**'
  id: totrans-1257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意在保存命令中指定的集合名称**'
- en: 'In one step, you’ve created the `Loc8r` database and a new `locations` collection,
    and added the first document to the collection. If you run `show dbs` in the MongoDB
    shell now, you should see the new `Loc8r` database being returned alongside the
    other databases, like so:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 在一步中，你创建了 `Loc8r` 数据库和新的 `locations` 集合，并将第一个文档添加到集合中。如果你现在在 MongoDB shell 中运行
    `show dbs`，你应该会看到新的 `Loc8r` 数据库与其他数据库一起返回，如下所示：
- en: '[PRE146]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now when you run `show collections` in the MongoDB shell, you should see the
    new `locations` collection being returned:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行 MongoDB shell 中的 `show collections` 时，你应该会看到返回的新 `locations` 集合：
- en: '[PRE147]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'You can query the collection to find the documents. Only one document is there
    currently, so the returned information is small. You can use the `find` command
    on the collection as well:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查询集合以找到文档。目前只有一个文档，所以返回的信息很少。你还可以在集合上使用 `find` 命令：
- en: '[PRE148]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '***1* Remember to run the find operation on the collection itself.**'
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记得在集合本身上运行查找操作。**'
- en: '***2* MongoDB has automatically added a unique identifier for this document.**'
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* MongoDB 已经为该文档自动添加了一个唯一标识符。**'
- en: 'This code snippet has been formatted for readability; the document that MongoDB
    returns to the shell won’t have the line breaks and indentation. But the MongoDB
    shell can prettify it for you if you add `.pretty()` to the end of the command,
    like this:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段已格式化以提高可读性；MongoDB 返回给 shell 的文档不会有换行符和缩进。但如果你在命令末尾添加 `.pretty()`，MongoDB
    shell 可以为你美化它，如下所示：
- en: '[PRE149]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Notice that the order of the data in the returned document doesn’t match the
    order of the data in the object you supplied. As the data structure isn’t column-based,
    it doesn’t matter how MongoDB stores the individual paths within a document. The
    data is always still there in the correct paths, and data held inside arrays always
    maintains the same order.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，返回文档中的数据顺序与您提供的数据对象中的顺序不匹配。由于数据结构不是基于列的，MongoDB 如何存储文档内的单个路径顺序并不重要。数据始终在正确的路径中，并且数组内部的数据保持相同的顺序。
- en: Adding subdocuments
  id: totrans-1269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加子文档
- en: You’ve probably noticed that your first document doesn’t have the full dataset;
    there are no review subdocuments. You can add them to the initial `save` command
    as you’ve done with the opening times, or you can update an existing document
    and push them in.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，你的第一个文档没有完整的数据集；没有审查子文档。你可以像处理营业时间那样，在初始的 `save` 命令中添加它们，或者你可以更新现有文档并将它们推入。
- en: 'MongoDB has an `update` command that accepts two arguments: a query so that
    it knows which document to update, and the instructions on what to do when it
    finds the document. At this point, you can do a simple query and look for the
    location by name (Starcups), as you know that there aren’t any duplicates. For
    the instruction object, you can use a `$push` command to add a new object to the
    reviews path. It doesn’t matter if the reviews path doesn’t exist yet; MongoDB
    adds it as part of the push operation.'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 有一个 `update` 命令，它接受两个参数：一个查询，以便它知道要更新哪个文档，以及当它找到文档时要执行的操作的说明。在这个阶段，你可以进行一个简单的查询，通过名称（Starcups）查找位置，因为你知道没有重复项。对于指令对象，你可以使用一个
    `$push` 命令向评论路径添加一个新的对象。即使评论路径尚不存在，MongoDB 也会在推送操作中将其添加。
- en: 'Putting it all together shows something like the following code snippet:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，就像以下代码片段所示：
- en: '[PRE150]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '***1* Starts with a query object to find correct document**'
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从查询对象开始以找到正确的文档**'
- en: '***2* When the document is found, pushes a subdocument into the reviews path**'
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当文档找到时，将子文档推入评论路径**'
- en: '***3* Subdocument contains this data**'
  id: totrans-1276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 子文档包含此数据**'
- en: If you run that command in the MongoDB shell while using the `Loc8r` database,
    you add a review to the document. You can repeat the command as often as you like,
    changing the data to add multiple reviews.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `Loc8r` 数据库在 MongoDB 壳中运行该命令，你将向文档添加一个评论。你可以根据需要重复该命令，更改数据以添加多个评论。
- en: You may have noticed that here, you specify the `_id` property and assign it
    the value of `ObjectId()`. MongoDB doesn’t automatically add `_id` to subdocuments
    as it does for documents, but this feature will be useful for you later. Giving
    the review subdocument the value of `ObjectId()` tells MongoDB to create a new
    unique identifier for this subdocument.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这里，你指定了 `_id` 属性并将其赋值为 `ObjectId()`。MongoDB 不会像对文档那样自动将 `_id` 添加到子文档中，但这个特性对你来说将非常有用。给评论子文档赋值
    `ObjectId()` 告诉 MongoDB 为此子文档创建一个新的唯一标识符。
- en: Note the `new Date()` function call for setting the timestamp of the review.
    Using this timestamp ensures that MongoDB stores the date as an ISO date object,
    not a string—which is what your schema expects, and which allows greater manipulation
    of dates data.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意设置评论时间戳的 `new Date()` 函数调用。使用此时间戳确保 MongoDB 将日期存储为 ISO 日期对象，而不是字符串——这是你的模式所期望的，并且允许对日期数据进行更高级的操作。
- en: Repeat the process
  id: totrans-1280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重复此过程
- en: These few commands have given you one location to test the application with,
    but ideally, you need a couple more. Add some more locations to your database.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 这几个命令已经为你提供了一个测试应用程序的位置，但理想情况下，你需要更多。向你的数据库添加一些更多位置。
- en: When you’re done with that and your data is set, you’re almost at the point
    where you can start using it from the application. In this case, you’ll be building
    an API. But before you jump into that task in [chapter 6](kindle_split_017.xhtml#ch06),
    there’s one more piece of housekeeping. You want to keep pushing regular updates
    to Heroku, and now that you’ve added a database connection and data models to
    your application, you need to make sure that these updates are supported in Heroku.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作并设置好数据后，你几乎可以开始从应用程序中使用它了。在这种情况下，你将构建一个 API。但在你跳转到第 6 章（[kindle_split_017.xhtml#ch06](https://example.org/kindle_split_017.xhtml#ch06)）中的任务之前，还有一项家务要做。你想要定期向
    Heroku 推送更新，现在你已经向应用程序添加了数据库连接和数据模型，你需要确保这些更新在 Heroku 上得到支持。
- en: 5.5\. Getting your database live
  id: totrans-1283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 使数据库上线
- en: If you’ve got your application out in the wild, it’s no good having your database
    on your local host. Your database also needs to be externally accessible. In this
    section, you’ll push your database into a live environment and update your Loc8r
    application so that it uses the published database from the published site, and
    the local host database from the development site. You’ll start by using the free
    tier of a service called mLab, which can be used as an add-on to Heroku. If you
    have a different preferred provider or your own database server, that’s no problem.
    The first part of this section runs through setting up on mLab, but the following
    parts—migrating the data and setting the connection strings in the Node application—aren’t
    platform specific.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序已经发布到野外，将数据库放在本地主机上是没有用的。您的数据库也需要外部可访问。在本节中，您将把数据库推送到一个实时环境中，并更新您的 Loc8r
    应用程序，使其使用发布站点的已发布数据库和开发站点的本地主机数据库。您将首先使用一个名为 mLab 的服务的免费层，该服务可以用作 Heroku 的附加组件。如果您有其他首选提供商或自己的数据库服务器，那没问题。本节的第一部分将介绍在
    mLab 上的设置，但以下部分——迁移数据和在 Node 应用程序中设置连接字符串——不是平台特定的。
- en: 5.5.1\. Setting up mLab and getting the database URI
  id: totrans-1285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1\. 设置 mLab 并获取数据库 URI
- en: The first goal is getting an externally accessible database URI so that you
    can push data to it and add it to the application. You’ll use mLab for this purpose,
    as it has a good free tier, excellent online documentation, and a responsive support
    team.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目标是获取一个外部可访问的数据库 URI，以便您可以将数据推送到它并将其添加到应用程序中。您将使用 mLab 来实现这一目的，因为它有一个良好的免费层，优秀的在线文档，以及响应的支持团队。
- en: You have a couple of ways to set up a database on mLab. The quickest and easiest
    way is to use an add-on via Heroku. This method is what you’ll use here, but it
    does require you to register a valid credit card with Heroku. Heroku makes you
    do this when you use add-ons through its ecosystem to protect itself from abusive
    behavior. Using the free sandbox tier of mLab won’t incur any charges. If you’re
    not comfortable using a credit card to set up your mLab database directly through
    Heroku, check out the sidebar “[Setting up mLab manually](#ch05sb09)” for details
    on setting up an mLab database and connecting it to your Heroku application manually.
    If you opt to set up your database manually, don’t follow the instructions for
    Heroku add-on installation; otherwise, you’ll end up with multiple databases associated
    with your application.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 您有几种在 mLab 上设置数据库的方法。最快、最简单的方法是通过 Heroku 的附加组件。这里您将使用这种方法，但它确实要求您在 Heroku 上注册一张有效的信用卡。Heroku
    在您通过其生态系统使用附加组件时要求您这样做，以保护自己免受滥用行为。使用 mLab 的免费沙盒层不会产生任何费用。如果您不习惯使用信用卡直接通过 Heroku
    设置您的 mLab 数据库，请查看侧边栏“[手动设置 mLab](#ch05sb09)”以获取有关手动设置 mLab 数据库并将其连接到您的 Heroku
    应用程序的详细信息。如果您选择手动设置数据库，请勿遵循 Heroku 附加组件安装的说明；否则，您最终会拥有与您的应用程序关联的多个数据库。
- en: '|  |'
  id: totrans-1288
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Setting up mLab manually**'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动设置 mLab**'
- en: You don’t have to use the Heroku add-on system if you don’t want to. What you
    want to do is to set up a MongoDB database in the cloud and get a connection string
    for it.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用 Heroku 附加组件系统，您可以这样做。您想要做的是在云中设置一个 MongoDB 数据库，并获取其连接字符串。
- en: The mLab documentation can guide you through this process; see [https://docs.mlab.com](https://docs.mlab.com).
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: mLab 文档可以指导您完成此过程；请参阅[https://docs.mlab.com](https://docs.mlab.com)。
- en: In short, the steps are
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，步骤如下
- en: Sign up for a free account.
  id: totrans-1293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个免费账户。
- en: Create a new database (select Single Node, Sandbox for the free tier).
  id: totrans-1294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的数据库（对于免费层，选择单节点，沙盒）。
- en: Add a user.
  id: totrans-1295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个用户。
- en: Get the database URI (connection string).
  id: totrans-1296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取数据库 URI（连接字符串）。
- en: 'The connection string looks something like this:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串看起来可能如下所示：
- en: '[PRE151]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: All the parts will be different for you, of course, and you’ll have to swap
    out the username and password with what you specified in step 3.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些部分对于您来说都会有所不同，您将不得不将用户名和密码替换为步骤 3 中指定的内容。
- en: 'When you have your full connection string, you should save it as part of your
    Heroku configuration. With a terminal prompt in the root folder of your application,
    you can do this with the following command:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 当您拥有完整的连接字符串时，您应该将其保存为 Heroku 配置的一部分。在您的应用程序根目录的终端提示符下，您可以使用以下命令来完成此操作：
- en: '[PRE152]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Replace `your_db_uri` with your full connection string, including the `mongodb://`
    protocol. The quick and easy way automatically creates the `MLAB_URI` setting
    in your Heroku configuration. These manual steps bring you to the same point as
    the quick way, and you can jump back to the main text.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 将`your_db_uri`替换为包括`mongodb://`协议在内的完整连接字符串。快速且简单的方法会自动在Heroku配置中创建`MLAB_URI`设置。这些手动步骤将你带到与快速方法相同的位置，你可以跳回正文。
- en: '|  |'
  id: totrans-1303
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Adding the mLab add-on to the Heroku application
  id: totrans-1304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将mLab附加组件添加到Heroku应用程序中
- en: 'The quickest way to add mLab as a Heroku add-on is through terminal. Make sure
    that you’re in the root folder of your application, and run the following command
    (using mLab’s old name, MongoLab):'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过终端将mLab作为Heroku附加组件添加的最快方式是通过以下命令（使用mLab的旧名称MongoLab）：确保你在应用程序的根目录中，并运行以下命令：
- en: '[PRE153]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Unbelievably, that’s it! You have a MongoDB database ready and waiting for
    you in the cloud. You can prove this to yourself and open a web interface to this
    new database by using the following command:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 令人难以置信，就是这样！你已经在云端准备好并等待使用MongoDB数据库了。你可以通过以下命令来证明这一点并打开这个新数据库的Web界面：
- en: '[PRE154]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: To use the database, you’ll need to know its URI.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用数据库，你需要知道它的URI。
- en: Getting the database URI
  id: totrans-1310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取数据库URI
- en: You can get the full database URI by using the command line. This method gives
    you the full connection string that you can use in the application and also shows
    you the various components that you’ll need to push data up to the database.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过命令行获取完整的数据库URI。这种方法提供了你可以在应用程序中使用的完整连接字符串，同时也显示了你需要将数据推送到数据库的各种组件。
- en: The command to get the database URI is
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据库URI的命令是
- en: '[PRE155]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'This command outputs the full connection string, which looks something like
    this:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令输出完整的连接字符串，看起来像这样：
- en: '[PRE156]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Keep your version handy, as you’ll use it in the application soon. First, you
    need to break it down into its components.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 保留你的版本，因为你在应用程序中很快就会用到它。首先，你需要将其分解为其组成部分。
- en: Breaking down the URI into its components
  id: totrans-1317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将URI分解为其组成部分
- en: 'The URI looks like a random mess of characters, but you can break it down to
    make sense of it. From section [5.1.2](#ch05lev2sec2), you know that this is how
    a database URI is constructed:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: URI看起来像是一团乱码，但你可以将其分解以使其有意义。从[5.1.2](#ch05lev2sec2)部分，你知道这是数据库URI的构建方式：
- en: '![](Images/p0154-01_alt.jpg)'
  id: totrans-1319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/p0154-01_alt.jpg)'
- en: 'Taking the URI that mLab has given you, you can break it down into something
    like the following:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 将mLab提供的URI分解成类似以下的形式：
- en: '*Username*—`heroku_t0zs37gc`'
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户名*—`heroku_t0zs37gc`'
- en: '*Password*—`1k3t3pgo8sb5enovqd9sk314gj`'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密码*—`1k3t3pgo8sb5enovqd9sk314gj`'
- en: '*Server address*—`ds159330.mlab.com`'
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器地址*—`ds159330.mlab.com`'
- en: '*Port*—`59330`'
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*端口号*—`59330`'
- en: '*Database name*—`heroku_t0zs37gc`'
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库名称*—`heroku_t0zs37gc`'
- en: These examples are from the example URI. Yours will be different, of course,
    but make note of them; they’ll be useful.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例来自示例URI。当然，你的将会有所不同，但请注意它们；它们会很有用。
- en: 5.5.2\. Pushing up the data
  id: totrans-1327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2. 推送数据
- en: 'Now that you have an externally accessible database set up and know all the
    details for connecting to it, you can push data up to it. The steps are as follows:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了一个外部可访问的数据库，并且知道了连接到它的所有详细信息，你可以将数据推送到它。以下是步骤：
- en: Navigate to a directory on your machine that’s suitable to hold a data dump.
  id: totrans-1329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的机器上的一个目录，这个目录适合存放数据转储。
- en: Dump the data from your development Loc8r database.
  id: totrans-1330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的开发Loc8r数据库中转储数据。
- en: Restore the data to your live database.
  id: totrans-1331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据恢复到你的实时数据库。
- en: Test the live database.
  id: totrans-1332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试实时数据库。
- en: All these steps can be achieved quickly through terminal, so that’s what you’ll
    do. It saves jumping around between environments.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都可以通过终端快速完成，所以这就是你将要做的。这样可以避免在不同环境之间跳转。
- en: Navigate to a suitable directory
  id: totrans-1334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 导航到一个合适的目录
- en: When you run the data dump command from the command line, it creates a folder
    called /dump in the current directory and places the data dump inside it. The
    first step, then, is navigating in terminal to a suitable location on your hard
    drive. Your home directory or documents folder will do, or you can create a specific
    folder if you prefer.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行中运行数据转储命令时，它会在当前目录下创建一个名为/dump的文件夹，并将数据转储放在里面。因此，第一步是在终端导航到硬盘上的一个合适位置。你的主目录或文档文件夹都可以，或者如果你更喜欢，可以创建一个特定的文件夹。
- en: Dumping the data from the development database
  id: totrans-1336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从开发数据库中转储数据
- en: Dumping the data sounds like you’re deleting everything from your local development
    version, but this isn’t the case. The process is more an export than a trashing.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转储听起来像是您从本地开发版本中删除了所有内容，但这并不是情况。这个过程更像是导出而不是丢弃。
- en: 'The command used is `mongodump`, which can accept many parameters, of which
    you need these two:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的命令是`mongodump`，它可以接受许多参数，其中您需要这两个：
- en: '`-h`—The host server (and port)'
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`—主机服务器（和端口）'
- en: '`-d`—The database name'
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`—数据库名称'
- en: 'Putting it all together and using the default MongoDB port of `27017`, you
    should end up with a command like the following:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，并使用默认的MongoDB端口`27017`，您应该得到以下类似的命令：
- en: '[PRE157]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Run that command, and you have a temporary dump of the data.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令，您将有一个临时数据转储。
- en: Restoring the data to your live database
  id: totrans-1344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将数据恢复到您的实时数据库
- en: 'The process of pushing up the data to your live database is similar, this time
    using the `mongorestore` command. This command expects the following parameters:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据推送到您的实时数据库的过程类似，这次使用`mongorestore`命令。此命令期望以下参数：
- en: '`-h`—Live host and port'
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`—实时主机和端口'
- en: '`-d`—Live database name'
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`—实时数据库名称'
- en: '`-u`—Username for the live database'
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`—实时数据库用户名'
- en: '`-p`—Password for the live database'
  id: totrans-1349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`—实时数据库密码'
- en: Path to the dump directory and database name (comes at the end of the command
    and doesn’t have a corresponding flag like the other parameters)
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转储目录的路径和数据库名称（位于命令末尾，没有像其他参数那样的对应标志）
- en: 'Putting all this together, using the information you have about the database
    URI, you should have a command like the following:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，使用您关于数据库URI的信息，您应该得到以下类似的命令：
- en: '[PRE158]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Your command will look a bit different, of course, because you’ll have a different
    host, live database name, username, and password. When you run your `mongorestore`
    command, it pushes the data up from the data dump into your live database.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 您的命令将略有不同，当然，因为您将有一个不同的主机、实时数据库名称、用户名和密码。当您运行`mongorestore`命令时，它将数据转储中的数据推送到您的实时数据库。
- en: Testing the live database
  id: totrans-1354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试实时数据库
- en: The MongoDB shell isn’t restricted to accessing databases on your local machine.
    You can also use the shell to connect to external databases (if you have the right
    credentials, of course).
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB shell不仅限于访问本地机器上的数据库。您还可以使用shell连接到外部数据库（当然，如果您有正确的凭证的话）。
- en: 'To connect the MongoDB shell to an external database, you use the same `mongo`
    command but add information about the database you want to connect to. You need
    to include the hostname, port, and database names, and you can supply a username
    and password if required. Use the following construct:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 要将MongoDB shell连接到外部数据库，您使用相同的`mongo`命令，但添加您想要连接到的数据库的信息。您需要包括主机名、端口和数据库名称，如果需要，您还可以提供用户名和密码。使用以下结构：
- en: '[PRE159]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Using the setup you’ve been looking at in this section would give you this
    command:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您在本节中查看的设置，您将得到以下命令：
- en: '[PRE160]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: This command connects you to the database through the MongoDB shell. When the
    connection is established, you can use the commands you’ve already been using
    to interrogate it, such as
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通过MongoDB shell将您连接到数据库。当连接建立后，您可以使用您已经使用过的命令来查询它，例如
- en: '[PRE161]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Now you’ve got two databases and two connection strings. It’s important to use
    the right one at the right time.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有两个数据库和两个连接字符串。在正确的时间使用正确的一个是重要的。
- en: 5.5.3\. Making the application use the right database
  id: totrans-1363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3\. 使应用程序使用正确的数据库
- en: You have your original development database on your local machine plus your
    new live database up on mLab (or elsewhere). You want to keep using the development
    database while you’re developing your application, and you want the live version
    of your application to use the live database. Yet both use the same source code.
    [Figure 5.12](#ch05fig12) shows the issue.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本地机器上有原始的开发数据库，以及在上面的mLab（或其他地方）上的新实时数据库。您希望在开发应用程序时继续使用开发数据库，并且希望应用程序的实时版本使用实时数据库。然而，两者都使用相同的源代码。[图5.12](#ch05fig12)显示了问题。
- en: Figure 5.12\. The source code runs in two locations, each of which needs to
    connect to a different database.
  id: totrans-1365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.12。源代码在两个位置运行，每个位置都需要连接到不同的数据库。
- en: '![](Images/05fig12_alt.jpg)'
  id: totrans-1366
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12](Images/05fig12_alt.jpg)'
- en: You now have one set of source code running in two environments, each of which
    should use a different database. The way to handle this problem is through using
    a Node environment variable, `NODE_ENV`.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有一组源代码在两个环境中运行，每个环境都应该使用不同的数据库。处理此问题的方法是使用Node环境变量`NODE_ENV`。
- en: The NODE_ENV environment variable
  id: totrans-1368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: NODE_ENV 环境变量
- en: Environment variables affect the way the core process runs, and the one you’ll
    look at and use here is `NODE_ENV`. The application already uses `NODE_ENV`; you
    don’t see it exposed anywhere. By default, Heroku should set `NODE_ENV` to `production`
    so that the application will run in production mode on its server.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量会影响核心进程的运行方式，你将在这里查看并使用的是 `NODE_ENV`。应用程序已经使用了 `NODE_ENV`；你不会在任何地方看到它被暴露出来。默认情况下，Heroku
    应该将 `NODE_ENV` 设置为 `production`，这样应用程序就会在其服务器上以生产模式运行。
- en: '|  |'
  id: totrans-1370
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Ensuring Heroku is using production mode**'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '**确保 Heroku 使用生产模式**'
- en: 'In certain instances, depending on how the application was set up, the Heroku
    application may not be running in production mode. You can ensure that the Heroku
    environment variable is set correctly with the following terminal command:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据应用程序的设置方式，Heroku 应用程序可能不会以生产模式运行。你可以使用以下终端命令来确保 Heroku 环境变量设置正确：
- en: '[PRE162]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You can validate this setting by using a `get` version of this command, like
    so:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用此命令的 `get` 版本来验证此设置，如下所示：
- en: '[PRE163]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '|  |'
  id: totrans-1376
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can read `NODE_ENV` from anywhere in the application by using the following
    statement:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在应用程序的任何地方使用以下语句来读取 `NODE_ENV`：
- en: '[PRE164]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Unless specified in your environment, this statement comes back as `undefined`.
    You can specify different environment variables when starting the Node application
    by prepending the assignment to the launch command, as in this example:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的环境没有指定，此语句将返回 `undefined`。你可以通过在启动 Node 应用程序的命令前添加赋值来指定不同的环境变量，如下例所示：
- en: '[PRE165]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: This command starts the application in production mode, and the value of `process.env.NODE_ENV`
    is set to `production`.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以生产模式启动应用程序，并将 `process.env.NODE_ENV` 的值设置为 `production`。
- en: '|  |'
  id: totrans-1382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don’t set `NODE_ENV` from inside the application; only read it.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在应用程序内部设置 `NODE_ENV`；只需读取它。
- en: '|  |'
  id: totrans-1385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Setting the database URI based on the environment
  id: totrans-1386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 根据环境设置数据库 URI
- en: 'The database connection for your application is held in the db.js file in app_server/models.
    The connection portion of this file currently looks like this:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序的数据库连接存储在 `app_server/models` 文件夹中的 `db.js` 文件中。此文件中的连接部分目前看起来像这样：
- en: '[PRE166]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Changing the value of `dbURI` based on the current environment is as simple
    as using an `if` statement to check `NODE_ENV`. The next code snippet shows how
    you can do this to pass in your live MongoDB connection. Remember to use your
    own MongoDB connection string rather than the one in this example:'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前环境更改 `dbURI` 的值就像使用一个 `if` 语句来检查 `NODE_ENV` 一样简单。下面的代码片段展示了如何使用它来传递你的实时
    MongoDB 连接。请记住使用你自己的 MongoDB 连接字符串，而不是示例中的那个：
- en: '[PRE167]'
  id: totrans-1390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: If the source code is going to be in a public repository, you probably don’t
    want to give everybody the login credentials to your database. A way around this
    situation is to use an environment variable. With mLab on Heroku, you automatically
    have one set up; it’s how you originally got access to the connection string.
    (If you set up your mLab account manually, this variable is the Heroku configuration
    variable that you set.) If you’re using a different provider that hasn’t added
    anything to the Heroku configuration, you can add your URI with the `heroku config:set`
    command that you used to ensure that Heroku is running in production mode.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源代码将存储在公共仓库中，你可能不希望每个人都拥有你数据库的登录凭证。绕过这种情况的一种方法是用环境变量。在 Heroku 上的 mLab，你自动设置了一个；这是你最初获取连接字符串的方式。（如果你手动设置了
    mLab 账户，这个变量就是你在 Heroku 上设置的配置变量。）如果你使用的是没有添加任何内容的 Heroku 配置的不同提供商，你可以使用你之前用来确保
    Heroku 以生产模式运行的 `heroku config:set` 命令来添加你的 URI。
- en: 'The following code snippet shows how you can use the connection string set
    in the environment variables:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用在环境变量中设置的连接字符串：
- en: '[PRE168]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Now you can share your code, but only you retain access to your database credentials.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以分享你的代码，但只有你保留对数据库凭证的访问权限。
- en: Testing before launching
  id: totrans-1395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 发布前测试
- en: You can test this update to the code locally before pushing the code to Heroku
    by setting the environment variable as you start the application from terminal.
    The Mongoose connection events you set up earlier output a log to the console
    when the database connection is made, verifying the URI used.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码推送到 Heroku 之前，你可以在终端启动应用程序时设置环境变量来在本地测试此代码更新。你之前设置的 Mongoose 连接事件在数据库连接时会在控制台输出日志，验证所使用的
    URI。
- en: 'To do this, you need to add both the `NODE_ENV` and `MJONGODB_URI` environment
    variables in front of the nodemon command, like this (note that all of the following
    should be entered as one line):'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要在nodemon命令前添加`NODE_ENV`和`MJONGODB_URI`环境变量，如下所示（注意以下所有内容应作为一行输入）：
- en: '[PRE169]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Now your console log on startup should look like this:'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动时的控制台日志应该看起来像这样：
- en: '[PRE170]'
  id: totrans-1400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: When running this command, you’ll probably notice that the Mongoose connection
    confirmation takes longer to appear in the production environment, due to the
    latency of using a separate database server. This is why it’s a good idea to open
    the database connection at application startup and leave it open.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此命令时，你可能会注意到Mongoose连接确认在生产环境中出现得较慢，这是由于使用单独的数据库服务器导致的延迟。这就是为什么在应用程序启动时打开数据库连接并保持其打开状态是个好主意。
- en: Testing on Heroku
  id: totrans-1402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在Heroku上测试
- en: 'If your local tests are successful, and you can connect to your remote database
    by temporarily starting the application in production mode, you’re ready to push
    it up to Heroku. Use the same commands as normal to push the latest version of
    the code up:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的本地测试成功，并且你可以通过临时以生产模式启动应用程序来连接到远程数据库，那么你就可以将其推送到Heroku了。使用与正常相同的命令来推送代码的最新版本：
- en: '[PRE171]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Heroku lets you look at the latest 100 lines of logs by running a terminal
    command. You can check those logs to see the output of your console log messages,
    one of which will be your `Mongoose connected to` logs. To view the logs, run
    the following command in terminal:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku允许你通过运行终端命令查看最新的100行日志。你可以检查这些日志以查看控制台日志消息的输出，其中之一将是你的`Mongoose connected
    to`日志。要查看日志，请在终端中运行以下命令：
- en: '[PRE172]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'This command outputs the latest 100 rows to the terminal window, with the latest
    messages at the bottom. Scroll up until you find the `Mongoose connected to` message
    that looks something like this:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将最新的100行输出到终端窗口，最新的消息在底部。向上滚动，直到找到类似以下内容的`Mongoose connected to`消息：
- en: '[PRE173]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: When you see this message, you know that the live application on Heroku is connecting
    to your live database.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到这条消息时，你就知道Heroku上的实时应用程序正在连接到你的实时数据库。
- en: So that’s the data defined and modeled, and your Loc8r application is connected
    to the database. But you’re not interacting with the database at all yet. That
    comes next!
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是定义和建模的数据，你的Loc8r应用程序已连接到数据库。但你现在还没有与数据库进行任何交互。接下来就是了！
- en: '|  |'
  id: totrans-1411
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Get the source code**'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取源代码**'
- en: 'The source code of the application so far is available from GitHub on the chapter-05
    branch of the gettingMean-2 repository. In a fresh folder in terminal, enter the
    following commands to clone it and install the npm module dependencies:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的应用程序源代码可在GitHub上找到，位于gettingMean-2存储库的chapter-05分支。在终端的新文件夹中，输入以下命令以克隆它并安装npm模块依赖项：
- en: '[PRE174]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '|  |'
  id: totrans-1415
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In [chapter 6](kindle_split_017.xhtml#ch06), you’ll use Express to create a
    REST API so that you can access the database through web services.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_017.xhtml#ch06)中，你将使用Express创建一个REST API，以便通过Web服务访问数据库。
- en: Summary
  id: totrans-1417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学习了
- en: Some ways of connecting a MongoDB database to an Express application using Mongoose
  id: totrans-1419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些将MongoDB数据库连接到Express应用程序使用Mongoose的方法
- en: Best practices for managing Mongoose connections
  id: totrans-1420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理Mongoose连接的最佳实践
- en: How to model data using Mongoose schemas
  id: totrans-1421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Mongoose模式建模数据
- en: How schemas compile into models
  id: totrans-1422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式如何编译成模型
- en: Using the MongoDB shell to work directly with the database
  id: totrans-1423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB shell直接与数据库工作
- en: Pushing your database to a live URI
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库推送到实时URI
- en: Connecting to different databases from different environments
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的环境连接到不同的数据库
- en: 'Chapter 6\. Writing a REST API: Exposing the MongoDB database to the application'
  id: totrans-1426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 编写REST API：将MongoDB数据库暴露给应用程序
- en: '*This chapter covers*'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Examining the rules of REST APIs
  id: totrans-1428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查REST API的规则
- en: Evaluating API patterns
  id: totrans-1429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估API模式
- en: Handling typical CRUD functions (create, read, update, delete)
  id: totrans-1430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理典型的CRUD函数（创建、读取、更新、删除）
- en: Using Express and Mongoose to interact with MongoDB
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express和Mongoose与MongoDB交互
- en: Testing API endpoints
  id: totrans-1432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试API端点
- en: 'As you come into this chapter, you have a MongoDB database set up, but you
    can interact with it only through the MongoDB shell. During the course of this
    chapter, you’ll build a REST API so that you can interact with your database through
    HTTP calls and perform the common CRUD functions: create, read, update, and delete.'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进入本章时，你已经设置了MongoDB数据库，但你只能通过MongoDB shell与之交互。在本章的过程中，你将构建一个REST API，以便你可以通过HTTP调用与数据库交互并执行常见的CRUD功能：创建、读取、更新和删除。
- en: You’ll work mainly with Node and Express, using Mongoose to help with interactions.
    [Figure 6.1](#ch06fig01) shows where this chapter fits into the overall architecture.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 你将主要使用Node和Express，利用Mongoose来帮助进行交互。[图6.1](#ch06fig01)显示了本章在整个架构中的位置。
- en: Figure 6.1\. This chapter focuses on building the API that interacts with the
    database, exposing an interface for the applications to talk to.
  id: totrans-1435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 本章重点在于构建与数据库交互的API，为应用程序提供一个通信接口。
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-1436
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig01_alt.jpg)'
- en: You’ll start by looking at the rules of a REST API. We’ll discuss the importance
    of defining the URL structure properly, the different request methods (`GET`,
    `POST`, `PUT`, and `DELETE`) that should be used for different actions, and how
    an API should respond with data and an appropriate HTTP status code. When you
    have that knowledge under your belt, you’ll move on to building your API for Loc8r,
    covering all the typical CRUD operations. We’ll discuss Mongoose along the way
    and get into some Node programming and more Express routing.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从查看REST API的规则开始。我们将讨论正确定义URL结构的重要性，以及用于不同操作的不同的请求方法（`GET`、`POST`、`PUT`和`DELETE`），以及API应该如何响应数据和适当的HTTP状态码。当你掌握了这些知识后，你将开始构建Loc8r的API，涵盖所有典型的CRUD操作。我们将沿途讨论Mongoose，并涉及一些Node编程和更多的Express路由。
- en: '|  |'
  id: totrans-1438
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you haven’t yet built the application from [chapter 5](kindle_split_016.xhtml#ch05),
    you can get the code from GitHub on the chapter-05 branch at [https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2).
    In a fresh folder in terminal, enter the following commands to clone it and install
    the npm module dependencies:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有从[第5章](kindle_split_016.xhtml#ch05)构建应用程序，你可以从GitHub的chapter-05分支[https://github.com/cliveharber/gettingMean-2](https://github.com/cliveharber/gettingMean-2)获取代码。在终端的新文件夹中，输入以下命令以克隆它并安装npm模块依赖项：
- en: '[PRE175]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '|  |'
  id: totrans-1442
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1\. The rules of a REST API
  id: totrans-1443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. REST API的规则
- en: We’ll start with a recap of what makes a REST API. From [chapter 2](kindle_split_012.xhtml#ch02),
    you may remember that
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从回顾REST API的特点开始。从[第2章](kindle_split_012.xhtml#ch02)中，你可能还记得
- en: '*REST* stands for *REpresentational State Transfer*, which is an architectural
    style rather than a strict protocol. REST is stateless; it has no idea of any
    current user state or history.'
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*REST*代表*表示性状态转移*，这是一种架构风格，而不是严格的协议。REST是无状态的；它对任何当前用户状态或历史没有任何概念。'
- en: '*API* is an abbreviation for *application program interface*, which enables
    applications to talk to one another.'
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API*是*应用程序程序接口*的缩写，它使应用程序能够相互通信。'
- en: A REST API is a stateless interface to your application. In the case of the
    MEAN stack, the REST API is used to create a stateless interface to your database,
    enabling a way for other applications to work with the data.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: REST API是应用程序的无状态接口。在MEAN栈的情况下，REST API用于创建数据库的无状态接口，使其他应用程序能够与数据交互。
- en: REST APIs have an associated set of standards. Although you don’t have to stick
    to these standards for your own API, it’s generally best to, as it means that
    any API you create will follow the same approach. It also means that you’re used
    to doing things the “right” way if you decide that you’re going to make your API
    public.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: REST API有一套相关的标准。虽然你不必坚持这些标准来构建自己的API，但通常最好这样做，因为这意味着你创建的任何API都将遵循相同的方法。这也意味着如果你决定将你的API公开，你已经习惯了以“正确”的方式做事。
- en: In basic terms, a REST API takes an incoming HTTP request, does some processing,
    and always sends back an HTTP response, as shown in [figure 6.2](#ch06fig02).
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本术语中，REST API接收传入的HTTP请求，进行一些处理，并始终发送回一个HTTP响应，如图6.2所示。
- en: Figure 6.2\. A REST API takes incoming HTTP requests, does some processing,
    and returns HTTP responses.
  id: totrans-1450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. REST API接收传入的HTTP请求，进行一些处理，并返回HTTP响应。
- en: '![](Images/06fig02_alt.jpg)'
  id: totrans-1451
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig02_alt.jpg)'
- en: The standards that you’ll follow for Loc8r revolve around the requests and the
    responses.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 你将遵循Loc8r的标准围绕请求和响应。
- en: 6.1.1\. Request URLs
  id: totrans-1453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 请求URL
- en: Request URLs for a REST API have a simple standard. Following this standard
    makes your API easy to pick up, use, and maintain.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: REST API的请求URL有一个简单的标准。遵循这个标准可以使您的API易于理解、使用和维护。
- en: The way to approach this task is to start thinking about the collections in
    your database, as you’ll typically have a set of API URLs for each collection.
    You may also have a set of URLs for each set of subdocuments. Each URL in a set
    has the same basic path, and some may have additional parameters.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个任务的思路是开始考虑您的数据库中的集合，因为您通常为每个集合有一组API URL。您也可能为每组子文档有一组URL。集合中的每个URL都有相同的基本路径，其中一些可能有额外的参数。
- en: Within a set of URLs, you need to cover several actions, generally based on
    the standard CRUD operations. The common actions you’ll likely want are
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 在一组URL中，您需要涵盖几个操作，通常基于标准的CRUD操作。您可能希望执行的一些常见操作是
- en: Create a new item
  id: totrans-1457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: Read a list of several items
  id: totrans-1458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取多个项目的列表
- en: Read a specific item
  id: totrans-1459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取特定项目
- en: Update a specific item
  id: totrans-1460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新特定项目
- en: Delete a specific item
  id: totrans-1461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除特定项目
- en: Using Loc8r as an example, the database has a Locations collection that you
    want to interact with. [Table 6.1](#ch06table01) shows how the URL paths might
    look for this collection. Note that all URLs have the same base path and, where
    used, have the same location ID parameter.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 以Loc8r为例，数据库中有一个位置集合，您希望与之交互。[表6.1](#ch06table01)展示了该集合的URL路径可能的样子。请注意，所有URL都有相同的基路径，并且在使用时，都有相同的地理位置ID参数。
- en: Table 6.1\. URL paths and parameters for an API to the Locations collection
  id: totrans-1463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1\. 位置集合API的URL路径和参数
- en: '| Action | URL path | Example |'
  id: totrans-1464
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | URL路径 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-1465
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create new location | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
  id: totrans-1466
  prefs: []
  type: TYPE_TB
  zh: '| 创建新位置 | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
- en: '| Read list of locations | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
  id: totrans-1467
  prefs: []
  type: TYPE_TB
  zh: '| 读取位置列表 | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
- en: '| Read a specific location | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1468
  prefs: []
  type: TYPE_TB
  zh: '| 读取特定位置 | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '| Update a specific location | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1469
  prefs: []
  type: TYPE_TB
  zh: '| 更新特定位置 | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '| Delete a specific location | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1470
  prefs: []
  type: TYPE_TB
  zh: '| 删除特定位置 | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: 'As you can see from [table 6.1](#ch06table01), each action has the same URL
    path, and three of them expect the same parameter to specify a location. This
    situation poses an obvious question: how do you use the same URL to initiate different
    actions? The answer lies in request methods.'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表6.1](#ch06table01)所示，每个操作都有相同的URL路径，其中三个操作期望相同的参数来指定位置。这种情况提出了一个明显的问题：您如何使用相同的URL来启动不同的操作？答案在于请求方法。
- en: 6.1.2\. Request methods
  id: totrans-1472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 请求方法
- en: HTTP requests can have different methods that essentially tell the server what
    type of action to take. The most common type of request is a `GET` request—the
    method used when you enter a URL in the address bar of your browser. Another common
    method is `POST`, often used for submitting form data.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求可以有不同方法，这些方法本质上告诉服务器执行什么类型的操作。最常见的一种请求是`GET`请求——这是您在浏览器地址栏中输入URL时使用的方法。另一种常见的方法是`POST`，通常用于提交表单数据。
- en: '[Table 6.2](#ch06table02) shows the methods you’ll be using in your API, their
    typical use cases, and what you’d expect to be returned.'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6.2](#ch06table02)展示了您在API中将使用的各种方法、它们的典型用途以及您期望返回的内容。'
- en: Table 6.2\. Four request methods used in a REST API
  id: totrans-1475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.2\. REST API中使用的四种请求方法
- en: '| Request method | Use | Response |'
  id: totrans-1476
  prefs: []
  type: TYPE_TB
  zh: '| 请求方法 | 用途 | 响应 |'
- en: '| --- | --- | --- |'
  id: totrans-1477
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| POST | Create new data in the database | New data object as seen in the database
    |'
  id: totrans-1478
  prefs: []
  type: TYPE_TB
  zh: '| POST | 在数据库中创建新数据 | 数据库中看到的新数据对象 |'
- en: '| GET | Read data from the database | Data object answering the request |'
  id: totrans-1479
  prefs: []
  type: TYPE_TB
  zh: '| GET | 从数据库读取数据 | 响应请求的数据对象 |'
- en: '| PUT | Update a document in the database | Updated data object as seen in
    the database |'
  id: totrans-1480
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 更新数据库中的文档 | 数据库中看到已更新的数据对象 |'
- en: '| DELETE | Delete an object from the database | Null |'
  id: totrans-1481
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | 从数据库中删除对象 | Null |'
- en: The four HTTP methods that you’ll use are `POST`, `GET`, `PUT,` and `DELETE`.
    If you look at the corresponding entries in the Use column, you’ll notice that
    each method performs a different CRUD operation.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用的四种 HTTP 方法是 `POST`、`GET`、`PUT` 和 `DELETE`。如果您查看 Use 列中的相应条目，您会注意到每种方法都执行不同的
    CRUD 操作。
- en: The method is important, because a well-designed REST API often has the same
    URL for different actions. In these cases, the method tells the server which type
    of operation to perform. We’ll discuss how to build and organize the routes for
    methods in Express later in this chapter.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 方法很重要，因为设计良好的 REST API 通常对于不同的操作具有相同的 URL。在这些情况下，方法告诉服务器执行哪种类型的操作。我们将在本章后面讨论如何在
    Express 中构建和组织方法的路由。
- en: If you take the paths and parameters and map across the appropriate request
    method, you can put together a plan for your API, as shown in [table 6.3](#ch06table03).
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将路径和参数映射到适当的请求方法，您可以为您的 API 制定一个计划，如 [表 6.3](#ch06table03) 所示。
- en: Table 6.3\. Request methods that link URLs to the desired actions, enabling
    the API to use the same URL for different actions
  id: totrans-1485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.3\. 将 URL 与所需操作链接的请求方法，使 API 能够使用相同的 URL 执行不同的操作
- en: '| Action | Method | URL path | Example |'
  id: totrans-1486
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 方法 | URL 路径 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1487
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Create new location | POST | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
  id: totrans-1488
  prefs: []
  type: TYPE_TB
  zh: '| 创建新位置 | POST | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
- en: '| Read list of locations | GET | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
  id: totrans-1489
  prefs: []
  type: TYPE_TB
  zh: '| 读取位置列表 | GET | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
- en: '| Read a specific location | GET | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1490
  prefs: []
  type: TYPE_TB
  zh: '| 读取特定位置 | GET | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '| Update a specific location | PUT | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1491
  prefs: []
  type: TYPE_TB
  zh: '| 更新特定位置 | PUT | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '| Delete a specific location | DELETE | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1492
  prefs: []
  type: TYPE_TB
  zh: '| 删除特定位置 | DELETE | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '[Table 6.3](#ch06table03) shows the paths and methods you’ll use for the requests
    to interact with the location data. There are five actions but only two URL patterns,
    so you can use the request methods to get the desired results.'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6.3](#ch06table03) 展示了您将用于与位置数据交互的路径和方法。有五个操作，但只有两种 URL 模式，因此您可以使用请求方法来获取所需的结果。'
- en: Loc8r only has one collection right now, so this is your starting point. But
    the documents in the Locations collection do have reviews as subdocuments, so
    you’ll quickly map them out too.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: Loc8r 目前只有一个集合，因此这是您的起点。但 Locations 集合中的文档确实有作为子文档的评论，所以您也会很快将它们映射出来。
- en: Subdocuments are treated in a similar way but require an additional parameter.
    Each request needs to specify the ID of the location, and some requests also need
    to specify the ID of a review. [Table 6.4](#ch06table04) shows the list of actions
    and their associated methods, URL paths, and parameters.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 子文档的处理方式类似，但需要额外的参数。每个请求都需要指定位置的 ID，某些请求还需要指定评论的 ID。[表 6.4](#ch06table04) 展示了操作列表及其相关的方法、URL
    路径和参数。
- en: Table 6.4\. URL specifications for interacting with subdocuments; each base
    URL path must contain the ID of the parent document
  id: totrans-1496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.4\. 与子文档交互的 URL 规范；每个基本 URL 路径都必须包含父文档的 ID
- en: '| Action | Method | URL path | Example |'
  id: totrans-1497
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 方法 | URL 路径 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1498
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Create new review | POST | /locations/:locationid/reviews | [http://loc8r.com/api/locations/123/reviews](http://loc8r.com/api/locations/123/reviews)
    |'
  id: totrans-1499
  prefs: []
  type: TYPE_TB
  zh: '| 创建新评论 | POST | /locations/:locationid/reviews | [http://loc8r.com/api/locations/123/reviews](http://loc8r.com/api/locations/123/reviews)
    |'
- en: '| Read a specific review | GET | /locations/:locationid/reviews/:reviewid |
    [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
  id: totrans-1500
  prefs: []
  type: TYPE_TB
  zh: '| 读取特定评论 | GET | /locations/:locationid/reviews/:reviewid | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
- en: '| Update a specific review | PUT | /locations/:locationid/reviews/:reviewid
    | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
  id: totrans-1501
  prefs: []
  type: TYPE_TB
  zh: '| 更新特定评论 | PUT | /locations/:locationid/reviews/:reviewid | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
- en: '| Delete a specific review | DELETE | /locations/:locationid/reviews/:reviewid
    | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
  id: totrans-1502
  prefs: []
  type: TYPE_TB
  zh: '| 删除特定评论 | DELETE | /locations/:locationid/reviews/:reviewid | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
- en: You may have noticed that for the subdocuments, you don’t have a “read a list
    of reviews” action, because you’ll be retrieving the list of reviews as part of
    the main document. The preceding tables should give you an idea of how to create
    basic API request specifications. The URLs, parameters, and actions will be different
    from one application to the next, but the approach should remain consistent.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，对于子文档，你没有“读取评论列表”的操作，因为你将作为主文档的一部分检索评论列表。前面的表格应该给你一个如何创建基本的API请求规范的想法。URL、参数和操作将因应用程序而异，但方法应该保持一致。
- en: That’s the story on requests. The other half of the flow, before you get stuck
    in some code, is responses.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是关于请求的故事。流程的另一部分，在你陷入某些代码之前，是响应。
- en: 6.1.3\. Responses and status codes
  id: totrans-1505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 响应和状态码
- en: A good API is like a good friend. If you go for a high five, a good friend won’t
    leave you hanging. The same goes for a good API. If you make a request, a good
    API always responds and doesn’t leave you hanging. Every single API request should
    return a response. The contrast between a good API and a bad one is shown in [figure
    6.3](#ch06fig03).
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的API就像一个好的朋友。如果你去击掌，一个好的朋友不会让你感到无助。同样的，一个好的API。如果你发起一个请求，一个好的API总是响应，不会让你感到无助。每个API请求都应该返回一个响应。好的API和坏的API之间的对比在[图6.3](#ch06fig03)中展示。
- en: Figure 6.3\. A good API always returns a response and shouldn’t leave you hanging.
  id: totrans-1507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 一个好的API总是返回响应，不应该让你感到无助。
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-1508
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig03_alt.jpg)'
- en: 'For a successful REST API, standardizing the responses is as important as standardizing
    the request format. There are two key components to a response:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个成功的REST API，标准化响应与标准化请求格式一样重要。响应有两个关键组成部分：
- en: The returned data
  id: totrans-1510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的数据
- en: The HTTP status code
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: Combining the returned data with the appropriate status code should give the
    requester all the information required to continue.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回的数据与适当的状态码结合起来，应该给请求者提供所有继续所需的信息。
- en: Returning data from an API
  id: totrans-1513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从API返回数据
- en: Your API should return a consistent data format. Typical formats for a REST
    API are XML and/or JSON. You’ll use JSON for your API, because it’s the natural
    fit for the MEAN stack. MongoDB outputs JSON, which Node and Angular can both
    natively understand. JSON is, after all, the JavaScript way of transporting data.
    JSON is also more compact than XML, so it can help speed the response times and
    efficiency of an API by reducing the bandwidth required.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API应该返回一致的数据格式。REST API的典型格式是XML和/或JSON。你将使用JSON作为你的API，因为它与MEAN栈是天然的匹配。MongoDB输出JSON，Node和Angular都可以原生理解。毕竟，JSON是JavaScript传输数据的方式。JSON也比XML更紧凑，因此可以通过减少所需的带宽来帮助提高API的响应时间和效率。
- en: 'Your API will return one of three things for each request:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API将为每个请求返回三件事之一：
- en: A JSON object containing data answering the request query
  id: totrans-1516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含响应查询数据的JSON对象
- en: A JSON object containing error data
  id: totrans-1517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含错误数据的JSON对象
- en: A null response
  id: totrans-1518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空响应
- en: During this chapter, we’ll discuss how to do all these things as you build the
    Loc8r API. As well as responding with data, a REST API should return the correct
    HTTP status code.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何在构建Loc8r API的过程中完成所有这些事情。除了响应数据外，REST API还应返回正确的HTTP状态码。
- en: Using HTTP status codes
  id: totrans-1520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用HTTP状态码
- en: A good REST API should return the correct HTTP status code. The status code
    most people are familiar with is 404, which is what a web server returns when
    a user requests a page that can’t be found. This error code is probably the most
    prevalent one on the internet, but there are dozens of other codes, relating to
    client errors, server errors, redirections, and successful requests. [Table 6.5](#ch06table05)
    shows the 10 most popular HTTP status codes and where they might be useful for
    building an API.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的REST API应该返回正确的HTTP状态码。大多数人熟悉的状态码是404，这是当用户请求一个找不到的页面时，Web服务器返回的状态码。这个错误码可能是互联网上最普遍的一个，但还有几十个其他的状态码，它们与客户端错误、服务器错误、重定向和成功请求有关。[表6.5](#ch06table05)显示了10个最受欢迎的HTTP状态码以及它们在构建API时可能的有用之处。
- en: Table 6.5\. Most popular HTTP status codes and how they might be used to send
    responses to an API request
  id: totrans-1522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.5\. 最受欢迎的HTTP状态码及其可能用于向API请求发送响应的方式
- en: '| Status code | Name | Use case |'
  id: totrans-1523
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 名称 | 用例 |'
- en: '| --- | --- | --- |'
  id: totrans-1524
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 200 | OK | A successful GET or PUT request |'
  id: totrans-1525
  prefs: []
  type: TYPE_TB
  zh: '| 200 | OK | 成功的 GET 或 PUT 请求 |'
- en: '| 201 | Created | A successful POST request |'
  id: totrans-1526
  prefs: []
  type: TYPE_TB
  zh: '| 201 | 已创建 | 成功的 POST 请求 |'
- en: '| 204 | No content | A successful DELETE request |'
  id: totrans-1527
  prefs: []
  type: TYPE_TB
  zh: '| 204 | 无内容 | 成功的 DELETE 请求 |'
- en: '| 400 | Bad request | An unsuccessful GET, POST, or PUT request due to invalid
    content |'
  id: totrans-1528
  prefs: []
  type: TYPE_TB
  zh: '| 400 | 错误请求 | 由于内容无效而导致的 GET、POST 或 PUT 请求失败 |'
- en: '| 401 | Unauthorized | Requesting a restricted URL with incorrect credentials
    |'
  id: totrans-1529
  prefs: []
  type: TYPE_TB
  zh: '| 401 | 未授权 | 使用不正确的凭据请求受限制的 URL |'
- en: '| 403 | Forbidden | Making a request that isn’t allowed |'
  id: totrans-1530
  prefs: []
  type: TYPE_TB
  zh: '| 403 | 禁止 | 进行不允许的请求 |'
- en: '| 404 | Not found | Unsuccessful request due to an incorrect parameter in the
    URL |'
  id: totrans-1531
  prefs: []
  type: TYPE_TB
  zh: '| 404 | 未找到 | 由于 URL 参数错误而导致的请求失败 |'
- en: '| 405 | Method not allowed | Request method not allowed for the given URL |'
  id: totrans-1532
  prefs: []
  type: TYPE_TB
  zh: '| 405 | 不允许的方法 | 对于给定的 URL 不允许请求方法 |'
- en: '| 409 | Conflict | Unsuccessful POST request when another object with the same
    data already exists |'
  id: totrans-1533
  prefs: []
  type: TYPE_TB
  zh: '| 409 | 冲突 | 当存在具有相同数据的另一个对象时，POST 请求失败 |'
- en: '| 500 | Internal server error | Problem with your server or the database server
    |'
  id: totrans-1534
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 内部服务器错误 | 服务器或数据库服务器出现问题 |'
- en: As you go through this chapter and build the Loc8r API, you’ll use several of
    these status codes while returning the appropriate data.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读本章并构建 Loc8r API 时，你将使用这些状态码中的几个来返回适当的数据。
- en: 6.2\. Setting up the API in Express
  id: totrans-1536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2. 设置 Express 中的 API
- en: You’ve already got a good idea about the actions you want your API to perform
    and the URL paths needed to do so. As you know from [chapter 4](kindle_split_015.xhtml#ch04),
    to get Express to do something based on an incoming URL request, you need to set
    up controllers and routes. The controllers do the action, and the routes map the
    incoming requests to the appropriate controllers.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经对 API 需要执行的操作和执行这些操作所需的 URL 路径有了很好的了解。正如你在 [第 4 章](kindle_split_015.xhtml#ch04)
    中所知，为了使 Express 根据传入的 URL 请求执行某些操作，你需要设置控制器和路由。控制器执行操作，而路由将传入的请求映射到适当的控制器。
- en: You have files for routes and controllers already set up in the application,
    so you could use those. A better option, though, is to keep the API code separate
    so that you don’t run the risk of confusion and complication in your application.
    In fact, this is one of the reasons for creating an API in the first place. Also,
    keeping the API code separate makes it easier to strip it out and put it into
    a separate application at a future point, should you choose to do so. You do want
    easy decoupling here.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在应用程序中为路由和控制器设置了文件，所以你可以使用这些文件。然而，更好的选择是将 API 代码保持独立，这样你就不必担心应用程序中的混淆和复杂化。实际上，这是创建
    API 的原因之一。此外，将 API 代码保持独立使得在未来某个时刻将其剥离并放入一个单独的应用程序中变得更加容易。你确实希望实现轻松解耦。
- en: The first thing you want to do is create a separate area inside the application
    for the files that will create the API. At the top level of the application, create
    a new folder called app_api. If you’ve been following along and building up the
    application as you go, this folder sits alongside the app_server folder.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要做的第一件事是在应用程序中为创建 API 的文件创建一个单独的区域。在应用程序的顶层，创建一个名为 app_api 的新文件夹。如果你一直在跟随并构建应用程序，则此文件夹位于
    app_server 文件夹旁边。
- en: 'This folder holds everything specific to the API: routes, controllers, and
    models. When you’ve got everything set up, take a look at some ways to test these
    API placeholders.'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含与 API 相关的所有特定内容：路由、控制器和模型。当你设置好一切后，看看一些测试这些 API 占位符的方法。
- en: 6.2.1\. Creating the routes
  id: totrans-1541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1. 创建路由
- en: As you did with the routes for the main Express application, you’ll have an
    index.js file in the app_api/routes folder that will hold all the routes you’ll
    use in the API. Start by referencing this file in the main application file app.js.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在主 Express 应用程序的路由中做的那样，你将在 app_api/routes 文件夹中有一个 index.js 文件，它将包含你将在 API
    中使用的所有路由。首先，在主应用程序文件 app.js 中引用此文件。
- en: Including the routes in the application
  id: totrans-1543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在应用程序中包含路由
- en: 'The first step is telling your application that you’re adding more routes to
    look out for and when it should use them. You can duplicate a line in app.js to
    `require` the server application routes, and set the path to the API routes as
    follows:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是告诉你的应用程序你正在添加更多需要关注的路由，以及何时应该使用它们。你可以在 app.js 中复制一行来 `require` 服务器应用程序的路由，并将路径设置为
    API 路由，如下所示：
- en: '[PRE176]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'You may also have a line in app.js that still brings the example `user` routes.
    You can delete this now, if so, because you don’t need it. Next, you need to tell
    the application when to use the routes. You currently have the following line
    in app.js telling the application to check the server application routes for all
    incoming requests:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在app.js中还有一行代码，仍然包含示例`user`路由。如果你有的话，现在可以删除它，因为你不需要它。接下来，你需要告诉应用程序何时使用这些路由。你目前在app.js中有以下行，告诉应用程序检查服务器应用程序路由以处理所有传入的请求：
- en: '[PRE177]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Notice the `''/''` as the first parameter. This parameter enables you to specify
    a subset of URLs for which the routes will apply. You’ll define all your API routes
    starting with /api/. By adding the line shown in the following code snippet, you
    can tell the application to use the API routes only when the route starts with
    /api:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一个参数是`'/'`。这个参数允许你指定一个子集的URL，对于这些URL，路由将适用。你将定义所有以/api/开头的API路由。通过添加以下代码片段中显示的行，你可以告诉应用程序仅在路由以/api/开头时使用API路由：
- en: '[PRE178]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: As before, you can delete the similar line for `user` routes if it’s there.
    Now it’s time to set up these URLs.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你有，可以删除类似的`user`路由行。现在，是时候设置这些URL了。
- en: Specifying the request methods in the routes
  id: totrans-1551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在路由中指定请求方法
- en: 'Up to now, you’ve used only the `GET` method in the routes, as in the following
    code snippet from your main application routes:'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只在路由中使用了`GET`方法，如你的主应用程序路由中的以下代码片段所示：
- en: '[PRE179]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Using the other methods—`POST`, `PUT`, and `DELETE`—is as simple as switching
    the `get` with the respective keywords `post`, `put`, and `delete`. The following
    code snippet shows an example using the `POST` method which creates a new location:'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他方法——`POST`、`PUT`和`DELETE`——就像将`get`与相应的关键字`post`、`put`和`delete`交换一样简单。以下代码片段展示了使用`POST`方法创建新位置的示例：
- en: '[PRE180]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Note that you don’t specify /api at the front of the path. You specify in app.js
    that these routes should be used only if the path starts with /api, so it’s assumed
    that all routes specified in this file are prefixed with /api.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不需要在路径的开头指定/api。你在app.js中指定，只有当路径以/api开头时才使用这些路由，因此假设此文件中指定的所有路由都带有/api前缀。
- en: Specifying Required URL parameters
  id: totrans-1557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指定必需的URL参数
- en: It’s common for API URLs to contain parameters for identifying specific documents
    or subdocuments—locations and reviews, in the case of Loc8r. Specifying these
    parameters in routes is simple; you prefix the name of the parameter with a colon
    when defining each route.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: API URL中包含用于识别特定文档或子文档的参数是很常见的——在Loc8r的情况下，这些参数是位置和评论。在路由中指定这些参数很简单；在定义每个路由时，你只需在参数名称前加上冒号即可。
- en: 'Suppose that you’re trying to access a review with the ID `abc` that belongs
    to a location with the ID `123`. You’d have a URL path like this:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在尝试访问一个ID为`abc`的评论，该评论属于ID为`123`的位置。你的URL路径可能如下所示：
- en: '[PRE181]'
  id: totrans-1560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Swapping out the IDs for the parameter names (with a colon prefix) gives you
    a path like this:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 将ID替换为参数名称（带有冒号前缀）给出如下路径：
- en: '[PRE182]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: With a path like this, Express matches only URLs that match that pattern. So
    a location ID must be specified and must be in the URL between locations/ and
    /reviews. Also, a review ID must be specified at the end of the URL. When a path
    like this is assigned to a controller, the parameters will be available to use
    in the code, with the names specified in the path (`locationid` and `reviewid`,
    in this case).
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的路径，Express只会匹配匹配该模式的URL。因此，必须指定位置ID，并且它必须在URL中的locations/和/reviews之间。同样，必须在URL的末尾指定评论ID。当将这样的路径分配给控制器时，参数将在代码中使用，其名称由路径指定（在本例中为`locationid`和`reviewid`）。
- en: We’ll review exactly how you get to them in a moment, but first, you need to
    set up the routes for your Loc8r API.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后详细说明如何访问它们，但首先，你需要设置Loc8r API的路由。
- en: Defining the Loc8r API routes
  id: totrans-1565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义Loc8r API路由
- en: Now you know how to set up routes to accept parameters, and you also know what
    actions, methods, and paths you want to have in your API. You can combine all
    this knowledge to create the route definitions for the Loc8r API.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何设置路由以接受参数，你也知道你想要在API中拥有的操作、方法和路径。你可以结合所有这些知识来创建Loc8r API的路由定义。
- en: If you haven’t done so yet, you should create an index.js file in the app_api/routes
    folder. To keep the sizes of individual files under control, separate the locations
    and reviews controllers into different files.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，你应该在app_api/routes文件夹中创建一个index.js文件。为了控制单个文件的大小，将位置和评论控制器分别放入不同的文件中。
- en: You’ll also use a slightly different way of defining routes in Express, which
    is ideal for managing multiple methods on a single route. With this approach,
    you define the route first and then chain on the different HTTP methods. This
    process streamlines route definitions, making them much easier to read.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将使用一种在 Express 中定义路由的不同方法，这对于管理单个路由上的多个方法非常理想。使用这种方法，您首先定义路由，然后链式连接不同的 HTTP
    方法。这个过程简化了路由定义，使它们更容易阅读。
- en: The following listing shows how the defined routes should look.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了定义的路由应该如何看起来。
- en: Listing 6.1\. Routes defined in app_api/routes/index.js
  id: totrans-1570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 在 app_api/routes/index.js 中定义的路由
- en: '[PRE183]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '***1*** **Includes controller files. (You’ll create these next.)**'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **包含控制器文件。（您将在下面创建这些。）**'
- en: '***2*** **Defines routes for locations**'
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为位置定义路由**'
- en: '***3*** **Defines routes for reviews**'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **为评论定义路由**'
- en: '***4*** **Exports routes**'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **导出路由**'
- en: In this router file, you need to `require` the related controller files. You
    haven’t created these controller files yet and will do so in a moment. This method
    is a good way to approach it, because by defining all the routes and declaring
    the associated controller functions here, you develop a high-level view of what
    controllers are needed.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 在此路由文件中，您需要 `require` 相关的控制器文件。您尚未创建这些控制器文件，将在稍后创建。这种方法是一个很好的方法，因为通过在这里定义所有路由并声明相关的控制器函数，您可以开发一个控制器所需的高级视图。
- en: 'The application now has two sets of routes: the main Express application routes
    and the new API routes. The application won’t start at the moment, though, because
    none of the controllers referenced by the API routes exists.'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在有两组路由：主 Express 应用程序路由和新的 API 路由。但是，由于 API 路由引用的任何控制器都不存在，应用程序目前无法启动。
- en: 6.2.2\. Creating the controller placeholders
  id: totrans-1578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 创建控制器占位符
- en: To enable the application to start, you can create placeholder functions for
    the controllers. These functions won’t do anything, but they stop the application
    from falling over while you’re building the API functionality.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序能够启动，您可以创建控制器的占位符函数。这些函数不会做任何事情，但它们会阻止应用程序在构建 API 功能时崩溃。
- en: The first step, of course, is creating the controller files. You know where
    these files should be and what they should be called because you’ve already declared
    them in the app_api/routes folder. You need two new files called locations.js
    and reviews.js in the app_api/controllers folder.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，第一步是创建控制器文件。您知道这些文件应该在何处以及它们应该被称为什么，因为您已经在 app_api/routes 文件夹中声明了它们。您需要在
    app_api/controllers 文件夹中创建两个新文件，分别命名为 locations.js 和 reviews.js。
- en: 'You can create a placeholder for each of the controller functions as an empty
    function, as in the following code snippet:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为每个控制器函数创建一个占位符，作为一个空函数，如下代码片段所示：
- en: '[PRE184]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Remember to put each controller in the correct file, depending on whether it’s
    for a location or a review, and export them at the bottom of the files, as in
    this example:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，根据它是用于位置还是评论，将每个控制器放入正确的文件，并在文件底部导出它们，如下例所示：
- en: '[PRE185]'
  id: totrans-1584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: To test the routing and the functions, though, you need to return a response.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了测试路由和函数，您需要返回一个响应。
- en: 6.2.3\. Returning JSON from an Express request
  id: totrans-1586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 从 Express 请求返回 JSON
- en: 'When building the Express application, you rendered a view template to send
    HTML to the browser, but with an API, you instead want to send a status code and
    some JSON data. Express makes this task easy with the following lines:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Express 应用程序时，您渲染了一个视图模板以将 HTML 发送到浏览器，但使用 API，您希望发送一个状态码和一些 JSON 数据。Express
    通过以下行使这项任务变得简单：
- en: '[PRE186]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '***1*** **Uses the Express response object**'
  id: totrans-1589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 Express 响应对象**'
- en: '***2*** **Sends response status code, such as 200**'
  id: totrans-1590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **发送响应状态码，例如 200**'
- en: '***3*** **Sends response data, such as {“status” : “success”}**'
  id: totrans-1591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **发送响应数据，例如 {“status” : “success”}**'
- en: 'You can use these two commands in the placeholder functions to test the success,
    as shown in the following code snippet:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下两个命令在占位符函数中测试成功，如下代码片段所示：
- en: '[PRE187]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: As you build up your API, you’ll use this method a lot to send different status
    codes and data as the response.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您构建您的 API，您将大量使用此方法来发送不同的状态码和数据作为响应。
- en: 6.2.4\. Including the model
  id: totrans-1595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.4\. 包含模型
- en: 'It’s vitally important that the API can talk to the database; without it, the
    API isn’t going to be of much use! To do this with Mongoose, you first need to
    `require` Mongoose into the controller files and then bring in the `Location`
    model. Right at the top of the controller files, above all the placeholder functions,
    add the following two lines:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: API 能够与数据库通信至关重要；没有它，API 将不会有多大用处！要使用 Mongoose 实现这一点，你首先需要将 Mongoose `require`
    到控制器文件中，然后引入 `Location` 模型。在控制器文件的最顶部，在所有占位符函数之上，添加以下两行：
- en: '[PRE188]'
  id: totrans-1597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The first line gives the controllers access to the database connection, and
    the second brings in the `Location` model so that you can interact with the Locations
    collection.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行给控制器提供了数据库连接的访问权限，第二行引入了 `Location` 模型，这样你就可以与 Locations 集合进行交互。
- en: If you take a look at the file structure of your application, you see the /models
    folder containing the database connection, and the Mongoose setup is inside the
    app_server folder. But it’s the API that’s dealing with the database, not the
    main Express application. If the two applications were separate, the model would
    be kept part of the API, so that’s where it should live.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看应用程序的文件结构，你会看到包含数据库连接的 /models 文件夹，Mongoose 设置在 app_server 文件夹内。但处理数据库的是
    API，而不是主要的 Express 应用程序。如果两个应用程序是分开的，模型将保留在 API 中，所以它应该在那里。
- en: Move the /models folder from the app_server folder into the app_api folder,
    creating a folder structure like that shown in [figure 6.4](#ch06fig04).
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 将 /models 文件夹从 app_server 文件夹移动到 app_api 文件夹，创建一个类似于 [图 6.4](#ch06fig04) 中所示的文件夹结构。
- en: Figure 6.4\. Folder structure of the application at this point. app_api has
    models, controllers, and routes, and app_server has views, controllers, and routes.
  id: totrans-1601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.4. 此时的应用程序文件夹结构。app_api 包含模型、控制器和路由，而 app_server 包含视图、控制器和路由。
- en: '![](Images/06fig04.jpg)'
  id: totrans-1602
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig04.jpg)'
- en: 'You need to tell the application that you’ve moved the app_api/models folder,
    of course, so you need to update the line in app.js that requires the model to
    point to the correct place:'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要告诉应用程序你已经移动了 app_api/models 文件夹，因此需要更新 app.js 中指向模型的行，使其指向正确的位置：
- en: '[PRE189]'
  id: totrans-1604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: With that done, the application should start again and still connect to your
    database. The next question is how to test the API.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，应用程序应该再次启动并仍然连接到你的数据库。接下来要问的问题是如何测试 API。
- en: 6.2.5\. Testing the API
  id: totrans-1606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.5. 测试 API
- en: You can test the `GET` routes in your browser quickly by heading to the appropriate
    URL, such as http://localhost:3000/api/locations/1234\. You should see the success
    response being delivered to the browser, as shown in [figure 6.5](#ch06fig05).
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问适当的 URL，例如 http://localhost:3000/api/locations/1234，快速在浏览器中测试 `GET` 路由。你应该看到成功响应被发送到浏览器，如图
    [图 6.5](#ch06fig05) 所示。
- en: Figure 6.5\. Testing a `GET` request of the API in the browser
  id: totrans-1608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.5. 在浏览器中测试 API 的 `GET` 请求
- en: '![](Images/06fig05_alt.jpg)'
  id: totrans-1609
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig05_alt.jpg)'
- en: This is okay for testing `GET` requests, but it doesn’t get you far with the
    `POST`, `PUT`, and `DELETE` methods. A few tools can help you test API calls like
    this, but our current favorite is a free application called Postman REST Client,
    available as a standalone application or browser extension.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于测试 `GET` 请求是可行的，但对于 `POST`、`PUT` 和 `DELETE` 方法帮助不大。一些工具可以帮助你测试这样的 API 调用，但我们目前最喜欢的免费应用程序是
    Postman REST 客户端，它可以作为独立应用程序或浏览器扩展使用。
- en: Postman enables you to test API URLs with several request methods, allowing
    you to specify additional query string parameters or form data. After you click
    the Send button, Postman makes a request to the URL you specified and displays
    the response data and status code.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 允许你使用多种请求方法测试 API URL，允许你指定额外的查询字符串参数或表单数据。点击发送按钮后，Postman 会向指定的 URL
    发送请求，并显示响应数据和状态码。
- en: '[Figure 6.6](#ch06fig06) shows a screenshot of Postman making a `PUT` request
    to the same URL as before.'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.6](#ch06fig06) 展示了 Postman 向之前相同的 URL 发送 `PUT` 请求的截图。'
- en: Figure 6.6\. Using the Postman REST Client to test a `PUT` request to the API
  id: totrans-1613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.6. 使用 Postman REST 客户端测试 API 的 `PUT` 请求
- en: '![](Images/06fig06_alt.jpg)'
  id: totrans-1614
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig06_alt.jpg)'
- en: It’s a good idea to get Postman or another REST client up and running now. You’ll
    need to use one a lot during this chapter as you build up a REST API. In the next
    section, you’ll start on the workings of the API by using `GET` requests to read
    data from MongoDB.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动 Postman 或其他 REST 客户端是个好主意。在构建 REST API 的过程中，你将在本章中大量使用它。在下一节中，你将使用 `GET`
    请求从 MongoDB 读取数据来开始 API 的操作。
- en: '6.3\. GET methods: Reading data from MongoDB'
  id: totrans-1616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3. GET 方法：从 MongoDB 读取数据
- en: '`GET` methods are all about querying the database and returning some data.
    In your routes for Loc8r, you have three `GET` requests doing different things,
    as listed in [table 6.6](#ch06table06).'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法都是关于查询数据库并返回一些数据的。在你的Loc8r路由中，有三个`GET`请求执行不同的操作，如[表6.6](#ch06table06)中列出。'
- en: Table 6.6\. Three `GET` requests of the Loc8r API
  id: totrans-1618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.6\. Loc8r API的三个`GET`请求
- en: '| Action | Method | URL path | Example |'
  id: totrans-1619
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 方法 | URL路径 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1620
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Read a list of locations | GET | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
  id: totrans-1621
  prefs: []
  type: TYPE_TB
  zh: '| 读取位置列表 | GET | /locations | [http://loc8r.com/api/locations](http://loc8r.com/api/locations)
    |'
- en: '| Read a specific location | GET | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1622
  prefs: []
  type: TYPE_TB
  zh: '| 读取特定位置 | GET | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '| Read a specific review | GET | /locations/:locationid/reviews/:reviewid |
    [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
  id: totrans-1623
  prefs: []
  type: TYPE_TB
  zh: '| 读取特定评论 | GET | /locations/:locationid/reviews/:reviewid | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
- en: You’ll look at how to find a single location first, because it provides a good
    introduction to the way Mongoose works. Next, you’ll locate a single document
    by using an ID, and then you’ll expand into searching for multiple documents.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先查看如何查找单个位置，因为它为Mongoose的工作方式提供了一个很好的介绍。接下来，你将使用ID定位单个文档，然后你将扩展到搜索多个文档。
- en: 6.3.1\. Finding a single document in MongoDB using Mongoose
  id: totrans-1625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 在MongoDB中使用Mongoose查找单个文档
- en: Mongoose interacts with the database through its models, which is why you imported
    the `Location` model as `Loc` at the top of the controller files. A Mongoose model
    has several associated methods to help manage the interactions, as noted in the
    sidebar “[Mongoose query methods](#ch06sb02).”
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose通过其模型与数据库交互，这就是为什么你将`Location`模型作为`Loc`导入到控制器文件顶部。Mongoose模型有几个相关方法可以帮助管理交互，如侧边栏[Mongoose查询方法](#ch06sb02)中所述。
- en: '|  |'
  id: totrans-1627
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mongoose query methods**'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mongoose查询方法**'
- en: 'Mongoose models have several methods available to help with querying the database.
    Here are some of the key ones:'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose模型有几种方法可以帮助查询数据库。以下是一些关键方法：
- en: '`find`—General search based on a supplied query object'
  id: totrans-1630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`—基于提供的查询对象进行通用搜索'
- en: '`findById`—Looks for a specific ID'
  id: totrans-1631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findById`—查找特定ID'
- en: '`findOne`—Gets the first document to match the supplied query'
  id: totrans-1632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findOne`—获取与提供的查询匹配的第一个文档'
- en: '`geoNear`—Finds places geographically close to the provided latitude and longitude'
  id: totrans-1633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geoNear`—查找与提供的纬度和经度地理上接近的地方'
- en: '`geoSearch`—Adds query functionality to a `geoNear` operation'
  id: totrans-1634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geoSearch`—为`geoNear`操作添加查询功能'
- en: You’ll use some but not all of these methods in this book.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在这本书中使用其中的一些方法，但不是全部。
- en: '|  |'
  id: totrans-1636
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For finding a single database document with a known ID in MongoDB, Mongoose
    has the `findById()` method.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在MongoDB中查找具有已知ID的单个数据库文档，Mongoose有`findById()`方法。
- en: Applying the findById method to the model
  id: totrans-1638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将findById方法应用于模型
- en: 'The `findById()` method is relatively straightforward, accepting a single parameter:
    the ID to look for. As it’s a model method, it’s applied to the model like this:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '`findById()`方法相对简单，接受一个参数：要查找的ID。作为模型方法，它应用于模型，如下所示：'
- en: '[PRE190]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This method won’t start the database query operation; it tells the model what
    the query will be. To start the database query, Mongoose models have an `exec`
    method.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不会启动数据库查询操作；它告诉模型查询将是什么。要启动数据库查询，Mongoose模型有一个`exec`方法。
- en: Running the query with the exec method
  id: totrans-1642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用exec方法运行查询
- en: 'The `exec` method executes the query and passes a callback function that will
    run when the operation is complete. The callback function should accept two parameters:
    an error object and the instance of the found document. As it’s a callback function,
    the names of these parameters can be whatever you like.'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec`方法执行查询，并传递一个回调函数，当操作完成时将运行。回调函数应接受两个参数：一个错误对象和找到的文档实例。作为回调函数，这些参数的名称可以随意命名。'
- en: 'The methods can be chained as follows:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以按以下方式链接：
- en: '[PRE191]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '***1*** **Applies the findById method to the Location model, using Loc**'
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将findById方法应用于Location模型，使用Loc**'
- en: '***2*** **Executes the query**'
  id: totrans-1647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **执行查询**'
- en: '***3*** **Logs the message when complete**'
  id: totrans-1648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **完成时记录消息**'
- en: This approach ensures that the database interaction is asynchronous and, therefore,
    doesn’t block the main Node process.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保数据库交互是异步的，因此不会阻塞主Node进程。
- en: Using the findById method in a controller
  id: totrans-1650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在控制器中使用 findById 方法
- en: The controller you’re working with to find a single location by ID is `locationsReadOne()`,
    in the locations.js file in app_api/controllers.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用的用于通过 ID 查找单个位置的控制器是 `locationsReadOne()`，位于 app_api/controllers 中的 locations.js
    文件。
- en: 'You know the basic construct of the operation: apply the `findById()` and `exec`
    methods to the `Location` model. To get this working in the context of the controller,
    you need to do two things:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道操作的基本结构：将 `findById()` 和 `exec` 方法应用于 `Location` 模型。为了在控制器上下文中使此操作生效，你需要做两件事：
- en: Get the `locationid` parameter from the URL, and pass it to the `findById()`
    method.
  id: totrans-1653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 URL 中获取 `locationid` 参数，并将其传递给 `findById()` 方法。
- en: Provide an output function to the `exec` method.
  id: totrans-1654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输出函数提供给 `exec` 方法。
- en: Express makes it easy to get the URL parameters you defined in the routes. The
    parameters are held inside a `params` object attached to the request object. With
    your route being defined like so
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: Express 使得获取你在路由中定义的 URL 参数变得简单。这些参数存储在附加到请求对象的 `params` 对象中。如果你的路由定义如下
- en: '[PRE192]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'you can access the `locationid` parameter from inside the controller like this:'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在控制器内部这样访问 `locationid` 参数：
- en: '[PRE193]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'For the output function, you can use a simple callback that sends the found
    locations as a JSON response. Putting all this together gives you the following:'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出函数，你可以使用一个简单的回调，将找到的位置作为 JSON 响应发送。将这些放在一起，你将得到以下内容：
- en: '[PRE194]'
  id: totrans-1660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '***1*** **Gets a locationid from the URL parameters, and gives it to the findById
    method**'
  id: totrans-1661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 从 URL 参数中获取 locationid，并将其传递给 findById 方法'
- en: '***2*** **Defines callback to accept possible parameters**'
  id: totrans-1662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **定义回调以接受可能的参数**'
- en: '***3*** **Sends the document found as a JSON response with an HTTP status of
    200**'
  id: totrans-1663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **以 HTTP 状态码 200 将找到的文档作为 JSON 响应发送**'
- en: Now you have a basic API controller. You can try it out by getting the ID of
    one of the locations in MongoDB and going to the URL in your browser or by calling
    it in Postman. To get one of the ID values, you can run the command `db.locations.find
    ()` in the Mongo shell, and the command lists all the locations you have, each
    of which includes the `_id` value. When you’ve put the URL together, the output
    should be a full location object as stored in MongoDB; you should see something
    like [figure 6.7](#ch06fig07).
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个基本的 API 控制器。你可以通过在浏览器中访问 MongoDB 中某个位置的 ID 的 URL 或者在 Postman 中调用它来尝试它。要获取一个
    ID 值，你可以在 Mongo shell 中运行命令 `db.locations.find ()`，该命令会列出你拥有的所有位置，每个位置都包含 `_id`
    值。当你组合好 URL 后，输出应该是一个完整的存储在 MongoDB 中的位置对象；你应该会看到类似[图 6.7](#ch06fig07)的内容。
- en: Figure 6.7\. A basic controller for finding a single location by ID returns
    a JSON object to the browser if the ID is found.
  id: totrans-1665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.7\. 通过 ID 查找单个位置的基本控制器在找到 ID 时向浏览器返回一个 JSON 对象。
- en: '![](Images/06fig07_alt.jpg)'
  id: totrans-1666
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig07_alt.jpg)'
- en: Did you try out the basic controller? Did you put an invalid location ID in
    the URL? If you did, you’ll have seen that you got nothing back—no warning, no
    message; a 200 status telling you that everything is okay, but no data returned.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 你尝试了基本控制器吗？你在 URL 中放入了一个无效的位置 ID 吗？如果你这样做了，你就会看到你没有收到任何东西——没有警告，没有消息；一个 200
    状态码告诉你一切正常，但没有返回数据。
- en: Catching errors
  id: totrans-1668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 捕获错误
- en: The problem with that basic controller is that it outputs only a success response,
    regardless of whether it was successful. This behavior isn’t good for an API.
    A good API should respond with an error code when something goes wrong.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 那个基本控制器的问题在于它只输出成功响应，无论是否成功。这种行为对 API 来说并不好。一个好的 API 应该在出现问题时返回错误代码。
- en: To respond with error messages, the controller needs to be set up to trap potential
    errors and send an appropriate response. Error trapping in this fashion typically
    involves `if` statements. Every `if` statement must have a corresponding `else`
    statement or include a `return` statement.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应错误消息，控制器需要设置以捕获潜在的错误并发送适当的响应。这种方式的错误捕获通常涉及 `if` 语句。每个 `if` 语句都必须有一个相应的 `else`
    语句或包含一个 `return` 语句。
- en: '|  |'
  id: totrans-1671
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Your API code must never leave a request unanswered.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 API 代码绝不能对请求置之不理。
- en: '|  |'
  id: totrans-1674
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'With your basic controller, you need to trap three errors:'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的基本控制器，你需要捕获三个错误：
- en: The request parameters don’t include `locationid`.
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求参数不包含 `locationid`。
- en: The `findById()` method doesn’t return a location.
  id: totrans-1677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findById()` 方法不返回位置。'
- en: The `findById()` method returns an error.
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findById()` 方法返回一个错误。'
- en: The status code for an unsuccessful `GET` request is 404\. Bearing this fact
    in mind, the final code for the controller to find and return a single location
    looks like the following listing.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 不成功的`GET`请求的状态码为404。考虑到这一点，查找并返回单个位置的控制器最终代码如下所示。
- en: Listing 6.2\. `locationsReadOne` controller
  id: totrans-1680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2. `locationsReadOne`控制器
- en: '[PRE195]'
  id: totrans-1681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '***1*** **Error trap 1: If Mongoose doesn’t return a location, sends a 404
    message and exits the function scope, using a return statement**'
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **错误陷阱1：如果Mongoose没有返回位置，则发送404消息并退出函数作用域，使用return语句**'
- en: '***2*** **Error trap 2: If Mongoose returns an error, sends it as a 404 response
    and exits the controller, using a return statement**'
  id: totrans-1683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **错误陷阱2：如果Mongoose返回错误，则将其作为404响应发送并退出控制器，使用return语句**'
- en: '***3*** **If Mongoose doesn’t error, continues as before, and sends a location
    object in a 200 response**'
  id: totrans-1684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果Mongoose没有出错，则继续之前的操作，并在200响应中发送位置对象**'
- en: '[Listing 6.2](#ch06ex02) uses both methods of trapping with `if` statements.
    Error trap 1 ***1*** and error trap 2 ***2*** use an `if` to check for an error
    returned by Mongoose. Each `if` includes a `return` statement, which prevents
    any following code in the callback scope from running. If no error was found,
    the `return` statement is ignored, and the code moves on to send the successful
    response ***3***.'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.2](#ch06ex02) 使用了`if`语句的两种捕获方法。错误陷阱1 ***1*** 和错误陷阱2 ***2*** 使用`if`语句检查Mongoose返回的错误。每个`if`语句都包含一个`return`语句，这阻止了回调作用域中任何后续代码的执行。如果没有找到错误，则忽略`return`语句，代码继续发送成功的响应
    ***3***。'
- en: Each of these traps provides a response for success and failure, leaving no
    room for the API to leave a requester hanging. If you want to, you can also throw
    in a few `console.log()` statements so that it’s easier to track what’s going
    on in terminal; the source code in GitHub has some.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 这些陷阱中的每一个都提供了成功和失败的响应，没有留下API让请求者悬而未决的空间。如果你愿意，你还可以加入一些`console.log()`语句，这样在终端中跟踪正在发生的事情会更容易；GitHub上的源代码中也有一些。
- en: '[Figure 6.8](#ch06fig08) shows the difference between a successful request
    and a failed request, using the Postman extension in Chrome.'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.8](#ch06fig08) 展示了使用Chrome中的Postman扩展程序时，成功请求与失败请求之间的区别。'
- en: Figure 6.8\. Testing successful (left) and failed (right) API responses using
    Postman
  id: totrans-1688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8. 使用Postman测试成功（左）和失败（右）的API响应
- en: '![](Images/06fig08_alt.jpg)'
  id: totrans-1689
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig08_alt.jpg)'
- en: That’s one complete API route dealt with. Now it’s time to look at the second
    `GET` request to return a single review.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理完了一个完整的API路由。现在，是时候查看第二个`GET`请求以返回单个评论了。
- en: 6.3.2\. Finding a single subdocument based on IDs
  id: totrans-1691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2. 基于ID查找单个子文档
- en: To find a subdocument, you first have to find the parent document, and then
    pinpoint the required location using its ID. When you’ve found the document, you
    can look for a specific subdocument. You can take the `locationsReadOne()` controller
    as the starting point, and add a few modifications to create the `reviewsReadOne()`
    controller. These modifications are
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找子文档，你首先必须找到父文档，然后使用其ID定位所需的位置。当你找到文档后，你可以查找特定的子文档。你可以以`locationsReadOne()`控制器为起点，并添加一些修改来创建`reviewsReadOne()`控制器。这些修改包括
- en: Accept and use an additional `reviewid` URL parameter.
  id: totrans-1693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受并使用额外的`reviewid` URL参数。
- en: Select only the name and reviews from the document rather than have MongoDB
    return the entire document.
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅从文档中选择名称和评论，而不是让MongoDB返回整个文档。
- en: Look for a review with a matching ID.
  id: totrans-1695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找具有匹配ID的评论。
- en: Return the appropriate JSON response.
  id: totrans-1696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回适当的JSON响应。
- en: To do these things, you can use a couple of new Mongoose methods.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这些事情，你可以使用几个新的Mongoose方法。
- en: Limiting the paths returned from MongoDB
  id: totrans-1698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 限制从MongoDB返回的路径
- en: When you retrieve a document from MongoDB, you don’t always need the full document;
    sometimes, you want some specific data. Limiting the data being passed around
    is also better for bandwidth consumption and speed.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从MongoDB检索文档时，你并不总是需要完整的文档；有时，你只想获取一些特定的数据。限制传递的数据也有助于带宽消耗和速度。
- en: 'Mongoose does this through a `select()` method chained to the model query.
    The following code snippet tells MongoDB that you want to get only the name and
    the reviews of a location:'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose通过将`select()`方法链接到模型查询来实现这一点。以下代码片段告诉MongoDB你只想获取位置的名字和评论：
- en: '[PRE196]'
  id: totrans-1701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The `select()` method accepts a space-separated string of the paths you want
    to retrieve.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()`方法接受一个由空格分隔的路径字符串，表示你想要检索的路径。'
- en: Using Mongoose to find a specific subdocument
  id: totrans-1703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Mongoose查找特定的子文档
- en: 'Mongoose also offers a helper method for finding a subdocument by ID. Given
    an array of subdocuments, Mongoose has an `id` method that accepts the ID you
    want to find. The `id` method returns the single matching subdocument, and it
    can be used as follows:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose还提供了一个辅助方法来通过ID查找子文档。给定一个子文档数组，Mongoose的`id`方法接受你想要查找的ID。`id`方法返回单个匹配的子文档，可以使用以下方式使用：
- en: '[PRE197]'
  id: totrans-1705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '***1*** **Passes reviewid from the parameters into the id method**'
  id: totrans-1706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将参数中的reviewid传递给id方法**'
- en: In this code snippet, a single review is returned to the `review` variable in
    the callback.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，回调函数将单个评论返回到`review`变量中。
- en: Adding some error trapping and putting it all together
  id: totrans-1708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加一些错误处理并将所有内容组合在一起
- en: Now you’ve got the ingredients needed to make the `reviewsReadOne()` controller.
    Starting with a copy of the `locationsReadOne()` controller, you can make the
    modifications required to return a single review.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了制作`reviewsReadOne()`控制器的所需成分。从`locationsReadOne()`控制器的副本开始，你可以进行必要的修改以返回单个评论。
- en: The following listing shows the `reviewsReadOne()` controller in review.js (modifications
    in bold).
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`reviewsReadOne()`控制器在review.js中的内容（加粗的修改）：
- en: Listing 6.3\. Controller for finding a single review
  id: totrans-1711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 查找一个单个评论的控制台
- en: '[PRE198]'
  id: totrans-1712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '***1*** **Adds the Mongoose select method to the model query, stating that
    you want to get the name of a location and its reviews**'
  id: totrans-1713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将Mongoose选择方法添加到模型查询中，表示你想要获取位置名称及其评论**'
- en: '***2*** **Checks that the returned location has reviews**'
  id: totrans-1714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查返回的位置是否有评论**'
- en: '***3*** **Uses the Mongoose subdocument .id method as a helper for searching
    for a matching ID**'
  id: totrans-1715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用Mongoose子文档.id方法作为搜索匹配ID的辅助工具**'
- en: '***4*** **If a review isn’t found, returns an appropriate response**'
  id: totrans-1716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **如果没有找到评论，返回适当的响应**'
- en: '***5*** **If a review is found, builds a response object returning the review
    and location name and ID**'
  id: totrans-1717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **如果找到评论，构建一个响应对象，返回评论和位置名称和ID**'
- en: '***6*** **If no reviews are found, returns an appropriate error message**'
  id: totrans-1718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **如果没有找到评论，返回适当的错误信息**'
- en: When this code is saved and ready, you can test it with Postman again. You need
    to have correct ID values, which you can get from the Postman query you made to
    check for a single location or directly from MongoDB via the Mongo shell. The
    Mongo command `db.locations.find()` return all the locations and their reviews.
    Remember that the URL is in the structure /locations/:locationid/reviews/:reviewid.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码保存并准备好后，你可以再次使用Postman进行测试。你需要有正确的ID值，这些值可以从你为检查单个位置所做的Postman查询中获取，或者可以直接从MongoDB通过Mongo
    shell获取。Mongo命令`db.locations.find()`返回所有位置及其评论。请记住，URL的结构是/locations/:locationid/reviews/:reviewid。
- en: You can also test what happens if you put in a false ID for a location or a
    review or try a review ID from a different location.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以测试如果你输入了一个错误的位置或评论ID会发生什么，或者尝试来自不同位置的评论ID。
- en: 6.3.3\. Finding multiple documents with geospatial queries
  id: totrans-1721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 使用地理空间查询查找多个文档
- en: The homepage of Loc8r should display a list of locations based on the user’s
    current geographical location. MongoDB and Mongoose have some special geospatial
    aggregation methods to help find nearby places.
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: Loc8r的首页应根据用户的当前地理位置显示位置列表。MongoDB和Mongoose提供了一些特殊的地理空间聚合方法，以帮助找到附近的地点。
- en: 'Here, you’ll use the Mongoose aggregate $`geoNear` to find a list of locations
    close to a specified point, up to a specified maximum distance. $`geoNear` is
    an aggregation method that accepts multiple configuration options, of which of
    the following are required:'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将使用Mongoose聚合$`geoNear`来查找一个接近指定点的位置列表，直到指定的最大距离。$`geoNear`是一个聚合方法，它接受多个配置选项，其中以下选项是必需的：
- en: '`near` as a `geoJSON` geographical point'
  id: totrans-1724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`near`作为一个`geoJSON`地理点'
- en: A `distanceField` object option
  id: totrans-1725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`distanceField`对象选项
- en: A `maxDistance` object option
  id: totrans-1726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`maxDistance`对象选项
- en: 'The following code snippet shows the basic construct:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了基本结构：
- en: '[PRE199]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Like the `findById` method, the $`geoNear` aggregate returns a Promise, and
    its value can be obtained by using a callback, its `exec` method, or async/await.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 与`findById`方法一样，$`geoNear`聚合返回一个Promise，其值可以通过使用回调、其`exec`方法或async/await来获取。
- en: Constructing a geoJSON point
  id: totrans-1730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建一个geoJSON点
- en: 'The first parameter of $`geoNear` is a `geoJSON` point: a simple JSON object
    containing a latitude and a longitude in an array. The construct for a `geoJSON`
    point is shown in the following code snippet:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '`$geoNear`的第一个参数是一个`geoJSON`点：一个包含纬度和经度数组的简单JSON对象。`geoJSON`点的结构在以下代码片段中显示：'
- en: '[PRE200]'
  id: totrans-1732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '***1*** **Declares object**'
  id: totrans-1733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **声明对象**'
- en: '***2*** **Defines it as type “Point”**'
  id: totrans-1734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将其定义为“Point”类型**'
- en: '***3*** **Sets longitude and latitude coordinates in an array, longitude first**'
  id: totrans-1735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在数组中设置经纬度坐标，先设置经度**'
- en: 'The route set up here to get a list of locations doesn’t have the coordinates
    in the URL parameters, meaning that they’ll have to be specified in a different
    way. A query string is ideal for this data type, so the request URL will look
    more like this:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 这里设置的获取位置列表的路由没有在URL参数中包含坐标，这意味着它们将以不同的方式指定。查询字符串是这种数据类型的理想选择，因此请求URL将看起来更像是这样：
- en: '[PRE201]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Express, of course, gives you access to the values in a query string, putting
    them in a query object attached to the request object, such as `req.query.lng`.
    The longitude and latitude values will be strings when retrieved, but they need
    to be added to the point object as numbers. JavaScript’s `parseFloat()` function
    can see to this. The following code snippet shows how to get the coordinates from
    the query string and create the `geoJSON` point required by the `$geoNear` aggregation:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: Express当然为您提供了访问查询字符串中的值的方法，将它们放入附加到请求对象的查询对象中，例如`req.query.lng`。当检索到经纬度值时，它们将是字符串，但需要将它们作为数字添加到点对象中。JavaScript的`parseFloat()`函数可以处理这一点。以下代码片段显示了如何从查询字符串中获取坐标并创建`geoJSON`点，这是`$geoNear`聚合所必需的：
- en: '[PRE202]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '***1*** **Gets coordinates from the query string and converts from strings
    to numbers**'
  id: totrans-1740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从查询字符串中获取坐标并将其从字符串转换为数字**'
- en: '***2*** **Creates geoJSON point**'
  id: totrans-1741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建geoJSON点**'
- en: '***3*** **You’re using spherical: true here because it causes MongoDB to use
    $nearSphere semantics, which calculates distances using spherical geometry. If
    this were false, it would use 2D geometry.**'
  id: totrans-1742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在这里您使用的是spherical: true，因为这会导致MongoDB使用$nearSphere语义，它使用球面几何来计算距离。如果这是false，它将使用2D几何。**'
- en: '***4*** **The aggregation**'
  id: totrans-1743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **聚合**'
- en: '***5*** **The spread operator (see the nearby sidebar)**'
  id: totrans-1744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **扩展运算符（参见附近的侧边栏）**'
- en: Trying to execute this controller code won’t result in a response, as processing
    of the data has not been started. Remember that this code is returning a Promise
    object.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试执行此控制器代码不会产生响应，因为数据处理尚未开始。请记住，此代码返回一个Promise对象。
- en: '|  |'
  id: totrans-1746
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Spread operator**'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展运算符**'
- en: New in ES2015 is the spread operator. This operator takes an iterable (an array,
    string, or object) and allows it to be expanded into places where zero or more
    arguments (when used in a function call) or elements (for array literals) are
    expected.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015中引入了扩展运算符。此运算符接受一个可迭代对象（一个数组、字符串或对象），并允许它扩展到期望零个或多个参数（在函数调用中使用）或元素（在数组字面量中使用）的位置。
- en: In the case of the aggregate function in the preceding code block, it injects
    the object properties in `geoOptions` into the `$geoNear` object. The spread operator
    has many uses; details are available at [http://mng.bz/wEya](http://mng.bz/wEya).
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个代码块中的聚合函数情况下，它将`geoOptions`中的对象属性注入到`$geoNear`对象中。扩展运算符有很多用途；详细信息请参阅[http://mng.bz/wEya](http://mng.bz/wEya)。
- en: '|  |'
  id: totrans-1750
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The spherical option in the Aggregation specification
  id: totrans-1751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚合规范中的球形选项
- en: 'The `geoOptions` object contains a spherical key. This value is required to
    be set to `true`, as you’ve already specified the search index in the MongoDB
    data store as `2dsphere`. If you try to set it to `false`, the application throws
    an exception:'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '`geoOptions`对象包含一个球形键。此值必须设置为`true`，因为您已经将MongoDB数据存储中的搜索索引指定为`2dsphere`。如果您尝试将其设置为`false`，应用程序将抛出异常：'
- en: '[PRE203]'
  id: totrans-1753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Limiting geoNear results by number
  id: totrans-1754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过数量限制geoNear结果
- en: You’ll often want to look after the API server—and the responsiveness seen by
    end users—by limiting the number of results when returning a list. In the $`geoNear`
    aggregate, adding the option `num or limit` does this. You specify the maximum
    number of results you want to have returned. You can specify both, but `num` is
    given priority over `limit`.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回列表时，您通常会希望通过限制结果数量来关注API服务器以及最终用户看到的响应性。在$`geoNear`聚合中，添加`num`或`limit`选项可以做到这一点。您指定希望返回的最大结果数量。您可以指定两者，但`num`优先于`limit`。
- en: 'The following code snippet shows `limit` added to the previous `geoOptions`
    object, limiting the size of the returned dataset to 10 objects:'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了添加到之前的`geoOptions`对象中的`limit`，限制返回数据集的大小为10个对象：
- en: '[PRE204]'
  id: totrans-1757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Now the search brings back no more than the 10 closest results.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 现在搜索只会返回最多10个最近的结果。
- en: Limiting geoNear results by distance
  id: totrans-1759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过距离限制geoNear结果
- en: When returning location-based data, another way to keep the processing of the
    API under control is to limit the list of results by distance from the central
    point. This is a case of adding another option called `maxDistance`. When you
    use the spherical option, MongoDB does the calculations in meters for you, making
    life simple. This wasn’t always the case. Older versions of MongoDB used radians,
    which made things much more complicated.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回基于位置的数据时，另一种保持API处理在控制之下的是通过距离限制结果列表。这是一个添加另一个名为`maxDistance`的选项的情况。当你使用球形选项时，MongoDB会为你以米为单位进行计算，使生活变得简单。这并不总是这种情况。MongoDB的旧版本使用弧度，这使得事情变得更加复杂。
- en: 'If you want to output in miles, you’ll need to do a little calculation, but
    you’ll stick to meters and kilometers. You’ll impose a limit of 20 km, which is
    20,000 m. Now you can add the `maxDistance` value to the options and add these
    options to the controller as follows:'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以英里为单位输出，你需要做一些计算，但你会坚持使用米和公里。你将设置一个20公里的限制，即20,000米。现在你可以将`maxDistance`值添加到选项中，并将这些选项按如下方式添加到控制器中：
- en: '[PRE205]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '***1*** **Creates an options object, including setting the maximum distance
    to 20 km**'
  id: totrans-1763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 创建一个选项对象，包括设置最大距离为20公里'
- en: '***2*****The rest of the definition object**'
  id: totrans-1764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*****定义对象的其余部分**'
- en: '|  |'
  id: totrans-1765
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Extra credit**'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外加分**'
- en: Try taking the maximum distance from a query string value instead of hardcoding
    it into the function. The code on GitHub for this chapter has the answer.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从查询字符串值中获取最大距离，而不是将其硬编码到函数中。本章在GitHub上的代码有答案。
- en: '|  |'
  id: totrans-1768
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That’s the last of the options you need for your $`geoNear` database search,
    so it’s time to start working with the output.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要的最后一个选项来对你的$`geoNear`数据库搜索，所以现在是时候开始处理输出了。
- en: Looking at the $geoNear aggregate output
  id: totrans-1770
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看the $geoNear聚合输出
- en: 'The result object for the $`geoNear` aggregate method is a list of the matched
    items from the database or an error object. If you were using the callback function,
    it would have the following signature: `callback(err, result)`. As you’re using
    `async`/`await`, you use `try`/`catch` to perform the operation or catch the error.'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: $`geoNear`聚合方法的返回结果对象是数据库中匹配项的列表或错误对象。如果你使用回调函数，它将有以下签名：`callback(err, result)`。由于你使用`async`/`await`，你使用`try`/`catch`来执行操作或捕获错误。
- en: With a successful query, the error object is undefined; the results object is
    a list of items, as previously stated. You’ll start by working with the successful
    query response before adding error trapping.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功查询的情况下，错误对象是未定义的；结果对象是一个项目列表，如前所述。你将首先处理成功的查询响应，然后再添加错误处理。
- en: 'Following a successful $`geoNear` aggregation, MongoDB returns an array of
    objects. Each object contains a distance value (at the path specified by the `distanceField`)
    and a returned document from the database. In other words, MongoDB includes the
    distance in the data. The following code snippet shows an example of the returned
    data, truncated for brevity:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的$`geoNear`聚合之后，MongoDB返回一个对象数组。每个对象包含一个距离值（由`distanceField`指定的路径）和从数据库返回的文档。换句话说，MongoDB在数据中包含了距离。以下代码片段显示了返回数据的示例，为了简洁而截断：
- en: '[PRE206]'
  id: totrans-1774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: This array has only one object, but a successful query is likely to have several
    objects returned at once. The $`geoNear` aggregate returns the entire document
    contained in the data store, but the API shouldn’t return more data than is requested.
    So rather than send the returned data back as the response, you have some processing
    to do first.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组只有一个对象，但成功的查询可能会一次性返回多个对象。$`geoNear`聚合返回数据存储中包含的整个文档，但API不应该返回比请求更多的数据。所以，而不是将返回的数据作为响应发送，你首先需要进行一些处理。
- en: Processing the $geoNear output
  id: totrans-1776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理$geoNear输出
- en: 'Before the API can send a response, you need to make sure that it’s sending
    the right thing and only what’s needed. You know what data the homepage listing
    needs; you’ve already built the homepage controller in app_server/controllers/location.js.
    The `homelist()` function sends several location objects, similar to the following
    example:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 在API发送响应之前，你需要确保它发送的是正确的内容，并且只发送所需的内容。你知道主页列表需要什么数据；你已经在app_server/controllers/location.js中构建了主页控制器。`homelist()`函数发送几个位置对象，类似于以下示例：
- en: '[PRE207]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'To create an object along these lines from the results, you need to iterate
    through the results and map the relevant data into a new array. Then this processed
    data can be returned with a status 200 response. The following code snippet shows
    how this result might look:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从结果中创建一个类似的对象，你需要遍历结果并将相关数据映射到一个新的数组中。然后，可以以状态 200 的响应返回处理后的数据。以下代码片段显示了这种结果可能的样子：
- en: '[PRE208]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '***1*** **Creates a new array to hold mapped results data**'
  id: totrans-1781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个新的数组来存储映射的结果数据**'
- en: '***2*** **Returns the result of the mapping**'
  id: totrans-1782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **返回映射的结果**'
- en: '***3*** **Gets the distance and fixes to the nearest integer**'
  id: totrans-1783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **获取距离并将其修正为最接近的整数**'
- en: '***4*** **Sends the processed data back as a JSON response**'
  id: totrans-1784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 将处理后的数据作为 JSON 响应发送'
- en: If you test this API route with Postman—remembering to add longitude and latitude
    coordinates to the query string—you’ll see something like [figure 6.9](#ch06fig09).
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Postman 测试这个 API 路由——记得在查询字符串中添加经纬度坐标——你会看到类似[图 6.9](#ch06fig09)的内容。
- en: Figure 6.9\. Testing the locations list route in Postman should give a 200 status
    and a list of results, depending on the geographical coordinates sent in the query
    string.
  id: totrans-1786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.9\. 在 Postman 中测试位置列表路由应该返回 200 状态和结果列表，具体取决于查询字符串中发送的地理坐标。
- en: '![](Images/06fig09_alt.jpg)'
  id: totrans-1787
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig09_alt.jpg)'
- en: '|  |'
  id: totrans-1788
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Extra credit**'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外加分**'
- en: Try passing the results to an external named function to build the list of locations.
    This function should return the processed list, which can then be passed into
    the JSON response.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将结果传递给一个外部命名函数来构建位置列表。这个函数应该返回处理后的列表，然后可以将其传递到 JSON 响应中。
- en: '|  |'
  id: totrans-1791
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you test this by sending coordinates too far away from the test data, you
    should still get a 200 status, but the returned array will be empty.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过发送距离测试数据太远的坐标来测试，你应该仍然得到 200 状态，但返回的数组将是空的。
- en: Adding the error trapping
  id: totrans-1793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: Once again, you’ve started by building the success functionality. Now you need
    to add some error traps to make sure that the API always sends the appropriate
    response.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你首先构建了成功功能。现在你需要添加一些错误陷阱，以确保 API 总是发送适当的响应。
- en: The traps you need to set should check that
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要设置的陷阱应该检查
- en: All the parameters have been sent correctly.
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数都已正确发送。
- en: The $`geoNear` aggregate hasn’t returned an error condition.
  id: totrans-1797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: $`geoNear` 聚合操作没有返回错误条件。
- en: The following listing shows the final controller, including these error traps.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了最终的控制器，包括这些错误陷阱。
- en: Listing 6.4\. Locations list controller locationsListByDistance
  id: totrans-1799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 位置列表控制器 locationsListByDistance
- en: '[PRE209]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '***1*** **Checks whether lng and lat query parameters exist in the right format;
    returns a 404 error and message if not**'
  id: totrans-1801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 检查 lng 和 lat 查询参数是否存在正确的格式；如果不存在，则返回 404 错误和信息'
- en: '***2* If $geoNear aggregation query returns error, sends this as a response
    with a 404 status**'
  id: totrans-1802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果 $geoNear 聚合查询返回错误，则以 404 状态发送此响应**'
- en: This listing completes the `GET` requests that your API needs to service, so
    it’s time to tackle the `POST` requests.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表完成了你的 API 需要服务的 `GET` 请求，因此现在是时候处理 `POST` 请求了。
- en: '6.4\. POST methods: Adding data to MongoDB'
  id: totrans-1804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. POST 方法：向 MongoDB 添加数据
- en: '`POST` methods are all about creating documents or subdocuments in the database
    and then returning the saved data as confirmation. In the routes for Loc8r, you
    have two `POST` requests doing different things, as listed in [table 6.7](#ch06table07).'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法主要涉及在数据库中创建文档或子文档，然后返回保存的数据作为确认。在 Loc8r 的路由中，你有两个 `POST` 请求执行不同的操作，如[表
    6.7](#ch06table07)中列出。'
- en: Table 6.7\. Two `POST` requests of the Loc8r API
  id: totrans-1806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.7\. Loc8r API 的两个 `POST` 请求
- en: '| Action | Method | URL path | Example |'
  id: totrans-1807
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 方法 | URL 路径 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1808
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Create new location | POST | /locations | [http://api.loc8r.com/locations](http://api.loc8r.com/locations)
    |'
  id: totrans-1809
  prefs: []
  type: TYPE_TB
  zh: '| 创建新位置 | POST | /locations | [http://api.loc8r.com/locations](http://api.loc8r.com/locations)
    |'
- en: '| Create new review | POST | /locations/:locationid/reviews | [http://api.loc8r.com/locations/123/reviews](http://api.loc8r.com/locations/123/reviews)
    |'
  id: totrans-1810
  prefs: []
  type: TYPE_TB
  zh: '| 创建新评论 | POST | /locations/:locationid/reviews | [http://api.loc8r.com/locations/123/reviews](http://api.loc8r.com/locations/123/reviews)
    |'
- en: '`POST` methods work by taking form data posted to them and adding it to the
    database. In the same way that URL parameters are accessed via `req.params` and
    query strings are accessed via `req.query`, Express controllers access posted
    form data via `req.body`.'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法通过获取发送给它们的表单数据并将其添加到数据库中工作。就像通过 `req.params` 访问 URL 参数和通过 `req.query`
    访问查询字符串一样，Express 控制器通过 `req.body` 访问发送的表单数据。'
- en: Start by looking at how to create documents.
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看看如何创建文档。
- en: 6.4.1\. Creating new documents in MongoDB
  id: totrans-1813
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 在 MongoDB 中创建新文档
- en: 'In the database for Loc8r, each location is a document, so you’ll create a
    document in this section. Mongoose couldn’t make the process of creating MongoDB
    documents much easier for you. You apply the `create()` method to your model,
    and send it some data and a callback function. This construct is minimal, as it
    would be attached to your `Loc` model:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Loc8r 的数据库中，每个位置都是一个文档，所以你将在本节中创建一个文档。Mongoose 无法使创建 MongoDB 文档的过程对你来说更加简单。你将
    `create()` 方法应用于你的模型，并传递一些数据和回调函数。这个结构是最小的，因为它将附加到你的 `Loc` 模型：
- en: '![](Images/p0187-01_alt.jpg)'
  id: totrans-1815
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0187-01_alt.jpg)'
- en: 'That’s simple. The creation process has two main steps:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。创建过程有两个主要步骤：
- en: Use the posted form data to create a JavaScript object that matches the schema.
  id: totrans-1817
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用发布的表单数据创建一个与架构匹配的 JavaScript 对象。
- en: Send an appropriate response in the callback, depending on the success or failure
    of the `create()` operation.
  id: totrans-1818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据创建操作的成功或失败，在回调中发送适当的响应。
- en: Looking at step 1, you already know that you can get data sent to you in a form
    by using `req.body`, and step 2 should be familiar by now. Jump straight into
    the code.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 看看步骤 1，你已经知道你可以通过使用 `req.body` 来获取发送给你的数据，步骤 2 现在应该很熟悉了。直接进入代码。
- en: The following listing shows the full `locationsCreate()` controller for creating
    a new document.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了创建新文档的完整 `locationsCreate()` 控制器。
- en: Listing 6.5\. Complete controller for creating a new location
  id: totrans-1821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 创建新位置的完整控制器
- en: '[PRE210]'
  id: totrans-1822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '***1*** **Applies the create method to the model**'
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将创建方法应用于模型**'
- en: '***2*** **Creates an array of facilities by splitting a comma-separated list**'
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **通过分割逗号分隔的列表创建设施数组**'
- en: '***3*** **Parses coordinates from strings to numbers**'
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将坐标从字符串解析为数字**'
- en: '***4*** **Supplies a callback function, containing appropriate responses for
    success and failure**'
  id: totrans-1826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **提供一个包含成功和失败适当响应的回调函数**'
- en: This listing shows how easy it can be to create a new document in MongoDB and
    save some data. For the sake of brevity, you’ve limited the `openingTimes` array
    to two entries, but this array could easily be extended or, better, put in a loop
    to check for the existence of the values.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了在 MongoDB 中创建新文档并保存一些数据是多么容易。为了简洁起见，你已将 `openingTimes` 数组限制为两个条目，但这个数组可以很容易地扩展，或者更好的是，放入循环中检查值的存在。
- en: 'You may also notice that no `rating` is set. Remember that in the schema, you
    set a default of `0`, as in the following snippet:'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到没有设置 `rating`。记住，在架构中，你设置了默认值 `0`，如下面的代码片段所示：
- en: '[PRE211]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'This snippet is applied when the document is created, setting the initial value
    to `0`. Something else about this code may be shouting out at you: there’s no
    validation!'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档创建时应用此代码片段，将初始值设置为 `0`。关于这段代码的其他一些可能让你感到惊讶的事情：没有验证！
- en: 6.4.2\. Validating the data using Mongoose
  id: totrans-1831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 使用 Mongoose 验证数据
- en: This controller has no validation code inside it, so what’s to stop somebody
    from entering loads of empty or partial documents? Again, you started building
    validations in the Mongoose schemas. In the schemas, you set a `required` flag
    to `true` in a few of the paths. When this flag is set, Mongoose won’t send the
    data to MongoDB.
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器内部没有验证代码，那么阻止某人输入大量空或部分文档的又是什么呢？再次强调，你开始在 Mongoose 架构中构建验证。在架构中，你将一些路径的
    `required` 标志设置为 `true`。当这个标志被设置时，Mongoose 不会将数据发送到 MongoDB。
- en: 'Given the following base schema for locations, for example, you can see that
    only `name` is a required field:'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下位置的基础架构，例如，你可以看到只有 `name` 是必填字段：
- en: '[PRE212]'
  id: totrans-1834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: If this field is missing, the `create()` method raises an error and doesn’t
    attempt to save the document to the database.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个字段缺失，`create()` 方法会引发错误，并且不会尝试将文档保存到数据库中。
- en: Testing this API route in Postman looks like [figure 6.10](#ch06fig10). Note
    that the method is set to `post` and that the data type selected (above the list
    of names and values) is `x-www-form-urlencoded`. You’ll enter the keys and values
    to submit with your `POST` request in the Postman interface, as shown in that
    figure. Be careful not to have any blank spaces before or after the keys you type
    in the Postman fields, as spaces will result in unexpected inputs.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中测试这个 API 路由看起来像[图 6.10](#ch06fig10)。注意方法设置为 `post`，并且选择的数据类型（在名称和值列表上方）是
    `x-www-form-urlencoded`。你将在 Postman 界面中输入要随 `POST` 请求一起提交的键和值，如图所示。注意不要在 Postman
    字段中输入的键前后留空白，因为空格会导致意外的输入。
- en: Figure 6.10\. Testing a `POST` method in Postman, ensuring that the method and
    form data settings are correct
  id: totrans-1837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10\. 在Postman中测试`POST`方法，确保方法和表单数据设置正确
- en: '![](Images/06fig10_alt.jpg)'
  id: totrans-1838
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig10_alt.jpg)'
- en: 6.4.3\. Creating new subdocuments in MongoDB
  id: totrans-1839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.3\. 在MongoDB中创建新的子文档
- en: In the context of Loc8r locations, reviews are subdocuments. Subdocuments are
    created and saved through their parent document. Put another way, to create and
    save a new subdocument, you have to
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 在Loc8r位置上下文中，评论是子文档。子文档通过其父文档创建和保存。换句话说，要创建和保存一个新的子文档，您必须
- en: Find the correct parent document.
  id: totrans-1841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到正确的父文档。
- en: Add a new subdocument.
  id: totrans-1842
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的子文档。
- en: Save the parent document.
  id: totrans-1843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存父文档。
- en: Finding the correct parent isn’t a problem, as you’ve already done that and
    can use it as the skeleton for the next controller, `reviewsCreate()`. When you’ve
    found the parent, you can call an external function to do the next part (you’ll
    write this function soon), as shown in the following listing.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 找到正确的父文档不是问题，因为您已经完成了这个操作，并且可以用它作为下一个控制器`reviewsCreate()`的框架。当您找到父文档后，您可以调用一个外部函数来完成下一部分（您很快就会编写这个函数），如下所示。
- en: Listing 6.6\. Controller for creating a review
  id: totrans-1845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 创建评论的控制器
- en: '[PRE213]'
  id: totrans-1846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '***1*** **Successful find operation will call a new function to add a review,
    passing request, response, and location object**'
  id: totrans-1847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **成功的查找操作将调用一个新函数来添加评论，传递请求、响应和位置对象**'
- en: This code isn’t doing anything particularly new; you’ve seen it all before.
    By putting in a call to a new function, you can keep the code neater by reducing
    the amount of nesting and indentation, and also make it easier to test.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有做特别新的事情；您之前都见过。通过调用一个新函数，您可以通过减少嵌套和缩进的数量来使代码更整洁，同时也更容易进行测试。
- en: Adding and saving a subdocument
  id: totrans-1849
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加和保存子文档
- en: 'Having found the parent document and retrieved the existing list of subdocuments,
    you need to add a new one. Subdocuments are arrays of objects, and the easiest
    way to add a new object to an array is to create the data object and use the JavaScript
    `push()` method, as the following code snippet demonstrates:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 找到父文档并检索现有的子文档列表后，您需要添加一个新的子文档。子文档是对象的数组，向数组中添加新对象的最简单方法是创建数据对象并使用JavaScript的`push()`方法，如下面的代码片段所示：
- en: '[PRE214]'
  id: totrans-1851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: This snippet is getting posted form data; hence, it uses `req.body`.
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在获取表单数据；因此，它使用`req.body`。
- en: 'When the subdocument has been added, the parent document must be saved because
    subdocuments can’t be saved on their own. To save a document, Mongoose has a model
    method `save()`, which expects a callback with an error parameter and a returned
    object parameter. The following code snippet shows this method in action:'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 当子文档被添加后，必须保存父文档，因为子文档不能单独保存。为了保存文档，Mongoose有一个模型方法`save()`，它期望一个带有错误参数和返回对象参数的回调。以下代码片段展示了这个方法的作用：
- en: '[PRE215]'
  id: totrans-1854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '***1*** **Finds last review in the returned array, as MongoDB returns the entire
    parent document, not only the new subdocument**'
  id: totrans-1855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在返回的数组中找到最后一个评论，因为MongoDB返回整个父文档，而不仅仅是新的子文档**'
- en: The document returned by the `save` method is the full parent document, not
    the new subdocument alone. To return the correct data in the API response—that
    is, the subdocument—you need to retrieve the last subdocument from the array ***1***.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`save`方法返回的文档是完整的父文档，而不是仅有的新子文档。为了在API响应中返回正确的数据——即子文档——您需要从数组中检索最后一个子文档 ***1***。
- en: When adding documents and subdocuments, you need to keep in mind any effect
    this action may have on other data. In Loc8r, for example, adding a review adds
    a new rating, and this new rating affects the overall rating for the document.
    On the successful save of a review, you’ll call another function to update the
    average rating.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加文档和子文档时，您需要考虑到这个操作可能对其他数据产生的影响。例如，在Loc8r中，添加评论会增加一个新的评分，这个新的评分会影响文档的整体评分。在评论成功保存后，您将调用另一个函数来更新平均评分。
- en: Putting everything you have together in the `doAddReview()` function, plus a
    little error trapping, gives you the following listing.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 将您拥有的所有内容组合到`doAddReview()`函数中，再加上一点错误处理，可以得到以下列表。
- en: Listing 6.7\. Adding and saving a subdocument
  id: totrans-1859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 添加和保存子文档
- en: '[PRE216]'
  id: totrans-1860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '***1*** **When provided a parent document . . .**'
  id: totrans-1861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **当提供一个父文档 . . .**'
- en: '***2*** **. . . pushes new data into a subdocument array . . .**'
  id: totrans-1862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **. . . 将新数据推送到子文档数组 . . .**'
- en: '***3*** **. . . before saving it.**'
  id: totrans-1863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **. . . 在保存之前。**'
- en: '***4*** **On successful save operation, calls a function to update the average
    rating**'
  id: totrans-1864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在成功保存操作后，调用一个函数来更新平均评分**'
- en: '***5*** **Retrieves the last review added to the array, and returns it as a
    JSON confirmation response**'
  id: totrans-1865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **检索数组中添加的最后一个评论，并将其作为 JSON 确认响应返回**'
- en: Updating the average rating
  id: totrans-1866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新平均评分
- en: Calculating the average rating isn’t particularly complicated, so we won’t dwell
    on it long. The steps are
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 计算平均评分并不特别复杂，所以我们不会过多停留。步骤如下
- en: Find the correct document, given a provided ID.
  id: totrans-1868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据提供的 ID 查找正确的文档。
- en: Add up the ratings from all the review subdocuments.
  id: totrans-1869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有评论子文档的评分加起来。
- en: Calculate the average rating value.
  id: totrans-1870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算平均评分值。
- en: Update the rating value of the parent document.
  id: totrans-1871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新父文档的评分值。
- en: Save the document.
  id: totrans-1872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Turning this list of steps into code gives you something along the lines of
    the following listing, which should be placed in the reviews.js controller file
    along with the review-based controllers.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 将此步骤列表转换为代码，你将得到以下类似列表，应将其放置在 reviews.js 控制器文件中，与基于评论的控制器一起。
- en: Listing 6.8\. Calculating and updating the average rating
  id: totrans-1874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. 计算和更新平均评分
- en: '[PRE217]'
  id: totrans-1875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '***1*** **Uses the location supplied data**'
  id: totrans-1876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用提供的位置数据**'
- en: '***2*****Uses the JavaScript array reduce method to sum up the ratings of the
    subdocuments**'
  id: totrans-1877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*****使用 JavaScript 数组 reduce 方法汇总子文档的评分**'
- en: '***3*** **Calculates the average rating value and updates the rating value
    of the parent document**'
  id: totrans-1878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **计算平均评分值并更新父文档的评分值**'
- en: '***4*** **Saves the parent document**'
  id: totrans-1879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **保存父文档**'
- en: '***5*** **Finds the location based on the provided locationid data**'
  id: totrans-1880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **根据提供的 locationid 数据查找位置**'
- en: You may have noticed that you’re not sending any JSON response here, because
    you’ve already sent it. This entire operation is asynchronous and doesn’t need
    to affect sending the API response that confirms the saved review.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到你没有发送任何 JSON 响应，因为你已经发送了。整个操作是异步的，不需要影响发送确认已保存评论的 API 响应。
- en: Adding a review isn’t the only time you’ll need to update the average rating,
    which is why it makes extra sense to make these functions accessible from the
    other controllers and not tightly coupled to the actions of creating a review.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 添加评论不是唯一需要更新平均评分的情况，这就是为什么让这些函数可以从其他控制器访问，而不是紧密耦合到创建评论的操作中，更有意义。
- en: What you’ve done here offers a sneak peek at using Mongoose to update data in
    MongoDB, so now you’ll move on to the `PUT` methods of the API.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里所做的是使用 Mongoose 更新 MongoDB 数据的预览，因此现在你将进入 API 的 `PUT` 方法。
- en: '6.5\. PUT methods: Updating data in MongoDB'
  id: totrans-1884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. PUT 方法：在 MongoDB 中更新数据
- en: '`PUT` methods are all about updating existing documents or subdocuments in
    the database and returning the saved data as confirmation. In the routes for Loc8r,
    you have two `PUT` requests doing different things, as listed in [table 6.8](#ch06table08).'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 方法全部关于在数据库中更新现有文档或子文档，并将保存的数据作为确认返回。在 Loc8r 的路由中，你有两个 `PUT` 请求执行不同的操作，如
    [表 6.8](#ch06table08) 所列。'
- en: Table 6.8\. Two `PUT` requests of the Loc8r API for updating locations and reviews
  id: totrans-1886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.8\. Loc8r API 更新位置和评论的两种 `PUT` 请求
- en: '| Action | Method | URL path | Example |'
  id: totrans-1887
  prefs: []
  type: TYPE_TB
  zh: '| Action | Method | URL path | Example |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1888
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Update a specific location | PUT | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1889
  prefs: []
  type: TYPE_TB
  zh: '| 更新特定位置 | PUT | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '| Update a specific review | PUT | /locations/:locationid/reviews/:reviewid
    | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
  id: totrans-1890
  prefs: []
  type: TYPE_TB
  zh: '| 更新特定评论 | PUT | /locations/:locationid/reviews/:reviewid | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
- en: '`PUT` methods are similar to `POST` methods, because they work by taking form
    data posted to them. But instead of using the data to create new documents in
    the database, `PUT` methods use the data to update existing documents.'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 方法与 `POST` 方法类似，因为它们通过接收发送给它们的表单数据来工作。但与使用数据在数据库中创建新文档不同，`PUT` 方法使用数据来更新现有文档。'
- en: 6.5.1\. Using Mongoose to update a document in MongoDB
  id: totrans-1892
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1\. 使用 Mongoose 更新 MongoDB 中的文档
- en: 'In Loc8r, you may want to update a location to add new facilities, change the
    open times, or amend any of the other data. The approach to updating data in a
    document is probably starting to look familiar:'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Loc8r 中，你可能想要更新位置以添加新设施、更改开放时间或修改其他数据。在文档中更新数据的方法可能已经开始看起来熟悉：
- en: Find the relevant document.
  id: totrans-1894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找相关文档。
- en: Make some changes to the instance.
  id: totrans-1895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对实例进行一些更改。
- en: Save the document.
  id: totrans-1896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Send a JSON response.
  id: totrans-1897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 JSON 响应。
- en: This approach is made possible by the way an instance of a Mongoose model maps
    directly to a document in MongoDB. When your query finds the document, you get
    a model instance. If you make changes to this instance and then save it, Mongoose
    updates the original document in the database with your changes.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是通过 Mongoose 模型实例直接映射到 MongoDB 中的文档的方式实现的。当你的查询找到文档时，你得到一个模型实例。如果你对这个实例进行更改然后保存它，Mongoose
    将使用你的更改更新数据库中的原始文档。
- en: 6.5.2\. Using the Mongoose save method
  id: totrans-1899
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2\. 使用 Mongoose 的 save 方法
- en: You saw this method in action when you updated the average rating value. The
    `save` method is applied to the model instance that the `find()` function returns.
    It expects a callback with the standard parameters of an error object and a returned
    data object.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新平均评分值时，你看到了这个方法的作用。`save` 方法应用于 `find()` 函数返回的模型实例。它期望一个带有标准参数的错误对象和返回数据对象的回调。
- en: 'A cut-down skeleton of this approach is shown in the following code snippet:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了这种方法的一个简化的骨架：
- en: '[PRE218]'
  id: totrans-1902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '***1*** **Finds the document to update**'
  id: totrans-1903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查找要更新的文档**'
- en: '***2*** **Makes a change to the model instance, changing a value of one path**'
  id: totrans-1904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **对模型实例进行更改，更改一个路径的值**'
- en: '***3*** **Saves the document with Mongoose’s save method**'
  id: totrans-1905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用 Mongoose 的 save 方法保存文档**'
- en: '***4*** **Returns a success or failure response**'
  id: totrans-1906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **返回成功或失败响应**'
- en: Here, you can clearly see the separate steps of finding, updating, saving, and
    responding. Fleshing out this skeleton into the `locationsUpdateOne()` controller
    with some error trapping and the data you want to save gives you the following
    listing.
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以清楚地看到查找、更新、保存和响应的单独步骤。通过添加一些错误处理和你要保存的数据，将这个骨架扩展到 `locationsUpdateOne()`
    控制器，可以得到以下列表。
- en: Listing 6.9\. Making changes to an existing document in MongoDB
  id: totrans-1908
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 在 MongoDB 中修改现有文档
- en: '[PRE219]'
  id: totrans-1909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '***1*** **Finds the location document by the supplied ID**'
  id: totrans-1910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **通过提供的 ID 查找位置文档**'
- en: '***2*** **Updates paths with values from the submitted form**'
  id: totrans-1911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用提交表单中的值更新路径**'
- en: '***3*** **Saves the instance**'
  id: totrans-1912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **保存实例**'
- en: '***4*** **Sends an appropriate response, depending on the outcome of the save
    operation**'
  id: totrans-1913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **根据保存操作的结果发送适当的响应**'
- en: There’s clearly a lot more code here, now that it’s fully fleshed out, but you
    can still easily identify the key steps of the update process.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于代码已经完全展开，这里显然有更多的代码，但你仍然可以轻松地识别更新过程的关键步骤。
- en: 'The eagle-eyed among you may have noticed something strange in the `select`
    statement:'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 眼尖的你们中的一些人可能已经注意到了 `select` 语句中的奇怪之处：
- en: '[PRE220]'
  id: totrans-1916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Previously, you used the `select()` method to say which columns you *do want*
    to select. By adding a dash in front of a pathname, you’re stating that you *don’t
    want* to retrieve it from the database. So this `select()` statement says to retrieve
    everything except the `reviews` and the `rating`.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你使用 `select()` 方法来说明你*想要*选择哪些列。通过在路径名前添加一个连字符，你声明你*不想要*从数据库中检索它。因此，这个 `select()`
    语句表示要检索除 `reviews` 和 `rating` 之外的所有内容。
- en: 6.5.3\. Updating an existing subdocument in MongoDB
  id: totrans-1918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.3\. 在 MongoDB 中更新现有子文档
- en: 'Updating a subdocument is exactly the same as updating a document, with one
    exception: after finding the document, you have to find the correct subdocument
    to make your changes. Then the `save` method is applied to the document, not the
    subdocument. So the steps for updating an existing subdocument are'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 更新子文档与更新文档的过程完全相同，只有一个例外：在找到文档后，你必须找到正确的子文档以进行更改。然后应用 `save` 方法到文档上，而不是子文档上。因此，更新现有子文档的步骤如下
- en: Find the relevant document.
  id: totrans-1920
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找相关文档。
- en: Find the relevant subdocument.
  id: totrans-1921
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到相关的子文档。
- en: Make some changes in the subdocument.
  id: totrans-1922
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子文档中进行一些更改。
- en: Save the document.
  id: totrans-1923
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Send a JSON response.
  id: totrans-1924
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送 JSON 响应。
- en: For Loc8r, the subdocuments you’re updating are reviews, so when a review is
    changed, you’ll have to remember to recalculate the average rating. That’s the
    only additional thing you’ll need to add above and beyond the five steps. The
    following listing shows everything put into place in the `reviewsUpdateOne()`
    controller.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Loc8r，你正在更新的子文档是评论，因此当评论被更改时，你必须记得重新计算平均评分。这将是你需要添加的唯一额外内容。以下列表显示了在 `reviewsUpdateOne()`
    控制器中放置的所有内容。
- en: Listing 6.10\. Updating a subdocument in MongoDB
  id: totrans-1926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 在 MongoDB 中更新子文档
- en: '[PRE221]'
  id: totrans-1927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '***1*** **Finds the parent document**'
  id: totrans-1928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查找父文档**'
- en: '***2*** **Finds the subdocument**'
  id: totrans-1929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **查找子文档**'
- en: '***3*** **Makes changes to the subdocument from the supplied form data**'
  id: totrans-1930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **根据提供的表单数据对子文档进行更改**'
- en: '***4*** **Saves the parent document**'
  id: totrans-1931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **保存父文档**'
- en: '***5*** **Returns a JSON response, sending the subdocument object on the basis
    of a successful save**'
  id: totrans-1932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **返回JSON响应，根据成功保存发送子文档对象**'
- en: 'The five steps for updating are clear to see in this listing: find the document;
    find the subdocument; make changes; save; and respond. Once again, a lot of the
    code here is error trapping, but it’s vital for creating a stable, responsive
    API. You don’t want to save incorrect data, send the wrong responses, or delete
    data you don’t want to delete. Speaking of deleting data, you can now move on
    to the final of the four API methods you’re using: `DELETE`.'
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中可以清楚地看到更新的五个步骤：查找文档；查找子文档；进行更改；保存；并响应。再次强调，这里的大部分代码都是错误处理，但对于创建一个稳定、响应式的API至关重要。你不想保存错误的数据，发送错误的响应，或者删除你不想删除的数据。说到删除数据，你现在可以继续到最后一个你使用的四个API方法：`DELETE`。
- en: '6.6\. DELETE method: Deleting data from MongoDB'
  id: totrans-1934
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6\. DELETE方法：从MongoDB中删除数据
- en: The `DELETE` method is, unsurprisingly, all about deleting existing documents
    or subdocuments in the database. In the routes for Loc8r, you have a `DELETE`
    request for deleting a location and another for deleting a review. The details
    are listed in [table 6.9](#ch06table09). Start by taking a look at deleting documents.
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`方法不出所料，完全是关于在数据库中删除现有文档或子文档。在Loc8r的路由中，你有一个用于删除位置的`DELETE`请求，还有一个用于删除评论的请求。详细信息列在[表6.9](#ch06table09)中。首先，让我们看看如何删除文档。'
- en: Table 6.9\. Two `DELETE` requests of the Loc8r API for deleting locations and
    reviews
  id: totrans-1936
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.9\. Loc8r API删除位置和评论的两个`DELETE`请求
- en: '| Action | Method | URL path | Example |'
  id: totrans-1937
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 方法 | URL路径 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1938
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Delete a specific location | DELETE | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
  id: totrans-1939
  prefs: []
  type: TYPE_TB
  zh: '| 删除特定位置 | DELETE | /locations/:locationid | [http://loc8r.com/api/locations/123](http://loc8r.com/api/locations/123)
    |'
- en: '| Delete a specific review | DELETE | /locations/:locationid/reviews/:reviewid
    | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
  id: totrans-1940
  prefs: []
  type: TYPE_TB
  zh: '| 删除特定评论 | DELETE | /locations/:locationid/reviews/:reviewid | [http://loc8r.com/api/locations/123/reviews/abc](http://loc8r.com/api/locations/123/reviews/abc)
    |'
- en: 6.6.1\. Deleting documents in MongoDB
  id: totrans-1941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.1\. 在MongoDB中删除文档
- en: 'Mongoose makes deleting a document in MongoDB extremely simple by giving you
    the method `findByIdAndRemove()`. This method expects a single parameter: the
    ID of the document to be deleted.'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose通过提供`findByIdAndRemove()`方法使在MongoDB中删除文档变得极其简单。此方法期望一个参数：要删除的文档的ID。
- en: The API should respond with a 404 in case of an error and a 204 in case of success.
    The following listing shows everything in place in the `locationsDeleteOne()`
    controller.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: API在出错时应响应404，在成功时应响应204。以下列表显示了`locationsDeleteOne()`控制器中的所有内容。
- en: Listing 6.11\. Deleting a document from MongoDB, given an ID
  id: totrans-1944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11\. 根据ID从MongoDB中删除文档
- en: '[PRE222]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '***1*** **Calls findByIdAndRemove method, passing in locationid**'
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **调用findByIdAndRemove方法，传入locationid**'
- en: '***2*** **Executes the method**'
  id: totrans-1947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **执行方法**'
- en: '***3*** **Responds with failure or success**'
  id: totrans-1948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **响应失败或成功**'
- en: 'That’s the quick and easy way to delete a document, but you can break it into
    a two-step process or, if you prefer, find it and then delete it. This gives you
    the chance to do something with the document before deleting (if you need to).
    This is demonstrated in the following code snippet:'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种快速简单的删除文档的方法，但你也可以将其分解为两步过程，或者如果你更喜欢，先找到它然后删除。这给了你在删除之前对文档进行操作的机会（如果你需要的话）。以下代码片段展示了这一点：
- en: '[PRE223]'
  id: totrans-1950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: This snippet has an extra level of nesting, but with it comes an extra level
    of flexibility, should you need it.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段有一个额外的嵌套层，但如果你需要的话，它带来了额外的灵活性。
- en: 6.6.2\. Deleting a subdocument from MongoDB
  id: totrans-1952
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.2\. 从MongoDB中删除子文档
- en: The process for deleting a subdocument is no different from the other work you’ve
    done with subdocuments; everything is managed through the parent document. The
    steps for deleting a subdocument are
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 删除子文档的过程与其他你使用子文档所做的操作没有区别；所有操作都是通过父文档来管理的。删除子文档的步骤如下
- en: Find the parent document.
  id: totrans-1954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找父文档。
- en: Find the relevant subdocument.
  id: totrans-1955
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找相关的子文档。
- en: Remove the subdocument.
  id: totrans-1956
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除子文档。
- en: Save the parent document.
  id: totrans-1957
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存父文档。
- en: Confirm success or failure of operation.
  id: totrans-1958
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认操作的成功或失败。
- en: 'Deleting the subdocument itself is easy, as Mongoose gives you another helper
    method. You’ve already seen that you can find a subdocument by its ID with the
    `id` method like this:'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 删除子文档本身很简单，因为 Mongoose 给了你另一个辅助方法。你已经看到你可以使用 `id` 方法通过 ID 查找子文档，如下所示：
- en: '[PRE224]'
  id: totrans-1960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Mongoose allows you to chain a `remove` method to the end of this statement
    like so:'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 允许你像这样将 `remove` 方法链接到这个语句的末尾：
- en: '[PRE225]'
  id: totrans-1962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: This instruction deletes the subdocument from the array. Remember to save the
    parent document to persist the change back to the database. Putting all the steps
    together—with a load of error trapping—into the `reviewsDeleteOne()` controller
    looks like the following listing.
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令会从数组中删除子文档。请记住保存父文档以将更改持久化回数据库。将所有步骤（包括大量错误处理）组合到 `reviewsDeleteOne()` 控制器中，如下所示。
- en: Listing 6.12\. Finding and deleting a subdocument from MongoDB
  id: totrans-1964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 在 MongoDB 中查找和删除子文档
- en: '[PRE226]'
  id: totrans-1965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '***1*** **Finds the relevant parent document**'
  id: totrans-1966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查找相关的父文档**'
- en: '***2*** **Finds and deletes the relevant subdocument in one step**'
  id: totrans-1967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **一步查找并删除相关的子文档**'
- en: '***3*** **Saves the parent document**'
  id: totrans-1968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **保存父文档**'
- en: '***4*** **Returns the appropriate success or failure response**'
  id: totrans-1969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **返回适当的成功或失败响应**'
- en: Again, most of the code here is error trapping. The API could return seven possible
    responses, and only one is the successful one. Deleting the subdocument is easy;
    make absolutely sure that you’re deleting the right one.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里的代码大部分是错误处理。API 可能会返回七个可能的响应，只有一个才是成功的。删除子文档很简单；务必确保你删除的是正确的文档。
- en: As you’re deleting a review, which will have a rating associated to it, you
    also have to remember to call the `updateAverageRating()` function to recalculate
    the average rating for the location. This function should only be called if the
    delete operation is successful.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 当你删除一个带有相关评分的评论时，你还得记得调用 `updateAverageRating()` 函数来重新计算位置的平均评分。这个函数只有在删除操作成功时才应该被调用。
- en: And that’s it. You’ve built a REST API in Express and Node that can accept `GET`,
    `POST`, `PUT`, and `DELETE` HTTP requests to perform CRUD operations on a MongoDB
    database.
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你已经构建了一个 Express 和 Node 的 REST API，它可以接受 `GET`、`POST`、`PUT` 和 `DELETE` HTTP
    请求来在 MongoDB 数据库上执行 CRUD 操作。
- en: Coming up in [chapter 7](kindle_split_018.xhtml#ch07), you’ll see how to use
    this API from inside the Express application, finally making the Loc8r site database-driven!
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](kindle_split_018.xhtml#ch07) 中将要介绍，你将看到如何从 Express 应用程序内部使用此 API，最终使
    Loc8r 网站数据库驱动化！
- en: Summary
  id: totrans-1974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: The best practices for creating a REST API, including URLs, request methods,
    and response codes
  id: totrans-1976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 REST API 的最佳实践，包括 URL、请求方法和响应代码
- en: How the `POST`, `GET`, `PUT`, and `DELETE` HTTP request methods map to common
    CRUD operations
  id: totrans-1977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`、`GET`、`PUT` 和 `DELETE` HTTP 请求方法如何映射到常见的 CRUD 操作'
- en: Mongoose helper methods for creating the helper methods
  id: totrans-1978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose 辅助方法用于创建辅助方法
- en: Ways to interact with the data through Mongoose models and how one instance
    of the model maps directly to one document in the database
  id: totrans-1979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Mongoose 模型与数据交互的方式，以及模型的一个实例如何直接映射到数据库中的一个文档
- en: How to manage subdocuments through their parent document
  id: totrans-1980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过父文档管理子文档
- en: Some ways of making the API robust by checking for any possible errors you can
    think of so that a request is never left unanswered
  id: totrans-1981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些通过检查你所能想到的任何可能的错误来使 API 坚固的方法，以确保请求永远不会得到无响应
- en: 'Chapter 7\. Consuming a REST API: Using an API from inside Express'
  id: totrans-1982
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. 消费 REST API：在 Express 中使用 API
- en: '*This chapter covers*'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Calling an API from an Express application
  id: totrans-1984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Express 应用程序中调用 API
- en: Handling and using data returned by the API
  id: totrans-1985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和使用 API 返回的数据
- en: Working with API response codes
  id: totrans-1986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 API 响应代码一起工作
- en: Submitting data from the browser back to the API
  id: totrans-1987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器将数据提交回 API
- en: Validating and trapping errors
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和捕获错误
- en: This chapter is an exciting one! Here’s where you tie the front end to the back
    end for the first time. You’ll remove the hardcoded data from the controllers,
    and eventually show data from the database in the browser instead. You’ll also
    push data back from the browser into the database via the API, creating new subdocuments.
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 这章内容非常精彩！这是你第一次将前端与后端连接起来。你将移除控制器中的硬编码数据，并最终在浏览器中显示数据库中的数据。你还将通过 API 将数据从浏览器推送到数据库，创建新的子文档。
- en: The technology focus for this chapter is on Node and Express. [Figure 7.1](#ch07fig01)
    shows where this chapter fits into the overall architecture and your grand plan.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术重点是 Node 和 Express。[图 7.1](#ch07fig01) 展示了本章在整个架构和宏伟计划中的位置。
- en: Figure 7.1\. This chapter focuses on updating the Express application from [chapter
    4](kindle_split_015.xhtml#ch04) to interact with the REST API developed in [chapter
    6](kindle_split_017.xhtml#ch06).
  id: totrans-1991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 本章的重点是将 Express 应用程序从[第 4 章](kindle_split_015.xhtml#ch04)更新为与在[第 6 章](kindle_split_017.xhtml#ch06)中开发的
    REST API 交互。
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-1992
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01_alt.jpg)'
- en: In this chapter, we’ll discuss how to call an API from within Express and how
    to deal with the responses. You’ll make calls to the API to read from the database
    and write to the database. Along the way, we’ll look at handling errors, processing
    data, and creating reusable code by separating concerns. Toward the end, we’ll
    cover the various layers of the architecture to which you can add validation and
    why these different layers are useful.
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何在 Express 中调用 API 以及如何处理响应。您将对 API 进行调用以从数据库中读取和写入数据。在这个过程中，我们将探讨错误处理、数据处理以及通过分离关注点来创建可重用代码。在结束时，我们将涵盖架构的各个层次，您可以在这些层次上添加验证，以及为什么这些不同的层次是有用的。
- en: Start by looking at how to call an API from an Express application.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看如何从 Express 应用程序调用 API。
- en: 7.1\. How to call an API from Express
  id: totrans-1995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 如何从 Express 调用 API
- en: The first part we need to cover is how to call an API from Express. This approach
    isn’t limited to your API; you can use it to call any API.
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先解决的问题是如何从 Express 调用 API。这种方法不仅限于您的 API；您可以使用它来调用任何 API。
- en: Your Express application needs to be able to call the API URLs that you set
    up in [chapter 6](kindle_split_017.xhtml#ch06)—sending the correct request method,
    of course—and then be able to interpret the response. To help, you’ll use a module
    called `request`.
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Express 应用程序需要能够调用您在[第 6 章](kindle_split_017.xhtml#ch06)中设置的 API URL，当然，发送正确的请求方法，并且能够解释响应。为此，您将使用一个名为
    `request` 的模块。
- en: 7.1.1\. Adding the request module to your project
  id: totrans-1998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 将请求模块添加到您的项目中
- en: 'The `request` module is like any of the other packages you’ve used so far and
    can be added to your project via npm. To install the latest version and add it
    to the package.json file, head to terminal, and type the following command:'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 模块就像您迄今为止使用的其他任何包一样，可以通过 npm 添加到您的项目中。要安装最新版本并将其添加到 package.json
    文件中，请转到终端，并输入以下命令：'
- en: '[PRE227]'
  id: totrans-2000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'When npm finishes doing its thing, you can include `request` in the files that
    will use it. In Loc8r, you have only one file that needs to make API calls: the
    file with the controllers for the main server-side application. So at the top
    of locations.js in app_server/controllers, add the following line to require the
    `request` module:'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 当 npm 完成其操作后，您可以将 `request` 包含在将使用它的文件中。在 Loc8r 中，您只有一个文件需要进行 API 调用：包含主要服务器端应用程序控制器的文件。因此，在
    app_server/controllers 中的 locations.js 文件顶部添加以下行以引入 `request` 模块：
- en: '[PRE228]'
  id: totrans-2002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Now you’re good to go!
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备就绪了！
- en: 7.1.2\. Setting up default options
  id: totrans-2004
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 设置默认选项
- en: Every API call with `request` must have a fully qualified URL, meaning that
    it must include the full address and not be a relative link. But this URL is different
    for development than for live environments.
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用 `request` 调用的 API 都必须有一个完全限定的 URL，这意味着它必须包含完整的地址，而不是一个相对链接。但这个 URL 在开发和生产环境中是不同的。
- en: To avoid having to make this check in every controller that makes an API call,
    you can set a default configuration option once at the top of the controllers
    file. To use the correct URL depending on the environment, you can use your old
    friend the `NODE_ENV` environment variable.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在每个进行 API 调用的控制器中都要进行此检查，您可以在控制器文件顶部设置一个默认配置选项。为了根据环境使用正确的 URL，您可以使用您熟悉的环境变量
    `NODE_ENV`。
- en: Putting this into practice, the top of the app_server/controllers/locations.js
    file should look something like the following listing.
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，app_server/controllers/locations.js 文件的开头应该看起来像以下列表。
- en: Listing 7.1\. Adding request and default API options to the locations.js controllers
    file
  id: totrans-2008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 将请求和默认 API 选项添加到 locations.js 控制器文件
- en: '[PRE229]'
  id: totrans-2009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '***1*** **Sets the default server URL for the local development**'
  id: totrans-2010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置本地开发的默认服务器 URL**'
- en: '***2*** **If the application is running in production mode, sets a different
    base URL; changes to the live address of the application**'
  id: totrans-2011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果应用程序以生产模式运行，则设置不同的基本 URL；更改应用程序的实时地址**'
- en: With this code in place, every call you make to the API can reference `apiOptions.server`
    and use the correct base URL.
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，您对API的每次调用都可以引用`apiOptions.server`并使用正确的基URL。
- en: 7.1.3\. Using the request module
  id: totrans-2013
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3\. 使用请求模块
- en: 'The basic construct for making a request is simple, being a single command
    taking parameters for options and a callback like this:'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求的基本结构很简单，是一个接受选项和回调参数的单个命令，如下所示：
- en: '![](Images/p0203-01.jpg)'
  id: totrans-2015
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0203-01.jpg)'
- en: The options specify everything for the request, including the URL, request method,
    request body, and query string parameters. These options, indeed, are the ones
    you’ll be using in this chapter, and they’re detailed in [table 7.1](#ch07table01).
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 选项指定了请求的所有内容，包括URL、请求方法、请求正文和查询字符串参数。这些选项确实是您在本章中将使用的选项，它们在[表7.1](#ch07table01)中有详细说明。
- en: Table 7.1\. Four common request options for defining a call to an API
  id: totrans-2017
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.1\. 定义API调用时的四个常见请求选项
- en: '| Option | Description | Required |'
  id: totrans-2018
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 | 必需 |'
- en: '| --- | --- | --- |'
  id: totrans-2019
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| url | Full URL of the request to be made, including protocol, domain, path,
    and URL parameters | Yes |'
  id: totrans-2020
  prefs: []
  type: TYPE_TB
  zh: '| url | 要进行的请求的完整URL，包括协议、域名、路径和URL参数 | 是 |'
- en: '| method | Method of the request, such as GET, POST, PUT, or DELETE | No—defaults
    to GET if not specified |'
  id: totrans-2021
  prefs: []
  type: TYPE_TB
  zh: '| method | 请求方法，如GET、POST、PUT或DELETE | 否——如果未指定，则默认为GET |'
- en: '| json | Body of the request as a JavaScript object; an empty object should
    be sent if no body data is needed | Yes—ensures that the response body is also
    parsed as JSON |'
  id: totrans-2022
  prefs: []
  type: TYPE_TB
  zh: '| json | 请求体作为JavaScript对象；如果不需要正文数据，则发送空对象 | 是——确保响应体也被解析为JSON |'
- en: '| qs | JavaScript object representing any query string parameters | No |'
  id: totrans-2023
  prefs: []
  type: TYPE_TB
  zh: '| qs | 表示任何查询字符串参数的JavaScript对象 | 否 |'
- en: 'The following code snippet shows an example of how you might put these options
    together for a `GET` request. A `GET` request shouldn’t have a body to send but
    might have query string parameters:'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了您可能如何将这些选项组合起来进行`GET`请求。`GET`请求不应发送正文，但可能包含查询字符串参数：
- en: '[PRE230]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '***1*** **Defines the URL of the API call to be made**'
  id: totrans-2026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义要进行的API调用的URL**'
- en: '***2*** **Sets the request method**'
  id: totrans-2027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置请求方法**'
- en: '***3*** **Defines the body of the request, even if it’s an empty JSON object**'
  id: totrans-2028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **定义请求的正文，即使它是一个空的JSON对象**'
- en: '***4*** **Optionally adds any query string parameters that might be used by
    the API**'
  id: totrans-2029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **可选地添加API可能使用的任何查询字符串参数**'
- en: 'You could specify many more options, but these four are the most common and
    the ones you’ll use in this chapter. For more information on other possible options,
    take a look at the reference in the GitHub repository: [https://github.com/mikeal/request](https://github.com/mikeal/request).'
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定更多选项，但这四个是最常见的，也是您在本章中将使用的选项。有关其他可能选项的更多信息，请参阅GitHub仓库中的参考：[https://github.com/mikeal/request](https://github.com/mikeal/request)。
- en: 'The callback function runs when a response comes back from the API and has
    three parameters: an error object, the full response, and the parsed body of the
    response. The error object is `null` unless an error has been caught. Three pieces
    of data will be most useful in your code: the status code of the response, the
    body of the response, and any error thrown. The following code snippet shows how
    you might structure a callback for the `request()` function:'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 当API返回响应时，回调函数会运行，并具有三个参数：一个错误对象、完整的响应和解析后的响应正文。除非捕获到错误，否则错误对象是`null`。在您的代码中，最有用的三份数据将是响应的状态码、响应体以及抛出的任何错误。以下代码片段显示了您可能如何为`request()`函数结构化一个回调：
- en: '[PRE231]'
  id: totrans-2032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '***1*** **If an error has passed through, does something with it**'
  id: totrans-2033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果已通过错误，则对其进行处理**'
- en: '***2*** **If a response status code is 200 (request was successful), outputs
    the JSON body of the response**'
  id: totrans-2034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果响应状态码为200（请求成功），则输出响应的JSON正文**'
- en: '***3*** **If the request returns a different status code, outputs the code**'
  id: totrans-2035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果请求返回不同的状态码，则输出该代码**'
- en: The full response object contains a huge amount of information, so we won’t
    go into it here. You can always check it out yourself by using a `console.log`
    statement when you start adding the API calls to your application.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的响应对象包含大量信息，所以我们在这里不会深入探讨。您可以通过在开始将API调用添加到应用程序时使用`console.log`语句来自己检查它。
- en: 'Putting the parts together, the skeleton for making API calls looks like the
    following:'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些部分组合起来，进行API调用的基本结构如下所示：
- en: '[PRE232]'
  id: totrans-2038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '***1*** **Defines options for the request**'
  id: totrans-2039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义请求选项**'
- en: '***2*** **Makes the request, sending through options and supplying a callback
    function to use responses as needed**'
  id: totrans-2040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **发送请求，通过选项发送并通过提供回调函数按需使用响应**'
- en: In the next section, you’ll put this theory into practice and start building
    the Loc8r controllers to use the API you’ve already built.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将把这种理论付诸实践，并开始构建Loc8r控制器以使用您已经构建的API。
- en: '7.2\. Using lists of data from an API: The Loc8r homepage'
  id: totrans-2042
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 使用来自API的数据列表：Loc8r主页
- en: 'By now, the controllers file that will be doing the work should already have
    the `request` module required in and some default values set. Now come the fun
    parts: updating the controllers to call the API and pulling the data for the pages
    from the database.'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，将要执行工作的控制器文件应该已经包含了`request`模块的导入和一些默认值的设置。现在来点有趣的：更新控制器以调用API并从数据库中提取页面数据。
- en: 'You’ve got two main pages that pull data: the homepage, showing a list of locations,
    and a Details page, giving more information about a specific location. Start at
    the beginning and get the data for the homepage from the database.'
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两个主要页面需要提取数据：主页，显示位置列表，以及详细信息页面，提供特定位置更多信息。从开始处获取主页的数据。
- en: The current homepage controller contains a `res.render()` function call, sending
    hardcoded data to the view. But the way you want it to work is to render the homepage
    after the API returns some data. The homepage controller will have quite a lot
    to do anyway, so move this rendering into its own function.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 当前主页控制器包含一个`res.render()`函数调用，将硬编码的数据发送到视图。但您希望的方式是在API返回一些数据后渲染主页。主页控制器无论如何都会有相当多的事情要做，所以将这个渲染移动到它自己的函数中。
- en: '7.2.1\. Separating concerns: Moving the rendering into a named function'
  id: totrans-2046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 分离关注点：将渲染移动到命名函数中
- en: There are a couple of reasons for moving the rendering into its own named function.
    First, you decouple the rendering from the application logic. The process of rendering
    doesn’t care where or how it got the data; if it’s given data in the right format,
    it uses that data. Using a separate function helps you get closer to the testable
    ideal that each function should do one thing. A related bonus is that the function
    becomes reusable, so you can call it from multiple places.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 将渲染移动到自己的命名函数中有几个原因。首先，您将渲染与应用逻辑解耦。渲染过程不关心数据是从哪里或如何获得的；如果提供了正确格式的数据，它就会使用这些数据。使用单独的函数有助于您更接近可测试的理想，即每个函数应该做一件事情。一个相关的额外好处是，该函数变得可重用，因此您可以从多个地方调用它。
- en: 'The second reason for creating a new function for the homepage rendering is
    that the rendering process occurs inside the callback of the API request. In addition
    to making the code hard to test, it makes the code hard to read. The level of
    nesting required makes for a rather large, heavily indented controller function.
    As a point of best practice, you should try to avoid deeply indenting code: it’s
    hard to read and understand when you come back to it.'
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于主页渲染的新函数的第二个原因是渲染过程发生在API请求的回调中。除了使代码难以测试外，它还使代码难以阅读。所需的嵌套级别使得控制器函数相当大，缩进很多。作为一个最佳实践，您应该尽量避免深度缩进代码：当您再次回到它时，它很难阅读和理解。
- en: The first step is making a new function called `renderHomepage()` in the locations.js
    file in the app_server/controllers folder and moving the contents of the `homelist`
    controller into it. Remember to ensure that the new function accepts the `req`
    and `res` parameters too. The following listing shows a stripped-down version
    of what you’re doing here. You can call this code from the `homelist` controller,
    as shown in the listing, and things will work as before.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在`app_server/controllers`文件夹中的locations.js文件中创建一个新的函数`renderHomepage()`，并将`homelist`控制器的内容移动到其中。请记住确保新函数也接受`req`和`res`参数。以下列表显示了您在这里所做的工作的简化版本。您可以从`homelist`控制器中调用此代码，如列表所示，一切将像以前一样工作。
- en: Listing 7.2\. Moving the contents of the `homelist` controller into an external
    function
  id: totrans-2050
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. 将`homelist`控制器的内容移动到外部函数中
- en: '[PRE233]'
  id: totrans-2051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '***1*** **Includes all code from the res.render call here (snipped for brevity)**'
  id: totrans-2052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在此处包含从res.render调用中所有的代码（为了简洁而省略）**'
- en: '***2*** **Calls a new renderHomepage function from the homelist controller**'
  id: totrans-2053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **从homelist控制器调用新的renderHomepage函数**'
- en: This step is a start, but you’re not there yet; you want data!
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步是一个开始，但您还没有完成；您需要数据！
- en: 7.2.2\. Building the API request
  id: totrans-2055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 构建API请求
- en: You’ll get the data you want by asking the API for it, and to do this, you need
    to build the request. To build the request, you need to know the URL, method,
    JSON body, and query string to send. Looking back at [chapter 6](kindle_split_017.xhtml#ch06),
    or indeed at the API code itself, you can see that you need to supply the information
    shown in [table 7.2](#ch07table02).
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过请求API来获取你想要的数据，为此，你需要构建请求。要构建请求，你需要知道要发送的URL、方法、JSON body和查询字符串。回顾[第6章](kindle_split_017.xhtml#ch06)，或者查看API代码本身，你可以看到你需要提供[表7.2](#ch07table02)中所示的信息。
- en: Table 7.2\. Information needed to make a request to the API for a list of locations
  id: totrans-2057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.2\. 向API请求位置列表所需的信息
- en: '| Parameter | Value |'
  id: totrans-2058
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 |'
- en: '| --- | --- |'
  id: totrans-2059
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| URL | SERVER:PORT/api/locations |'
  id: totrans-2060
  prefs: []
  type: TYPE_TB
  zh: '| URL | SERVER:PORT/api/locations |'
- en: '| Method | GET |'
  id: totrans-2061
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | GET |'
- en: '| JSON body | null |'
  id: totrans-2062
  prefs: []
  type: TYPE_TB
  zh: '| JSON body | null |'
- en: '| Query string | lng, lat, maxDistance |'
  id: totrans-2063
  prefs: []
  type: TYPE_TB
  zh: '| 查询字符串 | lng, lat, maxDistance |'
- en: Mapping this information to a request is straightforward. As you saw earlier
    in the chapter, the options for a request are JavaScript objects. For the time
    being, you’ll hardcode values for longitude and latitude into the options, which
    is a quicker and easier method for testing. Later in the book, you’ll make the
    application location-aware. For now, you’ll choose coordinates close to where
    the test data is stored. The maximum distance is set to 20 km.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 将此信息映射到请求是直接的。正如你在本章前面所看到的，请求的选项是JavaScript对象。目前，你将硬编码经纬度值到选项中，这是一种更快、更简单的方法来测试。在本书的后面部分，你将使应用程序具有位置感知能力。现在，你将选择接近测试数据存储位置的坐标。最大距离设置为20公里。
- en: When you make the request, you’ll pass through a simple callback function to
    call the `renderHomepage()` function so that you don’t leave the browser hanging.
    Expressing this idea as code looks like the following listing.
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发起请求时，你将通过一个简单的回调函数来调用`renderHomepage()`函数，这样就不会让浏览器挂起。将这个想法用代码表达如下所示。
- en: Listing 7.3\. Updating the `homelist` Controller to call the API before rendering
    the page
  id: totrans-2066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 更新`homelist`控制器以在渲染页面之前调用API
- en: '[PRE234]'
  id: totrans-2067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '***1*** **Sets the path for the API request. (The server is already set at
    the top of the file.)**'
  id: totrans-2068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置API请求的路径。（服务器已在文件顶部设置。）**'
- en: '***2*** **Sets the request options, including URL, method, empty JSON body,
    and hardcoded query string parameters**'
  id: totrans-2069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置请求选项，包括URL、方法、空的JSON body和硬编码的查询字符串参数**'
- en: '***3*** **Makes request, sending through request options**'
  id: totrans-2070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **发起请求，通过请求选项发送**'
- en: '***4*** **Supplies the callback to render the homepage**'
  id: totrans-2071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **提供回调以渲染主页**'
- en: If you save this code and run the application again, the homepage should display
    exactly as before. You might now be making a request to the API, but you’re ignoring
    the response.
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存此代码并再次运行应用程序，主页应该会显示得和之前完全一样。你现在可能正在向API发起请求，但你正在忽略响应。
- en: 7.2.3\. Using the API response data
  id: totrans-2073
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 使用API响应数据
- en: Seeing as you’re going to the effort of calling the API, the least you can do
    is use the data it’s sending back. You can handle the response more robustly later,
    but you’ll start with making the handler work. In order to make this happen, you’re
    going to assume that a response body is returned to the callback, and you can
    pass it straight into the `renderHomepage()` function, as highlighted in the following
    listing.
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你费心去调用API，至少你应该使用它返回的数据。你可以在以后更稳健地处理响应，但你现在将从使处理器工作开始。为了实现这一点，你将假设响应体被返回到回调中，你可以直接将其传递到`renderHomepage()`函数中，如下所示。
- en: Listing 7.4\. Updating the contents of the `homelist` controller to use the
    API response
  id: totrans-2075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 更新`homelist`控制器的内容以使用API响应
- en: '[PRE235]'
  id: totrans-2076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '***1*** **Passes the body returned by the request to the renderHomepage() function**'
  id: totrans-2077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将请求返回的body传递给renderHomepage()函数**'
- en: You coded the API, so you know that the response body returned by the API should
    be an array of locations. The `renderHomepage()` function needs an array of locations
    to send to the view, so try passing it straight through, making the changes highlighted
    in bold in the following listing.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写了API，所以你知道API返回的响应体应该是一个位置数组。`renderHomepage()`函数需要一个位置数组来发送到视图，所以尝试直接传递，对以下列表中加粗的部分进行更改。
- en: Listing 7.5\. Updating the `renderHomepage` function to use the data from the
    API
  id: totrans-2079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5\. 更新`renderHomepage`函数以使用API数据
- en: '[PRE236]'
  id: totrans-2080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '***1*** **Adds an additional responseBody parameter to the function declaration**'
  id: totrans-2081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在函数声明中添加一个额外的responseBody参数**'
- en: '***2*** **Removes the hardcoded array of locations, and passes the responseBody
    through instead**'
  id: totrans-2082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **移除硬编码的位置数组，并通过 responseBody 传递**'
- en: Can the process be that easy? Try it in the browser to see what happens. We
    hope that you’ll get something like [figure 7.2](#ch07fig02).
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程能这么简单吗？在浏览器中尝试一下，看看会发生什么。我们希望您会得到类似[图 7.2](#ch07fig02)的结果。
- en: 'Figure 7.2\. Initial result using data from the database in the browser: close
    to the desired result'
  id: totrans-2084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 使用浏览器中的数据库数据得到的初始结果：接近期望的结果
- en: '![](Images/07fig02_alt.jpg)'
  id: totrans-2085
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig02_alt.jpg)'
- en: That looks pretty good, right? You need to do something about how the distance
    is displayed, but other than that, the data is coming through as you wanted. Plugging
    in the data was quick and easy because of the work you did up front designing
    the views, building controllers based on the views, and developing the model based
    on the controllers.
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当不错，对吧？您需要处理一下距离的显示方式，但除此之外，数据正如您所期望的那样传输过来。由于您在前期设计视图、基于视图构建控制器以及基于控制器开发模型的工作，插入数据变得快速且简单。
- en: You’ve made it work. Now you need to make it better. There’s no error trapping
    yet, and the distances need some work.
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经让它工作了。现在您需要让它变得更好。目前还没有错误处理，距离需要一些改进。
- en: '7.2.4\. Modifying data before displaying it: fixing the distances'
  id: totrans-2088
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4\. 在显示之前修改数据：修正距离
- en: At the moment, the distances in the list are displaying 15 decimal places and
    no unit of measurement, so they’re extremely accurate and totally useless! You
    want to say whether each distance is in meters or kilometers and round the numbers
    off to a single meter or to one decimal place of a kilometer. You should do this
    before sending the data to the `renderHomepage()` function, as that function should
    be reserved for handling the actual rendering, not sorting out the data.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，列表中的距离显示有 15 位小数，没有单位，因此它们非常精确，但完全无用！您想要说明每个距离是以米还是千米为单位，并将数字四舍五入到单个米或千米的一位小数。您应该在将数据发送到
    `renderHomepage()` 函数之前这样做，因为这个函数应该保留用于处理实际渲染，而不是整理数据。
- en: You need to loop through the array of returned locations, formatting the distance
    value of each one. Rather than do this inline, you’ll create an external function
    (in the same file) called `formatDistance()` that accepts a distance value and
    returns it nicely formatted. Put the following function before `renderHomepage()`
    in the controller file.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要遍历返回的位置数组，格式化每个位置的距离值。而不是直接这样做，您将创建一个外部函数（在同一文件中），称为 `formatDistance()`，它接受一个距离值并返回格式良好的值。在控制器文件中，在
    `renderHomepage()` 之前放置以下函数。
- en: Listing 7.6\. Adding formatDistance function
  id: totrans-2091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 添加 formatDistance 函数
- en: '[PRE237]'
  id: totrans-2092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '***1*** **If the supplied distance is more than 1000 m, converts to km, rounds
    to one decimal place, and adds km unit**'
  id: totrans-2093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果提供的距离超过 1000 米，则转换为千米，四舍五入到一位小数，并添加千米单位**'
- en: '***2*** **Otherwise, rounds down to the nearest meter**'
  id: totrans-2094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **否则，向下取整到最近的米**'
- en: Now make the change as shown in bold in the following listing. Note that the
    framework of the `homelist` controller has been left out of this code snippet.
    To keep things short, the `request` statement still sits inside the controller.
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下列表中加粗所示进行更改。请注意，此代码片段中省略了 `homelist` 控制器的框架。为了使内容简短，`request` 语句仍然位于控制器内部。
- en: Listing 7.7\. Adding and using a function to format the distance returned by
    the API
  id: totrans-2096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 添加并使用一个函数来格式化 API 返回的距离
- en: '[PRE238]'
  id: totrans-2097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '***1*** **Creates a variable for future use**'
  id: totrans-2098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个变量供将来使用**'
- en: '***2*** **Maps the data in an array, formatting the distance value of the location**'
  id: totrans-2099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将数据映射到数组中，格式化位置的距离值**'
- en: '***3*** **Sends the modified data to be rendered instead of the original body
    content**'
  id: totrans-2100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **发送修改后的数据以进行渲染，而不是原始的正文内容**'
- en: You have one small additional change to make. You added `m` to the API output
    for distances, but with the `formatDistance()` function, this addition is no longer
    required, so make the following change in /app_api/controllers/locations.js.
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做一个小小的额外修改。您在 API 输出的距离中添加了 `m`，但使用 `formatDistance()` 函数后，这个添加就不再需要了，所以请在
    `/app_api/controllers/locations.js` 中进行以下更改。
- en: Listing 7.8\. Removing the unit from the API response
  id: totrans-2102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 从 API 响应中移除单位
- en: '[PRE239]'
  id: totrans-2103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '***1*** **Removes m from this line**'
  id: totrans-2104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从这一行中移除 m**'
- en: If you make these changes and refresh the page, you should see that the distances
    are tidied up a bit and are useful, as shown in [figure 7.3](#ch07fig03).
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行这些更改并刷新页面，应该会看到距离被整理了一下，变得更有用，如图[图 7.3](#ch07fig03)所示。
- en: Figure 7.3\. The homepage looks better after you format the distances returned
    by the API.
  id: totrans-2106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3. 在您格式化API返回的距离后，主页看起来更好。
- en: '![](Images/07fig03_alt.jpg)'
  id: totrans-2107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig03_alt.jpg)'
- en: That’s better; the homepage is looking more like you want it to. For extra credit,
    you can add some error trapping to the `formatDistance()` function to make sure
    that a `distance` parameter has been passed and that it’s a number.
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好；主页看起来更符合您的期望。为了加分，您可以在`formatDistance()`函数中添加一些错误捕获，以确保已经传递了一个`distance`参数，并且它是一个数字。
- en: 7.2.5\. Catching errors returned by the API
  id: totrans-2109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5. 捕获API返回的错误
- en: So far, you’ve assumed that the API will always return an array of data along
    with a 200 success code. But this isn’t necessarily the case. You coded the API
    to return a 200 status even if no locations are found nearby. As things stand,
    when this happens, the homepage will display without any content in the central
    area. A far better user experience would be to output a message to the user that
    there are no places nearby.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直假设API将始终返回一个包含200成功状态码的数据数组。但这并不一定。您编写了API，即使没有找到附近的位置，也会返回200状态码。目前的情况是，当这种情况发生时，主页将显示一个中央区域没有任何内容。更好的用户体验将是向用户输出一条消息，说明附近没有地方。
- en: You also know that your API can give 404 errors, so you’ll need to make sure
    you handle these errors appropriately. You don’t want to show a 404 to the user
    in this case, because the error won’t be due to the homepage being missing. The
    better option, again, is to send a message to the browser in the context of the
    homepage.
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 您也知道，您的API可能会返回404错误，因此您需要确保您适当地处理这些错误。在这种情况下，您不希望向用户显示404错误，因为错误不会是由于主页缺失造成的。更好的选择是，再次发送一条消息到浏览器，在主页的上下文中。
- en: Handling these scenarios shouldn’t be too difficult. The following sections
    show you how, starting with the controller.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些场景不应该太难。以下章节将向您展示如何操作，从控制器开始。
- en: Making the request callback more robust
  id: totrans-2113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使请求回调更健壮
- en: One of the main reasons for catching errors is to make sure that they don’t
    cause code to fail. The first point of weakness is in the `request` callback,
    where you’re manipulating the response before sending the data off to be rendered.
    This is fine if the data is always consistent, but you don’t have that luxury.
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获错误的主要原因是为了确保它们不会导致代码失败。第一个弱点在于`request`回调，在那里您在将数据发送到渲染之前正在操作响应。如果数据始终一致，这是可以的，但您没有这样的奢侈。
- en: The `request` callback currently runs a `for` loop to format the distances no
    matter what data is returned by the API. You should run this loop only when the
    API returns a 200 code and some results.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`回调目前运行一个`for`循环来格式化距离，无论API返回什么数据。您应该只在API返回200状态码和一些结果时运行这个循环。'
- en: The following listing shows how to achieve this result by adding a simple `if`
    statement (app_server/controllers/locations.js) checking the status code and the
    length of the returned data.
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何通过添加一个简单的`if`语句（app_server/controllers/locations.js）来检查状态码和返回数据的长度，从而实现这一结果。
- en: Listing 7.9\. Validating that the API has returned some data before trying to
    use it
  id: totrans-2117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9. 在尝试使用API返回的数据之前验证API是否已返回数据
- en: '[PRE240]'
  id: totrans-2118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '***1*** **Uses object destructing to get the statusCode, as that’s all you
    need**'
  id: totrans-2119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用对象解构来获取statusCode，因为您只需要这个**'
- en: '***2*** **Runs a loop to format distances only if the API returned a 200 status
    and some data**'
  id: totrans-2120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **仅在API返回200状态码和一些数据时运行循环来格式化距离**'
- en: Updating this piece of code should prevent this callback from falling over and
    throwing an error if the API responds with a status code other than 200\. The
    link in the chain is the `renderHomepage()` function.
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 更新这段代码应该可以防止在API响应状态码不是200时，这个回调崩溃并抛出错误。链中的链接是`renderHomepage()`函数。
- en: Defining output messages based on the response data
  id: totrans-2122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 根据响应数据定义输出消息
- en: As with the `request` callback, your original focus for the `renderHomepage()`
    function is to make it work when it’s passed an array of locations to display.
    Now that this function might be sent different data types, you need to make it
    handle the possibilities appropriately.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 与`request`回调一样，您最初对`renderHomepage()`函数的关注是使其在传递要显示的位置数组时工作。现在，由于这个函数可能会收到不同类型的数据，您需要使其能够适当地处理这些可能性。
- en: 'The response body could be one of three things:'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体可能是以下三种情况之一：
- en: An array of locations
  id: totrans-2125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置数组
- en: An empty array when no locations are found
  id: totrans-2126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有找到位置时，数组为空
- en: A string containing a message when the API returns an error
  id: totrans-2127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API返回错误时，包含消息的字符串
- en: You already have the code in place to deal with an array of locations, so you
    need to address the other two possibilities. When catching these errors, you also
    want to set a message that can be sent to the view.
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了处理地点数组的代码，所以你需要处理其他两种可能性。在捕获这些错误时，你还需要设置一个可以发送到视图的消息。
- en: 'To do so, you need to update the `renderHomepage()` function to also do the
    following:'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要更新`renderHomepage()`函数，同时还要执行以下操作：
- en: Set a variable container for a message
  id: totrans-2130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个用于消息的变量容器
- en: Check to see whether the response body is an array; if not, set an appropriate
    message
  id: totrans-2131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查响应体是否为数组；如果不是，设置一个适当的消息
- en: If the response is an array, set a different message if it’s empty (that is,
    no locations are returned)
  id: totrans-2132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果响应是数组，如果它是空的（即没有返回地点），则设置不同的消息
- en: Send the message to the view
  id: totrans-2133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息发送到视图
- en: The following listing shows how this looks in code.
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了代码中的样子。
- en: Listing 7.10\. Outputting messages if the API doesn’t return location data
  id: totrans-2135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.10\. 如果API不返回位置数据则输出消息
- en: '[PRE241]'
  id: totrans-2136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '***1*** **Defines a variable to hold a message**'
  id: totrans-2137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义一个变量来保存消息**'
- en: '***2*** **If the response isn’t an array, sets a message and sets the responseBody
    to be an empty array**'
  id: totrans-2138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果响应不是数组，设置一个消息并将responseBody设置为空数组**'
- en: '***3*** **If the response is an array with no length, sets a message**'
  id: totrans-2139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果响应是长度为零的数组，设置一个消息**'
- en: '***4*** **Adds a message to variables to send to the view**'
  id: totrans-2140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **向要发送到视图的变量中添加消息**'
- en: The only surprise is when you set the `responseBody` to be an empty array if
    it was originally passed through as a string. You do this to prevent the view
    from throwing an error. The view expects an array to be sent in the `locations`
    variable; it effectively ignores it if an empty array is sent but throws an error
    if a string is sent.
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的惊喜是当你将`responseBody`设置为空数组时，如果它最初是通过字符串传递的。你这样做是为了防止视图抛出错误。视图期望在`locations`变量中发送一个数组；如果发送一个空数组，它会忽略它，但如果发送一个字符串，则会抛出错误。
- en: The last link in this chain is updating the view to display a message when one
    is sent.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 这条链的最后一个链接是更新视图以在发送消息时显示消息。
- en: Updating the view to display the error messages
  id: totrans-2143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新视图以显示错误消息
- en: You’re catching the errors from the API, and you’re also working with them to
    pass something back to the user. The final step is letting the user see a message
    by adding a placeholder to the view template.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在捕获API的错误，并且你也在处理它们以将某些内容返回给用户。最后一步是通过在视图模板中添加占位符让用户看到消息。
- en: You don’t need to do anything fancy here; a simple `div` with a class of `error`
    to contain any messages will suffice. The following listing shows the `block content`
    section of the homepage view `locations-list.pug` in app_server/views.
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里不需要做任何复杂的事情；一个简单的带有`error`类的`div`来包含任何消息就足够了。以下列表显示了应用服务器视图`locations-list.pug`的主页视图的`block
    content`部分。
- en: Listing 7.11\. Updating the view to display an error message when needed
  id: totrans-2146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.11\. 更新视图以在需要时显示错误消息
- en: '[PRE242]'
  id: totrans-2147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '***1*** **Adds a div to the main content area, and has it display a message
    if one is sent**'
  id: totrans-2148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在主要内容区域添加一个div，并在发送消息时显示它**'
- en: That’s easy—basic, but easy. It will certainly do for now. All that’s left is
    to test it.
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单——基本但简单。现在应该足够了。剩下要做的就是测试它。
- en: Testing the API error trapping
  id: totrans-2150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试API错误捕获
- en: As with any new code, you need to make sure that it works. An easy way to test
    this code is to change the query string values that you’re sending in the `requestOptions`.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 任何新的代码，你都需要确保它能正常工作。测试这段代码的一个简单方法是更改`requestOptions`中发送的查询字符串值。
- en: 'To test the `No places found nearby` trap, you can set the `maxDistance` to
    a small number (remembering that it’s specified in kilometers) or set the `lng`
    and `lat` to a point where there are no locations, as shown in this example:'
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试“附近没有找到地点”的陷阱，你可以将`maxDistance`设置为一个小数值（记住它是以公里为单位的）或者将`lng`和`lat`设置为没有地点的点，如下例所示：
- en: '[PRE243]'
  id: totrans-2153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '***1*** **Changes the query string values sent in the request to get no results
    returned**'
  id: totrans-2154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **更改请求中发送的查询字符串值以获取无结果返回**'
- en: '|  |'
  id: totrans-2155
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Fixing an interesting bug**'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: '**修复一个有趣的错误**'
- en: Did you try testing the API error trapping by setting `lng` or `lat` to `0`?
    You should have been expecting to see the `No places found nearby` message but
    instead saw `API lookup error`, due to a bug in the error trapping in your API
    code.
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 你尝试通过将`lng`或`lat`设置为`0`来测试API错误捕获了吗？你应该期望看到“附近没有找到地点”的消息，但相反你看到了“API查找错误”，这是由于你的API代码中的错误捕获错误导致的。
- en: 'In the `locationsListByDistance` controller, check whether the `lng` and `lat`
    query string parameters were omitted by using a generic “falsey” JavaScript test.
    Your code has this: `if (!lng || !lat)`.'
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`locationsListByDistance`控制器中，使用通用的“falsey”JavaScript测试来检查是否省略了`lng`和`lat`查询字符串参数。您的代码如下：`if
    (!lng || !lat)`。
- en: In falsey tests like this one, JavaScript looks for any of the values that it
    considers to be false, such as an empty string, undefined, `null`, and (important
    for you) `0`. This introduces an unexpected bug into your code. If someone happened
    to be on the equator or on the Prime Meridian (that’s the Greenwich Mean Time
    line), they’d receive an API error.
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类“falsey”测试中，JavaScript会寻找它认为的任何假值，例如空字符串、未定义、`null`以及（对您来说很重要）`0`。这会在您的代码中引入一个意外的错误。如果某人恰好位于赤道或本初子午线（即格林威治标准时间线），他们将收到API错误。
- en: 'You can fix this bug by verifying the falsey test to say, “If it’s false but
    not zero.” In code, this statement looks like this: `if ((!lng && lng !== 0) ||
    (!lat && lat !== 0))`.'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过验证“falsey”测试来修复此错误，使其表示“如果它是假的但不是零”。在代码中，此语句看起来像这样：`if ((!lng && lng !==
    0) || (!lat && lat !== 0))`。
- en: Updating your controller in the API removes this bug.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 更新API中的控制器将消除此错误。
- en: '|  |'
  id: totrans-2162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can use a similar tactic to test the 404 error. The API expects all the
    query string parameters to be sent and returns a 404 if one of them is missing.
    To test the code quickly, you can comment one of them out:'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似的策略来测试404错误。API期望所有查询字符串参数都被发送，如果其中一个缺失，则返回404。为了快速测试代码，您可以注释掉其中一个参数：
- en: '[PRE244]'
  id: totrans-2164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '***1*** **Comment out one query string parameter in the request to help test
    what happens when the API returns 404.**'
  id: totrans-2165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在请求中注释掉一个查询字符串参数以帮助测试当API返回404时会发生什么。**'
- en: Do these two things one at a time and refresh the homepage to see the different
    messages coming through. These messages are shown in [figure 7.4](#ch07fig04).
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: 一次做这两件事，刷新主页以查看不同的消息。这些消息在[图7.4](#ch07fig04)中显示。
- en: Figure 7.4\. Showing error messages in the view after trapping the errors being
    returned
  id: totrans-2167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4. 显示在捕获返回的错误后在视图中显示的错误消息
- en: '![](Images/07fig04_alt.jpg)'
  id: totrans-2168
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig04_alt.jpg)'
- en: That figure shows the homepage set up nicely. Your Express application queries
    the API you built, which pulls data from the MongoDB database and passes it back
    to the application. When the application gets a response from the API, it works
    out what to do with it and shows either the data or an error message in the browser.
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 那个图显示了设置得很好的主页。您的Express应用程序查询您构建的API，该API从MongoDB数据库中提取数据并将其传递回应用程序。当应用程序从API收到响应时，它会确定如何处理它，并在浏览器中显示数据或错误消息。
- en: Next, you’ll do the same thing for the Details page, this time working with
    single instances of data.
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将为详情页面做同样的事情，这次处理单个数据实例。
- en: '7.3\. Getting single documents from an API: The Loc8r Details page'
  id: totrans-2171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 从API获取单个文档：Loc8r详情页面
- en: The Details page should display all the information you have about a specific
    location, from the name and address to ratings, reviews, facilities, and a location
    map. At the moment, this page is using data hardcoded into the controller and
    looks like [figure 7.5](#ch07fig05).
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 详情页面应显示您关于特定位置的所有信息，从名称和地址到评分、评论、设施和位置地图。目前，此页面正在使用控制器中硬编码的数据，看起来像[图7.5](#ch07fig05)。
- en: Figure 7.5\. The Details page as it is now, using data hardcoded into the controller
  id: totrans-2173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5. 现在的详情页面，使用控制器中硬编码的数据
- en: '![](Images/07fig05_alt.jpg)'
  id: totrans-2174
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig05_alt.jpg)'
- en: In this section, you’ll update the application so that it allows you to specify
    which location you want the details for, get the details from the API, and output
    them to the browser. You’ll also add some error trapping, of course.
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将更新应用程序，使其允许您指定您想要获取详情的位置，从API获取详情，并将它们输出到浏览器。当然，您还会添加一些错误处理。
- en: 7.3.1\. Setting URLs and routes to access specific MongoDB documents
  id: totrans-2176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1. 设置URL和路由以访问特定的MongoDB文档
- en: The current path you have to the Details page is /location. This path doesn’t
    offer a way to specify which location you want to look at. To address this situation,
    you can borrow the approach from the API routes, where you specify the ID of the
    location document as a URL parameter.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: 您当前访问详情页面的路径是/location。此路径没有提供指定您想要查看的位置的方法。为了解决这个问题，您可以借鉴API路由的方法，在那里您将位置文档的ID指定为URL参数。
- en: 'The API route for a single location is /api/location/:locationid. You can do
    the same thing for the main Express application and update the route to contain
    the `locationid` parameter. The main application routes for locations are in index.js
    in the /routes folder. The following code snippet shows the simple change needed
    to update the location detail route to accept the `locationid` URL parameter (app_server/routes/index.js):'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 单个位置的路由 API 是 /api/location/:locationid。你可以为主要的 Express 应用程序做同样的事情，并更新路由以包含
    `locationid` 参数。位置的主要应用程序路由在 `/routes` 文件夹中的 index.js 文件中。以下代码片段显示了更新位置详情路由以接受
    `locationid` URL 参数所需的简单更改（app_server/routes/index.js）：
- en: '[PRE245]'
  id: totrans-2179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '***1* Adds the locationid parameter to the route for a single location**'
  id: totrans-2180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为单个位置的路由添加 locationid 参数**'
- en: Okay, great, but where do you get the IDs of the locations from? Thinking about
    the application as a whole, the homepage is the best place to start, as that’s
    where the links for the Details page come from.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，但你是从哪里获取位置 ID 的呢？从整个应用程序的角度考虑，主页是最好的起点，因为详情页的链接都是从主页来的。
- en: When the API for the homepage returns an array of locations, each location object
    contains its unique ID. This entire object is already passed to the view, so it
    shouldn’t be too difficult to update the homepage view to add this ID as a URL
    parameter.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 当主页 API 返回位置数组时，每个位置对象都包含其唯一的 ID。这个整个对象已经传递到视图中，所以更新主页视图以添加这个 ID 作为 URL 参数不应该太难。
- en: It’s not difficult at all, in fact! The following listing shows the little change
    that needs to be made in the locations-list.pug file to append the unique ID of
    each location to the link through to the Details page.
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点也不难！以下列表显示了在 locations-list.pug 文件中需要进行的微小更改，以便将每个位置的唯一 ID 添加到链接中，以便通过详情页。
- en: Listing 7.12\. Updating the list view to add the location ID to the relevant
    links
  id: totrans-2184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. 更新列表视图以添加位置 ID 到相关链接
- en: '[PRE246]'
  id: totrans-2185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '***1*** **As each location in the array is looped through, pulls the unique
    ID from the object and appends it to href for a link to the Details page**'
  id: totrans-2186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在遍历数组中的每个位置时，从对象中提取唯一的 ID 并将其添加到链接的 href 中** '
- en: If only everything in life were that easy. Now the homepage contains unique
    links for each of the locations, and the links all click through to the Details
    page. Now you need to make them show the correct data.
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生活中的一切都这么简单就好了。现在主页包含了每个位置的唯一链接，所有链接都点击通过到详情页。现在你需要让它们显示正确的数据。
- en: '7.3.2\. Separating concerns: Moving the rendering into a named function'
  id: totrans-2188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 分离关注点：将渲染移动到命名函数
- en: As you did for the homepage, you’ll move the rendering of the Details page into
    its own named function. Again, you do this to keep the rendering functionality
    separate from the API call and data processing.
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你对主页所做的那样，你将详情页的渲染移动到其自己的命名函数中。再次强调，你这样做是为了将渲染功能与 API 调用和数据处理分离。
- en: The following listing shows a trimmed-down version of the new `renderDetailPage()`
    function and how it’s called from the `locationInfo` controller.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了新的 `renderDetailPage()` 函数的简化版本以及它是如何从 `locationInfo` 控制器中调用的。
- en: Listing 7.13\. Moving contents of the `locationInfo` controller into an external
    function
  id: totrans-2191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. 将 `locationInfo` 控制器的内容移动到外部函数
- en: '[PRE247]'
  id: totrans-2192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '***1*** **Creates a new function called renderDetailPage and moves all contents
    of the locationInfo controller into it**'
  id: totrans-2193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建了一个名为 renderDetailPage 的新函数，并将 locationInfo 控制器的所有内容移动到其中**'
- en: '***2*** **Calls a new function from the controller, remembering to pass it
    req and res parameters**'
  id: totrans-2194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **从控制器调用一个新函数，记得传递 req 和 res 参数**'
- en: Now you’re set up with a nice, clear controller, ready to query the API.
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了一个清晰、简洁的控制器，准备查询 API。
- en: 7.3.3\. Querying the API using a unique ID from a URL parameter
  id: totrans-2196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 使用 URL 参数中的唯一 ID 查询 API
- en: The URL for the API call needs to contain the ID of the location. Your Details
    page has this ID now as the URL parameter `locationid`, so you can get the value
    of this by using `req.params` and add it to the `path` in the request options.
    The request is a `GET` request, so the `json` value will be an empty object.
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: API 调用的 URL 需要包含位置的 ID。你的详情页现在有这个 ID，作为 URL 参数 `locationid`，因此你可以通过使用 `req.params`
    获取这个值，并将其添加到请求选项中的 `path`。请求是一个 `GET` 请求，所以 `json` 值将是一个空对象。
- en: Knowing all this, you can use the pattern you created in the homepage controller
    to build and make the request to the API. You’ll call the `renderDetailPage()`
    function when the API responds. All this is shown in the following listing.
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些后，你可以使用在主页控制器中创建的模式来构建对API的请求。当API响应时，你会调用`renderDetailPage()`函数。所有这些都在以下列表中展示。
- en: Listing 7.14\. Updating the `locationInfo` controller to call the API
  id: totrans-2199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.14\. 更新`locationInfo`控制器以调用API
- en: '[PRE248]'
  id: totrans-2200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '***1*** **Gets the locationid parameter from the URL and appends it to the
    API path**'
  id: totrans-2201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从URL中获取locationid参数并将其附加到API路径**'
- en: '***2*** **Sets all request options needed to call the API**'
  id: totrans-2202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置所有调用API所需的请求选项**'
- en: '***3*** **Calls the renderDetailPage() function when the API has responded**'
  id: totrans-2203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **当API响应时调用renderDetailPage()函数**'
- en: If you run this code now, you’ll see the same static data as before, as you’re
    not yet passing the data returned from the API into the view. You can add some
    console log statements to the `request` callback if you want to have a quick look
    at what’s being returned.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行此代码，你会看到与之前相同的静态数据，因为你还没有将API返回的数据传递到视图中。如果你想快速查看返回的内容，可以在`request`回调中添加一些控制台日志语句。
- en: If you’re happy that everything is working as it should, it’s time for you to
    pass the data into the view.
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确认一切按预期工作，那么是时候将数据传递到视图中了。
- en: 7.3.4\. Passing the data from the API to the view
  id: totrans-2206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.4\. 将API数据传递给视图
- en: 'You’re currently assuming that the API is returning the correct data; you’ll
    get around to error trapping soon. This data needs a small amount of preprocessing:
    the coordinates are returned from the API as an array, but the view needs them
    to be named key-value pairs in an object.'
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 你目前假设API返回的是正确数据；你很快就会处理错误检测。这些数据需要一点预处理：API返回的坐标是一个数组，但视图需要它们作为对象中的命名键值对。
- en: The following listing shows how you can do this in the context of the `request`
    statement, transforming the data from the API before sending it to the `renderDetailPage()`
    function.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何在`request`语句的上下文中执行此操作，在将数据发送到`renderDetailPage()`函数之前，将API中的数据转换。
- en: Listing 7.15\. Preprocessing data in the controller
  id: totrans-2209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.15\. 在控制器中预处理数据
- en: '[PRE249]'
  id: totrans-2210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '***1*** **Creates a copy of the returned data in a new variable**'
  id: totrans-2211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在新的变量中创建返回数据的副本**'
- en: '***2*** **Resets the coords property to be an object, setting lng and lat using
    values pulled from the API response**'
  id: totrans-2212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将coords属性重置为对象，使用从API响应中提取的值设置lng和lat**'
- en: '***3*** **Sends the transformed data to be rendered**'
  id: totrans-2213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **发送要渲染的转换后数据**'
- en: The next logical step is updating the `renderDetailPage()` function to use this
    data rather than the hardcoded data. To make this work, you need to make sure
    that the function accepts the data as a parameter and then update the values passed
    through to the view as required. The following listing highlights the changes
    needed in bold.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是更新`renderDetailPage()`函数以使用这些数据而不是硬编码的数据。为了使这可行，你需要确保该函数接受数据作为参数，然后根据需要更新传递给视图的值。以下列表以粗体突出显示了所需的更改。
- en: Listing 7.16\. Updating `renderDetailPage` to accept and use data from the API
  id: totrans-2215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.16\. 更新`renderDetailPage`以接受和使用API数据
- en: '[PRE250]'
  id: totrans-2216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '***1*** **Adds a new parameter for data in the function definition**'
  id: totrans-2217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在函数定义中添加一个用于数据的新的参数**'
- en: '***2*** **References specific items of data as needed in the function**'
  id: totrans-2218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在函数中根据需要引用具体的数据项**'
- en: '***3*** **Passes the full location data object to the view, containing all
    the details**'
  id: totrans-2219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将包含所有详细信息的完整位置数据对象传递给视图**'
- en: You’re able to take the approach of sending the full object through like this
    because you originally based the data model on what was needed by the view and
    the controller. If you run the application now, you should see that the page loads
    with the data pulled from the database, as shown in [figure 7.6](#ch07fig06).
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取发送完整对象的方法，因为你最初基于视图和控制器所需的数据构建数据模型。如果你现在运行应用程序，你应该会看到页面加载了从数据库中检索的数据，如图[图7.6](#ch07fig06)所示。
- en: Figure 7.6\. Details page pulling in data from MongoDB via the API
  id: totrans-2221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6\. 详细页面通过API从MongoDB中拉取数据
- en: '![](Images/07fig06_alt.jpg)'
  id: totrans-2222
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig06_alt.jpg)'
- en: 'The eagle-eyed reader will have noticed a problem with the screenshot in [figure
    7.6](#ch07fig06): the review doesn’t have a date associated with it.'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 留意细节的读者会发现[图7.6](#ch07fig06)中的截图存在问题：评论没有与之关联的日期。
- en: 7.3.5\. Debugging and fixing the view errors
  id: totrans-2224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.5\. 调试和修复视图错误
- en: So you have a problem with the view, which isn’t outputting the review date
    correctly. You built the data model based on the data provided by the view and
    controller, but now you see that you don’t have enough information. In this section,
    you’ll take a look at what’s going on.
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你遇到了一个视图问题，它没有正确输出评论日期。你基于视图和控制器提供的数据构建了数据模型，但现在你发现信息不足。在本节中，你将查看发生了什么。
- en: 'Starting with looking at the Pug file location-info.pug in app_server/views,
    you can isolate the line that outputs this section:'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: 从查看`app_server/views`中的Pug文件location-info.pug开始，你可以隔离输出此部分的行：
- en: '[PRE251]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Now you need to check the schema to see whether you changed something when
    defining the model. The schema for reviews is in locations.js in app_api/models
    and looks like the following code snippet:'
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要检查模式（schema）以查看在定义模型时是否进行了更改。评论的schema位于`app_api/models`中的locations.js，如下代码片段所示：
- en: '[PRE252]'
  id: totrans-2229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Ah, yes; here you can see that you changed the timestamp to `createdOn`, which
    is a more accurate name for the path.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，是的；在这里你可以看到你将时间戳改为了`createdOn`，这是一个更准确的路径名称。
- en: 'Updating the Pug file with this value looks like the following:'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此值更新Pug文件看起来如下：
- en: '[PRE253]'
  id: totrans-2232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Making these changes and refreshing the page gives you [figure 7.7](#ch07fig07).
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些更改并刷新页面后，你会得到[图7.7](#ch07fig07)。
- en: Figure 7.7\. Pulling the name and date directly from the returned data; the
    format of the date isn’t user friendly.
  id: totrans-2234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7\. 直接从返回的数据中提取名称和日期；日期的格式对用户来说不够友好。
- en: '![](Images/07fig07_alt.jpg)'
  id: totrans-2235
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig07_alt.jpg)'
- en: Success! Of sorts. The date is now showing, but not quite in the user-readable
    format that you’d like to see. You should be able to fix this problem by using
    Pug.
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！某种程度上。日期现在显示出来了，但并不是你希望看到的那种用户可读的格式。你应该能够通过使用Pug来修复这个问题。
- en: 7.3.6\. Formatting dates using a Pug mixin
  id: totrans-2237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.6\. 使用Pug混合格式化日期
- en: Back when you were setting up the views, you used a Pug mixin to output the
    rating stars based on the rating number provided. In Pug, mixins are like functions;
    you can send parameters when you call them, run some JavaScript code if you want,
    and have them generate some output.
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置视图时，你使用了一个Pug混合来根据提供的评分数字输出评分星级。在Pug中，混合就像函数一样；你可以调用它们时传递参数，如果你想的话，运行一些JavaScript代码，并让它们生成一些输出。
- en: Formatting dates could be useful in several places, so create a mixin to do
    the job. Your `outputRating` mixin is in the shared HTMLfunctions.pug file in
    app_server/views/_includes. Add a new mixin called `formatDate` to that file.
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个地方格式化日期可能很有用，因此创建一个混合（mixin）来完成这项工作。你的`outputRating`混合在`app_server/views/_includes`中的共享HTMLfunctions.pug文件里。向该文件添加一个新的混合，名为`formatDate`。
- en: In this mixin, you’ll largely use JavaScript to convert the date from the long
    ISO format to the more readable format *Day Month Year* (such as *10 May 2017*).
    The ISO date object arrives here as a string, so the first thing to do is convert
    it to a JavaScript date object. When that’s done, you’ll be able to use various
    JavaScript date methods to access the various parts of the date.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个混合中，你将主要使用JavaScript将日期从长ISO格式转换为更易读的格式*Day Month Year*（例如*10 May 2017*）。ISO日期对象以字符串形式到达这里，所以首先要做的事情是将它转换为JavaScript日期对象。完成这个操作后，你将能够使用各种JavaScript日期方法来访问日期的各个部分。
- en: The following listing shows how to do this in a mixin. Remember that lines of
    JavaScript in a Pug file must be prefixed by a dash.
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何在混合中完成这个操作。记住，在Pug文件中的JavaScript代码行必须以一个短横线为前缀。
- en: Listing 7.17\. Creating a Jade mixin to format the dates
  id: totrans-2242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.17\. 创建一个Jade混合来格式化日期
- en: '[PRE254]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '***1*** **Converts the date provided from a string to a date object**'
  id: totrans-2244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将提供的日期字符串转换为日期对象**'
- en: '***2*** **Sets up an array of values for the names of the months**'
  id: totrans-2245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置一个包含月份名称的值的数组**'
- en: '***3*** **Uses JavaScript data methods to extract and convert the required
    parts of the date**'
  id: totrans-2246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用JavaScript数据方法提取和转换日期的所需部分**'
- en: '***4*** **Puts the parts back together in the desired format and renders output**'
  id: totrans-2247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将部分重新组合成所需的格式并渲染输出**'
- en: 'Now, that mixin takes a date and processes it to output in the format that
    you want. As the mixin renders the output, you simply need to call it from the
    correct place in the code. The following code demonstrates this call, again based
    on the same two isolated lines from the whole template:'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个混合接受一个日期并对其进行处理，以输出你想要的格式。当混合渲染输出时，你只需从代码中的正确位置调用它。以下代码演示了这次调用，再次基于整个模板中的相同两个独立的行：
- en: '[PRE255]'
  id: totrans-2249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '***1*** **Calls the mixin from its own line, passing the creation date of the
    review (make sure that the new line is correctly indented)**'
  id: totrans-2250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从自己的行调用mixin，传递评论的创建日期（确保新行正确缩进）**'
- en: The call to the mixin should be placed on a new line, so you’ll need to remember
    to take care with the indentation; the date should be nested inside the `<small>`
    tag. Now the Details page is complete and looking like it should, as shown in
    [figure 7.8](#ch07fig08).
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 应将mixin的调用放在新的一行上，所以你需要记住注意缩进；日期应该嵌套在`<small>`标签内。现在详情页面已经完成，看起来应该像[图7.8](#ch07fig08)中所示的那样。
- en: Figure 7.8\. The complete Details page. The ID of the location is passed from
    the URL to the API, and the API retrieves the data and passes it back to the page
    to be formatted and rendered correctly.
  id: totrans-2252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8\. 完整的详情页面。位置ID从URL传递到API，API检索数据并将其格式化后返回到页面进行正确渲染。
- en: '![](Images/07fig08_alt.jpg)'
  id: totrans-2253
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig08_alt.jpg)'
- en: Excellent; that’s exactly what you wanted. If the URL contains an ID that’s
    found in the database, the page displays nicely. But what happens if the ID is
    wrong or isn’t found in the database?
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 很好；这正是你想要的。如果URL中包含数据库中找到的ID，页面将很好地显示。但如果ID错误或未在数据库中找到呢？
- en: 7.3.7\. Creating status-specific error pages
  id: totrans-2255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.7\. 创建特定状态的错误页面
- en: If the ID from the URL isn’t found in the database, the API returns a 404 error.
    This error originates from the URL in the browser, so the browser should also
    return a 404; the data for the ID wasn’t found, so in essence, the page can’t
    be found.
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URL中的ID在数据库中找不到，API将返回404错误。这个错误源于浏览器中的URL，因此浏览器也应该返回404；找不到该ID的数据，所以本质上页面是无法找到的。
- en: 'Using techniques you’ve already seen in this chapter, you can easily catch
    when the API returns a 404 status by using `response.statusCode` in the `request`
    callback. You don’t want to deal with it inside the callback, so you’ll pass the
    flow into a new function that you can call: `showError()`.'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用本章中已经看到的技术，你可以轻松地捕获API返回404状态码的情况，在`request`回调中使用`response.statusCode`。你不想在回调中处理它，所以你会将流程传递到一个新的函数中，你可以调用它：`showError()`。
- en: Catching all error codes
  id: totrans-2258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 捕获所有错误代码
- en: Even better than trapping for a 404 response, you can flip it on its head and
    look for any response from the API that isn’t a 200 success response. You can
    pass the status code to the `showError()` function and let it figure out what
    to do. To enable the `showError()` function to keep control, you’ll also pass
    through the `req` and `res` objects.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获404响应比捕获更好，你可以将其颠倒过来，寻找API返回的任何不是200成功响应的响应。你可以将状态码传递给`showError()`函数，让它决定如何处理。为了使`showError()`函数保持控制，你还将传递`req`和`res`对象。
- en: The following listing shows how to update the `request` callback to render the
    Details page for successful API calls and route all other errors to the catchall
    function `showError()`.
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何更新`request`回调以渲染成功API调用详情页面，并将所有其他错误路由到`showError()`捕获函数。
- en: Listing 7.18\. Trapping any errors caused by the API not returning a 200 status
  id: totrans-2261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.18\. 捕获API未返回200状态码引起的任何错误
- en: '[PRE256]'
  id: totrans-2262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '***1*** **You’re interested only in the statusCode, so get only that.**'
  id: totrans-2263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **你只对statusCode感兴趣，所以只获取它。**'
- en: '***2*** **Checks a for successful response from the API**'
  id: totrans-2264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查API是否返回成功响应**'
- en: '***3*** **Continues with rendering the page if the check was successful**'
  id: totrans-2265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果检查成功，则继续渲染页面**'
- en: '***4*** **If check wasn’t successful, passes the error to the showError() function.**'
  id: totrans-2266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **如果检查不成功，将错误传递给`showError()`函数。**'
- en: Great; now you’ll try to render the Details page if you have something from
    the API to display. What shall you do with the errors? Well, for now you want
    to send a message to the users, letting them know that there’s a problem.
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 很好；现在如果你从API获取了一些要显示的内容，你将尝试渲染详情页面。对于错误，你打算怎么办？嗯，目前你想要向用户发送一条消息，让他们知道存在问题。
- en: Displaying error messages
  id: totrans-2268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示错误消息
- en: You don’t want to do anything fancy here—only let users know that something
    is going on and give them some indication of what it is. You already have a generic
    Pug template that’s suitable for this purpose; it’s called generic-text.pug and
    expects only a title and some content. That will do you.
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想在这里做任何花哨的事情——只需让用户知道正在发生某些事情，并给他们一些关于它是什么的指示。你已经有一个适合此目的的通用Pug模板；它被称为`generic-text.pug`，只需要一个标题和一些内容。这就足够了。
- en: If you wanted to, you could create a unique page and layout for each type of
    error, but for now, you’re satisfied with catching it and letting the user know.
    As well as letting the user know, you should let the browser know by returning
    the appropriate status code when the page is displayed.
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以为每种错误类型创建一个独特的页面和布局，但到目前为止，你只是满足于捕获它并让用户知道。此外，你应通过在页面显示时返回适当的状态码来让浏览器知道。
- en: The following listing shows what the `showError()` function looks like, accepting
    a status parameter that, as well as being passed through as the response status
    code, is used to define the title and content of the page. Here, you have a specific
    message for a 404 page and a generic message for any other errors that are passed.
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`showError()`函数的样子，它接受一个状态参数，除了作为响应状态码传递之外，还用于定义页面的标题和内容。在这里，您有一个针对404页面的特定消息，以及针对传递的任何其他错误的通用消息。
- en: Listing 7.19\. Creating an error-handling function for API status codes that
    aren’t 200
  id: totrans-2272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.19\. 为非200状态码的API状态码创建错误处理函数
- en: '[PRE257]'
  id: totrans-2273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '***1*** **If the status passed through is 404, sets the title and content for
    the page**'
  id: totrans-2274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果通过的状态是404，则设置页面的标题和内容**'
- en: '***2*** **Otherwise, sets a generic catchall message**'
  id: totrans-2275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **否则，设置一个通用的捕获消息**'
- en: '***3*** **Uses the status parameter to set a response status**'
  id: totrans-2276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用状态参数设置响应状态**'
- en: '***4*** **Sends data to the view to be compiled and sent to the browser**'
  id: totrans-2277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将数据发送到视图进行编译并发送到浏览器**'
- en: This function can be reused from any of the controllers where you might find
    it useful. It’s also built in such a way that you can easily add new, specific
    error messages for particular codes if you want to.
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以从任何你可能觉得有用的控制器中重用。它还构建得易于添加新的、特定的错误消息，如果你想要的话。
- en: You can test the 404 error page by slightly changing the location ID in the
    URL, and you should see something like [figure 7.9](#ch07fig09).
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过稍微更改URL中的位置ID来测试404错误页面，您应该会看到类似于[图7.9](#ch07fig09)的内容。
- en: Figure 7.9\. The 404 error page displayed when the location ID in the URL isn’t
    found in the database by the API
  id: totrans-2280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9\. 当API在数据库中找不到URL中的位置ID时显示的404错误页面
- en: '![](Images/07fig09_alt.jpg)'
  id: totrans-2281
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig09_alt.jpg)'
- en: That brings you to the end of the Details page. You can successfully display
    all the information from the database for a given location and also display a
    404 message to the visitor if the location can’t be found.
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带您来到了详情页的结尾。您可以成功显示给定位置的数据库中的所有信息，如果找不到位置，还可以向访客显示404消息。
- en: Following through the user journey, your next and final task is adding the ability
    to add reviews.
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着用户旅程继续前进，您的下一个也是最后的任务是添加添加评论的功能。
- en: '7.4\. Adding data to the database via the API: add Loc8r reviews'
  id: totrans-2284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 通过API将数据添加到数据库：添加Loc8r评论
- en: In this section, you’ll see how to take form data submitted by a user, process
    it, and post it to the API. Reviews are added to Loc8r by clicking the Add Review
    button on a location’s Details page, filling in a form, and submitting it. That’s
    the plan, anyway. You currently have the views to do this but not the underlying
    functionality to make it happen. You need to change that situation right now.
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解如何处理用户提交的表单数据，对其进行处理，并将其发布到API。通过点击位置详情页上的“添加评论”按钮，填写表单并提交，评论被添加到Loc8r。无论如何，这是计划。您目前有执行此操作的视图，但没有实现其底层功能的代码。您需要立即改变这种情况。
- en: 'Here’s a list of the things you’ll do:'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个你将要做的列表：
- en: Make the review form aware of which location the review will be for.
  id: totrans-2287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让评论表单知道评论将针对哪个位置。
- en: Create a route for the form to `POST` to.
  id: totrans-2288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为表单创建一个`POST`路由。
- en: Send the new review data to the API.
  id: totrans-2289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的评论数据发送到API。
- en: Show the new review in place on the Details page.
  id: totrans-2290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详情页上显示新的评论。
- en: Note that at this stage in development, you don’t have an authentication method
    in place, so you have no concept of user accounts.
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在当前的开发阶段，你还没有设置认证方法，因此你没有用户账户的概念。
- en: 7.4.1\. Setting up the routing and views
  id: totrans-2292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. 设置路由和视图
- en: The first item on your list involves getting the ID of the location to the Add
    Review page in such a way that you can use it when the form is submitted. After
    all, this ID is the unique identifier that the API needs to add a review. The
    best approach for getting the ID to the page is to contain it in the URL, as you
    did for the Details page itself.
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 您列表中的第一项涉及将位置的ID添加到“添加评论”页面，以便在表单提交时使用。毕竟，这个ID是API添加评论所需的唯一标识符。将ID添加到页面的最佳方法是将它包含在URL中，就像您为详情页面本身所做的那样。
- en: Defining the two review routes
  id: totrans-2294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义两个评论路由
- en: Getting the location ID into the URL means changing the route of the Add Review
    page to add a `locationid` parameter. While you’re at it, you can deal with the
    second item on the list and create a route for the form to `POST` to. Ideally,
    this route should have the same path as the review form and be associated with
    a different request method and a different controller. To do this, you’ll update
    to the `router.route` syntax, making it clear that you’re using a single route
    with two different methods.
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 将位置ID放入URL意味着更改“添加评论”页面的路由，以添加一个`locationid`参数。在此过程中，您还可以处理列表上的第二项，为表单创建一个`POST`请求的路由。理想情况下，这个路由应该与评论表单有相同的路径，并关联不同的请求方法和不同的控制器。为此，您将更新到`router.route`语法，使其明确您正在使用一个具有两种不同方法的单个路由。
- en: 'The following code snippet shows how you can update the routes in index.js
    in the app_server/routes folder:'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何在`app_server/routes`文件夹中的index.js中更新路由：
- en: '[PRE258]'
  id: totrans-2297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '***1*** **Updates to router.route syntax, and inserts a locationid parameter
    into the review form route**'
  id: totrans-2298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **更新router.route语法，并在评论表单路由中插入locationid参数**'
- en: '***2*** **Creates a new route on the same URL, but using the POST method and
    referencing a different controller**'
  id: totrans-2299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在相同的URL上创建一个新的路由，但使用POST方法并引用不同的控制器**'
- en: 'Those routes are all you’ll need for this section, but restarting the application
    will fail because the `POST` route references a controller that doesn’t exist.
    You can fix this problem by adding a placeholder function to the controller file.
    Add the following code snippet to locations.js in app_server/controllers, and
    add `doAddReview` to the exports list at the bottom. Then the application will
    fire up successfully once again:'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由就是本节所需的所有内容，但重新启动应用程序将失败，因为`POST`路由引用了一个不存在的控制器。您可以通过向控制器文件添加一个占位符函数来修复这个问题。将以下代码片段添加到`app_server/controllers`中的locations.js，并将`doAddReview`添加到导出列表的底部。然后应用程序将再次成功启动：
- en: '[PRE259]'
  id: totrans-2301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: If you click through to the Add Review page, however, you’ll get an error. Oh,
    yes—you need to update the link to the Add Review page from the Details page.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您点击进入“添加评论”页面，您会得到一个错误。哦，是的——您需要从详情页面更新到“添加评论”页面的链接。
- en: Fixing the location detail view
  id: totrans-2303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修复位置详情视图
- en: You need to add the location ID to the `href` specified in the Add Review button
    on the Details page. The controller for this page passes through the full data
    object as returned from the API, which, along with the rest of the data, contains
    the `_id` field. This data object is called `location` when passed to the view.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将位置ID添加到详情页面上的“添加评论”按钮指定的`href`中。该页面的控制器将传递从API返回的完整数据对象，其中包含`_id`字段，以及其他数据。当传递到视图时，这个数据对象被称为`location`。
- en: 'The following code snippet shows a single line from the location-info.pug template
    in the app_server/views folder. This line shows how to add the location ID to
    the link for the Add Review button; note that you now use a JavaScript template
    string for the `href` value:'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`app_server/views`文件夹中的location-info.pug模板中的一行。这一行显示了如何将位置ID添加到“添加评论”按钮的链接中；请注意，您现在使用JavaScript模板字符串作为`href`值：
- en: '[PRE260]'
  id: totrans-2306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'With the template updated and saved, you can click through to a review form
    for each individual location. A couple of issues still exist, however: the form
    doesn’t post anywhere, and the name of the location is hardcoded into the controller.'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板更新并保存后，您可以为每个单独的位置点击进入评论表单。然而，仍然存在一些问题：表单没有提交到任何地方，并且位置名称被硬编码到控制器中。
- en: Updating the review form view
  id: totrans-2308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新评论表单视图
- en: 'Next, you want to make sure that the form posts to the correct URL. When the
    form is submitted now, it makes a `GET` request to the /location URL:'
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您想要确保表单提交到正确的URL。现在，当表单提交时，它会向/location URL发起一个`GET`请求：
- en: '[PRE261]'
  id: totrans-2310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'This line is taken from the location-review-form.pug file in app_server/views.
    The /location path is no longer valid in your application, and you also want to
    use a `POST` request instead of a `GET` request. The URL you want to post the
    form to is the same as the URL for the Add Review: /location/:locationid/reviews/new.'
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码来自`app_server/views`中的`location-review-form.pug`文件。在应用程序中，/location路径不再有效，你也不想使用`GET`请求。你想要将表单发送到的URL与添加评论的URL相同：/location/:locationid/reviews/new。
- en: 'An easy way to achieve this task is to set the action of the form to be an
    empty string and set the method to be `post`, as shown here:'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此任务的一个简单方法是将表单的动作设置为空字符串，并将方法设置为`post`，如下所示：
- en: '[PRE262]'
  id: totrans-2313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Now, when the form is submitted, it makes a `POST` request to the URL of the
    current page.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当表单提交时，它会向当前页面的URL发送一个`POST`请求。
- en: Creating a named function for rendering the Add Review page
  id: totrans-2315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为渲染添加评论页面创建一个命名函数
- en: As with the other pages, you’ll move the rendering of the page to a separate
    named function. This step allows you the separation of concerns you’re looking
    for when coding and prepares you for the next steps.
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他页面一样，你将把页面的渲染移动到单独的命名函数中。这一步骤允许你在编码时分离关注点，并为下一步做好准备。
- en: The following listing shows how this should look in the code. Make your changes
    in locations.js in app_server/controllers.
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了在代码中应该看起来是什么样子。请在`app_server/controllers`中的locations.js中进行更改。
- en: Listing 7.20\. Creating a render function for the `addReview` controller body
  id: totrans-2318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.20\. 为`addReview`控制器主体创建渲染函数
- en: '[PRE263]'
  id: totrans-2319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '***1*** **Creates the new function renderReviewForm(), and moves the contents
    of the addReview controller into it**'
  id: totrans-2320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 创建新的函数`renderReviewForm()`，并将`addReview`控制器的内容移动到其中'
- en: '***2*** **Calls the new function from within the addReview controller, passing
    the same parameters**'
  id: totrans-2321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 在`addReview`控制器内部调用新函数，并传递相同的参数'
- en: This code might look a little odd—creating a named function and then having
    the call to that function be the only thing in the controller—but it will be useful
    in a moment.
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能看起来有点奇怪——创建一个命名函数，然后让对该函数的调用成为控制器中唯一的事情——但它在稍后将会很有用。
- en: Getting the location detail
  id: totrans-2323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取位置详情
- en: On the Add Review page, you want to display the name of the location to retain
    a sense of context for the user. You want to hit the API again, give it the ID
    of the location, and get the information back to the controller and into the view.
    You’ve done this for the Details page, albeit with a different controller. If
    you approach this task correctly, you shouldn’t have to write much new code.
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加评论页面上，你想要显示位置名称以保留用户的上下文感。你想要再次调用API，给它提供位置ID，并将信息返回到控制器和视图中。你已经为详情页面做了这件事，尽管使用了不同的控制器。如果你正确地处理这个任务，你不需要编写太多新的代码。
- en: Rather than duplicate code and have to maintain two pieces, you’ll go for a
    DRY (don’t repeat yourself) approach. The Details page and the Add Review page
    both want to call the API to get the location information and then do something
    with it. So why not create a new function that does this? You’ve already got most
    of the code in the `locationInfo` controller; you need to change how it calls
    the final function. Instead of calling the `renderDetailPage()` explicitly, you’ll
    make it a callback.
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是复制代码并维护两份，你会选择DRY（不要重复自己）的方法。详情页面和添加评论页面都想要调用API获取位置信息，然后对其进行处理。那么为什么不创建一个执行此操作的新函数呢？你已经在`locationInfo`控制器中有了大部分代码；你需要改变它调用最终函数的方式。你将不再显式调用`renderDetailPage()`，而是将其作为一个回调。
- en: You’ll have a new function called `getLocationInfo()` that makes the API request.
    Following a successful request, this function should invoke whatever callback
    function was passed. The `locationInfo` controller calls this function, passing
    a callback function that calls the `renderDetailPage()` function. Similarly, the
    `addReview` controller can call this new function, passing it the `renderReviewForm()`
    function in the callback.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 你将有一个名为`getLocationInfo()`的新函数，它执行API请求。在请求成功后，此函数应调用传递的任何回调函数。`locationInfo`控制器调用此函数，传递一个调用`renderDetailPage()`函数的回调函数。同样，`addReview`控制器也可以调用这个新函数，传递`renderReviewForm()`函数作为回调。
- en: These changes give you one function making API calls that will have different
    outcomes depending on the callback function sent. The following listing shows
    everything in place.
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改使你拥有一个执行API调用并具有不同结果的函数，这取决于发送的回调函数。以下列表显示了所有内容。
- en: Listing 7.21\. Creating a new reusable function to get location information
  id: totrans-2328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.21\. 创建一个新的可重用函数以获取位置信息
- en: '[PRE264]'
  id: totrans-2329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '***1*** **New function getLocationInfo() accepts a callback as a third parameter
    and contains all code that used to be in locationInfo controller**'
  id: totrans-2330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **新函数 getLocationInfo() 接受一个回调作为第三个参数，并包含原来在 locationInfo 控制器中使用的所有代码**'
- en: '***2*** **Following a successful API response, invokes callback instead of
    a named function**'
  id: totrans-2331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在成功的 API 响应后，调用回调而不是命名函数**'
- en: '***3*** **In the locationInfo controller, calls the getLocationInfo() function,
    passing a callback function that will call the renderDetailPage() function upon
    completion**'
  id: totrans-2332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在 locationInfo 控制器中调用 getLocationInfo() 函数，传递一个回调函数，该函数在完成时将调用 renderDetailPage()
    函数**'
- en: '***4*** **Also calls getLocationInfo() from the addReview controller, but this
    time passes renderReviewForm() in a callback**'
  id: totrans-2333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **也从 addReview 控制器中调用 getLocationInfo()，但这次传递 renderReviewForm() 作为回调**'
- en: And there you have a nice, DRY approach to the problem. It would have been easy
    to copy and paste the API code from one controller to another—which, if we’re
    being honest, is absolutely fine if you’re figuring out your code and what you
    need to do to make it work. But when you see two pieces of code doing pretty much
    the same thing, always ask yourself how you can make it DRY to make your code
    cleaner and easier to maintain.
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就得到了一个优雅的 DRY 方法来解决这个问题。很容易从控制器中复制粘贴 API 代码——如果我们说实话，如果你在弄清楚代码以及你需要做什么来让它工作，这是绝对可以接受的。但是当你看到两段几乎做同样的事情的代码时，总是要问自己如何使其
    DRY，以使你的代码更干净、更容易维护。
- en: Displaying the location detail
  id: totrans-2335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示位置详情
- en: You have one more thing to take care of. The function for rendering the form
    still contains hardcoded data instead of using the data from the API. A quick
    tweak to the function changes that situation.
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有一件事要处理。用于渲染表单的函数仍然包含硬编码的数据而不是使用来自 API 的数据。对函数进行快速调整就可以改变这种情况。
- en: Listing 7.22\. Removing hardcoded data from the `renderReviewForm` function
  id: totrans-2337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.22\. 从 `renderReviewForm` 函数中移除硬编码的数据
- en: '[PRE265]'
  id: totrans-2338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '***1*** **Updates the renderReviewForm() function to accept a new parameter
    containing data, destructed to what you need**'
  id: totrans-2339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **更新 renderReviewForm() 函数以接受一个包含数据的新的参数，解构为所需的内容**'
- en: '***2*** **Swaps out hardcoded data for data references using template strings**'
  id: totrans-2340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用模板字符串替换硬编码的数据为数据引用**'
- en: The Add Review page is looking good once again, displaying the correct name
    based on the ID found in the URL, as shown in [figure 7.10](#ch07fig10).
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: “添加评论”页面再次看起来不错，根据在 URL 中找到的 ID 显示正确的名称，如[图 7.10](#ch07fig10)所示。
- en: Figure 7.10\. Add Review page pulling in the location name via the API, based
    on the ID contained in the URL
  id: totrans-2342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.10\. 通过 API 拉取包含在 URL 中的位置名称的“添加评论”页面
- en: '![](Images/07fig10_alt.jpg)'
  id: totrans-2343
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig10_alt.jpg)'
- en: 7.4.2\. POSTing the review data to the API
  id: totrans-2344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2\. 将评论数据 POST 到 API
- en: By now, you have the Add Review page set up and ready to go, including the posting
    destination. You’ve even got the route and controller for the `POST` action in
    place. The controller, `doAddReview`, is an empty placeholder, though.
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经设置了“添加评论”页面并准备就绪，包括发布目的地。你甚至已经设置了`POST`操作的路线和控制台。不过，控制台`doAddReview`是一个空的占位符。
- en: 'The plan for this controller is as follows:'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器的计划如下：
- en: Get the location ID from the URL to construct the API request URL.
  id: totrans-2347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 URL 中获取位置 ID 以构建 API 请求 URL。
- en: Get the data posted in the form, and package it up for the API.
  id: totrans-2348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取表单中提交的数据，并将其打包以供 API 使用。
- en: Make the API call.
  id: totrans-2349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 API 调用。
- en: Show the new review in place, if successful.
  id: totrans-2350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，则在当前位置显示新的评论。
- en: Display an error page, if not successful.
  id: totrans-2351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不成功，则显示错误页面。
- en: The only part of this procedure that you haven’t seen yet is passing the data
    to the API; so far, you’ve passed an empty JSON object to ensure that the response
    is formatted as JSON. Now you’ll take the form data and pass it to the API in
    the format it expects. You have three fields on the form and three references
    that the API expects. All you need to do is map one to the other. The form fields
    and model paths are shown in [table 7.3](#ch07table03).
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有看到此过程的唯一部分是将数据传递给 API；到目前为止，你已经传递了一个空的 JSON 对象以确保响应格式为 JSON。现在你将表单数据以 API
    期望的格式传递给它。表单上有三个字段，API 期望有三个引用。你所需要做的就是将它们映射到一起。表单字段和模型路径显示在[表 7.3](#ch07table03)中。
- en: Table 7.3\. Mapping the names of the form fields to the model paths expected
    by the API
  id: totrans-2353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.3\. 将表单字段名称映射到 API 期望的模型路径
- en: '| Form field | API references |'
  id: totrans-2354
  prefs: []
  type: TYPE_TB
  zh: '| 表单字段 | API 引用 |'
- en: '| --- | --- |'
  id: totrans-2355
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| name | author |'
  id: totrans-2356
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 作者 |'
- en: '| rating | rating |'
  id: totrans-2357
  prefs: []
  type: TYPE_TB
  zh: '| 评分 | 评分 |'
- en: '| review | reviewText |'
  id: totrans-2358
  prefs: []
  type: TYPE_TB
  zh: '| 评论 | 评论文本 |'
- en: 'Turning this mapping into a JavaScript object is straightforward. Create a
    new object containing the variable names that the API expects, and use `req.body`
    to get the values from the posted form. The following code snippet shows this
    object in isolation, and you’ll put it in the controller in just a moment:'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 将此映射转换为JavaScript对象是直接的。创建一个新的对象，包含API期望的变量名，并使用`req.body`从提交的表单中获取值。以下代码片段显示了此对象，你将在稍后将其放入控制器中：
- en: '[PRE266]'
  id: totrans-2360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Now that you’ve seen how that works, you can add it to the standard pattern
    you’ve been using for these API controllers and build out the `doAddReview` controller.
    Remember that the status code the API returns for a successful `POST` operation
    is 201, not the 200 you’ve been using so far with `GET` requests. The following
    listing shows the `doAddReview` controller, using everything you’ve learned so
    far.
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了它是如何工作的，你可以将其添加到你一直在使用的这些API控制器标准模式中，并构建出`doAddReview`控制器。记住，API返回的成功的`POST`操作的状态码是201，而不是你迄今为止在`GET`请求中使用的200。以下列表显示了`doAddReview`控制器，使用了你迄今为止学到的所有内容。
- en: Listing 7.23\. `doAddReview` controller used to post review data to the API
  id: totrans-2362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.23. `doAddReview`控制器用于将评论数据发布到API
- en: '[PRE267]'
  id: totrans-2363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '***1*** **Gets location ID from the URL to construct the API URL**'
  id: totrans-2364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 从URL获取位置ID以构建API URL'
- en: '***2*** **Creates a data object to send to the API, using the submitted form
    data**'
  id: totrans-2365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建一个数据对象以发送到API，使用提交的表单数据'
- en: '***3*** **Sets the request options, including the path, setting the POST method,
    and passing the submitted form data into a json parameter**'
  id: totrans-2366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 设置请求选项，包括路径，设置POST方法，并将提交的表单数据传递给json参数'
- en: '***4*** **Makes the request**'
  id: totrans-2367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 发送请求'
- en: '***5*** **Redirects to the Details page if review was added successfully, or
    shows an error page if the API returned an error**'
  id: totrans-2368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 如果评论添加成功，则重定向到详情页面，如果API返回错误，则显示错误页面'
- en: Now you can create a review, submit it, and then see it on the Details page,
    as shown in [figure 7.11](#ch07fig11).
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建一个评论，提交它，然后可以在详情页面上看到它，如图7.11所示。
- en: Figure 7.11\. After filling in and submitting the review form, the review is
    shown in situ on the Details page.
  id: totrans-2370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11. 填写并提交评论表单后，评论在详情页面上显示。
- en: '![](Images/07fig11_alt.jpg)'
  id: totrans-2371
  prefs: []
  type: TYPE_IMG
  zh: '![Images/07fig11_alt.jpg](Images/07fig11_alt.jpg)'
- en: Now that everything works, let’s take a quick look at adding form validation.
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切正常工作，让我们快速看一下如何添加表单验证。
- en: 7.5\. Protecting data integrity with data validation
  id: totrans-2373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5. 使用数据验证保护数据完整性
- en: Whenever an application accepts external input and adds it to a database, you
    need to make sure that the data is complete and accurate—as much as you can or
    as much as it makes sense to. If someone adds an email address, you should check
    that it’s a valid email format, but you can’t programmatically validate that it’s
    a *real* email address.
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 每当应用程序接受外部输入并将其添加到数据库时，你需要确保数据尽可能完整和准确——尽可能多或者有意义的那么多。如果有人添加一个电子邮件地址，你应该检查它是否是有效的电子邮件格式，但你不能通过编程方式验证它是否是一个*真实*的电子邮件地址。
- en: 'In this section, you’ll look at the ways that you can add validation to your
    application to prevent people from submitting empty reviews. You can add validation
    in three places:'
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解你可以如何向应用程序添加验证，以防止人们提交空评论。你可以在三个地方添加验证：
- en: At the schema level, using Mongoose, before the data is saved
  id: totrans-2376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Mongoose的模式级别，在数据保存之前
- en: At the application level, before the data is posted to the API
  id: totrans-2377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用级别，在数据发布到API之前
- en: At the client side, before the form is submitted
  id: totrans-2378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端，在表单提交之前
- en: You’ll look at each of these places in turn and add some validation at every
    step.
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 你将依次查看这些地方，并在每个步骤中添加一些验证。
- en: 7.5.1\. Validating at the schema level with Mongoose
  id: totrans-2380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1. 使用Mongoose在模式级别进行验证
- en: Validating the data before saving it is arguably the most important stage. This
    step is the final step, the one last chance to make sure that everything is as
    correct as it can be. This stage is particularly important when the data is exposed
    through an API; if you don’t have control of all the applications using the API,
    you can’t guarantee the quality of the data that you’re going to get. It’s important
    to ensure that the data is valid before saving it.
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存数据之前验证数据可能是最重要的阶段。这一步是最后一步，是确保一切尽可能正确的最后机会。当数据通过API公开时，这一阶段尤为重要；如果你无法控制所有使用API的应用程序，你无法保证你将获得的数据质量。在保存之前确保数据有效是很重要的。
- en: Updating the schema
  id: totrans-2382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更新模式
- en: When you first set up the schema in [chapter 5](kindle_split_016.xhtml#ch05),
    you looked at adding some validation in Mongoose. You set the `rating` path to
    be required, but you also want the `author displayName` and `reviewText` to be
    required. If one of these fields is missing, a review won’t make sense. Adding
    this to the schema is simple enough and looks like the following listing. (The
    schema is in locations.js in the app_api/model folder.)
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[第5章](kindle_split_016.xhtml#ch05)中首次设置模式时，你查看在Mongoose中添加一些验证。你将`rating`路径设置为必需的，但你还想将`author
    displayName`和`reviewText`设置为必需的。如果这些字段中的任何一个缺失，评论就没有意义。将此添加到模式中很简单，如下所示列表。（模式在app_api/model文件夹中的locations.js中。）
- en: Listing 7.24\. Adding validation to reviews at the schema level
  id: totrans-2384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.24\. 在模式级别添加评论的验证
- en: '[PRE268]'
  id: totrans-2385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '***1*** **Makes each of these paths a required field, because if one of them
    is missing, a review won’t make sense**'
  id: totrans-2386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将这些路径中的每一个都设置为必需字段，因为如果其中任何一个缺失，评论就没有意义**'
- en: '***2*** **createdOn doesn’t need to be required, because Mongoose automatically
    populates it when a new review is created.**'
  id: totrans-2387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **createdOn不需要是必需的，因为Mongoose在创建新评论时会自动填充它。**'
- en: When this code is saved, you can no longer save a review without any review
    text. You can try, but you’ll see the error page shown in [figure 7.12](#ch07fig12).
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码被保存时，你将无法在没有任何评论文本的情况下保存评论。你可以尝试，但你会看到[图7.12](#ch07fig12)中显示的错误页面。
- en: Figure 7.12\. Error message shown when trying to save a review without any review
    text, now that the schema says it’s required
  id: totrans-2389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.12\. 当尝试保存没有评论文本的评论时显示的错误消息，因为模式表明它是必需的
- en: '![](Images/07fig12_alt.jpg)'
  id: totrans-2390
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig12_alt.jpg)'
- en: On one hand, it’s good that you’re protecting the database, but it’s not a great
    user experience. You should try to catch that error and let the visitor try again.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，你保护数据库是好事，但用户体验并不好。你应该尝试捕捉那个错误，并让访客再次尝试。
- en: Catching Mongoose validation errors
  id: totrans-2392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 捕获Mongoose验证错误
- en: 'If you try to save a document with one or more required paths missing or empty,
    Mongoose returns an error. It does this without having to make a call to the database,
    because Mongoose itself holds the schema and knows what is and isn’t required.
    The following code snippet shows an example of such an error message:'
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试保存一个缺少一个或多个必需路径或为空的文档，Mongoose会返回一个错误。它这样做而不需要调用数据库，因为Mongoose本身持有模式并知道什么是必需的。以下代码片段显示了一个这样的错误消息示例：
- en: '[PRE269]'
  id: totrans-2394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'In the flow of the application, this happens inside the callback from the `save`
    function. If you take a look at the `save` command inside the `doAddReview()`
    function (in app_api/controllers/reviews.js), you can see where the error bubbles
    up and where you set the 400 status. The following code snippet shows this, including
    a temporary console log statement to show the output of the error to terminal:'
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的流程中，这发生在`save`函数的回调中。如果你查看`doAddReview()`函数（在app_api/controllers/reviews.js中）内的`save`命令，你可以看到错误是如何冒泡的以及你设置了400状态。以下代码片段显示了这一点，包括一个临时的控制台日志语句来显示错误输出到终端：
- en: '[PRE270]'
  id: totrans-2396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '***1*** **Mongoose validation errors are returned through an error object following
    an attempted save action.**'
  id: totrans-2397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **Mongoose验证错误是在尝试保存操作后通过一个错误对象返回的。**'
- en: Your API returns this message as the response body, alongside the 400 status.
    You can look for this information in your application by looking at the response
    body when the API returns a 400 status.
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API将此消息作为响应体返回，并附带400状态。你可以在API返回400状态时查看响应体以查找此信息。
- en: The place to do this is in the app_server—in the `doAddReview()` function in
    controllers/locations.js, to be precise. When you’ve caught a validation error,
    you want to let the user try again by redirecting to the Add Review page. So that
    the page knows that an attempt has been made, you can pass a flag in the query
    string.
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的地方是在app_server中——在controllers/locations.js中的`doAddReview()`函数中，更确切地说。当你捕捉到一个验证错误时，你想要通过重定向到添加评论页面让用户再次尝试。为了使页面知道已经尝试过，你可以在查询字符串中传递一个标志。
- en: The following listing shows this code in place, inside the request statement
    callback for the `doAddReview()` function.
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了这段代码的位置，在`doAddReview()`函数的请求语句回调中。
- en: Listing 7.25\. Trapping validation errors returned by the API
  id: totrans-2401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.25\. 捕获API返回的验证错误
- en: '[PRE271]'
  id: totrans-2402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '***1*** **Adds a check to see whether the status is 400, the body has a name,
    and that name is** **ValidationError**'
  id: totrans-2403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加了一个检查，看状态是否为400，正文是否有名称，并且该名称是** **ValidationError**'
- en: '***2*** **If true, redirects to the review form, passing an error flag in a
    query string**'
  id: totrans-2404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果为真，则通过查询字符串传递错误标志重定向到评论表单**'
- en: Now when the API returns a validation error, you can catch it and send the user
    back to the form to try again. Passing a value in the query string means that
    you can look for it in the controller that displays the review form and send a
    message to the view to alert the user to the problem.
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当 API 返回验证错误时，你可以捕获它并将用户送回表单再次尝试。在查询字符串中传递一个值意味着你可以在显示评论表单的控制器中查找它，并发送一条消息到视图以提醒用户问题。
- en: Displaying an error message in the browser
  id: totrans-2406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在浏览器中显示错误消息
- en: To display an error message in the view, you need to send a variable to the
    view if you see the `err` parameter passed in the query string. The `renderReviewForm()`
    function is responsible for passing variables into the view. When it’s called,
    it’s also passed the `req` object, which contains the `query` object, making it
    easy to pass the `err` parameter, when it exists. The following listing highlights
    the simple change required to make this happen.
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中显示错误消息，如果你在查询字符串中看到了传递的`err`参数，你需要将一个变量发送到视图中。`renderReviewForm()`函数负责将变量传递到视图中。当它被调用时，它也会传递`req`对象，该对象包含`query`对象，这使得在存在的情况下传递`err`参数变得容易。以下列表显示了实现这一功能所需进行的简单更改。
- en: Listing 7.26\. Updating the controller to pass an error string from query object
    to view
  id: totrans-2408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.26\. 更新控制器以从查询对象传递错误字符串到视图
- en: '[PRE272]'
  id: totrans-2409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '***1*** **Sends a new error variable to the view, passing the view any existing
    query parameters**'
  id: totrans-2410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **向视图发送新的错误变量，传递任何现有的查询参数**'
- en: The `query` object is always part of the `req` object, regardless of whether
    it has any content. This is why you don’t need to error-trap this object to check
    whether it exists; if the `err` parameter isn’t found, it returns `undefined`.
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: '`query`对象始终是`req`对象的一部分，无论它是否有内容。这就是为什么你不需要错误捕获此对象来检查它是否存在；如果找不到`err`参数，它返回`undefined`。'
- en: 'All that remains is to do something with this information in the view, letting
    the user know what the problem is. You’ll show a message to the user at the top
    of the form, if a validation error was bubbled up. To give this message some style
    and presence on the page, you’ll use a Bootstrap alert component: a `div` with
    some relevant classes and attributes. The following code snippet shows the two
    lines to add to the `location-review-form` view:'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是要在视图中处理这些信息，让用户知道问题是什么。如果验证错误被冒泡到顶部，你将在表单顶部向用户显示一条消息。为了给这条消息一些样式和页面上的存在感，你将使用一个
    Bootstrap 警告组件：一个带有相关类和属性的`div`。以下代码片段显示了要添加到`location-review-form`视图中的两行代码：
- en: '[PRE273]'
  id: totrans-2413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Now when the API returns a validation error, you catch it and display a message
    to the user. [Figure 7.13](#ch07fig13) shows how this message looks.
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当 API 返回验证错误时，你捕获它并向用户显示一条消息。[图 7.13](#ch07fig13) 显示了这条消息的外观。
- en: Figure 7.13\. The validation error message in the browser, the result of a process
    kicked off by Mongoose’s catching the error and returning it
  id: totrans-2415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.13\. 浏览器中的验证错误消息，这是由 Mongoose 捕获错误并返回错误的结果
- en: '![](Images/07fig13_alt.jpg)'
  id: totrans-2416
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig13_alt.jpg)'
- en: This type of validation at the API level is important and generally a great
    place to start, because it protects a database against inconsistent or incomplete
    data, regardless of the origin. But the experience for end users isn’t always
    best; they have to submit the form, and the form request makes a round trip to
    the API before the page reloads with an error. There’s clearly room for improvement,
    and the first step is performing some validation at the application level before
    the data is passed to the API.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在 API 级别的验证很重要，并且通常是一个很好的起点，因为它可以保护数据库免受不一致或不完整数据的影响，无论其来源如何。但最终用户的体验并不总是最好的；他们必须提交表单，表单请求在页面重新加载并显示错误之前会绕一圈到
    API。显然，还有改进的空间，第一步是在将数据传递到 API 之前在应用级别执行一些验证。
- en: 7.5.2\. Validating at the application level with Node and Express
  id: totrans-2418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2\. 使用 Node 和 Express 在应用级别进行验证
- en: Validation at the schema level is the backstop, the final line of defense in
    front of a database. An application shouldn’t rely solely on this backstop, however,
    and you should try to prevent unnecessary calls to the API, reducing overhead
    and speeding thing up for the user. One way is to add validation at the application
    level, checking the submitted data before sending it to the API.
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式级别进行验证是最后的防线，是数据库前的最后一道防线。然而，应用程序不应仅依赖于这个防线，你应该尝试减少对 API 的不必要调用，以减少开销并加快用户的速度。一种方法是在应用程序级别添加验证，在将数据发送到
    API 之前检查提交的数据。
- en: In your application, the validation required for a review is simple; you can
    add some simple checks to ensure that each of the fields has a value. If this
    test fails, you redirect the user back to the form, adding the same query string
    error flag as before. If the validation checks are successful, you allow the controller
    to continue to the request method. The following listing shows the additions needed
    in the `doAddReview` controller in locations.js in the app_server/controllers
    folder.
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，评论所需的验证很简单；你可以添加一些简单的检查以确保每个字段都有值。如果这个测试失败，你将用户重定向回表单，添加与之前相同的查询字符串错误标志。如果验证检查成功，你允许控制器继续到请求方法。以下列表显示了在
    app_server/controllers 文件夹中的 locations.js 中的 `doAddReview` 控制器所需添加的内容。
- en: Listing 7.27\. Adding some simple validation to an Express controller
  id: totrans-2421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.27\. 向 Express 控制器添加一些简单的验证
- en: '[PRE274]'
  id: totrans-2422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '***1*** **If any of three required data fields is falsey, redirects to the
    Add Review page, appending the query string used to display the error message**'
  id: totrans-2423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **如果三个必需的数据字段中的任何一个为假，则重定向到“添加评论”页面，并附加用于显示错误消息的查询字符串**'
- en: '***2*** **Otherwise, continues as before**'
  id: totrans-2424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **否则，继续之前的操作**'
- en: 'The outcome is the same as before: if the review text is missing, the user
    is shown the error message on the Add Review page. The user doesn’t know that
    you’re no longer posting data to the API, but it’s one less round trip and so
    should be a faster experience. But you can make it even faster with the third
    tier of validation: browser-based validation.'
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前相同：如果评论文本缺失，用户将在“添加评论”页面上看到错误消息。用户不知道你不再向 API 发送数据，但这减少了往返次数，因此应该是一个更快的体验。但是，你可以通过第三级验证：基于浏览器的验证来使其更快。
- en: 7.5.3\. Validating in the browser with jQuery
  id: totrans-2426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3\. 使用 jQuery 在浏览器中进行验证
- en: As application-level validation speeds things up by not requiring a call to
    the API, client-side validation in the browser can speed things up by catching
    an error before the form is submitted to the application, by removing yet another
    call. Catching an error at this point keeps the user on the same page.
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序级别的验证通过不需要调用 API 来加快速度，因此浏览器端的客户端验证可以通过在表单提交到应用程序之前捕获错误来加快速度，通过减少另一个调用。在这一点上捕获错误将保持用户在同一个页面上。
- en: To get JavaScript running in the browser, you need to place it in the public
    folder in the application. Express treats the contents of this folder as static
    files to be downloaded to the browser instead of run on the server. If you don’t
    have a folder called javascripts in your public folder, create one now. Inside
    this folder, create a new file called validation.js.
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中运行 JavaScript，你需要将其放置在应用程序的 public 文件夹中。Express 将此文件夹的内容视为要下载到浏览器的静态文件，而不是在服务器上运行。如果你在
    public 文件夹中没有名为 javascripts 的文件夹，现在创建一个。在这个文件夹中，创建一个名为 validation.js 的新文件。
- en: Writing the jQuery validation
  id: totrans-2429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写 jQuery 验证
- en: 'Inside this new validation.js file, put a jQuery function that does the following:'
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的 validation.js 文件中，放置一个 jQuery 函数，执行以下操作：
- en: Listens for the submit event of the review form
  id: totrans-2431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听评论表单的提交事件
- en: Checks to see that all the required fields have a value
  id: totrans-2432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有必需字段是否有值
- en: If one is empty, shows an error message like the ones you’ve used in the other
    types of validation and prevents the form from submitting
  id: totrans-2433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其中一个为空，显示类似于其他类型验证中使用的错误消息，并阻止表单提交
- en: The following listing shows the code to do this. We won’t dive into the semantics
    of jQuery here, assuming you have some familiarity with it or a similar library.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了执行此操作的代码。我们不会深入探讨 jQuery 的语义，假设你对它或类似的库有所了解。
- en: Listing 7.28\. Creating a jQuery form validation function
  id: totrans-2435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.28\. 创建一个 jQuery 表单验证函数
- en: '[PRE275]'
  id: totrans-2436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '***1*** **Listens for the submit event of the review form**'
  id: totrans-2437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **监听评论表单的提交事件**'
- en: '***2*** **Checks for any missing values**'
  id: totrans-2438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查是否有缺失的值**'
- en: '***3*** **Shows or injects an error message into the page if a value is missing**'
  id: totrans-2439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果值缺失，则在页面上显示或注入错误消息**'
- en: '***4*** **Prevents the form from submitting if a value is missing**'
  id: totrans-2440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 防止表单在缺少值时提交'
- en: You need to ensure that the form has an ID of `addReview` set so that the jQuery
    can listen for the correct event. You also need to add this script to the page
    so that the browser can run it.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保表单有一个名为`addReview`的ID，这样jQuery可以监听正确的事件。你还需要将此脚本添加到页面中，以便浏览器可以运行它。
- en: Adding the jQuery to the page
  id: totrans-2442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将jQuery添加到页面中
- en: 'You’ll include this jQuery file at the end of the body, along with the other
    client-side JavaScript files. These files are set in the `layout.pug` view in
    app_server/views, at the bottom. Add a new line below the others pointing to the
    new file:'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在body的末尾包含此jQuery文件，以及其他客户端JavaScript文件。这些文件在`layout.pug`视图中设置，位于app_server/views的底部。在下面的其他文件下方添加新行，指向新文件：
- en: '[PRE276]'
  id: totrans-2444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: That’s all there is to it. Now the form validates in the browser without the
    data being submitted anywhere, removing a page reload and any associated calls
    to the server.
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在表单在浏览器中进行了验证，而无需提交任何数据，从而消除了页面刷新和任何相关的服务器调用。
- en: '|  |'
  id: totrans-2446
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-2447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Client-side validation may seem to be all that you need, but the other types
    are vital to the robustness of an application. JavaScript can be turned off in
    the browser, removing the ability to run this validation, or the validation could
    be bypassed, with data being posted directly to either the form action URL or
    the API endpoint.
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端验证可能看起来是你所需要的全部，但其他类型对于应用程序的健壮性至关重要。在浏览器中可以关闭JavaScript，这将移除运行此验证的能力，或者验证可以被绕过，数据可以直接提交到表单操作URL或API端点。
- en: '|  |'
  id: totrans-2449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In [chapter 8](kindle_split_020.xhtml#ch08), you’ll introduce Angular into the
    mix and start playing with some interactive front-end components on top of the
    Express application.
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_020.xhtml#ch08)中，你将把Angular引入其中，并开始在Express应用程序之上玩一些交互式前端组件。
- en: Summary
  id: totrans-2451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: How to use the `request` module to make API calls from Express and how to make
    `POST` and `GET` requests to API endpoints
  id: totrans-2453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`request`模块从Express中发起API调用，以及如何向API端点发送`POST`和`GET`请求
- en: Some ways of separating concerns by keeping rendering functions away from the
    API request logic
  id: totrans-2454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些通过将渲染函数与API请求逻辑分离来分离关注点的方法
- en: How to apply a simple pattern to the API logic in each controller
  id: totrans-2455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将简单模式应用于每个控制器的API逻辑
- en: The application of data validation in three places in the architecture and when
    and why to use each
  id: totrans-2456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在架构中的三个位置应用数据验证，以及何时以及为什么使用每个
