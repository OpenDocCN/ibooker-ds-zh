- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: App essentials
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的基本要素
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: How Angular organizes code into modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 如何将代码组织成模块
- en: How apps are rendered
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的渲染方式
- en: Types of entities in Angular
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的实体类型
- en: The template syntax and capabilities of Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 的模板语法和功能
- en: Change detection and dependency injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更检测和依赖注入
- en: This chapter covers the essentials of Angular applications so that you can understand
    how everything fits together. It will be a good reference for the fundamentals.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Angular 应用程序的基本要素，以便您了解所有内容是如何结合在一起的。这将是一个很好的基础知识参考。
- en: It is focused on concepts, and there are no coding projects. You may be eager
    to jump into coding, and I certainly understand that. I recommend you take the
    time to read this chapter in its entirety, but you can also start by skimming
    the first couple paragraphs of each section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它专注于概念，没有编码项目。您可能急于开始编码，我当然理解这一点。我建议您花时间完整阅读本章，但您也可以从每个部分的头几段开始浏览。
- en: While in college, I studied abroad in Germany and was fortunate enough to do
    some traveling. I took a number of tours, but two I remember well were a tour
    of some salt mines in southern Germany and a tour of the Uffizi Museum in Florence,
    Italy. I learned a lot of interesting facts about salt mines, but I had no real
    background in mining. On the other hand, I had been taking an art history class,
    which made the experience of the Uffizi Museum far more satisfying.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学期间，我在德国留学，并有幸进行了一些旅行。我参加了很多旅行，但有两件事我记忆犹新：一次是德国南部的盐矿之旅，另一次是意大利佛罗伦萨的乌菲齐博物馆之旅。我了解了很多关于盐矿的有趣事实，但我对采矿没有真正的背景。另一方面，我一直在上艺术史课程，这使得乌菲齐博物馆的经历更加令人满意。
- en: I hope you went through chapter 2, which provides a hands-on tour of Angular,
    because I’ll use it as a reference as we talk about application essentials. It
    probably felt a bit like the salt mine tour, where you ran through it quickly
    and saw some interesting things. Now I’m going to fill in the backstory to give
    you a more complete picture of Angular so you can have your own Uffizi experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您已经阅读了第二章，它提供了 Angular 的实战之旅，因为我会将其作为参考，在我们讨论应用程序基本要素时使用。这可能感觉有点像盐矿之旅，您快速跑过并看到了一些有趣的事物。现在我将填补背景故事，给您一个更完整的
    Angular 图景，让您拥有自己的乌菲齐体验。
- en: Chapter 2 may have seemed fairly easy, or it might have been a challenge to
    keep everything straight. As with most technologies, there are a lot of potential
    things to learn, but most aren’t the things you’ll use on a regular basis. I’ve
    had my moments of clarity and confusion with Angular, and most often the problem
    is that I was fixating on too many things at once instead of focusing on the core
    problem and building up from there.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章可能看起来相当简单，或者可能很难保持所有内容清晰。与大多数技术一样，有很多潜在的学习内容，但大多数并不是你日常会用到的东西。我在学习 Angular
    时有过清晰和困惑的时刻，而大多数情况下问题是我一次专注于太多事情，而不是专注于核心问题并从这里构建。
- en: Based on that experience, I’m going to walk you through key aspects of the chapter 2
    app in greater detail and talk about the core concepts in play. I’ll layer on
    a few more concepts that will ultimately give you a more holistic picture of your
    Angular application and how it’s rendered to the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这次经验，我将更详细地为您讲解第 2 章应用程序的关键方面，并讨论其中的核心概念。我将添加一些更多概念，最终为您提供一个更全面的 Angular 应用程序视图以及它在屏幕上的渲染方式。
- en: Figure 3.1 shows the stock application from chapter 2\. If you want to see the
    example in action again, go to [https://angular-in-action.github.io/stocks/](https://angular-in-action.github.io/stocks/).
    You probably recall some of the things used to generate this application, which
    include several components, a service, directives, and more. Let’s look at these
    entities in Angular and better understand their roles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 展示了第二章的股票应用程序。如果您想再次看到这个示例的实际操作，请访问 [https://angular-in-action.github.io/stocks/](https://angular-in-action.github.io/stocks/)。您可能还记得用于生成此应用程序的一些内容，包括几个组件、一个服务、指令等。让我们来看看
    Angular 中的这些实体，并更好地理解它们的作用。
- en: '![c03-1.png](image_fi/293313c03/c03-1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![c03-1.png](image_fi/293313c03/c03-1.png)'
- en: '**Figure 3.1** Stock app from chapter 2, which we’ll use to describe Angular
    concepts in more detail'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.1**  第二章的股票应用程序，我们将用它来更详细地描述 Angular 概念'
- en: 3.1 Entities in Angular
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 Angular 中的实体
- en: Angular has several top-level types of entities, all of which you saw in chapter
    2\. But we didn’t give them a lot of attention in the context of how they are
    bundled and rendered into the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有几种顶级实体类型，您在第二章中都已经看到了。但我们没有在它们如何打包和渲染到应用程序的上下文中给予它们太多关注。
- en: 'These different entities have specific roles and capabilities, and you’ll be
    using them in various combinations to create your application. Here is a quick
    overview of the types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的实体具有特定的角色和能力，您将使用它们的各种组合来创建您的应用程序。以下是类型的快速概述：
- en: '*Modules* —Objects that help you to organize dependencies into discrete units'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块* — 帮助您将依赖项组织成离散单元的对象'
- en: '*Components* —New elements that will compose the majority of your application’s
    structure and logic'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件* — 将组成您应用程序结构和大部逻辑的新元素'
- en: '*Directives* —Objects that modify elements to give them new capabilities or
    change behaviors'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指令* — 修改元素以赋予它们新功能或改变行为的对象'
- en: '*Pipes* —Functions that format data before it’s rendered'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管道* — 在渲染之前格式化数据的函数'
- en: '*Services* —Reusable objects that fill niche roles such as data access or helper
    utilities'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务* — 填充特定角色（如数据访问或辅助工具）的可重用对象'
- en: For the most part, everything you write in Angular will fall into one of these
    five types (okay, I’m sure there are some exceptions). Looking at our stock application
    from chapter 2, we can see how these different entities came into play. Figure 3.2
    outlines the basic relationship of the entities and how they ultimately fit together.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，您所写的大部分内容都将属于这五种类型之一（好吧，我确信有一些例外）。查看第二章中的库存应用程序，我们可以看到这些不同实体是如何发挥作用的。图
    3.2 概述了实体之间的基本关系以及它们最终是如何结合在一起的。
- en: '![c03-2.png](image_fi/293313c03/c03-2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![c03-2.png](image_fi/293313c03/c03-2.png)'
- en: '**Figure 3.2** The entities and how they are leveraged during the application
    execution'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.2** — 实体及其在应用程序执行过程中的利用方式'
- en: As you can see, all these entities are ultimately merged into one application
    and are what generate the resulting user experience. I’ll refer to these types
    of entities often, so let’s dive a little deeper into each one.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有这些实体最终合并为一个应用程序，并生成最终的用户体验。我经常会提到这些实体类型，所以让我们更深入地了解每一个。
- en: 3.1.1 Modules
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 模块
- en: '*Modules* are buckets for storing related entities for easy reuse and distribution.
    Angular itself is composed of several modules, and any external libraries that
    you consume will also be packaged as modules.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是存储相关实体以方便重用和分发的容器。Angular 本身由几个模块组成，您所消耗的任何外部库也将被打包成模块。'
- en: There are two kinds of modules in Angular, and we need to clarify the difference.
    There are JavaScript modules (specifically modules added to the language in ES2015,
    and not other module systems like CommonJS and AMD), and then there are Angular
    modules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中有两种模块，我们需要明确它们的区别。有 JavaScript 模块（特别是 ES2015 中添加到语言中的模块，而不是其他模块系统如
    CommonJS 和 AMD），然后是 Angular 模块。
- en: JavaScript modules are language constructs and are a way to separate code into
    different files that can be loaded as needed. We leverage JavaScript modules heavily
    in our code, but they are not Angular modules. Every TypeScript file we wrote
    in chapter 2 was a JavaScript module because it either imported or exported some
    values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块是语言结构，是一种将代码分离到不同文件的方法，这些文件可以根据需要加载。我们在代码中大量使用 JavaScript 模块，但它们不是
    Angular 模块。第二章中我们编写的每个 TypeScript 文件都是一个 JavaScript 模块，因为它要么导入了某些值，要么导出了某些值。
- en: Whereas JavaScript modules are language constructs, Angular modules are logical
    constructs used for organizing similar groups of entities (such as all things
    needed for the router) and are used by Angular to understand what needs to be
    loaded as well as what dependencies exist. Recall from chapter 2 that your application
    has an App module that holds a reference to all the application logic for Angular
    to render. There must always be an App module, but there will likely be additional
    modules in your application—either official Angular modules, third-party ones,
    or other ones you may create.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JavaScript模块是语言结构，但Angular模块是用于组织类似实体组（如所有需要路由的东西）的逻辑结构，并且由 Angular 用于理解需要加载的内容以及存在的依赖项。回想一下第二章，您的应用程序有一个
    App 模块，它包含所有用于 Angular 渲染的应用程序逻辑。必须始终有一个 App 模块，但您的应用程序可能还会有其他模块——无论是官方 Angular
    模块、第三方模块还是您可能创建的其他模块。
- en: A module is declared by creating a class and decorating it with the `@NgModule`
    decorator. The following listing shows the module we created for the chapter 2
    stocks example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是通过创建一个类并用 `@NgModule` 装饰器装饰它来声明的。以下列表显示了为第 2 章股票示例创建的模块。
- en: '**Listing 3.1** App module from chapter 2'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 3.1** — 第 2 章的 App 模块'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This module declaration was generated by the CLI for us (though we could have
    written it ourselves), and it provides key pieces of information to Angular so
    it can understand how to render and load the application. The `@NgModule` decorator
    contains the metadata for the App module, and the empty class acts as the vessel
    for storing the data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块声明是由 CLI 为我们生成的（尽管我们也可以自己编写），它向 Angular 提供关键信息，以便它能够理解如何渲染和加载应用程序。`@NgModule`
    装饰器包含 App 模块的元数据，而空类则充当存储数据的容器。
- en: The `declarations` array contains a list of all components and directives that
    the application’s main module wants to make available to the entire application.
    Likewise, the `providers` array contains a list of all of the services that you
    want to make available to the whole application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`declarations` 数组包含应用程序主模块希望向整个应用程序提供所有组件和指令的列表。同样，`providers` 数组包含你希望向整个应用程序提供所有服务的列表。'
- en: The `imports` array contains a list of the other modules that this module depends
    upon. If you’re having trouble with another module not loading, this is the first
    place to check to see if it’s being registered with Angular.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`imports` 数组包含了这个模块所依赖的其他模块的列表。如果你遇到另一个模块无法加载的问题，这是你首先需要检查的地方，看看它是否已注册到 Angular。'
- en: To start rendering, Angular also needs to know what component(s) to render on
    the screen, and it looks at the `bootstrap` array for this list. Almost always,
    this will only contain one component, but in some rare cases you may need to render
    multiple components on load.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始渲染，Angular 还需要知道要在屏幕上渲染哪些组件，它查看 `bootstrap` 数组以获取此列表。几乎总是，这只会包含一个组件，但在一些罕见的情况下，你可能需要在加载时渲染多个组件。
- en: There are a few additional properties you don’t see listed here, but they’re
    less commonly used. I’ll cover them as they become relevant for our use cases.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的属性中还有一些你没有看到，但它们的使用频率较低。当它们与我们的用例相关时，我会介绍它们。
- en: 3.1.2 Components
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 组件
- en: Understanding components is vital to understanding Angular, as understanding
    words is vital to language. We’ll be focusing on the role and design of components
    in this section before we dive into the technical implementation details.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解组件对于理解 Angular 至关重要，正如理解单词对于语言至关重要。在我们深入技术实现细节之前，本节将重点关注组件的角色和设计。
- en: A *component* is an encapsulated element that maintains its own internal logic
    for how it desires to render some output, such as our Summary component from chapter
    2\. In HTML, a select element can be considered a component. Using Angular, we
    create our own HTML elements using components, though they are more than that.
    Components can have any number of capabilities or properties that you define.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*组件* 是一个封装的元素，它维护自己的内部逻辑，以决定如何渲染某些输出，例如我们第 2 章中的 Summary 组件。在 HTML 中，一个选择元素可以被视为一个组件。使用
    Angular，我们通过组件创建自己的 HTML 元素，尽管它们不仅仅是那样。组件可以拥有任何数量的能力或属性，你可以定义。'
- en: 'As a review, here are the key principles of a component discussed in chapter
    1, where we saw some of the web technologies that make it possible to build components.
    These principles focus on the way that components are best designed and how they
    behave in Angular:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，以下是第 1 章中讨论的组件的关键原则，在那里我们看到了一些使构建组件成为可能的前端技术。这些原则侧重于组件的最佳设计方式和它们在 Angular
    中的行为：
- en: '*Encapsulation* —Keep component logic isolated'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*封装* — 保持组件逻辑的隔离'
- en: '*Isolation* —Keep component internals hidden'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隔离* — 保持组件内部隐藏'
- en: '*Reusability* —Allow component reuse with minimal effort'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重用性* — 允许以最小的努力重用组件'
- en: '*Event-based* —Emit events during the lifecycle of the component'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于事件* — 在组件的生命周期中发出事件'
- en: '*Customizable* —Possible to style and extend the component'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可定制* — 可以为组件进行样式设计和扩展'
- en: '*Declarative* —Component used with simple declarative markup'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*声明式* — 使用简单的声明性标记的组件'
- en: Components may not implement all of these principles, but they should certainly
    be a guidepost for your thinking. It also helps to keep track of how components
    relate to one another—you can nest multiple components together to compose a more
    complex interaction.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可能不会实现所有这些原则，但它们确实应该是你思考的指南针。这也有助于跟踪组件之间的关系——你可以将多个组件嵌套在一起以组成更复杂的交互。
- en: Let’s take an example of a login form using only HTML elements. You start any
    form with the `form` element that wraps the entire form structure. This gives
    context to the rest of the elements inside the form, but it doesn’t provide any
    UI elements for the user to interact with. For that, we’d need to use a text input
    for the username, a password input for the password, and some kind of button to
    trigger the form action. In [figure 3.3](#figure3.3) we have a basic example of
    a form from Facebook™ that contains these elements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个仅使用HTML元素的登录表单为例。你从一个`form`元素开始，它包裹整个表单结构。这为表单内其余元素提供了上下文，但它不提供任何用户可以与之交互的UI元素。为此，我们需要使用一个文本输入来输入用户名，一个密码输入来输入密码，以及某种类型的按钮来触发表单操作。在[图3.3](#figure3.3)中，我们有一个包含这些元素的基本表单示例。
- en: '![c03-3.png](image_fi/293313c03/c03-3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![c03-3.png](image_fi/293313c03/c03-3.png)'
- en: '[**Figure 3.3**](#figureanchor3.3) Login form on Facebook that has several
    nested elements to produce a single form'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图3.3**](#figureanchor3.3) Facebook上的登录表单，其中包含多个嵌套元素以生成单个表单'
- en: Form events are provided access to the values of the inputs inside the form.
    This is like the Angular notion of data binding, where values from one element
    are connected to another. Then the form has a submit button, which when clicked
    triggers the submit event for the form.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表单事件提供了访问表单内输入值的能力。这类似于Angular中的数据绑定概念，其中一个元素的价值与另一个元素连接起来。然后表单有一个提交按钮，当点击时，触发表单的提交事件。
- en: This should be pretty standard HTML, but now let’s look at a combination of
    Angular components in a similar arrangement. In chapter 2, we had a Dashboard
    component that contained multiple instances of the Summary component. In [figure
    3.4](#figure3.4), I’ve outlined the two types of components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是一个相当标准的HTML，但现在让我们看看一组类似排列的Angular组件。在第2章中，我们有一个包含多个Summary组件实例的Dashboard组件。在[图3.4](#figure3.4)中，我概述了两种组件类型。
- en: '![c03-4.png](image_fi/293313c03/c03-4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![c03-4.png](image_fi/293313c03/c03-4.png)'
- en: '[**Figure 3.4**](#figureanchor3.4) Nested components from chapter 2 dashboard
    screen'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图3.4**](#figureanchor3.4) 嵌套组件来自第2章的仪表盘屏幕'
- en: The Dashboard component holds the data for all the stocks and binds that information
    into the individual Summary components. Each Summary component uses the provided
    stock data to display itself. Any changes in the dashboard data will cause the
    child Summary components to be updated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Dashboard组件持有所有股票的数据，并将这些信息绑定到各个Summary组件中。每个Summary组件使用提供的股票数据来显示自己。仪表盘数据中的任何变化都会导致子Summary组件被更新。
- en: The basic interaction of components is to push data down from parent components,
    usually through binding, and back up, usually through events. There are other
    ways for components to communicate (something I cover in more detail later), but
    much of your time working with Angular will be composing trees of components into
    a meaningful interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的基本交互是从父组件向下推送数据，通常通过绑定，以及向上回传，通常通过事件。组件之间还有其他通信方式（我将在稍后更详细地介绍），但你在使用Angular的大部分时间将用于将组件树组合成一个有意义的界面。
- en: 3.1.3 Directives
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 指令
- en: Angular favors putting logic and capabilities straight into the HTML markup
    of the application, and directives are a powerful tool to teach HTML elements
    new skills.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Angular倾向于直接将逻辑和能力放入应用程序的HTML标记中，而指令是教授HTML元素新技能的强大工具。
- en: You likely have used jQuery plugins in the past to enhance existing elements
    with new behaviors. There are endless plugins to turn regular elements into slideshows,
    tabs, and other things. The way these plugins work is that they take an existing
    element and apply new capabilities, such as making an image open up in a modal
    window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你过去可能使用过jQuery插件来增强现有元素的新行为。有无数插件可以将常规元素转换为幻灯片、标签和其他东西。这些插件的工作方式是，它们取一个现有元素并应用新的功能，例如使图片在模态窗口中打开。
- en: Similarly, directives can take a normal element and give it additional capabilities
    that don’t exist naturally. Imagine you’re building a form in which it’s important
    that the user doesn’t accidentally click any links to navigate away. You could
    create a directive that can disable links depending on whether the user has started
    to use the form or if they’ve completed it, and internally it would modify the
    anchor link to disable the `href` and therefore the clickability of the link.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，指令可以将一个普通元素转换并赋予它一些自然不存在的额外能力。想象一下，你正在构建一个表单，其中用户不小心点击任何链接进行导航是很重要的。你可以创建一个指令，根据用户是否已经开始使用表单或是否已经完成它来禁用链接，并且它将内部修改锚链接以禁用`href`，从而禁用链接的可点击性。
- en: Let’s look back to chapter 2 again and see how we used different directives
    to give regular elements new skills. Figure 3.5 shows the directives used on the
    dashboard view, which has NgFor, NgClass, and NgIf. The figure is annotated with
    how these directives changed the element behavior.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾第2章，看看我们是如何使用不同的指令来赋予常规元素新技能的。图3.5显示了仪表板视图中使用的指令，其中包括NgFor、NgClass和NgIf。该图注解了这些指令如何改变元素的行为。
- en: 'Here is one that adds a directive that will render or remove the element based
    on the value inside the attribute value (known as an expression):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个添加指令的例子，该指令将根据属性值中的值（称为表达式）来渲染或移除元素：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![c03-5.png](image_fi/293313c03/c03-5.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![c03-5.png](image_fi/293313c03/c03-5.png)'
- en: '[**Figure 3.5**](#figureanchor3.5) Directives used in chapter 2 stock application'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图3.5**](#figureanchor3.5) 第2章股票应用中使用的指令'
- en: The `*ngIf` is the directive, which is applied as an attribute to the element,
    and it will evaluate the value it’s assigned to (more on this later in section
    3.6). In this case, if the expression is truthy, it will render the element—otherwise
    it will remove it from the DOM. NgIf gives an element the ability to conditionally
    render or be removed, which is possibly the most common use of JavaScript on the
    web.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`*ngIf` 是一个指令，它被用作元素的属性，并且会评估它所分配的值（关于这一点，将在第3.6节中进一步讨论）。在这种情况下，如果表达式为真，它将渲染元素——否则它将从DOM中移除。NgIf赋予元素条件渲染或被移除的能力，这可能是JavaScript在网页上最常见的使用方式。'
- en: 'There are three categories of directives: attribute directives, structural
    directives, and components. We already talked about components, and it should
    make sense how a component adds new capabilities to HTML, making it also a directive.
    But components are special because they’re the only type of directive with a template,
    and therefore I suggest thinking of them as their own type of entity.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 指令分为三类：属性指令、结构指令和组件。我们已经讨论了组件，并且应该明白组件是如何向HTML添加新功能，使其也成为一种指令的。但是，组件是特殊的，因为它们是唯一具有模板的指令类型，因此我建议将它们视为一种独立的实体。
- en: Attribute directives are like our earlier example, where they modify the appearance
    or behavior of an element. The NgClass directive is one such example provided
    by Angular out of the box, which we saw in chapter 2\. There are a number of built-in
    attribute directives, so you won’t necessarily have to build many of your own.
    Typically, they work by changing the various properties of the element they are
    associated with, such as the NgClass directive changing the list of classes attached.
    Most directives are attribute directives.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令类似于我们之前的例子，它们会修改元素的外观或行为。NgClass指令是Angular提供的一个例子，我们在第2章中看到了它。存在许多内置的属性指令，因此你不必构建很多自己的。通常，它们通过改变它们所关联的元素的各个属性来实现，例如，NgClass指令会改变附加的类列表。大多数指令都是属性指令。
- en: On the other hand, structural directives modify the DOM tree based on some conditions.
    In chapter 2 we also saw NgIf as a way to conditionally display a DOM element,
    and NgFor as a way to iterate over a list of items and display them. There are
    fewer of these types of directives built into Angular because they’re versatile.
    They work by adding or removing DOM elements to or from the page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，结构指令根据某些条件修改DOM树。在第2章中，我们也看到了NgIf作为条件显示DOM元素的方式，以及NgFor作为遍历项目列表并显示它们的方式。由于它们很灵活，Angular中内置的结构指令类型较少。它们通过向或从页面添加或删除DOM元素来实现。
- en: We used three directives in chapter 2, as outlined in [figure 3.5](#figure3.5).
    NgIf was used to hide the cards list until the data had loaded. NgFor was used
    to loop over each stock and create N number of copies. Then NgClass was used to
    change the card background, depending on the positive or negative change for the
    stock price. But we didn’t go into detail about some of the other directives.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第2章中使用了三个指令，如[图3.5](#figure3.5)所示。NgIf用于在数据加载前隐藏卡片列表。NgFor用于遍历每个股票并创建N个副本。然后使用NgClass根据股票价格的正负变化来更改卡片背景。但我们没有详细讨论一些其他指令。
- en: 'The primary default directives provided by Angular consist of the following
    (there are also some provided by the Forms and Router modules):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供的首要默认指令包括以下内容（还有由表单和路由模块提供的一些）：
- en: '*NgClass* —Conditionally apply a class to an element'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NgClass* — 有条件地应用一个类到元素'
- en: '*NgStyle* —Conditionally apply a set of styles to an element'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NgStyle* — 有条件地应用一组样式到元素'
- en: '*NgIf* —Conditionally insert or remove an element from the DOM'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NgIf* — 有条件地插入或从DOM中删除一个元素'
- en: '*NgFor* —Iterate over a collection of items'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NgFor* — 遍历一个项目集合'
- en: '*NgSwitch* —Conditionally display an item from a set of options'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NgSwitch* — 有条件地显示一组选项中的一个'
- en: Without directives in the stock application, we would have to write JavaScript
    that would dynamically create multiple summary cards, and that gets harder to
    manage over time. Directives make life much easier because they modify an element
    to give it a new capability, without having to use JavaScript to reach into the
    template and modify it on the fly. We don’t have to use something like jQuery
    to modify the DOM and put our logic in an external, dissociated location.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在股票应用中没有指令，我们就必须编写JavaScript来动态创建多个摘要卡片，而且随着时间的推移，这会变得更加难以管理。指令使生活变得更加容易，因为它们通过修改元素来赋予它新的功能，而无需使用JavaScript动态进入模板并实时修改它。我们不必使用像jQuery这样的东西来修改DOM，并将我们的逻辑放在外部、分离的位置。
- en: 3.1.4 Pipes
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 管道
- en: Often you want to display data in a different format than the format it’s stored
    in. Typically, you want to have a date stored as a timestamp value, but that’s
    not particularly user-friendly. Using pipes, we can transform the data in the
    view during rendering without changing the underlying data value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望以不同于存储格式的格式显示数据。通常，你希望将日期存储为时间戳值，但这并不特别用户友好。使用管道，我们可以在渲染过程中转换视图中的数据，而不会改变底层数据值。
- en: 'Pipes are added into template expressions using the pipe character (`|`). For
    example, you could have an expression that looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道字符（`|`）将管道添加到模板表达式中。例如，你可以有一个看起来像这样的表达式：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The expression on the left side remains the same as we’ve seen throughout the
    chapter, but the addition of the pipe on the right side then applies a transformation
    to the value of the expression. In this case, it will use the Date pipe to format
    the user’s registration date. It also takes an option; a colon (`:`) denotes that
    the following value is passed to the pipe as a configuration option. In this example,
    you’re passing a configuration option that formats the date according to the format
    of `'shortDate'`, which I’ll cover shortly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的表达式与我们本章中看到的一致，但在右侧添加管道后，则会对表达式的值应用转换。在这种情况下，它将使用日期管道来格式化用户的注册日期。它还接受一个选项；冒号（`:`）表示下一个值作为管道的配置选项传递。在这个例子中，你传递了一个配置选项，该选项根据`'shortDate'`格式来格式化日期，我将在稍后介绍。
- en: In the stock app, we used the Currency and Percent pipes to display content.
    Figure 3.6 points out the pipes used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在股票应用中，我们使用了货币和百分比管道来显示内容。图3.6指出了使用的管道。
- en: '![c03-6.png](image_fi/293313c03/c03-6.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![c03-6.png](image_fi/293313c03/c03-6.png)'
- en: '**Figure 3.6** Pipes used by the stock application'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.6** 管道在股票应用中的使用'
- en: Angular comes with a set of default pipes that cover a number of common use
    cases. The default pipes are always available and don’t need to be injected or
    imported, so we can use them in our templates. Pipes are used by adding the pipe
    character and the name of the pipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自带一套默认管道，涵盖了众多常见用例。默认管道始终可用，无需注入或导入，因此我们可以在模板中使用它们。通过添加管道字符和管道名称来使用管道。
- en: Using a pipe changes the way the data is rendered, but it doesn’t change the
    value of the property. It creates a copy of the output, modifies it, and displays
    the resulting value. For example, the price for the FB stock is stored as a number,
    but when rendered, a copy of that value is converted to a string and formatted
    as a currency.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道会改变数据渲染的方式，但不会改变属性的值。它会创建输出值的副本，对其进行修改，并显示最终的结果值。例如，FB股票的价格存储为一个数字，但在渲染时，该值的副本会被转换为字符串，并格式化为货币形式。
- en: I like to create my own pipes to handle formatting whenever possible. This helps
    because the logic is easy to reuse and keeps code out of the component controller.
    Anytime you’re doing any kind of formatting of data, you should consider whether
    it can be a pipe. You’ll likely only create a handful of pipes, because they tend
    to be reusable and easily shared.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢尽可能创建自己的管道来处理格式化。这样做的好处是逻辑容易重用，并且可以将代码从组件控制器中分离出来。每次进行任何类型的数据格式化时，都应该考虑它是否可以成为一个管道。你可能会只创建少量管道，因为它们通常是可重用且易于共享的。
- en: 3.1.5 Services
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.5 服务
- en: The last primary entity type is services, which are a way to reuse functional
    pieces of JavaScript logic across your application. Developers often need to write
    some code that does repetitive tasks, and we don’t want it to be duplicated all
    around. Sometimes these services are a gateway to access data (such as we built
    in chapter 2), and other times they’re more like helper functions, like custom
    sorting algorithms. I’ll talk more in depth in section 3.4 about dependency injection
    to explain how these services are made available and shared.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个主要实体类型是服务，它们是在应用程序中跨组件重用JavaScript逻辑片段的一种方式。开发者经常需要编写一些执行重复性任务的代码，我们不希望它在各个地方重复。有时这些服务是访问数据（如我们在第2章中构建的）的网关，而有时它们更像是辅助函数，例如自定义排序算法。我将在第3.4节中更深入地讨论依赖注入，以解释这些服务是如何被提供和共享的。
- en: Angular provides a number of services out of the box, and many third-party modules
    will also expose services. In chapter 2, we built a service that also used the
    Angular Http service to request data—we created a wrapper around the Angular service
    to make it easier for us to use in our application. Let’s take another look at
    this code snippet in the following listing, though it has been simplified to highlight
    the use of the HttpClient service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一些内置的服务，许多第三方模块也会公开服务。在第2章中，我们构建了一个使用Angular Http服务请求数据的服务——我们创建了一个Angular服务的包装器，以便我们更容易在应用程序中使用它。尽管以下列表中的代码已被简化以突出HttpClient服务的使用，但让我们再次查看这个代码片段。
- en: '**Listing 3.2** Stock service, simplified'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3.2** 股票服务，简化版'
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, I’ve removed some of the extra code that isn’t related to using
    the HttpClient service. First HttpClient is imported to the file and then it’s
    injected into the `StocksService` through the controller. These are the steps
    to make a service consumable by your objects in Angular. For example, the same
    two steps would apply if this were a component controller.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我移除了一些与使用HttpClient服务无关的额外代码。首先将HttpClient导入到文件中，然后通过控制器将其注入到`StocksService`中。这些步骤是在Angular中使服务可由对象使用的方法。例如，如果这是一个组件控制器，相同的两个步骤也会适用。
- en: The `load()` method uses the HttpClient service to make a `GET` request, but
    it constructs the proper URL to call, making it easier to consume elsewhere in
    the application. Services are ideal for placing this type of logic that simplifies
    the usage of code and makes it possible to reuse.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`方法使用HttpClient服务进行`GET`请求，但它构建了正确的URL来调用，这使得在其他地方使用它更容易。服务是放置此类逻辑的理想场所，这种逻辑简化了代码的使用，并使其可重用。'
- en: Services are also the ideal place for data access, and component controllers
    aren’t. The principle of separation of concerns applies in Angular, and keeping
    individual entities focused on a single set of tasks is important for maintainability
    and testability. Make services that do one thing well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也是数据访问的理想场所，而组件控制器则不是。在Angular中，关注点分离的原则适用，并且保持单个实体专注于单一任务对于可维护性和可测试性非常重要。创建只做一件事且做得好的服务。
- en: I often write services for anything that isn’t inherently linked to the component
    controller, or that can be easily abstracted externally to the component. Sometimes
    I may only use a service in one place, but it helps better organize logic and
    intent for my code as well as help focus the testing. If at any point in the future
    I need to reuse that service, it’s ready to go. I find it’s easier to write another
    service than it is to over-engineer an existing service.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常为任何与组件控制器没有固有联系的东西或可以轻松抽象到组件外部的东西编写服务。有时我可能只在一个地方使用一个服务，但它有助于更好地组织代码的逻辑和意图，同时也有助于集中测试。如果将来我需要重用那个服务，它已经准备好了。我发现编写另一个服务比过度设计现有服务要容易。
- en: Now that we have a grasp of the primary entities in Angular, we can talk about
    how they all get combined during the rendering of the application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 Angular 中的主要实体，我们可以讨论它们如何在应用程序的渲染过程中结合在一起。
- en: 3.2 How Angular begins to render an app
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 Angular 开始渲染应用的方式
- en: The Angular CLI generates a fairly simple app that displays a single message
    on the screen, as we saw in chapter 2\. A number of things come together to make
    that simple message appear, and though we quickly covered how the app runs, we
    need to spend more time and dig into the details.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 生成了一个相当简单的 app，在屏幕上显示一条消息，正如我们在第 2 章中看到的。许多事情结合在一起才能使那条简单的消息出现，尽管我们很快介绍了应用是如何运行的，但我们还需要花更多的时间和精力深入了解细节。
- en: In Angular, the CLI generates a fairly lightweight app. It could be slightly
    smaller, but it’s easiest to consider the generated app as the base for future
    development, and I’ll often refer to it as the *base app*. We’ll focus on the
    app that’s generated when you run `ng new app-name`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，CLI 生成了一个相当轻量级的 app。它可能稍微小一些，但 easiest to consider the generated
    app as the base for future development, and I’ll often refer to it as the *base
    app*. 我们将关注当你运行 `ng new app-name` 时生成的 app。
- en: Angular has an app bootstrapping mechanism that kicks off the rendering. Figure 3.7
    shows the primary entities involved in the bootstrapping process and rendering
    of the content that gets displayed based on the base app.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有一个启动机制，用于启动渲染。图 3.7 显示了在引导过程中涉及的主要实体以及基于基础应用的渲染内容。
- en: '![c03-7.png](image_fi/293313c03/c03-7.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![c03-7.png](image_fi/293313c03/c03-7.png)'
- en: '**Figure 3.7** How Angular renders the base app into the browser'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.7**  Angular 如何将基础应用渲染到浏览器中'
- en: Immediately upon loading the page, the bootstrapper is called to begin Angular
    execution. You may be asking yourself, how does the bootstrap begin? The CLI uses
    webpack to build, and it compiles all the JavaScript and adds it as script tags
    to the bottom of the index.html on build. (You can learn more about webpack at
    [https://webpack.github.io/](https://webpack.github.io/) if you’re curious about
    the way it compiles.) This is when it will run the code to begin your app.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载立即，引导程序被调用以开始 Angular 的执行。你可能想知道引导是如何开始的？CLI 使用 webpack 进行构建，并将所有 JavaScript
    编译后添加为 script 标签到 index.html 的底部。（如果你对 webpack 的编译方式感兴趣，可以在 [https://webpack.github.io/](https://webpack.github.io/)
    上了解更多。）这时，它将运行代码以开始你的应用。
- en: Now that Angular has started, it loads your App module and reads through any
    additional dependencies that need to be loaded and bootstrapped. In the base app,
    the Browser module is loaded into the application before further execution happens.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Angular 已经启动，它加载你的 App 模块，并读取任何需要加载和启动的附加依赖项。在基础应用中，Browser 模块在进一步执行之前被加载到应用程序中。
- en: Then Angular renders the App component, which is the root element of your application.
    As this App component renders, any child components are also rendered as part
    of the component tree. This is like the DOM tree, except any special Angular template
    syntax has to be rendered by Angular. As it renders, it will also resolve bindings
    and set up event listeners for anything that declares it. Once this has been completed,
    the full application should be rendered out and available for the user to begin
    interacting with.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Angular 渲染 App 组件，这是你应用程序的根元素。当这个 App 组件渲染时，任何子组件也会作为组件树的一部分进行渲染。这就像 DOM
    树，但任何特殊的 Angular 模板语法都必须由 Angular 进行渲染。在渲染过程中，它还将解析绑定并为声明任何内容的任何内容设置事件监听器。一旦完成这些，完整的应用程序应该被渲染出来，并可供用户开始交互。
- en: The lifecycle of the application continues as the user begins to use the application,
    and the application will begin to react. As a user navigates around, the components
    on the screen will be removed, and new components will get loaded and rendered.
    The cycle of reacting to the user and rendering the component tree continues until
    the application is closed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的生命周期在用户开始使用应用程序时继续，应用程序将开始做出反应。当用户在应用程序中导航时，屏幕上的组件将被移除，新的组件将被加载和渲染。对用户做出反应和渲染组件树的周期将继续，直到应用程序关闭。
- en: Figure 3.7 doesn’t look closely at how a tree of components becomes the application,
    which we’ll see in more detail in chapter 4\.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7没有详细说明组件树如何成为应用程序，我们将在第4章中更详细地了解这一点。
- en: 3.3 Types of compilers
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 编译器的类型
- en: Angular provides two types of compilers, called the Just-in-Time (JiT) compiler
    and the Ahead-of-Time (AoT) compiler. The primary difference is the tooling and
    timing for the compiler, and that can change the way your application behaves
    and how it’s served to the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种类型的编译器，称为即时编译器（JiT）和预编译器（AoT）。它们的主要区别在于编译器的工具和时机，这可能会改变应用程序的行为以及它如何被提供给用户。
- en: With JiT compilation, it means that the compiling of the application happens
    in the browser only after the assets have all been loaded. That means there will
    be a lag between initially loading the page and being able to see the content.
    You saw that in the chapter 2 example, because there is a fairly basic “loading”
    message displayed until everything is ready and the compiler has run.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在JiT编译中，这意味着应用程序的编译仅在所有资源都加载完毕后才会发生在浏览器中。这意味着在页面最初加载和能够看到内容之间会有延迟。你可以在第2章的示例中看到这一点，因为有一个相当基本的“加载”信息显示，直到一切准备就绪并且编译器运行完毕。
- en: AoT, on the other hand, is a way to render the content before sending it to
    the browser. This means the user will be sent exactly what’s needed to display
    the content without any kind of loading message once the application assets have
    loaded.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，AoT是一种在发送到浏览器之前渲染内容的方法。这意味着一旦应用程序资源加载完成，用户将接收到显示内容所需的确切内容，而无需任何加载信息。
- en: The other big difference is that with JiT, the application must also load the
    compiler library before the application can execute, whereas the AoT version is
    able to drop this payload from being sent, causing a faster load experience.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重大区别是，与JiT相比，应用程序在执行之前必须加载编译器库，而AoT版本能够从发送中删除此负载，从而实现更快的加载体验。
- en: With AoT, we have the ability to perform a number of interesting optimizations,
    because the application is compiled before serving. The other possibility it provides
    is server-side rendering for applications, which can be useful for pre-rendering
    applications with user-specific data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在AoT中，我们能够在应用程序在服务之前编译的情况下执行许多有趣的优化。它提供的另一个可能性是应用程序的服务器端渲染，这对于预渲染具有用户特定数据的应用程序可能很有用。
- en: You should work to ensure your applications compile with the AoT compiler, because
    anytime you build your application for production it will use the AoT compiler.
    It is possible that in future releases of Angular, the JiT compiler may be removed
    entirely once AoT compilation is fast enough for development.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该努力确保你的应用程序使用AoT编译器进行编译，因为每次你为生产构建应用程序时，它都会使用AoT编译器。在Angular的未来版本中，一旦AoT编译对于开发足够快，JiT编译器可能会被完全移除。
- en: We’ll use JiT for all development in this book because it’s much faster to render
    and preview the application. We’ll also cover how to set up AoT compilation and
    reap the benefits when we build the application for production purposes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的所有开发中，我们将使用JiT，因为它渲染和预览应用程序的速度要快得多。我们还将介绍如何设置AoT编译，并在为生产目的构建应用程序时获得其好处。
- en: 3.4 Dependency injection
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 依赖注入
- en: All but the most basic code relies on using objects from other parts of the
    application. The problem is that the larger your code base becomes, the harder
    it is to ensure that individual parts are encapsulated while still being easy
    to access. Therefore, many programming languages or frameworks have some mechanism
    to facilitate tracking and sharing objects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最基本的代码之外，所有代码都依赖于使用来自应用程序其他部分的对象。问题是，随着代码库的增大，确保各个部分被封装同时仍然易于访问变得更加困难。因此，许多编程语言或框架都有某种机制来促进对象的跟踪和共享。
- en: There are many approaches to structuring your code in a way that allows you
    to easily share objects. *Dependency injection* (DI) is a pattern for obtaining
    objects that uses a registry to maintain a list of available objects and a service
    that allows you to request the object you need. Rather than having to pass around
    objects, you can ask for what you need when you need it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以组织您的代码，以便您能够轻松地共享对象。*依赖注入*（DI）是一种获取对象的模式，它使用注册表来维护可用对象列表，并允许您请求所需的对象。您不必传递对象，而可以在需要时请求所需的对象。
- en: You may be wondering how this is different from using JavaScript module imports
    and exports. Why do we need another method to pass code around when JavaScript
    now has modules? Dependency injection shouldn’t be confused with JavaScript module
    imports. There is a need for Angular to be able to keep track of what parts of
    the application need a particular service. JavaScript has no awareness of how
    dependencies are linked together, which can be useful information in understanding
    how to best assemble dependencies. Also, injecting a dependency with Angular will
    resolve any additional dependencies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道这与使用 JavaScript 模块导入和导出有何不同。为什么在 JavaScript 现在有了模块的情况下，我们还需要另一种方法来传递代码？依赖注入不应与
    JavaScript 模块导入混淆。Angular 需要能够跟踪应用程序的哪些部分需要特定的服务。JavaScript 没有意识到依赖项是如何相互关联的，这可能是理解如何最佳组装依赖项的有用信息。此外，使用
    Angular 注入依赖项将解决任何额外的依赖项。
- en: 'There are a few key pieces to the DI system. The first is the *injector*. This
    is the service that Angular provides for requesting and registering dependencies.
    The injector is often at work behind the scenes, but occasionally is used directly.
    Most of the time, you’ll invoke the injector by declaring a type annotation on
    the property. You may recall from chapter 2 how we injected the HttpClient service
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: DI 系统有几个关键部分。首先是 *injector*。这是 Angular 提供用于请求和注册依赖项的服务。注入器通常在幕后工作，但偶尔会直接使用。大多数时候，您将通过在属性上声明类型注解来调用注入器。您可能还记得在第
    2 章中我们如何像这样注入 HttpClient 服务：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because we declare the type as `HttpClient` (which is a known service in Angular),
    the application will use the injector to ensure that the `http` property contains
    an instance of the HttpClient service. This seems like magic, but it’s merely
    a way to alias the dependency you would like to request without directly calling
    the injector API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们声明类型为 `HttpClient`（Angular 中已知的服务），应用程序将使用注入器来确保 `http` 属性包含 HttpClient
    服务的实例。这看起来像是魔法，但这仅仅是一种别名您想要请求的依赖项，而不直接调用注入器 API 的方式。
- en: The second part of DI is *providers*. Providers are responsible for creating
    the instance of the object requested. The injector knows the list of available
    providers, and based on the name (which above is HttpClient), it calls a factory
    function from the provider and returns the requested object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: DI 的第二部分是 *providers*。提供者负责创建请求的对象的实例。注入器知道可用提供者的列表，并根据名称（上面是 HttpClient），调用提供者的工厂函数并返回请求的对象。
- en: 'Anything that has been registered with an NgModule’s `providers` array is available
    to be injected in your application code. You can inject anywhere, but I prefer
    to use the TypeScript approach, as we saw earlier, where the constructor properties
    are annotated with the specific type of service to inject. Alternatively, you
    could use the `@Inject` decorator to inject the Http service, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NgModule 的 `providers` 数组中注册的任何内容都可以在您的应用程序代码中注入。您可以在任何地方注入，但我更喜欢使用 TypeScript
    方法，正如我们之前看到的，其中构造函数属性被注解为要注入的特定类型的服务。或者，您可以使用 `@Inject` 装饰器来注入 Http 服务，如下所示：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This decorator wires up the dependency injection the same way as the TypeScript
    typing information. Either way you’ll get the same result.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器将依赖注入与 TypeScript 类型信息以相同的方式连接起来。无论哪种方式，您都会得到相同的结果。
- en: Providers don’t have to be exposed to the root module and instead can be made
    visible only to a particular component or component tree. We’ll look at how this
    works in more detail in chapter 6, but for now know that there's a lot of power
    that can be harnessed with DI.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者不必暴露给根模块，而可以仅使特定组件或组件树可见。我们将在第 6 章中更详细地探讨这一点，但到目前为止，您应该知道 DI 有很多可以利用的力量。
- en: Let’s now take a look at how Angular knows about changes in the application
    and how that results in re-rendering the application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 Angular 如何了解应用程序中的更改，以及这如何导致应用程序重新渲染。
- en: 3.5 Change detection
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 变更检测
- en: Simply put, *change detection* is the mechanism for keeping data and the rendered
    views in sync with one another. Changes always come down from the model into the
    view, and Angular employs a unidirectional propagation of changes from parents
    down to children. This helps ensure that if a parent changes, any children are
    also checked, due to potential linked data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*变更检测*是保持数据和渲染视图之间同步的机制。更改总是从模型到视图的下传，Angular采用从父组件到子组件的单向传播更改。这有助于确保如果父组件发生变化，任何子组件也会因为潜在关联数据而被检查。
- en: Angular will run a change detection process to check whether values have changed
    since the last time the process ran. JavaScript has no guaranteed way to notify
    about any change to an object, so Angular runs this process instead. It may sound
    heavy to be running these checks, but there are a number of optimizations that
    allow this to occur in a few milliseconds.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将运行变更检测过程来检查自上次运行过程以来值是否已更改。JavaScript没有保证通知对象任何更改的方法，因此Angular运行此过程。虽然运行这些检查可能听起来很重，但有一些优化允许这个过程在几毫秒内发生。
- en: To make this happen, Angular creates a special class, known as a *change detector*,
    when it renders a component. This class is in charge of keeping track of the state
    of the component data and detecting whether any values have changed between the
    times the change detection ran.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，当Angular渲染一个组件时，它会创建一个特殊类，称为*变更检测器*。这个类负责跟踪组件数据的状态，并在变更检测运行之间检测是否有任何值发生了变化。
- en: When a value change is detected in a component, it will update the component
    and potentially any child components as well. Also, because Angular applications
    are component trees, Angular can determine which components might be impacted
    by the change and limit the work involved.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当在组件中检测到值的变化时，它将更新该组件，并可能更新任何子组件。此外，由于Angular应用程序是组件树，Angular可以确定哪些组件可能会受到更改的影响，并限制涉及的工作。
- en: Angular has two ways for changes to be triggered. The Default mode will traverse
    the entire tree looking for changes with each change detection process. The OnPush
    mode tells Angular that the component only cares about changes to any values that
    are input into the component from its parent, and gives Angular the ability to
    skip checking the component during change detection if it already knows the parent
    hasn’t changed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有两种触发更改的方式。默认模式会在每次变更检测过程中遍历整个树以寻找更改。OnPush模式告诉Angular，组件只关心从父组件输入到组件中的任何值的更改，并赋予Angular在已知父组件未更改的情况下跳过在变更检测期间检查组件的能力。
- en: 'Change detection is triggered by either events, receiving HTTP responses, or
    timers/intervals. The best way to think of it is that anytime something asynchronous
    occurs, the change detection process begins to determine what may have changed,
    because synchronous calls are already handled during the normal rendering flow
    of Angular. Think of it like this: You can turn on your car, but until you put
    it in gear, push the pedal, or brake, the vehicle is in an idle state, waiting
    for the driver to give it something to do.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测由事件、接收HTTP响应或计时器/间隔触发。最好的理解方式是，每当发生异步操作时，变更检测过程开始确定可能发生了什么更改，因为同步调用已经在Angular的正常渲染流程中处理了。可以这样想：你可以打开你的车，但直到你挂上档位，踩下油门或刹车，车辆都处于闲置状态，等待驾驶员给它一些事情做。
- en: If we go back to how the component trees are designed, you'll remember how the
    tree pushes data down to children and events bubble data up. Change detection
    is the mechanism that allows components to be updated when data changes in a parent
    component, and ensure views and data are in sync.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾组件树的设计方式，你会记得树是如何将数据推送到子组件，以及事件是如何将数据向上冒泡的。变更检测是允许组件在父组件中的数据发生变化时更新的机制，并确保视图和数据同步。
- en: 3.6 Template expressions and bindings
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 模板表达式和绑定
- en: A component always has a template, and therefore it’s a logical place to start
    our deep dive into how templates shape the behavior of your application. Unlike
    many other approaches to building web applications, Angular allows the placement
    of logic and customization directly into the template, which allows for more declarative
    templates. This may feel a bit strange to you at first, but I have found it to
    be an elegant way to design applications. There are certainly some pitfalls that
    may arise, but keep an open mind and see how it can be embraced with Angular.
    Sometimes people think this is mixing presentation and business logic, which is
    true to some degree, but it allows us to write much cleaner code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 组件始终有一个模板，因此它是我们深入研究模板如何塑造应用程序行为的逻辑起点。与构建Web应用程序的许多其他方法不同，Angular允许将逻辑和定制直接放置到模板中，这使得模板更加声明式。一开始这可能会让您感到有些奇怪，但我发现这是一种优雅的应用程序设计方式。当然，可能会出现一些陷阱，但请保持开放的心态，看看它是如何被Angular所接受的。有时人们认为这是将表示层和业务逻辑混合在一起，这在某种程度上是正确的，但它允许我们编写更干净的代码。
- en: 'A template by itself is regular HTML, but with a few Angular capabilities that
    HTML markup takes on a whole new life. A template can leverage values stored in
    the controller inside the template logic. We saw a few templates in chapter 2,
    and they demonstrated several concepts:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本身是普通的HTML，但通过Angular的一些能力，HTML标记获得了全新的生命。模板可以利用存储在模板逻辑中的控制器中的值。我们在第2章中看到了一些模板，它们演示了几个概念：
- en: '*Interpolation* —Displaying content in the page'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*插值* — 在页面上显示内容'
- en: '*Attribute and property bindings* —Linking data from the component controller
    into attributes or properties of other elements'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性和属性绑定* — 将组件控制器中的数据链接到其他元素的属性或属性'
- en: '*Event bindings* —Adding event listeners to elements'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件绑定* — 向元素添加事件监听器'
- en: '*Directives* —Modifying the behavior or adding additional structure to elements'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指令* — 修改元素的行为或添加额外的结构'
- en: '*Pipes* —Formatting data before it’s displayed on the page'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管道* — 在显示在页面上之前格式化数据'
- en: 'Throughout the template you’ll see template *expressions*. These are like normal
    Java­Script expressions (any statements you could conclude with a semicolon),
    and all values resolve against the component controller. There are some additional
    features and limitations that template expressions have when compared to expressions
    in JavaScript:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个模板中，您会看到模板**表达式**。这些类似于普通的JavaScript表达式（任何可以用分号结束的语句），并且所有值都会相对于组件控制器进行解析。与JavaScript中的表达式相比，模板表达式有一些额外的功能和限制：
- en: They’re unable to reach globals, such as `console` or `window`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们无法访问全局变量，如`console`或`window`。
- en: They can’t be used to assign values to variables (except in events).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能用于向变量赋值（除了在事件中）。
- en: They can’t use the `new`, `++`, `--`, `|`, and `&` operators.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能使用`new`、`++`、`--`、`|`和`&`运算符。
- en: 'They provide new operators: `|` for pipes and the Elvis operator `?.` for allowing
    null properties.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了新的运算符：`|`用于管道和Elvis运算符`?.`用于允许空属性。
- en: 'Template expressions are used in three places: for interpolation, property
    bindings, and event bindings. Interpolation bindings, like the examples we’ve
    seen so far in this section, are shorthand for property bindings.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 模板表达式用于三个地方：用于插值、属性绑定和事件绑定。插值绑定，就像我们在本节中看到的例子一样，是属性绑定的简写。
- en: Let’s imagine we have a controller, and it has a `user` property and a `save`
    method. In the page, we’d want to display the user’s name and profile image and
    have a form so they could update their details. The basics would look something
    like [figure 3.8](#figure3.8). We’ll use this example to discover how data flows
    from the controller into a template, or how events flow up from the template to
    the controller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个控制器，它有一个`user`属性和一个`save`方法。在页面上，我们想要显示用户的姓名和简介图片，并有一个表单，以便他们可以更新他们的详细信息。基本结构可能看起来像[图3.8](#figure3.8)。我们将使用这个例子来了解数据是如何从控制器流到模板的，或者事件是如何从模板流到控制器的。
- en: '![c03-8.png](image_fi/293313c03/c03-8.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![c03-8.png](image_fi/293313c03/c03-8.png)'
- en: '[**Figure 3.8**](#figureanchor3.8) How a controller binds data into a template
    for interpolation, property, and event bindings, each using a different syntax'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图3.8**](#figureanchor3.8)  控制器如何将数据绑定到模板中进行插值、属性和事件绑定，每个都使用不同的语法'
- en: Bindings are the conduit for data or methods to be used from a controller in
    the template; they allow data in the controller to flow into the template, or
    events to call from the template back into the controller.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是数据或方法从模板中的控制器使用的通道；它们允许控制器中的数据流入模板，或者从模板调用事件回控制器。
- en: Let’s go through a bit more detail on bindings and template capabilities Angular
    provides, and then we’ll see how they get applied to our chapter example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解绑定和Angular提供的模板功能，然后我们将看到它们是如何应用到我们章节示例中的。
- en: 3.6.1 Interpolation
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 插值
- en: '*Interpolation* is probably the most used type of template syntax in Angular.
    We used it several times in chapter 2, but didn’t dig deeper into how it works.
    Interpolation resolves a binding and displays the resulting value as a string
    in the page.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*插值*可能是Angular中最常用的模板语法类型。我们在第2章中多次使用它，但没有深入探讨其工作原理。插值解析绑定并在页面上以字符串形式显示结果值。'
- en: 'The binding works by taking an expression, evaluating it, and replacing the
    binding with the result. This is similar to how a spreadsheet can take a formula
    (such as adding the values of a column of cells), calculate the resulting value
    (by resolving the formula against the data stored in the spreadsheet), and then
    display the value in that cell (in place of the formula). Here is our interpolation
    example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定通过获取一个表达式，评估它，并用结果替换绑定来工作。这与电子表格可以取一个公式（例如，添加单元格列的值）类似，通过将公式与存储在电子表格中的数据解析来计算结果值，然后在单元格中显示该值（代替公式）。以下是我们的插值示例：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Interpolations always use the `{{value}}` syntax to bind data into the template.
    It’s a familiar pattern for anyone who has used mustache templates, as anything
    between the double curly braces is evaluated to render some text. Here are some
    additional valid interpolation expressions that bind values into the view:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 插值始终使用`{{value}}`语法将数据绑定到模板中。对于使用过mustache模板的人来说，这是一个熟悉的模式，因为双大括号之间的任何内容都会被评估以渲染一些文本。以下是一些将值绑定到视图中的有效插值表达式：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first two expressions evaluate simple values. Most of the time, though,
    you’ll be referencing a value from the component to display or evaluate, as you
    see in the five examples in the preceding code. These expressions are evaluated
    within the context of the component, meaning your component controller should
    have a property called `user` and a `getName()` method. The expression context
    is how the view resolves what a particular value refers to, so `{{user.name}}`
    is resolved based on the `user.name` property from the controller, as demonstrated
    in [figure 3.8](#figure3.8).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个表达式评估简单值。然而，大多数时候，您将引用组件中的值来显示或评估，正如您在前面的代码中的五个示例中所看到的。这些表达式在组件的上下文中进行评估，这意味着您的组件控制器应该有一个名为`user`的属性和一个`getName()`方法。表达式上下文是视图如何解析特定值的方式，因此`{{user.name}}`是根据控制器中的`user.name`属性解析的，如[图3.8](#figure3.8)所示。
- en: Next we’ll take a look at property bindings and how they’re used to modify properties
    of elements that we want to make dynamic in some way.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨属性绑定及其如何用于修改我们想要以某种方式动态化的元素属性。
- en: 3.6.2 Property bindings
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 属性绑定
- en: 'In addition to interpolation, another binding type is *property bindings*,
    which allow you to bind values to properties of an element to modify their behavior
    or appearance. This can include properties such as `class`, `disabled`, `href`,
    or `textContent`. Property bindings also allow you to bind to custom component
    properties (called *inputs*—covered in much greater detail in chapter 4). For
    example, if you load a record from the database that contains a URL to an image,
    you can bind that URL into an `img` element to display that image:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了插值之外，另一种绑定类型是*属性绑定*，它允许您将值绑定到元素的属性上以修改其行为或外观。这可以包括诸如`class`、`disabled`、`href`或`textContent`等属性。属性绑定还允许您绑定到自定义组件属性（称为*inputs*——在第4章中详细讨论）。例如，如果您从数据库中加载一个包含图像URL的记录，您可以将该URL绑定到一个`img`元素上以显示该图像：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In fact, interpolation is shorthand for binding to the `textContent` property
    of an element. They can both accomplish the same thing in many situations, so
    you can choose to use whichever feels most natural.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，插值是绑定到元素`textContent`属性的简写。它们在许多情况下都可以完成相同的事情，因此您可以选择使用最自然的感觉。
- en: 'The syntax for property bindings is to put the property onto the element wrapped
    in brackets (`[]`). The name should match the property, usually in camel case,
    like `textContent`. We can rewrite the interpolation template to use property
    bindings like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定的语法是将属性放在括号内的元素上（`[]`）。名称应与属性匹配，通常为驼峰式，如 `textContent`。我们可以将插值模板重写为使用属性绑定，如下所示：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Interpolation is a shortcut for a property binding to the `textContent` property
    of an element.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是元素 `textContent` 属性的属性绑定的快捷方式。
- en: As with interpolation, the bindings are evaluated in the component context,
    so the binding will reference properties of the controller. Here you have the
    `[src]="user.img"` property binding, which does the same thing as `src="{{user.img}}"`.
    Both will evaluate the expression to bind the value to the image `src` property,
    but the syntax is different. Property bindings don’t use the curly braces and
    evaluate everything inside the quotes as the expression. I almost always use property
    bindings over interpolation when binding data into properties.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与插值类似，绑定是在组件上下文中评估的，因此绑定将引用控制器的属性。这里你有 `[src]="user.img"` 属性绑定，它与 `src="{{user.img}}"`
    做的是同样的事情。两者都会评估表达式并将值绑定到图像的 `src` 属性，但语法不同。属性绑定不使用花括号，并将引号内的所有内容作为表达式进行评估。我在将数据绑定到属性时几乎总是使用属性绑定而不是插值。
- en: 'To restate: interpolation is a shortcut for a property binding to the `textContent`
    property of an element. We could rewrite our interpolation example like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重新说明：插值是元素 `textContent` 属性的属性绑定的快捷方式。我们可以将我们的插值示例重写如下：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This results in the same output of rendering the user’s name in this case, but
    doing it this way isn’t common because it makes it harder to create longer text
    strings. Also, most developers will find the interpolation version to be more
    readable and concise. This might give you a new appreciation for how interpolation
    works, because under the hood, interpolation evaluates its own binding this way.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致在这种情况下渲染用户名称的相同输出，但这种方式并不常见，因为它使得创建较长的文本字符串更困难。此外，大多数开发者会发现插值版本更易于阅读和简洁。这可能会让您对插值的工作方式有新的认识，因为底层，插值以这种方式评估其自己的绑定。
- en: Using the `[]` syntax binds to an element’s property, not the attribute. This
    is an important distinction, because properties are the DOM element’s property.
    That makes it possible to use any valid HTML element property (such as the `img`
    `src` property). Instead of binding the data to the attribute, you’re binding
    data directly to the element property, which is quite efficient.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[]` 语法绑定到元素的属性，而不是属性。这是一个重要的区别，因为属性是 DOM 元素的属性。这使得可以使用任何有效的 HTML 元素属性（例如
    `img` 的 `src` 属性）。您不是将数据绑定到属性，而是直接将数据绑定到元素属性，这非常高效。
- en: Note that sometimes properties are in camel case even if the HTML attribute
    isn't. For example, the `rowspan` attribute for table cell elements is exposed
    as the `rowSpan` property for the element. If you did interpolation, you could
    use `rowspan="{{rows}}"`; if you did property binding, you would have to use `[rowSpan]="rows"`.
    I know it can be a little confusing, so when you’re debugging bindings, be sure
    to check that the names match.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使 HTML 属性不是驼峰式，属性有时也是驼峰式。例如，表格单元格元素的 `rowspan` 属性暴露为元素的 `rowSpan` 属性。如果您进行插值，可以使用
    `rowspan="{{rows}}"`；如果您进行属性绑定，则必须使用 `[rowSpan]="rows"`。我知道这可能会有些令人困惑，所以当您调试绑定时，请务必检查名称是否匹配。
- en: 3.6.3 Special property bindings
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 特殊属性绑定
- en: There are a couple of special property bindings for setting a class and style
    property for an element. They are both different from many properties that you
    typically bind to, because these properties contain a list of classes or styles,
    instead of setting a single property, and Angular has a special syntax for setting
    these properties.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种特殊的属性绑定用于设置元素的类和样式属性。它们与您通常绑定的许多属性都不同，因为这些属性包含一个类或样式的列表，而不是设置单个属性，Angular
    有特殊的语法来设置这些属性。
- en: 'The class property on an element is a `DOMTokenList`, which is a fancy array.
    You can do `[class]="getClass()"` and it will set a string of class or classes,
    but this will mess with any of the classes on the element if they’re already set.
    Often you’ll want to toggle a single class, which you can do by using a `[class.className]`
    syntax in the property. It will see the `class.` prefix for the property binding
    and know you are binding a particular class called `className`. Let’s see an example
    and how it is rendered:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 元素上的类属性是一个`DOMTokenList`，它是一个花哨的数组。你可以使用`[class]="getClass()"`并设置一个类或类的字符串，但这会与元素上已设置的任何类发生冲突。通常，你想要切换一个单独的类，你可以通过在属性中使用`[class.className]`语法来实现。它将看到属性绑定的`class.`前缀并知道你正在绑定一个名为`className`的特定类。让我们看看一个例子以及它是如何渲染的：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The class binding syntax is useful for targeting specific classes to be added
    or removed from an element. It also only adds to the existing classes instead
    of replacing them entirely, like if you use `[class]="getClass()"`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类绑定语法用于针对特定类来添加或从元素中删除。它也仅添加到现有类中，而不是完全替换它们，就像你使用`[class]="getClass()"`那样。
- en: Likewise, the `style` property is a `CSSStyleDeclaration` object, which is a
    special object that holds all the CSS properties. Angular has the same type of
    syntax for style binding to set individual style properties. Using `[style.styleName]`
    you can set the value of any valid CSS style. For example
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`style`属性是一个`CSSStyleDeclaration`对象，它是一个特殊对象，它包含所有CSS属性。Angular有相同类型的语法来设置单个样式属性。使用`[style.styleName]`你可以设置任何有效CSS样式的值。例如
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any valid CSS property can be used here, and it will render the binding as a
    `style` value directly on the element. Did you notice the second example has a
    third item, `.em`? For properties that accept units, you can use this syntax to
    declare the unit for the value that is returned by the expression. You can also
    leave it off and have the expression return the unit.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以使用任何有效的CSS属性，并且它将直接在元素上渲染为`style`值。你注意到第二个例子有一个第三项，`.em`吗？对于接受单位的属性，你可以使用这种语法来声明由表达式返回的值的单位。你也可以省略它，让表达式返回单位。
- en: I find these special bindings to be most useful in simple or edge cases where
    I need to make a simple change. I usually use NgClass or NgStyle, because if you’re
    trying to change multiple classes or style rules on the same element, this syntax
    becomes cumbersome.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这些特殊绑定在简单或边缘情况下非常有用，在这些情况下我需要做出简单的更改。我通常使用NgClass或NgStyle，因为如果你试图在同一个元素上更改多个类或样式规则，这种语法就会变得繁琐。
- en: 3.6.4 Attribute bindings
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.4 属性绑定
- en: Some element properties can’t be directly bound, because some HTML elements
    have attributes that aren't also made available as properties of the element.
    The `aria` (accessibility) attributes are one such example of an attribute that
    doesn’t get added as a property to the element.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一些元素属性不能直接绑定，因为某些HTML元素具有属性，这些属性并不是作为元素的属性提供的。`aria`（可访问性）属性就是这样一个例子，它不会作为属性添加到元素中。
- en: You can always inspect an element in the developer tools to see the available
    properties. That’s the fastest way to verify if you can bind to a particular attribute
    or not. Once you’ve verified that the attribute isn’t exposed as a property, you
    have an alternative syntax that Angular supports to bind to those attributes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以在开发者工具中检查元素以查看可用的属性。这是验证你是否可以绑定到特定属性的最快方式。一旦你验证了该属性没有作为属性公开，你就有了一个Angular支持的替代语法来绑定这些属性。
- en: '`aria` attributes are used to indicate information to assistive devices about
    elements, such as `aria-required`, which marks an input as required for submission.
    Normally, you’d use an attribute like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`aria`属性用于向辅助设备指示有关元素的信息，例如`aria-required`，它标记输入为提交所必需。通常，你会使用这样的属性：'
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Imagine that this field might not always be required, because your form may
    require giving a username or an email, depending on the situation. If you try
    to do `aria-required="{{isRequired()}}"` or `[aria-required]="isRequired()"`,
    you’ll get a template parsing error. Because this attribute isn’t a property,
    it can’t be directly bound to.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这个字段可能并不总是必需的，因为你的表单可能需要根据情况提供用户名或电子邮件。如果你尝试做`aria-required="{{isRequired()}}"`或`[aria-required]="isRequired()"`，你会得到模板解析错误。因为这个属性不是属性，所以不能直接绑定。
- en: 'The workaround is using the special attribute binding syntax, which looks like
    a property binding, except you put the name of the attribute in the brackets with
    the prefix `attr.`, like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用特殊的属性绑定语法，它看起来像属性绑定，但你在方括号中放入属性名称，并带有前缀`attr.`，如下所示：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Angular will now bind to the attribute and not the nonexistent property. There
    aren’t many attributes that aren’t also properties, but if you come across a template
    parse error that your binding isn’t a known native property, you’re probably binding
    to one of these attributes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Angular现在将绑定到属性而不是不存在的属性。没有多少属性不是也是属性，但如果你遇到模板解析错误，你的绑定不是一个已知的原生属性，那么你很可能绑定到了这些属性之一。
- en: There aren’t too many situations where you’ll need to use attribute bindings,
    but it’s likely that you’ll need them occasionally.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要使用属性绑定，但很可能你偶尔会需要它们。
- en: 3.6.5 Event bindings
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.5 事件绑定
- en: So far, all data has flowed from the component into the template elements. That’s
    great for displaying data, but we need some way for the elements in our template
    to bind back into the component. The good news is that JavaScript has a great
    mechanism built in to pass data back up, by using *events*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有数据都是从组件流向模板元素的。这对于显示数据来说很棒，但我们需要一种方法让模板中的元素能够反向绑定到组件。好消息是JavaScript内置了一个很好的机制，通过使用*事件*来向上传递数据。
- en: When people use applications, they generate all kinds of events as they interact
    with them. Any time they move the mouse, click, type, or touch the screen, they
    generate events in JavaScript. You’ve probably written event listeners before,
    and we’ll use Angular’s event bindings to do the same thing. You can also create
    your own events and fire them as needed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们使用应用程序时，他们会通过与它们交互生成各种事件。每次他们移动鼠标、点击、键入或触摸屏幕时，JavaScript都会生成事件。你可能之前已经编写过事件监听器，我们将使用Angular的事件绑定来做同样的事情。你也可以创建自己的事件，并在需要时触发它们。
- en: First let’s take some general use cases to understand the use cases for event
    bindings. When a user is logging into your app, they fill in their login credentials
    and submit the form (usually by hitting Enter or clicking a button). The event
    is the *form submit*, and you then want that event to trigger some behavior in
    your component. Traditionally, you would create an event listener that listens
    to the form submit event, but with Angular we can create a binding that will call
    a method on the component controller to handle the event ([figure 3.9](#figure3.9)).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过一些通用用例来了解事件绑定的使用场景。当用户登录你的应用时，他们会填写登录凭证并提交表单（通常是通过按Enter键或点击按钮）。事件是*表单提交*，你希望这个事件触发组件中的某些行为。传统上，你会创建一个监听表单提交事件的监听器，但使用Angular，我们可以创建一个绑定，它会调用组件控制器中的方法来处理事件（[图3.9](#figure3.9)）。
- en: '![c03-9.png](image_fi/293313c03/c03-9.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![c03-9.png](image_fi/293313c03/c03-9.png)'
- en: '[**Figure 3.9**](#figureanchor3.9) Event bindings link an event from the template
    with a method from the controller.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图3.9**](#figureanchor3.9) 事件绑定将模板中的事件与控制器中的方法关联起来。'
- en: 'The syntax for event bindings uses parentheses `()` to bind to a known event.
    You will use the name of the event inside the parentheses, without the *on* part
    of the name. For an example form submit event, you would write it like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定的语法使用括号`()`来绑定到已知事件。你将在括号内使用事件名称，不包含名称中的*on*部分。例如，对于一个表单提交事件，你会这样写：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will create an event listener on the form that will call the `save()` method
    in the component controller when the form is submitted. The context is important
    because the event binding only binds up to the current component, but you can
    trigger events and those will bubble up to parent elements and components if they’re
    listening. If you need a reference of available standard events in HTML, [https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)
    is an excellent reference. Chapter 4 goes into more depth about events.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在表单上创建一个事件监听器，当表单提交时，会在组件控制器中调用`save()`方法。上下文很重要，因为事件绑定只绑定到当前组件，但如果你可以触发事件，并且如果父元素和组件正在监听，这些事件会冒泡到它们。如果你需要HTML中可用标准事件的参考，[https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)是一个极好的参考。第四章将更深入地介绍事件。
- en: 'Components and directives can emit their own events, and you can listen to
    those events. Chapter 4 looks at how to do this in detail, but let’s also look
    at an example from chapter 2\. In the manage view, we had a form that let you
    add a new stock. Here’s the form again:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 组件和指令可以发出它们自己的事件，你可以监听这些事件。第四章将详细探讨如何实现这一点，但让我们也看看第二章的一个例子。在管理视图中，我们有一个表单，允许你添加新的股票。这是表单的再次展示：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two parts: the `form` element that has the `submit` event binding
    and the `input` that holds the data the user inputs via the keyboard. When the
    user hits the Enter key, the form submit event fires, calling the `add()` method
    in the controller. The method looks at the value from the input box and adds the
    stock to the list. This was all triggered by the `submit` event.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它分为两部分：具有 `submit` 事件绑定的 `form` 元素和包含用户通过键盘输入的数据的 `input`。当用户按下 Enter 键时，表单提交事件触发，调用控制器中的
    `add()` 方法。该方法检查输入框中的值并将股票添加到列表中。所有这些都是由 `submit` 事件触发的。
- en: 'We also see a special binding syntax here: the two-way binding approach. It
    uses both the property and event binding syntax together, which Angular likes
    to call *banana in a box* (it does kind of look like that if you type `[()]` and
    use your imagination). Those familiar with AngularJS will be familiar with how
    it allows you to sync the value of a binding as it changes in either the template
    or the controller. It does this by doing a regular property binding and setting
    up an event binding for you behind the scenes. You can only use `NgModel` with
    form elements, but you can use two-way binding syntax on properties. Generally,
    you will want to limit the use of this two-way binding for when it’s absolutely
    needed.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一种特殊的绑定语法：双向绑定方法。它结合了属性和事件绑定语法，Angular 喜欢称之为“盒子里的香蕉”（如果你输入 `[()]` 并发挥想象力，它确实有点像那样）。熟悉
    AngularJS 的人会熟悉它如何允许你在模板或控制器中值变化时同步绑定值。它是通过执行常规属性绑定并在幕后为你设置事件绑定来实现的。你只能在与表单元素一起使用
    `NgModel`，但可以在属性上使用双向绑定语法。通常，你只想在绝对需要时才限制使用这种双向绑定。
- en: Event bindings are important to the way components and templates communicate,
    as well as to how components can communicate with one another. The syntax and
    concepts of event bindings are fairly simple, but can be used in more complex
    orchestrations to enhance communication between components.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定对于组件和模板之间的通信方式以及组件之间如何相互通信非常重要。事件绑定的语法和概念相当简单，但可以用于更复杂的编排，以增强组件之间的通信。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We’ve covered a lot of ground with Angular essentials in this chapter. This
    chapter should act as a helpful reference for the remainder of the book. The primary
    takeaways are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已对 Angular 的基础知识进行了全面覆盖。本章应作为本书剩余部分的参考指南。主要收获如下：
- en: An Angular application is a tree of components, and there is always a root application
    component.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Angular 应用程序是一棵组件树，并且始终有一个根应用程序组件。
- en: The various entity types (modules, components, directives, pipes, services)
    each have a specific role and purpose.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种实体类型（模块、组件、指令、管道、服务）各自具有特定的角色和目的。
- en: Angular has two types of compilers, Ahead-of-Time (AoT) and Just-in-Time (JiT),
    to give you different ways to render the application.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 有两种类型的编译器，即时编译（AoT）和即时编译（JiT），以提供不同的方式来渲染应用程序。
- en: Dependency injection is fundamental for Angular to track all the objects in
    the application and make them available when they’re requested.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入对于 Angular 跟踪应用程序中的所有对象并在请求时使它们可用是基本的。
- en: Change detection keeps the components in sync with the model data as asynchronous
    changes occur from user input or other events.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户输入或其他事件导致异步变化时，变更检测会保持组件与模型数据的一致性。
- en: 'Templates contain several types of bindings: interpolation for displaying data,
    property bindings for modifying the element’s properties, attribute bindings for
    modifying non-property values of an element, and event bindings for handling events.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板包含几种类型的绑定：用于显示数据的插值绑定、用于修改元素属性的属性绑定、用于修改元素非属性值的属性绑定以及用于处理事件的事件绑定。
