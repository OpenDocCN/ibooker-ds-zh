- en: Chapter 1\. What is functional programming?
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章：什么是函数式编程？
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: The benefits of functional programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的好处
- en: Problems with side effects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用的弊端
- en: How referential transparency makes programs safer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性如何使程序更安全
- en: Reasoning about programs with the substitution model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用替换模型对程序进行推理
- en: Making the most of abstraction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用抽象
- en: 'Not everybody agrees on a definition for functional programming (FP). In general
    terms, functional programming is a programming paradigm, and it’s about programming
    with functions. But this doesn’t explain the most important aspect: how FP is
    different from other paradigms, and what makes it a (potentially) better way to
    write programs. In his article “Why Functional Programming Matters,” published
    in 1990, John Hughes writes the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个人都对函数式编程（FP）的定义达成一致。一般来说，函数式编程是一种编程范式，它涉及使用函数进行编程。但这并没有解释最重要的方面：函数式编程与其他范式的不同之处，以及它为什么是一种（潜在的）更好的编程方式。在1990年发表的文章《为什么函数式编程很重要》中，约翰·休斯写道以下内容：
- en: Functional programs contain no assignment statements, so variables, once given
    a value, never change. More generally, functional programs contain no side effects
    at all. A function call can have no effect other than to compute its result. This
    eliminates a major source of bugs, and also makes the order of execution irrelevant—since
    no side effect can change an expression’s value, it can be evaluated at any time.
    This relieves the programmer of the burden of prescribing the flow of control.
    Since expressions can be evaluated at any time, one can freely replace variables
    by their values and vice versa—that is, programs are “referentially transparent.”
    This freedom helps make functional programs more tractable mathematically than
    their conventional counterparts.^([[1](#ch01fn01)])
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数式程序不包含赋值语句，因此变量一旦赋予值就不再改变。更普遍地说，函数式程序根本不包含任何副作用。函数调用除了计算其结果外，不会产生任何影响。这消除了错误的主要来源，并且使得执行顺序无关紧要——因为没有任何副作用可以改变表达式的值，所以它可以在任何时间进行评估。这减轻了程序员指定控制流程的负担。由于表达式可以在任何时间进行评估，因此可以自由地用其值替换变量，反之亦然——也就是说，程序是“引用透明的”。这种自由使得函数式程序在数学上比传统的对应程序更容易处理。^([[1](#ch01fn01)])
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ¹
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: John Hughes, “Why Functional Programming Matters,” from D. Turner, ed., *Research
    Topics in Functional Programming* (Addison-Wesley, 1990), 17–42, [www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf).
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 约翰·休斯，《为什么函数式编程很重要》，收录于D. 特纳编，《函数式编程研究主题》（Addison-Wesley，1990），17–42，[www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)。
- en: In the rest of this chapter, I’ll briefly present concepts such as referential
    transparency and the substitution model, as well as other concepts that together
    are the essence of functional programming. You’ll apply these concepts over and
    over in the coming chapters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将简要介绍诸如引用透明性和替换模型等概念，以及其他共同构成函数式编程本质的概念。你将在接下来的章节中反复应用这些概念。
- en: 1.1\. What is functional programming?
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 什么是函数式编程？
- en: It’s often as important to understand what something is not, as to agree about
    what it is. If functional programming is a programming paradigm, there clearly
    must be other programming paradigms that FP differs from. Contrary to what some
    might think, functional programming isn’t the opposite of object-oriented programming
    (OOP). Some functional programming languages are object-oriented; some are not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 了解某物不是什么，与同意它是什么一样重要。如果函数式编程是一种编程范式，那么显然必须存在其他与FP不同的编程范式。与一些人的想法相反，函数式编程并不是面向对象编程（OOP）的对立面。一些函数式编程语言是面向对象的；一些则不是。
- en: Functional programming is sometimes considered to be a set of techniques that
    supplement or replace techniques found in other programming paradigms, such as
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程有时被认为是一组补充或替代其他编程范式（如）中找到的技术的方法
- en: First-class functions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首类函数
- en: Anonymous functions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Closures
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Currying
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化
- en: Lazy evaluation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Parametric polymorphism
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数多态性
- en: Algebraic data types
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数数据类型
- en: Although it is true that most functional languages do use a number of these
    techniques, you may find, for each of them, examples of functional programming
    languages that don’t, as well as non-functional languages that do. As you’ll see
    when studying each of these techniques in this book, it’s not the language that
    makes programming functional. It’s the way you write the code. But some languages
    are more *functional-friendly* than others.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数函数式语言确实使用了一些这些技术，但你可能会发现，对于每一种技术，都有函数式编程语言不使用它的例子，以及非函数式语言使用它的例子。正如你在本书研究这些技术的每一部分时将会看到的，使编程成为函数式的不是语言本身，而是你编写代码的方式。但有些语言比其他语言更**函数式友好**。
- en: 'What functional programming may be opposed to is the imperative programming
    paradigm. In imperative programming style, programs are composed from elements
    that “do” something. “Doing” something generally implies an initial state, a transition,
    and an end state. This is sometimes called *state mutation*. Traditional imperative-style
    programs are often described as a series of mutations, separated with condition
    testing. For example, an addition program for adding two positive values `a` and
    `b` might be represented by the following pseudo code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程可能反对的是命令式编程范式。在命令式编程风格中，程序由“做”某事的元素组成。“做”某事通常意味着一个初始状态、一个转换和一个最终状态。这有时被称为**状态突变**。传统的命令式风格程序通常被描述为一系列突变，通过条件测试分隔。例如，一个用于添加两个正数`a`和`b`的加法程序可能被以下伪代码表示：
- en: '`if b == 0, return a`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if b == 0, return a`'
- en: '`else increment a and decrement b`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else increment a and decrement b`'
- en: '`start again with the new a and b`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start again with the new a and b`'
- en: 'In this pseudo code, you can recognize the traditional instructions of most
    imperative languages: testing conditions, mutating variables, branching, and returning
    a value. This code may be represented graphically by a flow chart, such as [figure
    1.1](#ch01fig01).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个伪代码中，你可以识别出大多数命令式语言的传统指令：测试条件、突变变量、分支和返回值。此代码可以通过流程图来图形化表示，如[图1.1](#ch01fig01)。
- en: Figure 1.1\. A flow chart representing an imperative program as a process that
    occurs in time. Various things are transformed and states are mutated until the
    result is obtained.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1\. 表示命令式程序作为在时间中发生的流程的流程图。各种事物被转换，状态被突变，直到获得结果。
- en: '![](Images/01fig01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig01.jpg)'
- en: On the other hand, functional programs are composed of elements that “are” something—they
    don’t “do” something. The addition of `a` and `b` doesn’t “make” a result. The
    addition of 2 and 3, for example, doesn’t *make* 5\. It *is* 5.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数式程序由“是”某物的元素组成——它们不“做”某事。`a`和`b`的加法并不“制造”一个结果。例如，2和3的加法并不**制造**5。它**就是**5。
- en: The difference might not seem important, but it is. The main consequence is
    that each time you encounter 2 + 3, you can replace it with 5\. Can you do the
    same thing in an imperative program? Well, sometimes you can. But sometimes you
    can’t without changing the program’s outcome. If the expression you want to replace
    has no other effect than returning the result, you can safely replace it with
    its result. But how can you be sure that it has no other effect? In the addition
    example, you clearly see that the two variables `a` and `b` have been destroyed
    by the program. This is an effect of the program, besides returning the result,
    so it’s called a *side effect*. (This would be different if the computation were
    occurring inside a Java method, because the variables `a` and `b` would be passed
    by value, and the change would then be local and not visible from outside the
    method.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别可能看起来并不重要，但它很重要。主要后果是，每次你遇到2 + 3时，你都可以用5来替换它。你能在命令式程序中做同样的事情吗？嗯，有时你可以。但有时你无法在不改变程序结果的情况下做到这一点。如果你想要替换的表达式除了返回结果没有其他效果，你可以安全地用它的结果来替换。但你如何确保它没有其他效果？在加法示例中，你可以清楚地看到两个变量`a`和`b`被程序破坏了。这是程序的一个效果，除了返回结果之外，所以它被称为**副作用**。（如果计算是在Java方法内部进行的，这将是不同的，因为变量`a`和`b`将通过值传递，变化将是局部的，并且从方法外部不可见。）
- en: One major difference between imperative programming and FP is that in FP there
    are no side effects. This means, among other things,
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程和FP之间的一大区别是，在FP中没有副作用。这意味着，在其他方面，
- en: No mutation of variables
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有变量突变
- en: No printing to the console or to any device
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不打印到控制台或任何设备
- en: No writing to files, databases, networks, or whatever
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不写入文件、数据库、网络或任何东西
- en: No exception throwing
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有抛出异常
- en: When I say “no side effects,” I mean no observable side effects. Functional
    programs are built by composing *functions* that take an argument and return a
    value, and that’s it. You don’t care about what’s happening *inside* the functions,
    because, in theory, nothing is happening ever. But in practice, programs are written
    for computers that aren’t functional at all. All computers are based on the same
    imperative paradigm; so functions are black boxes that
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“无副作用”时，我的意思是没有可观察的副作用。函数式程序是通过组合 *函数* 构建的，这些函数接受一个参数并返回一个值，仅此而已。你不需要关心函数内部发生的事情，因为，从理论上讲，永远没有发生任何事情。但在实践中，程序是为那些根本不是函数式的计算机编写的。所有计算机都基于相同的命令式范式；因此，函数是黑盒，它们
- en: Take an argument (a *single* one, as you’ll see later)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个参数（一个 *单个* 参数，你稍后会看到）
- en: Do mysterious things inside, such as mutating variables and a lot of imperative-style
    stuff, but with no effect observable from outside
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部执行神秘的操作，例如更改变量和大量的命令式风格的操作，但没有从外部可观察到的效果
- en: Return a (single) value
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个（单个）值
- en: This is theory. In practice, it’s impossible for a function to have no side
    effects at all. A function will return a value at some time, and this time may
    vary. This is a side effect. It might create an out-of-memory error, or a stack-overflow
    error, and crash the application, which is a somewhat observable side effect.
    And it will cause writing to memory, registering mutations, thread launching,
    context switching, and other sorts of things that are indeed effects observable
    from outside.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种理论。在实践中，一个函数完全没有副作用是不可能的。函数会在某个时间返回一个值，这个时间可能会变化。这就是副作用。它可能会创建一个内存不足错误，或者栈溢出错误，导致应用程序崩溃，这是一个可以观察到的副作用。它还会导致写入内存、注册变更、线程启动、上下文切换以及其他一些确实可以从外部观察到的效果。
- en: So functional programming is writing programs with no *intentional side effects*,
    by which I mean side effects that are part of the expected outcome of the program.
    There should also be as few non-intentional side effects as possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数式编程是编写没有 *有意副作用* 的程序，我的意思是这些副作用是程序预期结果的一部分。还应该尽可能少地有非有意副作用。
- en: 1.2\. Writing useful programs with no side effects
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 编写无副作用的实用程序
- en: You may wonder how you can possibly write useful programs if they have no side
    effects. Obviously, you can’t. Functional programming is not about writing programs
    that have no observable results. It’s about writing programs that have no observable
    results other than returning a value. But if this is all the program does, it
    won’t be very useful. In the end, functional programs have to have an observable
    effect, such as displaying the result on a screen, writing it to a file or database,
    or sending it over a network. This interaction with the outside world won’t occur
    in the middle of a computation, but only when you finish the computation. In other
    words, side effects will be delayed and applied separately.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如果没有副作用，你如何可能编写有用的程序。显然，你不能。函数式编程不是关于编写没有可观察结果程序的。它是关于编写除了返回值之外没有其他可观察结果的程序的。但如果程序只做这些，它将不会很有用。最终，函数式程序必须有一个可观察的效果，比如在屏幕上显示结果，写入文件或数据库，或者通过网络发送。这种与外部世界的交互不会在计算过程中发生，而只在你完成计算时发生。换句话说，副作用将被延迟并单独应用。
- en: 'Take the example of the addition in [figure 1.1](#ch01fig01). Although it’s
    described in imperative style, it might yet be functional, depending on how it’s
    implemented. Imagine this program is implemented in Java as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以图 1.1 中的加法为例。[#ch01fig01](#ch01fig01)。尽管它是以命令式风格描述的，但它可能仍然是函数式的，这取决于它的实现方式。想象这个程序是用以下方式用
    Java 实现的：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This program is fully functional. It takes an argument, which is the pair of
    integers `a` and `b`, it returns a value, and it has absolutely no other observable
    effect. That it mutates variables doesn’t contradict the requirements, because
    arguments in Java are passed by value, so the mutations of the arguments aren’t
    visible from outside. You can then choose to apply an effect, such as displaying
    the result or using the result for another computation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序功能齐全。它接受一个参数，即整数对 `a` 和 `b`，它返回一个值，并且绝对没有其他可观察的效果。它改变变量并不违反要求，因为在 Java 中参数是通过值传递的，所以参数的变更对外部是不可见的。然后你可以选择应用一个效果，比如显示结果或使用结果进行其他计算。
- en: 'Note that although the result might not be correct (in case of an arithmetic
    overflow), that’s not in contradiction with having no side effects. If values
    `a` and `b` are too big, the program will silently overflow and return an erroneous
    result, but this is still functional. On the other hand, the following program
    is not functional:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管结果可能不正确（在算术溢出的情况下），但这并不与没有副作用相矛盾。如果值`a`和`b`太大，程序将静默溢出并返回错误的结果，但这仍然是功能性的。另一方面，以下程序不是函数式的：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although this program doesn’t mutate any variables, it throws an exception
    if `b` is equal to `0`. Throwing an exception is a side effect. In contrast, the
    following implementation, although a bit stupid, is functional:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个程序没有修改任何变量，但如果`b`等于`0`，它会抛出异常。抛出异常是一个副作用。相比之下，以下实现，尽管有点愚蠢，但却是函数式的：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This implementation won’t throw an exception if `b` is equal to `0`, but it
    will return a special result. It’s up to you to decide whether it’s OK or not
    for your function to return this specific result to mean that the divisor was
    `0`. (It’s probably not!)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`b`等于`0`，这个实现不会抛出异常，但它会返回一个特殊的结果。是否允许你的函数返回这个特定的结果来表示除数是`0`取决于你。（这很可能不是！）
- en: 'Throwing an exception might be an intentional or unintentional side effect,
    but it’s always a side effect. Often, though, in imperative programming, side
    effects are wanted. The simplest form might look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常可能是有意为之或无意为之的副作用，但无论如何，它始终是一个副作用。然而，在命令式编程中，副作用通常是期望的。最简单的形式可能如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program doesn’t return a value, but it prints the result to the console.
    This is a desired side effect.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序不返回值，但它将结果打印到控制台。这是一个期望的副作用。
- en: 'Note that the program could alternatively both return a value and have some
    intentional side effects, as in the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，程序可以同时返回一个值并产生一些有意为之的副作用，如下面的例子所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This program isn’t functional because it uses side effects for logging.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序不是函数式的，因为它使用了副作用进行日志记录。
- en: 1.3\. How referential transparency makes programs safer
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 引用透明性如何使程序更安全
- en: Having no side effects (and thus not mutating anything in the external world)
    isn’t enough for a program to be functional. Functional programs must also not
    be affected by the external world. In other words, the output of a functional
    program must depend only on its argument. This means functional code may not read
    data from the console, a file, a remote URL, a database, or even from the system.
    Code that doesn’t mutate or depend on the external world is said to be referentially
    transparent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 没有副作用（因此不会对外部世界中的任何东西进行修改）对于程序来说并不足够。函数式程序还必须不受外部世界的影响。换句话说，函数式程序的输出必须只依赖于其参数。这意味着函数式代码可能无法从控制台、文件、远程URL、数据库或甚至从系统中读取数据。不修改或依赖于外部世界的代码被称为引用透明。
- en: 'Referentially transparent code has several properties that might be of some
    interest to programmers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明代码有几个属性，可能对程序员有些兴趣：
- en: It’s self-contained. It doesn’t depend on any external device to work. You can
    use it in any context—all you have to do is provide a valid argument.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是自包含的。它不依赖于任何外部设备来工作。你可以在任何上下文中使用它——你只需要提供一个有效的参数。
- en: It’s deterministic, which means it will always return the same value for the
    same argument. With referentially transparent code, you won’t be surprised. It
    might return a wrong result, but at least, for the same argument, this result
    will never change.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是确定的，这意味着对于相同的参数，它将始终返回相同的值。在引用透明代码中，你不会感到惊讶。它可能会返回错误的结果，但至少，对于相同的参数，这个结果永远不会改变。
- en: It will never throw any kind of `Exception`. It might throw errors, such as
    OOME (out-of-memory error) or SOE (stack-overflow error), but these errors mean
    that the code has a bug, which is not a situation you, as a programmer, or the
    users of your API, are supposed to handle (besides crashing the application and
    eventually fixing the bug).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它永远不会抛出任何类型的`Exception`。它可能会抛出错误，例如OOME（内存不足错误）或SOE（栈溢出错误），但这些错误意味着代码中存在错误，这不是你作为程序员或你的API用户应该处理的情况（除了崩溃应用程序并最终修复错误）。
- en: It won’t create conditions causing other code to unexpectedly fail. For example,
    it won’t mutate arguments or some other external data, causing the caller to find
    itself with stale data or concurrent access exceptions.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会创建导致其他代码意外失败的条件。例如，它不会修改参数或某些其他外部数据，导致调用者发现自己拥有过时的数据或并发访问异常。
- en: It won’t hang because some external device (whether database, file system, or
    network) is unavailable, too slow, or simply broken.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会挂起，因为某些外部设备（无论是数据库、文件系统还是网络）不可用、太慢或简单地损坏。
- en: '[Figure 1.2](#ch01fig02) illustrates the difference between a referentially
    transparent program and one that’s not referentially transparent.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.2](#ch01fig02) 展示了引用透明程序和非引用透明程序之间的区别。'
- en: Figure 1.2\. Comparing a program that’s referentially transparent to one that’s
    not
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2. 比较引用透明程序和非引用透明程序
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig02_alt.jpg)'
- en: 1.4\. The benefits of functional programming
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 函数式编程的好处
- en: 'From what I’ve just said, you can likely guess the many benefits of functional
    programming:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从我刚才说的，你可能会猜到函数式编程的许多好处：
- en: Functional programs are easier to reason about because they’re deterministic.
    One specific input will always give the same output. In many cases, you might
    be able to prove your program correct rather than extensively testing it and still
    being uncertain whether it will break under unexpected conditions.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序更容易推理，因为它们是确定性的。特定的输入总是会给出相同的输出。在许多情况下，你可能会证明你的程序是正确的，而不是广泛测试它，并且仍然不确定它是否会在意外条件下崩溃。
- en: Functional programs are easier to test. Because there are no side effects, you
    don’t need mocks, which are generally required to isolate the programs under test
    from the outside.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序更容易测试。因为没有副作用，你不需要模拟，这通常是隔离测试程序所必需的。
- en: Functional programs are more modular because they’re built from functions that
    have only input and output; there are no side effects to handle, no exceptions
    to catch, no context mutation to deal with, no shared mutable state, and no concurrent
    modifications.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序更模块化，因为它们是由只有输入和输出的函数构建的；没有副作用需要处理，没有异常需要捕获，没有上下文突变需要处理，没有共享可变状态，也没有并发修改。
- en: Functional programming makes composition and recombination much easier. To write
    a functional program, you have to start by writing the various base functions
    you need and then combine these base functions into higher-level ones, repeating
    the process until you have a single function corresponding to the program you
    want to build. As all these functions are referentially transparent, they can
    then be reused to build other programs without any modifications.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程使得组合和重组变得容易得多。要编写一个函数式程序，你必须首先编写所需的各个基础函数，然后将这些基础函数组合成更高级的函数，重复此过程，直到你有一个对应于你想要构建的程序的单个函数。由于所有这些函数都是引用透明的，因此它们可以被重用来构建其他程序，而无需任何修改。
- en: Functional programs are inherently thread-safe because they avoid mutation of
    shared state. Once again, this doesn’t mean that all data has to be immutable.
    Only shared data must be. But functional programmers will soon realize that immutable
    data is always safer, even if the mutation is not visible externally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序天生是线程安全的，因为它们避免了共享状态的突变。再次强调，这并不意味着所有数据都必须是不可变的。只有共享数据必须如此。但函数式程序员很快就会意识到，不可变数据总是更安全，即使突变在外部不可见。
- en: 1.5\. Using the substitution model to reason about programs
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. 使用替换模型推理程序
- en: Remember that a function doesn’t *do* anything. It only has a value, which is
    only dependent on its argument. As a consequence, it’s always possible to replace
    a function call, or any referentially transparent expression, with its value,
    as shown in [figure 1.3](#ch01fig03).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个函数并不*做*任何事情。它只有一个值，这个值只依赖于它的参数。因此，总是可以替换函数调用或任何引用透明表达式，用它的值来替换，如图 1.3 所示。
- en: Figure 1.3\. Replacing referentially transparent expressions with their values
    doesn’t change the overall meaning.
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.3. 用它们的值替换引用透明表达式不会改变整体意义。
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig03_alt.jpg)'
- en: 'When applied to functions, the substitution model allows you to replace any
    function call with its return value. Consider the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于函数时，替换模型允许你用任何函数的返回值替换任何函数调用。考虑以下代码：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replacing `mult(2, 3)` and `mult(4, 5)` with their respective return values
    doesn’t change the signification of the program:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `mult(2, 3)` 和 `mult(4, 5)` 的相应返回值替换它们不会改变程序的意义：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In contrast, replacing the call to the `add` function with its return value
    changes the signification of the program, because the `log` method will no longer
    be called, and no logging will happen. This might be important or not; in any
    case, it changes the result of the program.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，用其返回值替换对`add`函数的调用会改变程序的意义，因为`log`方法将不再被调用，并且不会发生日志记录。这可能是重要的，也可能不重要；无论如何，它改变了程序的结果。
- en: 1.6\. Applying functional principles to a simple example
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 将函数式原则应用于简单示例
- en: As an example of converting an imperative program into a functional one, we’ll
    consider a very simple program representing the purchase of a donut with a credit
    card.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为将命令式程序转换为函数式程序的一个例子，我们将考虑一个非常简单的程序，该程序代表使用信用卡购买甜甜圈。
- en: Listing 1.1\. A Java program with side effects
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.1\. 带有副作用的Java程序
- en: '![](Images/009fig01_alt.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Images/009fig01_alt.jpg]'
- en: In this code, the charging of the credit card is a side effect ![](Images/num-01.jpg).
    Charging a credit card probably consists of calling the bank, verifying that the
    credit card is valid and authorized, and registering the transaction. The function
    returns the donut ![](Images/num-02.jpg).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，对信用卡的扣费是一个副作用 ![Images/num-01.jpg]。扣费信用卡可能包括调用银行，验证信用卡是否有效和已授权，并注册交易。函数返回甜甜圈
    ![Images/num-02.jpg]。
- en: The problem with this kind of code is that it’s difficult to test. Running the
    program for testing would involve contacting the bank and registering the transaction
    using some sort of mock account. Or you’d need to create a mock credit card to
    register the effect of calling the `charge` method and to verify the state of
    the mock after the test.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码的问题在于它很难测试。进行程序测试将涉及联系银行并使用某种模拟账户注册交易。或者你需要创建一个模拟信用卡来注册调用`charge`方法的效果，并在测试后验证模拟的状态。
- en: If you want to be able to test your program without contacting the bank or using
    a mock, you should remove the side effect. Because you still want to charge the
    credit card, the only solution is to add a representation of this operation to
    the return value. Your `buyDonut` method will have to return both the donut and
    this representation of the payment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要能够在不联系银行或使用模拟的情况下测试你的程序，你应该移除副作用。因为你还想对信用卡进行扣费，唯一的解决方案是向返回值中添加这个操作的表示。你的`buyDonut`方法将必须返回甜甜圈以及这个支付表示。
- en: To represent the payment, you can use a `Payment` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示支付，你可以使用一个`Payment`类。
- en: Listing 1.2\. The `Payment` class
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.2\. `Payment`类
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This class contains the necessary data to represent the payment, which consists
    of a credit card and the amount to charge. Because the `buyDonut` method must
    return both a `Donut` and a `Payment`, you could create a specific class for this,
    such as `Purchase`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含了表示支付所需的所有数据，支付由信用卡和要扣费的金额组成。因为`buyDonut`方法必须返回一个`Donut`和一个`Payment`，你可以创建一个特定的类来处理这种情况，例如`Purchase`：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ll often need such a class to hold two (or more) values, because functional
    programming replaces side effects with returning a representation of these effects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会需要这样的类来持有两个（或更多）值，因为函数式编程用返回这些效果的表示来替换副作用。
- en: Rather than creating a specific `Purchase` class, you’ll use a generic one that
    you’ll call `Tuple`. This class will be parameterized by the two types it will
    contain (`Donut` and `Payment`). The following listing shows its implementation,
    as well as the way it’s used in the `DonutShop` class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会创建一个特定的`Purchase`类，而是使用一个通用的类，你可以称之为`Tuple`。这个类将由它将包含的两个类型（`Donut`和`Payment`）进行参数化。以下列表显示了它的实现，以及它在`DonutShop`类中的使用方式。
- en: Listing 1.3\. The `Tuple` class
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.3\. `Tuple`类
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that you’re no longer concerned (at this stage) with how the credit card
    will actually be charged. This adds some freedom to the way you build your application.
    You could still process the payment immediately, or you could store it for later
    processing. You could even combine stored payments for the same card and process
    them in a single operation. This would allow you to save money by minimizing the
    bank fees for the credit card service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你在这个阶段不再关心信用卡实际上是如何被扣费的。这为构建你的应用程序提供了一些自由度。你仍然可以立即处理支付，或者你可以将其存储起来稍后处理。你甚至可以将同一张卡的存储支付组合起来，一次性处理。这将允许你通过最小化信用卡服务的银行费用来节省金钱。
- en: The `combine` method in the following listing allows you to combine payments.
    Note that if the credit cards don’t match, an exception is thrown. This doesn’t
    contradict what I said about functional programs not throwing exceptions. Here,
    trying to combine two payments with two different credit cards is considered a
    bug, so it should crash the application. (This isn’t very realistic. You’ll have
    to wait until [chapter 7](kindle_split_014.xhtml#ch07) to learn how to deal with
    such situations without throwing exceptions.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的`combine`方法允许您合并支付。请注意，如果信用卡不匹配，则会抛出异常。这并不与我说过的功能性程序不会抛出异常相矛盾。在这里，尝试使用两张不同的信用卡合并两个支付被认为是错误，因此应该使应用程序崩溃。（这并不太现实。您将不得不等到第[7章](kindle_split_014.xhtml#ch07)来学习如何在不抛出异常的情况下处理这种情况。）
- en: Listing 1.4\. Composing multiple payments into a single one
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.4\. 将多个支付组合成一个
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, the `combine` method wouldn’t be very efficient for buying several
    donuts at once. For this use case, you could simply replace the `buyDonut` method
    with `buy-Donuts(int n, CreditCard creditCard)`, as shown in the following listing.
    This method returns a `Tuple<List<Donut>, Payment>`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`combine`方法对于一次性购买多个甜甜圈可能不太高效。对于这种情况，您可以简单地用`buy-Donuts(int n, CreditCard
    creditCard)`方法替换`buyDonut`方法，如下所示。此方法返回一个`Tuple<List<Donut>, Payment>`。
- en: Listing 1.5\. Buying multiple donuts at once
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.5\. 一次性购买多个甜甜圈
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that this method doesn’t use the standard `java.util.List` class because
    that class doesn’t offer some of the functional methods you’ll need. In [chapter
    3](kindle_split_010.xhtml#ch03), you’ll see how to use the `java.util.List` class
    in a functional way by writing a small functional library. Then, in [chapter 5](kindle_split_012.xhtml#ch05),
    you’ll develop a completely new functional `List`. It’s this list that’s used
    here. This `combine` method is somewhat equivalent to the following, which uses
    the standard Java list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法没有使用标准的`java.util.List`类，因为这个类不提供您需要的某些功能性方法。在第[3章](kindle_split_010.xhtml#ch03)中，您将看到如何通过编写一个小型的功能性库来以功能性方式使用`java.util.List`类。然后，在第[5章](kindle_split_012.xhtml#ch05)中，您将开发一个全新的功能性`List`。这里使用的就是这个列表。这个`combine`方法在某种程度上等同于以下使用标准Java列表的代码：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you’ll soon need additional functional methods, you won’t be using the Java
    list. For the time being, you just need to know that the `static List<A> fill(int
    n, Supplier<A> s)` method creates a list of `n` instances of `A` by using a special
    object, `Supplier<A>`. As its name indicates, a `Supplier<A>` is an object that
    supplies an `A` when its `get()` method is called. Using a `Supplier<A>` instead
    of an `A` allows for *lazy evaluation*, which you’ll learn about in the next chapters.
    For now, you may think of it as a way to manipulate an `A` without effectively
    creating it until it’s needed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您很快就需要额外的功能性方法，您将不会使用Java列表。目前，您只需要知道`static List<A> fill(int n, Supplier<A>
    s)`方法通过使用一个特殊对象`Supplier<A>`来创建`n`个`A`实例的列表。正如其名称所示，`Supplier<A>`是一个当其`get()`方法被调用时提供`A`的对象。使用`Supplier<A>`而不是`A`允许进行*延迟评估*，您将在下一章中学习到这一点。目前，您可以将其视为一种在不实际创建它直到需要时操作`A`的方法。
- en: 'Now, your program can be tested without using a mock. For example, here’s a
    test for the method `buyDonuts`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在不使用模拟的情况下测试您的程序。例如，以下是对`buyDonuts`方法的测试：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another benefit of making your program functional is that it’s more easily composable.
    If the same person made several purchases with your initial program, you’d have
    to contact the bank (and pay the corresponding fee) each time. With the new functional
    version, you can choose to charge the card immediately for each purchase or to
    group all payments made with the same card and charge it only once for the total.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的程序设计为功能性的另一个好处是它更容易组合。如果同一个人使用您的初始程序进行了多次购买，您每次都必须联系银行（并支付相应的费用）。使用新的功能版本，您可以选择为每次购买立即扣款，或者将使用同一张卡进行的所有支付分组，并只对总额进行一次扣款。
- en: 'To group payments, you’ll need to use additional methods from your functional
    `List` class (you don’t need to understand how these methods work for now; you’ll
    study them in detail in [chapters 5](kindle_split_012.xhtml#ch05) and [8](kindle_split_015.xhtml#ch08)):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要分组支付，您需要使用您功能`List`类中的额外方法（目前您不需要理解这些方法是如何工作的；您将在第[5章](kindle_split_012.xhtml#ch05)和第[8章](kindle_split_015.xhtml#ch08)中详细学习它们）：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This instance method of the `List` class takes a function from `A` to `B` and
    returns a map of key and value pairs, with keys being of type `B` and values of
    type `List<A>`. In other words, it groups payments by credit cards:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`类的这个实例方法接受一个从`A`到`B`的函数，并返回一个键值对映射，其中键的类型为`B`，值的类型为`List<A>`。换句话说，它按信用卡对付款进行分组：'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is an instance method of `Map` that returns a list of all the values in
    the map:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Map`的实例方法，它返回映射中所有值的列表：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is an instance method of `List` that takes a function from `A` to `B`
    and applies it to all elements of a list of `A`, giving a list of `B`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`List`的实例方法，它接受一个从`A`到`B`的函数，并将其应用于`A`类型列表的所有元素，从而得到一个`B`类型的列表：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a method of the `List` class that takes as its argument a function from
    `A` to a tuple of values. For example, it might be a function that takes an email
    address and returns the name and the domain as a tuple. The `unzip` method, in
    that case, would return a tuple of a list of names and a list of domains.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`List`类的方法，它接受一个从`A`到值元组的函数作为其参数。例如，它可能是一个接受电子邮件地址并返回名称和域名作为元组的函数。在这种情况下，`unzip`方法将返回一个包含名称列表和域名列表的元组。
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method of `List` uses an operation to reduce the list to a single value.
    This operation is represented by `Function<A, Function<A, A>> f`. This notation
    may look a bit weird, but you’ll learn what it means in [chapter 2](kindle_split_009.xhtml#ch02).
    It could be, for example, an addition. In such a case, it would simply mean a
    function such as `f(a, b) = a + b`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`的这种方法使用一个操作将列表缩减为一个单一值。这个操作由`Function<A, Function<A, A>> f`表示。这种表示法可能看起来有点奇怪，但你将在第2章中了解到它的含义。例如，它可能是一个加法操作。在这种情况下，它仅仅意味着一个函数，如`f(a,
    b) = a + b`。'
- en: Using these methods, you can now create a new method that groups payments by
    credit card.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，你现在可以创建一个新的方法，按信用卡对付款进行分组。
- en: Listing 1.6\. Grouping payments by credit card
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.6. 按信用卡分组付款
- en: '![](Images/ch01ex06-0.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch01ex06-0.jpg)'
- en: '![](Images/ch01ex06-1.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch01ex06-1.jpg)'
- en: 'Note that you could use a method reference in the last line of the `groupByCard`
    method, but I chose the lambda notation because it’s probably (much) easier to
    read. If you prefer method references, you can replace this line with the following
    one:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以在`groupByCard`方法的最后一行使用方法引用，但我选择使用lambda表达式，因为这可能（更）容易阅读。如果你更喜欢方法引用，你可以将这一行替换为以下一行：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In [listing 1.6](#ch01ex06), the portion after `c1 ->` is a function taking
    a single parameter and passing that parameter to `c1.combine()`. And that’s exactly
    what `c1::combine` is—it’s a function taking a single parameter. Method references
    are often easier to read than lambdas, but not always!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表1.6](#ch01ex06)中，`c1 ->`后面的部分是一个接受单个参数并将该参数传递给`c1.combine()`的函数。这正是`c1::combine`所做的事情——它是一个接受单个参数的函数。方法引用通常比lambda表达式更容易阅读，但并不总是如此！
- en: 1.7\. Pushing abstraction to the limit
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7. 将抽象推向极限
- en: As you’ve seen, functional programming consists in writing programs by composing
    pure functions, which means functions without side effects. These functions may
    be represented by methods, or they may be *first-class functions*, such as the
    arguments of methods `groupBy`, `map`, or `reduce`, in the previous example. First-class
    functions are simply functions represented in such a way that, unlike methods,
    they can be manipulated by the program. In most cases, they’re used as arguments
    to other functions, or to methods. You’ll learn in [chapter 2](kindle_split_009.xhtml#ch02)
    how this is done.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，函数式编程在于通过组合纯函数来编写程序，这意味着没有副作用。这些函数可以表示为方法，或者它们可以是*一等函数*，如前例中`groupBy`、`map`或`reduce`方法的参数。一等函数只是以这种方式表示的函数，与方法不同，它们可以被程序操作。在大多数情况下，它们被用作其他函数或方法的参数。你将在第2章中了解到如何做到这一点。
- en: But the most important notion here is abstraction. Look at the `reduce` method.
    It takes as its argument an operation, and uses it to reduce a list to a single
    value. Here, the operation has two operands of the same type. Except for this,
    it could be any operation. Consider a list of integers. You could write a `sum`
    method to compute the sum of the elements; you could write a `product` method
    to compute the product of the elements; or you could write a `min` or a `max`
    method to compute the minimum or the maximum of the list. But you could also use
    the `reduce` method for all these computations. This is abstraction. You abstract
    the part that is common to all operations in the `reduce` method, and you pass
    the variable part (the operation) as an argument.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里最重要的概念是抽象。看看`reduce`方法。它接受一个操作作为参数，并使用它将列表缩减为一个单一值。在这里，操作有两个相同类型的操作数。除了这一点，它可以是任何操作。考虑一个整数列表。你可以编写一个`sum`方法来计算元素的总和；你可以编写一个`product`方法来计算元素乘积；或者你可以编写一个`min`或`max`方法来计算列表的最小值或最大值。但你也可以使用`reduce`方法来完成所有这些计算。这是抽象。你抽象了`reduce`方法中所有操作共有的部分，并将变量部分（操作）作为参数传递。
- en: But you could go further. The `reduce` method is a particular case of a more
    general method that might produce a result of a different type than the elements
    of the list. For example, it could be applied to a list of characters to produce
    a `String`. You’d need to start from a given value (probably an empty string).
    In [chapters 3](kindle_split_010.xhtml#ch03) and [5](kindle_split_012.xhtml#ch05),
    you’ll learn how to develop this method (called `fold`). Also note that the `reduce`
    method won’t work on an empty list. Think of a list of integers—if you want to
    compute the sum, you need to have an element to start with. If the list is empty,
    what should you return? Of course, you know that the result should be 0, but this
    only works for a sum. It doesn’t work for a product.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以更进一步。`reduce`方法是一个更一般方法的特例，它可能产生与列表元素不同类型的结果。例如，它可以应用于字符列表以产生一个`String`。你需要从一个给定的值开始（可能是一个空字符串）。在第[3](kindle_split_010.xhtml#ch03)章和[5](kindle_split_012.xhtml#ch05)章中，你将学习如何开发这种方法（称为`fold`）。还要注意，`reduce`方法在空列表上不会工作。想象一下整数列表——如果你想计算总和，你需要有一个元素来开始。如果列表为空，你应该返回什么？当然，你知道结果应该是0，但这只适用于总和。它不适用于乘积。
- en: Also consider the `groupByCard` method. It looks like a business method that
    can only be used to group payments by credit cards. But it’s not! You could use
    this method to group the elements of any list by any of their properties, so this
    method should be abstracted and put inside the `List` class in such a way that
    it could be reused easily.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑`groupByCard`方法。它看起来像是一个只能用于按信用卡分组付款的业务方法。但并非如此！你可以使用这个方法通过任何属性来对任何列表的元素进行分组，因此这个方法应该被抽象，并放在`List`类中，以便可以轻松重用。
- en: A very important part of functional programming consists in pushing abstraction
    to the limit. In the rest of this book, you’ll learn how to abstract many things
    so you never have to define them again. You will, for example, learn how to abstract
    loops so you won’t have to write loops ever again. And you’ll learn how to abstract
    parallelization in a way that will allow you to switch from serial to parallel
    processing just by selecting a method in the `List` class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个重要部分在于将抽象推向极限。在这本书的其余部分，你将学习如何抽象许多事物，这样你就不必再定义它们。例如，你将学习如何抽象循环，这样你就不必再编写循环。你还将学习如何以允许你通过在`List`类中选择方法来从串行处理切换到并行处理的方式来抽象并行化。
- en: 1.8\. Summary
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.8. 摘要
- en: Functional programming is programming with functions, returning values, and
    having no side effects.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程是以函数、返回值和没有副作用的方式进行编程。
- en: Functional programs are easy to reason about and easy to test.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序易于推理和测试。
- en: Functional programming offers a high level of abstraction and reusability.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程提供了高级的抽象和可重用性。
- en: Functional programs are more robust than their imperative counterparts.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序比它们的命令式对应物更健壮。
- en: Functional programs are safer in multithreading environments because they avoid
    shared mutable state.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序在多线程环境中更安全，因为它们避免了共享可变状态。
