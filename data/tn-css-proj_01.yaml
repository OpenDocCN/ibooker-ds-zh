- en: 1 CSS introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 CSS简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: A brief overview of CSS
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS的简要概述
- en: Basic CSS styling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本CSS样式
- en: How to select HTML elements effectively
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何有效地选择HTML元素
- en: Cascading Style Sheets (CSS) is used to control the appearance of the elements
    of a web page. CSS uses style rules to instruct the browser to select certain
    elements and apply styles and effects to them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 层叠样式表（CSS）用于控制网页元素的显示。CSS使用样式规则来指导浏览器选择某些元素并对它们应用样式和效果。
- en: Chapter 1 is a good place to start if you’re new to CSS or in need of a refresher.
    We’ll start with a brief history of CSS and swiftly move on to getting started
    with CSS, looking at ways to link CSS with HTML.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始学习CSS或需要复习，第一章是一个很好的起点。我们将从CSS的简要历史开始，迅速过渡到如何开始使用CSS，探讨将CSS与HTML链接的方法。
- en: When we have our CSS up and running, we’ll look at the structure of CSS by creating
    a static, single-column article page with basic media components such as headings,
    content, and imagery to see how everything works together.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的CSS运行起来后，我们将通过创建一个静态的单列文章页面，包含基本媒体组件（如标题、内容和图像）来查看CSS的结构，以了解所有元素是如何协同工作的。
- en: 1.1 Overview of CSS
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 CSS概述
- en: Håkon Wium Lie proposed the idea of CSS in 1994, a few years after Tim Berners-Lee
    created HTML in 1990\. CSS was introduced to separate styling from the content
    of the web page through the options of colors, layout, and typography.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Håkon Wium Lie在1994年提出了CSS的概念，这比Tim Berners-Lee在1990年创建HTML晚了几年。CSS通过颜色、布局和字体排印等选项将样式从网页内容中分离出来。
- en: 1.1.1 Separation of Concerns
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 关注点分离
- en: This separation of content and presentation is based on the design principle
    Separation of Concerns (SoC). The idea behind this principle is that a computer
    program or application should be broken into individual, distinct sections segregated
    by purpose. The benefits of keeping good SoC include
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内容和呈现的分离基于设计原则“关注点分离”（SoC）。这一原则背后的理念是，计算机程序或应用应该被分解成单个、独立的、按目的分离的部分。保持良好的SoC的好处包括
- en: Decreased code duplication and, therefore, easier maintainability
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少代码重复，因此更容易维护
- en: Extendibility, because it requires elements to focus on a single purpose
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性，因为它要求元素专注于单一目的
- en: Stability, because code is easier to maintain and test
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定性，因为代码更容易维护和测试
- en: With this principle in mind, HTML serves as the structure and content of a web
    page, CSS is the presentation, and JavaScript (JS) provides additional functionality.
    Together, they form the web pages. Figure 1.1 displays a diagram of this process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一原则，HTML充当网页的结构和内容，CSS是呈现，JavaScript（JS）提供额外的功能。它们共同构成了网页。图1.1显示了这一过程的示意图。
- en: '![](../Images/01-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-01.png)'
- en: Figure 1.1 A breakdown of a web page
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 网页的分解
- en: Since the introduction of smartphones in the mid-2000s, the web has expanded
    to mobile websites (often using m. subdomains, such as m.mywebsite.com), which
    tend to have fewer features than the desktop versions, and to responsive and adaptive
    designs. There are benefits and drawbacks to creating responsive/adaptive or mobile-specific
    websites.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2000年代中期智能手机的引入以来，网络已经扩展到移动网站（通常使用m.子域名，如m.mywebsite.com），这些网站通常比桌面版本功能更少，并且采用了响应式和自适应设计。创建响应式/自适应或针对移动设备的网站有其优点和缺点。
- en: The difference between responsive and adaptive designs
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式设计和自适应设计之间的区别
- en: '*Responsive design* uses a single fluid layout that can change based on factors
    such as screen size, orientation, and device preferences. *Adaptive design* can
    also change based on these factors. But instead of having a single fluid layout,
    we can create multiple fixed layouts, which gives us greater control of each one—at
    the cost of taking more time than a singular responsive layout. In practice, we
    can use both methods in conjunction with one another.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应式设计*使用单一流动布局，可以根据屏幕大小、方向和设备偏好等因素进行变化。*自适应设计*也可以根据这些因素进行变化。但与单一流动布局不同，我们可以创建多个固定布局，这使我们能够对每个布局有更大的控制权——但代价是比单一响应式布局需要更多的时间。在实践中，我们可以将这两种方法结合起来使用。'
- en: 'In general, responsive and adaptive designs are the way the industry is moving,
    especially as CSS expands, giving us more ability to apply CSS based on window
    sizes and media types (such as screen or print). Since the announcement of CSS
    in 1994, there have been three overall releases:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，响应式和自适应设计是行业发展的趋势，尤其是在CSS不断扩展，为我们提供了更多基于窗口大小和媒体类型（如屏幕或打印）应用CSS的能力之后。自从1994年CSS发布以来，共有三个主要版本发布：
- en: 1996—First World Wide Web Consortium (W3C) recommendation of CSS
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1996年—第一个万维网联盟（W3C）的CSS推荐
- en: 1997—First working draft of CSS2
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1997年—CSS2的第一个工作草案
- en: 1999—First three CSS3 drafts (color profiles, multicolumn layouts, and paged
    media; [https://www.w3.org/Style/CSS20](https://www.w3.org/Style/CSS20))
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1999年—第一个三个CSS3草案（颜色配置文件、多列布局和分页媒体；[https://www.w3.org/Style/CSS20](https://www.w3.org/Style/CSS20)）
- en: After 1999, the release strategy was changed to allow for faster, more frequent
    releases of new features. Now CSS is divided into modules, with numbered levels
    starting at 1 and incrementing upward as features and functionality evolve and
    expand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年之后，发布策略改为允许更快、更频繁地发布新功能。现在CSS被划分为模块，以1开始编号，随着功能和功能的演变和扩展，向上递增。
- en: A CSS level-1 module is something that’s brand new to CSS, such as a property
    that hasn’t existed as an official standard before. Modules that have gone through
    a few versions—such as media queries, color, fonts, and cascading and inheritance
    modules—have higher-level numbers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CSS级别1模块是CSS中全新的东西，例如一个以前作为官方标准不存在的属性。经过几个版本讨论的模块，如媒体查询、颜色、字体以及层叠和继承模块，有更高的级别编号。
- en: The benefit of breaking CSS into modules is that each part can move independently,
    without requiring large sweeping changes to the language as a whole. There have
    been some discussions about the need for someone to declare the current stage
    as CSS4, even if only to acknowledge that CSS has changed a lot since 1999\. This
    idea hasn’t gained any traction so far, however.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将CSS划分为模块的好处是每个部分可以独立移动，而不需要整个语言的大规模更改。已经有一些关于是否需要有人宣布当前阶段为CSS4的讨论，即使只是为了承认自1999年以来CSS已经发生了很大变化。然而，这个想法至今还没有得到任何支持。
- en: 1.1.2 What is CSS?
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 什么是CSS？
- en: 'CSS is a declarative programming language: the code tells the browser what
    needs to be done rather than how to do it. Our code says we want a certain heading
    to be red, for example, and the browser determines how it’s going to apply the
    style. This is useful because if we want to increase the line height of a paragraph
    to improve the reading experience, it’s up to the browser to determine the layout,
    sizing, and formatting of that new line height, which reduces effort for the developer.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CSS是一种声明性编程语言：代码告诉浏览器需要做什么，而不是如何做。例如，我们的代码表示我们想要某个标题是红色，浏览器将决定如何应用这种样式。这很有用，因为如果我们想增加段落的行高以改善阅读体验，那么布局、尺寸和格式化新行高的决定权在浏览器手中，这减少了开发者的工作量。
- en: Domain-specific language
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: CSS is a *domain-specific language* (DSL)—a specialized language created to
    solve a specific problem. DSLs are generally less complex than general-purpose
    languages (GPLs) such as Java and C#. CSS’s specific purpose is to style web content.
    Languages such as SQL, HTML, and XPath are also DSLs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CSS是一种*领域特定语言*（DSL）——一种为解决特定问题而创建的专用语言。DSL通常比通用语言（如Java和C#）简单。CSS的特定目的是样式化网页内容。SQL、HTML和XPath等语言也是DSL。
- en: CSS has come a long way since 1994\. Now we have ways to animate and transition
    elements, create motion paths to animate Scalable Vector Graphics (SVG) images,
    and conditionally apply styles based on viewport size. This type of functionality
    used to be possible only through JavaScript or Adobe Flash (now retired). We can
    look at CSS Zen Garden ([www.csszengarden.com](http://www.csszengarden.com/))
    for a glimpse of the possibilities; by looking at the first versus last designs,
    we can observe CSS’s progression over time ([https://www.w3.org/Style/CSS20](https://www.w3.org/Style/CSS20)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1994年以来，CSS已经走了很长的路。现在我们有方法来动画和过渡元素，创建运动路径来动画可缩放矢量图形（SVG）图像，并根据视口大小条件应用样式。这类功能以前只能通过JavaScript或Adobe
    Flash（现已退役）来实现。我们可以通过查看CSS Zen Garden（[www.csszengarden.com](http://www.csszengarden.com/））来一窥可能性；通过比较第一个和最后一个设计，我们可以观察到CSS随时间的发展([https://www.w3.org/Style/CSS20](https://www.w3.org/Style/CSS20))。
- en: In the past, design choices such as the use of transparency, rounded corners,
    masking, and blending were possible but required unconventional CSS techniques
    and hacks. As CSS evolved, properties were added to replace these hacks with standard,
    documented features.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，使用透明度、圆角、遮罩和混合等设计选择是可能的，但需要非传统的CSS技术和技巧。随着CSS的发展，添加了属性来用标准、文档化的功能替换这些技巧。
- en: CSS preprocessors
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CSS预处理器
- en: The evolution of CSS also led to the creation of CSS preprocessors and the introduction
    of Syntactically Awesome Style Sheets (Sass), released in 2006\. They were created
    to facilitate writing code that’s easier to read and maintain, as well as to provide
    added functionality that’s not available in CSS alone. We’ll use a preprocessor
    to style a page in chapter 12.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的演变也导致了CSS预处理器和Syntactically Awesome Style Sheets (Sass)的引入，Sass于2006年发布。它们被创建出来是为了简化代码的编写，使其更易于阅读和维护，同时也提供了CSS本身不具备的附加功能。在第12章中，我们将使用预处理器来样式化一个页面。
- en: It could be said that CSS is in a golden age. With the continual development
    of the language, opportunities for new and creative experiences are virtually
    endless.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，CSS正处于一个黄金时代。随着语言的持续发展，新的和创造性的体验机会几乎是无限的。
- en: 1.2 Getting started with CSS by creating an article layout
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 通过创建文章布局开始学习CSS
- en: 'In our first project, we’ll explore a common use case on the web: creating
    a single-column article. This chapter focuses on how to link CSS to HTML and explores
    the selectors we can use to style our HTML.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个项目中，我们将探索网络上的一个常见用例：创建单列文章。本章重点介绍如何将CSS链接到HTML，并探讨我们可以使用的选择器来样式化我们的HTML。
- en: The first thing we need to understand is how to tie our CSS to our HTML and
    how to select an element. Then we can worry about what properties and values we
    want to apply. Let’s start by going over some basics.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要理解的是如何将我们的CSS与HTML关联起来，以及如何选择一个元素。然后我们再考虑我们想要应用哪些属性和值。让我们先从一些基础知识开始。
- en: If you’re new to coding, you can often find free tools to use for these projects.
    You have the option of coding online, or you can do the work on your computer,
    using a code editor such as Sublime Text ([https://www.sublimetext.com](https://www.sublimetext.com)),
    Brackets ([https:// brackets.io](https://brackets.io)), or Visual Studio Code
    ([https://code.visualstudio.com](https://code.visualstudio.com)). Alternatively,
    you can use a basic text editor such as TextEdit for Mac ([http://mng.bz/rd9x](http://mng.bz/rd9x)),
    Windows Notepad ([http://mng.bz/VpAN](http://mng.bz/VpAN)), or gedit for Linux
    ([https://wiki.gnome.org/Apps/Gedit](https://wiki.gnome.org/Apps/Gedit)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始学习编程，你通常可以找到免费工具来使用这些项目。你有在线编码的选项，或者你可以在电脑上使用代码编辑器，如Sublime Text ([https://www.sublimetext.com](https://www.sublimetext.com))、Brackets
    ([https:// brackets.io](https://brackets.io)) 或 Visual Studio Code ([https://code.visualstudio.com](https://code.visualstudio.com))
    进行工作。或者，你也可以使用Mac的TextEdit ([http://mng.bz/rd9x](http://mng.bz/rd9x))、Windows的记事本
    ([http://mng.bz/VpAN](http://mng.bz/VpAN)) 或Linux的gedit ([https://wiki.gnome.org/Apps/Gedit](https://wiki.gnome.org/Apps/Gedit))
    作为基本文本编辑器。
- en: The downside to using a basic text editor instead of a code editor or integrated
    development environment (IDE) is that it lacks syntax highlighting. This highlighting
    displays text in different colors and fonts according to its purpose in the code,
    which helps readability.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用代码编辑器或集成开发环境（IDE）相比，使用基本文本编辑器的缺点是它缺乏语法高亮。这种高亮会根据文本在代码中的作用以不同的颜色和字体显示文本，这有助于提高可读性。
- en: You can also use a free online development editor such as CodePen ([https://codepen.io](https://codepen.io)).
    Online development editors are great ways to test ideas; they provide quick, easy
    access for frontend projects. CodePen provides a paid pro option that allows you
    to host assets such as images, which you’ll need in later chapters. Another option
    is to link to the GitHub location where the images are stored, as all assets that
    are uploaded to GitHub are stored in the `raw.githubusercontent.com` domain.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用免费的在线开发编辑器，如CodePen ([https://codepen.io](https://codepen.io))。在线开发编辑器是测试想法的好方法；它们为前端项目提供了快速、便捷的访问。CodePen提供了一个付费的Pro选项，允许你托管图像等资产，这些资产你将在后面的章节中需要。另一个选项是链接到存储图像的GitHub位置，因为所有上传到GitHub的资产都存储在`raw.githubusercontent.com`域名下。
- en: When you have a code editor installed on your computer or have chosen an online
    editor and created an account, you’ll need to get the starter code for the chapter.
    We created a code repository in GitHub ([https://github.com/michaelgearon/Tiny-CSS-Projects](https://github.com/michaelgearon/Tiny-CSS-Projects))
    containing all the code you’ll need to follow along with each chapter. Figure
    1.2 shows a screenshot of the repository.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在电脑上安装了代码编辑器或者选择了在线编辑器并创建了账户后，你需要获取本章的起始代码。我们在GitHub ([https://github.com/michaelgearon/Tiny-CSS-Projects](https://github.com/michaelgearon/Tiny-CSS-Projects))
    上创建了一个代码仓库，其中包含了你需要跟随每个章节的所有代码。图1.2显示了该仓库的截图。
- en: '![](../Images/01-02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-02.png)'
- en: Figure 1.2 Tiny-CSS-Projects repository in GitHub
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 GitHub上的Tiny-CSS-Projects仓库
- en: 'The code is organized in folders by chapter. Inside each chapter folder are
    two versions of the code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码按章节组织在文件夹中。每个章节文件夹中都有两个版本的代码：
- en: '`before`—Contains the starter code for the project. You’ll want this version
    if you’re coding along with the chapter.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before`—包含项目的初始代码。如果你要和本章一起编码，你需要这个版本。'
- en: '`after`—Contains the completed project as it is at the end of the chapter with
    the presented CSS applied.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after`—包含章节末尾完成的项目的最终状态，并应用了展示的CSS。'
- en: Download (or, if you’re familiar with Git, clone) the project, using the Code
    drop-down menu at the top of the screen. If you’re coding along with the chapter,
    grab the files from the `before` folder for chapter 1 and copy them to your project
    folder or pen. You should see an HTML file with some starter code and an empty
    CSS file. If you open the HTML file in a web browser or copy the contents of the
    `<body>` tag into CodePen, you’ll see that the content is unstyled except for
    the defaults provided by your browser (figure 1.3). Now you’re ready to start
    styling the content with CSS, as shown in listing 1.1.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用屏幕顶部的代码下拉菜单下载（或者如果你熟悉Git，克隆）项目。如果你要和本章一起编码，从第1章的`before`文件夹中获取文件，并将它们复制到你的项目文件夹或笔中。你应该会看到一个包含一些初始代码和一个空CSS文件的HTML文件。如果你在浏览器中打开HTML文件或将`<body>`标签的内容复制到CodePen中，你会看到内容没有样式，除了浏览器提供的默认样式（图1.3）。现在你就可以开始用CSS样式化内容了，如列表1.1所示。
- en: '![](../Images/01-03.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-03.png)'
- en: Figure 1.3 Starter HTML for our article
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 我们文章的初始HTML
- en: NOTE CodePen handles the information in the `<head>` tag for you automatically.
    Therefore, if you’re following along in CodePen or a similar online editor, you
    need to copy only the code within the `<body>` tag.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：CodePen会自动处理`<head>`标签中的信息。因此，如果你在CodePen或类似的在线编辑器中跟随，你只需要复制`<body>`标签内的代码。
- en: Listing 1.1 Starting HTML
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 开始的HTML
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 1.3 Adding CSS to our HTML
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 向我们的HTML添加CSS
- en: 'When we’re styling with CSS, we have three ways to apply CSS to our HTML:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用CSS进行样式设计时，我们有三种方法将CSS应用到我们的HTML中：
- en: Inline
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联
- en: Embedded
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内嵌
- en: External
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部
- en: 1.3.1 Inline CSS
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 内联CSS
- en: We can inline the CSS by adding a `style` attribute to an element. This method
    has us add the CSS to the element directly in the HTML.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过给一个元素添加一个`style`属性来内联CSS。这种方法让我们直接在HTML中向元素添加CSS。
- en: Attributes are always specified in the opening tag and typically consist of
    the name of the attribute—in this case, `style`. The attribute is sometimes followed
    by an equal sign (`=`) and its value in quotes. All the CSS goes inside the opening
    and closing quotation marks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 属性总是在开标签中指定，通常由属性的名称组成——在这个例子中是`style`。属性有时后面跟着一个等号（`=`）和用引号括起来的值。所有的CSS都放在开引号和闭引号之间。
- en: 'As an example, let’s set the color of our `heading` to `crimson`: `<h1` `style="color:`
    `crimson">` `Title` `of` `our` `article` `(heading` `1)</h1>`. If we save our
    HTML and view it in a browser, we’ll see that it’s crimson. If we’re using a code
    editor rather than a web client (CodePen), we need to refresh the browser page
    to view our changes. Figure 1.4 shows the output. Notice that the only element
    affected is the `<h1>` to which we applied the style.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，让我们将我们的`heading`的颜色设置为`crimson`：`<h1 style="color: crimson">文章的标题（heading
    1）</h1>`。如果我们保存我们的HTML并在浏览器中查看，我们会看到它是crimson色。如果我们使用的是代码编辑器而不是网络客户端（CodePen），我们需要刷新浏览器页面来查看我们的更改。图1.4显示了输出。注意，唯一受影响的元素是我们应用了样式的`<h1>`。'
- en: '![](../Images/01-04.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-04.png)'
- en: Figure 1.4 Crimson header
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 紫红色标题
- en: 'One downside of inline CSS is that it takes the highest specificity in CSS,
    which we’ll look at in more detail soon. Another major downside to inline CSS
    is that it can become unmanageable quickly. Suppose that we have 20 paragraphs
    within an HTML document. We would need to apply the same style attributes with
    the same CSS properties 20 times to make sure that all our paragraphs look the
    same. This case involves two problems:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 内联CSS的一个缺点是它在CSS中具有最高的特定性，我们将在稍后更详细地探讨这一点。内联CSS的另一个主要缺点是它很快就会变得难以管理。假设我们在一个HTML文档中有20个段落。我们需要应用相同的样式属性和相同的CSS属性20次，以确保所有段落看起来都一样。这种情况涉及两个问题：
- en: Our concerns are no longer separated. Our HTML, which is responsible for the
    content, and our CSS, which is responsible for styling, are now in the same place
    and tightly coupled.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的关注点不再分离。负责内容的HTML和负责样式的CSS现在在同一个地方，并且紧密耦合。
- en: We’re repeating the code in many places, which makes it extremely difficult
    to maintain and keep our styles consistent.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在许多地方重复代码，这使得维护和保持样式一致性变得极其困难。
- en: The benefit of inline CSS is page-load performance. The browser loads the HTML
    file first and then loads any other files it needs to render the page. When the
    CSS is already in the HTML file, the browser doesn’t need to wait for it to load
    from a separate location. Let’s undo the style we added to the `<h1>` and look
    at a different technique that has the same benefits as inline but fewer drawbacks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内联CSS的优点是页面加载性能。浏览器首先加载HTML文件，然后加载它渲染页面所需的任何其他文件。当CSS已经在HTML文件中时，浏览器不需要等待从单独的位置加载它。让我们撤销对`<h1>`添加的样式，并看看一种具有与内联相同优点但缺点更少的不同的技术。
- en: 1.3.2 Embedded CSS
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 嵌入式CSS
- en: To resolve the problem of repeating code, we can add our CSS within an embedded
    (sometimes referred to as internal) `<style>` element. The `<style>` element must
    be placed between the opening and closing `<head>` tags. To color all our heading
    elements crimson, we can use the snippet of code in the following listing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决重复代码的问题，我们可以在嵌入式（有时称为内部）`<style>`元素中添加我们的CSS。`<style>`元素必须放置在开`<head>`标签和闭`<head>`标签之间。要使所有标题元素变为深红色，我们可以使用以下列表中的代码片段。
- en: Listing 1.2 Embedded CSS
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.2 嵌入式CSS
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The benefit of this approach is that now we’re grouping all our CSS together,
    and the CSS will be applied to the whole HTML document. In our example, all headings
    (`<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`, and `<h6>`) within that web page will
    be crimson, as we can observe in figure 1.5.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是现在我们将所有CSS组合在一起，CSS将应用于整个HTML文档。在我们的例子中，该网页内的所有标题（`<h1>`、`<h2>`、`<h3>`、`<h4>`、`<h5>`和`<h6>`）都将变为深红色，正如我们可以在图1.5中观察到的。
- en: '![](../Images/01-05.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-05.png)'
- en: Figure 1.5 Styles applied to all headings
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 应用到所有标题的样式
- en: We also see a difference in how the embedded CSS is written compared with inline
    CSS. When we’re writing embedded CSS, we create what are known as *rulesets*,
    which are composed of the parts shown in figure 1.6.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到嵌入式CSS与内联CSS在书写方式上的差异。当我们编写嵌入式CSS时，我们创建所谓的*规则集*，它由图1.6中显示的部分组成。
- en: '![](../Images/01-06.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-06.png)'
- en: Figure 1.6 An example of a CSS rule
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 CSS规则的示例
- en: The part of the rule that defines which elements to apply the styles to is called
    the *selector*. The rule in figure 1.6 will be applied to all `<h1>` elements;
    its selector is `h1`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 规则中定义应用于哪些元素的部分被称为*选择器*。图1.6中的规则将应用于所有`<h1>`元素；其选择器为`h1`。
- en: To apply multiple selectors, we write them as a comma-delimited list before
    the opening curly brace. To select all `<h1>` and `<h2>` elements, for example,
    we would write `h1,h2` `{` `...` `}.`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用多个选择器，我们将它们作为逗号分隔的列表写在开括号之前。例如，要选择所有`<h1>`和`<h2>`元素，我们会写`h1,h2` `{` `...`
    `}`。
- en: The declaration is made up of the property—in this case, `color—`followed by
    a colon and then the property value (`red`). The declaration defines how the element
    selected will be styled. Both properties and values must be written in American
    English. Spelling variations such as *colour* and *capitalise* aren’t supported
    and won’t be recognized by the browser. When a browser comes across invalid CSS,
    it ignores it. If a rule has an invalid declaration inside it, valid declarations
    will still be applied; only those that are invalid will be ignored.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 声明由属性组成——在本例中为`color`，后跟一个冒号，然后是属性值（`red`）。声明定义了所选元素将被如何样式化。属性和值都必须用美式英语书写。如*colour*和*capitalise*之类的拼写变体不受支持，并且浏览器不会识别。当浏览器遇到无效的CSS时，它会忽略它。如果一个规则中有无效的声明，则有效的声明仍然会被应用；只有无效的声明会被忽略。
- en: Embedded CSS works well for one-off web pages in which the styles are specific
    to that page. It groups CSS nicely, allowing us to write rules that are applied
    across elements, preventing us from having to copy and paste the same styles in
    multiple places. It also has the same performance benefits as inline styles, in
    that the browser has immediate access to the CSS; it doesn’t have to wait for
    the CSS to be fetched from a different location.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式CSS适用于一次性的网页，其中样式特定于该页面。它很好地组织了CSS，允许我们编写应用于元素的规则，从而避免在多个地方复制和粘贴相同的样式。它还具有与内联样式相同的性能优势，即浏览器可以立即访问CSS；它不需要等待从不同位置获取CSS。
- en: The downside of having our CSS within our HTML document is that the CSS will
    work for only that document. So if our website has multiple pages, which is often
    the case, we’d need to copy that CSS into each HTML document. Unless these styles
    are being generated by a template of backend language (such as PHP), this task
    will become unmaintainable quickly, especially for large applications such as
    blogs and e-commerce websites. Next, let’s undo the changes to our project one
    last time and look at a third technique.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CSS 放在 HTML 文档中的缺点是，CSS 只适用于该文档。所以如果我们的网站有多个页面，这通常是情况，我们就需要将 CSS 复制到每个 HTML
    文档中。除非这些样式是由模板或后端语言（如 PHP）生成的，否则这项任务将很快变得难以维护，尤其是对于大型应用程序，如博客和电子商务网站。接下来，让我们最后一次撤销项目中的更改，并查看第三种技术。
- en: 1.3.3 External CSS
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 外部 CSS
- en: 'Like embedded CSS, the external CSS approach keeps our styles grouped together,
    but it places the CSS in a separate `.css` file. By separating our HTML and CSS,
    we can effectively separate our concerns: content and style.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与内联 CSS 类似，外部 CSS 方法将我们的样式分组在一起，但它将 CSS 放在单独的 `.css` 文件中。通过将我们的 HTML 和 CSS 分离，我们可以有效地分离我们的关注点：内容和样式。
- en: 'We link the stylesheet to the HTML by using the `<link>` HTML tag. The link
    element needs two attributes for stylesheets: the `rel` attribute, which describes
    the relationship between the HTML document and the thing being linked to, and
    the `href` attribute, which stands for *hypertext reference* and indicates where
    to find the document that we want to include. The following listing shows how
    we link our stylesheet to our HTML for our project.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `<link>` HTML 标签将样式表链接到 HTML。链接元素需要两个属性来指定样式表：`rel` 属性，它描述了 HTML 文档与被链接对象之间的关系，以及
    `href` 属性，它代表 *超文本引用* 并指示要包含的文档的位置。以下列表显示了我们将样式表链接到我们的 HTML 的方法。
- en: Listing 1.3 Applying external CSS to HTML
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.3 将外部 CSS 应用到 HTML
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of the time, this approach is the one we see across the web, so it’s the
    approach we’ll use throughout this book. The benefit of external stylesheets is
    that our CSS is in one single document that can be modified once to apply the
    changes across all of our HTML pages. The downside to this approach is that it
    takes an extra request from the browser to retrieve that document, losing the
    performance benefit provided by putting the CSS directly inside the HTML.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这种方法是我们在互联网上看到的方法，因此我们将在这本书中一直使用这种方法。外部样式表的好处是我们的 CSS 在一个单独的文档中，可以一次性修改以应用到所有
    HTML 页面上。这种方法的缺点是它需要浏览器额外的请求来检索该文档，从而失去了将 CSS 直接放在 HTML 中的性能优势。
- en: 1.4 The cascade of CSS
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 CSS 的层叠
- en: One fundamental feature of CSS that we need to understand is the cascade. When
    CSS was created, it was developed around the concept of *cascading,* which allows
    styles to overwrite or inherit from one another. This concept paved the way for
    multiple stylesheets that compete over the presentation of the web page.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 的一个基本特性是我们需要理解的是层叠。当 CSS 被创建时，它是围绕 *层叠* 的概念开发的，这允许样式相互覆盖或继承。这个概念为多个样式表竞争网页的展示铺平了道路。
- en: For this reason, while inspecting an element with the browser’s developer tools,
    we sometimes see multiple CSS values fighting to be the one rendered by the browser.
    The browser decides which CSS property values to apply to an element through specificity.
    Specificity allows the browser (or the user agent) to determine which declarations
    are relevant to the HTML and apply the styling to that element.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们使用浏览器的开发者工具检查一个元素时，我们有时会看到多个 CSS 值在争夺浏览器渲染的机会。浏览器通过特定性来决定将哪些 CSS 属性值应用到元素上。特定性允许浏览器（或用户代理）确定哪些声明与
    HTML 相关，并将样式应用到该元素。
- en: 'One aspect in which specificity is calculated is the order in which stylesheets
    are applied. When multiple stylesheets are applied, the styles in a later stylesheet
    will override styles provided by the preceding stylesheet. In other words, assuming
    that the same selector is used, the last one declared wins. CSS has three different
    stylesheet origins:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 特定性计算的一个方面是样式表的应用顺序。当应用多个样式表时，后续样式表中的样式将覆盖先前样式表提供的样式。换句话说，假设使用了相同的选择器，最后声明的样式将获胜。CSS
    有三种不同的样式表来源：
- en: User-agent stylesheets
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户代理样式表
- en: Author stylesheets
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者样式表
- en: User stylesheets
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户样式表
- en: 1.4.1 User-agent stylesheets
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 用户代理样式表
- en: The first origin is the browser’s default styles. When we opened the project,
    before we added any styles to it, our elements didn’t all look the same. Our headers
    are bigger and bolder than our text, for example. This formatting is defined by
    *user-agent* (UA) *stylesheets*. These stylesheets have the lowest priority of
    the three types, and we find that different browsers present HTML properties slightly
    differently.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个来源是浏览器的默认样式。当我们打开项目，在我们添加任何样式之前，我们的元素并不都看起来一样。例如，我们的标题比我们的文本更大、更粗。这种格式化是由**用户代理**（UA）样式表定义的。这些样式表在三种类型中具有最低的优先级，我们发现不同的浏览器对
    HTML 属性的呈现略有不同。
- en: Most of the time, UA stylesheets set the font size, border styles, and some
    basic layout for form elements such as the text input and progress bar, which
    can be useful if the user stylesheet can’t be found or a file-loading error occurs.
    The UA stylesheet provides some fallback styling, which makes the page more readable
    and maintains visual differentiation between element types.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，用户代理（UA）样式表设置字体大小、边框样式以及一些基本布局，例如文本输入和进度条，这在用户样式表找不到或发生文件加载错误时可能很有用。UA
    样式表提供了一些回退样式，这使得页面更易于阅读，并保持了不同元素类型之间的视觉差异。
- en: 1.4.2 Author stylesheets
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 作者样式表
- en: The stylesheets that we developers write are known as *author stylesheets*,
    which typically have the second-highest priority in terms of the styles that the
    browser displays. When we create a web page, the CSS we write (embedded, external,
    or inline) and apply to our web pages consists of author stylesheets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发者编写的样式表被称为**作者样式表**，在浏览器显示的样式优先级中通常具有第二高的优先级。当我们创建网页时，我们编写的 CSS（内嵌、外部或内联）并将其应用于我们的网页的样式表就是作者样式表。
- en: 1.4.3 User stylesheets
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 用户样式表
- en: A user who is accessing our web page can use their own stylesheet to override
    both author and UA styles. This option can improve their experience, especially
    for disabled users.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我们网页的用户可以使用他们自己的样式表来覆盖作者和 UA 样式。这个选项可以改善他们的体验，特别是对于残障用户。
- en: Users may use their own stylesheets for a variety of reasons, such as to set
    a minimum font size, choose a custom font, improve contrast, or increase the spacing
    between elements. Any user can apply a user stylesheet to a web page. How these
    stylesheets are applied to the web page depends on the browser, usually through
    browser settings or a plugin.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能出于各种原因使用自己的样式表，例如设置最小字体大小、选择自定义字体、提高对比度或增加元素之间的间距。任何用户都可以将用户样式表应用于网页。这些样式表如何应用于网页取决于浏览器，通常是通过浏览器设置或插件。
- en: The user stylesheet is applied only for the user who added it, and only in the
    browser in which they applied it. Whether the change is carried over from one
    device to another depends on the browser itself and its ability to sync user settings
    and installed plugins across multiple devices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户样式表仅适用于添加它的用户，并且仅在应用它的浏览器中生效。这种更改是否可以从一个设备传输到另一个设备，取决于浏览器本身及其在多个设备之间同步用户设置和已安装插件的能力。
- en: 1.4.4 CSS reset
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 CSS 重置
- en: Default styles provided by the browser aren’t consistent. Each browser has its
    own stylesheet. Default styles are different in Google Chrome from the way they
    are in Apple’s Safari, for example. This difference can create some challenges
    if we want our applications to look the same across all browsers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器提供的默认样式并不一致。每个浏览器都有自己的样式表。例如，默认样式在 Google Chrome 中与在 Apple 的 Safari 中不同。如果我们希望我们的应用程序在所有浏览器中看起来都一样，这种差异可能会带来一些挑战。
- en: 'Luckily, two options are available: CSS resets and CSS normalizers (such as
    Normalize.css; [https://github.com/necolas/normalize.css](https://github.com/necolas/normalize.css)).
    Although both can be used to solve cross-browser styling problems, they work in
    radically different ways.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有两种选择可用：CSS 重置和 CSS 规范化器（例如 Normalize.css；[https://github.com/necolas/normalize.css](https://github.com/necolas/normalize.css)）。尽管两者都可以用来解决跨浏览器样式问题，但它们的工作方式截然不同。
- en: By using a CSS reset, we undo the browser’s default styles; we’re telling the
    browser we don’t want any defaults at all. Without any author styles applied,
    all elements, regardless of what they are, look like plain text (figure 1.7).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 CSS 重置，我们撤销了浏览器的默认样式；我们告诉浏览器我们根本不想要任何默认样式。在没有应用任何作者样式的情况下，所有元素，无论它们是什么，看起来都像普通文本（图
    1.7）。
- en: '![](../Images/01-07.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01-07.png)'
- en: Figure 1.7 CSS reset applied
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 CSS 重置应用效果
- en: To apply a CSS reset to our project, first we create a reset stylesheet to add
    to our project. In our project folder, we create a file called `reset.css`. Then
    we copy the reset CSS into the file. Many reset options exist; one commonly used
    option is available at [https://meyerweb.com/eric/tools/css/reset](https://meyerweb.com/eric/tools/css/reset).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要将CSS重置应用于我们的项目，首先我们创建一个重置样式表并将其添加到我们的项目中。在我们的项目文件夹中，我们创建一个名为`reset.css`的文件。然后我们将重置CSS复制到文件中。存在许多重置选项；一个常用的选项可以在[https://meyerweb.com/eric/tools/css/reset](https://meyerweb.com/eric/tools/css/reset)找到。
- en: Finally, we need to link our stylesheet to our HTML. Because order matters,
    we want to make sure to include the reset CSS *before* our author styles in our
    `<head>`. Our HTML, therefore, will look like listing 1.4.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的样式表链接到我们的HTML文件。因为顺序很重要，我们想要确保在我们的`<head>`中包含重置CSS，在作者样式之前。因此，我们的HTML将看起来像列表1.4。
- en: Page-load performance
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载性能
- en: For readability, having the reset and our styles in separate files is a lot
    nicer than having everything in one file. This approach isn’t ideal for page-load
    performance, however.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，将重置和我们的样式放在单独的文件中比将所有内容放在一个文件中要好得多。然而，这种方法对页面加载性能来说并不理想。
- en: 'In a production environment, we’d want to do one of the following things:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我们想要做以下事情之一：
- en: Place the reset CSS at the beginning of the same file we have our own styles
    in so that we load only one stylesheet. We could do this manually or as part of
    a build process.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将重置CSS放置在我们自己的样式所在的同一文件的开始处，这样我们只加载一个样式表。我们可以手动做这件事，或者将其作为构建过程的一部分。
- en: Load the reset code from a content delivery network (CDN) before our own styles.
    By loading it from a CDN, we increase the likelihood that our users will have
    the code already cached on their machines.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们自己的样式之前从内容分发网络（CDN）加载重置代码。通过从CDN加载，我们增加了用户在他们机器上已经缓存了代码的可能性。
- en: Listing 1.4 Adding a CSS reset
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.4 添加CSS重置
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Resets stylesheet
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ① 重置样式表
- en: ② Author stylesheet
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ② 作者样式表
- en: The benefit of the CSS reset is that we have a blank slate to start from. As
    shown in figure 1.7, all our elements look like plain text now. The downside is
    that we need to define basic styles for all elements, including adding bullets
    to lists and differentiating header levels. Furthermore, each version of CSS reset
    will be slightly different, based on the version and the developer who authored
    it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: CSS重置的好处是我们有一个空白画布可以从中开始。如图1.7所示，现在我们的所有元素看起来都像是普通文本。缺点是我们需要为所有元素定义基本样式，包括为列表添加项目符号和区分标题级别。此外，每个CSS重置的版本都会根据版本和编写它的开发者有所不同。
- en: Our other option is using a normalizer. Instead of resetting the styles, a normalizer
    specifically targets elements that have differences across browsers and applies
    rules to standardize them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的另一种选择是使用标准化器。与重置样式不同，标准化器专门针对在不同浏览器中具有差异的元素，并应用规则以标准化它们。
- en: 1.4.5 Normalizer
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.5 标准化器
- en: 'Like a CSS reset, a normalizer styles things slightly differently depending
    on the version and author. One commonly used CSS normalizer is available at [https://necolas.github.io/normalize.css](https://necolas.github.io/normalize.css).
    We can apply it to our project in much the same way that we did the CSS reset
    code: create a file, copy the code into the file, and link it to our HTML. Note
    that the same performance consideration holds true here.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像CSS重置一样，标准化器根据版本和作者的不同，对样式进行轻微的调整。一个常用的CSS标准化器可以在[https://necolas.github.io/normalize.css](https://necolas.github.io/normalize.css)找到。我们可以以与CSS重置代码相同的方式将其应用于我们的项目：创建一个文件，将代码复制到文件中，并将其链接到我们的HTML文件。请注意，同样的性能考虑也适用于这里。
- en: When the normalizer is applied (figure 1.8), our HTML looks the same as it did
    originally, as most of the discrepancies it handles are on elements that aren’t
    being used in this particular project. Depending on the browser we’re using, we
    may notice a difference in the size of the `<h1>`s.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用标准化器（如图1.8所示）时，我们的HTML看起来与最初相同，因为它处理的大多数差异都在这个特定项目中未使用的元素上。根据我们使用的浏览器，我们可能会注意到`<h1>`的大小有所不同。
- en: '![](../Images/01-08.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01-08.png)'
- en: Figure 1.8 A normalizer applied to our project
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 应用到我们项目中的标准化器
- en: The good news is that UA stylesheet differences are far less problematic than
    they were more than 10 years ago. Today, browsers are more consistent in styling,
    so using a CSS reset or a normalizer is more a personal choice than a necessity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，用户代理（UA）样式表差异比10多年前的问题要小得多。今天，浏览器在样式上更加一致，因此使用CSS重置或标准化器更多的是一种个人选择，而不是必需品。
- en: Some differences still exist, however. Whether or not we use a CSS reset or
    a normalizer, we should be testing our code across a variety of devices and browsers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然存在一些差异。无论我们是否使用CSS重置或正常化器，我们都应该在各种设备和浏览器上测试我们的代码。
- en: 1.4.6 The !important annotation
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.6 !important注释
- en: The `!important` annotation is one you may have seen in some stylesheets. Often
    used as a last resort when all else fails, it’s a way to override the specificity
    and declare that a particular value is the most important thing. With great power,
    however, comes great responsibility. The `!important` annotation was originally
    created as an accessibility feature.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`!important`注释你可能在一些样式表中见过。通常在所有其他方法都失败时作为最后的手段使用，它是一种覆盖特定性并声明特定值是最重要的事情的方法。然而，权力越大，责任越大。`!important`注释最初被创建为一个可访问性功能。'
- en: Remember that we talked about users being able to apply their own styles to
    have a better user experience? This annotation was created to help users define
    their own styles without having to worry about specificity. Because it overrides
    any other styles, it ensures that a user’s styles always have the highest importance
    and therefore are the ones applied.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们提到过用户能够应用自己的样式以获得更好的用户体验吗？这个注释是为了帮助用户定义自己的样式，而无需担心特定性。因为它覆盖了任何其他样式，所以它确保了用户的样式总是具有最高的优先级，因此是应用的那一个。
- en: Using `!important` is considered to be bad practice, so we should generally
    avoid using it in our author stylesheets. Also, this annotation breaks the natural
    cascade of the CSS and can make it harder to manage the stylesheet going forward.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`!important`被认为是不良实践，因此我们应该尽量避免在我们的作者样式表中使用它。此外，这个注释打破了CSS的自然级联，可能会使管理样式表变得更加困难。
- en: 1.5 Specificity in CSS
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 CSS中的特定性
- en: When multiple property values are being applied to an element, one will win
    over the others. We determine the winner through a multistep process. We’ll ignore
    `!important` (section 1.4.6) for the time being, as it breaks the normal flow;
    we’ll come back to it later.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个属性值被应用于一个元素时，其中一个将胜过其他。我们通过一个多步骤的过程来确定胜者。我们暂时忽略`!important`（第1.4.6节），因为它打破了正常的流程；我们稍后会回到它。
- en: First, we look at where the value comes from. Anything explicitly defined in
    a rule will override inherited values. In listings 1.5 and 1.6, for example, if
    we set the font color to `red` on the `<body>` element, the elements inside `<body>`
    will have red text.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下值从哪里来。在规则中明确定义的任何内容都将覆盖继承的值。例如，在列表1.5和1.6中，如果我们将`<body>`元素的字体颜色设置为`red`，那么`<body>`内部的所有元素都将显示红色文本。
- en: The font color is inherited by child elements. If we specifically set a different
    color on a paragraph inside the body, the inherited `red` value would be overridden
    by the more specific `blue` value set on the paragraph. Therefore, that paragraph’s
    text color would be blue.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 字体颜色被子元素继承。如果我们特别在`<body>`内的段落中设置不同的颜色，继承的`red`值将被在段落上设置的更具体的`blue`值覆盖。因此，那个段落的文本颜色将是蓝色。
- en: Listing 1.5 Example of inheritance (HTML)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.5 继承示例（HTML）
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Our header would inherit the red color.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们的页眉将继承红色颜色。
- en: ② The paragraph’s color would be blue, as set by the paragraph rule.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ② 段落的颜色将是蓝色，这是由段落规则设置的。
- en: Listing 1.6 Example of inheritance (CSS)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.6 继承示例（CSS）
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Not all property values will be inherited. Theme-related styles such as color
    and font size will generally be inherited; layout considerations generally are
    not. This guideline is a loose one, with definite exceptions, but it’s a good
    place to start. We’ll cover exceptions on a case-by-case basis throughout the
    projects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有属性值都会被继承。与主题相关的样式，如颜色和字体大小通常会被继承；布局考虑通常不会。这个指南是松散的，有明确的例外，但这是一个好的起点。我们将在整个项目中根据具体情况处理例外。
- en: If the property value isn’t being inherited, the browser looks at the type of
    selector that was used and mathematically calculates the specificity value. We’ll
    get into more detail about what each selector type is in section 1.6, but first
    let’s look at how the math is applied.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性值没有被继承，浏览器会查看所使用的选择器类型，并通过数学计算特定性值。我们将在第1.6节中更详细地介绍每种选择器类型是什么，但首先让我们看看数学是如何应用的。
- en: The browser looks at the selector, categorizes the types of selectors being
    used by the rule, and applies the type value. Then it adds all the values and
    gets a final specificity value. Figure 1.9 diagrams the process. The biggest number
    wins, so rule 1 in the diagram would win over rule 2.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器查看选择器，根据规则分类使用的选择器类型，并应用类型值。然后它添加所有值并得到一个最终特定性值。图1.9展示了这个过程。最大的数字获胜，所以图中的规则1会胜过规则2。
- en: '![](../Images/01-09.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-09.png)'
- en: Figure 1.9 Calculating specificity
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 计算特定性
- en: 'Specificity values by selector type are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据选择器类型的特定性值如下：
- en: '`100`—ID selectors'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`100`—ID选择器'
- en: '`10`—Class selectors, attribute selectors, and pseudo-classes'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`—类选择器、属性选择器和伪类'
- en: '`1`—Type selectors and pseudo-elements'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`—类型选择器和伪元素'
- en: '`0`—Universal selectors'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`—通用选择器'
- en: 'If we still have a tie, the browser looks at which stylesheet the style originated
    from. If both values come from the same stylesheet, the one later in the document
    wins. If the values come from different stylesheets, the order is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然有平局，浏览器会查看样式来自哪个样式表。如果两个值都来自同一个样式表，文档中较后的那个获胜。如果值来自不同的样式表，顺序如下：
- en: User stylesheet
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户样式表
- en: Author stylesheets (in the order in which they’re being imported; the last one
    wins)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者样式表（按照导入的顺序；最后一个生效）
- en: UA stylesheet
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UA样式表
- en: We set `!important` to the side earlier. Now that we understand the normal flow,
    let’s add it back into the mix. When a value has the `!important` annotation,
    the process is short-circuited, and the value with the annotation automatically
    wins.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前将`!important`放在一边。现在我们理解了正常流程，让我们将其添加回混合中。当一个值有`!important`注释时，流程被短路，带有注释的值自动获胜。
- en: If both values have the `!important` annotation, the browser follows the normal
    flow. Figure 1.10 shows the flow through the stylesheets, including `!important`
    declarations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个值都有`!important`注释，浏览器遵循正常流程。图1.10显示了通过样式表的流程，包括`!important`声明。
- en: '![](../Images/01-10.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-10.png)'
- en: Figure 1.10 CSS order of precedence
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 CSS优先级顺序
- en: We’ve established that the type of selector will affect specificity. Let’s take
    a closer look at the selectors and use them in our project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定选择器的类型会影响特定性。让我们更仔细地查看选择器，并在我们的项目中使用它们。
- en: 1.6 CSS selectors
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 CSS选择器
- en: The selector sets what HTML elements we want to target. In CSS, we have seven
    ways to target the HTML elements we want to style, as discussed in the following
    sections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器设置我们想要定位的HTML元素。在CSS中，我们有七种方式来定位我们想要样式的HTML元素，如以下各节所述。
- en: 1.6.1 Basic selectors
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 基本选择器
- en: The most common method of applying styles to HTML elements is selecting them
    based on name, ID, or class name. These are used most often because of their one-to-one
    mapping to the HTML element itself or attributes set on the element.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将样式应用于HTML元素的最常见方法是根据名称、ID或类名选择它们。这些最常使用，因为它们与HTML元素本身或元素上设置的属性的一对一映射。
- en: Type selector
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 类型选择器
- en: The *type selector* targets the HTML element by name. The benefit of using the
    type selector is that when we read through our CSS, we can quickly work out which
    HTML elements would be affected if we made changes in the rule. This selector
    doesn’t require us to add any particular markup to the HTML to target the element.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型选择器*通过名称定位HTML元素。使用类型选择器的优点是，当我们阅读我们的CSS时，我们可以快速确定如果我们在规则中做出更改，哪些HTML元素会受到影响的。这个选择器不需要我们在HTML中添加任何特定的标记来定位元素。'
- en: Let’s use a type selector to target all our headings (`<h1>` through `<h6>`)
    and change their color to crimson. Our CSS would be `h1,` `h2,` `h3,` `h4,` `h5,`
    `h6` `{` `color:` `crimson;` `}`. Figure 1.11 shows that our headers have changed
    colors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用类型选择器来定位所有我们的标题（`<h1>`到`<h6>`），并将它们的颜色改为深红。我们的CSS将是`h1,` `h2,` `h3,` `h4,`
    `h5,` `h6` `{` `color:` `crimson;` `}`。图1.11显示我们的标题颜色已更改。
- en: '![](../Images/01-11.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-11.png)'
- en: Figure 1.11 Header color change
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 标题颜色更改
- en: Class selectors
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类选择器
- en: We can use class selectors on as many different elements as we want. By applying
    a class name to elements, we’re grouping multiple HTML elements so that when we
    apply styles, they’ll roll out to any element with that class name.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们想要的任何不同元素上使用类选择器。通过将类名应用于元素，我们正在将多个HTML元素分组，以便当我们应用样式时，它们将扩展到具有该类名的任何元素。
- en: To add classes to HTML, we use the `class` attribute. Within the `class` attribute,
    we can add as many values (or classes) as we want, separating each with a space.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 HTML 添加类，我们使用 `class` 属性。在 `class` 属性内，我们可以添加尽可能多的值（或类），每个值用空格分隔。
- en: We have many ways and methods to write our class names, such as Block, Element,
    Modifier (BEM) methodology ([https://en.bem.info](https://en.bem.info)) and Scalable
    and Modular Architecture for CSS (SMACSS; [http://smacss.com](http://smacss.com)),
    which are style guides for writing consistent stylesheets.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多方法和方式来编写我们的类名，例如块状、元素、修饰符（BEM）方法（[https://en.bem.info](https://en.bem.info)）和可伸缩和模块化
    CSS 架构（SMACSS；[http://smacss.com](http://smacss.com)），这些都是编写一致样式表的指南。
- en: The main point is to write class names that make sense to everyone. Adding the
    class name `text` to paragraph elements, for example, would be highly confusing.
    Other elements, such as our headings, can also be thought of as text, so it may
    not be clear which specific element we’re referring to.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目的是编写对每个人都有意义的类名。例如，给段落元素添加类名 `text` 会非常令人困惑。其他元素，如我们的标题，也可以被视为文本，所以可能不清楚我们指的是哪个特定元素。
- en: Applying class names based on a specific style, such as a `color`, can also
    be dangerous. Giving an element the class name `blue` might work immediately,
    but if the design changes and the color applied is now red, our class name will
    no longer make sense.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定的样式（如 `color`）应用类名也可能很危险。给一个元素添加类名 `blue` 可能会立即生效，但如果设计改变并且应用的颜色现在是红色，我们的类名将不再有意义。
- en: In our HTML, we find that some of our headings have a class of `small-heading`.
    We’re going to create a rule that selects `small-heading` and changes the text
    of the elements to uppercase.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 HTML 中，我们发现一些标题具有 `small-heading` 类。我们将创建一个选择 `small-heading` 并将元素的文本改为大写的规则。
- en: 'To select the `small-heading` class name, in the CSS we first type dot (`.`)
    followed by the class name `small-heading`. Then our styles go into curly braces
    as follows: `.small-heading` `{` `text-transform:` `uppercase` `}`. Figure 1.12
    shows our uppercased headings. Notice that the other headings aren’t affected—only
    those to which the class was applied.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择 `small-heading` 类名，在 CSS 中我们首先输入点（`.`）然后是类名 `small-heading`。然后我们的样式进入大括号，如下所示：`.small-heading`
    `{` `text-transform:` `uppercase` `}`。图 1.12 展示了我们的大写标题。注意，其他标题没有受到影响——只有那些应用了该类的标题。
- en: '![](../Images/01-12.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-12.png)'
- en: Figure 1.12 Class selector applied to elements that have the class name `small-heading`
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 类选择器应用于具有类名 `small-heading` 的元素
- en: ID selector
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ID 选择器
- en: In HTML, IDs are unique. Any given ID should be used only once on a web page.
    If an ID is repeated, our code is considered to be invalid HTML.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，ID 是唯一的。任何给定的 ID 应该在网页上只使用一次。如果 ID 重复，我们的代码被认为是无效的 HTML。
- en: Generally we should avoid using ID selectors; because they need to be unique
    in the HTML, rules constructed against the ID aren’t easy to reuse. Furthermore,
    an ID selector is one of the most specific selectors available, making the styles
    applied with an ID selector difficult to override. Unless the uniqueness of the
    element is key, avoid using ID attributes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们应该避免使用 ID 选择器；因为它们在 HTML 中必须是唯一的，针对 ID 构造的规则不容易重用。此外，ID 选择器是可用的最具体选择器之一，使得使用
    ID 选择器应用的风格难以覆盖。除非元素的唯一性是关键，否则请避免使用 ID 属性。
- en: Our example article contains a `blockquote` with an `ID` attribute containing
    the value `quote-by-author`. In our CSS, to select the `blockquote` we use a hash
    (`#`), followed immediately by the `ID` we want to target. Then we have curly
    braces, inside which we place our declarations, as shown in the following listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例文章包含一个具有 `ID` 属性的 `blockquote`，其值为 `quote-by-author`。在我们的 CSS 中，要选择 `blockquote`，我们使用井号（`#`），然后紧接着是我们想要定位的
    `ID`。然后我们有大括号，在大括号内放置我们的声明，如下所示。
- en: Listing 1.7 ID selector
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.7 ID 选择器
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 1.13 shows the code applied to our project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 展示了应用于我们项目的代码。
- en: '![](../Images/01-13.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-13.png)'
- en: Figure 1.13 Styles applied by `#quote-by-author`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 显示了 `#quote-by-author` 应用的样式
- en: 1.6.2 Combinators
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.2 组合器
- en: 'Another way to write CSS is through *combinators,* which allow for more complex
    CSS without overusing `class` or `ID` names. There are four combinators:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写 CSS 的方法是使用 *组合器*，这允许在不过度使用 `class` 或 `ID` 名称的情况下编写更复杂的 CSS。这里有四种组合器：
- en: Descendant combinator (`space`)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后代组合器（`space`）
- en: Child combinator (`>`)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子组合器（`>`）
- en: Adjacent sibling combinator (`+`)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相邻兄弟组合器（`+`）
- en: General sibling combinator (`~`)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用兄弟组合器（`~`）
- en: One important concept to understand is the relationships between elements. In
    the next couple of examples, we’ll look at how we can use the relationships between
    elements to target different HTML elements to style our article. Figure 1.14 introduces
    the types of relationships we’re going to examine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的一个重要概念是元素之间的关系。在接下来的几个示例中，我们将探讨如何使用元素之间的关系来定位不同的 HTML 元素以样式化我们的文章。图 1.14
    介绍了我们将要检查的关系类型。
- en: '![](../Images/01-14.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-14.png)'
- en: Figure 1.14 The relationships between elements in HTML
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 HTML 元素之间的关系
- en: Descendant combinator (space)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 后代组合符（空格）
- en: Selectors that use descendant combinators select all the HTML elements within
    a parent. A selector that uses a descendant combinator is made up of three parts.
    The first part is the parent, which in this case is the article element. The parent
    is followed by a space and then by any element we want to select. Figure 1.15
    diagrams the syntax.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后代组合符的选择器选择父元素内的所有 HTML 元素。使用后代组合符的选择器由三部分组成。第一部分是父元素，在本例中是文章元素。父元素后面跟着一个空格，然后是我们想要选择的所有元素。图
    1.15 示例了语法。
- en: '![](../Images/01-15.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-15.png)'
- en: Figure 1.15 An example of a selector using a descendant combinator
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 使用后代组合符的选择器示例
- en: In this example, the browser would find any `<article>` element, target all
    descendant paragraphs (`<p>`) in the parent `<article>` element, and make the
    text double-spaced. When this selector is applied, our article looks like figure
    1.16.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，浏览器将找到任何 `<article>` 元素，针对其父 `<article>` 元素中的所有后代段落 (`<p>`) 进行双倍行距处理。当应用此选择器时，我们的文章看起来像图
    1.16。
- en: '![](../Images/01-16.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-16.png)'
- en: Figure 1.16 Child paragraphs are double-spaced
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 子段落双倍行距
- en: Child combinator (>)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 子组合符（>）
- en: The child combinator allows us to target the immediate child elements of a particular
    selector. This combinator is different from a selector that uses a descendant
    combinator because in the case of a child combinator, the targeted element must
    be an immediate child. A selector that uses a descendant combinator can select
    any descendent (child, grandchild, great-grandchild, and so on).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 子组合符允许我们定位特定选择器的直接子元素。这个组合符与使用后代组合符的选择器不同，因为在子组合符的情况下，目标元素必须是直接子元素。使用后代组合符的选择器可以选中任何后代（子元素、孙子元素、曾孙元素等）。
- en: In our project, we’ll style the list items in the article. As listing 1.8 shows,
    we have an unordered list (`<ul>`) with list items (`<li>`). That first child
    element has its own nested items, which would be grandchildren and great-grandchildren.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将对文章中的列表项进行样式化。如列表 1.8 所示，我们有一个无序列表 (`<ul>`) 和列表项 (`<li>`)。第一个子元素有自己的嵌套项，这些将是孙子元素和曾孙元素。
- en: Listing 1.8 HTML list items
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.8 HTML 列表项
- en: '[PRE7]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Parent item (.list)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ① 父元素项 (.list)
- en: ② Children of .list
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ② .list 的子元素
- en: ③ Grandchild of .list
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ③ .list 的曾孙元素
- en: ④ Great-grandchildren of .list
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ④ .list 的曾孙元素
- en: 'We’re going to style only the first-level list items—or immediate children
    of the `<ul>` with a `class` attribute value containing `list`—in a crimson color,
    without affecting the nested list items (the great-grandchildren). So the browser
    will find elements containing the `list` class, target only their immediate children
    that are list items (`<li>`), and change `color` to `crimson`. We’ll use the following
    CSS:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅对第一级列表项——即 `<ul>` 的直接子元素——使用包含 `list` 的 `class` 属性值进行样式化，使其呈现深红色，而不会影响嵌套列表项（即曾孙元素）。因此，浏览器将找到包含
    `list` 类的元素，仅针对它们的直接子元素（即列表项 `<li>`）更改 `color` 为 `crimson`。我们将使用以下 CSS：
- en: '[PRE8]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this CSS, the entire list becomes crimson, not just the top-level list
    items. The color is applied to the `<li>` element and all of its descendants.
    Even though we select the immediate child, because color is inherited, the children
    also turn crimson.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 CSS，整个列表变为深红色，而不仅仅是顶级列表项。颜色应用于 `<li>` 元素及其所有后代。尽管我们选择了直接子元素，但由于颜色是继承的，子元素也变为深红色。
- en: To select only the top-level elements, we therefore need to add a second rule
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了仅选择顶级元素，我们需要添加第二个规则
- en: '[PRE9]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: which returns the nested list items to their initial color, as shown in figure
    1.17.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使嵌套列表项恢复到初始颜色，如图 1.17 所示。
- en: '![](../Images/01-17.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-17.png)'
- en: Figure 1.17 Child combinator applied to `list` items
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 将子组合符应用于 `list` 项
- en: 'We can perform this operation in reverse and select the parent of the child
    element, right? The short answer is no, as the following example wouldn’t work:
    `article` `<` `p` `{` `color:` `blue;` `}`. If we want to select the parent or
    ancestor of an element, we need to use the `has()` pseudo-class—`article:has(p)`
    `{` `color:` `blue;` `}`—covered in section 1.6.3.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反过来执行这个操作，选择子元素的父母元素，对吧？简短的回答是：不行，以下示例不会起作用：`article` `<` `p` `{` `color:`
    `blue;` `}`。如果我们想选择一个元素的父元素或祖先元素，我们需要使用`has()`伪类——`article:has(p)` `{` `color:`
    `blue;` `}`——这在1.6.3节中有介绍。
- en: Adjacent sibling combinator (+)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 相邻兄弟组合符（+）
- en: When we need to style an element that’s at the same level as another, the way
    your brother or sister is on the same level of the family tree as you, we can
    use the adjacent sibling combinator. If we want to target the element that’s directly
    after another, we can use a selector that uses an adjacent sibling combinator.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要对与另一个元素处于同一级别的元素进行样式设计时，就像你的兄弟姐妹与你处于家族树中的同一级别一样，我们可以使用相邻兄弟组合符。如果我们想定位直接跟在另一个元素后面的元素，我们可以使用一个使用相邻兄弟组合符的选择器。
- en: In listing 1.9, the browser will find any uses of the `<header>` element, target
    the first paragraph (`<p>`) immediately after (or adjacent to) the `<header>`
    element, and change the `font-size` to `1.5rem` and the `font-weight` to `bold`.
    Figure 1.18 shows the code applied to our article.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表1.9中，浏览器将找到任何`<header>`元素的使用，目标是在`<header>`元素之后立即（或相邻）的`<p>`元素，并将`font-size`更改为`1.5rem`，将`font-weight`更改为`bold`。图1.18显示了应用于我们的文章的代码。
- en: Listing 1.9 Adjacent sibling combinator
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.9 相邻兄弟组合符
- en: '[PRE10]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/01-18.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-18.png)'
- en: Figure 1.18 Styling the paragraph immediately after the header
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18 样式化标题之后的段落
- en: This approach could be useful if we’re trying to style the first element differently
    from the others to make it stand out. We might see this effect in a newspaper.
    The first paragraph of an article might be made to look more prominent than the
    rest to catch our attention.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在尝试将第一个元素与其他元素区分开来，使其突出时可能很有用。我们可能在报纸上看到这种效果。文章的第一段可能会被设计得比其他段落更突出，以吸引我们的注意。
- en: Another use case is for error handling in forms. Adjacent sibling combinators
    allow us to display an error message to the user immediately following an invalid
    value in a form control.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是在表单中进行错误处理。相邻兄弟组合符允许我们在表单控件中的无效值之后立即向用户显示错误消息。
- en: General sibling combinator (~)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通用兄弟组合符（~）
- en: The general sibling combinator is more open-ended than the other methods, as
    it allows us to target all elements that are siblings after the element targeted
    by the selector.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通用兄弟组合符比其他方法更开放，因为它允许我们针对选择器定位的元素之后的所有兄弟元素。
- en: In our example, we’ll style all images that come after the element `<header>`.
    Notice that we have three placeholder images. The first image is small (it could
    be a logo or an author photo) and resides above the `<header>`. We don’t want
    to style it. The other two images are farther down in the article. We want to
    apply a border around them to keep the color theme consistent with the rest of
    the article.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将为`<header>`元素之后的所有图像进行样式设计。请注意，我们有三个占位图像。第一个图像很小（它可能是一个标志或作者照片），位于`<header>`之上。我们不想对它进行样式设计。其他两个图像在文章中更低的位置。我们希望围绕它们添加边框，以保持与文章其余部分的色彩主题一致。
- en: 'Our rule will be as follows: `header` `~` `img` `{` `border:` `4px` `solid`
    `crimson;` `}.` The browser will find the `<header>` element; target all the sibling
    images (`<img>`) after that element; and add a `border` that’s `4px` in thickness,
    that’s a `solid` line (as opposed to a `dotted`, `dashed`, or `double` line),
    and that’s colored `crimson`. We can see the code applied to our article in figure
    1.19.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的规则将如下所示：`header` `~` `img` `{` `border:` `4px` `solid` `crimson;` `}`。浏览器将找到`<header>`元素；目标在该元素之后的所有兄弟图像（`<img>`）；并添加一个厚度为`4px`的边框，这是一条实线（而不是点线、虚线或双线），颜色为`crimson`。我们可以在图1.19中看到应用于我们的文章的代码。
- en: '![](../Images/01-19.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-19.png)'
- en: Figure 1.19 General sibling combinator targeting sibling images of header
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19 通用兄弟组合符定位标题的兄弟图像
- en: 1.6.3 Pseudo-class and pseudo-element selectors
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.3 伪类和伪元素选择器
- en: CSS has selectors called *pseudo-classes* and *pseudo-elements*. You may wonder
    where the names come from. *Pseudo* means “not genuine, false, or pretend.” This
    definition makes sense because, technically, we’re targeting a state or parts
    of an element that may not exist yet. We’re simply pretending.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: CSS有称为*伪类*和*伪元素*的选择器。你可能想知道这些名称的来源。"伪"意味着“不是真正的，虚假的或假装的”。这个定义是有意义的，因为从技术上讲，我们正在定位一个可能还不存在的状态或元素的部分。我们只是在假装。
- en: Not all pseudo-elements and pseudo-classes work on all HTML elements. Throughout
    this book, we’ll look at where we can use pseudo-classes and with which HTML elements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有伪元素和伪类都适用于所有HTML元素。在这本书的整个过程中，我们将探讨我们可以使用伪类的地方以及与哪些HTML元素一起使用。
- en: Pseudo-class
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 伪类
- en: A *pseudo-class* is added to a selector to target a specific state of the element.
    Pseudo-classes are especially useful for elements that the user will interact
    with, such as links, buttons, and form fields. Pseudo-classes use a single colon
    (`:`) followed by the state of the element.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 向选择器添加一个*伪类*以定位元素的具体状态。伪类对于用户将要与之交互的元素特别有用，例如链接、按钮和表单字段。伪类使用单个冒号（`:`）后跟元素的状态。
- en: Our article contains a few links. We haven’t styled the links in any way; therefore,
    their styles will come from the UA stylesheet. Most browsers underline links and
    display them in a color based on whether the link was previously visited—that
    is, whether the URL appears in the browser’s history.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文章包含一些链接。我们没有以任何方式对链接进行样式设计；因此，它们的样式将来自用户代理（UA）样式表。大多数浏览器会在链接下划线并基于链接是否被访问过（即URL是否出现在浏览器的历史记录中）以不同的颜色显示它们。
- en: With links, we have a few states to consider. The most common are
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链接，我们需要考虑一些状态。最常见的是
- en: '`link`—An anchor tag (`<a>`) contains an `href` attribute and a URL that doesn’t
    appear in the user’s browser history.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`—一个锚标签（`<a>`）包含一个`href`属性和一个不会出现在用户浏览器历史记录中的URL。'
- en: '`visited`—An anchor (`<a>`) element contains an `href` attribute and a URL
    that does appear in the user’s browser history.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visited`—一个锚（`<a>`）元素包含一个`href`属性和一个会出现在用户浏览器历史记录中的URL。'
- en: '`hover`—The user has the cursor over the element but hasn’t clicked it.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hover`—用户将光标悬停在元素上但尚未点击它。'
- en: '`active`—The user is clicking and holding the element.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`—用户正在点击并保持元素。'
- en: '`focus`—A *focused element* is an element that receives keyboard events by
    default. When a user clicks a focusable element, it automatically gains focus
    (unless some JavaScript alters this behavior). Using the keyboard to navigate
    among form fields, links, and buttons also changes the element that is in focus.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus`—一个*聚焦元素*是默认接收键盘事件的元素。当用户点击一个可聚焦元素时，它会自动获得焦点（除非某些JavaScript改变了这种行为）。使用键盘在表单字段、链接和按钮之间导航也会改变当前聚焦的元素。'
- en: '`focus-within`—When `focus-within` is applied to a parent element and the child
    of the parent has focus, `focus-within` styles will be applied.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus-within`—当`focus-within`应用于父元素，并且父元素的子元素获得焦点时，`focus-within`样式将被应用。'
- en: '`focus-visible`—When elements are selected using `focus-visible`, styles are
    applied only when focus has been gained via keyboard navigation or the user is
    interacting with the element via the keyboard.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus-visible`—当使用`focus-visible`选择元素时，样式仅在通过键盘导航获得焦点或用户通过键盘与元素交互时应用。'
- en: We mentioned `:has()` earlier. Also a pseudo-class but not specific to links,
    `:has()` applies when the element has at least one descendent that meets the selector
    specified inside the parentheses. When we wrote this book, `:has()` had not yet
    been implemented in all major browsers.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到了`:has()`。它也是一个伪类，但不仅限于链接，`:has()`在元素至少有一个符合括号内指定的选择器的后代时应用。当我们编写这本书时，`:has()`尚未在所有主要浏览器中得到实现。
- en: In our current article project, we’ll create an `a:link` rule to change the
    color of anchor tags that contain an `href` attribute and haven’t been visited
    to light blue, using the hex color code `#1D70B8`. The `:visited` state should
    be different from the `:link` state because it should indicate to the user that
    they haven’t visited that page before (that is, the URL isn’t present in their
    browser history). Often, websites don’t differentiate between the two states,
    but discerning them can provide a better user experience. In our example, we’ll
    change the :`visited` state to a purple `color`, using the hex code value `#4C2C92`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的这篇文章项目中，我们将创建一个 `a:link` 规则来改变包含 `href` 属性且未被访问的锚标签的颜色，使其变为浅蓝色，使用十六进制颜色代码
    `#1D70B8`。`:visited` 状态应该与 `:link` 状态不同，因为它应该向用户表明他们之前未曾访问过该页面（也就是说，URL 不存在于他们的浏览器历史记录中）。通常，网站不会区分这两种状态，但区分它们可以提供更好的用户体验。在我们的例子中，我们将`:visited`状态改为紫色`颜色`，使用十六进制代码值
    `#4C2C92`。
- en: Then we’ll handle the `:hover` state. This state doesn’t apply to mobile users,
    as there’s no way to recognize a user hovering over a link on a mobile device.
    In our article, we’ll change the :`hover` state text color to a dark blue, using
    the hex code value `#003078`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将处理 `:hover` 状态。此状态不适用于移动用户，因为在移动设备上没有识别用户悬停在链接上的方法。在我们的文章中，我们将`:hover`状态文本颜色改为深蓝色，使用十六进制代码值
    `#003078`。
- en: Finally, we’ll handle the `:focus` state. We can use this state on any focusable
    elements. Links, buttons, and form fields are focusable by default (unless disabled),
    but we can make any element focusable by using a positive-numbered `tabindex`,
    in which case focus-based styles could be applied. The `:focus` state is shown
    when the user clicks or taps an element. When the element is focused, we add a
    1-pixel crimson outline to the element. All put together, our link rules appear
    as shown in the following listing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将处理 `:focus` 状态。我们可以在任何可聚焦元素上使用此状态。链接、按钮和表单字段默认可聚焦（除非禁用），但我们可以通过使用正数 `tabindex`
    使任何元素可聚焦，在这种情况下，可以应用基于聚焦的样式。当用户点击或轻触元素时，将显示 `:focus` 状态。当元素聚焦时，我们在元素上添加一个 1 像素的深红色轮廓。所有这些加在一起，我们的链接规则如下所示。
- en: Listing 1.10 Styling links using pseudo-elements
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.10 使用伪元素设置链接样式
- en: '[PRE11]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the order in which these rulesets are written matters, as they have
    the same level of specificity. The condition that’s farthest down in the stylesheet
    will win if multiple conditions apply. In our example, if a link has been visited
    but is being hovered over, the link will take the color assigned to it by the
    `a:hover` `{}` rule because it comes after the `a:visited` `{}` rule in our stylesheet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些规则集的编写顺序很重要，因为它们具有相同的具体性级别。在样式表中，最底部的条件如果多个条件适用，将获胜。在我们的例子中，如果一个链接已被访问但正在悬停，则该链接将采用由
    `a:hover` `{}` 规则指定的颜色，因为它在我们的样式表中位于 `a:visited` `{}` 规则之后。
- en: Although developer tools vary in features and how those features are accessed,
    in most browsers, we can view the different element states by going into our browser,
    right-clicking, and choosing Inspect from the contextual menu. Typically, we get
    a view of the HTML with the CSS on the side. By clicking the `:hov` button in
    the Styles section, we see a panel that may say something like *force element
    state*, and then we can toggle different pseudo-classes on and off. Figure 1.20
    shows the Chrome developer tools with the `:hov` panel open.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开发者工具在功能和访问方式上有所不同，但在大多数浏览器中，我们可以通过进入浏览器，右键单击，并在上下文菜单中选择“检查”来查看不同的元素状态。通常，我们会看到一个带有
    CSS 侧边的 HTML 视图。通过点击样式部分中的 `:hov` 按钮，我们会看到一个可能显示“强制元素状态”的面板，然后我们可以打开和关闭不同的伪类。图
    1.20 显示了 Chrome 开发者工具中打开 `:hov` 面板的情况。
- en: Developer tools in browsers
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的开发者工具
- en: All major browsers have developer tools that allow developers to modify, debug,
    and optimize websites. For this book, we will use developer tools to examine our
    code. We will also examine the compiled code in the browser tools to understand
    how the browser is processing our CSS. For more information about developer tools
    and how to access them, see the appendix.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主流浏览器都提供了开发者工具，允许开发者修改、调试和优化网站。对于这本书，我们将使用开发者工具来检查我们的代码。我们还将检查浏览器工具中的编译代码，以了解浏览器是如何处理我们的
    CSS 的。有关开发者工具及其访问方式的更多信息，请参阅附录。
- en: '![](../Images/01-20.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01-20.png)'
- en: Figure 1.20 Viewing different element states by using the browser’s developer
    tools
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 使用浏览器开发者工具查看不同的元素状态
- en: Pseudo-element
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 伪元素
- en: '*Pseudo-elements* use a double colon (`::`). The purpose of pseudo-elements
    is to allow us to style a specific part of an element. Sometimes, pseudo-elements
    are written with a single colon, although using two is strongly recommended. The
    ability to ignore the second colon is for backward compatibility; the two-colon
    syntax was introduced as part of CSS3 to better differentiate between pseudo-classes
    and pseudo-elements.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪元素*使用双冒号（`::`）。伪元素的目的在于允许我们样式化元素的一个特定部分。有时，伪元素会使用单冒号书写，尽管使用两个冒号是强烈推荐的。忽略第二个冒号的能力是为了向后兼容；双冒号语法是作为CSS3的一部分引入的，以更好地区分伪类和伪元素。'
- en: Using the `::first-letter` pseudo-element, we can target the first letter of
    a paragraph rather than wrap the letter in something like a `span` element, which
    would break the word apart and clutter our HTML. This approach allows us to create
    complex CSS without complicating the HTML.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`::first-letter`伪元素，我们可以定位段落的第一个字母，而不是将其包裹在类似`span`元素的某物中，这会打断单词并使我们的HTML变得杂乱。这种方法允许我们创建复杂的CSS而不使HTML变得复杂。
- en: In our article, we used the adjacent sibling combinator to make our first paragraph
    bold and in a larger font size than the rest. Now we’re going to change the color
    of the first letter of that first paragraph and change the font style to `italic`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文章中，我们使用了相邻兄弟组合器来使第一段加粗，并且比其他段落的字体大小更大。现在我们将改变第一段第一个字母的颜色，并将其字体样式改为`italic`。
- en: First, we target the `header` element; then, we target the first letter (`::first-letter`)
    of the paragraph (`<p>`). With our selector created, we add our declarations.
    Our CSS will look like the following listing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定位`header`元素；然后，我们定位段落（`<p>`）的第一个字母（`::first-letter`）。创建选择器后，我们添加我们的声明。我们的CSS将如下所示。
- en: Listing 1.11 Selecting the first letter
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.11 选择第一个字母
- en: '[PRE12]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When this code is applied, the first letter is red and italicized (figure 1.21).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码应用后，第一个字母是红色的，并且是斜体的（图1.21）。
- en: '![](../Images/01-21.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-21.png)'
- en: Figure 1.21 Pseudo-element targeting the first letter of the first paragraph
    immediately after the header
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21 伪元素定位在标题后的第一段第一个字母
- en: 1.6.4 Attribute value selectors
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.4 属性值选择器
- en: Commonly used for styling links and form elements, the attribute selector styles
    HTML elements that include a specified attribute. The attribute value selector
    looks for a specific attribute with the same value.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 属性选择器通常用于样式化链接和表单元素，它样式化包含指定属性的HTML元素。属性值选择器寻找具有相同值的特定属性。
- en: In our article, we have some content in Italian. The language of the paragraph
    is specified by the `lang` attribute, as shown in the following listing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文章中，我们有一些意大利语内容。段落的语言由`lang`属性指定，如下所示。
- en: Listing 1.12 Specifying Italian content
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.12 指定意大利语内容
- en: '[PRE13]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To hint to users that this content is in Italian, we’ll use CSS to add the Italian-flag
    emoji. The browser will find the language (`lang`) attribute with the value of
    Italian (`it`) and then add an Italian-flag emoji `before` it. Listing 1.13 uses
    a `::before` pseudo-element as well. We can use multiple types of selectors to
    target the exact part of the HTML we want to style.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提示用户该内容是意大利语，我们将使用CSS添加意大利旗标表情。浏览器将找到值为意大利语（it）的`lang`属性，然后在它之前添加一个意大利旗标表情。列表1.13也使用了`::before`伪元素。我们可以使用多种类型的选择器来定位我们想要样式的HTML的精确部分。
- en: Listing 1.13 Using multiple types of selectors to add a flag before Italian
    content
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.13 使用多种类型的选择器在意大利语内容前添加旗标
- en: '[PRE14]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When this code is applied, our Italian content has an emoji flag before it (figure
    1.22).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码应用后，我们的意大利语内容前面有一个表情旗标（图1.22）。
- en: Emoji differences across devices and applications
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 设备和应用中的表情符号差异
- en: If you’re coding along with this chapter, your output may differ from figure
    1.22\. Emojis present differently depending on the device, operating system, and
    application being used. Sites such as Emojipedia ([https://emojipedia.org](https://emojipedia.org))
    show how a particular emoji would look across applications and devices. You can
    find details on the Italian flag at [https://emojipedia.org/flag-italy](https://emojipedia.org/flag-italy).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在与本章一起编码，你的输出可能与图1.22不同。表情符号在不同的设备、操作系统和应用中呈现方式不同。例如，Emojipedia（[https://emojipedia.org](https://emojipedia.org)）展示了特定表情符号在应用程序和设备上的外观。你可以在[https://emojipedia.org/flag-italy](https://emojipedia.org/flag-italy)上找到意大利国旗的详细信息。
- en: '![](../Images/01-22.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-22.png)'
- en: Figure 1.22 Italian flag applied by the attribute selector and a pseudo-element
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 通过属性选择器和伪元素应用的意大利国旗
- en: 1.6.5 Universal selector
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.5 通用选择器
- en: The broadest type of selector is the universal selector, which uses the asterisk
    symbol (`*`). Any declarations made with the universal selector will be applied
    to all the HTML elements.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛的选择器类型是通用选择器，它使用星号符号（`*`）。使用通用选择器做出的任何声明都将应用于所有 HTML 元素。
- en: Sometimes, this selector can be used to reset CSS, but in terms of specificity,
    it has a specificity value of `0`, which means that it can be overridden easily
    if necessary. This is important because it targets every element. The universal
    selector can also be used to target any and all descendants of a particular selector,
    as in `.foo` `*` `{` `background:` `yellow;` `}`, in which any and all descendants
    of an element with the class `foo` would be given a yellow background.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这个选择器可以用来重置 CSS，但从特定性的角度来看，它具有 `0` 的特定性值，这意味着如果需要，它可以很容易地被覆盖。这很重要，因为它针对了每个元素。通用选择器还可以用来针对特定选择器的任何和所有后代，例如
    `.foo` `*` `{` `background:` `yellow;` `}`，其中具有 `foo` 类的任何和所有后代元素都将被赋予黄色背景。
- en: In our example project, we’ll use a universal selector (`*`) to set the `font-family`
    to `sans-serif` so that the font will be sans-serif consistently throughout the
    article, as shown in the following listing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们将使用通用选择器（`*`）将 `font-family` 设置为 `sans-serif`，以便在整个文章中字体始终为无衬线字体，如下面的列表所示。
- en: Listing 1.14 Making our `font-family` consistent
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.14 使我们的 `font-family` 保持一致
- en: '[PRE15]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When this code is applied, all the text in our document uses a sans-serif font
    regardless of element type (figure 1.23).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码被应用时，我们文档中的所有文本都将使用无衬线字体，无论元素类型如何（图 1.23）。
- en: '![](../Images/01-23.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-23.png)'
- en: Figure 1.23 Using the universal selector to change the font type on all elements
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23 使用通用选择器更改所有元素的字体类型
- en: 1.7 Different ways to write CSS
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 编写 CSS 的不同方式
- en: CSS allows flexibility in the way we write our rules and formatting. In this
    section, we’ll look at shorthand properties (which we will keep coming back to
    throughout the book) and ways to format CSS.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 允许我们在编写规则和格式化时具有灵活性。在本节中，我们将探讨缩写属性（我们将在整本书中不断回到这个话题）以及格式化 CSS 的方法。
- en: 1.7.1 Shorthand
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.1 缩写
- en: '*Shorthand* replaces writing multiple CSS properties with merging all the values
    into one property. We can do this with a few properties such as padding, margin,
    and animation, all of which are covered at various points throughout this book.
    The benefit of writing shorthand is that it reduces the size of our stylesheet,
    which improves readability, performance, and memory use.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*缩写* 通过将所有值合并到一个属性中来替代编写多个 CSS 属性。我们可以使用一些属性，如 `padding`、`margin` 和 `animation`，这些属性在本书的各个部分都有涉及。编写缩写的优点是它减少了样式表的大小，从而提高了可读性、性能和内存使用。'
- en: 'Each shorthand property takes different values. Let’s explore the one we used
    in our project. We have a `blockquote` in our article. When we styled it, we used
    the `padding` property and declared our padding as follows: `padding:` `10px`.
    In doing so, we used shorthand. Instead, we could have written the code as shown
    in the following listing.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每个缩写属性都有不同的值。让我们探索我们在项目中使用的那个。我们在文章中有一个 `blockquote`。当我们为其添加样式时，我们使用了 `padding`
    属性，并声明了以下 `padding`：`padding:` `10px`。通过这样做，我们使用了缩写。相反，我们本可以像以下列表中所示那样编写代码。
- en: Listing 1.15 Padding expanded
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.15 扩展 `padding`
- en: '[PRE16]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s completely fine to write each declaration separately, but doing that is
    expensive in terms of computing performance, especially because all the property
    values are the same. Instead, we can use the `padding` property and put all four
    values on the same line. The order is `top`, `right`, `bottom`, and `left`. We
    can also combine `right`/`left` and `top`/`bottom` values if they’re identical,
    as depicted in figure 1.24.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个声明单独编写是完全可行的，但从计算性能的角度来看，这样做是昂贵的，尤其是因为所有属性值都是相同的。相反，我们可以使用 `padding` 属性并将所有四个值放在同一行上。顺序是
    `top`、`right`、`bottom` 和 `left`。如果 `right`/`left` 和 `top`/`bottom` 的值相同，我们还可以将它们组合起来，如图
    1.24 所示。
- en: '![](../Images/01-24.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-24.png)'
- en: Figure 1.24 Padding shorthand property explained
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24 解释缩写属性 `padding`
- en: As shown in the figure, we can declare all four values to define the `top`,
    `right`, `bottom`, and `left` values. But if we say that `right` and `left` are
    the same and `top` and `bottom` are different, we can specify three values, in
    the order `top`, `right` `&` `left`, `bottom`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，我们可以声明所有四个值来定义`top`、`right`、`bottom`和`left`的值。但如果我们说`right`和`left`相同，而`top`和`bottom`不同，我们可以指定三个值，顺序为`top`、`right`
    `&` `left`、`bottom`。
- en: If two values are declared, we’re saying the first value is what the `top` and
    `bottom` should be; then the second value sets the `right` and `left`. Finally,
    if only one value is declared, the value sets all four sides.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明了两个值，我们表示第一个值是`top`和`bottom`应该是什么；然后第二个值设置`right`和`left`。最后，如果只声明了一个值，该值将设置所有四个边。
- en: 1.7.2 Formatting
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.2 格式化
- en: We can write CSS in a few ways, and often when we view other people’s code,
    we see different formats. This section shows a few examples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用几种方式编写CSS，并且当我们查看他人的代码时，我们经常看到不同的格式。本节展示了几个示例。
- en: The multiline format shown in listing 1.16 is likely the most popular choice
    for formatting. Each declaration is on its own line and indented by means of tabs
    or spaces.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.16中所示的多行格式可能是格式化的最流行选择。每个声明都在自己的行上，并通过制表符或空格缩进。
- en: Listing 1.16 Multiline format
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.16 多行格式
- en: '[PRE17]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A variation on the multiline format, shown in listing 1.17, places the opening
    curly brace on its own line. This example is something we might see in the PHP
    language. It could be considered unnecessary to place the opening brace on its
    own line.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.17所示的多行格式的变体将开括号放在自己的行上。这个例子可能是我们在PHP语言中看到的东西。将开括号放在自己的行上可能被认为是多余的。
- en: Listing 1.17 A variation on multiline format
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.17 多行格式的变体
- en: '[PRE18]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The single-line format shown in listing 1.18 makes a lot of sense; it’s compact,
    and we can scan a file knowing that the first part is the selector. The downside
    is that it can be difficult to read if a rule contains many declarations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.18中所示的单行格式非常有意义；它紧凑，我们可以扫描一个文件，知道第一部分是选择器。缺点是如果规则包含许多声明，它可能难以阅读。
- en: Listing 1.18 Single-line format
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.18 单行格式
- en: '[PRE19]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All these options have positives and negatives, but the projects in this book
    use a combination of options one and three. The main thing to know is that there’s
    no right or wrong method; the choice generally comes down to what works best for
    you and/or your team. As long as the code is easy to understand, that’s all that
    matters.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都有优点和缺点，但本书中的项目使用了一和三的组合。要知道的主要是，没有正确或错误的方法；选择通常取决于对你和/或你的团队来说什么最有效。只要代码易于理解，那就足够了。
- en: Those with an eagle eye will notice that in listings 1.16, 1.17, and 1.18, there’s
    no semicolon (`;`) at the end of the last declaration of the rules. This semicolon
    is optional. One of the best aspects of CSS is that we can write it in the way
    that’s most comfortable for us.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 那些有鹰眼的人会注意到，在列表1.16、1.17和1.18中，规则的最后一个声明的末尾没有分号（`;`）。这个分号是可选的。CSS最好的一个方面之一是我们可以用最舒适的方式编写它。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: CSS is a well-established coding language, and each part of CSS is made up of
    modules.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS是一种成熟的编码语言，CSS的每一部分都由模块组成。
- en: Modules replaced large releases such as CSS3.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块替换了像CSS3这样的大型发布。
- en: Inline CSS can take the highest priority and has good performance, but it’s
    repetitive and hard to maintain.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联CSS可以具有最高优先级，并且性能良好，但它重复且难以维护。
- en: External CSS keeps our CSS separate from our HTML, maintaining SoC.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部CSS将我们的CSS与HTML分开，保持SoC。
- en: Along with our own CSS, the browser applies default styling.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了我们自己的CSS外，浏览器还会应用默认样式。
- en: The user may also apply their own CSS, which can override the author and UA
    stylesheets.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户还可以应用他们自己的CSS，这可以覆盖作者和UA样式表。
- en: Using `!important` is considered to be bad practice.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`!important`被认为是不良实践。
- en: A CSS rule consists of a selector and one or more declarations.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CSS规则由一个选择器和一条或多条声明组成。
- en: We can create rules for many types of selectors, and each rule can have its
    own level of specificity.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为许多类型的选择器创建规则，并且每个规则都可以有自己的特定级别。
