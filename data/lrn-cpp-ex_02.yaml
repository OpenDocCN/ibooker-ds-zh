- en: 2 Containers, iterators, and ranges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 容器、迭代器和范围
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Filling and using containers, with a focus on a vector of numbers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充和使用容器，重点关注数字向量
- en: Range-based `for` loops and `auto`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环和 `auto`
- en: Using a container with standard algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准算法的容器
- en: Using `format` to display output
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `format` 显示输出
- en: Ranges, views, and lambdas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围、视图和 lambda 表达式
- en: Containers and algorithms have been a fundamental part of C++ for a long time.
    Containers have included sequences (e.g., `vector)`, associative containers (e.g.,
    `map)`, and, since C++ 11, unordered associative containers (e.g., `unordered_map)`.
    The containers manage the storage for their elements. The separation of data structures
    and algorithms offers great flexibility, allowing one algorithm to be applied
    to various containers. The addition of ranges to the core language provides simplified
    ways to access and manipulate containers. To explore these features, in this chapter,
    we are going to construct Pascal’s triangle, which is made by adding up adjacent
    numbers from the preceding row, starting with a single 1 in the first row. The
    entries can be used to count the number of event combinations and more. We will
    use vectors to store the values, starting with the first row, to practice using
    a vector and writing out to the screen. We’ll then generate and display more rows,
    learning how to use vectors differently. Finally, we’ll discuss some of the triangle’s
    properties. This will help us think about testing our code later.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和算法长期以来一直是 C++ 的基本组成部分。容器包括序列（例如，`vector`），关联容器（例如，`map`），以及自 C++ 11 以来，无序关联容器（例如，`unordered_map`）。容器管理其元素的存储。数据结构和算法的分离提供了极大的灵活性，允许一个算法应用于各种容器。将范围添加到核心语言提供了简化访问和操作容器的方法。为了探索这些特性，在本章中，我们将构建帕斯卡三角形，它通过从前一行相邻数字相加得到，第一行从单个
    1 开始。这些条目可以用来计算事件组合的数量等等。我们将使用向量来存储值，从第一行开始，以练习使用向量和将内容输出到屏幕。然后我们将生成并显示更多行，学习如何以不同的方式使用向量。最后，我们将讨论三角形的一些属性。这将帮助我们思考稍后对代码进行测试。
- en: You’ll need a compiler and editor or an IDE if you want to code along. A list
    of free resources is available at [https://isocpp.org/get-started](https://isocpp.org/get-started).
    I’m using a mixture of Vim with GNU Compiler Collection (GCC) in the Windows Subsystem
    for Linux (WSL) and Visual Studio 2022 community edition, with `/std:c++latest`
    in the C++ command line properties.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随操作，则需要编译器和编辑器或 IDE。免费资源的列表可在 [https://isocpp.org/get-started](https://isocpp.org/get-started)
    找到。我使用 Vim 与 GNU 编译器集合（GCC）在 Windows 子系统（WSL）中的组合，以及 Visual Studio 2022 社区版，在
    C++ 命令行属性中使用 `/std:c++latest`。
- en: 2.1 Creating and displaying a vector
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 创建和显示向量
- en: First, we will create a vector containing a single number and display it. This
    will be the first row of the triangle. Vectors are the most commonly used containers,
    so starting with them is handy. We can then practice putting different elements
    in vectors, including other vectors, and using them with algorithms. We will also
    employ several other C++ features as we code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个包含单个数字的向量并显示它。这将构成三角形的第一行。向量是最常用的容器，因此从它们开始是方便的。然后我们可以练习将不同的元素放入向量中，包括其他向量，并使用算法处理它们。在编码过程中，我们还将使用几个其他
    C++ 功能。
- en: It’s a good idea to keep your code outside the `main` entry point function so
    you can add tests easily or build a library to make reusing the code straightforward.
    That said, we’ll put everything in one file, called `main.cpp`, to keep things
    simple, and we’ll make a function that we’ll call from `main`. We start by making
    a vector containing a number and displaying the contents as follows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码放在 `main` 入口点函数之外是一个好主意，这样您可以轻松添加测试或构建库以简化代码的重用。话虽如此，我们将把所有内容放在一个名为 `main.cpp`
    的文件中，以保持简单，并创建一个从 `main` 中调用的函数。我们首先创建一个包含一个数字的向量，并显示其内容如下。
- en: Listing 2.1 Filling and displaying a container
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 填充和显示容器
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Includes headers for output and the vector itself
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含输出和向量本身的头文件
- en: ❷ Defines a vector, initialized with a single number 1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个向量，初始化为单个数字 1
- en: ❸ Uses a range-based for loop to walk over the vector
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用基于范围的 for 循环遍历向量
- en: 'If you’re playing along, compile and run your code. For the GCC tools, compile
    like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在参与，请编译并运行您的代码。对于 GCC 工具，编译方式如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We don’t need to say which `std` we are using here, as long as the compiler
    supports at least C++11, and we are checking for any warnings, with `all` to the
    warning flag `-W`. The `-o` flag names our output, which we can run by typing
    `./main.out` once it has built the single `main.cpp` file. If you are using an
    IDE, find your Build button, and then find the Run button. You should get a single
    digit on your screen.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不需要说明使用的是哪个`std`，只要编译器支持至少C++11标准，并且我们正在检查任何警告，使用`all`到警告标志`-W`。`-o`标志指定了输出文件名，一旦构建了单个`main.cpp`文件，我们可以通过输入`./main.out`来运行它。如果你使用的是IDE，找到你的构建按钮，然后找到运行按钮。你应该在屏幕上看到一个数字。
- en: 'The code contains a few newer C++ features. At the top, we’ve included two
    headers: `iostream` for input and output streams and `vector`. This should be
    familiar. We then have a function to generate and display the first line of our
    triangle using a `vector` for storage. The `vector` is initialized with the single
    number 1:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含一些新的C++特性。在顶部，我们包含了两个头文件：`iostream`用于输入和输出流以及`vector`。这应该是熟悉的。然后有一个函数用于生成和显示三角形的第一行，使用`vector`进行存储。`vector`被初始化为单个数字1：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice we’re using curly braces, called the *uniform initialization syntax.*
    If we say
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的是花括号，称为*统一初始化语法*。如果我们说
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'instead, we get a vector with one value, which is 0\. A vector has various
    constructors. The second version using `(1)` treats the number 1 as a count of
    elements. The first version, using curly braces `{1}`, is using an *initializer
    list.* The list can have more than one item, and the vector is created with the
    contents of the initializer list. Trying to use an initializer list of `{1,` `2.3}`
    would generate a compiler error. This requires a *narrowing conversion* because
    `2.3` is a double, and we want a `vector` of `int`. We can even use `{}` to initialize
    a single number: `int x{` `42` `}`. As the brace initialization can be used in
    many places, it is called *uniform initialization*. ISOCpp suggests preferring
    brace initialization ([http://mng.bz/n1m5](http://mng.bz/n1m5)) because it avoids
    narrowing and allows consistency. Initialization is a big topic and can get complicated.
    For example, Nicolai Josuttis has talked about “The Nightmare of Initialization
    in C++” ([https://www.youtube.com/watch?v=7DTlWPgX6zs](https://www.youtube.com/watch?v=7DTlWPgX6zs)).
    The important thing to note here is that we can use an initializer list to construct
    a vector.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们得到一个只有一个值的向量，这个值是0。向量有各种构造函数。第二个版本使用`(1)`将数字1视为元素的数量。第一个版本，使用花括号`{1}`，是使用*初始化列表*。列表可以包含多个项目，向量是用初始化列表的内容创建的。尝试使用初始化列表`{1,`
    `2.3}`将生成编译器错误。这需要一个*narrowing conversion*，因为`2.3`是一个双精度浮点数，而我们想要一个`int`类型的`vector`。我们甚至可以使用`{}`来初始化一个单个数字：`int
    x{` `42` `}`。由于花括号初始化可以在许多地方使用，因此它被称为*统一初始化*。ISOCpp建议优先使用花括号初始化([http://mng.bz/n1m5](http://mng.bz/n1m5))，因为它避免了缩窄并允许一致性。初始化是一个很大的主题，可能会变得复杂。例如，Nicolai
    Josuttis谈到了“C++初始化的噩梦”([https://www.youtube.com/watch?v=7DTlWPgX6zs](https://www.youtube.com/watch?v=7DTlWPgX6zs))。这里要注意的重要一点是我们可以使用初始化列表来构造一个向量。
- en: 'Armed with our container of data, we can show its contents on the standard
    output stream (`cout`). We employ a *range-based* `for` *loop* to walk over the
    container, using the insertion `operator` `<<` to stream out elements from the
    container. Generally, a range-based `for` loop has the `for`, parentheses, and
    a colon, as we saw in listing 2.1:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的数据容器，我们可以在标准输出流(`cout`)上显示其内容。我们使用基于范围的`for`循环来遍历容器，使用插入操作符`<<`将容器中的元素流式传输出来。通常，基于范围的`for`循环有`for`、括号和冒号，就像我们在列表2.1中看到的那样：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a more succinct syntax than traditional `for` loops. On the left side
    of the colon, there are a type and a variable name. We can be lazy and get the
    compiler to figure out the type by using `auto`. To the right of the colon, there
    is a container, array, or similar. We can think of the range-based `for` loop
    as syntactic sugar to make our lives easier. We do not need to spell out the stopping
    conditions or how to step through the items. The range-based `for` loop does this
    for us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个比传统的`for`循环更简洁的语法。在冒号的左侧有一个类型和一个变量名。我们可以偷懒，让编译器通过使用`auto`来自动确定类型。在冒号的右侧有一个容器、数组或类似的东西。我们可以将基于范围的`for`循环视为一种语法糖，使我们的生活更轻松。我们不需要明确说明停止条件或如何遍历项目。基于范围的`for`循环为我们做了这些。
- en: 'If we try the code out in C++ Insights ([https://cppinsights.io/](https://cppinsights.io/)),
    we see the loop transformed into a traditional C-style `for` loop with three parts:
    a beginning, a stopping condition, and an increment. Every container has a beginning
    and an end, and the range-based `for` loop uses these to walk through the elements.
    C++ Insights shows all the gory details but gives code equivalent to'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在C++ Insights([https://cppinsights.io/](https://cppinsights.io/))中尝试这段代码，我们会看到循环被转换为一个传统的C风格`for`循环，包含三个部分：一个开始，一个停止条件，和一个增量。每个容器都有一个开始和一个结束，基于范围的`for`循环使用这些来遍历元素。C++
    Insights显示了所有细节，但给出的代码与
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the C-style `for` loop, we use a position that is an *iterator* into the
    vector, which we need to *dereference*, using `operator` `*`*,* when we want to
    print the value:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C风格的`for`循环时，我们使用一个指向向量的迭代器位置，当我们想要打印值时，需要使用`operator*`来解引用：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The range-based `for` loop is much easier to use and means we can code at a
    higher level without having to think about iterators.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的`for`循环更容易使用，这意味着我们可以以更高的层次进行编码，而不必考虑迭代器。
- en: Let’s look at `auto` in more detail. The keyword tells the compiler to deduce
    the type. If you’re using an IDE, a mouse hover over the word `auto` might tell
    you the number’s deduced type. Visual Studio says it’s using `std::vector<int>>::iterator::value_
    type`, which is `int`. Typing `int` instead of `auto` makes little apparent difference
    in our case, but there are advantages to almost always using auto (AAA). This
    phrase was coined by Herb Sutter on his Guru of the Week blog ([http://mng.bz/vPpp](http://mng.bz/vPpp)).
    In more complicated cases, `auto` will save a lot of typing, while tending to
    keep the code type safe. If we change the container’s type to use `double` instead,
    we do not need to change the loop as well, so the code is less brittle when we
    use `auto`. Using `auto` can also pick up subtleties that can be easily missed.
    If we make the data constant
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看`auto`。这个关键字告诉编译器推断类型。如果你在使用IDE，将鼠标悬停在`auto`这个词上可能会告诉你推断出的类型。Visual
    Studio说它使用`std::vector<int>>::iterator::value_`类型，即`int`。在我们的情况下，用`int`代替`auto`几乎没有明显的区别，但几乎总是使用`auto`（AAA）有一些优点。这个短语是由Herb
    Sutter在他的Guru of the Week博客([http://mng.bz/vPpp](http://mng.bz/vPpp))上提出的。在更复杂的情况下，`auto`将节省很多打字，同时倾向于保持代码类型安全。如果我们将容器的类型更改为使用`double`，我们就不需要更改循环，因此当使用`auto`时，代码更不容易出错。使用`auto`还可以捕捉到容易忽略的细微差别。如果我们使数据成为常量
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'the loop variable’s type automatically changes to a `const_iterator`, so we
    do not need to remember to make the change there. In fact, we can even declare
    our container using `auto`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 循环变量的类型会自动更改为`const_iterator`，所以我们不需要记住在那里进行更改。实际上，我们甚至可以使用`auto`来声明我们的容器：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because `data` is a vector of `int` constructed with an initializer list containing
    an `int`, it is deduced to be `vector<int>`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`data`是一个包含`int`的初始化列表构造的`int`向量，所以它被推断为`vector<int>`。
- en: More significantly, `auto` can help us avoid implicit conversions, including
    narrowing conversions, and force us to initialize our variables. We can say `auto`
    `variable` `=` `init`, or if we want a specific type, we can say `auto` `variable`
    `=` `type{init}`. In both cases, we are forced to spell out how to initialize
    the variable. We cannot say `auto` `variable;` because we will get a compiler
    error. If we try something like `auto` `x` `=` `int{` `1.5` `}`, we will also
    get a compiler error because we are trying to use a narrowing conversion. If we
    say `int` `x` `=` `1.5` instead, we might get a warning, but some people ignore
    warnings. Not a good idea, but it happens. Using `auto` would stop the potential
    error.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，`auto`可以帮助我们避免隐式转换，包括缩窄转换，并强制我们初始化变量。我们可以说`auto variable = init`，或者如果我们想要一个特定的类型，我们可以说`auto
    variable = type{init}`。在两种情况下，我们都被迫明确地说明如何初始化变量。我们不能说`auto variable;`，因为这将导致编译器错误。如果我们尝试像`auto
    x = int{1.5}`这样的操作，我们也会得到编译器错误，因为我们正在尝试使用缩窄转换。如果我们说`int x = 1.5`代替，我们可能会得到一个警告，但有些人会忽略警告。这不是一个好主意，但这种情况确实会发生。使用`auto`可以阻止潜在的错误。
- en: 'Back to our vector. We can make one more small change to how we create our
    vector. We told the compiler to put an integer in the vector, so surely it can
    figure out the type of the elements in the vector. Yes, it can now. Since C++17,
    we can simply say `std:: vector` `data{` `1` `}`. Notice we haven’t specified
    the template type. Instead, we are relying on *class template argument deduction*
    (CTAD). If we decided to use `auto` (almost) everywhere, we could even change
    our declaration to `auto` `data` `=` `std::vector{` `1` `}`. Now, if we want an
    empty vector, the type cannot be deduced because `auto` `data` `=` `std:: vector{}`
    does not have a way to deduce the type of the elements, so it fails to compile.
    CTAD is another new feature that saves us some typing.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '回到我们的向量。我们可以对创建向量的方式进行一个小改动。我们告诉编译器在向量中放置一个整数，所以它当然可以推断出向量中元素的类型。是的，它现在可以了。自从C++17以来，我们可以说`std::
    vector` `data{` `1` `}`。注意我们没有指定模板类型。相反，我们依赖于*类模板参数推导*（CTAD）。如果我们决定在几乎每个地方都使用`auto`，我们甚至可以将我们的声明改为`auto`
    `data` `=` `std::vector{` `1` `}`。现在，如果我们想要一个空向量，类型无法推断，因为`auto` `data` `=` `std::
    vector{}`没有一种方法可以推断出元素类型，所以它无法编译。CTAD是另一个新特性，它可以节省我们一些打字。'
- en: We can now display the first row of Pascal’s triangle. This may seem like a
    small step, but we have seen a handful of C++ features and can build on this.
    Next, we will add more rows to the triangle and learn more C++ along the way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以显示帕斯卡三角形的第一个行。这看起来可能是一个小步骤，但我们已经看到了一些C++特性，并且可以在此基础上构建。接下来，我们将向三角形添加更多行，并在过程中学习更多C++。
- en: 2.2 Creating and displaying Pascal’s triangle
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 创建和显示帕斯卡三角形
- en: We now have the first row and will use it to make the next few rows, displaying
    what we get. We will use C++20’s range library to print out the results. Ranges
    are one of the bigger features introduced in C++20 that go beyond shorter syntax.
    Once we have several rows, we will then think about some properties of Pascal’s
    triangle, which will help us test our code and practice using our vectors. Let’s
    start with a recap of how to build Pascal’s triangle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了第一行，并将用它来制作接下来的几行，展示我们得到的结果。我们将使用C++20的range库来打印结果。Ranges是C++20中引入的几个较大特性之一，它超越了更短的语法。一旦我们有了几行，我们就会考虑一些帕斯卡三角形的性质，这将帮助我们测试我们的代码并练习使用我们的向量。让我们先回顾一下如何构建帕斯卡三角形。
- en: 2.2.1 A reminder of Pascal’s triangle
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 帕斯卡三角形的提醒
- en: 'Pascal’s triangle contains several useful number sequences. One common use
    is to find the number of ways events can combine. If you toss a coin once, you
    can get either heads or tails. If you toss it twice, you can get heads twice,
    tails twice, or one of each, in two ways: heads and then tails or tails and then
    heads. For three tosses, you might get all heads, two heads, one heads, or none,
    but how many combinations are there for a given number of heads? Pascal’s triangle
    will tell us.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 帕斯卡三角形包含几个有用的数字序列。一个常见的用途是找出事件组合的方式。如果你掷一次硬币，你可以得到正面或反面。如果你掷两次，你可以得到两次正面，两次反面，或者一次正面一次反面，有两种方式：先正面后反面或先反面后正面。对于三次掷币，你可能得到全部正面，两次正面，一次正面，或者一个也没有，但对于给定数量的正面，有多少种组合呢？帕斯卡三角形会告诉我们。
- en: The triangle starts with a number 1, by definition. If we are looking for the
    number of possible combinations when tossing a coin, there is one result for zero
    coin tosses. Each subsequent row then starts and ends with 1, by definition. This
    corresponds to the combination of events. For one coin toss, we can get a single
    heads in one way or a single tails, again in one way. The second row is therefore
    two 1s. For the third row, again, we start and end with a 1 because we can get
    all heads in one way or all tails in one way. The next number is the sum of the
    two numbers in the preceding row, laying out the rows as shown in figure 2.1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形从定义上开始于一个数字1。如果我们正在寻找掷硬币时可能组合的数量，那么对于零次掷币有一个结果。每一行随后从定义上开始和结束于1。这对应于事件的组合。对于一次掷币，我们可以以一种方式得到一个单一的正面，或者以一种方式得到一个单一的反面。因此，第二行是两个1。对于第三行，同样，我们开始和结束于1，因为我们可以以一种方式得到全部正面，或者以一种方式得到全部反面。下一个数字是前一行中两个数字的和，按照图2.1所示排列行。
- en: '![CH02_F01_Buontempo](../Images/CH02_F01_Buontempo.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Buontempo](../Images/CH02_F01_Buontempo.png)'
- en: Figure 2.1 The figure shows the first few rows of Pascal’s triangle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 该图显示了帕斯卡三角形的几行。
- en: 'To generate the fourth row, we start with a 1, then sum the first two numbers
    from the last row, getting 1 + 2 = 3; next, we sum the second and the third number,
    getting 2 + 1 = 3\. We have used up the previous row, so we add a final 1\. For
    three coin tosses, the fourth row is telling us how many combinations we can have:
    1, 3, 3, 1\. In other words, there is one way to get all heads; three ways to
    get two heads (HHT, HTH, THH); three ways to get one heads (HTT, THT, TTH); and
    finally, one way to get no heads (TTT).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成第四行，我们从1开始，然后从上一行中求和前两个数字，得到1 + 2 = 3；接下来，我们求和第二个和第三个数字，得到2 + 1 = 3。我们已经用完了上一行，所以最后我们加一个1。对于三次抛硬币，第四行告诉我们可以有多少种组合：1,
    3, 3, 1。换句话说，有一种方法可以得到全部正面；三种方法可以得到两个正面（HHT, HTH, THH）；三种方法可以得到一个正面（HTT, THT,
    TTH）；最后，有一种方法可以得到没有正面（TTT）。
- en: We continue with the next row, starting with 1, adding adjacent pairs in the
    previous row, and ending with a final 1\. We could do this forever on paper, but
    code is a different matter. An integer will have a maximum value, which will vary
    between machines and compilers. If we include the numeric header, we can find
    out what a platform gives by calling `std::numeric_limits<int>::max()`. I get
    2,147,483,647, which is 1 less than 2 to the power of 31, 2^(31) - 1\. That’s
    plenty of space for a few rows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续下一行，从1开始，在上一行中添加相邻的数字对，并以最后的1结束。我们可以在纸上无限期地这样做，但代码是另一回事。整数有一个最大值，这将在不同的机器和编译器之间有所不同。如果我们包含数值头文件，我们可以通过调用`std::numeric_limits<int>::max()`来找出平台给出的值。我得到2,147,483,647，这是2的31次方减1，即2^(31)
    - 1。这足够存放几行。
- en: 2.2.2 Coding Pascal’s triangle
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 编码帕斯卡三角形
- en: There are several equivalent ways to generate the triangle; however, let’s write
    code based on the definition we just looked at. We saw how to build a new row
    using numbers from the previous row, so let’s build a function taking the last
    row and returning the next row. In the last section, we sent data straight to
    the screen, but that made code difficult to test, so it makes sense to return
    the data instead and write a separate display function. Single-responsibility
    functions are sensible after all. We made a `vector` of integers for the first
    row, so we will continue using a `vector<int>` for each row. The next listing
    shows our function, adding a 1 at the start and end of the next row and doing
    some adding in between.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种等效的方法可以生成三角形；然而，让我们根据我们刚刚看到的定义来编写代码。我们看到了如何使用上一行的数字构建一个新行，所以让我们构建一个函数，它接受最后一行并返回下一行。在上一个部分中，我们直接将数据发送到屏幕上，但这使得代码难以测试，所以返回数据并编写一个单独的显示函数是有意义的。毕竟，单一职责函数是合理的。我们为第一行创建了一个整数`vector`，所以我们将继续使用`vector<int>`为每一行。下一个列表显示了我们的函数，在下一行的开始和结束处添加一个1，并在中间进行一些求和。
- en: Listing 2.2 The next row of Pascal’s triangle using the previous row
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 使用上一行构建帕斯卡三角形的下一行
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ CTAD used to deduce that our template contains integers
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用CTAD推导出我们的模板包含整数
- en: ❷ Stores the sum of the two numbers in the row above
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储上一行中两个数字的和
- en: We initialized our first row using curly braces because there was a specific
    value. Now we want to calculate values and add them to a `vector`. There is more
    than one way to do this. To add to the end of the vector, we can use `push_back`
    or `emplace_back`. To add items inside elsewhere, we can use `insert` or `emplace`.
    The `emplace` versions send in data to create the item in place, while `push_back`
    or `insert` take a fully formed item that they copy, as illustrated in figure
    2.2.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用花括号初始化第一行，因为有一个特定的值。现在我们想要计算值并将它们添加到一个`vector`中。有多种方法可以做到这一点。要将值添加到向量的末尾，我们可以使用`push_back`或`emplace_back`。要在其他地方添加项目，我们可以使用`insert`或`emplace`。`emplace`版本发送数据以在原地创建项目，而`push_back`或`insert`则接受一个完全形成的项目，并将它们复制到向量中，如图2.2所示。
- en: '![CH02_F02_Buontempo](../Images/CH02_F02_Buontempo.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F02_Buontempo](../Images/CH02_F02_Buontempo.png)'
- en: Figure 2.2 `emplace` (left) takes parameters to construct an item in place,
    while `push_back` takes a fully constructed item copied into the vector.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 `emplace`（左侧）接受参数以在原地构建一个项目，而`push_back`则接受一个已完全构建的项目并将其复制到向量中。
- en: For our integers, both methods amount to the same. Sometimes, the `emplace`
    version is quicker because it constructs the element directly in place in the
    vector; however, `push_back` can be safer sometimes. The `emplace` version will
    find a constructor for us, which might not be what we would have chosen ourselves.
    Jason Turner discusses the pros and cons on C++ Weekly ([https://www.youtube.com/watch?v=jKS9dSHkAZY](https://www.youtube.com/watch?v=jKS9dSHkAZY)).
    The bottom line is that we are likely to see both being used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的整数，这两种方法都达到相同的效果。有时，`emplace`版本会更快，因为它直接在向量中构造元素；然而，有时`push_back`可能更安全。`emplace`版本会为我们找到一个构造函数，这可能与我们自己选择的并不一样。贾森·特纳在C++
    Weekly上讨论了其优缺点（[https://www.youtube.com/watch?v=jKS9dSHkAZY](https://www.youtube.com/watch?v=jKS9dSHkAZY)）。总之，我们可能会看到两者都被使用。
- en: We can now calculate the values in each row, but we need to store them somewhere.
    A vector is a sensible choice, giving us an `std::vector<std::vector<int>>`. That’s
    a mouthful, and the compiler can figure this out for us. This means we can use
    `auto` as the return type when we write a function to create the triangle to save
    typing out `std::vector<std::vector<int>>` in full. For a more complicated function,
    we might need to help the compiler figure out what type is being returned, but
    the compiler can cope in this example. How many rows do we want? We can postpone
    that decision if we accept the required number as a parameter. All we need to
    do is call our `get_next_row` function to populate the vector we return, starting
    with an empty data row.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以计算每一行的值，但我们需要将它们存储在某个地方。向量是一个明智的选择，它给我们一个`std::vector<std::vector<int>>`。这听起来有点复杂，编译器可以为我们解决这个问题。这意味着当我们编写一个创建三角形的函数时，我们可以使用`auto`作为返回类型，以避免完全写出`std::vector<std::vector<int>>`。对于更复杂的函数，我们可能需要帮助编译器确定返回的类型，但在这个例子中，编译器可以应对。我们想要多少行？如果我们接受所需的数字作为参数，我们可以推迟这个决定。我们只需要调用我们的`get_next_row`函数来填充我们返回的向量，从空的数据行开始。
- en: Listing 2.3 Generating several rows of Pascal’s triangle
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 生成帕斯卡三角形的几行
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ auto shorthand for deduced return type
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 推导返回类型的自动简写
- en: ❷ Generates the next row from the previous row
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从前一行生成下一行
- en: ❸ Adds it to the triangle
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将其添加到三角形中
- en: We could stop here, display our triangle, and move on to a new chapter. However,
    this approach is not particularly efficient. We can do better.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里停止，显示我们的三角形，并进入新的一章。然而，这种方法并不特别高效。我们可以做得更好。
- en: 2.2.3 Move semantics and perfect forwarding
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 移动语义和完美转发
- en: 'A vector has many different constructors. We used the version taking an initializer
    list in listing 2.1 when we made the first row of our triangle:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 向量有许多不同的构造函数。我们在列表2.1中创建三角形的第一行时使用了接受初始化列表的版本：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To generate the triangle, we *default construct* each data row as
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成三角形，我们默认构造每个数据行作为
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'and assign it after the function call:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 并在函数调用后分配它：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then push the data to the back of the triangle:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将数据推送到三角形的末尾：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is not as efficient as it could be. We create the row data, and a copy
    is pushed back to the vector of vectors. If we make a couple of small changes,
    in effect by using a different constructor, we can avoid the copy. Let’s see how
    to do this using what is referred to as *perfect forwarding*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像它本可以做到的那样高效。我们创建了行数据，并将其复制推回到向量中。如果我们进行一些小的更改，实际上是通过使用不同的构造函数，我们可以避免复制。让我们看看如何使用所谓的*完美转发*来实现这一点。
- en: 'We saw earlier that `vector` supports `push_back` and `emplace_back`. The former
    takes a fully formed item, which we have here, while the latter constructs an
    object in place. There are two versions of `push_back`. The first takes an item
    by reference:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到`vector`支持`push_back`和`emplace_back`。前者接受一个完整的项，这是我们在这里所拥有的，而后者在原地构造一个对象。`push_back`有两种版本。第一个通过引用接受一个项：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That version will be called by our code. It takes our `data` and makes a copy
    at the end of the triangle. We can avoid that copy if we use the second overload
    of `push_back`. The signature uses `&&` to indicate an *rvalue reference*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将由我们的代码调用。它接受我们的`data`并在三角形的末尾创建一个副本。如果我们使用`push_back`的第二个重载，我们可以避免这个复制。该签名使用`&&`来表示*rvalue
    reference*：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What is an rvalue reference? Any expression has a *value category*, such as
    an rvalue or an lvalue. There are other categories too, but we will not go into
    all of them here. Instead, we will concentrate on avoiding the copy. CppReference
    gives the full details ([http://mng.bz/468R](http://mng.bz/468R)) in case you
    want to take a deeper dive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是右值引用？任何表达式都有一个 *值类别*，例如右值或左值。还有其他类别，但在这里我们不会详细介绍它们。相反，我们将专注于避免复制。如果你想要深入了解，CppReference
    提供了完整细节（[http://mng.bz/468R](http://mng.bz/468R)）。
- en: C uses the idea of lvalues and rvalues. If we say
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C 使用了左值和右值的概念。如果我们说
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: the variable `x` is on the left of an expression and is therefore called an
    lvalue, whereas `42` is on the right and is called an rvalue. The lvalue has a
    name, while the rvalue does not. When we call `get_next_row`, we have an rvalue.
    This is a temporary unnamed vector, which we copied previously to the lvalue `data`.
    This is wasteful. Rather than keeping a copy of the data, we can use the `back`
    method to get the last row of the triangle. Thus, we need to initialize the triangle
    with the first row so that there is an element at the back. We can now write our
    function as shown in the next listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x` 位于表达式的左侧，因此被称为左值（lvalue），而 `42` 位于右侧，被称为右值（rvalue）。左值有一个名称，而右值没有。当我们调用
    `get_next_row` 时，我们得到一个右值。这是一个之前复制到左值 `data` 中的临时未命名向量。这是浪费的。与其保留数据的副本，我们可以使用
    `back` 方法来获取三角形的最后一行。因此，我们需要用第一行初始化三角形，以便在后面有一个元素。现在我们可以像下面列表中所示的那样编写我们的函数。
- en: Listing 2.4 Moving a temporary
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 移动临时对象
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Adds first row so we can call back
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加第一行，以便我们可以调用 back
- en: ❷ Starts at 1 because we already have a row
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 1 开始，因为我们已经有一行
- en: 'We no longer have a copy of data. The `push_back( const T& value )` version
    initializes a new element with a copy of the value, but the version taking an
    rvalue reference, `push_back( T&& value )`, can move the temporary into the triangle
    for us, avoiding the copy. The vector has various constructors, including one
    taking an rvalue reference, called a *move constructor*. Its signature has the
    `&&` we saw earlier:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再有数据的副本。`push_back( const T& value )` 版本使用值的副本初始化新元素，但接受右值引用的版本 `push_back(
    T&& value )` 可以为我们将临时对象移动到三角形中，避免复制。向量有各种构造函数，包括一个接受右值引用的构造函数，称为 *移动构造函数*。它的签名有我们之前看到的
    `&&`：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `push_back` method taking `T` `&&` value can utilize this constructor by
    calling `std::move`, referred to as *move semantics*. The `push_back` `&&` overload
    can be, and often is, implemented as
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接受 `T` `&&` 值的 `push_back` 方法可以通过调用 `std::move` 来利用这个构造函数，这被称为 *移动语义*。`push_back`
    `&&` 重载可以，并且通常可以，实现为
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inside the `push_back` method, the rvalue has a name (`value`), so it becomes
    an lvalue. By calling `std::move(value)`, the value is cast back to an rvalue
    so that the rvalue constructor is picked. In effect, C++’s `move` operation does
    not actually move anything. It casts a value to an rvalue. This allows an overload
    taking an rvalue to be called, referred to as *perfect forwarding*. Once `move`
    has been called and an rvalue passed to a function, the value is in a valid but
    unspecified state. Since it’s been moved, it’s not of much use to us anymore.
    Without the move, the other vector would be passed as an lvalue, and the copy
    constructor would be called. This involves unnecessary copies, so it would forward
    the value imperfectly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `push_back` 方法内部，右值有一个名称（`value`），因此它变成了左值。通过调用 `std::move(value)`，值被转换回右值，以便选择右值构造函数。实际上，C++
    的 `move` 操作并没有真正移动任何东西。它将一个值转换为右值。这允许调用接受右值的重载，这被称为 *完美转发*。一旦调用 `move` 并将右值传递给函数，值就处于有效但未指定的状态。由于它已经被移动，对我们来说就不再有用。如果没有移动，其他向量将作为左值传递，并且会调用复制构造函数。这涉及到不必要的复制，因此它将值转发得不够完美。
- en: Move semantics and perfect forwarding are big topics, and we have only scratched
    the surface. Thomas Becker wrote an excellent blog post back in 2013 that walks
    through the details ([http://mng.bz/QRE6](http://mng.bz/QRE6)). An rvalue reference,
    `&&`, might be an lvalue
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义和完美转发是很大的主题，我们只是触及了表面。托马斯·贝克尔（Thomas Becker）在2013年写了一篇优秀的博客文章，详细介绍了这些细节（[http://mng.bz/QRE6](http://mng.bz/QRE6)）。一个右值引用
    `&&` 可能是一个左值
- en: 'or an rvalue. If it has a name, it is an lvalue, but calling `std::move` casts
    it to an rvalue, allowing perfect forwarding. In fact, we could call `emplace_back`
    directly ourselves with the rvalue or temporary:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个右值。如果它有一个名称，它是一个左值，但调用 `std::move` 会将其转换为右值，从而允许完美转发。实际上，我们可以直接使用右值或临时对象调用
    `emplace_back`：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How does the move constructor avoid a copy? A vector stores items contiguously,
    so we can access elements using iterators as well as indexing. We don’t need to
    know the number of elements at compile time because a vector can resize dynamically.
    When a vector runs out of space, it allocates more memory. We can think of it
    as a container pointing to some items, as shown in figure 2.3.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数是如何避免复制的？向量连续存储项目，因此我们可以使用迭代器以及索引来访问元素。我们不需要在编译时知道元素的数量，因为向量可以动态调整大小。当向量空间不足时，它会分配更多的内存。我们可以将其视为一个指向某些项目的容器，如图2.3所示。
- en: '![CH02_F03_Buontempo](../Images/CH02_F03_Buontempo.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F03_Buontempo](../Images/CH02_F03_Buontempo.png)'
- en: Figure 2.3 A vector is pointing to its elements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 一个向量指向其元素。
- en: There’s more to a vector than a pointer to its elements, but focusing on this
    will reveal how the move constructor avoids copying. A copy constructor or assignment
    will need to copy over each element, so we would have the original vector of,
    say, four elements, as shown in figure 2.3, along with an identical copy, also
    pointing at four elements. A move constructor can effectively steal the elements
    from the rvalue by pointing to the rvalue’s items, rather than allocating copies,
    as shown in figure 2.4.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 向量不仅仅是一个指向其元素的指针，关注这一点将揭示移动构造函数如何避免复制。复制构造函数或赋值操作需要复制每个元素，因此我们将有一个原始的向量，比如四个元素，如图2.3所示，以及一个相同的副本，也指向四个元素。移动构造函数可以通过指向rvalue的项而不是分配副本来有效地从rvalue中窃取元素，如图2.4所示。
- en: '![CH02_F04_Buontempo](../Images/CH02_F04_Buontempo.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F04_Buontempo](../Images/CH02_F04_Buontempo.png)'
- en: Figure 2.4 A move-constructed vector can steal the rvalue’s elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 移动构造的向量可以窃取rvalue的元素。
- en: Nothing else can try to use the nameless temporary’s elements afterwards, so
    this is fine. Furthermore, nothing has actually moved, but rather, the move constructor
    took ownership of the temporary’s data, and no elements needed copying.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此后没有任何其他东西可以尝试使用无名的临时元素，所以这是可以的。此外，实际上没有任何东西移动过，而是移动构造函数接管了临时数据的所有权，并且不需要复制任何元素。
- en: We’ve seen two ways to generate the vector. The second version is more efficient
    because it doesn’t make unnecessary copies. We now need a way to display our triangle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种生成向量的方法。第二种方法更高效，因为它不会进行不必要的复制。我们现在需要一种方法来显示我们的三角形。
- en: 2.2.4 Using ranges to display the vector
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 使用范围来显示向量
- en: Previously, we sent our vector with a single element straight to the screen,
    but if we write something more general, we can send it to a file or any other
    stream. We do this by overloading the `operator` `<<` for our triangle. We have
    a row, which is a `vector`, which contains a `vector` of integers. Rather than
    writing a `for` loop within a `for` loop to write out each element, we can use
    the `ranges` library to copy the elements to the provided stream. If your compiler
    doesn’t support `ranges::copy` yet, you can use `std::copy` instead. We can use
    an output stream iterator (`std::ostream_iterator`) to copy to and indicate we
    want a space between each number; otherwise, they will be unreadable. Include
    `<algorithm>` for `std::copy` and the <`iterator>` header for `std::ostream_ iterator`.
    Then add a new function as indicated in the following listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们直接将包含单个元素的向量发送到屏幕上，但如果我们写得更通用一些，我们可以将其发送到文件或任何其他流。我们通过为我们的三角形重载`operator
    <<`来实现这一点。我们有一行，它是一个`vector`，包含一个整数的`vector`。我们不需要在`for`循环内部再写一个`for`循环来写出每个元素，我们可以使用`ranges`库将元素复制到提供的流中。如果你的编译器还不支持`ranges::copy`，你可以使用`std::copy`代替。我们可以使用输出流迭代器（`std::ostream_iterator`）来复制并指示我们希望在数字之间留有空格；否则，它们将不可读。包含`<algorithm>`以使用`std::copy`和包含`<iterator>`头文件以使用`std::ostream_iterator`。然后按照以下列表添加一个新函数。
- en: Listing 2.5 Sending the contents to a stream
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 将内容发送到流
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Includes algorithm to use ranges::copy
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含算法以使用ranges::copy
- en: ❷ Allows a choice of stream
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许选择流
- en: ❸ Uses the constant reference to avoid a copy
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用常量引用以避免复制
- en: ❹ Sends the row to the output stream
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将行发送到输出流
- en: 'Note we are now using a constant reference to each row in the triangle by using
    `const` `auto&` `row` in the `for` loop. This should be familiar. If we used `auto`
    `row:` `v` instead, we would copy the entire contents of the row into `data`.
    The reference avoids the copy, and `const` means we cannot change the contents.
    The CPP core guidelines ([http://mng.bz/Xqn9](http://mng.bz/Xqn9)) encourage us
    not to make expensive copies of a loop variable in a range based `for` loop, as
    pointed out in the expressions and statements (ES) section, “ES.71: Prefer a range-for-statement
    to a for-statement when there is a choice.” These guidelines are curated by Bjarne
    Stroustrup and Herb Sutter, along with many other contributors, and contain lots
    of sensible advice. You will see more of them from time to time in this book.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在通过在 `for` 循环中使用 `const auto& row` 来对三角形的每一行使用常量引用。这应该是熟悉的。如果我们使用 `auto
    row:` `v`，我们将把整行内容复制到 `data` 中。引用避免了复制，而 `const` 表示我们无法更改内容。C++ 核心指南（[http://mng.bz/Xqn9](http://mng.bz/Xqn9)）鼓励我们不要在基于范围的
    `for` 循环中创建循环变量的昂贵副本，正如在表达式和语句（ES）部分所指出的，“ES.71：当有选择时，优先使用范围-for语句而不是for语句。” 这些指南由Bjarne
    Stroustrup和Herb Sutter以及许多其他贡献者编纂，包含大量合理的建议。您将在本书中不时看到更多这样的建议。
- en: 'The `for` loop gives us a reference to each row. We send this to the stream
    using a range algorithm. As with the range-based `for` loop we used in listing
    2.1, the range’s copy figures out where to start and end from our data vector.
    A range is conceptually anything that allows iteration by providing a `start`
    iterator and `end` sentinel. The older algorithms took a `begin` and an `end`
    of the same type. A sentinel is a recent addition generalizing the idea of the
    `end` iterator, similar to the idea of using a null character to indicate the
    end of a `char` array. We could write our own sentinel to stop when a negative
    number is encountered or any other custom logic. However, our vector has a `begin`
    and `end`, which is all we need here. We could use the non-range copy algorithm
    from the same header, but we’d need to specify `begin` and `end` ourselves:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环为我们提供了每一行的引用。我们使用范围算法将这个引用发送到流中。与我们在列表2.1中使用的基于范围的 `for` 循环一样，范围的复制会确定从我们的数据向量开始和结束的位置。在概念上，任何通过提供
    `start` 迭代器和 `end` 标志提供迭代的对象都是范围。较老算法使用相同类型的 `begin` 和 `end`。标志是一个最近添加的通用概念，它泛化了
    `end` 迭代器的想法，类似于使用空字符来指示 `char` 数组的结束。我们可以编写自己的标志来在遇到负数时停止或任何其他自定义逻辑。然而，我们的向量有一个
    `begin` 和 `end`，这是我们在这里需要的所有内容。我们可以使用同一头文件中的非范围复制算法，但我们需要自己指定 `begin` 和 `end`：'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Either version of `copy` is fine, but the range version is a little less wordy.
    This is one of many range versions of standard algorithms. Ranges provide considerably
    more than succinct syntax. We can also take views of ranges, allowing composition
    and filtering without copying data. Views are evaluated on demand; in other words,
    they support lazy evaluation. We will use a few more ranges later in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 两种版本的 `copy` 都可以，但范围版本稍微简洁一些。这是标准算法的许多范围版本之一。范围提供了比简洁语法更多的功能。我们还可以对范围进行视图操作，允许在不复制数据的情况下进行组合和过滤。视图按需评估；换句话说，它们支持惰性求值。在本章的后面部分，我们将使用更多范围。
- en: Now we can call our code to generate the triangle and see what we get. If we
    ask for a large number of rows, it won’t fit on the screen, and we might overflow
    our `int`, so let’s try 16.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用我们的代码来生成三角形并查看我们得到的结果。如果我们请求大量的行数，它将无法适应屏幕，并且我们可能会溢出 `int`，所以让我们尝试16。
- en: Listing 2.6 Main code to generate and display the triangle
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 生成和显示三角形的主体代码
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `<<` operator finds our new function and generates a left-justified triangle,
    as shown in figure 2.5.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<` 运算符找到我们的新函数并生成一个左对齐的三角形，如图2.5所示。'
- en: '![CH02_F05_Buontempo](../Images/CH02_F05_Buontempo.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F05_Buontempo](../Images/CH02_F05_Buontempo.png)'
- en: Figure 2.5 The first few rows of Pascal’s triangle
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 帕斯卡三角形的最初几行
- en: Warning Defining `operator` `<<` for common types, such as `vector<vector< int>>`,
    is generally a bad idea because a large system may end up with clashes if two
    different libraries or components try to do the same thing. It’s okay for your
    own classes. Writing a named function is better. We’ll do that shortly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 为常见类型（如 `vector<vector<int>>`）定义 `operator <<` 通常是一个坏主意，因为如果两个不同的库或组件尝试做同样的事情，大型系统最终可能会发生冲突。对于你自己的类来说是可以的。编写一个命名函数更好。我们很快就会这么做。
- en: If we try generating many rows, say, 36, the last few rows won’t fit on the
    screen, and we’ll start seeing the integer wrap around and become negative. Printing
    each row out starting at the left was easy enough, but it gives us an unconventional
    output. We can do better if we center-justify the output. This also gives us the
    opportunity to learn about the new `format` library.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试生成许多行，比如说36行，最后几行将不会适应屏幕，我们将开始看到整数溢出并变成负数。从左侧开始打印每一行是足够的简单，但它给出了非传统的输出。如果我们居中对齐输出，我们可以做得更好。这也给了我们学习新`format`库的机会。
- en: 2.2.5 Using format to display output
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.5 使用格式显示输出
- en: 'When we saw how to generate the triangle, figure 2.1 showed the rows center-justified,
    which is the conventional way to show the triangle. Sticking with 16 rows gives
    numbers up to four digits long, so if we center each number in six spaces and
    add enough spaces at the start of each line, we will have what we want. We can
    use the `std::format` tools to do this by including the `format` header. `format`
    started life as the Victor Zverovich’s open source `fmt` library ([https://fmt.dev/latest/index.html](https://fmt.dev/latest/index.html)).
    Some compilers do not fully support `format` yet, so you may need to use this
    library instead. There are various ways to install the library, but the simplest
    is to download from the main page and unzip the download. Instead of including
    the standard `format` header in the code that follows, use `fmt/core.h`; it is
    simplest to use the header only:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到如何生成三角形时，图2.1显示了居中对齐的行，这是显示三角形的传统方式。坚持使用16行可以显示最多四位的数字，因此如果我们将每个数字居中对齐在六个空间内，并在每行的开头添加足够的空间，我们就会得到我们想要的结果。我们可以通过包含`format`头文件来使用`std::format`工具来完成这项工作。`format`最初是Victor
    Zverovich的开源`fmt`库([https://fmt.dev/latest/index.html](https://fmt.dev/latest/index.html))。一些编译器目前还没有完全支持`format`，因此您可能需要使用这个库。安装库有多种方法，但最简单的是从主页下载并解压下载的文件。在随后的代码中，不要包含标准的`format`头文件，而是使用`fmt/core.h`；只使用头文件是最简单的：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You also need to use `fmt::format` instead of `std::format` in the code, and
    you need to tell the compiler the additional `include` path, using the `-I` switch:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，您还需要使用`fmt::format`而不是`std::format`，并且您需要通过使用`-I`开关告诉编译器额外的`include`路径：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At the time of writing, the open source library contained more features than
    currently supported in standard C++, but we will stick with commonly supported
    features here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，开源库包含的功能比当前标准C++支持的功能更多，但在这里我们将坚持使用常见支持的功能。
- en: Tip If your compiler doesn’t support `format` yet, you can use the open source
    `fmt` library ([https://fmt.dev/latest/index.html](https://fmt.dev/latest/index.html)).
    Alternatively, the `fmt` library includes a link to Godbolt ([https://godbolt.org/z/Eq5763](https://godbolt.org/z/Eq5763)),
    which includes the `fmt` library so you can try out code in the compiler explorer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您的编译器目前不支持`format`，您可以使用开源的`fmt`库([https://fmt.dev/latest/index.html](https://fmt.dev/latest/index.html))。或者，`fmt`库包含一个指向Godbolt([https://godbolt.org/z/Eq5763](https://godbolt.org/z/Eq5763))的链接，其中包含`fmt`库，您可以在编译器探索器中尝试代码。
- en: The `format` library is similar to C’s `printf` function but is often faster,
    simpler, and safer to use. The syntax uses curly braces inside a string as placeholders.
    The placeholder can be empty, take a format specifier (such as `d` for decimal),
    or give the index of an argument from the values. If we don’t specify which value
    to use where via an index, they are placed in order. The format specifiers are
    very similar to Python’s. If we asked for a number with the `d` format specifier
    but passed a string
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`库类似于C的`printf`函数，但通常更快、更简单、更安全。语法在字符串内部使用花括号作为占位符。占位符可以是空的，也可以是一个格式说明符（例如`d`表示十进制），或者给出一个从值中获取的参数的索引。如果我们不通过索引指定在哪里使用哪个值，它们将按顺序放置。格式说明符与Python的非常相似。如果我们请求一个使用`d`格式说明符的数字，但传递了一个字符串'
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: we would get a compiler error, making `format` safer to use than `printf`. For
    numbers, we might want a plus or minus signs shown, so we can indicate that after
    the colon by using `{:+d}`. If we don’t specify it, we get the default of a minus
    sign for negative numbers and no sign otherwise. After the colon, we say if we
    want decimal `(d)`, binary `(b)`, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用错误的格式，将会得到编译器错误，这使得`format`比`printf`更安全使用。对于数字，我们可能希望显示正负号，因此可以通过使用`{:+d}`在冒号后表示。如果我们不指定，默认情况下负数将显示负号，而正数则不显示符号。冒号之后，我们可以说我们想要十进制`(d)`、二进制`(b)`等等。
- en: Looking back at figure 2.5, the largest number in the last row is 6435\. Because
    our numbers are therefore no more than four digits long, we can center each element
    in a block of six, giving at least one space on each side. The specifier for center
    is `^`, for left is `<`, and for right is `>`, so we format the elements using
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾图 2.5，最后一行的最大数字是 6435。因为我们的数字因此不会超过四位数长，所以我们可以将每个元素放在一个六位的块中，每边至少留一个空格。居中对齐的指定符是
    `^`，左对齐是 `<`，右对齐是 `>`，所以我们使用以下方式格式化元素
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice the placeholder `{}` with a colon. We aren’t using an index, so put
    nothing before the colon. We then have " `^6`", meaning pad with spaces to a length
    of 6, and center the value. In fact, we could vary the length by adding more curly
    braces inside the placeholder to send the 6 to, inside the placeholder, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意冒号后面的占位符 `{}`。我们不使用索引，所以在冒号前面不要放任何内容。然后我们有 " `^6`"，这意味着用空格填充到长度为 6，并居中对齐值。实际上，我们可以在占位符内部添加更多的花括号来改变长度，将
    6 传递到占位符内部，如下所示：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This gives us a *nested replacement field*. This way, we can calculate how much
    space each number needs. We will not do that here, but take time to experiment
    with `format`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个 *嵌套替换字段*。这样，我们可以计算每个数字需要多少空间。我们在这里不会做这件事，但花时间实验 `format`。
- en: We also need spaces at the start of each row to get a symmetric triangle. If
    we work out how long the last row is, we can halve its length to determine where
    to put the 1 from the first row. Let’s think this through for a couple of rows.
    We noted that the largest number on the last row is 6435, and it has four digits.
    If we add a space on each side, we need a block of six for each number. The second
    row will require two blocks of 6, giving twelve characters. To place our first
    number in the middle, we need three spaces at the start to make the first block
    sit on the two numbers in the next row. Because we told `format` to center the
    values, the first one will be in the middle of that block. Figure 2.6 shows this
    for the first two rows, using `1234` to indicate any four digits.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在每行的开头留空格以获得对称的三角形。如果我们计算出最后一行的长度，我们可以将其长度减半以确定放置第一行 1 的位置。让我们先思考几行。我们注意到最后一行的最大数字是
    6435，它有四个数字。如果我们每边都加一个空格，我们需要为每个数字一个六位的块。第二行将需要两个六位块，共十二个字符。为了将我们的第一个数字放在中间，我们需要在开头留三个空格，使第一个块位于下一行的两个数字上。因为我们告诉
    `format` 居中对齐值，第一个值将位于该块中间。图 2.6 使用 `1234` 来表示任何四位数，展示了这一点。
- en: '![CH02_F06_Buontempo](../Images/CH02_F06_Buontempo.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F06_Buontempo](../Images/CH02_F06_Buontempo.png)'
- en: Figure 2.6 If we add three spaces at the start of the first row, as indicated
    by the dashes, we can make the triangle more symmetrical.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 如果我们在第一行的开头添加三个空格（如虚线所示），我们可以使三角形更加对称。
- en: Calling `back().size()` on the vector of rows tells us how many blocks of six
    we will use for a final row. To put the first row in the middle, we need three
    spaces per row that we add; thus, we need padding of three times `back().size()`
    initially. For each row, we also shrink our padding by three at each step to make
    the triangle shape.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在行向量上调用 `back().size()` 告诉我们最终行将使用多少个六位块。为了将第一行放在中间，我们需要为每行添加三个空格；因此，我们最初需要
    `back().size()` 的三倍填充。对于每一行，我们也在每一步中将填充减少三个，以形成三角形形状。
- en: Pulling together our format and spaces calculation, we can write the following
    function to display our triangle.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的格式和空格计算结合起来，我们可以编写以下函数来显示我们的三角形。
- en: Listing 2.7 Center-justified output
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 居中对齐输出
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Three spaces per row
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每行三个空格
- en: ❷ Shrinks the spaces by three for each row
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每行减少三个空格
- en: ❸ Center-aligns each number in a block of six
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在六个数字的块中居中对齐每个数字
- en: We can then call our new function instead of our previous operator in the `main`
    function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `main` 函数中调用我们的新函数而不是之前的操作符。
- en: Listing 2.8 `main` function to generate and display the triangle
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 生成和显示三角形的 `main` 函数
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Swaps the operator << from listing 2.6 to show_vectors
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将列表 2.6 中的操作符 << 替换为 show_vectors
- en: This generates and displays our triangle center-justified, as shown in figure
    2.7\. The output looks about right, but we need to think about how to test our
    results. We will learn more C++ on the way.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '这生成并显示我们的居中对齐三角形，如图 2.7 所示。输出看起来大致正确，但我们需要考虑如何测试我们的结果。我们将在这个过程中学习更多 C++。 '
- en: '![CH02_F07_Buontempo](../Images/CH02_F07_Buontempo.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F07_Buontempo](../Images/CH02_F07_Buontempo.png)'
- en: Figure 2.7 A center-justified triangle
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 一个居中对齐的三角形
- en: 2.3 Properties of the triangle
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 三角形的性质
- en: We have already seen some patterns in the triangle. We know each row starts
    and ends with a 1, so we can start by adding a check for this property. We will
    then consider the number of elements we expect in each row, as well as the sum
    of the elements. Finally, we will see how many rows we can safely generate before
    the numbers get too big to fit into an integer. We will build these properties
    into a suite of tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了三角形的一些模式。我们知道每一行都以 1 开始和结束，所以我们可以先添加一个检查这个属性的检查。然后，我们将考虑每行期望的元素数量以及元素的总和。最后，我们将看到在数字太大而无法放入整数之前，我们可以安全生成多少行。我们将把这些属性构建成一系列测试。
- en: Unfortunately, C++ does not come with a testing framework. Rather than spending
    time setting up and learning such a framework, we will use the `assert` function
    defined in the `cassert` header. The letter `c` at the start tells us we are pulling
    in code from the C standard library. `assert` is a macro, so the preprocessor
    copies the contents verbatim. It will abort our program if the expression in the
    assertion is false. Some setups only use the `assert` in a debug build by determining
    whether the `NDEBUG` macro is defined. Without it, the assertions do something,
    but if `NDEBUG` is defined, they do nothing. Check your setup. The simplest way
    is to check whether `assert(0)` halts the program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++ 并没有自带测试框架。我们不会花时间设置和学习这样的框架，而是将使用在 `cassert` 头文件中定义的 `assert` 函数。开头的字母
    `c` 告诉我们我们正在从 C 标准库中引入代码。`assert` 是一个宏，因此预处理器会逐字复制其内容。如果断言中的表达式为假，它将终止我们的程序。某些设置只在使用
    `NDEBUG` 宏定义的情况下在调试构建中使用 `assert`。如果没有它，断言会做些事情，但如果 `NDEBUG` 被定义，它们就什么都不做。检查你的设置。最简单的方法是检查
    `assert(0)` 是否会终止程序。
- en: Listing 2.9 Starting with a failing test
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 从失败的测试开始
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Forces an assertion failure on line 5
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在第 5 行强制断言失败
- en: ❷ Calls function with empty vector
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用带有空向量的函数
- en: Using g++ in Ubuntu on the WSL, we see the message `Aborted` along with a line
    number, function name, and the message
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 的 WSL 上使用 g++，我们看到消息 `Aborted` 以及行号、函数名和消息
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we run this from Visual Studio, we get a dialog box, with details including
    the line number where the assertion failed. Beginning with a failing test is a
    good way to start testing code. At the very least, it proves we will get some
    feedback if an assertion fails. This means we are ready to test our triangle generation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 Visual Studio 运行它，我们会得到一个对话框，其中包含包括断言失败的行号在内的详细信息。从失败的测试开始是开始测试代码的好方法。至少，它证明了如果断言失败，我们会得到一些反馈。这意味着我们已经准备好测试我们的三角形生成。
- en: Note Using `assert` and checking properties from `main` is a pragmatic way to
    start testing; however, it’s worth taking time to learn a proper unit-testing
    framework. Several C++ testing frameworks, including Catch2, Google Test, and
    Boost, are available.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用 `assert` 和从 `main` 中检查属性是一种实用的开始测试的方法；然而，花时间学习一个合适的单元测试框架是值得的。有几个 C++
    测试框架可用，包括 Catch2、Google Test 和 Boost。
- en: Now we have a function to add properties to. Remove the `assert(0)`, and we
    are ready to add properties to check whether we have the right numbers in our
    triangle.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以添加属性的函数。移除 `assert(0)`，我们就可以添加属性来检查我们的三角形中是否有正确的数字了。
- en: 2.3.1 Checking the first and last elements of each row
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 检查每行的第一个和最后一个元素
- en: We know the first and last numbers in each row must be 1, so we will test that
    first. We need to add two assertions to our `properties` function to test our
    expectations, passing in the rows as in the following listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道每行的第一个和最后一个数字必须是 1，所以我们将首先测试这一点。我们需要向我们的 `properties` 函数添加两个断言来测试我们的预期，如下所示。
- en: Listing 2.10 Ensuring the first and last elements are 1
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 确保第一个和最后一个元素是 1
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Includes the assert marco
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含 assert 宏
- en: ❷ A new function taking the triangle as a constant reference
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个接受三角形作为常量引用的新函数
- en: ❸ Uses a range-based for loop to check each row
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用基于范围的 for 循环来检查每一行
- en: ❹ Checks whether the first element is 1
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查第一个元素是否为 1
- en: ❺ Checks whether the last element is 1
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查最后一个元素是否为 1
- en: 'We can call this from `main` after we have generated the triangle. Our single
    test was successful, so we are ready to add more. Be warned: because a failing
    assert calls `abort`, if one thing fails, we will not check any further properties.
    You can avoid this by stacking up failure messages and asserting the error messages
    are empty. Try this out, or even better, try to write the tests in a proper framework.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以在生成三角形后从 `main` 中调用这个函数。我们的单个测试是成功的，所以我们准备添加更多。警告：因为失败的 `assert` 会调用 `abort`，如果有一件事失败，我们将不会检查其他属性。你可以通过堆叠失败消息并断言错误消息为空来避免这种情况。尝试一下，或者更好的是，尝试在一个合适的框架中编写测试。 '
- en: 2.3.2 Checking the number of elements in each row
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 检查每行的元素数量
- en: Pascal’s triangle has several other properties. The *n*-th row has *n* numbers.
    Why? We know the first row is a solitary 1\. The second row is two 1s. The third
    starts with 1, then sums the 1s from the previous row to get the number 2, then
    has another 1 at the end, giving us three numbers. There are four numbers in the
    fourth row, and this pattern continues. Look back at the triangle in figure 2.5
    if you are not convinced. We can add another `assert` to check this if we keep
    track of the row number.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 帕斯卡三角形的其他属性。第 *n* 行有 *n* 个数字。为什么？我们知道第一行是一个单独的 1。第二行是两个 1。第三行以 1 开始，然后从上一行累加
    1 来得到数字 2，然后行尾再有一个 1，这样我们就有了三个数字。第四行有四个数字，这个模式继续。如果你还不确定，请回顾图 2.5 中的三角形。如果我们跟踪行号，我们可以添加另一个
    `assert` 来检查这个属性。
- en: Listing 2.11 Ensuring each row has the expected number of elements
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 确保每行具有预期的元素数量
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Tracks the row number with a variable
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用变量跟踪行号
- en: ❷ Checks whether each row has the expected size
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查每行是否具有预期的尺寸
- en: We should now check the contents. If we check each entry, we need to find another
    way to generate each number in the row; otherwise, we will duplicate the code
    we are trying to test. This trap is all too easy to fall into, and trying to think
    in terms of properties can help us avoid such problems.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该检查内容。如果我们检查每个条目，我们需要找到另一种方法来生成行中的每个数字；否则，我们将重复我们试图测试的代码。这个陷阱很容易陷入，而尝试从属性的角度思考可以帮助我们避免这样的问题。
- en: 2.3.3 Checking the sum of the elements in a row
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 检查行中元素的总和
- en: The sum of the numbers in each row also follows a pattern. Table 2.1 demonstrates
    that these are powers of 2, starting with 0\. Remember, anything to the power
    of 0 is 1\. This gives us another property to check.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每行数字的总和也遵循一个模式。表 2.1 展示了这些是 2 的幂，从 0 开始。记住，任何数的 0 次幂都是 1。这给我们提供了另一个要检查的属性。
- en: Table 2.1 The sum of the numbers in each row of the triangle is a power of 2.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 三角形每行数字之和是 2 的幂。
- en: '| Row numbers | Sum | Power of 2 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 行号 | 和 | 2 的幂 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: '| 1+1 | 2 | 1 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 1+1 | 2 | 1 |'
- en: '| 1+2+1 | 4 | 2 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 1+2+1 | 4 | 2 |'
- en: '| 1+3+3+1 | 8 | 3 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 1+3+3+1 | 8 | 3 |'
- en: '| 1+4+6+4+1 | 16 | 4 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 1+4+6+4+1 | 16 | 4 |'
- en: 'We need to find the sum for the numbers in each row to check this property.
    Rather than writing out a `for` loop, we can use the *standard template library*
    (STL). Herb Sutter and Andrei Alexandrescu suggested preferring algorithm calls
    to handwritten loops in their book *C++ Coding Standard: 101 Rules, Guidelines
    and Best Practices* (Addison-Wesley Professional, 2004). The STL also contains
    many algorithms for use with generic containers, including an `accumulate` method
    that lives in the `numeric` header, which is exactly what we need. We noted earlier
    that some algorithms support ranges, but some, including `accumulate`, do not.
    We, therefore, need to explicitly find `begin` and `end` ourselves.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到每行数字的总和来检查这个属性。而不是编写一个 `for` 循环，我们可以使用 *标准模板库* (STL)。Herb Sutter 和 Andrei
    Alexandrescu 在他们的书 *C++ 编程标准：101 条规则、指南和最佳实践*（Addison-Wesley Professional，2004
    年）中建议优先使用算法调用而不是手写循环。STL 还包含许多用于泛型容器的算法，包括位于 `numeric` 头文件中的 `accumulate` 方法，这正是我们所需要的。我们之前提到，一些算法支持范围，但一些，包括
    `accumulate`，则不支持。因此，我们需要显式地找到 `begin` 和 `end`。
- en: The `accumulate` function has two versions. They both take a first and last
    iterator of some range or container, along with an initial value. The first version
    applies the `operator+` to each element and the current accumulation value, starting
    with the provided initial value. If we use an initial value of 0, we will obtain
    the sum of all the elements, which is exactly what we need. The second version
    allows us to provide our own *binary* operator. That can be any function taking
    two arguments. The first argument starts with the given initial value, so it must
    be of the same type, or the initial value must be convertible to the type of this
    parameter. The second parameter takes the values from the iterator; thus, it also
    needs to be of a suitable type. CppReference ([http://mng.bz/yZGp](http://mng.bz/yZGp))
    gives full details, including the signatures. For the first version, which we
    will use, we have
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate`函数有两个版本。它们都接受某个范围或容器的第一个和最后一个迭代器，以及一个初始值。第一个版本将`operator+`应用于每个元素和当前的累积值，从提供的初始值开始。如果我们使用初始值0，我们将获得所有元素的总和，这正是我们所需要的。第二个版本允许我们提供自己的*二元*运算符。这可以是任何接受两个参数的函数。第一个参数从给定的初始值开始，因此它必须是相同类型，或者初始值必须可以转换为该参数的类型。第二个参数接受迭代器的值；因此，它也需要是合适的类型。CppReference
    ([http://mng.bz/yZGp](http://mng.bz/yZGp))提供了完整的详细信息，包括签名。对于我们将使用的第一个版本，我们有'
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice the initial value, `init`, has type T. So does the return value. If
    we use an `int`, we will get an `int` back, even for a container of doubles. Our
    container has `ints`, so we are fine, but we would need to use `0.0` if we were
    to use doubles. The `accumulate` function is very flexible. The second version
    takes a binary operator:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意初始值`init`的类型为T。返回值也是。如果我们使用`int`，即使是双精度容器的返回值也将是`int`。我们的容器有`ints`，所以我们没问题，但如果我们使用双精度，我们需要使用`0.0`。`accumulate`函数非常灵活。第二个版本接受一个二元运算符：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We could use `operator*` to find the product of all our numbers, provided we
    start with an initial value of 1\. The more general second form is sometimes called
    a *left fold*. If you want to revise algorithms, looking through what is in the
    `algorithm` and `numeric` headers is a good starting point.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`operator*`来找到所有数字的乘积，前提是我们从初始值1开始。更通用的第二种形式有时被称为*左折叠*。如果你想复习算法，查看`algorithm`和`numeric`头文件是一个好的起点。
- en: Now we can include the check for the sum of the rows in our property test function.
    Starting with an expected total of 1 and doubling each time, we can check that
    the sum of a row is the power of 2 we expect. Adding the expected total to our
    properties function and using the accumulate function, along with the `numeric`
    header, we have the following new check.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将检查行总和的检查包含到我们的属性测试函数中。从预期的总起始值1开始，每次翻倍，我们可以检查行的总和是否是我们预期的2的幂。将预期的总数添加到我们的属性函数中，并使用`accumulate`函数以及`numeric`头文件，我们得到以下新的检查。
- en: Listing 2.12 Ensuring each row has the expected sum of elements
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 确保每一行都有预期的元素总和
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Our expected total starts at 1.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们预期的总起始值为1。
- en: ❷ Checks the total
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查总数
- en: ❸ The expected total doubles with each iteration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 随着每次迭代，预期的总数翻倍。
- en: If we run our code, all the assertions pass. These properties do not prove we
    are correct, but they do give us some confidence in the generation code. We will
    now look at one final property of the triangle and then round off with another
    pattern, just for fun. Again, we will practice more C++ on the way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的代码，所有的断言都通过了。这些属性并不能证明我们是正确的，但它们确实给了我们对生成代码的一些信心。现在我们将看看三角形的一个最终属性，然后以另一个模式结束，只是为了好玩。同样，我们将在路上练习更多的C++。
- en: 2.3.4 How many rows can we generate correctly?
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 我们可以正确生成多少行？
- en: 'As each number is the sum of two previous numbers and we started with positive
    numbers, we should never get negative numbers. To the uninitiated and mathematicians,
    adding positive numbers should always give positive numbers. However, numbers
    do surprising and sometimes annoying things on computers, such as overflowing.
    We will start by setting up a test and then see if we can break it. If we keep
    adding `ints`, we will eventually overflow the maximum possible size. The standard
    tells us this is undefined behavior:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个数字都是两个前一个数字的和，并且我们开始时使用的是正数，所以我们永远不会得到负数。对于初学者和数学家来说，添加正数应该总是得到正数。然而，数字在计算机上有时会做一些令人惊讶的，有时令人烦恼的事情，比如溢出。我们将先设置一个测试，然后看看我们是否能破坏它。如果我们继续添加`ints`，我们最终会超出可能的最大大小。标准告诉我们这是未定义的行为：
- en: If during the evaluation of an expression, the result is not mathematically
    defined or not in the range of representable values for its type, the behavior
    is undefined. ([https://eel.is/c++draft/expr](https://eel.is/c++draft/expr))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在表达式的评估过程中，结果在数学上未定义或不在其类型的可表示值范围内，则行为是未定义的。（[https://eel.is/c++draft/expr](https://eel.is/c++draft/expr)）
- en: We could do some mathematics to find the maximum number of rows we can fit into
    our chosen numeric type. However, if we see what happens when we try to keep adding
    rows, we can learn some more C++ on the way. Although we are relying on undefined
    behavior, in Visual Studio, an integer wraps around so we can find the maximum
    number of rows we can safely generate.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一些数学计算来找出我们选择的数值类型能够容纳的最大行数。然而，如果我们观察当我们尝试不断添加行时会发生什么，我们可以在路上学习更多关于C++的知识。尽管我们依赖于未定义的行为，但在Visual
    Studio中，整数会环绕，这样我们就可以找到我们可以安全生成的最大行数。
- en: There are various ways to check that the values are not negative. We can check
    whether every number is positive or try to find any negative numbers. We could
    write our checks in a `for` loop, but we will heed the advice to use algorithms
    where we can. In fact, we will try a few approaches, getting a bit more practice
    with algorithms, and we will learn more about ranges too.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以检查值不是负数。我们可以检查每个数字是否为正，或者尝试找到任何负数。我们可以将检查写入`for`循环中，但我们将遵循在可能的情况下使用算法的建议。实际上，我们将尝试几种方法，以获得更多关于算法的实践，并且我们将更多地了解范围。
- en: The `algorithm` header provides several *non-modifying sequence* operations.
    Many of these find or search for elements. We can use `all_of` to check that all
    elements are positive. We could also use either `none_of` or `any_of`, which do
    what we might expect. All three take a *unary predicate*, which is a function
    that takes a value and returns a `bool.` The values come from a container or range.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`algorithm`头文件提供了几个*非修改序列*操作。其中许多用于查找或搜索元素。我们可以使用`all_of`来检查所有元素都是正数。我们也可以使用`none_of`或`any_of`，它们做我们可能期望的事情。所有三个都接受一个*一元谓词*，这是一个接受一个值并返回`bool`的函数。值来自容器或范围。'
- en: 'We want to check that all our numbers are greater than zero. This seems more
    positive than saying none of them are negative. We could write a function, but
    we can also use an anonymous function, known as a *lambda*. The syntax looks very
    much like a normal function, but it has no name and has a *capture list* at the
    start indicated by square brackets:`[]`. This allows us to capture local variables
    by reference or as a copy. We would say `[&]` to capture anything used in the
    body of the lambda expression by reference, and `[=]` to capture anything used
    by value. We could also specify specific variables by saying `[=,` `&x]`, so that
    `x` is captured as a reference, and anything else is captured by value. We could
    also explicitly name `y` as captured by value, in which case, we do not need the
    equals sign: `[y,` `&x]`. We don’t need to capture anything in our case. We only
    need to check whether any integer is greater than or equal to zero:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要检查所有的数字都大于零。这比说它们都不是负数更积极。我们可以编写一个函数，但我们也可以使用匿名函数，也就是所谓的*lambda*。其语法看起来非常像正常函数，但它没有名字，并且在开头有一个由方括号`[]`表示的*捕获列表*。这允许我们通过引用或作为副本捕获局部变量。我们会说`[&]`来通过引用捕获lambda表达式体中使用的任何内容，而`[=]`来捕获通过值使用的任何内容。我们也可以通过指定特定的变量来说明`[=,`
    `&x]`，这样`x`就被捕获为引用，而其他任何内容都是通过值捕获。我们也可以显式地将`y`命名为通过值捕获，在这种情况下，我们不需要等号：`[y,` `&x]`。在我们的情况下，我们不需要捕获任何内容。我们只需要检查是否有任何整数大于或等于零：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A named function would look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数看起来会是这样：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The syntax for each is similar, with a parameter list and the body in curly
    braces. The named function must specify a return type. The lambda can use a trailing
    return type, which we saw in chapter 1, but the return type is deduced if none
    is provided. Lambda expressions construct *closures*, borrowing a term from functional
    programming. We will look at this in more detail in the next chapter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个的语法都很相似，都有一个参数列表和花括号中的主体。命名函数必须指定一个返回类型。lambda可以使用尾随返回类型，这在第1章中我们已经看到，但如果未提供，则返回类型会被推导。lambda表达式构建*闭包*，这是一个从函数式编程中借用的术语。我们将在下一章中更详细地探讨这一点。
- en: 'We use our lambda in `std::all_of` like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像这样在`std::all_of`中使用我们的lambda：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using a named function is absolutely fine too, but for small functions, it
    can be easier to see what is happening if everything is in one place. Now, we
    have explicitly stated `int` as the parameter type. We know our `vector` contains
    integers. However, we were told to almost always use `auto` earlier, and we can
    do that here too:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名函数绝对没问题，但对于小型函数，如果所有内容都在一个地方，可能会更容易看到正在发生的事情。现在，我们明确声明了 `int` 作为参数类型。我们知道我们的
    `vector` 包含整数。然而，我们之前被告知几乎总是使用 `auto`，我们也可以在这里这样做：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we were to change the type contained in the vector, we wouldn’t need to
    change this code as well. In fact, we can also use a range to check all the rows
    like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要更改向量中包含的类型，我们也不需要更改此代码。实际上，我们还可以使用一个范围来检查所有行，如下所示：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’ve used a range-based `for` loop several times now and used `ranges::copy`
    in listing 2.5 to send a row to the screen. We know some of the standard algorithms,
    such as `all_of`, have a `ranges` equivalent, although not all of the algorithms
    have equivalents. Where they do exist, they save us from typing out `begin` and
    `end`. Ranges offer far more, though. Containers and algorithms are a part of
    the STL. The two abstractions are useful but rely on iterators. Writing your own
    can be cumbersome, and if you want to compose algorithms, you need to track where
    the end is after each call. Notoriously, the `remove_if` algorithm does not remove
    anything. Instead, it shunts the elements you do not want removed to the start
    of the collection and returns an iterator to the first of the unneeded elements,
    which you can use instead of `end` if you want to do something further without
    these elements. The following code shows what happens if we forget to track the
    new end.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用基于范围的 `for` 循环，并在列表 2.5 中使用 `ranges::copy` 将一行发送到屏幕。我们知道一些标准算法，如 `all_of`，有一个
    `ranges` 等价物，尽管并非所有算法都有等价物。当它们存在时，它们可以节省我们输入 `begin` 和 `end`。范围提供了更多。容器和算法是 STL
    的一部分。这两个抽象很有用，但依赖于迭代器。编写自己的可能会很麻烦，如果你想要组合算法，你需要跟踪每次调用后的结束位置。臭名昭著的，`remove_if`
    算法不会移除任何东西。相反，它将你不想移除的元素推送到集合的开始处，并返回一个指向第一个不需要的元素的迭代器，如果你想在没有这些元素的情况下做进一步的操作，你可以使用这个迭代器代替
    `end`。以下代码显示了如果我们忘记跟踪新的结束点会发生什么。
- en: Listing 2.13 Using `remove_if`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.13 使用 `remove_if`
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Removes elements less than 3
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 移除小于 3 的元素
- en: ❷ Displays the whole container
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示整个容器
- en: ❸ Using the new end
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用新的结束点
- en: ❹ Dereferences the iterator with * to get each element
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 * 解引用迭代器以获取每个元素
- en: The first loop prints out `3,` `4,` `5,` `3,` `4,` `5` in Visual Studio because
    the elements less than 3 have been removed. Other compilers might give different
    results. However, we now have three elements beyond the new end. The second loop
    displays `3,` `4,` `5` as required. Things get out of hand quickly if you need
    to filter and transform several times over.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环在 Visual Studio 中打印出 `3,` `4,` `5,` `3,` `4,` `5`，因为小于 3 的元素已经被移除。其他编译器可能会给出不同的结果。然而，我们现在有三个元素超过了新的结束点。第二个循环按要求显示了
    `3,` `4,` `5`。如果你需要多次过滤和转换，事情会很快变得失控。
- en: 'Ranges avoid this problem. They allow us to take a read-only `view` of a container
    and filter or transform the elements in the view, without needing to keep track
    of iterators. We can access the `ranges` view using `std::view`. This is a convenient
    shorthand for `std::ranges::views`, defined in the `ranges` header. If we want
    to skip over initial elements less than 3, we can use `drop_while`, which may
    be familiar from various other programming languages:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 范围避免了这个问题。它们允许我们获取容器的只读 `视图` 并在视图中过滤或转换元素，而无需跟踪迭代器。我们可以使用 `std::view` 访问 `ranges`
    视图。这是一个方便的缩写，表示 `std::ranges::views`，它在 `ranges` 头文件中定义。如果我们想跳过小于 3 的初始元素，我们可以使用
    `drop_while`，这在各种其他编程语言中可能很熟悉：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If your compiler does not support ranges yet, try this out on the Compiler
    Explorer ([https://godbolt.org/z/YrnsTGbfx](https://godbolt.org/z/YrnsTGbfx)).
    We can also use the pipe character `''|''` to apply `drop_while` to our container.
    The pipe character is an operator allowing us to chain together multiple algorithms,
    which is neat and powerful. If we want to compose several views, the first approach
    would end up with several calls nested deeply inside brackets, whereas separating
    the steps with the pipe operator makes code easier to read. You may be familiar
    with the pipe characters used in Unix to send the output from one command to another.
    We only want one filter for this example. We can rewrite the version sending the
    vector to the `drop_while` function using the pipe operator like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的编译器还不支持范围，请在编译器探索器([https://godbolt.org/z/YrnsTGbfx](https://godbolt.org/z/YrnsTGbfx))上尝试。我们还可以使用管道字符`'|'`将`drop_while`应用于我们的容器。管道字符是一个运算符，允许我们将多个算法链接在一起，这既方便又强大。如果我们想组合几个视图，第一种方法最终会在括号内嵌套多个调用，而使用管道运算符分隔步骤会使代码更容易阅读。你可能熟悉Unix中用于将一个命令的输出发送到另一个命令的管道字符。我们只想为这个例子设置一个过滤器。我们可以使用管道运算符重写将向量发送到`drop_while`函数的版本，如下所示：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we run it, we see `3,` `4,` `5` without having to concentrate on remembering
    which iterator is pointing where.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们会看到`3,` `4,` `5`，而无需集中精力记住哪个迭代器指向哪里。
- en: We can use views to make sure that we have no negative numbers in our triangle’s
    rows. Rather than skipping initial elements using `drop_while`, we want to filter
    out any negative numbers, so we use the `filter` function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用视图确保我们的三角形行中没有负数。而不是使用`drop_while`跳过初始元素，我们想要过滤掉任何负数，所以我们使用`filter`函数。
- en: Listing 2.14 Making sure there are no negative numbers by using a view
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 通过使用视图确保没有负数
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ A predicate to determine whether a number is negative
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个谓词，用于确定一个数字是否为负
- en: ❷ Filters the row for negative numbers
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 过滤行以获取负数
- en: ❸ Checks whether negatives is empty
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查负数是否为空
- en: As with the `drop_while` example, we have the form
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与`drop_while`示例一样，我们有以下形式
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: which gives us a view of our container.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够看到我们的容器视图。
- en: 'We can add this check to our tests for negative numbers. Everything is fine
    if we stick with generating 16 rows. If we try 35 rows, however, the assertion
    fails. When we learned how to generate rows in the triangle, we noted that we
    would run out of numbers eventually. We found our largest possible entry using
    `std::numeric_limits<int> ::max()`, which is likely to be 2,147,483,647, depending
    on your compiler. The maximum value in the 34^(th) row is 1,166,803,110\. We then
    get double this amount in the next row because we add adjacent values, which would
    give 2,333,606,220\. This number overflows an `int`, and the behavior is undefined
    by the standard as we saw. On some systems, this wraps around to the minimum value,
    -2147483648, and then counts up again. That is why our test fails. An unsigned
    would give us more space: it would still wrap around after 4,294,967,295, but
    to 0\. This would make the error harder to spot.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此检查添加到我们的负数测试中。如果我们坚持生成16行，一切都会正常。然而，如果我们尝试35行，断言就会失败。当我们学习如何生成三角形的行时，我们注意到我们最终会耗尽数字。我们使用`std::numeric_limits<int>::max()`找到了可能的最大条目，这可能是2,147,483,647，具体取决于您的编译器。第34行的最大值是1,166,803,110。然后我们在下一行得到双倍的数量，因为我们添加了相邻的值，这将给出2,333,606,220。这个数字超出了`int`的范围，并且按照标准，其行为是未定义的，正如我们所看到的。在某些系统上，这个值会回绕到最小值-2147483648，然后再次计数。这就是为什么我们的测试失败的原因。无符号整数会给我们更多的空间：它会在4,294,967,295之后再次回绕，但回绕到0。这将使错误更难被发现。
- en: The core guidelines tell us we should not try to avoid negative values by using
    `unsigned` ([http://mng.bz/M9VQ](http://mng.bz/M9VQ)). We can assign a negative
    value to an unsigned, for example, `unsigned` `int` `u1` `=` `-2`. Annoyingly,
    this compiles and gives us a large positive number. With a signed integer, we
    can check that the value is not negative. With an unsigned integer, we cannot
    check anymore. We know how many rows we can safely generate. Let’s test one final
    property of the triangle.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 核心指南告诉我们，我们不应该通过使用`unsigned`来尝试避免负值([http://mng.bz/M9VQ](http://mng.bz/M9VQ))。例如，我们可以将一个负值赋给一个`unsigned`，比如`unsigned
    int u1 = -2`。令人烦恼的是，这会编译并给我们一个很大的正数。对于有符号整数，我们可以检查该值是否不是负数。对于无符号整数，我们不能再进行检查了。我们知道我们可以安全生成多少行。让我们测试三角形的最后一个属性。
- en: 2.3.5 Checking whether each row is symmetric
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 检查每一行是否对称
- en: Every row is symmetric. The first and last numbers are both 1s, which is symmetric,
    and we checked this. We can go further and check all the entries for symmetry.
    This is like checking that a word is a palindrome, meaning that it reads the same
    backward as forward. CppReference uses checking for palindromes as an example
    of ranges’ `equal` method ([http://mng.bz/amej](http://mng.bz/amej)). We can repurpose
    this to check our vector. We need to make sure that the first half of a row matches
    the second half reversed. Ranges provide a view of a container. Views have a `take`
    method, which walks over as many elements as we ask for. We need the first half,
    that is, `v.size()/2`. We compare this with the second half, reversed, using `ranges`::`equal`
    method.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都是对称的。第一个和最后一个数字都是1，这是对称的，我们已经检查了这一点。我们可以进一步检查所有条目是否对称。这就像检查一个单词是否是回文一样，意味着它读起来前后一样。CppReference将检查回文作为ranges的`equal`方法的示例([http://mng.bz/amej](http://mng.bz/amej))。我们可以重新利用这个来检查我们的向量。我们需要确保行的前半部分与后半部分反转后匹配。Ranges提供了一个容器的视图。视图有一个`take`方法，它遍历我们请求的元素数量。我们需要前半部分，即`v.size()/2`。我们使用`ranges`::`equal`方法将这个与反转的后半部分进行比较。
- en: Listing 2.15 Checking for symmetry
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 检查对称性
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ A forward view of the first half
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 前半部分的正向视图
- en: ❷ A reversed view
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 反转视图
- en: ❸ Using the second half, chained with |
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用后半部分，通过|连接
- en: ❹ Checking whether these are equal
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查这些是否相等
- en: 'Note that we have chained together views with the pipe operator and do not
    need to focus on which iterators are needed where. We can add one final assertion
    to our tests using the palindrome function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经使用管道操作符将视图连接在一起，不需要关注哪些迭代器在哪里需要。我们可以使用回文函数添加一个最终的断言到我们的测试中：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We now have a useful set of tests and have used a handful of methods in the
    ranges’ library. There are many other patterns in the triangle, but as this chapter
    is nearly done, we will only look at one more pattern to pull together what we’ve
    learned.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一套有用的测试，并使用了`ranges`库中的一系列方法。三角形中还有许多其他模式，但由于本章即将结束，我们只会再查看一个模式来总结我们所学的内容。
- en: 2.3.6 Highlighting odd numbers in a row
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 在一行中突出显示奇数
- en: 'If we highlight the odd numbers in the triangle, we will see another pattern.
    Looking back at our code to show the triangle in listing 2.7, we can transform
    each row before we print it using another tool from the `ranges` library. Every
    odd number is one more than a multiple of two, so we can check `x` `%` `2` to
    find odd numbers. We will display them with a star to see the pattern. Otherwise,
    we display a single space. We will use the view’s transform method to apply action
    to each row:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在三角形中突出显示奇数，我们会看到另一种模式。回顾我们的代码，在列表2.7中显示三角形，我们可以在打印之前使用`ranges`库中的另一个工具来转换每一行。每个奇数都是两个的倍数加一，因此我们可以通过检查`x`
    `%` `2`来找到奇数。我们将用星号显示它们以查看模式。否则，我们显示一个空格。我们将使用视图的转换方法来对每一行应用操作：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can use our transformation code to give something similar to listing 2.7,
    where we showed the actual values in the triangle. Figure 2.8 illustrates the
    resulting pattern.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的转换代码来给出类似于列表2.7的内容，其中我们显示了三角形中的实际值。图2.8展示了产生的模式。
- en: '![CH02_F08_Buontempo](../Images/CH02_F08_Buontempo.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F08_Buontempo](../Images/CH02_F08_Buontempo.png)'
- en: Figure 2.8 An approximation to the Sierpinski triangle obtained by printing
    an * for an odd number and a blank space for an even number
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 通过打印奇数个*和偶数个空白空间得到的Sierpinski三角形的近似
- en: Listing 2.16 Showing odd numbers as stars
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 显示奇数用星号表示
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We expected the symmetry. The repeating triangles might be a nice surprise.
    This approximates the Sierpinski triangle, which is a triangle shape recursively
    divided into smaller triangles. If we made an equilateral triangle, folded the
    corners over each other, and drew lines where we made the folds, we would get
    the blank triangle in the middle of figure 2.6, along with a triangle at the top,
    one on the bottom left, and one on the bottom right. We can then do the same with
    the three triangles on the corners. This triangle is fractal because it repeats
    as you zoom in. We could keep dividing up the triangles forever in theory, showing
    this fractal property. We could also try out even numbers instead or a different
    modulus, and we would see other patterns.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预期会有对称性。重复的三角形可能是一个令人惊喜的发现。这近似于Sierpinski三角形，它是一个递归地分成更小三角形的三角形形状。如果我们画一个等边三角形，将角折叠在一起，并在折叠处画线，我们就会得到图2.6中间的空白三角形，以及顶部的三角形，左下角的三角形和右下角的三角形。然后我们可以对角落上的三个三角形做同样的处理。这个三角形是分形的，因为当你放大时它会重复。理论上我们可以永远地分割三角形，展示这种分形特性。我们也可以尝试使用偶数或者不同的模数，我们会看到其他模式。
- en: In this chapter, we have learned a fair bit about how to use vectors. We have
    not covered everything, but we have done enough to recognize various C++ features
    and test our code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于如何使用向量的知识。我们没有涵盖所有内容，但我们已经做了足够的练习，以识别各种C++特性和测试我们的代码。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Containers are part of the STL, and the compiler can sometimes deduce the type
    of expressions for us.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是STL的一部分，编译器有时可以为我们推导表达式的类型。
- en: We can initialize objects using an initializer list `{value1,` `value2,` `...}`
    when we want to provide values directly.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想直接提供值时，可以使用初始化列表`{value1, value2, ...}`来初始化对象。
- en: We can use `emplace_back` or `emplace` when we want to create an object in place
    directly in a container, or `push_back` or insert when we already have an object.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想在容器中直接创建对象时，可以使用`emplace_back`或`emplace`，或者当我们已经有一个对象时，可以使用`push_back`或`insert`。
- en: The range-based `for` loop is a common way to walk over a container, avoiding
    iterators or indices.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于范围的`for`循环是遍历容器的一种常见方式，避免了迭代器或索引的使用。
- en: Use `auto` almost always, including relying on class template argument deduction
    when using containers.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎总是使用`auto`，包括在容器中使用时依赖类模板参数推导。
- en: '`std::move` casts a value to an rvalue, allowing perfect forwarding.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::move`将值转换为右值，允许完美转发。'
- en: Some versions of standard algorithms take `begin` and `end`, while others in
    the `std::ranges` namespace now support ranges.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些标准算法的版本接受`begin`和`end`，而`std::ranges`命名空间中的其他版本现在支持范围。
- en: Views and filters can be chained with the pipe operator.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用管道操作符将视图和过滤器链式连接。
- en: Lambdas are unnamed functions that can capture variables and form closures.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda是未命名的函数，可以捕获变量并形成闭包。
- en: Use `format` to align text or set the width or precision of numbers for speed
    and type safety.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`format`对齐文本或设置数字的宽度或精度，以提高速度和类型安全。
