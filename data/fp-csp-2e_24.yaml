- en: Appendix A. Working with previous version of C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A.使用C#的早期版本
- en: This second edition of the book was written for C# 10 and takes advantage of
    the language’s latest features, given that they’re relevant to FP. If you’re working
    on legacy projects that use previous versions of C#, you can still apply all of
    the ideas discussed in this book. This appendix shows you how.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第二版是为 C# 10编写的，并利用了语言最新的功能，前提是它们与函数式编程相关。如果你正在处理使用 C# 早期版本的遗留项目，你仍然可以应用这本书中讨论的所有想法。本附录向你展示了如何做到这一点。
- en: A.1 Immutable data objects before C# 9
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 C# 9之前的不可变数据对象
- en: 'In the book, I’ve used records and structs for all data objects. Records are
    immutable by default, and structs are copied by value when passed between functions
    so that they too are perceived as being immutable. If you want to work with immutable
    data objects but need to use a version prior to C# 9, you have to rely on one
    of the following options:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我使用了记录和结构体来处理所有数据对象。记录默认是不可变的，结构体在函数间按值复制时也是复制的，因此它们也被视为不可变。如果你想要使用不可变数据对象，但需要使用
    C# 9之前的版本，你必须依赖以下选项之一：
- en: Treat objects as immutable by convention.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按惯例将对象视为不可变。
- en: Manually define immutable objects.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动定义不可变对象。
- en: Use F# for your domain objects.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 F# 作为你的领域对象。
- en: To illustrate each of these strategies, I’ll go back to the task of writing
    an `AccountState` class to represent the state of a bank account in the BOC application.
    We saw this in section 11.3.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些策略中的每一个，我将回到编写 `AccountState` 类的任务，以表示 BOC 应用程序中银行账户的状态。我们在第11.3节中看到了这个。
- en: A.1.1 Immutability by convention
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.1 按惯例的不可变性
- en: Before the introduction of records, C# developers usually defined data objects
    with an empty constructor and property getters and setters. The following listing
    shows how you could model the state of a bank account using this approach.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入记录之前，C# 开发者通常使用空构造函数和属性获取器和设置器来定义数据对象。以下列表展示了如何使用这种方法来模拟银行账户的状态。
- en: Listing A.1 A simple model for the state of a bank account
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.1 银行账户状态的简单模型
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This allows us to create new instances elegantly with the object initializer
    syntax as in the following listing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们以如下列表所示的对象初始化器语法优雅地创建新实例。
- en: Listing A.2 Using the convenient object initializer syntax
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2 使用方便的对象初始化器语法
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates a new account with the `Currency` property set explicitly; other
    properties are initialized to their default values. Note that the object initializer
    syntax calls the parameterless constructor and the public setters defined in `AccountState`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的账户，其中 `Currency` 属性被显式设置；其他属性初始化为它们的默认值。请注意，对象初始化器语法调用无参数构造函数和 `AccountState`
    中定义的公共设置器。
- en: A.1.2 Defining copy methods
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.2 定义复制方法
- en: If we want to represent a change in state, such as if the account is frozen,
    we’ll create a new `AccountState` with the new `Status`. We can do this by adding
    a convenience method on `AccountState` as the following listing shows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要表示状态的变化，例如账户被冻结，我们将创建一个新的 `AccountState`，并带有新的 `Status`。我们可以通过在 `AccountState`
    上添加一个方便的方法来实现，如下列表所示。
- en: Listing A.3 Defining a copy method
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.3 定义复制方法
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The updated field
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更新字段
- en: ❷ All other fields are copied from the current state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所有其他字段都从当前状态复制。
- en: '`WithStatus` is a method that returns a copy of the instance, identical to
    the original in everything except the `Status`, which is as given. This is similar
    to the behavior you get with `AddDays` and similar methods defined on `DateTime`:
    they all return a new instance (see section 11.2.1).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithStatus` 是一个返回实例副本的方法，除了 `Status` 以外，其他方面都与原始实例相同，`Status` 的值如所给。这与使用 `AddDays`
    和在 `DateTime` 上定义的类似方法得到的行为相似：它们都返回一个新的实例（参见第11.2.1节）。'
- en: Methods like `WithStatus` are called *copy methods* or *with-ers* because the
    convention is to name them `With[Property]`. The following listing shows an example
    of calling a copy method to represent a change in the state of the account.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `WithStatus` 这样的方法被称为 *复制方法* 或 *with-ers*，因为惯例是给它们命名为 `With[Property]`。以下列表展示了如何调用一个复制方法来表示账户状态的改变。
- en: Listing A.4 Obtaining a modified version of the object
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.4 获取对象的修改版本
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Copy methods are similar to `with` expressions in records, in that they return
    a copy of the original object, where one property has been updated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 复制方法与记录中的 `with` 表达式类似，因为它们返回原始对象的副本，其中一个属性已被更新。
- en: 'NOTE The cost of representing changes through copy methods is not as high as
    you might think, as already discussed in section 11.3 (specifically in the sidebar
    on “Performance impact of using immutable objects”). This is because a copy method
    like `WithStatus` creates a *shallow copy* of the original: an operation that
    is fast and sufficient to guarantee safety (assuming that all the object’s children
    are immutable as well).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：通过复制方法表示更改的成本并不像你想象的那么高，正如第11.3节中已经讨论的那样（特别是在“使用不可变对象对性能的影响”侧边栏中）。这是因为像`WithStatus`这样的复制方法会创建原始对象的**浅拷贝**：这是一个快速且足以保证安全性的操作（假设对象的所有子对象也都是不可变的）。
- en: A.1.3 Enforcing immutability
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.3 强制不可变性
- en: 'The implementation shown so far uses property setters to initially populate
    an object (section A.1.1) and copy methods to obtain updated versions (section
    A.1.2). This approach is called *immutability by convention*: you use convention
    and discipline to avoid mutation. The setters are exposed, but they should never
    be called after the object has been initialized. But this doesn’t prevent a mischievous
    colleague who’s not sold on immutability from setting the fields directly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所示的实施方案使用属性setter来最初填充对象（A.1.1节）和使用复制方法来获取更新版本（A.1.2节）。这种方法被称为**约定不可变性**：你使用约定和纪律来避免突变。setter是公开的，但它们应该在对象初始化后
    never 被调用。但这并不能阻止一个不认同不可变性的淘气的同事直接设置字段：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you want to prevent such destructive updates, you’ll have to make your object
    immutable by removing property setters altogether. New instances must then be
    populated by passing all values as arguments to the constructor as the following
    listing shows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要防止这种破坏性更新，你必须通过完全移除属性setter来使你的对象不可变。然后，新的实例必须通过将所有值作为参数传递给构造函数来填充，如下列所示。
- en: 'Listing A.5 Refactoring towards immutability: removing all setters'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.5：朝着不可变性重构：移除所有setter
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the constructor, I’ve used named parameters and default values in such a
    way that I can create a new instance with a syntax that is similar to the object
    initializer syntax we were using before. We can now create a new account with
    sensible values like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我使用了命名参数和默认值，这样我就可以使用类似于我们之前使用的对象初始化器语法来创建一个新的实例。现在我们可以用如下方式创建一个新的账户，并赋予其合理的值：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `WithStatus` copy method works just like before. Notice that we’ve now enforced
    that a value must be provided for `Currency`, which isn’t possible when you use
    the object initializer syntax. So we’ve kept readability while making the implementation
    more robust.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithStatus`复制方法与之前一样工作。注意，我们现在强制为`Currency`提供一个值，这在使用对象初始化器语法时是不可能的。因此，我们在保持可读性的同时，使实现更加健壮。'
- en: TIP Forcing the clients of your code to use a constructor or a factory function
    to instantiate an object improves the robustness of your code because you can
    enforce business rules at this point, making it impossible to create an object
    in an invalid state, such as an account with no currency.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：强制你的代码客户端使用构造函数或工厂函数来实例化对象可以提高代码的健壮性，因为你可以在这个点强制执行业务规则，使得无法创建处于无效状态的对象，例如没有货币的账户。
- en: A.1.4 Immutable all the way down
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.4 一直到底的不可变性
- en: 'We’re still not done because for an object to be immutable, all its constituents
    must be immutable too. Here we’re using a mutable `List`, so your mischievous
    colleague could still effectively mutate the account state by writing this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，因为对于一个对象来说，要成为不可变的，它的所有组成部分也必须是不可变的。在这里，我们使用了一个可变的`List`，所以你的淘气的同事仍然可以通过编写以下代码来有效地突变账户状态：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The most effective way to prevent this is to create a copy of the list given
    to the constructor and store its contents in an immutable list. The following
    listing shows how to do this using the `ImmutableList` type in the `System.Collections.Immutable`
    library.[¹](#pgfId-1124916)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种情况最有效的方法是创建构造函数提供的列表的副本，并将内容存储在一个不可变列表中。以下列表显示了如何使用`System.Collections.Immutable`库中的`ImmutableList`类型来完成此操作。[¹](#pgfId-1124916)
- en: Listing A.6 Preventing mutation by using immutable collection
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.6：通过使用不可变集合防止突变
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Marks the class as sealed to prevent mutable subclasses
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将类标记为密封以防止可变子类
- en: ❷ Creates and stores a defensive copy of the given list
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建并存储给定列表的防御性副本
- en: When a new `AccountState` is created, the given list of transactions is copied
    and stored in an `ImmutableList`. This is called a *defensive copy*. Now the list
    of transactions of an `AccountState` can’t be altered by any consumers, and it
    remains unaffected even if the list given in the constructor is altered at a later
    point. Fortunately, `CreateRange` is smart enough that if it’s given an `ImmutableList`,
    it just returns it so that copy methods won’t incur any additional overhead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的`AccountState`时，给定的交易列表会被复制并存储在一个`ImmutableList`中。这被称为*防御性复制*。现在，`AccountState`的交易列表不能被任何消费者更改，即使构造函数中给出的列表在以后被更改，它也不会受到影响。幸运的是，`CreateRange`足够智能，如果它被给定了`ImmutableList`，它就会直接返回它，这样复制方法就不会产生任何额外的开销。
- en: Furthermore, `Transaction` and `Currency` must also be immutable types. I’ve
    also marked `AccountState` as `sealed` to prevent the creation of mutable subclasses.
    Now `AccountState` is truly immutable, at least in theory. In practice, one could
    still mutate an instance using reflection so that your mischievous colleague can
    still have the upper hand.[²](#pgfId-1124944) But at least now there’s no room
    for mutating the object by mistake.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Transaction`和`Currency`也必须是不可变类型。我还将`AccountState`标记为`sealed`以防止创建可变的子类。现在，`AccountState`在理论上确实是不可变的。在实践中，仍然可以通过反射来修改实例，这样你那淘气的同事仍然可以占据上风。[²](#pgfId-1124944)
    但至少现在没有通过错误修改对象的空间了。
- en: How can you add a new transaction to the list? You don’t. You create a new list
    that has the new transaction as well as all existing ones and that will be part
    of a new `AccountState`, as the following listing demonstrates.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将一笔新交易添加到列表中？你不需要这样做。你创建一个新的列表，其中包含新交易以及所有现有交易，并且这个新列表将成为一个新的`AccountState`的一部分，如下面的列表所示。
- en: Listing A.7 Adding an element to a list requires a new parent object
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.7 向列表添加元素需要一个新的父对象
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Includes `Prepend` as an extension method on `IEnumerable`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将`Prepend`作为`IEnumerable`的扩展方法
- en: ❷ A new `IEnumerable` including existing values and the one being added
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含现有值和即将添加的一个新的`IEnumerable`
- en: ❸ All other fields are copied as usual.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 所有其他字段都按常规复制。
- en: Notice that in this particular case, we’re *prepending* the transaction to the
    list. This is domain-specific; in most cases, you’re interested in the latest
    transactions, so it’s most efficient to keep the latest ones at the front of the
    list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个特定的情况下，我们是在列表中*预加*交易。这是特定领域的；在大多数情况下，你感兴趣的是最新的交易，所以最有效的方法是将最新的交易放在列表的前面。
- en: A.1.5 Copy methods without boilerplate?
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.5 无样板复制方法？
- en: 'Now that we’ve managed to properly implement `AccountState` as an immutable
    type, let’s face one of the pain points: *writing copy methods is no fun!* Imagine
    an object with 10 properties, all of which need copy methods. If there are any
    collections, you’ll need to copy them into immutable collections and add copy
    methods that add or remove items from those collections. That’s a lot of boilerplate!'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地将`AccountState`实现为一个不可变类型，让我们面对一个痛点：*编写复制方法并不有趣!* 想象一个有10个属性的对象，所有这些属性都需要复制方法。如果有任何集合，你需要将它们复制到不可变集合中，并添加复制方法来添加或删除这些集合中的项目。这有很多样板代码！
- en: The following listing shows how to mitigate this by including a single `With`
    method with named optional arguments, much like how we used them in the `AccountState`
    constructor in listing A.5.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何通过包含一个带有命名可选参数的单个`With`方法来减轻这种情况，就像我们在列表A.5中的`AccountState`构造函数中使用它们一样。
- en: Listing A.8 A single `With` method that can set any property
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.8 一个可以设置任何属性的单一`With`方法
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ `null` indicates that the field isn’t specified.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `null`表示该字段未指定。
- en: ❷ If no value is specified, uses the current instance’s value
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果未指定值，则使用当前实例的值
- en: ❸ You can prevent arbitrary changes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 你可以防止任意更改。
- en: The default value of `null` indicates that the value hasn’t been specified;
    in which case, the current instance’s value is used to populate the copy. For
    value-type fields, you can use the corresponding nullable type for the argument
    type to allow a default of `null`. Because the default value `null` indicates
    that the field hasn’t been specified, and hence the current value will be used,
    it’s not possible to use this method to set a field to `null`. Given the discussion
    on `null` versus `Option` in section 5.5.1, you can probably see that this isn’t
    a good idea anyway.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 的默认值表示值尚未指定；在这种情况下，将使用当前实例的值来填充复制。对于值类型字段，你可以使用相应的可空类型作为参数类型，以允许 `null`
    作为默认值。因为默认值 `null` 表示字段尚未指定，因此将使用当前值，所以不可能使用此方法将字段设置为 `null`。鉴于第5.5.1节中关于 `null`
    与 `Option` 的讨论，你可能已经看出这并不是一个好主意。'
- en: 'Notice that in listing A.8, we’re only allowing changes to two fields because
    we’re assuming that we can never change the currency of a bank account or make
    arbitrary changes to the transaction history. This approach allows us to reduce
    boilerplate while still retaining fine-grained control over what operations we
    want to allow. The usage is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在列表A.8中，我们只允许更改两个字段，因为我们假设我们永远不能更改银行账户的货币或对交易历史进行任意更改。这种方法使我们能够在保留对想要允许的操作的细粒度控制的同时减少样板代码。使用方法如下：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This not only reads clearly but gives us better performance compared to using
    the classic `With[Property]` methods: if we need to update multiple fields, a
    single new instance is created. I definitely recommend using this single `With`
    method over defining a copy method for every field.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅读起来清晰，而且与使用经典的 `With[Property]` 方法相比，性能更好：如果我们需要更新多个字段，则只创建一个新实例。我强烈推荐使用这个单一的
    `With` 方法，而不是为每个字段定义复制方法。
- en: Another approach is to define a generic helper that does the copying and updating
    without the need for any boilerplate. I’ve implemented such a general-purpose
    `With` method in the `LaYumba.Functional.Immutable` class, and it can be used
    as the following listing shows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是定义一个通用的辅助器，它执行复制和更新而不需要任何样板代码。我在 `LaYumba.Functional.Immutable` 类中实现了一个这样的通用
    `With` 方法，如下所示。
- en: Listing A.9 Using a general-purpose copy method
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.9 使用通用复制方法
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `With` is an extension method on `object` that takes an `Expression` identifying
    the property to be updated and the new value. Using reflection, it then creates
    a bitwise copy of the original object, identifies the backing field of the specified
    property, and sets it to the given value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`With` 是一个在 `object` 上的扩展方法，它接受一个 `Expression` 来标识要更新的属性和新的值。使用反射，它随后创建原始对象的位复制，识别指定属性的备份字段，并将其设置为给定值。
- en: In short, it does what we want—for any field and any type. On the upside, this
    saves us from having to write tedious copy methods. On the downside, reflection
    is relatively slow, and we lose the fine-grained control available when we explicitly
    choose what fields can be updated in `With`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，它做了我们想要的事情——对于任何字段和任何类型。优点是，这使我们免于编写繁琐的复制方法。缺点是，反射相对较慢，并且当我们显式选择在 `With`
    中可以更新的字段时，我们失去了细粒度的控制。
- en: A.1.6 Comparing strategies for immutability
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1.6 比较不可变性的策略
- en: In summary, before the introduction of records in C# 9, enforcing immutability
    was a thorny business, and one of the biggest hurdles when programming functionally.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在C# 9引入记录之前，强制不可变性是一个棘手的问题，并且在函数式编程时也是一个最大的障碍。
- en: 'Here are the pros and cons of the two approaches I''ve discussed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我所讨论的两种方法的优缺点：
- en: '*Immutability by convention*—In this approach, you don’t do any extra work
    to *prevent* mutation; you just *avoid* it like you probably avoid the use of
    `goto`, `unsafe` pointer access, and bitwise operations (just to mention a few
    things that the language allows but that have proven problematic). This can be
    a viable choice if you’re working independently or with a team that’s sold on
    this approach from day one. The downside is, of course, that mutation can creep
    in.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*约定不可变性*——在这种方法中，你不需要做任何额外的工作来*防止*突变；你只是像可能避免使用 `goto`、`unsafe` 指针访问和位操作（仅举几例，这些是语言允许但已被证明有问题的操作）一样避免它。如果你独立工作或与从第一天起就支持这种方法的团队一起工作，这可以是一个可行的选择。当然，缺点是突变可能会悄悄地出现。'
- en: '*Define immutable objects in C#*—This approach gives you a more robust model
    that communicates to other developers that the object shouldn’t be mutated. It
    is preferable if you’re working on a project where immutability isn’t used across
    the board. Compared to immutability by convention, it requires at least some extra
    work in defining constructors.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 C# 中定义不可变对象*——这种方法为你提供了一个更健壮的模型，它向其他开发者传达了该对象不应该被修改的信息。如果你在一个项目中工作，其中并没有全面使用不可变性，那么这种方法是首选的。与约定不可变性相比，它至少需要在定义构造函数时做一些额外的工作。'
- en: To make things even more complicated, third-party libraries may have limitations
    that dictate your choices. Traditionally, deserializers and ORMs for .NET have
    used the empty constructor and settable properties to create and populate objects.
    If you’re relying on libraries with such requirements, immutability by convention
    may be your only option.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使事情更加复杂，第三方库可能有限制，这些限制决定了你的选择。传统上，.NET 的反序列化器和 ORM 使用空构造函数和可设置属性来创建和填充对象。如果你依赖于具有此类要求的库，约定不可变性可能就是你的唯一选择。
- en: A.2 Pattern matching before C# 8
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 在 C# 8 之前进行模式匹配
- en: Pattern matching is a language feature that allows you to execute different
    code depending on the *shape* of some data—most importantly, its type. It’s a
    staple of statically typed functional languages, and we’ve used it extensively
    in the book, whether through `switch` expressions or through the definition of
    a `Match` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种语言特性，允许你根据某些数据（最重要的是其类型）的 *形状* 执行不同的代码。它是静态类型函数式语言的一个基本特性，我们在书中广泛使用了它，无论是通过
    `switch` 表达式还是通过定义一个 `Match` 方法。
- en: In this section, I’ll describe how support for pattern matching has evolved
    through successive versions in C# and show you a solution to use pattern matching
    even if you’re working on an older version of C#.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述模式匹配在 C# 中随版本演变的支持情况，并展示一个解决方案，即使你正在使用较旧的 C# 版本，也可以使用模式匹配。
- en: A.2.1 C#'s incremental support for pattern matching
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 C# 对模式匹配的增量支持
- en: 'For a long time, C# had poor support for pattern matching. Until C# 7, the
    `switch` statement only supported a very limited form of pattern matching, allowing
    you to match on the exact value of an expression. What about matching on the *type*
    of an expression? For example, suppose you have the following simple domain:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间，C# 对模式匹配的支持都很差。直到 C# 7，`switch` 语句只支持非常有限的形式的模式匹配，允许你匹配表达式的确切值。那么，匹配表达式的
    *类型* 呢？例如，假设你有一个以下简单的领域：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Up to C# 6, computing a description of a given `Reward` had to be done as the
    following listing shows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 之前，计算给定 `Reward` 的描述必须像以下列表所示那样进行。
- en: Listing A.10 Matching on the type of an expression in C# 6
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.10 在 C# 6 中对表达式类型进行匹配
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For such a simple operation, this is incredibly tedious and noisy. C# 7 introduced
    some limited support for pattern matching so that the preceding code could be
    abridged as the next listing shows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的操作，这确实非常繁琐且嘈杂。C# 7 引入了一些对模式匹配的有限支持，以便前面的代码可以像以下列表所示那样简化。
- en: Listing A.11 Matching on type in C# 7 with `is`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.11 使用 `is` 在 C# 7 中进行类型匹配
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Or, alternatively, using the `switch` statement as the following listing shows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以使用以下列表所示的 `switch` 语句。
- en: Listing A.12 Matching on type in C# 7 with `switch`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.12 使用 `switch` 在 C# 7 中进行类型匹配
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is still fairly awkward, especially because in FP, we’d like to use expressions,
    whereas both `if` and `switch` expect statements in each branch.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然相当尴尬，尤其是在函数式编程中，我们希望使用表达式，而 `if` 和 `switch` 都在每个分支中期望语句。
- en: Finally, C# 8 introduced `switch` expressions (you saw several examples in the
    book), allowing us to write the preceding code as the following listing shows.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C# 8 引入了 `switch` 表达式（你在书中看到了几个例子），允许我们将前面的代码写成以下列表所示的形式。
- en: Listing A.13 A `switch`-expression in C# 8
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.13 C# 8 中的 `switch` 表达式
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A.2.2 A custom solution for pattern matching expressions
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 用于模式匹配表达式的自定义解决方案
- en: If you’re working on a codebase that uses a version prior to C# 8, you can still
    pattern match on type using the `Pattern` class I’ve included in `LaYumba.Functional`.
    It can be used as in the following listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 C# 8 之前的版本的代码库，你仍然可以使用我包含在 `LaYumba.Functional` 中的 `Pattern` 类来进行类型匹配。它可以像以下列表所示那样使用。
- en: Listing A.14 A custom `Pattern` class for expression-based pattern matching
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.14 用于基于表达式的模式匹配的自定义 `Pattern` 类
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The generic parameter specifies the type that’s returned when calling `Match`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 泛型参数指定调用 `Match` 时返回的类型。
- en: ❷ A list of functions; the first one with a matching type is evaluated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个函数列表；第一个匹配类型的函数将被评估。
- en: ❸ Optionally adds a default value or handler
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 可选地添加默认值或处理程序
- en: ❹ Supplies the value on which to match
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 提供要匹配的值
- en: This isn’t as performant as first-class language support nor does it have all
    the bells and whistles like deconstruction, but it’s still a good solution if
    you’re just interested in matching on type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这不如一等语言支持性能好，也没有所有像解构这样的功能，但如果您只是对类型匹配感兴趣，这仍然是一个很好的解决方案。
- en: You first set up the functions that handle each case (internally, `Pattern`
    is essentially a list of functions, so I’m using list initializer syntax). You
    can optionally call `Default` to provide a default value or a function to use
    if no matching function is found. Finally, you use `Match` to supply the value
    to match on; this will evaluate the first function whose input type matches the
    type of the given value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先设置处理每个情况的函数（内部，`Pattern` 实质上是一个函数列表，所以我使用了列表初始化语法）。您可以可选地调用 `Default` 来提供一个默认值或一个函数，如果找不到匹配的函数则使用。最后，您使用
    `Match` 来提供要匹配的值；这将评估第一个输入类型与给定值类型匹配的函数。
- en: There’s also a non-generic version of `Pattern` in which `Match` returns `dynamic`.
    You could use this in the preceding example by simply omitting `<string>`, making
    the syntax a bit cleaner still.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Pattern` 还有一个非泛型版本，其中 `Match` 返回 `dynamic`。您可以在前面的示例中通过简单地省略 `<string>`
    来使用这个版本，从而使语法更加简洁。
- en: TIP In this book, you saw implementations of a `Match` method for `Option`,
    `Either`, `List`, `Tree`, and so on. These effectively perform pattern matching.
    Defining such methods makes sense when you know from the start all the cases you’ll
    need to handle (for instance, `Option` can only be `Some` or `None`). By contrast,
    the `Pattern` class is useful for types that are open for inheritance, like `Event`
    or `Reward`, where you can envisage adding new subclasses as the system evolves.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在这本书中，您看到了为 `Option`、`Either`、`List`、`Tree` 等实现的 `Match` 方法。这些方法有效地执行模式匹配。当您一开始就知道需要处理的所有情况时（例如，`Option`
    只能是 `Some` 或 `None`），定义此类方法是有意义的。相比之下，`Pattern` 类对于开放继承的类型很有用，如 `Event` 或 `Reward`，您可以根据系统的发展添加新的子类。
- en: A.3 Revisiting the event sourcing example
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 重新审视事件源示例
- en: To illustrate the techniques described previously, let’s revisit our event sourcing
    scenario from section 13.2 and suppose we can only use C# 6\. We don’t have records,
    so to represent the state of an account, we’ll define `AccountState` as an immutable
    class. All properties will be read-only and will be populated in the constructor.
    The following listing shows the implementation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明之前描述的技术，让我们回顾一下 13.2 节中的事件源场景，并假设我们只能使用 C# 6。我们没有记录，所以为了表示账户的状态，我们将定义 `AccountState`
    为一个不可变类。所有属性都将只读，并在构造函数中填充。以下列表显示了实现。
- en: Listing A.15 An immutable class representing the state of an account
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.15 表示账户状态的不可变类
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ All properties are read-only.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有属性都是只读的。
- en: ❷ Initializes properties in the constructor
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在构造函数中初始化属性
- en: ❸ Exposes copy methods for creating modified copies
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提供复制方法以创建修改后的副本
- en: Other than properties and the constructor, `AccountState` has a `WithStatus`
    copy method that creates a new `AccountState` with an updated status. `Debit`
    and `Credit` are also copy methods that create a copy with an updated balance.
    (This pretty long class definition replaces the record definition in listing 13.2,
    which was only seven lines.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性和构造函数之外，`AccountState` 还有一个 `WithStatus` 复制方法，它创建一个新的 `AccountState`，并带有更新的状态。`Debit`
    和 `Credit` 也是复制方法，它们创建一个带有更新余额的副本。（这个相当长的类定义替换了列表 13.2 中的记录定义，后者只有七行。）
- en: Now, about state transitions. Remember that we use the first event in the account’s
    history to create an `AccountState` and then use each event to compute the account’s
    new state after the event. The signature for a state transition is
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于状态转换。记住，我们使用账户历史中的第一个事件来创建一个 `AccountState`，然后使用每个事件来计算事件之后账户的新状态。状态转换的签名是
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to implement the state transition, we pattern match on the type of
    event and update the `AccountState` accordingly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现状态转换，我们根据事件类型进行模式匹配，并相应地更新 `AccountState`：
- en: Listing A.16 Modeling state transitions with pattern matching
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.16 使用模式匹配建模状态转换
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ `CreatedAccount` is a special case because there is no prior state.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `CreatedAccount` 是一个特殊情况，因为没有先前的状态。
- en: ❷ Calls the relevant transition, depending on the type of the event
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 根据事件类型调用相关的转换
- en: Without being able to rely on language support for pattern matching, this code
    uses the pattern matching solution shown in section A.2.2 to great effect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法依赖语言对模式匹配的支持，此代码有效地使用了 A.2.2 节中展示的模式匹配解决方案。
- en: A.4 In conclusion
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 结论
- en: As you saw, all the techniques discussed in this book can be used on legacy
    projects that use older versions of C#. Of course, if you can, do upgrade to the
    latest version of C# to take advantage of new language features, especially records
    and pattern matching.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，本书中讨论的所有技术都可以用于使用较旧版本的 C# 的遗留项目。当然，如果你能的话，升级到 C# 的最新版本以利用新的语言特性，特别是记录和模式匹配。
- en: '* * *'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ The `System.Collections.Immutable` library was developed by Microsoft to complement
    the mutable collections in the BCL, so its feel should be familiar. You must get
    it from NuGet.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 微软开发了 `System.Collections.Immutable` 库来补充 BCL 中的可变集合，因此它的感觉应该很熟悉。你必须从 NuGet
    获取它。
- en: ² The utilities in `System.Reflection` allow you to view and modify the value
    of any field at run time, including `private` and `readonly` fields and the backing
    fields of autoproperties.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Reflection` 中的实用工具允许你在运行时查看和修改任何字段的值，包括 `private` 和 `readonly` 字段以及自动属性的底层字段。'
