- en: Chapter 15\. Troubleshooting peripheral devices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章\. 解决外围设备故障
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Analyzing system hardware profiles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析系统硬件配置文件
- en: Managing kernel modules to administer hardware devices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内核模块以管理硬件设备
- en: Managing kernel settings to solve hardware boot conflicts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内核设置以解决硬件启动冲突
- en: Using CUPS to manage and troubleshoot printers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CUPS管理和解决打印机问题
- en: The connection between clicking a mouse button and seeing something happen on
    your screen is complicated. In simple terms, you need some kind of software process
    that’ll shuttle data back and forth between the mouse and the computer, between
    the computer and the software that’s running on it, and between the software and
    the screen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 点击鼠标按钮和你在屏幕上看到发生的事情之间的连接很复杂。简单来说，你需要某种软件过程，它将在鼠标和电脑之间、电脑和运行在其上的软件之间、以及软件和屏幕之间来回穿梭数据。
- en: More than just data transmission, you’ll also need a way to translate the data
    between the mouse that knows only the tabletop on which it sits and software that
    knows only zeros and ones. Multiply that by thousands of device models and throw
    in the many connection types (PCI, SATA, USB, serial), and you’ve got yourself
    quite a stew cooking away in your PC.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是数据传输，你还需要一种方法来在只知道它所坐的桌面的鼠标和只知道零和一的软件之间转换数据。将这一点乘以数千种设备型号，再加上许多连接类型（PCI、SATA、USB、串行），你就在你的PC中煮了一锅相当复杂的汤。
- en: Given the complexity of the whole thing, it’s a wonder that it all works as
    reliably as it does. In this chapter, you’re going to learn how to deal with those
    times that it doesn’t...like when the marketing team is waiting for you to activate
    the webcam so their virtual meeting can begin. Or when their WiFi won’t let them
    connect in the first place. To do all that magic, you’ll need to understand how
    Linux sees your peripheral devices and how you can guide the Linux kernel to take
    a shy device under its wing and care for it. Because we care about all of our
    devices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到整个系统的复杂性，它竟然如此可靠地工作，真是令人惊讶。在本章中，你将学习如何处理那些它不工作的时候……比如当市场营销团队在等待你激活摄像头，以便他们的虚拟会议开始。或者当他们的WiFi不允许他们首先连接。要完成所有这些魔法，你需要了解Linux如何看待你的外围设备，以及你如何引导Linux内核将一个害羞的设备纳入其羽翼下并照顾它。因为我们关心我们所有的设备。
- en: 15.1\. Identifying attached devices
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1\. 识别连接的设备
- en: Webcam plugged in but not broadcasting your smiling face across the internet?
    Printer not printing? WiFi adapter not adapting (or whatever it is that they do)?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的摄像头没有在互联网上展示你的笑脸？打印机没有打印？WiFi适配器没有适配（或者它们所做的任何事情）？
- en: Before you invest too much time and energy working to activate hardware devices,
    you must first accept the sad truth that an operating system (OS) might sometimes
    fail to even recognize some of its attached hardware. The first thing you’ll do
    if a newly plugged in device doesn’t seem to work is confirm that Linux knows
    its there. That’ll keep you busy for the next couple of pages. If you run the
    diagnostics I’m about to show you and there’s still no sign of life, consider
    the possibility that
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你投入太多时间和精力去激活硬件设备之前，你必须首先接受这个令人悲伤的事实：操作系统（OS）有时甚至可能无法识别其连接的一些硬件。如果你新插入的设备似乎不起作用，你首先应该确认Linux知道它的存在。这将让你忙上接下来的几页。如果你运行我即将展示的诊断程序，仍然没有生命迹象，那么考虑一下这种可能性：
- en: The device is incompatible with your hardware or with Linux.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备与你的硬件或Linux不兼容。
- en: The device is damaged or faulty.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备损坏或故障。
- en: The hardware interface or cable is damaged or faulty.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件接口或电缆损坏或故障。
- en: The system needs a reboot.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统需要重启。
- en: You’re having a bad day.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你今天过得不太好。
- en: 'Once they’re talking to each other, I’ll show you how to use kernel modules
    so Linux and your device can team up to get some work done for you. We’ll begin
    by looking at your hardware through the eyes of Linux. In fact, this whole “find
    out if Linux recognizes the device you just plugged in” business isn’t entirely
    new. You’ll remember how you used `lsblk` back in [chapter 6](kindle_split_014.xhtml#ch06)
    to discover attached block devices. Well, `lsblk` has some cousins: `lsusb` lists
    any USB devices Linux is aware of, and, as you saw in the last chapter, `lspci`
    will do the same for PCI devices. Here’s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们开始互相通信后，我会向你展示如何使用内核模块，让Linux和你的设备能够联手为你完成一些工作。我们将从通过Linux的视角查看你的硬件开始。实际上，这个“找出Linux是否识别了你刚刚插入的设备”的业务并不是全新的。你还记得在[第6章](kindle_split_014.xhtml#ch06)中使用了
    `lsblk` 来发现附加的块设备。嗯，`lsblk` 有一些表亲：`lsusb` 列出Linux所知的任何USB设备，正如你在上一章中看到的，`lspci`
    会为PCI设备做同样的事情。以下是一个例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* A Brother laser printer**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一台兄弟激光打印机**'
- en: '***2* A webcam**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一款网络摄像头**'
- en: '***3* A USB multiport hub**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一款USB多端口集线器**'
- en: '***4* A USB WiFi adapter**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一款USB无线网卡**'
- en: '[Chapter 14](kindle_split_022.xhtml#ch14) is also where you saw the grand old
    patriarch of the `ls` family, `lshw`. When run with `root` permissions, `lshw`
    prints a complete hardware profile of your system. The first thing you’ll notice
    is that `lshw` has an awful lot to say about every piece of your hardware. One
    way to tame that beast is to convert the output to an easy-to-read .html file
    that you can view in your web browser. The `-html` argument does that. Clicking
    the filename in a GUI file manager like Nautilus should load it into your default
    browser. Here’s how:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](kindle_split_022.xhtml#ch14)也是你看到 `ls` 家族的老大 `lshw` 的地方。当以 `root` 权限运行时，`lshw`
    会打印出系统的完整硬件配置文件。你首先会注意到的是，`lshw` 对你硬件的每一部分都有很多话要说。驯服这个巨兽的一种方法是将输出转换为易于阅读的 .html
    文件，你可以在网页浏览器中查看它。`-html` 参数就是用来做这个的。在Nautilus这样的GUI文件管理器中点击文件名应该会将其加载到你的默认浏览器中。以下是操作方法：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember how we used `lshw -class network` in the last chapter to restrict the
    output to only network-related content? That trick will work for other data subsets,
    too. For instance, `lshw -c memory` displays detailed information about all types
    of memory used by your system (including RAM, BIOS firmware, and cache); `-c`,
    as you may have guessed, works as a quicker alternative to `-class`. In addition
    to those, `lshw -c storage` displays information on SATA and SCSI interfaces,
    `-c multimedia` covers audio and video devices, and `-c cpu` tells you everything
    you ever wanted to know about the CPU plugged into your motherboard. That’s how
    you can nicely *consume* `lshw` information. But how should you *use* it?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在上一章中使用 `lshw -class network` 来限制输出只显示与网络相关的内容吗？这个技巧同样适用于其他数据子集。例如，`lshw
    -c memory` 会显示系统使用所有类型的内存的详细信息（包括RAM、BIOS固件和缓存）；你可能已经猜到了，`-c` 作为 `-class` 的快捷方式，可以更快地使用。除此之外，`lshw
    -c storage` 会显示SATA和SCSI接口的信息，`-c multimedia` 包括音频和视频设备，而 `-c cpu` 会告诉你关于连接到主板上的CPU的所有信息。这就是如何优雅地*消费*
    `lshw` 信息。但你应该如何*使用*它呢？
- en: Here’s a common scenario. Suppose you’re considering adding extra RAM to a system—perhaps
    the metrics you gathered back in [chapter 13](kindle_split_021.xhtml#ch13) suggest
    you’re running low. You’ll need to know how much you’ve already got and what kind
    of RAM it is, not to mention what motherboard you’re using so you can research
    how may RAM slots are available and what their maximum capacity is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的场景。假设你正在考虑向系统添加额外的RAM——也许你在[第13章](kindle_split_021.xhtml#ch13)中收集的指标表明你的RAM可能不足。你需要知道你已经有多少RAM以及它的类型，更不用说你需要了解你正在使用的主板，以便你可以研究有多少RAM插槽可用以及它们的最大容量是多少。
- en: OK. So RAM isn’t exactly a peripheral device, but it works well as an example
    of the kind of hardware discovery that’s possible. And hardware discovery should
    always be your first step when troubleshooting problems with your hardware.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以RAM并不完全是一个外围设备，但它很好地作为一个例子，说明了可能的硬件发现类型。而且，在解决硬件问题时，硬件发现始终应该是你的第一步。
- en: By way of illustration, `lshw` shows me that my motherboard has four RAM slots,
    two of which are currently occupied by 4 GB A-Data DDR3 1600 memory modules. Because
    you should avoid installing mismatched memory modules on a single system, this
    tells me exactly what kind of RAM I should purchase to fill those two empty slots
    and double my capacity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，`lshw`告诉我我的主板有四个RAM插槽，其中两个目前被4GB A-Data DDR3 1600内存模块占用。由于你应该避免在单个系统上安装不匹配的内存模块，这告诉我我应该购买什么类型的RAM来填充这两个空槽，并将我的容量加倍。
- en: I should point out that I have no immediate plans to upgrade my workstation.
    And why should I? The modest hardware profile I’ve already got allows me to run
    multiple VMs while editing and/or encoding a small handful of videos (using Kdenlive),
    and all while keeping at least one web browser busy with more than a dozen open
    tabs. And the computer I built from the ground up for less than $300 performs
    significantly better than the $1,000+ rigs used by many of my colleagues. What’s
    the difference? Those poor souls are feeding their resource-hungry Windows and
    macOS operating systems while I’m using fast and efficient Linux. Take that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，我目前没有升级工作站的计划。我为什么要升级呢？我已经拥有的硬件配置相当适中，它允许我在编辑和/或编码少量视频（使用Kdenlive）的同时运行多个虚拟机，并且还能让至少一个网络浏览器保持忙碌，打开十几个标签页。而我用不到300美元从头搭建的电脑，其性能比许多同事使用的1000多美元的设备要好得多。区别在哪里？那些可怜的家伙在喂养着资源消耗巨大的Windows和macOS操作系统，而我却在使用快速高效的Linux。看吧。
- en: What if your device is recognized by Linux but it still isn’t active? Perhaps
    there’s an appropriate kernel module out there waiting to be loaded.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备被Linux识别但仍然不活跃，可能有一个合适的内核模块正在等待被加载。
- en: 15.2\. Managing peripherals with Linux kernel modules
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2. 使用Linux内核模块管理外围设备
- en: Linux manages hardware peripherals using kernel modules. Here’s how that works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通过内核模块来管理硬件外围设备。以下是它是如何工作的。
- en: A running Linux kernel is one of those things you don’t want to upset. After
    all, the kernel is the software that drives everything your computer does. Considering
    how many details have to be simultaneously managed on a live system, it’s better
    to leave the kernel to do its job with as few distractions as possible. But if
    it’s impossible to make even small changes to the compute environment without
    rebooting the whole system, then plugging in a new webcam or printer could cause
    a painful disruption to your workflow. Having to reboot each time you add a device
    to get the system to recognize it is hardly efficient.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的Linux内核是你不希望打扰的东西之一。毕竟，内核是驱动你电脑所有操作的软件。考虑到在实时系统中需要同时管理的许多细节，最好是让内核在没有太多干扰的情况下完成其工作。但如果连对计算环境进行微小更改都需要重启整个系统，那么插入新的摄像头或打印机可能会对你的工作流程造成痛苦的干扰。每次添加设备都需要重启以使系统识别它，这几乎是不高效的。
- en: To create an effective balance between the opposing virtues of stability and
    usability, Linux isolates the kernel itself, but lets you add specific functionality
    on the fly through *loadable kernel modules* (LKMs). Looking at [figure 15.1](#ch15fig01),
    you can think of a module as a piece of software that tells the kernel where to
    find a device and what to do with it. In turn, the kernel makes the device available
    to users and processes and oversees its operation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在稳定性和可用性这两种对立的优点之间创造一个有效的平衡，Linux将内核本身隔离出来，但允许你通过*可加载内核模块*（LKMs）即时添加特定功能。查看[图15.1](#ch15fig01)，你可以将模块想象成一段软件，它告诉内核设备的位置以及如何处理它。反过来，内核将设备提供给用户和进程，并监督其操作。
- en: Figure 15.1\. Kernel modules act as translators between devices and the Linux
    kernel.
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.1. 内核模块作为设备和Linux内核之间的翻译器。
- en: '![](Images/15fig01_alt.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片15.1](Images/15fig01_alt.jpg)'
- en: There’s nothing stopping you from writing your own module to support a device
    exactly the way you’d like it, but why bother? The Linux module library is already
    so robust that there’s usually no need to roll out your own. And the vast majority
    of the time, Linux will automatically load a new device’s module without you even
    knowing it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么阻止你编写自己的模块来支持你想要的设备，但你为什么要费这个劲呢？Linux模块库已经非常强大，通常没有必要自己开发。而且，绝大多数情况下，Linux会自动加载新设备的模块，而你甚至可能都不知道。
- en: Still, there’ll be times when for some reason it doesn’t happen by itself. (You
    don’t want to leave that hiring manager impatiently waiting too long for your
    smiling face to join the video conference job interview.) To help things along,
    you’ll want to understand a bit more about kernel modules and, in particular,
    how to find the actual module that will run your peripheral, and then how to manually
    activate it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时出于某种原因，它不会自动发生。（你不想让那个招聘经理不耐烦地等待太久，直到你的笑脸加入视频会议面试。）为了帮助事情顺利进行，你需要了解更多关于内核模块的信息，特别是如何找到将运行你的外围设备的实际模块，然后如何手动激活它。
- en: 15.2.1\. Finding kernel modules
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1\. 查找内核模块
- en: 'By accepted convention, modules are files with a .ko (*kernel object*) extension
    that live beneath the /lib/modules/ directory. Before you navigate all the way
    down to those files, however, you’ll probably have to make a choice. Because you’re
    given the option at boot time of loading one from a list of releases, the specific
    software needed to support your choice (including the kernel modules) has to exist
    somewhere. Well, /lib/modules/ is one of those somewheres. And that’s where you’ll
    find directories filled with the modules for each available Linux kernel release,
    like these:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据公认的习惯，模块是以.ko（内核对象）扩展名的文件，位于/lib/modules/目录之下。然而，在你导航到那些文件之前，你可能需要做出一个选择。因为你在启动时可以从一系列版本中选择加载一个，所以支持你的选择（包括内核模块）的特定软件必须存在于某个地方。好吧，/lib/modules/就是那些某个地方之一。你会在那里找到每个可用的Linux内核版本的模块目录，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In my case, the active kernel is the version with the highest release number
    (4.4.0-104-generic), but there’s no guarantee that’ll be the same for you (kernels
    are frequently updated). If you’re going to be doing some work with modules that
    you’d like to use on a live system, you’ll need to be sure you’ve got the right
    directory tree.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，活动的内核是具有最高发布号的版本（4.4.0-104-generic），但并不能保证这对你来说也是一样的（内核经常更新）。如果你打算做一些你希望在实时系统上使用模块的工作，你需要确保你有了正确的目录树。
- en: 'Good news: there’s a reliable trick. Rather than identifying the directory
    by name and hoping you’ll get the right one, use the system variable that always
    points to the name of the active kernel. You can invoke that variable using `uname
    -r` (the `-r` specifies the kernel release number from within the system information
    that would normally be displayed):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：有一个可靠的技巧。与其通过名称识别目录并希望得到正确的目录，不如使用始终指向活动内核名称的系统变量。你可以使用`uname -r`（`-r`指定系统信息中通常显示的内核发布号）来调用该变量：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With that information, you can incorporate `uname` into your file system references
    using a process known as *command substitution*. To navigate to the right directory,
    for instance, you’d add it to /lib/modules. To tell Linux that “uname” itself
    isn’t a file system location, enclose the `uname` part in back ticks, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些信息，你可以使用称为*命令替换*的过程将`uname`整合到你的文件系统引用中。例如，为了导航到正确的目录，你可以在/lib/modules/中添加它。为了告诉Linux“uname”本身不是一个文件系统位置，将`uname`部分用反引号括起来，如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You’ll find most of the modules themselves organized within their own subdirectories
    beneath the kernel/ directory. Take a few minutes now to browse through those
    directories to get an idea of how things are arranged and what’s available. The
    filenames usually give you a good idea of what you’re looking at:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现大多数模块都组织在kernel/目录下的自己的子目录中。现在花几分钟浏览这些目录，以了解事物的组织方式和可用性。文件名通常会给你一个很好的提示，你正在看什么：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* The busiest of the subdirectories listed here is kernel, beneath which
    you can find modules for hundreds of devices.**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这里列出的子目录中最繁忙的是kernel，在其下你可以找到数百个设备的模块。**'
- en: 'That’s one way to locate kernel modules, actually the quick and dirty way to
    go about it. But it’s not the only one. If you want to get the complete set, you
    can list all currently loaded modules along with some basic information using
    `lsmod`. The first column is the module name, followed by the file size and number,
    and then names of other modules on which each is dependent:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一种定位内核模块的方法，也是快速而简单的方法。但并非只有这一种方法。如果你想获取完整的集合，你可以使用`lsmod`列出所有当前加载的模块和一些基本信息。第一列是模块名称，后面是文件大小和数量，然后是每个模块所依赖的其他模块的名称：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* This small sampling of the results shows modules related to VirtualBox
    and my USB WiFi adapter.**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这一小部分结果展示了与VirtualBox和我的USB WiFi适配器相关的模块。**'
- en: 'How many is too many? Well, let’s run `lsmod` once again, but this time piping
    the output to `wc -l` to get a count of the lines:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 多少才算太多？好吧，让我们再次运行`lsmod`，但这次将输出通过管道传递给`wc -l`以获取行数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Those are the loaded modules. How many are available in total? Running `modprobe
    -c` and counting the lines will give us that number:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是已加载的模块。总共有多少个可用？运行`modprobe -c`并计算行数将给出这个数字：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 33,350 available modules? Looks like someone’s been working hard over the years
    to provide us with the software to run our physical devices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 33,350个可用的模块？看起来有人在多年来努力为我们提供运行物理设备的软件。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: On some systems you might encounter customized modules that are referenced either
    with their own unique entries in the /etc/modules file or as a configuration file
    saved to /etc/modules-load.d/. The odds are that such modules are the product
    of local development projects, perhaps involving cutting-edge experiments. Either
    way, it’s good to have some idea of what it is you’re looking at.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上，你可能会遇到自定义模块，这些模块要么在`/etc/modules`文件中有它们自己的唯一条目，要么作为配置文件保存在`/etc/modules-load.d/`中。这些模块很可能是本地开发项目的产物，可能涉及前沿实验。无论如何，了解你所看到的内容总是一个好主意。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That’s how you find modules. Your next job is to figure out how to manually
    load an inactive module if, for some reason, it didn’t happen on its own.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何查找模块。你的下一个任务是弄清楚如何手动加载一个非活跃模块，如果由于某种原因它没有自动发生。
- en: 15.2.2\. Manually loading kernel modules
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.2\. 手动加载内核模块
- en: Before you can load a kernel module, logic dictates that you’ll have to confirm
    it exists. And before you can do that, you’ll need to know what it’s called. Getting
    that part might sometimes require equal parts magic and luck, and some help from
    online documentation authors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载内核模块之前，逻辑上你必须确认它存在。而在你能够做到这一点之前，你需要知道它的名字。有时候，获取这部分信息可能需要魔法和运气的同等部分，以及来自在线文档作者的某些帮助。
- en: 'I’ll illustrate the process by describing a problem I ran into some time back.
    One fine day, for a reason that still escapes me, the WiFi interface on a laptop
    stopped working. Just like that. Perhaps a software update knocked it out. Who
    knows? I ran `lshw -c network` and was treated to this very strange information:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过描述我之前遇到的一个问题来阐述这个过程。有一天，出于我至今仍无法理解的原因，笔记本电脑上的WiFi接口突然停止工作。就是这样。可能是一个软件更新让它失效了。谁知道呢？我运行了`lshw
    -c network`并得到了以下非常奇怪的信息：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Linux recognized the interface (the Atheros AR9485) but listed it as unclaimed.
    Well, as they say, “When the going gets tough, the tough search the internet.”
    I ran a search for “atheros ar9 linux module” and, after sifting through pages
    and pages of 5 and even 10-year-old results advising me to either write my own
    module or just give up, I finally discovered that with Ubuntu 16.04, at least,
    a working module existed. Its name: ath9k.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Linux识别了接口（Atheros AR9485），但将其列为未声明。嗯，正如他们所说，“当困难来临时，坚强的人会去搜索互联网。”我搜索了“atheros
    ar9 linux module”，在翻阅了成页甚至10年前的结果后，建议我要么编写自己的模块，要么放弃，我终于发现，至少在Ubuntu 16.04上，存在一个可用的模块。它的名字是ath9k。
- en: 'Yes! The battle’s as good as won! Adding a module to the kernel is a lot easier
    than it sounds. To double check that it’s available, you can run `find` against
    the modules’ directory tree, specify `-type f` to tell Linux you’re looking for
    a file, and then add the string `ath9k` along with a glob asterisk to include
    all filenames that start with your string:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！战斗几乎已经胜利！向内核添加模块比听起来要容易得多。为了确认它可用，你可以对模块的目录树运行`find`命令，指定`-type f`告诉Linux你正在寻找一个文件，然后添加字符串`ath9k`以及通配符星号来包括所有以你的字符串开头的文件名：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just one more step, loading the module:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 只需再走一步，加载模块：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That’s it. No reboots. No fuss.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。无需重启。无需麻烦。
- en: One more example to show you how to work with active modules that have become
    corrupted. There was a time when using my Logitech webcam with a particular piece
    of software would make the camera inaccessible to any other programs until the
    next system boot. Sometimes I needed to open the camera in a different application
    and didn’t have the time to shut down and start up again. (I run a lot of applications,
    and getting them all in place after booting takes some time.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，展示如何处理已损坏的活跃模块。曾经有一段时间，使用我的罗技摄像头与某款特定软件配合时，会使摄像头在下次系统启动之前对任何其他程序都不可用。有时我需要在不同应用程序中打开摄像头，但没有时间关闭和重新启动。（我运行了很多应用程序，启动后需要一些时间才能将它们全部设置好。）
- en: 'Because this module was presumably active, using `lsmod` to search for the
    word *video* gave me a hint about the name of the relevant module. In fact, it
    was better than a hint—the only module described with the word *video* was uvcvideo,
    as you can see in the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个模块可能处于活动状态，使用`lsmod`搜索单词*video*给了我关于相关模块名称的提示。实际上，这比提示更好——唯一描述了单词*video*的模块是uvcvideo，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There was probably something I could have controlled, for what was causing
    the crash; and, I guess, I could have dug a bit deeper to see if I couldn’t fix
    things the right way. But you know how it is: sometimes you don’t care about the
    theory and just want your device working. So I used `rmmod` to kill the uvcvideo
    module and `modprobe` to start it up again all nice and fresh:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于导致崩溃的原因，可能有一些我可以控制的事情；而且，我想，我可以挖得更深，看看是否可以正确地解决问题。但你知道，有时候你不在乎理论，只想让你的设备工作。所以我使用`rmmod`来终止uvcvideo模块，并使用`modprobe`来重新启动它，让它焕然一新：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Again: no reboots. No stubborn blood stains.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调：无需重启。无需顽固的血迹。
- en: 15.3\. Manually managing kernel parameters at boot time
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3. 手动管理启动时的内核参数
- en: 'Because we’re talking about the kernel anyway, now would be a good time to
    have a serious chat about kernel parameters. You know, the chat we’ve been putting
    off for a while because kernel parameters sounds scary. Well, they are scary:
    getting them wrong can leave your computer at least temporarily unbootable. And
    spelling counts.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为无论如何我们都在谈论内核，现在正是讨论内核参数的好时机。你知道，我们一直推迟的对话，因为内核参数听起来很吓人。好吧，它们确实很吓人：选错它们可能会让你的电脑至少暂时无法启动。而且拼写也很重要。
- en: Why make trouble in the first place? Because sometimes your kernel’s default
    boot configuration won’t work for what you’re doing, and the only way to fix it
    is to change the way the kernel boots.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最初为什么要制造麻烦？因为有时你的内核默认启动配置可能不适合你的需求，而唯一解决问题的方法就是改变内核的启动方式。
- en: There are two ways to pass custom parameters to the kernel at boot time. One
    involves editing the GRUB menu item during the boot process, and the other, editing
    the /etc/default/grub configuration file on a running system for the changes to
    take effect the next time you start up. To illustrate each of those approaches,
    I’ll use two practical use-case scenarios. You’ll have to continue reading to
    find out what those are.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时向内核传递自定义参数有两种方式。一种是在启动过程中编辑GRUB菜单项，另一种是在运行的系统上编辑`/etc/default/grub`配置文件，以便在下次启动时生效。为了说明这些方法，我将使用两个实际用例场景。你必须继续阅读才能了解这些是什么。
- en: 15.3.1\. Passing parameters at boot time
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.1. 在启动时传递参数
- en: I’m not sure how common a problem this is, but it’ll do nicely as a teaching
    example. Some unfortunate individuals find it impossible to properly shut down
    or reboot Linux, experiencing an unwanted system freeze each time. Adding a simple
    kernel parameter will sometimes solve the issue. Here’s how it’s done.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定这个问题有多普遍，但它作为一个教学示例会很合适。一些不幸的人发现他们无法正确关闭或重启Linux，每次都会遇到不想要的系统冻结。添加一个简单的内核参数有时可以解决这个问题。下面是如何操作的。
- en: With the Linux release you want to boot selected in the GRUB menu (see [figure
    15.2](#ch15fig02)), press the e key, and you’ll be taken to an editing screen.
    There you’ll be able to use the regular cursor and text keys to navigate and then
    edit the contents.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在GRUB菜单中选择你想要启动的Linux版本（见图15.2），按e键，你将被带到编辑屏幕。在那里，你可以使用常规的光标和文本键进行导航，然后编辑内容。
- en: Figure 15.2\. The main GRUB menu displaying the multiple Linux kernels available
    for loading
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.2. 主要GRUB菜单显示可加载的多个Linux内核
- en: '![](Images/15fig02_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/15fig02_alt.jpg)'
- en: Scroll down until you reach the Linux entry highlighted in [figure 15.3](#ch15fig03).
    In this example, after wrapping to the next line, that entry ends with *ro*. (Don’t
    worry if yours is different.) Then add `reboot=bios` to the end of the line and
    press Ctrl-x to accept the changes and boot. If that doesn’t fix the shutdown
    problem, you can try again using `reboot=pci` instead of `reboot=bios`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动直到你到达图15.3中突出显示的Linux条目。在这个例子中，在换行后，该条目以*ro*结束。（如果你的不同，不用担心。）然后在行尾添加`reboot=bios`，并按Ctrl-x接受更改并启动。如果这不能解决关闭问题，你可以尝试再次使用`reboot=pci`而不是`reboot=bios`。
- en: Figure 15.3\. The Linux line that shows boot parameters, pointing GRUB to the
    location of a Linux image
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.3. 显示启动参数的Linux行，指向Linux镜像的位置
- en: '![](Images/15fig03_alt.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/15fig03_alt.jpg)'
- en: Bear in mind that this edit will not be permanent. After the next boot, the
    GRUB settings will once again be controlled by configuration files in the file
    system. To find out how to make changes that will persist through boots, keep
    reading.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这次编辑不会是永久的。下次启动后，GRUB 设置将再次由文件系统中的配置文件控制。要了解如何进行持久更改，请继续阅读。
- en: 15.3.2\. Passing parameters via the file system
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.2\. 通过文件系统传递参数
- en: OK, how about this one? There might be times when you want to boot a desktop
    machine without its GUI. Perhaps some elements of the GUI itself aren’t loading
    properly, and you need a clean, reliable shell session to troubleshoot. Well waddya
    know, you can set the default run level to 3 (multiuser, nongraphical mode) through
    GRUB.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个怎么样？可能会有时候你想在没有 GUI 的情况下启动桌面机器。也许 GUI 本身的一些元素没有正确加载，你需要一个干净、可靠的 shell 会话来排除故障。你知道吗，你可以通过
    GRUB 将默认运行级别设置为 3（多用户，非图形模式）。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: A *run level* is a setting that defines the Linux system state for a particular
    session. Choosing between run levels 0–6 determines what services should be available,
    ranging from a full, graphic, multiuser system to no services at all (meaning,
    shut down).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行级别* 是一个设置，用于定义特定会话的 Linux 系统状态。在运行级别 0–6 之间进行选择，确定哪些服务应该可用，从完整的图形多用户系统到没有任何服务（即关机）。'
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Open the /etc/default/grub file, and find the `GRUB_CMDLINE_LINUX_DEFAULT`
    line. It often comes with a couple of parameters and looks something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 /etc/default/grub 文件，找到 `GRUB_CMDLINE_LINUX_DEFAULT` 行。它通常带有几个参数，看起来像这样：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add `systemd.unit=runlevel3.target` to the end of the line so it looks like
    the following. (`quiet splash` doesn’t interest us one way or the other; it controls
    what you see on your screen as you boot.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `systemd.unit=runlevel3.target` 添加到行尾，使其看起来如下所示。（`quiet splash` 对我们来说无关紧要；它控制你在启动时在屏幕上看到的内容。）
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run `update-grub` on Ubuntu or `grub2-mkconfig` on CentOS for the changes to
    take effect. The next time you boot your computer, you’ll be dropped into a command-line
    shell. Once you’re done with your troubleshooting, you can remove `systemd.unit=runlevel3.target`
    from /etc/default/grub, again update GRUB, and reboot.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上运行 `update-grub` 或在 CentOS 上运行 `grub2-mkconfig` 以使更改生效。下次启动计算机时，你将进入命令行
    shell。一旦你完成了故障排除，你可以从 /etc/default/grub 中移除 `systemd.unit=runlevel3.target`，再次更新
    GRUB，然后重新启动。
- en: 15.4\. Managing printers
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4\. 管理打印机
- en: Ready for a shock? Make sure you’re sitting down. I’m going to advise you to
    pass over a perfectly good command-line tool in favor of its GUI equivalent. The
    command-line tool? `lp`. Complete with its updated engine under the hood, `lp`
    is still around, and it can certainly do some interesting things. But trust me,
    if one of the office printers you support disappears from the network, you’re
    not going to be opening up a command line to troubleshoot. These days it’s all
    Common UNIX Printing System (CUPS), all the time. But before we go there, I’ll
    give you a couple of `lp` commands that might come in handy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好受到惊吓了吗？确保你已经坐好。我将建议你跳过一个完美的命令行工具，转而使用其 GUI 等效工具。命令行工具？`lp`。在引擎盖下配备了更新的引擎，`lp`
    仍然存在，并且它确实可以做一些有趣的事情。但相信我，如果你支持的办公室打印机从网络上消失，你不会打开命令行来排除故障。如今，一切都是 Common UNIX
    Printing System (CUPS)，一直如此。但在我们深入之前，我会给你一些可能用得上的 `lp` 命令。
- en: 15.4.1\. Basics of lp
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.1\. `lp` 的基础知识
- en: 'Suppose there’s a file on a remote computer that needs printing. You know it’s
    not much fun to launch LibreOffice over a remote X session, right? Wouldn’t it
    be nice to do it through a simple, fast, and reliable SSH shell? Say no more.
    Use `lpq` to list available printers (along with the current job queue):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一台远程计算机上的文件需要打印。你知道通过远程 X 会话启动 LibreOffice 并不是很有趣，对吧？通过简单、快速、可靠的 SSH shell
    来做不是更好吗？说吧，不再多说了。使用 `lpq` 列出可用的打印机（包括当前的作业队列）：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then use `lp` to print the file. If there’s more than one printer on the system,
    you’ll also need to specify the printer you’d like to use. Here’s an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `lp` 打印文件。如果系统上有多个打印机，你还需要指定你想要使用的打印机。以下是一个示例：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Don’t want to print right away? Schedule it for later. The `-H` schedule setting
    always uses UTC time rather than local:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不想立即打印？稍后安排。`-H` 调度设置始终使用 UTC 时间而不是本地时间：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 15.4.2\. Managing printers using CUPS
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.2\. 使用 CUPS 管理打印机
- en: 'Once upon a time, before purchasing a printer to use with a Linux system, you’d
    need careful and time-consuming research to make sure it was compatible. If it
    was, you’d often need to download and install the appropriate driver and then
    manually install the printer through the OS. When it worked, it was cause for
    celebration. Three things have happened over the past years to make Linux printing
    a lot better:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，在购买打印机用于Linux系统之前，你需要进行仔细且耗时的研究以确保其兼容性。如果兼容，你通常需要下载并安装适当的驱动程序，然后通过操作系统手动安装打印机。当它工作正常时，这会是一个值得庆祝的时刻。在过去几年中，有三件事情的发生使得Linux打印变得更好：
- en: The CUPS modular printing system has been adopted by many, if not all, Linux
    distributions to manage printers and printing. Believe it or not, CUPS is managed
    on behalf of the community by Apple. As you’ll soon see, the CUPS interface greatly
    simplifies administration and troubleshooting and is quite reliable.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUPS模块化打印系统已被许多，如果不是所有，的Linux发行版采用来管理打印机和打印。信不信由你，CUPS是由苹果公司代表社区进行管理的。正如你很快就会看到的，CUPS界面极大地简化了管理和故障排除，并且非常可靠。
- en: The major printer manufacturers now generally provide Linux drivers. They’re
    not always perfect, but they’re workable. This means that, these days, nearly
    any modern printer can be deployed with Linux computers. Still, it can’t hurt
    to take a quick look at an online resource like [https://help.ubuntu.com/community/Printers](https://help.ubuntu.com/community/Printers).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要打印机制造商现在通常提供Linux驱动程序。它们并不总是完美的，但它们是可行的。这意味着，如今，几乎任何现代打印机都可以与Linux计算机一起部署。尽管如此，快速查看像[https://help.ubuntu.com/community/Printers](https://help.ubuntu.com/community/Printers)这样的在线资源也无妨。
- en: Starting with release 17.04, Ubuntu now offers driverless printing. This means
    any accessible local or networked printers will automatically be added to CUPS
    without any setup required.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从17.04版本开始，Ubuntu现在提供无驱动打印。这意味着任何可访问的本地或网络打印机都将自动添加到CUPS，无需任何设置。
- en: At any rate, you access the CUPS interface through your browser, pointing it
    to port 631 on your own machine (localhost:631). The Administration tab (visible
    in [figure 15.4](#ch15fig04)) contains straightforward links to manage finding,
    securing, scheduling, and tracking all available printers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你通过浏览器访问CUPS界面，将其指向你自己的机器上的端口631（localhost:631）。管理标签页（在[图15.4](#ch15fig04)中可见）包含管理查找、保护、安排和跟踪所有可用打印机的直接链接。
- en: Figure 15.4\. The CUPS browser interface that, by default, is available via
    port 631 on any Linux computer running CUPS
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.4\. 默认情况下通过任何运行CUPS的Linux计算机的端口631可用的CUPS浏览器界面
- en: '![](Images/15fig04_alt.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig04_alt.jpg)'
- en: You can even manage groups of printers in a class to allow effective use of
    multiple devices. This can be a great way to organize resources to ensure, for
    instance, more expensive color printing is only used for high-priority jobs and
    draft documents are forced to print on cheaper, lower-quality printers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以管理一组打印机，以允许有效使用多个设备。这可以是一种组织资源的好方法，例如，确保昂贵的彩色打印仅用于高优先级的工作，草稿文档被迫打印在更便宜、质量较低的打印机上。
- en: CUPS handles all the dirty administration details invisibly. Should you need
    to detach a particular printer from one computer (or network subnet, if it’s a
    network printer) and attach it to another, you’ll only need to make the relevant
    changes within the CUPS interface on the host computer. The appropriate routing
    information will be automatically updated across the network within a minute or
    two.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CUPS无痕处理所有脏管理细节。如果你需要将特定的打印机从一台计算机（或网络子网，如果是网络打印机）断开连接，并将其连接到另一台，你只需在主机计算机的CUPS界面上进行相关更改即可。适当的路由信息将在一分钟或两分钟内自动更新到网络中。
- en: CUPS knows which printers are available because, by default, printers connected
    to any computer running CUPS will broadcast their existence to all others on the
    network. This, along with many other configuration settings, can be controlled
    by the /etc/cups/cupsd.conf file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CUPS知道哪些打印机可用，因为默认情况下，连接到任何运行CUPS的计算机的打印机都会向网络上的所有其他计算机广播其存在。这，连同许多其他配置设置，可以通过/etc/cups/cupsd.conf文件进行控制。
- en: Listing 15.1\. A section of the /etc/cups/cupsd.conf configuration file
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.1\. /etc/cups/cupsd.conf配置文件的一部分
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* You can change the network port used by CUPS.**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 你可以更改CUPS使用的网络端口。'
- en: '***2* You can block access to the web interface altogether should security
    considerations require it.**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 如果出于安全考虑需要，你可以完全阻止对Web界面的访问。'
- en: 'If CUPS doesn’t recognize one of your printers, there are a few things to try
    even before searching the internet (using the name of your printer and the word
    *linux*):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CUPS 未能识别您的打印机，在搜索互联网（使用打印机的名称和单词 *linux*）之前，有一些事情可以尝试：
- en: Check for error messages. Running `systemctl status cups` is a good way to view
    the most recent alerts.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查错误信息。运行 `systemctl status cups` 是查看最新警报的好方法。
- en: Run `lsusb` (assuming it’s a USB printer) and/or `lpinfo -v` from the command
    line to confirm that the system sees your printer.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行 `lsusb`（假设是 USB 打印机）和/或 `lpinfo -v` 以确认系统可以看到您的打印机。
- en: Make sure there are no duplicate or outdated entries in the /etc/cups/printers
    .conf file. If there are, shut down CUPS (`systemctl stop cups`), save a copy
    of the original file, and then remove any old entries. Start CUPS again, and try
    adding the printer from the browser interface.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在 `/etc/cups/printers .conf` 文件中没有重复或过时的条目。如果有，关闭 CUPS（`systemctl stop cups`），保存原始文件的副本，然后删除任何旧条目。再次启动
    CUPS，并尝试从浏览器界面添加打印机。
- en: Make sure that the `<Policy default>` section of the /etc/cups/cupsd.conf file
    doesn’t have any overly restrictive settings that might be blocking legitimate
    requests.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在 `/etc/cups/cupsd.conf` 文件的 `<Policy default>` 部分没有过于严格的设置，这些设置可能会阻止合法请求。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The visibility and insight into your hardware profile provided by Linux tools
    like `lshw` should be used in all hardware upgrades and repair decisions.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用 Linux 工具（如 `lshw`）提供的硬件配置的可见性和洞察力来辅助所有硬件升级和维修决策。
- en: The Linux kernel is isolated from system activity to protect it from destabilizing
    changes, but kernel modules can safely provide hardware devices with dynamic access
    to kernel resources.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 内核通过隔离系统活动来保护自己免受不稳定变化的影响，但内核模块可以安全地为硬件设备提供对内核资源的动态访问。
- en: The Linux kernel can be modified by adding parameters at boot time, either by
    editing configuration files or through the GRUB menu.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 内核可以通过在启动时添加参数来修改，无论是通过编辑配置文件还是通过 GRUB 菜单。
- en: CUPS provides an interface to closely administer printers across a network.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUPS 提供了一个网络管理打印机的接口。
- en: Key terms
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键术语
- en: A *kernel module* is software that defines the attributes of a hardware device
    for the benefit of the Linux kernel.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内核模块* 是一种软件，它为 Linux 内核定义了硬件设备的属性，以供其使用。'
- en: A *kernel parameter* is an argument that’s added to the kernel at runtime to
    control system behavior.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内核参数* 是在运行时添加到内核的参数，用于控制系统行为。'
- en: Security best practices
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Use the /etc/cups/cupsd.conf file to control network access to your printers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `/etc/cups/cupsd.conf` 文件来控制对打印机的网络访问。
- en: Command-line review
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行审查
- en: '`lshw -c memory` (or `lshw -class memory`) displays the memory section of a
    system’s hardware profile.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lshw -c memory`（或 `lshw -class memory`）显示系统硬件配置的内存部分。'
- en: '`` ls /lib/modules/`uname -r` `` lists the contents of the directory under
    /lib/modules/ containing modules for your current, active kernel.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` ls /lib/modules/`uname -r` `` 列出 `/lib/modules/` 目录下包含当前活动内核模块的内容。'
- en: '`lsmod` lists all active modules.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsmod` 列出所有活动模块。'
- en: '`modprobe -c` lists all available modules.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modprobe -c` 列出所有可用的模块。'
- en: '`find /lib/modules/$(uname -r) -type f -name ath9k*` searches for a file among
    the available kernel modules with a name starting with *ath9k*.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find /lib/modules/$(uname -r) -type f -name ath9k*` 在可用的内核模块中搜索以 *ath9k* 开头的文件。'
- en: '`modprobe ath9k` loads the specified module into the kernel.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modprobe ath9k` 将指定的模块加载到内核中。'
- en: '`GRUB_CMDLINE_LINUX_DEFAULT="systemd.unit=runlevel3.target"` (in the /etc/default/grub
    file) loads Linux as a multiuser, nongraphic session.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GRUB_CMDLINE_LINUX_DEFAULT="systemd.unit=runlevel3.target"`（在 `/etc/default/grub`
    文件中）以多用户、非图形会话方式加载 Linux。'
- en: '`lp -H 11:30 -d Brother-DCP-7060D /home/user/myfile.pdf` schedules a print
    job to the Brother printer at 11:30 UTC.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lp -H 11:30 -d Brother-DCP-7060D /home/user/myfile.pdf` 在 UTC 时间 11:30 调度打印任务到
    Brother 打印机。'
- en: Test yourself
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自己
- en: '**[1](#ch15qa2q0a1)**'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch15qa2q0a1)**'
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the best way to easily visualize your computer’s complete hardware profile?
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是最简单的方法来直观地查看计算机的完整硬件配置？
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`lsmod`'
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lsmod`'
- en: '`lshw -class memory`'
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lshw -class memory`'
- en: '`lshw -html > lshw-output.html`'
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lshw -html > lshw-output.html`'
- en: '`modprobe -C`'
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`modprobe -C`'
- en: '**[2](#ch15qa2q0a2)**'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch15qa2q0a2)**'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the best way to reference the file system location containing the active
    kernel modules?
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最好的方法来引用包含活动内核模块的文件系统位置是什么？
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`/lib/kernel/uname -a`'
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/lib/kernel/uname -a`'
- en: '`/lib/modules/name -r`'
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/lib/modules/name -r`'
- en: '`/usr/modules/uname -r`'
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/usr/modules/uname -r`'
- en: '`/lib/modules/uname -r`'
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/lib/modules/uname -r`'
- en: '**[3](#ch15qa2q0a3)**'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch15qa2q0a3)**'
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will deactivate a kernel module?
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令将禁用内核模块？
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`delmod uvcvideo`'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delmod uvcvideo`'
- en: '`rmmod uvcvideo`'
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rmmod uvcvideo`'
- en: '`modprobe -d uvcvideo`'
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`modprobe -d uvcvideo`'
- en: '`rmmod -r uvcvideo`'
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rmmod -r uvcvideo`'
- en: '**[4](#ch15qa2q0a4)**'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch15qa2q0a4)**'
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You need to pass a parameter to the Linux kernel that will be effective immediately
    and permanently. What are the steps you should take?
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您需要向 Linux 内核传递一个参数，使其立即且永久生效。您应该采取哪些步骤？
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Edit the linux line in the Edit menu of the GRUB menu at boot time, save the
    file using Ctrl-x, and boot.
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在引导时，编辑 GRUB 菜单的“编辑”菜单中的 linux 行，使用 Ctrl-x 保存文件，然后引导系统。
- en: Add the parameter to the /etc/default/grub file, update GRUB, and then reboot.
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数添加到 /etc/default/grub 文件中，更新 GRUB，然后重启系统。
- en: Upgrade GRUB from the command line, reboot, add the parameter to the `linux`
    line in the Edit menu of the GRUB menu at boot time, save the file using Ctrl-x,
    and boot.
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行升级 GRUB，重启系统，在引导时编辑 GRUB 菜单的“编辑”菜单中的 linux 行，使用 Ctrl-x 保存文件，然后引导系统。
- en: Reboot, upgrade GRUB from the command line, and add the parameter to the /etc/default/grub
    file.
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启系统，从命令行升级 GRUB，并将参数添加到 /etc/default/grub 文件中。
- en: '**[5](#ch15qa2q0a5)**'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch15qa2q0a5)**'
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will schedule a print job for half past ten?
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令将在十点半安排打印作业？
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`lpd 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lpd 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
- en: '`lpq -h 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lpq -h 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
- en: '`lp -T 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lp -T 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
- en: '`lp -H 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lp -H 10:30 -d Brother-DCP-7060D /home/user/myfile.pdf`'
- en: Answer key
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 答案键
- en: '**[1.](#ch15qa1q1)**'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1.](#ch15qa1q1)**'
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[2.](#ch15qa1q2)**'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2.](#ch15qa1q2)**'
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[3.](#ch15qa1q3)**'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3.](#ch15qa1q3)**'
- en: ''
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[4.](#ch15qa1q4)**'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4.](#ch15qa1q4)**'
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[5.](#ch15qa1q5)**'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5.](#ch15qa1q5)**'
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
