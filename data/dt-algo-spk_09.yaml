- en: Chapter 6\. Graph Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章\. 图算法
- en: 'So far we’ve mainly been focusing on record data, which is typically stored
    in flat files or relational databases and can be represented as a matrix (a set
    of rows with named columns). Now we’ll turn our attention to graph-based data,
    which depicts the relationships between two or more data points. A common example
    is social network data: for example, if “Alex” is a “friend” of “Jane” and “Jane”
    is a “friend” of “Bob,” these relationships form a graph. Airline/flight data
    is another common example of graph data; we’ll explore both of these (and others)
    in this chapter.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注的是记录数据，通常存储在平面文件或关系数据库中，并且可以表示为矩阵（一组带有命名列的行）。现在我们将注意力转向基于图的数据，它描述了两个或多个数据点之间的关系。一个常见的例子是社交网络数据：例如，如果“Alex”是“Jane”的“朋友”，而“Jane”是“Bob”的“朋友”，这些关系形成了一个图。航空公司/航班数据是图数据的另一个常见例子；我们将在本章中探索这两个（及其他）例子。
- en: Data structures are specific ways of organizing and storing data in computers
    so that it can be used effectively. In addition to linear data structures like
    the ones we’ve primarily been working with in the previous chapters (arrays, lists,
    tuples, etc.), these include nonlinear structures such as trees, hash maps, and
    graphs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是计算机中有效组织和存储数据的特定方式。除了线性数据结构（如我们在前几章中主要使用的数组、列表、元组等）外，还包括非线性结构，如树、哈希映射和图。
- en: This chapter introduces GraphFrames, a powerful external package for Spark that
    provides APIs for representing directed and undirected graphs, querying and analyzing
    graphs, and running algorithms on graphs. We’ll start by exploring graphs and
    what they are used for, then look at how to use the GraphFrames API in PySpark
    to build and query graphs. We’ll dig into a few of the algorithms GraphFrames
    supports, such as finding triangles and motif finding, then walk through some
    practical, real-world applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了GraphFrames，这是一个强大的Spark外部包，提供API用于表示有向和无向图，查询和分析图，并在图上运行算法。我们将首先探讨图及其用途，然后看看如何在PySpark中使用GraphFrames
    API构建和查询图。我们将深入了解GraphFrames支持的一些算法，例如查找三角形和模式查找，然后讨论一些实际的现实应用。
- en: Introduction to Graphs
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的介绍
- en: 'Graphs are nonlinear data structures used to visually illustrate relationships
    in data. Informally, a graph is a pair `(V, E)`, where:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图是非线性数据结构，用于直观地展示数据中的关系。非正式地说，图是一对 `(V, E)`，其中：
- en: '`V` is a set of nodes, called vertices.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V` 是一组称为顶点的节点。'
- en: '`E` is a collection of pairs of vertices, called edges.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E` 是一组称为边的顶点对集合。'
- en: '`V` (vertices) and `E` (edges) are positions and store elements.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V`（顶点）和 `E`（边）是位置，并存储元素。'
- en: 'In general, each node is identified by a unique identifier and a set of associated
    attributes. An edge is identified by two node identifiers (the source and target
    nodes) and a set of associated attributes. A path represents a sequence of edges
    between two vertices. For example, in the case of an airline network:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，每个节点通过唯一标识符和一组关联属性来标识。边由两个节点标识符（源节点和目标节点）和一组关联属性标识。路径表示两个顶点之间的一系列边。例如，在航空网络中：
- en: A vertex represents an airport and stores the three-letter airport code and
    other vital information (city, state, etc.).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点代表机场，并存储三字母机场代码及其他重要信息（城市、州等）。
- en: An edge represents a flight route between two airports and stores the mileage
    of the route.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边代表两个机场之间的航班路线，并存储路线的里程数。
- en: An edge can be *directed* or *undirected*, as shown in [Figure 6-1](#directed_and_undirected_graph_example).
    A directed edge consists of an ordered pair of vertices `(u, v)`, where the first
    vertex (`u`) is the source and the second vertex (`v`) is the destination. An
    undirected edge consists of an unordered pair of vertices `(u, v)`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 边可以是*有向*或*无向*的，如图[6-1](#directed_and_undirected_graph_example)所示。有向边由有序顶点对`(u,
    v)`组成，其中第一个顶点(`u`)是源，第二个顶点(`v`)是目的地。无向边由无序顶点对`(u, v)`组成。
- en: '![daws 0601](Images/daws_0601.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![daws 0601](Images/daws_0601.png)'
- en: Figure 6-1\. Directed and undirected edges
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 有向和无向边
- en: Similarly, a graph can be either directed (composed of directed edges) or undirected
    (composed of undirected edges). [Figure 6-2](#directed_graph_example) shows an
    example of a directed graph. it represents a small set of airports as vertices
    (identified by the airport codes, such as SJC, LAX, etc.) and shows the relationships
    between originating airports and flight destinations with edges.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，图可以是有向的（由有向边组成）或无向的（由无向边组成）。[图 6-2](#directed_graph_example) 展示了一个有向图的例子。它表示了一小组机场作为顶点（通过机场代码标识，如SJC、LAX等），并显示了始发机场和飞行目的地之间的关系。
- en: '![daws 0602](Images/daws_0602.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![daws 0602](Images/daws_0602.png)'
- en: Figure 6-2\. Directed graph example
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 有向图示例
- en: '[Figure 6-3](#undirected_graph_example) shows an undirected graph with six
    nodes, labeled as `{A, B, C, D, E, F}`, connected with edges. In this example,
    the nodes might represent cities and edges might represent the distances between
    the cities. As you can see, in an undirected graph all the edges are bidirectional.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](#undirected_graph_example) 展示了一个具有六个节点的无向图，标记为`{A, B, C, D, E, F}`，节点之间用边连接。在这个例子中，节点可能表示城市，边可能表示城市之间的距离。在无向图中，所有的边都是双向的。'
- en: '![daws 0603](Images/daws_0603.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![daws 0603](Images/daws_0603.png)'
- en: Figure 6-3\. Undirected graph example
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 无向图示例
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To convert a directed graph to an undirected graph, you add an additional edge
    for every directed edge. That is, if there is a directed edge as `(u, v)`, then
    you add an edge as `(v, u)`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要将有向图转换为无向图，您需要为每条有向边添加一条额外的边。也就是说，如果有一条有向边 `(u, v)`，那么您需要添加一条边 `(v, u)`。
- en: Certain types of data are particularly well suited to being expressed using
    graphs. For instance, in network analysis, data is usually modeled as a graph
    or set of graphs. Graphs and matrices are commonly used to represent and analyze
    information about patterns of ties among social actors (users, friends, followers)
    and objects (such as products, stories, genes, etc.). We’ll look at some real-world
    examples of how graphs can be used to solve data problems later in this chapter,
    but first, let’s dive into the GraphFrames API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类型的数据特别适合使用图来表示。例如，在网络分析中，数据通常被建模为一个图或一组图。图和矩阵通常用于表示和分析社会参与者（用户、朋友、追随者）和对象（如产品、故事、基因等）之间联系模式的信息。我们将在本章后面看一些实际的例子，展示图如何用于解决数据问题，但首先让我们深入了解GraphFrames
    API。
- en: The GraphFrames API
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphFrames API
- en: 'Spark offers two distinct and powerful APIs for implementing graph algorithms
    such as PageRank, shortest paths, connected components, and triangle counting:
    GraphX and GraphFrames. GraphX is a core component of Spark based on RDDs, while
    GraphFrames (an open source external library) is based on DataFrames.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spark提供了两种不同且强大的API来实现图算法，如PageRank、最短路径、连通组件和三角形计数：GraphX和GraphFrames。GraphX是基于RDD的Spark核心组件，而GraphFrames（一个开源的外部库）则基于DataFrames。
- en: We’ll be concentrating on GraphFrames, as at the time of writing GraphX (a general-purpose
    graph processing library optimized for fast distributed computing) only has APIs
    for Scala and Java, not Python. GraphFrames provides high-level APIs in all three
    languages, so we can use it in PySpark and optionally interface with selected
    GraphX functions under the covers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将集中讨论GraphFrames，因为在撰写本文时，GraphX（一种面向快速分布式计算优化的通用图处理库）仅支持Scala和Java的API，而不支持Python。GraphFrames在这三种语言中提供了高级API，因此我们可以在PySpark中使用它，并在底层选择性地使用部分GraphX函数。
- en: In addition to the functionality of GraphX, GraphFrames offers extended functionality
    taking advantage of Spark’s DataFrames. It provides the scalability and high performance
    of DataFrames and a unified API for graph processing. GraphFrames gives us powerful
    tools for running graph queries and algorithms; among other benefits, it simplifies
    interactive graph queries and supports motif finding, also known as graph pattern
    matching.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了GraphX的功能外，GraphFrames提供了利用Spark DataFrames的扩展功能。它利用DataFrames提供的可扩展性和高性能，并为图处理提供了统一的API。GraphFrames为我们提供了运行图查询和算法的强大工具；除此之外，它简化了交互式图查询，并支持图案发现，也称为图模式匹配。
- en: '[Table 6-1](#graphframes_graphx) summarizes the key differences between the
    two libraries.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](#graphframes_graphx) 总结了这两个库之间的关键差异。'
- en: Table 6-1\. GraphFrames versus GraphX
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. GraphFrames与GraphX比较
- en: '| Feature | GraphFrames | GraphX |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | GraphFrames | GraphX |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Based on | DataFrames | RDDs |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 基于 | DataFrames | RDDs |'
- en: '| Supported languages | Scala, Java, Python | Scala, Java |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 支持的语言 | Scala, Java, Python | Scala, Java |'
- en: '| Use cases | Algorithms and queries | Algorithms |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 使用案例 | 算法和查询 | 算法 |'
- en: '| Vertex/edge attributes | Any number of DataFrame columns | Any vertex (`VD`)
    or edge (`ED`) type |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 顶点/边属性 | 任意数量的 DataFrame 列 | 任意顶点 (`VD`) 或边 (`ED`) 类型 |'
- en: '| Return types | `GraphFrame` or DataFrame | `Graph<VD,ED>` or RDD |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | `GraphFrame` 或 DataFrame | `Graph<VD,ED>` 或 RDD |'
- en: '| Supports motif finding | Yes | No direct support |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 支持模式查找 | 是 | 不支持直接 |'
- en: 'The main class in the GraphFrames library is `graphframes.GraphFrame`, which
    builds a graph using the GraphFrames API. The `GraphFrame` class is defined as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GraphFrames 库中的主要类是 `graphframes.GraphFrame`，它使用 GraphFrames API 构建图。`GraphFrame`
    类定义如下：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO1-1)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO1-1)'
- en: '`vertices` is a DataFrame.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertices` 是一个 DataFrame。'
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO1-2)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO1-2)'
- en: '`edges` is a DataFrame.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`edges` 是一个 DataFrame。'
- en: '[![3](Images/3.png)](#co_graph_algorithms_CO1-3)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_graph_algorithms_CO1-3)'
- en: Searches for structural patterns in a graph (motif finding).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中搜索结构模式（motif finding）。
- en: '[![4](Images/4.png)](#co_graph_algorithms_CO1-4)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_graph_algorithms_CO1-4)'
- en: Returns the degree of each vertex in the graph as a DataFrame.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 返回图中每个顶点的度作为 DataFrame。
- en: '[![5](Images/5.png)](#co_graph_algorithms_CO1-5)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_graph_algorithms_CO1-5)'
- en: Runs the PageRank algorithm on the graph.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在图上运行 PageRank 算法。
- en: '[![6](Images/6.png)](#co_graph_algorithms_CO1-6)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_graph_algorithms_CO1-6)'
- en: Computes the connected components of the graph.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 计算图的连通分量。
- en: How to Use GraphFrames
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 GraphFrames
- en: Let’s dive in and use the GraphFrames API to build some graphs. Since GraphFrames
    is an external package (not a main component of the Spark API), to use it in the
    PySpark shell we have to explicitly make it available. The first step is to download
    and install it. GraphFrames is a collaborative effort by UC Berkeley, MIT, and
    Databricks. You can find the latest distribution of the GraphFrames package on
    [Spark Packages](https://oreil.ly/w3neM), and the documentation is available on
    [GitHub](https://oreil.ly/T1ZBY).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入使用 GraphFrames API 来构建一些图。由于 GraphFrames 是一个外部包（不是 Spark API 的主要组件），在 PySpark
    shell 中使用它需要显式地使其可用。第一步是下载并安装它。GraphFrames 是加州大学伯克利分校（UC Berkeley）、麻省理工学院（MIT）和
    Databricks 的合作成果。你可以在 [Spark Packages](https://oreil.ly/w3neM) 找到最新的 GraphFrames
    包分发版，并且文档可以在 [GitHub](https://oreil.ly/T1ZBY) 上获取。
- en: 'You can use the `--packages` argument in the PySpark shell to download the
    GraphFrames package and any dependencies automatically. Here, I’ve specified a
    particular version of the package (`0.8.2-spark3.2-s_2.12`). To use a different
    version, just change the last part of the `--packages` argument. From the OS command
    prompt, you can import the library with the following commands (note that the
    output here has been trimmed):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 PySpark shell 中使用 `--packages` 参数自动下载 GraphFrames 包及其所有依赖项。这里，我指定了一个特定版本的包（`0.8.2-spark3.2-s_2.12`）。要使用不同的版本，只需更改
    `--packages` 参数的最后一部分。从操作系统命令提示符下，你可以使用以下命令导入该库（注意这里的输出已经被修整）：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the import succeeds, you’re ready to start using the GraphFrames API. The
    following example shows how to create a `GraphFrame`, query it, and run the PageRank
    algorithm on the graph. We’ll go into more detail on PageRank in [Chapter 8](ch08.xhtml#unique_chapter_id_08);
    for now, you just need to know that it’s an algorithm used to rank pages in web
    search results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入成功，你就可以开始使用 GraphFrames API 了。以下示例展示了如何创建一个 `GraphFrame`，对其进行查询，并在图上运行 PageRank
    算法。我们将在 [第8章](ch08.xhtml#unique_chapter_id_08) 中详细介绍 PageRank；现在你只需要知道它是用于对网页搜索结果进行排名的算法。
- en: In the GraphFrames API, a graph is represented as an instance of `GraphFrame(v,
    e)`, where `v` represents the vertices (as a DataFrame) and `e` represents the
    edges (as a DataFrame). Consider the simple graph in [Figure 6-4](#simple_graph).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphFrames API 中，图表示为 `GraphFrame(v, e)` 的实例，其中 `v` 表示顶点（作为 DataFrame），`e`
    表示边（作为 DataFrame）。考虑 [图 6-4](#simple_graph) 中的简单图。
- en: '![Three Nodes Graph](Images/daws_0605.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Three Nodes Graph](Images/daws_0605.png)'
- en: Figure 6-4\. A simple graph
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 一个简单的图
- en: In the following steps, we will build this graph using the GraphFrames API and
    apply some simple graph queries and algorithms to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将使用 GraphFrames API 构建这个图，并对其应用一些简单的图查询和算法。
- en: 'Create a vertex DataFrame with unique ID column, `id`. The `id` column is required
    by the GraphFrames API; it uniquely identifies all the vertices for the graph
    to be built. You can include additional columns too, depending on the node attributes.
    Here, we create `vertices` as a DataFrame with three columns (`DataFrame["id",
    "name", "age"]`):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有唯一ID列`id`的顶点DataFrame。GraphFrames API需要`id`列；它唯一标识要构建的图中的所有顶点。您还可以根据节点属性包括其他列。在这里，我们创建`vertices`作为一个有三列的DataFrame（`DataFrame["id",
    "name", "age"]`）：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO2-1)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO2-1)'
- en: A Python collection representing vertices.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代表顶点的Python集合。
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO2-2)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO2-2)'
- en: '`v` represents vertices as a DataFrame.'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`v` 表示顶点作为一个DataFrame。'
- en: 'Create an edge DataFrame with `src` and `dst` columns. In addition to these
    required columns, which represent the source and destination vertex IDs, you can
    include additional attributes as required. We want to store information on the
    types of relationships between nodes in our graph, so we’ll include a `relationship`
    column. Here, we create `edges` as a DataFrame with three columns (`DataFrame["src",
    "dst", "relationship"]`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`src`和`dst`列创建边DataFrame。除了这些必需的列外，它们代表源和目标顶点ID，您还可以根据需要包括其他属性。我们希望存储图中节点之间关系类型的信息，因此我们将包括一个`relationship`列。在这里，我们创建`edges`作为一个有三列的DataFrame（`DataFrame["src",
    "dst", "relationship"]`）：
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO3-1)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO3-1)'
- en: A Python collection representing edges.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代表边的Python集合。
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO3-2)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO3-2)'
- en: '`e` represents edges as a DataFrame.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`e` 表示边作为一个DataFrame。'
- en: 'The next step is to create our graph. With the GraphFrames API, a graph is
    built as an instance of `GraphFrame`, which is a pair of vertices (as `v`) and
    edges (as `e`):'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建我们的图。使用GraphFrames API，图被构建为一个`GraphFrame`实例，其中包括顶点（作为`v`）和边（作为`e`）的一对：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO4-1)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO4-1)'
- en: Import the required class `GraphFrame`.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入所需的`GraphFrame`类。
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO4-2)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO4-2)'
- en: Build a graph as an instance of `GraphFrame` using `v` (vertices) and `e` (edges).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`v`（顶点）和`e`（边）构建一个`GraphFrame`的实例来构建图。
- en: '[![3](Images/3.png)](#co_graph_algorithms_CO4-3)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_graph_algorithms_CO4-3)'
- en: Inspect the built graph.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查构建的图。
- en: 'Once the graph is built, we can start issuing queries and applying algorithms.
    For example, we can issue the following query to get the “in-degree” of each vertex
    in the graph (that is, the number of edges that terminate in that vertex):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦图被构建，我们可以开始发出查询和应用算法。例如，我们可以发出以下查询来获取图中每个顶点的“入度”（即终止于该顶点的边的数量）：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is a DataFrame with two columns: `id` (the ID of the vertex) and
    `inDegree`, which stores the in-degree of the vertex as an integer. Note that
    vertices with no incoming edges are not returned in the result.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是一个有两列的DataFrame：`id`（顶点的ID）和`inDegree`，存储顶点的入度作为整数。注意，没有入边的顶点不会在结果中返回。
- en: 'Next, let’s count the number of “follow” connections in the graph:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们计算图中“follow”连接的数量：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can run the PageRank algorithm on the graph and show the results:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在图上运行PageRank算法并展示结果：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO5-1)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO5-1)'
- en: Run the PageRank algorithm on the given graph for 20 iterations.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对给定的图运行PageRank算法20次迭代。
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO5-2)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO5-2)'
- en: Show the PageRank values for each node of the given graph.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展示给定图中每个节点的PageRank值。
- en: GraphFrames Functions and Attributes
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphFrames 函数和属性
- en: As the previous example suggests, GraphFrames functions (also known as graph
    operations, or GraphOps) give you access to a lot of details about your graphs.
    As well as various graph algorithm implementations (which we’ll examine in more
    detail in the next section), the API exposes attributes that enable you to easily
    get information about the graph’s vertices, edges, and degrees (`degrees`, `inDegrees`,
    and `outDegrees`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，GraphFrames函数（也称为图操作或GraphOps）使您可以访问有关图的许多细节。除了各种图算法实现（我们将在下一节中更详细地讨论）外，API还公开了一些属性，使您能够轻松获取有关图的顶点、边和度数（`degrees`、`inDegrees`和`outDegrees`）的信息。
- en: 'For example, if `graph` is an instance of `GraphFrame` you can get the vertices
    and edges as DataFrames as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`graph`是`GraphFrame`的一个实例，您可以按以下方式将顶点和边作为DataFrame获取：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO6-1)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO6-1)'
- en: The `Graphframe.vertices` attribute returns the graph’s vertices as a DataFrame.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graphframe.vertices`属性将图的顶点返回为一个DataFrame。'
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO6-2)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO6-2)'
- en: The `Graphframe.edges` attribute returns the graph’s edges as a DataFrame.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graphframe.edges`属性将图的边返回为一个DataFrame。'
- en: A complete list of the available attributes and functions can be found in the
    [API documentation](https://oreil.ly/6JMVO), but note that not all of those functions
    can be used with DataFrames. If you know how to work with DataFrames, you can
    also apply `sort()`, `groupBy()`, and `filter()` operations on the output of these
    functions to get more information, as we did to count the number of “follow” connections
    in our example graph (you’ll learn more about working with DataFrames in the following
    chapters).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[API 文档](https://oreil.ly/6JMVO)提供了所有可用属性和函数的完整列表，但请注意，并非所有这些函数都适用于 DataFrames。如果您了解如何操作
    DataFrames，则还可以对这些函数的输出应用`sort()`、`groupBy()`和`filter()`操作，以获取更多信息，就像我们在示例图中统计“关注”连接的数量一样（您将在后续章节中更多了解如何处理
    DataFrames）。'
- en: GraphFrames Algorithms
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphFrames 算法
- en: 'The GraphFrames API provides a set of algorithms for tasks such as finding
    a particular pattern or subgraph (also known as a “motif”) in the graph, which
    is usually an expensive operation. Since Spark uses MapReduce and distributed
    algorithms it can run these operations relatively quickly, but they are still
    time-consuming processes. In addition to motif finding (with `find()`), the supported
    algorithms include:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: GraphFrames API提供了一组算法，用于在图中查找特定模式或子图（也称为“motif”），这通常是一项昂贵的操作。由于Spark使用MapReduce和分布式算法，它可以相对快速地运行这些操作，但它们仍然是耗时的过程。除了查找模式（使用`find()`）之外，支持的算法还包括：
- en: Motif finding
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找模式
- en: Breadth-first search (BFS)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）
- en: Connected components
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连通分量
- en: Strongly connected components
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强连通分量
- en: Label propagation
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签传播
- en: PageRank
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank
- en: Shortest path
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短路径
- en: Triangle count
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形计数
- en: Let’s dig in to a few of these algorithms in more detail.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地研究其中的一些算法。
- en: Finding Triangles
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找三角形
- en: This section provides efficient solutions to find, count, and list all triangles
    for a given graph or set of graphs using the GraphFrames API. Before we look at
    an example, we need to define a triad and a triangle. Let `T = (a, b, c)` be a
    set of three distinct nodes in a graph identified by `G`. Then `T` is a triad
    if two of those nodes are connected `({(a, b), (a, c)})` and it is a triangle
    if all three nodes are connected `({(a, b), (a, c), (b, c)})`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了使用GraphFrames API查找、计数和列出给定图形或一组图形中所有三角形的高效解决方案。在我们查看示例之前，我们需要定义三元组和三角形。设
    `T = (a, b, c)` 是由 `G` 标识的图中的三个不同节点集合。如果这些节点中的两个是连接的 `({(a, b), (a, c)})`，那么 `T`
    是一个三元组；如果所有三个节点都连接 `({(a, b), (a, c), (b, c)})`，则它是一个三角形。
- en: 'In graph analysis, there are three important metrics:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在图分析中，有三个重要的度量指标：
- en: Global clustering coefficient
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局聚类系数
- en: Transitivity ratio, defined as *T* = 3 × *m* / *n*, where *m* is the number
    of triangles in the graph and *n* is the number of connected triads of vertices
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递率，定义为 *T* = 3 × *m* / *n*，其中 *m* 是图中的三角形数量，*n* 是顶点的连接三元组数量
- en: Local clustering coefficient
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部聚类系数
- en: Triangle counting (counting the number of triangles for each node in a graph)
    is a common task in social network analysis, where it’s used to detect and measure
    the cohesiveness of communities. It’s also often used in the computation of network
    indices like [clustering coefficients](https://oreil.ly/iTkRj). An efficient algorithm
    is needed for this task, as in some cases the graphs can have hundreds of millions
    of nodes (e.g., users in a social network) and edges (the relationships between
    these users).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形计数（计算图中每个节点的三角形数量）是社交网络分析中的常见任务，用于检测和衡量社区的凝聚力。它也经常用于计算网络指标，如[聚类系数](https://oreil.ly/iTkRj)。这项任务需要高效的算法，因为在某些情况下，图可能包含数亿个节点（例如社交网络中的用户）和边（这些用户之间的关系）。
- en: Triangle Counting with MapReduce
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MapReduce进行三角形计数
- en: Chapter 16 of my book [*Data Algorithms*](https://www.oreilly.com/library/view/data-algorithms/9781491906170)
    (O’Reilly) provides two MapReduce solutions that find, count, and list all triangles
    for a given graph or set of graphs. Solutions are provided in Java, MapReduce,
    and Spark.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我的书[*Data Algorithms*](https://www.oreilly.com/library/view/data-algorithms/9781491906170)（O'Reilly）的第16章提供了两种MapReduce解决方案，用于查找、计数和列出给定图形或一组图形中的所有三角形。解决方案以Java、MapReduce和Spark提供。
- en: The GraphFrames package provides a convenient method, `GraphFrame.triangleCount()`,
    that computes the number of triangles passing through each vertex. Let’s walk
    through an example that shows how to build a graph from nodes and edges and then
    find the number of triangles passing through each node.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: GraphFrames包提供了一个方便的方法，`GraphFrame.triangleCount()`，用于计算通过每个顶点的三角形数量。让我们通过一个示例来展示如何从节点和边构建图，然后找到通过每个节点的三角形数量。
- en: 'Step 1: Build a graph'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤1：构建图
- en: 'First, we’ll define the vertices:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义顶点：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we define the edges between nodes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义节点之间的边：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have vertices and edges, we can build a graph:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了顶点和边，我们可以构建一个图：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO7-1)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO7-1)'
- en: The `id` column is required for a vertex DataFrame.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点DataFrame需要`id`列。
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO7-2)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO7-2)'
- en: The `src` and `dst` columns are required for an edge DataFrame.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 边DataFrame需要`src`和`dst`列。
- en: '[![3](Images/3.png)](#co_graph_algorithms_CO7-3)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_graph_algorithms_CO7-3)'
- en: The graph is built as a `GraphFrame` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图被构建为一个`GraphFrame`对象。
- en: 'Now let’s examine the graph and its vertices and edges:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查图及其顶点和边：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Step 2: Count triangles'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2：计算三角形
- en: 'Next, we’ll use the `GraphFrame.triangleCount()` method to count the number
    of triangles passing through each vertex in this graph:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`GraphFrame.triangleCount()`方法计算该图中通过每个顶点的三角形数量：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To show only the vertex IDs and the number of triangles passing through each
    vertex, we can write:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅显示顶点ID和通过每个顶点的三角形数量，我们可以编写：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The results suggest that there are three triangles in our graph. However, these
    are all really the same triangle, with different roots:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明我们的图中有三个三角形。然而，这些实际上是同一个三角形，具有不同的根：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next section, I will show you how to use the GraphFrames API’s motif
    finding algorithm to drop duplicate triangles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向您展示如何使用GraphFrames API的模式查找算法来消除重复的三角形。
- en: Motif Finding
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找模式
- en: Motifs in graphs are patterns of interactions between vertices, such as triangles
    and other subgraphs. For example, since Twitter data is not bidirectional (if
    Alex follows Bob, there’s no guarantee that Bob will follow Alex), we can use
    motif finding to find all bidirectional user relationships. Motif finding enables
    us to execute queries to discover a variety of structural patterns in graphs,
    and the GraphFrames API provides strong support for this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的模式是顶点之间的交互模式，例如三角形和其他子图。例如，由于Twitter数据不是双向的（如果Alex关注Bob，并不意味着Bob会关注Alex），我们可以使用模式查找来查找所有双向用户关系。模式查找使我们能够执行查询，以发现图中各种结构模式，而GraphFrames
    API为此提供了强大的支持。
- en: 'GraphFrames uses a simple domain-specific language (DSL) for expressing structural
    queries. For example, the following query:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: GraphFrames使用一种简单的领域特定语言（DSL）来表达结构查询。例如，以下查询：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: will search for pairs of vertices `{a, b}` connected by edges in both directions
    (bi-directional relationships). It will return a DataFrame of all such structures
    in the graph, with columns for each of the named elements (vertices or edges)
    in the motif. In this case, the returned columns will be "`a, b, e1, e2`" (where
    `e1` represents an edge from `a` to `b` and `e2` represents an edge from `b` to
    `a`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将在图中搜索由边双向连接的顶点对`{a, b}`。它将返回一个DataFrame，其中包含图中所有这种结构，列分别为模式中每个命名元素（顶点或边）。在本例中，返回的列将是"`a,
    b, e1, e2`"（其中`e1`表示从`a`到`b`的边，`e2`表示从`b`到`a`的边）。
- en: 'In the GraphFrames framework, the DSL for expressing structural patterns is
    defined as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphFrames框架中，表达结构模式的DSL定义如下：
- en: The basic unit of a pattern is an edge. An edge connects one node to another
    one; for example, `"(a)-[e]->(b)"` expresses an edge `e` from vertex `a` to vertex
    `b`. Note that vertices are denoted by parentheses (`(a)` and `(b)`), while edges
    are denoted by square brackets (`[e]`).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式的基本单位是边。一条边连接一个节点到另一个节点；例如，`"(a)-[e]->(b)"`表示从顶点`a`到顶点`b`的边`e`。请注意，顶点由圆括号表示（`(a)`和`(b)`），而边由方括号表示（`[e]`）。
- en: A pattern is expressed as a union of edges. Edge patterns can be joined with
    semicolons (`;`). For example, the motif `"(a)-[e1]->(b); (b)-[e2]->(c)"` specifies
    two edges (`e1` and `e2`), from `a` to `b` and `b` to `c`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式被表达为边的并集。边模式可以用分号连接（`;`）。例如，模式`"(a)-[e1]->(b); (b)-[e2]->(c)"`指定了两条边（`e1`和`e2`），从`a`到`b`和从`b`到`c`。
- en: 'Within a pattern, names can be assigned to vertices and edges. For example,
    `"(a)-[e]->(b)"` has three named elements: vertices `{a, b}` and an edge `e`.
    These names serve two purposes:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模式中，名称可以分配给顶点和边缘。例如，`"(a)-[e]->(b)"`有三个命名元素：顶点`{a, b}`和边缘`e`。这些名称有两个作用：
- en: The names can identify common elements among edges. For example, `"(a)-[e1]->(b);
    (b)-[e2]->(c)"` specifies that the same vertex `b` is the destination of edge
    `e1` and the source of edge `e2`.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称可以识别边缘之间的共同元素。例如，`"(a)-[e1]->(b); (b)-[e2]->(c)"`指定了相同的顶点`b`是边缘`e1`的目的地和边缘`e2`的源。
- en: The names are used as column names in the resulting DataFrame. For example,
    if a motif contains named vertex `a`, then the resulting DataFrame will contain
    a column `a` which is a `StructType` with subfields equivalent to the schema (columns)
    of `GraphFrame.vertices`. Similarly, an edge `e` in a motif will produce a column
    `e` in the resulting DataFrame with subfields equivalent to the schema (columns)
    of `GraphFrame.edges`.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些名称被用作结果DataFrame中的列名。例如，如果模式包含命名的顶点`a`，则结果DataFrame将包含一个名为`a`的列，其`StructType`子字段等效于`GraphFrame.vertices`的模式（列）。类似地，模式中的边缘`e`将在结果DataFrame中产生一个名为`e`的列，其子字段等效于`GraphFrame.edges`的模式（列）。
- en: It is acceptable to omit names for vertices or edges in motifs when they are
    not needed. For example, the motif `"(a)-[]->(b)"` expresses an edge between vertices
    `a` and `b` but does not assign a name to the edge. There will be no column for
    the anonymous edge in the resulting DataFrame. Similarly, the motif `"(a)-[e]->()"`
    indicates an out-edge of vertex `a` but does not name the destination vertex,
    and `"()-[e]->(b)"` indicates an in-edge of vertex `b` but does not name the source
    vertex.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不需要时，可以省略模式中顶点或边缘的名称。例如，模式`"(a)-[]->(b)"`表示顶点`a`到`b`之间的边缘，但不为该边缘分配名称。在结果DataFrame中将没有匿名边缘的列。类似地，模式`"(a)-[e]->()"`表示顶点`a`的出边缘，但不命名目标顶点，而`"()-[e]->(b)"`表示顶点`b`的入边缘，但不命名源顶点。
- en: An edge can be negated by using an exclamation point (`!`) to indicate that
    the edge should not be present in the graph. For example, the motif `(a)-[]->(b);
    !(b)-[]->(a)` finds edges from `a` to `b` for which there is no edge from `b`
    to `a` (“a” follows “b”, but “b” does not follow “a”).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用感叹号（`!`）来否定边缘，以表示图中不应存在的边缘。例如，模式`(a)-[]->(b); !(b)-[]->(a)`找到从`a`到`b`的边缘，但从`b`到`a`没有边缘（“a”跟随“b”，但“b”不跟随“a”）。
- en: Triangle counting with motifs
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模式进行三角形计数
- en: 'The motif finding algorithm in the GraphFrames API enables us to find structural
    patterns (such as triangles) in a graph easily by defining a motif. For example,
    if `"{a, b, c}"` denotes three nodes in a graph, then we can define a motif for
    a triangle as:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphFrames API 中的模式查找算法使我们能够通过定义模式轻松地在图中找到结构模式（如三角形）。例如，如果`"{a, b, c}"`表示图中的三个节点，则我们可以将三角形的模式定义为：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This definition includes three vertices (`a`, `b`, and `c`) such that:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义包括三个顶点（`a`、`b`和`c`），使得：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can also build more complex relationships involving edges and vertices using
    motifs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用模式构建涉及边缘和顶点的更复杂的关系。
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To help you understand the concept of motif finding, let’s look at another
    example. Given a `GraphFrame` object `g`, we will walk through a few trials to
    find the optimal way of identifying triangles. Assume that our graph is undirected:
    if we have an edge `[a -> b]`, then we will have another edge as `[b -> a]`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解模式查找的概念，让我们看另一个例子。给定一个`GraphFrame`对象`g`，我们将通过几个试验来找到识别三角形的最佳方法。假设我们的图是无向的：如果我们有一个边缘`[a
    -> b]`，那么我们将有另一个边缘`[b -> a]`。
- en: Trial 1
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 试验 1
- en: 'Our first approach will be to find a triangle as `"a -> b -> c -> a"`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种方法是将三角形视为`"a -> b -> c -> a"`：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This trial finds triangles, but there is problem with duplicated output (since
    our graph is undirected).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个试验找到了三角形，但由于我们的图是无向的，存在重复输出的问题。
- en: Trial 2
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 试验 2
- en: 'Let’s try again, this time adding a filter to remove duplicate triangles. This
    filter ensures that `e1.src` and `e1.dst` are not the same:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次，这次添加一个过滤器来去除重复的三角形。这个过滤器确保了`e1.src`和`e1.dst`不相同：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is better, but we still have some duplicates in our results.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法更好，但我们的结果中仍然有一些重复。
- en: Trial 3
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 试验 3
- en: 'In our final trial, we’ll add another filter that will enable us to uniquely
    identify all triangles without duplicates:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终试验中，我们将添加另一个过滤器，可以确保我们唯一地识别所有的三角形而没有重复：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO8-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO8-1)'
- en: Find triangles `{a -> b -> c -> a}`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 找到三角形`{a -> b -> c -> a}`。
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO8-2)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO8-2)'
- en: Make sure that `e1.src` and `e1.dst` are not the same.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `e1.src` 和 `e1.dst` 不相同。
- en: '[![3](Images/3.png)](#co_graph_algorithms_CO8-3)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_graph_algorithms_CO8-3)'
- en: Make sure that `e2.src` and `e2.dst` are not the same.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `e2.src` 和 `e2.dst` 不相同。
- en: Finding unique triangles with motifs
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模式查找唯一的三角形
- en: In this section I’ll show you how to build a `GraphFrame` from a set of vertices
    and edges, and then find the unique triangles in the graph.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何从一组顶点和边构建 `GraphFrame`，然后在图中找到唯一的三角形。
- en: Input
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The required components for building a graph (using GraphFrames) are vertices
    and edges. Assume that our vertices and edges are defined in two files:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 构建图所需的组件（使用 GraphFrames）是顶点和边。假设我们的顶点和边在两个文件中定义：
- en: '*sample_graph_vertices.txt*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sample_graph_vertices.txt*'
- en: '*sample_graph_edges.txt*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sample_graph_edges.txt*'
- en: 'Let’s examine these input files:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些输入文件：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To comply with the GraphFrames API, we’ll perform the following cleanup and
    filtering tasks:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合 GraphFrames API，我们将执行以下清理和过滤任务：
- en: Rename `vertex_id` to `id`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vertex_id` 重命名为 `id`。
- en: Drop the column `edge_weight`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `edge_weight` 列。
- en: Rename `from_id` to `src`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `from_id` 重命名为 `src`。
- en: Rename `to_id` to `dst`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `to_id` 重命名为 `dst`。
- en: Output
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'The expected output will be unique triangles from the built graph. Note that
    given three vertices `{a, b, c}` of a triangle, it can be represented in any of
    the following six ways:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出将是构建图中唯一的三角形。请注意，给定三个顶点 `{a, b, c}` 的三角形可以以以下六种方式的任何一种表示：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The goal is to output only one of these representations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是仅输出其中一种表示方式。
- en: Algorithm
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算法
- en: 'The complete PySpark solution is presented as *unique_triangles_finder.py*.
    Using the GraphFrames motif finding algorithm and DataFrames, the solution is
    pretty simple:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 PySpark 解决方案被称为 *unique_triangles_finder.py*。利用 GraphFrames 模式发现算法和 DataFrames，解决方案非常简单：
- en: 'Create a DataFrame for vertices: `vertices_df`.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为顶点创建一个 DataFrame：`vertices_df`。
- en: 'Create a DataFrame for edges: `edges_df`.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为边创建一个 DataFrame：`edges_df`。
- en: Build a graph as a `GraphFrame`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 `GraphFrame` 构建图。
- en: Apply a motif which is a triangle pattern.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用一个三角形模式。
- en: Filter out duplicate triangles.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉重复的三角形。
- en: Building `vertices_df` is straightforward. In building `edges_df`, to make sure
    that our graph is undirected, if there is a connection from a `src` vertex to
    a `dst` vertex, then we add an extra edge from `dst` to `src`. This way we will
    be able to find all the triangles.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 `vertices_df` 很简单。在构建 `edges_df` 时，为了确保我们的图是无向的，如果有一个连接从 `src` 顶点到 `dst`
    顶点，那么我们会添加一个额外的边从 `dst` 到 `src`。这样我们就能找到所有的三角形。
- en: 'We’ll start by finding all the triangles, including potential duplicates:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从找到所有三角形开始，包括潜在的重复：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we’ll use the DataFrame’s powerful filtering mechanism to remove duplicate
    triangles, keeping only one representation of a triangle `{a, b, c}` where `a
    > b > c`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 DataFrame 强大的过滤机制来移除重复的三角形，仅保留 `{a, b, c}` 中 `a > b > c` 的一种表示：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO9-1)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO9-1)'
- en: Remove duplicate triangles.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 移除重复的三角形。
- en: Note that `motifs.count()` returned `42` (since a triangle can be represented
    in six different ways, as shown earlier) and `unique_triangles.count()` returns
    `7` (6 × 7 = 42)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`motifs.count()` 返回了 `42`（因为三角形可以有六种不同的表示方式，如前所示），而 `unique_triangles.count()`
    返回了 `7`（6 × 7 = 42）。
- en: Other motif finding examples
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他模式查找示例
- en: The combination of GraphFrames and DataFrames is a very powerful tool for solving
    graph-related problems and beyond. I’ve demonstrated how to use motifs to find
    triangles, but there are many other applications. We’ll look at a few of them
    here.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: GraphFrames 和 DataFrames 的组合是解决与图相关问题及其他问题的强大工具。我展示了如何使用模式来查找三角形，但还有许多其他应用。我们将在这里看几个例子。
- en: Finding bidirectional vertices
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找双向顶点
- en: 'Using motifs, you can build more complex relationships involving a graph’s
    edges and vertices. The following example finds the pairs of vertices with edges
    in both directions between them. The result is a DataFrame in which the column
    names are motif keys. Let `graph` be an instance of a `GraphFrame`. Then, finding
    bidirectional vertices can be expressed as:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式，您可以构建涉及图的边和顶点更复杂的关系。以下示例找到具有两个方向上的边的顶点对。结果是一个 DataFrame，其中列名是模式键。假设 `graph`
    是一个 `GraphFrame` 的实例。然后，找到双向顶点可以表示为：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO10-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO10-1)'
- en: '`bidirectional` will have columns `a`, `e1`, `b`, and `e2`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`bidirectional` 将具有列 `a`、`e1`、`b` 和 `e2`。'
- en: 'Since the result is a DataFrame, more complex queries can build on top of the
    motif. For instance, we can find all the reciprocal relationships in which one
    person is older than 30 as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果是一个DataFrame，更复杂的查询可以建立在这种主题之上。例如，我们可以找到所有逆向关系，其中一个人年龄超过30岁，如下所示：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finding subgraphs
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找子图
- en: 'A subgraph is a graph whose vertices and edges are subsets of another graph.
    You can build subgraphs by filtering on a subset of edges and vertices. For example,
    we can construct a subgraph containing only relationships where the follower is
    younger than the user being followed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 子图是图的顶点和边是另一个图的子集。您可以通过过滤顶点和边的子集来构建子图。例如，我们可以构建一个仅包含关注者比被关注用户年轻的关系的子图：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Friend recommendation
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 朋友推荐
- en: 'Another common task in social networks that is made easy by the GraphFrames
    motif finding algorithm is making friend recommendations. For example, to recommend
    whom users might like to follow, we might search for triplets of users `(A, B,
    C)` where "`A` follows `B`" and "`B` follows `C`,” but "`A` does not follow `C`.”
    This can be expressed as:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: GraphFrames motif查找算法使得在社交网络中另一个常见任务变得简单，即进行朋友推荐。例如，为了推荐用户可能喜欢关注的人，我们可能搜索用户三元组`(A,
    B, C)`，其中"`A`关注`B`"且"`B`关注`C`"，但"`A`不关注`C`"。这可以表示为：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Product recommendations
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 产品推荐
- en: As a final example, we’ll look at product recommendations. Consider a case where
    a customer who bought product `p` also purchased two other products, `a` and `b`.
    This relationship is depicted in [Figure 6-6](#product_recommendation).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，我们将看一下产品推荐。考虑一个情况，一个购买了产品`p`的客户还购买了另外两个产品，`a`和`b`。这种关系显示在[图 6-6](#product_recommendation)中。
- en: '![Product Relationships](Images/daws_0607.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![产品关系](Images/daws_0607.png)'
- en: Figure 6-6\. Relationship between purchased products
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-6\. 购买产品之间的关系
- en: 'There are two separate edges, from product `p` to `a` and `b`. Therefore, this
    motif can be expressed as:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有两条单独的边，从产品`p`到`a`和`b`。因此，这个motif可以表示为：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also apply filters to the result of motif finding. For example, here
    we specify the value of the vertex `p` as `1200` (denoting the product with that
    `id`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对motif查找的结果应用过滤器。例如，在这里我们指定顶点`p`的值为`1200`（表示具有该`id`的产品）：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The following example shows how to find strong relationships between two products
    (i.e., products that are often purchased together). In this example, we specify
    edges from `p` to `a` and `a` to `b`, and another one from `b` to `a`. This pattern
    typically represents the case in which when a customer buys a product `p`, they
    may also buy `a` and then go on to buy `b`. This can be indicative of some prioritization
    of the items being purchased (see [Figure 6-7](#product_relationships)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示如何查找两个产品之间的强关系（即经常一起购买的产品）。在这个例子中，我们指定从`p`到`a`和`a`到`b`的边，以及从`b`到`a`的另一条边。这种模式通常表示当客户购买产品`p`时，他们可能还会购买`a`，然后继续购买`b`。这可能表明正在购买的项目的一些优先级（参见[图 6-7](#product_relationships)）。
- en: '![Product Relationships](Images/daws_0608.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![产品关系](Images/daws_0608.png)'
- en: Figure 6-7\. Product relationships
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-7\. 产品关系
- en: 'The motif for finding products with this type of relationship can be expressed
    as:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 找到具有这种类型关系的产品的主题可以表示为：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Recall that in motif definition the notation `[e]` denotes an edge labeled as
    `e`, while `[]` denotes an edge without a name.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在motif定义中，符号`[e]`表示标记为`e`的边，而`[]`表示没有名称的边。
- en: Next, we’ll dive into some real-world examples of how GraphFrames can be used.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨一些实际世界中使用GraphFrames的例子。
- en: Real-World Applications
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用
- en: The purpose of this section is to present some real-world applications using
    the motif finding feature of the GraphFrames API.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是介绍使用GraphFrames API的motif查找功能的一些实际应用。
- en: Gene Analysis
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基因分析
- en: 'Let’s start by walking through an example of how to use GraphFrames along with
    motifs for gene analysis. A gene is a unit of heredity that is transferred from
    a parent to its offspring and is held to determine some characteristic of the
    offspring. Gene relationships have been analyzed for Down syndrome with [labeled
    transition graphs](https://oreil.ly/mc3Ip) based on gene interaction data (directed
    graphs where vertices represent genes and an edge represents a relationship between
    genes). For example, three vertices (XAB2, ERCC8, and POLR2A, denoting three genes)
    and two edges (denoting the interactions between them) can be represented by the
    following raw data:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示如何使用GraphFrames和motifs进行基因分析。基因是从父代传递给后代并据以确定后代某些特征的遗传单位。基因关系已经分析过与[标记过渡图](https://oreil.ly/mc3Ip)相关的唐氏综合征的基因互动数据（顶点表示基因，边表示基因之间的关系的有向图）。例如，三个顶点（XAB2、ERCC8和POLR2A，表示三个基因）和两条边（表示它们之间的互动）可以用以下原始数据表示：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One important analysis is to find motifs between specific vertices, which can
    help detect conditions like Down syndrome or Alzheimer’s disease. Examples include
    the Hedgehog signaling pathway (HSP), illustrated in [Figure 6-8](#hedgehog_singaling_pathway_relationship),
    and the gene regulatory network shown in [Figure 6-9](#alzheimers_disease_relationship).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的分析是找到特定顶点之间的motif，这有助于检测类似于唐氏综合征或阿尔茨海默病的情况。例如，刺猬信号通路（HSP），在[图6-8](#hedgehog_singaling_pathway_relationship)中说明，以及基因调控网络显示在[图6-9](#alzheimers_disease_relationship)中。
- en: '![daws 0609](Images/daws_0609.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![daws 0609](Images/daws_0609.png)'
- en: Figure 6-8\. The Hedgehog signaling pathway relationship
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-8。刺猬信号通路关系
- en: '![daws 0610](Images/daws_0610.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![daws 0610](Images/daws_0610.png)'
- en: Figure 6-9\. Gene regulatory network linked to Alzheimer’s disease
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-9。与阿尔茨海默病相关的基因调控网络
- en: These patterns and relationships can be easily detected by the GraphFrames API’s
    motif finding feature. We can also find the most important genes using the PageRank
    algorithm, or find gene communities by running label propagation algorithm for
    many iterations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式和关系可以通过GraphFrames API的motif查找功能轻松检测到。我们还可以使用PageRank算法找到最重要的基因，或者通过运行标签传播算法多次迭代来找到基因社群。
- en: 'Let’s walk through building the graph. The input has the following format:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步构建图表。输入的格式如下：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here are a few examples of what the input records look like:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些输入记录的示例：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since we have input only for edges, we will derive the vertices from the edges.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有边的输入，我们将从边中推导顶点。
- en: Motif finding for genes
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为基因查找motif
- en: 'Earlier, I showed two structural patterns. To express the HSP as a motif, we
    would write:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我展示了两种结构模式。为了表达HSP作为一个主题，我们会写：
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is very powerful and straightforward: search for three nodes connected
    to each other, and further restrict them to specific nodes.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大且直接：搜索彼此连接的三个节点，并进一步限制它们到特定节点。
- en: Social Recommendations
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社会推荐
- en: Recommendation systems are popular these days in applications like social networks
    (such as Twitter and Facebook) and shopping sites (such as Amazon). In this section,
    based on the blog post [“Using Graphframes for Social Recommendation”](https://oreil.ly/SDNka)
    by Hamed Firooz, I’ll show you how to build a simple social recommendation system
    using Spark’s GraphFrames package.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统在当今应用非常广泛，如社交网络（例如Twitter和Facebook）和购物网站（例如Amazon）。在本节中，基于Hamed Firooz的博客文章[“使用Graphframes进行社交推荐”](https://oreil.ly/SDNka)，我将向您展示如何使用Spark的GraphFrames包构建一个简单的社交推荐系统。
- en: 'Let’s assume that we have two types of objects: users and tables, which contain
    messages sent between users. These objects will be represented as vertices in
    a graph), and the relationships between them will be represented as edges. Users
    can follow each other, and this is a one-way connection (unlike the “friend” relationship
    on Facebook, which is bidirectional). Tables contain two types of data: public
    and private. A user can choose to either “follow” a table, which gives them access
    to public messages, or be a “member” of table, which gives them access to all
    messages and also the ability to send messages to other members and followers
    of the table.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两种对象：用户和表格，它们包含用户之间发送的消息。这些对象将作为图中的顶点表示，并且它们之间的关系将作为边表示。用户可以互相关注，这是单向连接（不像Facebook上的“朋友”关系是双向的）。表格包含两种类型的数据：公共和私有。用户可以选择“关注”表格，这样他们就可以访问公共消息，或者成为表的“成员”，这样他们可以访问所有消息，还可以向表的成员和关注者发送消息。
- en: We’ll base our analysis on the sample graph in [Figure 6-10](#sample_social_graph),
    which shows data for six users and three tables.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于图6-10的示例图进行分析，该图显示了六个用户和三个表的数据。
- en: '![daws 0611](Images/daws_0611.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![daws 0611](Images/daws_0611.png)'
- en: 'Figure 6-10\. Sample social graph (Source: [“Using Graphframes for Social Recommendation”](https://oreil.ly/SDNka))'
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-10\. 示例社交图（来源：[“使用Graphframes进行社交推荐”](https://oreil.ly/SDNka)）
- en: 'Given this graph, suppose we want to recommend that person B follow person
    A if the following four conditions are satisfied:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个图，假设我们希望推荐B关注A，如果满足以下四个条件：
- en: A and B are not connected. A does not follow B, and B does not follow A.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A和B没有连接。A不关注B，B也不关注A。
- en: A and B have at least four nodes in common. This means they each are connected
    to at least four nodes.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A和B至少有四个共同的节点。这意味着它们各自连接至少四个节点。
- en: At least two of those four nodes are tables.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少有两个那四个节点是表格。
- en: A is a member of those two tables.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A是这两个表格的成员。
- en: 'We can express this using the GraphFrames motif finding algorithm as follows
    (recall from [“Motif Finding”](#motif_finding) that the `!` character indicates
    negation; i.e., that the edge should not be present in the graph):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过GraphFrames模式查找算法来表达这一点，如下所示（从[“模式查找”](#motif_finding)中回忆，“!”字符表示否定；即，该边不应存在于图中）：
- en: 'Remember that GraphFrame motif finding uses a domain-specific language (DSL)
    for expressing structural pattern and queries. For example, the following motif
    finds the triangles by using the `find()` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，GraphFrame模式查找使用领域特定语言（DSL）来表示结构模式和查询。例如，以下模式使用`find()`函数查找三角形：
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'will search for triangles as pairs of vertices “a, b, and c” such that:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 将搜索三角形作为“a、b和c”顶点对。
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It will return a DataFrame of all such structures in the graph, with columns
    for each of the named elements (vertices or edges) in the motif. In this case,
    the returned columns will be `"a, b, c, e1, e2, e3"`. To express negation in motif
    finding, the exclamation (“!”) character is used; an edge can be negated to indicate
    that the edge should not be present in the graph. For example, the following motif:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回图中所有这样的结构的DataFrame，每个命名元素（顶点或边）在模式中都有对应的列。在这种情况下，返回的列将是`"a, b, c, e1, e2,
    e3"`。在模式查找中表达否定时，使用感叹号（“!”）字符；边可以被否定，以指示图中不应存在该边。例如，以下模式：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: finds edges from “a to b” for which there is no edge from “b to a”.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 查找从“a到b”的边，其中没有从“b到a”的边。
- en: 'Our social recommendation can be achieved by GraphFrames “motif finding”:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的社交推荐可以通过GraphFrames的“模式查找”实现：
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO11-1)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO11-1)'
- en: Make sure `a` and `b` are not connected.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`a`和`b`没有连接。
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO11-2)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO11-2)'
- en: Make sure that at least two of those four nodes to which both `a` and `b` are
    connected are of type `'table'`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 确保至少有两个那四个节点，`a`和`b`都连接的节点类型为`'table'`。
- en: '[![3](Images/3.png)](#co_graph_algorithms_CO11-3)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_graph_algorithms_CO11-3)'
- en: Make sure `a` is not the same as `b`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`a`不同于`b`。
- en: '[![4](Images/4.png)](#co_graph_algorithms_CO11-4)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_graph_algorithms_CO11-4)'
- en: Make sure the four nodes are not the same.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 确保四个节点不相同。
- en: 'The output will be:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is a good example of the power of motif finding in GraphFrames. We are
    interested in finding two nodes `{a, b}`, which are both connected to four other
    nodes `{c1, c2, c3, c4}`. This is expressed as:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 GraphFrames 中使用 Motif 查找的一个很好的例子。我们有兴趣找到两个节点 `{a, b}`，它们都连接到另外四个节点 `{c1,
    c2, c3, c4}`。这可以表示为：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The motif expresses the following rules:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Motif 表达了以下规则：
- en: '`a` and `b` are not connected to each other. This is expressed as:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 和 `b` 之间没有连接。这可以表示为：'
- en: '[PRE45]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At least two of those four nodes are tables. This is expressed using two filters:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这四个节点中至少有两个是表。这可以使用两个过滤器来表示：
- en: '[PRE46]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`a` and `b` are not the same user. This is expressed as:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 和 `b` 不是同一个用户。这可以表示为：'
- en: '[PRE47]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`a` and `b` are connected to four unique nodes. This is expressed as:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 和 `b` 连接到四个唯一的节点。这可以表示为：'
- en: '[PRE48]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, since there are many ways to traverse the graph for a given motif,
    we want to make sure that we eliminate the duplicate entries. We can do this as
    follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于在给定的 Motif 下遍历图的方式有很多种，我们希望确保消除重复的条目。我们可以这样做：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Facebook Circles
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Facebook 圈子
- en: In this section we will use motif finding to analyze Facebook relationships.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Motif 查找来分析 Facebook 关系。
- en: Input
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入
- en: For input, we’ll use data from the [Stanford Network Analysis Project (SNAP)](https://oreil.ly/j9ZJA)
    consisting of “circles” (or “friends lists”) from Facebook. The data was collected
    from survey participants using a Facebook app and has been anonymized. The dataset
    includes node features (profiles), circles, and ego networks.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入，我们将使用来自 [Stanford Network Analysis Project (SNAP)](https://oreil.ly/j9ZJA)
    的数据，这些数据包括来自 Facebook 的“圈子”（或“朋友列表”）。该数据是通过使用 Facebook 应用程序对调查参与者进行匿名化收集的。数据集包括节点特征（配置文件）、圈子和自我网络。
- en: 'Let’s take at a look at the downloaded data:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下载的数据：
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This tells us that we have 4,039 vertices and 88,235 edges. Next, we’ll examine
    the first few lines of each file. As you can see, these files have headers that
    we can use as column names when we create our DataFrames (I’ve renamed the columns
    to follow the GraphFrames guidelines):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们有 4,039 个顶点和 88,235 条边。接下来，我们将检查每个文件的前几行。正如您所见，这些文件有我们在创建 DataFrames 时可以用作列名的标头（我已经按照
    GraphFrames 的指南重命名了列）：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Building the graph
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建图
- en: 'Since we have vertices and edges as CSV files with headers, our first step
    is to build DataFrames for these. We’ll start with the `vertices` DataFrame:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有顶点和边作为带有标头的 CSV 文件，我们的第一步是为这些文件构建 DataFrames。我们将从 `vertices` DataFrame
    开始：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO12-1)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO12-1)'
- en: '`spark` is an instance of `SparkSession`.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`spark` 是 `SparkSession` 的一个实例。'
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO12-2)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO12-2)'
- en: Return a `DataFrameReader` to read the input file.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个 `DataFrameReader` 以读取输入文件。
- en: '[![3](Images/3.png)](#co_graph_algorithms_CO12-3)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_graph_algorithms_CO12-3)'
- en: Specify the type of file to be read.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要读取的文件类型。
- en: '[![4](Images/4.png)](#co_graph_algorithms_CO12-4)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_graph_algorithms_CO12-4)'
- en: Indicate that the input CSV file has a header.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 指示输入的 CSV 文件有一个标头。
- en: '[![5](Images/5.png)](#co_graph_algorithms_CO12-5)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_graph_algorithms_CO12-5)'
- en: Infer the DataFrame schema from the input file; this option requires one extra
    pass over the data and is `false` by default.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入文件推断 DataFrame 的模式；该选项需要对数据进行额外的一次传递，默认为 `false`。
- en: '[![6](Images/6.png)](#co_graph_algorithms_CO12-6)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_graph_algorithms_CO12-6)'
- en: Provide the path for the CSV file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 提供 CSV 文件的路径。
- en: 'Then build and inspect our `edges` DataFrame:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后构建并检查我们的 `edges` DataFrame：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[![1](Images/1.png)](#co_graph_algorithms_CO13-1)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_graph_algorithms_CO13-1)'
- en: '`spark` is an instance of `SparkSession`.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`spark` 是 `SparkSession` 的一个实例。'
- en: '[![2](Images/2.png)](#co_graph_algorithms_CO13-2)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_graph_algorithms_CO13-2)'
- en: Return a `DataFrameReader` to read the input file.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个 `DataFrameReader` 以读取输入文件。
- en: '[![3](Images/3.png)](#co_graph_algorithms_CO13-3)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_graph_algorithms_CO13-3)'
- en: Specify the type of file to be read.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要读取的文件类型。
- en: '[![4](Images/4.png)](#co_graph_algorithms_CO13-4)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_graph_algorithms_CO13-4)'
- en: Indicate that the input CSV file has a header.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 指示输入的 CSV 文件有一个标头。
- en: '[![5](Images/5.png)](#co_graph_algorithms_CO13-5)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_graph_algorithms_CO13-5)'
- en: Infer the DataFrame schema from the input file.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入文件推断 DataFrame 的模式。
- en: '[![6](Images/6.png)](#co_graph_algorithms_CO13-6)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_graph_algorithms_CO13-6)'
- en: Provide the path for the CSV file.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 提供 CSV 文件的路径。
- en: 'Once we have our two DataFrames, we can create the `GraphFrame` object:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了两个 DataFrames，我们可以创建 `GraphFrame` 对象：
- en: '[PRE54]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Motif finding
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Motif 查找
- en: 'Now that we’ve built our graph, we can do some analysis. First, we’ll find
    all connected vertices with the same birthday:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们建立了图表，可以进行一些分析。首先，我们将找到所有具有相同生日的连接顶点：
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we’ll count the number of triangles passing through each vertex in this
    graph:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将统计通过每个顶点的三角形数：
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following graph query finds “friends of friends” who are not connected
    to each other, but who graduated the same year from the same school:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图查询找到了“朋友的朋友”，他们彼此之间没有连接，但是他们从同一所学校的同一年毕业：
- en: '[PRE57]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we run the PageRank algorithm on our graph:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在图上运行 PageRank 算法：
- en: '[PRE58]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Connected Components
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接组件
- en: Given millions of DNA samples and data on the genomic relationships between
    each pair of samples, how do you find connected families? Given social networks
    (such as Facebook or Twitter), how do you identify connected communities? To solve
    these kinds of problems, you can use the connected components algorithm.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 给定数百万个 DNA 样本和样本间基因组关系数据，如何找出连接的家族？给定社交网络（如 Facebook 或 Twitter），如何识别连接的社区？为了解决这些问题，可以使用连接组件算法。
- en: 'The goal of this algorithm is to identify independent, disconnected subgraphs.
    Before I present the algorithm itself, let’s define the concept of connected components.
    Let `G` be a graph defined as a set of vertices `V` and a set of edges `E`, where
    each edge is a pair of vertices:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法的目标是识别独立的、不相连的子图。在我介绍算法本身之前，让我们定义连接组件的概念。让 `G` 是一个图，定义为顶点集 `V` 和边集 `E`，其中每条边都是一对顶点：
- en: '[PRE59]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A path from `x` in `V` to `y` in `V` can then be described by a sequence of
    vertices:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `V` 中的 `x` 到 `V` 中的 `y` 的路径可以通过顶点序列描述：
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: where we have an edge from `u[i]` to `u[{i+1}]` for each `0 <= i <= n-1`. Note
    that vertices can repeat, allowing the path to cross or fold onto itself. Now,
    we can define a connected component. We say that a graph `G` is connected if there
    is a path between every pair of vertices. So, we can say that a connected component
    of a graph is a sub-graph in which any two vertices are connected to each other
    by paths, and which is connected to no additional vertices in the supergraph.
    The smallest connected component can be a single vertex, which does not connect
    to any other vertex. For example, the graph in [Figure 6-11](#connected_components_example)
    has three connected components.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们从 `u[i]` 到 `u[{i+1}]` 每个 `0 <= i <= n-1` 有一条边。请注意，顶点可以重复，允许路径交叉或折叠到自身。现在，我们可以定义一个连接组件。我们说一个图
    `G` 是连通的，如果每对顶点之间存在路径。因此，我们可以说图的一个连接组件是一个子图，在这个子图中，任意两个顶点通过路径连接，并且它与超图中的其他顶点不连接。最小的连接组件可以是一个单一的顶点，它不连接到任何其他顶点。例如，图
    6-11 的图有三个连接组件。
- en: '![Connected Components Example](Images/daws_0612.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![连接组件示例](Images/daws_0612.png)'
- en: Figure 6-11\. Connected components example
  id: totrans-366
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-11\. 连接组件示例
- en: Finding and identifying connected components is at the heart of many graph applications.
    For example, consider the problem of identifying family clusters in a set of DNA
    samples. We can represent each DNA sample by a vertex and add an edge between
    each pair of samples that are deemed “connected” (parent–offspring, sibling, second-degree
    relative, third-degree relative, etc.). The connected components of this graph
    correspond to different family groups.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多图应用程序的核心是找到并识别连接的组件。例如，考虑在一组 DNA 样本中识别家庭群集的问题。我们可以用一个顶点表示每个 DNA 样本，并在被视为“连接”的每对样本之间添加一条边（父子、兄弟姐妹、二度亲戚、三度亲戚等）。这个图的连接组件对应于不同的家族群体。
- en: Given a graph, how do we identify its connected components? The algorithm involves
    a breadth-first or depth-first search that begins at some vertex `v` and traverses
    outward node by node until it finds the entire connected component containing
    `v`. To find all the connected components of a graph, we loop through its vertices,
    starting a new search whenever the loop reaches a vertex not already included
    in a previously found connected component.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图，如何识别它的连接组件？算法涉及广度优先或深度优先搜索，从某个顶点 `v` 开始，逐节点向外遍历，直到找到包含 `v` 的整个连接组件。要找出图的所有连接组件，我们循环遍历其顶点，每当循环到达一个先前未包含在先前找到的连接组件中的顶点时，就开始新的搜索。
- en: Connected components in Spark
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spark 中的连接组件
- en: 'The connected components algorithm labels each connected component of the graph
    with the ID of its lowest-numbered vertex. To use this algorithm, we first build
    a graph as an instance of `GraphFrame` as usual, then call the `connectedComponents()`
    method to compute the connected components of the graph. This method has the following
    signature:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 连通组件算法将图的每个连通组件标记为其最低编号顶点的ID。要使用此算法，我们首先像往常一样构建一个`GraphFrame`的图实例，然后调用`connectedComponents()`方法来计算图的连通组件。此方法具有以下签名：
- en: '[PRE61]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Its use looks something like the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用看起来像以下内容：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Analyzing Flight Data
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析航班数据
- en: The purpose of this section is to show how to build and execute graph queries.
    The example provided here is inspired by the blog post [“Analyzing Flight Delays
    with Apache Spark GraphFrames and MapR Database”](https://oreil.ly/nI3CD) by Carol
    McDonald, which provides a solution for flight data analysis in Scala using GraphFrames.
    The presented solution is an equivalent solution in PySpark.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是展示如何构建和执行图查询。此处提供的示例灵感来源于Carol McDonald的博客文章[“使用Apache Spark GraphFrames和MapR数据库分析航班延误”](https://oreil.ly/nI3CD)，该文章提供了一个使用GraphFrames在Scala中进行航班数据分析的解决方案。这里提供的解决方案是PySpark中的等效解决方案。
- en: Input
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入
- en: The data for vertices (airports) and edges (flights) is provided in JSON format.
    We will read these datafiles and create two DataFrames for vertices and edges.
    Then we’ll use these to create a graph represented as an instance of GraphFrame.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点（机场）和边（航班）的数据以JSON格式提供。我们将读取这些数据文件，并为顶点和边创建两个DataFrame。然后我们将使用这些数据创建一个图，表示为`GraphFrame`的实例。
- en: Vertices
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶点
- en: 'The data for vertices is provided in the file [*airports.json*](https://oreil.ly/WrNCf).
    Let’s review the first two records of this file:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点的数据以文件[*airports.json*](https://oreil.ly/WrNCf)提供。让我们查看该文件的前两条记录：
- en: '[PRE63]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Edges
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边
- en: 'The data for edges (flight data) is provided as a JSON file [*flightdata2018.json*](https://oreil.ly/VTJlj).
    The first record looks like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 边（航班数据）的数据以JSON文件[*flightdata2018.json*](https://oreil.ly/VTJlj)提供。第一条记录如下：
- en: '[PRE64]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Building the graph
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建图
- en: 'To build a graph as an instance of `GraphFrame`, we have to create two DataFrames.
    We’ll start by building the vertex DataFrame, from the file *airports.json*:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要作为`GraphFrame`的图实例构建图，我们必须创建两个DataFrame。我们将从文件*airports.json*开始构建顶点DataFrame：
- en: '[PRE65]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then we’ll build the edge DataFrame from *flightdata2018.json*:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将从*flightdata2018.json*构建边的DataFrame：
- en: '[PRE66]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can now build our graph using these two DataFrames:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这两个DataFrame构建我们的图：
- en: '[PRE67]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Flight analysis
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 航班分析
- en: 'Now that we have created a graph, we can execute queries on it. For example,
    now we can query the `GraphFrame` to answer the following questions:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个图，我们可以在其上执行查询。例如，我们现在可以查询`GraphFrame`以回答以下问题：
- en: How many airports are there?
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少个机场？
- en: '[PRE68]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How many flights are there?
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少个航班？
- en: '[PRE69]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Which flight routes have the longest distance?
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些航班路线距离最长？
- en: '[PRE70]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Which flight routes have the highest average delays?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些航班路线有最高的平均延误？
- en: '[PRE71]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Which flight departure hours have the highest average delays?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些航班起飞时间有最高的平均延误？
- en: '[PRE72]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: What are the longest delays for flights that are greater than 1,500 miles in
    distance? Note that the output here has been trimmed to fit the page.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对超过1,500英里距离的航班，哪些航班的延误时间最长？请注意，这里的输出已被修剪以适应页面。
- en: '[PRE73]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: What is the average delay for delayed flights departing from Atlanta (ATL)?
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延误航班从亚特兰大（ATL）出发的平均延误时间是多少？
- en: '[PRE74]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Viewing the Execution Plan
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看执行计划
- en: 'To view Spark’s logical and physical plans for DataFrame execution, you can
    use `DataFrame.explain()`:'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看DataFrame执行的Spark逻辑和物理计划，您可以使用`DataFrame.explain()`：
- en: '[PRE75]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For example, for the previous query, you could view the execution plan as follows:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，对于前面的查询，您可以如下查看执行计划：
- en: '[PRE76]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that you should always filter your RDD/DataFrame before applying an expensive
    transformation. This will drop nonrequired elements/rows from the RDD/DataFrame
    and hence improve the performance for future transformations, by reducing the
    amount of data passed between transformations.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在应用昂贵的转换之前，您应始终过滤您的RDD/DataFrame。这将从RDD/DataFrame中删除非必需的元素/行，从而减少传递给未来转换的数据量，从而提高性能。
- en: What are the worst departure hours for delayed flights departing from Atlanta?
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从亚特兰大出发的延误航班的最差起飞时间是什么？
- en: '[PRE77]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: What are the four most frequent flight routes in the dataset?
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集中哪四条航班路线最频繁？
- en: '[PRE78]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Tip
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To find this information, we get the count of flights for all possible flight
    routes and sort them in descending order. We’ll use the resulting DataFrame later,
    to find flight routes with no direct connection.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要找到这些信息，我们获取所有可能航班路线的航班计数，并按降序排序。稍后，我们将使用生成的DataFrame来查找没有直接连接的航班路线。
- en: Which airports have the most incoming and outgoing flights?
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些机场有最多的进出航班？
- en: '[PRE79]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To answer this question we use the GraphFrames `degrees` operation, which returns
    the count of all edges (incoming and outgoing) of each vertex in the graph.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们使用GraphFrames的`degrees`操作，该操作返回图中每个顶点的所有边（入边和出边）的计数。
- en: What are the most important airports, according to the PageRank algorithm?
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据PageRank算法，哪些机场最重要？
- en: '[PRE80]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The PageRank algorithm provided by the GraphFrames API is based on Google’s
    PageRank. It’s an iterative algorithm that measures the importance of each vertex
    in a graph by determining which vertices have the most connections to other vertices
    (i.e., the most edges). This output indicates that the city of Chicago’s airport
    is the most important (since it has the highest PageRank score) of all the airports
    examined.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GraphFrames API提供的PageRank算法基于Google的PageRank。它是一种通过确定哪些顶点与其他顶点（即具有最多边的顶点）连接最多来衡量图中每个顶点重要性的迭代算法。这个输出表明，芝加哥市的机场是所有检查的机场中最重要的（因为它具有最高的PageRank分数）。
- en: 'You can also run the PageRank algorithm for a fixed number of iterations, rather
    than using the tolerance level for convergence, as shown here:'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以对PageRank算法进行固定次数的迭代，而不是使用收敛容差级别，如下所示：
- en: '[PRE81]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: For more details on using the PageRank algorithm, refer to [Chapter 8](ch08.xhtml#unique_chapter_id_08).
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于使用PageRank算法的更多细节，请参考[第8章](ch08.xhtml#unique_chapter_id_08)。
- en: 'Next we’ll consider a slightly more complicated query: what are the flight
    routes with no direct connection? To answer this question, we will use the GraphFrames
    API’s motif finding algorithm. First we’ll create a subgraph from the `flight_route_count`
    DataFrame that we created earlier, which gives us a subgraph with all the possible
    flight routes. Then we’ll do a `find()` to search for flights from `a` to `b`
    and `b` to `c` where there is no flight from `a` to `c`. Finally we’ll use a DataFrame
    filter to remove duplicates. This example shows how graph queries can be easily
    combined with DataFrame operations like `filter()`.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑一个稍微复杂的查询：哪些航班路线没有直接连接？为了回答这个问题，我们将使用GraphFrames API的模式查找算法。首先，我们将从之前创建的`flight_route_count`
    DataFrame创建一个子图，这给我们一个包含所有可能航班路线的子图。然后，我们将使用`find()`来搜索从`a`到`b`和从`b`到`c`的航班，其中没有从`a`到`c`的航班。最后，我们将使用DataFrame的过滤器来删除重复项。这个示例展示了如何将图查询与`filter()`等DataFrame操作轻松结合。
- en: 'Using our `flight_route_count` DataFrame, we can use the following pattern
    to search for flights from `a` to `b` and `b` to `c` where there is no direct
    flight from `a` to `c`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`flight_route_count` DataFrame，我们可以使用以下模式来搜索从`a`到`b`和从`b`到`c`的航班，其中没有从`a`到`c`的直达航班：
- en: '[PRE82]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This produces the following results:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下结果：
- en: '[PRE83]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Suppose we want to find which cities do not offer direct flights to one particular
    airport. To answer this question, we can use the shortest path algorithm to compute
    the shortest paths from each vertex (airport) to one or more “landmark” vertices
    (airports). Here we search for the shortest path from each airport to LGA. The
    results (distances greater than 1) show that there are no direct flights from
    IAH, CLT, LAX, DEN, or DFW to LGA:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找出哪些城市没有直达航班到某个特定机场。为了回答这个问题，我们可以使用最短路径算法计算从每个顶点（机场）到一个或多个“地标”顶点（机场）的最短路径。在这里，我们搜索从每个机场到LGA的最短路径。结果（距离大于1）显示，从IAH、CLT、LAX、DEN或DFW到LGA没有直达航班：
- en: '[PRE84]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now suppose we want to find out if there are any direct flights between two
    specific airports. The breadth-first search (BFS) algorithm finds the shortest
    path from a beginning vertex to an end vertex. The beginning and end vertices
    are specified as DataFrame expressions, and `maxPathLength` sets a limit on the
    length of the paths between them. Here, we see that there are no direct flights
    between LAX and LGA, although there are connecting flights (note that the output
    has been truncated to fit the page):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要找出两个特定机场之间是否有直达航班。广度优先搜索（BFS）算法找到从起始顶点到结束顶点的最短路径。起始和结束顶点被指定为DataFrame表达式，`maxPathLength`设置路径长度的限制。在这里，我们看到LAX和LGA之间没有直达航班，尽管有连接航班（请注意，输出已截断以适应页面）：
- en: '[PRE85]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can also use motif finding to identify connecting flights between two airports.
    Here, we’ll use a motif query to search for the pattern of `a` to `c` through
    `b`, then apply a DataFrame filter on the results for `a = LAX` and `c = LGA`.
    The results show some flights from LAX to LGA connecting through IAH:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用图案发现来识别两个机场之间的联程航班。在这里，我们将使用一个图案查询来搜索`a`到`c`通过`b`的模式，然后在结果上应用一个DataFrame过滤器，以`a
    = LAX`和`c = LGA`。结果显示了一些从LAX到LGA经由IAH联程的航班：
- en: '[PRE86]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: By combining motif finding with DataFrame operations we could narrow these results
    down even further, for example to exclude flights with an arrival time before
    the initial departure flight time, and/or to identify flights with a specific
    carrier.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将图案发现与DataFrame操作结合，我们甚至可以进一步缩小这些结果，例如排除到达时间早于初始出发航班时间的航班，并/或者识别特定航空公司的航班。
- en: Summary
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'To recap:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 总结如下：
- en: Spark provides two graph libraries, GraphX (based on RDDs) and GraphFrames (based
    on DataFrames). GraphX is Spark’s internal API for graphs and graph-parallel computation
    and is available only for Java and Scala. GraphFrames is an external package for
    Spark that provides high-level APIs in Python, Scala, and Java. It is available
    in PySpark, whereas GraphX is not.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark提供两个图库，GraphX（基于RDD）和GraphFrames（基于DataFrames）。GraphX是Spark的内部图API，用于图和图并行计算，仅支持Java和Scala。GraphFrames是Spark的外部包，为Python、Scala和Java提供高级API。它在PySpark中可用，而GraphX则不可用。
- en: 'GraphFrames provide:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphFrames提供：
- en: Python, Java, and Scala APIs
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python、Java和Scala API
- en: Expressive graph queries by using “motif finding”
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用“图案发现”进行表达性图查询
- en: Query plan optimizers from Spark SQL
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Spark SQL的查询计划优化器
- en: Graph algorithms
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图算法
- en: Next, we’ll cover how Spark interacts with outside data sources.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍Spark如何与外部数据源交互。
