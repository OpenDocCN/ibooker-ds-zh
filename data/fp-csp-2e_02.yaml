- en: 1 Introducing functional programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 介绍函数式编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Benefits and tenets of functional programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的好处和原则
- en: Functional features of the C# language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 语言的函数式特性
- en: Using records and pattern matching for type-driven programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录和模式匹配进行类型驱动程序
- en: 'Functional programming (FP) is a programming *paradigm*: a different way of
    thinking about programs than the mainstream imperative paradigm you’re probably
    used to. For this reason, learning to think functionally is challenging but also
    very enriching. My ambition is that, after reading this book, you’ll never look
    at code with the same eyes as before!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）是一种编程*范式*：一种不同于你可能习惯的主流命令式范式的思考程序的方式。因此，学习以函数式思考是具有挑战性的，但也是非常有益的。我的目标是，在阅读这本书之后，你将永远以不同的眼光看待代码！
- en: The learning process can be a bumpy ride. You’re likely to go from frustration
    at concepts that seem obscure or useless to exhilaration when something clicks
    in your mind, and you’re able to replace a mess of imperative code with just a
    couple of lines of elegant, functional code. This chapter will address some questions
    you may have as you start on this journey. What exactly is functional programming?
    Why should I care? Can I code functionally in C#? Is it worth the effort?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 学习过程可能是一段颠簸的旅程。你可能会从对看似晦涩或无用的概念感到沮丧，到当你脑海中有所领悟，能够用几行优雅的函数式代码替换一大堆命令式代码时的兴奋。本章将解答你在开始这段旅程时可能有的疑问。函数式编程究竟是什么？我为什么要关心？我能在C#中进行函数式编程吗？这值得付出努力吗？
- en: 1.1 What is this thing called functional programming?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 这个东西叫什么函数式编程？
- en: 'What exactly is functional programming (FP)? At a high level, it’s a programming
    style that emphasizes functions while avoiding state mutation. This definition
    is already twofold as it includes two fundamental concepts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）究竟是什么？从高层次来看，它是一种强调函数同时避免状态变化的编程风格。这个定义已经包含两个基本概念：
- en: Functions as first-class values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一等值
- en: Avoiding state mutation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免状态变化
- en: Let’s see what these mean.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些意味着什么。
- en: Running snippets in the REPL
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中运行代码片段
- en: As you go through the snippets in this chapter and in the book, I encourage
    you to type them in a REPL. A *REPL* (Read-Eval-Print-Loop) is a command-line
    interface that lets you experiment with the language by typing in statements and
    getting immediate feedback. You may want to try out a few variations on the examples
    I show you; getting your hands dirty by messing with real code will get you learning
    fastest.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读本章和书中的代码片段，我鼓励你在REPL中输入它们。*REPL*（读取-评估-打印-循环）是一个命令行界面，允许你通过输入语句来实验语言，并立即获得反馈。你可能想尝试我展示的示例的一些变体；通过实际代码的实验来弄脏你的手将让你更快地学习。
- en: If you use Visual Studio, you can start the REPL by going to View > Other Windows
    > C# Interactive. Alternatively, you can use LINQPad. Unfortunately, at the time
    of writing, these options are only available on Windows. On other OSs, you can
    use the `csi` command, even though it’s not as feature-rich.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio，可以通过转到视图 > 其他窗口 > C#交互式来启动REPL。或者，你可以使用LINQPad。不幸的是，在撰写本文时，这些选项仅在Windows上可用。在其他操作系统上，你可以使用`csi`命令，尽管它不是功能最丰富的。
- en: 1.1.1 Functions as first-class values
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 函数作为一等值
- en: In a language where functions are first-class values, you can use them as inputs
    or outputs of other functions, you can assign them to variables, and you can store
    them in collections. In other words, you can do with functions all the operations
    that you can do with values of any other type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个将函数作为一等值的语言中，你可以将它们用作其他函数的输入或输出，你可以将它们赋值给变量，并将它们存储在集合中。换句话说，你可以对函数执行所有可以对任何其他类型的值执行的操作。
- en: For example, type the contents of the following listing into the REPL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将以下列表的内容输入到REPL中。
- en: Listing 1.1 A simple example of using a function as a first-class value
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.1 使用函数作为一等值的简单示例
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Defines a function that returns the triple of a given integer
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个返回给定整数三倍的函数
- en: ❷ Creates a list with the values `[1,` `2,` `3]`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个包含值 `[1,` `2,` `3]` 的列表
- en: ❸ Applies `triple` to all the values in range
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 `triple` 应用到范围内的所有值
- en: In this example, you invoke `Select` (an extension method on `IEnumerable`),
    giving it the range and the `triple` function as arguments. This creates a new
    `IEnumerable` containing the elements obtained by applying the `triple` function
    to each element in the input range.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你调用`Select`（`IEnumerable`上的扩展方法），给它传递范围和`triple`函数作为参数。这创建了一个新的`IEnumerable`，它包含通过将`triple`函数应用于输入范围中的每个元素而获得的所有元素。
- en: 'Notice that prior to C# 10 you needed to explicitly declare the delegate type
    for `triple` like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在C# 10之前，你需要像这样显式声明`triple`的委托类型：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code in listing 1.1 demonstrates that functions are indeed first-class values
    in C# because you can assign the multiply-by-3 function to the variable `triple`
    and give it as an argument to `Select`. Throughout the book, you’ll see that treating
    functions as values allows you to write powerful and concise code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1中的代码演示了函数在C#中确实是第一等值，因为你可以将乘以3的函数分配给变量`triple`，并将其作为`Select`的参数。在整个书中，您将看到将函数视为值可以使您编写强大而简洁的代码。
- en: 1.1.2 Avoiding state mutation
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 避免状态突变
- en: 'If we follow the functional paradigm, we should refrain from state mutation
    altogether: once created, an object *never* changes, and variables should never
    be reassigned (so that, in fact, they’re *variable* in name only). The term *mutation*
    indicates that a value is changed in place, updating a value stored somewhere
    in memory. For example, the following code creates and populates an array, and
    then it updates one of the array’s values in place:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循函数式范式，我们应该完全避免状态突变：一旦创建，对象*永远不会*改变，变量也不应该被重新分配（因此，实际上，它们在名称上只是*变量*）。术语*突变*表示值在原地被更改，更新存储在内存中的某个位置的价值。例如，以下代码创建并填充了一个数组，然后它原地更新了数组中的一个值：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Such updates are also called *destructive updates* because the value stored
    prior to the update is destroyed. These should always be avoided when coding functionally.
    (Purely functional languages don’t allow in-place updates at all.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更新也被称为*破坏性更新*，因为更新之前存储的值被破坏。在函数式编程中，应该始终避免这种更新。（纯函数式语言根本不允许原地更新。）
- en: Following this principle, sorting or filtering a list should not modify the
    list in place but should create a new, suitably filtered or sorted list without
    affecting the original. Type the code in the following listing into the REPL to
    see what happens when sorting or filtering a list using LINQ’s `Where` and `OrderBy`
    functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 依据这个原则，排序或过滤列表不应该原地修改列表，而应该创建一个新的、适当过滤或排序的列表，而不影响原始列表。将以下列表中的代码输入到REPL中，以查看使用LINQ的`Where`和`OrderBy`函数排序或过滤列表时会发生什么。
- en: 'Listing 1.2 Functional approach: `Where` and `OrderBy` create new lists'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.2 函数式方法：`Where`和`OrderBy`创建新的列表
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The original list isn’t affected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 原始列表不受影响。
- en: ❷ Sorting and filtering yielded new lists.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 排序和过滤产生了新的列表。
- en: As you can see, the original list is unaffected by the sorting or filtering
    operations, which yield new `IEnumerable`s. Let’s look at a counterexample in
    the following listing. If you have an array, you can sort it in place by calling
    its `Sort` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，原始列表不受排序或过滤操作的影响，这些操作产生新的`IEnumerable`s。让我们看看以下列表中的反例。如果你有一个数组，你可以通过调用它的`Sort`方法原地对其进行排序。
- en: 'Listing 1.3 Nonfunctional approach: `List<T>.Sort` sorts the list in place'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.3 非函数式方法：`List<T>.Sort`原地排序列表
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, after sorting, the original ordering is destroyed. We’ll see why
    this is problematic next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，排序后，原始顺序被破坏。我们将在下面看到这是为什么有问题。
- en: 'NOTE The reason you see both the functional and nonfunctional approaches in
    .NET libraries is historical: `Array.Sort` predates LINQ, which marked a decisive
    turn in a functional direction.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你在.NET库中看到函数式和非函数式方法的原因是历史性的：`Array.Sort`早于LINQ，LINQ标志着向函数式方向的一个决定性转变。
- en: 1.1.3 Writing programs with strong guarantees
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 编写具有强保证的程序
- en: Of the two concepts we just discussed, functions as first-class values initially
    seems more exciting, and we’ll concentrate on it in chapter 2\. But before we
    move on, I’d like to briefly demonstrate why avoiding state mutation is also hugely
    beneficial—it eliminates many complexities caused by mutable state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚讨论的两个概念中，函数作为一等值最初似乎更有趣，我们将在第2章集中讨论它。但在我们继续之前，我想简要说明避免状态突变为什么也非常有益——它消除了由可变状态引起的许多复杂性。
- en: Let’s look at an example. (We’ll revisit these topics in more detail, so don’t
    worry if not everything is clear at this point.) Type the code in the following
    listing into the REPL.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。（我们将在更详细地回顾这些主题，所以如果你现在对某些内容不清楚，请不要担心。）将以下列表中的代码输入到 REPL 中。
- en: Listing 1.4 Mutating state from concurrent processes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 从并发过程中修改状态
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Lets you call `Range` and `WriteLine` without full qualification
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许你无需完全限定即可调用 `Range` 和 `WriteLine`
- en: ❷ Executes both tasks in parallel
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 并行执行两个任务
- en: 'Here you define `nums` to be an array of all integers between 10,000 and -10,000;
    their sum should obviously be 0\. You then create two tasks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义 `nums` 为介于 10,000 和 -10,000 之间的所有整数的数组；它们的总和显然应该是 0。然后你创建两个任务：
- en: '`task1` computes and prints the sum.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task1` 计算并打印总和。'
- en: '`task2` first sorts the array and then computes and prints the sum.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task2` 首先对数组进行排序，然后计算并打印总和。'
- en: 'Each of these tasks correctly computes the sum if run independently. When you
    run both tasks in parallel, however, `task1` comes up with an incorrect and unpredictable
    result. It’s easy to see why. As `task1` reads the numbers in the array to compute
    the sum, `task2` is reordering the elements in the array. That’s somewhat like
    trying to read a book while somebody else flips the pages: you’d be reading some
    well-mangled sentences! This is shown graphically in figure 1.1.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果独立运行，每个任务都能正确地计算总和。但是，当你并行运行这两个任务时，`task1` 得出的结果是不正确且不可预测的。这很容易理解。当 `task1`
    读取数组中的数字以计算总和时，`task2` 正在重新排列数组中的元素。这有点像在别人翻页的同时阅读一本书：你会读到一些混乱的句子！这在图 1.1 中有图形表示。
- en: '![](Images/CH01_F01_Buonanno2.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F01_Buonanno2.png)'
- en: Figure 1.1 Modifying data in place can give concurrent threads an incorrect
    view of the data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 就地修改数据可能会给并发线程提供一个错误的数据视图。
- en: What if we use LINQ’s `OrderBy` method, instead of sorting the list in place?
    Let’s look at an example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 LINQ 的 `OrderBy` 方法，而不是就地排序列表，会怎样呢？让我们来看一个例子。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, using LINQ’s functional implementation gives you a predictable
    result, even when you execute the tasks in parallel. This is because `task3` isn’t
    modifying the original array but rather creating a completely new view of the
    data, which is sorted: `task1` and `task3` read from the original array concurrently,
    but concurrent reads don’t cause any inconsistencies, as figure 1.2 shows.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 LINQ 的函数式实现即使在并行执行任务时也能给出可预测的结果。这是因为 `task3` 并没有修改原始数组，而是创建了一个完全新的数据视图，该视图已排序：`task1`
    和 `task3` 并发地从原始数组中读取，但并发读取不会导致任何不一致，如图 1.2 所示。
- en: '![](Images/CH01_F02_Buonanno2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH01_F02_Buonanno2.png)'
- en: 'Figure 1.2 The functional approach: creating a new, modified version of the
    original structure'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 函数式方法：创建原始结构的新的修改版本
- en: 'This simple example illustrates a wider truth: when developers write an application
    in the imperative style (explicitly mutating the program state) and later introduce
    concurrency (due to new requirements or a need to improve performance), they inevitably
    face a lot of work and potentially some difficult bugs. When a program is written
    in a functional style from the outset, concurrency can often be added for free
    or with substantially less effort. We’ll discuss state mutation and concurrency
    more in chapters 3 and 11\. For now, let’s go back to our overview of FP.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子说明了更广泛的真理：当开发者在命令式风格（显式地修改程序状态）编写应用程序，后来引入并发（由于新需求或提高性能的需要）时，他们不可避免地会面临大量工作，并可能遇到一些难以解决的错误。如果一个程序从一开始就是以函数式风格编写的，那么并发通常可以免费添加或以大大减少的努力来实现。我们将在第
    3 章和第 11 章中更详细地讨论状态修改和并发。现在，让我们回到我们对函数式编程（FP）的概述。
- en: 'Although most people will agree that treating functions as first-class values
    and avoiding state mutation are fundamental tenets of FP, their application gives
    rise to a series of practices and techniques, so it’s debatable which techniques
    should be considered essential and included in a book like this. I encourage you
    to take a pragmatic approach to the subject and try to understand FP as *a set
    of tools* that you can use to address your programming tasks. As you learn these
    techniques, you’ll start to look at problems from a different perspective: you’ll
    start to think functionally.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数人都会同意将函数视为一等值并避免状态修改是函数式编程（FP）的基本原则，但它们的运用引发了一系列实践和技术，因此关于哪些技术应该被认为是基本并包含在本书中的讨论是有争议的。我鼓励你对此问题采取实用主义的方法，并尝试将
    FP 理解为 *一套工具*，你可以使用这些工具来解决你的编程任务。随着你学习这些技术，你将开始从不同的角度看待问题：你将开始以函数式的方式思考。
- en: Now that we have a working definition of FP, let’s look at the C# language itself
    and at its support for FP techniques.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了函数式编程的工作定义，让我们来看看C#语言本身及其对函数式编程技术的支持。
- en: Functional vs. object-oriented?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式与面向对象？
- en: I’m often asked to compare and contrast FP with object-oriented programming
    (OOP). This isn’t simple, mainly because there are conflicting assumptions about
    what OOP should look like.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常被要求比较和对比函数式编程与面向对象编程（OOP）。这并不简单，主要是因为对OOP应该是什么样子的假设存在冲突。
- en: In theory, the fundamental principles of OOP (encapsulation, data abstraction,
    and so on) are orthogonal to the principles of FP, so there’s no reason why the
    two paradigms can’t be combined.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，面向对象编程（OOP）的基本原则（封装、数据抽象等）与函数式编程的原则是正交的，因此没有理由认为这两种范式不能结合。
- en: In practice, however, most object-oriented (OO) developers heavily rely on the
    imperative style in their method implementations, mutating state in place and
    using explicit control flow; they use OO design in the large and imperative programming
    in the small. The real question is that of *imperative versus functional* programming.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，大多数面向对象（OO）开发者在其方法实现中严重依赖命令式风格，就地修改状态并使用显式控制流；他们在大型设计中使用面向对象设计，在小型设计中使用命令式编程。真正的问题是命令式与函数式编程之间的对比。
- en: 'Another interesting question is how FP differs from OOP in terms of structuring
    a large, complex application. The difficult art of structuring a complex application
    relies on the following principles. They’re generally valid, regardless of whether
    the component in question is a function, a class, or an application:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的问题是函数式编程（FP）与面向对象编程（OOP）在构建大型、复杂应用程序方面的区别。构建复杂应用程序的困难艺术依赖于以下原则。它们通常是有效的，无论所讨论的组件是函数、类还是应用程序：
- en: '*Modularity*—Software should be composed of discrete, reusable components.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块化*——软件应由离散、可重用的组件组成。'
- en: '*Separation of concern*s—Each component should only do one thing.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关注点分离*——每个组件应该只做一件事。'
- en: '*Layering*—High-level components can depend on low-level components but not
    vice versa.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分层*——高级组件可以依赖于低级组件，但反之则不然。'
- en: '*Loose coupling*—A component shouldn’t know about the internal details of the
    components it depends on; therefore, changes to a component shouldn’t affect components
    that depend on it.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*松耦合*——一个组件不应该了解它所依赖的组件的内部细节；因此，对组件的更改不应影响依赖于它的组件。'
- en: These principles are also in no way specific to OOP, so the same principles
    can be used to structure an application written in the functional style. The difference
    will be in what the components are and which APIs they expose. In practice, the
    functional emphasis on pure functions (which we’ll discuss in chapter 3) and composability
    (chapter 7) make it significantly easier to achieve some of these design goals.^a
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则也绝不是面向对象的特定，因此可以使用相同的原理来构建函数式风格的应用程序。区别将在于组件是什么以及它们公开的API。在实践中，对纯函数（我们将在第3章中讨论）和可组合性（第7章）的函数式强调使实现某些设计目标变得容易得多.^a
- en: ^a For a more thorough discussion on why imperatively flavored OOP is a *cause*
    of (rather than a solution to) program complexity, see the article “Out of the
    Tar Pit,” by Ben Moseley and Peter Marks (November, 2006) at [http://mng.bz/xXK7](http://mng.bz/xXK7).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ^a 关于为什么命令式风格的面向对象编程是（而不是解决）程序复杂性的原因的更深入讨论，请参阅本·莫斯利和彼得·马克斯（2006年11月）撰写的文章“Out
    of the Tar Pit”，网址为[http://mng.bz/xXK7](http://mng.bz/xXK7)。
- en: 1.2 How functional a language is C#?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 C#语言有多函数式？
- en: Functions are indeed first-class values in C#, as demonstrated in the previous
    listings. In fact, C# had support for functions as first-class values from the
    earliest version of the language through the `Delegate` type, and the subsequent
    introduction of lambda expressions made the syntactic support even better. We’ll
    review these language features in chapter 2.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数确实是C#中的一等值，如前文示例所示。实际上，C#从语言的最早期版本开始就支持函数作为一等值，通过`Delegate`类型，随后引入的lambda表达式使语法支持更加完善。我们将在第2章中回顾这些语言特性。
- en: There are some quirks and limitations when it comes to type inference, which
    we’ll discuss in chapter 10, but overall the support for functions as first-class
    values is pretty good.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型推断方面，有一些怪癖和限制，我们将在第10章中讨论，但总的来说，对函数作为一等值的支持相当不错。
- en: As for supporting a programming model that avoids in-place updates, the fundamental
    requirement in this area is that a language have garbage collection. Because you
    create modified versions of existing data structures, rather than updating their
    values in place, you want old versions to be garbage-collected as needed. Again,
    C# satisfies this requirement.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 至于支持避免原地更新的编程模型，这个领域的根本要求是语言必须具备垃圾回收功能。因为你创建了现有数据结构的修改版本，而不是在原地更新它们的值，所以你希望旧版本在需要时被垃圾回收。同样，C#
    满足了这一要求。
- en: 'Ideally, the language should also *discourage* in-place updates. For a long
    time, this was C#''s greatest shortcoming: having everything mutable by default
    and no easy way to define immutable types was a hurdle when programming in a functional
    style. This all changed with the introduction of records in C# 9\. As you’ll see
    in section 1.2.3, records allow you to define custom immutable types without any
    boilerplate; in fact, it’s easier to define a record than a “normal” class.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，语言还应该*阻止*原地更新。长期以来，这是 C# 最大的不足：默认情况下所有内容都是可变的，而且没有简单的方法来定义不可变类型，这在函数式编程风格中是一个障碍。但随着
    C# 9 中记录的引入，这一切都发生了改变。正如你在 1.2.3 节中将会看到的，记录允许你定义自定义的不可变类型，而不需要任何样板代码；实际上，定义记录比定义“普通”类还要简单。
- en: As a result of the features added over time, C# 9 offers good language support
    for many functional techniques. In this book, you’ll learn to harness these features
    and to work around any shortcomings. Next, we’ll review some language features
    of C# that are particularly relevant to FP.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随着时间的推移添加了这些特性，C# 9 为许多函数式技术提供了良好的语言支持。在这本书中，你将学习如何利用这些特性，并解决任何不足。接下来，我们将回顾一些与
    FP 特别相关的 C# 语言特性。
- en: 1.2.1 The functional nature of LINQ
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 LINQ 的函数式特性
- en: When C# 3 was released, along with version 3.5 of the .NET Framework, it included
    a host of features inspired by functional languages, including the LINQ library
    (`System.Linq`) and some new language features enabling or enhancing what you
    could do with LINQ. These features included extension methods, lambda expression,
    and expression trees.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当 C# 3 发布时，伴随着 .NET Framework 3.5 版本的推出，它包含了一系列受函数式语言启发的特性，包括 LINQ 库 (`System.Linq`)
    以及一些新的语言特性，这些特性使得你可以使用 LINQ 做更多的事情。这些特性包括扩展方法、lambda 表达式和表达式树。
- en: LINQ is indeed a functional library (as you probably noticed, I used LINQ earlier
    to illustrate both tenets of FP). The functional nature of LINQ will become even
    more apparent as you progress through this book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 确实是一个函数式库（正如你可能注意到的，我之前使用 LINQ 来说明 FP 的两个原则）。随着你在这本书中的进展，LINQ 的函数式特性将变得更加明显。
- en: 'LINQ offers implementations for many common operations on lists (or, more generally,
    on “sequences,” as instances of `IEnumerable` should technically be called), the
    most common of which are mapping, sorting, and filtering, see the “Common operations
    on sequences” sidebar. Here’s an example combining all three operations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 为列表（或更普遍地，对“序列”，因为 `IEnumerable` 的实例在技术上应该被称为）上的许多常见操作提供了实现，其中最常见的是映射、排序和过滤，请参阅“序列的常见操作”侧边栏。以下是一个结合所有三个操作的示例：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how `Where`, `OrderBy`, and `Select` all take functions as arguments
    and don’t mutate the given `IEnumerable` but return a new `IEnumerable` instead.
    This illustrates both tenets of FP you saw earlier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Where`、`OrderBy` 和 `Select` 都接受函数作为参数，并且不会修改给定的 `IEnumerable`，而是返回一个新的
    `IEnumerable`。这说明了你之前看到的 FP 的两个原则。
- en: LINQ facilitates querying not only objects in memory (LINQ to objects), but
    various other data sources as well, like SQL tables and XML data. C# programmers
    have embraced LINQ as the standard toolset for working with lists and relational
    data (accounting for a substantial amount of a typical codebase). On the upside,
    this means that you’ll already have some sense of what a functional library’s
    API feels like.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 不仅简化了内存中对象的查询（LINQ to Objects），还简化了各种其他数据源，如 SQL 表和 XML 数据。C# 程序员已经将 LINQ
    作为处理列表和关系数据的标准工具集（这占典型代码库中相当大的比例）。从积极的一面来看，这意味着你将已经对函数式库的 API 有了一定的了解。
- en: On the other hand, when working with other types, C# programmers generally stick
    to the imperative style of using flow-control statements to express the program’s
    intended behavior. As a result, most C# codebases I’ve seen are a patchwork of
    functional style (when working with `IEnumerable`s and `IQueryable`s) and imperative
    style (when working with everything else).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当与其他类型一起工作时，C# 程序员通常坚持使用流程控制语句的命令式风格来表示程序的预期行为。因此，我所看到的多数 C# 代码库都是函数式风格（当处理
    `IEnumerable` 和 `IQueryable` 时）和命令式风格（当处理其他所有内容时）的混合体。
- en: What this means is that, although C# programmers are aware of the benefits of
    using a functional library such as LINQ, they haven’t had enough exposure to the
    design principles behind LINQ to leverage those techniques in their own designs.
    That’s something this book aims to address.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，尽管 C# 程序员了解使用 LINQ 等函数式库的好处，但他们并没有足够接触 LINQ 的设计原则，以在他们的设计中利用这些技术。这正是本书旨在解决的问题。
- en: Common operations on sequences
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 序列上的常见操作
- en: 'The LINQ library contains many methods for performing common operations on
    sequences such as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 库包含许多执行常见序列操作的方法，如下所示：
- en: '*Mapping*—Given a sequence and a function, mapping yields a new sequence whose
    elements are obtained by applying the given function to each element in the original
    sequence (in LINQ, this is done with the `Select` method):'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射*——给定一个序列和一个函数，映射会产生一个新的序列，其元素是通过将给定的函数应用于原序列中的每个元素获得的（在 LINQ 中，这是通过 `Select`
    方法实现的）：'
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Filtering*—Given a sequence and a predicate, filtering yields a new sequence
    including all the elements from the original sequence that satisfy the predicate
    (in LINQ, this is done with `Where`):'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤*——给定一个序列和一个谓词，过滤会产生一个新的序列，包含所有满足谓词的原序列元素（在 LINQ 中，这是通过 `Where` 实现的）：'
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Sorting*—Given a sequence and a key-selector function, sorting yields a sequence
    where the elements of the original sequence are ordered by the key (in LINQ, this
    is done with `OrderBy` and `OrderByDescending`):'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排序*——给定一个序列和一个键选择函数，排序会产生一个序列，其中原序列的元素按键排序（在 LINQ 中，这是通过 `OrderBy` 和 `OrderByDescending`
    实现的）：'
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 1.2.2 Shorthand syntax for coding functionally
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 编程函数式的简写语法
- en: C# 6, C# 7, and C# 10 were not revolutionary releases, but they included many
    smaller language features that, taken together, provide more idiomatic syntax
    and hence a better experience for coding functionally. The following listing illustrates
    some of these features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6、C# 7 和 C# 10 并不是革命性的发布，但它们包含了许多较小的语言特性，这些特性结合起来提供了更符合语法的语法，从而为函数式编程提供了更好的体验。以下列表展示了这些特性的一些示例。
- en: Listing 1.5 C# idioms relevant for FP
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.5 与函数式编程相关的 C# 习惯用法
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ `using` `static` enables unqualified access to the static members of `System.Math`,
    like `PI` and `Pow`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `using static` 允许无限定访问 `System.Math` 的静态成员，如 `PI` 和 `Pow`。
- en: ❷ An expression-bodied property
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表达式属性
- en: ❸ A local function is a method declared within another method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 局部函数是在另一个方法中声明的函数。
- en: Importing static members with the using static directive
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `using static` 指令导入静态成员
- en: 'The `using static` directive introduced in C# 6 allows you to import the static
    members of a class (in listing 1.5, the `System.Math` class). As a result, in
    this example you can invoke the `PI` and `Pow` members of `Math` without further
    qualification:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 中引入的 `using static` 指令允许你导入一个类的静态成员（在列表 1.5 中，是 `System.Math` 类）。因此，在这个例子中，你可以直接调用
    `Math` 的 `PI` 和 `Pow` 成员，无需进一步限定：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Why is this important? In FP, we prefer functions whose behavior relies only
    on their input arguments because we can reason about and test these functions
    in isolation (contrast this with instance methods, whose implementation typically
    interacts with instance variables). These functions are implemented as static
    methods in C#, so a functional library in C# consists mainly of static methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要呢？在函数式编程（FP）中，我们更喜欢那些行为仅依赖于输入参数的函数，因为我们可以独立地推理和测试这些函数（与实现通常与实例变量交互的实例方法形成对比）。这些函数在
    C# 中实现为静态方法，因此 C# 中的函数式库主要由静态方法组成。
- en: '`using` `static` allows you to more easily consume such libraries. This is
    even truer in C# 10, where `global` `using` `static` allows you to make functions
    available throughout your project. Although overuse of these directives can lead
    to namespace pollution, reasonable use can make for clean, readable code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`using static` 允许你更轻松地使用此类库。在 C# 10 中，这一点尤为明显，其中 `global using static` 允许你在整个项目中提供函数。尽管过度使用这些指令可能导致命名空间污染，但合理使用可以使代码更清晰、易读。'
- en: More concise functions with expression-bodied members
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式体成员的更简洁的函数
- en: 'We declare the `Circumference` property with an *expression body*, introduced
    with `=>`, rather than with the usual *statement body* enclosed by curly braces:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`=>`引入的*表达式体*来声明`Circumference`属性，而不是使用通常的由花括号包围的*语句体*：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how much more concise this is compared to the `Area` property in listing
    1.5!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这与列表1.5中的`Area`属性相比要简洁得多！
- en: In FP, we tend to write lots of simple functions, many of them one-liners, and
    then compose these into more complex workflows. Expression-bodied methods allow
    you to do this with minimal syntactic noise. This is particularly evident when
    you want to write a function that returns a function—something you’ll see a lot
    of in this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，我们倾向于编写许多简单的函数，其中许多是一行代码，然后将这些函数组合成更复杂的流程。表达式体方法允许你以最小的语法噪声来完成这项工作。当你想要编写一个返回函数的函数时，这一点尤为明显——你将在本书中看到很多这种情况。
- en: The expression-bodied syntax was introduced in C# 6 for methods and property
    getters. It was generalized in C# 7 to also apply to constructors, destructors,
    getters, and setters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式体语法是在C# 6中为方法和属性获取器引入的。在C# 7中，它被推广到也适用于构造函数、析构函数、获取器和设置器。
- en: Declaring functions within functions
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内声明函数
- en: 'Writing lots of simple functions means that many functions are called from
    one location only. C# allows you to make this explicit by declaring a function
    within the scope of another function. There are actually two ways to do this;
    the one I favor uses a delegate:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编写许多简单的函数意味着许多函数只从一个位置调用。C# 允许你通过在另一个函数的作用域内声明一个函数来明确这一点。实际上有两种方法可以做到这一点；我偏爱的方法是使用委托：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code uses a lambda expression to represent the function and assigns it
    to the `square` variable. (In C# 10, the compiler infers the type of `square`
    to be `Func<double, double>` so that you can declare it with the `var` keyword.)
    We'll look at lambda expressions and delegates more in depth in chapter 2.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用lambda表达式来表示函数，并将其分配给`square`变量。（在C# 10中，编译器推断`square`的类型为`Func<double,
    double>`，因此你可以使用`var`关键字来声明它。）我们将在第2章中更深入地探讨lambda表达式和委托。
- en: Another possibility is to use *local functions*, effectively methods declared
    within a method—a feature introduced in C# 7.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用*局部函数*，这实际上是在方法内部声明的函数——这是一个在C# 7中引入的特性。
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Both lambda expressions and local functions can refer to variables within the
    enclosing scope for this reason, the compiler actually generates a class for each
    local function. To mitigate the possible performance impact, if a local function
    does not need to access variables from the enclosing scope, as is the case in
    this example, C# 8 allows you to declare the local function `static` like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，lambda表达式和局部函数都可以引用封装作用域内的变量，编译器实际上为每个局部函数生成一个类。为了减轻可能的影响，如果局部函数不需要访问封装作用域中的变量，就像在这个例子中一样，C#
    8允许你将局部函数声明为`static`，如下所示：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you refer to a variable in the enclosing scope from within a local function
    that is marked as `static`, you’ll get a compiler error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从标记为`static`的局部函数中引用封装作用域中的变量，你会得到一个编译器错误。
- en: 1.2.3 Language support for tuples
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 对元组的语言支持
- en: C# 7 introduced new lightweight syntax for creating and consuming tuples, similar
    to the syntax found in many other languages. This was the most important feature
    introduced in C# 7.[¹](#pgfId-1104249)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7引入了创建和消费元组的新轻量级语法，类似于许多其他语言中的语法。这是C# 7中引入的最重要特性。[¹](#pgfId-1104249)
- en: How are tuples useful in practice, and why are they relevant to FP? In FP, we
    tend to break tasks down into small functions. You may end up with a data type
    whose only purpose is to capture the information returned by one function, and
    that’s expected as input by another function. It’s impractical to define dedicated
    types for such structures, which don’t correspond to meaningful domain abstractions.
    That’s where tuples come in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中元组有何用途，为什么它们与FP相关？在FP中，我们倾向于将任务分解成小的函数。你可能会得到一个数据类型，它的唯一目的是捕获一个函数返回的信息，并且另一个函数期望作为输入。为这样的结构定义专用类型是不切实际的，这些结构并不对应于有意义的领域抽象。这就是元组发挥作用的地方。
- en: 'Let’s look at an example. Imagine you have a currency-pair identifier such
    as EURUSD, which identifies the exchange rate for Euros/US Dollars, and you’d
    like to break it up into its two parts:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设你有一个货币对标识符，例如EURUSD，它标识了欧元/美元的汇率，你希望将其拆分为两部分：
- en: The *base currency* (EUR)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基础货币*（EUR）'
- en: The *quote currency* (USD)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*报价货币*（USD）'
- en: 'For this, you can define a general function that splits a string at the given
    index. The following example shows this operation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你可以定义一个通用函数，该函数在给定的索引处拆分字符串。以下示例展示了此操作：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Declares a tuple as the method’s return type
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将元组声明为方法的返回类型
- en: ❷ Constructs a tuple
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建一个元组
- en: ❸ Deconstructs a tuple
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 解构元组
- en: 'Furthermore, you can assign meaningful names to the elements of a tuple. This
    allows you to query them like properties:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以为元组的元素分配有意义的名称。这允许你像属性一样查询它们：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Assigns names to the elements of the returned tuple
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为返回的元组元素分配名称
- en: ❷ Accesses the elements by name
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过名称访问元素
- en: 'Let’s see another example. You know you can use `Where` with a predicate to
    filter the values in a list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。你知道你可以使用`Where`与谓词一起过滤列表中的值：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What if you want to know both the elements that satisfy the predicate and those
    that don’t, in order to process them separately? For this, I’ve defined a method
    called `Partition`, which returns a tuple containing both lists:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道满足谓词的元素以及那些不满足的元素，以便分别处理它们，我可以定义一个名为`Partition`的方法，该方法返回包含两个列表的元组：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As these examples illustrate, tuple syntax allows you to elegantly write and
    consume methods that need to return more than one value. There’s no good reason
    to define a dedicated type to hold together those values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些示例所示，元组语法允许你优雅地编写和消费需要返回多个值的函数。没有必要定义一个专门的数据类型来组合这些值。
- en: 1.2.4 Pattern matching and record types
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 模式匹配和记录类型
- en: 'Versions 8 and 9 of C#, which appeared after the first edition of this book
    was published, bring us two important features that are directly inspired by functional
    languages:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书第一版出版后出现的 C# 8 和 9 版本，为我们带来了两个直接受函数式语言启发的功能：
- en: '*Pattern matching*—Lets you use the `switch` keyword to match not only on specific
    values but also on the shape of the data, most importantly its type'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模式匹配*—允许你使用`switch`关键字来匹配不仅特定的值，还包括数据的形状，最重要的是其类型'
- en: '*Records*—Boilerplate-free immutable types with built-in support for creating
    modified versions'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*记录*—无需样板代码的不可变类型，具有内置的创建修改版本的支持'
- en: TIP The appendix shows you how you can work with pattern matching and immutable
    types if you’re working with legacy code and are stuck with an older version of
    C#.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：附录展示了如果你在使用遗留代码并且被限制在较旧的 C# 版本中，如何使用模式匹配和不可变类型。
- en: I’ll illustrate how you can use these through a practical example. If you’ve
    ever worked in e-commerce, you may have come across the need to evaluate the value-added
    tax (VAT) that your customers will pay with their purchases.[²](#pgfId-1104304)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过一个实际示例来展示如何使用这些功能。如果你曾经从事过电子商务，你可能遇到过评估客户购买时需要支付的增值税（VAT）的需求。[²](#pgfId-1104304)
- en: 'Imagine you’re tasked with writing a function that estimates the VAT a customer
    needs to pay on an order. The logic and amount of VAT depends on the country to
    which the item is sent and, of course, on the purchase amount. Therefore, we’re
    looking to implement a function named `Vat` that will compute a `decimal` (the
    tax amount), given an `Order` and the buyer’s `Address`. Assume that the requirements
    are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被要求编写一个函数来估算客户在订单上需要支付的增值税。增值税的逻辑和金额取决于物品寄送的国家，当然，还有购买金额。因此，我们正在寻找实现一个名为`Vat`的函数，该函数将根据一个`Order`和买家的`Address`计算一个`decimal`（税额）。假设以下要求：
- en: For goods shipped to Italy and Japan, VAT will be charged at a fixed rate of
    22% and 8%, respectively.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于运往意大利和日本的商品，将分别收取 22% 和 8% 的固定税率增值税。
- en: Germany charges 8% on food products and 20% on all other products.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 德国对食品产品收取 8% 的增值税，对所有其他产品收取 20% 的增值税。
- en: The US charges a fixed rate on all products, but the rate varies for each state.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国对所有产品收取固定的税率，但每个州的税率各不相同。
- en: Before you read on, you might like to take a moment to think how you would go
    about tackling this task.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，你可能想花一点时间思考一下你将如何着手处理这个任务。
- en: The following listing shows how you can use record types to model an `Order`.
    To keep things simple, I’m assuming that an `Order` cannot contain different types
    of `Product`s.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用记录类型来模拟一个`Order`。为了简化问题，我假设一个`Order`不能包含不同类型的`Product`。
- en: Listing 1.6 Positional records
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.6 位置记录
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ A record without a body ends with a semicolon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个没有主体的记录以分号结尾。
- en: ❷ A record can have a body with additional members.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记录可以有带有附加成员的主体。
- en: Notice how with a single line, you can define the `Product` type! The compiler
    generates a constructor, property getters, and several convenience methods such
    as `Equals`, `GetHashCode`, and `ToString` for you.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您只需一行就可以定义`Product`类型！编译器为您生成构造函数、属性获取器和几个便利方法，例如`Equals`、`GetHashCode`和`ToString`。
- en: NOTE Records in C# 9 are reference types, but C# 10 allows you to use record
    syntax to define value types by simply writing `record struct` rather than just
    `record`. Somewhat surprisingly, record structs are mutable, and you have to declare
    your struct as `readonly` `record` `struct` if you want it to be immutable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：C# 9中的记录是引用类型，但C# 10允许您通过简单地写入`record struct`而不是仅`record`来使用记录语法定义值类型。有些令人惊讶的是，记录结构是可变的，如果您想使其不可变，必须将您的结构声明为`readonly`
    `record` `struct`。
- en: The following listing shows how we can implement the first business rule, which
    applies to countries with a fixed VAT rate, like Italy and Japan.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何实现第一个业务规则，该规则适用于具有固定增值税率的意大利和日本等国家。
- en: Listing 1.7 Pattern matching on a value
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.7 在值上执行模式匹配
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here I’ve defined `RateByCountry` to map country codes to their respective VAT
    rates. Notice the clean syntax of a `switch` expression compared to the traditional
    `switch` statement with its clunky use of `case`, `break`, and `return`. Here
    we simply match on the *value* of `country`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我定义了`RateByCountry`来映射国家代码到它们各自的增值税率。注意与传统的使用`case`、`break`和`return`的笨拙的`switch`语句相比，`switch`表达式的简洁语法。这里我们只是匹配`country`的*值*。
- en: 'Also notice that the code in listing 1.7 assumes there is an `Address` type
    with a `Country` property. This can be defined as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，列表1.7中的代码假设存在一个具有`Country`属性的`Address`类型。它可以定义如下：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What about the other fields that make up an address, like the street, postal
    code, and so on? No, I didn’t forget or leave them out for simplicity. Because
    we only require the country for this calculation, it’s legitimate to have an `Address`
    type that only encapsulates the information we need in this context. You could
    have a different, richer definition of `Address` in a different component, and
    define a conversion between the two, if required.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '那么，组成地址的其他字段，如街道、邮政编码等呢？不，我没有忘记或为了简单起见而省略它们。因为我们只需要这个计算的国家信息，所以拥有只封装我们在这个上下文中需要的信息的`Address`类型是合法的。您可以在不同的组件中有一个不同的、更丰富的`Address`定义，并在需要时定义两者之间的转换。 '
- en: Let’s move on and add the implementation for goods shipped to Germany. As a
    reminder, Germany charges 8% on food products and 20% on all other products. The
    code in the following listing shows how we can add this rule.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并添加将货物运往德国的实现。作为提醒，德国对食品产品征收8%的税，对所有其他产品征收20%的税。以下列表中的代码显示了如何添加此规则。
- en: Listing 1.8 Deconstructing a record in a pattern-matching expression
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.8 在模式匹配表达式中解构记录
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ve now added a `switch` expression within the `Vat` function. In each case,
    the given `Address` is deconstructed, allowing us to match on the value of its
    `Country`. In the first case, we match it against the literal value "de"; if this
    matches, we call the VAT computation for Germany, `DeVat`. In the second case,
    the value is assigned to the `country` variable and we retrieve the rate by country
    as previously. Note that it’s possible to simplify the clauses of the `switch`
    expression as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`Vat`函数中添加了一个`switch`表达式。在每种情况下，给定的`Address`都会被解构，使我们能够根据其`Country`的值进行匹配。在第一种情况下，我们将其与字面值"de"进行匹配；如果匹配成功，我们调用德国的增值税计算，`DeVat`。在第二种情况下，值被分配给`country`变量，我们按照之前的方法检索该国的税率。注意，可以将`switch`表达式的子句简化如下：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because the type of `address` is known to be `Address`, you can omit the type.
    In this example, you must include a variable name for the matching expression;
    here we use a discard, the underscore character. This is not required if the object
    being deconstructed has at least two fields.[³](#pgfId-1108075)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`address`的类型已知为`Address`，所以可以省略类型。在这个例子中，必须为匹配表达式包含一个变量名；这里我们使用一个丢弃的变量，即下划线字符。如果正在解构的对象至少有两个字段，则不需要这样做。[³](#pgfId-1108075)
- en: Property patterns
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 属性模式
- en: The previous listing shows how to match on the value of a field by deconstructing
    the Address; this is called a *positional pattern*. Now, imagine that your `Address`
    type were more complex, including half a dozen fields or so. In this case, a positional
    pattern would be noisy, as you’d need to include a variable name (at least a discard)
    for each field.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表展示了如何通过解构地址来匹配字段的值，这被称为*位置模式*。现在，假设您的`Address`类型更复杂，包括大约六个字段。在这种情况下，位置模式会变得嘈杂，因为您需要为每个字段包含一个变量名（至少是一个丢弃变量）。
- en: 'This is where *property pattern*s are better suited. The following code shows
    how you can match on the value of a property:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是*属性模式*更适合的地方。以下代码展示了如何通过匹配属性值来进行匹配：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This syntax offers the advantage that you do not need to change anything if
    you later add an extra field to `Address`. In general, property patterns work
    best with your typical OO entities, whereas positional patterns work best with
    very simple objects whose definition is unlikely to change (like a 2D point),
    or with objects that were modeled around a specific pattern matching scenario,
    like the simplified `Address` type in the current example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的好处是，如果您后来向`Address`添加了额外的字段，您不需要做任何改变。一般来说，属性模式最适合您的典型面向对象实体，而位置模式最适合非常简单的对象，其定义不太可能改变（如2D点），或者与特定模式匹配场景建模的对象，如当前示例中的简化`Address`类型。
- en: 'Now for the US. Here we also need to know the state to which the order is going
    because different states apply different rates. You can model this as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是关于美国的。在这里，我们也需要知道订单将发送到哪个州，因为不同的州有不同的税率。您可以按照以下方式建模：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That is, we create a dedicated type to represent a US address. This extends
    `Address` because it has additional data. (In my opinion, this is better than
    adding a `State` property to `Address` and having it be `null` for the majority
    of countries.) We can now complete our requirements as the following listing shows.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们创建了一个专门的数据类型来表示美国地址。这扩展了`Address`，因为它有额外的数据。（在我看来，这比在`Address`中添加一个`State`属性并将其设置为`null`对于大多数国家来说更好。）现在，我们可以像以下列表所示那样完成我们的需求。
- en: Listing 1.9 Pattern matching by type
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.9 通过类型进行模式匹配
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`RateByState` is implemented along the same lines as `RateByCountry`. What’s
    more interesting is the pattern matching in `Vat`. We can now match on the `UsAddress`
    type, extracting the state, to find the rate applicable to that state.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`RateByState`的实现与`RateByCountry`类似。更有趣的是`Vat`中的模式匹配。我们现在可以匹配`UsAddress`类型，提取出该州的税率。'
- en: TIP This section illustrates the most common (and most useful) patterns that
    C# supports. In addition, you can use relational patterns to match, say, all values
    greater than 100, or logical patterns to combine several other patterns. Head
    to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns)
    for the full specification.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 本节说明了C#支持的最常见（也是最有用）的模式。此外，您可以使用关系模式来匹配，例如，匹配所有大于100的值，或者使用逻辑模式来组合多个其他模式。有关完整规范，请访问[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns)。
- en: And we’re done! The whole thing is just over 40 lines, most functions are one-liners,
    and the three cases in our requirements are clearly expressed in the corresponding
    cases in the top-level `switch` expression. We didn’t need to go crazy with functions
    (yet). We didn’t need to create an interface with multiple implementations as
    an OO programmer (seeing this problem as a perfect candidate for the *strategy*
    pattern) probably would have. Instead, we just used a *type-driven* approach that
    is representative of how records and pattern matching can be used in statically-typed
    functional languages.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了！整个代码只有40多行，大多数函数都是单行代码，我们需求中的三个情况在顶层`switch`表达式的相应情况中得到了清晰的表达。我们还没有必要对函数进行复杂的操作（目前还没有）。我们也不需要像面向对象程序员那样创建一个具有多个实现的接口（将这个问题视为*策略模式*的完美候选），可能的话。相反，我们只是使用了一种*类型驱动*的方法，这种方法展示了如何在静态类型函数式语言中使用记录和模式匹配。
- en: The resulting code is not only concise, but is also readable and extensible.
    You can see that it would be easy for any programmer to come in and add new rules
    for other countries or modify the existing rules if required.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码不仅简洁，而且可读性和可扩展性都很强。您可以看到，任何程序员都很容易添加针对其他国家的规则或根据需要修改现有规则。
- en: 1.3 What you will learn in this book
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 你将在本书中学到什么
- en: In this chapter, you’ve seen some of the basic ideas of FP and the C# features
    that allow you to program in a functional style. This book does not assume any
    prior knowledge of functional programming. It does assume you know .NET and C#
    well (or, alternatively, a similar language like Java, Swift, or Kotlin). This
    book is about functional programming, not C#. After reading this book, you will
    be able to
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了 FP 和 C# 的基本概念，以及允许你在函数式风格中编程的特性。本书不假设你对函数式编程有任何先前的了解。它假设你非常了解 .NET
    和 C#（或者，作为替代，类似 Java、Swift 或 Kotlin 这样的语言）。本书是关于函数式编程的，而不是关于 C# 的。阅读完这本书后，你将能够
- en: Use higher-order functions to achieve more with less code and reduce duplication
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶函数以更少的代码实现更多功能，并减少重复
- en: Use pure functions to write code that is easy to test and optimize
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯函数编写易于测试和优化的代码
- en: Write APIs that are pleasant to consume and accurately describe your program’s
    behavior
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写易于消费且准确描述程序行为的 API
- en: Use dedicated types to handle nullability, system errors, and validation rules
    in a way that’s elegant and predictable
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用类型以优雅和可预测的方式处理可空性、系统错误和验证规则
- en: Write testable, modular code that can be composed without the overhead of an
    IoC container
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可测试、模块化的代码，无需 IoC 容器的开销即可组合
- en: Write a Web API in a functional style
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式风格编写 Web API
- en: Write complex programs with simple, declarative code, using high-level functions
    to process elements in a sequence or a stream of values
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单、声明性的代码编写复杂的程序，利用高级函数处理序列或值流中的元素
- en: Read and understand literature written for functional languages
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读和理解为函数式语言编写的文献
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional programming (FP) is a powerful paradigm that can help you make your
    code more concise, maintainable, expressive, robust, testable, and concurrency-friendly.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程（FP）是一种强大的范式，可以帮助你使代码更加简洁、可维护、表达性强、健壮、可测试，并且对并发友好。
- en: FP differs from object-oriented programming (OOP) by focusing on functions rather
    than objects, and on data transformations rather than state mutations.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP 与面向对象编程（OOP）不同，它侧重于函数而不是对象，侧重于数据转换而不是状态突变。
- en: 'FP can be seen as a collection of techniques that are based on two fundamental
    tenets:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP 可以被视为一系列基于两个基本原则的技术集合：
- en: Functions are first-class values.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是一等值。
- en: In-place updates should be avoided.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应避免就地更新。
- en: C# is a multi-paradigm language that has steadily incorporated functional features,
    allowing you to reap the benefits of programming in a functional style.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 是一种多范式语言，它稳步地融合了函数式特性，让你能够享受到在函数式风格编程中的好处。
- en: '* * *'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ C# 7 tuples supersede their clunky C# 4 predecessors, which were suboptimal
    in performance and unattractive in syntax, their elements being accessed via properties
    called `Item1`, `Item2`, and so on. Apart from the new syntax, the underlying
    implementation of tuples also changed. The old tuples are backed by the `System.Tuple`
    classes, which are immutable reference types. The new tuples are backed by the
    `System .ValueTuple` structs. Being structs, they’re copied when passed between
    functions, yet they’re mutable, so you can update their members within methods,
    which is a compromise between the expected immutability of tuples and performance
    considerations.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ C# 7 的元组取代了笨拙的 C# 4 前辈，后者在性能上不佳，在语法上不吸引人，其元素通过名为 `Item1`、`Item2` 等的属性访问。除了新的语法外，元组的底层实现也发生了变化。旧的元组由
    `System.Tuple` 类支持，它们是不变引用类型。新的元组由 `System.ValueTuple` 结构支持。作为结构，它们在函数间传递时会被复制，但它们是可变的，因此你可以在方法内更新它们的成员，这是元组预期的不可变性和性能考虑之间的折衷。
- en: ² VAT is also called *sales tax* or *consumption tax*, depending on the country
    you’re in.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ² 增值税（VAT）也被称为 *销售税* 或 *消费税*，具体取决于你所在的国家。
- en: ³ The problem is that in C# `("de")` is identical to `"de"`, so the compiler
    would think you’re matching on a `string`, rather than an object with a single
    string field.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 问题在于在 C# 中 `("de")` 与 `"de"` 是相同的，所以编译器会认为你是在匹配一个 `string`，而不是具有单个字符串字段的对象。
