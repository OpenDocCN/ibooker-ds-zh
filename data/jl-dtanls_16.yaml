- en: 14 Creating web services for sharing data analysis results
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 创建用于共享数据分析结果的Web服务
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Implementing a Monte Carlo simulation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施蒙特卡洛模拟
- en: Using multiple threads in computations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算中使用多线程
- en: Creating and running a web service in Julia
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Julia中创建和运行Web服务
- en: In chapter 1, we discussed a Timeline case study. Recall that the Timeline company
    provides a web application that helps financial advisers with retirement financial
    planning. This application needs to perform a lot of on-demand computations while
    having a fast response time. In this chapter, we will create a web service that
    serves a similar purpose in a simplified setting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了一个时间线案例研究。回想一下，时间线公司提供了一款帮助财务顾问进行退休财务规划的网络应用程序。该应用程序需要在快速响应时间的同时执行大量的按需计算。在本章中，我们将创建一个在简化设置中具有类似功能的Web服务。
- en: Imagine we are working at a company that offers its customers a service of evaluating
    financial assets. You are asked to create a web service that will perform pricing
    of an Asian option. *Asian options* are financial instruments whose price depends
    on an average price of an underlying asset (for example, a stock) over a certain
    period; in section 14.1, I give details of how this option is defined.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在一家为客户提供评估金融资产服务的公司工作。你被要求创建一个Web服务，用于对亚洲期权进行定价。*亚洲期权*是一种金融工具，其价格取决于一定时期内标的资产（例如，股票）的平均价格；在第14.1节中，我给出了该期权定义的详细信息。
- en: Since the Asian option is a complex financial instrument, there is no simple
    formula for its value. Therefore, you need to perform a Monte Carlo simulation
    to approximate this value. When doing a Monte Carlo simulation, we randomly sample
    the evolution of the underlying asset’s price multiple times. Next, for each price
    path, we compute the payoff of the Asian option and use the average payoff to
    approximate the option’s value.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于亚洲期权是一种复杂的金融工具，其价值没有简单的公式。因此，您需要执行蒙特卡洛模拟来近似这个值。在进行蒙特卡洛模拟时，我们多次随机采样标的资产价格的变化。接下来，对于每条价格路径，我们计算亚洲期权的收益，并使用平均收益来近似期权的价值。
- en: The challenge is that Monte Carlo simulations are compute intensive. Therefore,
    in this chapter, you will learn how to use multiple cores of your CPU, taking
    advantage of Julia’s support for multithreading, to produce the desired result
    as quickly as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于蒙特卡洛模拟计算密集。因此，在本章中，您将学习如何利用CPU的多核，利用Julia对多线程的支持，尽可能快地产生所需的结果。
- en: From the engineering side, the requirements are that your web service accepts
    JSON payloads in POST requests and also returns the response in JSON format. In
    this case, the POST request sends data to the server specifying the parameters
    of the Asian option that we want to valuate. These parameters are passed in JSON
    format to the server; information passed this way is often called a *JSON payload*.
    You will learn how to create such web services by using the Genie.jl package.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从工程角度来看，要求是您的Web服务接受POST请求中的JSON有效载荷，并返回JSON格式的响应。在这种情况下，POST请求将数据发送到服务器，指定我们想要评估的亚洲期权的参数。这些参数以JSON格式传递到服务器；以这种方式传递的信息通常被称为*JSON有效载荷*。您将通过使用Genie.jl包学习如何创建此类Web服务。
- en: To test the created web service, we will write a client program that will analyze
    how the valuation of the Asian option changes with its parameters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试创建的Web服务，我们将编写一个客户端程序，该程序将分析亚洲期权的估值如何随着其参数的变化而变化。
- en: 'This chapter is divided into the following sections:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下几节：
- en: Section 14.1 explains the theory of pricing Asian options by using a Monte Carlo
    simulation.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第14.1节解释了使用蒙特卡洛模拟对亚洲期权进行定价的理论。
- en: In section 14.2, we implement the simulation while taking advantage of the multithreading
    support that Julia offers.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第14.2节中，我们利用Julia提供的多线程支持来实现模拟。
- en: In section 14.3, using the Genie.jl package, we create a web service that can
    respond to requests for valuation of the Asian option.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第14.3节中，我们使用Genie.jl包创建了一个可以响应对亚洲期权估值请求的Web服务。
- en: In section 14.4, we test the created web service by writing a client that sends
    requests to it and fetches the returned response.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第14.4节中，我们通过编写一个客户端程序向创建的Web服务发送请求并获取返回的响应来测试该Web服务。
- en: 14.1 Pricing financial options by using a Monte Carlo simulation
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 使用蒙特卡洛模拟对金融期权进行定价
- en: In this section, you will learn the theory behind pricing Asian options by using
    a Monte Carlo simulation. Such pricing models are commonly used in the financial
    industry, so it is useful to know the details of how they work. Our example is
    adapted from *Foundations and Methods of Stochastic Simulation* by Barry L. Nelson
    (Springer, 2013).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将通过使用蒙特卡洛模拟来学习亚洲期权定价背后的理论。这类定价模型在金融行业中普遍使用，因此了解它们是如何工作的细节是有用的。我们的例子改编自Barry
    L. Nelson的《随机模拟的基础与方法》（Springer，2013年）。
- en: 14.1.1 Calculating the payoff of an Asian option definition
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 计算亚洲期权的收益定义
- en: We start by giving a definition of an Asian option we consider. The payoff of
    such an option depends on an underlying financial instrument. Assume that this
    underlying instrument is a stock. We observe the price of this stock over a certain
    period of time. The Asian option gives an investor a payoff if the average price
    of the stock is greater than a value called the *strike price*. In such a case,
    the payoff of the Asian option is equal to the mean price of the stock minus the
    strike price. Now I’ll formally define the way the payoff is computed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先给出我们考虑的亚洲期权的定义。这种期权的收益取决于一个基础金融工具。假设这个基础工具是股票。我们在一定时间内观察这只股票的价格。如果股票的平均价格高于称为*行权价格*的值，亚洲期权会给投资者带来收益。在这种情况下，亚洲期权的收益等于股票的平均价格减去行权价格。现在我将正式定义收益是如何计算的。
- en: Assume that a stock is traded on the market. We use *X*(*t*) to denote its price
    at time *t*. For simplicity, assume that we are currently at time *t* = 0, so
    we know that the price of the stock is *X*(*0*). We are interested in the average
    price of this stock in the period from *t* = 0 to *t* = *T*. During this period,
    the stock changes its price *m* times. Therefore, we will see its price at times
    0, *T*/*m*, 2*T*/*m*, . . . , (*m* - 2)*T*/*m,* (*m* - 1)*T*/*m,* and *T*. We
    use *Y* to denote the average price of the stock over these *m* + 1 points in
    time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一只股票在市场上交易。我们用 *X*(*t*) 表示它在时间 *t* 的价格。为了简单起见，假设我们目前处于时间 *t* = 0，因此我们知道股票的价格是
    *X*(*0*)。我们感兴趣的是从 *t* = 0 到 *t* = *T* 这段时间内股票的平均价格。在这段时间内，股票的价格变化了 *m* 次。因此，我们将看到它在时间
    0，*T*/*m*，2*T*/*m*，...，(*m* - 2)*T*/*m,*，(*m* - 1)*T*/*m,* 和 *T* 的价格。我们用 *Y* 表示在这些
    *m* + 1 个时间点上的股票平均价格。
- en: The Asian option we consider has the following rule of its valuation. At time
    *T*, we compute the average price of the stock *Y*. If this value is greater than
    the value *K* (called the *strike price*), we get a *Y - K* payoff; otherwise,
    we get no payoff. More formally, our payoff is max(*Y - K*, 0). If you have experience
    with machine learning, you will recognize that this function is often called a
    *rectified linear unit* (*ReLU*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的亚洲期权有其估值规则。在时间 *T*，我们计算股票 *Y* 的平均价格。如果这个值大于价值 *K*（称为*行权价格*），我们得到 *Y - K*
    的收益；否则，我们得不到任何收益。更正式地说，我们的收益是 max(*Y - K*, 0)。如果你有机器学习的经验，你会认识到这个函数通常被称为*修正线性单元*
    (*ReLU*)。
- en: 'Before we move forward, let’s consider an example of such pricing. Assume that
    we have *T* = 1.0, *m* = 4, and *K* = 1.05\. We are in time *T*, and we have seen
    the prices *X* that were 1.0, 1.1, 1.3, 1.2, 1.2\. Therefore, *Y* is equal to
    1.16, so the payoff is max(*Y - K*, 0) = 0.11\. We can visualize this scenario
    with the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们考虑这样一个定价的例子。假设我们有 *T* = 1.0，*m* = 4，和 *K* = 1.05。我们处于时间 *T*，我们看到了价格
    *X* 为 1.0，1.1，1.3，1.2，1.2。因此，*Y* 等于 1.16，所以收益是 max(*Y - K*, 0) = 0.11。我们可以用以下代码可视化这个场景：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we use three new functions. The range function creates a vector
    of equally spaced values, from the first to the second positional argument it
    is passed, and the length keyword argument specifies the number of points we want.
    The hline! function adds a horizontal line to the plot, and the annotate! function
    adds text annotations to it. The annotate! function takes a vector in which each
    element is a tuple specifying the *x* location, *y* location, and the text to
    be displayed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了三个新的函数。范围函数创建一个从第一个到第二个位置参数的等间距值的向量，长度关键字参数指定我们想要的点的数量。hline! 函数向图中添加一条水平线，annotate!
    函数向其添加文本注释。annotate! 函数接受一个向量，其中每个元素都是一个元组，指定了 *x* 位置，*y* 位置和要显示的文本。
- en: Figure 14.1 shows the result produced by our code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1显示了我们的代码产生的结果。
- en: '![CH14_F01_Kaminski2](../Images/CH14_F01_Kaminski2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F01_Kaminski2](../Images/CH14_F01_Kaminski2.png)'
- en: Figure 14.1 Since Y is above K, the Asian option gives a positive payoff for
    stock price X.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 由于Y高于K，亚洲期权对于股票价格X给出了正的收益。
- en: 14.1.2 Computing the value of an Asian option
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 计算亚洲期权的价值
- en: Our task is to compute the value of the Asian option at time 0\. At this time,
    we do not know *Y*. What, then, is a fair value of our Asian option?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是计算亚洲期权在时间 0 的价值。在这个时候，我们不知道 *Y*。那么，我们亚洲期权的公平价值是什么？
- en: Imagine that we could buy such an option many times and observe the evolution
    of the stock prices underlying our option. The value of our option is defined
    to be the average payoff we could expect in such an experiment. Formally, using
    the language of probability theory, we say that we want to compute the expected
    value of our payoff via *E*(max(*Y - K*, 0)). However, we need to consider one
    additional factor. Since the payoff is collected at time *T*, and we are at time
    0, we need to discount it. Assume that *r* is a risk-free interest rate, and we
    use continuous compounding (this is a typical assumption made in financial calculations;
    see, for example, [http://mng.bz/AV87](http://mng.bz/AV87)). Therefore, we need
    to multiply the expected value of the payoff by discount factor exp(*-rT*). In
    summary, the value of the option at time 0 is exp(*-rT*)·*E*(max(*Y - K*, 0)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假想我们能够多次购买这样的期权并观察我们期权所依据的股票价格的演变。我们期权的价值被定义为在这种实验中我们可能期望的平均收益。正式来说，使用概率论的语言，我们说我们想要通过
    *E*(max(*Y - K*, 0)) 来计算我们收益的期望值。然而，我们需要考虑一个额外的因素。由于收益是在时间 *T* 收集的，而我们处于时间 0，我们需要对其进行折现。假设
    *r* 是无风险利率，我们使用连续复利（这是金融计算中常见的假设；例如，参见 [http://mng.bz/AV87](http://mng.bz/AV87)）。因此，我们需要将收益的期望值乘以折现因子
    exp(*-rT*)。总之，期权在时间 0 的价值是 exp(*-rT*)·*E*(max(*Y - K*, 0))。
- en: The challenge of computing the requested value is that at time 0, the value
    of *Y* is unknown. We will assume that the price of the stock in the period between
    0 and *T* follows *geometric Brownian motion* (GBM, [http://mng.bz/ZpRa](http://mng.bz/ZpRa)).
    This stochastic process is often used to model prices of financial assets.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 计算所需价值的挑战在于，在时间 0，*Y* 的价值是未知的。我们将假设在 0 到 *T* 期间股票的价格遵循几何布朗运动（GBM，[http://mng.bz/ZpRa](http://mng.bz/ZpRa)）。这个随机过程常用于模拟金融资产的价格。
- en: 14.1.3 Understanding GBM
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 理解GBM
- en: Typically, the GBM process is introduced as a solution of a stochastic differential
    equation, but for our purposes, it is enough that you have an intuitive understanding.
    The idea is as follows. If we have a stochastic process *X*(*t*) representing
    a stock price, we want the logarithm of the ratio of this price between two times
    *t*[1] and *t*[2] (where *t*[1] *< t*[2]) to follow a normal distribution. This
    ratio can be expressed using the formula log(*X*(*t*[2])/*X*(*t*[1])) and is called
    the *log return* ([http://mng.bz/RvmO](http://mng.bz/RvmO)). Since we assume that
    the log return follows a normal distribution, we should specify the mean and variance
    of this distribution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，GBM过程被介绍为随机微分方程的解，但就我们的目的而言，你只需要有一个直观的理解即可。其思路如下。如果我们有一个随机过程 *X*(*t*) 代表股票价格，我们希望这个价格在两个时间
    *t*[1] 和 *t*[2]（其中 *t*[1] *< t*[2]）之间的比率的对数遵循正态分布。这个比率可以用公式 log(*X*(*t*[2])/*X*(*t*[1]))
    表示，称为 *log return* ([http://mng.bz/RvmO](http://mng.bz/RvmO))。由于我们假设log return遵循正态分布，因此我们应该指定这个分布的均值和方差。
- en: Let’s start with the variance of the distribution of the stock price’s log return.
    In the GBM model, we assume that the variance is equal to *s*²(*t*[2] - *t*[1]),
    where *s* is a parameter. As you can see, the variance is proportional to the
    difference between *t*[2] and *t*[1]. To understand why this is a natural assumption,
    consider three time periods, *t*[1] *<* *t*[2] *<* *t*[3]. The assumption in the
    GBM model is that the log returns between periods *t*[1] and *t*[2], and *t*[2]
    and *t*[3], respectively, are independent. Observe that log(*X*(*t*[2])/*X*(*t*[1]))
    *+* log(*X*(*t*[3])/*X*(*t*[2])) = log(*X*(*t*[3])/*X*(*t*[1])). Therefore, if
    we want the GBM model to be consistent, the sum of variances of the two terms
    on the left-hand side of this equation must be equal to the variance of the term
    on the right-hand side. Indeed, this is the case, as *s*²(*t*[2] - *t*[1]) *+
    s*²(*t*[3] *- t*[2]) = *s*²*(t*[3] *- t*[1]*)*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从股票价格对数收益率的分布的方差开始。在GBM模型中，我们假设方差等于*s*²(*t*[2] - *t*[1])，其中*s*是一个参数。正如你所看到的，方差与*t*[2]和*t*[1]之间的差异成正比。为了理解为什么这是一个自然的假设，考虑三个时间段，*t*[1]
    *<* *t*[2] *<* *t*[3]。GBM模型中的假设是，时间段*t*[1]和*t*[2]，以及*t*[2]和*t*[3]之间的对数收益率是独立的。观察log(*X*(*t*[2])/*X*(*t*[1]))
    *+* log(*X*(*t*[3])/*X*(*t*[2])) = log(*X*(*t*[3])/*X*(*t*[1])). 因此，如果我们想让GBM模型保持一致，方程左边两个项的方差之和必须等于方程右边项的方差。确实如此，因为*s*²(*t*[2]
    - *t*[1]) *+ s*²(*t*[3] *- t*[2]) = *s*²*(t*[3] *- t*[1]*)*.
- en: We are now ready to turn to the expected value of the distribution of the stock
    price’s log return. Here the assumption I make in the book is that the log return
    on the expected stock price should be equal to the log return of the risk-free
    asset. Recall that we have used *r* to denote the risk-free interest rate with
    continuous compounding. This means that *r*(*t*[2] *- t*[1]) should be equal to
    log(*E*(*X*(*t*[2]))/*E*(*X*(*t*[1]))). It can be shown that if we want this property
    to hold, the mean of the distribution of the stock price’s log return should be
    equal to (*r - s*²/2)(*t*[2] *- t*[1]).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备转向股票价格对数收益率的分布的期望值。在这里，我在书中提出的假设是，预期股票价格的对数收益率应该等于无风险资产的对数收益率。回想一下，我们用*r*来表示连续复利下的无风险利率。这意味着*r*(*t*[2]
    *- t*[1])应该等于log(*E*(*X*(*t*[2]))/*E*(*X*(*t*[1]))). 可以证明，如果我们想使这个性质成立，股票价格对数收益率的分布的均值应该等于(*r
    - s*²/2)(*t*[2] *- t*[1])。
- en: In summary, in our GBM model, we assume that the log return of the stock price
    log(*X*(*t*[2])/*X*(*t*[1])) follows a normal distribution with mean (*r - s*²/2)(*t*[2]
    *- t*[1]) and standard deviation *s*²(*t*[3] *- t*[1]). Let’s translate this assumption
    to the parameterization we use in the implementation. Recall that we assume that
    the stock price is measured at times 0, *T*/*m*, 2*T*/*m, . . .* , (*m - 2)T*/*m*,
    (*m - 1*)*T*/*m*, and *T*. Under these assumptions, the value of the ratio *X*((*I*
    + 1)*T*/*m*)/*X*(*iT*/*m*) is the random variable exp((*r - s*²/2)*T*/*m* + *s*²(*T*/*m*)·*Z*(*i*)),
    where *Z*(*0)*, *Z*(*1*), . . . , *Z*(*m -* 2), *Z*(*m - 1*) are independent and
    identically distributed random variables having normal distribution with mean
    0 and standard deviation 1\. In this formula, *r* is the risk-free interest rate,
    and *s* is a measure of the stock price’s variability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在我们的几何布朗运动模型中，我们假设股票价格对数(*X*(*t*[2])/*X*(*t*[1]))的收益率服从均值为(*r - s*²/2)(*t*[2]
    *- t*[1])和标准差*s*²(*t*[3] *- t*[1])的正态分布。让我们将这个假设转换为我们实现中使用的参数化。回想一下，我们假设股票价格是在时间0，*T*/*m*，2*T*/*m*，...，(*m
    - 2)T*/*m*，(*m - 1*)*T*/*m*，和*T*时测量的。在这些假设下，比率*X*((*I* + 1)*T*/*m*)/*X*(*iT*/*m*)的值是随机变量exp((*r
    - s*²/2)*T*/*m* + *s*²(*T*/*m*)·*Z*(*i*))，其中*Z*(*0)*，*Z*(*1*)，...，*Z*(*m - 2)，*Z*(*m
    - 1*)是独立同分布的随机变量，具有均值为0和标准差1的正态分布。在这个公式中，*r*是无风险利率，*s*是股票价格变动的度量。
- en: Before we move forward, let’s look at a minimal example of generating a single
    sample of the GBM process. In the computations, we use *X*(0) = 1.0, *T* = 2.0,
    *s* = 0.2, *r* = 0.1, and *m* = 4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们看看生成GBM过程单个样本的最小示例。在计算中，我们使用*X*(0) = 1.0，*T* = 2.0，*s* = 0.2，*r*
    = 0.1，和*m* = 4。
- en: 'In the code, we collect the results of a simulation of a single sample of the
    GBM process in a data frame having two columns: simulated stock price X and time
    t. Next, we iteratively sample the log return of our stock price between two consecutive
    periods. Using it, we compute the updated stock price and store it as a new row
    of the gbm data frame using the push! function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们将 GBM 过程单个样本的模拟结果收集到一个具有两列的数据框中：模拟股票价格 X 和时间 t。然后，我们迭代地抽取股票价格在两个连续时间段之间的
    log 返回值。使用它，我们计算更新的股票价格，并使用 push! 函数将其存储为 gbm 数据框的新行：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Sets the seed of the random number generator to ensure reproducibility of
    the example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置随机数生成器的种子以确保示例的可重复性
- en: ❷ Assigns values to several comma-separated variables using a single expression
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用单个表达式为几个逗号分隔的变量赋值
- en: ❸ Initializes the gbm data frame that will store the results of the simulation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 初始化将存储模拟结果的 gbm 数据框
- en: ❹ Generates a random value from the standard normal distribution by using the
    randn function
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 randn 函数从标准正态分布中生成一个随机值
- en: ❺ Computes the log-return of the stock price between two consecutive time periods
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 计算两个连续时间段之间股票价格的 log 返回值
- en: ❻ Computes the stock price in the next period, given the last stored price and
    log return
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 根据最后存储的价格和 log 返回值计算下一期的股票价格
- en: ❼ Adds a row to a data frame with information about the stock price and time
    when it was recorded
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 向数据框中添加一行，包含股票价格和记录时间的信息
- en: In the example, the stock price stored in column X of the gbm data frame changes
    randomly from period to period because in the calculation of the log_return variable,
    we have a random component represented by the Z variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，gbm数据框中存储的股票价格在周期之间随机变化，因为在计算 log_return 变量时，我们有一个由 Z 变量表示的随机成分。
- en: 14.1.4 Using a numerical approach to computing the Asian option value
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 使用数值方法计算亚洲期权价值
- en: The formulas describing the GBM process look complex. This suggests that there
    is no simple method allowing us to compute the value of the Asian option; recall
    that this value is defined as exp(*-rT*)·*E*(max(*Y - K*, 0)). Indeed, in this
    case there is no closed-form formula for this expression. How should we compute
    its value? We will use a Monte Carlo simulation to approximate it. The algorithm
    of a Monte Carlo simulation is as follows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 GBM 过程的公式看起来很复杂。这表明没有简单的方法可以让我们计算亚洲期权的价值；回想一下，这个价值被定义为 exp(*-rT*)·*E*(max(*Y
    - K*, 0))。实际上，在这种情况下，这个表达式的闭式公式不存在。我们应该如何计算它的值？我们将使用蒙特卡洛模拟来近似它。蒙特卡洛模拟的算法如下。
- en: 'In a single step of our Monte Carlo simulation, we need to compute the payoff
    of our Asian option for a single realization of the GBM process. Therefore, we
    need to perform the following operations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的蒙特卡洛模拟的单个步骤中，我们需要为 GBM 过程的单个实现计算亚洲期权的收益。因此，我们需要执行以下操作：
- en: Sample independent random values *Z*(0), *Z*(1), . . . , *Z*(*m* - 2), *Z*(*m*
    - 1) from the standard normal distribution.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从标准正态分布中独立抽取随机值 *Z*(0), *Z*(1), . . . , *Z*(*m* - 2), *Z*(*m* - 1)。
- en: Compute stock prices *X*(0), *X*(*T*/*m*), . . . , *X*((*m -* 1)/*T*), *X*(*T*)
    by using the generated random values.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的随机值计算股票价格 *X*(0), *X*(*T*/*m*), . . . , *X*((*m -* 1)/*T*), *X*(*T*)。
- en: Compute *Y* as an average of the computed stock prices.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *Y* 计算为计算出的股票价格的平均值。
- en: Compute *V* = exp(*-rT*)·max(*Y - K*, 0).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *V* = exp(*-rT*)·max(*Y - K*, 0)。
- en: In our Monte Carlo simulation, we repeat this single step of the process independently
    many times. Use *n* to denote the number of times we perform this single step.
    We thus will collect *n* values *V*(1), *V*(2), . . . , *V*(*n* - 1), *V*(*n*).
    The mean of these values approximates the value of our Asian option exp(*-rT*)·*E*(max(*Y
    - K*, 0)). However, since the process I have described is randomized, this value
    is not exact. In such situations, we usually want to quantify this uncertainty
    somehow. We will therefore compute the 95% confidence interval of our Asian option
    price.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的蒙特卡洛模拟中，我们独立重复这个过程很多次。用 *n* 表示执行此单个步骤的次数。因此，我们将收集 *n* 个值 *V*(1), *V*(2),
    . . . , *V*(*n* - 1), *V*(*n*)。这些值的平均值近似于我们的亚洲期权价值 exp(*-rT*)·*E*(max(*Y - K*,
    0))。然而，由于我描述的过程是随机的，这个值不是精确的。在这种情况下，我们通常希望以某种方式量化这种不确定性。因此，我们将计算亚洲期权价格的 95% 置信区间。
- en: The 95% confidence interval is a range in which, if we ran the simulation and
    computed it multiple times, 95% of the intervals would contain the true (unknown)
    value of our Asian option price ([www.simplypsychology.org/confidence-interval.html](https://www.simplypsychology.org/confidence-interval.html)).
    If we have a set of *n* independent observations whose mean is *m* and whose standard
    deviation is *sd*, then the formula for approximation of the 95% confidence interval
    that we will use in this chapter is [*m - 1.96sd*/√*n, m* + 1.96*sd*/√*n*].
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 95%置信区间是一个范围，如果我们运行模拟并多次计算，95%的区间将包含我们亚洲期权价格的真实（未知）值（[www.simplypsychology.org/confidence-interval.html](https://www.simplypsychology.org/confidence-interval.html)）。如果我们有一组
    *n* 个独立的观察值，其均值为 *m*，标准差为 *sd*，那么我们将使用以下公式在本章中近似95%置信区间：[*m - 1.96sd*/√*n, m*
    + 1.96*sd*/√*n*]。
- en: 'Before we move on to implementing the Asian option valuation algorithm, I’ll
    summarize the parameters that we need to know to calculate the value of the Asian
    option we are considering:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实现亚洲期权估值算法之前，我将总结我们需要知道以计算我们考虑的亚洲期权价值所需的参数：
- en: Time horizon *T*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间范围 *T*
- en: Starting price of the stock *X*(0)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票的起始价格 *X*(0)
- en: Strike price *K*
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行价格 *K*
- en: Risk-free interest rate *r*
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无风险利率 *r*
- en: Stock’s price volatility *s*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票价格波动率 *s*
- en: Number of changes of the price of the stock *m*
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票价格变动次数 *m*
- en: We assume that the user asking for the valuation of the Asian option knows these
    parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设请求亚洲期权估值用户知道这些参数。
- en: An additional technical parameter is *n*, which is the number of repetitions
    of the simulation. This parameter will affect the precision with which we will
    calculate the Asian option price.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技术参数是 *n*，它是模拟重复的次数。这个参数将影响我们计算亚洲期权价格时的精度。
- en: We are ready to write code that will compute the approximate value of the Asian
    option, along with the 95% confidence interval of this price. Additionally, in
    our implementation, we want to determine the probability that the payoff of the
    option will be zero.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备编写代码来计算亚洲期权的近似价值及其95%置信区间。此外，在我们的实现中，我们还想确定期权收益为零的概率。
- en: 14.2 Implementing the option pricing simulator
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 实现期权定价模拟器
- en: In this section, you will learn how to implement the simulator that prices the
    Asian option, following the description from the last part of section 14.1\. First,
    we will create a function that computes the payoff of our option for a single
    sample of stock prices. Next, we will create a function that computes the approximate
    price of the option by using the Monte Carlo simulation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何实现根据14.1节最后部分描述来定价亚洲期权的模拟器。首先，我们将创建一个函数，用于计算单个股票价格样本下我们期权的收益。接下来，我们将创建一个函数，通过蒙特卡洛模拟来计算期权的近似价格。
- en: In the process, we will use multithreading so we can quickly get the results
    of the computation. Learning how to write multithreaded code is useful, as it
    can efficiently use your CPU cores and, consequently, deliver computation results
    faster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将使用多线程，以便我们可以快速获得计算结果。学习如何编写多线程代码是有用的，因为它可以有效地使用你的CPU核心，从而更快地提供计算结果。
- en: 14.2.1 Starting Julia with multiple-thread support
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 使用多线程支持的Julia启动
- en: In this section, you will learn how to start Julia with multiple-thread support.
    This is useful when you want to use the full power of your CPU in the computations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何以多线程支持的方式启动Julia。当你想要在计算中使用CPU的全部能力时，这非常有用。
- en: 'For our computations, we want to use multiple threads, so start Julia with
    support for four threads. This is done by passing the -t4 switch. If you work
    in the terminal, you should be in the directory where we store the repository
    of code associated with this book. Type the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算中，我们希望使用多个线程，因此以四个线程的支持启动Julia。这是通过传递-t4开关来完成的。如果你在终端工作，你应该在我们存储与本书相关的代码存储库的目录中。输入以下内容：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you use Visual Studio Code (see appendix A), you can set the number of threads
    that the Julia session should use in the settings of the Julia extension.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio Code（见附录A），你可以在Julia扩展的设置中设置Julia会话应使用的线程数。
- en: I assume that the processor on your computer has at least four physical cores.
    The code will work if your processor does not meet this requirement, but you might
    not see the performance improvements that I present.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您电脑上的处理器至少有四个物理核心。如果您的处理器不符合这一要求，代码仍然可以运行，但您可能看不到我展示的性能提升。
- en: 'Once you start your Julia session using four threads, we first check to see
    if we set things up properly. The Threads.nthreads function returns the number
    of threads available to the Julia process:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用四个线程启动Julia会话，我们首先检查是否正确设置了环境。Threads.nthreads函数返回Julia进程可用的线程数：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As expected, we get 4, which means that code supporting multithreading will
    be able to use four cores of your CPU.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们得到4，这意味着支持多线程的代码将能够使用您CPU的四个核心。
- en: Starting Julia
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Julia
- en: You can choose from multiple options when you start the Julia process. You can
    get a list of those options by typing julia --help in the terminal or by checking
    the “Command-Line Options” section of the Julia Manual ([http://mng.bz/2r7m](https://shortener.manning.com/2r7m)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Julia进程时，您可以选择多个选项。您可以通过在终端中输入julia --help来获取这些选项的列表，或者检查Julia手册中的“命令行选项”部分（[http://mng.bz/2r7m](https://shortener.manning.com/2r7m)）。
- en: 'Here is a selected list of available switches:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可用的开关列表：
- en: -tN, *where N is a number*—Sets the number of threads to be used by Julia to
    N. In Visual Studio Code, you can set the value of N in the settings of the Julia
    extension.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -tN，*其中N是数字*—设置Julia使用的线程数为N。在Visual Studio Code中，您可以在Julia扩展的设置中设置N的值。
- en: --project—Sets the current working directory as the home project (see appendix
    A for an explanation). If you use the terminal, you should use this option when
    starting Julia for all code presented in this book. In Visual Studio Code, this
    option is used by default if you start a Julia session and opened a directory
    earlier with the repository storing your code along with Project.toml and Manifest.toml
    files.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --project—将当前工作目录设置为家目录项目（参见附录A的解释）。如果您使用终端，在启动Julia时，对于本书中展示的所有代码，您应该使用此选项。在Visual
    Studio Code中，如果您之前已经启动了一个Julia会话并且打开了一个包含Project.toml和Manifest.toml文件的代码仓库目录，则此选项默认使用。
- en: -pN, *where N is a number*—Sets the number of additional worker processes that
    Julia should launch on this computer. (This option is used with distributed computing.
    We do not discuss this topic in this book; see the “Multiprocessing and Distributed
    Computing” section of the Julia Manual at [http://mng.bz/19Jn](http://mng.bz/19Jn)
    for details.)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -pN，*其中N是数字*—设置Julia应在此计算机上启动的额外worker进程数。（此选项用于分布式计算。本书中不讨论此主题；有关详细信息，请参阅Julia手册中的“多进程和分布式计算”部分[http://mng.bz/19Jn](http://mng.bz/19Jn)）。
- en: --machine-file <file>—Starts additional worker processes on hosts listed in
    <file> . (This option is used with distributed computing. We do not discuss this
    topic in this book; see the “Multiprocessing and Distributed Computing” section
    of the Julia Manual at [http://mng.bz/19Jn](http://mng.bz/19Jn) for details.)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --machine-file <文件>—在<文件>中列出的主机上启动额外的worker进程。（此选项用于分布式计算。本书中不讨论此主题；有关详细信息，请参阅Julia手册中的“多进程和分布式计算”部分[http://mng.bz/19Jn](http://mng.bz/19Jn)）。
- en: --depwarn={yes│no│error}—Decides whether Julia should print deprecation warnings
    (usually emitted when you use functionalities of some packages that are deprecated
    and might be removed or changed in the future). By default, deprecation warnings
    are not printed; if this option is set to error, all deprecations are turned into
    errors.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --depwarn={yes│no│error}—决定Julia是否应打印弃用警告（通常在您使用某些已弃用且可能在未来被删除或更改的功能时发出）。默认情况下，不打印弃用警告；如果此选项设置为error，则所有弃用都转换为错误。
- en: -ON, *where N is a number from 0 to 3*—Sets the optimization level for the compiler.
    The default is 2 (the higher the optimization level, the more optimizations the
    compiler performs).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -ON，*其中N是0到3之间的数字*—设置编译器的优化级别。默认值为2（优化级别越高，编译器执行的优化越多）。
- en: 14.2.2 Computing the option payoff for a single sample of stock prices
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 计算单个股票价格样本的期权收益
- en: In this section, we will implement the function that computes the payoff of
    the Asian option we consider in this chapter for a single sample of stock prices.
    We also will check whether we can use multiple threads to speed up the execution
    of the code computing this payoff.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个函数，用于计算本章中考虑的亚洲期权的收益，针对单个股票价格样本。我们还将检查是否可以使用多个线程来加快计算该收益的代码的执行速度。
- en: Our code directly follows the specification presented in section 14.1\. In the
    X variable, we keep the current price of the stock, and in the sumX variable,
    we keep the sum of all observed prices. We update the X and sumX variables *m*
    times. The X variable is iteratively multiplied by the sample of the exp((*r -
    s*²/2)*T*/*m + s*²(*T*/*m*)*Z*(*i*)) expression. Recall that *Z*(*i*) is normally
    distributed with a mean of 0 and a standard deviation of 1\. We can sample this
    value in Julia by using the randn function. Listing 14.1 presents a complete implementation
    of the payoff_asian_sample function that calculates the payoff of the option for
    one sample of stock price trajectory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码直接遵循第14.1节中提出的规范。在X变量中，我们保持股票的当前价格，而在sumX变量中，我们保持所有观察到的股票价格的总和。我们更新X和sumX变量m次。X变量被迭代地乘以exp((*r
    - s*²/2)*T*/*m + s*²(*T*/*m*)*Z*(*i*))表达式的样本。回想一下，*Z*(*i*)是均值为0，标准差为1的正态分布。我们可以在Julia中使用randn函数来采样这个值。列表14.1展示了计算一个股票价格轨迹样本的期权收益的payoff_asian_sample函数的完整实现。
- en: Note in listing 14.1 that I have added the ::Float64 type annotation after the
    payoff_asian_sample(T, X0, K, r, s, m) signature. In this way, I ensure that the
    return value of this function is converted to a Float64 value. In other words,
    this function always returns a number that has the Float64 type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在列表14.1中，我在payoff_asian_sample(T, X0, K, r, s, m)签名后添加了::Float64类型注释。这样，我确保这个函数的返回值被转换为Float64值。换句话说，这个函数总是返回一个具有Float64类型的数字。
- en: This annotation is optional but occasionally useful. First, it explicitly signals
    the intention of the function’s developer, so it is useful as documentation. Second,
    if we were to mistakenly try to return a value from this function that cannot
    be converted to Float64, we would get an error, which would allow us to catch
    potential bugs faster. Finally, since we know that this function returns Float64,
    writing the code that uses this function can be made a bit simpler in some cases.
    For example, when we want to preallocate a collection that will store the values
    produced, then we can safely declare its element type as Float64.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释是可选的，但有时很有用。首先，它明确地传达了函数开发者的意图，因此作为文档很有用。其次，如果我们错误地尝试从这个函数返回一个无法转换为Float64的值，我们会得到一个错误，这将使我们能够更快地捕获潜在的bug。最后，既然我们知道这个函数返回Float64，那么在某些情况下，使用这个函数编写的代码可以稍微简单一些。例如，当我们想要预分配一个将存储产生的值的集合时，我们可以安全地将它的元素类型声明为Float64。
- en: Listing 14.1 Computing the payoff of the Asian option for one sample of price
    trajectory
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.1 计算亚洲期权的价格轨迹样本的收益
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The X variable keeps track of the current stock price.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ X变量跟踪当前股票价格。
- en: ❷ The sumX variable accumulates the sum of all observed stock prices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ sumX变量累积所有观察到的股票价格的总和。
- en: ❸ The d variable has a value equal to the time delta between measurements of
    the stock price.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ d变量具有等于股票价格测量时间差的值。
- en: ❹ Changes the stock price by using the log return calculated following the GBM
    formula
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过使用根据GBM公式计算的日志回报来改变股票价格
- en: ❺ The Y variable stores the average stock price over the considered period.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ Y变量存储了考虑期间的平均股票价格。
- en: 'Execution of the payoff_asian_sample function involves random number generation,
    so running it several times will produce different results. For example, let’s
    check it for the parameters T=1.0, X0=50.0, K=55.0, r=0.05, s=0.3, and m=200:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 执行payoff_asian_sample函数涉及随机数生成，因此多次运行它会产生不同的结果。例如，让我们检查T=1.0，X0=50.0，K=55.0，r=0.05，s=0.3和m=200的参数：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you run this example, expect to get different results, since we have not
    set the seed of the random number generator.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，预期会得到不同的结果，因为我们没有设置随机数生成器的种子。
- en: 'As discussed in section 14.1, we want to run payoff_asian_sample many times
    to approximate the value of the Asian option. For the purposes of this example,
    we benchmark the amount of time it takes to run this function 10,000 times and
    collect the results in a freshly allocated vector:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如第14.1节所述，我们想要多次运行payoff_asian_sample来近似亚洲期权的价值。为了这个示例的目的，我们基准测试了运行这个函数10,000次所需的时间，并将结果收集在一个新分配的向量中：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Can we run this simulation faster? We can, and one of the ways to do so is
    to use multithreading. We will use the map function from the ThreadsX.jl package.
    This is a multithreaded version of the map function that will spawn multiple *tasks*
    (informally, portions of code that can be independently executed) that will be
    run in parallel to use all threads available in the Julia session:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否使这个模拟更快？我们可以，其中一种方法就是使用多线程。我们将使用ThreadsX.jl包中的map函数。这是一个map函数的多线程版本，它将生成多个*任务*（非正式地说，是可独立执行的代码部分），这些任务将并行运行以使用Julia会话中可用的所有线程：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our code runs almost four times faster, so the use of multithreading is justified
    in this case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码运行速度几乎快了四倍，因此在这种情况下使用多线程是合理的。
- en: Experienced programmers will notice that we need to consider one issue when
    we start to use a parallelized version of the map function. The payoff_asian_sample
    function uses the random number generator when it calls the randn function. Therefore,
    the question is whether it is safe to run this function in parallel since potentially
    it could lead to a race condition ([http://mng.bz/PoRv](http://mng.bz/PoRv)),
    because when we generate pseudo random numbers, we update the internal state of
    their generator. The answer is that the code is correct since each task in Julia
    uses a separate instance of the random number generator, so tasks do not interfere
    with each other.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的程序员会注意到，当我们开始使用map函数的并行化版本时，需要考虑一个问题。payoff_asian_sample函数在调用randn函数时使用随机数生成器。因此，问题是是否安全地在并行中运行此函数，因为它可能导致竞争条件([http://mng.bz/PoRv](http://mng.bz/PoRv))，因为当我们生成伪随机数时，我们会更新它们的生成器的内部状态。答案是代码是正确的，因为Julia中的每个任务都使用随机数生成器的单独实例，所以任务之间不会相互干扰。
- en: The ThreadsX.jl package
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ThreadsX.jl包
- en: 'The ThreadsX.jl package provides parallelized versions of functions available
    in Base Julia. Here’s a list of selected functions that are implemented: any,
    all, map, prod, reduce, collect, sort, minimum, maximum, sum, and unique. You
    can find more details in the package documentation ([https://github.com/tkf/ThreadsX.jl](https://github.com/tkf/ThreadsX.jl)).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ThreadsX.jl包提供了Base Julia中可用函数的并行化版本。以下是一个实现所选函数的列表：any、all、map、prod、reduce、collect、sort、minimum、maximum、sum和unique。更多详细信息请参阅包文档([https://github.com/tkf/ThreadsX.jl](https://github.com/tkf/ThreadsX.jl))。
- en: Remember that when using the functions that can take functions as arguments,
    we must make sure that using them will not lead to race condition bugs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用可以接受函数作为参数的函数时，我们必须确保使用它们不会导致竞争条件错误。
- en: As a more advanced topic, it is worth adding that the functions defined in the
    ThreadsX.jl package were designed to support reproducibility of the produced results
    even across sessions using different numbers of threads. To ensure such reproducibility,
    use the basesize keyword argument that specifies the number of input elements
    to be processed in each task.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更高级的主题，值得补充的是，在ThreadsX.jl包中定义的函数旨在支持即使在使用不同数量的线程的会话中，产生的结果的可重复性。为了确保这种可重复性，请使用basesize关键字参数来指定每个任务中要处理的输入元素数量。
- en: 14.2.3 Computing the option value
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 计算期权价值
- en: In this section, we will implement the function that approximates the Asian
    option value. Additionally, it will return an assessment of the uncertainty of
    the result by computing the 95% confidence interval of the value and will compute
    the probability that the option gives zero payoff.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个近似亚洲期权价值的函数。此外，它将通过计算价值的95%置信区间来返回结果的不确定性评估，并计算期权给出零收益的概率。
- en: Implementing the function performing the Asian option valuation
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实现执行亚洲期权估值的函数
- en: Recall from section 14.1 that to approximate the value of the Asian option,
    we are going to use a Monte Carlo simulation. Therefore, we will need to run the
    payoff_ asian_sample function defined in listing 14.1 multiple times. But how
    many times should we do this? In this section, we will use the following approach.
    Instead of specifying the number of repetitions *n* given in the formulas in section
    14.1, we will allow the user to specify the time the simulation is allowed to
    run, and we will compute as many repetitions as possible within this time budget.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第14.1节，为了近似亚洲期权的价值，我们将使用蒙特卡洛模拟。因此，我们需要多次运行第14.1节中定义的payoff_asian_sample函数。但我们应该运行多少次呢？在本节中，我们将使用以下方法。我们不会指定第14.1节公式中给出的重复次数*n*，而是允许用户指定模拟允许运行的时间，我们将在此时间预算内计算尽可能多的重复次数。
- en: The reason we prefer to set a limit on computation time is that later we will
    use this function in a web service, and we want to be able to control the web
    service’s response time to make sure its potential users do not have to wait very
    long for the results. Recall from chapter 1 that in the Timeline case study, long
    waiting times for a web application response were one of the reasons the company
    decided to switch to Julia.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以倾向于设置计算时间限制，是因为我们稍后将在一个网络服务中使用这个函数，我们希望能够控制网络服务的响应时间，以确保潜在的用户不需要等待很长时间才能得到结果。回想一下，在第
    1 章的 Timeline 案例研究中，网络应用响应的长时间等待是公司决定转向 Julia 的原因之一。
- en: To allow for controlling the maximum computation time, we will run the payoff_
    asian_sample function in batches of 10,000 by using the ThreadsX.map function,
    just as we did in section 14.2.2, until we reach the computation time passed by
    the user. We will repeatedly append the results of the ThreadsX.map function to
    a single collection of results. After finishing the computations using formulas
    given in section 14.1, we will compute the approximation of the option value,
    the 95% confidence interval of the price, and the probability that the option
    gives zero payoff. These steps are implemented in the asian_value function in
    the following listing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制最大计算时间，我们将使用 `ThreadsX.map` 函数以每批 10,000 个元素的方式运行 `payoff_asian_sample`
    函数，就像我们在第 14.2.2 节中所做的那样，直到达到用户指定的计算时间。我们将反复将 `ThreadsX.map` 函数的结果追加到单个结果集合中。在完成第
    14.1 节中给出的公式计算后，我们将计算期权的近似价值、价格的 95% 置信区间以及期权产生零收益的概率。这些步骤在以下列表中的 `asian_value`
    函数中实现。
- en: Listing 14.2 Function that approximates the value of the Asian option
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.2 近似亚洲期权价值的函数
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ The result variable stores the simulated payoffs that are computed in 10,000-element
    batches.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 结果变量存储了以 10,000 个元素批次计算的模拟收益。
- en: ❷ Records the time when we start the simulation
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记录开始模拟的时间
- en: ❸ Until the max_time computation time is not exceeded, adds a 10,000-element
    batch of simulated payoffs
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在不超过 `max_time` 计算时间的情况下，添加一个包含 10,000 个元素的模拟收益批次
- en: ❹ The ==(0) syntax is a shorthand for the x -> x == 0 anonymous function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `(0)` 语法是 `x -> x == 0` 匿名函数的简写。
- en: ❺ The (; n, mv, lo95, hi95, zero) syntax is shorthand for (n=n, mv=mv, lo95=lo95,
    hi95=hi95, zero=zero).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ `(; n, mv, lo95, hi95, zero)` 语法是 `(n=n, mv=mv, lo95=lo95, hi95=hi95, zero=zero)`
    的简写。
- en: The max_time argument passed to the asian_value function should be given in
    seconds. In the function, we use the time function to get the current time measured
    in seconds. This measurement has microsecond resolution. In particular, the time()
    - start_time expression measures, in seconds, the time since the while loop present
    in the function body started.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `asian_value` 函数的 `max_time` 参数应以秒为单位给出。在函数中，我们使用 `time` 函数获取以秒为单位的当前时间。这个测量具有微秒分辨率。特别是，`time()
    - start_time` 表达式测量自函数体中存在的 `while` 循环开始以来的时间，以秒为单位。
- en: In the while loop, we compute simulated payoffs of the Asian option in batches
    of 10,000 elements. We know from section 14.2 that computing each batch takes
    around 5 ms using four threads. We append the 10,000-element batches to the result
    vector by using the append! function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，我们以每批 10,000 个元素的方式计算亚洲期权的模拟收益。我们知道，根据第 14.2 节，使用四个线程计算每个批次大约需要
    5 毫秒。我们通过使用 `append!` 函数将 10,000 个元素的批次追加到结果向量中。
- en: 'After the loop finishes, we compute the following statistics by using formulas
    from section 14.1: the mean payoff, its 95% confidence interval, and the probability
    that the payoff is 0.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，我们使用第 14.1 节中的公式计算以下统计数据：平均收益、其 95% 置信区间以及收益为 0 的概率。
- en: 'In the mean(==(0), result) expression, we use the same pattern that you learned
    in chapter 4 for the sum function. The mean function accepts a function as its
    first argument and a collection as its second argument. Then it efficiently computes
    the mean of values stored in the collection after transforming them by the passed
    function. Here is a simple example of this pattern at work:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mean(==(0), result)` 表达式中，我们使用了在第 4 章中为求和函数学习的相同模式。均值函数接受一个函数作为其第一个参数，一个集合作为其第二个参数。然后它通过传递的函数转换这些集合中存储的值，有效地计算这些值的均值。以下是一个此模式应用的简单示例：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result of the operation is 11.0 since we compute the mean of squares of
    integers from 1 to 5—that is, (1^2 + 2^2 + 3^2 + 4^2 + 5^2) / 5.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的结果是 11.0，因为我们计算了从 1 到 5 的整数的平方的平均值——即 `(1^2 + 2^2 + 3^2 + 4^2 + 5^2) / 5`。
- en: Using partial function application syntax
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用部分函数应用语法
- en: Another expression to note is ==(0). You know that, normally, the == operator
    requires two arguments and checks their equality. The ==(0) is a *partial function
    application* operation ([http://mng.bz/JVda](http://mng.bz/JVda)). It fixes the
    right side of the == operation to be equal to 0.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的表达式是`==(0)`。你知道，通常，`==`运算符需要两个参数并检查它们的相等性。`==(0)`是一个*部分函数应用*操作([http://mng.bz/JVda](http://mng.bz/JVda))。它将`==`操作右侧固定为等于0。
- en: 'The result of ==(0) is a function that expects one argument and compares it
    to 0 by using the == operator. Therefore, you can think of ==(0) as equivalent
    to defining an anonymous function x -> x == 0 that fixes the right side of the
    operation to be 0. Here’s an example of using the function returned by ==(0):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`==(0)`的结果是一个期望一个参数并通过使用`==`运算符将其与0进行比较的函数。因此，你可以将`==(0)`视为等同于定义一个匿名函数`x ->
    x == 0`，该函数将操作右侧固定为0。以下是一个使用由`==(0)`返回的函数的示例：'
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Operations that support partial function application
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 支持部分函数应用的运算
- en: Partial function application is quite convenient because it makes the code more
    readable as compared to using anonymous functions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数应用相当方便，因为它与使用匿名函数相比，使代码更易于阅读。
- en: Additionally, repeatedly defining anonymous functions creates a new function
    each time, which requires their compilation each time (this is a more advanced
    topic). On the other hand, partial function application creates a definition only
    once, so it also is preferred from a compilation latency perspective.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重复定义匿名函数每次都会创建一个新的函数，这需要每次编译（这是一个更高级的话题）。另一方面，部分函数应用只创建一次定义，因此从编译延迟的角度来看也是首选的。
- en: Therefore, in addition to ==, common operations like >, >=, <, <=, and isequal
    also support the partial function application pattern.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了`==`之外，常见的运算符如`>`, `>=`, `<`, `<=`, 和 `isequal` 也支持部分函数应用模式。
- en: Exercise 14.1 Using the @time macro, compare the time to compute the mean of
    values in the range -10^6:10^6 transformed by the <(0) and x -> x < 0 functions.
    Also check the timing when you predefine the lt0(x) = x < 0 function. Run each
    operation three times.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 练习14.1 使用`@time`宏，比较使用`<(0)`和`x -> x < 0`函数将值范围-10^6:10^6转换后的平均值计算时间。同时检查预定义`lt0(x)
    = x < 0`函数时的计时。运行每个操作三次。
- en: Using a convenient syntax for creating a NamedTuple
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用创建命名元组的便捷语法
- en: 'The last new element that you learned in listing 14.2 is a notation that simplifies
    the creation of named tuples from variables. If you put in parentheses a semicolon
    (;) followed by a comma-separated list of variables, Julia creates a NamedTuple
    whose field names are the names of variables you used and whose values are the
    values of these variables. Here is an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你在列表14.2中学习到的最后一个新元素是一种简化从变量创建命名元组的符号。如果你在括号中放入一个分号 (;) 后跟一个以逗号分隔的变量列表，Julia会创建一个命名元组，其字段名称是你使用的变量的名称，其值是这些变量的值。以下是一个示例：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is equivalent to writing (val1=val1, val2=val2), but is shorter and
    more convenient to type and read. This pattern is commonly used when you want
    to return a NamedTuple from a function and want to store some variables that you
    have computed inside this function. This is what we did in the asian_value function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结果等同于编写`(val1=val1, val2=val2)`，但更短，更方便输入和阅读。当你想从一个函数中返回一个命名元组并想存储一些在这个函数内部计算过的变量时，通常使用这种模式。这就是我们在`asian_value`函数中所做的。
- en: Testing the Asian option valuation function
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试亚洲期权估值函数
- en: 'Before we move forward, let’s test our asian_value function, giving it 0.25
    seconds of computation time and keeping the values for all other parameters the
    same as those in our tests in section 14.2.2:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们测试一下我们的`asian_value`函数，给它0.25秒的计算时间，并保持所有其他参数与第14.2.2节测试中的值相同：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each time, the function execution time is just a bit over 0.25 seconds. The
    first time, it is able to run 300,000 steps of the simulation, while the second
    and third times, respectively, it runs 410,000 and 370,000\. This difference occurs
    because during the first run, Julia additionally needs to perform compilation
    of the code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每次函数执行时间略超过0.25秒。第一次运行时，它能够运行300,000步的模拟，而第二次和第三次运行时，分别运行410,000步和370,000步。这种差异发生是因为在第一次运行期间，Julia还需要执行代码的编译。
- en: From a computational perspective, note that the obtained results are similar
    for all three runs of the simulation. With the 0.25-second time budget, the width
    of the 95% confidence interval is around 0.03\. For the purposes of this chapter,
    let’s assume that this is acceptable from the end user’s perspective.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算的角度来看，请注意，所有三次模拟运行获得的结果相似。在0.25秒的时间预算下，95%置信区间的宽度大约为0.03。为了本章的目的，让我们假设这从最终用户的角度来看是可以接受的。
- en: Multithreading in Julia
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的多线程
- en: In this section, you have learned about the ThreadsX.jl package, which provides
    a high-level API enabling you to conveniently perform typical operations by using
    multiple threads.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了ThreadsX.jl包，它提供了一个高级API，允许你通过使用多个线程方便地执行典型操作。
- en: Base Julia also has the Threads module, which provides a low-level API enabling
    you to write multithreaded code. The key element of this API is the Threads.@spawn
    macro ([http://mng.bz/wyja](http://mng.bz/wyja)), which creates a task and schedules
    it to run on an available thread. The Threads module also allows you to use locks
    ([http://mng.bz/qoj6](http://mng.bz/qoj6)), which can help you avoid race condition
    problems and have support for atomic operations ([http://mng.bz/5mo8](http://mng.bz/5mo8))
    that are thread safe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的基础库也包含一个Threads模块，该模块提供了一个低级API，允许你编写多线程代码。这个API的关键元素是Threads.@spawn宏([http://mng.bz/wyja](http://mng.bz/wyja))，它创建一个任务并将其调度到可用的线程上。Threads模块还允许你使用锁([http://mng.bz/qoj6](http://mng.bz/qoj6))，这可以帮助你避免竞态条件问题，并支持原子操作([http://mng.bz/5mo8](http://mng.bz/5mo8))，这些操作是线程安全的。
- en: Many Julia packages take advantage of multithreading. For example, selected
    expensive operations in DataFrames.jl can take advantage of multiple threads.
    You can check the package documentation for the list ([http://mng.bz/69np](http://mng.bz/69np)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Julia包都利用了多线程。例如，DataFrames.jl中的一些选定的昂贵操作可以利用多个线程。你可以查看包文档以获取列表([http://mng.bz/69np](http://mng.bz/69np))。
- en: You can find more details about the functionality of the Threads module in the
    “Multithreading” section of the Julia Manual ([http://mng.bz/o5ry](http://mng.bz/o5ry)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Julia手册的“多线程”部分找到关于Threads模块功能更详细的信息([http://mng.bz/o5ry](http://mng.bz/o5ry))。
- en: 14.3 Creating a web service serving the Asian option valuation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 创建一个提供亚洲期权估值的Web服务
- en: In this section, we will build a web service that will allow us to serve the
    Asian option valuation over the Hypertext Transfer Protocol (HTTP). For those
    who would like a refresher, see “An Overview of HTTP” on the MDN Web Docs site
    ([http://mng.bz/ne1V](http://mng.bz/ne1V)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个Web服务，它将允许我们通过超文本传输协议（HTTP）提供亚洲期权估值。对于那些想要复习的人，请参阅MDN Web文档网站上的“HTTP概述”([http://mng.bz/ne1V](http://mng.bz/ne1V))。
- en: Web services are currently one of the most popular methods of allowing applications
    to exchange messages. Their use became especially widespread when cloud computing
    became popular, since they allow for communication between software programs over
    the network, independent of the programming language used to create them or the
    platform on which they are run.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务目前是允许应用程序交换消息的最流行方法之一。当云计算变得流行时，它们的使用变得特别广泛，因为它们允许通过网络在软件程序之间进行通信，而不管创建它们的编程语言或运行它们的平台是什么。
- en: 14.3.1 A general approach to building a web service
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 构建Web服务的一般方法
- en: We want the web service to work as follows. Assume you have a client application
    and a web service running on a server. We want the client application to be allowed
    to send a request to the server, asking for the price of the Asian option. In
    response, the server returns information about the calculated price. The communication
    happens over the internet, using the HTTP protocol. Figure 14.2 shows a high-level
    view of this process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望Web服务能够这样工作。假设你有一个客户端应用程序和一个运行在服务器上的Web服务。我们希望客户端应用程序能够向服务器发送请求，请求亚洲期权的价格。作为回应，服务器返回计算出的价格信息。通信通过互联网，使用HTTP协议完成。图14.2展示了这个过程的高级视图。
- en: '![CH14_F02_Kaminski2](../Images/CH14_F02_Kaminski2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F02_Kaminski2](../Images/CH14_F02_Kaminski2.png)'
- en: Figure 14.2 Communication between a client application and a web service running
    on a server is done via HTTP.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 客户端应用程序与服务器上运行的Web服务之间的通信是通过HTTP完成的。
- en: 'How can the client send a request to the server? In this section, I show you
    how to use the POST method of HTTP to perform this action in Julia. To send such
    a request, we need to pass the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端如何向服务器发送请求？在本节中，我将向您展示如何在 Julia 中使用 HTTP 的 POST 方法执行此操作。要发送此类请求，我们需要传递以下内容：
- en: The address we want to send the request to. In this chapter, we will use http://127.0.0.1:8000,
    which is the default in Genie.jl and refers to the current device (called the
    *local host*) and port 8000.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要发送请求的地址。在本章中，我们将使用 http://127.0.0.1:8000，这是 Genie.jl 的默认设置，指的是当前设备（称为 *本地主机*）和端口号
    8000。
- en: The request header (request metadata).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求头（请求元数据）。
- en: The request body (request data).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求体（请求数据）。
- en: We want our web service to accept requests with data in JSON format. (We discussed
    JSON format in chapter 7.) The format of the request should allow the client to
    pass the parameters of the Asian option we are interested in. For simplicity,
    out of all parameters we discussed in section 14.1, we will allow the user to
    pass the value of the strike price *K*. An additional technical parameter that
    we will send is the time we allow the server to process the request before returning
    a response. To send such a query to the web service, we need to set in the request
    header the Content-Type metadata to application/json. The request body should
    be data in JSON format, specifying the value of *K* and the expected response
    time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的网络服务能够接受以 JSON 格式发送数据的请求。（我们在第 7 章中讨论了 JSON 格式。）请求的格式应允许客户端传递我们感兴趣的亚洲期权的参数。为了简化，在
    14.1 节中讨论的所有参数中，我们将允许用户传递执行价格 *K* 的值。我们还将发送一个额外的技术参数，即服务器在返回响应之前允许处理请求的时间。要向网络服务发送此类查询，我们需要在请求头中设置
    Content-Type 元数据为 application/json。请求体应该是 JSON 格式的数据，指定 *K* 的值和期望的响应时间。
- en: In response, the web service should return the values produced by the asian_value
    function defined in section 14.2—that is, the number of Monte Carlo samples used,
    the approximation of the Asian option price, the 95% confidence interval of this
    price, and the probability that the value of the option will be zero. All these
    values should also be sent using JSON format. We have already worked with this
    response type in chapter 7.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为响应，网络服务应返回第 14.2 节中定义的 asian_value 函数产生的值——即使用的蒙特卡洛样本数量、亚洲期权价格的近似值、该价格的 95%
    置信区间以及期权价值为零的概率。所有这些值也应使用 JSON 格式发送。我们已经在第 7 章中处理过这种响应类型。
- en: To create a web service, we will use the Genie.jl package. This full-stack web
    framework has all the components needed for developing web applications. In this
    section, I will use a limited and simplified set of functionalities of Genie.jl.
    If you would like to learn more about this package, check its documentation ([http://mng.bz/qomJ](http://mng.bz/qomJ)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建网络服务，我们将使用 Genie.jl 包。这个全栈式网络框架拥有开发网络应用程序所需的所有组件。在本节中，我将使用 Genie.jl 的有限和简化功能集。如果您想了解更多关于这个包的信息，请查看其文档([http://mng.bz/qomJ](http://mng.bz/qomJ))。
- en: Web development in Julia
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的网络开发
- en: 'In this chapter, we want to only build a web service. However, in general,
    Julia provides the full set of tools needed to build production web applications.
    The three key components of the Genie Framework are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只想构建网络服务。然而，通常 Julia 提供了构建生产级网络应用程序所需的全套工具。Genie 框架的三个关键组件如下：
- en: '*Genie.jl*—A web framework with features such as a flexible request router,
    web socket support, templating, and authentication'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Genie.jl*—一个具有灵活请求路由器、WebSocket 支持、模板和身份验证等功能的网络框架'
- en: '*SearchLight.jl*—Provides an object-relational mapping (ORM; [www.altexsoft.com/blog/object-relational-mapping/](https://www.altexsoft.com/blog/object-relational-mapping/))
    layer, allowing you to connect to PostgreSQL, MySQL, and SQLite databases'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SearchLight.jl*—提供对象关系映射（ORM；[www.altexsoft.com/blog/object-relational-mapping/](https://www.altexsoft.com/blog/object-relational-mapping/))
    层，允许您连接到 PostgreSQL、MySQL 和 SQLite 数据库'
- en: '*Stipple.jl*—A reactive UI library for building interactive data applications'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Stipple.jl*—一个用于构建交互式数据应用的响应式 UI 库'
- en: If you would like to learn more about the Genie Framework, visit [https://genieframework.com](https://genieframework.com/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 Genie 框架的信息，请访问 [https://genieframework.com](https://genieframework.com/)。
- en: 14.3.2 Creating a web service using Genie.jl
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 使用 Genie.jl 创建网络服务
- en: 'To set up a simple web service, follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个简单的网络服务，请按照以下步骤操作：
- en: Load the Genie.jl package.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 Genie.jl 包。
- en: Set Genie.config.run_as_server to true so that later the Genie.jl server will
    be started synchronously; the Julia process will handle the server operations
    only after the server is started. The visible effect will be that the Genie .Server.up
    function used to start the server will not return.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Genie.config.run_as_server设置为true，以便稍后Genie.jl服务器将同步启动；Julia进程将仅在服务器启动后处理服务器操作。可见的效果是，用于启动服务器的Genie.Server.up函数将不会返回。
- en: Define a mapping between a URL and the Julia function that should be invoked
    to send the response back to the client when it receives the request. This is
    achieved by using the Genie.Router.route function.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个URL与应调用的Julia函数之间的映射，以便在接收到请求时将响应发送回客户端。这是通过使用Genie.Router.route函数实现的。
- en: Start the server by calling Genie.Server.up().
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用Genie.Server.up()启动服务器。
- en: A crucial element of this procedure is understanding how to define the function
    that will handle the POST requests. In this section, we want our web service to
    accept JSON POST payloads; we want to allow clients of our web service to send
    JSON-formatted data in the request body. We also want the produced response to
    be in JSON format.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的一个关键要素是理解如何定义处理POST请求的函数。在本节中，我们希望我们的网络服务接受JSON POST有效负载；我们希望允许我们的网络服务的客户端在请求体中发送JSON格式的数据。我们还希望生成的响应以JSON格式呈现。
- en: To process an application/json POST request, use the Genie.Requests .jsonpayload
    function. Then you can index the returned object to get its fields. If parsing
    JSON fails, Genie.Requests.jsonpayload returns nothing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理application/json POST请求，请使用Genie.Requests.jsonpayload函数。然后您可以索引返回的对象以获取其字段。如果解析JSON失败，Genie.Requests.jsonpayload返回nothing。
- en: 'To produce a response that has the application/json content type, use the Genie.Renderer.Json.json
    function. We will pass NamedTuple value to it, as it conveniently gets converted
    to JSON in the body of the message, and an appropriate message header is added.
    Here is an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成具有application/json内容类型的响应，请使用Genie.Renderer.Json.json函数。我们将传递NamedTuple值给它，因为它方便地将JSON转换为消息体，并添加适当的消息头。以下是一个示例：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now know everything we need to create a web service. I have put its code
    in a separate ch14_server.jl file in the GitHub repository. The web service code
    is given in listing 14.3\. The only new part is the handling of the web service.
    The payoff_asian_ sample and asian_value functions are the same as we defined
    them in section 14.2.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经知道了一切，可以创建一个网络服务。我已经将其代码放在GitHub仓库中单独的ch14_server.jl文件中。网络服务的代码在列表14.3中给出。唯一的新部分是网络服务的处理。payoff_asian_sample和asian_value函数与我们第14.2节中定义的相同。
- en: In the code, we set a route for root ("/") accepting the POST payload. We use
    default settings of Genie.jl so we will be able to send POST requests to the address
    http://127.0.0.1:8000\. For this route, we first store in the message variable
    the received JSON payload. We then have a try-catch-end block that tries to get
    data from the message and pass it to the asian_value function. Note that for simplicity,
    I have assumed that our web service accepts only the K and max_time parameters
    of the asian_value function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们为根("/")设置了一个接受POST有效负载的路由。我们使用Genie.jl的默认设置，因此我们可以向地址http://127.0.0.1:8000发送POST请求。对于此路由，我们首先将接收到的JSON有效负载存储在message变量中。然后我们有一个try-catch-end块，它尝试从message中获取数据并将其传递给asian_value函数。请注意，为了简单起见，我假设我们的网络服务只接受asian_value函数的K和max_time参数。
- en: We use the float function to make sure that both K and max_time, when passed
    to asian_value, are floating-point numbers. If the process of getting the JSON
    request and running the simulation is successful, we return a message with OK
    status and the value returned by the asian_value function. If anything breaks
    (for example, parameter K is not passed or is not numeric), an exception will
    be raised, and in the catch part of the block, we will return an ERROR status
    and an empty string as a value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用float函数确保K和max_time在传递给asian_value时都是浮点数。如果获取JSON请求和运行模拟的过程成功，我们将返回一个具有OK状态的消息和asian_value函数返回的值。如果发生任何错误（例如，参数K未传递或不是数字），将引发异常，并在块的catch部分返回ERROR状态和空字符串作为值。
- en: Listing 14.3 Creating the Asian option pricing web service
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.3 创建亚洲期权定价网络服务
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Configures Genie.jl to start the web service synchronously
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置Genie.jl以同步启动网络服务
- en: ❷ Uses the do-end block to define an anonymous function that will be invoked
    if the user passes the POST request to the root of the address where the web service
    will be made available
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用do-end块定义一个匿名函数，该函数将在用户将POST请求传递到Web服务提供的地址根时被调用
- en: ❸ Parses the JSON payload sent in the POST request
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 解析在POST请求中发送的JSON有效负载
- en: ❹ Tries getting the parameters and computing the valuation of the Asian option;
    returns OK as a status and the value on success; otherwise, returns ERROR as a
    status
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 尝试获取参数并计算亚洲期权的估值；在成功时返回OK状态和值，否则返回ERROR状态
- en: ❺ Starts the web service
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 启动Web服务
- en: 14.3.3 Running the web service
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 运行Web服务
- en: 'We are now ready to start our web service. Open a new terminal window, switch
    to the folder where you have cloned the GitHub repository, and run the julia --project
    -t4 ch14_server.jl command. You should see the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好启动我们的Web服务。打开一个新的终端窗口，切换到您已克隆GitHub存储库的文件夹，并运行julia --project -t4 ch14_server.jl命令。您应该看到以下输出：
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have a running server, so we can connect to it. Note that we have started
    it with four threads using the -t4 switch. Do not close this terminal window.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个正在运行的服务器，因此我们可以连接到它。请注意，我们使用-t4开关启动了四个线程。不要关闭此终端窗口。
- en: Before we move forward, let me add one comment. In listing 14.3, when we get
    an incorrect request, we still send a response with the 200 OK status to the client
    by using the Genie.Renderer.Json.json((status="ERROR", value="")) expression.
    An alternative way to handle this situation would be to return the 400 Bad Request
    response. If you would prefer to respond with this status code, you should put
    the Genie.Responses.setstatus(400) expression in the catch part of listing 14.3
    instead. If you would like to learn more about HTTP status codes, you can check
    the “HTTP Status Code Registry” page ([http://mng.bz/4965](http://mng.bz/4965)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我添加一条注释。在14.3列表中，当我们收到一个错误的请求时，我们仍然通过使用Genie.Renderer.Json.json((status="ERROR",
    value=""))表达式向客户端发送带有200 OK状态的响应。处理这种情况的另一种方法是将400 Bad Request响应返回。如果您希望以这个状态码响应，您应该在14.3列表的catch部分放置Genie.Responses.setstatus(400)表达式。如果您想了解更多关于HTTP状态码的信息，您可以查看“HTTP状态码注册表”页面([http://mng.bz/4965](http://mng.bz/4965))。
- en: 14.4 Using the Asian option pricing web service
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 使用亚洲期权定价Web服务
- en: In this section, you will learn how to send requests to a web service and parse
    the received response. Learning how to do this is useful, as your programs will
    often need to use third-party web services. For this, we will use the HTTP.jl
    and JSON3.jl packages that you learned about in chapter 7.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何向Web服务发送请求并解析收到的响应。学习如何做这件事是有用的，因为您的程序通常会需要使用第三方Web服务。为此，我们将使用您在第7章中了解到的HTTP.jl和JSON3.jl包。
- en: 'As an example, we will check to see how the value of our Asian option changes
    as we change the strike price *K* in the range from 30 to 80, keeping all other
    parameters at values we fixed in section 14.3\. This section is organized as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将检查在保持所有其他参数在14.3节中固定的值的情况下，我们的亚洲期权价值如何随着执行价格*K*在30到80之间的变化而变化。本节组织如下：
- en: We start with discussing how to send a single POST request to our web service.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先讨论如何向我们的Web服务发送单个POST请求。
- en: We collect the results of multiple POST requests in a data frame.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在一个数据框中收集多个POST请求的结果。
- en: The collected results have a complex structure, in which one column stores multiple
    values. We unnest each column into multiple columns to facilitate working with
    the data.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集到的结果具有复杂的结构，其中一列存储多个值。我们将每个列展开成多个列，以便于处理数据。
- en: We visualize the results of our computations to verify that increasing the strike
    price *K* decreases the value of our Asian option and increases the probability
    that it gives zero payoff.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可视化计算结果，以验证提高执行价格*K*会降低我们的亚洲期权价值，并增加它给出零收益的概率。
- en: 14.4.1 Sending a single request to the web service
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.1 向Web服务发送单个请求
- en: Start a new Julia session (remember not to terminate the session where we are
    running our web service).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的Julia会话（记住不要终止我们运行Web服务的会话）。
- en: 'We start with sending a POST request to our web service. Recall that it is
    available at http://127.0.0.1:8000\. Let’s get the response for K=55.0 and max_time=0.25,
    as these are values we already used in section 14.2\. At a high level, figure
    14.2 visualizes the process of communication between our client and web service:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先发送一个POST请求到我们的网络服务。回想一下，它位于http://127.0.0.1:8000。让我们获取K=55.0和max_time=0.25的响应，因为这些值我们在第14.2节中已经使用过。从高层次上讲，图14.2展示了我们的客户端和网络服务之间的通信过程：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We already used the JSON3.read function in chapter 7 and know that it parses
    JSON data into a JSON object from which we can get data. The JSON3.write function,
    which we also use in the code, performs a reverse operation. It takes a Julia
    object and converts it to a JSON-formatted string. Let’s see what JSON3.write((K=55.0,
    max_ time=0.25)) produces to make sure it is indeed properly formatted JSON data:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第7章中使用了JSON3.read函数，并且知道它可以解析JSON数据到JSON对象中，从而我们可以从中获取数据。JSON3.write函数，我们在代码中也使用，执行一个相反的操作。它接受一个Julia对象并将其转换为JSON格式的字符串。让我们看看JSON3.write((K=55.0,
    max_time=0.25))会产生什么，以确保它确实是正确格式的JSON数据：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have not used HTTP.post yet either, since in chapter 7 we used the HTTP.get
    function. The difference between them is as follows. You use the HTTP.post function
    when you want to send a POST request, and you use HTTP.get when you want to send
    a GET request. Our web service expects the POST request, as we need to pass JSON
    data to it, called a *JSON payload* (the GET request does not support sending
    data in a request payload). You can find an overview of various HTTP request methods
    at the W3Schools website ([www.w3schools.com/tags/ref_httpmethods.asp](https://www.w3schools.com/tags/ref_httpmethods.asp)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用HTTP.post，因为在第7章中我们使用了HTTP.get函数。它们之间的区别如下。当你想要发送POST请求时，你使用HTTP.post函数，当你想要发送GET请求时，你使用HTTP.get。我们的网络服务期望POST请求，因为我们需要向它传递JSON数据，称为*JSON有效负载*（GET请求不支持在请求有效负载中发送数据）。你可以在W3Schools网站上找到各种HTTP请求方法的概述([www.w3schools.com/tags/ref_httpmethods.asp](https://www.w3schools.com/tags/ref_httpmethods.asp))。
- en: 'In the HTTP.post method, we pass the following arguments:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP.post方法中，我们传递以下参数：
- en: The URL we want to query (http://127.0.0.1:8000 in our case).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要查询的URL（在我们的例子中是http://127.0.0.1:8000）。
- en: The header metadata. Since our content is application/json, we pass the "Content-Type"
    => "application/json" pair; it is wrapped in a vector, as potentially we might
    want to pass more metadata in the header.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头元数据。由于我们的内容是application/json，我们传递了"Content-Type" => "application/json"这对；它被封装在一个向量中，因为我们可能还想在标头中传递更多的元数据。
- en: The body of the request, which is in JSON format.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的主体，它是JSON格式的。
- en: 'Now switch for a moment to the terminal where you have our web service running.
    You will note that a message is printed there showing that the POST request was
    handled successfully:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在暂时切换到运行我们网络服务的终端。你会注意到那里打印了一条消息，显示POST请求已被成功处理：
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now check to see what happens if we send an incorrect request to our web service:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查一下，如果我们向网络服务发送一个不正确的请求会发生什么：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, since we sent an empty string instead of a number as the K parameter,
    we get an ERROR in the status and an empty string as the value. Therefore, error
    handling in our web service seems to work correctly.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于我们将K参数作为空字符串而不是数字发送，我们得到了状态中的ERROR和一个空字符串作为值。因此，我们的网络服务中的错误处理似乎工作正常。
- en: Exercise 14.2 Create a web service that accepts a JSON payload with a single
    element n that is an integer. It should return, in JSON format, a vector of n
    random numbers generated using the rand function. If the passed request is incorrect,
    a 400 Bad Request response should be produced. Run this web server on your local
    computer and test whether it works as expected.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 练习14.2 创建一个接受包含单个元素n的JSON有效负载的网络服务，该元素是一个整数。它应该返回一个使用rand函数生成的n个随机数的向量，格式为JSON。如果传递的请求不正确，应生成400
    Bad Request响应。在您的本地计算机上运行此Web服务器，并测试它是否按预期工作。
- en: 14.4.2 Collecting responses to multiple requests from a web service in a data
    frame
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.2 在数据框中收集来自网络服务的多个请求的响应
- en: Now we can collect the valuations of our Asian option for K varying from 30
    to 80\. In the code presented next, we first create a data frame in which each
    row stores the values of K that we want to check. Additionally, in this data frame,
    we store the max_time that we want to use (in the example, it is fixed to be equal
    to 0.25).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以收集K从30变到80时我们的亚洲期权的估值。在下面的代码中，我们首先创建一个数据框，其中每一行存储我们想要检查的K的值。此外，在这个数据框中，我们存储我们想要使用的max_time（在示例中，它被固定为等于0.25）。
- en: 'Next, for each row of our data frame, we run the HTTP.post function discussed
    in this section. To achieve this, we use the map function, passing the K and max_
    time columns of the data frame as collections that we want to iterate. We store
    the results fetched from the web service in the data column. Since the process
    of getting the results is time-consuming, we print the value of K that we process
    by using the @show K macro call. In this way, we can easily watch the progress
    of the computations. Additionally, we print the time the web service took to produce
    the response to confirm that it is indeed around 0.25 seconds:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于数据框的每一行，我们运行本节讨论的HTTP.post函数。为了实现这一点，我们使用map函数，将数据框的K和max_time列作为我们想要迭代的集合传递。我们将从网络服务获取的结果存储在data列中。由于获取结果的过程耗时较长，我们使用@show
    K宏调用打印我们正在处理的K的值。这样，我们可以轻松地观察计算进度。此外，我们打印网络服务生成响应的时间，以确认它确实大约为0.25秒：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Initially populates the data frame with the values of the strike price K for
    which we want to compute the value of the Asian option and the maximum allowed
    computation time for each run
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始时，数据框用我们想要计算亚洲期权价值的执行价格K的值以及每次运行允许的最大计算时间填充
- en: ❷ Sends a POST request to our web service for each pair of strike price K and
    computation time, using the map function, and stores the result in the data column
    of the data frame
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用map函数，为每个执行价格K和计算时间的组合向我们的网络服务发送POST请求，并将结果存储在数据框的data列中
- en: 'Now our df data frame has three columns: K, max_time, and data. The last column
    stores the JSON3 objects that are constructed from data returned by the web service:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的df数据框有三个列：K，max_time和data。最后一列存储由网络服务返回的数据构建的JSON3对象：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, check that in all cases we receive the OK status of the request, which
    will show that the web service processed them without a problem. To achieve this,
    we use the all function. We pass two positional arguments to this function. The
    first argument is a predicate function—in this case, an anonymous function checking
    whether the status is OK. The second is a collection of elements for which we
    want to check that the predicate is always true. Here is the code that performs
    the check:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查在所有情况下我们是否都收到请求的OK状态，这将表明网络服务没有问题地处理了它们。为了实现这一点，我们使用all函数。我们向这个函数传递两个位置参数。第一个参数是一个谓词函数——在这种情况下，是一个匿名函数，检查状态是否为OK。第二个是我们想要检查谓词始终为真的元素集合。以下是执行检查的代码：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For all queries, we receive a response with the OK status.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有查询，我们都会收到一个状态为OK的响应。
- en: 14.4.3 Unnesting a column of a data frame
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.3 解包数据框的列
- en: 'The information stored in the data column in the df data frame is slightly
    inconvenient to work with since it is nested. Each element of the df.data vector
    has an internal structure. Each entry of a vector stored in the data column has
    a value element. Recall from section 14.3 that each value element internally stores
    five sub-elements: n, mv, lo95, hi95, and zero. We want to create five new columns
    in our data frame using data extracted from these five sub-elements. This process
    is typically called *unnesting*.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: df数据框中存储在data列中的信息稍微有些不便，因为它嵌套了。df.data向量的每个元素都有一个内部结构。存储在data列中的向量的每个条目都有一个值元素。回想一下第14.3节，每个值元素内部存储了五个子元素：n，mv，lo95，hi95和zero。我们想要使用从这五个子元素中提取的数据在我们的数据框中创建五个新列。这个过程通常被称为*解包*。
- en: Figure 14.3 illustrates an example of unnesting. The source data frame has a
    single column x. Each element of this column is a NamedTuple with fields a and
    b. When we unnest such a column, we create new columns in the target data frame,
    called a and b, that store the values from the respective fields of named tuples
    that form column x.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3展示了解包的一个示例。源数据框只有一个列x。该列的每个元素都是一个包含字段a和b的NamedTuple。当我们解包这样的列时，我们在目标数据框中创建新的列，称为a和b，它们存储来自构成列x的命名元组的相应字段的值。
- en: '![CH14_F03_Kaminski2](../Images/CH14_F03_Kaminski2.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F03_Kaminski2](../Images/CH14_F03_Kaminski2.png)'
- en: Figure 14.3 The x column in the source data frame is unnested into a and b columns
    in the target data frame. Unnesting often makes it easier to work with the stored
    data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 源数据框中的x列被解包到目标数据框中的a和b列。解包通常使处理存储的数据更容易。
- en: We can perform the unnesting by using the select function we already worked
    with in chapter 13\. However, to perform this operation, we need to learn a new
    element of the operation specification syntax.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用在第13章中已经使用过的 select 函数执行展开。然而，要执行此操作，我们需要学习操作指定语法的另一个新元素。
- en: In chapters 12 and 13, you learned that the general structure of this syntax
    is source_column => operation_function => target_column_name. For example, when
    we write :a => sum => :sum_a, we want to get column a from a source data frame,
    apply the sum function to it, and store it in the sum_a column in the target data
    frame.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12章和第13章中，你学习了这种语法的通用结构是 source_column => operation_function => target_column_name。例如，当我们写
    :a => sum => :sum_a 时，我们希望从源数据框中获取列 a，对其应用求和函数，并将其存储在目标数据框的 sum_a 列中。
- en: 'As we have already discussed, the value element of the stored JSON objects
    has five sub-elements: n, mv, lo95, hi95, and zero. Therefore, if we wanted to
    extract the n element, for example, we could write the following transformation
    specification (we discussed ByRow in chapter 13; recall that it transforms a function
    that accepts scalars to a function that is vectorized):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已讨论的，存储的 JSON 对象的价值元素有五个子元素：n、mv、lo95、hi95 和 zero。因此，如果我们想提取 n 元素，例如，我们可以编写以下转换指定（我们在第13章讨论了
    ByRow；回想一下，它将接受标量的函数转换为向量化的函数）：
- en: '[PRE23]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, we want to extract all five sub-elements of the value element. We
    could write five such transformation specification operations, but there is an
    easier way. In operation specification syntax, the target_column_name typically
    is the name of a column. However, we can instead pass a special AsTable expression
    as the target column name. If we do this, DataFrames.jl will try to extract the
    elements stored in the return value of the operation function into multiple columns.
    The names of the columns will be automatically generated using the names of the
    elements that are unnested. This process is easiest to explain by example. Assume,
    following figure 14.3, that we have a data frame whose column x stores named tuples
    that have properties a and b:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望提取价值元素的五个子元素。我们可以编写五个这样的转换指定操作，但有一个更简单的方法。在操作指定语法中，target_column_name
    通常是指列的名称。然而，我们可以传递一个特殊的 AsTable 表达式作为目标列名称。如果我们这样做，DataFrames.jl 将尝试将操作函数的返回值中存储的元素提取到多个列中。列的名称将自动使用展开的元素名称生成。这个过程通过示例最容易解释。假设，根据图14.3，我们有一个数据框，其列
    x 存储具有属性 a 和 b 的命名元组：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We now want to unnest the properties :a and :b as new columns. We can write
    this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在希望将属性 :a 和 :b 展开为新的列。我们可以这样写：
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or, as explained in chapter 13, you can omit the operation function if it is
    not required and write this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如第13章所述，如果不需要操作函数，可以省略它并这样写：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now know that we can use AsTable as the target column name to unnest the
    data stored in the value element from the JSON objects contained in the data column
    of the df data frame. We also want to keep the K column to have information on
    which row represents which value of the strike price. Here is the code that performs
    the required operation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以使用 AsTable 作为目标列名称，从 df 数据框的数据列中包含的 JSON 对象的价值元素中展开存储的数据。我们还希望保留 K
    列，以了解哪一行代表哪个执行价格的价值。以下是执行所需操作的代码：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 14.4.4 Plotting the results of Asian option pricing
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4.4 亚洲期权定价结果的绘图
- en: 'To visualize the obtained results, we will create two plots. In the first,
    we want to show the value of our Asian option as a function of the strike price.
    In the second, the probability of zero payoff of this option as a function of
    the strike price is visualized. We expect that as the strike price grows, the
    value of the option drops, and the probability of zero payoff grows. We generate
    the plot with the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化获得的结果，我们将创建两个图表。在第一个图表中，我们想显示亚洲期权的价值作为执行价格的函数。在第二个图表中，该期权的零收益概率作为执行价格的函数被可视化。我们预计随着执行价格的上升，期权的价值会下降，零收益的概率会增加。我们使用以下代码生成图表：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Figure 14.4 shows the result.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4显示了结果。
- en: '![CH14_F04_Kaminski2](../Images/CH14_F04_Kaminski2.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![CH14_F04_Kaminski2](../Images/CH14_F04_Kaminski2.png)'
- en: Figure 14.4 Plotting the approximated value of the Asian option and the probability
    of zero payoff of the option as a function of K. The higher the probability of
    zero payoff of our option, the lower its value.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 绘制亚洲期权的近似价值及其作为 K 的函数的零收益概率。我们期权的零收益概率越高，其价值就越低。
- en: Before we finish our work, remember to terminate the web service. Go to the
    terminal window where your web service is running, and press Ctrl-C (on Windows
    and Linux) or Cmd-C (on a Mac). Now the terminal should show your system prompt,
    indicating that the web service is terminated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成工作之前，记得终止网络服务。前往你的网络服务正在运行的控制台窗口，然后按 Ctrl-C（在 Windows 和 Linux 上）或 Cmd-C（在
    Mac 上）。现在终端应该显示系统提示，表明网络服务已终止。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Asian options are complex financial instruments. They often do not have a closed-form
    formula that would allow you to compute their value. In such situations, you can
    use a Monte Carlo simulation to approximate this value. In a Monte Carlo simulation,
    we randomly sample the evolution of the stock price underlying the Asian option
    multiple times, and for each sample, we compute the option’s payoff. The mean
    of these payoffs allows us to compute the approximate value of the Asian option.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚洲期权是一种复杂的金融工具。它们通常没有封闭形式的公式来计算其价值。在这种情况下，你可以使用蒙特卡洛模拟来近似这个值。在蒙特卡洛模拟中，我们多次随机采样亚洲期权所依据的股票价格的变化，并对每个样本计算期权的收益。这些收益的平均值使我们能够计算亚洲期权的近似价值。
- en: Pricing financial assets by using a Monte Carlo simulation is compute intensive.
    Julia is a good choice for this task since it is a fast language.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛模拟对金融资产进行定价是计算密集型的。由于 Julia 是一种快速语言，因此它是这项任务的理想选择。
- en: Julia natively supports multithreading. To allow your Julia process to use multiple
    threads, pass the -tN option when you start it, where N is the desired number
    of threads. Built-in support for multithreading is one of the features that distinguishes
    Julia from R or Python. This functionality allows your programs to run faster,
    as they can take advantage of the multiple CPU cores on which Julia is run.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 本地支持多线程。要允许你的 Julia 进程使用多个线程，在启动时传递 -tN 选项，其中 N 是所需的线程数。内置的多线程支持是区分 Julia
    与 R 或 Python 的特性之一。这个功能允许你的程序运行得更快，因为它们可以利用 Julia 运行的多个 CPU 核心来提高性能。
- en: The Threads module provides a low-level API for writing multithreaded code in
    Julia. It offers all standard components (like spawning tasks, atomics, and locks)
    that are needed to write advanced code using multithreading.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Threads 模块为在 Julia 中编写多线程代码提供了低级 API。它提供了所有标准组件（如创建任务、原子操作和锁），这些都是编写使用多线程的高级代码所必需的。
- en: The ThreadsX.jl package provides a high-level API allowing you to easily run
    standard functions (for example, map using multiple threads).
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ThreadsX.jl 包提供了一组高级 API，允许你轻松运行标准函数（例如，使用多线程进行映射）。
- en: The functionalities of the Threads module and the ThreadsX.jl package taken
    together enable simple operations to be easily parallelized in Julia, even by
    non-experts. In addition, writing complex multithreaded code is possible, and
    experts can squeeze out maximum performance from the available CPU.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Threads 模块和 ThreadsX.jl 包的功能结合在一起，使得在 Julia 中轻松并行化简单操作成为可能，即使是非专家也能做到。此外，编写复杂的线程代码也是可能的，专家可以充分利用可用的
    CPU 来获得最佳性能。
- en: When you write code that has a limited time budget for computations and you
    still want it to use multithreading, a useful pattern is to process data in batches.
    The batch size should be big enough that you get the benefit of multithreading,
    but also small enough that performing computations for a single batch requires
    a small amount of the available time budget. This technique is often useful when
    you write applications that serve data interactively and need to ensure that your
    users can decide how long they can wait for the results.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你编写的代码有有限的计算时间预算，但你仍然希望它使用多线程时，一个有用的模式是分批处理数据。批处理的大小应该足够大，以便你能够获得多线程的好处，但也足够小，以至于对单个批次的计算只需要一小部分可用的时间预算。当你编写需要确保用户可以决定他们可以等待多长时间的应用程序时，这种技术通常很有用。
- en: Several operators in Julia (like ==, >, and <) allow for partial function application.
    Therefore, writing ==(0) has the same effect as defining an anonymous function
    x -> x == 0. Using the partial function application pattern leads to more-readable
    code that also requires less compilation than using anonymous functions.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的几个运算符（如 ==、> 和 <）允许部分函数应用。因此，编写 == (0) 与定义匿名函数 x -> x == 0 的效果相同。使用部分函数应用模式可以编写更易读的代码，并且比使用匿名函数需要更少的编译。
- en: The Genie.jl package is a full-stack web framework that allows you to create
    complex web applications. In data science workflows using Genie.jl, you can easily
    create web services, which allow you to use HTTP to serve the results of your
    analysis.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Genie.jl 包是一个全栈网络框架，允许你创建复杂的网络应用程序。在使用 Genie.jl 的数据科学工作流程中，你可以轻松创建网络服务，这些服务允许你使用
    HTTP 来提供分析结果。
- en: When designing web services, you can use the HTTP POST request method to allow
    client applications to send data to the server in the body of the request. The
    server is informed about the format of your data through the value of the Content-Type
    header of the request.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计网络服务时，你可以使用 HTTP POST 请求方法，允许客户端应用程序在请求体中向服务器发送数据。服务器通过请求的 Content-Type 头部的值来了解你数据的格式。
- en: Using Genie.jl, you can design your web service so that it accepts POST requests
    containing a JSON payload specifying the parameters of the user’s request and
    also returns the response in JSON format. Using this web service design, you can
    easily integrate Julia code with code written in other programming languages,
    as HTTP and the JSON format abstract out the implementation details of your web
    service.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Genie.jl，你可以设计你的网络服务，使其接受包含指定用户请求参数的 JSON 有效负载的 POST 请求，并返回 JSON 格式的响应。使用这种网络服务设计，你可以轻松地将
    Julia 代码与其他编程语言编写的代码集成在一起，因为 HTTP 和 JSON 格式抽象出了你的网络服务的实现细节。
- en: You can easily unnest a column in a data frame that contains complex structures
    (for example, named tuples or JSON objects) by using AsTable as the target column
    name in the operation specification syntax. This functionality is useful when
    working with data organized hierarchically, which is often the case, for example,
    when data is stored in JSON format.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在操作规范语法中使用 AsTable 作为目标列名，轻松地展开一个包含复杂结构（例如，命名元组或 JSON 对象）的数据帧中的列。当数据以层次结构组织时，这个功能非常有用，例如，当数据以
    JSON 格式存储时。
