- en: 1 The basics of unit testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 单元测试的基础
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Identifying entry points and exit points
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别入口点和出口点
- en: The definitions of *unit test* and *unit of work*
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*和*工作单元*的定义'
- en: The difference between unit testing and integration testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试与集成测试之间的区别
- en: A simple example of unit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的简单示例
- en: Understanding test-driven development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试驱动开发
- en: Manual tests suck. You write your code, you run it in the debugger, you hit
    all the right keys in your app to get things just right, and then you repeat all
    this the next time you write new code. And you have to remember to check all the
    other code that might have been affected by the new code. More manual work. Great.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试很糟糕。你编写代码，你在调试器中运行它，你在应用中按下所有正确的键以使事情恰到好处，然后你重复所有这些操作，下次你编写新代码时。而且你必须记得检查所有可能受到新代码影响的代码。更多手动工作。太棒了。
- en: Doing tests and regression testing completely manually, repeating the same actions
    again and again like a monkey, is error prone and time consuming, and people seem
    to hate doing that as much as anything can be hated in software development. These
    problems are alleviated by tooling and our decision to use it for good, by writing
    automated tests that save us precious time and debugging pain. Integration and
    unit testing frameworks help developers write tests more quickly with a set of
    known APIs, execute those tests automatically, and review the results of those
    tests easily. And they never forget! I’m assuming you’re reading this book because
    either you feel the same way, or because someone forced you to read it, and that
    someone feels the same way. Or maybe that someone was forced to force you into
    reading this book. Doesn’t matter. If you believe repetitive manual testing is
    awesome, this book will be very difficult to read. The assumption is that you
    *want* to learn how to write good unit tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完全手动进行测试和回归测试，一次又一次地重复相同的动作，就像猴子一样，容易出错且耗时，人们似乎对做这件事的厌恶程度不亚于软件开发中的任何事物。这些问题通过工具和我们的决定得到缓解，我们决定使用它来做好事，通过编写自动化测试来节省我们宝贵的时间和调试痛苦。集成和单元测试框架帮助开发者使用一组已知的
    API 更快地编写测试，自动执行这些测试，并轻松地审查这些测试的结果。而且它们永远不会忘记！我假设你阅读这本书是因为你感觉一样，或者是因为有人强迫你阅读它，而那个人也有同样的感觉。或者也许那个人被迫强迫你阅读这本书。没关系。如果你认为重复的手动测试很棒，这本书将很难阅读。假设你*想要*学习如何编写好的单元测试。
- en: This book also assumes that you know how to write code using JavaScript or TypeScript,
    using at least ECMAScript 6 (ES6) features, and that you are comfortable with
    node package manager (npm). Another assumption is that you are familiar with Git
    source control. If you’ve seen github.com before and you know how to clone a repository
    from there, you are good to go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书还假设你了解如何使用 JavaScript 或 TypeScript 编写代码，至少使用 ECMAScript 6 (ES6) 功能，并且你对 node
    包管理器 (npm) 感到舒适。另一个假设是你熟悉 Git 源代码控制。如果你之前见过 github.com 并且知道如何从那里克隆存储库，那么你就准备好了。
- en: Although all the book’s code listings are in JavaScript and TypeScript, you
    don’t have to be a JavaScript programmer to read this book. The previous editions
    of this book were in C#, and I’ve found that about 80% of the patterns there have
    transferred over quite easily. You should be able to read this book even if you
    come from Java, .NET, Python, Ruby, or other languages. The patterns are just
    patterns. The language is used to demonstrate those patterns, but they are not
    language-specific.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书的所有代码示例都是用 JavaScript 和 TypeScript 编写的，但你不必是 JavaScript 程序员就能阅读这本书。本书的前几版是
    C# 编写的，我发现那里的大约 80% 的模式都很容易迁移。即使你来自 Java、.NET、Python、Ruby 或其他语言，你也应该能够阅读这本书。这些模式只是模式。语言被用来演示这些模式，但它们不是特定于语言的。
- en: JavaScript vs. TypeScript in this book
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的 JavaScript 与 TypeScript 的比较
- en: 'This book contains both vanilla JavaScript and TypeScript examples throughout.
    I take full responsibility for creating such a Tower of Babel (no pun intended),
    but I promise, there’s a good reason: this book is dealing with three programming
    paradigms in JavaScript: *procedural*, *functional,* and *object-oriented* design.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含整个过程中 vanilla JavaScript 和 TypeScript 的示例。我完全负责创建这样一个巴别塔（没有讽刺的意思），但我保证，这有一个很好的理由：这本书处理
    JavaScript 中的三种编程范式：*过程式*、*函数式*和*面向对象*设计。
- en: I use regular JavaScript for the samples dealing with procedural and functional
    designs. I use TypeScript for the object-oriented examples, because it provides
    the structure needed to express these ideas.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用常规 JavaScript 来处理过程式和函数式设计的示例。我使用 TypeScript 来处理面向对象的示例，因为它提供了表达这些想法所需的结构。
- en: In previous editions of this book, when I was working in C#, this wasn’t an
    issue. When moving to JavaScript, which supports these multiple paradigms, using
    TypeScript makes sense.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几版中，当我使用 C# 进行工作时，这不是一个问题。当转向支持这些多种范式的 JavaScript 时，使用 TypeScript 是有意义的。
- en: Why not just use TypeScript for all the paradigms, you ask? Both to show that
    TypeScript is not needed to write unit tests and that the concepts of unit testing
    do not depend on one language or another, or on any type of compiler or linter,
    to work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么不直接使用 TypeScript 来处理所有范式呢？这样做既是为了展示编写单元测试不需要 TypeScript，也是为了说明单元测试的概念并不依赖于某种语言或任何类型的编译器或代码检查工具来工作。
- en: This means that if you’re into functional programming, some of the examples
    in this book will make sense, and others will seem like they are overcomplicated
    or needlessly verbose. Feel free to focus only on the functional examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你对函数式编程感兴趣，本书中的一些示例可能对你有意义，而另一些可能看起来过于复杂或冗长。你可以自由地只关注函数式示例。
- en: If you’re into object-oriented programming or are coming from a C#/Java background,
    you’ll find that some of the non-object-oriented examples are simplistic and don’t
    represent your day-to-day work in your own projects. Fear not, there will be plenty
    of sections relating to the object-oriented style.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从事面向对象编程或来自 C#/Java 背景，你会发现一些非面向对象的示例可能过于简单，并不能代表你在自己的项目中的日常工作。不要担心，会有很多与面向对象风格相关的章节。
- en: 1.1 The first step
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 第一步
- en: 'There’s always a first step: the first time you wrote a program, the first
    time you failed a project, and the first time you succeeded in what you were trying
    to accomplish. You never forget your first time, and I hope you won’t forget your
    first tests.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有第一步：你第一次编写程序，第一次项目失败，以及第一次成功完成你想要达成的目标。你永远不会忘记你的第一次，我希望你也不会忘记你的第一次单元测试。
- en: You may have come across tests in some form. Some of your favorite open source
    projects come with bundled “test” folders—you have them in your own projects at
    work. You might have already written a few tests yourself, and you may even remember
    them as being bad, awkward, slow, or unmaintainable. Even worse, you might have
    felt they were useless and a waste of time. (Many people sadly do.) Or you may
    have had a great first experience with unit tests, and you’re reading this book
    to see what more you might be missing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经以某种形式遇到过测试。一些你最喜欢的开源项目都附带“测试”文件夹——你在自己的工作项目中也有。你可能已经自己编写了一些测试，甚至可能记得它们是糟糕的、笨拙的、慢的或难以维护的。更糟糕的是，你可能觉得它们毫无用处，是浪费时间。（很多人很遗憾地是这样。）或者你可能对单元测试有了一次非常好的体验，你现在正在阅读这本书，看看你可能还错过了什么。
- en: This chapter will analyze the “classic” definition of a unit test and compare
    it to the concept of integration testing. This distinction is confusing to many,
    but it’s very important to learn, because, as you’ll learn later in the book,
    separating unit tests from other types of tests can be crucial to having high
    confidence in your tests when they fail or pass.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分析单元测试的“经典”定义，并将其与集成测试的概念进行比较。这种区别对许多人来说可能很困惑，但了解这一点非常重要，因为正如你在本书后面将学到的，将单元测试与其他类型的测试分开可能是当测试失败或通过时对测试有高度信心的重要因素。
- en: We’ll also discuss the pros and cons of unit testing versus integration testing,
    and we’ll develop a better definition of what might be a “good” unit test. We’ll
    finish with a look at test-driven development (TDD), because it’s often associated
    with unit testing but is a separate skill that I highly recommend giving a chance
    (it’s not the main topic of this book, though). Throughout this chapter, I’ll
    also touch on concepts that are explained more thoroughly elsewhere in the book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论单元测试与集成测试的优缺点，并制定一个更好的定义，说明可能是一个“好的”单元测试。我们将以对测试驱动开发（TDD）的探讨结束，因为它通常与单元测试相关联，但它是一项我强烈推荐尝试的独立技能（尽管这不是本书的主要内容）。在本章中，我还会简要提及本书其他部分更详细解释的概念。
- en: First, let’s define what a unit test should be.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一下单元测试应该是什么。
- en: 1.2 Defining unit testing, step by step
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 逐步定义单元测试
- en: Unit testing isn’t a new concept in software development. It’s been floating
    around since the early days of the Smalltalk programming language in the 1970s,
    and it proves itself time and time again as one of the best ways a developer can
    improve code quality while gaining a deeper understanding of the functional requirements
    of a module, class, or function. Kent Beck introduced the concept of unit testing
    in Smalltalk, and it has carried on into many other programming languages, making
    unit testing an extremely useful practice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在软件开发中不是一个新概念。它自20世纪70年代Smalltalk编程语言的早期就已经存在，并且一次又一次地证明了自己是开发者提高代码质量、更深入理解模块、类或函数功能需求的最佳方式之一。Kent
    Beck在Smalltalk中引入了单元测试的概念，并且这一概念已经扩展到许多其他编程语言中，使得单元测试成为一种极其有用的实践。
- en: To see what we *don’t* want to use as our definition of unit testing, let’s
    look to Wikipedia as a starting point. I’ll use its definition with reservations,
    because, in my opinion, there are many important parts missing, but it is largely
    accepted by many for lack of other good definitions. Our definition will slowly
    evolve throughout this chapter, with the final definition appearing in section
    1.9.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们*不*希望作为单元测试定义的内容，让我们以维基百科为起点。我将带着保留意见使用其定义，因为在我看来，其中缺少了许多重要的部分，但鉴于缺乏其他好的定义，它被许多人广泛接受。在本章中，我们的定义将逐渐演变，最终定义将在第1.9节出现。
- en: Unit tests are typically automated tests written and run by software developers
    to ensure that a section of an application (known as the “unit”) meets its design
    and behaves as intended. In procedural programming, a unit could be an entire
    module, but it is more commonly an individual function or procedure. In object-oriented
    programming, a unit is often an entire interface, such as a class, or an individual
    method ([https://en.wikipedia.org/wiki/Unit_testing](https://en.wikipedia.org/wiki/Unit_testing)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常是软件开发者编写的自动化测试，用于确保应用程序的一部分（称为“单元”）符合其设计和预期行为。在过程式编程中，一个单元可能是一个完整的模块，但更常见的是单个函数或过程。在面向对象编程中，一个单元通常是一个完整的接口，例如一个类，或者一个单独的方法([https://en.wikipedia.org/wiki/Unit_testing](https://en.wikipedia.org/wiki/Unit_testing))。
- en: The thing you’ll write tests for is the *subject*, *system, or suite under test*
    (SUT).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的测试对象是*主题*、*系统或测试套件*（SUT）。
- en: Definition SUT stands for *subject*, *system, or suite under test*, and some
    people like to use CUT (*component, class, or code under test*). When you test
    something, you refer to the thing you’re testing as the SUT.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义SUT代表*主题*、*系统或测试套件*，有些人喜欢使用CUT（*组件、类或待测试代码*）。当你测试某物时，你将你正在测试的东西称为SUT。
- en: Let’s talk about the word “unit” in unit testing. To me, *unit* stands for a
    “unit of work” or a “use case” inside the system. A unit of work has a beginning
    and an end, which I call an *entry point* and an *exit point*. A simple example
    of a unit of work is a function that calculates something and returns a value.
    However, a function could also use other functions, other modules, and other components
    in the calculation process, which means the unit of work (from entry point to
    exit point), could span more than just a function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈单元测试中的“单元”这个词。对我来说，“单元”代表系统内的“工作单元”或“用例”。工作单元有一个开始和一个结束，我称之为*入口点*和*出口点*。工作单元的一个简单例子是一个计算并返回值的函数。然而，一个函数也可能在计算过程中使用其他函数、其他模块和其他组件，这意味着工作单元（从入口点到出口点）可能不仅仅是一个函数。
- en: Unit of work
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元
- en: A *unit of work* is all the actions that take place between the invocation of
    an *entry point* up until a noticeable end result through one or more *exit points*.
    The *entry point* is the thing we trigger. Given a publicly visible function,
    for example
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*工作单元*是指从调用*入口点*开始，直到通过一个或多个*出口点*产生一个明显的结束结果之间发生的所有操作。*入口点*是我们触发的东西。例如，给定一个公开可见的函数'
- en: The function’s body is all or part of the unit of work.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数体是工作单元的全部或部分。
- en: The function’s declaration and signature are the entry point into the body.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的声明和签名是进入函数体的入口点。
- en: The resulting outputs or behaviors of the function are its exit points.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数产生的输出或行为是其出口点。
- en: 1.3 Entry points and exit points
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 入口点和出口点
- en: A unit of work always has an entry point and one or more exit points. Figure
    1.1 shows a simple diagram of a unit of work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元始终有一个入口点和一个或多个出口点。图1.1显示了工作单元的简单示意图。
- en: '![01-01](../Images/01-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![01-01](../Images/01-01.png)'
- en: Figure 1.1 A unit of work has entry points and exit points.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 一个工作单元有入口点和出口点。
- en: A unit of work can be a single function, multiple functions, or even multiple
    modules or components. But it always has an entry point that we can trigger from
    the outside (via tests or other production code), and it always ends up doing
    something useful. If it doesn’t do anything useful, we might as well remove it
    from our codebase.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作单元可以是一个函数、多个函数，甚至是多个模块或组件。但它始终有一个我们可以从外部触发的入口点（通过测试或其他生产代码），并且它最终总会做一些有用的事情。如果它没有做任何有用的事情，我们不妨从我们的代码库中移除它。
- en: 'What’s *useful*? Something publicly noticeable that happens in the code: a
    return value, a state change, or calling an external party, as shown in figure
    1.2\. Those noticeable behaviors are what I call *exit points.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**有用的**？在代码中公开可见的某些事情：一个返回值、状态变化，或者调用外部方，如图1.2所示。这些引人注目的行为就是我所说的**出口点**。
- en: '![01-02](../Images/01-02.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![01-02](../Images/01-02.png)'
- en: Figure 1.2 Types of exit points
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 出口点的类型
- en: Why “exit point”?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么叫“出口点”？
- en: Why use the term “exit point” and not something like “behavior”? My thinking
    is that behaviors can be purely internal, whereas we’re looking for externally
    visible behaviors from the caller. That difference might be difficult to distinguish
    at a glance. Also, “exit point” nicely suggests we are leaving the context of
    a unit of work and going back to the test context, though behaviors might be a
    bit more fluid than that. There’s an extensive discussion about types of behavior,
    including observable behavior, in *Unit Testing Principles, Practices, and Patterns*
    by Vladimir Khorikov (Manning, 2020). Refer to that book to learn more about this
    topic.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用“出口点”这个词而不是“行为”之类的词？我的想法是，行为可以是纯粹内部的，而我们寻找的是来自调用者的外部可见行为。这种差异可能一眼难以区分。此外，“出口点”很好地暗示了我们正在离开工作单元的上下文，回到测试上下文，尽管行为可能比这更灵活。关于行为类型，包括可观察行为，在Vladimir
    Khorikov的《单元测试原则、实践和模式》（Manning, 2020）中有广泛的讨论。请参考那本书以了解更多关于这个主题的信息。
- en: The following listing shows a quick code example of a simple unit of work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了简单工作单元的快速代码示例。
- en: Listing 1.1 A simple function that we’d like to test
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 我们想要测试的简单函数
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: About the JavaScript version used in this book
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本书使用的JavaScript版本
- en: I’ve chosen to use Node.js 12.8 with plain ES6 JavaScript along with JSDoc-style
    comments. The module system I’ll use is CommonJS, to keep things simple. Perhaps
    in a future edition I’ll start using ES modules (.mjs files), but for now, and
    for the rest of this book, CommonJS will do. It doesn’t really matter for the
    patterns in this book anyway.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用Node.js 12.8和纯ES6 JavaScript以及JSDoc风格的注释。我将使用的模块系统是CommonJS，以保持简单。也许在未来的版本中，我会开始使用ES模块（.mjs文件），但到目前为止，以及本书的其余部分，CommonJS将足够。对于本书中的模式来说，这实际上并不重要。
- en: You should be able to easily extrapolate the techniques used here for whatever
    JavaScript stack you’re currently working with, whether you’re using TypeScript,
    Plain JS, ES modules, backend or frontend, Angular, or React. It shouldn’t matter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够轻松地将这里使用的技巧应用到您目前正在使用的任何JavaScript栈中，无论您使用TypeScript、纯JS、ES模块、后端或前端、Angular还是React。这都不重要。
- en: Getting the code for this chapter
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 获取本章的代码
- en: You can download all the code samples shown in this book from GitHub. You can
    find the repository at [https://github.com/royosherove/aout3-samples](https://github.com/royosherove/aout3-samples).
    Make sure you have Node 12.8 or higher installed, and run `npm` `install` followed
    by `npm` `run` `ch[chapter` `number]`. For this chapter, you would run `npm` `run`
    `ch1`. This will run all the tests for this chapter so you can see their outputs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载本书中展示的所有代码示例。您可以在[https://github.com/royosherove/aout3-samples](https://github.com/royosherove/aout3-samples)找到存储库。请确保您已安装Node
    12.8或更高版本，然后运行`npm install`，接着运行`npm run ch[章节编号]`。对于本章，您将运行`npm run ch1`。这将运行本章的所有测试，以便您可以看到它们的输出。
- en: This unit of work is completely encompassed in a single function. The function
    is the entry point, and because its end result returns a value, it also acts as
    the exit point. We get the end result in the same place we trigger the unit of
    work, so the entry point is also the exit point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作单元完全包含在一个单独的函数中。这个函数是入口点，因为它最终返回一个值，它也充当出口点。我们在触发工作单元的地方获得最终结果，所以入口点也是出口点。
- en: If we drew this function as a unit of work, it would look something like figure
    1.3\. I used `sum(numbers)` as the entry point, not `numbers`, because the entry
    point is the function signature. The parameters are the context or input given
    through the entry point.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个函数作为工作单元绘制，它看起来就像图 1.3 一样。我使用 `sum(numbers)` 作为入口点，而不是 `numbers`，因为入口点是函数签名。参数是通过入口点给出的上下文或输入。
- en: '![01-03](../Images/01-03.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![01-03](../Images/01-03.png)'
- en: Figure 1.3 A function that has the same entry point as exit point
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 一个具有相同入口点和出口点的函数
- en: The following listing shows a variation on this idea.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了这个想法的一个变体。
- en: Listing 1.2 A unit of work with entry points and exit points
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.2 具有入口点和出口点的工作单元
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '❶ New functionality: calculating a running total'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新功能：计算累计总和
- en: 'This new version of `sum` has *two* exit points. It does two things:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `sum` 的新版本有两个出口点。它做两件事：
- en: It returns a value.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个值。
- en: 'It introduces new functionality: a running total of all the sums. It sets the
    state of the module in a way that is noticeable (via `totalSoFar`) from the caller
    of the entry point.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它引入了新的功能：所有求和的总计。它以某种明显的方式（通过 `totalSoFar`）设置模块的状态，供入口点的调用者可见。
- en: 'Figure 1.4 shows how I would draw this unit of work. You can think of these
    two exit points as two different paths, or requirements, from the same unit of
    work, because they indeed *are* two different useful things the code is expected
    to do. This also means I’d be very likely to write two different unit tests here:
    one for each exit point. Very soon we’ll do exactly that.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 展示了我会如何绘制这个工作单元。你可以将这些两个出口点视为从同一工作单元出发的两个不同路径或需求，因为它们确实 *是* 代码预期执行的两个不同的有用操作。这也意味着我可能会为每个出口点编写两个不同的单元测试：一个用于每个出口点。很快我们就会这样做。
- en: '![01-04](../Images/01-04.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![01-04](../Images/01-04.png)'
- en: Figure 1.4 A unit of work with two exit points
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 具有两个出口点的工作单元
- en: What about `totalSoFar`? Is this also an entry point? Yes, it could be, *in
    a separate test*. I could write a test that proves that calling `totalSoFar` without
    triggering prior to that call returns `0`. That would make it its own little unit
    of work, which would be perfectly fine. Often one unit of work (such as `sum`)
    can be composed of smaller units.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `totalSoFar` 呢？这也是一个入口点吗？是的，它可以是一个，*在单独的测试中*。我可以编写一个测试来证明在调用之前不触发返回 `0` 的
    `totalSoFar`。这将使其成为一个独立的小的工作单元，这将是完全可行的。通常，一个工作单元（如 `sum`）可以由更小的单元组成。
- en: As you can see, the scope of our tests can change and mutate, but we can still
    define them with entry points and exit points. Entry points are always where the
    test triggers the unit of work. You can have multiple entry points into a unit
    of work, each used by a different set of tests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们测试的范围可以改变和变异，但我们仍然可以使用入口点和出口点来定义它们。入口点始终是测试触发工作单元的地方。您可以为工作单元设置多个入口点，每个入口点由不同的测试集使用。
- en: A note on design
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设计的说明
- en: 'There are two main types of actions: “query” actions and “command” actions.
    Query actions don’t change stuff; they just return values. Command actions change
    stuff but don’t return values.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要类型的操作：“查询”操作和“命令”操作。查询操作不改变任何东西；它们只是返回值。命令操作改变东西但不返回值。
- en: 'We often combine the two, but there are many cases where separating them might
    be a better design choice. This book isn’t primarily about design, but I urge
    you to read more about the concept of *command query separation* over on Martin
    Fowler’s website: [https://martinfowler.com/bliki/CommandQuerySeparation.html](https://martinfowler.com/bliki/CommandQuerySeparation.html).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将它们结合起来，但在许多情况下，将它们分开可能是一个更好的设计选择。这本书主要不是关于设计的，但我敦促您在 Martin Fowler 的网站上了解更多关于
    *命令查询分离* 的概念：[https://martinfowler.com/bliki/CommandQuerySeparation.html](https://martinfowler.com/bliki/CommandQuerySeparation.html)。
- en: Exit points signifying requirements and new tests, and vice versa
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 出口点表示需求和新的测试，反之亦然
- en: Exit points are end results of a unit of work. For unit tests, I usually write
    at least one test, with its own readable name, for each exit point. I may then
    add more tests with variations on the inputs, all using the same entry point,
    to gain more confidence.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 出口点是工作单元的最终结果。对于单元测试，我通常为每个出口点至少编写一个测试，并给它一个可读的名字。然后我可以添加更多具有不同输入的测试，所有这些测试都使用相同的入口点，以获得更多的信心。
- en: 'Integration tests, which we’ll discuss later in this chapter and in the book,
    usually include multiple end results, since it can be impossible to separate code
    paths at those levels. That’s also one of the reasons integration tests are harder
    to debug, get up and running, and maintain: they do much more than unit tests,
    as you’ll soon see.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试，我们将在本章和书中稍后讨论，通常包括多个最终结果，因为在那些级别上分离代码路径可能是不可能的。这也是集成测试更难调试、启动和维持的原因之一：它们所做的比单元测试多得多，正如你很快就会看到的。
- en: A third version of our example function is shown in the following listing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了我们示例函数的第三个版本。
- en: Listing 1.3 Adding a logger call to the function
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.3 向函数添加记录器调用
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ CA new exit point
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新增出口点
- en: 'You can see that there’s a new exit point (or requirement, or end result) in
    the function. It logs something to an external entity—perhaps to a file, or the
    console, or a database. We don’t know, and we don’t care. This is the third type
    of exit point: *calling a third party*. I also like to refer to it as “calling
    a *dependency*.”'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到函数中有一个新的出口点（或要求，或最终结果）。它将某些信息记录到外部实体——可能是文件、控制台或数据库。我们不知道，也不关心。这是第三种类型的出口点：**调用第三方**。我也喜欢称它为“调用**依赖**”。
- en: DEFINITION A *dependency* is something we don’t have full control over during
    a unit test. Or it can be something that trying to control in a test would make
    our lives miserable. Some examples would include loggers that write to files,
    things that talk to the network, code that’s controlled by other teams, components
    that take a long time (calculations, threads, database access), and more. The
    rule of thumb is that if we can fully and easily control what it’s doing, and
    it runs in memory, and it’s fast, then it’s not a dependency. There are always
    exceptions to the rule, but this should get you through 80% of the cases, at least.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一个**依赖**是在单元测试期间我们没有完全控制的东西。或者它也可以是试图在测试中控制它会使我们的生活变得痛苦的东西。一些例子包括写入文件的记录器、与网络通信的事物、由其他团队控制的代码、需要很长时间（计算、线程、数据库访问）的组件等等。一般来说，如果我们可以完全且容易地控制它在做什么，并且它在内存中运行，且运行速度快，那么它就不是依赖。规则总有例外，但这应该至少能让你处理80%的情况。'
- en: Figure 1.5 shows how I’d draw this unit of work with all three exit points.
    At this point we’re still discussing a function-sized unit of work. The entry
    point is the function call, but now we have three possible paths, or exit points,
    that do something useful and that the caller can verify publicly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5展示了如何用所有三个出口点绘制这个工作单元。在这个阶段，我们仍在讨论一个函数大小的工作单元。入口点是函数调用，但现在我们有三个可能路径，或出口点，执行一些有用的操作，并且调用者可以公开验证。
- en: '![01-05](../Images/01-05.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![01-05](../Images/01-05.png)'
- en: Figure 1.5 Showing three exit points from a function
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5展示了一个函数的三个出口点
- en: 'Here’s where it gets interesting: it’s a good idea to have a *separate test
    for each exit point*. This will make the tests more readable and simpler to debug
    or change without affecting other outcomes.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就变得有趣了：为每个出口点进行**单独的测试**是个好主意。这将使测试更易于阅读，并且更容易调试或更改，而不会影响其他结果。
- en: 1.4 Exit point types
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 出口点类型
- en: 'We’ve seen that we have three different types of end results:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们有三种不同的最终结果：
- en: The invoked function returns a useful value (not undefined). If this was in
    a statically typed language such as Java or C#, we’d say it is a public, non-void
    function.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被调用的函数返回一个有用的值（不是未定义的）。如果在静态类型语言如Java或C#中，我们会说它是一个公开的、非空函数。
- en: There’s a *noticeable* change to the state or behavior of the system before
    and after invocation that can be determined without interrogating private state.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用前后，系统的状态或行为有明显的改变，可以在不查询私有状态的情况下确定。
- en: 'There’s a callout to a third-party system over which the test has no control.
    That third-party system doesn’t return any value, or that value is ignored. (Example:
    the code calls a third-party logging system that was not written by you, and you
    don’t control its source code.)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一个对第三方系统的调用，测试者无法控制。该第三方系统不返回任何值，或者该值被忽略。（例如：代码调用了一个不是由你编写的第三方日志系统，并且你无法控制其源代码。）
- en: '*XUnit Test Patterns’* definition of entry and exit points'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**《XUnit测试模式》**对入口点和出口点的定义'
- en: Gerard Meszaros’ book *XUnit Test Patterns* (Addison-Wesley Professional, 2007)
    discusses the notion of *direct inputs and outputs,* and *indirect inputs and
    outputs*. *Direct inputs* are what I like to call entry points. Meszaros refers
    to it as “using the front door” of a component. *Indirect outputs* in that book
    are the other two types of exit points I mentioned (state change and calling a
    third party).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Gerard Meszaros 的书籍 *XUnit Test Patterns*（Addison-Wesley Professional，2007）讨论了*直接输入和输出*以及*间接输入和输出*的概念。*直接输入*是我喜欢称之为入口点的东西。Meszaros
    称之为“使用组件的前门”。该书中的*间接输出*是我在前面提到的其他两种退出点类型（状态改变和调用第三方）。
- en: Both versions of these ideas have evolved in parallel, but the idea of a “unit
    of work” only appears in this book. A unit of work, coupled with entry and exit
    points, makes much more sense to me than direct and indirect inputs and outputs,
    but you can consider this a stylistic choice about how to teach the concept of
    test scopes. You can find more about *XUnit Test Patterns* at [xunitpatterns.com](http://xunitpatterns.com).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种想法的版本都并行发展，但“工作单元”的概念只出现在这本书中。工作单元与入口和退出点结合，对我来说比直接和间接输入和输出更有意义，但你可以将这视为关于如何教授测试范围概念的风格选择。你可以在
    [xunitpatterns.com](http://xunitpatterns.com) 上找到更多关于 *XUnit Test Patterns* 的信息。
- en: 'Let’s see how the idea of entry and exit points affects the definition of a
    unit test: A *unit test* is a piece of code that invokes a unit of work and checks
    one specific exit point as an end result of that unit of work. If the assumptions
    about the end result turn out to be wrong, the unit test has failed. A unit test’s
    scope can span as little as a function or as much as multiple modules or components,
    depending on how many functions and modules are used between the entry point and
    the exit point.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看入口和退出点的概念如何影响单元测试的定义：*单元测试*是一段代码，它调用一个工作单元并检查该工作单元的一个特定退出点作为结果。如果关于结果假设是错误的，则单元测试失败。单元测试的范围可以从一个函数到多个模块或组件，具体取决于入口点和退出点之间使用的函数和模块的数量。
- en: 1.5 Different exit points, different techniques
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 不同的退出点，不同的技术
- en: 'Why am I spending so much time talking about types of exit points? Because
    not only is it a great idea to separate the tests for each exit point, but different
    types of exit points might require different techniques to test successfully:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我要花这么多时间谈论退出点的类型？因为不仅将每个退出点的测试分开是一个好主意，而且不同的退出点类型可能需要不同的技术来成功测试：
- en: Return-value-based exit points (direct outputs in Meszaros’ *XUnit Test Patterns*)
    should be the easiest exit points to test. You trigger an entry point, you get
    something back, and you check the value you got back.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于返回值的退出点（Meszaros 的 *XUnit Test Patterns* 中的直接输出）应该是测试起来最简单的退出点。你触发一个入口点，得到一些东西，然后检查你得到的价值。
- en: State-based tests (indirect outputs) usually require a little more gymnastics.
    You call something, and then you do another call to check something else (or you
    call the previous thing again) to see if everything went according to plan.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于状态的测试（间接输出）通常需要更多的技巧。你调用某个东西，然后进行另一个调用以检查其他事情（或者再次调用之前的东西）以查看一切是否按计划进行。
- en: In a third-party situation (indirect outputs), we have the most hoops to jump
    through. We haven’t discussed this yet, but that’s where we’re forced to use things
    like *mock objects* to replace the external system with something we can control
    and interrogate in our tests. I’ll cover this idea deeply later in the book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三方情况（间接输出）中，我们需要跳过最多的障碍。我们还没有讨论这个问题，但这就是我们被迫使用像*模拟对象*这样的东西来替换外部系统，以便我们可以在测试中控制并质询的地方。我将在本书的后面深入探讨这个想法。
- en: Which exit points make the most problems?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些退出点造成最多的问题？
- en: As a rule of thumb, I try to mostly use either return-value-based or state-based
    tests. I try to avoid mock-object-based tests if I can, and usually I can. As
    a result, I usually have no more than 5% of my tests using mock objects for verification.
    Those types of tests complicate things and make maintainability more difficult.
    Sometimes there’s no escape, though, and we’ll discuss them as we proceed in the
    next chapters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我尽量主要使用基于返回值或状态的测试。如果可能，我会尽量避免使用基于模拟对象的测试，通常也是可以做到的。因此，我的测试中通常不超过5%使用模拟对象进行验证。这类测试会使事情复杂化，并使维护变得更加困难。尽管如此，有时我们别无选择，我们将在接下来的章节中讨论它们。
- en: 1.6 A test from scratch
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 从零开始进行测试
- en: Let’s go back to the first, simplest version of the code (listing 1.1) and try
    to test it, shall we? If we were to try to write a test for this, what would it
    look like?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到代码的第一个、最简单的版本（列表 1.1），并尝试测试它，好吗？如果我们尝试为这个编写测试，它看起来会是什么样子？
- en: Let’s take the visual approach first with figure 1.6\. Our entry point is `sum`
    with an input of a string called `numbers`. `sum` is also our exit point, since
    we will get a return value back from it and check its value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从视觉方法开始，看看图 1.6。我们的入口点是 `sum`，输入是一个名为 `numbers` 的字符串。`sum` 也是我们的出口点，因为我们将从它那里获取一个返回值并检查其值。
- en: '![01-06](../Images/01-06.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![01-06](../Images/01-06.png)'
- en: Figure 1.6 A visual view of our test
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 我们测试的视觉视图
- en: It’s possible to write an automated unit test without using a test framework.
    In fact, because developers have gotten more into the habit of automating their
    testing, I’ve seen plenty of them doing this before discovering test frameworks.
    In this section, we’ll write such a test without a framework, so that you can
    contrast this approach with using a framework in chapter 2.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用测试框架也可以编写自动化的单元测试。事实上，由于开发者越来越习惯于自动化他们的测试，我见过很多开发者在使用测试框架之前就已经这样做。在本节中，我们将不使用框架编写这样的测试，这样你就可以将这种方法与第
    2 章中使用框架的方法进行对比。
- en: So, let’s assume test frameworks don’t exist (or that we don’t know they do).
    We have decided to write our own little automated test from scratch. The following
    listing shows a very naive example of testing our own code with plain JavaScript.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设测试框架不存在（或者我们不知道它们存在）。我们已经决定从头开始编写我们自己的小型自动化测试。以下列表显示了使用纯JavaScript测试我们自己的代码的一个非常简单的示例。
- en: Listing 1.4 A very naive test against `sum()`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 对 `sum()` 的一个非常简单的测试
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'No, this code is not lovely. But it’s good enough to explain how tests work.
    To run this code, we can do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这段代码并不优美。但它足以解释测试是如何工作的。要运行此代码，我们可以这样做：
- en: Open the command line and type an empty string.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行并输入一个空字符串。
- en: Add an entry under package.json’s `"scripts"` entry under `"test"` to execute
    `"node` `mytest.js"` and then execute `npm` `test` on the command line.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 package.json 的 `"scripts"` 条目下添加一个条目 `"test"`，以执行 `"node mytest.js"`，然后在命令行上执行
    `npm test`。
- en: The following listing shows this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了这一点。
- en: Listing 1.5 The beginning of our package.json file
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.5 我们 package.json 文件的开头
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The test method invokes the *production module* (the SUT) and then checks the
    returned value. If it’s not what’s expected, the test method writes to the console
    an error and a stack trace. The test method also catches any exceptions that occur
    and writes them to the console, so that they don’t interfere with the running
    of subsequent methods. When we use a test framework, that’s usually handled for
    us automatically.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法调用 *生产模块*（SUT）并检查返回的值。如果不是预期的值，测试方法将错误和堆栈跟踪写入控制台。测试方法还会捕获发生的任何异常并将它们写入控制台，这样它们就不会干扰后续方法的运行。当我们使用测试框架时，这通常会被自动处理。
- en: Obviously, this is an ad hoc way of writing such a test. If you were to write
    multiple tests like this, you might want to have a generic `test` or `check` method
    that all tests could use, and which would format the errors consistently. You
    could also add special helper methods that would check on things like null objects,
    empty strings, and so on, so that you don’t need to write the same long lines
    of code in many tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一种编写此类测试的临时方法。如果你要编写多个这样的测试，你可能希望有一个通用的 `test` 或 `check` 方法，所有测试都可以使用，并且可以一致地格式化错误。你还可以添加特殊的辅助方法，用于检查诸如空对象、空字符串等事物，这样你就不需要在多个测试中编写相同的冗长代码行。
- en: The following listing shows what this test would look like with a slightly more
    generic `check` and `assertEquals` functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了使用稍微更通用的 `check` 和 `assertEquals` 函数的测试看起来会是什么样子。
- en: Listing 1.6 Using a more generic implementation of the `Check` method
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.6 使用 `Check` 方法的更通用实现
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ve now created two helper methods: `assertEquals`, which removes boilerplate
    code for writing to the console or throwing errors, and `check`, which takes a
    string for the name of the test and a callback to the implementation. It then
    takes care of catching any test errors, writing them to the console, and reporting
    on the status of the test.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了两个辅助方法：`assertEquals`，它消除了写入控制台或抛出错误的样板代码，以及 `check`，它接受一个字符串作为测试的名称和一个回调到实现。然后它负责捕获任何测试错误，将它们写入控制台，并报告测试的状态。
- en: Built-in asserts
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内置断言
- en: It’s important to note that we don’t need to write our own asserts. We could
    have easily used Node.js’s built-in assert functions, which were originally built
    for internal use in testing Node.js itself. We could do so by importing the functions
    with
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们不需要编写自己的断言。我们可以很容易地使用Node.js的内置断言函数，这些函数最初是为测试Node.js本身而内部构建的。我们可以通过导入函数来实现这一点：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, I’m trying to demonstrate the underlying simplicity of the concept,
    so we’ll avoid that. You can find more info about Node.js’s `assert` module at
    [https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我正在尝试展示这个概念背后的简单性，所以我们将会避免这一点。你可以在[https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html)找到更多关于Node.js的`assert`模块的信息。
- en: 'Notice how the tests are easier to read and faster to write with just a couple
    of helper methods. Unit testing frameworks such as Jest can provide even more
    generic helper methods like this, so tests are even easier to write. I’ll talk
    about that in chapter 2\. First, let’s talk a bit about the main subject of this
    book: good unit tests.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用几个辅助方法，测试变得更容易阅读和编写。像Jest这样的单元测试框架可以提供更多这样的通用辅助方法，从而使测试更容易编写。我将在第2章中讨论这一点。首先，让我们谈谈本书的主要主题：好的单元测试。
- en: 1.7 Characteristics of a good unit test
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 一个好的单元测试的特点
- en: No matter what programming language you’re using, one of the most difficult
    aspects of defining a unit test is defining what’s meant by a *good* one. Of course,
    good is relative, and it can change whenever we learn something new about coding.
    That may seem obvious, but it really isn’t. I need to explain *why* we need to
    write better tests—understanding what a unit of work is isn’t enough.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么编程语言，定义单元测试最困难的方面之一就是定义什么是“好的”。当然，好是相对的，并且每当我们对编码有新的了解时，它都可能发生变化。这看起来可能很明显，但实际上并不是。我需要解释为什么我们需要编写更好的测试——仅仅理解工作单元是什么是不够的。
- en: Based on my own experience, involving many companies and teams over the years,
    most people who try to unit test their code either give up at some point or don’t
    actually perform unit tests. They waste a lot of time writing problematic tests,
    and they give up when they have to spend a lot of time maintaining them, or worse,
    they don’t trust their results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我多年的经验，涉及许多公司和团队，大多数试图对代码进行单元测试的人要么在某一点上放弃，要么实际上并没有进行单元测试。他们浪费了很多时间编写有问题的测试，当需要花费大量时间维护它们时，他们会放弃，或者更糟糕的是，他们不相信测试结果。
- en: There’s no point in writing a bad unit test, unless you’re in the process of
    learning how to write a good one. There are more downsides than upsides to writing
    bad tests, such as wasting time debugging buggy tests, wasting time writing tests
    that bring no benefit, wasting time trying to understand unreadable tests, and
    wasting time writing tests only to delete them a few months later. There’s also
    a huge issue with maintaining bad tests, and with how they affect the maintainability
    of production code. Bad tests can actually slow down your development speed, not
    only when writing test code, but also when writing production code. I’ll touch
    on all these things later in the book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个糟糕的单元测试是没有意义的，除非你正处于学习如何编写一个好的单元测试的过程中。编写糟糕的测试的缺点比优点多，比如浪费时间调试有缺陷的测试，浪费时间编写没有带来任何好处的测试，浪费时间试图理解难以阅读的测试，以及浪费时间编写几个月后就会删除的测试。维护糟糕的测试也存在巨大的问题，以及它们如何影响生产代码的可维护性。糟糕的测试实际上会减慢你的开发速度，不仅是在编写测试代码时，而且在编写生产代码时也是如此。我将在本书的后面部分讨论所有这些内容。
- en: By learning what a good unit test is, you can be sure you aren’t starting off
    on a path that will be hard to fix later on, when the code becomes a nightmare.
    We’ll also define other forms of tests (component, end to end, and more) later
    in the book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解什么是好的单元测试，你可以确保你不会走上一个以后难以修复的道路，当代码变成噩梦时。我们还会在本书的后面部分定义其他形式的测试（组件测试、端到端测试等）。
- en: 1.7.1 What is a good unit test?
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.1 什么是好的单元测试？
- en: 'Every good automated test (not just unit tests) should have the following properties:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个好的自动化测试（不仅仅是单元测试）都应该具备以下特性：
- en: It should be easy to understand the intent of the test author.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该很容易理解测试作者的意图。
- en: It should be easy to read and write.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该易于阅读和编写。
- en: It should be automated.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是自动化的。
- en: It should be consistent in its results (it should always return the same result
    if you don’t change anything between runs).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的结果应该是一致的（如果你在运行之间没有改变任何东西，它应该总是返回相同的结果）。
- en: It should be useful and provide actionable results.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是有用的，并提供可操作的结果。
- en: Anyone should be able to run it with the push of a button.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以通过按按钮来运行它。
- en: When it fails, it should be easy to detect what was expected and determine how
    to pinpoint the problem.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它失败时，应该很容易检测到预期的内容，并确定如何定位问题。
- en: 'A good unit test should also exhibit the following properties:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的单元测试还应具备以下特性：
- en: It should run quickly.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该运行得快。
- en: It should have *full control* of the code under test (more on that in chapter
    3).
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该对被测试的代码拥有*完全控制权*（更多内容请见第3章）。
- en: It should be fully isolated (run independently of other tests).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是完全隔离的（独立于其他测试运行）。
- en: It should run in memory without requiring system files, networks, or databases.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该在内存中运行，而不需要系统文件、网络或数据库。
- en: It should be as synchronous and linear as possible when that makes sense (no
    parallel threads if we can help it).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这样做有意义时，它应该尽可能同步和线性（如果可能的话，不要使用并行线程）。
- en: It’s impossible for all tests to follow the properties of a good unit test,
    and that’s fine. Such tests will simply transition to the realm of integration
    testing (the topic of section 1.8). Still, there are ways to refactor some of
    your tests to conform to these properties.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有测试都能遵循良好单元测试的特性，这是完全可以接受的。这样的测试将简单地过渡到集成测试的领域（第1.8节的主题）。尽管如此，仍然有方法可以将一些测试重构为符合这些特性。
- en: Replacing the database (or another dependency) with a stub
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 用存根替换数据库（或另一个依赖项）
- en: We’ll discuss stubs in later chapters, but, in short, they are fake dependencies
    that emulate the real ones. Their purpose is to simplify the process of testing
    because they are easier to set up and maintain.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中讨论存根，但简而言之，它们是模拟真实依赖项的假依赖项。它们的目的在于简化测试过程，因为它们更容易设置和维护。
- en: Beware of in-memory databases, though. They can help you isolate tests from
    each other (as long as you don’t share database instances between tests) and thus
    adhere to the properties of good unit tests, but such databases lead to an awkward,
    in-between spot. In-memory databases aren’t as easy to set up as stubs. At the
    same time, they don’t provide as strong guarantees as real databases. Functionality-wise,
    an in-memory database may differ drastically from the production one, so tests
    that pass an in-memory database may fail the real one, and vice versa. You’ll
    often have to rerun the same tests manually against the production database to
    gain additional confidence that your code works. Unless you use a small and standardized
    set of SQL features, I recommend sticking to either stubs (for unit tests) or
    real databases (for integration testing).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，要小心内存数据库。它们可以帮助你将测试彼此隔离（只要测试之间不共享数据库实例），从而遵守良好单元测试的特性，但这样的数据库会导致一个尴尬的中间地带。内存数据库不像存根那样容易设置。同时，它们也不提供像真实数据库那样的强保证。在功能上，内存数据库可能与生产环境中的数据库大相径庭，因此通过内存数据库通过的测试可能会在真实数据库中失败，反之亦然。你通常需要手动对生产数据库重新运行相同的测试，以获得额外的信心，确保你的代码是有效的。除非你使用一组小型和标准化的SQL功能，否则我建议坚持使用存根（用于单元测试）或真实数据库（用于集成测试）。
- en: The same is true for solutions like jsdom. You can use it to replace the real
    DOM, but make sure it supports your particular use cases. Don’t write tests that
    require you to manually recheck them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像jsdom这样的解决方案也是如此。你可以用它来替换真实的DOM，但请确保它支持你的特定用例。不要编写需要手动重新检查的测试。
- en: Emulating asynchronous processing with linear, synchronous tests
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性、同步测试模拟异步处理
- en: With the advent of promises and `async/await`, asynchronous coding has become
    standard in JavaScript. Our tests can still verify asynchronous code synchronously,
    though. Usually that means triggering callbacks directly from the test or explicitly
    waiting for an asynchronous operation to finish executing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着承诺（promises）和`async/await`的出现，异步编程已成为JavaScript的标准。尽管如此，我们的测试仍然可以同步验证异步代码。通常这意味着直接从测试中触发回调或显式等待异步操作完成执行。
- en: 1.7.2 A unit test checklist
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7.2 单元测试清单
- en: 'Many people confuse the act of testing their software with the concept of a
    unit test. To start off, ask yourself the following questions about the tests
    you’ve written and executed up to now:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人混淆了测试软件的行为与单元测试的概念。首先，请自问以下关于你迄今为止编写和执行的测试的问题：
- en: Can I run and get results from a test I wrote two weeks or months or years ago?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我能否运行并从两个月或几个月或几年前我编写的测试中获得结果？
- en: Can any member of my team run and get results from tests I wrote two months
    ago?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的团队成员中是否有人能运行并从两个月前我编写的测试中获得结果？
- en: Can I run all the tests I’ve written in no more than a few minutes?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我能否在几分钟内运行我编写的所有测试？
- en: Can I run all the tests I’ve written at the push of a button?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我能否按一下按钮就运行我编写的所有测试？
- en: Can I write a basic test in no more than a few minutes?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我能否在几分钟内编写一个基本的测试？
- en: Do my tests pass when there are bugs in another team’s code?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当另一个团队的代码中存在错误时，我的测试是否通过？
- en: Do my tests show the same results when run on different machines or environments?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的机器或环境中运行我的测试结果是否相同？
- en: Do my tests stop working if there’s no database, network, or deployment?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有数据库、网络或部署，我的测试是否停止工作？
- en: If I delete, move, or change one test, do other tests remain unaffected?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我删除、移动或更改一个测试，其他测试是否不受影响？
- en: If you answered “no” to any of these questions, there’s a high probability that
    what you’re implementing either isn’t fully automated or it isn’t a unit test.
    It’s definitely *some* kind of test, and it might be as important as a unit test,
    but it has drawbacks compared to tests that would let you answer yes to all of
    those questions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些问题的任何一个回答了“不”，那么你正在实施的内容很可能既不是完全自动化的，也不是单元测试。它肯定是一种测试，可能和单元测试一样重要，但与那些能让你对所有这些问题都回答“是”的测试相比，它有缺点。
- en: “What was I doing until now?” you might ask. You’ve been doing integration testing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: “我之前都在做什么？”你可能会问。你一直在做集成测试。
- en: 1.8 Integration tests
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 集成测试
- en: I consider *integration tests* to be any tests that don’t live up to one or
    more of the conditions outlined previously for good unit tests. For example, if
    the test uses the real network, the real rest APIs, the real system time, the
    real filesystem, or a real database, it has stepped into the realm of integration
    testing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为**集成测试**是指不符合之前概述的任何一个或多个良好单元测试条件的任何测试。例如，如果测试使用了真实的网络、真实的REST API、真实系统时间、真实文件系统或真实数据库，那么它已经进入了集成测试的领域。
- en: If a test doesn’t have control of the system time, for example, and it uses
    the current `new` `Date()` in the test code, then every time the test executes,
    it’s essentially a different test because it uses a different time. It’s no longer
    consistent. That’s not a bad thing per se. I think integration tests are important
    counterparts to unit tests, but they should be separated from them to achieve
    a feeling of “safe green zone,” which is discussed later in this book.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试没有控制系统时间，例如，在测试代码中使用当前的`new` `Date()`，那么每次测试执行时，它本质上都是不同的测试，因为它使用了不同的时间。它不再是一致的。这本身并不是坏事。我认为集成测试是单元测试的重要补充，但它们应该分开，以实现“安全绿色区域”的感觉，这在本书的后面会讨论。
- en: If a test uses the real database, it’s no longer only running in memory—its
    actions are harder to erase than when using only in-memory fake data. The test
    will also run longer, and we won’t easily be able to control how long data access
    takes. Unit tests should be *fast*. Integration tests are usually much slower.
    When you start having hundreds of tests, every half-second counts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试使用了真实数据库，它就不再是仅在内存中运行了——它的操作比仅使用内存中的模拟数据更难擦除。测试也将运行得更长，我们不容易控制数据访问所需的时间。单元测试应该是**快速**的。集成测试通常要慢得多。当你开始有成百上千个测试时，每一半秒都很重要。
- en: 'Integration tests increase the risk of another problem: testing too many things
    at once. For example, suppose your car breaks down. How do you learn what the
    problem is, let alone fix it? An engine consists of many subsystems working together,
    each relying on the others to help produce the final result: a moving car. If
    the car stops moving, the fault could be with any of the subsystems—or with more
    than one. It’s the integration of those subsystems (or layers) that makes the
    car move. You could think of the car’s movement as the ultimate integration test
    of these parts as the car goes down the road. If the test fails, all the parts
    fail together; if it succeeds, all the parts succeed.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试增加了另一个问题的风险：一次测试太多东西。例如，假设你的车坏了。你是如何学习问题的，更不用说修复它了？发动机由许多子系统组成，它们共同工作，每个子系统都依赖其他子系统来帮助产生最终结果：一辆行驶的汽车。如果汽车停止移动，故障可能是任何子系统，或者多个子系统。这些子系统的集成（或层）使汽车移动。你可以把汽车的运动看作是这些部件在汽车下路的最终集成测试。如果测试失败，所有部件一起失败；如果成功，所有部件都成功。
- en: The same thing happens in software. The way most developers test their functionality
    is through the final functionality of the app or REST API or UI. Clicking some
    button triggers a series of events—functions, modules, and components working
    together to produce the final result. If the test fails, all of these software
    components fail as a team, and it can be difficult to figure out what caused the
    failure of the overall operation (see figure 1.7).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，大多数开发者测试功能的方式是通过应用或REST API或UI的最终功能。点击某个按钮会触发一系列事件——函数、模块和组件协同工作以产生最终结果。如果测试失败，所有这些软件组件作为一个团队失败，可能很难找出导致整体操作失败的原因（见图1.7）。
- en: '![01-07](../Images/01-07.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![01-07](../Images/01-07.png)'
- en: Figure 1.7 You can have many failure points in an integration test. All the
    units have to work together, and each could malfunction, making it harder to find
    the source of a bug.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 在集成测试中，你可以有多个故障点。所有单元都必须协同工作，每个单元都可能出现故障，这使得找到错误源更加困难。
- en: 'As defined in *The Complete Guide to Software Testing* by Bill Hetzel (Wiley,
    1988), integration testing is “an orderly progression of testing in which software
    and/or hardware elements are combined and tested until the entire system has been
    integrated.” Here’s my own variation on defining integration testing:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据比尔·赫塞尔（Bill Hetzel）在《软件测试完全指南》（Wiley, 1988）中的定义，集成测试是“一种有序的测试进展，其中软件和/或硬件元素被组合并测试，直到整个系统被集成。”以下是我自己对集成测试定义的变体：
- en: Integration testing is testing a unit of work without having full control over
    all of its real dependencies, such as other components by other teams, other services,
    the time, the network, databases, threads, random number generators, and more.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是在没有完全控制所有真实依赖项的情况下测试一个工作单元，这些依赖项可能包括其他团队的其他组件、其他服务、时间、网络、数据库、线程、随机数生成器等等。
- en: To summarize, an integration test uses real dependencies; unit tests isolate
    the unit of work from its dependencies so that they’re easily consistent in their
    results and can easily control and simulate any aspect of the unit’s behavior.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，集成测试使用真实依赖项；单元测试将工作单元与其依赖项隔离，以便它们的结果容易保持一致，并且可以轻松控制和模拟单元行为的任何方面。
- en: 'Let’s apply the questions from section 1.7.2 to integration tests and consider
    what you want to achieve with real-world unit tests:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将1.7.2节中的问题应用到集成测试中，并考虑你在现实世界的单元测试中想要实现的目标：
- en: '*Can I run and get results from a test I wrote two weeks or months or years
    ago?*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我能否运行并从两周、几个月或几年前写的测试中获得结果？*'
- en: If you can’t, how would you know whether you broke a feature that you created
    earlier? Shared data and code changes regularly during the life of an application,
    and if you can’t (or won’t) run tests for all the previously working features
    after changing your code, you just might break it without knowing—this is known
    as a *regression*. Regressions seem to occur a lot near the end of a sprint or
    release, when developers are under pressure to fix existing bugs. Sometimes they
    introduce new bugs inadvertently as they resolve old ones. Wouldn’t it be great
    to know that you broke something within 60 seconds of breaking it? You’ll see
    how that can be done later in this book.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不能，你将如何知道你是否破坏了你之前创建的功能？共享数据和代码在应用程序的生命周期中会定期更改，如果你不能（或不愿意）在更改代码后为所有之前工作的功能运行测试，你可能会在不了解的情况下破坏它——这被称为*回归*。回归似乎在冲刺或发布的最后阶段发生得很多，当时开发者们面临着修复现有错误的压力。有时，他们在解决旧错误时无意中引入了新的错误。知道你在60秒内破坏了某物不是很好吗？你将在本书的后面部分看到如何做到这一点。
- en: Definition A *regression* is broken functionality—code that used to work. You
    can also think of it as one or more units of work that once worked and now don’t.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 定义A：*回归*是指损坏的功能——曾经工作过的代码。你也可以将其视为一个或多个曾经工作但现在不工作的工作单元。
- en: '*Can any member of my team run and get results from tests I wrote two months
    ago?*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我的团队能否运行并从两个月前我写的测试中获得结果？*'
- en: This goes with the previous point but takes it up a notch. You want to make
    sure that you don’t break someone else’s code when you change something. Many
    developers fear changing legacy code in older systems for fear of not knowing
    what other code depends on what they’re changing. In essence, they risk changing
    the system into an unknown state of stability.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与上一个观点相关，但更进一步。你想要确保在更改某些内容时不会破坏他人的代码。许多开发者害怕更改旧系统中的遗留代码，因为他们不知道他们更改的代码依赖于什么其他代码。本质上，他们冒着将系统改变到一个未知稳定状态的风险。
- en: Few things are scarier than not knowing whether the application still works,
    especially when you didn’t write that code. If you have that safety net of unit
    tests and know you aren’t breaking anything, you’ll be much less afraid of taking
    on code you’re less familiar with.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有什么事情比不知道应用程序是否仍然工作更令人害怕的，尤其是当你没有编写那段代码的时候。如果你有单元测试的安全网，并且知道你没有破坏任何东西，那么你对处理不太熟悉的代码就会少很多恐惧。
- en: Good tests can be accessed and run by anyone.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的测试可以被任何人访问和运行。
- en: 'Definition *Legacy code* is defined by Wikipedia as “old computer source code
    that is no longer supported on the standard hardware and environments” ([https://en.wikipedia.org/wiki/Legacy_system](https://en.wikipedia.org/wiki/Legacy_system)),
    but many shops refer to any older version of the application currently under maintenance
    as legacy code. It often refers to code that’s hard to work with, hard to test,
    and usually even hard to read. A client once defined legacy code in a down-to-earth
    way: “code that works.” Many people like to define legacy code as “code that has
    no tests.” *Working Effectively with Legacy Code* by Michael Feathers (Pearson,
    2004) uses “code that has no tests” as an official definition of legacy code,
    and it’s a definition to be considered while reading this book.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*遗留代码*被维基百科定义为“不再在标准硬件和环境上得到支持的旧计算机源代码”([https://en.wikipedia.org/wiki/Legacy_system](https://en.wikipedia.org/wiki/Legacy_system))，但许多商店将当前维护的任何旧版本应用程序称为遗留代码。这通常指的是难以工作、难以测试，通常甚至难以阅读的代码。一位客户曾经用一种接地气的方式定义遗留代码：“能工作的代码。”许多人喜欢将遗留代码定义为“没有测试的代码”。Michael
    Feathers的《*与遗留代码有效协作*》（Pearson，2004）将“没有测试的代码”作为遗留代码的官方定义，这是在阅读这本书时需要考虑的定义。
- en: '*Can I run all the tests I’ve written in no more than a few minutes?*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我能在几分钟内运行我写的所有测试吗？*'
- en: If you can’t run your tests quickly (seconds are better than minutes), you’ll
    run them less often (daily, or even weekly or monthly in some places). The problem
    is that when you change code, you want to get feedback as early as possible to
    see if you broke something. The more time required between running the tests,
    the more changes you make to the system, and the (many) more places you’ll have
    to search for bugs when you find that you broke something.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不能快速运行你的测试（秒比分钟好），你将更少地运行它们（每天，甚至在某些地方每周或每月）。问题是当你更改代码时，你希望尽早得到反馈，以查看你是否破坏了某些东西。运行测试所需的时间越长，你对系统进行的更改就越多，当你发现你破坏了某些东西时，你将不得不查找（许多）更多的地方来寻找错误。
- en: Good tests should run *quickly*.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的测试应该运行得*很快*。
- en: '*Can I run all the tests I’ve written at the push of a button?*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我能否按一下按钮就能运行我写的所有测试？*'
- en: If you can’t, it probably means that you have to configure the machine on which
    the tests will run so that they run correctly (setting up a Docker environment,
    or setting connection strings to the database, for example), or it may mean that
    your unit tests aren’t fully automated. If you can’t fully automate your unit
    tests, you’ll probably avoid running them repeatedly, as will everyone else on
    your team.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你做不到，这可能意味着你必须配置测试运行的机器，以确保它们能够正确运行（例如设置Docker环境，或设置数据库的连接字符串），或者这可能意味着你的单元测试并没有完全自动化。如果你不能完全自动化你的单元测试，你可能会避免反复运行它们，你的团队中的其他人也会这样做。
- en: No one likes to get bogged down with configuring details to run tests, just
    to make sure that the system still works. Developers have more important things
    to do, like writing more features into the system. But they can’t do that if they
    don’t know the state of the system.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有人喜欢被配置细节拖累，只是为了确保系统仍然工作。开发者有更重要的事情要做，比如将更多功能写入系统。但如果你不知道系统的状态，他们就不能这样做。
- en: Good tests should be easily executed in their original form, not manually.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的测试应该能够以它们原始的形式轻松执行，而不是手动执行。
- en: '*Can I write a basic test in no more than a few minutes?*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我能在几分钟内写一个基本的测试吗？*'
- en: One of the easiest ways to spot an integration test is that it takes time to
    prepare correctly and to implement, not just to execute. It takes time to figure
    out how to write it because of all the internal, and sometimes external, dependencies.
    (A database may be considered an external dependency.) If you’re not automating
    the test, dependencies are less of a problem, but you’re losing all the benefits
    of an automated test. The harder it is to write a test, the less likely you are
    to write more tests or to focus on anything other than the “big stuff” that you’re
    worried about. One of the strengths of unit tests is that they tend to test every
    little thing that might break, not only the big stuff. People are often surprised
    at how many bugs they can find in code they thought was simple and bug free.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 识别集成测试的一种简单方法就是它需要花费时间来正确准备和实施，而不仅仅是执行。由于所有内部和有时外部的依赖关系，编写它的方法也需要时间。例如，数据库可能被视为外部依赖。）如果你没有自动化测试，依赖关系就不再是问题，但你正在失去自动化测试的所有好处。编写测试越困难，你编写更多测试或专注于除你担心的“重要事项”之外的事情的可能性就越小。单元测试的一个优点是它们往往会测试可能出错的每一个小细节，而不仅仅是重要事项。人们常常惊讶于他们可以在看似简单且无错误的代码中找到多少错误。
- en: When you concentrate only on the big tests, the overall confidence in your code
    is still very much lacking. Many parts of the code’s core logic aren’t tested
    (even though you may be covering more components), and there may be many bugs
    that you haven’t considered and might be “unofficially” worried about.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你只关注大型测试时，你对代码的整体信心仍然非常不足。代码的核心逻辑的许多部分都没有经过测试（即使你可能覆盖了更多组件），并且可能存在许多你没有考虑过且可能“非正式”担忧的错误。
- en: Good tests against the system should be easy and quick to write, once you’ve
    figured out the patterns you want to use to test your specific set of objects,
    functions, and dependencies (the *domain model*).
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你确定了想要用来测试你特定的对象集、函数和依赖关系（*领域模型*）的模式，针对系统的良好测试应该很容易编写，也很快速。
- en: '*Do my tests pass when there are bugs in another team’s code? Do my tests show
    the same results when run on different machines or environments? Do my tests stop
    working if there’s no database, network, or deployment?*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*当另一个团队的代码中有错误时，我的测试是否通过？在不同的机器或环境中运行时，我的测试结果是否相同？如果没有数据库、网络或部署，我的测试是否停止工作？*'
- en: These three points refer to the idea that our test code is isolated from various
    dependencies. The test results are consistent because we have control over what
    those indirect inputs into our system provide. We can have fake databases, fake
    networks, fake time, and fake machine culture. In later chapters, I’ll refer to
    those points as *stubs* and *seams* in which we can inject those stubs.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这三点指的是我们的测试代码与各种依赖关系隔离的想法。测试结果是一致的，因为我们控制了那些间接输入到我们系统中的内容。我们可以有假数据库、假网络、假时间和假机器文化。在后面的章节中，我将把这些点称为*存根*和*接口*，我们可以在这里注入这些存根。
- en: '*If I delete, move, or change one test, do other tests remain unaffected?*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果我删除、移动或更改一个测试，其他测试是否仍然不受影响？*'
- en: Unit tests usually don’t need to have any shared state, but integration tests
    often do, such as an external database or service. Shared state can create a dependency
    between tests. For example, running tests in the wrong order can corrupt the state
    for future tests.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元测试通常不需要任何共享状态，但集成测试通常需要，例如外部数据库或服务。共享状态可以在测试之间创建依赖关系。例如，以错误的顺序运行测试可能会破坏未来测试的状态。
- en: WARNING Even experienced unit testers can find that it may take 30 minutes or
    more to figure out how to write the very *first* unit test against a domain model
    they’ve never unit tested before. This is part of the work and is to be expected.
    The second and subsequent tests on that domain model should be very easy to accomplish
    once you’ve figured out the entry and exit points of the unit of work.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告** 即使经验丰富的单元测试人员也可能发现，编写针对他们之前从未进行过单元测试的领域模型的第一个单元测试可能需要30分钟或更长时间。这是工作的一部分，是可以预料的。一旦你确定了单元工作的入口和出口点，对该领域模型的第二次和随后的测试应该很容易完成。'
- en: 'We can recognize three main criteria in the previous questions and answers:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前的问题和答案中识别出三个主要标准：
- en: '*Readability*—If we can’t read it, then it’s hard to maintain, hard to debug,
    and hard to know what’s wrong.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可读性*——如果我们无法阅读它，那么维护它、调试它和了解出了什么问题都变得很困难。'
- en: '*Maintainability*—If maintaining the test or production code is painful because
    of the tests, our lives will become a living nightmare.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*——如果维护测试或生产代码因为测试而痛苦，我们的生活将变成一个活生生的噩梦。'
- en: '*Trust*—If we don’t trust the results of our tests when they fail, we’ll start
    manually testing again, losing all the time benefit the tests are supposed to
    provide. If we don’t trust the tests when they *pass*, we’ll start debugging more,
    again losing any time benefit.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信任*——如果我们不相信测试失败的结果，我们将开始手动测试，从而失去测试本应提供的所有时间效益。如果我们不相信测试通过的结果，我们将开始进行更多的调试，再次失去任何时间效益。'
- en: 'From what I’ve explained so far about what a unit test is not and what features
    need to be present for testing to be useful, I can now start to answer the primary
    question this chapter poses: what is a good unit test?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我到目前为止关于单元测试不是什么以及测试要有效需要具备哪些特性的解释，我现在可以开始回答本章提出的主要问题：什么是好的单元测试？
- en: 1.9 Finalizing our definition
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9 完善我们的定义
- en: 'Now that I’ve covered the important properties that a unit test should have,
    I’ll define unit tests once and for all:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经介绍了单元测试应该具备的重要属性，我将一次性定义单元测试：
- en: A unit test is an automated piece of code that invokes the unit of work through
    an entry point and then checks one of its exit points. A unit test is almost always
    written using a unit testing framework. It can be written easily and runs quickly.
    It’s trustworthy, readable, and maintainable. It is consistent as long as the
    production code we control has not changed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一段自动化的代码，它通过一个入口点调用工作单元，然后检查其出口点之一。单元测试几乎总是使用单元测试框架编写的。它编写起来容易，运行速度快。它是可信的、可读的和可维护的。只要我们控制的生成代码没有变化，它就是一致的。
- en: This definition certainly looks like a tall order, particularly considering
    how many developers implement unit tests poorly. It makes us take a hard look
    at the way we, as developers, have implemented testing up until now, compared
    to how we’d like to implement it. (Trustworthy, readable, and maintainable tests
    are discussed in depth in chapters 7 through 9.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义显然要求很高，尤其是考虑到许多开发者实施单元测试的方式不佳。这让我们不得不认真审视我们作为开发者至今为止实施测试的方式，以及我们希望如何实施测试。（在第7章至第9章中深入讨论了可信、可读和可维护的测试。）
- en: In the first edition of this book, my definition of a unit test was slightly
    different. I used to define a unit test as “only running against control flow
    code,” but I no longer think that’s true. Code without logic is usually used as
    part of a unit of work. Even properties with no logic will get used by a unit
    of work, so they don’t have to be specifically targeted by tests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，我对单元测试的定义略有不同。我过去将单元测试定义为“仅针对控制流代码运行”，但我不这么认为。没有逻辑的代码通常用作工作单元的一部分。即使没有逻辑的属性也会被工作单元使用，因此它们不需要被测试专门针对。
- en: 'Definition *Control flow code* is any piece of code that has some sort of logic
    in it, small as it may be. It has one or more of the following: an `if` statement,
    a loop, calculations, or any other type of decision-making code.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *控制流代码* 是指任何包含某种逻辑的代码片段，无论其逻辑多么简单。它包含以下之一或多个：一个 `if` 语句、一个循环、计算或任何其他类型的决策代码。
- en: 'Getters and setters are good examples of code that usually doesn’t contain
    any logic and so don’t require specific targeting by the tests. It’s code that
    will probably get used by the unit of work you’re testing, but there’s no need
    to test it directly. But watch out: once you add any logic inside a getter or
    setter, you’ll want to make sure that logic is being tested.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器是代码的好例子，通常不包含任何逻辑，因此不需要测试专门针对。这是可能会被你测试的工作单元使用的代码，但不需要直接测试它。但要注意：一旦你在获取器或设置器中添加任何逻辑，你将想要确保该逻辑正在被测试。
- en: In the next section, we’ll stop talking about what is a good test and talk about
    *when* you might want to write tests. I’ll discuss test-driven development, because
    it is often put in the same bucket as doing unit testing. I want to make sure
    we set the record straight on that.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将停止讨论什么是好的测试，而是讨论 *何时* 你可能想要编写测试。我将讨论测试驱动开发，因为它经常与进行单元测试放在一起。我想确保我们在这方面记录准确。
- en: 1.10 Test-driven development
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10 测试驱动开发
- en: Once you know how to write readable, maintainable, and trustworthy tests with
    a unit testing framework, the next question is *when* to write the tests. Many
    people feel that the best time to write unit tests for software is after they’ve
    created some functionality and just before they merge their code into remote source
    control.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你学会了如何使用单元测试框架编写可读、可维护和可信的测试，下一个问题就是 *何时* 编写测试。许多人认为编写软件单元测试的最佳时间是创建了一些功能之后，但在将代码合并到远程源控制之前。
- en: Also, to be a bit blunt, a lot of people don’t believe writing tests is a good
    idea, but have realized through trial and error that there are strict testing
    requirements in source control reviews, so they *have* to write tests to appease
    the code review gods and get their code merged into the main branch. (That kind
    of dynamic is a great source of bad tests, and I’ll address it in the third part
    of this book.)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，坦白说，很多人不相信编写测试是一个好主意，但通过反复试验，他们意识到源代码审查中有严格的测试要求，所以他们*必须*编写测试来取悦代码审查之神，并将他们的代码合并到主分支中。（这种动态是产生糟糕测试的绝佳来源，我将在本书的第三部分中讨论这个问题。）
- en: A growing number of developers prefer writing unit tests incrementally, during
    the coding session and before each piece of very small functionality is implemented.
    This approach is called *test-first* or *test-driven* development (TDD).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的开发者倾向于在编码会话期间以及在每个非常小的功能实现之前逐步编写单元测试。这种方法被称为*测试先行*或*测试驱动开发*（TDD）。
- en: Note There are many different views on exactly what test-driven development
    means. Some say it’s test-first development, and some say it means you have a
    lot of tests. Some say it’s a way of designing, and others feel it could be a
    way to drive your code’s behavior with only some design. In this book, TDD means
    test-first development, with design taking an incremental role in the technique
    (besides this section, TDD won’t be discussed in this book).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于测试驱动开发的确切含义存在许多不同的观点。有些人说它是测试先行开发，有些人说它意味着你有很多测试。有些人说它是一种设计方法，而其他人感觉它可能只是用一些设计来驱动代码行为的方法。在这本书中，TDD
    意味着测试先行开发，设计在技术中扮演着增量角色（除了本节之外，本书不会讨论 TDD）。
- en: Figures 1.8 and 1.9 show the differences between traditional coding and TDD.
    TDD is different from traditional development, as figure 1.9 shows. You begin
    by writing a test that fails; then you move on to creating the production code,
    seeing the test pass, and continuing on to either refactor your code or create
    another failing test.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 和 1.9 展示了传统编码与 TDD 之间的差异。TDD 与传统开发不同，如图 1.9 所示。你首先编写一个失败的测试；然后继续创建生产代码，看到测试通过，并继续重构你的代码或创建另一个失败的测试。
- en: '![01-08](../Images/01-08.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![01-08](../Images/01-08.png)'
- en: Figure 1.8 The traditional way of writing unit tests
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 传统编写单元测试的方式
- en: '![01-09](../Images/01-09.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![01-09](../Images/01-09.png)'
- en: 'Figure 1.9 Test-driven development—a bird’s-eye view. Notice the circular nature
    of the process: write the test, write the code, refactor, write the next test.
    It shows the incremental nature of TDD: small steps lead to a quality end result
    with confidence.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 测试驱动开发——鸟瞰图。注意过程的循环性：编写测试，编写代码，重构，编写下一个测试。它展示了 TDD 的增量特性：小步骤带来有信心的高质量最终结果。
- en: This book focuses on the technique of writing good unit tests, rather than on
    TDD, but I’m a big fan of TDD. I’ve written several major applications and frameworks
    using TDD, I’ve managed teams that utilize it, and I’ve taught hundreds of courses
    and workshops on TDD and unit testing techniques. Throughout my career, I’ve found
    TDD to be helpful in creating quality code, quality tests, and better designs
    for the code I was writing. I’m convinced that it can work to your benefit, but
    it’s not without a price (time to learn, time to implement, and more). It’s definitely
    worth the admission price, though, if you’re willing to take on the challenge
    of learning it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本书侧重于编写良好单元测试的技术，而不是 TDD，但我对 TDD 非常推崇。我使用 TDD 编写了好几个主要的应用程序和框架，我管理过使用它的团队，我还教授了数百门关于
    TDD 和单元测试技术的课程和工作坊。在我的整个职业生涯中，我发现 TDD 有助于创建高质量的代码、高质量的测试以及我编写的代码的更好设计。我相信它对你有益，但它并非没有代价（学习时间、实施时间以及更多）。不过，如果你愿意接受学习它的挑战，这绝对物有所值。
- en: '1.10.1 TDD: Not a substitute for good unit tests'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.10.1 TDD：不是良好单元测试的替代品
- en: 'It’s important to realize that TDD doesn’t ensure project success or tests
    that are robust or maintainable. It’s quite easy to get caught up in the technique
    of TDD and not pay attention to the way unit tests are written: their naming,
    how maintainable or readable they are, and whether they test the right things
    or might themselves have bugs. That’s why I’m writing this book—because writing
    good tests is a separate skill from TDD.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，TDD 并不能保证项目成功或测试的健壮性或可维护性。很容易陷入 TDD 技术的陷阱，而忽略了单元测试的编写方式：它们的命名、可维护性或可读性，以及它们是否测试了正确的事物或可能自身存在错误。这就是我写这本书的原因——因为编写良好的测试是一项与
    TDD 不同的技能。
- en: 'The technique of TDD is quite simple:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的技术非常简单：
- en: '*Write a failing test to prove code or functionality is missing from the end
    product.* The test is written *as if* the production code were already working,
    so the test failing means there’s a bug in the production code. How do I know?
    The test is written such that it would pass if the production code had no bugs.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编写一个失败的测试来证明最终产品中缺少代码或功能。* 这个测试是“好像”生产代码已经工作一样编写的，所以测试失败意味着生产代码中存在错误。我如何知道？这个测试是编写成如果生产代码没有错误就会通过的样子。'
- en: In some languages other than JavaScript, the test might not even compile at
    first, since the code doesn’t exist yet. Once it does run, it should be failing,
    because the production code is still not working. This is where a lot of the “design”
    in test-driven-design thinking happens.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在JavaScript之外的一些语言中，测试可能一开始甚至无法编译，因为代码还不存在。一旦它运行，它应该失败，因为生产代码还没有工作。这就是在测试驱动设计思维中发生很多“设计”的地方。
- en: '*Make the test pass by adding functionality to the production code that meets
    the expectations of your test.* The production code should be kept as simple as
    possible. Don’t touch the test. You have to make it pass only by touching production
    code.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*通过向生产代码中添加满足测试预期的新功能来使测试通过。* 生产代码应该尽可能简单。不要触摸测试。你必须只通过触摸生产代码来使其通过。'
- en: '*Refactor your code.* When the test passes, you’re free to move on to the next
    unit test or to refactor your code (both production code and tests) to make it
    more readable, to remove code duplication, and so on. This is another point where
    the “design” part happens. We refactor and can even redesign our components while
    still keeping the old functionality.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构你的代码。* 当测试通过时，你可以自由地继续下一个单元测试或重构代码（包括生产代码和测试），使其更易于阅读，移除代码重复，等等。这也是“设计”部分发生的地方。我们重构，甚至可以在保持旧功能的同时重新设计我们的组件。'
- en: Refactoring steps should be very small and incremental, and we run all the tests
    after each small step to make sure we didn’t break anything with our changes.
    Refactoring can be done after writing several tests or after writing each test.
    It’s an important practice, because it ensures your code gets easier to read and
    maintain, while still passing all of the previously written tests. There’s a whole
    section (8.3) on refactoring later in the book.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重构步骤应该非常小且逐步进行，我们在每个小步骤之后运行所有测试，以确保我们没有因为我们的更改而破坏任何东西。重构可以在编写几个测试之后或在每个测试编写之后进行。这是一个重要的实践，因为它确保你的代码更容易阅读和维护，同时仍然通过所有之前编写的测试。书中后面有一个关于重构的整个部分（8.3）。
- en: Definition *Refactoring* means changing a piece of code *without* changing its
    functionality. If you’ve ever renamed a method, you’ve done refactoring. If you’ve
    ever split a large method into multiple smaller method calls, you’ve refactored
    your code. The code still does the same thing, but it becomes easier to maintain,
    read, debug, and change.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**的定义是指在不改变其功能的情况下改变代码的一部分。如果你曾经重命名过方法，你就已经进行了重构。如果你曾经将一个大方法拆分成多个较小的方法调用，你就已经重构了你的代码。代码仍然执行相同的功能，但它变得更容易维护、阅读、调试和修改。'
- en: The preceding steps sound technical, but there’s a lot of wisdom behind them.
    Done correctly, TDD can make your code quality soar, decrease the number of bugs,
    raise your confidence in the code, shorten the time it takes to find bugs, improve
    your code’s design, and keep your manager happier. If TDD is done incorrectly,
    it can cause your project schedule to slip, waste your time, lower your motivation,
    and lower your code quality. It’s a double-edged sword, and many people find this
    out the hard way.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤听起来很技术性，但它们背后有很多智慧。如果正确执行，TDD可以使你的代码质量大幅提升，减少错误数量，提高你对代码的信心，缩短查找错误的时间，改进代码的设计，并让你的经理更加满意。如果TDD执行不当，可能会导致你的项目进度延误，浪费你的时间，降低你的动力，并降低代码质量。这是一把双刃剑，很多人都是通过艰难的方式才意识到这一点。
- en: Technically, one of the biggest benefits of TDD that nobody tells you about
    is that by seeing a test fail, and then seeing it pass without changing the test,
    you’re basically testing the test itself. If you expect it to fail and it passes,
    you might have a bug in your test or you’re testing the wrong thing. If the test
    failed, you fixed it, and now you expect it to pass, and it still fails, your
    test could have a bug, or maybe it’s expecting the wrong thing to happen.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，TDD最大的好处之一是没有人告诉您的是，通过看到测试失败，然后看到测试在没有更改的情况下通过，您实际上是在测试测试本身。如果您期望它失败而它通过了，您可能在测试中有一个错误，或者您测试了错误的东西。如果测试失败了，您修复了它，现在您期望它通过，但它仍然失败，您的测试可能有一个错误，或者它可能期望发生错误的事情。
- en: This book deals with readable, maintainable, and trustworthy tests, but if you
    add TDD on top, your confidence in your own tests will increase by seeing the
    failed, you fixed it, tests failing when they should and passing when they should.
    In test-after style, you’ll usually only see them pass when they should, and fail
    when they shouldn’t (since the code they test should already be working). TDD
    helps with that a lot, and it’s also one of the reasons developers do far less
    debugging when practicing TDD than when they’re simply unit testing after the
    fact. If they trust the tests, they don’t feel a need to debug it “just in case.”
    That’s the kind of trust you can only gain by seeing both sides of the test—failing
    when it should and passing when it should.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本书处理可读的、可维护的、值得信赖的测试，但如果您在TDD之上添加，您将看到失败的测试，您修复了它，当应该失败时测试失败，当应该通过时测试通过，您对自己测试的信心将会增加。在测试之后风格中，您通常只有在应该通过时才会看到它们通过，在不应该通过时才会失败（因为它们测试的代码应该已经工作）。TDD在这方面有很大帮助，这也是开发者为什么在实践TDD时比在事后简单地单元测试时进行更少的调试的原因之一。如果他们信任测试，他们就不会觉得有必要“以防万一”进行调试。这种信任只能通过看到测试的双方——当应该失败时失败，当应该通过时通过——来获得。
- en: 1.10.2 Three core skills needed for successful TDD
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.10.2 成功TDD所需的三项核心技能
- en: 'To be successful in test-driven development, you need three different skill
    sets: knowing how to write good tests, writing them test-first, and designing
    the tests and the production code well. Figure 1.10 shows these more clearly:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试驱动开发中取得成功，您需要三种不同的技能集：知道如何编写好的测试，以测试优先的方式编写它们，以及设计良好的测试和生产代码。图1.10更清楚地展示了这些：
- en: '*Just because you write your tests first doesn’t mean they’re maintainable,
    readable, or trustworthy.* Good unit testing skills are what this book is all
    about.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仅仅因为您先编写测试并不意味着它们是可维护的、可读的或值得信赖的。良好的单元测试技能正是本书的主题。*'
- en: '*Just because you write readable, maintainable tests doesn’t mean you’ll get
    the same benefits as when writing them test-first.* Test-first skills are what
    most of the TDD books out there teach, without teaching the skills of good testing.
    I would especially recommend Kent Beck’s *Test-Driven Development: By Example*
    (Addison-Wesley Professional, 2002).'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仅仅因为您编写了可读的、可维护的测试并不意味着您会得到与先编写测试相同的收益。测试优先的技能是大多数TDD书籍所教授的，而没有教授良好的测试技能。我特别推荐Kent
    Beck的*通过示例进行测试驱动开发*（Addison-Wesley Professional，2002年）。*'
- en: '*Just because you write your tests first, and they’re readable and maintainable,
    doesn’t mean you’ll end up with a well-designed system.* Design skills are what
    make your code beautiful and maintainable. I recommend *Growing Object-Oriented
    Software, Guided by Tests* by Steve Freeman and Nat Pryce (Addison-Wesley Professional,
    2009) and *Clean Code* by Robert C. Martin (Pearson, 2008) as good books on the
    subject.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仅仅因为您先编写测试，并且它们是可读的和可维护的，并不意味着您最终会得到一个设计良好的系统。设计技能是使您的代码美观和可维护的关键。我推荐Steve
    Freeman和Nat Pryce的*通过测试引导面向对象软件发展*（Addison-Wesley Professional，2009年）以及Robert
    C. Martin的*Clean Code*（Pearson，2008年）作为该主题的好书。*'
- en: '![01-10](../Images/01-10.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![01-10](../Images/01-10.png)'
- en: Figure 1.10 Three core skills of test-driven development
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 测试驱动开发的核心三项技能
- en: A pragmatic approach to learning TDD is to learn each of these three aspects
    separately; that is, to focus on one skill at a time, ignoring the others in the
    meantime. The reason I recommend this approach is that I often see people trying
    to learn all three skill sets at the same time, having a really hard time in the
    process, and finally giving up because the wall is too high to climb. By taking
    a more incremental approach to learning this field, you relieve yourself of the
    constant fear that you’re getting it wrong in a different area than you’re currently
    focusing on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 TDD 的实用方法是分别学习这三个方面；也就是说，一次专注于一项技能，同时忽略其他技能。我推荐这种方法的原因是，我经常看到人们试图同时学习这三个技能集，在学习过程中遇到极大的困难，最终因为障碍太高而放弃。通过采取更渐进的方法来学习这个领域，你可以减轻自己在当前关注领域之外的其他领域犯错的持续恐惧。
- en: In the next chapter, you’ll start writing your first unit tests using Jest,
    one of the most commonly used test frameworks for JavaScript.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始使用 Jest 编写你的第一个单元测试，Jest 是 JavaScript 最常用的测试框架之一。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'A good unit test has these qualities:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的单元测试具有以下特点：
- en: It should run quickly.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该运行得很快。
- en: It should have full control of the code under test.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该完全控制被测试的代码。
- en: It should be fully isolated (it should run independently of other tests).
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该完全隔离（它应该独立于其他测试运行）。
- en: It should run in memory without requiring filesystem files, networks, or databases.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该在内存中运行，无需文件系统文件、网络或数据库。
- en: It should be as synchronous and linear as possible (no parallel threads).
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该尽可能同步和线性（没有并行线程）。
- en: Entry points are public functions that are the doorways into our units of work
    and trigger the underlying logic. Exit points are the places you can inspect with
    your test. They represent the effects of the units of work.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口点是公共函数，是进入我们的工作单元的门，并触发底层逻辑。出口点是你可以用测试检查的地方。它们代表了工作单元的效果。
- en: An exit point can be a return value, a change of state, or a call to a third-party
    dependency. Each exit point usually requires a separate test, and each type of
    exit point requires a different testing technique.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个出口点可以是一个返回值、状态的变化或对第三方依赖的调用。每个出口点通常需要一个单独的测试，每种类型的出口点都需要不同的测试技术。
- en: A unit of work is the sum of actions that take place between the invocation
    of an entry point up until a noticeable end result through one or more exit points.
    A unit of work can span a function, a module, or multiple modules.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作单元是在入口点调用和通过一个或多个出口点达到一个明显的结束结果之间的所有操作的集合。工作单元可以跨越一个函数、一个模块或多个模块。
- en: Integration testing is just unit testing with some or all of the dependencies
    being real and residing outside of the current execution process. Conversely,
    unit testing is like integration testing, but with all of the dependencies in
    memory (both real and fake), and we have control over their behavior in the test.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试只是单元测试，其中一些或所有依赖项是真实的，并位于当前执行过程之外。相反，单元测试就像集成测试一样，但所有依赖项都在内存中（真实的和假的），并且我们在测试中控制它们的行为。
- en: The most important attributes of any test are readability, maintainability,
    and trust. *Readability* tells us how easy it is to read and understand the test.
    *Maintainability* is the measure of how painful it is to maintain the test code.
    Without *trust*, it’s harder to introduce important changes (such as refactoring)
    in a codebase, which leads to code deterioration.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何测试最重要的属性是可读性、可维护性和可信度。*可读性*告诉我们测试的可读性和理解难度。*可维护性*是衡量维护测试代码痛苦程度的指标。没有*可信度*，在代码库中引入重要更改（如重构）会更困难，这会导致代码退化。
- en: Test-driven development (TDD) is a technique that advocates for writing tests
    before the production code. This approach is also referred to as a test-first
    approach (as opposed to code-first).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）是一种提倡在编写生产代码之前编写测试的技术。这种方法也被称为测试优先方法（与代码优先相对）。
- en: The main benefit of TDD is verifying the correctness of your tests. Seeing your
    tests fail before writing production code ensures that these same tests would
    fail if the functionality they cover stops working properly.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD 的主要好处是验证测试的正确性。在编写生产代码之前看到测试失败可以确保如果它们覆盖的功能停止正常工作，这些相同的测试也会失败。
