- en: 1 JavaScript reloaded
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 重新加载JavaScript
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: 'Evaluating the key aspects of day-to-day coding: objects, functions, code,
    and data'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估日常编码的关键方面：对象、函数、代码和数据
- en: Comparing prototype- and delegation-based object models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较基于原型和委托的对象模型
- en: Understanding the composability of functions and types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数和类型的可组合性
- en: Achieving clear separation of concerns through modularity and metaprogramming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模块化和元编程实现关注点的清晰分离
- en: Using promises and streams programming to create unidirectional data pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺和流编程创建单向数据管道
- en: Introducing the sample blockchain application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍示例区块链应用程序
- en: '*Any application that can be written in JavaScript, will eventually be written
    in JavaScript.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何可以用JavaScript编写的应用程序，最终都会用JavaScript编写。*'
- en: —Jeff Atwood
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ——杰夫·阿特伍德
- en: It’s an amazing time to be a JavaScript developer. Today, JavaScript developers
    can write code that runs virtually anywhere from tablets, smartphones, desktops,
    bots, and cloud platforms to the Internet of Things, such as toasters, refrigerators,
    thermostats, and even spacesuits! Also, we can program all tiers of an application
    stack, from the client and server, all the way down to the database. The world
    is at our fingertips.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是成为一名JavaScript开发者的大好时机。今天的JavaScript开发者可以编写几乎在任何地方运行的代码，从平板电脑、智能手机、桌面、机器人到云平台，再到物联网，如烤箱、冰箱、恒温器，甚至太空服！此外，我们还可以编程应用程序堆栈的所有层，从客户端和服务器，一直到数据库。世界尽在掌握之中。
- en: Despite JavaScript’s resounding popularity, most developers—even those who use
    it every day—still struggle to decide how to approach writing a new application.
    Most of the time, you or your organization will have a prearranged framework of
    choice, which gives you a good starting point. But even in these situations, frameworks
    only get you so far; business-domain logic (done in plain JavaScript coding) will
    always be the most difficult and uncertain part of the equation—one that you can’t
    throw a library at to do. For these cases, it’s important to have a good grasp
    of the language’s syntax, the features it has to offer, and the paradigms it supports.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript非常受欢迎，但大多数开发者——甚至那些每天使用它的人——仍然难以决定如何编写新的应用程序。大多数时候，你或你的组织将有一个预先安排的选择框架，这为你提供了一个良好的起点。但即使在这些情况下，框架也只能带你走这么远；业务领域逻辑（以纯JavaScript编码完成）始终是等式中最困难、最不确定的部分——你不能简单地扔一个库来解决这个问题。在这些情况下，了解语言的语法、它提供的功能以及它支持的模式是非常重要的。
- en: 'Most general-purpose programming languages typically have a recommended way
    of solving a certain type of problem. Java and similar languages are hard-set
    on classes to represent your business model, for example. With JavaScript, however,
    there are many more options to consider: functions, object literals, creational
    APIs, and even classes. Because JavaScript glues the web together, not only in
    browsers and mobile devices, but also increasingly in the server, it’s continuously
    evolving to meet the demands of diverse developer communities and rise to the
    new challenges imposed by these (sometimes opposite) environments. Examples of
    these challenges include managing asynchronous data originating from a user clicking
    buttons to performing lower-level file I/O and breaking complex parts of your
    business logic into simple, maintainable modules that can be shared and used across
    clients and servers. These problems are unique.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数通用编程语言通常都有一种推荐的方式来解决某一类问题。例如，Java和类似的语言坚持使用类来表示你的业务模型。然而，JavaScript却提供了许多可供考虑的选项：函数、对象字面量、创建API，甚至类。因为JavaScript不仅将网络粘合在一起，而且在浏览器、移动设备，甚至在服务器上，它不断进化以满足不同开发者社区的需求，并应对这些（有时相反）环境提出的新挑战。这些挑战的例子包括管理来自用户点击按钮到执行底层文件I/O的异步数据，以及将复杂的业务逻辑分解成简单、可维护的模块，这些模块可以在客户端和服务器之间共享和使用。这些问题是独特的。
- en: In addition, when we use JavaScript at scale, we also need to concern ourselves
    with how to instantiate objects from proper abstractions that match our way of
    reasoning, decomposing complex algorithms into simpler, reusable functions and
    handling potentially infinite streams of data. All these tasks require good design
    skills so that the code is simple to reason about and easy to maintain.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们大规模使用JavaScript时，我们还需要关注如何从适当的抽象中实例化对象，以匹配我们的推理方式，将复杂算法分解成更简单、可重用的函数，并处理可能无限的数据流。所有这些任务都需要良好的设计技能，以便代码易于推理和维护。
- en: That is where The Joy of JavaScript comes in. The goal of this book is to help
    you identify and work with the different features of the language so that you
    become a well-rounded JavaScript professional who understands how expert developers
    are using JavaScript. The topics covered will give you enough information to allow
    you to focus on and master what you need to tackle today’s and tomorrow’s challenges.
    The book will also prepare you to use some of the new features that might be coming
    into the language in the coming years, including pipeline and bind operators,
    throw expressions, and observables. My aim is to make you a better, more productive
    programmer so that you can do more with less. After a few chapters—and certainly
    by the end of the book—you should be writing even leaner and more elegant code
    than you are already writing. In short, you’ll emerge from this book with a batch
    of new tools and techniques at your disposal for more effective and efficient
    programming, whether you are writing code for the frontend or the backend.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是《JavaScript的乐趣》这本书的用武之地。本书的目的是帮助你识别和使用语言的不同特性，以便你成为一个全面发展的JavaScript专业人士，了解专家开发者是如何使用JavaScript的。本书涵盖的主题将为你提供足够的信息，让你能够专注于并掌握今天和明天需要应对的挑战。本书还将为你准备使用一些可能在未来的几年内加入语言的新特性，包括管道和绑定操作符、抛出表达式和可观察对象。我的目标是让你成为一个更好的、更高效的程序员，这样你就可以用更少的资源做更多的事情。在阅读了几章之后——当然，在本书结束时——你应该能够写出比你现在写的更简洁、更优雅的代码。简而言之，你将从本书中收获一批新的工具和技术，用于更有效、更高效地编程，无论你是编写前端还是后端代码。
- en: Many years ago, JavaScript development wasn’t particularly associated with “joy.”
    It was cumbersome to manage deep object hierarchies, for example, or to package
    your application into modules that would work across environments. The problem
    of implementing cross-platform, cross-vendor compatible code, plus the lack of
    tool support, made lots of developers cringe at the idea of having to write or
    maintain JavaScript code for a living. But that’s changed; in fact, it’s quite
    the opposite.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年前，JavaScript开发并没有特别与“快乐”联系在一起。例如，管理深层对象层次结构或打包你的应用程序为能在不同环境中工作的模块是件麻烦事。实现跨平台、跨供应商兼容的代码的问题，加上工具支持的缺乏，让许多开发者对必须为生计编写或维护JavaScript代码的想法感到厌恶。但情况已经改变；事实上，正好相反。
- en: 'Fortunately, we’re now in the modern days of JavaScript development, which
    means several things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们现在正处于JavaScript开发的现代时期，这意味着几件事情：
- en: First, we can closely monitor JavaScript’s steady evolution with a well-defined,
    fast-paced, task group called TC39 that pushes new language features every year,
    all in the open and transparently. This creates both excitement and angst, because
    it inevitably forces you to rethink or throw away old habits and get ready for
    what’s coming. Not all developers embrace change well or keep an open mind, but
    I hope that you do.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以通过一个名为TC39的明确、快速的任务组来密切监控JavaScript的稳步发展，该任务组每年都会推出新的语言特性，所有这些都在公开和透明中进行。这既带来了兴奋，也带来了焦虑，因为它不可避免地迫使你重新思考或放弃旧习惯，为即将到来的事物做好准备。并不是所有开发者都能很好地接受变化或保持开放的心态，但我希望你能。
- en: Second, the days of copy-paste programming are long behind us, and gone with
    them is the stigma of having Script in the name as somehow describing an inferior
    language. This sentiment was a global one many years ago, but that’s no longer
    the case. The JavaScript ecosystem is among the most vibrant and cutting-edge
    ecosystems, and today, JavaScript developers rank among the highest-paid professionals
    in the industry.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，复制粘贴编程的时代已经离我们远去，与之一起消失的还有将“Script”作为名称的耻辱感，仿佛在描述一种低级语言。这种观点在多年前是普遍存在的，但现在已经不再是这样了。JavaScript生态系统是其中最充满活力和前沿的生态系统之一，如今，JavaScript开发者已成为行业内薪酬最高的专业人士之一。
- en: Finally, the misconception that a JavaScript developer is a jQuery, React, Angular,
    Vue, Svelte, or <name-your-framework> developer is fading. You’re a JavaScript
    developer—period. The decision to use any of these frameworks or libraries is
    yours to make. By using good practices and learning how to properly use the wide
    spectrum of tools that JavaScript gives you, plain-vanilla JavaScript is powerful
    enough to let your creativity run wild and contribute to any kind of project.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，认为JavaScript开发者就是jQuery、React、Angular、Vue、Svelte或<命名你的框架>开发者的这种误解正在逐渐消失。你是一个JavaScript开发者——仅此而已。决定使用这些框架或库中的任何一个，是你的选择。通过使用良好的实践，并学习如何正确使用JavaScript提供的广泛工具集，纯JavaScript已经足够强大，让你的创造力自由发挥，并为任何类型的项目做出贡献。
- en: 'To bring you into the present and future of JavaScript programming, this book
    explores the language in the context of the most popular paradigms—functional,
    reflective, and reactive—and describes how to work with key coding elements within
    each paradigm. The book is organized around the four themes used in addressing
    most programming problems: objects, functions, code, and data. Within these themes,
    you’ll learn which proper object models to use to design your business domain,
    how to combine functions and transform these objects into the desired output,
    how to modularize your applications effectively, and how to manage the data that
    flows through your application, whether that data is synchronous or asynchronous.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解JavaScript编程的现在和未来，本书在功能、反射和响应式等最流行的范式背景下探讨了这门语言，并描述了如何在每个范式内与关键编码元素一起工作。本书围绕解决大多数编程问题的四个主题组织：对象、函数、代码和数据。在这些主题中，您将学习如何使用适当的对象模型来设计您的业务领域，如何结合函数并将这些对象转换为所需的输出，如何有效地模块化您的应用程序，以及如何管理通过您的应用程序流动的数据，无论这些数据是同步的还是异步的。
- en: As you can see from the spectrum of topics covered, this book is not for a JavaScript
    newcomer or beginner. This book assumes that you already have some professional
    experience and a strong grasp of the basics (such as variables, loops, objects,
    functions, scopes, and closures), and that you have gone through the exercise
    of implementing and configuring JavaScript programs and setting up a transpiler
    such as Babel or TypeScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从涵盖的主题范围中可以看到，这本书不是为JavaScript新手或初学者准备的。本书假设您已经具备一些专业经验，并对基础知识（如变量、循环、对象、函数、作用域和闭包）有很强的掌握，并且您已经经历过实现和配置JavaScript程序以及设置像Babel或TypeScript这样的转译器的练习。
- en: Modern JavaScript development is possible only when the language has a consistent,
    steady evolution of features and syntax that tackle these problems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当语言具有一致、稳定的特性和语法演变来解决这些问题时，现代JavaScript开发才成为可能。
- en: 1.1 Evolving JavaScript
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 JavaScript的演变
- en: For many years, the evolution of JavaScript was stagnant. To put matters in
    perspective, ECMAScript, the specification language for JavaScript, had been stuck
    at version 3.1 across major JavaScript engines since December 2009\. This version
    was later renamed as the better-known ECMAScript 5, or ES5\. We waited for nearly
    six agonizing years—since June 2015, to be exact—to see any progress made in the
    language. In tech years, six years is a long time; even ATM machines get updated
    sooner.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，JavaScript的演变一直停滞不前。为了更清楚地说明问题，JavaScript的规范语言ECMAScript自2009年12月以来在主要JavaScript引擎中一直停滞在3.1版本。这个版本后来被更名为更为人所知的ECMAScript
    5，或简称ES5。我们等了近六年的痛苦时光——确切地说，从2015年6月开始——才看到语言有任何进展。在技术领域，六年是一个很长的时间；即使是自动取款机也会更快地更新。
- en: During this time, a standards committee known as TC39 ([https://github.com/
    tc39](https://github.com/tc39)), with the help of institutions such as the OpenJS
    Foundation ([https://openjsf .org](https://openjsf.org/)), gave birth to ECMAScript
    2015, also known as ES6\. This change was the biggest leap that JavaScript had
    made since its inception. Among the most important features in this release ([http://es6-features.org](http://es6-features.org))
    were classes, arrow functions, promises, template literals, blocked-scoped variables,
    default arguments, metaprogramming support, destructuring assignment, and modules.
    Aside from all these most-needed language features, the most important change
    was that JavaScript’s evolution shifted to a yearly release cadence, allowing
    the language to iterate quickly and address problems and shortcomings sooner.
    To help you keep track of where we are, ES6 refers to ECMAScript 2015, ES7 to
    ECMAScript 2016, and so on. These incremental releases are much easier to adopt
    and manage by platform vendors than large, monolithic releases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段时间里，一个名为TC39的标准委员会（[https://github.com/tc39](https://github.com/tc39)），在诸如OpenJS
    Foundation（[https://openjsf.org](https://openjsf.org/)）等机构的帮助下，诞生了ECMAScript 2015，也称为ES6。这次变革是自JavaScript诞生以来最大的飞跃。在这个版本中最重要的特性（[http://es6-features.org](http://es6-features.org)）包括类、箭头函数、Promise、模板字符串、块级作用域变量、默认参数、元编程支持、解构赋值和模块。除了所有这些最需要的语言特性之外，最重要的变化是JavaScript的演变转向了每年一次的发布节奏，这使得语言能够快速迭代并更早地解决问题和不足。为了帮助您跟踪我们的位置，ES6指的是ECMAScript
    2015，ES7指的是ECMAScript 2016，依此类推。这些增量发布对于平台供应商来说更容易采用和管理，比大型、单一的发布更容易。
- en: 'TC39 is composed of members of leading web companies that will also continue
    evolving ECMAScript, the specification language set to standardize JavaScript,
    known internationally as ISO/IEC 16262 or ECMA262 for short. (That’s a lot of
    acronyms, I know, but I hope that you got the gist.) TC39 is also a platform that
    gives the whole community some input into where the language is headed through
    participation in IRC channels and mailing lists, as well as through finding and
    helping to document issues in existing proposals. If you take a quick look at
    the language proposals on TC39’s GitHub site, you can see that each one goes through
    a set of stages. These stages are well documented on GitHub, so I’ll summarize
    them for you here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TC39由领先网络公司的成员组成，他们也将继续发展ECMAScript，这是一种旨在标准化JavaScript的规范语言，在国际上被称为ISO/IEC
    16262，简称ECMA262。（我知道有很多缩写，但我希望您已经抓住了要点。）TC39也是一个平台，通过参与IRC频道和邮件列表，以及通过发现和帮助记录现有提案中的问题，让整个社区能够对语言的发展方向提供一些意见。如果您快速查看TC39的GitHub网站上的语言提案，您可以看到每个提案都要经过一系列阶段。这些阶段在GitHub上有很好的记录，所以我会在这里为您总结：
- en: Stage 0 (strawman) — This stage is informal, and the proposal can have any form,
    so anyone can contribute to the further development of the language. To add your
    input, you must be a member of TC39 or registered with ECMA International. If
    you’re interested, feel free to register at [https://tc39.github.io/agreements/
    contributor](https://tc39.github.io/agreements/contributor). When you’re registered,
    you can propose your ideas via the es-discuss mailing list. You can also follow
    the discussions at [https://esdiscuss.org](https://esdiscuss.org).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0阶段（草稿阶段）——这个阶段是非正式的，提案可以采取任何形式，因此任何人都可以为语言的进一步发展做出贡献。要添加您的意见，您必须是TC39的成员或在ECMA国际注册。如果您感兴趣，请随时在[https://tc39.github.io/agreements/contributor](https://tc39.github.io/agreements/contributor)注册。注册后，您可以通过es-discuss邮件列表提出您的想法。您还可以关注[https://esdiscuss.org](https://esdiscuss.org)上的讨论。
- en: Stage 1 (proposal) — After a strawman has been made, a member of TC39 must champion
    your addition to advance it to the next stage. The TC39 member must explain why
    the addition is useful and describe how it will behave and look when it’s implemented.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1阶段（提案阶段）——在提出一个草稿之后，TC39的成员必须支持您的添加，以将其推进到下一阶段。TC39成员必须解释添加的理由，并描述它实现后的行为和外观。
- en: Stage 2 (draft) — The proposal gets fully spec’d out and is considered to be
    experimental. If it reaches this stage, the committee expects the feature to make
    it into the language eventually.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2阶段（草案阶段）——提案得到完全规范，并被认为是实验性的。如果它达到这个阶段，委员会期望该特性最终会进入语言中。
- en: Stage 3 (candidate) — At this stage, the solution is considered to be complete
    and is signed off. Changes after this stage are rare and generally are made only
    for critical discoveries after implementation and significant use. You can feel
    comfortable using features in this stage. After a suitable period of deployment,
    the addition is safely bumped to stage 4.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3阶段（候选阶段）——在这个阶段，解决方案被认为是完整的，并已获得批准。此阶段之后的变更很少，通常仅在实施和大量使用后进行的关键发现时才会进行。您可以使用这个阶段的特性。在经过一段适当的部署期后，该新增特性可以安全地提升到第4阶段。
- en: Stage 4 (finished) — Stage 4 is the final stage. If a proposal reaches this
    stage, it is ready to be included in the formal ECMAScript standard specification.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4阶段（完成阶段）——第4阶段是最终阶段。如果一个提案达到这个阶段，它就可以被纳入正式的ECMAScript标准规范。
- en: 'This healthy stream of new proposals is important so that JavaScript keeps
    up with the demands of today’s application development practices. Aside from discussing
    the cool techniques and paradigms that come alive only with JavaScript, this book
    introduces you to a few proposals that will forever change how we write JavaScript
    in the near future, some of which I’ll mention briefly in this chapter. Here they
    are, in the order in which they’ll appear in the rest of the book:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这股健康的新提案流非常重要，这样JavaScript才能跟上当今应用开发实践的需求。除了讨论只有JavaScript才能实现的酷炫技术和范式之外，这本书还向您介绍了一些将在不久的将来永远改变我们编写JavaScript方式的提案，其中一些我在本章中会简要提及。以下是它们在本书其余部分出现的顺序：
- en: Private class fields ([https://github.com/tc39/proposal-class-fields](https://github.com/tc39/proposal-class-fields))
    allow you to define access modifiers (private, static) to a class’s properties.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有类字段（[https://github.com/tc39/proposal-class-fields](https://github.com/tc39/proposal-class-fields)）允许您为类的属性定义访问修饰符（私有、静态）。
- en: The pipeline operator ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator))
    brings the UNIX-like pipe feature of functional languages to JavaScript functions.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道运算符（[https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)）将函数式语言中类似UNIX管道的功能引入JavaScript函数。
- en: The bind operator ([https://github.com/tc39/proposal-bind-operator](https://github.com/tc39/proposal-bind-operator))
    is a new language syntax that abstracts the use of `Function.prototype.bind`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定运算符（[https://github.com/tc39/proposal-bind-operator](https://github.com/tc39/proposal-bind-operator)）是一种新的语言语法，它抽象化了`Function.prototype.bind`的使用。
- en: Throw expressions ([https://github.com/tc39/proposal-throw-expressions](https://github.com/tc39/proposal-throw-expressions))
    allow you to treat a `throw` statement as though it were a function or a variable.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出表达式（[https://github.com/tc39/proposal-throw-expressions](https://github.com/tc39/proposal-throw-expressions)）允许你将`throw`语句当作函数或变量来处理。
- en: Observables ([https://github.com/tc39/proposal-observable](https://github.com/tc39/proposal-observable))
    enable the stream-based, reactive paradigm.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象（[https://github.com/tc39/proposal-observable](https://github.com/tc39/proposal-observable)）使基于流的响应式范式成为可能。
- en: For most of the remainder of this chapter, I’ll introduce you to the book’s
    four major themes so that you understand the big picture and see how the themes
    relate to one another. I’ll start with objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余的大部分内容中，我将介绍本书的四个主要主题，以便你理解整体情况并看到这些主题是如何相互关联的。我将从对象开始。
- en: 1.2 Objects
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 对象
- en: An object is nothing more than a memory reference that points (links) to other
    memory locations. At its core, JavaScript is an object-oriented language, and
    there are many ways to define objects and the association among them in JavaScript.
    In this book, we’ll look at many ways to define objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不过是一个指向其他内存位置的内存引用。在核心上，JavaScript是一种面向对象的语言，并且有多种方式在JavaScript中定义对象及其之间的关系。在这本书中，我们将探讨许多定义对象的方法。
- en: For one-time use, for example, a simple object literal is probably the best
    and quickest approach. An object literal comes in handy when you need to group
    multiple pieces of data that need to be passed to, or returned from, a function.
    When you need to create multiple objects with the same shape, however, it’s best
    to use a creational API like `Object.create` to act as a factory of objects. You
    can also use your own functions as object factories when combined with the `new`
    keyword. In the same vein, classes have become popular in recent years and behave
    in much the same way. But if objects are nothing more than references (links)
    to other objects, JavaScript also lets you mash multiple small objects into one
    big one by using the spread operator or even an API like `Object.assign`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性使用，例如，简单的对象字面量可能是最好且最快的方法。当需要将多个数据项组合起来传递给函数或从函数返回时，对象字面量就派上用场了。然而，当你需要创建具有相同形状的多个对象时，最好使用像`Object.create`这样的创建型API作为对象的工厂。你也可以结合`new`关键字使用自己的函数作为对象工厂。同样，类在近年来也变得流行，并且行为方式非常相似。但如果对象仅仅是其他对象的引用（链接），JavaScript也允许你通过使用扩展运算符或像`Object.assign`这样的API将多个小对象合并成一个大的对象。
- en: 'Regardless of the approach you take, you often need to share data and a set
    of methods to avoid duplicating code. JavaScript uses two central mechanisms:
    the property resolution mechanism and prototypes. These mechanisms are intertwined.
    JavaScript uses the object’s internal prototype reference as a path to navigate
    an object hierarchy during property resolution, which can happen when you query
    properties of an object or invoke a method. Suppose that you have the inheritance
    configuration shown in figure 1.1.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你采取哪种方法，你通常都需要共享数据和一组方法以避免代码重复。JavaScript使用两种核心机制：属性解析机制和原型。这些机制是相互交织的。JavaScript使用对象的内部原型引用作为在属性解析期间导航对象层次结构的路径，这发生在你查询对象的属性或调用方法时。假设你有图1.1所示的继承配置。
- en: '![](../Images/1-1.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/1-1.png)'
- en: Figure 1.1 A simple prototype hierarchy in which objects of `Student` inherit
    from objects of `Person`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 一个简单的原型层次结构，其中`Student`对象继承自`Person`对象
- en: Here, objects constructed from `Student` inherit from objects constructed from
    `Person`, which means that all `Student` instances have at their disposal the
    data and methods defined in `Person`. This relationship goes by the name differential
    inheritance, because as the object graph becomes longer, every object borrows
    the shape of the one above it and differentiates itself (becomes more specialized)
    with new behavior.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从`Student`构造的对象继承自从`Person`构造的对象，这意味着所有`Student`实例都可以使用在`Person`中定义的数据和方法。这种关系被称为差异继承，因为随着对象图的变长，每个对象都会借用其上层的形状，并通过新的行为来区分自己（变得更加专业化）。
- en: From figure 1.1, calling `enroll` on a `Student` invokes the desired property
    right away because it’s local to the object, but calling `getAddress` uses JavaScript’s
    property lookup mechanism to traverse up the prototype hierarchy. The downside
    of this approach is that when your object graphs become a lot more complex, a
    change to a base-level object will cause a ripple effect in all derived objects,
    even at runtime. This situation is known as prototype pollution, and it’s a serious
    issue that plagues large JavaScript applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从图1.1可以看出，在`Student`对象上调用`enroll`方法会立即触发所需属性，因为它是局部于对象的，但调用`getAddress`则使用JavaScript的属性查找机制沿着原型层次结构向上遍历。这种方法的缺点是，当你的对象图变得非常复杂时，对基级对象的任何更改都会在所有派生对象中引起连锁反应，甚至在运行时也是如此。这种情况被称为原型污染，它是困扰大型JavaScript应用的严重问题。
- en: 'Because the prototype is an internal implementation detail of objects in JavaScript,
    from the point of view of the caller the `Student` API is a façade with four properties:
    `firstName`, `lastName`, `getAddress`, and `enroll`. Similarly, we can obtain
    the same shape by composing object literals describing a `Person` and `Student`.
    This approach is a slight twist on the configuration in figure 1.1, but an important
    one. Take a look at figure 1.2.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原型是JavaScript中对象的内部实现细节，从调用者的角度来看，`Student` API是一个具有四个属性的门面：`firstName`、`lastName`、`getAddress`和`enroll`。同样，我们可以通过组合描述`Person`和`Student`的对象字面量来获得相同的形状。这种方法是对图1.1中配置的轻微扭曲，但非常重要。请看图1.2。
- en: '![](../Images/1-2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2](../Images/1-2.png)'
- en: Figure 1.2 Two concrete objects (`Student` and `Person`) mesh into a brand new
    object with all properties assigned from the combined objects. Although no prototypal
    inheritance is at play here, the directions of the arrow is kept the same as in
    figure 1.1 to convey the similar mental model of both approaches.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2中，两个具体对象（`Student`和`Person`）合并成一个全新的对象，其中包含从组合对象分配的所有属性。尽管这里没有使用原型继承，但箭头的方向与图1.1中保持一致，以传达两种方法类似的心理模型。
- en: With figure 1.2, the main difference is that we replaced prototype references
    with a `copy` operation to symbolize that we’re essentially taking all the properties
    of `Student` and `Person` and copying them (actually, assigning them) to an empty
    object. So instead of linking objects, we created separate objects with the same
    shape. From the caller’s point of view, these objects are exactly the same, and
    you still benefit from code reuse. In this scenario, `Student` and `Person` are
    not constructors or factories; they are simple mixins (pieces of an object). Although
    this approach saves you from unintended downstream changes and prototype pollution
    to some degree, the downside is that every new object you create adds a new copy
    of the assigned properties in memory, making the memory footprint a bit larger.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在图1.2中，主要的不同之处在于我们用`copy`操作替换了原型引用，以表示我们实际上正在将`Student`和`Person`的所有属性复制（实际上，是分配）到一个空对象中。因此，我们不是链接对象，而是创建了具有相同形状的独立对象。从调用者的角度来看，这些对象完全相同，你仍然可以受益于代码重用。在这种情况下，`Student`和`Person`不是构造函数或工厂；它们是简单的混入（对象的一部分）。尽管这种方法在一定程度上可以避免意外的下游更改和原型污染，但缺点是每个新创建的对象都会在内存中添加一个新副本的属性，使得内存占用稍微大一些。
- en: As you know, most things in computer science are trade-offs. Here, you trade
    the memory-efficient approach of prototypes, which JavaScript engines highly optimize,
    for ease of maintainability and reusability. In chapters 2 and 3, we’ll talk in
    detail about these and other patterns, as well as the code that implements them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，计算机科学中的大多数事物都是权衡的结果。在这里，你以原型的高效内存使用方法为代价，换取了易于维护和重用性。在第2章和第3章中，我们将详细讨论这些以及其他模式，以及实现它们的代码。
- en: If objects are the fabric of JavaScript, functions represent the needles used
    to thread the pieces together. JavaScript functions are by far the strongest parts
    of the language, as we’ll discuss in section 1.3.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是JavaScript的织物，那么函数就是用来将碎片缝合在一起的针线。JavaScript函数是语言中最强大的部分，我们将在第1.3节中讨论。
- en: 1.3 Functions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 函数
- en: 'Functions implement the business logic of your application and drive its state
    (such as the data inside all the objects in memory) to its desired outcome. At
    a fundamental level, you can think about functions in two ways:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数实现了您应用程序的业务逻辑，并驱动其状态（例如内存中所有对象内的数据）达到期望的结果。在根本层面上，你可以从两种方式来考虑函数：
- en: In the procedural or imperative mindset, a function is nothing more than a group
    of statements that execute together, used to organize and avoid duplicating similar
    patterns of code. The object-oriented paradigm inherits from procedural programming,
    so it’s also a sequence of statements or commands that modify objects. The reader
    is expected to be familiar with this approach.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在过程式或命令式思维模式中，函数不过是一组共同执行的语句集合，用于组织和避免代码模式重复。面向对象范式继承了过程式编程，因此它也是一个修改对象的语句或命令序列。读者应熟悉这种方法。
- en: On the other hand, you can think about functions as expressions through the
    lens of functional programming (FP). In this view of the world, functions represent
    immutable computations that are assembled like Lego bricks.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，你可以通过函数式编程（FP）的视角来考虑函数作为表达式。在这个世界的观点中，函数代表像乐高积木一样组装的不可变计算。
- en: Figure 1.3 shows a flowchart of a hypothetical program of minor complexity that
    uses a procedural style. We’ve been trained to think like computers and map out
    data flows in this way. But as you’ll see over the next couple of figures (figure
    1.4 and 1.5), when you use the right techniques, you can simplify even the most
    complex program as a streamlined sequence of expressions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3展示了一个使用过程式风格的、复杂度较低的假设程序的流程图。我们被训练成像计算机一样思考，并以这种方式绘制数据流。但正如你将在接下来的几个图中看到（图1.4和1.5），当你使用正确的技术时，你可以将甚至是最复杂的程序简化为一系列流畅的表达式序列。
- en: '![](../Images/1-3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-3.png)'
- en: Figure 1.3 A hypothetical description of a program illustrating `if/else` conditions
    and looping
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：一个假设的程序描述，展示了`if/else`条件和循环
- en: You should be writing maintainable, declarative code that your users and teammates
    can understand, and letting the computer parse and optimize code for its own understanding.
    FP can help a lot in this regard. You’ve probably heard or read that React allows
    you to build UIs “the functional way” or that Redux promotes immutable state management.
    Have you ever wondered where all these concepts come from? You can code functionally
    by taking advantage of higher-order functions. In JavaScript, a function is an
    object capable of carrying or linking to variables in its lexical scope (also
    known as its closure or backpack) and one that you can pass as an argument and
    return as a callback. This fundamental part of the language, which has existed
    since the birth of JavaScript, has infinite potential for designing code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该编写可维护的、声明式的代码，让你的用户和队友能够理解，并让计算机解析和优化代码以供其自身理解。FP在这方面有很大帮助。你可能听说过或读到React允许你“函数式地”构建UI，或者Redux促进不可变状态管理。你有没有想过所有这些概念从何而来？你可以通过利用高阶函数来函数式地编码。在JavaScript中，一个函数是一个能够携带或链接到其词法作用域（也称为其闭包或背包）中的变量，并且你可以将其作为参数传递并作为回调返回的对象。这是语言的一个基本部分，自从JavaScript诞生以来就存在，具有无限的潜力来设计代码。
- en: FP expresses computations and data as a combination of pure functions. Instead
    of changing the state of the system on every call, these functions yield a new
    state; they are immutable. Coding with FP will prevent a lot of bugs—ones you
    don’t have to bother to code around—and yield code that you can look at years
    later and reason about more easily. This feature isn’t part of JavaScript per
    se, but it complements coding with JavaScript’s higher-order functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: FP将计算和数据表达为纯函数的组合。这些函数在每次调用时不会改变系统的状态，而是产生一个新的状态；它们是不可变的。使用FP编码将防止许多错误——你不需要费心去绕过的错误——并产生你可以多年后查看且更容易推理的代码。这个特性本身并不是JavaScript固有的，但它补充了使用JavaScript高阶函数的编码。
- en: Chapter 4 teaches you enough FP to significantly affect the way that you do
    your day-to-day coding. It goes through an exercise of decomposition (breaking
    complex problems into small, manageable chunks) and composition (pulling the pieces
    back together). Abstractly, the coding mindset is shown in figure 1.4.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章将教会你足够的FP知识，以显著影响你日常编码的方式。它通过分解（将复杂问题分解成小而可管理的块）和组合（将这些部分重新组合在一起）的练习。从抽象的角度来看，编码思维模式如图1.4所示。
- en: '![](../Images/1-4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/1-4.png)'
- en: Figure 1.4 FP programs tend to decompose big problems and solve them as the
    composition of smaller tasks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 FP程序倾向于将大问题分解成更小的任务，并作为这些小任务的组合来解决。
- en: Inevitably, you’ll tend to create much simpler functions that work on some input
    and produce an output based solely on this input. When you’ve been able to disassemble
    a complex problem and represent it as multiple functions, you’ll use techniques
    such as currying and composition to string all these functions back together.
    You can use functions to abstract any kind of logic—such as conditional execution,
    loops, and even error handling—to create a pipeline of information that looks
    like figure 1.5.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，你可能会倾向于创建许多更简单的函数，这些函数只对某些输入有效，并仅基于这个输入产生输出。当你能够将复杂问题分解成多个函数表示时，你会使用诸如currying和composition等技术将这些函数重新组合起来。你可以使用函数来抽象任何类型的逻辑——如条件执行、循环甚至错误处理——以创建类似于图1.5的信息管道。
- en: '![](../Images/1-5.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/1-5.png)'
- en: Figure 1.5 Composition allows you to build function pipelines in which the output
    of one function becomes the input to the next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 组合允许你构建函数管道，其中一个函数的输出成为下一个函数的输入。
- en: 'We’re fortunate to use a language that can give us this kind of support. In
    future releases of the language, figure 1.5 could be encoded directly in JavaScript
    with the new pipeline operator (`|>`) syntax, which you’ll learn about in chapter
    4:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运使用一种能够给我们这种支持的编程语言。在语言的未来版本中，图1.5可能可以直接使用新的管道操作符（`|>`) 语法在JavaScript中编码，你将在第4章中了解到这一点：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Like a UNIX shell, this operator allows you to “pipe” the output of one function
    as the input to the next. Let’s assume that you created a `split` function to
    break apart a string by spaces into an array and a `count` function to return
    the length of the array. The following line is valid JavaScript code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像UNIX shell一样，这个操作符允许你将一个函数的输出“管道”到下一个函数的输入。假设你创建了一个`split`函数，用于通过空格将字符串拆分成一个数组，以及一个`count`函数，用于返回数组的长度。以下是一行有效的JavaScript代码：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Furthermore, one of the most noticeable differences between figures 1.3 and
    1.5 is the removal of the conditional logic (the diamond shapes). How is this
    possible? Chapter 5 introduces a concept known as the Algebraic Data Type (ADT).
    In our case, type means an object with a certain shape, not a static type, which
    is what it commonly refers to in other language communities. Given that there’s
    a lot of discussion about static type systems for JavaScript (such as TypeScript
    and Flow), this book does spend a little bit of time talking about static types
    in JavaScript in appendix B.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，图1.3和图1.5之间最明显的区别之一是条件逻辑（菱形形状）的去除。这是如何实现的？第5章介绍了一个称为代数数据类型（ADT）的概念。在我们的情况下，类型意味着具有某种形状的对象，而不是静态类型，这在其他语言社区中通常是指静态类型。鉴于关于JavaScript静态类型系统（如TypeScript和Flow）有很多讨论，本书在附录B中花了一些时间讨论JavaScript中的静态类型。
- en: ADTs are commonplace nowadays in many programming languages and libraries as
    an elegant solution to common problems such as data validation, error handling,
    null checks, and I/O. In fact, JavaScript’s own optional chaining, pipeline, promises,
    and nullish coalesce operators, as well as `Array.prototype{map,` `flatMap}` APIs
    (all discussed in this book), are inspired in these algebraic types.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ADTs现在在许多编程语言和库中很常见，作为解决常见问题（如数据验证、错误处理、空值检查和I/O）的优雅解决方案。事实上，JavaScript自己的可选链、管道、承诺和nullish合并操作符，以及`Array.prototype{map,`
    `flatMap}` API（本书中均有讨论），都是受到这些代数类型灵感的启发。
- en: Earlier, we discussed composition in terms of functions. How can composition
    apply to custom data objects? You’ll learn that `Array`’s own `map` and `flatMap`
    methods conceptually apply to much more than arrays. They are part of a set of
    universally accepted interfaces that you can implement to make any object behave
    like a function; we’ll call this object a functor or a monad. JavaScript’s own
    `Array` has functor-like behavior, and you’ve been using this pattern all along
    without realizing it when transforming arrays by using `map`. This style of coding
    is important as a foundation for many of the topics covered in this book, so I’ll
    spend a little time here going over it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了函数的组合。组合如何应用于自定义数据对象？你会了解到`Array`的`map`和`flatMap`方法在概念上适用于比数组更多的情况。它们是一组普遍接受的接口的一部分，你可以实现这些接口来使任何对象表现得像函数；我们将这种对象称为函子或单子。JavaScript的`Array`具有类似函子的行为，而你一直在使用这种模式来转换数组，却没有意识到这一点。这种编码风格是本书涵盖的许多主题的基础，所以我会在这里花点时间来讲解它。
- en: Suppose that you’ve declared some functor `F` (which could be `Array`) and given
    it some input data. Functors are known by their specific implementation of `map`
    so that you can transform the data enclosed inside `F`. Figure 1.6 shows a step-by-step
    view of sequentially applying (mapping) functions to a string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经声明了一些函子`F`（可能是`Array`）并给它提供了一些输入数据。函子以其特定的`map`实现而闻名，这样你就可以转换`F`内部封装的数据。图1.6展示了将函数按顺序（映射）应用到字符串上的逐步视图。
- en: '![](../Images/1-6.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图1-6](../Images/1-6.png)'
- en: Figure 1.6 A functor object (`F`) uses `map` to transform the data contained
    inside it. Functors are side-effect-free, as every application of `map` yields
    a new instance of `F` while the original stays intact.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 一个使用`map`转换其内部数据的函子对象（`F`）。函子是无副作用的，因为每次应用`map`都会产生`F`的新实例，而原始实例保持不变。
- en: '`map` is a contract that can apply to any `F` that meets the functor requirements.
    When dealing with functions that you want to apply consistently across different
    independent objects, you may be inclined to use `Function.prototype.bind` to set
    the target object receiving the function call. With JavaScript’s new bind operator
    (`::`) syntax, this process got easier. Here’s a contrived example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`是一个合约，可以应用于满足函子要求的任何`F`。当处理你想要在不同独立对象上一致应用的功能时，你可能倾向于使用`Function.prototype.bind`来设置接收函数调用的目标对象。随着JavaScript新绑定的操作符（`::`）语法的出现，这个过程变得更加简单。以下是一个虚构的例子：'
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are many use cases in which functors are useful, so let’s hone in on the
    issue of conditional logic for validation. In chapter 5, we will implement our
    own ADT from scratch to abstract over `if`/`else` logic with an expression such
    as “If data is valid, do X; else, do Y.” The flow of data, although following
    the declarative recipe-like paradigm of figure 1.5, will execute proper branching
    logic internally, depending on the result of the validation check. In other words,
    if the result of a validation check is successful, the callback function is executed
    with the wrapped input; otherwise, it’s ignored. These two code flows are shown
    in figure 1.7.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多用例中，函子都是有用的，所以让我们专注于验证中的条件逻辑问题。在第5章中，我们将从头开始实现自己的ADT，以抽象`if`/`else`逻辑，例如“如果数据有效，执行X；否则，执行Y”。尽管数据流遵循图1.5的声明性食谱样范式，但内部将执行适当的分支逻辑，这取决于验证检查的结果。换句话说，如果验证检查的结果是成功的，回调函数将使用封装的输入执行；否则，它将被忽略。这两种代码流在图1.7中显示。
- en: '![](../Images/1-7.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图1-7](../Images/1-7.png)'
- en: Figure 1.7 An ADT to implement conditional logic models mutually exclusive (`OR`)
    branching. On the `Yes` (success) side of the branch, all mapped operations are
    executed against the data contained inside the ADT. Otherwise, on the `No` (failure)
    side, all operations are skipped. In both cases, the data flows sequentially from
    beginning to end.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 一个实现条件逻辑模型的互斥（`OR`）分支的ADT。在分支的`Yes`（成功）一侧，所有映射操作都针对ADT内部包含的数据执行。否则，在`No`（失败）一侧，所有操作都将跳过。在两种情况下，数据都从开始到结束按顺序流动。
- en: Learning about ADTs now will prepare you for where the language is headed. Early
    proposals include features such as pattern matching, which is proper for more
    functional alt-JS programming languages such as Elm. I don’t cover pattern matching
    in this book, as this proposal was in early draft form at the time of this writing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在了解ADT将为你准备好语言的发展方向。早期的提案包括模式匹配等特性，这对于更函数式的Alt-JS编程语言如Elm来说是合适的。由于这个提议在写作时还处于早期草案形式，本书没有涵盖模式匹配。
- en: Now that you’ve learned object-oriented and functional techniques to model your
    business domain, section 1.4 introduces you to JavaScript’s official module system,
    known as ECMAScript Modules (ESM), to help you organize and deliver your code
    in an optimal manner.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学习了面向对象和函数式技术来建模您的业务领域，第 1.4 节向您介绍了 JavaScript 的官方模块系统，称为 ECMAScript 模块（ESM），以帮助您以最佳方式组织和交付您的代码。
- en: 1.4 Code
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 代码
- en: Chapter 6 focuses on how to import and export code across your application by
    using ESM. The main goal of this feature is to standardize how code is shared
    and used in a platform-agnostic fashion. ESM supersedes earlier attempts at a
    standard module system for JavaScript, such as AMD, UMD, and even CommonJS (eventually).
    ESM uses a static module format that build/bundler tools can use to apply a lot
    of code optimizations simply by analyzing the static layout of your project and
    its interdependencies. This format is especially useful for reducing the size
    of bundled code that is sent over the wire to remote servers or directly to a
    browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章重点介绍如何使用 ESM 在您的应用程序中导入和导出代码。这个功能的主要目标是标准化代码在平台无关的方式下共享和使用。ESM 取代了 JavaScript
    早期尝试的标准模块系统，如 AMD、UMD，甚至最终是 CommonJS。ESM 使用静态模块格式，构建/捆绑工具可以使用它来通过分析项目的静态布局及其依赖关系来应用大量的代码优化。这种格式对于减少通过网络发送到远程服务器或直接发送到浏览器的捆绑代码的大小特别有用。
- en: JavaScript can use its module system to load modules as small as a single function
    to as big as monolithic classes. When you use well-established, tried-and-tested
    keywords such as `export` and `import`, creating modular, reusable code is straightforward.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可以使用其模块系统来加载从单个函数到大型单体类的大小不等的模块。当您使用像 `export` 和 `import` 这样的经过良好建立、经过测试的关键字时，创建模块化和可重用的代码是直接的。
- en: Being able to change one area of your code without affecting others is the cornerstone
    of modularity. Separation of concerns doesn’t apply only to the global project
    structure, but also to running code—the topic of chapter 7.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不影响其他区域的情况下更改您的代码是模块化的基石。关注点的分离不仅适用于全局项目结构，也适用于运行中的代码——这是第 7 章的主题。
- en: Chapter 7 talks about separation of concerns by taking advantage of JavaScript’s
    metaprogramming capabilities. Using JavaScript symbols and APIs such as `Proxy`
    and `Reflect` to enable reflection and introspection, you can keep your code clean
    and focused on the problem at hand. We’ll use these APIs to create our own method
    decorators to dynamically inject cross-cutting behavior (such as logging, tracing,
    and performance counters) that would otherwise clutter your business logic, doing
    so only when you need it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章通过利用 JavaScript 的元编程能力来讨论关注点的分离。使用 JavaScript 符号和 API，如 `Proxy` 和 `Reflect`
    来启用反射和内省，您可以保持代码干净并专注于当前的问题。我们将使用这些 API 来创建我们自己的方法装饰器，以动态注入跨切面行为（如日志记录、跟踪和性能计数器），否则这些行为会弄乱您的业务逻辑，仅在需要时才这样做。
- en: As a simple example, suppose that during debugging and troubleshooting you want
    to turn on logging of any property access (reading the contents of a property
    or calling a method) on some critical objects of your application. You’d like
    to do this without modifying a single line of code and be able to turn it off
    when you’re done. With the right instrumentation in place, you can create dynamic
    proxies that decorate objects of your choice and intercept or trap any calls to
    that object to weave new functionality. This simple example is depicted in figure
    1.8.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的例子，假设在调试和故障排除过程中，您想在应用程序的一些关键对象上打开任何属性访问（读取属性内容或调用方法）的日志记录。您希望在不修改任何一行代码的情况下完成此操作，并在完成后能够关闭它。通过放置正确的工具，您可以创建动态代理，装饰您选择的对象，并拦截或捕获对该对象的任何调用以编织新的功能。这个简单的例子在图
    1.8 中展示。
- en: '![](../Images/1-8.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 1-8](../Images/1-8.png)'
- en: Figure 1.8 Creating a proxy object dynamically around some target object. Any
    property access (`foo`) is trapped by the proxy object, so you can inject any
    code you want. In this simple case, the proxy object traps the access to `foo`
    and dynamically changes its return value to `'bar'`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 动态地围绕某些目标对象创建代理对象。任何属性访问（`foo`）都会被代理对象捕获，因此您可以注入任何想要的代码。在这个简单的例子中，代理对象捕获了对
    `foo` 的访问，并动态地将其返回值更改为 `'bar'`。
- en: Now imagine replacing this simple trap with performance counters before and
    after areas of code that you want to optimize, or using global security policies
    that can mangle or obfuscate sensitive strings inside objects before printing
    them to the screen or a log file. These method decorators become useful in a large
    number of use cases. We’ll look at how to do these things in chapter 7.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，在你想优化的代码区域之前和之后使用性能计数器，或者使用可以在打印到屏幕或日志文件之前破坏或混淆对象中敏感字符串的全局安全策略。这些方法装饰器在大量用例中变得很有用。我们将在第7章中探讨如何做这些事情。
- en: Now that you have objects, functions, and your code properly organized, all
    that’s left to do is manage the data that flows through it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了对象、函数和代码的适当组织，剩下要做的就是管理流经它的数据。
- en: 1.5 Data
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 数据
- en: Because JavaScript is critically positioned as the language of the web (both
    server and client), it needs to handle data of many shapes and sizes. Data can
    arrive synchronously (from local memory) or asynchronously (from anywhere else
    in the world). It may come in all at once (single object), in an ordered sequence
    (array), or in chunks (stream). JavaScript engines, at a high level, rely on an
    architecture featuring a callback queue with an event loop that can execute code
    continuously in a concurrent fashion and without halting the main thread.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JavaScript作为网络（包括服务器和客户端）的关键语言，它需要处理各种形状和大小的数据。数据可以同步到达（来自本地内存）或异步到达（来自世界上的任何地方）。它可能一次性到达（单个对象），按顺序到达（数组），或者分块到达（流）。JavaScript引擎在高级上依赖于一个具有回调队列和事件循环的架构，该架构可以连续以并发方式执行代码，而不会停止主线程。
- en: Without a doubt, using promises as a pattern for abstracting time and data locality
    has made it simpler to reason about asynchronous code. A `Promise` is an object
    that behaves like a function representing an eventual value, with an API that
    bears a lot of resemblance to ADTs. In your mind, you can replace `then` with
    `map`/`flatMap`. A `Promise` can be in one of several states, as shown in figure
    1.9, of which the most noticeable are `'fulfilled'` and `'rejected'`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，使用Promise作为抽象时间和数据局部性的模式，使得对异步代码进行推理变得更加简单。`Promise`是一个表现最终值的函数对象，其API与ADT有很多相似之处。在你的脑海中，你可以用`map`/`flatMap`替换`then`。`Promise`可以处于几种状态之一，如图1.9所示，其中最明显的是`'fulfilled'`和`'rejected'`。
- en: '![](../Images/1-9.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片1-9](../Images/1-9.png)'
- en: Figure 1.9 A new `Promise` object and all its possible states
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 新的`Promise`对象及其所有可能的状态
- en: As you can see, promises also models two branches of code. These two branches
    move your logic forward to execute your business logic to the desired outcome
    (`'fulfilled'`) or produce some sort of error message (`'rejected'`). Promises
    are composable types, much like ADTs and functions, and you can create chains
    of sequential logic to attack complex problems involving asynchronous data sources
    and profit from proper error handling along the way (figure 1.10).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Promise还模拟了两个代码分支。这两个分支将你的逻辑向前推进，以执行你的业务逻辑达到期望的结果（`'fulfilled'`）或产生某种错误消息（`'rejected'`）。Promise是可组合的类型，就像ADT和函数一样，你可以创建一系列的顺序逻辑链来攻击涉及异步数据源和复杂问题，并在过程中从适当的错误处理中受益（图1.10）。
- en: '![](../Images/1-10.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片1-10](../Images/1-10.png)'
- en: Figure 1.10 How `Promise` objects chain to form new `Promise` objects. Along
    the way, the same pattern repeats. Both success and rejection cases lead to a
    new `Promise` object returned.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 `Promise`对象如何链接形成新的`Promise`对象。在这个过程中，相同的模式重复出现。成功和拒绝情况都会导致返回一个新的`Promise`对象。
- en: In chapter 8, we discuss promises and the `async`/`await` syntax that appeals
    to developers from a more imperative or procedural background, yet shares the
    behavioral semantics of promises. With `async`/`await`, you have the visual advantage
    of writing code that looks as though it’s pausing and waiting for a command to
    execute (as in fetching data with an HTTP request), but behind the scenes, it’s
    all promises interacting with the underlying event loop architecture. In chapter
    8, we also explore topics implemented on top of promises such as async iterators
    and async generators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们讨论了Promise和`async`/`await`语法，这对于有更命令式或过程式背景的开发者来说很有吸引力，但与Promise的行为语义相同。使用`async`/`await`，你有编写看起来像暂停并等待执行命令的代码的视觉优势（例如，使用HTTP请求获取数据），但在幕后，一切都是Promise与底层事件循环架构的交互。在第8章中，我们还探讨了在Promise之上实现的主题，如异步迭代器和异步生成器。
- en: Promises model single, asynchronous values, but async generators allow you to
    deliver potentially infinite sequences of data over time. Async generators are
    a good mental model for understanding streams, which are sequences of events over
    some period of time, as depicted in figure 1.11.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Promises模型单个异步值，但异步生成器允许你在一段时间内交付可能无限的数据序列。异步生成器是理解流的好心理模型，流是在一段时间内的事件序列，如图1.11所示。
- en: '![](../Images/1-11.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/1-11.png)'
- en: Figure 1.11 A simple stream with three events separated by some unit of time
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 一个简单的流，有三个事件，由一些时间单位分隔
- en: There are standard `Stream` APIs to read/write streams implemented in both browsers
    and Node.js. Examples are file I/O streams in Node.js and the Fetch API in browsers.
    Nevertheless, given the diversity of the data types we deal with on a daily basis,
    instead of using `Promise` for a single-value event and `Stream` for sequences
    of events, ideally we’d use a single API to abstract over all these data types
    with the same computing model. This approach is attractive to framework and library
    authors alike because it allows them to provide a consistent interface. Fortunately,
    JavaScript proposes the `Observable` API as the solution.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器和Node.js中都有实现标准的`Stream` API来读写流。例如，Node.js中的文件I/O流和浏览器中的Fetch API。尽管如此，鉴于我们每天处理的数据类型的多样性，我们理想情况下应该使用单个API来抽象这些数据类型，并使用相同的计算模型。这种方法对框架和库的作者都有吸引力，因为它允许他们提供一个一致的接口。幸运的是，JavaScript提出了`Observable`
    API作为解决方案。
- en: 'Any time you see an `Observable` object, you should be thinking in terms of
    figure 1.11\. JavaScript’s inclusion of `Observable` built into the language seeks
    to standardize the amazing things you can do with libraries like RxJS. With observables,
    you can subscribe to events coming from any source: a simple function, an array,
    an event emitter (such as DOM), an HTTP request, promises, generators, or even
    WebSockets. The idea is that you can treat each piece of data as some event in
    time and use a consistent set of operators (observable functions) to process it.
    Like functions, promises, and ADTs, observables are composable. Do you see a pattern?
    This pattern isn’t a coincidence; it’s the coding pattern of modern software and
    one that most languages are increasingly adopting. Hence, you can also create
    chains or pipelines by calling a sequence of composable operators that work on
    or transform the data flowing through an observable object to process data synchronously
    or asynchronously as it propagates forward in time. Figure 1.12 shows how a source
    observable is transformed by some operator (maybe `map`?) to yield a new observable.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你看到`Observable`对象时，你应该从图1.11的角度去思考。JavaScript将`Observable`内置到语言中，旨在标准化使用像RxJS这样的库所能做的令人惊叹的事情。有了可观察者，你可以订阅来自任何来源的事件：一个简单的函数、一个数组、一个事件发射器（如DOM）、一个HTTP请求、promises、生成器，甚至是WebSockets。这个想法是你可以将每份数据视为时间中的一个事件，并使用一组一致的运算符（可观察函数）来处理它。像函数、promises和ADTs一样，可观察者是可组合的。你看到了一个模式吗？这个模式不是巧合；它是现代软件的编码模式，并且大多数语言都在越来越多地采用这种模式。因此，你也可以通过调用一系列可组合的运算符来创建链或管道，这些运算符在或转换通过可观察对象流动的数据，以同步或异步的方式处理数据，随着时间向前传播。图1.12显示了源可观察对象是如何通过某个运算符（可能是`map`？）进行转换，从而产生一个新的可观察对象。
- en: '![](../Images/1-12.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/1-12.png)'
- en: Figure 1.12 A source `Observable` object (first long arrow) with all its events
    piped into an operator function and transformed. All new values are emitted by
    means of a new `Observable`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 一个源`Observable`对象（第一个长箭头）将所有事件管道输入到一个运算符函数中并进行了转换。所有新值都是通过一个新的`Observable`发出的。
- en: In chapter 9, we’ll create our own little library of operators. These pipeable
    operators are themselves higher-order functions, and the functions you provide
    to them encode your domain-specific business logic. As I said at the beginning
    of this chapter, and as you’ll see time and time again throughout the book, higher-order
    functions are by far the strongest feature of JavaScript.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章中，我们将创建自己的小运算符库。这些可管道的运算符本身就是高阶函数，而你提供给它们的函数则编码了你的特定业务逻辑。正如我在本章开头所说，并且你将在整本书中反复看到，高阶函数是JavaScript最强大的特性。
- en: I hope that this overview sounds exciting. I’ve kept the discussion at a high
    level for now, but each chapter after this one will dive into lots of detail and
    code. In this book, you’ll not only be exposed to new cutting-edge techniques,
    but also see them implemented in the context of a more contemporary type of application.
    Before we dive into all those nifty topics, let me introduce you to the sample
    application we’ll be building throughout this book. Section 1.6 helps set the
    context for all the code you’ll see.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个概述听起来很吸引人。目前，我将讨论保持在较高水平，但每个随后的章节都将深入许多细节和代码。在这本书中，您不仅将接触到新的尖端技术，还将看到它们在更现代类型的应用程序中的实现。在我们深入所有这些巧妙的话题之前，让我向您介绍我们将在这本书中构建的示例应用。第1.6节有助于为所有您将看到的代码设定背景。
- en: '1.6 Sample application: Blockchain'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 示例应用：区块链
- en: It’s been my experience that most programming books use trivial examples, often
    numeric or foo/bar, to demonstrate a particular feature of a technology. Although
    these examples are effective because they assume zero domain knowledge, the downside
    is that you’re left wondering how they fit into a more complex, realistic application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，大多数编程书籍使用琐碎的例子，通常是数字或foo/bar，来展示技术的特定功能。虽然这些例子因为假设零领域知识而有效，但缺点是您会感到困惑，不知道它们如何适应更复杂、更现实的应用。
- en: If you haven’t been living under a rock for the past few years, you’ve seen
    a lot of hype about blockchain and cryptocurrencies, which have taken the world
    by storm. Many analysts consider blockchain to be one of the most important technologies
    to learn in the years to come. Blockchains are so ubiquitous and prevalent nowadays
    that getting familiar with them will add an invaluable skill to your tool belt—not
    to mention the fact that blockchains are cool. Certainly, teaching this technology
    is not simple, but this application is deliberately kept small and simple to fit
    in this book. No ramp-up is needed, and no background is required. Your own passion
    and drive, with some JavaScript background, are the only prerequisites.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在过去几年里没有躲在石头下，您一定看到了很多关于区块链和加密货币的炒作，它们已经席卷了世界。许多分析师认为，区块链是未来几年需要学习的重要技术之一。如今，区块链无处不在且普遍存在，熟悉它们将为您的工具箱增添一项无价的技能——更不用说区块链本身很酷了。当然，教授这项技术并不简单，但这个应用故意保持小而简单，以便纳入本书。无需任何预热，也不需要任何背景知识。您自己的热情和动力，以及一些JavaScript背景，是唯一的先决条件。
- en: In this book, we’ll build some parts of a simple, naive blockchain protocol
    from scratch to illustrate how we can apply modern JavaScript techniques to a
    real-world problem. Because the focus is on teaching JavaScript, teaching blockchain
    is purely pedagogical and far from a production-ready implementation. Nevertheless,
    you’ll be exposed to some interesting techniques from the blockchain world, such
    as immutability, hashing, mining, and proof of work. For the sake of exploring
    the wide breadth of JavaScript features, we’ll find creative ways to plug in as
    many features and techniques as possible into this small, contrived sample application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将从头开始构建一个简单、直观的区块链协议的部分，以说明我们如何将现代JavaScript技术应用于实际问题。由于重点是教授JavaScript，因此教授区块链纯粹是教学性质的，远非生产就绪的实现。尽管如此，您将接触到区块链世界的一些有趣技术，例如不可变性、哈希、挖矿和工作量证明。为了探索JavaScript功能的广泛范围，我们将找到创造性的方法，尽可能地将尽可能多的功能和技巧融入到这个小型、人为构建的示例应用中。
- en: To give you some background, a blockchain is a type of database made up of a
    list of records (called blocks) that may store any type of data in some chronological
    order. Unlike traditional databases, blocks are immutable records; you can never
    alter the contents of a block, only add new ones.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您提供一些背景信息，区块链是一种由一系列记录（称为区块）组成的数据库，这些记录可以按某种时间顺序存储任何类型的数据。与传统数据库不同，区块是不可变的记录；您永远无法更改区块的内容，只能添加新的区块。
- en: Blocks are linked cryptographically. No pointer or reference connects one block
    to the next, as in a linked list. Rather, each block contains a cryptographically
    secure hash (such as SHA-256), and the hash of a new block depends on the hash
    of the block that preceded it, thereby forming a chain. Because every block is
    hashed from the previous block’s hash, this chain is inherently tamperproof. Manipulating
    even a single property of any transaction in the history of all blocks will result
    in a different hash value that will invalidate the entire chain. This fact is
    one of the main reasons why blockchain data structures are desired not only in
    financial software, but also in secure document-storage solutions, online voting,
    and other industry segments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 区块通过密码学方式相互链接。与链表中的指针或引用不同，没有连接一个区块到下一个区块的指针或引用。相反，每个区块包含一个密码学安全的哈希（如SHA-256），新块的哈希值依赖于前一个块的哈希值，从而形成链。由于每个区块都是从前一个块的哈希值中哈希出来的，这个链天生具有防篡改的特性。即使操纵所有区块历史中任何一笔交易的任何一个属性，也会导致不同的哈希值，从而使整个链无效。这就是为什么区块链数据结构不仅被金融软件所青睐，还被用于安全的文档存储解决方案、在线投票和其他行业领域的主要原因之一。
- en: The process of computing block hashes daisy-chains all the way back to the first
    block in the chain, which is known as the genesis, or block of height 0\. In real
    life, a blockchain is much more complex. For purposes of this book, though, it’s
    enough to picture it as a sequential data structure in which each block stores
    the most recent transactions that occurred. This simplified structure is shown
    in figure 1.13.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 计算区块哈希的过程将所有这些哈希值一直追溯到链中的第一个区块，即创世区块，或高度为0的区块。在现实生活中，区块链要复杂得多。然而，为了本书的目的，我们可以将其想象为一个顺序数据结构，其中每个区块存储了最近发生的交易。这种简化的结构在图1.13中展示。
- en: '![](../Images/1-13.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图1-13](../Images/1-13.png)'
- en: Figure 1.13 A simple representation of a blockchain, in which each block stores
    the previous block’s hash. This hash is used to compute the current block’s own
    hash, effectively connecting all these blocks in a chain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13展示了区块链的一个简单表示，其中每个区块存储了前一个区块的哈希值。这个哈希值用于计算当前区块的自身哈希值，从而有效地将这些区块连接成链。
- en: As you can see in the figure, each block is made up of a block header, which
    is the metadata associated with each block. Part of this header is a field, `previousHash`,
    that stores the previous block’s hash. Aside from metadata, each block may contain
    a payload, which more commonly is a set of transactions. The latest block contains
    the most recent transactions that were pending in the chain at the moment it was
    created.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，每个区块由一个区块头组成，这是与每个区块关联的元数据。区块头的一部分是一个字段，`previousHash`，它存储了前一个区块的哈希值。除了元数据外，每个区块可能还包含一个有效载荷，这通常是一组交易。最新的区块包含了在创建时链上待处理的最新交易。
- en: A transaction looks like a typical bank transaction and has the form “A transferred
    X amount of funds to B,” where A and B are cryptographic public keys that identify
    the parties involved in the transaction. Because the blockchain contains all the
    transactions that occurred in history, in the world of digital currencies like
    Bitcoin, it is known as a public ledger. Unlike your bank account, which is private,
    a blockchain like Bitcoin is public. You might be thinking, “My bank is in charge
    of validating every transaction, so who validates these transactions?” Through
    a process called mining, which you’ll learn about in chapter 8, you can validate
    all the transactions stored in a block, as well as all those stored in history.
    Mining is a resource-intensive process. While mining is happening, the transactions
    are said to be pending. All these pending transactions combine to form the next
    block’s data payload. When the block gets added to the blockchain, the transaction
    is complete.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 交易看起来像典型的银行交易，形式为“A向B转了X金额的资金”，其中A和B是识别交易中各方的加密公钥。由于区块链包含了历史上发生的所有交易，在比特币等数字货币的世界里，它被称为公共账本。与你的银行账户不同，它是私密的，而比特币这样的区块链是公开的。你可能正在想，“我的银行负责验证每一笔交易，那么谁验证这些交易呢？”通过称为挖矿的过程，你将在第8章中了解到，你可以验证存储在区块中的所有交易，以及存储在历史中的所有交易。挖矿是一个资源密集型的过程。在挖矿进行时，交易被认为是待处理的。所有这些待处理的交易组合形成了下一个区块的数据有效载荷。当区块被添加到区块链中时，交易就完成了。
- en: A cryptocurrency acquires monetary value when the backing resource is scarce
    and expensive to find, extract, or “mine,” such as gold, diamonds, or oil. Computers
    can use their powerful processors or arithmetic logic units to perform high-speed
    math that solves a mathematical problem, which is known as proof of work. We’ll
    look at the implementation details of our `proofOfWork` function in chapter 7.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当支撑资源稀缺且难以寻找、提取或“挖掘”时，例如黄金、钻石或石油，加密货币就会获得货币价值。计算机可以使用它们强大的处理器或算术逻辑单元来执行高速数学运算，解决数学问题，这被称为工作量证明。我们将在第7章中查看`proofOfWork`函数的实现细节。
- en: Consider an example of how a transaction is added and then secured by the blockchain
    protocol. Suppose that Luke buys coffee from Ana’s Café for 10 Bitcoin. Users
    are identified by their digital wallets. The payment process triggers logic to
    transfer funds in the form of a new pending transaction. The set of pending transactions
    is stored inside a block; then the block is mined and added to the chain for validation
    to occur. If all validation checks are good, the transactions are said to be complete.
    The incentive for a miner to run this expensive proof-of-work computation is that
    there’s a reward for mining. This protocol is summarized in figure 1.14.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个交易是如何被添加并由区块链协议安全验证的例子。假设路克用10个比特币在安娜的咖啡馆买咖啡。用户通过他们的数字钱包被识别。支付过程触发逻辑以新待处理交易的形式转移资金。待处理交易集存储在区块中；然后该区块被挖掘并添加到链中以进行验证。如果所有验证检查都良好，则称交易已完成。矿工运行这个昂贵的证明工作计算的动力是，有挖掘奖励。这个协议在图1.14中总结。
- en: '![](../Images/1-14.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片1-14](../Images/1-14.png)'
- en: Figure 1.14 Luke buys coffee from Ana’s coffee shop, paying with his digital
    wallet. The payment process creates a new transaction, set to pending. After a
    certain period, miners compete to validate this transaction. Then all the transactions
    that happened, including Luke’s payment, are added as a block in the chain, and
    the payment is complete.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 路克在安娜的咖啡店用他的数字钱包买咖啡。支付过程创建了一个新的待处理交易。在一段时间后，矿工们竞争验证这个交易。然后，包括路克的支付在内的所有发生的交易都被添加到链中的一个区块中，支付完成。
- en: Taking these concepts into account, figure 1.15 shows a simple diagram of all
    the objects involved in this sequence.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些概念，图1.15展示了在这个序列中涉及的所有对象的简单图示。
- en: '![](../Images/1-15.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片1-15](../Images/1-15.png)'
- en: Figure 1.15 The main objects of the domain layer at play in our simple blockchain
    application
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 在我们的简单区块链应用程序中起作用的领域层的主要对象
- en: As we progress through the chapters, we’ll flesh out all these objects as well
    as the business logic that ties them together. Concretely, we’ll implement code
    to validate the entire chain, calculate the Bitcoin balance of a specific user
    (wallet account), execute a simple proof-of-work algorithm, and mine a block into
    a blockchain.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入章节，我们将详细说明所有这些对象以及将它们联系在一起的业务逻辑。具体来说，我们将实现代码以验证整个链，计算特定用户的比特币余额（钱包账户），执行一个简单的证明工作算法，并将一个区块挖掘到区块链中。
- en: Where to find the code
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在哪里可以找到
- en: The code for this book is freely available on GitHub ([https://github.com/JoyOfJava
    Script/joj](https://github.com/JoyOfJavaScript/joj)). The repository contains
    the worked-out blockchain application as well as all code listings in the form
    of unit tests. It’s important to mention that all code samples in this book assume
    strict mode (`"use` `strict";`), which is the recommended way of writing JavaScript.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码在GitHub上免费提供([https://github.com/JoyOfJavaScript/joj](https://github.com/JoyOfJavaScript/joj))。该存储库包含已解决的区块链应用程序以及所有以单元测试形式呈现的代码列表。重要的是要提到，本书中的所有代码示例都假设严格模式（`"use
    strict";`），这是编写JavaScript的推荐方式。
- en: Strict mode is beneficial because it disallows some bad parts of the language,
    such as employing the infamous `with` statement, calling `delete` on a variable
    (it would be nice if JavaScript also forbade calling `delete` on an object property),
    and using some of the newly reserved keywords (such as `interface`). Strict mode
    also turns some passive errors into full-blown exceptions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式是有益的，因为它禁止了一些语言中的不良部分，例如使用臭名昭著的`with`语句，对一个变量调用`delete`（如果JavaScript也禁止对对象属性调用`delete`会更好），以及使用一些新保留的关键字（例如`interface`）。严格模式还将一些被动错误转换为完全的异常。
- en: The repository also includes Babel configuration files to transpile some nonstandard
    proposals that will change your JavaScript coding in the future. Babel is not
    covered in the chapters, but you can read a bit more about it in appendix A.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库还包括Babel配置文件，用于转换一些将改变你未来JavaScript编码的非标准提案。Babel在章节中没有涉及，但你可以在附录A中了解更多关于它的信息。
- en: 'To run each chapter’s listings, you have two options: download and install
    Node.js v14 or later to run the code locally, or use a minimal Docker configuration
    that configures a virtual environment with Node.js 14 and contains all the required
    project configurations. Docker is convenient if you don’t want to or can’t upgrade
    your environment. The Docker sandbox ensures that all the code works regardless
    of your system configuration or even which operating system you use. It’s straightforward
    to sign up and download a Docker engine for your specific OS from [https://www.docker.com/
    products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行每一章的代码示例，你有两种选择：下载并安装Node.js v14或更高版本以在本地运行代码，或者使用一个最小的Docker配置，该配置配置了一个带有Node.js
    14的虚拟环境，并包含所有必需的项目配置。如果你不想或不能升级你的环境，Docker非常方便。Docker沙盒确保所有代码都能在没有你的系统配置或甚至你使用的操作系统的情况下正常工作。从[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)注册并下载适用于你特定操作系统的Docker引擎非常简单。
- en: Visit the GitHub project’s README.md file for instructions about how to get
    started.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 访问GitHub项目的README.md文件，获取有关如何开始的说明。
- en: This 10,000-foot introduction to some of the ideas and new concepts covered
    in this book scratches the surface. By the end, you’ll see that JavaScript possesses
    all the expressive power you need to let your limitless creativity and imagination
    run wild while writing lean and clean code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书对其中一些思想和新概念的10,000英尺高的介绍只是触及了表面。到结束时，你会发现JavaScript拥有你需要的所有表达力，让你在编写精简且干净的代码时，让你的无限创造力和想象力自由驰骋。
- en: So welcome aboard. I trust that you will find this book fun and engaging as
    you embark on the journey that is the joy of JavaScript!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，欢迎加入我们。我相信，当你开始这段是JavaScript乐趣的旅程时，你会觉得这本书既有趣又引人入胜！
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'JavaScript has two important features that differentiate it from other languages:
    a prototype-based object model and higher-order functions. You can combine these
    features in systematic ways to craft powerful, elegant code.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript有两个重要的特性，使其与其他语言区分开来：基于原型的对象模型和高级函数。你可以以系统化的方式结合这些特性，以构建强大而优雅的代码。
- en: TC39, ECMAScript’s standards body, has committed to releasing new features to
    JavaScript every year. Now we have a community-driven process to evolve JavaScript
    following the ECMA standard as well as to fix any shortcomings quickly. In this
    book. you’ll learn how to use the bind and pipeline operators, code with observables,
    and use many other new features, all originating from this process.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TC39，ECMAScript的标准机构，致力于每年向JavaScript发布新功能。现在，我们有一个社区驱动的流程来根据ECMA标准发展JavaScript，以及快速修复任何缺陷。在这本书中，你将学习如何使用绑定和管道操作符，使用可观测者进行编码，以及使用许多其他新功能，所有这些功能都源于这个过程。
- en: JavaScript’s dynamic object model makes it easy to use mixin composition over
    prototype inheritance by taking advantage of dynamic object extension.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的动态对象模型使其能够利用动态对象扩展，通过混合组合而不是原型继承来使用混合组合。
- en: Abstractions should make code more specific or refined by stripping ideas down
    to their fundamental concepts. ADTs refine code branching, error handling, null
    checking, and other programming tasks.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象应该通过将想法简化到其基本概念来使代码更加具体或精细。ADTs（抽象数据类型）可以优化代码分支、错误处理、空值检查和其他编程任务。
- en: FP uses techniques such as function composition to make your code leaner and
    more declarative.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程（FP）使用诸如函数组合等技术，使你的代码更加精简和声明式。
- en: JavaScript is one of the few languages that has had first-class support for
    asynchronous programming since the beginning. It was revamped with the advent
    of `async/await`, which completely abstracts the asynchronous nature of the code.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript是少数几种从一开始就支持异步编程的语言之一。它随着`async/await`的出现而进行了改进，这完全抽象了代码的异步性质。
- en: Observables use the streams programming model to provide a consistent pane of
    glass over any type of data source—synchronous, asynchronous, single-value, or
    infinite.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观测者使用流编程模型，为任何类型的数据源——同步的、异步的、单值或无限的——提供一致的全景视图。
