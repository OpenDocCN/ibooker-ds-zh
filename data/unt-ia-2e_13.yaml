- en: 10 Connecting your game to the internet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 将你的游戏连接到互联网
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Generating dynamic visuals for the sky
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为天空生成动态视觉效果
- en: Downloading data using web requests in coroutines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程进行网络请求下载数据
- en: Parsing common data formats like XML and JSON
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析常见的数据格式，如XML和JSON
- en: Displaying images downloaded from the internet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示从互联网下载的图片
- en: Sending data to a web server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Web服务器发送数据
- en: In this chapter, you’ll learn how to send and receive data over a network. The
    projects built in previous chapters represented a variety of game genres, but
    all have been isolated to the player’s machine. Connecting to the internet and
    exchanging data is increasingly important for games in all genres.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何通过网络发送和接收数据。前几章中构建的项目代表了各种游戏类型，但所有这些都局限于玩家的机器上。对于所有类型的游戏来说，连接到互联网并交换数据变得越来越重要。
- en: Many games exist almost entirely over the internet, with constant connection
    to a community of other players; games of this sort are referred to as massively
    multiplayer online (MMO) and are most widely known through MMO role-playing games
    (MMORPGs). Even when a game doesn’t require such constant connectivity, modern
    video games usually incorporate features like reporting scores to a global list
    of high scores, or they record analytics to help improve the game. Unity provides
    support for such networking, so we’ll be going over those features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏几乎完全在互联网上进行，与玩家社区的持续连接；这类游戏被称为大型多人在线（MMO），最广为人知的是MMO角色扮演游戏（MMORPG）。即使游戏不需要这种持续的连接，现代视频游戏通常也包含将分数报告给全球高分榜或记录分析以帮助改进游戏的功能。Unity提供了对这种网络的支持，因此我们将介绍这些功能。
- en: 'Unity supports multiple approaches to network communication, since different
    approaches are better suited to different needs. This chapter covers the most
    general sort of internet communication: issuing HTTP requests.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持多种网络通信方法，因为不同的方法更适合不同的需求。本章涵盖了最通用的互联网通信方式：发出HTTP请求。
- en: What are HTTP requests?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是HTTP请求？
- en: 'I assume most readers know what HTTP requests are, but here’s a quick primer
    just in case: Hypertext Transfer Protocol (HTTP) is a communication protocol for
    sending requests to and receiving responses from web servers. When you click a
    link on a web page, your browser (the client) sends out a request to a specific
    address, and then that server responds with the new page. HTTP requests can be
    set to a variety of methods, in particular either GET or POST, to retrieve or
    to send data.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设大多数读者都知道什么是HTTP请求，但这里有一个快速入门，以防万一：超文本传输协议（HTTP）是一种用于向Web服务器发送请求并接收响应的通信协议。当你点击网页上的链接时，你的浏览器（客户端）会向特定地址发送请求，然后该服务器会响应新的页面。HTTP请求可以设置为各种方法，特别是GET或POST，以检索或发送数据。
- en: HTTP requests are reliable, and that’s why the majority of the internet is built
    around them. The requests themselves, as well as the infrastructure for handling
    such requests, are designed to be robust and handle a wide range of failures in
    the network.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求是可靠的，这也是为什么互联网的大部分内容都是围绕它们构建的。请求本身以及处理此类请求的基础设施都设计得非常健壮，能够处理网络中广泛的各种故障。
- en: As a good comparison, imagine how a modern single-page web application works
    (as opposed to old-school web development based on web pages generated server-side).
    In an online game built around HTTP requests, the project developed in Unity is
    essentially a thick client that communicates with the server in an Ajax style.
    However, the familiarity of this approach can be misleading for experienced web
    developers. Video games often have much more stringent performance requirements
    than web applications, and these differences can affect design decisions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种良好的比较，想象一下现代单页Web应用是如何工作的（与基于服务器端生成网页的老式Web开发相对）。在一个围绕HTTP请求构建的在线游戏中，Unity中开发的项目本质上是一个厚客户端，以Ajax风格与服务器通信。然而，这种方法的熟悉性可能会误导经验丰富的Web开发者。视频游戏通常比Web应用有更严格的表现要求，这些差异可能会影响设计决策。
- en: WARNING Time scales can be vastly different between web apps and video games.
    Half a second can seem like a short wait for updating a website, but pausing even
    just a fraction of that time can be excruciating in the middle of a high-intensity
    action game. The concept of *fast* is definitely relative to the situation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Web应用和视频游戏之间的时间尺度可能差异很大。对于更新网站来说，半秒钟可能看起来很短，但在高强度的动作游戏中，暂停哪怕是一小部分时间都可能让人难以忍受。*快*的概念绝对与情境相关。
- en: Online games usually connect to a server specifically intended for that game.
    For learning purposes, however, we’ll connect to some freely available internet
    data sources, including both weather data and images we can download. The last
    section of this chapter requires you to set up a custom web server; that section
    is optional because of that requirement, although I’ll explain an easy way to
    do it with open source software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在线游戏通常连接到专门为该游戏设计的服务器。然而，出于学习目的，我们将连接到一些免费可用的互联网数据源，包括可以下载的天气数据和图像。本章的最后部分要求你设置一个自定义的Web服务器；由于这个要求，该部分是可选的，尽管我会解释一种使用开源软件的简单方法来做这件事。
- en: 'The plan for this chapter is to go over multiple uses of HTTP requests so you
    can learn how they work within Unity:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的计划是回顾HTTP请求的多种用途，以便你可以在Unity中了解它们是如何工作的：
- en: Setting up an outdoor scene (in particular, building a sky that can react to
    the weather data)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置户外场景（特别是，构建可以响应天气数据的天空）
- en: Writing code to request weather data from the internet
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码从互联网请求天气数据
- en: Parsing the response and then modifying the scene based on the data
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析响应并根据数据修改场景
- en: Downloading and displaying an image from the internet
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从互联网下载并显示图像
- en: Posting data to your own server (in this case, a log of weather conditions)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向你的服务器（在这种情况下，是天气状况日志）发送数据
- en: The actual game that you’ll use for this chapter’s project matters little. Everything
    in this chapter will add new scripts to an existing project and won’t modify any
    of the existing code. For the sample code, I used the movement demo from chapter
    2, mostly so we can see the sky in first-person view when it gets modified.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章项目中使用的实际游戏关系不大。本章中的一切都将向现有项目添加新的脚本，而不会修改任何现有代码。对于示例代码，我使用了第2章中的移动演示，主要是为了在修改后能够以第一人称视角看到天空。
- en: The project for this chapter isn’t directly tied into the gameplay, but obviously
    for most games you create, you would want the networking tied to the gameplay
    (for example, spawning enemies based on responses from the server). On to the
    first step!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目与游戏玩法没有直接关联，但显然对于你创建的大多数游戏，你希望网络与游戏玩法相关联（例如，根据服务器的响应生成敌人）。接下来是第一步！
- en: 10.1 Creating an outdoor scene
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 创建户外场景
- en: Because we’re going to be downloading weather data, we’ll first set up an outdoor
    area where the weather will be visible. The trickiest part of that will be the
    sky, but first let’s take a moment to apply outdoors-looking textures on the level
    geometry.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将下载天气数据，我们首先设置一个户外区域，在那里天气将可见。其中最棘手的部分将是天空，但首先让我们花点时间将看起来像户外的纹理应用到关卡几何形状上。
- en: Just as in chapter 4, I obtained a couple of images from [www.textures.com](https://www.textures.com/)
    to apply to the walls and floor of the level. Remember to change the size of the
    downloaded images to a power of 2, such as 256 × 256.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在第4章中一样，我从[www.textures.com](https://www.textures.com/)获取了一些图像，用于应用到关卡墙壁和地板上。记住将下载的图像的大小更改为2的幂，例如256
    × 256。
- en: Then import the images into the Unity project, create materials, and assign
    the images to the materials (that is, drag an image into the texture slot of the
    material). Drag the materials onto the walls or floor in the scene, and increase
    tiling in the material (try numbers like 8 or 9 in one or both directions) so
    that the image won’t be stretched in an ugly way. Once the ground and walls are
    taken care of, it’s time to address the sky.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将图像导入Unity项目，创建材质，并将图像分配给材质（即，将一个图像拖动到材质的纹理槽中）。将材质拖放到场景中的墙壁或地板上，并在材质中增加平铺（尝试一个或两个方向上的数字，如8或9），这样图像就不会以难看的方式拉伸。一旦地面和墙壁处理完毕，就轮到处理天空了。
- en: 10.1.1 Generating sky visuals by using a skybox
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 通过使用天空盒生成天空视觉效果
- en: Start by importing the skybox images as you did in chapter 4\. Once again, I
    obtained skybox images from [www.93i.de/](https://93i.de/), but this time I got
    the DarkStormy set in addition to TropicalSunnyDay (the sky will be more complex
    in this project). Simply get them from the book’s sample project or download skybox
    images you find elsewhere. Import these textures into Unity and (as explained
    in chapter 4) set their Wrap Mode to Clamp.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像第4章中那样导入天空盒图像。再次，我从[www.93i.de/](https://93i.de/)获取了天空盒图像，但这次我除了TropicalSunnyDay（在这个项目中天空将更加复杂）之外，还得到了DarkStormy。只需从书籍的示例项目中获取它们或从其他地方下载天空盒图像。将这些纹理导入Unity，并（如第4章中所述）将它们的Wrap
    Mode设置为Clamp。
- en: Now create a new material to use for this skybox. At the top of the settings
    for this material, click the Shader menu to see the drop-down list with all the
    available shaders. Move down to the Skybox section and choose 6-Sided in that
    submenu. With this shader active, the material now has six texture slots (instead
    of only the small Albedo texture slot that the standard shader had).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的材质来用于这个天空盒。在这个材质的设置顶部，点击着色器菜单以查看所有可用着色器的下拉列表。向下移动到天空盒部分，并在子菜单中选择6-Sided。使用这个着色器后，材质现在有六个纹理槽（而不是标准着色器中只有的小Albedo纹理槽）。
- en: Drag the SunnyDay skybox images to the texture slots of the new material. The
    names of the images correspond to the texture slot to assign them to (top, front,
    and so on). Once all six textures are linked, you can use this new material as
    the skybox for the scene.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将SunnyDay天空盒图像拖动到新材质的纹理槽中。图像的名称对应于分配给它们的纹理槽（顶部、前面等）。一旦所有六个纹理都链接好了，你就可以使用这个新材质作为场景的天空盒。
- en: Assign this skybox material by opening the Lighting window (Window > Rendering
    > Lighting). Switch to the Environment tab and assign the material for your skybox
    to the Skybox slot at the top of the window (either drag the material over or
    click the little circle button next to the slot). Click Play and you should see
    something like figure 10.1.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开照明窗口（窗口 > 渲染 > 照明）来分配这个天空盒材质。切换到环境选项卡，并将你的天空盒材质分配到窗口顶部的天空盒槽中（可以拖动材质到槽中，或者点击槽旁边的圆形按钮）。点击播放，你应该能看到类似于图10.1的效果。
- en: '![CH10_F01_Hocking3](../Images/CH10_F01_Hocking3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F01_Hocking3](../Images/CH10_F01_Hocking3.png)'
- en: Figure 10.1 Scene with background pictures of the sky
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 带有天空背景图片的场景
- en: 'Great, now you have an outdoors scene! A skybox is an elegant way to create
    the illusion of a vast atmosphere surrounding the player. But the skybox shader
    built into Unity does have one significant limitation: the images can never change,
    resulting in a sky that appears completely static. We’ll address that limitation
    by creating a new custom shader.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在你有一个户外场景了！天空盒是一种优雅的方式来创建围绕玩家的广阔氛围的幻觉。但Unity内置的天空盒着色器确实有一个显著的限制：图像永远不会改变，导致天空看起来完全静止。我们将通过创建一个新的自定义着色器来解决这个问题。
- en: 10.1.2 Setting up an atmosphere that’s controlled by code
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 通过代码设置受控的大气环境
- en: The images in the TropicalSunnyDay set look great for a sunny day, but what
    if we want to transition between sunny and overcast weather? This will require
    a second set of sky images (some pictures of a cloudy sky), so we need a new shader
    for the skybox.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TropicalSunnyDay集中的图像在晴天看起来很棒，但如果我们想从晴天过渡到多云天气呢？这将需要一个包含多云天空图片的第二组天空图像，因此我们需要一个新的天空盒着色器。
- en: As explained in chapter 4, a shader is a short program with instructions for
    how to render the image. This implies that you can program new shaders, and that
    is, in fact, the case. We’re going to create a new shader that takes two sets
    of skybox images and transitions between them. Get a shader for this purpose from
    [https://github.com/jhocking/from-unity-wiki/blob/main/SkyboxBlended.shader](https://github.com/jhocking/from-unity-wiki/blob/main/SkyboxBlended.shader).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第4章所述，着色器是一个包含如何渲染图像的指令的简短程序。这意味着你可以编写新的着色器，实际上也是如此。我们将创建一个新的着色器，它接受两组天空盒图像并在它们之间进行转换。为此目的从[https://github.com/jhocking/from-unity-wiki/blob/main/SkyboxBlended.shader](https://github.com/jhocking/from-unity-wiki/blob/main/SkyboxBlended.shader)获取着色器。
- en: 'In Unity, create a new shader script: Go to the Create menu just like when
    you create a new C# script, but select a Standard Surface Shader instead. Name
    the asset SkyboxBlended and then double-click the shader to open the script. Copy
    the code from that webpage and paste it into the shader script. The top line is
    Shader "Skybox/Blended", which tells Unity to add the new shader into the shader
    list under the Skybox category (the same category as the regular skybox).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中创建一个新的着色器脚本：就像创建一个新的C#脚本一样，但选择标准表面着色器。将资产命名为SkyboxBlended，然后双击着色器以打开脚本。从该网页复制代码并将其粘贴到着色器脚本中。顶行是Shader
    "Skybox/Blended"，这告诉Unity将新的着色器添加到Skybox类别下的着色器列表中（与常规天空盒相同的类别）。
- en: NOTE We won’t go over all the details of the shader program right now. Shader
    programming is a pretty advanced computer graphics topic, thus outside the scope
    of this book. You may want to look that up after you’ve finished this book; if
    so, start with the Unity Manual at [http://mng.bz/wQzQ](http://mng.bz/wQzQ).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们现在不会详细讲解着色器程序的所有细节。着色器编程是一个相当高级的计算机图形学话题，因此超出了本书的范围。您可以在阅读完本书后查找相关信息；如果是这样，可以从Unity手册开始，网址为[http://mng.bz/wQzQ](http://mng.bz/wQzQ)。
- en: Now you can set your material to the Skybox Blended shader. Again, select the
    material and then look for the Shader menu at the top of the material’s settings.
    There are now 12 texture slots, in two sets of six images. Assign TropicalSunnyDay
    images to the first six textures just as before; for the remaining textures, use
    the DarkStormy set of skybox images.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以设置材质为Skybox Blended着色器。再次，选择材质，然后在材质设置的最顶部查找着色器菜单。现在有12个纹理槽位，分为两组，每组六张图像。与前一样，将TropicalSunnyDay图像分配给前六个纹理；对于剩余的纹理，使用DarkStormy天空盒图像集。
- en: This new shader also added a Blend slider near the top of the settings. The
    Blend value controls how much of each set of skybox images you want to display;
    when you adjust the slider from one side to the other, the skybox transitions
    from sunny to overcast. You can test by adjusting the slider and playing the game,
    but manually adjusting the sky isn’t terribly helpful while the game is running,
    so let’s write code to transition the sky.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的着色器还在设置的最顶部添加了一个混合滑块。混合值控制您想要显示每套天空盒图像的多少；当您调整滑块从一侧到另一侧时，天空盒会从晴朗过渡到多云。您可以通过调整滑块并玩游戏来测试，但在游戏运行时手动调整天空并不十分有帮助，所以让我们编写代码来过渡天空。
- en: Create an empty object in the scene and name it Controller. Create a new script
    and name it WeatherController. Drag that script onto the empty object and then
    write this listing in that script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中创建一个空对象并命名为Controller。创建一个新的脚本并命名为WeatherController。将此脚本拖放到空对象上，然后在脚本中编写以下代码。
- en: Listing 10.1 WeatherController script transitioning from sunny to overcast
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 WeatherController脚本从晴朗过渡到多云
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Reference the material in Project view, not only objects in the scene.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在项目视图中参考材质，而不仅仅是场景中的对象。
- en: ❷ Initial intensity of the light is considered “full” intensity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 灯光的初始强度被认为是“全强度”。
- en: ❸ Increment the value every frame for a continuous transition.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每帧增加值以实现连续过渡。
- en: ❹ Adjust both the material’s Blend value and the light’s intensity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调整材质的混合值和灯光的强度。
- en: I’ll point out several things in this code, but the key new method is SetFloat(),
    which appears almost at the bottom. Everything up to that point should be fairly
    familiar, but that one is new. The method sets a number value on the material.
    The first parameter to that method defines *which* value specifically. In this
    case, the material has a property called _Blend (note that material properties
    in code start with an underscore).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在代码中指出来几个要点，但关键的新方法是SetFloat()，它几乎出现在底部。到那时为止的所有内容都应该相当熟悉，但那一个是新的。该方法在材质上设置一个数值。该方法的第一参数定义了具体是哪个值。在这种情况下，材质有一个名为_Blend（注意代码中的材质属性以下划线开头）的属性。
- en: As for the rest of the code, we define a few variables, including both the material
    and a light. For the material, you want to reference the blended skybox material
    we just created, but what’s with the light? That’s so that the scene will also
    darken when transitioning from sunny to overcast; as the Blend value increases,
    we’ll turn down the light. The directional light in the scene acts as the main
    light and provides illumination everywhere. Drag both the material and the light
    onto the variables in the Inspector.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 至于其余的代码，我们定义了一些变量，包括材质和灯光。对于材质，您想要引用我们刚刚创建的混合天空盒材质，但灯光呢？这是为了让场景在从晴朗变为多云时也会变暗；随着混合值的增加，我们将降低灯光。场景中的方向光作为主光，为各个地方提供照明。将材质和灯光拖放到检查器中的变量上。
- en: NOTE The advanced lighting system in Unity takes the skybox into account to
    achieve realistic results. But this lighting approach won’t work right with a
    changing skybox, so you may want to freeze the lighting setup. In the Lighting
    window, you can turn off the Auto Generate check box at the bottom; then the setup
    will update only when you click the button. Set the Blend of the skybox to the
    middle for an average look and then click the Generate button (next to the Auto
    check box) to manually bake lightmaps (lighting information was saved in a new
    folder that’s named after the scene).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：Unity的高级照明系统会考虑天空盒以实现逼真的效果。但这种方法与不断变化的天空盒不兼容，因此你可能想要冻结照明设置。在照明窗口中，你可以关闭底部的自动生成复选框；然后设置将仅在点击按钮时更新。将天空盒的混合设置为中间以获得平均外观，然后点击生成按钮（位于自动复选框旁边）以手动烘焙光照贴图（光照信息已保存到一个以场景命名的新文件夹中）。
- en: When the script starts, it initializes the intensity of the light. The script
    will store the starting value and consider that to be the full intensity. This
    full intensity will be used later in the script when dimming the light.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本开始运行时，它会初始化光线的强度。脚本将存储起始值，并将其视为全强度。这个全强度将在脚本中稍后用于调暗光线。
- en: Then the code increments a value every frame and uses that value to adjust the
    sky. Specifically, it calls SetOvercast() every frame, and that function encapsulates
    the multiple adjustments made to the scene. I’ve already explained what SetFloat()
    is doing, so we won’t go over that again, and the last line adjusts the intensity
    of the light.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码在每一帧增加一个值，并使用该值来调整天空。具体来说，它每帧调用一次 SetOvercast()，该函数封装了对场景进行的多次调整。我已经解释了
    SetFloat() 的作用，所以我们将不再重复，最后一行调整了光线的强度。
- en: 'Now play the scene to watch the code running. You’ll see the depiction in figure
    10.2: over a couple of seconds, you’ll see the scene transition from a sunny day
    to dark and overcast.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在播放场景以观看代码的运行。你会看到图10.2中的描述：在几秒钟内，你会看到场景从晴朗的一天过渡到黑暗和多云。
- en: '![CH10_F02_Hocking3](../Images/CH10_F02_Hocking3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F02_Hocking3](../Images/CH10_F02_Hocking3.png)'
- en: 'Figure 10.2 Before and after: scene transition from sunny to overcast'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：场景从晴朗到多云的过渡前后对比
- en: WARNING One unexpected quirk about Unity is that the Blend change on the material
    is permanent. Unity resets objects in the scene when the game stops running, but
    assets that were linked directly from the Project view (such as the skybox material)
    are changed permanently. This happens only within Unity’s editor (changes don’t
    carry over between plays after the game is deployed outside the editor), thus
    resulting in frustrating bugs if you forget about it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Unity的一个意想不到的怪癖是，材质上的混合变化是永久的。当游戏停止运行时，Unity会重置场景中的对象，但直接从项目视图链接的资产（如天空盒材质）会永久更改。这仅在Unity的编辑器内发生（更改不会在游戏部署到编辑器外后传递），因此如果你忘记这一点，可能会导致令人沮丧的错误。
- en: 'Watching the scene transition from sunny to overcast is pretty cool. But this
    was all just a setup for the actual goal: having the weather in the game sync
    up to real-world weather conditions. For that, we need to start downloading weather
    data from the internet.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 观看场景从晴朗变为多云的过渡非常酷。但这只是为实际目标所做的设置：让游戏中的天气与真实世界的天气条件同步。为此，我们需要开始从互联网下载天气数据。
- en: 10.2 Downloading weather data from an internet service
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 从互联网服务下载天气数据
- en: Now that we’ve set up the outdoors scene, we can write code that will download
    weather data and modify the scene based on that data. This task will provide a
    good example of retrieving data by using HTTP requests. Many web services provide
    weather data; an extensive list is posted at ProgrammableWeb ([www.programmableweb.com)](https://www.programmableweb.com).
    I chose OpenWeather; the code examples use its API (application programming interface,
    a way to access their service using code commands instead of a graphical interface)
    located at [http://openweathermap.org/api](http://openweathermap.org/api).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了户外场景，我们可以编写代码来下载天气数据并根据这些数据修改场景。这个任务将很好地展示如何通过使用HTTP请求来检索数据。许多网络服务提供天气数据；一个详尽的列表发布在
    ProgrammableWeb ([www.programmableweb.com](https://www.programmableweb.com))。我选择了
    OpenWeather；代码示例使用了其API（应用程序编程接口，一种使用代码命令而不是图形界面来访问其服务的方式），API位于 [http://openweathermap.org/api](http://openweathermap.org/api)。
- en: DEFINITION A *web service**,* or *web API**,* is a server connected to the internet
    that returns data upon request. There’s no technical difference between a web
    API and a website; a website is a web service that happens to return the data
    for a web page, and browsers interpret HTML data as a visible document.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*网络服务*，或*网络 API*，是指连接到互联网并在请求时返回数据的服务器。网络 API 和网站之间没有技术上的区别；网站是一个返回网页数据的网络服务，浏览器将
    HTML 数据解释为可见文档。
- en: NOTE Web services often require you to register, even for free service. For
    example, if you go to the API page for OpenWeather, it has instructions for obtaining
    an API key, a value you will paste into requests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：网络服务通常需要您注册，即使是免费服务。例如，如果您访问 OpenWeather 的 API 页面，它有获取 API 密钥的说明，这是一个您将粘贴到请求中的值。
- en: The code you’ll write will be structured around the same Managers architecture
    from chapter 9\. This time, you’ll have a WeatherManager class that gets initialized
    from the central manager of managers. WeatherManager will be in charge of retrieving
    and storing weather data, but to do so, it’ll need the ability to communicate
    with the internet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要编写的代码将围绕第 9 章中相同的 Managers 架构。这次，您将有一个从管理者的中心管理者初始化的 WeatherManager 类。WeatherManager
    将负责检索和存储天气数据，但要做到这一点，它需要能够与互联网通信。
- en: To accomplish that, you’ll create a utility class called NetworkService to handle
    the details of connecting to the internet and making HTTP requests. WeatherManager
    can then tell NetworkService to make those requests and pass back the response.
    Figure 10.3 shows how this code structure will operate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您将创建一个名为 NetworkService 的实用程序类来处理连接到互联网和制作 HTTP 请求的细节。然后，WeatherManager
    可以告诉 NetworkService 进行这些请求并返回响应。图 10.3 显示了这种代码结构将如何运行。
- en: '![CH10_F03_Hocking3](../Images/CH10_F03_Hocking3.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F03_Hocking3](../Images/CH10_F03_Hocking3.png)'
- en: Figure 10.3 How the networking code will be structured
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 网络代码的结构
- en: For this to work, obviously WeatherManager will need to have access to the NetworkService
    object. You’re going to address this by creating the object in Managers and then
    injecting the NetworkService object into the various managers when they’re initialized.
    In this way, not only will WeatherManager have a reference to the NetworkService,
    but so will any other managers you create later.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，显然 WeatherManager 将需要访问 NetworkService 对象。您将通过在 Managers 中创建对象并在初始化时将
    NetworkService 对象注入到各个管理者来解决此问题。这样，不仅 WeatherManager 将拥有对 NetworkService 的引用，您以后创建的任何其他管理者也将拥有。
- en: To start bringing over the Managers code architecture from chapter 9, first
    copy over ManagerStatus and IGameManager (remember that IGameManager is the interface
    that all managers must implement, whereas ManagerStatus is an enum that IGameManager
    uses). You’ll need to modify IGameManager slightly to accommodate the new NetworkService
    class, so create a new script called NetworkService (delete :MonoBehaviour and
    otherwise leave it empty for now; you’ll fill it in later) and then adjust IGameManager.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要从第 9 章开始引入 Managers 的代码架构，首先复制 ManagerStatus 和 IGameManager（记住 IGameManager
    是所有管理者必须实现的接口，而 ManagerStatus 是 IGameManager 使用的枚举）。您需要稍微修改 IGameManager 以适应新的
    NetworkService 类，因此创建一个新的脚本名为 NetworkService（删除 :MonoBehaviour 并暂时将其留空；您稍后会填写它）然后调整
    IGameManager。
- en: Listing 10.2 Adjusting IGameManager to include NetworkService
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 调整 IGameManager 以包含 NetworkService
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '❶ The startup function now takes one parameter: the injected object.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启动函数现在接受一个参数：注入的对象。
- en: Next let’s create WeatherManager to implement this slightly adjusted interface.
    Create a new C# script.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 WeatherManager 来实现这个稍微调整过的接口。创建一个新的 C# 脚本。
- en: Listing 10.3 Initial script for WeatherManager
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 WeatherManager 的初始脚本
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Store the injected NetworkService object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储注入的 NetworkService 对象。
- en: 'This initial pass at WeatherManager doesn’t really do anything. For now, the
    class implements the minimum amount that IGameManager requires: declare the status
    property from the interface and implement the Startup() function. You’ll fill
    in this empty framework over the next few sections. Finally, copy over Managers
    from chapter 9 and adjust it to start up WeatherManager.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 WeatherManager 的初始版本实际上并没有做任何事情。目前，该类实现了 IGameManager 所需的最小量：从接口声明状态属性并实现
    Startup() 函数。您将在接下来的几节中填充这个空框架。最后，复制第 9 章的 Managers 并调整它以启动 WeatherManager。
- en: Listing 10.4 Managers adjusted to initialize WeatherManager
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 调整后的 Managers 以初始化 WeatherManager
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Require the new manager instead of player and inventory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要新的管理者而不是玩家和库存。
- en: ❷ Instantiate NetworkService to inject in all managers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 实例化NetworkService以注入所有管理器。
- en: ❸ Pass the network service to managers during startup.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在启动时将网络服务传递给管理器。
- en: And that’s everything needed codewise for the Managers code architecture. As
    you have in previous chapters, create the game managers object in the scene and
    then attach both Managers and WeatherManager to the empty object. Even though
    the manager isn’t doing anything yet, you can see startup messages in the console
    when it’s set up correctly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Manager代码架构所需的所有代码。正如你在前面的章节中所做的那样，在场景中创建游戏管理器对象，然后将Manager和WeatherManager附加到空对象上。即使管理器目前还没有做任何事情，你可以在设置正确时在控制台中看到启动消息。
- en: Whew, we had quite a few boilerplate things to get out of the way! Now we can
    get on with writing the networking code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们有很多样板代码要处理！现在我们可以继续编写网络代码。
- en: 10.2.1 Requesting HTTP data using coroutines
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 使用协程请求HTTP数据
- en: NetworkService is currently an empty script, so you can write code in it to
    make HTTP requests. The primary class you need to know about is UnityWebRequest.
    Unity provides the UnityWebRequest class to communicate with the internet. Instantiating
    a request object using a URL will send a request to that URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkService目前是一个空脚本，所以你可以在其中编写代码来制作HTTP请求。你需要了解的主要类是UnityWebRequest。Unity提供了UnityWebRequest类来与互联网通信。使用URL实例化请求对象将向该URL发送请求。
- en: 'Coroutines can work with the UnityWebRequest class to wait for the request
    to complete. Coroutines were introduced in chapter 3, where we used them to pause
    code for a set period of time. Recall the explanation given there: coroutines
    are special functions that seemingly run in the background of a program, in a
    repeated cycle of running partway and then returning to the rest of the program.
    When used along with the StartCoroutine() method, the yield keyword causes the
    coroutine to temporarily pause, handing back the program flow and picking up again
    from that point in the next frame.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以与UnityWebRequest类一起工作，等待请求完成。协程在第3章中介绍，我们使用它们来暂停代码一段时间。回想一下那里的解释：协程是似乎在程序后台运行的特殊函数，在运行部分并返回到程序其余部分的循环中。当与StartCoroutine()方法一起使用时，yield关键字使协程暂时暂停，将程序流程交回，并在下一帧从该点继续。
- en: 'In chapter 3, the coroutines yielded at WaitForSeconds(), an object that caused
    the function to pause for a specific number of seconds. Yielding a coroutine when
    sending a request will pause the function until that network request completes.
    The program flow here is similar to making asynchronous Ajax calls in a web application:
    first you send a request, then you continue with the rest of the program, and
    after some time you receive a response.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，WaitForSeconds()协程产生的yield，这是一个使函数暂停特定秒数的对象。在发送请求时产生协程将暂停函数，直到网络请求完成。这里的程序流程类似于在Web应用程序中制作异步Ajax调用：首先发送请求，然后继续执行程序的其余部分，过一段时间后收到响应。
- en: That was the theory; now let’s write the code
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那是理论部分；现在让我们编写代码
- en: All right, let’s implement this stuff in our code. First open the NetworkService
    script and replace the default template with the contents of this listing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们在我们的代码中实现这些功能。首先打开NetworkService脚本，并将默认模板替换为这个列表的内容。
- en: Listing 10.5 Making HTTP requests in NetworkService
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 在NetworkService中制作HTTP请求
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ URL to send request to
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 发送请求的URL
- en: ❷ Create UnityWebRequest object in GET mode.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在GET模式下创建UnityWebRequest对象。
- en: ❸ Pause while downloading.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 下载时暂停。
- en: ❹ Check for errors in the response.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查响应中的错误。
- en: ❺ Delegate can be called just like the original function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 可以像原始函数一样调用委托。
- en: ❻ Yield cascades through coroutine methods that call each other.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通过相互调用的协程方法产生级联。
- en: warning The Action type (explained in “Understanding how the callback works”)
    is contained in the System namespace; notice the additional using statements at
    the top of the script. Don’t forget this detail in your scripts!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Action类型（在“理解回调如何工作”中解释）包含在System命名空间中；注意脚本顶部的附加using语句。不要忘记这个细节！
- en: 'Remember the code design explained earlier: WeatherManager will tell NetworkService
    to go fetch data. All this code doesn’t actually run yet; you’re setting up code
    that will be called by WeatherManager a bit later. To explore this code listing,
    let’s start at the bottom and work our way up.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住之前解释的代码设计：WeatherManager将告诉NetworkService去获取数据。所有这些代码实际上还没有运行；你正在设置稍后将被WeatherManager调用的代码。为了探索这个代码列表，让我们从底部开始，逐步向上。
- en: Writing coroutine methods that cascade through each other
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编写相互级联的协程方法
- en: GetWeatherXML()is the coroutine method that outside code can use to tell NetworkService
    to make an HTTP request. Notice that this function has IEnumerator for its return
    type; methods used in coroutines must have IEnumerator declared as the return
    type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GetWeatherXML() 是一个协程方法，外部代码可以使用它来告诉 NetworkService 发起一个 HTTP 请求。请注意，这个函数的返回类型是
    IEnumerator；在协程中使用的函数必须声明为 IEnumerator 类型。
- en: It might look odd at first that GetWeatherXML() doesn’t have a yield statement.
    Coroutines are paused by the yield statement, which implies that every coroutine
    must yield somewhere. It turns out that the yielding can cascade through multiple
    methods. If the initial coroutine method itself calls another method, and that
    other method yields part of the way through, then the coroutine will pause inside
    that second method and resume there. Thus, the yield statement in CallAPI() pauses
    the coroutine that was started in GetWeatherXML(); figure 10.4 shows this code
    flow.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，GetWeatherXML() 没有使用 yield 语句可能看起来有些奇怪。协程通过 yield 语句暂停，这意味着每个协程必须在某个地方产生。结果是，yield
    可以通过多个方法级联。如果初始的协程方法本身调用了另一个方法，并且那个方法在中间部分产生了，那么协程将在那个第二个方法内部暂停，并在那里恢复。因此，CallAPI()
    中的 yield 语句暂停了在 GetWeatherXML() 中启动的协程；图 10.4 展示了这段代码的流程。
- en: '![CH10_F04_Hocking3](../Images/CH10_F04_Hocking3.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F04_Hocking3](../Images/CH10_F04_Hocking3.png)'
- en: Figure 10.4 How the network coroutine works
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 网络协程的工作方式
- en: The next potential head-scratcher is the callback parameter of type Action.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个可能让人头疼的是 Action 类型的回调参数。
- en: Understanding how the callback works
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理解回调的工作原理
- en: When the coroutine is started, the method is called with a parameter called
    callback, and callback has the Action type. But what is an Action?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当协程启动时，方法会带有一个名为 callback 的参数被调用，并且 callback 是 Action 类型。但什么是 Action？
- en: DEFINITION The Action type is a delegate (C# has a few approaches to delegates,
    but this one is the simplest). Delegates are references to some other method/function.
    They allow you to store the function (or rather, a pointer to the function) in
    a variable and to pass that function as a parameter to another function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** Action 类型是一个委托（C# 有几种处理委托的方法，但这种方法是最简单的）。委托是对其他方法/函数的引用。它们允许你将函数（或者更确切地说，函数的指针）存储在变量中，并将该函数作为参数传递给另一个函数。'
- en: If you’re unfamiliar with the concept of delegates, realize that they enable
    you to pass around functions just as you do numbers and strings. Without delegates,
    you can’t pass around functions to call later—you can only directly call the function
    immediately. With delegates, you can tell code about other methods to call later.
    This is useful for many purposes, especially for implementing callback functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉委托的概念，请意识到它们允许你传递函数，就像传递数字和字符串一样。没有委托，你不能传递函数以供稍后调用——你只能立即直接调用函数。有了委托，你可以告诉代码稍后要调用的其他方法。这对于许多用途都很有用，特别是实现回调函数。
- en: DEFINITION A *callback* is a function used to communicate back to the calling
    object. Object A could tell Object B about one of the methods in A. B could later
    call A’s method to communicate back to A.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** *回调* 是一个用于向调用对象返回信息的函数。对象 A 可以告诉对象 B 关于 A 中的一个方法。B 可以稍后调用 A 的方法以将信息返回给
    A。'
- en: In this case, for example, the callback is used to communicate the response
    data back after waiting for the HTTP request to complete. In CallAPI(), the code
    first makes an HTTP request, then yields until that request completes, and finally
    uses callback() to send back the response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，回调用于在等待 HTTP 请求完成后将响应数据返回。在 CallAPI() 中，代码首先发起一个 HTTP 请求，然后等待直到请求完成，最后使用
    callback() 发送响应。
- en: 'Note the <> syntax used with the Action keyword; the type written in the angle
    brackets declares the parameters required to fit this Action. In other words,
    the function this Action points to must take parameters matching the declared
    type. In this case, the parameter is a single string, so the callback method must
    have a signature like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Action 关键字使用的 <> 语法；尖括号中写出的类型声明了符合此 Action 所需的参数。换句话说，这个 Action 所指向的函数必须接受与声明类型匹配的参数。在这种情况下，参数是一个字符串，因此回调方法必须具有如下签名：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The concept of a callback may make more sense after you’ve seen it in action,
    which you will in listing 10.6; this initial explanation is so that you’ll recognize
    what’s going on when you see that additional code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到实际操作之后，回调的概念可能更容易理解，你将在列表10.6中看到它；这个初始解释是为了让你在看到额外的代码时能识别出正在发生的事情。
- en: 'The rest of listing 10.5 is pretty straightforward. The request object is created
    inside a using statement so that the object’s memory will be cleaned up once we’re
    done with that object. The conditional checks for errors in the HTTP response.
    There are two kinds of errors: the request could’ve failed because of a bad internet
    connection, or the response returned could have an error code. A const value is
    declared with the URL to make the request to. (Incidentally, you should replace
    APIKEY at the end with your OpenWeather API key.)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5的其余部分相当直接。请求对象在using语句内部创建，以便在完成该对象后清理对象的内存。条件检查HTTP响应中的错误。有两种类型的错误：请求可能因为网络连接不良而失败，或者返回的响应可能包含错误代码。声明了一个具有请求URL的const值。（顺便说一句，你应该在末尾替换APIKEY为你的OpenWeather
    API密钥。）
- en: Making use of the Networking code
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 利用网络代码
- en: That wraps up the code in NetworkService. Now let’s use NetworkService in WeatherManager.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了NetworkService中的代码。现在让我们在WeatherManager中使用NetworkService。
- en: Listing 10.6 Adjusting WeatherManager to use NetworkService
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 调整WeatherManager以使用NetworkService
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Start loading data from the internet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 开始从互联网加载数据。
- en: ❷ Instead of Started, make the status Initializing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将状态从“Started”改为“Initializing”。
- en: ❸ Callback method after the data is loaded
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 数据加载后的回调方法
- en: 'Three primary changes are made to the code in this manager: starting a coroutine
    to download data from the internet, setting a different startup status, and defining
    a callback method to receive the response.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个管理器中对代码进行了三项主要更改：启动一个协程从互联网下载数据，设置不同的启动状态，并定义一个回调方法以接收响应。
- en: Starting the coroutine is simple. Most of the complexity behind coroutines was
    handled in NetworkService, so calling StartCoroutine() is all you need to do here.
    Then you set a different startup status, because the manager isn’t finished initializing;
    it needs to receive data from the internet before startup is complete.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 启动协程很简单。协程背后的大多数复杂性都由NetworkService处理，所以在这里你只需要调用StartCoroutine()即可。然后你设置一个不同的启动状态，因为管理器还没有完成初始化；在启动完成之前，它需要从互联网接收数据。
- en: WARNING Always start networking methods by using StartCoroutine(); don’t just
    call the function normally. This can be easy to forget because creating request
    objects outside of a coroutine doesn’t generate any sort of compiler error.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：始终使用StartCoroutine()启动网络方法；不要正常调用函数。这很容易忘记，因为在外部协程中创建请求对象不会生成任何编译器错误。
- en: When you call the StartCoroutine() method, you need to invoke the method used
    as a parameter. That is, actually type the parentheses—()—and don’t provide only
    the name of the function. In this case, the coroutine method needs a callback
    function as its one parameter, so let’s define that function. We’ll use OnXMLDataLoaded()
    for the callback; notice that this method has a string parameter, which fits the
    Action<string> declaration from NetworkService. The callback function doesn’t
    do a lot right now; the debug line simply prints the received data to the console
    to verify that the data was received correctly. Then the last line of the function
    changes the startup status of the manager to say that it’s completely started
    up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用StartCoroutine()方法时，你需要调用作为参数使用的方法。也就是说，实际上输入括号—()—，而不仅仅是函数名。在这种情况下，协程方法需要一个回调函数作为其一个参数，所以让我们定义这个函数。我们将使用OnXMLDataLoaded()作为回调；注意，这个方法有一个字符串参数，这与NetworkService中的Action<string>声明相匹配。回调函数目前并不做很多事情；调试行只是将接收到的数据打印到控制台以验证数据是否正确接收。然后函数的最后一行将管理器的启动状态改为表示它已经完全启动。
- en: Click Play to run the code. Assuming you have a solid internet connection, you
    should see a bunch of data appear in the console. This data is simply a long string,
    but the string is formatted in a specific way that we can make use of.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放以运行代码。假设你有稳定的互联网连接，你应该会在控制台看到一些数据出现。这些数据只是一个长字符串，但字符串是以一种我们可以利用的特定方式格式化的。
- en: 10.2.2 Parsing XML
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 解析XML
- en: Data that exists as a long string usually has individual bits of information
    embedded within the string. You extract those bits of information by parsing the
    string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 存在为长字符串的数据通常包含在字符串中嵌入的信息片段。你通过解析字符串来提取这些信息片段。
- en: DEFINITION *Parsing* means analyzing a chunk of data and dividing it into separate
    pieces of information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *解析* 意味着分析一块数据并将其划分为单独的信息部分。
- en: To parse the string, it needs to be formatted in a way that allows you (or rather,
    the parser code) to identify separate pieces. A couple of standard formats are
    commonly used to transfer data over the internet; one of the most common standard
    formats is *XML*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析字符串，它需要以允许你（或者更确切地说，解析器代码）识别单独部分的方式格式化。在互联网上传输数据时，常用几种标准格式；最常见的一种标准格式是 *XML*。
- en: DEFINITION *XML* stands for *Extensible Markup Language*. It’s a set of rules
    for encoding documents in a structured way, similar to HTML web pages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *XML* 代表 *可扩展标记语言*。它是一套用于以结构化方式编码文档的规则，类似于HTML网页。
- en: Fortunately, Unity (or rather Mono, the code framework built into Unity) provides
    functionality for parsing XML. The weather data we requested is formatted in XML,
    so we’re going to add code to WeatherManager to parse the response and extract
    the cloudiness. Put the URL into a web browser to see the response data; there’s
    a lot there, but we’re interested only in the node that contains something like
    <clouds value="40" name="scattered clouds"/>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Unity（或者更确切地说，Unity中内置的代码框架Mono）提供了解析XML的功能。我们请求的天气数据格式为XML，因此我们将在WeatherManager中添加代码来解析响应并提取云量。将URL输入到网页浏览器中查看响应数据；那里有很多内容，但我们只对包含类似<clouds
    value="40" name="scattered clouds"/>的节点感兴趣。
- en: In addition to adding code to parse XML, we’re going to use the same messenger
    system as we did in chapter 7\. That’s because once the weather data is downloaded
    and parsed, we still need to inform the scene about that. Create a script called
    Messenger and paste in the code from [https://github.com/jhocking/from-unity-wiki/blob/main/
    Messenger.cs](https://github.com/jhocking/from-unity-wiki/blob/main/Messenger.cs).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加解析XML的代码外，我们还将使用第7章中使用的相同信使系统。这是因为一旦下载并解析了天气数据，我们仍然需要通知场景。创建一个名为Messenger的脚本，并将[https://github.com/jhocking/from-unity-wiki/blob/main/Messenger.cs](https://github.com/jhocking/from-unity-wiki/blob/main/Messenger.cs)中的代码粘贴进去。
- en: Then you need to create a script called GameEvent. As explained in chapter 7,
    this messenger system is great for providing a decoupled way of communicating
    events to the rest of the program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要创建一个名为GameEvent的脚本。如第7章所述，这个信使系统非常适合以解耦的方式将事件传达给程序的其余部分。
- en: Listing 10.7 GameEvent code
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.7 GameEvent代码
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the messenger system is in place, adjust WeatherManager.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦信使系统就位，调整WeatherManager。
- en: Listing 10.8 Parsing XML in WeatherManager
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.8 在WeatherManager中解析XML
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Be sure to add needed using statements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确保添加所需的using语句。
- en: ❷ Cloudiness is modified internally but read-only elsewhere.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 云量在内部修改，但在其他地方只读。
- en: ❸ Parse XML into a searchable structure.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将XML解析为可搜索的结构。
- en: ❹ Pull out a single node from the data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从数据中提取单个节点。
- en: ❺ Convert the value to a 0-1 float.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将值转换为0-1浮点数。
- en: ❻ Broadcast message to inform the other scripts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 向其他脚本广播消息。
- en: You can see that the most important changes were made inside OnXMLDataLoaded().
    Previously, this method simply logged the data to the console to verify that data
    was coming through correctly. This listing adds a lot of code to parse the XML.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，最重要的更改是在OnXMLDataLoaded()内部进行的。之前，该方法只是将数据记录到控制台以验证数据是否正确通过。这个列表添加了大量代码来解析XML。
- en: First create a new empty XML document; this is an empty container that you can
    fill with a parsed XML structure. The next line parses the data string into a
    structure contained by the XML document. Then we start at the root of the XML
    tree so that everything can search up the tree in subsequent code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的空XML文档；这是一个空容器，你可以用解析的XML结构填充它。下一行将数据字符串解析为XML文档包含的结构。然后我们从XML树的根开始，以便在后续代码中一切都可以向上搜索树。
- en: At this point, you can search for nodes within the XML structure to pull out
    individual bits of information. In this case, <clouds> is the only node we’re
    interested in. Find that node in the XML document and then extract the value attribute
    from that node. This data defines the cloud value as a 0-100 integer, but we’re
    going to need it as a 0-1 float in order to adjust the scene later. Converting
    that is a simple bit of math added to the code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以在XML结构中搜索节点以提取个别信息。在这种情况下，<clouds> 是我们唯一感兴趣的节点。在XML文档中找到该节点，然后从该节点中提取值属性。这些数据定义了云值为0-100的整数，但我们需要它作为0-1的浮点数，以便稍后调整场景。将此转换为代码中添加的简单数学运算。
- en: Finally, after extracting out the cloudiness value from the full data, broadcast
    a message that the weather data has been updated. Currently, nothing is listening
    for that message, but the broadcaster doesn’t need to know anything about listeners
    (indeed, that’s the entire point of a decoupled messenger system). Later, we’ll
    add a listener to the scene.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在从完整数据中提取出云量值之后，广播一条消息，表明天气数据已更新。目前，没有任何东西在监听这条消息，但广播者不需要了解任何关于监听者的信息（实际上，这就是解耦消息系统的全部意义）。稍后，我们将向场景中添加一个监听器。
- en: Great—we’ve written code to parse XML data! But before we move on to applying
    this value to the visible scene, I want to go over another option for data transfer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们已经编写了解析 XML 数据的代码！但在我们将此值应用于可见场景之前，我想介绍一下另一种数据传输的选项。
- en: 10.2.3 Parsing JSON
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 解析 JSON
- en: Before continuing to the next step in the project, let’s explore an alternative
    format for transferring data. XML is one common format for data transferred over
    the internet; another common one is *JSON*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行项目中的下一步之前，让我们探索一种用于传输数据的替代格式。XML 是互联网上传输数据的一种常见格式；另一种常见的是 *JSON*。
- en: DEFINITION *JSON* stands for *JavaScript Object Notation*. Similar in purpose
    to XML, JSON was designed to be a lightweight alternative. Although the syntax
    for JSON was originally derived from JavaScript, the format is not language-specific
    and is readily used with a variety of programming languages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** *JSON* 代表 *JavaScript 对象表示法*。与 XML 的目的相似，JSON 被设计成一种轻量级的替代方案。尽管 JSON
    的语法最初来源于 JavaScript，但该格式并非特定于任何一种语言，并且可以轻松地与各种编程语言一起使用。'
- en: Unlike XML, Mono doesn’t come with a parser for this format. Fortunately, numerous
    good JSON parsers are available. Unity itself provides a JsonUtility class, while
    externally developed options include Json.NET from Newtonsoft. I generally use
    Json.NET in my games, because Newtonsoft’s library is widely used outside Unity
    in the whole .NET ecosystem. It can be installed using Unity’s new Package Manager
    system, and that’s how it’s installed in the sample project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与 XML 不同，Mono 并未附带该格式的解析器。幸运的是，有大量的优秀 JSON 解析器可供选择。Unity 本身提供了一个 JsonUtility
    类，而外部开发的选项包括 Newtonsoft 的 Json.NET。我通常在我的游戏中使用 Json.NET，因为 Newtonsoft 的库在 Unity
    之外的全 .NET 生态系统中被广泛使用。它可以使用 Unity 的新包管理器系统安装，这也是它在示例项目中安装的方式。
- en: WARNING Json.NET has actually been packaged for Unity multiple times, and this
    book uses the package from jilleJr. However, recently Unity packaged Json.NET
    as com.unity.nuget.newtonsoft-json, and uses that as a dependency for other packages.
    Thus, if you have one of those other packages installed (such as Version Control),
    then you already have Json.NET in your project, and trying to install Json.NET
    a second time will cause errors. The easiest way to check is to expand the Packages
    folder (below Assets) in the Project view and look for Newtonsoft Json.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告** Json.NET 实际上已经被 Unity 打包多次，本书使用的是 jilleJr 的包。然而，最近 Unity 将 Json.NET
    打包为 com.unity.nuget.newtonsoft-json，并将其用作其他包的依赖项。因此，如果您安装了那些其他包之一（例如版本控制），那么您项目中已经包含了
    Json.NET，再次尝试安装 Json.NET 将会导致错误。最简单的方法是在项目视图中展开（位于 Assets 下方）的 Packages 文件夹，并查找
    Newtonsoft Json。'
- en: The GitHub page at [http://mng.bz/7l4y](https://shortener.manning.com/7l4y)
    has multiple sections about how to install, and “Installation via Pure UPM” explains
    the steps we need. As mentioned way back in chapter 1, the Unity Package Manager
    (UPM) is easiest to use with packages made by Unity itself. However, UPM is increasingly
    supported by external package authors as well; for example, the glTF package mentioned
    in chapter 4 is installed this way. While packages made by Unity are listed in
    the Package Manager window and can be selected there, externally created packages
    need to be installed by adjusting the manifest text file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://mng.bz/7l4y](https://shortener.manning.com/7l4y) 的 GitHub 页面上有多个部分介绍如何安装，其中“通过纯
    UPM 安装”解释了我们需要的步骤。正如在第一章中提到的，Unity 包管理器（UPM）与 Unity 自身制作的包一起使用最为简便。然而，UPM 正在越来越多地被外部包作者支持；例如，在第
    4 章中提到的 glTF 包就是以这种方式安装的。虽然由 Unity 制作的包列在包管理器窗口中，并可以从那里选择，但外部创建的包需要通过调整清单文本文件来安装。
- en: As explained by the GitHub page, navigate to the Unity project’s folder on your
    computer, open the Packages folder in there, and then open manifest.json in any
    text editor. The installation documentation on GitHub lists all the text to paste
    into the package manifest, so do that. Installing a package always involves adding
    an entry in the dependencies block; in addition, some packages (for example, this
    JSON library) will also have scopedRegistries for you to add. Return to Unity,
    where it will take a moment for the new package to download.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如GitHub页面所述，导航到您计算机上的Unity项目文件夹，打开其中的Packages文件夹，然后以任何文本编辑器打开manifest.json。GitHub上的安装文档列出了要粘贴到包清单中的所有文本，所以这样做。安装包始终涉及在依赖项块中添加条目；此外，一些包（例如，这个JSON库）还将具有作用域注册表供您添加。返回Unity，新包的下载将需要一段时间。
- en: Now you can use this library to parse JSON data. We’ve been getting XML from
    the OpenWeather API, but as it happens, OpenWeather can also send the same data
    formatted as JSON. To do that, modify NetworkService to request JSON.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用这个库来解析JSON数据。我们一直从OpenWeather API获取XML数据，但正如所发生的那样，OpenWeather还可以以JSON格式发送相同的数据。为此，修改NetworkService以请求JSON。
- en: Listing 10.9 Making NetworkService request JSON instead of XML
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9 将NetworkService请求从XML更改为JSON
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ The URL is slightly different this time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这次URL略有不同。
- en: This is pretty much the same as the code to download XML data, except that the
    URL is slightly different. The data returned from this request has the same values,
    but it’s formatted differently. This time we’re looking for a chunk like "clouds":{"all":40}.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与下载XML数据的代码相同，只是URL略有不同。此请求返回的数据具有相同的值，但格式不同。这次我们正在寻找一个类似"clouds":{"all":40}的块。
- en: There wasn’t a ton of additional code required this time. That’s because we
    set up the code for requests into nicely parceled separate functions, so every
    subsequent HTTP request will be easy to add. Nice! Now let’s modify WeatherManager
    to request JSON data instead of XML.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不需要太多额外的代码。那是因为我们为请求设置了代码，将其分解为单独的函数，所以每个后续的HTTP请求都很容易添加。太棒了！现在让我们修改WeatherManager以请求JSON数据而不是XML。
- en: Listing 10.10 Modifying WeatherManager to request JSON
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 修改WeatherManager以请求JSON
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Be sure to add the needed using statement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一定要添加所需的using语句。
- en: ❷ Network request changed
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 网络请求已更改
- en: ❸ Instead of an XML container, parse into a JSON object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 而不是XML容器，解析为JSON对象。
- en: ❹ Syntax has changed, but this code is still doing the same things.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 语法已更改，但此代码仍在执行相同的事情。
- en: As you can see, the code for working with JSON looks similar to the code for
    XML. The only real difference is that the data is parsed into a JSON object instead
    of an XML document container.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理JSON的代码与处理XML的代码类似。唯一的真正区别是数据被解析为JSON对象而不是XML文档容器。
- en: NOTE Json.NET provides multiple approaches to parsing the data, and the alternative
    used here is referred to as *JSON Linq*. This alternative approach doesn’t require
    as much setup, which is convenient for a small example like this. The main approach,
    however, requires first creating a new class with fields that mirror the structure
    of the JSON data. The data then populates this class by using the command JsonConvert.DeserializeObject.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Json.NET 提供了多种解析数据的方法，这里使用的替代方法被称为 *JSON Linq*。这种替代方法不需要太多的设置，这对于像这样的小示例来说很方便。然而，主要方法需要首先创建一个新的类，其字段与JSON数据的结构相对应。然后使用命令JsonConvert.DeserializeObject通过填充这个类来使用数据。
- en: DEFINITION *Deserialize* means pretty much the same thing as *parse*, only with
    the implication that a code object is being created out of the data. This is the
    reverse of *serialize*, which means to encode a code object into a form that can
    be transferred and stored, such as a JSON string.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *反序列化* 几乎与 *解析* 具有相同的意思，只是暗示从数据中创建了一个代码对象。这是 *序列化* 的逆过程，意味着将代码对象编码成可以传输和存储的形式，例如JSON字符串。
- en: Aside from the different syntax, all the steps are the same. Extract the value
    from the data chunk (for some reason, the value is called all this time, but that’s
    just a quirk of the API), do some simple math to convert the value to a 0-1 float,
    and broadcast an update message. With that done, it’s time to apply the value
    to the visible scene.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不同的语法外，所有步骤都是相同的。从数据块中提取值（由于某种原因，这个值一直被称为all，但这只是API的一个怪癖），进行一些简单的数学运算将值转换为0-1浮点数，并广播一个更新消息。完成这些后，就是将值应用到可见场景中的时候了。
- en: 10.2.4 Affecting the scene based on weather data
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 基于天气数据影响场景
- en: Regardless of exactly how the data is formatted, once the cloudiness value is
    extracted from the response data, we can use that value in the SetOvercast() method
    of WeatherController. Whether XML or JSON, the data string ultimately gets parsed
    into a series of words and numbers. The SetOvercast() method takes a number as
    a parameter. In section 9.1.2, we used a number incremented every frame, but we
    could just as easily use the number returned by the weather API. This shows the
    full WeatherController script again, after modifications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数据格式如何，一旦从响应数据中提取出云量值，我们就可以在WeatherController的SetOvercast()方法中使用该值。无论是XML还是JSON，数据字符串最终都会解析成一系列单词和数字。SetOvercast()方法接受一个数字作为参数。在第9.1.2节中，我们使用了每帧递增的数字，但我们可以同样容易地使用天气API返回的数字。以下是修改后的完整WeatherController脚本。
- en: Listing 10.11 WeatherController that reacts to downloaded weather data
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.11 响应下载天气数据的WeatherController
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Add/remove event listeners.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加/移除事件监听器。
- en: ❷ Use the cloudiness value from WeatherManager.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用WeatherManager中的云量值。
- en: Notice that the changes aren’t only additions; several bits of test code got
    removed. Specifically, we removed the local cloudiness value that was incremented
    every frame; we don’t need that anymore, because we’ll use the value from WeatherManager.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些变化不仅仅是添加；一些测试代码被移除了。具体来说，我们移除了每帧递增的本地云量值；我们不再需要它，因为我们将从WeatherManager使用值。
- en: A listener gets added and removed in OnEnable()/OnDisable() (these are the functions
    of MonoBehaviour called when the object is turned on or off). This listener is
    part of the broadcast messaging system and calls OnWeatherUpdated() when that
    message is received. OnWeatherUpdated() retrieves the cloudiness value from WeatherManager
    and calls SetOvercast() using that value. In this way, the appearance of the scene
    is controlled by downloaded weather data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在OnEnable()/OnDisable()中添加和移除监听器（这些是当对象开启或关闭时MonoBehaviour调用的函数）。这个监听器是广播消息系统的一部分，当接收到该消息时调用OnWeatherUpdated()。OnWeatherUpdated()从WeatherManager获取云量值，并使用该值调用SetOvercast()。这样，场景的外观就由下载的天气数据控制。
- en: Run the scene now and you’ll see the sky update according to the cloudiness
    in the weather data. You may see it take time to request the weather; in a real
    game, you’d probably want to hide the scene behind a loading screen until the
    sky updates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行场景，你会看到天空根据天气数据中的云量进行更新。你可能看到请求天气信息需要花费一些时间；在实际游戏中，你可能希望在天空更新之前，将场景隐藏在加载屏幕后面。
- en: Game networking beyond HTTP
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 超越HTTP的游戏网络
- en: HTTP requests are robust and reliable, but the latency between making a request
    and receiving a response is too slow for many games. HTTP requests are therefore
    a good way of sending relatively slow-paced messages to a server (such as moves
    in a turn-based game, or submission of high scores for any game), but something
    like a multiplayer FPS would need a different approach to networking.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求是健壮和可靠的，但请求和接收响应之间的延迟对于许多游戏来说太慢了。因此，HTTP请求是向服务器发送相对较慢的消息（如回合制游戏中的移动或任何游戏的得分提交）的好方法，但像多人FPS这样的东西需要不同的网络方法。
- en: These approaches involve various communication technologies, as well as techniques
    to compensate for lag. Unity provides one API for multiplayer games, called MLAPI,
    but other options include Mirror or Photon.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法涉及各种通信技术，以及补偿延迟的技术。Unity为多人游戏提供了一个API，称为MLAPI，但其他选项还包括Mirror或Photon。
- en: The cutting edge for networked action games is a complex topic that goes beyond
    the scope of this book. You can look up more information on your own, starting
    with the Unity Multiplayer Networking site ([https://docs-multiplayer.unity3d.com/](https://docs-multiplayer.unity3d.com/)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 网络动作游戏的尖端技术是一个复杂的话题，超出了本书的范围。你可以自己查找更多信息，从Unity多人网络网站开始（[https://docs-multiplayer.unity3d.com/](https://docs-multiplayer.unity3d.com/))。
- en: Now that you know how to get numerical and string data from the internet, let’s
    do the same thing with an image.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何从互联网获取数值和字符串数据，让我们用图像来做同样的事情。
- en: 10.3 Adding a networked billboard
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 添加网络广告牌
- en: Although the responses from a web API are almost always text strings formatted
    in XML or JSON, many other sorts of data are transferred over the internet. Besides
    text data, the most common kind of data requested is images. The UnityWebRequest
    object can be used to download images too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然来自Web API的响应几乎总是以XML或JSON格式化的文本字符串，但互联网上传输的其他类型的数据也很多。除了文本数据外，最常见的数据请求类型是图像。UnityWebRequest对象也可以用来下载图像。
- en: 'You’re going to learn about this task by creating a billboard that displays
    an image downloaded from the internet. You need to code two steps: downloading
    an image to display and applying that image to the billboard object. As a third
    step, you’ll improve the code so that the image will be stored to use on multiple
    billboards.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过创建一个显示从互联网下载的图像的广告牌来学习这个任务。你需要编写两个步骤：下载要显示的图像并将该图像应用于广告牌对象。作为第三个步骤，你将改进代码，以便图像可以存储以用于多个广告牌。
- en: 10.3.1 Loading images from the internet
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 从互联网加载图像
- en: First let’s write the code to download an image. You’re going to download some
    public domain landscape photography (see figure 10.5) to test with. The downloaded
    image won’t be visible on the billboard yet; I’ll show you a script to display
    the image in the next section, but before that, let’s get the code in place that
    will retrieve the image.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写下载图像的代码。你将下载一些公共领域的风景摄影（见图10.5）进行测试。下载的图像在广告牌上尚不可见；我将在下一节中展示一个显示图像的脚本，但在那之前，让我们先放置检索图像的代码。
- en: '![CH10_F05_Hocking3](../Images/CH10_F05_Hocking3.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F05_Hocking3](../Images/CH10_F05_Hocking3.png)'
- en: Figure 10.5 Image of Moraine Lake in Banff National Park, Canada
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 加拿大班夫国家公园的Moraine湖图像
- en: The code architecture for downloading an image looks much the same as the architecture
    for downloading data. A new manager module (called ImagesManager) will be in charge
    of downloaded images to be displayed. Once again, the details of connecting to
    the internet and sending HTTP requests will be handled in NetworkService, and
    ImagesManager will call upon NetworkService to download images for it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下载图像的代码架构与下载数据的架构非常相似。一个新的管理模块（称为ImagesManager）将负责要显示的下载图像。再次强调，连接到互联网和发送HTTP请求的细节将由NetworkService处理，而ImagesManager将调用NetworkService为其下载图像。
- en: The first addition to the code is in NetworkService. This listing adds image
    downloading to that script.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一个新增部分是在NetworkService中。此列表将图像下载添加到该脚本中。
- en: Listing 10.12 Downloading an image in NetworkService
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.12 在NetworkService中下载图像
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Put this const up near the top with the other URLs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将此const放置在顶部附近，与其他URL一起。
- en: ❷ This callback takes a Texture2D instead of a string.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此回调接收一个Texture2D而不是字符串。
- en: ❸ Retrieve the downloaded image by using the DownloadHandler utility.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用DownloadHandler实用程序检索下载的图像。
- en: 'The code that downloads an image looks almost identical to the code for downloading
    data. The primary difference is the type of callback method; note that the callback
    takes a Texture2D this time instead of a string. That’s because you’re sending
    back the relevant response: you downloaded a string of data previously—now you’re
    downloading an image. This listing contains code for the new ImagesManager. Create
    a new script and enter this code.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下载图像的代码几乎与下载数据的代码相同。主要区别在于回调方法的类型；注意这次回调接收一个Texture2D而不是字符串。这是因为你正在发送相关的响应：你之前下载的是数据字符串——现在你正在下载图像。此列表包含ImagesManager的新代码。创建一个新的脚本并输入此代码。
- en: Listing 10.13 Creating ImagesManager to retrieve and store images
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.13 创建ImagesManager以检索和存储图像
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Variable to store the downloaded image
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储下载图像的变量
- en: ❷ Check whether the image is already stored.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查图像是否已存储。
- en: ❸ Invoke the callback right away (don’t download) if there’s a stored image.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果有已存储的图像，立即调用回调（不下载）。
- en: The most interesting part of this code is GetWebImage(); everything else in
    this script consists of standard properties and methods that implement the manager
    interface. When GetWebImage() is called, it’ll return (via a callback function)
    the web image. First, it’ll check whether webImage already has a stored image.
    If not, it’ll invoke the network call to download the image. If webImage already
    has a stored image, GetWebImage() will send back the stored image (rather than
    downloading the image anew).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中最有趣的部分是GetWebImage()；此脚本中的其他所有内容都由实现管理接口的标准属性和方法组成。当调用GetWebImage()时，它将通过回调函数返回网络图像。首先，它会检查webImage是否已经存储了图像。如果没有，它将调用网络调用以下载图像。如果webImage已经存储了图像，GetWebImage()将发送回存储的图像（而不是重新下载图像）。
- en: NOTE Currently, the downloaded image is never being stored, which means webImage
    will always be empty. Code that specifies what to do when webImage is *not* empty
    is already in place, so you’ll adjust the code to store that image in the following
    sections. This adjustment is in a separate section because it involves some tricky
    code wizardry.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：目前，下载的图像从未被存储，这意味着webImage始终为空。当webImage为*非空*时指定要执行的操作的代码已经就绪，因此你将在以下部分调整代码以存储该图像。这个调整在一个单独的部分中，因为它涉及一些复杂的代码技巧。
- en: Of course, just like all manager modules, ImagesManager needs to be added to
    Managers, and this listing details the additions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像所有管理模块一样，ImagesManager需要添加到Managers中，以下列表详细说明了添加的内容。
- en: Listing 10.14 Adding the new manager to Managers
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.14 将新管理器添加到Managers
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Unlike the way we set up WeatherManager, GetWebImage() in ImagesManager isn’t
    called automatically on startup. Instead, the code waits until it’s invoked; that’ll
    happen in the next section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们设置WeatherManager的方式不同，ImagesManager中的GetWebImage()在启动时不会自动调用。相反，代码会等待被调用；这将在下一节中发生。
- en: 10.3.2 Displaying images on the billboard
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 在广告牌上显示图像
- en: The ImagesManager you just wrote doesn’t do anything until it’s called upon,
    so now we’ll create a billboard object that will call methods in ImagesManager.
    First create a new cube and then place it in the middle of the scene, at something
    like Position 0, 1.5, -5 and Scale 5, 3, 0.5 (see figure 10.6).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写的ImagesManager在未被调用之前不会做任何事情，因此现在我们将创建一个广告牌对象，该对象将调用ImagesManager中的方法。首先创建一个新的立方体，然后将其放置在场景中间，大约在位置0,
    1.5, -5和缩放5, 3, 0.5（见图10.6）。
- en: '![CH10_F06_Hocking3](../Images/CH10_F06_Hocking3.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F06_Hocking3](../Images/CH10_F06_Hocking3.png)'
- en: Figure 10.6 The billboard object, before and after displaying the downloaded
    image
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 显示下载图像前后的广告牌对象
- en: You’re going to create a device that operates just like the color-changing monitor
    in chapter 9\. Copy the DeviceOperator script and put it on the player. As you
    may recall, that script will operate nearby devices when the C key is pressed.
    Also create a script for the billboard device called WebLoadingBillboard, put
    that script on the billboard object, and enter this code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个操作方式与第9章中提到的颜色变化监视器类似的设备。复制DeviceOperator脚本并将其放在玩家上。你可能还记得，当按下C键时，该脚本将操作附近的设备。同时创建一个名为WebLoadingBillboard的广告牌设备脚本，将其放在广告牌对象上，并输入以下代码。
- en: Listing 10.15 WebLoadingBillboard device script
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.15 WebLoadingBillboard设备脚本
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Call the method in ImagesManager.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用ImagesManager中的方法。
- en: ❷ The downloaded image is applied to the material in the callback.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将下载的图像应用到回调中的材质。
- en: 'This code does two primary things: it calls ImagesManager.GetWebImage() when
    the device is operated, and it applies the image from the callback function. Textures
    are applied to materials, so you can change the texture in the material that’s
    on the billboard. Figure 10.6 shows what the billboard will look like after you
    play the game.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码主要做两件事：当设备被操作时，它会调用ImagesManager.GetWebImage()，并将回调函数中的图像应用到材质上。纹理应用于材质，因此你可以更改广告牌上材质的纹理。图10.6显示了游戏运行后广告牌的外观。
- en: 'AssetBundles: How to download other kinds of assets'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: AssetBundles：如何下载其他类型的资产
- en: Downloading an image is fairly straightforward using UnityWebRequest, but what
    about other kinds of assets, like mesh objects and prefabs? UnityWebRequest has
    properties for text and images, but other assets are a bit more complicated.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UnityWebRequest下载图像相对简单，但其他类型的资产，如网格对象和预制件呢？UnityWebRequest有文本和图像的属性，但其他资产要复杂一些。
- en: Unity can download any kind of asset through a mechanism called AssetBundles.
    Long story short, you first package assets into a bundle, and then Unity can extract
    the assets after downloading the bundle. The details of both creating and downloading
    AssetBundles are beyond the scope of this book; if you want to learn more, start
    by reading the Unity Manual at [http://mng.bz/m1X2](http://mng.bz/m1X2) and [http://mng.bz/5Zn1](http://mng.bz/5Zn1).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Unity可以通过一种称为AssetBundles的机制下载任何类型的资产。简而言之，你首先将资产打包成一个包，然后Unity在下载包后可以提取资产。创建和下载AssetBundles的详细内容超出了本书的范围；如果你想了解更多，请从阅读Unity手册开始，网址为[http://mng.bz/m1X2](http://mng.bz/m1X2)和[http://mng.bz/5Zn1](http://mng.bz/5Zn1)。
- en: Great, the downloaded image is displayed on the billboard! But this code could
    be optimized further to work with multiple billboards. Let’s tackle that optimization
    next.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，下载的图像已经显示在广告牌上了！但这段代码还可以进一步优化以支持多个广告牌。让我们接下来解决这个优化问题。
- en: 10.3.3 Caching the downloaded image for reuse
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 为重用缓存下载的图像
- en: As noted in section 10.3.1, ImagesManager doesn’t yet store the downloaded image.
    That means the image will be downloaded over and over for multiple billboards.
    This is inefficient, because it’ll be the same image each time. To address this,
    we’re going to adjust ImagesManager to cache images that have been downloaded.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 10.3.1 节所述，ImagesManager 还未存储下载的图像。这意味着图像将多次为多个广告牌重新下载。这是低效的，因为每次都是相同的图像。为了解决这个问题，我们将调整
    ImagesManager 以缓存已下载的图像。
- en: DEFINITION *Cache* means to keep stored locally. The most common (but not only!)
    context involves files, such as images, downloaded from the internet.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *缓存* 意味着在本地存储。最常见（但不仅限于此！）的上下文涉及从互联网下载的文件，例如图像。
- en: The key is to provide a callback function in ImagesManager that first saves
    the image, and then calls the callback from WebLoadingBillboard. This is tricky
    to do (as opposed to the current code that directly uses the callback from WebLoadingBillboard)
    because the code doesn’t know ahead of time what the callback from WebLoadingBillboard
    will be. Put another way, there’s no way to write a method in ImagesManager that
    calls a specific method in WebLoadingBillboard because we don’t yet know what
    that specific method will be. The way around this conundrum is to use lambda functions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于在 ImagesManager 中提供一个回调函数，首先保存图像，然后调用来自 WebLoadingBillboard 的回调。这比当前直接使用来自
    WebLoadingBillboard 的回调要复杂（因为代码在提前并不知道来自 WebLoadingBillboard 的回调将是什么）。换句话说，我们无法在
    ImagesManager 中编写一个调用 WebLoadingBillboard 中特定方法的方法，因为我们还不知道那个特定方法是什么。解决这个难题的方法是使用
    Lambda 函数。
- en: DEFINITION A *lambda function* (also called an *anonymous function*) is a function
    that doesn’t have a name. These functions are usually created on the fly inside
    other functions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *Lambda 函数*（也称为 *匿名函数*）是一个没有名称的函数。这些函数通常在其他函数内部动态创建。
- en: Lambda functions are a tricky code feature supported in multiple programming
    languages, including C#. By using a lambda function for the callback in ImagesManager,
    the code can create the callback function on the fly by using the method passed
    in from WebLoadingBillboard. You don’t need to know the method to call ahead of
    time, because this lambda function doesn’t exist ahead of time! This listing shows
    how to do this voodoo in ImagesManager.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数是多种编程语言中支持的一种复杂代码特性，包括 C#。通过在 ImagesManager 中使用 Lambda 函数作为回调，代码可以动态地使用从
    WebLoadingBillboard 传入的方法来创建回调函数。你不需要提前知道要调用哪个方法，因为这个 Lambda 函数在提前并不存在！这个列表展示了如何在
    ImagesManager 中实现这种巫术。
- en: Listing 10.16 Lambda function for callback in ImagesManager
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.16 ImagesManager 中回调的 Lambda 函数
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Store the downloaded image.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保存下载的图像。
- en: ❷ The callback is used in the lambda function instead of being sent directly
    to NetworkService.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 Lambda 函数中使用回调而不是直接发送到 NetworkService。
- en: 'The main change is in the function passed to NetworkService.DownloadImage().
    Previously, the code was passing through the same callback method from WebLoadingBillboard.
    After the change, though, the callback sent to NetworkService is a separate lambda
    function declared on the spot that called the method from WebLoadingBillboard.
    Take note of the syntax to declare a lambda function: () => {}.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 主要变化在于传递给 NetworkService.DownloadImage() 的函数。之前，代码是通过传递来自 WebLoadingBillboard
    的相同回调方法。然而，在变化之后，发送给 NetworkService 的回调是一个现场声明的单独的 Lambda 函数，它调用了来自 WebLoadingBillboard
    的方法。请注意声明 Lambda 函数的语法：() => {}。
- en: Making the callback a separate function makes it possible to do more than call
    the method in WebLoadingBillboard; specifically, the lambda function also stores
    a local copy of the downloaded image. Thus, GetWebImage() has to download the
    image only the first time; all subsequent calls will use the locally stored image.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将回调作为一个单独的函数，使得除了调用 WebLoadingBillboard 中的方法之外，Lambda 函数还可以存储下载的图像的本地副本。因此，GetWebImage()
    只需在第一次下载图像；所有后续调用都将使用本地存储的图像。
- en: Because this optimization applies to subsequent calls, the effect will be noticeable
    only on multiple billboards. Let’s duplicate the billboard object so that a second
    billboard will be in the scene. Select the billboard object, click Duplicate (look
    under the Edit menu or right-click), and move the duplicate over (for example,
    change the X position to 18).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种优化适用于后续调用，因此只有在多个广告牌上才会注意到效果。让我们复制广告牌对象，以便在场景中有一个第二个广告牌。选择广告牌对象，点击复制（在编辑菜单下或右键单击），并将复制品移动过来（例如，将
    X 位置更改为 18）。
- en: Now play the game and watch what happens. When you operate the first billboard,
    a noticeable pause occurs while the image downloads from the internet. But when
    you then walk over to the second billboard, the image will appear immediately
    because it has already been downloaded.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始游戏并观察会发生什么。当你操作第一个广告牌时，图像从互联网下载时会出现明显的暂停。但当你走到第二个广告牌前，图像会立即出现，因为它们已经下载完毕。
- en: 'This is an important optimization for downloading images (there’s a reason
    web browsers cache images by default). One more major networking task remains
    to go over: sending data back to the server.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对下载图像的重要优化（这就是为什么默认情况下网络浏览器会缓存图像的原因）。还有一个主要的网络任务需要完成：将数据发送回服务器。
- en: 10.4 Posting data to a web server
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 将数据发布到Web服务器
- en: We’ve gone over multiple examples of downloading data, but we still need to
    see an example of *sending* data. This last section does require you to have a
    server to send requests to, so this section is *optional*. But it’s easy to download
    open source software to set up a server to test on.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了多个下载数据的例子，但我们仍然需要看到发送数据的例子。本节确实需要你有一个服务器来发送请求，所以这一节是可选的。但是，很容易下载开源软件来设置服务器进行测试。
- en: I recommend XAMPP for a test server. Go to [www.apachefriends.org](https://www.apachefriends.org)
    to download XAMPP (on macOS you need to rename the .bz2 to .dmg) and follow the
    installation instructions. Once that’s installed and the server is running, you
    can access XAMPP’s htdocs folder with the address http://localhost/ just as you
    would a server on the internet. Once you have XAMPP up and running, create a folder
    called uia in htdocs; that’s where you’ll put the server-side script.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用XAMPP作为测试服务器。访问[www.apachefriends.org](https://www.apachefriends.org)下载XAMPP（在macOS上需要将.bz2重命名为.dmg）并遵循安装说明。一旦安装并启动服务器，你可以使用地址http://localhost/访问XAMPP的htdocs文件夹，就像访问互联网上的服务器一样。一旦XAMPP启动并运行，在htdocs中创建一个名为uia的文件夹；这就是你将放置服务器端脚本的地方。
- en: Whether you use XAMPP or your own existing web server, the actual task will
    be to post weather data to the server when the player reaches a checkpoint in
    the scene. This checkpoint will be a trigger volume, just like the door trigger
    in chapter 9\. You need to create a new cube object, position it off to one side
    of the scene, set the collider to Trigger, and apply a semitransparent material
    as you did in chapter 9 (remember, set the material’s Rendering Mode). Figure
    10.7 shows the checkpoint object with a green semitransparent material applied.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用XAMPP还是你自己的现有Web服务器，实际的任务是在玩家达到场景中的检查点时将天气数据发送到服务器。这个检查点将是一个触发体积，就像第9章中的门触发器一样。你需要创建一个新的立方体对象，将其放置在场景的一侧，将碰撞器设置为触发器，并应用与第9章中相同的半透明材质（记住，设置材质的渲染模式）。图10.7显示了应用了绿色半透明材质的检查点对象。
- en: '![CH10_F07_Hocking3](../Images/CH10_F07_Hocking3.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![CH10_F07_Hocking3](../Images/CH10_F07_Hocking3.png)'
- en: Figure 10.7 The checkpoint object that triggers data sending
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 触发数据发送的检查点对象
- en: Now that the trigger object is in the scene, let’s write the code that it invokes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在触发对象已经在场景中，让我们编写它调用的代码。
- en: '10.4.1 Tracking current weather: Sending post requests'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 跟踪当前天气：发送POST请求
- en: The code that’s invoked by the checkpoint object will cascade through several
    scripts. As with the code for downloading data, the code for sending data will
    involve WeatherManager telling NetworkService to make the request, and NetworkService
    handles the details of HTTP communication. This shows the adjustments you need
    to make to NetworkService.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由检查点对象调用的代码将通过几个脚本级联。与下载数据的代码一样，发送数据的代码将涉及WeatherManager告诉NetworkService发起请求，而NetworkService处理HTTP通信的细节。这显示了你需要对NetworkService进行的调整。
- en: Listing 10.17 Adjusting NetworkService to post data
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.17 调整NetworkService以发送数据
- en: '[PRE17]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Address of the server-side script; change this if needed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 服务器端脚本的地址；如有需要，请更改此地址。
- en: ❷ Added arguments to CallAPI() parameters
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向CallAPI()参数添加了参数
- en: ❸ Either POST using WWWForm or GET without
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 要么使用WWWForm进行POST，要么不使用GET
- en: ❹ Calls modified because of changed parameters
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 由于参数更改而修改的调用
- en: ❺ Define a form with values to send.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 定义一个带有要发送的值的表单。
- en: ❻ Send a timestamp along with the cloudiness.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 与云量一起发送时间戳。
- en: First, notice that CallAPI() has a new parameter. This is a WWWForm object,
    a series of values to send along with the HTTP request. A condition in the code
    uses the presence of a WWWForm object to alter the request created. Normally we
    want to send a GET request, but WWWForm will change it to a POST request to send
    data. All the other changes in the code react to that central change (for example,
    modifying the GetWeather() code because of the CallAPI() parameters). The following
    code is what you need to add in WeatherManager.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意 CallAPI() 有一个新参数。这是一个 WWWForm 对象，是一系列与 HTTP 请求一起发送的值。代码中的一个条件使用 WWWForm
    对象的存在来改变创建的请求。通常我们想要发送一个 GET 请求，但 WWWForm 会将其改为 POST 请求以发送数据。代码中的所有其他更改都是对那个核心更改的反应（例如，由于
    CallAPI() 参数而修改 GetWeather() 代码）。以下是你需要在 WeatherManager 中添加的代码。
- en: Listing 10.18 Adding code to WeatherManager that sends data
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.18 向 WeatherManager 添加代码以发送数据
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, make use of this code by adding a checkpoint script to the trigger
    volume in the scene. Create a script called CheckpointTrigger, put that script
    on the trigger volume, and enter the contents of the next listing.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在场景中的触发体积上添加一个检查点脚本来使用此代码。创建一个名为 CheckpointTrigger 的脚本，将其放在触发体积上，并输入下一个列表的内容。
- en: Listing 10.19 CheckpointTrigger script for the trigger volume
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.19 触发体积的 CheckpointTrigger 脚本
- en: '[PRE19]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Track if the checkpoint has already been triggered.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪检查点是否已经被触发。
- en: ❷ Call to send data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用以发送数据。
- en: An Identifier slot will appear in the Inspector; name it something like checkpoint1.
    Run the code, and data will be sent when you enter the checkpoint. The response
    will indicate an error, though, because no script is on the server to receive
    the request. That’s the last step in this section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中会出现一个标识符槽位；可以将其命名为 checkpoint1。运行代码，当你进入检查点时，将会发送数据。但是，响应将指示一个错误，因为没有在服务器上放置脚本来接收请求。这是本节中的最后一步。
- en: 10.4.2 Server-side code in PHP
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 PHP 服务器端代码
- en: The server needs to have a script to receive data sent from the game. Coding
    server scripts is beyond the scope of this book, so we won’t go into detail here.
    We’ll just whip up a PHP script, because that’s the easiest approach. Create a
    text file in htdocs (or wherever your web server is located) and name it api.php
    (listing 10.20).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器需要有一个脚本来接收从游戏发送过来的数据。编写服务器脚本超出了本书的范围，所以这里不会详细介绍。我们只需快速编写一个 PHP 脚本，因为这是最简单的方法。在
    htdocs（或你的 web 服务器所在位置）中创建一个文本文件，并将其命名为 api.php（列表 10.20）。
- en: Listing 10.20 Server script written in PHP that receives our data
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.20 用 PHP 编写的服务器脚本，用于接收我们的数据
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Extract post data into variables.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将请求数据提取到变量中。
- en: ❷ Define the filename to write to.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义要写入的文件名。
- en: ❸ Write the file.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 写入文件。
- en: Note that this script writes received data into data.txt, so you also need to
    put a text file with that name on the server. Once api.php is in place, you’ll
    see weather logs appear in data.txt when triggering checkpoints in the game. Great!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此脚本将接收到的数据写入 data.txt，因此你还需要在服务器上放置一个同名文本文件。一旦 api.php 就位，你将在触发游戏中的检查点时看到天气日志出现在
    data.txt 中。太棒了！
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Skybox is designed for sky visuals that render behind everything else.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天空盒是为渲染在其他所有内容之后的天空视觉效果而设计的。
- en: Unity provides UnityWebRequest to download data.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 提供了 UnityWebRequest 来下载数据。
- en: Common data formats like XML and JSON can be parsed easily.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的数据格式，如 XML 和 JSON，可以轻松解析。
- en: Materials can display images downloaded from the internet.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料可以显示从互联网下载的图片。
- en: UnityWebRequest can also post data to a web server.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UnityWebRequest 还可以将数据发布到网络服务器。
