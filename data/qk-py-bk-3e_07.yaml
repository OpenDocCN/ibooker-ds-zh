- en: Chapter 6\. Strings
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 章\. 字符串
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding strings as sequences of characters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串视为字符序列
- en: Using basic string operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本字符串操作
- en: Inserting special characters and escape sequences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入特殊字符和转义序列
- en: Converting from objects to strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从对象转换为字符串
- en: Formatting strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: Using the byte type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字节类型
- en: Handling text—from user input to filenames to chunks of text to be processed—is
    a common chore in programming. Python comes with powerful tools to handle and
    format text. This chapter discusses the standard string and string-related operations
    in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本——从用户输入到文件名，再到要处理的文本块——是编程中的常见任务。Python 提供了强大的工具来处理和格式化文本。本章讨论了 Python 中的标准字符串和字符串相关操作。
- en: 6.1\. Strings as sequences of characters
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 字符串作为字符序列
- en: 'For the purposes of extracting characters and substrings, strings can be considered
    to be sequences of characters, which means that you can use index or slice notation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取字符和子字符串，可以将字符串视为字符序列，这意味着你可以使用索引或切片记号：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One use for slice notation with strings is to chop the newline off the end
    of a string (usually, a line that’s just been read from a file):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串切片记号的一个用途是去除字符串末尾的换行符（通常，这是从文件中读取的一行）：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is just an example. You should know that Python strings have other,
    better methods to strip unwanted characters, but this example illustrates the
    usefulness of slicing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是一个示例。你应该知道 Python 字符串有其他更好的方法来去除不需要的字符，但这个例子说明了切片的有用性。
- en: 'You can also determine how many characters are in the string by using the `len`
    function, just like finding out the number of elements in a list:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 `len` 函数来确定字符串中的字符数量，就像找出列表中的元素数量一样：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But strings aren’t lists of characters. The most noticeable difference between
    strings and lists is that unlike lists, *strings can’t be modified*. Attempting
    to say something like `string.append('c')` or `string[0] = 'H'` results in an
    error. You’ll notice in the previous example that I stripped off the newline from
    the string by creating a string that was a slice of the previous one, not by modifying
    the previous string directly. This is a basic Python restriction, imposed for
    efficiency reasons.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但字符串不是字符列表。字符串和列表之间最明显的区别是，与列表不同，*字符串不能被修改*。尝试执行类似 `string.append('c')` 或 `string[0]
    = 'H'` 的操作会导致错误。你会在前面的例子中注意到，我是通过创建一个前一个字符串的切片来去除字符串中的换行符，而不是直接修改前一个字符串。这是 Python
    的一个基本限制，出于效率考虑而实施。
- en: 6.2\. Basic string operations
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 基本字符串操作
- en: 'The simplest (and probably most common) way to combine Python strings is to
    use the string concatenation operator `+`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串组合的最简单（也可能是最常见）的方法是使用字符串连接运算符 `+`：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Python also has an analogous string multiplication operator that I’ve found
    to be useful sometimes, but not often:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还有一个类似的有用字符串乘法运算符，但并不常用：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 6.3\. Special characters and escape sequences
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 特殊字符和转义序列
- en: 'You’ve already seen a few of the character sequences that Python regards as
    special when used within strings: `\n` represents the newline character, and `\t`
    represents the tab character. Sequences of characters that start with a backslash
    and that are used to represent other characters are called *escape sequences*.
    Escape sequences are generally used to represent *special characters*—that is,
    characters (such as tab and newline) that don’t have a standard one-character
    printable representation. This section covers escape sequences, special characters,
    and related topics in more detail.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些 Python 在字符串中使用时视为特殊的字符序列：`\n` 表示换行符，`\t` 表示制表符。以反斜杠开头并用于表示其他字符的字符序列称为
    *转义序列*。转义序列通常用于表示 *特殊字符*——即没有标准单字符可打印表示的字符（如制表符和换行符）。本节将更详细地介绍转义序列、特殊字符和相关主题。
- en: 6.3.1\. Basic escape sequences
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 基本转义序列
- en: Python provides a brief list of two-character escape sequences to use in strings
    (see [table 6.1](#ch06table01)). The same sequences also apply to bytes objects,
    which will be introduced at the end of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一组简短的两位转义序列，用于在字符串中使用（见[表 6.1](#ch06table01)）。相同的序列也适用于字节对象，将在本章末尾介绍。
- en: Table 6.1\. Escape sequences for string and bytes literals
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.1\. 字符串和字节字面量的转义序列
- en: '| Escape sequence | Character represented |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 表示的字符 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| \'' | Single-quote character |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| \'' | 单引号字符 |'
- en: '| \" | Double-quote character |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| \" | 双引号字符 |'
- en: '| \\ | Backslash character |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| \\ | 反斜杠字符 |'
- en: '| \a | Bell character |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| \a | 铃声字符 |'
- en: '| \b | Backspace character |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| \b | 退格字符 |'
- en: '| \f | Formfeed character |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| \f | 换页字符 |'
- en: '| \n | Newline character |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| \n | 换行字符 |'
- en: '| \r | Carriage-return character (not the same as \n) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| \r | 回车字符（与\n不同） |'
- en: '| \t | Tab character |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| \t | 制表符 |'
- en: '| \v | Vertical tab character |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| \v | 垂直制表符字符 |'
- en: The ASCII character set, which is the character set used by Python and the standard
    character set on almost all computers, defines quite a few more special characters.
    These characters are accessed by the numeric escape sequences, described in the
    next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII字符集，即Python和几乎所有计算机上使用的标准字符集，定义了相当多的特殊字符。这些字符通过下一节中描述的数字转义序列访问。
- en: 6.3.2\. Numeric (octal and hexadecimal) and Unicode escape sequences
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 数字（八进制和十六进制）和Unicode转义序列
- en: You can include any ASCII character in a string by using an octal (base 8) or
    hexadecimal (base 16) escape sequence corresponding to that character. An octal
    escape sequence is a backslash followed by three digits defining an octal number;
    the ASCII character corresponding to this octal number is substituted for the
    octal escape sequence. A hexadecimal escape sequence is with `\x` rather than
    just `\` and can consist of any number of hexadecimal digits. The escape sequence
    is terminated when a character is found that’s not a hexadecimal digit. For example,
    in the ASCII character table, the character *m* happens to have decimal value
    109\. This value is octal value 155 and hexadecimal value 6D, so
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用与该字符对应的八进制（基数为8）或十六进制（基数为16）转义序列来在字符串中包含任何ASCII字符。八进制转义序列是一个反斜杠后跟三个数字，定义了一个八进制数；与这个八进制数对应的ASCII字符将替换八进制转义序列。十六进制转义序列以`\x`而不是`\`开头，可以包含任意数量的十六进制数字。转义序列在找到一个不是十六进制数字的字符时终止。例如，在ASCII字符表中，字符*m*的十进制值恰好是109。这个值是八进制值155和十六进制值6D，所以
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All three expressions evaluate to a string containing the single character
    *m*. But these forms can also be used to represent characters that have no printable
    representation. The newline character `\n`, for example, has octal value 012 and
    hexadecimal value 0A:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三个表达式都评估为包含单个字符*m*的字符串。但这些形式也可以用来表示没有可打印表示的字符。例如，换行符`\n`的八进制值为012，十六进制值为0A：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because all strings in Python 3 are Unicode strings, they can also contain
    almost every character from every language available. Although a discussion of
    the Unicode system is far beyond the scope of this book, the following examples
    illustrate that you can also escape any Unicode character, either by number (as
    shown earlier) or by Unicode name:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python 3中的所有字符串都是Unicode字符串，所以它们也可以包含几乎来自每种语言的每个字符。尽管Unicode系统的讨论远远超出了本书的范围，但以下示例说明您也可以通过数字（如之前所示）或Unicode名称转义任何Unicode字符：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Escapes by Unicode name**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用Unicode名称进行转义**'
- en: '***3* Escapes by number, using \u**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用数字进行转义，使用 \u**'
- en: The Unicode character set includes the common ASCII characters ***2***.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字符集包括常见的ASCII字符***2***。
- en: 6.3.3\. Printing vs. evaluating strings with special characters
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 打印与评估包含特殊字符的字符串
- en: 'I talked earlier about the difference between evaluating a Python expression
    interactively and printing the result of the same expression by using the `print`
    function. Although the same string is involved, the two operations can produce
    screen outputs that look different. A string that’s evaluated at the top level
    of an interactive Python session is shown with all of its special characters as
    octal escape sequences, which makes clear what’s in the string. Meanwhile, the
    `print` function passes the string directly to the terminal program, which may
    interpret special characters in special ways. Here’s what happens with a string
    consisting of an `a` followed by a newline, a tab, and a `b`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，在交互式Python会话中评估Python表达式和使用`print`函数打印相同表达式的结果之间的区别。尽管涉及的是相同的字符串，但这两个操作可以产生看起来不同的屏幕输出。在交互式Python会话的最高级别评估的字符串会显示其所有特殊字符作为八进制转义序列，这使得字符串中的内容清晰可见。同时，`print`函数直接将字符串传递给终端程序，该程序可能会以特殊方式解释特殊字符。以下是一个由一个`a`字符后跟一个换行符、一个制表符和一个`b`字符组成的字符串的示例：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the first case, the newline and tab are shown explicitly in the string; in
    the second, they’re used as newline and tab characters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，换行符和制表符在字符串中明确显示；在第二种情况下，它们用作换行符和制表符。
- en: 'A normal `print` function also adds a newline to the end of the string. Sometimes
    (that is, when you have lines from files that already end with newlines), you
    may not want this behavior. Giving the `print` function an `end` parameter of
    `""` causes the `print` function to not append the newline:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的 `print` 函数也会在字符串的末尾添加一个换行符。有时（即当你有以换行符结束的文件行时），你可能不希望这种行为。给 `print` 函数一个
    `end` 参数为 `""` 将导致 `print` 函数不添加换行符：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 6.4\. String methods
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4. 字符串方法
- en: Most of the Python string methods are built into the standard Python string
    class, so all string objects have them automatically. The standard `string` module
    also contains some useful constants. Modules are discussed in detail in [chapter
    10](kindle_split_021.html#ch10).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 字符串方法都内置在标准的 Python 字符串类中，因此所有字符串对象都自动拥有它们。标准的 `string` 模块也包含一些有用的常量。模块将在第
    10 章中详细讨论。[第 10 章](kindle_split_021.html#ch10)。
- en: For the purposes of this section, you need only remember that most string methods
    are attached to the string object they operate on by a dot (`.`), as in `x.upper()`.
    That is, they’re prepended with the string object followed by a dot. Because strings
    are immutable, the string methods are used only to obtain their return value and
    don’t modify the string object they’re attached to in any way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节的内容，你只需要记住，大多数字符串方法都是通过点（`.`）附加到它们操作的字符串对象上的，例如 `x.upper()`。也就是说，它们在字符串对象前加上点。因为字符串是不可变的，所以字符串方法仅用于获取它们的返回值，并且不会以任何方式修改它们附加的字符串对象。
- en: I begin with those string operations that are the most useful and most commonly
    used; then I discuss some less commonly used but still useful operations. At the
    end of this section, I discuss a few miscellaneous points related to strings.
    Not all the string methods are documented here. See the documentation for a complete
    list of string methods.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我从最有用和最常用的字符串操作开始；然后讨论一些不太常用但仍然有用的操作。在本节的最后，我将讨论一些与字符串相关的杂项问题。并非所有的字符串方法都在这里进行说明。请参阅文档以获取字符串方法的全列表。
- en: 6.4.1\. The split and join string methods
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1. 分割和连接字符串方法
- en: 'Anyone who works with strings is almost certain to find the `split` and `join`
    methods invaluable. They’re the inverse of one another: `split` returns a list
    of substrings in the string, and `join` takes a list of strings and puts them
    together to form a single string with the original string between each element.
    Typically, `split` uses whitespace as the delimiter to the strings it’s splitting,
    but you can change that behavior via an optional argument.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何处理字符串的人都会发现 `split` 和 `join` 方法非常有价值。它们是彼此的逆操作：`split` 返回字符串中的子字符串列表，而 `join`
    接受一个字符串列表并将它们组合成一个单独的字符串，每个元素之间都有原始字符串。通常，`split` 使用空白字符作为分隔符来分割字符串，但你可以通过可选参数来改变这种行为。
- en: 'String concatenation using `+` is useful but not efficient for joining large
    numbers of strings into a single string, because each time `+` is applied, a new
    string object is created. The previous “Hello World” example produces two string
    objects, one of which is immediately discarded. A better option is to use the
    `join` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `+` 进行字符串连接很有用，但不是将大量字符串连接成一个字符串的高效方法，因为每次应用 `+` 时都会创建一个新的字符串对象。之前的“Hello
    World”示例产生了两个字符串对象，其中一个被立即丢弃。更好的选择是使用 `join` 函数：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By changing the string used to `join`, you can put anything you want between
    the joined strings:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变用于 `join` 的字符串，你可以在连接的字符串之间放置任何你想要的内容：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can even use an empty string, `""`, to join elements in a list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用空字符串 `""` 来连接列表中的元素：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The most common use of `split` is probably as a simple parsing mechanism for
    string-delimited records stored in text files. By default, `split` splits on any
    whitespace, not just a single space character, but you can also tell it to split
    on a particular sequence by passing it an optional argument:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`split` 最常见的用途可能是作为字符串分隔记录的简单解析机制，这些记录存储在文本文件中。默认情况下，`split` 在任何空白字符上分割，而不仅仅是单个空格字符，但你也可以通过传递一个可选参数来告诉它在一个特定的序列上分割：'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sometimes, it’s useful to permit the last field in a joined string to contain
    arbitrary text, perhaps including substrings that may match what `split` splits
    on when reading in that data. You can do this by specifying how many splits `split`
    should perform when it’s generating its result, via an optional second argument.
    If you specify *n* splits, `split` goes along the input string until it has performed
    *n* splits (generating a list with *n*+1 substrings as elements) or until it runs
    out of string. Here are some examples:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，允许连接的字符串中的最后一个字段包含任意文本是有用的，可能包括在读取该数据时`split`可能分割的子字符串。你可以通过指定`split`在生成结果时应执行多少次分割来做到这一点，通过一个可选的第二个参数。如果你指定*n*次分割，`split`将沿着输入字符串进行，直到它执行了*n*次分割（生成一个包含*n*+1个子字符串的列表）或直到它耗尽字符串。以下是一些示例：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When using `split` with its optional second argument, you must supply a first
    argument. To get it to split on runs of whitespace while using the second argument,
    use `None` as the first argument.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带有可选第二个参数的`split`时，你必须提供一个第一个参数。为了在使用第二个参数时按空白字符分割，请使用`None`作为第一个参数。
- en: I use `split` and `join` extensively, usually when working with text files generated
    by other programs. If you want to create more standard output files from your
    programs, good choices are the `csv` and `json` modules in the Python standard
    library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我广泛使用`split`和`join`，通常是在处理由其他程序生成的文本文件时。如果你想要从你的程序中创建更标准的输出文件，Python标准库中的`csv`和`json`模块是不错的选择。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: split and join'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：分割和连接
- en: How could you use `split` and `join` to change all the whitespace in string
    x to dashes, such as changing `"this is a test"` to `"this-is-a-test"`?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何使用`split`和`join`将字符串x中的所有空白字符替换为破折号，例如将`"this is a test"`更改为`"this-is-a-test"`？
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.4.2\. Converting strings to numbers
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 将字符串转换为数字
- en: You can use the functions `int` and `float` to convert strings to integer or
    floating-point numbers, respectively. If they’re passed a string that can’t be
    interpreted as a number of the given type, these functions raise a `ValueError`
    exception. Exceptions are explained in [chapter 14](kindle_split_025.html#ch14).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`int`和`float`函数将字符串转换为整数或浮点数。如果它们传递的字符串不能被解释为给定类型的数字，这些函数将引发`ValueError`异常。异常在[第14章](kindle_split_025.html#ch14)中解释。
- en: 'In addition, you may pass `int` an optional second argument, specifying the
    numeric base to use when interpreting the input string:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以向`int`传递一个可选的第二个参数，指定解释输入字符串时使用的数字基数：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Can’t have decimal point in integer.**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 整数中不能有十进制点。**'
- en: '***2* Interprets 10000 as octal number**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将10000解释为八进制数**'
- en: '***3* Can’t interpret 123456 as base 6 number.**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 不能将123456解释为六进制数。**'
- en: Did you catch the reason for that last error? I requested that the string be
    interpreted as a base 6 number, but the digit 6 can never appear in a base 6 number.
    Sneaky!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否发现了最后一个错误的理由？我要求将字符串解释为六进制数，但数字6永远不会出现在六进制数中。狡猾！
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Strings to Numbers'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：字符串转换为数字
- en: Which of the following will not be converted to numbers, and why?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个不会转换为数字，为什么？
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.4.3\. Getting rid of extra whitespace
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.3\. 移除额外空白
- en: 'A trio of surprisingly useful simple methods are the `strip`, `lstrip`, and
    `rstrip` functions. `strip` returns a new string that’s the same as the original
    string, except that any whitespace at the *beginning or end* of the string has
    been removed. `lstrip` and `rstrip` work similarly, except that they remove whitespace
    only at the left or right end of the original string, respectively:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 三个非常实用的简单方法分别是`strip`、`lstrip`和`rstrip`函数。`strip`返回一个新的字符串，它与原始字符串相同，除了字符串的*开头或结尾*的任何空白都被移除。`lstrip`和`rstrip`的工作方式类似，但它们只分别移除原始字符串的左端或右端的空白：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, tab characters are considered to be whitespace. The exact
    meaning may differ across operating systems, but you can always find out what
    Python considers to be whitespace by accessing the `string.whitespace` constant.
    On my Windows system, Python returns the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，制表符字符被视为空白。确切的意义可能因操作系统而异，但你总是可以通过访问`string.whitespace`常量来找出Python认为什么是空白。在我的Windows系统上，Python返回以下内容：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The characters given in backslashed hex (`\xnn`) format represent the vertical
    tab and formfeed characters. The space character is in there as itself. It may
    be tempting to change the value of this variable, to attempt to affect how `strip`
    and so forth work, but don’t do it. Such an action isn’t guaranteed to give you
    the results you’re looking for.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以反斜杠十六进制 (`\xnn`) 格式给出的字符代表制表符和换页字符。空格字符就是它本身。你可能想改变这个变量的值，试图影响 `strip` 等函数的工作方式，但不要这样做。这样的操作并不能保证你得到你想要的结果。
- en: 'But you can change which characters `strip`, `rstrip`, and `lstrip` remove
    by passing a string containing the characters to be removed as an extra parameter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以通过传递一个包含要移除的字符的字符串作为额外参数来改变 `strip`、`rstrip` 和 `lstrip` 移除的字符：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Strips off all *w*s**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 移除所有 *w* 字符**'
- en: '***2* Strips off all *g*s, *o*s, and *r*s**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 移除所有 *g*、*o* 和 *r* 字符**'
- en: '***3* Strips off all dots, *g*s, *o*s, *r*s and *w*s**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 移除所有点、*g*、*o*、*r* 和 *w* 字符**'
- en: Note that `strip` removes any and all of the characters in the extra parameter
    string, no matter in which order they occur ***2***.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`strip` 会移除任何在额外参数字符串中出现的字符，无论它们的顺序如何 ***2***。
- en: The most common use for these functions is as a quick way to clean up strings
    that have just been read in. This technique is particularly helpful when you’re
    reading lines from files (discussed in [chapter 13](kindle_split_024.html#ch13)),
    because Python always reads in an entire line, including the trailing newline,
    if one exists. When you get around to processing the line read in, you typically
    don’t want the trailing newline. `rstrip` is a convenient way to get rid of it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数最常见的使用方式是作为一种快速清理刚读取的字符串的方法。当你从文件中读取行时（在第 13 章 [kindle_split_024.html#ch13]
    中讨论），这种技术尤其有用，因为 Python 总是读取整个行，包括尾随换行符（如果有的话）。当你开始处理读取的行时，你通常不希望有尾随换行符。`rstrip`
    是一种方便的方法来去除它。
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: strip'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：strip
- en: If the string `x` equals `"(name, date),\n"`, which of the following would return
    a string containing `"name, date"`?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串 `x` 等于 `"(name, date),\n"`，以下哪个会返回包含 `"name, date"` 的字符串？
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.4.4\. String searching
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.4\. 字符串搜索
- en: 'The string objects provide several methods to perform simple string searches.
    Before I describe them, though, I’ll talk about another module in Python: `re`.
    (This module is discussed in-depth in [chapter 16](kindle_split_028.html#ch16).)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象提供了几种方法来执行简单的字符串搜索。在我描述它们之前，我将谈谈 Python 中的另一个模块：`re`。（这个模块在 [第 16 章](kindle_split_028.html#ch16)
    中进行了深入讨论。）
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Another method for searching strings: the re module**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种搜索字符串的方法：re 模块**'
- en: The `re` module also does string searching but in a far more flexible manner,
    using *regular expressions*. Rather than search for a single specified substring,
    a `re` search can look for a string pattern. You could look for substrings that
    consist entirely of digits, for example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`re` 模块也执行字符串搜索，但方式更加灵活，使用 *正则表达式*。而不是搜索单个指定的子字符串，`re` 搜索可以查找字符串模式。例如，你可以查找完全由数字组成的子字符串。'
- en: Why am I mentioning this when `re` is discussed fully later? In my experience,
    many uses of basic string searches are inappropriate. You’d benefit from a more
    powerful searching mechanism but aren’t aware that one exists, so you don’t even
    look for something better. Perhaps you have an urgent project involving strings
    and don’t have time to read this entire book. If basic string searching does the
    job for you, that’s great. But be aware that you have a more powerful alternative.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在后面会详细讨论 `re` 模块的时候，我还要提到这个？在我的经验中，许多基本字符串搜索的使用是不恰当的。你会从更强大的搜索机制中受益，但你可能不知道它的存在，所以你甚至没有寻找更好的东西。也许你有一个紧急的项目涉及到字符串，你没有时间阅读这本书的整个内容。如果基本的字符串搜索对你来说足够用，那很好。但请注意，你有一个更强大的替代方案。
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The four basic string-searching methods are similar: `find`, `rfind`, `index`,
    and `rindex`. A related method, `count`, counts how many times a substring can
    be found in another string. I describe `find` in detail and then examine how the
    other methods differ from it.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 四种基本字符串搜索方法类似：`find`、`rfind`、`index` 和 `rindex`。一个相关的方法 `count`，用于计算一个子字符串在另一个字符串中可以出现的次数。我将详细描述
    `find`，然后检查其他方法与它的区别。
- en: '`find` takes one required argument: the substring being searched for. `find`
    returns the position of the first character of the first instance of `substring`
    in the `string` object, or `–1` if `substring` doesn’t occur in the string:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 函数接受一个必需的参数：要搜索的子字符串。`find` 函数返回 `string` 对象中第一个 `substring` 实例的第一个字符的位置，如果
    `substring` 在字符串中不存在，则返回 `-1`：'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`find` can also take one or two additional, optional arguments. The first of
    these arguments, if present, is an integer `start`; it causes `find` to ignore
    all characters before position `start` in `string` when searching for `substring`.
    The second optional argument, if present, is an integer `end`; it causes `find`
    to ignore characters at or after position `end` in `string`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 方法也可以接受一个或两个额外的可选参数。这些参数中的第一个，如果存在，是一个整数 `start`；它会导致 `find` 在搜索子字符串时忽略
    `string` 中 `start` 位置之前的所有字符。第二个可选参数，如果存在，是一个整数 `end`；它会导致 `find` 忽略 `string`
    中 `end` 位置及之后的字符：'
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`rfind` is almost the same as `find`, except that it starts its search at the
    end of `string` and so returns the position of the first character of the last
    occurrence of `substring` in `string:`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`rfind` 几乎与 `find` 相同，除了它从 `string` 的末尾开始搜索，因此返回子字符串在 `string` 中最后出现的第一字符的位置：'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`rfind` can also take one or two optional arguments, with the same meanings
    as those for `find`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`rfind` 也可以接受一个或两个可选参数，其含义与 `find` 的相同。'
- en: '`index` and `rindex` are identical to `find` and `rfind`, respectively, except
    for one difference: If `index` or `rindex` fails to find an occurrence of `substring`
    in `string`, it doesn’t return `–1` but raises a `ValueError` exception. Exactly
    what this means will be clear after you read [chapter 14](kindle_split_025.html#ch14).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 和 `rindex` 与 `find` 和 `rfind` 相同，唯一的区别是：如果 `index` 或 `rindex` 在 `string`
    中找不到 `substring` 的出现，它不会返回 `-1`，而是引发一个 `ValueError` 异常。具体是什么意思，在你阅读了 [第14章](kindle_split_025.html#ch14)
    之后就会清楚。'
- en: '`count` is used identically to any of the previous four functions, but returns
    the number of non-overlapping times the given substring occurs in the given string:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 的用法与前面四个函数相同，但返回给定子字符串在给定字符串中非重叠出现的次数：'
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can use two other string methods to search strings: `startswith` and `endswith`.
    These methods return a `True` or `False` result, depending on whether the string
    they’re used on starts or ends with one of the strings given as parameters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另外两种字符串方法来搜索字符串：`startswith` 和 `endswith`。这些方法根据它们所使用的字符串是否以参数中给出的字符串之一开始或结束，返回
    `True` 或 `False` 结果：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Both `startswith` and `endswith` can look for more than one string at a time.
    If the parameter is a tuple of strings, both methods check for all the strings
    in the tuple and return `True` if any one of them is found:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`startswith` 和 `endswith` 都可以同时查找多个字符串。如果参数是字符串的元组，这两个方法都会检查元组中的所有字符串，如果其中任何一个被找到，则返回
    `True`：'
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`startswith` and `endswith` are useful for simple searches where you’re sure
    that what you’re checking for is at the beginning or end of a line.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`startswith` 和 `endswith` 对于简单的搜索很有用，其中你确信你要检查的是行的开始或结束。'
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: String searching'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：字符串搜索
- en: If you wanted to check whether a line ends with the string `"rejected"`, what
    string method would you use? Would there be any other ways to get the same result?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查一行是否以字符串 `"rejected"` 结尾，你会使用什么字符串方法？还有没有其他方法可以得到相同的结果？
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.4.5\. Modifying strings
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.5\. 修改字符串
- en: Strings are immutable, but string objects have several methods that can operate
    on that string and return a new string that’s a modified version of the original
    string. This provides much the same effect as direct modification for most purposes.
    You can find a more complete description of these methods in the documentation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的，但字符串对象有几种方法可以操作该字符串，并返回一个新的字符串，它是原始字符串的修改版本。这在大多数情况下提供了与直接修改相同的效果。你可以在文档中找到这些方法的更完整描述。
- en: 'You can use the `replace` method to replace occurrences of `substring` (its
    first argument) in the string with `newstring` (its second argument). This method
    also takes an optional third argument (see the documentation for details):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `replace` 方法将字符串中的 `substring`（其第一个参数）替换为 `newstring`（其第二个参数）。此方法还接受一个可选的第三个参数（有关详细信息，请参阅文档）：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Like the string search functions, the `re` module is a much more powerful method
    of substring replacement.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串搜索函数一样，`re` 模块是替换子字符串的更强大方法。
- en: The functions `string.maketrans` and `string.translate` may be used together
    to translate characters in strings into different characters. Although rarely
    used, these functions can simplify your life when they’re needed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `string.maketrans` 和 `string.translate` 可以一起使用，将字符串中的字符转换成不同的字符。尽管很少使用，但在需要时这些函数可以简化你的生活。
- en: Suppose that you’re working on a program that translates string expressions
    from one computer language into another. The first language uses `~` to mean logical
    not, whereas the second language uses `!`; the first language uses `^` to mean
    logical and, the second language uses `&`; the first language uses `(` and `)`,
    whereas the second language uses `[` and `]`. In a given string expression, you
    need to change all instances of `~` to `!`, all instances of `^` to `&`, all instances
    of `(` to `[`, and all instances of `)` to `]`. You could do this by using multiple
    invocations of `replace`, but an easier and more efficient way is
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个程序，将字符串表达式从一种计算机语言翻译成另一种语言。第一种语言中用 `~` 表示逻辑非，而第二种语言中用 `!`；第一种语言中用 `^`
    表示逻辑与，第二种语言中用 `&`；第一种语言中使用 `(` 和 `)`，而第二种语言中使用 `[` 和 `]`。在给定的字符串表达式中，你需要将所有 `~`
    替换为 `!`，所有 `^` 替换为 `&`，所有 `(` 替换为 `[`，以及所有 `)` 替换为 `]`。你可以通过多次调用 `replace` 来完成这个任务，但一个更简单、更有效的方法是
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second line uses `maketrans` to make up a translation table from its two
    string arguments. The two arguments must each contain the same number of characters,
    and a table is made such that looking up the *n*th character of the first argument
    in that table gives back the *n*th character of the second argument.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行使用 `maketrans` 从其两个字符串参数创建一个翻译表。这两个参数必须包含相同数量的字符，并且创建的表使得在表中查找第一个参数的第 *n*
    个字符会返回第二个参数的第 *n* 个字符。
- en: Next, the table produced by `maketrans` is passed to `translate`. Then `translate`
    goes over each of the characters in its `string` object and checks to see whether
    they can be found in the table given as the second argument. If a character can
    be found in the translation table, `translate` replaces that character with the
    corresponding character looked up in the table to produce the translated string.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`maketrans` 生成的表传递给 `translate`。然后 `translate` 遍历其 `string` 对象中的每个字符，并检查它们是否可以在提供的第二个参数的表中找到。如果一个字符可以在翻译表中找到，`translate`
    就会将其替换为表中查找的相应字符，以生成翻译后的字符串。
- en: You can give `translate` an optional argument to specify characters that should
    be removed from the string. See the documentation for details.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `translate` 提供一个可选参数来指定应从字符串中删除的字符。有关详细信息，请参阅文档。
- en: Other functions in the `string` module perform more specialized tasks. `string.lower`
    converts all alphabetic characters in a string to lowercase, and `upper` does
    the opposite. `capitalize` capitalizes the first character of a string, and `title`
    capitalizes all words in a string. `swapcase` converts lowercase characters to
    uppercase and uppercase to lowercase in the same string. `expandtabs` gets rid
    of tab characters in a string by replacing each tab with a specified number of
    spaces. `ljust`, `rjust`, and `center` pad a string with spaces to justify it
    in a certain field width. `zfill` left-pads a numeric string with zeros. Refer
    to the documentation for details on these methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 模块中的其他函数执行更专业的任务。`string.lower` 将字符串中的所有字母字符转换为小写，而 `upper` 则相反。`capitalize`
    将字符串的第一个字符转换为大写，而 `title` 将字符串中的所有单词转换为大写。`swapcase` 在同一字符串中将小写字符转换为大写，将大写字符转换为小写。`expandtabs`
    通过将每个制表符替换为指定数量的空格来删除字符串中的制表符。`ljust`、`rjust` 和 `center` 使用空格填充字符串以在特定字段宽度内对齐。`zfill`
    在数字字符串的左侧填充零。有关这些方法的详细信息，请参阅文档。'
- en: 6.4.6\. Modifying strings with list manipulations
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.6\. 使用列表操作修改字符串
- en: 'Because strings are immutable objects, you have no way to manipulate them directly
    in the same way that you can manipulate lists. Although the operations that produce
    new strings (leaving the original strings unchanged) are useful for many things,
    sometimes you want to be able to manipulate a string as though it were a list
    of characters. In that case, turn the string into a list of characters, do whatever
    you want, and then turn the resulting list back into a string:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串是不可变对象，你不能像操作列表那样直接操作它们。虽然产生新字符串（不改变原始字符串）的操作对许多事情都很有用，但有时你希望能够像操作字符列表一样操作字符串。在这种情况下，将字符串转换为字符列表，做你想做的任何操作，然后将结果列表转换回字符串：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Removes everything after comma**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 删除逗号之后的所有内容**'
- en: '***2* Joins with no space between**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 无空格连接**'
- en: You can also turn a string into a tuple of characters by using the built-in
    `tuple` function. To turn the list back into a string, use `"".join()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内置的 `tuple` 函数将字符串转换为字符元组。要将列表转换回字符串，使用 `"".join()`。
- en: You shouldn’t go overboard with this method because it causes the creation and
    destruction of new `string` objects, which is relatively expensive. Processing
    hundreds or thousands of strings in this manner probably won’t have much of an
    impact on your program; processing millions of strings probably will.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该过度使用此方法，因为它会导致新的 `string` 对象的创建和销毁，这相对昂贵。以这种方式处理数百或数千个字符串可能不会对您的程序产生太大影响；处理数百万个字符串可能会。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Modifying strings'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：修改字符串
- en: What would be a quick way to change all punctuation in a string to spaces?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么快速的方法可以将字符串中的所有标点符号更改为空格？
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.4.7\. Useful methods and constants
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.7\. 有用的方法和常量
- en: '`string` objects also have several useful methods to report various characteristics
    of the string, such as whether it consists of digits or alphabetic characters,
    or is all uppercase or lowercase:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 对象还具有几个有用的方法来报告字符串的各种特征，例如它是否由数字或字母字符组成，或者是否全部为大写或小写：'
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For a list of all the possible string methods, refer to the string section of
    the official Python documentation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有可能的字符串方法的列表，请参阅官方 Python 文档中的字符串部分。
- en: Finally, the `string` module defines some useful constants. You’ve already seen
    `string.whitespace`, which is a string made up of the characters Python thinks
    of as whitespace on your system. `string.digits` is the string `'0123456789'`.
    `string.hexdigits` includes all the characters in `string.digits`, as well as
    `'abcdefABCDEF'`, the extra characters used in hexadecimal numbers. `string.octdigits`
    contains `'01234567'`—only those digits used in octal numbers. `string.lowercase`
    contains all lowercase alphabetic characters; `string.uppercase` contains all
    uppercase alphabetic characters; `string.letters` contains all the characters
    in `string.lowercase` and `string.uppercase`. You might be tempted to try assigning
    to these constants to change the behavior of the language. Python would let you
    get away with this action, but it probably would be a bad idea.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`string` 模块定义了一些有用的常量。您已经看到了 `string.whitespace`，它是由 Python 系统认为的空白字符组成的字符串。`string.digits`
    是字符串 `'0123456789'`。`string.hexdigits` 包含 `string.digits` 中的所有字符，以及 `'abcdefABCDEF'`，这是十六进制数中使用的额外字符。`string.octdigits`
    包含 `'01234567'`——仅包含八进制数中使用的数字。`string.lowercase` 包含所有小写字母字符；`string.uppercase`
    包含所有大写字母字符；`string.letters` 包含 `string.lowercase` 和 `string.uppercase` 中的所有字符。您可能会想尝试将这些常量赋值以更改语言的行为。Python
    会让您逃避这种行为，但这可能不是一个好主意。
- en: Remember that strings are sequences of characters, so you can use the convenient
    Python `in` operator to test for a character’s membership in any of these strings,
    although usually the existing string methods are simpler and easier. The most
    common string operations are shown in [table 6.2](#ch06table02).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，字符串是字符序列，因此您可以使用方便的 Python `in` 操作符来测试字符是否属于这些字符串中的任何一个，尽管通常现有的字符串方法更简单、更容易使用。最常见的字符串操作如表
    6.2 所示。
- en: Table 6.2\. Common string operations
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.2\. 常见字符串操作
- en: '| String operation | Explanation | Example |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 字符串操作 | 说明 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| + | Adds two strings together | x = "hello " + "world" |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| + | 将两个字符串连接在一起 | x = "hello " + "world" |'
- en: '| * | Replicates a string | x = " " * 20 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| * | 复制字符串 | x = " " * 20 |'
- en: '| upper | Converts a string to uppercase | x.upper() |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| upper | 将字符串转换为大写 | x.upper() |'
- en: '| lower | Converts a string to lowercase | x.lower() |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| lower | 将字符串转换为小写 | x.lower() |'
- en: '| title | Capitalizes the first letter of each word in a string | x.title()
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| title | 将字符串中每个单词的首字母大写 | x.title() |'
- en: '| find, index | Searches for the target in a string | x.find(y) x.index(y)
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| find, index | 在字符串中搜索目标 | x.find(y) x.index(y) |'
- en: '| rfind, rindex | Searches for the target in a string, from the end of the
    string | x.rfind(y) x.rindex(y) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| rfind, rindex | 在字符串中从末尾开始搜索目标 | x.rfind(y) x.rindex(y) |'
- en: '| startswith, endswith | Checks the beginning or end of a string for a match
    | x.startswith(y) x.endswith(y) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| startswith, endswith | 检查字符串的开始或结束是否与指定字符串匹配 | x.startswith(y) x.endswith(y)
    |'
- en: '| replace | Replaces the target with a new string | x.replace(y, z) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| replace | 将目标字符串替换为新字符串 | x.replace(y, z) |'
- en: '| strip, rstrip, lstrip | Removes whitespace or other characters from the ends
    of a string | x.strip() |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| strip, rstrip, lstrip | 从字符串的末尾删除空白或其他字符 | x.strip() |'
- en: '| encode | Converts a Unicode string to a bytes object | x.encode("utf_8")
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| encode | 将 Unicode 字符串转换为 bytes 对象 | x.encode("utf_8") |'
- en: Note that these methods don’t change the string itself; they return either a
    location in the string or a new string.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法不会改变字符串本身；它们返回字符串中的一个位置或一个新的字符串。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: String operations'
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：字符串操作
- en: 'Suppose that you have a list of strings in which some (but not necessarily
    all) of the strings begin and end with the double quote character:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个字符串列表，其中一些（但不一定是所有）字符串以双引号字符开始和结束：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What code would you use on each element to remove just the double quotes?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用什么代码来处理每个元素以仅删除双引号？
- en: What code could you use to find the position of the last `p` in `Mississippi`?
    When you’ve found that position, what code would you use to remove just that letter?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用什么代码来找到 `Mississippi` 中最后一个 `p` 的位置？当你找到这个位置后，你会使用什么代码来仅删除那个字母？
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.5\. Converting from objects to strings
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5. 从对象转换为字符串
- en: 'In Python, almost anything can be converted to some sort of a string representation
    by using the built-in `repr` function. Lists are the only complex Python data
    types you’re familiar with so far, so here, I turn some lists into their representations:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，几乎任何东西都可以通过使用内置的 `repr` 函数转换为某种字符串表示。列表是你迄今为止熟悉的唯一复杂 Python 数据类型，所以在这里，我将一些列表转换为它们的表示：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The example uses `repr` to convert the list `x` to a string representation,
    which is then concatenated with the other string to form the final string. Without
    the use of `repr`, this code wouldn’t work. In an expression like `"string" +
    [1, 2] + 3`, are you trying to add strings, add lists, or just add numbers? Python
    doesn’t know what you want in such a circumstance, so it does the safe thing (raises
    an error) rather than make any assumptions. In the previous example, all the elements
    had to be converted to string representations before the string concatenation
    would work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用 `repr` 将列表 `x` 转换为字符串表示，然后将该字符串与其他字符串连接起来形成最终的字符串。如果没有使用 `repr`，此代码将无法工作。在表达式
    `"string" + [1, 2] + 3` 中，你是想添加字符串、添加列表还是仅仅添加数字？Python 在这种情况下不知道你想要什么，所以它做了安全的事情（引发错误）而不是做出任何假设。在前面的例子中，所有元素都必须转换为字符串表示，然后才能进行字符串连接。
- en: 'Lists are the only complex Python objects that I’ve described to this point,
    but `repr` can be used to obtain some sort of string representation for almost
    any Python object. To see this, try `repr` around a built-in complex object, which
    is an actual Python function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我描述的唯一复杂 Python 对象是列表，但 `repr` 可以用于为几乎任何 Python 对象获取某种字符串表示。为了看到这一点，尝试在某个内置的复杂对象周围使用
    `repr`，这是一个实际的 Python 函数：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Python hasn’t produced a string containing the code that implements the `len`
    function, but it has at least returned a string—`<built-in function len>`—that
    describes what that function is. If you keep the `repr` function in mind and try
    it on each Python data type (dictionaries, tuples, classes, and the like) in the
    book, you’ll see that no matter what type of Python object you have, you can get
    a string that describes something about that object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有生成包含实现 `len` 函数的代码的字符串，但它至少返回了一个字符串——`<内置函数 len>`——描述了该函数的功能。如果你记住
    `repr` 函数并尝试将其应用于书中提到的每种 Python 数据类型（字典、元组、类等），你会发现无论你有什么类型的 Python 对象，你都可以得到一个描述该对象的字符串。
- en: This is great for debugging programs. If you’re in doubt about what’s held in
    a variable at a certain point in your program, use `repr` and print out the contents
    of that variable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试程序非常有用。如果你对你的程序中某个特定点的变量所包含的内容有疑问，请使用 `repr` 并打印出该变量的内容。
- en: I’ve covered how Python can convert any object to a string that describes that
    object. The truth is, Python can do this in either of two ways. The `repr` function
    always returns what might be loosely called the *formal string representation*
    of a Python object. More specifically, `repr` returns a string representation
    of a Python object from which the original object can be rebuilt. For large, complex
    objects, this may not be the sort of thing you want to see in debugging output
    or status reports.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了 Python 如何将任何对象转换为描述该对象的字符串。事实上，Python 可以以两种方式之一完成此操作。`repr` 函数始终返回可以松散地称为
    Python 对象的 *正式字符串表示* 的内容。更具体地说，`repr` 返回一个可以重建原始对象的字符串表示。对于大型、复杂对象，这可能不是你希望在调试输出或状态报告中看到的内容。
- en: Python also provides the built-in `str` function. In contrast to `repr`, `str`
    is intended to produce *printable* string representations, and it can be applied
    to any Python object. `str` returns what might be called the *informal string
    representation* of the object. A string returned by `str` need not define an object
    fully and is intended to be read by humans, not by Python code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还提供了内置的 `str` 函数。与 `repr` 相比，`str` 的目的是生成 *可打印* 的字符串表示，它可以应用于任何 Python
    对象。`str` 返回可能被称为对象的 *非正式字符串表示*。`str` 返回的字符串不需要完全定义一个对象，其目的是供人类阅读，而不是供 Python 代码阅读。
- en: You won’t notice any difference between `repr` and `str` when you start using
    them, because until you begin using the object-oriented features of Python, there’s
    no difference. `str` applied to any built-in Python object always calls `repr`
    to calculate its result. Only when you start defining your own classes does the
    difference between `str` and `repr` become important, as discussed in [chapter
    15](kindle_split_027.html#ch15).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用它们时，你不会注意到 `repr` 和 `str` 之间的任何区别，因为直到你开始使用 Python 的面向对象特性，它们之间没有区别。将
    `str` 应用到任何内置 Python 对象时，总是调用 `repr` 来计算其结果。只有当你开始定义自己的类时，`str` 和 `repr` 之间的区别才变得重要，如第
    [15 章](kindle_split_027.html#ch15) 中所述。
- en: So why talk about this now? I want you to be aware that there’s more going on
    behind the scenes with `repr` than just being able to easily write `print` functions
    for debugging. As a matter of good style, you may want to get into the habit of
    using `str` rather than `repr` when creating strings for displaying information.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么现在要谈论这个呢？我想让你意识到，在 `repr` 的背后还有更多的事情在进行，而不仅仅是能够轻松地编写 `print` 函数进行调试。作为一个良好的风格习惯，你可能想要养成在创建用于显示信息的字符串时使用
    `str` 而不是 `repr` 的习惯。
- en: 6.6\. Using the format method
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6\. 使用格式方法
- en: You can format strings in Python 3 in two ways. The newer way is to use the
    string class’s `format` method. The `format` method combines a format string containing
    replacement fields marked with `{ }` with replacement values taken from the parameters
    given to the `format` command. If you need to include a literal `{` or `}` in
    the string, you double it to `{{` or `}}`. The `format` command is a powerful
    string-formatting mini-language that offers almost endless possibilities for manipulating
    string formatting. Conversely, it’s fairly simple to use for the most common use
    cases, so I look at a few basic patterns in this section. Then, if you need to
    use the more advanced options, you can refer to the string-formatting section
    of the standard library documentation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，你可以用两种方式格式化字符串。较新的方法是使用字符串类的 `format` 方法。`format` 方法将包含用 `{ }`
    标记的替换字段的格式字符串与从 `format` 命令提供的参数中取出的替换值结合起来。如果你需要在字符串中包含字面量 `{` 或 `}`，你可以将其加倍为
    `{{` 或 `}}`。`format` 命令是一个强大的字符串格式化迷你语言，提供了几乎无限的可能性来操作字符串格式化。相反，对于最常见的用例来说，它使用起来相当简单，所以我在本节中查看了一些基本模式。然后，如果你需要使用更高级的选项，你可以参考标准库文档中的字符串格式化部分。
- en: 6.6.1\. The format method and positional parameters
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.1\. 格式方法和位置参数
- en: 'A simple way to use the string `format` method is with numbered replacement
    fields that correspond to the parameters passed to the `format` function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串 `format` 方法的简单方法是与传递给 `format` 函数的参数相对应的编号替换字段：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the `format` method is applied to the format string, which can also
    be a string variable ***1***. Doubling the `{ }` characters escapes them so that
    they don’t mark a replacement field ***2***.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`format` 方法应用于格式字符串，该字符串也可以是一个字符串变量 ***1***。将 `{ }` 字符加倍可以将其转义，这样它们就不会标记替换字段
    ***2***。
- en: This example has three replacement fields, `{0}`, `{1}`, and `{2}`, which are
    in turn filled by the first, second, and third parameters. No matter where in
    the format string you place `{0}`, it’s always be replaced by the first parameter,
    and so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有三个替换字段，`{0}`、`{1}` 和 `{2}`，它们依次由第一个、第二个和第三个参数填充。无论你在格式字符串中的哪个位置放置 `{0}`，它总是被第一个参数替换，依此类推。
- en: You can also use the named parameters.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用命名参数。
- en: 6.6.2\. The format method and named parameters
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.2\. 格式方法和命名参数
- en: 'The `format` method also recognizes named parameters and replacement fields:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 方法也识别命名参数和替换字段：'
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, the replacement parameter is chosen by matching the name of the
    replacement field with the name of the parameter given to the `format` command.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，替换参数是通过将替换字段的名字与传递给 `format` 命令的参数的名字相匹配来选择的。
- en: 'You can also use both positional and named parameters, and you can even access
    attributes and elements within those parameters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用位置参数和命名参数，甚至可以访问这些参数内的属性和元素：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, the first parameter is positional, and the second, `user[1]`,
    refers to the second element of the named parameter `user`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个参数是位置参数，第二个参数 `user[1]` 指的是命名参数 `user` 的第二个元素。
- en: 6.6.3\. Format specifiers
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.3\. 格式说明符
- en: 'Format specifiers let you specify the result of the formatting with even more
    power and control than the formatting sequences of the older style of string formatting.
    The format specifier lets you control the fill character, alignment, sign, width,
    precision, and type of the data when it’s substituted for the replacement field.
    As noted earlier, the syntax of format specifiers is a mini-language in its own
    right and too complex to cover completely here, but the following examples give
    you an idea of its usefulness:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符允许你使用比旧式字符串格式化的格式化序列更多的力量和控制来指定格式化的结果。格式说明符允许你控制填充字符、对齐、符号、宽度、精度和数据类型，当它替换替换字段时。如前所述，格式说明符的语法是其自身的迷你语言，过于复杂，无法在此完全介绍，但以下示例可以给你一个其有用性的概念：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: :`10` is a format specifier that makes the field 10 spaces wide and pads with
    spaces ***1***. :`{1}` takes the width from the second parameter ***2***. :`>10`
    forces right-justification of the field and pads with spaces ***3***. :`&>10`
    forces right-justification and pads with `&` instead of spaces ***4***.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: :`10` 是一个格式说明符，使字段宽度为 10 个空格，并用空格填充 ***1***。 :`{1}` 从第二个参数 ***2*** 中获取宽度。 :`>10`
    强制字段右对齐，并用空格填充 ***3***。 :`&>10` 强制右对齐，并用 `&` 而不是空格填充 ***4***。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: the format() method'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：format() 方法
- en: 'What will be in x when the following snippets of code are executed?:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '当以下代码片段执行时，x 将包含什么？:'
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.7\. Formatting strings with %
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7\. 使用 `%` 格式化字符串
- en: This section covers formatting strings with the *string modulus* (`%`) operator.
    This operator is used to combine Python values into formatted strings for printing
    or other use. C users will notice a strange similarity to the `printf` family
    of functions. The use of `%` for string formatting is the old style of string
    formatting, and I cover it here because it was the standard in earlier versions
    of Python, and you’re likely to see it in code that’s been ported from earlier
    versions of Python or was written by coders who are familiar with those versions.
    This style of formatting shouldn’t be used in new code, however, because it’s
    slated to be deprecated and then removed from the language in the future.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了使用 *字符串模运算符* (`%`) 格式化字符串。此运算符用于将 Python 值组合成格式化字符串以供打印或其他用途。C 语言用户会注意到它与
    `printf` 函数家族有奇怪的相似性。使用 `%` 进行字符串格式化是旧式字符串格式化的方式，我在这里介绍它是因为它是 Python 早期版本的标准，你可能会在从早期版本迁移的代码中看到它，或者是由熟悉这些版本的程序员编写的代码中看到它。然而，这种格式化方式不应该用于新代码，因为它计划在未来被弃用并从语言中移除。
- en: 'Here’s an example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The string modulus operator (the bold `%` that occurs in the middle, not the
    three instances of `%s` that come before it in the example) takes two parts: the
    left side, which is a string, and the right side, which is a tuple. The string
    modulus operator scans the left string for special *formatting sequences* and
    produces a new string by substituting the values on the right side for those formatting
    sequences, in order. In this example, the only formatting sequences on the left
    side are the three instances of `%s`, which stands for “Stick a string in here.”'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模运算符（中间的粗体 `%`，而不是示例中它前面的三个 `%s` 实例）包含两部分：左边，是一个字符串；右边，是一个元组。字符串模运算符会扫描左边的字符串以查找特殊的*格式化序列*，并通过用右边的值按顺序替换这些格式化序列来生成一个新的字符串。在这个例子中，左边唯一的格式化序列是三个
    `%s` 实例，代表“在这里插入一个字符串”。
- en: 'Passing in different values on the right side produces different strings:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在右边传递不同的值会产生不同的字符串：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The members of the tuple on the right have `str` applied to them automatically
    by `%s`, so they don’t have to already be strings:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 右边元组的成员会被 `%s` 自动应用 `str`，因此它们不必已经是字符串：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 6.7.1\. Using formatting sequences
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.1\. 使用格式化序列
- en: All formatting sequences are substrings contained in the string on the left
    side of the central `%`. Each formatting sequence begins with a percent sign and
    is followed by one or more characters that specify what is to be substituted for
    the formatting sequence and how the substitution is to be accomplished. The `%s`
    formatting sequence used previously is the simplest formatting sequence; it indicates
    that the corresponding string from the tuple on the right side of the central
    `%` should be substituted in place of the `%s`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有格式化序列都是位于中心 `%` 左侧字符串中的子字符串。每个格式化序列以一个百分号开始，后面跟一个或多个字符，这些字符指定了要替换格式化序列的内容以及如何进行替换。之前使用的
    `%s` 格式化序列是最简单的格式化序列；它表示应该用位于中心 `%` 右侧元组的对应字符串替换 `%s`。
- en: 'Other formatting sequences can be more complex. The following sequence specifies
    the field width (total number of characters) of a printed number to be six, specifies
    the number of characters after the decimal point to be two, and left-justifies
    the number in its field. I’ve put this formatting sequence in angle brackets so
    you can see where extra spaces are inserted into the formatted string:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 其他格式化序列可能更复杂。以下序列指定了打印数字的字段宽度（总字符数）为六，指定小数点后的字符数为两位，并将数字左对齐在其字段中。我将这个格式化序列放在尖括号中，这样你可以看到在格式化字符串中插入额外空格的位置：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All the options for characters that are allowable in formatting sequences are
    given in the documentation. There are quite a few options, but none is particularly
    difficult to use. Remember that you can always try a formatting sequence interactively
    in Python to see whether it does what you expect it to do.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化序列中允许使用的字符选项都在文档中给出。选项有很多，但没有任何一个特别难用。记住，你总是可以在 Python 中交互式地尝试一个格式化序列，看看它是否按预期工作。
- en: 6.7.2\. Named parameters and formatting sequences
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.2\. 命名参数和格式化序列
- en: 'Finally, one additional feature available with the `%` operator can be useful
    in certain circumstances. Unfortunately, to describe it, I have to employ a Python
    feature that I haven’t yet discussed in detail: *dictionaries*, commonly called
    *hash tables* or *associative arrays* in other languages. You can skip ahead to
    [chapter 7](kindle_split_018.html#ch07) to learn about dictionaries; skip this
    section for now and come back to it later; or read straight through, trusting
    the examples to make things clear.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`%` 操作符的一个额外功能在特定情况下可能很有用。不幸的是，为了描述它，我必须使用一个我还没有详细讨论过的 Python 功能：*字典*，在其他语言中通常称为
    *散列表* 或 *关联数组*。你可以跳到[第7章](kindle_split_018.html#ch07)去了解字典；现在跳过这一节，稍后再回来；或者直接阅读，相信示例会使事情变得清晰。
- en: 'Formatting sequences can specify what should be substituted for them by name
    rather than by position. When you do this, each formatting sequence has a name
    in parentheses immediately following the initial `%` of the formatting sequence,
    like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化序列可以指定通过名称而不是位置来替换它们的内容。当你这样做时，每个格式化序列在其格式化序列的初始 `%` 后面都有一个括号内的名称，如下所示：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Note name in parentheses.**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意括号中的名称。**'
- en: 'In addition, the argument to the right of the `%` operator is no longer given
    as a single value or tuple of values to be printed, but as a dictionary of values
    to be printed, with each named formatting sequence having a correspondingly named
    key in the dictionary. Using the previous formatting sequence with the string
    modulus operator, you might produce code like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`%` 操作符右侧的参数不再是作为单个值或值的元组来打印，而是作为要打印的值的字典。在字典中，每个命名的格式化序列都有一个相应命名的键。使用之前的格式化序列和字符串模数操作符，你可能产生如下代码：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code is particularly useful when you’re using format strings that perform
    a large number of substitutions, because you no longer have to keep track of the
    positional correspondences of the right-side tuple of elements with the formatting
    sequences in the format string. The order in which elements are defined in the
    `dict` argument is irrelevant, and the template string may use values from `dict`
    more than once (as it does with the `'pi'` entry).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用执行大量替换的格式字符串时，这段代码特别有用，因为你不再需要跟踪右侧元素元组与格式字符串中格式化序列的位置对应关系。在 `dict` 参数中定义元素的顺序无关紧要，模板字符串可以使用
    `dict` 中的值多次（就像 `'pi'` 条目那样）。
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Controlling output with the print function**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 print 函数控制输出**'
- en: 'Python’s built-in `print` function also has some options that can make handling
    simple string output easier. When used with one parameter, `print` prints the
    value and a newline character, so that a series of calls to `print` prints each
    value on a separate line:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的内置 `print` 函数还有一些选项可以使处理简单的字符串输出更加容易。当使用一个参数时，`print` 打印值和换行符，因此一系列对
    `print` 的调用将在单独的一行上打印每个值：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But `print` can do more. You can also give the `print` function several arguments,
    and those arguments are printed on the same line, separated by spaces and ending
    with a newline:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `print` 函数的功能不止于此。你还可以给 `print` 函数传递多个参数，这些参数将在同一行上打印出来，由空格分隔，并以换行符结束：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If that’s not quite what you need, you can give the `print` function additional
    parameters to control what separates each item and what ends the line:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，你可以给 `print` 函数提供额外的参数来控制每个项目之间的分隔符以及行结束符：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, the `print` function can be used to print to files as well as console
    output.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`print` 函数还可以用于打印到文件以及控制台输出。
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using the `print` function’s options gives you enough control for simple text
    output, but more complex situations are best served by using the `format` method.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `print` 函数的选项为你提供了足够控制简单文本输出的能力，但对于更复杂的情况，最好使用 `format` 方法。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Formatting strings with %'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：使用 % 格式化字符串
- en: What would be in the variable `x` after the following snippets of code have
    executed?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段执行后，变量 `x` 中会有什么？
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.8\. String interpolation
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8\. 字符串插值
- en: 'Starting in Python 3.6, there’s a way to create string constants containing
    arbitrary values, which is called *string interpolation*. String interpolation
    is a way to include the values of Python expressions inside literal strings. These
    f-strings, as they’re commonly called because they are prefixed with `f`, use
    a syntax similar to that of the format method, but with a little less overhead.
    The following examples should give you a basic idea of how f-strings work:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.6 开始，有一种创建包含任意值字符串常量的方法，这被称为 *字符串插值*。字符串插值是一种在字面字符串中包含 Python 表达式值的方法。这些
    f-字符串，因为它们以 `f` 开头而通常被称为 f-字符串，使用与格式化方法类似的语法，但开销更小。以下示例应该能给你一个关于 f-字符串如何工作的基本概念：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Just as with the format method, format specifiers may be added:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 就像格式化方法一样，可以添加格式说明符：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Because string interpolation is a new feature, it’s not yet clear how it will
    be used. For the complete documentation on f-strings and format specifiers, refer
    to PEP-498 in the online Python documentation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串插值是一个新特性，目前尚不清楚它将如何被使用。有关 f-字符串和格式说明符的完整文档，请参阅在线 Python 文档中的 PEP-498。
- en: 6.9\. Bytes
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9\. 字节
- en: 'A `bytes` object is similar to a `string` object but with an important difference:
    A `string` is an immutable sequence of Unicode characters, whereas a `bytes` object
    is a sequence of integers with values from 0 to 256\. Bytes can be necessary when
    you’re dealing with binary data, such as reading from a binary data file.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `bytes` 对象与 `string` 对象类似，但有一个重要的区别：`string` 是一个不可变的 Unicode 字符序列，而 `bytes`
    对象是一个值从 0 到 256 的整数序列。当你处理二进制数据，如从二进制数据文件读取时，字节可能是必要的。
- en: 'The key thing to remember is that `bytes` objects may look like strings, but
    they can’t be used exactly like strings or combined with strings:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的关键点是，`bytes` 对象可能看起来像字符串，但它们不能像字符串那样使用，也不能与字符串组合：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first thing you can see is that to convert from a regular (Unicode) string
    to `bytes`, you need to call the string’s `encode` method ***1***. After it’s
    encoded to a `bytes` object, the character is 2 bytes and no longer prints the
    same way that the string did ***2***. Further, if you attempt to add a `bytes`
    object and a string object together, you get a type error because the two types
    are incompatible ***3***. Finally, to convert a `bytes` object back to a string,
    you need to call that object’s `decode` method ***4***.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先可以看到的是，要将常规（Unicode）字符串转换为 `bytes`，你需要调用字符串的 `encode` 方法 ***1***。在编码为 `bytes`
    对象后，字符是 2 个字节，并且不再以字符串的方式打印 ***2***。此外，如果你尝试将 `bytes` 对象和字符串对象相加，你会得到一个类型错误，因为这两种类型是不兼容的
    ***3***。最后，要将 `bytes` 对象转换回字符串，你需要调用该对象的 `decode` 方法 ***4***。
- en: Most of the time, you shouldn’t need to think about Unicode or bytes at all.
    But when you need to deal with international character sets (an increasingly common
    issue), you must understand the difference between regular strings and `bytes`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你根本不需要考虑 Unicode 或字节。但是，当你需要处理国际字符集（一个越来越普遍的问题）时，你必须理解常规字符串和 `bytes`
    之间的区别。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Bytes'
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：字节
- en: For which of the following kinds of data would you want to use a string? For
    which could you use bytes?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下哪种类型的数据，你会想要使用字符串？对于哪种可以使用字节？
- en: '***1*** Data file storing binary data'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 存储二进制数据的文件'
- en: '***2*** Text in a language with accented characters'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 带有重音字符的语言中的文本'
- en: '***3*** Text with only uppercase and lowercase roman characters'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 只有大小写罗马字符的文本'
- en: '***4*** A series of integers no larger than 255'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 一系列不超过255的整数'
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 6: Preprocessing Text'
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室6：文本预处理
- en: 'In processing raw text, it’s quite often necessary to clean and normalize the
    text before doing anything else. If you want to find the frequency of words in
    text, for example, you can make the job easier if, before you start counting,
    you make sure that everything is lowercase (or uppercase, if you prefer) and that
    all punctuation has been removed. You can also make things easier by breaking
    the text into a series of words. In this lab, the task is to read the first part
    of the first chapter of *Moby Dick* (found in the book’s source code), make sure
    that everything is one case, remove all punctuation, and write the words one per
    line to a second file. Because I haven’t yet covered reading and writing files,
    here’s the code for those operations:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理原始文本时，通常在执行其他任何操作之前都需要清理和规范化文本。例如，如果你想找到文本中单词的频率，你可以在开始计数之前确保所有内容都是小写（或如果你更喜欢，大写）并且所有标点符号都已删除。你还可以通过将文本分解成一系列单词来简化工作。在这个实验中，任务是读取《白鲸记》第一部分的第一章（位于书籍的源代码中），确保所有内容都是统一的大小写，删除所有标点符号，并将单词逐行写入第二个文件。因为我还没有介绍读取和写入文件，所以这里提供了这些操作的代码：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python strings have powerful text-processing features, including searching and
    replacing, trimming characters, and changing case.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python字符串具有强大的文本处理功能，包括搜索和替换、修剪字符和更改大小写。
- en: Strings are immutable; they can’t be changed in place.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是不可变的；它们不能在原地更改。
- en: Operations that appear to change strings actually return a copy with the changes.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作看起来像是在更改字符串，实际上返回的是带有更改的副本。
- en: The `re` (regular expression) module has even more powerful string capabilities,
    which are discussed in [chapter 16](kindle_split_028.html#ch16).
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re`（正则表达式）模块具有更强大的字符串功能，这些功能将在第16章中讨论。[链接](kindle_split_028.html#ch16)。'
