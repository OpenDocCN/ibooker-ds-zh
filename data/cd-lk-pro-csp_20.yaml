- en: 14 JSON serialization/ deserialization and custom model binding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 JSON 序列化/反序列化和自定义模型绑定
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Serializing and deserializing JSON data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化JSON数据
- en: Using the `[FromBody]` argument attribute to magically deserialize JSON data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[FromBody]` 参数属性神奇地反序列化 JSON 数据
- en: Implementing a custom model binder using the `IModelBinder` interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`IModelBinder`接口实现自定义模型绑定器
- en: Generating an OpenAPI specification on the fly at run time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时动态生成OpenAPI规范
- en: This is it. The last refactoring chapter. Throughout this book, you refactored
    an existing codebase from the ground up. We learned about test-driven development,
    how to write clean code, and tips and tricks for C#. Figure 14.1 shows how far
    we’ve come on our journey together.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是了。这是最后一章重构。在这本书中，我们从零开始重构了一个现有的代码库。我们学习了测试驱动开发、如何编写干净的代码以及C#的技巧和窍门。图14.1显示了我们共同旅程的进展。
- en: '![](../Images/14_01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14_01.png)'
- en: Figure 14.1 In the previous chapters, we implemented the database access, repository,
    and service layers, and `FlightController` class. In this chapter, we’ll finish
    the job and implement the `BookingController` class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 在前面的章节中，我们实现了数据库访问、仓库和服务层，以及`FlightController`类。在本章中，我们将完成这项工作并实现`BookingController`类。
- en: 'In this chapter, we’ll implement the last controller: `BookingController` (section
    14.1). After that, we’ll do some manual testing and acceptance testing against
    the OpenAPI specification from FlyTomorrow. We’ll also set up Swagger middleware
    to generate an OpenAPI specification on the fly (section 14.2). This is an optional
    but a very useful technique to know because Swagger helps us with our acceptance
    testing.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现最后一个控制器：`BookingController`（第14.1节）。之后，我们将根据FlyTomorrow的OpenAPI规范进行一些手动测试和验收测试。我们还将设置Swagger中间件以动态生成OpenAPI规范（第14.2节）。这是一个可选但非常有用的技术，因为Swagger帮助我们进行验收测试。
- en: 14.1 Implementing the BookingController class
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 实现BookingController类
- en: In chapter 13, we learned how to implement a controller (`FlightController`)
    and added some HTTP `GET` methods (`GET /Flight` and `GET Flight/{FlightNumber})`.
    In this section, we’ll build on that knowledge and implement the `BookingController`.
    The `BookingController` is the entry point and gateway for FlyTomorrow to create
    a booking with Flying Dutchman Airlines. With this controller, we’ll complete
    our implementation of the FlyingDutchmanAirlinesNextGen service and start providing
    some actual revenue value to the company. After all, if people cannot book seats
    on our flights, we can’t make money from oversized bags, snacks, and lottery tickets
    on board.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章中，我们学习了如何实现控制器（`FlightController`）并添加了一些HTTP `GET` 方法（`GET /Flight` 和 `GET
    Flight/{FlightNumber}`）。在本节中，我们将在此基础上构建并实现`BookingController`。`BookingController`是FlyTomorrow与飞荷兰人航空公司创建预订的入口和网关。通过这个控制器，我们将完成FlyingDutchmanAirlinesNextGen服务的实现，并开始为公司提供一些实际的收入价值。毕竟，如果人们不能在我们的航班上预订座位，我们就无法从超大的行李、零食和船上的彩票中赚钱。
- en: Let’s take one more look at the contract between Flying Dutchman Airlines and
    FlyTomorrow to see what endpoints the `BookingController` class should have, shown
    in figure 14.2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看飞荷兰人航空公司与FlyTomorrow之间的合同，看看`BookingController`类应该有哪些端点，如图14.2所示。
- en: '![](../Images/14_02.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14_02.png)'
- en: Figure 14.2 The, by now, well-known contract between FlyTomorrow and Flying
    Dutchman Airlines. Endpoints 1 and 2 were implemented in chapter 13\. In this
    chapter, we’ll implement endpoint 3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 现在，众所周知的FlyTomorrow与飞荷兰人航空公司之间的合同。端点1和2在第13章中实现。在本章中，我们将实现端点3。
- en: 'As you can see, we have the following three endpoints to implement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要实现以下三个端点：
- en: '`GET /Flight`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight`'
- en: '`GET /Flight/{FlightNumber}`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight/{FlightNumber}`'
- en: '`POST /Booking/{FlightNumber}`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /Booking/{FlightNumber}`'
- en: In chapter 13, we implemented endpoints numbers 1 and 2\. That leaves only the
    third endpoint for us now. The first two endpoints live inside a `FlightController`
    class, but the third requires us to implement a `BookingController` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章中，我们实现了端点1和2。现在只剩下第三个端点等待我们去实现。前两个端点位于`FlightController`类中，但第三个需要我们实现`BookingController`类。
- en: The previous two endpoints also did not require us to process any provided JSON
    body. Sure, we had a path parameter in the `GET /Flight/{FlightNumber}` endpoint,
    but it constrained the flight number data to whatever a path parameter can accept.
    With a `POST`, we need to accept the data that was posted to the endpoint. We’ll
    look at how to do this in section 14.1.2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个端点也没有要求我们处理提供的 JSON 体。当然，在 `GET /Flight/{FlightNumber}` 端点中，我们有一个路径参数，但它将航班的数字数据限制为路径参数可以接受的任何内容。对于
    `POST`，我们需要接受发送到端点的数据。我们将在第 14.1.2 节中查看如何做到这一点。
- en: 'Before we do that, however, let’s create our (by now) standard skeleton class:
    `BookingController`. We know from section 13.3 that for the CLR to pick up our
    controller class as a viable routing end station, we need to have the `BookingController`
    derive from the `Controller` class and add the `[Route]` class attribute as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，让我们创建我们的（到目前为止）标准骨架类：`BookingController`。根据第 13.3 节，为了 CLR 能够将我们的控制器类作为可行的路由端点识别，我们需要让
    `BookingController` 继承自 `Controller` 类，并添加以下 `[Route]` 类属性：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 14.1.1 Introduction to data deserialization
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 数据反序列化简介
- en: Let’s unravel the details around the `POST /Booking/{flightNumber}` endpoint
    and look at the data we can expect to be passed into our service (figure 14.3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析 `POST /Booking/{flightNumber}` 端点，并查看我们可以期望传递给我们的服务的数据（图 14.3）。
- en: '![](../Images/14_03.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片 14_03](../Images/14_03.png)'
- en: Figure 14.3 The `POST` `/Booking/{flightNumber}` endpoint accepts an HTTP body
    containing the first and last name of the customer that wants to book the given
    flight. It returns a 201 or 500\. This is a screenshot from a generated OpenAPI
    specification.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 `POST` `/Booking/{flightNumber}` 端点接受包含想要预订给定航班的客户姓名的 HTTP 体。它返回 201
    或 500。这是从生成的 OpenAPI 规范中截取的屏幕截图。
- en: 'The `POST /Booking/{flightNumber}` combines two ways of providing data to the
    controller: a path parameter (`flightNumber`) and a JSON body containing two strings:
    first and last names. We can model this data in JSON as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST /Booking/{flightNumber}` 结合了两种向控制器提供数据的方式：路径参数（`flightNumber`）和包含两个字符串（姓名和姓氏）的
    JSON 体。我们可以在 JSON 中如下建模此数据：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course, nothing stops users from filling out the fields incorrectly and
    providing full names in both fields as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，用户无法填写字段并错误地提供如这里所示的两个字段中的全名：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have no way of checking the correctness of the data before it is sent to
    us, so let’s assume a (very, very naïve) validation rule: both `firstName` and
    `lastName` need to be populated.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在收到数据之前无法检查其正确性，所以让我们假设一个（非常，非常天真的）验证规则：`firstName` 和 `lastName` 都需要填写。
- en: Now, you may ask, “Jort, that is really great. But how can we access such data
    inside our methods?” To that, I say, “Excellent question.” Unlike a path parameter,
    we cannot simply add `firstName` and `lastName` parameters to a method’s parameter
    list. We need to deserialize the incoming data to a data structure that we can
    understand. Deserialization, shown in figure 14.4, is the process of converting
    a stream of data (often in bytes or a JSON string) to a consumable data structure
    in memory or on disk. The reverse (converting an object to bytes or a JSON string
    so we can send it over HTTP or write it to a binary file) is called *serialization*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问，“Jort，这确实很棒。但我们如何在方法内部访问这样的数据？”对于这个问题，我说，“这是一个非常好的问题。”与路径参数不同，我们无法简单地将
    `firstName` 和 `lastName` 参数添加到方法参数列表中。我们需要将传入的数据反序列化为我们可以理解的数据结构。如图 14.4 所示的反序列化是将数据流（通常是字节或
    JSON 字符串）转换为内存或磁盘上的可消费数据结构的过程。其逆过程（将对象转换为字节或 JSON 字符串，以便我们可以通过 HTTP 发送或将其写入二进制文件）称为
    *序列化*。
- en: '![](../Images/14_04.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片 14_04](../Images/14_04.png)'
- en: Figure 14.4 Deserialization takes streams of data such as XML, JSON, and binary
    files and turns them into consumable data, often stored in data structures. This
    allows us to work with serialized data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 反序列化将 XML、JSON 和二进制文件等数据流转换为可消费数据，通常存储在数据结构中。这允许我们处理序列化数据。
- en: Because the HTTP request’s body comes through the wire serialized (as a JSON
    string in our case), and we need to access its body information, we have to deserialize
    the body into some sort of defined structure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 HTTP 请求的体通过线缆序列化（在我们的例子中是 JSON 字符串），我们需要访问其体信息，所以我们必须将体反序列化为某种定义的结构。
- en: 'To deserialize data, we use the following two concepts:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反序列化数据，我们使用以下两个概念：
- en: A data structure (usually a class) with an appropriate structure to deserialize
    the data
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有适当结构以反序列化数据的（通常是类）数据结构
- en: Model binding using the `[FromBody]` argument attribute (model binding is also
    referred to as data binding)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `[FromBody]` 参数属性（模型绑定也称为数据绑定）
- en: '![](../Images/14_05.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_05.png)'
- en: Figure 14.5 The `BookingData` class is added to the new JsonData folder in the
    ControllerLayer folder. Keeping the JsonData classes inside the ControllerLayer
    folder aids us in making sure our codebase is organized.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 `BookingData` 类被添加到 ControllerLayer 文件夹中的新 JsonData 文件夹。将 JsonData 类保持在
    ControllerLayer 文件夹内有助于我们确保代码库是有组织的。
- en: Let’s start by providing ASP.NET with a data structure into which to deserialize
    the provided body. The best way to do this (because it is the most organized)
    is to create a class or struct to hold our data. Even though we just want to store
    the data, we also want to do some validation on the provided data, so, we use
    a class. We store this new class in a new folder, ControllerLayer/JsonData, and
    name the file BookingData.cs, as shown in figure 14.5 and the next code snippet.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为 ASP.NET 提供一个数据结构来反序列化提供的主体。最有效的方法（因为它是最有序的）是创建一个类或结构来存储我们的数据。尽管我们只想存储数据，但我们还希望对提供的数据进行一些验证，因此，我们使用一个类。我们将这个新类存储在一个新的文件夹中，ControllerLayer/JsonData，并将文件命名为
    BookingData.cs，如图 14.5 和下一代码片段所示。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When all is said and done, the `BookingData` class should be populated with
    the data provided by the external system calling the endpoint. We also want to
    do some validation on the properties: if the provided string is null or empty,
    do not set the property to the provided string but throw an `InvalidOperationException`
    (alternatively, an `ArgumentNullException` would also be appropriate). We’ll also
    set a message on the exception, telling people what we couldn’t do: set either
    `FirstName` or `LastName`. Rather than duplicating that same validation twice
    (once for both properties’ setters), we can create a private method to do the
    validation and just call that. To add a body to the setter, we need to also provide
    one for the getter. This leads to the needed creation of a backing field as well,
    as shown in the next listing.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切完成后，`BookingData` 类应该被外部系统调用端点提供的数据填充。我们还想对属性进行一些验证：如果提供的字符串为空或为空，不要将属性设置为提供的字符串，而是抛出
    `InvalidOperationException`（或者，使用 `ArgumentNullException` 也会是合适的）。我们还会在异常上设置一个消息，告诉人们我们无法做什么：设置
    `FirstName` 或 `LastName`。为了避免在两个属性的设置器中重复相同的验证（一次为每个属性的设置器），我们可以创建一个私有方法来进行验证，并只需调用它。为了向设置器添加一个体，我们还需要为获取器提供一个。这导致需要创建一个后置字段，如下一列表所示。
- en: Listing 14.1 BookingData.cs
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.1 BookingData.cs
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Backing field for the FirstName property
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `FirstName` 属性的后置字段
- en: ❷ Returns the backing field’s value
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回后置字段的值
- en: ❸ Sets the value to the backing field
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将值设置为后置字段
- en: ❹ Validates the input value
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证输入值
- en: In listing 14.1, we pass in the name of the properties to help us construct
    the error message on the fly. To do this, we use the `nameof` expression, which
    gets us the name of a variable, type, or member as a string that is resolved at
    compile time. The listing should be easy to follow for you at this point, and
    you should be able to explain the differences between auto-properties and full
    properties with backing fields. If you have trouble with the differences, please
    revisit section 3.3.3.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 14.1 中，我们传递属性的名称来帮助我们动态构建错误消息。为此，我们使用 `nameof` 表达式，它在我们编译时获取变量、类型或成员的名称作为字符串。到这一点，列表应该很容易理解，您应该能够解释自动属性和具有后置字段的全属性之间的区别。如果您对区别有困难，请重新阅读第
    3.3.3 节。
- en: '| ![](../Images/LightBulb.png)   | Conditional curly braces The only odd part
    of listing 14.1 is the lack of curly braces after the `if(IsValidName(value))`
    conditionals. In C#, if you omit the curly braces after a conditional, the CLR
    assumes the next statement is the conditional’s body and executes it. Note that
    this is limited to one executed statement. If you have two or more statements
    that make up a conditional’s body, you need to use curly braces. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 条件大括号 列表 14.1 中唯一奇怪的部分是 `if(IsValidName(value))`
    条件之后缺少大括号。在 C# 中，如果您在条件之后省略大括号，CLR 假设下一个语句是条件的主体并执行它。请注意，这仅限于一个执行的语句。如果您有一个或多个语句组成条件的主体，您需要使用大括号。'
- en: 'The last thing we have to do for the `BookingData` class is provide some unit
    tests that validate our assumptions around the functionality we just implemented.
    These unit tests are pretty straightforward, and you should be able to write them
    yourself. If you get stuck, the following are implementations you can use (we
    add the test file to the new FlyingDutchmanAirlines_Test/ControllerLayer/JsonData
    folder):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BookingData`类，我们最后要做的就是提供一些单元测试来验证我们对刚刚实现的功能的假设。这些单元测试非常直接，你应该能够自己编写它们。如果你遇到困难，以下是一些你可以使用的实现（我们将测试文件添加到新的FlyingDutchmanAirlines_Test/ControllerLayer/JsonData文件夹中）：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How do we populate the `BookingData` class after we receive an HTTP `POST` request?
    That is where the `[FromBody]` attribute comes in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到HTTP `POST`请求后，我们如何填充`BookingData`类？这就是`[FromBody]`属性发挥作用的地方。
- en: 14.1.2 Using the [FromBody] attribute to deserialize incoming HTTP data
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 使用[FromBody]属性反序列化传入的HTTP数据
- en: 'In section 14.1.1, we created a data structure in which to store deserialized
    information. Within the context of an HTTP `POST` request, we can usually expect
    valid information to adhere to our provided OpenAPI specification. In this case,
    for the `POST` request to be valid, the JSON data needs to be deserialized to
    the `BookingData` class’s properties: `firstName` and `lastName`. If we end up
    with an incomplete request (the `BookingClass`’s properties have null pointers),
    we return an HTTP status code of 500\. You could also return an HTTP status code
    of 400 (Bad Request) in this scenario, and that may often be the correct code
    to return, but let’s stick with the provided OpenAPI specification (shown in figure
    14.3).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在14.1.1节中，我们创建了一个数据结构来存储反序列化的信息。在HTTP `POST`请求的上下文中，我们通常可以期望有效信息遵循我们提供的OpenAPI规范。在这种情况下，为了使`POST`请求有效，JSON数据需要反序列化到`BookingData`类的属性：`firstName`和`lastName`。如果我们最终得到一个不完整的请求（`BookingClass`的属性有null指针），我们返回HTTP状态码500。在这种情况下，你也可以返回HTTP状态码400（Bad
    Request），这可能是正确的代码，但让我们坚持使用提供的OpenAPI规范（如图14.3所示）。
- en: 'But first things first: how do we get the data deserialized to the `BookingData`
    class? We can’t just add a `BookingData` type to the parameter list and expect
    it to automatically work. It may sound crazy, but that is actually pretty close
    to reality! ASP.NET’s `[FromBody]` attribute can be applied to a parameter to
    tell ASP.NET we want to perform model binding to this type. When the CLR routes
    a payload to an endpoint with such a parameter, it takes the payload’s `Body`
    element and attempts to deserialize it to the given data type.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，最重要的是：我们如何将数据反序列化到`BookingData`类中？我们不可能仅仅将`BookingData`类型添加到参数列表中并期望它自动工作。这听起来可能有些疯狂，但实际上这非常接近现实！ASP.NET的`[FromBody]`属性可以应用于一个参数，以告诉ASP.NET我们想要对这个类型执行模型绑定。当CLR将有效载荷路由到具有此类参数的端点时，它会获取有效载荷的`Body`元素并尝试将其反序列化到给定的数据类型。
- en: 'To request this model binding, simply add “*FromBody* *type* *argumentName*”
    to the parameter list of a method (in our case, let’s create a new method in the
    `BookingController` class called `CreateBooking` along with an HTTP attribute
    of `[HttpPost]`) as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求这种模型绑定，只需将“*FromBody* *type* *argumentName*”添加到方法参数列表中（在我们的例子中，让我们在`BookingController`类中创建一个新的方法，称为`CreateBooking`，并带有HTTP属性`[HttpPost]`），如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By adding the `[FromBody]` attribute to a type of `BookingData` accessible through
    the `body` variable, we can now use the data from the HTTP request, as shown in
    figure 14.6.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`[FromBody]`属性添加到可以通过`body`变量访问的`BookingData`类型，我们现在可以使用HTTP请求中的数据，如图14.6所示。
- en: '![](../Images/14_06.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14_06.png)'
- en: Figure 14.6 Using the `[``FromBody]` attribute. When using the `[FromBody]`
    attribute, you can deserialize HTTP JSON data to a specific data structure and
    access it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 使用`[FromBody]`属性。当使用`[FromBody]`属性时，你可以将HTTP JSON数据反序列化到特定的数据结构并访问它。
- en: 'It is that simple. Now, some people are not a fan of “magic” in their codebases,
    and that’s fine. Know that by default, ASP.NET is set up to serialize JSON data.
    If you want to use XML, you have to add the following lines to a global.asax.cs
    file (this file, when present, contains global configuration details for your
    service):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如此简单。现在，有些人可能不喜欢在他们的代码库中使用“魔法”，这是完全可以理解的。要知道，默认情况下，ASP.NET被设置为序列化JSON数据。如果你想使用XML，你必须将以下行添加到global.asax.cs文件中（当存在此文件时，它包含你的服务的全局配置详细信息）：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s quickly look at an alternative way of parsing HTTP data to data structures
    before we continue (and keep using `[FromBody]`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们快速看一下在继续使用`[FromBody]`之前解析HTTP数据到数据结构的另一种方法。
- en: 14.1.3 Using a custom model binder and method attribute for model binding
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 使用自定义模型绑定器和方法属性进行模型绑定
- en: Instead of using the `[FromBody]` attribute to automatically bind HTTP data
    to a data structure, we can also lift the veil of ASP.NET’s magic and implement
    our own model binder. People often object to using the `[FromBody]` attribute
    because it seems to be magically doing things under the hood with no explanation.
    This section aims to explain that magic.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不使用`[FromBody]`属性自动将HTTP数据绑定到数据结构，也可以揭开ASP.NET魔法的面纱并实现我们自己的模型绑定器。人们经常反对使用`[FromBody]`属性，因为它似乎在幕后神秘地执行操作而没有解释。本节旨在解释这种魔法。
- en: As a custom model binder, our `BookingModelBinder` contains information on how
    we want to bind the given data to our class. Using a custom model binder is somewhat
    cumbersome but can provide greater control to your data-binding process. To start,
    let’s add a new class to serve as our model binder, as shown in the next listing.
    This class, `BookingModelBinder`, needs to implement the `IModelBinder` interface.
    The `IModelBinder` interface is what lets us use the `BookingModelBinder` to bind
    the data to the model, which we will do in a bit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为自定义模型绑定器，我们的`BookingModelBinder`包含了如何将给定数据绑定到我们类中的信息。使用自定义模型绑定器有些繁琐，但可以为我们提供对数据绑定过程更大的控制。首先，让我们添加一个新的类作为我们的模型绑定器，如下所示。这个类，`BookingModelBinder`，需要实现`IModelBinder`接口。`IModelBinder`接口允许我们使用`BookingModelBinder`将数据绑定到模型，我们将在稍后进行操作。
- en: Listing 14.2 The beginnings of a custom model binder
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.2 自定义模型绑定器的开始
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ To provide custom model binding, we need to implement the IModelBinder interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要提供自定义模型绑定，我们需要实现IModelBinder接口。
- en: ❷ The IModelBinder interface requires us to implement BindModelAsync.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ IModelBinder接口要求我们实现BindModelAsync。
- en: 'Our `BookingModelBinder` class’s implementation has the following four major
    parts, as shown in figure 14.7:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`BookingModelBinder`类的实现包含以下四个主要部分，如图14.7所示：
- en: Validate the `bindingContext` input argument.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`bindingContext`输入参数。
- en: Read the HTTP body into a parsable format.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTTP正文读取到可解析的格式。
- en: Bind the HTTP body data to the `BookingData` class’s properties.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTTP正文数据绑定到`BookingData`类的属性。
- en: Return the bound model.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回绑定后的模型。
- en: '![](../Images/14_07.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14_07.png)'
- en: Figure 14.7 When using a custom model binder to deserialize data, we need to
    validate, parse, and bind our data before returning the data in a bound model.
    This workflow gives us fine-grained control over the deserializing process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 当使用自定义模型绑定器反序列化数据时，我们需要在返回绑定模型的数据之前进行验证、解析和绑定。这个工作流程让我们对反序列化过程有更细粒度的控制。
- en: 'The first step is also the easiest: we just want to make sure that the `bindingContext`
    argument isn’t tied to a null value as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步也是最简单的：我们只想确保`bindingContext`参数没有与null值相关联，如下所示：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For step 2 (read the HTTP body into a parsable format), we need to access and
    then handle the HTTP body information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于步骤2（将HTTP正文读取到可解析的格式），我们需要访问并处理HTTP正文信息。
- en: Luckily, we can access everything we need about the incoming HTTP request through
    the provided `ModelBindingContext` instance. The classes we are looking for are
    `HttpContext` and `HttpRequest`. They contain properties tied to all expected
    elements (body, headers, and the like). The `Request` class provides us with an
    instance of `PipeReader`, which has access to the serialized body element. The
    `PipeReader` class is part of the `System.IO.Pipelines` namespace. `System.IO.Pipelines`
    contains classes (most importantly, `Pipe`, `PipeWriter`, and `PipeReader`) that
    help with high-performance input/output (IO) operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过提供的`ModelBindingContext`实例访问关于传入HTTP请求的所有需要的信息。我们正在寻找的类是`HttpContext`和`HttpRequest`。它们包含与所有预期元素（正文、头信息等）相关的属性。`Request`类为我们提供了一个`PipeReader`实例，它有权访问序列化的正文元素。`PipeReader`类是`System.IO.Pipelines`命名空间的一部分。`System.IO.Pipelines`包含帮助进行高性能输入/输出（IO）操作的类（最重要的是`Pipe`、`PipeWriter`和`PipeReader`）。
- en: 'To retrieve and use the `PipeReader` so we can get one step closer to the body
    data, we use the `Request.BodyReader` property and call its `ReadAsync` method
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索和使用`PipeReader`以便我们更接近正文数据，我们使用`Request.BodyReader`属性并调用其`ReadAsync`方法，如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ReadAsync` method returns an instance of `Task<ReadResult>`. This object
    contains three properties: `IsCompleted`, `IsCanceled`, and `Buffer`. The first
    two are used for checking whether the reading of the provided data was completed
    or canceled. The third is where our data lives. Because we are dealing with serialized
    data and an asynchronous process, the data is stored in a buffer of type `ReadOnlySequence<byte>`.
    It is this buffer that contains the actual bytes representing the body data. Typically,
    the buffer contains only one “segment” of data, so we can retrieve the first `Span`
    (a `Span` represents a contiguous chunk of data). Then, we need to deserialize
    that data back into a readable JSON string. We do that by using the `Encoding.UTF8`
    class as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadAsync` 方法返回一个 `Task<ReadResult>` 实例。该对象包含三个属性：`IsCompleted`、`IsCanceled`
    和 `Buffer`。前两个用于检查提供的数据读取是否完成或取消。第三个是我们数据所在的地方。因为我们处理的是序列化数据和异步过程，所以数据存储在类型为 `ReadOnlySequence<byte>`
    的缓冲区中。正是这个缓冲区包含了表示正文数据的实际字节。通常，缓冲区只包含一个“数据段”，因此我们可以检索第一个 `Span`（`Span` 表示连续的数据块）。然后，我们需要将那些数据反序列化回可读的
    JSON 字符串。我们通过使用 `Encoding.UTF8` 类来完成这项操作，如下所示：'
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have the JSON string, we can deserialize the JSON string into our
    model (step 3: bind the HTTP body data to the `BookingData` class’s properties).
    C# has some solid JSON functionality through the `System.Text.Json` namespace,
    which was introduced (and comes installed by default) in .NET 5\. To deserialize
    a JSON string into a `BookingData` struct, we just have to call `JsonSerializer.Deserialize<T>`
    and give it the type we want to reserialize into as the generic type parameter
    (`BookingData`) and the JSON string we want to deserialize (`body`), as shown
    here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 JSON 字符串，我们可以将 JSON 字符串反序列化到我们的模型中（步骤 3：将 HTTP 正文数据绑定到 `BookingData`
    类的属性）。C# 通过 `System.Text.Json` 命名空间提供了一些可靠的 JSON 功能，该命名空间在 .NET 5 中引入（并且默认安装）。要将
    JSON 字符串反序列化为 `BookingData` 结构体，我们只需调用 `JsonSerializer.Deserialize<T>` 并将其类型作为泛型类型参数（`BookingData`）以及要反序列化的
    JSON 字符串（`body`）传递，如下所示：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This deserializes the values coming out of the `body` to the appropriate types
    for their respective properties on the `BookingData` struct.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `body` 中出来的值反序列化为 `BookingData` 结构体相应属性的适当类型。
- en: 'The last step (step 4) is to return the bound model. You may have noticed that
    the return type of the `BindModelAsync` method is `Task`. We cannot change the
    return type to be `Task<BookingData>` because we are bound to implement the `IModelBinder`
    interface. But, we have another way to get the new `BookingModel` instance to
    the endpoint method: by using the `ModelBindingContext` class’s `Result` property,
    as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步（步骤 4）是返回绑定后的模型。你可能已经注意到 `BindModelAsync` 方法的返回类型是 `Task`。我们不能将返回类型更改为 `Task<BookingData>`，因为我们必须实现
    `IModelBinder` 接口。但是，我们还有另一种方法将新的 `BookingModel` 实例传递到端点方法：通过使用 `ModelBindingContext`
    类的 `Result` 属性，如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we add that to the end of our method, we can rest assured that our instance
    of `BookingData` is passed to the controller—another piece of magic. As you continue
    your C# journey, you will encounter many such pieces of magic. But, if you drill
    down far enough, you can usually figure out what is going on underneath the covers.
    In the words of Harry Potter’s Vernon Dursley, “There’s no such thing as magic!”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此添加到方法末尾，我们可以确信我们的 `BookingData` 实例被传递到控制器——这是另一件魔法般的事情。随着你继续你的 C# 之旅，你将遇到许多这样的魔法。但是，如果你深入挖掘，你通常可以弄清楚底层发生了什么。正如哈利·波特的弗农·德思礼所说：“根本就没有魔法！”
- en: 'That wraps up the `BookingModelBinder` class, but what about the endpoint method?
    Because we can’t use the `[FromBody]` attribute, what do we do instead? It is
    actually fairly similar. We add a `[ModelBinder(typeof([custom binder]))]` attribute
    to the parameter as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `BookingModelBinder` 类，但端点方法怎么办？因为我们不能使用 `[FromBody]` 属性，我们该怎么办？实际上，这非常相似。我们向参数添加一个
    `[ModelBinder(typeof([custom binder]))]` 属性，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although definitely more involved than simply slapping on the `[FromBody]` attribute,
    we can understand this argument attribute through our knowledge of `[FromBody]`.
    See the next listing for the complete code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这肯定比简单地添加 `[FromBody]` 属性要复杂得多，但我们可以通过我们对 `[FromBody]` 的了解来理解这个参数属性。请参见下一列表以获取完整的代码。
- en: Listing 14.3 Completed `BookingModelBinder` custom model binder class
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.3 完成的 `BookingModelBinder` 自定义模型绑定器类
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code you saw in this section is not required (and in fact not used) going
    forward. It is merely an excellent tool for you to know but overkill for our use
    case.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中看到的代码在后续操作中不是必需的（实际上也没有使用）。它仅仅是一个很好的工具，让你知道，但对于我们的用例来说有点过度。
- en: 14.1.4 Implementing the CreateBooking endpoint method logic
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 实现创建预订端点方法的逻辑
- en: 'With the model binding out of the way (and we go back to using the `[FromBody]`
    attribute), we can now focus on the meat of the `CreateBooking` method: the logic
    that calls the necessary service methods to create a booking in the database.
    Let’s recap what the general steps are to create a booking, as shown in figure
    14.8:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完模型绑定（并回到使用 `[FromBody]` 属性）之后，我们现在可以专注于 `CreateBooking` 方法的核心：调用必要的服务方法在数据库中创建预订的逻辑。让我们回顾一下创建预订的一般步骤，如图
    14.8 所示：
- en: Validate our data binding.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们的数据绑定。
- en: Make sure we have the provided customer in the database. If we do not, add the
    customer to the database.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保数据库中存在提供的客户。如果没有，将客户添加到数据库中。
- en: Make sure the flight the customer wants to book exists.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保客户想要预订的航班存在。
- en: Request a new entry in the `Booking` table containing the new booking.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Booking` 表中请求一个新的条目，包含新的预订。
- en: '![](../Images/14_08.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8](../Images/14_08.png)'
- en: Figure 14.8 Creating a new booking in the database involves validating our model
    binding, retrieving (and adding if appropriate) a customer, retrieving the flight,
    and then creating the booking in the database. With this workflow, we always have
    all the information we need in the database.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 在数据库中创建新的预订涉及验证我们的模型绑定，检索（如果需要则添加）客户，检索航班，然后在数据库中创建预订。使用此工作流程，我们始终在数据库中拥有所需的所有信息。
- en: 'Because we implemented the service and repository layer methods already, all
    these items should be very easy to implement. Let’s start with the only somewhat
    tricky one: validating our data binding. To make sure our instance of `BookingData`
    is in a valid state, we need to define what that means. The instance is considered
    valid if both the `FirstName` and the `LastName` properties are set to a valid,
    nonempty string. If this is not the case, we don’t want to do any processing.
    We already have logic in the `BookingData` class that makes sure we assign only
    valid names to the properties. If the passed-in name is not valid, the property
    remains unset. We do not want to use the instance in this case.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经实现了服务层和仓储层的方法，所有这些项目都应该很容易实现。让我们从唯一稍微有点棘手的一个开始：验证我们的数据绑定。为了确保我们的 `BookingData`
    实例处于有效状态，我们需要定义这意味着什么。如果 `FirstName` 和 `LastName` 属性都设置为有效的非空字符串，则实例被认为是有效的。如果不是这种情况，我们不想进行任何处理。`BookingData`
    类中已经存在逻辑，确保我们只将有效的名称分配给属性。如果传入的名称无效，则属性保持未设置。在这种情况下，我们不想使用该实例。
- en: 'ASP.NET gives us access to the `IValidatableObject` interface. This interface
    allows us to define validation rules for the CLR to run through at the creation
    of the instance. If the validation rules are found to be broken, ASP.NET sets
    to `false` a Boolean property on the `ControllerBase` class: `ModelState.IsValid`.
    We can check that property in our controller to make sure the object we are using
    is valid. To implement the `IValidatableObject` interface, we need to do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 给我们提供了访问 `IValidatableObject` 接口的权限。此接口允许我们为 CLR 在实例创建时运行定义验证规则。如果发现验证规则被破坏，ASP.NET
    将 `ControllerBase` 类上的布尔属性 `ModelState.IsValid` 设置为 `false`。我们可以在我们的控制器中检查该属性，以确保我们使用的对象是有效的。要实现
    `IValidatableObject` 接口，我们需要执行以下操作：
- en: Add the `IValidatableObject` interface to the `BookingData` class.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `IValidatableObject` 接口添加到 `BookingData` 类中。
- en: Implement the required `Validate` method to validate the property values and
    handle any errors.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现所需的 `Validate` 方法以验证属性值并处理任何错误。
- en: 'That doesn’t sound too bad. Adding the interface to the class is easy, as shown
    next:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来并不太糟糕。将接口添加到类中很容易，如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because the `BookingData` class now says it implements the `IValidatableObject`
    interface, we should actually do so. The interface tells us we *need* to implement
    a method called `Validate`, so let’s hop right on that as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `BookingData` 类现在声明它实现了 `IValidatableObject` 接口，我们应该实际上这样做。该接口告诉我们我们需要实现一个名为
    `Validate` 的方法，所以让我们直接按照以下方式实现它：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that when we implement an interface, we have to implement any methods
    on that interface in our implementation class. We cannot change the method’s signature
    because that would break our promise to the compiler and the interface to implement
    all methods on the interface. So, what do we do with the `Validate` method? The
    CLR calls the `Validate` method when the object is instantiated, and determines
    (based on the provided validation rules) how to set the `ModelState.IsValid` property.
    The return type (`IEnumerable<ValidationResult>`) allows us to return a data structure
    (implementing the `IEnumerable` interface, containing instances of `ValidationResult`)
    with no, one, or multiple errors. We can access these errors in the controller
    and return them to the customer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们实现一个接口时，我们必须在我们的实现类中实现该接口上的任何方法。我们不能更改方法的签名，因为这会打破我们对编译器和接口的承诺，即实现接口上的所有方法。那么，我们该如何处理
    `Validate` 方法？CLR 在对象实例化时调用 `Validate` 方法，并根据提供的验证规则确定如何设置 `ModelState.IsValid`
    属性。返回类型 (`IEnumerable<ValidationResult>`) 允许我们返回一个数据结构（实现 `IEnumerable` 接口，包含
    `ValidationResult` 实例），其中可能没有、一个或多个错误。我们可以在控制器中访问这些错误并将它们返回给客户。
- en: What does this look like? Well, we need to instantiate a new type of `IEnumerable
    <ValidationResult>`, verify that our properties are set to an appropriate value
    (we already check whether the names they are set to are valid through the property’s
    setters at model-binding time, but they can still be null values), add errors
    to the return data structure if a problem arises, and return the list of errors,
    as shown in the next listing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像什么？嗯，我们需要实例化一个新的 `IEnumerable<ValidationResult>` 类型，验证我们的属性是否设置到了合适的值（我们在模型绑定时已经通过属性的设置器检查了它们设置的名称是否有效，但它们仍然可能是空值），如果出现问题，向返回的数据结构中添加错误，并返回错误列表，如下一列表所示。
- en: Listing 14.4 `BookingData`’s `Validate` method
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.4 `BookingData` 的 `Validate` 方法
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Creates an empty list of errors
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空的错误列表
- en: ❷ Checks if both FirstName and LastName are null values
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查 `FirstName` 和 `LastName` 是否都是空值
- en: ❸ If both properties are null values, adds an error to the list
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果两个属性都是空值，则向列表中添加一个错误
- en: ❹ If they are not both null values, perhaps only one of them is.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果它们不是两个都是空值，可能只有一个。
- en: ❺ If only one of the properties is a null value, adds an error to the list
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果只有一个属性是空值，则向列表中添加一个错误
- en: ❻ Returns the list containing errors (if any)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回包含错误列表（如果有）
- en: 'How do we actually use these errors? Back in the controller method, we should
    add a check to see if the `ModelState.IsValid` property is set to `true`. If it
    is, we can continue with our work. But if it is not, we should return an HTTP
    status code of 500, along with the found error, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实际使用这些错误？回到控制器方法中，我们应该添加一个检查来查看 `ModelState.IsValid` 属性是否设置为 `true`。如果是，我们可以继续我们的工作。但如果不是，我们应该返回一个
    HTTP 状态码 500，以及找到的错误，如下所示：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we were to query the `CreateBooking` endpoint with an invalid JSON payload,
    we would get an HTTP code of 500 along with the found validation error. We now
    have code that binds the provided JSON data to a model and that validates the
    resulting model. All we have to do now is to ask the `BookingService` to create
    a booking for us and pass on the appropriate information. To do this, we first
    need to add a backing field and an injected instance of type `BookingService`
    and set up the middleware to provide us with this instance at runtime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用无效的 JSON 有效负载查询 `CreateBooking` 端点，我们会得到一个 HTTP 状态码 500 以及找到的验证错误。我们现在有了将提供的
    JSON 数据绑定到模型并将结果模型进行验证的代码。我们现在要做的就是请求 `BookingService` 为我们创建一个预订，并传递适当的信息。为此，我们首先需要添加一个后置字段和一个
    `BookingService` 类型的注入实例，并设置中间件在运行时为我们提供这个实例。
- en: 'First up, let’s add the backing field and injected instance (through a constructor)
    in `BookingController` as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `BookingController` 中添加一个后置字段和注入实例（通过构造函数），如下所示：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let’s add the dependency injection middleware in `Startup`. The `BookingService`
    class requires injected dependencies of type `BookingRepository`, `FlightRepository`,
    and `CustomerRepository`. Luckily, we already have an injected (transient) dependency
    of type `FlightRepository`, so we just have to add (besides the `BookingService`)
    the `BookingRepository` and `CustomerRepository` transient instances to the `Startup
    .ConfigureServices` method, as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `Startup` 中添加依赖注入中间件。`BookingService` 类需要注入的类型为 `BookingRepository`、`FlightRepository`
    和 `CustomerRepository` 的依赖项。幸运的是，我们已经有了一个注入的（瞬时的）类型为 `FlightRepository` 的依赖项，所以我们只需要将（除了
    `BookingService` 之外）的 `BookingRepository` 和 `CustomerRepository` 瞬时实例添加到 `Startup.ConfigureServices`
    方法中，如下所示：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The last thing we need before we can request the creating of a new booking is
    the endpoint’s path parameter, shown in the next code sample. This parameter maps
    to the `{flightNumber}` section of the `POST /Booking/{flightNumber}` endpoint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以请求创建新预订之前，我们还需要端点的路径参数，如下一个代码示例所示。该参数映射到 `POST /Booking/{flightNumber}`
    端点的 `{flightNumber}` 部分。
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s also do some quick input validation on the `flightNumber` argument. We
    can use the `IsPositiveInteger` extension method to make sure the flight number
    is not a negative integer as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也在 `flightNumber` 参数上做一些快速输入验证。我们可以使用 `IsPositiveInteger` 扩展方法来确保航班号不是负整数，如下所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With that, we can almost call the `BookingService.CreateBooking` method and
    create a booking in the database. We just have to concatenate the `FirstName`
    and `LastName` strings (with a space in between), because `BookingService.CreateBooking`
    just takes a single parameter of type `string` representing the customer’s name.
    We should be able to use string interpolation for this. Following the concatenation,
    we can finally call the service’s `CreateBooking` method as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们几乎可以调用 `BookingService.CreateBooking` 方法并在数据库中创建一个预订。我们只需要连接 `FirstName`
    和 `LastName` 字符串（之间有一个空格），因为 `BookingService.CreateBooking` 只需要一个表示客户名称的 `string`
    类型的单个参数。我们应该能够使用字符串插值来完成这个任务。在连接之后，我们最终可以按照以下方式调用服务的 `CreateBooking` 方法：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `BookingService.CreateBooking` method returns a tuple containing a Boolean
    value representing whether the creation of the booking was successful and an exception
    value set to any exception that was thrown. Based on these return values, we can
    determine what we want to return to the user as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingService.CreateBooking` 方法返回一个包含一个表示预订创建是否成功的布尔值和一个设置为抛出的任何异常值的元组。基于这些返回值，我们可以确定我们想要返回给用户的内容如下：'
- en: If the Boolean is set to `true`, and the exception is null, return an HTTP status
    code of 201 (Created).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果布尔值设置为 `true`，并且异常为空，则返回 HTTP 状态码 201（已创建）。
- en: If the Boolean is set to `false`, and the exception is not null, return an HTTP
    status code of 500 or 404, depending on the exception type.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果布尔值设置为 `false`，并且异常不为空，则根据异常类型返回 HTTP 状态码 500 或 404。
- en: If the Boolean is set to `false`, and the exception is null, return an HTTP
    status code of 500.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果布尔值设置为 `false`，并且异常为空，则返回 HTTP 状态码 500。
- en: 'We can easily add these as a couple of conditionals as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加以下几个条件：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because the `BookingService` returns an exception of type `CouldNotAddBookingToDatabaseException`
    when the flight cannot be found, we can use that to pivot our return status code
    to a 404.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当找不到航班时，`BookingService` 返回 `CouldNotAddBookingToDatabaseException` 类型的异常，我们可以利用这一点将我们的返回状态码转换为
    404。
- en: 'And at this point, I have some really exciting news: we are all done with implementing
    our rewrite of the Flying Dutchman Airlines service! Pat yourself on the back
    and reflect on the (hopefully) many things you learned along the way. Although
    not a true production-ready reflection of the actual world, this process highlighted
    a lot of real-world scenarios and decisions. In the next section, we’ll verify
    our work by doing some acceptance testing.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我有一些非常激动人心的消息：我们已经完成了对飞荷兰人航空公司服务的重写实施！给自己鼓掌，并反思一下在过程中（希望）学到的许多东西。虽然这不是真正面向生产的实际世界的反映，但这个过程突显了许多现实世界的场景和决策。在下一节中，我们将通过进行一些验收测试来验证我们的工作。
- en: 14.2 Acceptance testing and Swagger middleware
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 验收测试和 Swagger 中间件
- en: 'There are many ways to verify that your code works as you expect. Throughout
    the book, we used unit tests as a way to measure functionality expectations. But
    what do you do when you are at the end of the line? You implemented all your code
    using TDD-light (we cheated somewhat in the book), and now you want to verify
    the entire system. You could do something like automated integration tests (tests
    that run entire workflows in a production codebase; they are often part of a CI/CD
    system and run nightly). You may also be in the very lucky position to have a
    QA engineer available to you. But I want to show you a simple way of verifying
    your code works: acceptance testing.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以验证您的代码按预期工作。在整个书中，我们使用单元测试作为衡量功能预期的手段。但您在走到尽头时该怎么办？您使用TDD-light（我们在书中有些作弊）实现了所有代码，现在您想验证整个系统。您可以做一些像自动化集成测试（在生产代码库中运行整个工作流程的测试；它们通常是CI/CD系统的一部分，并在夜间运行）。您也可能非常幸运，有一位QA工程师可供您使用。但我想向您展示一种简单的方法来验证您的代码是否有效：验收测试。
- en: 'When we talk about acceptance testing, all we are really saying is, “Match
    the requirements to our functionality.” The requirements we got from the user
    came in the form of an OpenAPI specification, but they can come in a lot of forms
    (user stories are another notable requirement format). So, in this section, we’ll
    do acceptance testing in the following two ways:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论验收测试时，我们真正说的是，“将需求与我们的功能相匹配。”我们从用户那里得到的需求是以OpenAPI规范的形式出现的，但它们可以以很多形式出现（用户故事是另一种值得注意的需求格式）。因此，在本节中，我们将以以下两种方式执行验收测试：
- en: We’ll take the OpenAPI specification provided by FlyTomorrow and manually test
    our endpoints (section 14.2.1).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用FlyTomorrow提供的OpenAPI规范手动测试我们的端点（第14.2.1节）。
- en: We’ll add an optional Swagger middleware to our service to generate an OpenAPI
    specification on the fly. We’ll compare this generated specification to the provided
    one. They should match (section 14.2.2).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在我们的服务中添加一个可选的Swagger中间件，以动态生成OpenAPI规范。我们将比较这个生成的规范与提供的规范。它们应该匹配（第14.2.2节）。
- en: Acceptance testing before you hand off your product to a client is incredibly
    important and useful. Wouldn’t you want to catch any bugs or incorrect functionality
    *before* the client does? Because we are testing against the production (deployed)
    database,[¹](#pgfId-1234198) we can test only happy path and nondatabase exception
    scenarios. We don’t want to force failures in a production environment. This is
    where us having unit-tested the failure paths comes in handy because we can still
    be safe in knowing they work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在将您的产品交付给客户之前进行验收测试非常重要且有用。您不想在客户之前捕捉到任何错误或不正确的功能吗？因为我们是在针对生产（已部署）数据库进行测试，[¹](#pgfId-1234198)，我们只能测试快乐路径和非数据库异常场景。我们不希望在生产环境中强制出现故障。这就是我们为什么需要对失败路径进行单元测试，因为我们可以确保它们仍然有效。
- en: 14.2.1 Manual acceptance testing with an OpenAPI specification
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 使用OpenAPI规范进行手动验收测试
- en: 'Before we start testing, let’s come up with a methodology and some testing
    steps that we can follow for all endpoints. We expect all functionality to work
    fine, especially because we did test the code after implementing it, but we can
    never be too sure! For our manual testing, I propose we use the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始测试之前，让我们制定一个方法论和一些测试步骤，我们可以遵循所有端点。我们期望所有功能都能正常工作，特别是因为我们已经在实现后测试了代码，但我们永远不能太过自信！对于我们的手动测试，我建议我们使用以下步骤：
- en: Identify the input requirements.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定输入需求。
- en: Determine the happy path and nondatabase exception cases.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定快乐路径和非数据库异常情况。
- en: Test!
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试！
- en: 'The endpoints we need to test follow:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试的端点如下：
- en: '`GET /flight`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /flight`'
- en: '`GET /flight/{flightNumber}`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /flight/{flightNumber}`'
- en: '`POST /booking/{flightNumber}`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /booking/{flightNumber}`'
- en: So, without further ado, let’s begin with the `GET /flight` endpoint, shown
    in figure 14.9\. If we look at the OpenAPI specification, we see that this endpoint
    can return HTTP statuses of 200 (along with the `flightView` data), 404, and 500.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无需多言，让我们从图14.9中所示的`GET /flight`端点开始。如果我们查看OpenAPI规范，我们会看到这个端点可以返回HTTP状态200（附带`flightView`数据）、404和500。
- en: '![](../Images/14_09.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_09.png)'
- en: Figure 14.9 OpenAPI specification of the `GET` `/flight` endpoint. This endpoint
    is used to get information on all flights in the database. This is a screenshot
    from a generated OpenAPI specification.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 `GET` `/flight`端点的OpenAPI规范。此端点用于获取数据库中所有航班的详细信息。这是从生成的OpenAPI规范中截取的屏幕截图。
- en: Because this is just a `GET` call, and there are no path parameters or other
    inputs that need validating, the only happy path (or non-database-related exception)
    case is the success case. If we query the `GET /flight` endpoint, we should get
    details on every flight in the database, as shown in figure 14.10.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这只是一个`GET`调用，没有路径参数或其他需要验证的输入，所以唯一的幸福路径（或非数据库相关异常）情况是成功情况。如果我们查询`GET /flight`端点，我们应该得到数据库中每架航班的详细信息，如图14.10所示。
- en: '![](../Images/14_10.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14_10.png)'
- en: Figure 14.10 The return data from a query to the `GET` `/flight` endpoint. All
    flights in the database are returned in JSON form. This allows users to quickly
    process the data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 `GET` `/flight`端点的查询返回数据。数据库中的所有航班都以JSON形式返回。这使用户能够快速处理数据。
- en: 'As you can see, the endpoint returned a lengthy list of information on flights
    in the database. That does it for the `GET /flight` endpoint. Let’s move on to
    the next (more interesting) endpoint: `GET /flight/{flightNumber}`, whose spec
    is shown in figure 14.11.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，端点返回了数据库中航班信息的详细列表。这就是`GET /flight`端点的情况。让我们继续到下一个（更有趣的）端点：`GET /flight/{flightNumber}`，其规范如图14.11所示。
- en: '![](../Images/14_11.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14_11.png)'
- en: Figure 14.11 OpenAPI specification of the `GET` `/flight/{flightNumber}` endpoint.
    This endpoint allows the user to get information on a specific flight when given
    a flight number. This is a screenshot from a generated OpenAPI specification.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 `GET` `/flight/{flightNumber}`端点的OpenAPI规范。当提供一个航班号时，此端点允许用户获取特定航班的详细信息。这是从生成的OpenAPI规范中截取的屏幕截图。
- en: We can see that the `GET /flight/{flightNumber}` uses a path parameter and can
    return a 200 (along with some data), a 400, or a 404\. We can test all these scenarios
    by requesting a valid flight, a flight with an invalid flight number, and a flight
    with a flight number that is valid but not in the database, as shown in table
    14.1.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`GET /flight/{flightNumber}`使用路径参数，可以返回200（附带一些数据）、400或404。我们可以通过请求一个有效的航班、一个无效的航班号和一个有效但不在数据库中的航班号来测试所有这些场景，如表14.1所示。
- en: Table 14.1 Return data for our manual tests of the `GET` `/flight/{flightNumber}`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 `GET` `/flight/{flightNumber}`的手动测试返回数据
- en: '| Flight numbers | Returned status | Returned data |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 飞行号 | 返回状态 | 返回数据 |'
- en: '| 19 | 201 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 201 |'
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| –1 | 400 | (Bad Request) N/A |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| –1 | 400 | (Bad Request) N/A |'
- en: '| 500 | 404 | (Flight Not Found) N/A |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 404 | (Flight Not Found) N/A |'
- en: 'In table 14.1, all returned data from the endpoint is presented. It looks like
    we have another passing endpoint on our hands. Now, for the final endpoint: `POST
    /booking/{flightNumber}`, whose spec is shown in figure 14.12.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在表14.1中，端点返回的所有数据都得到了展示。看起来我们手头又有一个通过端点。现在，对于最后一个端点：`POST /booking/{flightNumber}`，其规范如图14.12所示。
- en: '![](../Images/14_12.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/14_12.png)'
- en: Figure 14.12 The OpenAPI specification for the `POST` `/booking/{flightNumber}`
    endpoint. This endpoint allows users to book a flight, given a customer name and
    flight number. This is a screenshot from a generated OpenAPI specification.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 `POST /booking/{flightNumber}`端点的OpenAPI规范。此端点允许用户在提供客户姓名和航班号的情况下预订航班。这是从生成的OpenAPI规范中截取的屏幕截图。
- en: 'The `POST /booking/{flightNumber}` only has two potential return states (a
    201 and a 500), but that is somewhat deceptive. We can force an error from this
    endpoint in the following ways:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST /booking/{flightNumber}` 只有两个潜在的返回状态（201和500），但这有些误导。我们可以通过以下方式从这个端点强制引发错误：'
- en: Pass in a JSON body with empty strings for names.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交一个包含空字符串的JSON体作为姓名。
- en: Pass in a JSON body missing one or both of the required properties (`firstName`
    and `lastName`).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交一个缺少一个或两个所需属性（`firstName`和`lastName`）的JSON体。
- en: Use an invalid flight number.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无效的飞行号。
- en: Use a flight number for a flight that does not exist.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个不存在的航班的飞行号。
- en: 'Table 14.2 shows the inputs and outputs the `GET /flight/{flightNumber}` gives
    us. With the data in table 14.2, we can say that all our manual testing passes.
    We did not see any unexpected output and can safely move on to the last test:
    generating an OpenAPI file based on the service on the fly and comparing it against
    FlyTomorrow’s version.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.2显示了`GET /flight/{flightNumber}`提供的输入和输出。根据表14.2中的数据，我们可以说所有我们的手动测试都通过了。我们没有看到任何意外的输出，可以安全地继续到最后一个测试：根据服务动态生成OpenAPI文件，并将其与FlyTomorrow的版本进行比较。
- en: Table 14.2 All success and failure responses from the `POST /booking/{flightNumber}`
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.2 `POST /booking/{flightNumber}`的所有成功和失败响应
- en: '| Endpoint flight number | Body | Returned status | Returned data |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 端点飞行号 | 主体 | 返回状态 | 返回数据 |'
- en: '| `1` | `firstName : "Alan"``lastName: "Turing"` | 201 | (Created) N/A |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `firstName : "Alan"``lastName: "Turing"` | 201 | (Created) N/A |'
- en: '| `-1` | `firstName : "Alan"``lastName: "Turing"` | 400 | (Bad Request) N/A
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `-1` | `firstName : "Alan"``lastName: "Turing"` | 400 | (Bad Request) N/A
    |'
- en: '| `999` | `firstName : "Alan"``lastName: "Turing"` | 404 | (Not Found) N/A
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `999` | `firstName : "Alan"``lastName: "Turing"` | 404 | (Not Found) N/A
    |'
- en: '| `1` | `firstName : "Alan"``lastName: ""` | 500 | (Internal Server Error)
    “One of the given data points is null” |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `firstName : "Alan"``lastName: ""` | 500 | (Internal Server Error)
    “One of the given data points is null” |'
- en: '| `1` | `firstName : ""``lastName: "Turing"` | 500 | (Internal Server Error)
    “One of the given data points is null” |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `firstName : ""``lastName: "Turing"` | 500 | (Internal Server Error)
    “One of the given data points is null” |'
- en: '| `1` | `firstName : "Alan"` | 500 | (Internal Server Error) “One of the given
    data points is null” |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `firstName : "Alan"` | 500 | (Internal Server Error) “One of the given
    data points is null” |'
- en: '| `1` | `lastName: "Turing"` | 500 | (Internal Server Error) “One of the given
    data points is null” |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `lastName: "Turing"` | 500 | (Internal Server Error) “One of the given
    data points is null” |'
- en: '| `1` | `firstName : ""``lastName: ""` | 500 | “All given data points are null”
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `firstName : ""``lastName: ""` | 500 | “All given data points are null”
    |'
- en: '| `1` | N/A | 500 | “All given data points are null” |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `1` | N/A | 500 | “All given data points are null” |'
- en: 14.2.2 Generating an OpenAPI specification at runtime
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 在运行时生成OpenAPI规范
- en: In section 13.3, we discussed middleware and how to use it. We looked at routing
    and dependency injection. But what if I told you we can generate an OpenAPI specification
    through a Swagger middleware option (Swagger is the precursor to OpenAPI)? The
    CLR through ASP.NET creates this OpenAPI specification at runtime, so it always
    reflects the latest and greatest state of your endpoints. The goal of this section
    is to generate such a dynamic OpenAPI specification and compare it with the OpenAPI
    specification we got from FlyTomorrow.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13.3节中，我们讨论了中间件及其使用方法。我们探讨了路由和依赖注入。但如果我告诉你，我们可以通过Swagger中间件选项（Swagger是OpenAPI的前身）生成OpenAPI规范呢？通过ASP.NET创建的CLR在运行时创建此OpenAPI规范，因此它始终反映了端点的最新和最佳状态。本节的目标是生成这样的动态OpenAPI规范，并将其与从FlyTomorrow获得的OpenAPI规范进行比较。
- en: NOTE This section is optional and requires the installation of a third-party
    C# library. Generating an OpenAPI specification is not a functional requirement
    for most applications. If you skip this section, you can pick up reading again
    at the summary.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节是可选的，需要安装第三方C#库。生成OpenAPI规范不是大多数应用程序的功能性要求。如果你跳过本节，你可以在总结部分继续阅读。
- en: Because .NET 5 does not come with the functionality to add Swagger middleware,
    we have to install a third-party library called Swashbuckle. Go ahead and install
    the `Swashbuckle.AspNetCore` package through the NuGet package manager (see section
    5.2.1). Once we have installed the `Swashbuckle.AspNetCore` package, we can add
    the middleware configuration.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为.NET 5没有提供添加Swagger中间件的功能，所以我们不得不安装一个名为Swashbuckle的第三方库。请继续通过NuGet包管理器安装`Swashbuckle.AspNetCore`包（参见第5.2.1节）。一旦我们安装了`Swashbuckle.AspNetCore`包，我们就可以添加中间件配置。
- en: We add middleware to the Startup.cs file by changing both the `Configure` method
    and the `ConfigureServices` method. The setup is simple and works out of the box,
    as shown in the next listing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过更改`Startup.cs`文件中的`Configure`方法和`ConfigureServices`方法来向Startup.cs文件添加中间件。设置很简单，并且开箱即用，如以下列表所示。
- en: Listing 14.5 Startup with Swashbuckle middleware
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.5带有Swashbuckle中间件的Startup
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Generates a Swagger file at the default location
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在默认位置生成Swagger文件
- en: ❷ Exposes an interactive GUI, pointing to the generated Swagger file
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供一个交互式GUI，指向生成的Swagger文件
- en: ❸ Adds Swagger to middleware
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将Swagger添加到中间件
- en: 'By adding the Swagger setup to both the `ConfigureServices` and `Configure`
    methods, the CLR knows to scan the service at launch and request a Swagger file
    to be generated based on that information. To test this out, all we have to do
    is launch the service and navigate to the `SwaggerUI` endpoint: `[service]/swagger`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Swagger设置添加到`ConfigureServices`和`Configure`方法中，CLR知道在启动时扫描服务并请求基于该信息生成Swagger文件。为了测试这一点，我们只需要启动服务并导航到`SwaggerUI`端点：`[service]/swagger`。
- en: In figure 14.13, you see the resulting Swagger UI generated by the Swagger middleware.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在图14.13中，你可以看到由Swagger中间件生成的Swagger UI。
- en: '![](../Images/14_13.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_13.png)'
- en: Figure 14.13 The autogenerated OpenAPI specification of the Flying Dutchman
    Airlines service. We can use this to double-check our work against FlyTomorrow’s
    OpenAPI specification.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 展示了飞荷兰人航空公司服务的自动生成的OpenAPI规范。我们可以使用这个规范来对照FlyTomorrow的OpenAPI规范进行双重检查。
- en: On the surface, this looks pretty good, albeit a bit sparse. Let’s investigate
    further and see if we are missing any information. By expanding the `GET /{controller]/[flightNumber}`
    section, we can see in figure 14.14 that it generated only the return information
    for a status code 200.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看起来相当不错，尽管有点简略。让我们进一步调查，看看是否遗漏了任何信息。通过展开`GET /{controller}/[flightNumber]`部分，我们可以在图14.14中看到它只生成了状态码200的返回信息。
- en: '![](../Images/14_14.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_14.png)'
- en: Figure 14.14 The expanded `GET` `/Flight/{FlightNumber}` OpenAPI information
    generated at the launch of the service. This seems to be missing some return information
    that we added to the controller.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 展示了在服务启动时生成的扩展的 `GET` `/Flight/{FlightNumber}` OpenAPI信息。这似乎遗漏了一些我们添加到控制器中的返回信息。
- en: 'The thing is that we know for a fact that we added logic to the appropriate
    endpoint method to return more than just a 200\. What happened here? You often
    encounter this situation: for whatever reason, the CLR could not automatically
    determine all the return status codes. But, luckily, we can add a method attribute
    to the appropriate method that tells the CLR what return codes the method returns
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们知道我们确实在适当端点方法中添加了逻辑来返回不仅仅是200的状态码。这里发生了什么？你经常会遇到这种情况：由于某种原因，CLR无法自动确定所有返回状态码。但幸运的是，我们可以向适当的方法添加一个方法属性，告诉CLR该方法返回哪些返回码，如下所示：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we now compile and launch the service again, we see the Swagger UI has changed
    (as shown in figure 14.15).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次编译并启动服务，我们会看到Swagger UI已经改变（如图14.15所示）。
- en: '![](../Images/14_15.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_15.png)'
- en: Figure 14.15 The expanded `GET` `/Flight/{FlightNumber}` OpenAPI information
    was generated at the launch of the service with the correct return statuses. It
    is important to reflect your API truthfully in an OpenAPI specification so you
    do not lead people down the wrong road.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15 展示了在服务启动时生成的扩展的 `GET` `/Flight/{FlightNumber}` OpenAPI信息，其中包含了正确的返回状态。在OpenAPI规范中真实地反映你的API非常重要，这样你才不会引导人们走上错误的道路。
- en: That looks good. To make sure the other two endpoints (`GET /Flight` and `POST
    /Booking/{flightNumber}`) have the correct information, go ahead and add the appropriate
    method attributes to their respective endpoint methods. After that, we can compare
    our generated OpenAPI to the one provided by FlyTomorrow.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。为了确保其他两个端点（`GET /Flight` 和 `POST /Booking/{flightNumber}`）有正确的信息，请继续为它们各自的端点方法添加适当的方法属性。之后，我们可以将我们生成的OpenAPI与FlyTomorrow提供的OpenAPI进行比较。
- en: 'Comparing OpenAPI specifications: get /flight'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 比较OpenAPI规范：get /flight
- en: Perhaps the easiest endpoint to compare in terms of OpenAPI specifications is
    the `GET /flight` endpoint, shown in figure 14.16\. It does not take in a body
    (`GET` requests cannot contain a body), and it returns a 200 along with any data
    it finds, a 404 if no data was found, or a 500 in case of trouble.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenAPI规范方面，也许最容易比较的端点是`GET /flight`端点，如图14.16所示。它不接收正文（`GET`请求不能包含正文），并返回200状态码以及找到的任何数据，如果没有找到数据则返回404，如果出现问题时则返回500。
- en: Figure 14.16 shows us clearly that all return codes are accounted for in the
    autogenerated OpenAPI specification for the `GET /flight` endpoint.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16 清楚地显示，在自动生成的OpenAPI规范中，对于`GET /flight`端点，所有返回代码都已考虑在内。
- en: '![](../Images/14_16.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_16.png)'
- en: Figure 14.16 Comparing the FlyTomorrow and the autogenerated OpenAPI specification
    for `GET` `/Flight`. This is one way to verify our work against a customer specification.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16 比较了FlyTomorrow和自动生成的OpenAPI规范中的`GET` `/Flight`。这是验证我们的工作是否符合客户规范的一种方法。
- en: 'Comparing openapi specifications: get /flight/{flightNumber}'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 比较openapi规范：get /flight/{flightNumber}
- en: The second endpoint we look at is the `GET /Flight/{flightNumber}` endpoint.
    This endpoint is very similar to the `GET /flight` endpoint but introduces the
    concept of a path parameter. Let’s see in figure 14.17 how our generated OpenAPI
    specification stacks up against the FlyTomorrow specification.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的第二个端点是`GET /Flight/{flightNumber}`端点。这个端点与`GET /flight`端点非常相似，但引入了路径参数的概念。让我们在图14.17中看看我们的生成的OpenAPI规范与FlyTomorrow规范相比如何。
- en: '![](../Images/14_17.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_17.png)'
- en: Figure 14.17 Comparing the FlyTomorrow and the autogenerated OpenAPI specification
    for `GET` `/Flight/{flightNumber}`. By comparing the two specifications, we can
    be sure we did a good job.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17 比较FlyTomorrow和自动生成的OpenAPI规范中的`GET` `/Flight/{flightNumber}`。通过比较这两个规范，我们可以确信我们做得很好。
- en: Once again, the returned statuses look to be the same in both the FlyTomorrow
    and the autogenerated OpenAPI specification. Great, let’s move on to the final
    endpoint.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，返回的状态在FlyTomorrow和自动生成的OpenAPI规范中看起来是相同的。太好了，让我们继续到最后一个端点。
- en: 'Comparing openapi specifications: post /Booking/{flightNumber}'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 比较openapi规范：post /Booking/{flightNumber}
- en: The final endpoint we implemented was the `POST /Booking/{flightNumber}`. This
    endpoint combined a `POST` request plus a body with a path parameter. The endpoint
    method had to do JSON deserialization and serialization of data coming in and
    out of the service. Let’s have a look at how we did (figure 14.18).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的最后一个端点是`POST /Booking/{flightNumber}`。这个端点结合了一个带有路径参数的`POST`请求和一个正文。端点方法必须对进入和离开服务的数据进行JSON反序列化和序列化。让我们看看我们是如何做到的（图14.18）。
- en: '![](../Images/14_18.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14_18.png)'
- en: Figure 14.18 Comparing the FlyTomorrow and the autogenerated OpenAPI specification
    for `POST` `/Booking/{flightNumber}`. If we did not compare the two specifications,
    we may have missed the need for the 404 Not Found return and shipped incorrect
    code to the customer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18 比较FlyTomorrow和自动生成的OpenAPI规范中的`POST` `/Booking/{flightNumber}`。如果我们没有比较这两个规范，我们可能会错过404
    Not Found返回的需求，并向客户发送了错误的代码。
- en: 'The image in figure 14.18 is encouraging but not quite what we want to see
    at this stage. We can see that the 201 and 500 status codes map correctly, but
    it turns out we implemented a 404 return status. This return was not necessary
    per the FlyTomorrow OpenAPI specification. Now, there is something to be said
    for keeping this return status because there is a possibility that the developers
    at FlyTomorrow would like to have it. On the other hand, it is often best to stick
    to the customer requirements fairly tightly. In that vein, the last task in this
    book for you is to change the `BookingController` to not return the 404 (if you
    get stuck, see the source code). As a bonus challenge: Swagger has the functionality
    to specify descriptions along with return codes. Research and implement this.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18中的图像令人鼓舞，但在这个阶段我们看到的并不完全是我们想要的。我们可以看到201和500状态码映射正确，但结果是我们实现了404返回状态。根据FlyTomorrow
    OpenAPI规范，这种返回是不必要的。现在，保留这种返回状态有一些道理，因为FlyTomorrow的开发者可能希望拥有它。另一方面，通常最好严格遵循客户需求。在这个意义上，这本书中留给你的最后一个任务是修改`BookingController`以不返回404（如果你卡住了，请查看源代码）。作为额外挑战：Swagger具有指定与返回代码一起的描述的功能。研究和实现这一点。
- en: 14.3 The end of the road
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 路的尽头
- en: Congratulations! You did it. You reached the end of the book. I hope you thoroughly
    enjoyed the material and learned a new thing or two. If you want to continue your
    C# journey, I suggest you look at Jon Skeet’s *C# in Depth* (4th edition; Manning,
    2019), Dustin Metzgar’s *.NET Core in Action* (Manning, 2018), Andrew Lock’s *ASP.NET
    Core in Action* (2nd edition; Manning, 2021), and Jeffrey Richter’s *CLR via C#*
    (4th edition; Microsoft Press, 2012). Appendix E contains a list of various resources
    (books, websites, articles) recommended in this book.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你做到了。你到达了这本书的结尾。我希望你充分享受了这些材料，并学到了一些新东西。如果你想继续你的C#之旅，我建议你看看Jon Skeet的《C#深度》（第4版；Manning，2019年），Dustin
    Metzgar的《.NET Core实战》（Manning，2018年），Andrew Lock的《ASP.NET Core实战》（第2版；Manning，2021年），以及Jeffrey
    Richter的《CLR via C#》（第4版；Microsoft Press，2012年）。附录E包含了一本推荐的各种资源（书籍、网站、文章）的列表。
- en: Lastly, I want to leave you with a quote from the eminent Donald Knuth:[²](#pgfId-1234515)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想给你留下一个来自著名人物Donald Knuth的引言：[²](#pgfId-1234515)
- en: '*If you find that you’re spending almost all your time on theory, start turning
    some attention to practical things; it will improve your theories. If you find
    that you''re spending almost all your time on practice, start turning some attention
    to theoretical things; it will improve your practice*.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你发现自己几乎把所有时间都花在理论上，开始把一些注意力转向实际事物；这将改善你的理论。如果你发现自己几乎把所有时间都花在实践上，开始把一些注意力转向理论事物；这将改善你的实践*。'
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: JSON data coming in from an HTTP request is serialized. This means that the
    data is not in a format that we can directly use. We need to deserialize this
    data before we can operate on it.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自HTTP请求的JSON数据是序列化的。这意味着数据不是我们可以直接使用的格式。在我们能够操作它之前，我们需要反序列化这些数据。
- en: To deserialize JSON data, we can use either the `[FromBody]` argument attribute
    or implement a custom model binder. Deserializing data is what allows us to put
    incoming JSON or XML data in a usable data structure.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要反序列化 JSON 数据，我们可以使用 `[FromBody]` 参数属性或实现自定义模型绑定器。反序列化数据使我们能够将传入的 JSON 或 XML
    数据放入可用的数据结构中。
- en: You can use the `IModelBinder` interface to implement a custom model binder.
    This is useful when you want to have more control over how data is serialized
    into your models.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `IModelBinder` 接口来实现自定义模型绑定器。当您想要对数据序列化到模型中的方式有更多控制时，这很有用。
- en: By using the `ModelState.IsValid` check, we can verify that no errors were found
    during model binding. This is most useful when combined with a custom model binder,
    because you can precisely define when a model is not valid in that situation.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `ModelState.IsValid` 检查，我们可以验证在模型绑定过程中没有发现错误。当与自定义模型绑定器结合使用时，这最有用，因为您可以在那种情况下精确地定义何时模型无效。
- en: You can generate an OpenAPI specification of your service at launch by adding
    Swagger middleware to your configuration. This is helpful with acceptance testing
    and to make sure you are implementing the correct endpoints.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在启动时通过向配置中添加 Swagger 中间件来生成服务的 OpenAPI 规范。这有助于验收测试并确保您正在实现正确的端点。
- en: '* * *'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)You typically do not want to test against a production database. The reason
    we do so in this book is because it allows me to provide a publicly deployed database
    for you to use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）您通常不想对生产数据库进行测试。我们在本书中这样做的原因是，这允许我为您提供公开部署的数据库供您使用。
- en: ^(2.)Donald Knuth is an American computer scientist, famous for his books in
    *The Art of Computer Programming* series. He is the recipient of the 1974 ACM
    Turing Award (the computer world’s equivalent of the Academy Awards/Pulitzer Prize/Nobel
    Prize), was instrumental in the popularization of asymptotic notation, and is
    professor emeritus at Stanford University. His (excellent) personal website is
    [https://www-cs-faculty.stanford.edu/ ~knuth/](https://www-cs-faculty.stanford.edu/~knuth/).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^（2.）唐纳德·克努特是一位美国计算机科学家，以其《计算机程序设计艺术》系列书籍而闻名。他是 1974 年 ACM 图灵奖（计算机世界的奥斯卡奖/普利策奖/诺贝尔奖）的获得者，对推广渐近符号学起到了关键作用，并在斯坦福大学担任荣誉教授。他的（出色的）个人网站是
    [https://www-cs-faculty.stanford.edu/~knuth/](https://www-cs-faculty.stanford.edu/~knuth/)。
