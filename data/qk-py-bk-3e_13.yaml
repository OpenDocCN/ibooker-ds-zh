- en: Chapter 12\. Using the filesystem
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章\. 使用文件系统
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Managing paths and pathnames
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理路径和路径名
- en: Getting information about files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取文件信息
- en: Performing filesystem operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行文件系统操作
- en: Processing all files in a directory subtree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理目录子树中的所有文件
- en: 'Working with files involves one of two things: basic I/O (described in [chapter
    13](kindle_split_024.html#ch13), *“*Reading and writing files”) and working with
    the filesystem (for example, naming, creating, moving, or referring to files),
    which is a bit tricky, because different operating systems have different filesystem
    conventions.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件一起工作涉及以下两种情况之一：基本的I/O操作（在第13章中描述，*“*读取和写入文件”）和与文件系统一起工作（例如，命名、创建、移动或引用文件），这有点棘手，因为不同的操作系统有不同的文件系统约定。
- en: It would be easy enough to learn how to perform basic file I/O without learning
    all the features Python has provided to simplify cross-platform filesystem interaction—but
    I wouldn’t recommend it. Instead, read at least the first part of this chapter,
    which gives you the tools you need to refer to files in a manner that doesn’t
    depend on your particular operating system. Then, when you use the basic I/O operations,
    you can open the relevant files in this manner.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不学习Python提供的简化跨平台文件系统交互的所有功能，就可以轻松地学习如何执行基本的文件I/O操作——但我不会推荐这样做。相反，至少阅读本章的第一部分，它提供了你需要的工具，以便以不依赖于你特定操作系统的方式引用文件。然后，当你使用基本的I/O操作时，你可以以这种方式打开相关文件。
- en: 12.1\. os and os.path vs. pathlib
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. os和os.path与pathlib
- en: The traditional way that file paths and filesystem operations have been handled
    in Python is by using functions included in the `os` and `os.path` modules. These
    functions have worked well enough but often resulted in more verbose code than
    necessary. Since Python 3.5, a new library, `pathlib`, has been added; it offers
    a more object-oriented and more unified way of doing the same operations. Because
    a lot of code out there still uses the older style, I’ve retained those examples
    and their explanations. On the other hand, `pathlib` has a lot going for it and
    is likely to become the new standard, so after each example of the old method,
    I include an example (and brief explanation, where necessary) of how the same
    thing would be done with `pathlib`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，处理文件路径和文件系统操作的传统方式是使用`os`和`os.path`模块中包含的函数。这些函数已经足够好了，但通常会导致比必要的更冗长的代码。自Python
    3.5以来，新增了一个名为`pathlib`的新库；它提供了一种更面向对象和更统一的方式来执行相同的操作。由于许多代码仍然使用旧风格，我保留了那些示例及其解释。另一方面，`pathlib`有很多优点，并可能成为新的标准，因此在每个旧方法的示例之后，我都包括了一个示例（以及必要的简要解释），说明如何使用`pathlib`来完成相同的事情。
- en: 12.2\. Paths and pathnames
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 路径和路径名
- en: All operating systems refer to files and directories with strings naming a given
    file or directory. Strings used in this manner are usually called *pathnames*
    (or sometimes just *paths*), which is the word I’ll use for them. The fact that
    pathnames are strings introduces possible complications into working with them.
    Python does a good job of providing functions that help avert these complications;
    but to use these Python functions effectively, you need to understand the underlying
    problems. This section discusses these details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作系统都使用字符串来命名文件或目录，以引用文件或目录。以这种方式使用的字符串通常被称为*路径名*（有时也简称为*路径*），我将使用这个词来指代它们。路径名是字符串的事实，在处理它们时引入了可能的复杂性。Python提供了很好的函数来帮助避免这些复杂性；但为了有效地使用这些Python函数，你需要了解其背后的问题。本节将讨论这些细节。
- en: 'Pathname semantics across operating systems are very similar because the filesystem
    on almost all operating systems is modeled as a tree structure, with a disk being
    the root and folders, subfolders, and so on being branches, subbranches, and so
    on. This means that most operating systems refer to a specific file in fundamentally
    the same manner: with a pathname that specifies the path to follow from the root
    of the filesystem tree (the disk) to the file in question. (This characterization
    of the root corresponding to a hard disk is an oversimplification, but it’s close
    enough to the truth to serve for this chapter.) This pathname consists of a series
    of folders to descend into to get to the desired file.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 跨操作系统的路径名语义非常相似，因为几乎所有的操作系统都将文件系统建模为树结构，其中磁盘是根，文件夹、子文件夹等是分支、子分支等。这意味着大多数操作系统以基本相同的方式引用特定文件：使用路径名指定从文件系统树（磁盘）的根到要查询的文件的路径。（这种将根对应到硬盘的描述是一种过度简化，但它足够接近真相，可以用于本章。）这个路径名由一系列文件夹组成，需要进入这些文件夹才能到达所需的文件。
- en: 'Different operating systems have different conventions regarding the precise
    syntax of pathnames. The character used to separate sequential file or directory
    names in a Linux/UNIX pathname is /, whereas the character used to separate file
    or directory names in a Windows pathname is \. In addition, the UNIX filesystem
    has a single root (which is referred to by having a / character as the first character
    in a pathname), whereas the Windows filesystem has a separate root for each drive,
    labeled `A:\`, `B:\`, `C:\`, and so forth (with C: usually being the main drive).
    Because of these differences, files have different pathname representations on
    different operating systems. A file called `C:\data\myfile` in MS Windows might
    be called `/data/myfile` on UNIX and on the Mac OS. Python provides functions
    and constants that allow you to perform common pathname manipulations without
    worrying about such syntactic details. With a little care, you can write your
    Python programs in such a manner that they’ll run correctly no matter what the
    underlying filesystem happens to be.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不同操作系统对路径名的精确语法有不同的约定。在Linux/UNIX路径名中用于分隔连续文件或目录名的字符是/，而在Windows路径名中用于分隔文件或目录名的字符是\。此外，UNIX文件系统有一个单一的根（通过在路径名中以/字符作为第一个字符来引用），而Windows文件系统为每个驱动器都有一个单独的根，标记为`A:\`、`B:\`、`C:\`等等（其中C:通常是主驱动器）。由于这些差异，不同操作系统上的文件有不同的路径名表示。在MS
    Windows中名为`C:\data\myfile`的文件在UNIX和Mac OS上可能被称为`/data/myfile`。Python提供了函数和常量，允许您在不担心这些语法细节的情况下执行常见的路径名操作。只要稍加注意，您就可以以这种方式编写Python程序，无论底层文件系统是什么，它们都能正确运行。
- en: 12.2.1\. Absolute and relative paths
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1\. 绝对和相对路径
- en: 'These operating systems allow two types of pathnames:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作系统允许两种类型的路径名：
- en: '*Absolute* pathnames specify the exact location of a file in a filesystem without
    any ambiguity; they do this by listing the entire path to that file, starting
    from the root of the filesystem.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绝对*路径名指定了文件在文件系统中的确切位置，没有任何歧义；它们通过列出到达该文件的完整路径来实现，从文件系统的根开始。'
- en: '*Relative* pathnames specify the position of a file relative to some other
    point in the filesystem, and that other point isn’t specified in the relative
    pathname itself; instead, the absolute starting point for relative pathnames is
    provided by the context in which they’re used.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相对*路径名指定了文件相对于文件系统中的某个其他点的位置，而那个其他点在相对路径名中并没有指定；相反，相对路径名的绝对起始点是它们被使用的上下文提供的。'
- en: 'As examples, here are two Windows absolute pathnames:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是两个Windows的绝对路径名：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and here are two Linux absolute pathnames and a Mac absolute pathname:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下是两个Linux的绝对路径名和一个Mac的绝对路径名：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'and here are two Windows relative pathnames:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下是两个Windows的相对路径名：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'and these are Linux/UNIX/Mac relative pathnames:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以及这些是Linux/UNIX/Mac的相对路径名：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Relative paths need context to anchor them. This context is typically provided
    in one of two ways.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径需要上下文来定位。这种上下文通常以两种方式之一提供。
- en: 'The simpler way is to append the relative path to an existing absolute path,
    producing a new absolute path. You might have a relative Windows path, `Start
    Menu\Programs\Startup`, and an absolute path, `C:\Users\Administrator`. By appending
    the two, you have a new absolute path: `C:\Users\Administrator\Start Menu\Programs\Startup`,
    which refers to a specific location in the filesystem. By appending the same relative
    path to a different absolute path (say, `C:\Users\myuser`), you produce a path
    that refers to the Startup folder in a different user’s (myuser’s) Profiles directory.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的方法是将相对路径附加到现有的绝对路径上，从而生成一个新的绝对路径。你可能有一个相对的 Windows 路径，`Start Menu\Programs\Startup`，和一个绝对路径，`C:\Users\Administrator`。通过将这两个路径连接起来，你得到一个新的绝对路径：`C:\Users\Administrator\Start
    Menu\Programs\Startup`，它指向文件系统中的特定位置。通过将相同的相对路径附加到不同的绝对路径（例如，`C:\Users\myuser`），你得到一个指向不同用户（myuser）的配置文件目录中的启动文件夹的路径。
- en: The second way in which relative paths may obtain a context is via an implicit
    reference to the *current working directory*, which is the particular directory
    where a Python program considers itself to be at any point during its execution.
    Python commands may implicitly make use of the current working directory when
    they’re given a relative path as an argument. If you use the `os.listdir(path)`
    command with a relative path argument, for example, the anchor for that relative
    path is the current working directory, and the result of the command is a list
    of the filenames in the directory whose path is formed by appending the current
    working directory with the relative path argument.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径获取上下文的第二种方式是通过隐式引用 *当前工作目录*，这是 Python 程序在其执行过程中认为自身所在的特定目录。当 Python 命令以相对路径作为参数时，它们可能会隐式地使用当前工作目录。例如，如果你使用
    `os.listdir(path)` 命令并带有相对路径参数，那么该相对路径的锚点是当前工作目录，该命令的结果是目录中文件名的列表，其路径是通过将当前工作目录与相对路径参数连接而成的。
- en: 12.2.2\. The current working directory
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2\. 当前工作目录
- en: Whenever you edit a document on a computer, you have a concept of where you
    are in that computer’s file structure because you’re in the same directory (folder)
    as the file you’re working on. Similarly, whenever Python is running, it has a
    concept of where in the directory structure it is at any moment. This fact is
    important because the program may ask for a list of files stored in the current
    directory. The directory that a Python program is in is called the *current working
    directory* for that program. This directory may be different from the directory
    the program resides in.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在一台计算机上编辑文档时，你都有一个关于你在该计算机文件结构中的位置的概念，因为你处于你正在工作的文件的同一目录（文件夹）中。同样，每当 Python
    运行时，它都有一个关于在任何时刻它在目录结构中的位置的概念。这个事实很重要，因为程序可能会要求列出当前目录中存储的文件列表。Python 程序所在的目录被称为该程序的
    *当前工作目录*。这个目录可能与程序所在的目录不同。
- en: 'To see this in action, start Python and use the `os.getcwd` (get current working
    directory) command to find Python’s initial current working directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这一功能如何运作，请启动 Python 并使用 `os.getcwd`（获取当前工作目录）命令来查找 Python 的初始当前工作目录：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that `os.getcwd` is used as a zero-argument function call, to emphasize
    the fact that the value it returns isn’t a constant but will change as you issue
    commands that alter the value of the current working directory. (That directory
    probably will be either the directory the Python program itself resides in or
    the directory you were in when you started Python. On a Linux machine, the result
    is /home/myuser, which is the home directory.) On Windows machines, you’ll see
    extra backslashes inserted into the path because Windows uses \ as its path separator,
    and in Python strings (as discussed in [section 6.3.1](kindle_split_017.html#ch06lev2sec1)),
    \ has a special meaning unless it’s itself backslashed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`os.getcwd` 被用作零参数函数调用，以强调它返回的值不是一个常数，而是会随着你发出改变当前工作目录值的命令而改变。（该目录可能要么是 Python
    程序本身所在的目录，要么是你启动 Python 时所在的目录。在 Linux 机器上，结果是 /home/myuser，这是主目录。）在 Windows 机器上，你会在路径中看到插入的额外反斜杠，因为
    Windows 使用 \ 作为其路径分隔符，而在 Python 字符串（如第 6.3.1 节中讨论的）中，\ 有特殊含义，除非它本身被转义。（[section
    6.3.1](kindle_split_017.html#ch06lev2sec1)）
- en: Now type
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The constant `os.curdir` returns whatever string your system happens to use
    as the same directory indicator. On both UNIX and Windows, the current directory
    is represented as a single dot, but to keep your programs portable, you should
    always use `os.curdir` instead of typing just the dot. This string is a relative
    path, meaning that `os.listdir` appends it to the path for the current working
    directory, giving the same path. This command returns a list of all the files
    or folders inside the current working directory. Choose some folder name, and
    type
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 `os.curdir` 返回系统当前使用的相同目录指示符的字符串。在 UNIX 和 Windows 上，当前目录都表示为一个单独的点，但为了保持你的程序的可移植性，你应该始终使用
    `os.curdir` 而不是直接输入点。这个字符串是一个相对路径，意味着 `os.listdir` 会将其附加到当前工作目录的路径上，得到相同的路径。此命令返回当前工作目录内所有文件或文件夹的列表。选择一个文件夹名称，并输入
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* “Change directory” function**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “更改目录”功能**'
- en: As you can see, Python moves into the folder specified as an argument of the
    `os.chdir` function. Another call to `os.listdir(os.curdir)` would return a list
    of files in `folder`, because `os.curdir` would then be taken relative to the
    new current working directory. Many Python filesystem operations use the current
    working directory in this manner.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 会移动到 `os.chdir` 函数参数指定的文件夹。再次调用 `os.listdir(os.curdir)` 将返回 `folder`
    中的文件列表，因为此时 `os.curdir` 将相对于新的当前工作目录进行解析。许多 Python 文件系统操作都以这种方式使用当前工作目录。
- en: 12.2.3\. Accessing directories with pathlib
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.3\. 使用 pathlib 访问目录
- en: 'To get the current directory with `pathlib`, you could do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `pathlib` 获取当前目录，你可以执行以下操作：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s no way for `pathlib` to change the current directory in the way that
    `os.chdir()` does (see the preceding section), but you could work with a new folder
    by creating a new path object, as discussed in [section 12.2.5](#ch12lev2sec5),
    “[Manipulating pathnames with pathlib](#ch12lev2sec5).”
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib` 没有办法像 `os.chdir()` 那样更改当前目录（参见上一节），但你可以通过创建一个新的路径对象来处理一个新的文件夹，正如在[第
    12.2.5 节](#ch12lev2sec5)“使用 pathlib 操作路径名”中讨论的那样。'
- en: 12.2.4\. Manipulating pathnames
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.4\. 操作路径名
- en: Now that you have the background to understand file and directory pathnames,
    it’s time to look at the facilities Python provides for manipulating these pathnames.
    These facilities consist of several functions and constants in the `os.path` submodule,
    which you can use to manipulate paths without explicitly using any operating-system-specific
    syntax. Paths are still represented as strings, but you need never think of them
    or manipulate them as such.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了理解文件和目录路径名的基础，是时候看看 Python 提供的用于操作这些路径名的工具了。这些工具包括 `os.path` 子模块中的几个函数和常量，你可以使用它们来操作路径，而无需明确使用任何特定于操作系统的语法。路径仍然以字符串的形式表示，但你无需将它们视为或以这种方式操作它们。
- en: To start, construct a few pathnames on different operating systems, using the
    `os.path.join` function. Note that importing `os` is sufficient to bring in the
    `os.path` submodule also; there’s no need for an explicit `import os.path` statement.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `os.path.join` 函数在不同的操作系统上构建几个路径名。请注意，导入 `os` 就足以引入 `os.path` 子模块；不需要显式地使用
    `import os.path` 语句。
- en: 'First, start Python under Windows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 Windows 下启动 Python：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `os.path.join` function interprets its arguments as a series of directory
    names or filenames, which are to be joined to form a single string understandable
    as a relative path by the underlying operating system. In a Windows system, that
    means path component names should be joined with backslashes, which is what was
    produced.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.join` 函数将它的参数解释为一系列目录名或文件名，这些名称将被连接起来形成一个字符串，该字符串可以被底层操作系统理解为一个相对路径。在一个
    Windows 系统中，这意味着路径组件名称应该用反斜杠连接，这正是产生的结果。'
- en: 'Now try the same thing in UNIX:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在 UNIX 中做同样的事情：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is the same path, but using the Linux/UNIX convention of forward
    slash separators rather than the Windows convention of backslash separators. In
    other words, `os.path.join` lets you form file paths from a sequence of directory
    or filenames without any worry about the conventions of the underlying operating
    system. `os.path.join` is the fundamental way by which file paths may be built
    in a manner that doesn’t constrain the operating systems on which your program
    will run.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是相同的路径，但使用了 Linux/UNIX 的正斜杠分隔符约定，而不是 Windows 的反斜杠分隔符约定。换句话说，`os.path.join`
    允许你从一系列目录或文件名中构建文件路径，而无需担心底层操作系统的约定。`os.path.join` 是构建文件路径的基本方式，这种方式不会限制你的程序将在哪些操作系统上运行。
- en: 'The arguments to `os.path.join` need not be a single directory or filename;
    they may also be subpaths that are then joined to make a longer pathname. The
    following example illustrates this in the Windows environment and is also a case
    in which you’d find it necessary to use double backslashes in your strings. Note
    that you could enter the pathname with forward slashes (/) as well, because Python
    converts them before accessing the Windows operating system:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.join` 的参数不需要是单个目录或文件名；它们也可以是子路径，然后连接起来形成更长的路径名。以下示例在 Windows 环境中说明了这一点，并且也是您需要在使用字符串中的双反斜杠的情况下找到它的一个例子。请注意，您也可以使用正斜杠
    (/) 输入路径名，因为 Python 在访问 Windows 操作系统之前会将它们转换过来：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you always use `os.path.join` to build up your paths, of course, you’ll rarely
    need to worry about this situation. To write this example in a portable manner,
    you should enter
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您始终使用 `os.path.join` 来构建路径，那么您很少需要担心这种情况。为了以可移植的方式编写此示例，您应该输入
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `os.path.join` command also has some understanding of absolute versus relative
    pathnames. In Linux/UNIX, an *absolute* path always begins with a / (because a
    single slash denotes the topmost directory of the entire system, which contains
    everything else, including the various floppy and CD drives that might be available).
    A *relative* path in UNIX is any legal path that does *not* begin with a slash.
    Under any of the Windows operating systems, the situation is more complicated
    because the way in which Windows handles relative and absolute paths is messier.
    Rather than go into all of the details, I’ll just say that the best way to handle
    this situation is to work with the following simplified rules for Windows paths:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.join` 命令也了解绝对路径和相对路径。在 Linux/UNIX 中，*绝对* 路径始终以 / 开头（因为单个斜杠表示整个系统的最高级目录，其中包含所有其他内容，包括可能可用的各种软盘和
    CD 驱动器）。UNIX 中的 *相对* 路径是任何合法路径，且不以斜杠开头。在任何 Windows 操作系统中，情况更为复杂，因为 Windows 处理相对和绝对路径的方式更为混乱。而不是深入所有细节，我只想说，处理这种情况的最佳方式是遵循以下简化的
    Windows 路径规则：'
- en: 'A pathname beginning with a drive letter followed by a colon and a backslash
    and then a path is an absolute path: C:\Program Files\Doom. (Note that C: by itself,
    without a trailing backslash, can’t reliably be used to refer to the top-level
    directory on the C: drive. You must use C:\ to refer to the top-level directory
    on C:. This requirement is a result of DOS conventions, not Python design.)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '以驱动器字母开头，后跟冒号和反斜杠，然后是路径的路径名是绝对路径：C:\Program Files\Doom。（注意，仅凭 C: 本身，如果没有尾随的反斜杠，就不能可靠地用来引用
    C: 驱动器上的顶级目录。您必须使用 C:\ 来引用 C: 的顶级目录。这一要求是 DOS 习惯的结果，而不是 Python 的设计。）'
- en: 'A pathname beginning with neither a drive letter nor a backslash is a relative
    path: `mydirectory\letters\business`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 neither 驱动器字母 nor 反斜杠开头的路径名是相对路径：`mydirectory\letters\business`。
- en: A pathname beginning with \\ followed by the name of a server is the path to
    a network resource.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 \\ 开头，后跟服务器名称的路径名是网络资源的路径。
- en: Anything else can be considered to be an invalid pathname.^([[1](#ch12fn1)])
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他情况都可以被认为是无效的路径名.^([[1](#ch12fn1)])
- en: ¹
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Microsoft Windows allows some other constructs, but it’s probably best to stick
    to the given definitions.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Microsoft Windows 允许一些其他结构，但可能最好坚持使用给定的定义。
- en: Regardless of the operating system used, the `os.path.join` command doesn’t
    perform sanity checks on the names it’s constructing. It’s possible to construct
    pathnames containing characters that, according to your OS, are forbidden in pathnames.
    If such checks are a requirement, probably the best solution is to write a small
    path-validity-checker function yourself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不论使用哪种操作系统，`os.path.join` 命令都不会对其构造的路径名进行合理性检查。有可能构造出包含根据您的操作系统认为在路径名中禁止使用的字符的路径名。如果此类检查是必需的，可能最好的解决方案是自行编写一个小的路径有效性检查函数。
- en: 'The `os.path.split` command returns a two-element tuple splitting the basename
    of a path (the single file or directory name at the end of the path) from the
    rest of the path. You might use this example on a Windows system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.split` 命令返回一个包含两个元素的元组，将路径的基本名称（路径末尾的单个文件或目录名称）从路径的其余部分分割开来。您可能会在
    Windows 系统上使用此示例：'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `os.path.basename` function returns only the basename of the path, and
    the `os.path.dirname` function returns the path up to but not including the last
    name, as in this example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.basename` 函数仅返回路径的基本名称，而 `os.path.dirname` 函数返回路径直到但不包括最后一个名称的部分，如下例所示：'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To handle the dotted extension notation used by most filesystems to indicate
    file type (the Macintosh is a notable exception), Python provides `os.path.splitext`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理大多数文件系统（Macintosh 是一个显著的例外）用来表示文件类型的点分扩展名表示法，Python 提供了 `os.path.splitext`：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last element of the returned tuple contains the dotted extension of the
    indicated file (if there was a dotted extension). The first element of the returned
    tuple contains everything from the original argument except the dotted extension.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元组的最后一个元素包含指定文件的点分扩展名（如果有）。返回的元组的第一个元素包含从原始参数中除点分扩展名之外的所有内容。
- en: 'You can also use more specialized functions to manipulate pathnames. `os.path.commonprefix(path1,
    path2, ...)` finds the common prefix (if any) for a set of paths. This technique
    is useful if you want to find the lowest-level directory that contains every file
    in a set of files. `os.path.expanduser` expands username shortcuts in paths, such
    as for UNIX. Similarly, `os.path.expandvars` does the same for environment variables.
    Here’s an example on a Windows 10 system:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用更专业的函数来操作路径名。`os.path.commonprefix(path1, path2, ...)` 为一组路径找到公共前缀（如果有的话）。如果你想要找到包含一组文件中的每个文件的最低级目录，这个技术很有用。`os.path.expanduser`
    在路径中扩展用户名快捷方式，例如在 UNIX 中。同样，`os.path.expandvars` 对环境变量执行相同的操作。以下是在 Windows 10
    系统上的一个示例：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 12.2.5\. Manipulating pathnames with pathlib
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.5\. 使用 pathlib 操作路径名
- en: Just as you did in the preceding section, start by constructing a few pathnames
    on different operating systems, using the path object’s methods.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的部分中所做的那样，首先在不同的操作系统上使用路径对象的方法构造几个路径名。
- en: 'First, start Python under Windows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 Windows 下启动 Python：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same result can be achieved by using the slash operator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用斜杠操作符也可以达到相同的结果：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that in the representation of the path object, forward slashes are always
    used, but Windows Path objects have the forward slashes converted to backslashes
    as required by the OS. So if you try the same thing in UNIX:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在路径对象的表示中，始终使用正斜杠，但 Windows 路径对象将正斜杠转换为操作系统所需的反斜杠。所以如果你在 UNIX 中尝试相同的事情：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `parts` property returns a tuple of all the components of a path. You might
    use this example on a Windows system:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`parts` 属性返回一个包含路径所有组件的元组。你可以在 Windows 系统上使用这个示例：'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `name` property returns only the basename of the path, the `parent` property
    returns the path up to but not including the last name, and the `suffix` property
    handles the dotted extension notation used by most filesystems to indicate file
    type (but the Macintosh is a notable exception). Here’s an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 属性返回路径的基名，`parent` 属性返回路径直到但不包括最后一个名称的部分，而 `suffix` 属性处理大多数文件系统用来表示文件类型的点分扩展名表示法（但
    Macintosh 是一个显著的例外）。以下是一个示例：'
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Several other methods associated with `Path` objects allow flexible manipulation
    of both pathnames and files themselves, so you should review the documentation
    of the `pathlib` module. It’s likely that the `pathlib` module will make your
    life easier and your file-handling code more concise.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Path` 对象相关联的几个其他方法允许灵活地操作路径名和文件本身，因此你应该查看 `pathlib` 模块的文档。`pathlib` 模块可能会使你的生活更轻松，并使你的文件处理代码更简洁。
- en: 12.2.6\. Useful constants and functions
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.6\. 有用的常量和函数
- en: You can access several useful path-related constants and functions to make your
    Python code more system-independent than it otherwise would be. The most basic
    of these constants are `os.curdir` and `os.pardir`, which respectively define
    the symbol used by the operating system for the directory and parent directory
    path indicators. In Windows as well as Linux/UNIX and macOS, these indicators
    are `.` and `..` respectively, and they can be used as normal path elements. This
    example
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问几个有用的路径相关常量和函数，使你的 Python 代码比其他情况下更系统无关。这些常量中最基本的是 `os.curdir` 和 `os.pardir`，它们分别定义了操作系统用于目录和父目录路径指示器的符号。在
    Windows 以及 Linux/UNIX 和 macOS 中，这些指示器分别是 `.` 和 `..`，它们可以用作正常的路径元素。以下是一个示例
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: asks whether the parent of the parent of `path` is a directory. `os.curdir`
    is particularly useful for requesting commands on the current working directory.
    This example
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 询问 `path` 的父父是否是目录。`os.curdir` 特别适用于请求当前工作目录上的命令。以下是一个示例
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: returns a list of filenames in the current working directory (because `os.curdir`
    is a relative path, and `os.listdir` always takes relative paths as being relative
    to the current working directory).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前工作目录中的文件名列表（因为 `os.curdir` 是一个相对路径，而 `os.listdir` 总是接受相对路径作为相对于当前工作目录的路径）。
- en: 'The `os.name` constant returns the name of the Python module imported to handle
    the operating system–specific details. Here’s an example on my Windows XP system:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.name` 常量返回用于处理操作系统特定细节的 Python 模块的名称。以下是在我的 Windows XP 系统上的一个示例：'
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that `os.name` returns `'nt'` even though the actual version of Windows
    could be Windows 10\. Most versions of Windows, except for Windows CE, are identified
    as `'nt'`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使实际的 Windows 版本是 Windows 10，`os.name` 也会返回 `'nt'`。除了 Windows CE 之外，大多数 Windows
    版本都被标识为 `'nt'`。
- en: 'On a Mac running OS X and on Linux/UNIX, the response is `posix`. You can use
    this response to perform special operations, depending on the platform you’re
    working on:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 OS X 的 Mac 和 Linux/UNIX 上，响应是 `posix`。你可以根据你正在工作的平台执行特殊操作：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You may also see programs use `sys.platform`, which gives more exact information.
    On Windows 10, `sys.platform` is set to `win32`—even if the machine is running
    the 64-bit version of the operating system. On Linux, you may see `linux2`, whereas
    on Solaris, it may be set to `sunos5` depending on the version you’re running.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能看到程序使用 `sys.platform`，它提供了更精确的信息。在 Windows 10 上，`sys.platform` 被设置为 `win32`——即使机器运行的是操作系统的
    64 位版本。在 Linux 上，你可能看到 `linux2`，而在 Solaris 上，它可能根据你运行的版本被设置为 `sunos5`。
- en: All your environment variables and the values associated with them are available
    in a dictionary called `os.environ`. On most operating systems, this directory
    includes variables related to paths—typically, search paths for binaries and so
    forth. If what you’re doing requires this directory, you know where to find it
    now.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你的环境变量以及与它们关联的值都存储在一个名为 `os.environ` 的字典中。在大多数操作系统中，这个目录包括与路径相关的变量——通常是二进制文件的搜索路径等。如果你需要这个目录，现在你知道在哪里可以找到它。
- en: At this point, you’ve received an introduction to the major aspects of working
    with pathnames in Python. If your immediate need is to open files for reading
    or writing, you can jump directly to the next chapter. Continue reading for further
    information about pathnames, testing what they point to, useful constants, and
    so forth.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了在 Python 中处理路径的主要方面。如果你的直接需求是打开文件进行读取或写入，你可以直接跳到下一章。继续阅读以获取有关路径名、测试它们指向的内容、有用的常量等方面的更多信息。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Manipulating paths'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：路径操作
- en: How would you use the `os` module’s functions to take a path to a file called
    `test.log` and create a new file path in the same directory for a file called
    `test.log.old`? How would you do the same thing using the `pathlib` module?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何使用 `os` 模块的函数来获取一个指向名为 `test.log` 的文件的路径，并在同一目录下创建一个名为 `test.log.old` 的新文件路径？你会如何使用
    `pathlib` 模块来完成同样的操作？
- en: What path would you get if you created a pathlib `Path` object from `os .pardir`?
    Try it and find out.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 `os.pardir` 创建一个 pathlib `Path` 对象，你会得到什么路径？试一试，看看结果。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 12.3\. Getting information about files
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 获取文件信息
- en: File paths are supposed to indicate actual files and directories on your hard
    drive. You’re probably passing a path around, of course, because you want to know
    something about what it points to. Various Python functions are available for
    this purpose.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 文件路径应该指示你硬盘上的实际文件和目录。你当然会传递一个路径，因为你想要了解它指向的内容。Python 提供了各种函数来处理这个目的。
- en: 'The most commonly used Python path-information functions are `os.path.exists`,
    `os.path.isfile`, and `os.path.isdir`, all of which take a single path as an argument.
    `os.path.exists` returns `True` if its argument is a path corresponding to something
    that exists in the filesystem. `os.path.isfile` returns `True` if and only if
    the path it’s given indicates a normal data file of some sort (executables fall
    under this heading), and it returns `False` otherwise, including the possibility
    that the path argument doesn’t indicate anything in the filesystem. `os.path.isdir`
    returns `True` if and only if its path argument indicates a directory; it returns
    `False` otherwise. These examples are valid on my system. You may need to use
    different paths on yours to investigate the behavior of these functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的 Python 路径信息函数是 `os.path.exists`、`os.path.isfile` 和 `os.path.isdir`，它们都接受一个路径作为参数。`os.path.exists`
    如果其参数是一个在文件系统中存在的路径，则返回 `True`。`os.path.isfile` 仅当其提供的路径指示某种正常的数据文件（可执行文件属于这一类）时返回
    `True`，否则返回 `False`，包括路径参数在文件系统中没有指示任何内容的情况。`os.path.isdir` 仅当其路径参数指示一个目录时返回 `True`，否则返回
    `False`。以下示例在我的系统上是有效的。你可能需要使用你自己的不同路径来调查这些函数的行为：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Several similar functions provide more specialized queries. `os.path.islink`
    and `os.path.ismount` are useful in the context of Linux and other UNIX operating
    systems that provide file links and mount points; they return `True` if, respectively,
    a path indicates a file that’s a link or a mount point. `os.path.islink` does
    *not* return `True` on Windows shortcuts files (files ending with .lnk), for the
    simple reason that such files aren’t true links. However, `os.path.islink` returns
    `True` on Windows systems for true symbolic links created with the `mklink()`
    command. The OS doesn’t assign them a special status, and programs can’t transparently
    use them as though they were the actual file. `os.path.samefile(path1, path2)`
    returns `True` if and only if the two path arguments point to the same file. `os.path.isabs(path)`
    returns `True` if its argument is an absolute path; it returns `False` otherwise.
    `os.path.getsize(path)`, `os.path.getmtime(path)`, and `os.path.getatime(path)`
    return the size, last modify time, and last access time of a pathname, respectively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 几个类似的功能提供了更专业的查询。`os.path.islink` 和 `os.path.ismount` 在 Linux 和其他提供文件链接和挂载点的
    UNIX 操作系统环境中很有用；它们分别返回 `True`，如果路径指示的是一个链接或挂载点。`os.path.islink` 在 Windows 快捷方式文件（以
    .lnk 结尾的文件）上不返回 `True`，简单的理由是这类文件不是真正的链接。然而，`os.path.islink` 在使用 `mklink()` 命令创建的真正符号链接的
    Windows 系统上返回 `True`。操作系统没有为它们分配特殊状态，程序不能透明地使用它们，就像它们是实际文件一样。`os.path.samefile(path1,
    path2)` 仅当两个路径参数指向同一文件时返回 `True`。`os.path.isabs(path)` 如果其参数是绝对路径则返回 `True`；否则返回
    `False`。`os.path.getsize(path)`、`os.path.getmtime(path)` 和 `os.path.getatime(path)`
    分别返回路径名的大小、最后修改时间和最后访问时间。
- en: 12.3.1\. Getting information about files with scandir
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1. 使用 scandir 获取文件信息
- en: In addition to the `os.path` functions listed, you can get more complete information
    about the files in a directory by using `os.scandir`, which returns an iterator
    of `os.DirEntry` objects. `os.DirEntry` objects expose the file attributes of
    a directory entry, so using `os.scandir` can be faster and more efficient than
    combining `os.listdir` (discussed in the next section) with the `os.path` operations.
    If, for example, you need to know whether the entry refers to a file or directory,
    `os.scandir`’s ability to access more directory information than just the name
    will be a plus. `os.DirEntry` objects have methods that correspond to the `os.path`
    functions mentioned in the previous section, including `exists`, `is_dir`, `is_file`,
    `is_socket`, and `is_symlink`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列出的 `os.path` 函数外，你还可以通过使用 `os.scandir` 获取目录中文件的更完整信息，它返回一个 `os.DirEntry`
    对象的迭代器。`os.DirEntry` 对象公开了目录条目的文件属性，因此使用 `os.scandir` 可能比将 `os.listdir`（在下一节中讨论）与
    `os.path` 操作组合更快、更高效。例如，如果你需要知道条目是否指向文件或目录，`os.scandir` 能够访问比仅名称更多的目录信息，这将是一个优点。`os.DirEntry`
    对象具有与上一节中提到的 `os.path` 函数相对应的方法，包括 `exists`、`is_dir`、`is_file`、`is_socket` 和 `is_symlink`。
- en: '`os.scandir` also supports a context manager using `with`, and using one is
    recommended to ensure resources are properly disposed of. This example code iterates
    over all of the entries in a directory and prints both the name of the entry and
    whether it’s a file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.scandir` 也支持使用 `with` 的上下文管理器，并建议使用它以确保资源得到适当的处理。以下示例代码遍历目录中的所有条目并打印条目的名称以及它是否是文件：'
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 12.4\. More filesystem operations
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. 更多的文件系统操作
- en: In addition to obtaining information about files, Python lets you perform certain
    filesystem operations directly through a set of basic but highly useful commands
    in the `os` module.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取文件信息外，Python 允许你通过 `os` 模块中的一组基本但非常有用的命令直接执行某些文件系统操作。
- en: I describe only those true cross-platform operations in this section. Many operating
    systems have access to more advanced filesystem functions, and you need to check
    the main Python library documentation for the details.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我只在本节中描述了那些真正的跨平台操作。许多操作系统可以访问更高级的文件系统功能，你需要检查主要的 Python 库文档以获取详细信息。
- en: 'You’ve already seen that to obtain a list of files in a directory, you use
    `os.listdir`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，要获取目录中的文件列表，你使用 `os.listdir`：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that unlike the list-directory command in many other languages or shells,
    Python does *not* include the `os.curdir` and `os.pardir` indicators in the list
    returned by `os.listdir.`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与许多其他语言或壳中的列表目录命令不同，Python 不在 `os.listdir` 返回的列表中包含 `os.curdir` 和 `os.pardir`
    指示符。
- en: 'The `glob` function from the `glob` module (named after an old UNIX function
    that did pattern matching) expands Linux/UNIX shell-style wildcard characters
    and character sequences in a pathname, returning the files in the current working
    directory that match. A `*` matches any sequence of characters. A `?` matches
    any single character. A character sequence (`[h,H]` or `[0-9]`) matches any single
    character in that sequence:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `glob` 模块的 `glob` 函数（以旧UNIX模式匹配函数命名）扩展了Linux/UNIX shell样式的通配符和字符序列，在路径名中返回当前工作目录中匹配的文件。`*`
    匹配任何字符序列。`?` 匹配任何单个字符。字符序列（`[h,H]` 或 `[0-9]`）匹配该序列中的任何单个字符：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To rename (move) a file or directory, use `os.rename`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名（移动）文件或目录，请使用 `os.rename`：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can use this command to move files across directories as well as within
    directories.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此命令在目录之间以及目录内部移动文件。
- en: 'Remove or delete a data file with `os.remove`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `os.remove` 删除或删除数据文件：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that you can’t use `os.remove` to delete directories. This restriction
    is a safety feature, to ensure that you don’t accidentally delete an entire directory
    substructure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不能使用 `os.remove` 删除目录。此限制是一个安全特性，以确保您不会意外删除整个目录子结构。
- en: 'Files can be created by writing to them, as discussed in [chapter 11](kindle_split_022.html#ch11).
    To create a directory, use `os.makedirs` or `os.mkdir`. The difference between
    them is that `os.mkdir` doesn’t create any necessary intermediate directories,
    but `os.makedirs` does:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过写入它们来创建文件，如第11章所述。[第11章](kindle_split_022.html#ch11)。要创建目录，请使用 `os.makedirs`
    或 `os.mkdir`。它们之间的区别在于 `os.mkdir` 不会创建任何必要的中间目录，而 `os.makedirs` 会：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To remove a directory, use `os.rmdir`. This function removes only empty directories.
    Attempting to use it on a nonempty directory raises an exception:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个目录，请使用 `os.rmdir`。此函数仅删除空目录。尝试在非空目录上使用它将引发异常：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To remove nonempty directories, use the `shutil.rmtree` function. It recursively
    removes all files in a directory tree. See the Python standard library documentation
    for details on its use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除非空目录，请使用 `shutil.rmtree` 函数。它递归地删除目录树中的所有文件。有关其使用的详细信息，请参阅Python标准库文档。
- en: 12.4.1\. More filesystem operations with pathlib
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1. 使用 pathlib 执行更多文件系统操作
- en: 'Path objects have most of the same methods mentioned earlier. Some differences
    exist, however. The `iterdir` method is similar to the `os.path.listdir` function
    except that it returns an iterator of paths rather than a list of strings:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 路径对象具有前面提到的许多相同的方法。然而，存在一些差异。`iterdir` 方法类似于 `os.path.listdir` 函数，但它返回路径的迭代器而不是字符串列表：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that in a Windows environment, the paths returned are `WindowsPath` objects,
    whereas on Mac OS or Linux, they’re `PosixPath` objects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Windows环境中，返回的路径是 `WindowsPath` 对象，而在Mac OS或Linux中，它们是 `PosixPath` 对象。
- en: '`pathlib` path objects also have a `glob` method built in, which again returns
    not a list of strings but an iterator of path objects. Otherwise, this function
    behaves very much like the `glob.glob` function demonstrated above:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib` 路径对象也内置了 `glob` 方法，它再次返回的不是字符串列表，而是路径对象的迭代器。否则，此函数的行为与上面演示的 `glob.glob`
    函数非常相似：'
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To rename (move) a file or directory, use the path object’s `rename` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名（移动）文件或目录，请使用路径对象的 `rename` 方法：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can use this command to move files across directories as well as within
    directories.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此命令在目录之间以及目录内部移动文件。
- en: 'Remove or delete a data file with `unlink`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unlink` 删除或删除数据文件：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that as with `os.remove`, you can’t use the `unlink` method to delete directories.
    This restriction is a safety feature, to ensure that you don’t accidentally delete
    an entire directory substructure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `os.remove` 一样，您不能使用 `unlink` 方法删除目录。此限制是一个安全特性，以确保您不会意外删除整个目录子结构。
- en: 'To create a directory by using a path object, use the path object’s `mkdir`
    method. If you give the `mkdir` method a `parents=True` parameter, it creates
    any necessary intermediate directories; otherwise, it raises a `FileNotFoundError`
    if an intermediate directory isn’t there:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用路径对象创建目录，请使用路径对象的 `mkdir` 方法。如果您给 `mkdir` 方法传递 `parents=True` 参数，它将创建任何必要的中间目录；否则，如果中间目录不存在，它将引发
    `FileNotFoundError`：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To remove a directory, use the `rmdir` method. This method removes only empty
    directories. Attempting to use it on a nonempty directory raises an exception:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除目录，请使用 `rmdir` 方法。此方法仅删除空目录。尝试在非空目录上使用它将引发异常：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 12: More file operations'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室12：更多文件操作
- en: How might you calculate the total size of all files ending with .txt that aren’t
    symlinks in a directory? If your first answer was using `os.path`, also try it
    with `pathlib`, and vice versa.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何计算目录中所有以 .txt 结尾且不是符号链接的文件的总大小？如果你的第一个答案是使用 `os.path`，也试着用 `pathlib` 来做，反之亦然。
- en: Write some code that builds off your solution to move the same .txt files in
    the lab question to a new subdirectory called backup in the same directory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些代码，基于你的解决方案将实验室问题中的相同 .txt 文件移动到同一目录下的一个名为 backup 的新子目录中。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.5\. Processing all files in a directory subtree
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. 处理目录子树中的所有文件
- en: 'Finally, a highly useful function for traversing recursive directory structures
    is the `os.walk` function. You can use it to walk through an entire directory
    tree, returning three things for each directory it traverses: the root, or path,
    of that directory; a list of its subdirectories; and a list of its files.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个用于遍历递归目录结构的非常有用的函数是 `os.walk` 函数。你可以用它来遍历整个目录树，对于它遍历的每个目录，返回三个东西：该目录的根或路径；其子目录的列表；以及其文件的列表。
- en: '`os.walk` is called with the path of the starting, or top, directory and can
    have three optional arguments: `os.walk(directory`, `topdown=True`, `onerror=None`,
    `followlinks= False)`. `directory` is a starting directory path; if `topdown`
    is `True` or not present, the files in each directory are processed *before* its
    subdirectories, resulting in a listing that starts at the top and goes down; whereas
    if `topdown` is `False`, the subdirectories of each directory are processed *first*,
    giving a bottom-up traversal of the tree. The `onerror` parameter can be set to
    a function to handle any errors that result from calls to `os.listdir`, which
    are ignored by default. `os.walk` by default doesn’t walk down into folders that
    are symbolic links unless you give it the `followlinks=True` parameter.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.walk` 使用起始或顶级目录的路径调用，并可以有三个可选参数：`os.walk(directory, topdown=True, onerror=None,
    followlinks=False)`。`directory` 是起始目录路径；如果 `topdown` 为 `True` 或未指定，则每个目录中的文件在处理其子目录之前进行处理，结果是一个从顶部开始向下走的列表；而如果
    `topdown` 为 `False`，则首先处理每个目录的子目录，从而实现从下到上的树遍历。`onerror` 参数可以设置为一个函数来处理由 `os.listdir`
    调用产生的任何错误，默认情况下这些错误会被忽略。默认情况下，`os.walk` 不会进入符号链接指向的文件夹，除非你提供了 `followlinks=True`
    参数。'
- en: When called, `os.walk` creates an iterator that recursively applies itself to
    all the directories contained in the `top` parameter. In other words, for each
    subdirectory `subdir` in `names`, `os.walk` recursively invokes a call to itself,
    of the form `os.walk(subdir, ...)`. Note that if `topdown` is `True` or not given,
    the list of subdirectories may be modified (using any of the list-modification
    operators or methods) before its items are used for the next level of recursion;
    you can use this to control into which—if any—subdirectories `os.walk` will descend.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，`os.walk` 创建一个迭代器，它递归地应用于 `top` 参数包含的所有目录。换句话说，对于 `names` 中的每个子目录 `subdir`，`os.walk`
    递归地调用自身的形式为 `os.walk(subdir, ...)`。注意，如果 `topdown` 为 `True` 或未指定，在递归的下一级使用之前，子目录列表可能会被修改（使用任何列表修改运算符或方法）；你可以使用这个来控制
    `os.walk` 将会进入哪些子目录（如果有的话）。
- en: 'To get a feel for `os.walk`, I recommend iterating over the tree and printing
    out the values returned for each directory. As an example of the power of `os.walk`,
    list the current working directory and all of its subdirectories along with a
    count of the number of entries in each of them, excluding any .git directories:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受 `os.walk` 的能力，我建议迭代整个树并打印出每个目录返回的值。作为 `os.walk` 力量的一个例子，列出当前工作目录及其所有子目录，以及每个目录中条目的数量，排除任何
    .git 目录：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Checks for directory named .git**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 检查名为 .git 的目录**'
- en: '***2* Removes .git (only the .git directory) from directory list**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从目录列表中移除 .git（仅 .git 目录）**'
- en: This example is complex, and if you want to use `os.walk` to its fullest extent,
    you should probably play around with it quite a bit to understand the details
    of what’s going on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很复杂，如果你想充分利用 `os.walk`，你可能需要大量地玩弄它来理解正在发生的事情的细节。
- en: The `copytree` function of the `shutil` module recursively makes copies of all
    the files in a directory and all of its subdirectories, preserving permission
    mode and stat (that is, access/modify times) information. `shutil` also has the
    already-mentioned `rmtree` function for removing a directory and all of its subdirectories,
    as well as several functions for making copies of individual files. See the standard
    library documentation for details.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil`模块的`copytree`函数递归地复制目录及其所有子目录中的所有文件，并保留权限模式和stat（即访问/修改时间）信息。`shutil`还具有已提到的`rmtree`函数，用于删除目录及其所有子目录，以及几个用于复制单个文件的函数。有关详细信息，请参阅标准库文档。'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python provides a group of functions and constants that handle filesystem references
    (pathnames) and filesystem operations in a manner independent of the underlying
    operating system.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python提供了一组函数和常量，以独立于底层操作系统的方式处理文件系统引用（路径名）和文件系统操作。
- en: For more advanced and specialized filesystem operations that typically are tied
    to a certain operating system or systems, look at the main Python documentation
    for the `os, pathlib,` and `posix` modules.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更高级和专业的文件系统操作，这些操作通常与特定的操作系统或系统相关联，请查看`os`、`pathlib`和`posix`模块的主Python文档。
- en: For convenience, a summary of the functions discussed in this chapter is given
    in [table 12.1](#ch12table01) and [table 12.2](#ch12table02).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便起见，本章讨论的函数的总结在[表12.1](#ch12table01)和[表12.2](#ch12table02)中给出。
- en: Table 12.1\. Summary of filesystem values and functions
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.1\. 文件系统值和函数的摘要
- en: '| Function | Filesystem value or operation |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 文件系统值或操作 |'
- en: '| --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| os.getcwd(), Path.cwd() | Gets the current directory |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| os.getcwd(), Path.cwd() | 获取当前目录 |'
- en: '| os.name | Provides generic platform identification |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| os.name | 提供通用的平台识别 |'
- en: '| sys.platform | Provides specific platform information |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| sys.platform | 提供特定的平台信息 |'
- en: '| os.environ | Maps the environment |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| os.environ | 映射环境 |'
- en: '| os.listdir(path) | Gets files in a directory |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| os.listdir(path) | 获取目录中的文件 |'
- en: '| os.scandir(path) | Gets an iterator of os.DirEntry objects for a directory
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| os.scandir(path) | 获取目录的`os.DirEntry`对象迭代器 |'
- en: '| os.chdir(path) | Changes directory |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| os.chdir(path) | 更改目录 |'
- en: '| os.path.join(elements), Path.joinpath(elements) | Combines elements into
    a path |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| os.path.join(elements), Path.joinpath(elements) | 将元素组合成一个路径 |'
- en: '| os.path.split(path) | Splits the path into a base and tail (the last element
    of the path) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| os.path.split(path) | 将路径拆分为基本路径和尾部（路径的最后一个元素） |'
- en: '| Path.parts | A tuple of the path’s elements |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| Path.parts | 路径元素的元组 |'
- en: '| os.path.splitext(path) | Splits the path into a base and a file extension
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| os.path.splitext(path) | 将路径拆分为基本路径和文件扩展名 |'
- en: '| Path.suffix | The path’s file extension |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| Path.suffix | 路径的文件扩展名 |'
- en: '| os.path.basename(path) | Gets the base of the path |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| os.path.basename(path) | 获取路径的基本名 |'
- en: '| Path.name | The base name of the path |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Path.name | 路径的基本名 |'
- en: '| os.path.commonprefix(list_of_paths) | Gets the common prefix for all paths
    on a list |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| os.path.commonprefix(list_of_paths) | 获取列表中所有路径的共同前缀 |'
- en: '| os.path.expanduser(path) | Expands ~ or ~user to a full pathname |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| os.path.expanduser(path) | 将 ~ 或 ~user 扩展为完整路径名 |'
- en: '| os.path.expandvars(path) | Expands environment variables |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| os.path.expandvars(path) | 扩展环境变量 |'
- en: '| os.path.exists(path) | Tests to see if a path exists |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| os.path.exists(path) | 检查路径是否存在 |'
- en: '| os.path.isdir(path), Path.is_dir() | Tests to see if a path is a directory
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| os.path.isdir(path), Path.is_dir() | 检查路径是否为目录 |'
- en: '| os.path.isfile(path), Path.is_file() | Tests to see if a path is a file |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| os.path.isfile(path), Path.is_file() | 检查路径是否为文件 |'
- en: '| os.path.islink(path), Path.is_link() | Tests to see if a path is a symbolic
    link (not a Windows shortcut) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| os.path.islink(path), Path.is_link() | 检查路径是否为符号链接（非Windows快捷方式） |'
- en: '| os.path.ismount(path) | Tests to see if a path is a mount point |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| os.path.ismount(path) | 检查路径是否为挂载点 |'
- en: '| os.path.isabs(path), Path.is_absolute() | Tests to see if a path is an absolute
    path |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| os.path.isabs(path), Path.is_absolute() | 检查路径是否为绝对路径 |'
- en: '| os.path.samefile(path_1, path_2) | Tests to see if two paths refer to the
    same file |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| os.path.samefile(path_1, path_2) | 检查两个路径是否指向同一文件 |'
- en: '| os.path.getsize(path) | Gets the size of a file |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| os.path.getsize(path) | 获取文件的大小 |'
- en: '| os.path.getmtime(path) | Gets the modification time |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| os.path.getmtime(path) | 获取修改时间 |'
- en: '| os.path.getatime(path) | Gets the access time |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| os.path.getatime(path) | 获取访问时间 |'
- en: '| os.rename(old_path, new_path) | Renames a file |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| os.rename(old_path, new_path) | 重命名文件 |'
- en: '| os.mkdir(path) | Creates a directory |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| os.mkdir(path) | 创建目录 |'
- en: '| os.makedirs(path) | Creates a directory and any needed parent directories
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| os.makedirs(path) | 创建目录以及所需的任何父目录 |'
- en: '| os.rmdir(path) | Removes a directory |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| os.rmdir(path) | 删除目录 |'
- en: '| glob.glob(pattern) | Gets matches to a wildcard pattern |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| glob.glob(pattern) | 获取与通配符模式匹配的结果 |'
- en: '| os.walk(path) | Gets all filenames in a directory tree |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| os.walk(path) | 获取目录树中的所有文件名 |'
- en: Table 12.2\. Partial list of pathlib properties and functions
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.2. pathlib属性和函数的部分列表
- en: '| Method or property | Value or operation |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 方法或属性 | 值或操作 |'
- en: '| --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Path.cwd() | Gets the current directory |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| Path.cwd() | 获取当前目录 |'
- en: '| Path.joinpath(elements) or Path / element / element | Combines elements into
    a new path |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Path.joinpath(elements) 或 Path / element / element | 将元素组合成新的路径 |'
- en: '| Path.parts | A tuple of the path’s elements |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| Path.parts | 路径元素的元组 |'
- en: '| Path.suffix | The path’s file extension |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| Path.suffix | 路径的文件扩展名 |'
- en: '| Path.name | The base name of the path |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| Path.name | 路径的基本名称 |'
- en: '| Path.exists() | Tests to see if a path exists |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| Path.exists() | 检查路径是否存在 |'
- en: '| Path.is_dir() | Tests to see if a path is a directory |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| Path.is_dir() | 检查路径是否为目录 |'
- en: '| Path.is_file() | Tests to see if a path is a file |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| Path.is_file() | 检查路径是否为文件 |'
- en: '| Path.is_symlink() | Tests to see if a path is a symbolic link (not a Windows
    shortcut) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| Path.is_symlink() | 检查路径是否为符号链接（非Windows快捷方式） |'
- en: '| Path.is_absolute() | Tests to see if a path is an absolute path |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| Path.is_absolute() | 检查路径是否为绝对路径 |'
- en: '| Path.samefile(Path2) | Tests to see if two paths refer to the same file |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| Path.samefile(Path2) | 检查两个路径是否指向同一文件 |'
- en: '| Path1.rename(Path2) | Renames a file |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| Path1.rename(Path2) | 重命名文件 |'
- en: '| Path.mkdir([parents=True]) | Creates a directory, if parents is True also
    creates needed parent directories |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| Path.mkdir([parents=True]) | 创建目录，如果parents为True，也将创建所需的父目录 |'
- en: '| Path.rmdir() | Removes a directory |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| Path.rmdir() | 删除目录 |'
- en: '| Path.glob(pattern) | Gets matches to a wildcard pattern |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| Path.glob(pattern) | 获取与通配符模式匹配的结果 |'
