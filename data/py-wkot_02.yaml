- en: 2 Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 字符串
- en: Strings in Python are the way we work with text. Words, sentences, paragraphs,
    and even entire files are read into and manipulated via strings. Because so much
    of our work revolves around text, it’s no surprise that strings are one of the
    most common data types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，字符串是我们处理文本的方式。单词、句子、段落，甚至整个文件都是通过字符串读取和操作的。由于我们的工作大部分围绕文本展开，因此字符串成为最常见的数据类型之一也就不足为奇了。
- en: 'You should remember two important things about Python strings: (1) they’re
    immutable, and (2) in Python 3, they contain Unicode characters, encoded in UTF-8\.
    (See the sidebars on each of these subjects.)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住关于 Python 字符串的两个重要事项：（1）它们是不可变的，并且（2）在 Python 3 中，它们包含 Unicode 字符，编码为 UTF-8。（参见每个主题的侧边栏。）
- en: There’s no such thing as a “character” type in Python. We can talk about a “one-character
    string,” but that just means a string whose length is 1.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中没有“字符”类型。我们可以谈论“单字符字符串”，但这仅仅意味着字符串的长度为 1。
- en: Python’s strings are interesting and useful, not only because they allow us
    to work with text, but also because they’re a Python sequence. This means that
    we can iterate over them (character by character), retrieve their elements via
    numeric indexes, and search in them with the `in` operator.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的字符串既有趣又实用，不仅因为它们允许我们处理文本，而且因为它们是 Python 序列。这意味着我们可以逐个遍历它们（字符），通过数字索引检索它们的元素，并使用
    `in` 操作符在它们中进行搜索。
- en: This chapter includes exercises designed to help you work with strings in a
    variety of ways. The more familiar you are with Python’s string manipulation techniques,
    the easier it will be to work with text.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括旨在帮助您以各种方式处理字符串的练习。您对 Python 的字符串操作技术越熟悉，处理文本就会越容易。
- en: Useful references
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的参考资料
- en: Table 2.1 What you need to know
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `in` | Operator for searching in a sequence | `''a'' in ''abcd''` | [http://mng.bz/yy2G](http://mng.bz/yy2G)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 用于在序列中搜索的操作符 | `''a'' in ''abcd''` | [http://mng.bz/yy2G](http://mng.bz/yy2G)
    |'
- en: '| Slice | Retrieves a subset of elements from a sequence | `# returns ''bdf''``''abcdefg''[1:7:2]`
    | [http://mng.bz/MdW7](http://mng.bz/MdW7) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 切片 | 从序列中检索元素子集 | `# 返回 ''bdf''``''abcdefg''[1:7:2]` | [http://mng.bz/MdW7](http://mng.bz/MdW7)
    |'
- en: '| `str.split` | Breaks strings apart, returning a list | `# returns [''abc'',
    ''def'', ''ghi'']``''abc def ghi''.split()` | [http://mng.bz/aR4z](http://mng.bz/aR4z)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `str.split` | 将字符串拆分，返回一个列表 | `# 返回 [''abc'', ''def'', ''ghi'']``''abc def
    ghi''.split()` | [http://mng.bz/aR4z](http://mng.bz/aR4z) |'
- en: '| `str.join` | Combines strings to create a new one | `# returns ''abc*def*ghi''``''*''.join([''abc'',
    ''def'', ''ghi''])` | [http://mng.bz/gyYl](http://mng.bz/gyYl) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `str.join` | 将字符串合并以创建一个新的字符串 | `# 返回 ''abc*def*ghi''``''*''.join([''abc'',
    ''def'', ''ghi''])` | [http://mng.bz/gyYl](http://mng.bz/gyYl) |'
- en: '| `list.append` | Adds an element to a list | `mylist.append(''hello'')` |
    [http://mng.bz/aR7z](http://mng.bz/aR7z) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `list.append` | 向列表添加一个元素 | `mylist.append(''hello'')` | [http://mng.bz/aR7z](http://mng.bz/aR7z)
    |'
- en: '| `sorted` | Returns a sorted list, based on an input sequence | `# returns
    [10, 20, 30]``sorted([10, 30, 20])` | [http://mng.bz/pBEG](http://mng.bz/pBEG)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `sorted` | 返回一个基于输入序列的排序列表 | `# 返回 [10, 20, 30]``sorted([10, 30, 20])` |
    [http://mng.bz/pBEG](http://mng.bz/pBEG) |'
- en: '| Iterating over files | Opens a file and iterates over its lines one at a
    time | `for one_line in open(filename):` | [http://mng.bz/OMAn](http://mng.bz/OMAn)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 遍历文件 | 打开文件并逐行遍历 | `for one_line in open(filename):` | [http://mng.bz/OMAn](http://mng.bz/OMAn)
    |'
- en: Exercise 5 ■ Pig Latin
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5 ■ 猪拉丁语
- en: 'Pig Latin ([http://mng.bz/YrON](http://mng.bz/YrON)) is a common children’s
    “secret” language in English-speaking countries. (It’s normally secret among children
    who forget that their parents were once children themselves.) The rules for translating
    words from English into Pig Latin are quite simple:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 猪拉丁语 ([http://mng.bz/YrON](http://mng.bz/YrON)) 是英语国家中常见的儿童“秘密”语言。（通常在孩子们忘记他们的父母曾经也是孩子的情况下是保密的。）将单词从英语翻译成猪拉丁语的规则相当简单：
- en: If the word begins with a vowel (a, e, i, o, or u), add “way” to the end of
    the word. So “air” becomes “airway” and “eat” becomes “eatway.”
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果单词以元音字母（a、e、i、o 或 u）开头，则在单词末尾添加“way”。因此，“air”变成“airway”，“eat”变成“eatway”。
- en: If the word begins with any other letter, then we take the first letter, put
    it on the end of the word, and then add “ay.” Thus, “python” becomes “ythonpay”
    and “computer” becomes “omputercay.”
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果单词以任何其他字母开头，那么我们就取第一个字母，将其放在单词的末尾，然后加上“ay。”因此，“python”变成“ythonpay”，而“computer”变成“omputercay”。
- en: (And yes, I recognize that the rules can be made more sophisticated. Let’s keep
    it simple for the purposes of this exercise.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，我承认规则可以更加复杂。为了这个练习的目的，让我们保持简单。）
- en: For this exercise, write a Python function (`pig_latin`) that takes a string
    as input, assumed to be an English word. The function should return the translation
    of this word into Pig Latin. You may assume that the word contains no capital
    letters or punctuation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，编写一个 Python 函数（`pig_latin`），它接受一个字符串作为输入，假设这是一个英文单词。该函数应将此单词翻译成猪拉丁语。你可以假设该单词不包含大写字母或标点符号。
- en: This exercise isn’t meant to help you translate documents into Pig Latin for
    your job. (If that is your job, then I really have to question your career choices.)
    However, it demonstrates some of the powerful techniques that you should know
    when working with sequences, including searches, iteration, and slices. It’s hard
    to imagine a Python program that doesn’t include any of these techniques.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习并不是为了帮助你将文档翻译成猪拉丁语用于你的工作。（如果你的工作是这样，那么我真的很想质疑你的职业选择。）然而，它展示了你在处理序列时应了解的一些强大技术，包括搜索、迭代和切片。很难想象一个不包含这些技术的
    Python 程序。
- en: Working it out
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: This has long been one of my favorite exercises to give students in my introductory
    programming classes. It was inspired by Brian Harvey, whose excellent series *Computer
    Science Logo Style* ([http://mng.bz/gyNl](http://mng.bz/gyNl)), has long been
    one of my favorites for beginning programmers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这一直是我给入门级编程课程学生出的最喜欢的练习之一。它受到了布莱恩·哈维的启发，他的优秀系列 *计算机科学标志风格* ([http://mng.bz/gyNl](http://mng.bz/gyNl))，长期以来一直是我最喜欢的初学者编程资源。
- en: The first thing to consider for this solution is how we’ll check to make sure
    that `word[0]`, the first letter in `word`, is a vowel. I’ve often seen people
    start to use a loop, as in
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个解决方案，首先需要考虑的是如何检查 `word[0]`，即 `word` 中的第一个字母是否为元音。我经常看到人们开始使用循环，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even if that code will work, it’s already starting to look a bit clumsy and
    convoluted.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这段代码会工作，它已经开始看起来有些笨拙和复杂。
- en: 'Another solution that I commonly see is this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到的一种解决方案是：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As I like to say to my students, “Unfortunately, this code works.” Why do I
    dislike this code so much? Not only is it longer than necessary, but it’s highly
    repetitive. The don’t repeat yourself (DRY) rule should always be at the back
    of your mind when writing code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我经常对我的学生说的，“不幸的是，这段代码是可行的。”为什么我这么不喜欢这段代码？这不仅比必要的要长，而且高度重复。在编写代码时，始终要牢记“不要重复自己”（DRY）规则。
- en: Moreover, Python programs tend to be short. If you find yourself repeating yourself
    and writing an unusually long expression or condition, you’ve likely missed a
    more Pythonic way of doing things.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 程序往往比较简短。如果你发现自己正在重复自己，并且写出了异常长的表达式或条件，那么你很可能错过了更 Pythonic 的做事方式。
- en: 'We can take advantage of the fact that Python sees a string as a sequence,
    and use the built-in `in` operator to search for `word[0]` in a string containing
    the vowels:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 Python 将字符串视为序列的事实，并使用内置的 `in` 操作符在包含元音的字符串中搜索 `word[0]`：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That single line has the combined advantage of being readable, short, accurate,
    and fairly efficient. True, the time needed to search through a string--or any
    other Python sequence--rises along with the length of the sequence. But such linear
    time, sometimes expressed as `O(n)`, is often good enough, especially when the
    strings through which we’ll be searching are fairly short.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码具有可读性、简短、准确和相对高效的结合优势。诚然，搜索字符串（或任何其他 Python 序列）所需的时间会随着序列长度的增加而增加。但这样的线性时间，有时表示为
    `O(n)`，通常足够好，尤其是当我们将要搜索的字符串相对较短时。
- en: '*Tip* The `in` operator works on all sequences (strings, lists, and tuples)
    and many other Python collections. It effectively runs a `for` loop on the elements.
    Thus, using `in` on a dict will work but will only search through the keys, ignoring
    the values.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示* `in` 操作符适用于所有序列（字符串、列表和元组）以及许多其他 Python 集合。它实际上在元素上运行一个 `for` 循环。因此，在字典上使用
    `in` 也会工作，但只会搜索键，忽略值。'
- en: Once we’ve determined whether the word begins with a vowel, we can apply the
    appropriate Pig Latin rule.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定单词是否以元音开头，我们就可以应用适当的猪拉丁语规则。
- en: Slices
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 切片
- en: All of Python’s sequences--strings, lists, and tuples--support *slicing*. The
    idea is that if I say
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的所有序列——字符串、列表和元组——都支持 *切片*。其想法是，如果我这么说
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Returns “cdef”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回“cdef”
- en: 'I’ll get all of the characters from `s`, starting at index 2 and until (but
    not including) index 6, meaning the string `cdef`. A slice can also indicate the
    step size:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从 `s` 中获取所有字符，从索引 2 开始，直到（但不包括）索引 6，这意味着字符串 `cdef`。切片还可以指示步长：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Returns “ce”
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回“ce”
- en: This code will print the string `ce`, since we start at index 2 (`c`), move
    forward two indexes to `e`, and then reach the end.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将打印字符串 `ce`，因为我们从索引 2 (`c`) 开始，向前移动两个索引到 `e`，然后到达末尾。
- en: Slices are Python’s way of retrieving a subset of elements from a sequence.
    You can even omit the starting and/or ending index to indicate that you want to
    start from the sequence’s first element or end at its last element. For example,
    we can get every other character from our string with
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是 Python 从序列中检索元素子集的方式。你甚至可以省略起始和/或结束索引，以表示你希望从序列的第一个元素开始或在其最后一个元素结束。例如，我们可以从我们的字符串中获取每隔一个字符，如下所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Returns “aceg”
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回“aceg”
- en: Solution
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    XP5M](http://mng.bz/XP5M).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行此代码的版本，网址为 [http://mng.bz/XP5M](http://mng.bz/XP5M)。
- en: Screencast solution
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此简短视频教程，了解解决方案：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'It’s hard to exaggerate just how often you’ll need to work with strings in
    Python. Moreover, Python is often used in text analysis and manipulation. Here
    are some ways that you can extend the exercise to push yourself further:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你将非常频繁地需要处理字符串。此外，Python 经常用于文本分析和处理。以下是一些你可以扩展练习的方法，以进一步挑战自己：
- en: '*Handle capitalized words* --If a word is capitalized (i.e., the first letter
    is capitalized, but the rest of the word isn’t), then the Pig Latin translation
    should be similarly capitalized.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理首字母大写的单词* -- 如果一个单词首字母大写（即第一个字母大写，但单词的其他部分不是），那么 Pig Latin 翻译应该相应地首字母大写。'
- en: '*Handle punctuation* --If a word ends with punctuation, then that punctuation
    should be shifted to the end of the translated word.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理标点符号* -- 如果一个单词以标点符号结尾，那么该标点符号应移至翻译单词的末尾。'
- en: '*Consider an alternative version of Pig Latin* --We don’t check to see if the
    first letter is a vowel, but, rather, we check to see if the word contains two
    different vowels. If it does, we don’t move the first letter to the end. Because
    the word “wine” contains two different vowels (“i” and “e”), we’ll add “way” to
    the end of it, giving us “wineway.” By contrast, the word “wind” contains only
    one vowel, so we would move the first letter to the end and add “ay,” rendering
    it “indway.” How would you check for two different vowels in the word? (Hint:
    sets can come in handy here.)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*考虑 Pig Latin 的另一种版本* -- 我们不检查第一个字母是否为元音，而是检查单词是否包含两个不同的元音。如果是这样，我们不会将第一个字母移动到末尾。因为单词“wine”包含两个不同的元音（“i”和“e”），所以我们在其末尾添加“way”，得到“wineway”。相比之下，单词“wind”只包含一个元音，所以我们会将第一个字母移动到末尾并添加“ay”，得到“indway”。你将如何检查单词中是否有两个不同的元音？（提示：集合在这里很有用。）'
- en: Immutable?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变？
- en: 'One of the most important concepts in Python is the distinction between mutable
    and immutable data structures. The basic idea is simple: if a data structure is
    immutable, then it can’t be changed--ever.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中最重要的概念之一是可变和不可变数据结构的区别。基本思想很简单：如果一个数据结构是不可变的，那么它永远不能被更改。
- en: 'For example, you might define a string and then try to change it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能会定义一个字符串，然后尝试修改它：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ You’ll get an exception when running this code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 运行此代码时会抛出异常。
- en: But this code won’t work; you’ll get an exception, with Python telling you that
    you’re not allowed to modify a string.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但此代码将无法工作；你会得到一个异常，Python 会告诉你不允许修改字符串。
- en: Many data structures in Python are immutable, including such basics as integers
    and Boolean values. But strings are where people get tripped up most often, partly
    because we use strings so often, and partly because many other languages have
    mutable strings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的许多数据结构是不可变的，包括像整数和布尔值这样的基本数据结构。但字符串是人们最常出错的地方，部分原因是我们经常使用字符串，部分原因是因为许多其他语言都有可变字符串。
- en: Why would Python do such a thing? There are a number of reasons, chief among
    which is that it makes the implementation more efficient. But it also has to do
    with the fact that strings are the most common type used as dict keys. If strings
    were mutable, they wouldn’t be allowed as dict keys--or we’d have to allow for
    mutable keys in dicts, which would create a whole host of other issues.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python为什么要这样做呢？原因有很多，其中最主要的是这使实现更加高效。但这也与字符串是最常用的作为字典键的类型有关。如果字符串是可变的，它们就不能作为字典键--或者我们不得不允许字典中有可变键，这将会引发一系列其他问题。
- en: Because immutable data can’t be changed, we can make a number of assumptions
    about it. If we pass an immutable type to a function, then the function won’t
    modify it. If we share immutable data across threads, then we don’t have to worry
    about locking it, because it can’t be changed. And if we invoke a method on an
    immutable type, then we get a new object back--because we can’t modify immutable
    data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可变数据不能被更改，我们可以对它做出一些假设。如果我们向函数传递一个不可变类型，那么函数不会修改它。如果我们通过线程共享不可变数据，那么我们不必担心锁定它，因为它们不能被更改。而且如果我们对一个不可变类型调用方法，那么我们会得到一个新的对象--因为我们不能修改不可变数据。
- en: Learning to work with immutable strings takes some time, but the trade-offs
    are generally worthwhile. If you find yourself needing a mutable string type,
    then you might want to look at StringIO ([http://mng.bz/045x](http://mng.bz/045x)),
    which provides file-like access to a mutable, in-memory type.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 学习使用不可变字符串需要一些时间，但权衡通常是值得的。如果你发现自己需要可变字符串类型，那么你可能想看看StringIO ([http://mng.bz/045x](http://mng.bz/045x))，它提供了对可变内存类型的文件样式的访问。
- en: Many newcomers to Python think that *immutable* is just another word for *constant*,
    but it isn’t. Constants, which many programming languages offer, permanently connect
    a name with a value. In Python, there’s no such thing as a constant; you can always
    reassign a name to point to a new value. But you can’t modify a string or a tuple,
    no matter how hard you try; for example
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python的新手认为*不可变*只是*常量*的另一个词，但这并不是。许多编程语言提供的常量，永久地将一个名称与一个值连接起来。在Python中，没有这样的常量；你总是可以将一个名称重新分配以指向新的值。但你不能修改字符串或元组，无论你多么努力尝试；例如
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Not allowed, since strings are immutable
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不允许，因为字符串是不可变的
- en: ❷ The variables s and t now refer to the same string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 变量s和t现在指向同一个字符串。
- en: ❸ The variable s now refers to the new string, but t continues to refer to the
    old string, unchanged.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 变量s现在指向新的字符串，但t继续指向旧的字符串，没有改变。
- en: Exercise 6 ■ Pig Latin sentence
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6 ■ 猪拉丁语句子
- en: 'Now that you’ve successfully written a translator for a single English word,
    let’s make things more difficult: translate a series of English words into Pig
    Latin. Write a function called `pl_sentence` that takes a string containing several
    words, separated by spaces. (To make things easier, we won’t actually ask for
    a real sentence. More specifically, there will be no capital letters or punctuation.)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功编写了一个单词翻译器，让我们使事情更难一些：将一系列英语单词翻译成猪拉丁语。编写一个名为`pl_sentence`的函数，它接受一个包含多个单词的字符串，单词之间由空格分隔。（为了简化问题，我们实际上不会要求一个真正的句子。更具体地说，不会有大写字母或标点符号。）
- en: So, if someone were to call
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果有人调用
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: the output would be
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会是
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Print the output on a single line, rather than with each word on a separate
    line.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出打印在同一行上，而不是每个单词一行。
- en: This exercise might seem, at least superficially, like the previous one. But
    here, the emphasis is not on the Pig Latin translation. Rather, it’s on the ways
    we typically use loops in Python, and how loops go together with breaking strings
    apart and putting them back together again. It’s also common to want to take a
    sequence of strings and print them out on a single line. There are a few ways
    to do this, and I want you to consider the advantages and disadvantages of each
    one.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习可能看起来，至少表面上，与上一个练习相似。但这里的重点不是猪拉丁语的翻译。而是我们通常在Python中使用循环的方式，以及循环如何与拆分和重新组合字符串结合在一起。通常还希望将一系列字符串打印在同一行上。有几种方法可以做到这一点，我希望你考虑每种方法的优缺点。
- en: Working it out
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: The core of the solution is nearly identical to the one in the previous section,
    in which we translated a single word into Pig Latin. Once again, we’re getting
    a text string as input from the user. The difference is that, in this case, rather
    than treating the string as a single word, we’re treating it as a sentence--meaning
    that we need to separate it into individual words. We can do that with `str.split`
    ([http://mng.bz/aR4z](http://mng.bz/aR4z)). `str.split` can take an argument,
    which determines which string should be used as the separator between fields.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的核心几乎与上一节中的相同，其中我们将单个单词翻译成猪拉丁语。再次，我们正在从用户那里获取文本字符串作为输入。不同之处在于，在这种情况下，我们不是将字符串视为单个单词，而是将其视为一个句子——这意味着我们需要将其分解成单个单词。我们可以使用
    `str.split` ([http://mng.bz/aR4z](http://mng.bz/aR4z)) 来做到这一点。`str.split` 可以接受一个参数，它决定了哪个字符串应该用作字段之间的分隔符。
- en: 'It’s often the case that you want to use any and all whitespace characters,
    regardless of how many there are, to split the fields. In such a case, don’t pass
    an argument at all; Python will then treat any number of spaces, tabs, and newlines
    as a single separation character. The difference can be significant:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你可能希望使用任何数量的空白字符（无论多少）来分割字段。在这种情况下，不要传递任何参数；Python 将将任何数量的空格、制表符和换行符视为单个分隔符。这种差异可能是显著的：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Two spaces separating
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 两个空格分隔
- en: ❷ Returns ['abc', '', 'def ', '', 'ghi']
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回值 ['abc', '', 'def ', '', 'ghi']
- en: ❸ Returns ['abc', 'def', 'ghi']
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回值 ['abc', 'def', 'ghi']
- en: '*Note* If you don’t pass any arguments to `str.split`, it’s effectively the
    same as passing `None`. You can pass any string to `str.split`, not just a single-character
    string. This means that if you want to split on `::`, you can do that. However,
    you can’t split on more than one thing, saying that both `,` and `::` are field
    separators. To do that, you’ll need to use regular expressions and the `re.split`
    function in the Python standard library, described here: [http://mng.bz/K2RK](http://mng.bz/K2RK).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 如果你没有向 `str.split` 传递任何参数，它实际上等同于传递 `None`。你可以向 `str.split` 传递任何字符串，而不仅仅是单字符字符串。这意味着，如果你想根据
    `::` 来分割，你可以这样做。然而，你不能根据多个东西来分割，比如说 ``,` 和 `::` 都是字段分隔符。要做到这一点，你需要使用正则表达式和 Python
    标准库中的 `re.split` 函数，这里有所描述：[http://mng.bz/K2RK](http://mng.bz/K2RK)。'
- en: Thus, we can take the user’s input and break it into words--again, assuming
    that there are no punctuation characters--and then translate each individual word
    into Pig Latin. Whereas the one-word version of our program could simply print
    its output right away, this one needs to store the accumulated output and then
    print it all at once. It’s certainly possible to use a string for that, and to
    invoke `+=` on the string with each iteration. But as a general rule, it’s not
    a good idea to build strings in that way. Rather, you should add elements to a
    list using `list.append` ([http://mng.bz/Mdlm](http://mng.bz/Mdlm)) and then invoke
    `str.join` to turn the list’s elements into a long string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以获取用户的输入并将其分解成单词——再次假设没有标点符号——然后逐个将每个单词翻译成猪拉丁语。而我们的程序的单词版本可以简单地立即打印输出，而这个版本需要存储累积的输出，然后一次性打印出来。当然，可以使用字符串来做这件事，并在每次迭代中调用
    `+=`。但作为一个一般规则，以这种方式构建字符串并不是一个好主意。相反，你应该使用 `list.append` 向列表中添加元素([http://mng.bz/Mdlm](http://mng.bz/Mdlm))，然后调用
    `str.join` 将列表的元素转换成长字符串。
- en: That’s because strings are immutable, and `+=` on a string forces Python to
    create a new string. If we’re adding to a string many times, then each time will
    trigger the creation of a new object whose contents will be larger than the previous
    iteration. By contrast, lists are mutable, and adding to them with `list.append`
    is relatively inexpensive, in both memory and computation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为字符串是不可变的，而字符串上的 `+=` 迫使 Python 创建一个新的字符串。如果我们多次向字符串中添加内容，那么每次都会触发创建一个新对象，其内容将比前一次迭代更大。相比之下，列表是可变的，使用
    `list.append` 向其添加内容在内存和计算上相对便宜。
- en: Solution
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/yydE](http://mng.bz/yydE).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中尝试这个代码版本：[http://mng.bz/yydE](http://mng.bz/yydE)。
- en: Screencast solution
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Splitting, joining, and manipulating strings are common actions in Python.
    Here are some additional activities you can try to push yourself even further:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，拆分、连接和操作字符串是常见的操作。这里有一些你可以尝试的额外活动来进一步挑战自己：
- en: Take a text file, creating (and printing) a nonsensical sentence from the nth
    word on each of the first 10 lines, where n is the line number.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取一个文本文件，从每行第 n 个单词开始创建（并打印）一个无意义的句子，其中 n 是行号。
- en: Write a function that transposes a list of strings, in which each string contains
    multiple words separated by whitespace. Specifically, it should perform in such
    a way that if you were to pass the list `['abc` `def` `ghi',` `'jkl` `mno` `pqr',`
    `'stu` `vwx` `yz']` to the function, it would return `['abc` `jkl` `stu',` `'def`
    `mno` `vwx',` `'ghi` `pqr` `yz']`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，将包含多个单词（由空格分隔）的字符串列表进行转置。具体来说，它应该以这种方式执行，即如果你将列表 `['abc` `def` `ghi',`
    `'jkl` `mno` `pqr',` `'stu` `vwx` `yz']` 传递给该函数，它将返回 `['abc` `jkl` `stu',` `'def`
    `mno` `vwx',` `'ghi` `pqr` `yz']`。
- en: Read through an Apache logfile. If there is a 404 error--you can just search
    for `'` `404` `'`, if you want--display the IP address, which should be the first
    element.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细阅读 Apache 日志文件。如果出现 404 错误——如果你想搜索的话，可以搜索 `'` `404` `'`——显示 IP 地址，它应该是第一个元素。
- en: Exercise 7 ■ Ubbi Dubbi
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7 ■ Ubbi Dubbi
- en: When they hear that Python’s strings are immutable, many people wonder how the
    language can be used for text processing. After all, if you can’t modify strings,
    then how can you do any serious work with them?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们听说 Python 的字符串是不可变的，很多人会想知道这种语言如何用于文本处理。毕竟，如果你不能修改字符串，那么你怎么能对它们进行任何严肃的工作呢？
- en: Moreover, there are times when a simple `for` loop, as we used with the Pig
    Latin examples, won’t work. If we’re modifying each word only once, then that’s
    fine, but if we’re potentially modifying it several times, we have to make sure
    that each modification won’t affect future modifications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时候简单的 `for` 循环，就像我们在 Pig Latin 示例中使用的那样，可能不起作用。如果我们只修改每个单词一次，那没问题，但如果可能要修改多次，我们必须确保每次修改都不会影响未来的修改。
- en: This exercise is meant to help you practice thinking in this way. Here, you’ll
    implement a translator from English into another secret children’s language, Ubbi
    Dubbi ([http://mng.bz/90zl](http://mng.bz/90zl)). (This was popularized on the
    wonderful American children’s program *Zoom*, which was on television when I was
    growing up.) The rules of Ubbi Dubbi are even simpler than those of Pig Latin,
    although programming a translator is more complex and requires a bit more thinking.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习旨在帮助你练习这种思维方式。在这里，你将实现一个从英语翻译到另一种秘密儿童语言 Ubbi Dubbi 的翻译器（[http://mng.bz/90zl](http://mng.bz/90zl))。（这在美国儿童节目
    *Zoom* 中流行起来，这个节目在我成长的时候在电视上播出。）Ubbi Dubbi 的规则甚至比 Pig Latin 的规则还要简单，尽管编写翻译器更为复杂，需要更多的思考。
- en: In Ubbi Dubbi, every vowel (a, e, i, o, or u) is prefaced with `ub`. Thus `milk`
    becomes `mubilk` (`m-ub-ilk`) and `program` becomes `prubogrubam` (`prub-ogrub-am`).
    In theory, you only put an `ub` before every vowel *sound*, rather than before
    each vowel. Given that this is a book about Python and not linguistics, I hope
    that you’ll forgive this slight difference in definition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubbi Dubbi 中，每个元音（a、e、i、o 或 u）前面都加上 `ub`。因此 `milk` 变成 `mubilk`（`m-ub-ilk`），而
    `program` 变成 `prubogrubam`（`prub-ogrub-am`）。从理论上讲，你只需要在每个元音 *声音* 前面加上 `ub`，而不是在每个元音前。鉴于这是一本关于
    Python 的书，而不是语言学，我希望你能原谅这个定义上的微小差异。
- en: Ubbi Dubbi is enormously fun to speak, and it’s somewhat magical if and when
    you can begin to understand someone else speaking it. Even if you don’t understand
    it, Ubbi Dubbi sounds extremely funny. See some YouTube videos on the subject,
    such as [http://mng.bz/aRMY](http://mng.bz/aRMY), if you need convincing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Ubbi Dubbi 说话非常有趣，如果你能开始理解别人说这种语言，那就更有魔力了。即使你不理解它，Ubbi Dubbi 听起来也非常有趣。如果你需要说服自己，可以看看一些
    YouTube 视频，例如 [http://mng.bz/aRMY](http://mng.bz/aRMY)。
- en: For this exercise, you’ll write a function (called `ubbi_dubbi`) that takes
    a single word (string) as an argument. It returns a string, the word’s translation
    into Ubbi Dubbi. So if the function is called with `octopus`, the function will
    return the string `uboctubopubus`. And if the user passes the argument `elephant`,
    you’ll output `ubelubephubant`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你需要编写一个函数（称为 `ubbi_dubbi`），它接受一个单词（字符串）作为参数。它返回一个字符串，即单词翻译成 Ubbi Dubbi
    的形式。所以如果函数用 `octopus` 调用，函数将返回字符串 `uboctubopubus`。如果用户传递参数 `elephant`，你将输出 `ubelubephubant`。
- en: As with the original Pig Latin translator, you can ignore capital letters, punctuation,
    and corner cases, such as multiple vowels combining to create a new sound. When
    you do have two vowels next to one another, preface each of them with `ub`. Thus,
    `soap` will become `suboubap`, despite the fact that `oa` combines to a single
    vowel sound.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始的猪拉丁语翻译器一样，你可以忽略大写字母、标点符号和特殊情况，比如多个元音结合产生新的声音。当你有两个相邻的元音时，在每个元音前加上`ub`。因此，`soap`将变成`suboubap`，尽管`oa`结合成一个元音音素。
- en: Much like the “Pig Latin sentence” exercise, this brings to the forefront the
    various ways we often need to scan through strings for particular patterns, or
    translate from one Python data structure or pattern to another, and how iterations
    can play a central role in doing so.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这与“猪拉丁语句子”练习非常相似，它将我们经常需要扫描字符串以查找特定模式的各种方法，或者将一个Python数据结构或模式转换为另一个数据结构或模式，以及迭代如何在这个过程中发挥核心作用的问题提到了前面。
- en: Working it out
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: The task here is to ask the user for a word, and then to translate that word
    into Ubbi Dubbi. This is a slightly different task than we had with Pig Latin,
    because we need to operate on a letter-by-letter basis. We can’t simply analyze
    the word and produce output based on the entire word. Moreover, we have to avoid
    getting ourselves into an infinite loop, in which we try to add `ub` before the
    `u` in `ub`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的任务是要求用户输入一个单词，然后将该单词翻译成Ubbi Dubbi。这与猪拉丁语的任务略有不同，因为我们需要逐字母操作。我们不能简单地分析单词并基于整个单词生成输出。此外，我们必须避免陷入无限循环，在尝试在`ub`中的`u`前添加`ub`。
- en: The solution is to iterate over each character in `word`, adding it to a list,
    `output`. If the current character is a vowel, then we add `ub` before the letter.
    Otherwise, we just add the letter. At the end of the program, we join and then
    print the letters together. This time, we don’t join the letters together with
    a space character (`'` `'`), but rather with an empty string (`'` `'`). This means
    that the resulting string will consist of the letters joined together with nothing
    between them--or, as we often call such collections, a *word*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是遍历`word`中的每个字符，将其添加到列表`output`中。如果当前字符是元音，则我们在字母前添加`ub`。否则，我们只添加字母。在程序结束时，我们将字母连接起来并打印出来。这次，我们不是用空格字符(`'
    '` `'`)连接字母，而是用空字符串(`' '` `'`)连接。这意味着生成的字符串将由字母连接而成，字母之间没有任何间隔--或者，正如我们经常称呼这样的集合，一个*单词*。
- en: Solution
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Why append to a list, and not to a string? To avoid allocating too much memory.
    For short strings, it’s not a big deal. But for long loops and large strings,
    it’s a bad idea.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为什么要将内容添加到列表中，而不是字符串中？为了避免分配过多的内存。对于短字符串来说，这并不是什么大问题。但是对于长循环和大字符串来说，这可不是什么好主意。
- en: You can work through this code in the Python Tutor at [http://mng.bz/eQJZ](http://mng.bz/eQJZ).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行这段代码：[http://mng.bz/eQJZ](http://mng.bz/eQJZ)。
- en: Screencast solution
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这段关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'It’s common to want to replace one value with another in strings. Python has
    a few different ways to do this. You can use `str.replace` ([http://mng.bz/WPe0](http://mng.bz/WPe0))
    or `str .translate` ([http://mng.bz/8pyP](http://mng.bz/8pyP)), two string methods
    that translate strings and sets of characters, respectively. But sometimes, there’s
    no choice but to iterate over a string, look for the pattern we want, and then
    append the modified version to a list that we grow over time:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中替换一个值与另一个值是很常见的。Python有几种不同的方法来做这件事。你可以使用`str.replace` ([http://mng.bz/WPe0](http://mng.bz/WPe0))
    或 `str.translate` ([http://mng.bz/8pyP](http://mng.bz/8pyP))，这两个字符串方法分别用于转换字符串和字符集。但有时，别无选择，只能遍历字符串，查找我们想要的模式，然后将修改后的版本追加到一个我们逐渐增长的列表中：
- en: '*Handle capitalized words* --If a word is capitalized (i.e., the first letter
    is capitalized, but the rest of the word isn’t), then the Ubbi Dubbi translation
    should be similarly capitalized.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理大写单词* --如果一个单词是大写的（即，第一个字母是大写的，但单词的其他部分不是），那么Ubbi Dubbi翻译应该相应地大写。'
- en: '*Remove author names* --In academia, it’s common to remove the authors’ names
    from a paper submitted for peer review. Given a string containing an article and
    a separate list of strings containing authors’ names, replace all names in the
    article with `_` characters.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移除作者姓名* ——在学术界，从提交给同行评审的论文中移除作者姓名是很常见的。给定一个包含文章和包含作者姓名的单独字符串列表的字符串，将文章中的所有姓名替换为
    `_` 字符。'
- en: '*URL-encode characters* --In URLs, we often replace special and nonprintable
    characters with a `%` followed by the character’s ASCII value in hexadecimal.
    For example, if a URL is to include a space character (ASCII 32, aka 0x20), we
    replace it with `%20`. Given a string, URL-encode any character that isn’t a letter
    or number. For the purposes of this exercise, we’ll assume that all characters
    are indeed in ASCII (i.e., one byte long), and not multibyte UTF-8 characters.
    It might help to know about the `ord` ([http://mng.bz/EdnJ](http://mng.bz/EdnJ))
    and `hex` ([http://mng .bz/nPxg](http://mng.bz/nPxg)) functions.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*URL 编码字符* ——在 URL 中，我们经常用 `%` 后跟字符的十六进制 ASCII 值来替换特殊和非可打印字符。例如，如果 URL 要包含一个空格字符（ASCII
    32，即 0x20），我们将其替换为 `%20`。给定一个字符串，对任何不是字母或数字的字符进行 URL 编码。为了这个练习的目的，我们假设所有字符确实都是
    ASCII（即，一个字节长），而不是多字节的 UTF-8 字符。了解 `ord` ([http://mng.bz/EdnJ](http://mng.bz/EdnJ))
    和 `hex` ([http://mng.bz/nPxg](http://mng.bz/nPxg)) 函数可能会有所帮助。'
- en: Exercise 8 ■ Sorting a string
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8 ■ 排序字符串
- en: If strings are immutable, then does this mean we’re stuck with them forever,
    precisely as they are? Kind of--we can’t change the strings themselves, but we
    can create new strings based on them, using a combination of built-in functions
    and string methods. Knowing how to work around strings’ immutability and piece
    together functionality that effectively changes strings, even though they’re immutable,
    is a useful skill to have.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串是不可变的，那么这难道意味着我们将永远被它们困住，就像它们现在这样？有点——我们无法更改字符串本身，但我们可以使用内置函数和字符串方法组合来创建基于它们的新的字符串。了解如何绕过字符串的不可变性并组合功能，即使它们是不可变的，也能有效地更改字符串，这是一种有用的技能。
- en: In this exercise, you’ll explore this idea by writing a function, `strsort`,
    that takes a single string as its input and returns a string. The returned string
    should contain the same characters as the input, except that its characters should
    be sorted in order, from the lowest Unicode value to the highest Unicode value.
    For example, the result of invoking `strsort('cba')` will be the string `abc`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你需要通过编写一个名为 `strsort` 的函数来探索这个想法，该函数接受一个字符串作为输入并返回一个字符串。返回的字符串应包含与输入相同的字符，但其字符应按顺序排序，从最低的
    Unicode 值到最高的 Unicode 值。例如，调用 `strsort('cba')` 的结果将是字符串 `abc`。
- en: Working it out
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution’s implementation of `strsort` takes advantage of the fact that
    Python strings are sequences. Normally, we think of this as relevant in a `for`
    loop, in that we can iterate over the characters in a string. However, we don’t
    need to restrict ourselves to such situations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`strsort` 函数的实现利用了 Python 字符串是序列的事实。通常，我们认为这与 `for` 循环相关，因为我们可以遍历字符串中的字符。然而，我们不需要将自己限制在这些情况下。'
- en: For example, we can use the built-in `sorted` ([http://mng.bz/pBEG](http://mng.bz/pBEG))
    function, which takes an iterable--which means not only a sequence, but anything
    over which we can iterate, such as a set of files--and returns its elements in
    sorted order. Invoking `sorted` in our string will thus do the job, in that it
    will sort the characters in Unicode order. However, it returns a list, rather
    than a string.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用内置的 `sorted` ([http://mng.bz/pBEG](http://mng.bz/pBEG)) 函数，它接受一个可迭代对象——这意味着不仅是一个序列，而且是我们能遍历的任何东西，比如一组文件——并按排序顺序返回其元素。因此，在我们的字符串上调用
    `sorted` 将完成这项工作，因为它将以 Unicode 顺序对字符进行排序。然而，它返回的是一个列表，而不是一个字符串。
- en: To turn our list into a string, we use the `str.join` method ([http://mng.bz/gyYl](http://mng.bz/gyYl)).
    We use an empty string (`''`) as the glue we’ll use to join the elements, thus
    returning a new string whose characters are the same as the input string, but
    in sorted order.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的列表转换成字符串，我们使用 `str.join` 方法 ([http://mng.bz/gyYl](http://mng.bz/gyYl))。我们使用一个空字符串
    (`''`) 作为我们将用来连接元素的粘合剂，从而返回一个新的字符串，其字符与输入字符串相同，但按排序顺序排列。
- en: Unicode
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode
- en: What is Unicode? The idea is a simple one, but the implementation can be extremely
    difficult and is confusing to many developers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 是什么？这个想法很简单，但实现可能极其困难，并且对许多开发者来说很令人困惑。
- en: The idea behind Unicode is that we should be able to use computers to represent
    any character used in any language from any time. This is a very important goal,
    in that it means we won’t have problems creating documents in which we want to
    show Russian, Chinese, and English on the same page. Before Unicode, mixing character
    sets from a number of languages was difficult or impossible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode背后的理念是我们应该能够使用计算机来表示任何语言中使用的任何字符，无论其使用时间。这是一个非常重要的目标，因为它意味着我们不会在创建想要在同一页面上显示俄语、中文和英语的文档时遇到问题。在Unicode出现之前，混合来自多种语言的字符集是困难的，甚至是不可能的。
- en: Unicode assigns each character a unique number. But those numbers can (as you
    imagine) get very big. Thus, we have to take the Unicode character number (known
    as a *code point*) and translate it into a format that can be stored and transmitted
    as bytes. Python and many other languages use what’s known as UTF-8, which is
    a *variable-length encoding*, meaning that different characters might require
    different numbers of bytes. Characters that exist in ASCII are encoded into UTF-8
    with the same number they use in ASCII, in one byte. French, Spanish, Hebrew,
    Arabic, Greek, and Russian all use two bytes for their non-ASCII characters. And
    Chinese, as well as your childrens' emojis, are three bytes or more.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode为每个字符分配一个唯一的数字。但这些数字（正如你所想象的那样）可以变得非常大。因此，我们必须将Unicode字符数字（称为*码点*）转换为一种可以存储和传输为字节的格式。Python和许多其他语言使用的是UTF-8，这是一种*可变长度编码*，意味着不同的字符可能需要不同数量的字节。存在于ASCII中的字符使用ASCII中相同的数字编码为UTF-8，占用一个字节。法语、西班牙语、希伯来语、阿拉伯语、希腊语和俄语都使用两个字节来表示它们的非ASCII字符。而中文以及孩子们的表情符号则需要三个字节或更多。
- en: How much does this affect us? Both a lot and a little. On the one hand, it’s
    convenient to be able to work with different languages so easily. On the other
    hand, it’s easy to forget that there’s a difference between bytes and characters,
    and that you sometimes (e.g., when working with files on disk) need to translate
    from bytes to characters, or vice versa.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们有多大影响？既多又少。一方面，能够轻松地处理不同的语言是非常方便的。另一方面，很容易忘记字节和字符之间的区别，有时（例如，当处理磁盘上的文件时）你需要从字节转换为字符，或者相反。
- en: 'For further details about characters versus strings, and the way Python stores
    characters in our strings, I recommend this talk by Ned Batchelder, from PyCon
    2012: [http://mng .bz/NKdD](http://mng.bz/NKdD).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符与字符串的进一步细节，以及Python如何存储字符串中的字符，我推荐Ned Batchelder在PyCon 2012上的这个演讲：[http://mng.bz/NKdD](http://mng.bz/NKdD)。
- en: Solution
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can work through this code in the Python Tutor at [http://mng.bz/pBd0](http://mng.bz/pBd0).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行这段代码：[http://mng.bz/pBd0](http://mng.bz/pBd0)。
- en: Screencast solution
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: This exercise is designed to give you additional reminders that strings are
    sequences and can thus be put wherever other sequences (lists and tuples) can
    be used. We don’t often think in terms of sorting a string, but there’s no difference
    between running `sorted` on a string, a list, or a tuple. The elements (in the
    case of a string, the characters) are returned in sorted order.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习旨在给你额外的提醒，即字符串是序列，因此可以在其他序列（列表和元组）可以使用的任何地方使用。我们很少从排序字符串的角度思考，但在对字符串、列表或元组运行`sorted`之间没有区别。元素（在字符串的情况下，是字符）以排序顺序返回。
- en: However, `sorted` ([http://mng.bz/pBEG](http://mng.bz/pBEG)) returns a list,
    and we wanted to get a string. We thus needed to turn the resulting list back
    into a string--something that `str.join` is designed to do. `str.split` ([http://mng.bz/aR4z](http://mng.bz/aR4z))
    and `str.join` ([http:// mng.bz/gyYl](http://mng.bz/gyYl)) are two methods with
    which you should become intimately familiar because they’re so useful and help
    in so many cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`sorted`([http://mng.bz/pBEG](http://mng.bz/pBEG))返回一个列表，而我们想要得到一个字符串。因此，我们需要将得到的列表转换回字符串——这正是`str.join`设计来做的。`str.split`([http://mng.bz/aR4z](http://mng.bz/aR4z))和`str.join`([http://
    mng.bz/gyYl](http://mng.bz/gyYl))是两个你应该非常熟悉的方法，因为它们非常有用，并且在许多情况下都很有帮助。
- en: 'Consider a few other variations of, and extensions to, this exercise, which
    also use `str.split` and `str.join`, as well as `sorted`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个练习的几种其他变体和扩展，它们也使用了`str.split`和`str.join`，以及`sorted`：
- en: Given the string “Tom Dick Harry,” break it into individual words, and then
    sort those words alphabetically. Once they’re sorted, print them with commas (`,`)
    between the names.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定字符串“Tom Dick Harry”，将其分解成单个单词，然后按字母顺序对这些单词进行排序。一旦排序完成，用逗号（`,`）在名字之间打印它们。
- en: Which is the last word, alphabetically, in a text file?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个文本文件中，哪个是按字母顺序排列的最后一个单词？
- en: Which is the longest word in a text file?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个文本文件中，哪个是最长的单词？
- en: 'Note that for the second and third challenges, you may well want to read up
    on the `key` parameter and the types of values you can pass to it. A good introduction,
    with examples, is here: [http://mng.bz/D28E](http://mng.bz/D28E).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于第二个和第三个挑战，你可能需要了解 `key` 参数以及你可以传递给它的值类型。一个很好的介绍，包括示例，在这里：[http://mng.bz/D28E](http://mng.bz/D28E)。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Python programmers are constantly dealing with text. Whether it’s because we’re
    reading from files, displaying things on the screen, or just using dicts, strings
    are a data type with which we’re likely familiar from other languages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序员一直在处理文本。无论是我们正在从文件中读取，还是在屏幕上显示内容，或者只是使用字典，字符串是我们可能从其他语言中熟悉的数据类型。
- en: At the same time, strings in Python are unusual, in that they’re also sequences--and
    thus, thinking in Python requires that you consider their sequence-like qualities.
    This means searching (using `in`), sorting (using `sorted`), and using slices.
    It also means thinking about how you can turn strings into lists (using `str.split`)
    and turn sequences back into strings (using `str.join`). While these might seem
    like simple tasks, they crop up on a regular basis in production Python code.
    The fact that these data structures and methods are written in C, and have been
    around for many years, means they’re also highly efficient--and not worth reinventing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Python 中的字符串很特殊，因为它们也是序列——因此，用 Python 思考需要考虑它们的序列特性。这意味着搜索（使用 `in`），排序（使用
    `sorted`），以及使用切片。这也意味着思考如何将字符串转换为列表（使用 `str.split`）以及将序列转换回字符串（使用 `str.join`）。虽然这些可能看起来像是简单的任务，但在实际的
    Python 代码中它们经常出现。这些数据结构和方法是使用 C 语言编写的，并且已经存在多年，这意味着它们也非常高效——不值得重新发明。
