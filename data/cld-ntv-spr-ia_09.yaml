- en: 7 Kubernetes fundamentals for Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 个 Spring Boot 的 Kubernetes 基本概念
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Moving from Docker to Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Docker 迁移到 Kubernetes
- en: Deploying Spring Boot applications on Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上部署 Spring Boot 应用程序
- en: Understanding service discovery and load balancing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务发现和负载均衡
- en: Building scalable and disposable applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可扩展和可丢弃的应用程序
- en: Establishing a local Kubernetes development workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立本地 Kubernetes 开发工作流程
- en: Validating Kubernetes manifests with GitHub Actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 验证 Kubernetes 清单
- en: In the previous chapter, you learned about Docker and the main characteristics
    of images and containers. With Buildpacks and Spring Boot, you can build a production-ready
    image in one command, without even having to write your own Dockerfile or install
    additional tools. With Docker Compose, you can simultaneously control multiple
    applications, which is convenient for architectures like microservices. But what
    if a container stops working? What if the machine where your containers are running
    (the Docker host) crashes? What if you want to scale your applications? This chapter
    will introduce Kubernetes into your workflow to address issues that Docker alone
    cannot.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了 Docker 以及镜像和容器的主要特性。通过 Buildpacks 和 Spring Boot，你可以通过一条命令构建一个生产就绪的镜像，甚至无需编写自己的
    Dockerfile 或安装额外的工具。使用 Docker Compose，你可以同时控制多个应用程序，这对于微服务架构来说非常方便。但万一容器停止工作怎么办？如果你的容器运行所在的机器（Docker
    主机）崩溃了怎么办？如果你想扩展你的应用程序怎么办？这一章将引入 Kubernetes 到你的工作流程中，以解决 Docker 单独无法解决的问题。
- en: As a developer, it’s not your job to configure and manage a Kubernetes cluster.
    You would probably use either a managed service offered by a cloud provider such
    as Amazon, Microsoft, or Google, or a service managed on premises by a specialized
    team in your organization (commonly known as the *platform team*). For now you’ll
    use a local Kubernetes cluster provisioned with *minikube*. Later in the book
    you’ll use a managed Kubernetes service offered by a cloud provider.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，配置和管理 Kubernetes 集群不是你的工作。你可能使用云提供商（如亚马逊、微软或谷歌）提供的托管服务，或者由你组织中的专业团队（通常称为“平台团队”）管理的本地服务。目前，你将使用由
    *minikube* 提供的本地 Kubernetes 集群。在本书的后面部分，你将使用云提供商提供的托管 Kubernetes 服务。
- en: In our daily job as developers, we don’t want to spend too much time on infrastructural
    concerns, but it’s critical to know the basics. Kubernetes has become the de facto
    orchestration tool and the common language for talking about containerized deployments.
    Cloud vendors have been building platforms on top of Kubernetes to provide a better
    experience for developers. Once you know how Kubernetes works, it’ll be straightforward
    to use those platforms, because you’ll be familiar with the language and the abstractions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们作为开发者的日常工作中，我们不希望花费太多时间在基础设施问题上，但了解基础知识是至关重要的。Kubernetes 已经成为事实上的编排工具和容器化部署的通用语言。云提供商已经在
    Kubernetes 上构建平台，为开发者提供更好的体验。一旦你了解了 Kubernetes 的工作原理，使用这些平台将变得非常简单，因为你将熟悉这种语言和抽象。
- en: This chapter will walk you through the main features of Kubernetes and teach
    you how to create and manage Pods, Deployments, and Services for your Spring Boot
    applications. Along the way you’ll enable graceful shutdown for your applications,
    learn how to scale them, and learn how to use the service discovery and load balancing
    features provided by Kubernetes. You’ll also learn to automate your local development
    workflow with Tilt, visualize your workloads with Octant, and validate your Kubernetes
    manifests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你了解 Kubernetes 的主要功能，并教你如何为你的 Spring Boot 应用程序创建和管理 Pods、Deployments 和 Services。在这个过程中，你将使你的应用程序能够优雅地关闭，学习如何扩展它们，以及如何使用
    Kubernetes 提供的服务发现和负载均衡功能。你还将学习如何使用 Tilt 自动化你的本地开发工作流程，使用 Octant 可视化你的工作负载，以及验证你的
    Kubernetes 清单。
- en: Note The source code for the examples in this chapter is available in the Chapter07/07-begin
    and Chapter07/07-end folders, which contain the initial and final states of the
    project ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在 Chapter07/07-begin 和 Chapter07/07-end 文件夹中找到，这些文件夹包含项目的初始状态和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 7.1 Moving from Docker to Kubernetes
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 从 Docker 迁移到 Kubernetes
- en: With Docker Compose, you can manage the deployment of several containers at
    once, including the configuration of networks and storage. That is extremely powerful,
    but it’s limited to one machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose，你可以一次性管理多个容器的部署，包括网络和存储的配置。这非常强大，但仅限于单个机器。
- en: Using Docker CLI and Docker Compose, the interaction happens with a single Docker
    daemon that manages Docker resources on a single machine, called the Docker host.
    Furthermore, it’s not possible to scale a container. All of this is limiting when
    you need cloud native properties like scalability and resilience for your system.
    Figure 7.1 shows how you target a single machine when using Docker.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker CLI 和 Docker Compose，交互是通过单个 Docker 守护进程进行的，该守护进程管理单个机器上的 Docker 资源，称为
    Docker 主机。此外，无法扩展容器。当你需要系统具有云原生属性，如可扩展性和弹性时，所有这些都会受到限制。图 7.1 展示了使用 Docker 时如何针对单个机器进行定位。
- en: '![07-01](../Images/07-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![07-01](../Images/07-01.png)'
- en: Figure 7.1 Docker clients interact with a Docker daemon that can only manage
    resources on the machine where it is installed, called the Docker host. Applications
    are deployed as containers to the Docker host.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 Docker 客户端与 Docker 守护进程交互，该守护进程只能管理其安装的机器上的资源，称为 Docker 主机。应用程序作为容器部署到
    Docker 主机上。
- en: You learned in chapter 2 that we change our point of view when we move from
    a container runtime like Docker to an orchestration platform like Kubernetes.
    With Docker, we deploy containers to an individual machine. With Kubernetes, we
    deploy containers to a cluster of machines, enabling scalability and resilience.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第二章中学到，当我们从像 Docker 这样的容器运行时转移到像 Kubernetes 这样的编排平台时，我们会改变我们的视角。使用 Docker，我们将容器部署到单个机器上。使用
    Kubernetes，我们将容器部署到机器集群上，从而实现可扩展性和弹性。
- en: Kubernetes clients use an API to interact with the Kubernetes Control Plane,
    which is responsible for creating and managing objects in a Kubernetes cluster.
    In this new scenario, we still send commands to a single entity, but it acts on
    several machines rather than only one. Figure 7.2 shows the logical infrastructure
    when we use Kubernetes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 客户端使用 API 与 Kubernetes 控制平面交互，该控制平面负责在 Kubernetes 集群中创建和管理对象。在这个新场景中，我们仍然向单个实体发送命令，但它作用于多个机器，而不仅仅是单个机器。图
    7.2 展示了使用 Kubernetes 时的逻辑基础设施。
- en: '![07-02](../Images/07-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![07-02](../Images/07-02.png)'
- en: Figure 7.2 Kubernetes clients interact with the Control Plane, which manages
    containerized applications in a cluster consisting of one or more nodes. Applications
    are deployed as Pods to the nodes of a cluster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 Kubernetes 客户端与控制平面交互，该控制平面负责管理由一个或多个节点组成的集群中的容器化应用程序。应用程序作为 Pods 部署到集群的节点上。
- en: 'These are the main components shown in figure 7.2:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是图 7.2 中显示的主要组件：
- en: '*Cluster*—A set of nodes running containerized applications. It hosts the Control
    Plane and comprises one or more worker nodes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集群*——运行容器化应用程序的一组节点。它托管控制平面，并包括一个或多个工作节点。'
- en: '*Control Plane*—The cluster component exposing the API and interfaces to define,
    deploy, and manage the life cycle of Pods. It comprises all the essential elements
    that implement the typical features of an orchestrator, like cluster management,
    scheduling, and health monitoring.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制平面*——集群组件，公开 API 和接口以定义、部署和管理 Pods 的生命周期。它包括实现编排器典型功能的所有基本元素，如集群管理、调度和健康监控。'
- en: '*Worker nodes*—Physical or virtual machines providing capacity such as CPU,
    memory, network, and storage so that containers can run and connect to a network.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*工作节点*——提供 CPU、内存、网络和存储等能力的物理或虚拟机器，以便容器可以运行并连接到网络。'
- en: '*Pod*—The smallest deployable unit wrapping an application container.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod*——封装应用程序容器的最小可部署单元。'
- en: Now that you have a good understanding of the Kubernetes infrastructure, let’s
    see how you can create and manage a Kubernetes cluster on your local machine.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 Kubernetes 基础设施有了很好的理解，让我们看看如何在你的本地机器上创建和管理一个 Kubernetes 集群。
- en: 7.1.1 Working with a local Kubernetes cluster
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 在本地 Kubernetes 集群中工作
- en: In chapter 2, we worked with *minikube* ([https://minikube.sigs.k8s.io](https://minikube.sigs.k8s.io)),
    a tool for running Kubernetes clusters on local environments. We used the minikube
    CLI to create a local Kubernetes cluster relying on the default configuration.
    In this section, you’ll see how to define a custom configuration for minikube
    that you can use when initializing a new local Kubernetes cluster for deploying
    Polar Bookshop.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们使用了 *minikube* ([https://minikube.sigs.k8s.io](https://minikube.sigs.k8s.io))，这是一个在本地环境中运行
    Kubernetes 集群的工具。我们使用 minikube CLI 创建了一个依赖于默认配置的本地 Kubernetes 集群。在本节中，你将看到如何为
    minikube 定义一个自定义配置，你可以在初始化用于部署 Polar Bookshop 的新本地 Kubernetes 集群时使用它。
- en: Note If you haven’t installed minikube yet, refer to the instructions in section
    A.3 of appendix A.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你还没有安装 minikube，请参考附录 A 的 A.3 节中的说明。
- en: Since we run minikube on top of Docker, remember to start the Docker Engine
    first. Then make sure the default cluster is not running by executing the minikube
    stop command. From now on, we won’t use the default cluster. Instead, we’ll create
    a custom one for working with Polar Bookshop. With minikube you can create and
    control multiple clusters identified via *profiles*. When no profile is specified,
    minikube falls back on the default cluster.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 Docker 上运行 minikube，请记住首先启动 Docker 引擎。然后确保默认集群没有运行，通过执行 minikube stop
    命令。从现在开始，我们不会使用默认集群。相反，我们将创建一个用于与 Polar Bookshop 一起工作的自定义集群。使用 minikube，你可以创建和控制多个通过
    *配置文件* 识别的集群。如果没有指定配置文件，minikube 将回退到默认集群。
- en: Warning Running the examples on a local Kubernetes cluster requires Docker to
    have at least 2 CPUs and 4 GB of memory. If you are using Docker Desktop for Mac
    or for Windows, and you need to increase the resources assigned to the Docker
    Engine, refer to the product documentation for instructions on how to do that
    for your specific operating system ([https://docs.docker.com/desktop](https://docs.docker.com/desktop)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在本地 Kubernetes 集群上运行示例需要 Docker 至少有 2 个 CPU 和 4 GB 的内存。如果你使用的是 Docker Desktop
    for Mac 或 Windows，并且需要增加分配给 Docker 引擎的资源，请参考产品文档了解如何在你的特定操作系统上执行此操作（[https://docs.docker.com/desktop](https://docs.docker.com/desktop)）。
- en: 'Let’s create a new Kubernetes cluster named polar on top of Docker. This time,
    we also want to declare the resource limits for CPU and memory:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Docker 上创建一个新的名为 polar 的 Kubernetes 集群。这次，我们还想声明 CPU 和内存的资源限制：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can get a list of all the nodes in the cluster with the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令获取集群中所有节点的列表：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The cluster we have just created is composed of a single node, which hosts the
    Control Plane and acts as a worker node for deploying containerized workloads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的集群由单个节点组成，该节点托管控制平面并作为部署容器化工作负载的工作节点。
- en: 'You can use the same Kubernetes client (kubectl) to interact with different
    local or remote clusters. The following command will list all the available *contexts*
    with which you can interact:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的 Kubernetes 客户端（kubectl）与不同的本地或远程集群交互。以下命令将列出所有可用的 *上下文*，你可以通过这些上下文进行交互：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you have more than one context, make sure kubectl is configured to use polar.
    You can verify which is the current context by running this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有多个上下文，请确保 kubectl 已配置为使用 polar。你可以通过运行此命令来验证当前上下文：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the result is different from polar, you can change the current context as
    follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果与 polar 不同，你可以按照以下方式更改当前上下文：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the rest of the chapter, I will assume you have this local cluster up and
    running. At any time, you can stop the cluster with minikube stop --profile polar
    and start it again with minikube start --profile polar. If you ever want to delete
    it and start over, you can run the minikube delete --profile polar command.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我将假设你已经启动并运行了这个本地集群。任何时候，你都可以使用 minikube stop --profile polar 命令停止集群，并使用
    minikube start --profile polar 命令再次启动它。如果你想要删除它并重新开始，你可以运行 minikube delete --profile
    polar 命令。
- en: In the next section, you’ll complete the setup for your local Kubernetes cluster
    by deploying a PostgreSQL database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将通过部署 PostgreSQL 数据库来完成本地 Kubernetes 集群的设置。
- en: 7.1.2 Managing data services in a local cluster
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 在本地集群中管理数据服务
- en: As you learned in chapter 5, data services are the stateful components of a
    system and require special care in a cloud environment due to the challenges of
    handling their storage. Managing persistence and storage in Kubernetes is a complex
    topic, and it’s not usually the responsibility of developers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 5 章中学到的，数据服务是系统的有状态组件，由于处理其存储的挑战，在云环境中需要特别注意。在 Kubernetes 中管理持久性和存储是一个复杂的话题，通常不是开发者的责任。
- en: When you deploy the Polar Bookshop system in production, you’ll rely on the
    managed data services offered by the cloud provider, so I have prepared the configuration
    for deploying PostgreSQL in your local Kubernetes cluster. Check the source code
    repository accompanying this book (Chapter07/07-end) and copy the content of the
    polar-deployment/kubernetes/platform/development folder into the same path in
    your polar-deployment repository. The folder contains basic Kubernetes manifests
    to run a PostgreSQL database.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在生产环境中部署 Polar Bookshop 系统时，您将依赖云提供商提供的托管数据服务，因此我已经为您准备好了在本地 Kubernetes 集群中部署
    PostgreSQL 的配置。检查本书附带源代码仓库（第07章/07-end）并将 polar-deployment/kubernetes/platform/development
    文件夹的内容复制到您的 polar-deployment 仓库中的相同路径。该文件夹包含运行 PostgreSQL 数据库的基本 Kubernetes 清单。
- en: 'Open a Terminal window, navigate to the kubernetes/platform/development folder
    located in your polar-deployment repository, and run the following command to
    deploy PostgreSQL in your local cluster:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到位于您的 polar-deployment 仓库中的 kubernetes/platform/development 文件夹，并运行以下命令以在本地集群中部署
    PostgreSQL：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note The preceding command creates the resources defined in the manifests within
    the services folder. In the next section, you’ll learn more about the kubectl
    apply command and Kubernetes manifests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：前面的命令会在服务文件夹中创建在清单中定义的资源。在下一节中，您将了解更多关于 kubectl apply 命令和 Kubernetes 清单的内容。
- en: 'The result will be a Pod running a PostgreSQL container in your local Kubernetes
    cluster. You can check it out with the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将在您的本地 Kubernetes 集群中运行一个运行 PostgreSQL 容器的 Pod。您可以使用以下命令进行检查：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip You can check the database logs by running kubectl logs deployment/polar-postgres.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可以通过运行 kubectl logs deployment/polar-postgres 来检查数据库日志。
- en: Running Kubernetes services with Helm
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 运行 Kubernetes 服务
- en: A popular way of running third-party services in a Kubernetes cluster is through
    Helm ([https://helm.sh](https://helm.sh)). Think of it as a package manager. To
    install software on your computer, you can use one of the operating system package
    managers, like Apt (Ubuntu), Homebrew (macOS), or Chocolatey (Windows); in Kubernetes,
    you can similarly use Helm, but we call them *charts* instead of *packages*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中运行第三方服务的一种流行方式是通过 Helm ([https://helm.sh](https://helm.sh))。将其视为一个包管理器。要在您的计算机上安装软件，您可以使用操作系统包管理器之一，如
    Apt（Ubuntu）、Homebrew（macOS）或 Chocolatey（Windows）；在 Kubernetes 中，您可以使用 Helm，但我们称之为
    *charts* 而不是 *packages*。
- en: At this stage in our cloud native journey, using Helm would be a bit premature
    and perhaps confusing. To fully understand how it works, it’s essential to acquire
    more familiarity with Kubernetes first.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们云原生之旅的这个阶段，使用 Helm 可能有些过早，也许会让人困惑。要完全理解它的工作原理，首先需要更多地熟悉 Kubernetes。
- en: For the rest of the chapter, I’ll assume you have a PostgreSQL instance running
    in your local cluster. If at any point you need to undeploy the database, you
    can run the kubectl delete -f services command from the same folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的其余部分，我将假设您在本地集群中运行了一个 PostgreSQL 实例。如果您在任何时候需要卸载数据库，您可以从同一文件夹中运行 kubectl
    delete -f services 命令。
- en: The following section will present the main Kubernetes concepts and guide you
    through deploying Spring Boot applications on your local cluster.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍主要的 Kubernetes 概念，并指导您在本地集群上部署 Spring Boot 应用程序。
- en: 7.2 Kubernetes Deployments for Spring Boot
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 Kubernetes 部署 Spring Boot
- en: This section will walk you through the main Kubernetes objects you’ll be working
    with as a developer and the vocabulary necessary to communicate efficiently with
    a platform team and deploy your applications to a cluster.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带您了解作为开发者将与之合作的主要 Kubernetes 对象以及与平台团队高效沟通所需的词汇，并将您的应用程序部署到集群中。
- en: You have already gone through the containerization of a Spring Boot application.
    A Spring Boot application on Kubernetes is still packaged as a container, but
    it runs in a Pod controlled by a Deployment object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经经历了 Spring Boot 应用程序的容器化。在 Kubernetes 上的 Spring Boot 应用程序仍然被打包为容器，但它运行在由
    Deployment 对象控制的 Pod 中。
- en: Pods and Deployments are core concepts you need to understand when working with
    Kubernetes. Let’s start by looking at some of their main characteristics, after
    which you’ll practice declaring and creating Kubernetes resources to deploy the
    Catalog Service application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 和 Deployments 是您在处理 Kubernetes 时需要理解的核心概念。让我们首先看看它们的一些主要特性，然后您将练习声明和创建
    Kubernetes 资源以部署 Catalog Service 应用程序。
- en: 7.2.1 From containers to Pods
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 从容器到 Pods
- en: As we discussed in the previous section, Pods are the smallest deployable units
    in Kubernetes. When moving from Docker to Kubernetes, we switch from managing
    containers to managing Pods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的，Pods是Kubernetes中最小的可部署单元。当从Docker迁移到Kubernetes时，我们从管理容器切换到管理Pods。
- en: A *Pod* is the smallest Kubernetes object, and it “represents a set of running
    containers” in a cluster. It’s usually set up to run a single primary container
    (your application), but it can also run optional helper containers with additional
    features like logging, monitoring, or security ([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pod*是Kubernetes中最小的对象，它“代表集群中一组运行的容器”。它通常被设置为运行单个主要容器（你的应用程序），但它也可以运行具有额外功能（如日志记录、监控或安全性）的可选辅助容器([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary))。'
- en: 'A Pod is usually comprised of one container: the application instance. When
    that happens, it’s not much different from working with containers directly. However,
    there are some scenarios where your application container needs to be deployed
    together with some *helper* containers that perhaps perform initialization tasks
    required by the application or add extra functionality such as logging. For example,
    Linkerd (a *service mesh*) adds its own container (a *sidecar*) to Pods to perform
    operations such as intercepting HTTP traffic and encrypting it to guarantee secure
    communication between all Pods via mTLS (mutual Transport Layer Security). Figure
    7.3 illustrates single-container and multi-container Pods.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Pod通常由一个容器组成：应用程序实例。当这种情况发生时，它与直接使用容器的工作方式没有太大区别。然而，在某些场景中，你的应用程序容器需要与一些*辅助*容器一起部署，这些辅助容器可能执行应用程序所需的初始化任务或添加额外的功能，如日志记录。例如，Linkerd（一个*服务网格*）将其自己的容器（一个*边车*）添加到Pods中，以执行诸如拦截HTTP流量并对其进行加密以通过mTLS（相互传输层安全性）保证所有Pod之间的安全通信等操作。图7.3说明了单容器和多容器Pods。
- en: '![07-03](../Images/07-03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![07-03](../Images/07-03.png)'
- en: Figure 7.3 Pods are the smallest deployable units in Kubernetes. They run at
    least one primary container (the application) and might run optional helper containers
    for additional features like logging, monitoring, or security.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 Pods是Kubernetes中最小的可部署单元。它们至少运行一个主要容器（应用程序）并可能运行用于额外功能（如日志记录、监控或安全性）的可选辅助容器。
- en: In this book, you’ll work with single-container Pods, where the container is
    the application. Compared to containers, Pods allow you to manage related containers
    as a single entity. But that’s not enough. Directly creating and managing Pods
    would not be much different than working with plain Docker containers. We need
    something at a higher level of abstraction to define how we want to deploy and
    scale our applications. That’s where the Deployment objects come into play.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将使用单容器Pods，其中容器是应用程序。与容器相比，Pods允许你将相关的容器作为一个单一实体来管理。但这还不够。直接创建和管理Pods与直接使用纯Docker容器的工作方式没有太大区别。我们需要一个更高层次的抽象来定义我们想要如何部署和扩展我们的应用程序。这就是Deployment对象发挥作用的地方。
- en: 7.2.2 Controlling Pods with Deployments
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 使用部署控制Pods
- en: How can you scale an application to have five replicas running? How can you
    ensure there are always five replicas up and running even when failures occur?
    How can you deploy a new version of the application without downtime? With *Deployments*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将一个应用程序扩展到运行五个副本？如何在出现故障时确保始终有五个副本在运行？如何在不停机的情况下部署应用程序的新版本？使用*部署*。
- en: A *Deployment* is an object that manages the life cycle of a stateless, replicated
    application. Each replica is represented by a Pod. The replicas are distributed
    among the nodes of a cluster for better resilience ([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署*是一个管理无状态、复制应用程序生命周期的对象。每个副本由一个Pod表示。副本在集群的节点之间分布，以提高弹性([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary))。'
- en: In Docker you manage your application instances directly by creating and removing
    containers. In Kubernetes you don’t manage Pods. You let a Deployment do that
    for you. Deployment objects have several important and valuable characteristics.
    You can use them to deploy your applications, roll out upgrades without downtime,
    roll back to a previous version in case of errors, and pause and resume upgrades.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中，你通过创建和删除容器直接管理应用程序实例。在Kubernetes中，你不需要管理Pod。你让部署为你做这件事。部署对象具有几个重要且宝贵的特性。你可以使用它们来部署你的应用程序，无停机时间地发布升级，在出错时回滚到先前的版本，以及暂停和恢复升级。
- en: Deployments also let you manage replication. They make use of an object named
    *ReplicaSet* to ensure there’s always the desired number of Pods up and running
    in your cluster. If one of them crashes, a new one is created automatically to
    replace it. Furthermore, replicas are deployed across different nodes in your
    cluster to ensure even higher availability if one node crashes. Figure 7.4 shows
    the relationship between containers, Pods, ReplicaSets, and Deployments.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还允许你管理复制。它们使用名为*副本集*的对象来确保集群中始终有所需数量的Pod运行。如果其中一个崩溃，会自动创建一个新的来替换它。此外，副本会在集群的不同节点上部署，以确保在某个节点崩溃时具有更高的可用性。图7.4显示了容器、Pod、副本集和部署之间的关系。
- en: '![07-04](../Images/07-04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![07-04](../Images/07-04.png)'
- en: Figure 7.4 A Deployment manages replicated applications with ReplicaSets and
    Pods in your cluster. A ReplicaSet ensures the desired number of Pods is always
    up and running. A Pod runs a containerized application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 一个部署通过副本集和Pod管理集群中的复制应用程序。副本集确保始终有所需数量的Pod运行。Pod运行容器化应用程序。
- en: Deployments provide a convenient abstraction for us to declare what we want
    to achieve (the *desired state*), and we can let Kubernetes make it happen. You
    don’t need to worry about how to achieve a specific result. Unlike imperative
    tools such as Ansible or Puppet, you can just tell Kubernetes what you want, and
    the orchestrator will figure out how to achieve the desired result and keep it
    consistent. That’s what we call *declarative configuration*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 部署为我们提供了一个方便的抽象，使我们能够声明我们想要实现的内容（*所需状态*），我们可以让Kubernetes来实现它。你不需要担心如何实现特定的结果。与Ansible或Puppet等命令式工具不同，你只需告诉Kubernetes你想要什么，协调器就会找出如何实现所需的结果并保持其一致性。这就是我们所说的*声明式配置*。
- en: Kubernetes uses controllers that watch the system and compare the desired state
    with the actual state. When there is any difference between the two, it acts to
    make them match again. Deployments and ReplicaSets are controller objects, handling
    rollout, replication, and self-healing. For example, suppose you declare that
    you want three replicas of your Spring Boot application deployed. If one crashes,
    the associated ReplicaSet notices it and creates a new Pod to align the actual
    state with the desired one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用控制器来监视系统，并将所需状态与实际状态进行比较。当两者之间存在任何差异时，它会采取措施使它们再次匹配。部署和副本集是控制器对象，负责滚动发布、复制和自我修复。例如，假设你声明你想要部署三个Spring
    Boot应用的副本。如果一个崩溃了，相关的副本集会注意到这一点并创建一个新的Pod来使实际状态与所需状态一致。
- en: After packaging a Spring Boot application as an OCI image, all you need to do
    to run it in a Kubernetes cluster is define a Deployment object. You’ll learn
    how in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将Spring Boot应用打包为OCI镜像后，你只需定义一个部署对象即可在Kubernetes集群中运行它。你将在下一节中学习如何操作。
- en: 7.2.3 Creating a Deployment for a Spring Boot application
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 为Spring Boot应用创建部署
- en: There are a few options for creating and managing Kubernetes objects in a cluster.
    In chapter 2 we used the kubectl client directly, but that approach lacks version
    control and reproducibility. It’s the same reason why we prefer Docker Compose
    over the Docker CLI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中创建和管理Kubernetes对象有几个选项。在第2章中，我们直接使用了kubectl客户端，但这种方法缺乏版本控制和可重复性。这也是我们为什么更喜欢Docker
    Compose而不是Docker CLI的原因。
- en: 'In Kubernetes, the recommended approach is to describe an object’s desired
    state in a *manifest* file, typically specified in YAML format. We use *declarative
    configuration*: we declare what we want instead of how to achieve it. In chapter
    2 we *imperatively* used kubectl to create and delete objects, but when we work
    with manifests, we *apply* them to the cluster. Then Kubernetes will automatically
    reconcile the actual state in the cluster with the desired state in the manifest.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，建议的方法是在 *manifest* 文件中描述对象的期望状态，通常指定为 YAML 格式。我们使用 *声明性配置*：我们声明我们想要的内容，而不是如何实现它。在第
    2 章中，我们 *命令式* 使用 kubectl 创建和删除对象，但当我们处理清单时，我们 *应用* 它们到集群。然后 Kubernetes 将自动将集群中的实际状态与清单中的期望状态进行协调。
- en: 'A Kubernetes manifest usually comprises four main sections, as shown in figure
    7.5:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 清单通常包含四个主要部分，如图 7.5 所示：
- en: apiVersion defines the versioned schema of the specific object representation.
    Core resources such as Pods or Services follow a versioned schema composed of
    only a version number (such as v1). Other resources like Deployments or ReplicaSet
    follow a versioned schema consisting of a group and a version number (for example,
    apps/v1). If in doubt about which version to use, you can refer to the Kubernetes
    documentation ([https://kubernetes.io/docs](https://kubernetes.io/docs)) or use
    the kubectl explain <object_name> command to get more information about the object,
    including the API version to use.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: apiVersion 定义了特定对象表示的版本化模式。核心资源，如 Pods 或 Services，遵循仅由版本号（例如 v1）组成的版本化模式。其他资源，如
    Deployments 或 ReplicaSet，遵循由组和版本号（例如，apps/v1）组成的版本化模式。如果您不确定使用哪个版本，可以参考 Kubernetes
    文档 ([https://kubernetes.io/docs](https://kubernetes.io/docs)) 或使用 kubectl explain
    <object_name> 命令来获取有关对象更多信息，包括要使用的 API 版本。
- en: kind is the type of Kubernetes object you want to create, such as Pod, ReplicaSet,
    Deployment, or Service. You can use the kubectl api-resources command to list
    all the objects supported by the cluster.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kind 是您想要创建的 Kubernetes 对象类型，例如 Pod、ReplicaSet、Deployment 或 Service。您可以使用 kubectl
    api-resources 命令列出集群支持的所有对象。
- en: metadata provides details about the object you want to create, including the
    name and a set of labels (key/value pairs) used for categorization. For example,
    you can instruct Kubernetes to replicate all the objects with a specific label
    attached.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: metadata 提供了您要创建的对象的详细信息，包括名称和一组用于分类的标签（键/值对）。例如，您可以指示 Kubernetes 复制所有带有特定标签的对象。
- en: spec is a section specific to each object type and is used to declare the desired
    configuration.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spec 是针对每种对象类型特有的部分，用于声明所需的配置。
- en: '![07-05](../Images/07-05.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![07-05](../Images/07-05.png)'
- en: 'Figure 7.5 A Kubernetes manifest is typically composed of four main sections:
    apiVersion, kind, metadata, and spec.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 Kubernetes 清单通常由四个主要部分组成：apiVersion、kind、metadata 和 spec。
- en: Now that you’re familiar with the main sections of a Kubernetes manifest, let’s
    define one for a Deployment object that will run a Spring Boot application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了 Kubernetes 清单的主要部分，让我们定义一个用于运行 Spring Boot 应用程序的 Deployment 对象。
- en: Defining a Deployment manifest with YAML
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 YAML 定义 Deployment 清单
- en: There are different strategies for organizing Kubernetes manifests. For the
    Catalog Service application, create a “k8s” folder in the project root (catalog-service).
    We will use it to store the manifests for the application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 组织 Kubernetes 清单有不同的策略。对于 Catalog Service 应用程序，在项目根目录（catalog-service）中创建一个“k8s”文件夹。我们将使用它来存储应用程序的清单。
- en: Note If you haven’t followed along with the examples implemented in the previous
    chapters, you can refer to the repository accompanying the book ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))
    and use the project in Chapter07/07-begin/catalog-service as a starting point.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您没有跟随前几章中实现的示例，可以参考本书附带的代码库 ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))，并以第
    07 章的 07-begin/catalog-service 中的项目作为起点。
- en: Let’s start by creating a deployment.yml file inside the catalog-service/k8s
    folder. As you saw in figure 7.5, the first sections you need to include are apiVersion,
    kind, and metadata.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 catalog-service/k8s 文件夹内创建 deployment.yml 文件开始。如图 7.5 所示，您需要包含的第一个部分是
    apiVersion、kind 和 metadata。
- en: Listing 7.1 Initializing a Deployment manifest for Catalog Service
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 初始化 Catalog Service 的 Deployment 清单
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The API version for Deployment objects
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Deployment 对象的 API 版本
- en: ❷ The type of object to create
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 要创建的对象类型
- en: ❸ The name of the Deployment
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Deployment 的名称
- en: ❹ A set of labels attached to the Deployment
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❹附加到Deployment的一组标签
- en: ❺ This Deployment is labeled with “app=catalog-service.”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 此Deployment被标记为“app=catalog-service。”
- en: Note The Kubernetes API can change over time. Make sure you always use the API
    supported by the version of Kubernetes you’re running. If you have followed along
    so far, you shouldn’t have this problem. But if it happens, kubectl will return
    a very descriptive error message telling you exactly what’s wrong and how to fix
    it. You can also use the kubectl explain <object_ name> command to check the API
    version supported by your Kubernetes installation for a given object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Kubernetes API可能会随时间而变化。请确保您始终使用运行Kubernetes版本支持的API。如果您到目前为止一直跟随，您不应该有这个问题。但如果发生这种情况，kubectl将返回一个非常详细的错误消息，告诉您确切的问题以及如何修复它。您还可以使用kubectl
    explain <对象名称>命令来检查您的Kubernetes安装对给定对象的API版本支持情况。
- en: The spec section of a Deployment manifest contains a selector part to define
    a strategy for identifying which objects should be scaled by a ReplicaSet (more
    on this later) and a template part describing the specifications for creating
    the desired Pod and containers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment清单的spec部分包含一个选择器部分，用于定义一个策略，以确定哪些对象应该由ReplicaSet进行扩展（关于这一点稍后会有更多介绍）以及一个模板部分，描述创建所需Pod和容器的规范。
- en: Listing 7.2 The desired state for the Catalog Service deployment
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 目录服务部署的期望状态
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Defines the labels used to select the Pods to be scaled
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义用于选择要扩展的Pod的标签
- en: ❷ The template for creating a Pod
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建Pod的模板
- en: ❸ Labels attached to the Pod object. They should match the ones used as selectors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸附加到Pod对象的标签。它们应该与用作选择器的标签匹配。
- en: ❹ The list of containers in the Pod (one in this case)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Pod中的容器列表（本例中只有一个）
- en: ❺ The name of the Pod
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ Pod的名称
- en: ❻ The image used to run the container. No tag is defined, so “latest” will be
    used implicitly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 运行容器所使用的镜像。没有定义标签，因此将隐式地使用“latest”。
- en: ❼ Instructs Kubernetes to pull the image from a container registry only if it’s
    not present locally yet
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 指示Kubernetes仅在本地尚未存在时从容器注册库拉取镜像
- en: ❽ The ports exposed by the container
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 容器暴露的端口
- en: ❾ The list of environment variables passed to the Pod
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 传递给Pod的环境变量列表
- en: ❿ A Paketo Buildpacks environment variable to configure the number of threads
    for memory calculation
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 用于配置内存计算线程数的Paketo Buildpacks环境变量
- en: ⓫ A value for the spring.datasource.url property pointing to the PostgreSQL
    Pod deployed previously
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 指向之前部署的PostgreSQL Pod的spring.datasource.url属性的值
- en: ⓬ Enables the “testdata” Spring profile
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 启用“testdata”Spring配置文件
- en: The containers part should look familiar, since it resembles how you defined
    containers in the services section of a Docker Compose file. Like you did with
    Docker, you can use an environment variable to define the URL for the PostgreSQL
    instance the application should use. The hostname part of the URL (polar-postgres)
    is the name of the Service object that was used to expose the database and was
    created previously from the kubernetes/platform/development folder. You’ll learn
    more about Services later in the chapter. For now, it’s enough to know that polar-postgres
    is the name through which other objects in the cluster can communicate with the
    PostgreSQL instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 容器部分应该看起来很熟悉，因为它类似于您在Docker Compose文件的services部分中定义容器的方式。就像您使用Docker一样，您可以使用环境变量来定义应用程序应使用的PostgreSQL实例的URL。URL的主机部分（polar-postgres）是用于暴露数据库并之前从kubernetes/platform/development文件夹中创建的Service对象的名称。您将在本章的后面部分了解更多关于Service的信息。现在，只需知道polar-postgres是通过其他集群对象与PostgreSQL实例通信的名称。
- en: In a production scenario, the image would be fetched from a container registry.
    During development, it’s more convenient to work with local images. Let’s build
    one for Catalog Service, as you learned in the previous chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产场景中，镜像将从容器注册库中获取。在开发过程中，使用本地镜像更方便。让我们为目录服务构建一个，正如您在上一章中学到的。
- en: 'Open a Terminal window, navigate to the Catalog Service root folder (catalog-service),
    and build a new container image as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到目录服务根文件夹（catalog-service），并按照以下步骤构建一个新的容器镜像：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Tip If you’re working on ARM64 machines (such as Apple Silicon computers),
    you can add the --builder ghcr.io/thomasvitale/java-builder-arm64 argument to
    the previous command to use an experimental version of Paketo Buildpacks with
    ARM64 support. Be aware that it’s experimental and not ready for production. For
    more information, you can refer to the documentation on GitHub: [https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64).
    Without this workaround, until official support is added ([https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51)),
    you can still use Buildpacks to build containers and run them via Docker Desktop
    on Apple Silicon computers, but the build process and application startup phase
    will be slower than usual.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你在ARM64机器（如苹果硅电脑）上工作，你可以在之前的命令中添加--builder ghcr.io/thomasvitale/java-builder-arm64参数来使用具有ARM64支持的Paketo
    Buildpacks的实验版本。请注意，这是实验性的，并不适合生产环境。有关更多信息，你可以参考GitHub上的文档：[https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64)。在没有官方支持添加之前（[https://github.com/paketo-buildpacks/stacks/issues/51](https://github.com/paketo-buildpacks/stacks/issues/51)），你仍然可以使用Buildpacks来构建容器并通过Docker
    Desktop在苹果硅电脑上运行它们，但构建过程和应用启动阶段将比通常慢。
- en: 'By default, minikube doesn’t have access to your local container images, so
    it will not find the image you have just built for Catalog Service. But don’t
    worry: you can manually import it into your local cluster:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，minikube无法访问你的本地容器镜像，因此它将找不到你为目录服务刚刚构建的镜像。但别担心：你可以手动将其导入到你的本地集群中：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note YAML is an expressive language, but it can make your coding experience
    quite bad due to its constraints about spaces or perhaps the lack of support from
    your editor. When a kubectl command involving a YAML file fails, verify that spaces
    and indentation are used correctly. For Kubernetes, you can install a plugin in
    your editor to support you while writing YAML manifests, ensuring that you always
    use the correct syntax, spaces, and indentation. You can find a few plugin options
    in the README.md file in the repository accompanying this book: [https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意YAML是一种表达性语言，但由于其对空格或可能是编辑器支持的缺乏，它可能会使你的编码体验相当糟糕。当涉及YAML文件的kubectl命令失败时，请验证空格和缩进是否使用正确。对于Kubernetes，你可以在编辑器中安装一个插件来支持你编写YAML清单，确保你始终使用正确的语法、空格和缩进。你可以在本书附带的存储库中的README.md文件中找到一些插件选项：[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)。
- en: Now that you have a Deployment manifest, let’s move on and see how to apply
    it to your local Kubernetes cluster.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了部署清单，让我们继续看看如何将其应用到你的本地Kubernetes集群。
- en: Creating a Deployment object from a manifest
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从清单创建部署对象
- en: 'You can apply Kubernetes manifests to a cluster using the kubectl client. Open
    a Terminal window, navigate to your Catalog Service root folder (catalog-service),
    and run the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用kubectl客户端将Kubernetes清单应用到集群。打开一个终端窗口，导航到你的目录服务根目录（catalog-service），并运行以下命令：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The command is processed by the Kubernetes Control Plane, which will create
    and maintain all the related objects in the cluster. You can verify which objects
    have been created with the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 命令由Kubernetes控制平面处理，它将在集群中创建并维护所有相关对象。你可以使用以下命令来验证已创建的对象：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since you used labels consistently in your Deployment manifest, you can use
    the label app=catalog-service to fetch all the Kubernetes objects related to the
    Catalog Service deployment. As you can see, the declaration in deployment.yml
    resulted in the creation of a Deployment, a ReplicaSet, and a Pod.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在部署清单中一致地使用了标签，你可以使用标签app=catalog-service来获取与目录服务部署相关的所有Kubernetes对象。正如你所看到的，deployment.yml中的声明导致了Deployment、ReplicaSet和Pod的创建。
- en: 'To verify that Catalog Service started up correctly, you can check the logs
    from its Deployment as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证目录服务是否正确启动，你可以按照以下方式检查其部署的日志：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note You can monitor whether Pods have been created successfully by inspecting
    the STATUS column when you run kubectl get pods. Should a Pod fail to be deployed,
    check that column. Common error statuses are ErrImagePull or ImagePullBackOff.
    They happen when Kubernetes can’t pull the image used by the Pod from the configured
    container registry. We’re currently working with local images, so make sure you
    built and loaded a Catalog Service container image into minikube. You can use
    the kubectl describe pod <pod_name> command to get more information about the
    error and kubectl logs <pod_name> to get the application logs from a specific
    Pod instance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以通过运行kubectl get pods时检查STATUS列来监控Pod是否已成功创建。如果Pod部署失败，请检查该列。常见的错误状态是ErrImagePull或ImagePullBackOff。它们发生在Kubernetes无法从配置的容器注册库中拉取Pod使用的镜像时。我们目前正在使用本地镜像，所以请确保你已构建并将目录服务容器镜像加载到minikube中。你可以使用kubectl
    describe pod <pod_name>命令来获取有关错误的更多信息，以及使用kubectl logs <pod_name>来获取特定Pod实例的应用程序日志。
- en: When deploying containers in a cloud environment like a Kubernetes cluster,
    you’ll want to be sure it has enough resources to operate. In chapter 15, you’ll
    learn how to assign CPU and memory resources to a container running in Kubernetes
    and how to configure memory for the JVM by applying the Java memory calculator
    provided by Cloud Native Buildpacks. For now, we’ll rely on the default resource
    configuration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类似于Kubernetes集群的云环境中部署容器时，你想要确保它有足够的资源来运行。在第15章中，你将学习如何将CPU和内存资源分配给在Kubernetes中运行的容器，以及如何通过应用Cloud
    Native Buildpacks提供的Java内存计算器来配置JVM的内存。现在，我们将依赖于默认的资源配置。
- en: So far, you have created a Deployment for a Spring Boot application and run
    it in your local Kubernetes cluster. But it’s not possible to use it yet, since
    it’s isolated inside the cluster. In the next section you’ll learn how to expose
    your application to the outside world and how to use the service-discovery and
    load-balancing functionality provided by Kubernetes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经为Spring Boot应用程序创建了一个Deployment并在你的本地Kubernetes集群中运行它。但是，由于它被隔离在集群内部，所以目前还不能使用它。在下一节中，你将学习如何将你的应用程序暴露给外部世界，以及如何使用Kubernetes提供的服务发现和负载均衡功能。
- en: 7.3 Service discovery and load balancing
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 服务发现和负载均衡
- en: We’ve talked about Pods and Deployments, so let’s dig into Services a bit. You’ve
    got the Catalog Service application running as a Pod in your local Kubernetes
    cluster, but there are still unanswered questions. How can it interact with the
    PostgreSQL Pod running in the cluster? How does it know where to find it? How
    can you expose a Spring Boot application to be used by other Pods in the cluster?
    How can you expose it outside the cluster?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Pods和Deployments，那么让我们深入了解一下Services。你在本地Kubernetes集群中运行了目录服务应用程序作为Pod，但还有一些未解决的问题。它如何与集群中运行的PostgreSQL
    Pod交互？它是如何知道其位置的？你如何将Spring Boot应用程序暴露给集群中的其他Pod使用？你如何将其暴露在集群之外？
- en: 'This section will answer those questions by introducing two important aspects
    of cloud native systems: service discovery and load balancing. I’ll present the
    two main patterns available to implement them when working with Spring applications:
    client-side and server-side. Then you’ll apply the latter approach, which is conveniently
    offered natively by Kubernetes through Service objects, meaning you don’t have
    to change anything in your code to support it (unlike the client-side option).
    Finally, you’ll learn how the communication between the Catalog Service Pod and
    the PostgreSQL Pod happens, and you’ll expose the Catalog Service application
    as a network service.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将通过介绍云原生系统的两个重要方面来回答这些问题：服务发现和负载均衡。我将介绍在处理Spring应用程序时实现这两个功能的主要模式：客户端和服务器端。然后，你将应用后者方法，该方法通过Kubernetes的Service对象原生提供，这意味着你不需要更改代码来支持它（与客户端选项不同）。最后，你将了解目录服务Pod和PostgreSQL
    Pod之间的通信是如何发生的，以及你将如何将目录服务应用程序作为网络服务公开。
- en: 7.3.1 Understanding service discovery and load balancing
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 理解服务发现和负载均衡
- en: 'When one service needs to communicate with another, it must be provided with
    information about where to find it, such as an IP address or a DNS name. Let’s
    consider two applications: Alpha App and Beta App. Figure 7.6 shows how the communication
    between the two would happen if there were only one Beta App instance.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个服务需要与另一个服务通信时，它必须提供有关其位置的信息，例如IP地址或DNS名称。让我们考虑两个应用程序：Alpha应用程序和Beta应用程序。图7.6显示了如果只有一个Beta应用程序实例，这两个应用程序之间的通信将如何发生。
- en: '![07-06](../Images/07-06.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![07-06](../Images/07-06.png)'
- en: Figure 7.6 If there were only one Beta App instance, the interprocess communication
    between Alpha App and Beta App would be based on a DNS name resolving to the IP
    address of Beta App.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 如果只有一个Beta App实例，Alpha App和Beta App之间的进程间通信将基于一个解析到Beta App IP地址的DNS名称。
- en: In the scenario illustrated in figure 7.6, we say that Alpha App is *upstream*
    and Beta App is *downstream*. Furthermore, Beta App is a *backing service* with
    respect to Alpha App. There’s only one instance of Beta App running, so the DNS
    name gets resolved to its IP address.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.6所示的场景中，我们说Alpha App是*上游*，Beta App是*下游*。此外，对于Alpha App来说，Beta App是一个*后端服务*。Beta
    App只有一个实例在运行，所以DNS名称解析到其IP地址。
- en: In the cloud, you’ll probably want to have multiple instances of a service running,
    and each service instance will have its own IP address. Unlike physical machines
    or long-running virtual machines, a service instance will not live long in the
    cloud. Application instances are disposable—they can be removed or replaced for
    different reasons, such as when they are not responsive anymore. You can even
    enable the auto-scaling feature to automatically scale your application in and
    out, depending on the workload. Using IP addresses for interprocess communication
    in the cloud is not an option.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中，你可能希望运行多个服务实例，并且每个服务实例都将有自己的IP地址。与物理机器或长期运行的虚拟机不同，服务实例在云中不会存活很长时间。应用程序实例是可丢弃的——它们可以因为各种原因被移除或替换，例如当它们不再响应时。你甚至可以启用自动扩展功能，根据工作负载自动扩展和缩小应用程序。在云中使用IP地址进行进程间通信不是一个选择。
- en: To overcome that issue, you might consider using DNS records, relying on a round-robin
    name resolution pointing to one of the IP addresses assigned to the replicas.
    Knowing the hostname, you can reach the backing service even if one of the IP
    addresses changes because the DNS server would be updated with the new ones. However,
    this approach is not the best fit for cloud environments because the topology
    changes too often. Some DNS implementations cache the results of name lookups
    even after they should have expired. Similarly, some applications cache DNS lookup
    responses for too long. Either way, there’s a high chance of using a hostname/IP
    address resolution that is no longer valid.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，你可能考虑使用DNS记录，依靠一个循环冗余名称解析指向分配给副本之一的IP地址。知道主机名后，即使其中一个IP地址发生变化，你也可以访问后端服务，因为DNS服务器会更新为新地址。然而，这种方法并不适合云环境，因为拓扑结构变化过于频繁。一些DNS实现甚至在名称查找应该过期后仍然缓存结果。同样，一些应用程序也会长时间缓存DNS查找响应。无论哪种方式，使用不再有效的域名/IP地址解析的可能性很高。
- en: Service discovery in cloud environments requires a different solution. First,
    we need to keep track of all the service instances running and store that information
    in a *service registry*. Whenever a new instance is created, an entry should be
    added to the registry. When it’s shut down, it should be removed accordingly.
    The registry recognizes that multiple instances of the same application can be
    up and running. When an application needs to call a backing service, it performs
    a *lookup* in the registry to determine which IP address to contact. If multiple
    instances are available, a *load-balancing* strategy is applied to distribute
    the workload across them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 云环境中的服务发现需要不同的解决方案。首先，我们需要跟踪所有运行的服务实例，并将这些信息存储在*服务注册表*中。每当创建一个新的实例时，应该在注册表中添加一个条目。当它关闭时，应该相应地删除。注册表认识到同一应用程序的多个实例可以同时运行。当应用程序需要调用后端服务时，它会在注册表中执行*查找*以确定要联系哪个IP地址。如果可用多个实例，则应用*负载均衡*策略将工作负载分配给它们。
- en: We distinguish between client-side and server-side service discovery, depending
    on where the problem is solved. Let’s take a look at both options.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据问题解决的地点区分客户端和服务器端的服务发现。让我们看看这两种选项。
- en: 7.3.2 Client-side service discovery and load balancing
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 客户端服务发现和负载均衡
- en: Client-side service discovery requires applications to register themselves with
    a service registry upon startup and unregister when shutting down. Whenever they
    need to call a backing service, they ask the service registry for an IP address.
    If multiple instances are available, the registry will return the list of IP addresses.
    The application will choose one of them, depending on a load-balancing strategy
    defined by the application itself. Figure 7.7 shows how that works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端服务发现要求应用程序在启动时向服务注册表注册自己，并在关闭时注销。每当它们需要调用后端服务时，它们都会向服务注册表请求一个IP地址。如果有多个实例可用，注册表将返回IP地址列表。应用程序将根据应用程序本身定义的负载均衡策略选择其中之一。图7.7展示了这是如何工作的。
- en: '![07-07](../Images/07-07.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![07-07](../Images/07-07.png)'
- en: Figure 7.7 The interprocess communication between Alpha App and Beta App is
    based on the IP address of the specific instance to call, chosen from a list of
    IP addresses returned upon lookup in the service registry.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 Alpha App和Beta App之间的进程间通信基于要调用的特定实例的IP地址，该地址从服务注册表中查询返回的IP地址列表中选择。
- en: The Spring Cloud project offers a few options for adding client-side service
    discovery to your Spring applications. One of the popular choices is Spring Cloud
    Netflix Eureka, which wraps the Eureka service registry developed by Netflix.
    Alternatives are Spring Cloud Consul, Spring Cloud Zookeeper Discovery, and Spring
    Cloud Alibaba Nacos.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud项目为向Spring应用程序添加客户端服务发现提供了几种选项。其中一种流行的选择是Spring Cloud Netflix Eureka，它封装了Netflix开发的Eureka服务注册表。其他替代方案包括Spring
    Cloud Consul、Spring Cloud Zookeeper Discovery和Spring Cloud Alibaba Nacos。
- en: Besides managing a service registry explicitly, you’ll also need to add the
    correct integration to all your applications. For each of the previously mentioned
    options, Spring Cloud provides a client library you can add to your Spring application
    so it can use the service registry with minimal effort. Finally, Spring Cloud
    Load Balancer can be used for client-side load balancing, which is the preferred
    choice over Spring Cloud Netflix Ribbon (no longer maintained).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显式管理服务注册表外，您还需要将正确的集成添加到所有应用程序中。对于上述提到的每个选项，Spring Cloud都提供了一个客户端库，您可以将其添加到Spring应用程序中，以便它能够以最小的努力使用服务注册表。最后，Spring
    Cloud Load Balancer可用于客户端负载均衡，这是比Spring Cloud Netflix Ribbon（不再维护）更受欢迎的选择。
- en: 'All those libraries offered by Spring Cloud contributed to making it an excellent
    choice for building cloud native applications and implementing microservices architectures.
    A benefit of such a solution is that your applications have complete control over
    the load-balancing strategy. Suppose you need to implement patterns like *hedging*:
    sending the same request to multiple instances to increase the chance one responds
    correctly within a specific time limit. Client service discovery can help you
    with that.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud提供的所有这些库都有助于使其成为构建云原生应用程序和实现微服务架构的绝佳选择。这种解决方案的好处是您的应用程序可以完全控制负载均衡策略。假设您需要实现像*对冲*这样的模式：向多个实例发送相同的请求，以增加在特定时间限制内正确响应的几率。客户端服务发现可以帮助您实现这一点。
- en: A drawback is that client service discovery assigns more responsibility to developers.
    If your system includes applications built using different languages and frameworks,
    you’ll need to handle the client part of each of them in different ways. Also,
    it results in one more service to deploy and maintain (the service registry),
    unless you use PaaS solutions like Azure Spring Apps or VMware Tanzu Application
    Service, which provide it for you. Server-side discovery solutions solve these
    issues at the expense of fine-grained control in the application. Let’s see how.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个缺点是客户端服务发现将更多的责任分配给了开发者。如果您的系统包括使用不同语言和框架构建的应用程序，您将需要以不同的方式处理每个应用程序的客户端部分。此外，它还导致需要部署和维护一个额外的服务（服务注册表），除非您使用像Azure
    Spring Apps或VMware Tanzu Application Service这样的PaaS解决方案，这些解决方案为您提供了它。服务器端发现解决方案以牺牲应用程序的细粒度控制为代价来解决这些问题。让我们看看它是如何做到的。
- en: 7.3.3 Server-side service discovery and load balancing
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 服务器端服务发现和负载均衡
- en: Server-side service discovery solutions move a lot of responsibility to the
    deployment platform, so that developers can focus on the business logic and rely
    on the platform to provide all the necessary functionality for service discovery
    and load balancing. Such solutions automatically register and deregister application
    instances and rely on a load-balancer component to route any incoming requests
    to one of the available instances according to a specific strategy. In this case,
    the application doesn’t need to interact with the service registry, which is updated
    and managed by the platform. Figure 7.8 shows how that works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端服务发现解决方案将很多责任转移到部署平台，这样开发者可以专注于业务逻辑，并依赖平台提供所有必要的服务发现和负载均衡功能。此类解决方案会自动注册和注销应用程序实例，并依赖于负载均衡器组件根据特定策略将任何传入请求路由到可用的实例之一。在这种情况下，应用程序不需要与服务注册表交互，该注册表由平台更新和管理。图7.8展示了其工作原理。
- en: '![07-08](../Images/07-08.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![07-08](../Images/07-08.png)'
- en: Figure 7.8 The interprocess communication between Alpha App and Beta App is
    based on a DNS name that gets resolved to one of the instance IP addresses by
    a load-balancer component. The service registration process is handled by the
    platform transparently.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 Alpha应用和Beta应用之间的进程间通信基于一个DNS名称，该名称由负载均衡器组件解析为一个实例IP地址。服务注册过程由平台透明地处理。
- en: The Kubernetes implementation of this service discovery pattern is based on
    Service objects. A *Service* is “an abstract way to expose an application running
    on a set of Pods as a network service” ([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes对这种服务发现模式的实现基于服务对象。一个*服务*是“将运行在一系列Pod上的应用程序以网络服务的方式暴露的一种抽象方法”([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary))。
- en: A Service object is an abstraction targeting a set of Pods (typically using
    labels) and defining the access policy. When an application needs to contact a
    Pod exposed by a Service object, it can use the Service name instead of calling
    the Pod directly. That’s what you did to let the Catalog Service application interact
    with the PostgreSQL instance (polar-postgres was the name of the Service exposing
    the PostgreSQL Pod). The Service name is then resolved to the IP address of the
    Service itself by a local DNS server running in the Kubernetes Control Plane.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象是一个针对一组Pod（通常使用标签）的抽象，并定义了访问策略。当应用程序需要联系由服务对象暴露的Pod时，它可以使用服务名称而不是直接调用Pod。这正是您让目录服务应用程序与PostgreSQL实例交互的方式（polar-postgres是暴露PostgreSQL
    Pod的服务名称）。然后，本地DNS服务器将服务名称解析为服务本身的IP地址，该DNS服务器运行在Kubernetes控制平面中。
- en: Note The IP address assigned to a Service is fixed for its lifetime. Therefore,
    the DNS resolution of a Service name doesn’t change as often as it would with
    application instances.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：分配给服务的IP地址在其生命周期内是固定的。因此，服务名称的DNS解析不像应用程序实例那样频繁变化。
- en: After resolving the Service name to its IP address, Kubernetes relies on a proxy
    (called *kube-proxy*), which intercepts the connection to the Service object and
    forwards the request to one of the Pods targeted by the Service. The proxy knows
    all the replicas available and adopts a load-balancing strategy depending on the
    type of Service and the proxy configuration. There is no DNS resolution involved
    in this step, solving the problems I mentioned earlier. The service discovery
    implementation adopted by Kubernetes is shown in figure 7.9.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析服务名称到其IP地址后，Kubernetes依赖于一个代理（称为*kube-proxy*），该代理拦截对服务对象的连接，并将请求转发到服务目标之一。代理知道所有可用的副本，并根据服务类型和代理配置采用负载均衡策略。这一步不涉及DNS解析，解决了我之前提到的问题。Kubernetes采用的服务发现实现如图7.9所示。
- en: '![07-09](../Images/07-09.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![07-09](../Images/07-09.png)'
- en: Figure 7.9 In Kubernetes, the interprocess communication between Alpha App and
    Beta App happens through a Service object. Any request arriving at the Service
    is intercepted by a proxy that forwards it to one of the replicas targeted by
    the Service based on a specific load-balancing strategy.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 在Kubernetes中，Alpha应用和Beta应用之间的进程间通信是通过一个服务对象实现的。到达服务的任何请求都会被一个代理拦截，该代理根据特定的负载均衡策略将其转发到服务目标之一。
- en: This solution is transparent to your Spring Boot applications. Unlike options
    like Spring Cloud Netflix Eureka, you get service discovery and load balancing
    out of the box in Kubernetes, without requiring any change to your code. That’s
    why it’s the preferred option when you use a Kubernetes-based platform to deploy
    your applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案对你的Spring Boot应用程序来说是透明的。与Spring Cloud Netflix Eureka等选项不同，你可以在Kubernetes中获得开箱即用的服务发现和负载均衡功能，而无需对代码进行任何更改。这就是为什么当你使用基于Kubernetes的平台部署应用程序时，它是首选选项。
- en: Service discovery and Spring Cloud Kubernetes
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现与Spring Cloud Kubernetes
- en: 'If you need to migrate existing applications that use one of the client-side
    service discovery options I mentioned in the previous section, you can use Spring
    Cloud Kubernetes to make the transition smoother. You can keep your existing service
    discovery and load-balancing logic in your application. However, instead of solutions
    like Spring Cloud Netflix Eureka, you can use the *Spring Cloud Kubernetes Discovery
    Server* for service registry. This can be a convenient way to migrate applications
    to Kubernetes without changing too much in your application code. For more information,
    refer to the project documentation: [https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要迁移之前提到的客户端服务发现选项之一的应用程序，你可以使用Spring Cloud Kubernetes来使过渡更加平滑。你可以在应用程序中保留现有的服务发现和负载均衡逻辑。然而，与Spring
    Cloud Netflix Eureka等解决方案不同，你可以使用*Spring Cloud Kubernetes Discovery Server*进行服务注册。这可以是一种方便地将应用程序迁移到Kubernetes而无需在应用程序代码中做太多更改的方法。有关更多信息，请参阅项目文档：[https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes)。
- en: Unless what you’re doing requires specific handling of service instances and
    load balancing in your applications, my recommendation is to migrate over time
    to using the native service discovery functionality offered by Kubernetes, aiming
    at removing infrastructural concerns from your applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的操作需要对你的应用程序中的服务实例和负载均衡进行特定处理，我的建议是逐步迁移到使用Kubernetes提供的原生服务发现功能，目标是消除应用程序中的基础设施关注点。
- en: With this general understanding of how service discovery and load balancing
    are implemented in Kubernetes, let’s look at how we can define a Service to expose
    a Spring Boot application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何在Kubernetes中实现服务发现和负载均衡之后，让我们看看如何定义一个服务来暴露Spring Boot应用程序。
- en: 7.3.4 Exposing Spring Boot applications with Kubernetes Services
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 使用Kubernetes服务暴露Spring Boot应用程序
- en: As you learned in the previous section, Kubernetes Services let you expose a
    set of Pods via an interface that other applications can call without knowing
    the details about the individual Pod instances. This model provides applications
    with transparent service-discovery and load-balancing functionality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中学到的，Kubernetes服务允许你通过一个接口暴露一组Pod，其他应用程序可以通过该接口调用，而无需了解单个Pod实例的详细信息。这种模型为应用程序提供了透明的服务发现和负载均衡功能。
- en: First of all, there are different types of Services, depending on which access
    policy you want to enforce for the application. The default and most common type
    is called *ClusterIP*, and it exposes a set of Pods to the cluster. This is what
    makes it possible for Pods to communicate with each other (for example, Catalog
    Service and PostgreSQL).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，根据你想要强制执行的应用程序访问策略，存在不同类型的Service。默认且最常见的一种类型被称为*ClusterIP*，它将一组Pod暴露给集群。这使得Pod之间能够相互通信（例如，目录服务和PostgreSQL）。
- en: 'Four pieces of information characterize a ClusterIP Service:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 四个信息点定义了一个ClusterIP服务：
- en: The selector label used to match all the Pods that should be targeted and exposed
    by the Service
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务用于匹配所有应被服务和暴露的Pod的标签选择器
- en: The network protocol used by the Service
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务使用的网络协议
- en: The port on which the Service is listening (we’re going to use port 80 for all
    our application Services)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务监听的端口（我们将使用端口80来监听所有应用程序服务）
- en: The targetPort, which is the port exposed by the targeted Pods to which the
    Service will forward requests
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: targetPort，即目标Pod暴露的端口，服务将请求转发到该端口
- en: Figure 7.10 shows the relationship between a ClusterIP Service and a set of
    target Pods running applications exposed on port 8080\. The name of the Service
    must be a valid DNS name, since it will be used by other Pods as a hostname to
    access the targeted Pods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10显示了ClusterIP服务与一组在端口8080上运行应用程序的目标Pod之间的关系。服务名称必须是一个有效的DNS名称，因为它将被其他Pod用作主机名来访问目标Pod。
- en: '![07-10](../Images/07-10.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![07-10](../Images/07-10.png)'
- en: Figure 7.10 A ClusterIP service exposes a set of Pods to the network inside
    the cluster.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 一个 ClusterIP 服务将一组 Pod 暴露给集群内部的网络。
- en: Defining a Service manifest with YAML
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 YAML 定义 Service 清单
- en: Let’s see how we can define a manifest for a Service object to expose the Catalog
    Service application through the DNS name catalog-service and port 80. Open the
    catalog-service/k8s folder you created earlier and add a new service.yml file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义一个 Service 对象的清单，以通过 DNS 名称 catalog-service 和端口 80 暴露 Catalog Service
    应用程序。打开您之前创建的 catalog-service/k8s 文件夹，并添加一个新的 service.yml 文件。
- en: Listing 7.3 Service manifest for the Catalog Service application
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 Catalog Service 应用程序的 Service 清单
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ The API version for Service objects
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Service 对象的 API 版本
- en: ❷ The type of object to create
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 要创建的对象类型
- en: ❸ The name of the Service; it must be a valid DNS name.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 服务的名称；它必须是一个有效的 DNS 名称。
- en: ❹ A label attached to the Service
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 附加到服务的标签
- en: ❺ The type of Service
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 服务的类型
- en: ❻ The label used to match the Pods to target and expose
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 用于将 Pod 匹配到目标和暴露的标签
- en: ❼ The network protocol used by the Service
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 服务的网络协议
- en: ❽ The port exposed by the Service
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 服务的暴露端口
- en: ❾ The port exposed by the Pods targeted by the Service
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 服务的目标 Pod 暴露的端口
- en: Creating a Service object from a manifest
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从清单创建 Service 对象
- en: 'You can apply a Service manifest as you did for Deployments. Open a Terminal
    window, navigate to your Catalog Service root folder (catalog-service), and run
    the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像对 Deployments 一样应用 Service 清单。打开一个终端窗口，导航到您的 Catalog Service 根目录（catalog-service），并运行以下命令：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The command will be processed by the Kubernetes Control Plane, which will create
    and maintain the Service object in the cluster. You can verify the result with
    the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将由 Kubernetes 控制平面处理，它将在集群中创建并维护 Service 对象。您可以使用以下命令验证结果：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since it’s of type ClusterIP, the Service makes it possible for other Pods within
    the cluster to communicate with the Catalog Service application, either using
    its IP address (called the cluster IP) or through its name. That will be useful
    for the applications you’ll build in the next chapters, but what about us? How
    can we expose the application outside the cluster to test it?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是 ClusterIP 类型，Service 使得集群内的其他 Pod 能够通过其 IP 地址（称为集群 IP）或通过其名称与 Catalog Service
    应用程序通信。这对您将在下一章中构建的应用程序很有用，但我们怎么办？我们如何将应用程序暴露在集群外部以进行测试？
- en: 'For now, we’ll rely on the port-forwarding feature offered by Kubernetes to
    expose an object (in this case, a Service) to a local machine. You did that already
    in chapter 2, so the command should look familiar:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将依赖 Kubernetes 提供的端口转发功能来将对象（在这种情况下，是 Service）暴露到本地机器。您已经在第 2 章中这样做过了，所以命令应该看起来很熟悉：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can finally call the application from localhost on port 9001, and all requests
    will be forwarded to the Service object and ultimately to the Catalog Service
    Pod. Try visiting http://localhost:9001 from your browser to see the welcome message,
    or http://localhost:9001/books to browse the books available in the catalog.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从本地主机上的端口 9001 调用应用程序，所有请求都将转发到 Service 对象，最终转发到 Catalog Service Pod。尝试从您的浏览器访问
    http://localhost:9001 来查看欢迎信息，或访问 http://localhost:9001/books 来浏览目录中的书籍。
- en: Tip The process started by the kubectl port-forward command will keep running
    until you explicitly stop it with Ctrl-C. Until then, you’ll need to open another
    Terminal window if you want to run CLI commands.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：由 kubectl port-forward 命令启动的过程将一直运行，直到您使用 Ctrl-C 明确停止它。在此之前，如果您想运行 CLI 命令，则需要打开另一个终端窗口。
- en: Figure 7.11 illustrates how the communication works between your computer, Catalog
    Service, and PostgreSQL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 展示了您的计算机、Catalog Service 和 PostgreSQL 之间的通信工作方式。
- en: '![07-11](../Images/07-11.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![07-11](../Images/07-11.png)'
- en: Figure 7.11 The Catalog Service application is exposed to your local machine
    through port forwarding. Both Catalog Service and PostgreSQL are exposed to the
    inside of the cluster through the cluster-local hostname, IP address, and port
    assigned to the Service objects.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 通过端口转发，Catalog Service 应用程序暴露给了您的本地机器。Catalog Service 和 PostgreSQL 都通过分配给
    Service 对象的集群本地主机名、IP 地址和端口暴露给集群内部。
- en: So far we’ve been working with only one instance of Catalog Service, but we
    can take advantage of Kubernetes and scale it out. The following section will
    cover how to scale Spring Boot applications and address aspects such as fast startup
    and graceful shutdown, which are essential for cloud native applications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只与 Catalog 服务的一个实例一起工作，但我们可以利用 Kubernetes 来扩展它。下一节将介绍如何扩展 Spring Boot
    应用，并解决诸如快速启动和优雅关闭等问题，这对于云原生应用至关重要。
- en: Note Imagine running all those commands every time you change something in your
    application, and you want to test it locally. It doesn’t look very appealing,
    does it? Don’t worry! In section 7.5 I’ll show you how to set up a local Kubernetes
    development workflow to automate all those operations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：想象一下，每次您在应用中更改某些内容时都要运行所有这些命令，并且您想在本地上测试它。这看起来并不吸引人，对吧？别担心！在第7.5节中，我将向您展示如何设置本地
    Kubernetes 开发工作流程来自动化所有这些操作。
- en: 7.4 Scalability and disposability
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 可扩展性和可丢弃性
- en: Deploying multiple instances of the same application helps in achieving high
    availability. When the workload is high, it can be distributed across different
    replicas. When an instance enters a faulty state and can’t process requests anymore,
    it can be deleted and a new one created. This continuous and dynamic scaling of
    application instances requires stateless and disposable applications, as per the
    15-Factor methodology.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 部署同一应用的多个实例有助于实现高可用性。当负载较高时，它可以在不同的副本之间进行分配。当一个实例进入故障状态并且无法再处理请求时，它可以被删除并创建一个新的实例。这种对应用实例的持续和动态扩展需要无状态和可丢弃的应用，根据15个因素方法。
- en: This section will show you what it means for an application to be disposable,
    how to enable graceful shutdown, and how to scale an application in Kubernetes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示一个应用成为可丢弃应用的意义，如何启用优雅关闭，以及如何在 Kubernetes 中扩展应用。
- en: '7.4.1 Ensuring disposability: Fast startup'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 确保可丢弃性：快速启动
- en: Traditional applications deployed on application servers take quite some time
    to start. It’s not rare for them to take several minutes before they’re ready
    to accept connections. On the other hand, cloud native applications should be
    optimized for starting quickly, taking a few seconds rather than minutes to become
    ready. Spring Boot is already optimized for fast startup, and each new version
    is shipped with more improvements.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 部署在应用服务器上的传统应用启动需要相当长的时间。它们在准备好接受连接之前可能需要几分钟并不罕见。另一方面，云原生应用应该优化快速启动，只需几秒钟而不是几分钟即可准备好。Spring
    Boot 已经针对快速启动进行了优化，并且每个新版本都带来了更多的改进。
- en: Fast startup is relevant in a cloud environment because applications are disposable
    and are frequently created, destroyed, and scaled. The quicker the startup, the
    sooner a new application instance is ready to accept connections.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 快速启动在云环境中很重要，因为应用是可丢弃的，并且经常被创建、销毁和扩展。启动越快，新的应用实例就越快准备好接受连接。
- en: Standard applications, like microservices, are good with a startup time in the
    range of a few seconds. On the other hand, serverless applications usually require
    a faster startup phase in the range of milliseconds rather than seconds. Spring
    Boot covers both needs, but the second use case might require a bit of additional
    configuration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 标准应用，如微服务，对于几秒钟的启动时间表现良好。另一方面，无服务器应用通常需要比秒更快的启动阶段，在毫秒范围内。Spring Boot 涵盖了这两种需求，但第二种用例可能需要一些额外的配置。
- en: In chapter 16, you’ll learn about serverless applications with Spring Cloud
    Function, and I’ll show you how to package them as native images using Spring
    Native and GraalVM. The result will be an application with almost instant startup
    time, reduced resource consumption, and reduced image size.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16章中，您将了解使用 Spring Cloud Function 的无服务器应用，我将向您展示如何使用 Spring Native 和 GraalVM
    将它们打包为原生镜像。结果是具有几乎即时启动时间、减少的资源消耗和减少的镜像大小的应用。
- en: '7.4.2 Ensuring disposability: Graceful shutdown'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 确保可丢弃性：优雅关闭
- en: Having applications start quickly is not enough to address our scalability needs.
    Whenever an application instance is shut down, it must happen gracefully without
    clients experiencing downtime or errors. Gracefully shutting down means the application
    stops accepting new requests, completes all those still in progress, and closes
    any open resources, like database connections.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 仅让应用快速启动不足以解决我们的可扩展性需求。每当一个应用实例关闭时，它必须优雅地发生，而不会让客户端经历停机或错误。优雅关闭意味着应用停止接受新的请求，完成所有仍在进行中的请求，并关闭任何打开的资源，如数据库连接。
- en: All the embedded servers available in Spring Boot support a graceful shutdown
    mode, but in slightly different ways. Tomcat, Jetty, and Netty stop accepting
    new requests entirely when the shutdown signal is received. On the other hand,
    Undertow keeps accepting new requests but immediately replies with an HTTP 503
    response.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot中可用的所有嵌入式服务器都支持优雅关闭模式，但方式略有不同。当接收到关闭信号时，Tomcat、Jetty和Netty完全停止接受新请求。另一方面，Undertow继续接受新请求，但会立即回复HTTP
    503响应。
- en: By default, Spring Boot stops the server immediately after receiving a termination
    signal (SIGTERM). You can switch to a graceful mode by configuring the server.shutdown
    property. You can also configure the *grace period*, which is how long the application
    can spend processing all the pending requests. After the grace period expires,
    the application is terminated even if there are still pending requests. By default,
    the grace period is 30 seconds. You can change it through the spring.lifecycle.timeout-per-shutdown-phase
    property.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot在接收到终止信号（SIGTERM）后立即停止服务器。您可以通过配置server.shutdown属性切换到优雅模式。您还可以配置*宽限期*，即应用程序可以花费多长时间处理所有挂起的请求。宽限期过后，即使还有挂起的请求，应用程序也会被终止。默认的宽限期是30秒。您可以通过spring.lifecycle.timeout-per-shutdown-phase属性来更改它。
- en: 'Let’s configure graceful shutdown for Catalog Service. We could do that via
    environment variables or set it as a default configuration. We’ll go with the
    second option. Open the application.yml file located in the catalog-service/src/main/resources
    folder, and update the configuration as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为目录服务配置优雅关闭。我们可以通过环境变量或将其设置为默认配置来实现。我们将选择第二种方法。打开位于catalog-service/src/main/resources文件夹中的application.yml文件，并按照以下方式更新配置：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Enable graceful shutdown
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用优雅关闭
- en: ❷ Defines a 15 s grace period
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义了15秒的宽限期
- en: Since we’ve modified the application source code, we need to build a new container
    image and load it into minikube. That’s not very efficient, is it? Later in the
    chapter, I’ll show you a better way. For now, follow the procedure I described
    earlier to package Catalog Service as a container image (./gradlew bootBuildImage)
    and load it into the Kubernetes cluster we are using for Polar Bookshop (minikube
    image load catalog -service --profile polar).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经修改了应用程序源代码，我们需要构建一个新的容器镜像并将其加载到minikube中。这并不高效，是吗？在本章的后面部分，我会向您展示一个更好的方法。现在，请按照我之前描述的步骤将目录服务打包为容器镜像（./gradlew
    bootBuildImage）并将其加载到我们用于Polar Bookshop的Kubernetes集群中（minikube image load catalog
    -service --profile polar）。
- en: After enabling application support for graceful shutdown, you need to update
    the Deployment manifest accordingly. When a Pod has to be terminated (for example,
    during a downscaling process or as part of an upgrade), Kubernetes sends a SIGTERM
    signal to it. Spring Boot will intercept that signal and start shutting down gracefully.
    By default, Kubernetes waits for a grace period of 30 seconds. If the Pod is not
    terminated after that period, Kubernetes sends a SIGKILL signal to force the Pod’s
    termination. Since the Spring Boot grace period is lower than the Kubernetes one,
    the application is in control of when it will terminate.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用应用程序支持优雅关闭后，您需要相应地更新部署清单。当一个Pod需要被终止（例如，在缩放过程或作为升级的一部分时），Kubernetes会向其发送SIGTERM信号。Spring
    Boot将拦截该信号并开始优雅地关闭。默认情况下，Kubernetes等待30秒的宽限期。如果在此期间Pod没有被终止，Kubernetes会发送SIGKILL信号强制终止Pod。由于Spring
    Boot的宽限期低于Kubernetes，因此应用程序控制着何时终止。
- en: When it sends the SIGTERM signal to a Pod, Kubernetes will also inform its own
    components to stop forwarding requests to the terminating Pod. Since Kubernetes
    is a distributed system, and the two actions happen in parallel, there is a short
    time window when the terminating Pod might still receive requests, even if it
    has already started the graceful shutdown procedure. When that happens, those
    new requests will be rejected, resulting in errors in the clients. Our goal was
    to make the shutdown procedure transparent to the clients, so that scenario is
    unacceptable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当它向Pod发送SIGTERM信号时，Kubernetes还会通知其自身组件停止将请求转发到正在终止的Pod。由于Kubernetes是一个分布式系统，这两个动作是并行发生的，因此在终止Pod可能仍然接收请求的短暂时间内，可能会出现这种情况，即使它已经开始了优雅关闭过程。当这种情况发生时，这些新请求将被拒绝，导致客户端出现错误。我们的目标是使关闭过程对客户端透明，因此这种情况是不可接受的。
- en: The recommended solution is to delay sending the SIGTERM signal to the Pod so
    that Kubernetes has enough time to spread the news across the cluster. By doing
    so, all Kubernetes components will already know not to send new requests to the
    Pod when it starts the graceful shutdown procedure. Technically, the delay can
    be configured through a preStop hook. Let’s see how we can update the Deployment
    manifest for Catalog Service to support a transparent and graceful shutdown.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的解决方案是延迟向 Pod 发送 SIGTERM 信号，以便 Kubernetes 有足够的时间将消息传播到整个集群。这样做，所有 Kubernetes
    组件在 Pod 开始优雅关闭过程时，都已经知道不要向 Pod 发送新的请求。技术上，延迟可以通过 preStop 钩子进行配置。让我们看看我们如何更新 Catalog
    Service 的 Deployment 清单以支持透明和优雅的关闭。
- en: Open the deployment.yml file located in catalog-service/k8s, and add a preStop
    hook to delay the SIGTERM signal by 5 seconds.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 catalog-service/k8s 的 deployment.yml 文件，并添加一个 preStop 钩子，以延迟 SIGTERM 信号
    5 秒。
- en: Listing 7.4 Configuring a delay in Kubernetes before the shutdown starts
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 在 Kubernetes 中配置关闭开始前的延迟
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Makes Kubernetes wait 5 seconds before sending the SIGTERM signal to the Pod
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 让 Kubernetes 在向 Pod 发送 SIGTERM 信号前等待 5 秒
- en: Finally, apply the updated version of the Deployment object with kubectl apply
    -f k8s/deployment.yml. Kubernetes will reconcile the new desired state and replace
    the existing Pod with a new one for which graceful shutdown is fully configured.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 kubectl apply -f k8s/deployment.yml 应用 Deployment 对象的更新版本。Kubernetes 将协调新的期望状态，并用一个完全配置了优雅关闭的新
    Pod 替换现有的 Pod。
- en: Note When a Pod contains multiple containers, the SIGTERM signal is sent to
    all of them in parallel. Kubernetes will wait up to 30 seconds. If any of the
    containers in the Pod are not terminated yet, it will shut them down forcefully.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当一个 Pod 包含多个容器时，SIGTERM 信号会并行发送到所有容器。Kubernetes 将等待最多 30 秒。如果 Pod 中的任何容器尚未终止，它将强制关闭它们。
- en: Now that we’ve configured the graceful shutdown behavior for Catalog Service,
    let’s look at how to scale it in a Kubernetes cluster.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 Catalog Service 配置了优雅关闭的行为，让我们看看如何在 Kubernetes 集群中对其进行扩展。
- en: 7.4.3 Scaling Spring Boot applications
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 扩展 Spring Boot 应用
- en: Scalability is one of the main properties of a cloud native application, as
    you learned in chapter 1\. To be scalable, applications should be disposable and
    stateless, as per the 15-Factor methodology.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是云原生应用的主要特性之一，正如你在第一章中学到的。为了实现可扩展性，应用应该是可丢弃的和无状态的，按照 15-Factor 方法论。
- en: We handled disposability in the previous section, and Catalog Service is already
    a stateless application. It has no state but relies on a stateful service (the
    PostgreSQL database) to permanently store the data about books. We scale applications
    in and out, and if they weren’t stateless, we would lose the state every time
    an instance is shut down. The general idea is to keep the applications stateless
    and rely on data services for storing the state, just like we do in Catalog Service.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中处理了可丢弃性，并且 Catalog Service 已经是一个无状态的应用。它没有状态，但依赖于有状态的服务（PostgreSQL 数据库）来永久存储关于书籍的数据。我们扩展和缩小应用，如果它们不是无状态的，每次实例关闭时我们都会丢失状态。一般想法是保持应用无状态，并依赖于数据服务来存储状态，就像我们在
    Catalog Service 中做的那样。
- en: In Kubernetes, replication is handled at the Pod level by a ReplicaSet object.
    As you saw earlier, Deployment objects are already configured to use ReplicaSets.
    All you need to do is specify how many replicas you want to be deployed. You can
    do that in the Deployment manifest.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，副本通过 ReplicaSet 对象在 Pod 层级进行管理。正如你之前看到的，Deployment 对象已经配置为使用
    ReplicaSet。你所需要做的就是指定你想要部署的副本数量。你可以在 Deployment 清单中做到这一点。
- en: Open the deployment.yml file located in catalog-service/k8s, and define how
    many replicas of the Pod running Catalog Service you want. Let’s go with two.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 catalog-service/k8s 的 deployment.yml 文件，并定义你想要运行的 Catalog Service Pod 的副本数量。让我们选择两个。
- en: Listing 7.5 Configuring number of replicas for the Catalog Service Pod
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 配置 Catalog Service Pod 的副本数量
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ How many Pod replicas should be deployed
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应部署多少个 Pod 副本
- en: The replication is controlled using labels. In listing 7.5, the configuration
    instructs Kubernetes to manage all Pods with the label app=catalog-service so
    that there are always two replicas running.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 副本是通过标签进行控制的。在列表 7.5 中，配置指示 Kubernetes 管理所有带有标签 app=catalog-service 的 Pod，以确保始终运行两个副本。
- en: 'Let’s check it out. Open a Terminal window, navigate to the catalog-service
    folder, and apply the updated version of the Deployment resource:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看。打开一个终端窗口，导航到 catalog-service 文件夹，并应用 Deployment 资源更新的版本：
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Kubernetes will realize that the actual state (one replica) and the desired
    state (two replicas) don’t match, and it will immediately deploy a new replica
    of Catalog Service. You can verify the result with the following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 会意识到实际状态（一个副本）和期望状态（两个副本）不匹配，并会立即部署一个新的 Catalog 服务副本。您可以使用以下命令来验证结果：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the “age” column, you can tell which Pod is the one that has just been deployed
    to achieve a state with two replicas.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在“年龄”列中，您可以判断哪个 Pod 是刚刚部署以实现两个副本状态的 Pod。
- en: 'What happens if one of them terminates? Let’s find out. Pick one of the two
    Pod replicas and copy its name. For example, I might use the Pod named catalog-service-68bc5659b8-kmwm5.
    Then, from a Terminal window, delete that Pod with the following command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个终止会发生什么？让我们来看看。选择两个 Pod 副本中的一个，并复制其名称。例如，我可能会使用名为 catalog-service-68bc5659b8-kmwm5
    的 Pod。然后，从终端窗口，使用以下命令删除该 Pod：
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Deployment manifest declares two replicas as the desired state. Since there
    is now only one, Kubernetes will immediately step up to ensure the actual state
    and the desired state are aligned. If you inspect the Pods again with kubectl
    get pods -l app=catalog-service, you will still see two Pods, but one of them
    has just been created to replace the deleted Pod. You can identify it by checking
    its age:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 清单声明了两个副本作为期望状态。由于现在只有一个，Kubernetes 会立即采取措施确保实际状态和期望状态一致。如果您再次使用
    kubectl get pods -l app=catalog-service 检查 Pods，您仍然会看到两个 Pods，但其中一个刚刚被创建来替换被删除的
    Pod。您可以通过检查其年龄来识别它：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Under the hood, a ReplicaSet object keeps checking the number of replicas deployed
    and ensures they are always in the desired state. That’s the basic functionality
    on top of which you can configure an autoscaler to dynamically increase or decrease
    the number of Pods, depending on the workload and without having to update the
    manifest every time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，ReplicaSet 对象会持续检查已部署的副本数量，并确保它们始终处于期望状态。这是您可以在其上配置自动扩展器以动态增加或减少 Pod 数量的基本功能，根据工作负载进行调整，而无需每次都更新清单。
- en: 'Before moving on to the next section, make sure you change the number of replicas
    back to one and clean up your cluster by removing all the resources you have created
    so far. First, open a Terminal window, navigate to the catalog-service folder
    where you defined the Kubernetes manifests, and delete all the objects created
    for Catalog Service:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，请确保将副本数量改回一个，并通过删除到目前为止创建的所有资源来清理您的集群。首先，打开一个终端窗口，导航到您定义 Kubernetes
    清单的 catalog-service 文件夹，并删除为 Catalog 服务创建的所有对象：
- en: '[PRE25]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, go to your polar-deployment repository, navigate to the kubernetes/platform/development
    folder, and delete the PostgreSQL installation:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转到您的 polar-deployment 仓库，导航到 kubernetes/platform/development 文件夹，并删除 PostgreSQL
    安装：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 7.5 Local Kubernetes development with Tilt
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 使用 Tilt 进行本地 Kubernetes 开发
- en: 'In the previous sections, you learned about the basic Kubernetes concepts and
    worked with the fundamental objects used to deploy applications to a cluster:
    Pods, ReplicaSets, Deployments, and Services. After defining the Deployment and
    Service manifests, you probably don’t want to keep rebuilding container images
    manually and using the kubectl client to update the Pods whenever you make a change.
    Luckily for you, you don’t have to.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了 Kubernetes 的基本概念，并使用用于将应用程序部署到集群的基本对象：Pods、ReplicaSets、Deployments
    和 Services。在定义 Deployment 和 Service 清单之后，您可能不想手动重新构建容器镜像，并在每次更改时使用 kubectl 客户端更新
    Pods。幸运的是，您不必这样做。
- en: This section will show you how to set up a local Kubernetes development workflow
    to automate steps like building images and applying manifests to a Kubernetes
    cluster. It’s part of implementing the *inner development loop* of working with
    a Kubernetes platform. Tilt takes care of many infrastructural concerns and lets
    you focus more on the business logic of your applications. I’ll also introduce
    Octant, which will help you visualize and manage your Kubernetes objects through
    a convenient GUI.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何设置本地 Kubernetes 开发工作流程来自动化构建镜像和将清单应用到 Kubernetes 集群等步骤。这是实现与 Kubernetes
    平台一起工作的 *内部开发循环* 的一部分。Tilt 负责许多基础设施问题，让您更多地关注应用程序的业务逻辑。我还会介绍 Octant，它将帮助您通过方便的
    GUI 可视化和管理您的 Kubernetes 对象。
- en: 7.5.1 Inner development loop with Tilt
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 使用 Tilt 进行内部开发循环
- en: Tilt ([https://tilt.dev](https://tilt.dev)) aims at providing a good developer
    experience when working on Kubernetes. It’s an open source tool that offers features
    for building, deploying, and managing containerized workloads in your local environment.
    We’ll use some of its basic features to automate a development workflow for a
    specific application, but Tilt can also help you orchestrate the deployment of
    multiple applications and services in a centralized way. You can find information
    about how to install it in section A.4 of appendix A.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Tilt ([https://tilt.dev](https://tilt.dev)) 致力于在 Kubernetes 上工作时提供良好的开发者体验。它是一个开源工具，提供在本地环境中构建、部署和管理容器化工作负载的功能。我们将使用其一些基本功能来自动化特定应用程序的开发工作流程，但
    Tilt 还可以帮助您以集中化的方式编排多个应用程序和服务的部署。您可以在附录 A 的 A.4 节中找到有关如何安装它的信息。
- en: 'Our goal will be to design a workflow that will automate the following steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标将是设计一个工作流程，以自动化以下步骤：
- en: Package a Spring Boot application as a container image using Cloud Native Buildpacks.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用云原生构建包将 Spring Boot 应用程序打包为容器镜像。
- en: Upload the image to a Kubernetes cluster (in our case, the one created with
    minikube).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像上传到 Kubernetes 集群（在我们的例子中，是使用 minikube 创建的）。
- en: Apply all the Kubernetes objects declared in the YAML manifests.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用在 YAML 清单中声明的所有 Kubernetes 对象。
- en: Enable the port-forwarding functionality to access applications from your local
    computer.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用端口转发功能，以便从您的本地计算机访问应用程序。
- en: Give you easy access to the logs from the applications running on the cluster.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让您轻松访问集群上运行的应用程序的日志。
- en: 'Before configuring Tilt, make sure you have a PostgreSQL instance up and running
    in your local Kubernetes cluster. Open a Terminal window, navigate to the kubernetes/
    platform/development folder in your polar-deployment repository, and run the following
    command to deploy PostgreSQL:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 Tilt 之前，请确保您在本地 Kubernetes 集群中有一个正在运行的 PostgreSQL 实例。打开一个终端窗口，导航到您的 polar-deployment
    仓库中的 kubernetes/platform/development 文件夹，并运行以下命令以部署 PostgreSQL：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s now see how to configure Tilt to establish that automated development
    workflow.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何配置 Tilt 以建立自动化的开发工作流程。
- en: 'Tilt can be configured via a *Tiltfile*, an extensible configuration file written
    in Starlark (a simplified Python dialect). Go to your Catalog Service project
    (catalog-service) and create a file named “Tiltfile” (with no extension) in the
    root folder. The file will contain three main configurations:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Tilt 可以通过一个 *Tiltfile* 进行配置，这是一个用 Starlark（一种简化的 Python 方言）编写的可扩展配置文件。转到您的 Catalog
    Service 项目（catalog-service），在根文件夹中创建一个名为“Tiltfile”的文件（不带扩展名）。该文件将包含三个主要配置：
- en: How to build a container image (Cloud Native Buildpacks)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建容器镜像（云原生构建包）
- en: How to deploy the application (Kubernetes YAML manifests)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何部署应用程序（Kubernetes YAML 清单）
- en: How to access the application (port forwarding)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问应用程序（端口转发）
- en: Listing 7.6 Tilt configuration for Catalog Service (Tiltfile)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 为 Catalog Service 配置的 Tilt（Tiltfile）
- en: '[PRE28]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Tip If you’re working on ARM64 machines (such as Apple Silicon computers),
    you can add the --builder ghcr.io/thomasvitale/java-builder-arm64 argument to
    the ./gradlew bootBuildImage --imageName $EXPECTED_REF command to use an experimental
    version of Paketo Buildpacks with ARM64 support. Be aware that it’s experimental
    and not ready for production. For more information, you can refer to the documentation
    on GitHub: [https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您在 ARM64 机器（例如苹果硅电脑）上工作，您可以将 `--builder ghcr.io/thomasvitale/java-builder-arm64`
    参数添加到 `./gradlew bootBuildImage --imageName $EXPECTED_REF` 命令中，以使用带有 ARM64 支持的实验性
    Paketo Buildpacks 版本。请注意，这是实验性的，并不适合生产环境。有关更多信息，您可以参考 GitHub 上的文档：[https://github.com/ThomasVitale/paketo-arm64](https://github.com/ThomasVitale/paketo-arm64)。
- en: The Tiltfile configures Tilt to use the same approach we used throughout the
    chapter for building, loading, deploying, and publishing applications on the local
    Kubernetes cluster. The main difference? It’s all automated now! Let’s give it
    a try.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Tiltfile 配置 Tilt 使用我们在本章中用于在本地 Kubernetes 集群上构建、加载、部署和发布应用程序的相同方法。主要区别是什么？现在一切都是自动化的！让我们试试看。
- en: 'Open a Terminal window, navigate to the root folder of your Catalog Service
    project, and run the following command to start Tilt:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到您的 Catalog Service 项目的根文件夹，并运行以下命令以启动 Tilt：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The process started by the tilt up command will keep running until you explicitly
    stop it with Ctrl-C. One of the useful features provided by Tilt is a convenient
    GUI where you can keep track of the services managed by Tilt, check application
    logs, and trigger updates manually. Go to the URL where Tilt started its services
    (by default, it should be http://localhost:10350), and monitor the process that
    Tilt follows to build and deploy Catalog Service (figure 7.12). The first time
    it can take one or two minutes because the Buildpacks libraries need to be downloaded.
    The subsequent times it will be much faster.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: tilt up 命令启动的过程将持续运行，直到您明确使用 Ctrl-C 停止它。Tilt 提供的一个有用功能是方便的 GUI，您可以在其中跟踪 Tilt
    管理的服务，检查应用程序日志，并手动触发更新。转到 Tilt 启动其服务的 URL（默认情况下，应该是 http://localhost:10350），并监控
    Tilt 构建和部署目录服务（图 7.12）的过程。第一次可能需要一或两分钟，因为需要下载 Buildpacks 库。随后的时间将会快得多。
- en: '![07-12](../Images/07-12.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![07-12](../Images/07-12.png)'
- en: Figure 7.12 Tilt provides a convenient GUI where you can monitor and manage
    applications.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 Tilt 提供了一个方便的 GUI，您可以在其中监控和管理应用程序。
- en: 'Besides building and deploying the application, Tilt has also activated port
    forwarding to your local machine on port 9001. Go ahead and verify that the application
    is working correctly:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建和部署应用程序外，Tilt 还激活了端口转发到您的本地机器的 9001 端口。继续验证应用程序是否正常工作：
- en: '[PRE30]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tilt will keep the application in sync with the source code. Whenever you make
    any change to the application, Tilt will trigger an *update* operation to build
    and deploy a new container image. All of that happens automatically and continuously.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Tilt 将使应用程序与源代码保持同步。无论何时您对应用程序进行任何更改，Tilt 都将触发一个 *更新* 操作来构建和部署一个新的容器镜像。所有这些都会自动且持续进行。
- en: Note Rebuilding the whole container image every time you change something in
    your code is not very efficient. You can configure Tilt to synchronize only the
    changed files and upload them into the current image. To achieve that, you can
    rely on the features offered by Spring Boot DevTools ([https://mng.bz/nY8v](https://mng.bz/nY8v))
    and Paketo Buildpacks ([https://mng.bz/vo5x](https://mng.bz/vo5x)).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每次在代码中更改内容时重新构建整个容器镜像并不高效。您可以通过配置 Tilt 仅同步更改的文件并将它们上传到当前镜像来实现这一点。为此，您可以使用
    Spring Boot DevTools ([https://mng.bz/nY8v](https://mng.bz/nY8v)) 和 Paketo Buildpacks
    ([https://mng.bz/vo5x](https://mng.bz/vo5x)) 提供的功能。
- en: 'When you’re done testing the application, stop the Tilt process in the Catalog
    Service project and run the following command to undeploy the application:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成应用程序的测试后，在目录服务项目中停止 Tilt 进程，并运行以下命令来卸载应用程序：
- en: '[PRE31]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 7.5.2 Visualizing your Kubernetes workloads with Octant
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 使用 Octant 可视化您的 Kubernetes 工作负载
- en: When you start deploying multiple applications to a Kubernetes cluster, it can
    become challenging to manage all the related Kubernetes objects or investigate
    failures when they happen. There are different solutions for visualizing and managing
    Kubernetes workloads. This section will cover Octant ([https://octant.dev](https://octant.dev)),
    an “open source developer-centric web interface for Kubernetes that lets you inspect
    a Kubernetes cluster and its applications.” You can find information about how
    to install it in section A.4 of appendix A.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始将多个应用程序部署到 Kubernetes 集群时，管理所有相关的 Kubernetes 对象或调查发生故障时可能会变得具有挑战性。有不同解决方案用于可视化和管理
    Kubernetes 工作负载。本节将介绍 Octant ([https://octant.dev](https://octant.dev))，这是一个“针对
    Kubernetes 的开源开发者中心化网络界面，允许您检查 Kubernetes 集群及其应用程序。”您可以在附录 A 的 A.4 节中找到有关如何安装它的信息。
- en: 'I expect you still have the local Kubernetes cluster you used in the previous
    section up and running and PostgreSQL deployed. You can also deploy Catalog Service
    by going into the project’s root folder and running tilt up. Then, open a new
    Terminal window and run the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计您仍然运行着上一节中使用的本地 Kubernetes 集群和已部署的 PostgreSQL。您也可以通过进入项目的根目录并运行 tilt up 来部署目录服务。然后，打开一个新的终端窗口并运行以下命令：
- en: '[PRE32]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will open the Octant Dashboard in your browser (usually at http://localhost:7777).
    Figure 7.13 shows the Dashboard. The Overview page provides a picture of all the
    Kubernetes objects running in the cluster. If you followed along, you should have
    PostgreSQL and Catalog Service running in the cluster.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在您的浏览器中打开 Octant 仪表板（通常位于 http://localhost:7777）。图 7.13 展示了仪表板。概览页面提供了集群中所有运行的
    Kubernetes 对象的概览。如果您一直跟随操作，您应该在集群中运行 PostgreSQL 和目录服务。
- en: '![07-13](../Images/07-13.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![07-13](../Images/07-13.png)'
- en: Figure 7.13 Octant offers a web interface for inspecting a Kubernetes cluster
    and its workloads.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 Octant 为检查 Kubernetes 集群及其工作负载提供了一个网络界面。
- en: From the Overview page you can expand the objects to get more details. For example,
    if you click the item corresponding to the Catalog Service Pod, you’ll get access
    to information about the object, as shown in figure 7.14\. You can also perform
    several operations like enabling port forwarding, reading the logs, modifying
    the Pod’s manifest, and investigating failures.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从概述页面，你可以展开对象以获取更多详细信息。例如，如果你点击对应于目录服务 Pod 的项目，你将获得有关该对象的信息，如图 7.14 所示。你还可以执行一些操作，如启用端口转发、读取日志、修改
    Pod 的清单以及调查故障。
- en: '![07-14](../Images/07-14.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![07-14](../Images/07-14.png)'
- en: Figure 7.14 Octant lets you access Pod information easily, check their logs,
    and enable a port forward.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 Octant 允许你轻松访问 Pod 信息，检查它们的日志，并启用端口转发。
- en: Take your time exploring the many features provided by Octant. It’s a convenient
    tool that you can use to inspect and troubleshoot a local Kubernetes cluster or
    a remote one. We’ll also use Octant to examine the remote production cluster where
    we’ll deploy the Polar Bookshop application. For now, close Octant by stopping
    its process with Ctrl-C.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细探索 Octant 提供的众多功能。这是一个方便的工具，你可以用它来检查和调试本地 Kubernetes 集群或远程集群。我们还将使用 Octant
    来检查我们将部署 Polar Bookshop 应用程序的生产集群。现在，通过使用 Ctrl-C 停止其进程来关闭 Octant。
- en: 'When you’re done, you can stop the Tilt process in the Catalog Service project
    and run tilt down to undeploy the application. Then go to your polar-deployment
    repository, navigate to the kubernetes/platform/development folder, and delete
    the PostgreSQL installation with kubectl delete -f services. Finally, stop the
    cluster as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成操作后，你可以在目录服务项目中停止 Tilt 进程，并运行 tilt 以卸载应用程序。然后前往你的 polar-deployment 仓库，导航到
    kubernetes/platform/development 文件夹，并使用 kubectl delete -f services 删除 PostgreSQL
    安装。最后，按照以下步骤停止集群：
- en: '[PRE33]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '7.6 Deployment pipeline: Validate Kubernetes manifests'
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 部署管道：验证 Kubernetes 清单
- en: 'Chapter 3 introduced the concept of a deployment pipeline and its importance
    in the continuous delivery approach for delivering software quickly, reliably,
    and safely. So far we’ve automated the first part of a deployment pipeline: the
    commit stage. After a developer commits new code to the mainline, this stage goes
    through build, unit tests, integration tests, static code analysis, and packaging.
    At the end of this stage, an executable application artifact is published to an
    artifact repository. That is a *release candidate*.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章介绍了部署管道的概念及其在快速、可靠和安全地交付软件的持续交付方法中的重要性。到目前为止，我们已经自动化了部署管道的第一部分：提交阶段。当开发者将新代码提交到主线后，这一阶段将经历构建、单元测试、集成测试、静态代码分析和打包。在这个阶段的末尾，可执行的应用程序工件被发布到工件存储库。这被称为
    *发布候选*。
- en: In this chapter, you learned how to deploy Spring Boot applications on Kubernetes
    using a declarative approach based on *resource manifests*. They are fundamental
    to a successful deployment of the release candidate on Kubernetes, so we should
    guarantee their correctness. This section will show you how to validate Kubernetes
    manifests as part of the commit stage.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用基于 *资源清单* 的声明性方法在 Kubernetes 上部署 Spring Boot 应用程序。它们对于在 Kubernetes
    上成功部署发布候选版本至关重要，因此我们应该保证它们的正确性。本节将向你展示如何在提交阶段验证 Kubernetes 清单。
- en: 7.6.1 Validating Kubernetes manifests in the commit stage
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 在提交阶段验证 Kubernetes 清单
- en: Throughout this chapter, we’ve worked with resource manifests for creating Deployments
    and Services in a Kubernetes cluster. A *manifest* is “a specification of a Kubernetes
    API object in JSON or YAML format.” It specifies “the desired state of an object
    that Kubernetes will maintain when you apply the manifest” ([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary)).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们一直在使用资源清单在 Kubernetes 集群中创建 Deployments 和 Services。*清单* 是“Kubernetes
    API 对象的 JSON 或 YAML 格式规范。”它指定了“当你应用清单时 Kubernetes 将维护的对象的期望状态” ([https://kubernetes.io/docs/reference/glossary](https://kubernetes.io/docs/reference/glossary))。
- en: Since a manifest specifies the desired state of an object, we should ensure
    that our specification complies with the API exposed by Kubernetes. It’s a good
    idea to automate this validation in the commit stage of a deployment pipeline
    to get fast feedback in case of errors (rather than waiting until the acceptance
    stage, where we need to use those manifests to deploy the application in a Kubernetes
    cluster). Figure 7.15 illustrates the main steps of the commit stage after including
    the validation of Kubernetes manifests.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于清单指定了对象的期望状态，我们应该确保我们的规范符合 Kubernetes 提供的 API。在部署管道的提交阶段自动进行此验证是一个好主意，以便在出现错误时快速获得反馈（而不是等到验收阶段，那时我们需要使用这些清单在
    Kubernetes 集群中部署应用程序）。图 7.15 展示了包含 Kubernetes 清单验证的提交阶段的主要步骤。
- en: '![07-15](../Images/07-15.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![07-15](../Images/07-15.png)'
- en: Figure 7.15 When Kubernetes manifests are included in the application repository,
    a new step in the commit stage is included to validate them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 当 Kubernetes 清单包含在应用程序仓库中时，提交阶段将包含一个新步骤来验证它们。
- en: There are several ways of validating Kubernetes manifests against the Kubernetes
    API. We’ll use Kubeval ([www.kubeval.com](http://www.kubeval.com)), an open source
    tool. You can find information about how to install it in section A.4 of appendix
    A.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以验证 Kubernetes 清单与 Kubernetes API 的兼容性。我们将使用 Kubeval ([www.kubeval.com](http://www.kubeval.com))，这是一个开源工具。您可以在附录
    A 的 A.4 节中找到有关如何安装它的信息。
- en: 'Let’s see how it works. Open a Terminal window and navigate to the root folder
    of your Catalog Service project (catalog-service). Then use the kubeval command
    to validate the Kubernetes manifests within the k8s directory (-d k8s). The --strict
    flag disallows adding additional properties not defined in the object schema:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。打开一个终端窗口，导航到您的目录服务项目（catalog-service）的根目录。然后使用 kubeval 命令验证 k8s
    目录中的 Kubernetes 清单（-d k8s）。--strict 标志禁止添加对象模式中未定义的额外属性：
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section, you’ll see how to use Kubeval in the commit stage workflow
    we implemented with GitHub Actions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到如何使用 Kubeval 在我们使用 GitHub Actions 实现的提交阶段工作流程中。
- en: 7.6.2 Automating Kubernetes manifests validation with GitHub Actions
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 使用 GitHub Actions 自动化 Kubernetes 清单验证
- en: GitHub Actions is the workflow engine we used to implement the commit stage
    for the Catalog Service’s deployment pipeline. Let’s extend it to include the
    Kubernetes manifest validation step, as illustrated in figure 7.15.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是我们用来实现目录服务部署管道提交阶段的工作流程引擎。让我们扩展它以包含 Kubernetes 清单验证步骤，如图 7.15
    所示。
- en: Go to your Catalog Service project (catalog-service), and open the commit-stage.yml
    file within the .github/workflows folder. To implement the validation step, we’ll
    rely on an action built by Stefan Prodan. He’s the maintainer of FluxCD, a CNCF-incubating
    project providing a continuous deployment solution on Kubernetes based on the
    GitOps principles. The action lets you install specific versions of useful Kubernetes-related
    tools. We’ll configure the action to install kubectl and Kubeval.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前往您的目录服务项目（catalog-service），并在 .github/workflows 文件夹中打开 commit-stage.yml 文件。为了实现验证步骤，我们将依赖
    Stefan Prodan 构建的操作。他是 FluxCD 的维护者，FluxCD 是一个 CNCF 孵化项目，基于 GitOps 原则提供 Kubernetes
    上的持续部署解决方案。该操作允许您安装特定版本的实用 Kubernetes 相关工具。我们将配置该操作以安装 kubectl 和 Kubeval。
- en: Listing 7.7 Validating the Kubernetes manifests for Catalog Service
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 验证目录服务的 Kubernetes 清单
- en: '[PRE35]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ An action capable of installing useful tools to work with Kubernetes
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个能够安装用于与 Kubernetes 一起工作的有用工具的操作
- en: ❷ Includes the Kubernetes CLI in the installation
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在安装中包含 Kubernetes CLI
- en: ❸ Includes Kubeval in the installation
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在安装中包含 Kubeval
- en: ❹ Uses Kubeval to validate the Kubernetes manifests in the k8s folder
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 Kubeval 验证 k8s 文件夹中的 Kubernetes 清单
- en: After updating the commit-stage.yml file with the additional validation step,
    you can commit and push your changes to your catalog-service repository on GitHub
    and verify that the commit stage workflow completes successfully, meaning what
    you included in the manifests is compliant with the Kubernetes API.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在将附加验证步骤更新到 commit-stage.yml 文件后，您可以将更改提交并推送到 GitHub 上的 catalog-service 仓库，并验证提交阶段工作流程是否成功完成，这意味着您包含在清单中的内容与
    Kubernetes API 兼容。
- en: Polar Labs
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Labs
- en: Feel free to apply what you learned in this chapter to Config Service and prepare
    the application for deployment.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 随意将本章学到的知识应用到配置服务中，并为部署准备应用程序。
- en: Configure graceful shutdown and a grace period for the application.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置应用程序的优雅关闭和宽限期。
- en: Write the Deployment and Service manifests for deploying Config Service to a
    Kubernetes cluster.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为将 Config 服务部署到 Kubernetes 集群编写部署和服务清单。
- en: Update the commit stage of the deployment pipeline for Config Service to validate
    the Kubernetes manifests.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新部署管道中 Config 服务的提交阶段以验证 Kubernetes 清单。
- en: Configure the Catalog Service Deployment with the Config Service URL via the
    SPRING_CLOUD_CONFIG_URI environment variable, relying on the Kubernetes native
    service discovery feature.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 SPRING_CLOUD_CONFIG_URI 环境变量，使用 Config 服务 URL 配置目录服务部署，依赖于 Kubernetes 原生的服务发现功能。
- en: Configure Tilt to automate the Config Service deployment to your local Kubernetes
    cluster bootstrapped with minikube.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Tilt 以自动化将 Config 服务部署到使用 minikube 引导的本地 Kubernetes 集群。
- en: When you’re done, try deploying all the components of the Polar Bookshop system
    we’ve built so far, and check their status in Octant. You can refer to the Chapter07/
    07-end folder in the code repository accompanying the book to check the final
    result ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，尝试部署我们迄今为止构建的 Polar Bookshop 系统的所有组件，并在 Octant 中检查它们的状态。您可以通过查看书中附带的代码仓库中的
    Chapter07/ 07-end 文件夹来检查最终结果 ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))。
- en: Congratulations!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Docker works fine when running single-instance containers on a single machine.
    When your system needs properties like scalability and resilience, you can use
    Kubernetes.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 在单机运行单实例容器时运行良好。当您的系统需要像可扩展性和弹性这样的属性时，您可以使用 Kubernetes。
- en: Kubernetes provides all the features for scaling containers across a cluster
    of machines, ensuring resilience both when a container fails and when a machine
    goes down.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 提供了在机器集群中扩展容器的所有功能，确保在容器失败和机器宕机时都具有弹性。
- en: Pods are the smallest deployable units in Kubernetes.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 是 Kubernetes 中最小的可部署单元。
- en: Rather than creating Pods directly, you can use a Deployment object to declare
    the desired state for your applications, and Kubernetes will ensure it matches
    the actual state. That includes having the desired number of replicas up and running
    at any time.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是直接创建 Pod，您可以使用 Deployment 对象来声明应用程序的期望状态，Kubernetes 将确保它匹配实际状态。这包括在任何时候都有期望数量的副本正在运行。
- en: The cloud is a dynamic environment, and the topology keeps changing. Service
    discovery and load balancing let you dynamically establish interactions between
    services, managed either on the client side (for example, using Spring Cloud Netflix
    Eureka) or on the server side (for example, using Kubernetes).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云是一个动态的环境，拓扑结构不断变化。服务发现和负载均衡让您能够动态地建立服务之间的交互，这些服务可以在客户端（例如，使用 Spring Cloud Netflix
    Eureka）或服务器端（例如，使用 Kubernetes）管理。
- en: Kubernetes provides a native service-discovery and load-balancing feature that
    you can use through the Service objects.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 提供了原生的服务发现和负载均衡功能，您可以通过 Service 对象来使用这些功能。
- en: Each Service name can be used as a DNS name. Kubernetes will resolve the name
    to the Service IP address and, ultimately, forward the request to one of the instances
    available.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务名称都可以用作 DNS 名称。Kubernetes 将解析该名称到服务 IP 地址，并最终将请求转发到可用的实例之一。
- en: 'You can deploy Spring Boot applications to a Kubernetes cluster by defining
    two YAML manifests: one for the Deployment object and one for the Service object.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过定义两个 YAML 清单将 Spring Boot 应用程序部署到 Kubernetes 集群：一个用于 Deployment 对象，另一个用于
    Service 对象。
- en: The kubectl client lets you create objects from a file with the command kubectl
    apply -f <your-file.yml>.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl 客户端允许您使用命令 kubectl apply -f <your-file.yml> 从文件创建对象。
- en: Cloud native applications should be disposable (fast startup and graceful shutdown)
    and stateless (rely on data services for storing the state).
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用程序应该是可丢弃的（快速启动和优雅关闭）并且无状态的（依赖于数据服务来存储状态）。
- en: Graceful shutdown is supported both by Spring Boot and Kubernetes and is an
    essential aspect of scalable applications.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅关闭在 Spring Boot 和 Kubernetes 中都受到支持，并且是可扩展应用程序的一个基本方面。
- en: Kubernetes uses ReplicaSet controllers to replicate your application Pods and
    keep them running.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 使用 ReplicaSet 控制器来复制您的应用程序 Pod 并保持它们运行。
- en: 'Tilt is a tool that automates your local development workflow with Kubernetes:
    you work on the application while Tilt takes care of building the image, deploying
    it to your local Kubernetes cluster, and keeping it up-to-date whenever you change
    something in the code.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tilt 是一个工具，它通过 Kubernetes 自动化你的本地开发工作流程：你专注于应用开发，而 Tilt 则负责构建镜像、将镜像部署到你的本地 Kubernetes
    集群，并在你更改代码时保持其最新状态。
- en: You can start Tilt for your project with tilt up.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过运行 `tilt up` 来为你的项目启动 Tilt。
- en: The Octant dashboard lets you visualize your Kubernetes workloads.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Octant 仪表板让你能够可视化你的 Kubernetes 工作负载。
- en: Octant is a convenient tool that you can use not only for inspecting and troubleshooting
    a local Kubernetes cluster but also for a remote one.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Octant 是一个方便的工具，你可以用它不仅来检查和排除本地 Kubernetes 集群的故障，也可以用于远程集群。
- en: Kubeval is a convenient tool you can use to validate Kubernetes manifests. It’s
    particularly useful when it’s included in your deployment pipeline.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubeval 是一个方便的工具，你可以用它来验证 Kubernetes 清单。当它包含在你的部署管道中时，尤其有用。
