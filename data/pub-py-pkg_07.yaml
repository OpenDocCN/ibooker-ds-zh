- en: 7 Automating work through continuous integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 通过持续集成自动化工作
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Automating code quality checks on each change using GitHub Actions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub Actions在每次更改上自动化代码质量检查
- en: Building distributions for a variety of platforms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为各种平台构建发行版
- en: Publishing distributions to PyPI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到PyPI的发行版
- en: Throughout the course of the previous chapters, you’ve built up a repertoire
    of tasks you execute each time you change your package so that you can maintain
    functionality and code quality. This is a huge stride in building confidence in
    changes, but doing all this locally on your own computer is still a big limitation,
    as you’ve already seen when interacting with the team over at CarCorp. You may
    have trouble remembering all the steps that go into verifying a change, and people
    just starting to work on the project may struggle even more. Even when they perform
    their due diligence, you can’t directly verify commands they run locally unless
    you’re supervising them. This is difficult enough with a team of a few people,
    but it becomes impossible in the open source world, where you may not even know
    the person contributing code changes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章的过程中，你已经建立了一套任务库，每次更改你的包时都会执行这些任务，以便你可以保持功能性和代码质量。这是在建立对更改的信心方面迈出的巨大一步，但像你之前在与CarCorp团队互动时所看到的那样，在个人电脑上本地执行所有这些操作仍然是一个很大的限制。你可能难以记住验证更改所需的所有步骤，而对于刚开始参与项目的人来说，这可能更加困难。即使他们进行了尽职调查，除非你在监督他们，否则你无法直接验证他们在本地运行的命令。对于只有几个人的团队来说，这已经足够困难，但在开源世界中，你可能甚至不知道贡献代码更改的人是谁。
- en: In this chapter, you’ll create a pipeline for your package to bring automation
    to nearly every aspect of the packaging process—aside from writing the code, of
    course. Before getting too deep into the details of setting up this pipeline,
    you first need to understand the high-level flow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将为你的包创建一个流水线，将自动化引入包装过程的几乎所有方面——当然，除了编写代码之外。在深入设置此流水线的细节之前，你首先需要了解其高级流程。
- en: Important You can use the code companion ([http://mng.bz/69A5](http://mng.bz/69A5))
    to check your work for the exercises in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 你可以使用代码伴侣（[http://mng.bz/69A5](http://mng.bz/69A5)）来检查本章练习中的工作。
- en: 7.1 The continuous integration workflow
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 持续集成工作流程
- en: Imagine you’ve onboarded several new developers to your project to continue
    taking on new vehicle clients. Your team has spent the last several weeks getting
    ready for the next release of your package, and you finally shipped the new version
    earlier in the day. As your team celebrates, the incessant vibration of your phone
    gives you the sinking feeling that something is wrong. It turns out that the developer
    who worked on the final changes before release forgot to run the unit tests, and
    the last change broke a core piece of functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你已经将几位新开发者纳入你的项目，以继续承担新的车辆客户。你的团队已经花了几个星期的时间为下一个版本的包做准备，你今天早上终于发布了新版本。当你的团队庆祝时，你手机的持续振动让你有一种不祥的预感。结果证明，在发布前进行最后更改的开发者忘记运行单元测试，最后一个更改破坏了核心功能的一部分。
- en: You need a system in place that can run the valuable checks you’ve developed
    on each change automatically in an environment where everyone working on the project
    can confirm their status. These *continuous integration* systems are another major
    stride in productivity and confidence in your project as it evolves.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个系统，可以在一个每个人都可以确认其状态的环境中自动运行你在每个更改上开发的宝贵检查。这些*持续集成*系统是随着项目的发展在生产力方面和对你项目的信心方面迈出的另一个重大步伐。
- en: Definition Continuous integration (CI) is the practice of incorporating changes
    as often as possible into the main stream of development for a project to minimize
    the possibility of behavior that diverges from the desired or expected behavior.
    CI is diametrically opposed to the early practices of large software projects
    where development might go on for months or years before being merged and released.
    CI encourages small, incremental changes with the aim of delivering value earlier
    and more frequently.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 持续集成（CI）是将更改尽可能频繁地纳入项目的主干开发流程的实践，以最大限度地减少出现与预期或期望行为不一致的行为的可能性。持续集成与大型软件项目早期实践截然相反，在合并和发布之前，开发可能持续数月或数年。持续集成鼓励小而渐进的更改，目的是更早、更频繁地交付价值。
- en: For in-depth coverage of continuous integration, check out *Grokking Continuous
    Delivery* (Manning, 2022, [http://mng.bz/82M5](http://mng.bz/82M5)) by Christie
    Wilson and *Pipeline as Code* (Manning, 2021, [https://www.manning.com/books/pipeline-as-code](https://www.manning.com/books/pipeline-as-code))
    by Mohamed Labouardy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解持续集成，请参阅Christie Wilson所著的*Grokking Continuous Delivery*（Manning，2022，[http://mng.bz/82M5](http://mng.bz/82M5)）和Mohamed
    Labouardy所著的*Pipeline as Code*（Manning，2021，[https://www.manning.com/books/pipeline-as-code](https://www.manning.com/books/pipeline-as-code)）。
- en: Most continuous integration workflows consist of the same basic steps, as shown
    in figure 7.1\. The automatic *build* and *test* steps are the gaps in your current
    process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数持续集成工作流程都包含相同的基本步骤，如图7.1所示。自动的*构建*和*测试*步骤是您当前流程中的空白。
- en: '![](../../OEBPS/Images/07-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-01.png)'
- en: Figure 7.1 A basic continuous integration workflow gives developers an automated
    feedback loop about their changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 基本的持续集成工作流程为开发者提供了一个关于他们更改的自动反馈循环。
- en: 'Because the automated building and testing steps are performed in a shared
    location, you and your team can verify that a given change works as expected,
    regardless of any testing steps the author of the change performed locally. This
    is a key shift: local testing can now focus on writing new tests or updating existing
    tests in quick iterations, and running the full test suite becomes an optional
    convenience. Developers have options during their implementation based on their
    capacity at the moment, instead of being forced to do things one very specific
    way.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自动构建和测试步骤是在共享位置执行的，因此您和您的团队能够验证给定的更改是否按预期工作，无论更改作者在本地执行了哪些测试步骤。这是一个关键的转变：本地测试现在可以专注于快速迭代中编写新测试或更新现有测试，而运行完整测试套件则成为可选的便利。开发者可以根据他们当前的能力在实施过程中有选择，而不是被迫以非常具体的方式行事。
- en: Now that you’re familiar with the basic flow of continuous integration, you
    can start working toward building one using freely available tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了持续集成的基本流程，您就可以开始使用免费工具构建一个了。
- en: 7.2 Continuous integration with GitHub Actions
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 使用GitHub Actions进行持续集成
- en: Before merging any new code, you decide each change to the project should be
    verified, recorded, and published using a CI pipeline in a shared environment.
    This removes any variability due to someone’s local configuration and prevents
    the scenario where someone publishes a package version from their computer that
    never gets incorporated into the code base. Because your team has been using GitHub
    to host the code base and collaborate on changes, you decide to give GitHub Actions
    ([https://github.com/features/actions](https://github.com/features/actions)) a
    try.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并任何新代码之前，您决定每个对项目的更改都应该通过共享环境中的CI管道进行验证、记录和发布。这消除了由于某人本地配置引起的任何变化，并防止了有人从他们的计算机发布一个永远不会被整合到代码库中的软件包版本的情况。因为您的团队一直在使用GitHub托管代码库并协作更改，您决定尝试GitHub
    Actions ([https://github.com/features/actions](https://github.com/features/actions))。
- en: Other continuous integration solutions
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其他持续集成解决方案
- en: Although I’ve chosen to cover GitHub Actions in this book, it’s just one of
    a wide variety of options out there. Most continuous integration solutions have
    strong overlap in their concepts, so learning a different platform is often a
    matter of understanding their particular lingo.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我选择在本书中介绍GitHub Actions，但它只是众多选项中的一个。大多数持续集成解决方案在概念上都有很强的重叠，因此学习不同的平台通常只是理解它们的特定术语的问题。
- en: 'Some widely used cloud-first CI solutions follow:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些广泛使用的以云为先的CI解决方案如下：
- en: GitLab CI/CD ([https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/))
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab CI/CD ([https://docs.gitlab.com/ee/ci/](https://docs.gitlab.com/ee/ci/))
- en: CircleCI ([https://circleci.com/](https://circleci.com/))
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CircleCI ([https://circleci.com/](https://circleci.com/))
- en: Azure DevOps ([https://azure.microsoft.com/en-us/services/devops](https://azure.microsoft.com/en-us/services/devops))
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure DevOps ([https://azure.microsoft.com/en-us/services/devops](https://azure.microsoft.com/en-us/services/devops))
- en: Google Cloud Build ([https://cloud.google.com/build](https://cloud.google.com/build))
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Build ([https://cloud.google.com/build](https://cloud.google.com/build))
- en: It can be useful to choose one of these if it aligns with your existing choice
    of cloud provider for personal or organizational work. Jenkins ([https://www.jenkins.io/](https://www.jenkins.io/))
    is an open source solution that typically requires a bit more effort on your part
    but might be nice if you want full end-to-end control.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它与您在个人或组织工作中选择的现有云服务提供商相匹配，选择其中之一可能是有用的。Jenkins ([https://www.jenkins.io/](https://www.jenkins.io/))
    是一个开源解决方案，通常需要您付出更多努力，但如果您想要完全端到端控制，它可能是个不错的选择。
- en: I strongly recommend staying away from Travis CI, and I won’t link to it here.
    Although it used to be one of the most beloved platforms for open source projects,
    it has suffered from slow feature development, poor communication, security concerns,
    and a push toward paid plans since its acquisition in 2019.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议远离Travis CI，并且在这里不会提供链接。尽管它曾经是开源项目中最受欢迎的平台之一，但自从2019年被收购以来，它经历了功能发展缓慢、沟通不佳、安全问题以及对付费计划的推动。
- en: To work effectively with GitHub Actions, you need to understand the high-level
    workflow, the GitHub Actions–specific terminology, and the configuration format
    in the following sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地使用GitHub Actions，您需要了解以下部分中的高级工作流程、GitHub Actions特定的术语和配置格式。
- en: 7.2.1 A high-level GitHub Actions workflow
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 高级GitHub Actions工作流程
- en: 'In your new pipeline, any time you open a pull request or push new commits
    to GitHub, the CI pipeline checks out the code from your branch and performs the
    following in parallel:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的新管道中，每次您打开一个拉取请求或向GitHub推送新的提交时，CI管道都会从您的分支检出代码，并并行执行以下操作：
- en: Checks code formatting using `black` and the `format` tox environment
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`black`和`format` tox环境检查代码格式
- en: Lints the code using flake8 and the `lint` tox environment
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用flake8和`lint` tox环境进行代码格式检查
- en: Type checks the code using mypy and the `typecheck` tox environment
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用mypy和`typecheck` tox环境进行类型检查
- en: Unit tests the code using pytest and the default tox environment
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pytest和默认tox环境进行单元测试
- en: Builds a source distribution using `build`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`build`构建源发行版
- en: Builds binary wheel distributions using `build` and cibuildwheel (more on this
    later in the chapter)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`build`和cibuildwheel构建二进制wheel发行版（关于这一点将在本章后面详细介绍）
- en: Whenever you tag a commit, the pipeline additionally publishes the distributions
    to PyPI. Figure 7.2 depicts this flow at a high level.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您标记一个提交时，管道还会将发行版发布到PyPI。图7.2以高级别描述了此流程。
- en: '![](../../OEBPS/Images/07-02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-02.png)'
- en: Figure 7.2 A continuous integration pipeline flow for Python packaging using
    GitHub Actions
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 使用GitHub Actions进行Python打包的持续集成管道流程
- en: You’re locking all the testing and code quality work you did into an automated
    pipeline. In the future, if you change how one of your tox environments works
    or add a new kind of check, you can add them to your pipeline as well. This investment
    will pay dividends with each new process you create.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在将所有测试和代码质量工作锁定到一个自动化管道中。在未来，如果您更改了其中一个tox环境的工作方式或添加了新的检查类型，您也可以将它们添加到您的管道中。随着您创建的新流程，这种投资将带来回报。
- en: 7.2.2 Understanding GitHub Actions terminology
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 理解GitHub Actions术语
- en: 'You need to make use of the following GitHub Actions concepts to build your
    CI pipeline:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用以下GitHub Actions概念来构建您的CI管道：
- en: '*Workflow*—The highest level of granularity for a CI pipeline. You can create
    multiple workflows that happen in response to different events.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*工作流程*—CI管道的最高粒度级别。您可以根据不同的事件创建多个工作流程。'
- en: '*Job*—A high-level phase you define for a workflow, such as building or testing
    something.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作业*—您为工作流程定义的一个高级阶段，例如构建或测试某些内容。'
- en: '*Step*—A specific task you define in a job, usually consisting of a single
    shell command. Steps can also reference other predefined actions, which is useful
    when building off of common tasks like checking out your code.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤*—您在作业中定义的特定任务，通常由单个shell命令组成。步骤还可以引用其他预定义的操作，这在构建基于常见任务（如检出您的代码）时非常有用。'
- en: '*Trigger*—An event or activity that causes a workflow to happen. Even when
    a workflow is triggered, you can skip jobs in that workflow conditionally with
    expressions.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*触发器*—导致工作流程发生的事件或活动。即使工作流程被触发，您也可以使用表达式有条件地跳过该工作流程中的作业。'
- en: '*Expression*—One of a set of GitHub-specific conditions and values that you
    can check to control your CI pipeline.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表达式*—一组GitHub特定的条件和值之一，您可以使用它来检查并控制您的CI管道。'
- en: For now, you need just one workflow consisting of several jobs, some of which
    run conditionally based on the triggering event. Each job has several similar
    steps to install dependencies and tools and finally run a task. The workflow is
    triggered by pull requests and tags that you create. Figure 7.3 shows the same
    CI pipeline you saw earlier, this time pointing out how these different moving
    parts map to GitHub Actions concepts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您只需要一个包含多个作业的工作流程，其中一些作业根据触发事件有条件地运行。每个作业都有几个类似的步骤来安装依赖项和工具，并最终运行任务。工作流程由您创建的拉取请求和标签触发。图
    7.3 展示了您之前看到的相同的 CI 管道，这次指出了这些不同的移动部分如何映射到 GitHub Actions 概念。
- en: '![](../../OEBPS/Images/07-03.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-03.png)'
- en: Figure 7.3 How different parts of a continuous integration pipeline map to GitHub
    Actions concepts
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 连续集成管道的不同部分如何映射到 GitHub Actions 概念
- en: Understanding GitHub Actions in depth
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 深入理解 GitHub Actions
- en: Teaching all of what GitHub Actions has to offer is outside the scope of this
    book, but if you’d like to explore more features, you can follow GitHub’s learning
    materials ([http://mng.bz/E0WX](http://mng.bz/E0WX)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 教授 GitHub Actions 提供的所有内容超出了本书的范围，但如果您想探索更多功能，可以参考 GitHub 的学习材料 ([http://mng.bz/E0WX](http://mng.bz/E0WX))。
- en: With the terminology in hand, you’re ready to start building a GitHub Actions
    workflow for your package.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些术语后，您就可以开始构建您的包的 GitHub Actions 工作流程了。
- en: Important If you haven’t done so yet, now is a good time to bring your project
    under version control in a Git repository and push it to GitHub. If you aren’t
    familiar with Git or GitHub, pause here and take some time to familiarize yourself.
    Their documentation ([http://mng.bz/N56v](http://mng.bz/N56v)) and *Git in Practice*
    by Mike McQuaid (Manning, 2014, [https://www.manning.com/books/git-in-practice](https://www.manning.com/books/git-in-practice))
    are good resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：如果您还没有这样做，现在是时候将您的项目纳入 Git 仓库的版本控制，并将其推送到 GitHub。如果您不熟悉 Git 或 GitHub，请在此处暂停，并花些时间熟悉它们。他们的文档
    ([http://mng.bz/N56v](http://mng.bz/N56v)) 和 Mike McQuaid 的《Git in Practice》（Manning，2014，[https://www.manning.com/books/git-in-practice](https://www.manning.com/books/git-in-practice)）是很好的资源。
- en: 7.2.3 Starting a GitHub Actions workflow configuration
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 开始配置 GitHub Actions 工作流程
- en: You configure GitHub Actions workflows using YAML ([https://yaml.org/](https://yaml.org/)).
    For your workflow, you can use a single YAML file to specify the jobs and steps.
    Start by creating a new branch in your repository. Create a .github/ directory
    in the root directory of your project if it doesn’t already exist. Inside the
    .github/ directory, create a new directory called workflows/. GitHub automatically
    discovers files with a .yml extension in the .github/workflows/ directory and
    expects them to be valid workflow definitions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 YAML ([https://yaml.org/](https://yaml.org/)) 配置 GitHub Actions 工作流程。对于您的工作流程，您可以使用单个
    YAML 文件来指定作业和步骤。首先，在您的仓库中创建一个新的分支。如果项目根目录中尚不存在 .github/ 目录，请创建一个。在 .github/ 目录内，创建一个名为
    workflows/ 的新目录。GitHub 会自动在 .github/workflows/ 目录中查找具有 .yml 扩展名的文件，并期望它们是有效的流程定义。
- en: You can give your workflow configuration file almost any name you like, but
    using the name main.yml is a common practice when a project has only one workflow
    configured. You can also use a name that indicates the purpose of the workflow,
    such as packaging.yml. Create an empty configuration file in the .github/workflows/
    directory now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为工作流程配置文件几乎取任何您喜欢的名字，但当一个项目只有一个工作流程配置时，使用 main.yml 作为名称是一种常见的做法。您还可以使用一个表明工作流程目的的名称，例如
    packaging.yml。现在在 .github/workflows/ 目录中创建一个空的配置文件。
- en: 'Each GitHub Actions workflow must have at least the following few fields:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 GitHub Actions 工作流程都必须至少包含以下几个字段：
- en: '`name`—A human-friendly string to display in a few parts of the GitHub interface'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`—在 GitHub 界面的一些部分显示的友好字符串'
- en: '`on`—A list of one or more events that trigger the workflow'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`—触发工作流程的一个或多个事件列表'
- en: '`jobs`—A map of one or more jobs to perform'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs`—要执行的一个或多个作业的映射'
- en: 'In turn, a job must have at least a few fields as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，作业必须至少包含以下几个字段：
- en: '*Key*—A machine-readable string by which to reference the job elsewhere in
    the pipeline. Often this is a version of the job name that uses only letters and
    hyphens.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关键字*—一个机器可读的字符串，用于在管道的其他地方引用作业。通常这是作业名称的一个版本，只使用字母和连字符。'
- en: '`name`—A human-friendly string to display in a few parts of the GitHub interface.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`—在 GitHub 界面的一些部分显示的友好字符串。'
- en: '`runs-on`—The type of GitHub Actions runner to use for the job. For your purposes,
    `ubuntu-latest` works well. You can see all the available runners in the `runs-on`
    documentation ([http://mng.bz/PnKP](http://mng.bz/PnKP)).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runs-on`—用于作业的GitHub Actions运行器类型。就你的用途而言，`ubuntu-latest`表现良好。你可以在`runs-on`文档中查看所有可用的运行器（[http://mng.bz/PnKP](http://mng.bz/PnKP)）。'
- en: '`steps`—A list of one or more steps to perform.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steps`—要执行的一个或多个步骤的列表。'
- en: 'Finally, a step may be in one of the following two formats:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个步骤可能以下列两种格式之一：
- en: A reference to a predefined action, such as the official checkout action ([https://github.com/actions/checkout](https://github.com/actions/checkout))
    provided by GitHub or by a third party. This format specifies a `uses` key whose
    value references the action’s GitHub repository and an optional version string
    separated by an `@` character.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对预定义操作的引用，例如GitHub或第三方提供的官方checkout操作（[https://github.com/actions/checkout](https://github.com/actions/checkout)）。此格式指定一个`uses`键，其值引用操作的GitHub存储库，以及一个可选的版本字符串，由一个`@`字符分隔。
- en: A human-friendly `name` string to display in a few parts of the GitHub interface,
    and a `run` field that specifies the command to run.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于在GitHub界面的一些部分显示的人类友好`name`字符串，以及一个指定要运行的命令的`run`字段。
- en: The next listing shows how these pieces fit together into a sample workflow
    configuration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了这些部分如何组合成一个示例工作流程配置。
- en: Listing 7.1 A sample GitHub Actions workflow
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 一个示例GitHub Actions工作流程。
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ A human-friendly name for the workflow
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 工作流程的人类友好名称。
- en: ❷ The workflow is triggered by pushed code and tags.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 工作流程由推送的代码和标签触发。
- en: ❸ The jobs for the workflow
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 工作流程的作业。
- en: ❹ A machine-readable key for the job
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 作业的机器可读键。
- en: ❺ A human-friendly name for the job
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 作业的人类友好名称。
- en: ❻ The job uses the latest Ubuntu-based runner.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 作业使用最新的基于Ubuntu的运行器。
- en: ❼ The steps for the job
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 作业的步骤。
- en: ❽ Uses the official checkout action to check out the code
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用官方checkout操作检出代码。
- en: ❾ Runs a step with a custom name and command
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 运行具有自定义名称和命令的步骤。
- en: When run, the workflow checks out the code of the branch or tag that triggered
    the workflow and then runs an `echo` command to say hello. If the triggering push
    event is a pull request, GitHub Actions reports the pending status near the bottom
    of that pull request’s page (see figure 7.4).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，工作流程检出触发工作流程的分支或标签的代码，然后运行一个`echo`命令来问候。如果触发推送事件是拉取请求，GitHub Actions在该拉取请求页面的底部报告挂起状态（见图7.4）。
- en: '![](../../OEBPS/Images/07-04.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-04.png)'
- en: Figure 7.4 A pending GitHub Actions workflow displayed at the bottom of a pull
    request
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 在拉取请求底部显示的挂起GitHub Actions工作流程。
- en: After the workflow completes, GitHub Actions shows the completed status on the
    pull request page (see figure 7.5).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程完成后，GitHub Actions在拉取请求页面上显示完成状态（见图7.5）。
- en: '![](../../OEBPS/Images/07-05.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-05.png)'
- en: Figure 7.5 A successfully completed GitHub Actions workflow on a pull request
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 在拉取请求上成功完成的GitHub Actions工作流程。
- en: You can click the Details link on a workflow job to see the output of individual
    steps (as shown in figure 7.6). You can also find all previous job runs on the
    Actions tab of your repository. GitHub Actions performs some steps of its own
    before and after the steps you define.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击工作流程作业上的“详情”链接来查看单个步骤的输出（如图7.6所示）。你还可以在你的存储库的操作选项卡中找到所有以前的工作流程运行。GitHub
    Actions在你定义的步骤之前和之后执行一些自己的步骤。
- en: '![](../../OEBPS/Images/07-06.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-06.png)'
- en: Figure 7.6 The detailed steps and output for a GitHub Actions workflow job.
    Some steps are user-defined, and some are built into GitHub Actions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 GitHub Actions工作流程作业的详细步骤和输出。一些步骤是用户定义的，而另一些是GitHub Actions内置的。
- en: You can click a step’s name to expand and view its output, which can be useful
    in better understanding actions provided by GitHub or a third-party (see figure
    7.7).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击步骤的名称来展开并查看其输出，这有助于更好地理解GitHub或第三方提供的行为（如图7.7所示）。
- en: '![](../../OEBPS/Images/07-07.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-07.png)'
- en: Figure 7.7 The output from the official checkout action shows all the steps
    involved in checking out the code from the triggering branch or tag.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 官方checkout操作的输出显示了从触发分支或标签检出代码所涉及的所有步骤。
- en: You can also use the output to confirm or debug steps you create yourself, such
    as ensuring that a logged value is what you expect (as shown in figure 7.8).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用输出以确认或调试你创建的步骤，例如确保记录的值是你预期的（如图7.8所示）。
- en: '![](../../OEBPS/Images/07-08.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-08.png)'
- en: Figure 7.8 Commands specified in a workflow job step are displayed along with
    their output.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 在工作流程作业步骤中指定的命令及其输出显示。
- en: When a workflow fails, browsing these different levels of the GitHub Actions
    interface becomes especially important in discovering how to fix the failure.
    These areas are where you’ll see failing unit tests and messages about improperly
    formatted code or other code quality issues found by your tools.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作流程失败时，浏览 GitHub Actions 界面的不同级别对于发现如何修复失败特别重要。这些区域是你将看到失败的单元测试和关于代码格式不正确或其他代码质量问题的消息，这些问题是由你的工具发现的。
- en: Exercise 7.1
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.1
- en: 'On a new branch in your repository, do the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的仓库的一个新分支上，执行以下操作：
- en: Create a .github/ directory in the root directory of your project if it doesn’t
    already exist.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的项目根目录下还没有 .github/ 目录，请创建一个。
- en: Inside the .github/ directory, create a new directory called workflows/.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .github/ 目录内，创建一个名为 workflows/ 的新目录。
- en: Create a YAML file for your workflow configuration in the .github/worfklows/
    directory. You can name your workflow configuration file what you like, but using
    the name main.yml is a common practice when a project has only one workflow configured.
    You can also use a name that indicates the purpose of the workflow, such as packaging.yml.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .github/workflows/ 目录中创建一个用于工作流程配置的 YAML 文件。你可以根据喜好命名你的工作流程配置文件，但当一个项目只有一个工作流程配置时，使用
    main.yml 作为名称是一种常见的做法。你也可以使用一个表明工作流程目的的名称，例如 packaging.yml。
- en: In your workflow file, add the sample YAML from listing 7.1.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的工作流程文件中，添加列表 7.1 中的示例 YAML。
- en: Commit and push your changes to GitHub.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的更改提交并推送到 GitHub。
- en: Open a pull request.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交一个 pull request。
- en: After you complete these steps, you should see GitHub Actions trigger the workflow
    on your pull request. Confirm that the workflow succeeds and performs the steps
    you defined. Change the `echo` command to a new string, and push a new commit.
    The workflow should trigger again, and the output should reflect your updated
    string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你应该会看到 GitHub Actions 在你的 pull request 上触发了工作流程。确认工作流程成功执行并执行了你定义的步骤。将
    `echo` 命令更改为新的字符串，并推送一个新的提交。工作流程应该再次触发，并且输出应该反映你的更新字符串。
- en: Now that you’ve created a working GitHub Actions workflow, you’re ready to add
    your real tasks to it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个工作的工作流程，你可以添加你的实际任务到其中。
- en: 7.3 Converting manual tasks to GitHub Actions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 将手动任务转换为 GitHub Actions
- en: Earlier you learned about the high-level flow of continuous integration in GitHub
    Actions. Zooming in a bit, your focus now is the specific jobs and steps your
    workflow needs to perform. Several correspond to the tox environments you created
    in chapters 5 and 6\. Most of these jobs can also be run in parallel; the only
    exception is the publishing job, which should wait for all the other jobs to succeed
    before proceeding to ensure only verified changes get published. Figure 7.9 iterates
    what you need to implement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前你学习了 GitHub Actions 中持续集成的整体流程。稍微放大一点，你现在的重点是工作流程需要执行的具体作业和步骤。其中一些对应于你在第 5
    章和第 6 章中创建的 tox 环境。大多数这些作业也可以并行运行；唯一的例外是发布作业，它应该在所有其他作业成功后继续进行，以确保只有经过验证的更改被发布。图
    7.9 重复了你需要实现的内容。
- en: '![](../../OEBPS/Images/07-09.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-09.png)'
- en: Figure 7.9 The jobs for a Python packaging workflow. Each job has a similar
    set of steps.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 Python 打包工作流程的作业。每个作业都有类似的步骤集。
- en: 'You need to update your workflow config to use a clearer value for `name`,
    remove the `say-hello` job, and add the real jobs. Rename your workflow something
    like `Packaging` and remove the `say-hello` job now. To add the new jobs, start
    with the job for checking the formatting of the code. This job needs to do the
    following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更新你的工作流程配置，为 `name` 使用更清晰的值，删除 `say-hello` 作业，并添加真实作业。将工作流程重命名为类似 `Packaging`
    的名称，并现在删除 `say-hello` 作业。要添加新作业，从检查代码格式的作业开始。这个作业需要执行以下操作：
- en: Check out the code using the `actions/checkout@v3` action.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/checkout@v3` 动作检查代码。
- en: Set up the most recent version of Python your package supports using the `actions/setup-python@v4.0.0`
    action. You can specify the Python version using the `with` key and specify a
    value for the `python-version` key underneath it. Be sure to put the Python version
    in quotes; YAML will interpret the version as a floating-point number otherwise.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/setup-python@v4.0.0` 动作设置你的包支持的最新版本的 Python。你可以使用 `with` 键指定 Python
    版本，并在其下方指定 `python-version` 键的值。务必将 Python 版本用引号括起来；否则，YAML 会将版本解释为浮点数。
- en: Install tox. By using the `setup-python` action, the version of Python you request
    will be available as the `python` command in the `run` value of the step.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 tox。通过使用 `setup-python` 动作，你请求的 Python 版本将作为步骤的 `run` 值中的 `python` 命令可用。
- en: Use tox to run the appropriate environment for the job. In this case, you’ll
    use the `format` tox environment.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 tox 运行适合该作业的环境。在这种情况下，你将使用 `format` tox 环境。
- en: Note You may notice that the code companion ([http://mng.bz/69A5](http://mng.bz/69A5))
    also includes a `working-directory` key in some steps, but this is only because
    the package directory isn’t in the root of the Git repository. If your package
    is in the root of your repository—which is the case if you’ve been following along
    closely with this book—you should omit the `working-directory` key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能还会注意到代码伴侣（[http://mng.bz/69A5](http://mng.bz/69A5)）在某些步骤中也包括了一个 `working-directory`
    键，但这仅仅是因为包目录不在 Git 仓库的根目录中。如果你的包在仓库的根目录中——如果你一直密切跟随这本书——你应该省略 `working-directory`
    键。
- en: Add the new job now and return here when you’re done. Make sure to give your
    job and custom steps human-friendly names using their respective `name` keys.
    Your workflow file should look something like the following listing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加新的作业，完成后返回这里。确保使用各自的 `name` 键给你的作业和自定义步骤提供人性化的名称。你的工作流程文件应该看起来像以下列表。
- en: Listing 7.2 A GitHub Actions job for checking Python code formatting
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 用于检查 Python 代码格式的 GitHub Actions 作业
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Ensures the workflow name always reflects its purpose
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确保工作流程名称始终反映其目的
- en: ❷ A job to check the code formatting
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个用于检查代码格式的作业
- en: ❸ Ensures job names also reflect their purpose
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 确保作业名称也反映其目的
- en: ❹ Installs the desired Python version
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 安装所需的 Python 版本
- en: ❺ Installs tox to the installed Python
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在安装的 Python 中安装 tox
- en: ❻ Uses tox to run the format environment
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用 tox 运行格式环境
- en: With this new job added, commit your changes and push them to your branch on
    GitHub. The workflow will trigger again, and if your formatting checks are passing
    locally, you should expect them to pass on GitHub as well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了新的作业后，提交你的更改并将它们推送到你的 GitHub 分支。工作流程将再次触发，如果你的格式检查在本地通过，你应该期待它们在 GitHub 上也能通过。
- en: Exercise 7.2
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.2
- en: The jobs for linting and type checking your code look nearly identical to the
    one for checking the code formatting; only the tox environment and the `name`
    values should differ. Add a job for linting and a job for type checking.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码格式化和类型检查的作业看起来几乎与检查代码格式的作业相同；只有 tox 环境和 `name` 值应该不同。添加一个用于代码检查的作业和一个用于类型检查的作业。
- en: Remember that multiple jobs run in parallel by default. After you push the changes
    to add these jobs, you should see your three jobs run in parallel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住默认情况下多个作业是并行运行的。在你推送更改以添加这些作业后，你应该看到你的三个作业并行运行。
- en: You now have all of your code quality checks in place. You should feel a sense
    of calm washing over you. Before it takes over completely, you’ll need to learn
    some additional GitHub Actions features before getting your testing and wheel-building
    jobs working.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经设置了所有的代码质量检查。你应该会感到一种平静的感觉涌过。在它完全占据之前，你需要在测试和 wheel 构建作业工作之前学习一些额外的 GitHub
    Actions 功能。
- en: 7.3.1 Running a job multiple times with a build matrix
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 使用构建矩阵多次运行作业
- en: Remember from chapter 5 that tox can create a build matrix to run your tests
    across several configurations. GitHub Actions provides a rather similar feature.
    You can use the GitHub Actions matrix feature in tandem with tox’s matrix feature
    to install the appropriate Python version for a particular tox testing environment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 5 章中记住，tox 可以创建一个构建矩阵来跨多个配置运行你的测试。GitHub Actions 提供了一个相当类似的功能。你可以将 GitHub
    Actions 的矩阵功能与 tox 的矩阵功能结合使用，为特定的 tox 测试环境安装适当的 Python 版本。
- en: Note You could also achieve this with distinct jobs, but much like tox, using
    the matrix feature saves you a fair amount of repetitive manual configuration,
    especially when you need to support many configuration variants.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你也可以使用不同的作业来实现这一点，但与 tox 类似，使用矩阵功能可以节省你大量的重复手动配置，尤其是在你需要支持许多配置变体时。
- en: You tell GitHub Actions that a particular job should be run for several combinations
    using the `strategy.matrix` key. Each key nested within the `strategy.matrix`
    key can have a name of your choosing and represents one set to choose from in
    the matrix expansion. The value for each key is a list of maps, with each map
    supplying variables that will be substituted into a particular job instance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您告诉 GitHub Actions，特定作业应该运行几个组合，使用 `strategy.matrix` 键。`strategy.matrix` 键内的每个键都可以有您选择的名称，并代表矩阵展开中选择的一组。每个键的值是一个映射列表，每个映射提供将替换到特定作业实例中的变量。
- en: As an example, if you have four keys defined in `strategy.matrix` and each has
    a list of four variable maps, the matrix will have 16 combinations and the job
    will run across each of those 16 variants. You can reference the variable substitutions
    from the matrix using the `matrix` value from the GitHub Actions context ([http://mng.bz/DDgA](http://mng.bz/DDgA)).
    The next listing shows an example of the syntax for defining a job with a matrix.
    For a full reference, you can also reference the GitHub documentation ([http://mng.bz/J2pv](http://mng.bz/J2pv)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在 `strategy.matrix` 中定义了四个键，并且每个键都有一个包含四个变量映射的列表，那么矩阵将有 16 种组合，作业将在这些
    16 个变体中运行。您可以使用 GitHub Actions 上下文中的 `matrix` 值（[http://mng.bz/DDgA](http://mng.bz/DDgA)）引用变量替换。下一个列表显示了定义具有矩阵的作业的语法示例。对于完整的参考，您还可以参考
    GitHub 文档（[http://mng.bz/J2pv](http://mng.bz/J2pv)）。
- en: Listing 7.3 A GitHub Actions job that uses a matrix build strategy
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 使用矩阵构建策略的 GitHub Actions 作业
- en: '[PRE2]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Text color is one factor of the matrix.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 文本颜色是矩阵的一个因素。
- en: ❷ The text-color.value variable has four options.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `text-color.value` 变量有四个选项。
- en: ❸ Background color is another matrix factor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 背景颜色是另一个矩阵因素。
- en: ❹ A matrix factor can have multiple variables per option.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 每个选项可以有多个变量。
- en: ❺ This step will be run for each of the 24 possible combinations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这个步骤将为 24 种可能的组合中的每一个运行。
- en: ❻ Values for each matrix factor are available in the context.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 每个矩阵因子的值都在上下文中可用。
- en: Because you’re using tox to run your unit tests on multiple Python versions,
    the main matrix factor you need is the Python version. But the string tox uses
    for the testing environments differs from the Python version string, so you need
    to specify both of these separately. You can model this in your configuration
    using a single `python` matrix factor where each option has both a `version` and
    `toxenv` variable. In your job, you can then reference the `matrix` context values
    for the Python version in the `actions/setup-python@v4.0.0` action and run only
    the relevant tox environment in the last step.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您使用 tox 在多个 Python 版本上运行单元测试，所以您需要的主要矩阵因子是 Python 版本。但是 tox 用于测试环境的字符串与 Python
    版本字符串不同，因此您需要分别指定这两个值。您可以在配置中使用单个 `python` 矩阵因子来模拟这一点，其中每个选项都包含一个 `version` 和
    `toxenv` 变量。然后，在您的作业中，您可以在 `actions/setup-python@v4.0.0` 动作中引用 Python 版本的 `matrix`
    上下文值，并在最后一步中仅运行相关的 tox 环境。
- en: Add the new job for unit testing your code to your workflow file now and return
    here when you’re done. It should look something like the following listing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将用于单元测试代码的新作业添加到您的流程文件中，完成后返回此处。它应该看起来像以下列表。
- en: Listing 7.4 A job that runs different Python versions and tox environments
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 运行不同 Python 版本和 tox 环境的作业
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A factor for the Python version and tox environment
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Python 版本和 tox 环境的因素
- en: ❷ The Python version to use for a particular job
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于特定作业的 Python 版本
- en: ❸ The tox environment name to use for a particular job
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为特定作业使用的 tox 环境名称
- en: ❹ A reference to a context value for a particular job
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对特定作业上下文值的引用
- en: ❺ Another reference to a context value for a particular job
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 另一个对特定作业上下文值的引用
- en: Commit and push your changes. GitHub Actions will show you the status of each
    job individually on your pull request (see figure 7.10).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 提交并推送您的更改。GitHub Actions 将在您的拉取请求中单独显示每个作业的状态（见图 7.10）。
- en: '![](../../OEBPS/Images/07-10.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-10](../../OEBPS/Images/07-10.png)'
- en: Figure 7.10 GitHub Actions pull request feedback for jobs in a build matrix
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 GitHub Actions 构建矩阵中的作业拉取请求反馈
- en: In the Details view, you can see that it groups the related jobs from the matrix
    together (figure 7.11).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在“详细信息”视图中，您可以看到它将矩阵中的相关作业分组在一起（见图 7.11）。
- en: '![](../../OEBPS/Images/07-11.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-11](../../OEBPS/Images/07-11.png)'
- en: Figure 7.11 GitHub Actions build matrix in the detailed view on the Actions
    tab
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 在“操作”选项卡上的详细视图中的 GitHub Actions 构建矩阵
- en: You can expand them to see each individual job by clicking the aggregated summary
    (see figure 7.12).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击汇总摘要（见图 7.12）来展开它们，以查看每个单独的任务。
- en: '![](../../OEBPS/Images/07-12.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-12.png)'
- en: Figure 7.12 The expanded build matrix that shows each individual job in the
    Actions tab
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 展开的构建矩阵，显示了“操作”选项卡中的每个单独的任务
- en: In addition to the code quality checks, your unit tests are also fully automated
    in your continuous integration pipeline. Now you can move to the jobs that build
    the distributions of your package.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码质量检查之外，你的单元测试也在你的持续集成管道中完全自动化。现在你可以转向构建你包发行版的作业。
- en: 7.3.2 Building Python package distributions for a variety of platforms
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 为各种平台构建 Python 包发行版
- en: You learned in chapter 4 how to build an extension in a language other than
    Python. You also learned that, unlike a pure Python package, packages with non-Python
    extensions need to be distributed either as source code that must be built by
    the user or as binary distributions for many different platforms. Whereas building
    all those different distributions is tedious and in some cases impossible on your
    local machine, for CI solutions with runners on a variety of operating systems
    and architectures, this becomes a matter of some additional configuration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第四章学习了如何使用除 Python 之外的语言构建扩展。你也了解到，与纯 Python 包不同，带有非 Python 扩展的包需要以源代码的形式分发，用户必须自行构建，或者作为适用于许多不同平台的二进制发行版。而构建所有这些不同的发行版既繁琐，在某些情况下在本地机器上甚至不可能完成，但对于在多种操作系统和架构上运行的
    CI 解决方案，这成为了一些额外的配置问题。
- en: To achieve the building of binary wheel distributions across a broad swath of
    target platforms, you can make use of the fantastic cibuildwheel tool from the
    PyPA ([https://github.com/pypa/cibuildwheel](https://github.com/pypa/cibuildwheel)).
    This tool is intended to act as a convenient way to build wheels across as many
    platforms as possible. As of this writing, cibuildwheel also has the widest support
    on GitHub Actions over other popular continuous integration solutions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在广泛的目标平台上构建二进制 wheel 发行版，你可以使用 PyPA 的出色工具 cibuildwheel ([https://github.com/pypa/cibuildwheel](https://github.com/pypa/cibuildwheel))。此工具旨在作为在尽可能多的平台上构建
    wheels 的便捷方式。截至本文撰写时，cibuildwheel 在 GitHub Actions 上的支持比其他流行的持续集成解决方案更广泛。
- en: 'You need to create a job rather similar to the others you’ve created so far,
    with only a few key differences, as shown next:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个与之前创建的任务非常相似的作业，只有几个关键的区别，如下所示：
- en: Install the `cibuildwheel` package instead of the `tox` package.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装`cibuildwheel`包而不是`tox`包。
- en: Run a command using cibuildwheel instead of a tox environment.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 cibuildwheel 而不是 tox 环境，运行一个命令。
- en: Use the `actions/upload-artifact@v3` action ([https://github.com/actions/upload-artifact](https://github.com/actions/upload-artifact))
    to store the files created by cibuildwheel when needed for publishing.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `actions/upload-artifact@v3` 动作（[https://github.com/actions/upload-artifact](https://github.com/actions/upload-artifact)）在需要时存储由
    cibuildwheel 创建的文件，以便发布。
- en: 'You can run cibuildwheel as a module using Python. You can pass it a directory
    in which to put the built wheels using the `--output-dir` flag. As an example,
    the following command builds wheels and puts them in a `wheels/` directory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Python 作为模块运行 cibuildwheel。你可以使用 `--output-dir` 标志传递一个目录，将构建的 wheels 放入其中。以下命令构建
    wheels 并将它们放入 `wheels/` 目录：
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you have files you want to upload to GitHub Actions as artifacts for later
    use, you can pass a glob pattern of files to upload to the `actions/upload-artifact@v3`
    action using the `with.path` key. The following example uploads all files with
    a .whl extension from the wheels/ directory:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有文件想要上传到 GitHub Actions 作为后续使用的工件时，你可以使用 `with.path` 键将上传文件的 glob 模式传递给 `actions/upload-artifact@v3`
    动作。以下示例上传了 wheels/ 目录中所有扩展名为 .whl 的文件：
- en: '[PRE5]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exercise 7.3
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.3
- en: 'Add a new job for building wheels to your workflow file that does the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工作流程文件中添加一个用于构建轮子的新任务，该任务执行以下操作：
- en: Uses a build matrix and the `runs-on` key to run the job on `ubuntu-20.04`,
    `windows-2019`, and `macOS-10.15`
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构建矩阵和 `runs-on` 键在 `ubuntu-20.04`、`windows-2019` 和 `macOS-10.15` 上运行作业
- en: Uses cibuildwheel to build wheels in a wheels/ directory
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 cibuildwheel 在 wheels/ 目录下构建 wheels
- en: Uses the `actions/upload-artifact@v3` action
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/upload-artifact@v3` 动作
- en: Reference the code companion ([http://mng.bz/69A5](http://mng.bz/69A5)) if you
    need to check your work. Commit and push your changes to confirm the wheels build
    successfully. Note that these jobs may take significantly longer than the tests
    and code quality checks because of the amount of work cibuildwheel needs to do.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要检查您的作业，请参考代码伴侣 ([http://mng.bz/69A5](http://mng.bz/69A5))。提交并推送您的更改以确认轮子构建成功。请注意，由于
    cibuildwheel 需要执行的工作量，这些作业可能比测试和代码质量检查长得多。
- en: Although the binary wheel distributions require a fair amount of heavy lifting,
    you need to build only a single source distribution. You can do this by using
    the `build` tool that you learned about in chapter 3\. You can run `build` as
    a module using Python. Tell it to build a source distribution using the `--sdist`
    flag, and it will build the distribution to a dist/ directory by default.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管二进制轮分发需要大量的工作，但您只需要构建单个源分发。您可以通过使用第 3 章中介绍过的 `build` 工具来完成此操作。您可以使用 Python
    运行 `build` 作为模块，并使用 `--sdist` 标志告诉它构建源分发，默认情况下它会将分发构建到 dist/ 目录。
- en: Exercise 7.4
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.4
- en: 'Add a new job for building a source distribution to your workflow file that
    does the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的流程文件中添加一个新的作业，用于构建源分发，该作业执行以下操作：
- en: Installs the `build` package
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `build` 包
- en: Runs `build` to create a source distribution in the dist/ directory
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `build` 命令以在 dist/ 目录中创建源分发
- en: Uses the `actions/upload-artifact@v3` action to upload all .tar.gz files from
    the dist/ directory for later use
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/upload-artifact@v3` 动作上传 dist/ 目录中的所有 .tar.gz 文件以供以后使用
- en: Reference the code companion ([http://mng.bz/69A5](http://mng.bz/69A5)) if you
    need to check your work. Commit and push your changes to confirm the source distribution
    builds successfully.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要检查您的作业，请参考代码伴侣 ([http://mng.bz/69A5](http://mng.bz/69A5))。提交并推送您的更改以确认源分发构建成功。
- en: You now have automation for each and every activity you’ve learned in the packaging
    workflow up to now. With these checks in place, you can feel confident that each
    change submitted to your project will pass muster. You can also do this without
    lifting so much as a finger, because GitHub Actions will give feedback to the
    author of a change on the pull request, letting them know they need to fix something
    if it breaks. You and your team can even start to develop a hypothesis-driven
    development model. You can run a subset of tests locally that pertain directly
    to your change, make a hypothesis that the full suite will pass, and see if the
    status of the full suite of checks confirms your expectations. This is a highly
    productive position to be in and can even give a bit of a rush with the confidence
    you may feel. The final step to automate is the publishing of the package.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经为包装工作流程中到目前为止学习的每一个活动实现了自动化。有了这些检查，您可以有信心，提交给项目的每个更改都将通过审查。您甚至可以不费吹灰之力就做到这一点，因为
    GitHub Actions 将向更改的作者在拉取请求中提供反馈，让他们知道如果出现错误需要修复。您和您的团队甚至可以开始开发一个基于假设的开发模型。您可以在本地运行与您的更改直接相关的测试子集，假设完整套件将通过，然后查看完整套件检查的状态是否确认了您的预期。这是一个高度高效的位置，甚至可以带来一些信心带来的兴奋感。最后要自动化的步骤是发布包。
- en: 7.4 Publishing a package
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 发布包
- en: This book is called *Publishing Python Packages*, so you may have been wondering
    when it would actually get around to the publishing aspect. Although there’s been
    a big lead-up to this moment, it’s been in the name of learning the concepts so
    you can react to alternative tools, debug issues along the way, and generally
    explore the packaging landscape with confidence. I’m proud of you for making it
    this far, and I hope you are too!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的名称是《发布 Python 包》，因此您可能想知道它何时真正涉及到发布方面。尽管为此做了大量的准备工作，但这是为了学习概念，以便您能够对替代工具做出反应，在过程中调试问题，并自信地探索包装领域。我为你们走到这一步感到自豪，也希望你们自己也是如此！
- en: Important Before you can publish a package to PyPI, you need a PyPI user account.
    Visit the registration page ([https://pypi.org/account/register/](https://pypi.org/account/register/))
    now to create an account if you don’t already have one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：在您可以将包发布到 PyPI 之前，您需要一个 PyPI 用户账户。如果您还没有账户，请现在访问注册页面 ([https://pypi.org/account/register/](https://pypi.org/account/register/))
    创建一个账户。
- en: Before you can automate publishing your package properly, you first need to
    “claim” the package name you want to use on PyPI by manually uploading your package.
    I strongly urge you to use the format `pubpypack-harmony-<firstname>-<lastname>`
    for your package if you’re following the exercises in this book closely so that
    you don’t use up good package names on PyPI for your practice package. Update
    the name field in your setup.cfg file to use this format now. You should also
    check whether a package with that name already exists by searching for it from
    the PyPI home page ([https://pypi.org](https://pypi.org)) or visiting what would
    be the project’s URL (https://pypi.org/project/pubpypack-harmony-<firstname>-<lastname>),
    in case you share your name with another reader. This will also help me find all
    your successes more easily! My version lives at [https://pypi.org/project/pubpypack-harmony-dane-hillard](https://pypi.org/project/pubpypack-harmony-dane-hillard).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够正确自动化发布您的包之前，您首先需要通过手动上传您的包来“声明”您想在PyPI上使用的包名。如果您仔细遵循本书中的练习，我强烈建议您使用`pubpypack-harmony-<firstname>-<lastname>`格式为您的包命名，这样您就不会在PyPI上为您的练习包耗尽好的包名。现在更新您的setup.cfg文件中的名称字段以使用此格式。您还应该通过从PyPI主页([https://pypi.org](https://pypi.org))或访问项目URL（https://pypi.org/project/pubpypack-harmony-<firstname>-<lastname>）来检查是否存在具有该名称的包，以防您与另一位读者同名。这也有助于我更容易地找到您的所有成功！我的版本位于[https://pypi.org/project/pubpypack-harmony-dane-hillard](https://pypi.org/project/pubpypack-harmony-dane-hillard)。
- en: Tip You can also do all these same steps on the test PyPI instance ([https://test.pypi.org/](https://test.pypi.org/)),
    which is helpful for trying new things out before doing them on the live instance.
    You need to create a separate account and any other credentials specific to the
    test instance if you decide to do so.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您也可以在测试PyPI实例([https://test.pypi.org/](https://test.pypi.org/))上执行所有这些相同的步骤，这在尝试在实时实例上执行之前尝试新事物非常有帮助。如果您决定这样做，您需要创建一个单独的账户以及针对测试实例的任何其他凭证。
- en: 'After you settle on a package name, you can use the twine ([https://twine.readthedocs.io/en/stable/](https://twine.readthedocs.io/en/stable/))
    tool to publish your package. To do so, you need to have your PyPI username and
    password handy. When you’re ready, run the following commands from the root of
    your package to create a source distribution and upload it to PyPI. You’ll be
    prompted to enter your PyPI credentials:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在您确定包名之后，您可以使用twine ([https://twine.readthedocs.io/en/stable/](https://twine.readthedocs.io/en/stable/))工具发布您的包。为此，您需要准备好您的PyPI用户名和密码。准备好后，从您包的根目录运行以下命令以创建源分布并将其上传到PyPI。您将被提示输入您的PyPI凭证：
- en: '[PRE6]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip You can create a tox environment for uploading the package using twine.
    This can be helpful for running repeatedly while debugging issues, and is especially
    helpful if you use a private package repository such as Artifactory that requires
    you to specify a nonstandard repository URL.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可以使用twine创建一个用于上传包的tox环境。这在进行调试时反复运行问题非常有帮助，如果您使用的是需要指定非标准仓库URL的私有包仓库（如Artifactory），则特别有用。
- en: 'After you successfully upload the package, it becomes associated with your
    account. This allows you to create an API token specific to that package, which
    is very useful for automation purposes because you don’t need to use your personal
    username and password directly. Create an API token specific to your package now
    using the following steps, also shown in figure 7.13:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在您成功上传包之后，它将与您的账户关联。这允许您为该包创建一个特定的API令牌，这对于自动化目的非常有用，因为您不需要直接使用您的个人用户名和密码。现在按照以下步骤创建一个针对您的包的API令牌，如图7.13所示：
- en: Visit the API token creation page ([https://pypi.org/manage/account/token/](https://pypi.org/manage/account/token/)).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问API令牌创建页面([https://pypi.org/manage/account/token/](https://pypi.org/manage/account/token/))。
- en: Give the token a name you’ll recognize, such as `pubpypack`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给令牌起一个您能识别的名字，例如`pubpypack`。
- en: 'Select Project: pubpypack-harmony-<firstname>-<lastname> from the Scope dropdown
    menu.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从范围下拉菜单中选择项目：pubpypack-harmony-<firstname>-<lastname>。
- en: Click Add Token.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加令牌。
- en: '![](../../OEBPS/Images/07-13.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-13.png)'
- en: Figure 7.13 The interface for adding a project-specific API token to a PyPI
    account
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 向PyPI账户添加特定项目API令牌的界面
- en: After you add the token, you’ll be shown a page with the contents of the token
    (see figure 7.14). You should copy this token somewhere for safekeeping, because
    you’ll be able to access it only this one time. You can always generate a new
    one later, but if you lose the token, you may need to update it in a variety of
    places, depending on where you used it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 添加令牌后，你将看到一个包含令牌内容的页面（如图7.14所示）。你应该将此令牌复制到安全的地方保存，因为你可以只访问它这一次。你总是可以稍后生成一个新的，但如果丢失了令牌，你可能需要根据你使用它的地方更新它。
- en: '![](../../OEBPS/Images/07-14.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14](../../OEBPS/Images/07-14.png)'
- en: Figure 7.14 The one-time page displaying a newly added PyPI API token.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 显示一次性页面，展示新添加的PyPI API令牌。
- en: 'Now you need to add your newly created PyPI API token as a *secret* in your
    GitHub repository. Secrets are sensitive information that GitHub Actions encrypts
    for storage. They can be injected into GitHub Actions but aren’t viewable directly
    by anyone. Add your token using the following steps, starting from your repository’s
    GitHub page:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将新创建的PyPI API令牌作为*秘密*添加到你的GitHub仓库中。秘密是敏感信息，GitHub Actions会对其进行加密存储。它们可以注入到GitHub
    Actions中，但任何人无法直接查看。按照以下步骤添加你的令牌，从你的仓库的GitHub页面开始：
- en: Click Settings.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击设置。
- en: Click Secrets in the lower left. Make sure you end up on the Actions Secrets
    page, which is the default as of this writing.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左下角点击秘密。确保你最终到达的是动作秘密页面，这是截至本文写作时的默认设置。
- en: Click New Repository Secret in the top right.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角点击“新建仓库秘密”。
- en: Name the secret `PYPI_API_TOKEN`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将秘密命名为`PYPI_API_TOKEN`。
- en: Paste the value of the API token you saved from PyPI.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从PyPI保存的API令牌的值粘贴进去。
- en: Click Add Secret.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加秘密”。
- en: After you add the secret, you should see it listed in the Repository Secrets
    table (shown in figure 7.15).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 添加秘密后，你应该在仓库秘密表中看到它（如图7.15所示）。
- en: '![](../../OEBPS/Images/07-15.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15](../../OEBPS/Images/07-15.png)'
- en: Figure 7.15 The GitHub Actions secrets interface displaying an added secret
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 显示添加的秘密的GitHub Actions秘密界面
- en: You can reference the `PYPI_API_TOKEN` secret from the `secret` context variable
    in your job. Now you have all the credentials in place to automate your package
    publishing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你的作业中的`secret`上下文中引用`PYPI_API_TOKEN`秘密。现在你已经设置了所有凭证，可以自动化你的包发布了。
- en: Whereas all the checks, tests, and distribution builds you’ve added to your
    workflow so far are triggered directly by pushed commits and tags, the publishing
    step is one you’ll want to restrict from running as regularly. As an example,
    you probably wouldn’t want to publish a new version of the package on each new
    commit pushed to your repository, especially when the branch is from an untrusted
    author. Someone with malicious intent could open a pull request with a security
    flaw and exploit your pipeline to publish that code. A tag representing a milestone
    in the Git history is a common triggering event for publishing a package version
    that also enables you to be very deliberate about the exact moment in the code
    history from which to publish a version. To restrict the publishing job to only
    tags, you’ll make use of an expression to check for the right conditions. If the
    conditions aren’t met, GitHub Actions skips the job.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 而到目前为止，你添加到工作流程中的所有检查、测试和分发构建都是直接由推送的提交和标签触发的，但发布步骤是你希望限制其定期运行的。例如，你可能不希望每次将新提交推送到你的仓库时都发布新版本的包，尤其是当分支来自不可信的作者时。有恶意意图的人可能会提交一个包含安全漏洞的拉取请求，并利用你的管道发布该代码。表示Git历史中里程碑的标签是发布包版本的一个常见触发事件，它还允许你非常谨慎地选择从代码历史中哪个确切时刻发布版本。为了将发布作业限制为仅使用标签，你需要使用一个表达式来检查正确的条件。如果条件不满足，GitHub
    Actions将跳过作业。
- en: 'Your publishing job must do all of the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你的发布作业必须完成以下所有操作：
- en: Wait for all the other jobs to finish. You don’t want to publish something that
    fails the other checks.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有其他作业完成。你不希望发布失败的检查。
- en: Run only if the Git ref for the triggering event is a tag starting with `v`,
    using the `if` key and the `startsWith` function to check the `github.event.ref`
    context variable value. This will allow you to create tags like `v3.4.0` to trigger
    publishing, but tags unrelated to releases won’t trigger publishing.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅当触发事件的Git引用是一个以`v`开头的标签时才运行，使用`if`键和`startsWith`函数检查`github.event.ref`上下文变量的值。这将允许你创建像`v3.4.0`这样的标签来触发发布，但与发布无关的标签不会触发发布。
- en: Use the `actions/download-artifact@v3` action to download the wheel and source
    distribution files you built and uploaded as artifacts in the previous jobs. You
    can use the `with.path` key to tell the action where to download the artifacts.
    The dist/ directory is a good choice because the next step will look there by
    default.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `actions/download-artifact@v3` 动作下载您在先前作业中构建和上传作为工件的可执行文件和源分发文件。您可以使用 `with.path`
    键告诉动作将工件下载到何处。dist/ 目录是一个不错的选择，因为下一步将默认查找那里。
- en: Use the `pypa/gh-action-pypi-publish@1.5.0` action from the PyPA to take care
    of the publishing details. This action uses twine under the hood, but reduces
    the amount of configuration you need to manage.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PyPA 的 `pypa/gh-action-pypi-publish@1.5.0` 动作来处理发布细节。此动作在底层使用 twine，但减少了您需要管理的配置量。
- en: The configuration for the publishing job should look something like the following
    listing when you’re done.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，发布作业的配置应类似于以下列表。
- en: Listing 7.5 A job for publishing a Python package and its distributions to PyPI
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 一个用于将 Python 包及其分发发布到 PyPI 的作业
- en: '[PRE7]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Runs this job only if triggered by specific tags
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在特定标签触发时运行此作业
- en: ❷ Waits for all other jobs to finish first
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 等待所有其他作业首先完成
- en: ❸ Used to download artifacts from the previous jobs
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 用于从先前作业下载工件
- en: ❹ Downloads all artifacts into a single directory
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将所有工件下载到单个目录中
- en: ❺ Puts artifacts in a directory the next step will use by default
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将工件放入下一步将默认使用的目录
- en: ❻ Used to publish package artifacts to PyPI
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 用于将包工件发布到 PyPI
- en: ❼ Uses an API token instead of user/password authentication
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用 API 令牌而不是用户/密码身份验证
- en: ❽ References the repository secret you added
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 引用您添加的仓库秘密
- en: This time, after you commit and push your changes, you should expect the new
    job to be skipped (see figure 7.16). This is because the commits you push don’t
    match the `if` expression you added.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在您提交并推送更改后，您应该预期新作业将被跳过（见图 7.16）。这是因为您推送的提交与您添加的 `if` 表达式不匹配。
- en: '![](../../OEBPS/Images/07-16.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-16.png)'
- en: Figure 7.16 You can configure jobs in a workflow to be skipped under conditions
    you specify.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 您可以在工作流程中配置作业在指定条件下跳过。
- en: To trigger the publishing job, you need to create a tag with a matching name;
    otherwise, the pipeline won’t be triggered. You also need to ensure you don’t
    try to publish a version that already exists; otherwise, you’ll wait through all
    the jobs of the pipeline only to receive an error during the publishing job. Your
    earlier twine upload likely published version `0.0.1` if you’ve been following
    this book closely. Update the `version` value in your setup.cfg file to the next
    highest version, such as `0.0.2`, now. After updating the version, commit and
    push the change. Then trigger the publishing job using the following steps to
    create a GitHub *release*. A *release* is a GitHub-specific construct that is
    associated with a tag and allows you to add relevant notes and attachments.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发发布作业，您需要创建一个具有匹配名称的标签；否则，管道不会被触发。您还需要确保您不要尝试发布已经存在的版本；否则，您将等待管道中的所有作业，最终在发布作业期间收到错误。如果您一直密切跟随本书，您早期的
    twine 上传可能已发布版本 `0.0.1`。现在，请将 setup.cfg 文件中的 `version` 值更新为下一个最高版本，例如 `0.0.2`。更新版本后，提交并推送更改。然后，按照以下步骤触发发布作业以创建
    GitHub *发布*。*发布* 是 GitHub 特有的结构，与标签相关联，并允许您添加相关的说明和附件。
- en: Note You can achieve the same effect as a GitHub release by manually creating
    a Git tag and pushing it to GitHub. For public projects, the release workflow
    is nice because it gives you an opportunity to enter useful release notes from
    your change log. More on this later in the book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以通过手动创建 Git 标签并将其推送到 GitHub 来实现与 GitHub 发布相同的效果。对于公开项目，发布工作流程很棒，因为它给您提供了一个机会，从您的更改日志中输入有用的发布说明。关于这一点，本书后面会详细介绍。
- en: To create a release, click Releases near the bottom right. This link can be
    hard to spot; you can always visit https://github.com/<you>/<repo>/releases as
    well (see figure 7.17).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建发布，请点击页面右下角的“发布”。此链接可能难以找到；您始终可以访问 https://github.com/<you>/<repo>/releases（见图
    7.17）。
- en: '![](../../OEBPS/Images/07-17.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-17.png)'
- en: Figure 7.17 Navigating to the releases for a GitHub repository
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 导航到 GitHub 仓库的发布
- en: Click Draft a New Release (see figure 7.18).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“创建新发布”（见图 7.18）。
- en: '![](../../OEBPS/Images/07-18.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-18.png)'
- en: Figure 7.18 Starting a new release for a GitHub repository
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 为 GitHub 仓库启动新的发布
- en: 'Click the Choose a Tag dropdown menu, enter a new version such as `v0.0.2`
    into the box, and then click + Create New Tag: v0.0.2 on Publish (see figure 7.19).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“选择标签”下拉菜单，在框中输入新版本号，例如`v0.0.2`，然后点击“发布”中的“+ 创建新标签：v0.0.2”（见图7.19）。
- en: '![](../../OEBPS/Images/07-19.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图7.22](../../OEBPS/Images/07-22.png)'
- en: Figure 7.19 Specifying the tag to create for a GitHub release
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 指定为GitHub发布创建的标签
- en: Click the Target dropdown menu, and choose the Git branch you’re using (see
    figure 7.20).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“目标”下拉菜单，并选择你正在使用的Git分支（见图7.20）。
- en: '![](../../OEBPS/Images/07-20.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20](../../OEBPS/Images/07-20.png)'
- en: Figure 7.20 Specifying the point in the Git history from which to create a tag
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 指定从Git历史中创建标签的点
- en: Enter the version in the Release Title box, and optionally add a description
    for the release describing the changes. Finally, click Publish Release (see figure
    7.21).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在“发布标题”框中输入版本号，并可选地添加描述发布的说明，描述更改。最后，点击“发布发布”（见图7.21）。
- en: '![](../../OEBPS/Images/07-21.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图7.21](../../OEBPS/Images/07-21.png)'
- en: Figure 7.21 Populating and publishing a GitHub release
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 填充和发布GitHub发布
- en: After you publish the release, visit the Actions tab of your repository. You
    should see a new workflow run with your new tag name next to it instead of a branch
    name. This run will meet the condition on the publishing job, and it will not
    be skipped this time (as shown in figure 7.22).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 发布发布后，访问你仓库的动作标签页。你应该会看到一个新的工作流程运行，旁边是你新的标签名称，而不是分支名称。这次运行将满足发布作业的条件，并且这次不会跳过（如图7.22所示）。
- en: '![](../../OEBPS/Images/07-22.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图7.22](../../OEBPS/Images/07-22.png)'
- en: Figure 7.22 A job succeeding after meeting the conditions specified
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 满足指定条件后作业成功
- en: Congratulations! You just published your first fully automated package version.
    How does it feel? If you’re like me, you’re probably tired and a little bit grumpy,
    but in that way that turns into excitement after a night’s sleep. What you’ve
    achieved here can’t be overstated. Your team is free from the confines of their
    local development environments, and you’re delivering prebuilt distributions for
    a wider variety of platforms than ever before. Even though the folks at CarCorp
    use a variety of computer vendors, you can have some confidence that they’ll be
    able to use your work. You’ve also finally gotten the distributions published
    to PyPI so that others can even install them in their Python applications using
    familiar tools like pip. Well done, you.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚发布了你的第一个完全自动化的包版本。感觉如何？如果你像我一样，你可能感到疲惫和有点烦躁，但经过一夜的睡眠后，这种情绪会转变为兴奋。你所取得的成就不容小觑。你的团队摆脱了本地开发环境的束缚，你现在可以为比以往更广泛的平台提供预构建的分发。尽管CarCorp的人们使用各种计算机供应商，但你仍然可以有一些信心，他们能够使用你的工作。你还将最终将分发发布到PyPI，这样其他人甚至可以使用pip等熟悉工具在他们的Python应用程序中安装它们。做得好，你。
- en: Now that you’re an expert in automation and have a package you want people to
    use, you need to make sure they know *how* and *why* to use it. Continue to the
    next chapter to learn about building and maintaining documentation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成为自动化领域的专家，并且有一个希望人们使用的包，你需要确保他们知道**如何**和**为什么**使用它。继续到下一章学习如何构建和维护文档。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Continuous integration gives you frequent, reliable feedback in a shared environment
    for high confidence in changes.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成为你提供了一个共享环境中的频繁、可靠的反馈，从而在更改方面具有高度的信心。
- en: Use a continuous integration solution that works closely with your version control
    system and deployment infrastructure.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与你的版本控制系统和部署基础设施紧密集成的持续集成解决方案。
- en: Check each change you make by configuring your continuous integration solution
    to run several high-level tasks in parallel, each composed of a few specific commands.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过配置你的持续集成解决方案并行运行几个高级任务来检查你做出的每个更改，每个任务由几个特定的命令组成。
- en: Be conservative in triggering your publishing process because you want to make
    sure the code is perfect. Keep a manual trigger in the way of this process until
    you build very high confidence in the system.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在触发你的发布流程时要保守，因为你想要确保代码是完美的。在建立对系统的高度信心之前，保持手动触发这一过程。
