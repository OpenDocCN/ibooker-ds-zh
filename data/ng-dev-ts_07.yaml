- en: Chapter 8\. Implementing component communications
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 实现组件通信
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating loosely coupled components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建松耦合组件
- en: How a parent component should pass data to its child, and vice versa
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父组件如何将数据传递给子组件，反之亦然
- en: Implementing the Mediator design pattern for component communication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现组件通信的中介者设计模式
- en: An Angular application is a tree of views represented by components. While designing
    components, you need to ensure that they’re self-contained and at the same time
    have some means of communicating with each other. In this chapter, we’ll focus
    on how components can pass data to each other in a loosely coupled manner.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用是由组件表示的视图树。在设计组件时，你需要确保它们是自包含的，同时有一些方式可以相互通信。在本章中，我们将重点关注组件如何以松耦合的方式相互传递数据。
- en: First, we’ll show you how a parent component can pass data to its children by
    binding to their input properties. Then, you’ll see how a child component can
    send data to its parent by emitting events via its output properties.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向你展示一个父组件如何通过绑定到它们的输入属性将数据传递给其子组件。然后，你将看到子组件如何通过其输出属性通过发射事件将数据发送给父组件。
- en: We’ll continue with an example that applies the Mediator design pattern to arrange
    data exchange between components that don’t have parent-child relationships. Mediator
    is probably the most important design pattern in any component-based framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用一个示例，该示例应用中介者设计模式来安排没有父子关系的组件之间的数据交换。中介者可能是任何基于组件的框架中最重要的设计模式。
- en: 8.1\. Intercomponent communication
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 组件间通信
- en: '[Figure 8.1](#ch08fig01) shows a view that consists of components that are
    numbered and have different shapes for easier reference. Some of the components
    contain other components (let’s call the outer ones *containers*), and others
    are peers. To abstract this from any particular UI framework, we’ve avoided using
    HTML elements like input fields, drop-downs, and buttons, but you can extrapolate
    this into a view of your real-world application.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.1](#ch08fig01) 展示了一个由编号和不同形状的组件组成的视图，这有助于更容易地参考。其中一些组件包含其他组件（我们称外部的为*容器*），而其他的是同级的。为了避免与任何特定的UI框架相关联，我们避免了使用像输入字段、下拉菜单和按钮这样的HTML元素，但你可以将这些扩展到你的实际应用视图。'
- en: Figure 8.1\. A view consists of components.
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 一个视图由组件组成。
- en: '![](Images/08fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01.jpg)'
- en: When you design a view that consists of multiple components, the less they know
    about each other, the better. Say a user clicks the button in component 4, which
    has to initiate some actions in component 5\. Is it possible to implement this
    scenario without component 4 knowing that component 5 exists? Yes, it is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计一个由多个组件组成的视图时，它们彼此知道的越少，越好。比如说，一个用户在组件4中点击按钮，这个按钮需要在组件5中启动一些操作。是否有可能在不让组件4知道组件5存在的情况下实现这个场景？是的，可以。
- en: You’ve seen already examples of loosely coupling components by using dependency
    injection. Now we’ll show you a different technique for achieving the same goal
    by using bindings and events.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过使用依赖注入看到了松耦合组件的例子。现在我们将通过使用绑定和事件展示另一种实现相同目标的技术。
- en: 8.2\. Input and output properties
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 输入和输出属性
- en: Think of an Angular component as a black box with outlets. Some of them are
    marked as `@Input()`, and others are marked as `@Output()`. You can create a component
    with as many inputs and outputs as you want.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将Angular组件想象成一个带有出口的黑盒。其中一些被标记为`@Input()`，而其他被标记为`@Output()`。你可以创建一个具有任意数量输入和输出的组件。
- en: If an Angular component needs to receive values from the outside world, you
    can bind the producers of these values to the corresponding inputs of the component.
    Who are they received from? The component doesn’t have to know. The component
    just needs to know what to do with these values when they’re provided.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Angular组件需要从外部世界接收值，你可以将这些值的提供者绑定到组件的相应输入上。它们是从哪里接收的？组件不需要知道。组件只需要知道当这些值提供时该如何处理它们。
- en: If a component needs to communicate values to the outside world, it can *emit
    events* through its output properties. Whom are they emitted to? The component
    doesn’t have to know. Whoever is interested can subscribe to the events that a
    component emits.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件需要将值传递到外部世界，它可以通过其输出属性*发射事件*。它们被发射到谁那里？组件不需要知道。任何感兴趣的人都可以订阅组件发射的事件。
- en: Let’s implement these loosely coupled principles. First, you’ll create an `OrderProcessorComponent`
    that can receive order requests from its parent component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这些松耦合原则。首先，你将创建一个`OrderProcessorComponent`，它可以接收来自父组件的订单请求。
- en: 8.2.1\. Input properties
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 输入属性
- en: The input properties of a component annotated with the `@Input()` decorator
    are used to get data from the parent component. Imagine that you want to create
    a UI component for placing orders to buy stocks. It will know how to connect to
    the stock exchange, but that’s irrelevant in the context of this discussion of
    input properties. You want to ensure that `OrderProcessorComponent` receives data
    from other components via its properties marked with `@Input()` decorators. Your
    `OrderProcessorComponent` will look like the following listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Input()`装饰器注解的组件输入属性用于从父组件获取数据。想象一下，你想创建一个用于下单购买股票的UI组件。它将知道如何连接到证券交易所，但在本讨论输入属性的上下文中这不相关。你想要确保`OrderProcessorComponent`通过其带有`@Input()`装饰器的属性从其他组件接收数据。你的`OrderProcessorComponent`将如下所示。
- en: Listing 8.1\. order.component.ts
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. order.component.ts
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Doesn’t show the text unless the stockSymbol is truthy**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只有当stockSymbol为真值时才显示文本**'
- en: '***2* Declares the input property to receive the stock symbol**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明输入属性以接收股票代码**'
- en: '***3* Declares the input property to receive the quantity**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明输入属性以接收数量**'
- en: The `OrderProcessorComponent` doesn’t know who will provide the values for these
    properties, which makes this component completely reusable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderProcessorComponent`不知道谁将为这些属性提供值，这使得该组件完全可重用。'
- en: Next, we’ll look at the `AppComponent`, which in your app is the parent of `OrderComponent`.
    `AppComponent` allows users to enter a stock symbol in the input field, and the
    entered value is passed to the `OrderProcessorComponent` via property binding.
    The following listing shows the code of the `AppComponent`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`AppComponent`，它是你的应用程序中`OrderComponent`的父组件。`AppComponent`允许用户在输入字段中输入股票代码，输入的值通过属性绑定传递给`OrderProcessorComponent`。以下列表显示了`AppComponent`的代码。
- en: Listing 8.2\. input/app.component.ts
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. input/app.component.ts
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* When the user moves the focus from the input field (change event), invokes
    the event handler passing the event object to it**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当用户将焦点从输入字段移除（改变事件）时，调用事件处理器并传递事件对象给它**'
- en: '***2* Binds the input property stockSymbol of the child component to the value
    of the property stock**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将子组件的输入属性stockSymbol绑定到属性stock的值**'
- en: '***3* Binds the value of the property quantity of the child component to the
    value of the property numberOfShares**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将子组件的属性quantity的值绑定到属性numberOfShares的值**'
- en: '***4* You can’t use the keyword const with class properties; use readonly.**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 你不能在类属性中使用关键字const；使用readonly。**'
- en: '***5* Extracts the value of the property target from the event object given
    as an argument**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从作为参数给出的事件对象中提取属性目标值**'
- en: '***6* Assigns the value entered in the input field to the property stock**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将输入字段中输入的值分配给属性stock**'
- en: 'Both properties of the `<order-processor>` component are surrounded with square
    brackets to denote property binding. If you change the value of `stockSymbol`
    or `quantity` inside the `OrderProcessorComponent`, the change won’t affect the
    property values of the parent component. Property binding is unidirectional: from
    parent to child.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`<order-processor>`组件的两个属性都用方括号包围，表示属性绑定。如果你在`OrderProcessorComponent`内部更改`stockSymbol`或`quantity`的值，这不会影响父组件的属性值。属性绑定是单向的：从父组件到子组件。'
- en: 'To see this app in action, run `npm install` in the chapter8/inter-component
    folder, and run the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际效果，请在第8章的`inter-component`文件夹中运行`npm install`，然后运行以下命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Best practice**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Though we praised TypeScript for allowing specification of variable types, we
    didn’t declare the type for the `numberOfShares` property. Because we initialized
    it with a numeric value, TypeScript compiler will use *type inference* to guess
    the type of `NumberOfShares` when it gets initialized. Explicitly declare types
    in a public API, for example, public class properties, function parameters and
    return types, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们赞扬TypeScript允许指定变量类型，但我们没有声明`numberOfShares`属性的类型。因为我们用数值初始化了它，TypeScript编译器将在初始化时使用*类型推断*来猜测`NumberOfShares`的类型。在公共API中明确声明类型，例如，公共类属性、函数参数和返回类型等。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 8.2](#ch08fig02) shows the browser window after the user types `IBM`
    in the input field. The `OrderProcessorComponent` received the input values `100`
    and `IBM`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.2](#ch08fig02) 展示了用户在输入字段中输入 `IBM` 后的浏览器窗口。`OrderProcessorComponent` 接收了输入值
    `100` 和 `IBM`。'
- en: Figure 8.2\. The `OrderProcessorComponent` receives values.
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2. `OrderProcessorComponent` 接收值。
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig02_alt.jpg)'
- en: How can a component intercept the moment when the value of the input property
    `stockSymbol` changes to perform some additional processing? A simple way is to
    turn `stockSymbol` into a setter. If you want to use `stockSymbol` in the template
    of the component, create a getter as well, as shown in the following listing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让组件拦截输入属性 `stockSymbol` 值变化时的时刻以执行一些额外的处理？一个简单的方法是将 `stockSymbol` 转换为一个设置器。如果你想在组件的模板中使用
    `stockSymbol`，也要创建一个获取器，如下面的列表所示。
- en: Listing 8.3\. Adding the setter and getter
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3. 添加设置器和获取器
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* This private variable isn’t accessible from the template.**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此私有变量无法从模板中访问。**'
- en: '***2* Defines an input property as a setter**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义一个输入属性为设置器**'
- en: '***3* Defines a getter so stockSymbol is accessible from the template**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义一个获取器以便从模板中访问 stockSymbol**'
- en: When this application starts, the change detection mechanism qualifies the initialization
    as a change of the bound variable `stockSymbol`. The setter is invoked, and, to
    avoid sending an order for the undefined `stockSymbol`, you check its value in
    the setter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当此应用程序启动时，变更检测机制将初始化视为绑定变量 `stockSymbol` 的变更。设置器被调用，为了避免为未定义的 `stockSymbol`
    发送订单，你在设置器中检查其值。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In [section 9.2.1](kindle_split_018.xhtml#ch09lev2sec3) in [chapter 9](kindle_split_018.xhtml#ch09),
    we’ll show you how to intercept the changes in input properties without using
    setters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第9.2.1节](kindle_split_018.xhtml#ch09lev2sec3) 中，我们将展示如何在 [第9章](kindle_split_018.xhtml#ch09)
    中拦截输入属性的变更而不使用设置器。
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.2.2\. Output properties and custom events
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2. 输出属性和自定义事件
- en: Angular components can dispatch custom events using the `EventEmitter` object.
    These events are to be consumed by the component’s parent. `EventEmitter` is a
    subclass of `Subject` (explained in [appendix D](kindle_split_028.xhtml#app04))
    that can serve as both observable and observer, but typically you use `EventEmitter`
    just for emitting custom events that are handled in the template of the parent
    component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 组件可以使用 `EventEmitter` 对象派发自定义事件。这些事件将由组件的父组件消费。`EventEmitter` 是 `Subject`
    的一个子类（在附录D中解释），它可以作为观察者和观察对象，但通常你只使用 `EventEmitter` 来派发自定义事件，这些事件在父组件的模板中处理。
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Best practice**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: If you need to have an object that’s both an observable and an observer, use
    the RxJS `BehaviorSubject`. You’ll see how to do that in [section 8.3.2](#ch08lev2sec4).
    In future releases, the internal implementation of `EventEmitter` may change,
    so it’s better to use it only for emitting custom events.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个既是观察者又是观察对象的对象，请使用 RxJS 的 `BehaviorSubject`。你将在 [第8.3.2节](#ch08lev2sec4)
    中看到如何做到这一点。在未来的版本中，`EventEmitter` 的内部实现可能会改变，因此最好只用于派发自定义事件。
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s say you need to write a UI component that’s connected to a stock exchange
    and displays changing stock prices. In addition to displaying prices, the component
    should also send events with the latest prices so its parent component can handle
    it and apply business logic to the changing prices. Let’s create a `PriceQuoterComponent`
    that implements such functionality. In this component, you won’t connect to any
    financial servers but will rather emulate the changing prices using a random number
    generator.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要编写一个连接到证券交易所并显示股票价格的UI组件。除了显示价格外，该组件还应发送包含最新价格的事件，以便其父组件可以处理它并应用业务逻辑到变化的价格。让我们创建一个
    `PriceQuoterComponent` 来实现这样的功能。在这个组件中，你不会连接到任何金融服务器，而是使用随机数生成器来模拟价格的变化。
- en: Displaying changing prices inside `PriceQuoterComponent` is pretty straightforward—you’ll
    bind the `stockSymbol` and `lastPrice` properties to the component’s template.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PriceQuoterComponent` 中显示变化的价格相当直接——你将 `stockSymbol` 和 `lastPrice` 属性绑定到组件的模板中。
- en: 'You’ll notify the parent about the latest prices by emitting custom events
    via the `@Output` property of the component. Not only will you fire an event as
    soon as the price changes, but this event will also carry a payload: an object
    with the stock symbol and its latest price. The type of the payload will be defined
    as `PriceQuote` interface, as shown in the following listing.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过组件的`@Output`属性发出自定义事件来通知父组件最新的价格。不仅您会在价格变化时立即触发事件，而且此事件还将携带一个负载：一个包含股票符号及其最新价格的对象。负载的类型将被定义为`PriceQuote`接口，如下所示。
- en: Listing 8.4\. iprice.quote.ts
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. iprice.quote.ts
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PriceQuoterComponent` will generate random quotes and will emit them every
    two seconds.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriceQuoterComponent`将生成随机报价，并且每两秒发出一次。'
- en: Listing 8.5\. price.quoter.component.ts
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. price.quoter.component.ts
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* The question mark represents the safe navigation operator.**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 问号代表安全导航操作符。**'
- en: '***2* The output property lastPrice is represented by the EventEmitter object,
    which emits lastPrice events to the parent.**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出属性lastPrice由EventEmitter对象表示，该对象向父组件发出lastPrice事件。**'
- en: '***3* Emulates changing prices by invoking a function that generates a random
    number every two seconds and populates the priceQuote object**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过每两秒调用生成随机数的函数来模拟价格变化，并填充priceQuote对象**'
- en: '***4* Emits new price via the output property; the lastPrice event carries
    the PriceQuote object as a payload**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通过输出属性发出新价格；lastPrice事件携带PriceQuote对象作为负载**'
- en: The safe navigation operator in `priceQuote?` ensures that if the `priceQuote`
    object isn’t available yet, the code in the template won’t try to access properties
    of an uninitialized `priceQuote`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`priceQuote?`中的安全导航操作符确保如果`priceQuote`对象尚未可用，模板中的代码不会尝试访问未初始化的`priceQuote`对象的属性。'
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: We used the `Observable.interval()` instead of `setInterval()` because the latter
    is the browser-only API. Starting from Angular 6, use `interval()` instead of
    `Observable.interval()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`Observable.interval()`而不是`setInterval()`，因为后者是仅适用于浏览器的API。从Angular 6开始，请使用`interval()`而不是`Observable.interval()`。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The next listing shows how the parent component will receive and handle the
    `lastPrice` from the `<price-quoter>` component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了父组件将如何接收和处理来自`<price-quoter>`组件的`lastPrice`。
- en: Listing 8.6\. app.component.ts
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. app.component.ts
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The AppComponent receives the lastPrice event and invokes the priceQuoteHandler,
    passing the received object as an argument.**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* AppComponent接收lastPrice事件并调用priceQuoteHandler，将接收到的对象作为参数传递。**'
- en: '***2* Receives the IPriceQuote object and uses its properties to populate the
    respective properties of the AppComponent**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 接收IPriceQuote对象并使用其属性填充AppComponent的相关属性**'
- en: Run this example, and you’ll see the prices update every two seconds in both
    `PriceQuoterComponent` (on a pink background) as well as in `AppComponent` (white
    background), as shown in [figure 8.3](#ch08fig03).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例，您将看到价格在每两秒更新一次，在`PriceQuoterComponent`（粉色背景）以及`AppComponent`（白色背景）中，如图[图8.3](#ch08fig03)所示。
- en: Figure 8.3\. Running the output properties example
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 运行输出属性示例
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig03_alt.jpg)'
- en: 'To see this app in action, run the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的运行情况，请运行以下命令：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Event bubbling**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件冒泡**'
- en: 'Angular doesn’t offer an API to support event bubbling. If you try to listen
    to the `lastPrice` event not on the `<price-quoter>` element but on its parent,
    the event won’t bubble up there. In the following code snippet, the `lastPrice`
    event won’t reach the `<div>`, because it’s the parent of `<price-quoter>`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Angular不提供支持事件冒泡的API。如果您尝试在`<price-quoter>`元素上而不是其父元素上监听`lastPrice`事件，事件将不会在那里冒泡。在以下代码片段中，`lastPrice`事件不会到达`<div>`，因为它是`<price-quoter>`的父元素：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If event bubbling is important to your app, don’t use `EventEmitter`; use native
    DOM events instead. The following code snippet shows how the `PriceQuoterComponent`
    uses a `CustomEvent` (from Web API) that supports bubbling:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件冒泡对您的应用很重要，不要使用`EventEmitter`；请使用原生的DOM事件。以下代码片段展示了`PriceQuoterComponent`如何使用支持冒泡的`CustomEvent`（来自Web
    API）：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Angular injects an `ElementRef` object, which has a reference to the DOM element
    that represents `<price-quoter>`, and then a `CustomEvent` is dispatched by invoking
    `element.nativeElement.dispatchEvent()`. Event bubbling will work here, but using
    `ElementRef` works only in browser-based apps and won’t work with non-HTML renderers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Angular注入一个`ElementRef`对象，该对象有一个指向代表`<price-quoter>`的DOM元素的引用，然后通过调用`element.nativeElement.dispatchEvent()`来触发一个`CustomEvent`。在这里，事件冒泡将起作用，但使用`ElementRef`仅在基于浏览器的应用程序中有效，与非HTML渲染器不兼容。
- en: 'The `AppComponent` shown next handles the `lastPrice` event in the `<div>`,
    which is a parent of the `<price-quoter>` component. Note that the type of the
    argument of the `priceQuoteHandler()` is `CustomEvent`, and you can access its
    payload via the `detail` property:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`AppComponent`处理`<div>`中的`lastPrice`事件，它是`<price-quoter>`组件的父组件。请注意，`priceQuoteHandler()`参数的类型是`CustomEvent`，您可以通过`detail`属性访问其有效载荷：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We established that each UI component should be self-contained and shouldn’t
    rely on the existence of other UI components, and using `@Input()` and `@Output()`
    decorators allows you to create reusable components. But how do you arrange communication
    between two components if they don’t know about each other?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定每个UI组件应该是自包含的，并且不应该依赖于其他UI组件的存在，使用`@Input()`和`@Output()`装饰器可以创建可重用组件。但是，如果两个组件彼此不了解，如何安排它们之间的通信呢？
- en: 8.3\. Implementing the Mediator design pattern
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. 实现中介者设计模式
- en: Communication between loosely coupled components can be implemented using the
    Mediator design pattern, which, according to Wikipedia, “defines how a set of
    objects interact” ([https://en.wikipedia.org/wiki/Mediator_pattern](https://en.wikipedia.org/wiki/Mediator_pattern)).
    We’ll explain what this means by analogy with interconnecting toy bricks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中介者设计模式可以实现松散耦合组件之间的通信，根据维基百科的定义，该模式“定义了一组对象如何交互”([https://en.wikipedia.org/wiki/Mediator_pattern](https://en.wikipedia.org/wiki/Mediator_pattern))。我们将通过类比连接玩具积木来解释这究竟意味着什么。
- en: Imagine a child playing with building bricks (think *components*) that “don’t
    know” about each other. Today this child (the *mediator*) can use some blocks
    to build a house, and tomorrow they’ll construct a boat from the same components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个孩子正在玩搭建积木（想象成组件）的游戏，这些积木“不知道”彼此的存在。今天这个孩子（中介者）可以用一些积木搭建一座房子，明天他们将从相同的积木中构建一艘船。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The role of the mediator is to ensure that components properly fit together
    according to the task at hand while remaining loosely coupled.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者的作用是确保组件根据当前任务正确地组合在一起，同时保持松散耦合。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Coming back to the web UI realm, we’ll consider two cases:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Web UI领域，我们将考虑两种情况：
- en: Arranging communication when components have a common parent
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件有共同父组件时的通信安排
- en: Arranging communication when components don’t have a common parent
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件没有共同父组件时的通信安排
- en: 8.3.1\. Using a common parent as a mediator
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1. 使用共同父组件作为中介者
- en: Let’s revisit the first figure of this chapter, shown again in [figure 8.4](#ch08fig04).
    Each component except 1 has a parent (a container) that can play the role of mediator.
    The top-level mediator is container 1, which is responsible for making sure its
    direct children 2, 3, and 6 can communicate if need be. On the other hand, component
    2 is a mediator for 4 and 5\. Component 3 is a mediator for 7 and 8.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾本章的第一幅图，再次展示在[图8.4](#ch08fig04)。除了组件1之外，每个组件都有一个父组件（容器），它可以充当中介者的角色。顶级中介者是容器1，它负责确保其直接子组件2、3和6在需要时能够进行通信。另一方面，组件2是组件4和5的中介者。组件3是组件7和8的中介者。
- en: Figure 8.4\. A view consists of components.
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4. 视图由组件组成。
- en: '![](Images/08fig04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig04.jpg)'
- en: The mediator needs to receive data from one component and pass it to another.
    Let’s go back to examples of monitoring stock prices.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者需要从组件接收数据并将其传递给另一个组件。让我们回到监控股票价格的例子。
- en: Imagine a trader monitoring the prices of several stocks. At some point, the
    trader clicks the Buy button next to a stock symbol to place a purchase order
    with the stock exchange. You can easily add a Buy button to the `PriceQuoterComponent`
    from the previous section, but this component doesn’t know how to place orders
    to buy stocks. `PriceQuoterComponent` will notify the mediator (`AppComponent`)
    that the trader wants to purchase a particular stock at that moment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个交易员正在监控几只股票的价格。在某个时刻，交易员点击了股票符号旁边的购买按钮，向证券交易所下单。你可以轻松地将购买按钮添加到上一节中的 `PriceQuoterComponent`，但这个组件不知道如何下单购买股票。`PriceQuoterComponent`
    将通知调解器（`AppComponent`），交易员此时想要购买特定的股票。
- en: The mediator should know which component can place purchase orders and how to
    pass the stock symbol and quantity to it. [Figure 8.5](#ch08fig05) shows how an
    `AppComponent` can mediate the communication between `PriceQuoterComponent` and
    `OrderComponent`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 调解器应该知道哪个组件可以放置购买订单，以及如何将股票符号和数量传递给它。[图 8.5](#ch08fig05) 展示了 `AppComponent`
    如何在 `PriceQuoterComponent` 和 `OrderComponent` 之间进行通信调解。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Emitting events works like broadcasting. `PriceQuoterComponent` emits events
    via the `@Output()` property without knowing who will receive them. `OrderComponent`
    waits for the value of its `@Input()` property to change as a signal for placing
    an order.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 发射事件的工作方式类似于广播。`PriceQuoterComponent` 通过 `@Output()` 属性发射事件，而不需要知道谁将接收它们。`OrderComponent`
    等待其 `@Input()` 属性的值发生变化，作为下单的信号。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 8.5\. Mediating communications
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 调解通信
- en: '![](Images/08fig05_alt.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig05_alt.jpg)'
- en: 'To demonstrate the Mediator pattern in action, let’s write a small app that
    consists of the two components shown in [figure 8.5](#ch08fig05). You can find
    this application in the mediator-parent directory, which has the following files:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示调解器模式的应用，让我们编写一个小型应用程序，该应用程序由 [图 8.5](#ch08fig05) 中显示的两个组件组成。您可以在调解器父目录中找到此应用程序，该目录包含以下文件：
- en: '***istock.ts*—** The `Stock` interface defining a value object that represents
    a stock'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***istock.ts*—** 定义表示股票的值对象的 `Stock` 接口'
- en: '***price.quoter.component.ts*—** `PriceQuoterComponent`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***price.quoter.component.ts*—** `PriceQuoterComponent`'
- en: '***order.component.ts*—** `OrderComponent`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***order.component.ts*—** `OrderComponent`'
- en: '***app.component.ts*—** A parent component (the mediator) that contains `<price-quoter>`
    and `<order-processor>` in its template'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***app.component.ts*—** 包含 `<price-quoter>` 和 `<order-processor>` 的模板中的父组件（调解器）'
- en: '***app.module.ts*—** The `AppModule` class'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***app.module.ts*—** `AppModule` 类'
- en: 'You’ll use the `Stock` interface in two scenarios:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在两种情况下使用 `Stock` 接口：
- en: To represent the payload of the event emitted by the `PriceQuoterComponent`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了表示由 `PriceQuoterComponent` 发射的事件的有效负载
- en: To represent the data given to the `OrderComponent` via binding
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了表示通过绑定传递给 `OrderComponent` 的数据
- en: The content of the istock.ts file is shown in the following listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 istock.ts 文件的内容。
- en: Listing 8.7\. istock.ts
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. istock.ts
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `PriceQuoterComponent`, shown in the next listing, has a Buy button and
    the `buy` output property. It emits the `buy` event only when the user clicks
    the Buy button.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中展示的 `PriceQuoterComponent` 有一个购买按钮和 `buy` 输出属性。它仅在用户点击购买按钮时发射 `buy` 事件。
- en: Listing 8.8\. price.quoter.component.ts
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. price.quoter.component.ts
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* The buy output property will be used as a custom buy event.**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 购买输出属性将用作自定义购买事件。**'
- en: '***2* Emits the custom buy event**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 发射自定义购买事件**'
- en: When the mediator (`AppComponent`) receives the `buy` event from `<price-quoter>`,
    it extracts the payload from this event and assigns it to the `stock` variable,
    which is bound to the input parameter of `<order-processor>`, as shown in the
    following listing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当调解器（`AppComponent`）从 `<price-quoter>` 接收到 `buy` 事件时，它从该事件中提取有效负载并将其分配给 `stock`
    变量，该变量绑定到 `<order-processor>` 的输入参数，如下列所示。
- en: Listing 8.9\. app.component.ts
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. app.component.ts
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* When the mediator receives the buy event, it invokes the event handler.**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当调解器接收到购买事件时，它将调用事件处理器。**'
- en: '***2* The stock received from <price-quoter> is passed to <order-processor>.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将从 `<price-quoter>` 接收到的股票传递给 `<order-processor>`。**'
- en: When the value of the `buy` input property on `OrderComponent` changes, its
    setter displays the message “Placed order ...,” showing the `stockSymbol` and
    the `bidPrice`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `OrderComponent` 上的 `buy` 输入属性的值发生变化时，其设置器将显示消息“已放置订单...”，显示 `stockSymbol`
    和 `bidPrice`。
- en: Listing 8.10\. order.component.ts
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. order.component.ts
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Receives the stock object through this setter**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过此设置器接收股票对象**'
- en: '***2* Prepares a message to be displayed in the template**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 准备在模板中显示的消息**'
- en: '[Figure 8.6](#ch08fig06) shows what happens after the user clicked the Buy
    button when the price of the IBM stock was $36.53\. `PriceQuoterComponent` is
    rendered on the left, and `OrderComponent` is on the right. They’re self-contained,
    loosely coupled, and still can communicate with each other via the `AppComponent`
    mediator.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6](#ch08fig06) 展示了当IBM股票价格为36.53美元时，用户点击购买按钮后发生的情况。`PriceQuoterComponent`
    在左侧渲染，而 `OrderComponent` 在右侧。它们是自包含的、松散耦合的，并且仍然可以通过 `AppComponent` 中介相互通信。'
- en: Figure 8.6\. Running the mediator example
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6\. 运行中介示例
- en: '![](Images/08fig06_alt.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![示例交易员屏幕](Images/08fig06_alt.jpg)'
- en: 'To see this app in action, run the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请运行以下命令：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Mediator design pattern is a good fit for ngAuction as well. Imagine the
    last minutes of a bidding war for a hot product. Users monitor frequently updated
    bids and click a button to increase their bids.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 中介设计模式也适合ngAuction。想象一下对热门产品的拍卖战最后几分钟。用户监控频繁更新的出价，并点击按钮提高他们的出价。
- en: 8.3.2\. Using an injectable service as a mediator
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 使用可注入服务作为中介
- en: In the last section, you saw how sibling components use their parent as a mediator.
    If components don’t have the same parent or aren’t displayed at the same time
    (the router may not display the required component at the moment), you can use
    an injectable service as a mediator. Whenever the component is created, the mediator
    service is injected, and the component can subscribe to events emitted by the
    service (as opposed to using `@Input()` parameters like `OrderComponent` did).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您看到了兄弟组件如何使用它们的父组件作为中介。如果组件没有相同的父组件或不是同时显示的（路由器可能此时不会显示所需的组件），您可以使用可注入服务作为中介。每当组件被创建时，中介服务就会被注入，组件可以订阅服务发出的事件（与
    `OrderComponent` 所使用的 `@Input()` 参数相反）。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**A real-world example of a multicomponent UI**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**多组件UI的真实世界示例**'
- en: You can find many UIs that consist of multiple components in real-world web
    apps. We’ll show you a UI taken from the publicly available site [www.forex.com](http://www.forex.com)
    that offers a web platform for trading currencies. A trader can monitor the prices
    of multiple currency pairs (for example, US dollars and euros) in real time and
    place orders to buy the currencies when the price is right.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的Web应用中，您可以找到许多由多个组件组成的UI。我们将向您展示一个从公开网站 [www.forex.com](http://www.forex.com)
    获取的UI，该网站提供了一个用于货币交易的Web平台。交易员可以实时监控多种货币对的报价（例如，美元和欧元），并在价格合适时下单购买货币。
- en: Here’s a snapshot of a trader’s screen that you can find at [http://mng.bz/M9Af](http://mng.bz/M9Af).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以在 [http://mng.bz/M9Af](http://mng.bz/M9Af) 找到的交易员屏幕的快照。
- en: '![](Images/f0191-01_alt.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![示例](Images/f0191-01_alt.jpg)'
- en: A sample trader’s screen from forex.com
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 forex.com 的示例交易员屏幕
- en: We don’t know which JavaScript framework (if any) was used for creating this
    UI, but we can clearly see that it consists of multiple components. If we needed
    to develop such an app in Angular, we’d create, say, a `CurrencyPairComponent`
    and would place four of its instances at the top. Below, we’d use other components,
    such as `PopularMarketComponent`, `WatchListComponent`, and so on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道创建此UI时使用了哪个JavaScript框架（如果有的话），但我们可以清楚地看到它由多个组件组成。如果我们需要在Angular中开发这样的应用程序，我们会创建一个
    `CurrencyPairComponent`，并在顶部放置其四个实例。下面，我们会使用其他组件，例如 `PopularMarketComponent`、`WatchListComponent`
    等。
- en: 'Within the `CurrencyPairComponent`, we’d create two child components: `SellComponent`
    and `BuyComponent`. Their Sell and Buy buttons would emit a custom event that
    would be received by the parent `CurrencyPairComponent`, which in turn would need
    to communicate with an `OrderComponent` to place a sell or buy order. But what
    if `CurrencyPairComponent` and `OrderComponent` don’t have a common parent? Who
    will mediate their communications?'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CurrencyPairComponent` 中，我们会创建两个子组件：`SellComponent` 和 `BuyComponent`。它们的买卖按钮会发出一个自定义事件，该事件会被父
    `CurrencyPairComponent` 接收，然后父组件需要与 `OrderComponent` 通信以放置买卖订单。但如果 `CurrencyPairComponent`
    和 `OrderComponent` 没有共同的父组件，谁将作为它们通信的中介？
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 8.7](#ch08fig07) shows a diagram representing a scenario when component
    5 needs to send data to components 6 and 8\. As you see, they don’t have a common
    parent, so you use an injectable service as a mediator.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7](#ch08fig07) 展示了一个场景图，表示组件5需要向组件6和8发送数据。如您所见，它们没有共同的父组件，因此您使用可注入服务作为中介。'
- en: Figure 8.7\. Injectable service as mediator
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图8.7\. 可注入服务作为中介](Images/08fig07.jpg)'
- en: '![](Images/08fig07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6\. 运行中介示例](Images/08fig07.jpg)'
- en: The same instance of the service will be injected into components 5, 6, and
    8\. Component 5 can use the API of the service to provide some data, and components
    6 and 8 will subscribe to the data as soon as they’re instantiated. By creating
    a subscription in the constructors of components 6 and 8, you ensure that no matter
    when these components are created, they’ll start getting data from the service
    right away.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个服务实例将被注入到组件 5、6 和 8 中。组件 5 可以使用服务的 API 提供一些数据，而组件 6 和 8 将在实例化后立即订阅数据。通过在组件
    6 和 8 的构造函数中创建订阅，您确保无论这些组件何时创建，它们都会立即从服务中获取数据。
- en: Let’s consider a practical example to illustrate how this works. Imagine you
    have a UI with which you can search for products by typing a product name in an
    input box of a component. You want to offer searching for products either on eBay
    or Amazon. Initially, you’ll render the eBay component, but if users aren’t satisfied
    with the deal offered on eBay, they’ll try to find the same product on Amazon.
    [Figure 8.8](#ch08fig08) shows the UI of this app after the user enters `aaa`
    as a product name in the search field. Initially, the eBay component is rendered
    and receives aaa as a product to search for.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个实际例子来说明这是如何工作的。想象您有一个 UI，您可以通过在组件的输入框中输入产品名称来搜索产品。您希望提供在 eBay 或 Amazon
    上搜索产品的功能。最初，您将渲染 eBay 组件，但如果用户对 eBay 提供的交易不满意，他们会在 Amazon 上寻找相同的产品。[图 8.8](#ch08fig08)
    展示了用户在搜索字段中输入 `aaa` 作为产品名称后的该应用 UI。最初，渲染了 eBay 组件，并接收 aaa 作为要搜索的产品。
- en: Figure 8.8\. Searching for product aaa on eBay
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8\. 在 eBay 上搜索产品 aaa
- en: '![](Images/08fig08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig08.jpg)'
- en: Say eBay provides details and pricing for aaa, but the user isn’t happy and
    clicks the link to find the same product on Amazon. Your UI has two links, one
    for eBay and another for Amazon. When the user clicks the Amazon link, the router
    destroys the eBay component and creates the Amazon one. You want to maintain the
    application state so the user doesn’t need to reenter the product name, and the
    Amazon component has to be rendered showing aaa—the saved search criteria, as
    shown in [figure 8.9](#ch08fig09).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 eBay 提供了 aaa 的详细信息和定价，但用户不满意并点击链接在 Amazon 上寻找相同的产品。您的 UI 有两个链接，一个用于 eBay，另一个用于
    Amazon。当用户点击 Amazon 链接时，路由器销毁 eBay 组件并创建 Amazon 组件。您希望保持应用程序状态，以便用户不需要重新输入产品名称，并且
    Amazon 组件必须渲染显示 aaa——保存的搜索条件，如图 [8.9](#ch08fig09) 所示。
- en: Figure 8.9\. Searching for product aaa on Amazon
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.9\. 在 Amazon 上搜索产品 aaa
- en: '![](Images/08fig09.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig09.jpg)'
- en: If the user changes their mind and decides to search for a different product
    on Amazon, and then returns back to eBay, the new search criteria has to be shown
    in the eBay component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户改变主意，决定在 Amazon 上搜索不同的产品，然后返回 eBay，新的搜索条件必须在 eBay 组件中显示。
- en: 'So you need to implement two features:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要实现两个功能：
- en: Communication between the search, eBay, and Amazon components.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索、eBay 和 Amazon 组件之间的通信。
- en: State management so the latest search criteria is preserved while the user navigates
    between eBay and Amazon.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理，以便在用户在 eBay 和 Amazon 之间导航时保留最新的搜索条件。
- en: 'The code for this app is located in the mediator-service-subject folder and
    contains the following files:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的代码位于 mediator-service-subject 文件夹中，并包含以下文件：
- en: '***app.component.ts*—** The top-level component `AppComponent`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***app.component.ts*—** 最高级组件 `AppComponent`'
- en: '***app.module.ts*—** The `AppModule` that includes routes configuration'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***app.module.ts*—** 包含路由配置的 `AppModule`'
- en: '***state.service.ts*—** The injectable service that also stores the app state'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***state.service.ts*—** 存储应用状态的注入式服务'
- en: '***search.component.ts*—** The `SearchComponent` with an `<input>` field'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***search.component.ts*—** 带有 `<input>` 字段的 `SearchComponent`'
- en: '***amazon.component.ts*—** The `AmazonComponent`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***amazon.component.ts*—** `AmazonComponent`'
- en: '***ebay.component.ts*—** The `EbayComponent`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***ebay.component.ts*—** `EbayComponent`'
- en: '`AppComponent` serves as a parent for `SearchComponent`, provides two links
    to eBay and Amazon components, and includes `<router-outlet>`, as shown in the
    following listing.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent` 作为 `SearchComponent` 的父组件，提供 eBay 和 Amazon 组件的两个链接，并包含 `<router-outlet>`，如下所示。'
- en: Listing 8.11\. app.component.ts
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. app.component.ts
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* The user enters the product name here.**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用户在此处输入产品名称。**'
- en: '***2* A link used for navigation**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用于导航的链接**'
- en: '***3* The eBay or Amazon component is rendered under the links.**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* eBay 或 Amazon 组件在链接下方渲染。**'
- en: '`AppModule` loads the routes configuration as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppModule` 按如下方式加载路由配置：'
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You want to create an injectable `StateService` that would accept the search
    criteria from the `SearchComponent` and emit it to its subscribers (eBay or Amazon
    components). In [appendix D](kindle_split_028.xhtml#app04), we explain how the
    RxJS `Subject` works. It contains both observable and observer and would fit your
    needs except it wouldn’t remember the emitted value (the search criteria). You
    could create a separate variable to store the value provided by the `SearchComponent`,
    but there’s a better solution.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个可注入的 `StateService`，它将接受来自 `SearchComponent` 的搜索条件并将其发送给其订阅者（eBay 或 Amazon
    组件）。在 [附录 D](kindle_split_028.xhtml#app04) 中，我们解释了 RxJS 的 `Subject` 如何工作。它包含可观察对象和观察者，将满足您的需求，但不会记住已发出的值（搜索条件）。您可以为
    `SearchComponent` 提供的值创建一个单独的变量来存储，但有一个更好的解决方案。
- en: 'The RxJS library includes `BehaviorSubject`, which supports the functionality
    of `Subject`—plus it reemits the latest emitted value. Let’s see how it’ll work
    in your app:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 库包括 `BehaviorSubject`，它支持 `Subject` 的功能——并且它会重新发出最新的已发出值。让我们看看它如何在您的应用中工作：
- en: '**1**.  The user enters `aaa`, and the `SearchComponent` invokes the API on
    the `StateService` to emit `aaa` to the subscriber, which is initially an eBay
    component. The `BehaviorSubject` emits `aaa` and remembers it (stores the app
    state).'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 用户输入 `aaa`，`SearchComponent` 调用 `StateService` 的 API 以将 `aaa` 发送到订阅者，最初是一个
    eBay 组件。`BehaviorSubject` 发出 `aaa` 并记住它（存储应用状态）。'
- en: '**2**.  The user navigates to the Amazon component, which immediately subscribes
    to the same `BehaviorSubject`, which reemits `aaa`.'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 用户导航到 Amazon 组件，该组件立即订阅了相同的 `BehaviorSubject`，重新发出 `aaa`。'
- en: The code of the `StateService` is shown in the next listing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了 `StateService` 的代码。
- en: Listing 8.12\. state.service.ts
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. state.service.ts
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Creates an instance of BehaviorSubject to reemit the last emitted value
    to new subscribers**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个 `BehaviorSubject` 实例以重新向新订阅者发出最后一个发出的值**'
- en: '***2* SearchComponent will invoke this method.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* SearchComponent 将调用此方法。**'
- en: '***3* Emits the search criteria to subscriber(s)**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向订阅者发出搜索条件**'
- en: '***4* Returns the reference to Observable of the Subject**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回主题的可观察对象的引用**'
- en: The `getState()` method returns the observable portion of `BehaviorSubject`
    so the eBay or Amazon components can subscribe to it. Technically, these components
    could subscribe to the subject directly, but if they had a reference to your `BehaviorSubject`,
    they could use the `next()` API to emit data on the subject’s observers. You want
    to allow eBay or Amazon components to only use the `subscribe()` API—that’s why
    you’ll give them only the reference to the observable property from the `BehaviorSubject`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`getState()` 方法返回 `BehaviorSubject` 的可观察部分，这样 eBay 或 Amazon 组件就可以订阅它。技术上，这些组件可以直接订阅主题，但如果它们有对您的
    `BehaviorSubject` 的引用，它们可以使用 `next()` API 在主题的观察者上发出数据。您希望允许 eBay 或 Amazon 组件仅使用
    `subscribe()` API——这就是为什么您将只提供来自 `BehaviorSubject` 的可观察属性引用的原因。'
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We used the `Injectable()` decorator, but it’s optional here because we don’t
    inject other services into `StateService`. If we injected into this service the
    `HttpClient` or any other service, using `Injectable()` would be required.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `Injectable()` 装饰器，但在这里它是可选的，因为我们没有将其他服务注入到 `StateService` 中。如果我们向这个服务注入
    `HttpClient` 或任何其他服务，使用 `Injectable()` 就是必需的。
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The code of the `SearchComponent` is shown next. You use the Forms API to subscribe
    to the `valueChanges` observable, as explained in [chapter 6](kindle_split_015.xhtml#ch06).
    Note that you inject the `StateService` into this component, and as the user types
    in the input field, you assign the values to the `searchCriteria` property on
    the `StateService`. The `searchCriteria` property is implemented as a setter,
    which emits the values entered by the user to the subscriber(s) of the `stateSubject`,
    as shown in the following listing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了 `SearchComponent` 的代码。您使用表单 API 订阅 `valueChanges` 可观察对象，如 [第 6 章](kindle_split_015.xhtml#ch06)
    中所述。请注意，您将 `StateService` 注入到该组件中，并且当用户在输入字段中键入时，您将值分配给 `StateService` 上的 `searchCriteria`
    属性。`searchCriteria` 属性实现为一个设置器，将用户输入的值发送到 `stateSubject` 的订阅者，如下面的列表所示。
- en: Listing 8.13\. search.component.ts
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. search.component.ts
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* An observable that emits the content of the input field**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个发出输入字段内容的可观察对象**'
- en: '***2* Passes the entered value to StateService**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将输入值传递给 StateService**'
- en: The following listing shows the code of `EbayComponent`, which gets `StateService`
    injected and subscribes to the observable of `stateSubject`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 `EbayComponent` 的代码，它注入了 `StateService` 并订阅了 `stateSubject` 的可观察对象。
- en: Listing 8.14\. ebay.component.ts
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.14\. ebay.component.ts
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* The async pipe autosubscribes to the observable searchFor$.**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 异步管道自动订阅 observable searchFor$。**'
- en: '***2* Injects the StateService**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 StateService**'
- en: '***3* Stores the observable in the class variable**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将可观察对象存储在类变量中**'
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The code in the `AmazonComponent` should be identical, but in the source code
    that comes with this chapter, we keep a more verbose version that uses `subscribe()`
    and `unsubscribe` so you can compare and appreciate the benefits of the `async`
    pipe.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`AmazonComponent` 中的代码应该是相同的，但在本章附带源代码中，我们保留了一个更冗长的版本，它使用 `subscribe()` 和 `unsubscribe`，这样您就可以比较并欣赏
    `async` 管道的好处。'
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When the eBay (or Amazon) component is created, it gets the existing state of
    the `stateSubject` and displays it. [Figure 8.10](#ch08fig10) shows how the components
    of the sample app communicate.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建eBay（或Amazon）组件时，它会获取 `stateSubject` 的现有状态并显示它。[图8.10](#ch08fig10) 展示了示例应用中组件之间的通信方式。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This sample app not only illustrates how you can arrange intercomponent communication
    using an injectable service as a mediator, it also shows how you can keep track
    of the app state in small and mid-size applications. If your application is large,
    consider implementing app state using the NgRx library, as explained in [chapter
    15](kindle_split_024.xhtml#ch15).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用不仅说明了您如何使用可注入服务作为中介来安排组件间的通信，还展示了您如何在小型和中型应用中跟踪应用状态。如果您的应用很大，请考虑使用NgRx库实现应用状态，如第15章所述。[第15章](kindle_split_024.xhtml#ch15)。
- en: '|  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 8.10\. The application’s workflows
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.10\. 应用的工作流程
- en: '![](Images/08fig10_alt.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig10_alt.jpg)'
- en: 'To see this application in action, run the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的实际运行情况，请运行以下命令：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can also watch a short video that explains how this app works at [http://mng.bz/oE0s](http://mng.bz/oE0s).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以观看一个简短的视频，解释这个应用是如何工作的：[http://mng.bz/oE0s](http://mng.bz/oE0s)。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t start implementing the UI components of your application until you’ve
    identified your mediators, the reusable components, and the means of communication
    between them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定您的中介、可重用组件以及它们之间的通信方式之前，不要开始实现您应用的UI组件。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now you know that a parent component can pass data to other components without
    knowing either their content or existence. But what if a parent component knows
    that it has a child that implements a certain API; can the parent invoke this
    API on the child directly?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道父组件可以在不知道其内容或存在的情况下将数据传递给其他组件。但如果父组件知道它有一个实现了特定API的子组件；父组件能否直接在子组件上调用此API？
- en: 8.4\. Exposing a child component’s API
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 暴露子组件的API
- en: You’ve learned how a parent component can pass data to its child using bindings
    to input properties. But there are other cases when the parent just needs to use
    the API exposed by the child. We’ll show you an example that illustrates how a
    parent component can invoke the child’s API from both the template and the TypeScript
    code of the parent.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了父组件如何通过绑定到输入属性来将其数据传递给子组件。但还有其他情况，当父组件只需要使用子组件公开的API时。我们将向您展示一个示例，说明父组件如何从模板和父组件的TypeScript代码中调用子组件的API。
- en: 'Let’s create a simple application in which a child component has a `greet()`
    method that will be invoked by the parent. In particular, the parent component
    includes the following lines in its template:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用，其中子组件有一个 `greet()` 方法，该方法将由父组件调用。特别是，父组件在其模板中包含以下行：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Local template variables are meant to be used within the template. In the preceding
    code, the parent’s template invokes the `greet()` method on the child component,
    `#child1`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本地模板变量旨在在模板中使用。在上面的代码中，父组件的模板在子组件 `#child1` 上调用 `greet()` 方法。
- en: 'You can also invoke the child’s API from TypeScript. Let’s create two instances
    of the same child component to illustrate how to do this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从TypeScript中调用子组件的API。让我们创建两个相同的子组件实例来演示如何做到这一点：
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The DOM references to these instances will be stored in template variables `#child1`
    and `#child2`, respectively. Now you can declare a property in your TypeScript
    class, decorated with `@ViewChild()` so you can use these objects from your TypeScript
    code. The `@ViewChild()` decorator is handy when you need a reference to a child
    component.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实例的DOM引用将分别存储在模板变量 `#child1` 和 `#child2` 中。现在您可以在TypeScript类中声明一个属性，并用 `@ViewChild()`
    装饰它，这样您就可以从TypeScript代码中使用这些对象。当您需要子组件的引用时，`@ViewChild()` 装饰器非常有用。
- en: 'Here’s how you can pass a reference to the child component from the template
    variable `#child1` to the TypeScript variable `firstChild`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样从模板变量 `#child1` 将子组件的引用传递到 TypeScript 变量 `firstChild`：
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `@ViewChildren()` decorator would give you references to several children
    of the same type. Let’s write a small app that will illustrate the use of these
    decorators. The code of the child component is located in the childapi/child.component.ts
    file and is shown in the following listing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChildren()` 装饰器将为你提供相同类型的多个子组件的引用。让我们编写一个小应用程序来展示这些装饰器的使用。子组件的代码位于 `childapi/child.component.ts`
    文件中，如下所示。'
- en: Listing 8.15\. child.component.ts
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. child.component.ts
- en: '[PRE25]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The parent will include two instances of the child and will use both `@ViewChild()`
    and `@ViewChildren()` decorators. The full code of the parent component that uses
    both decorators is shown in the following listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件将包含两个子组件实例，并使用 `@ViewChild()` 和 `@ViewChildren()` 装饰器。使用这两个装饰器的父组件的完整代码如下所示。
- en: Listing 8.16\. app.component.ts
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. app.component.ts
- en: '[PRE26]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Obtains the reference to the first child instance**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取第一个子组件实例的引用**'
- en: '***2* Obtains the references to both children (returns a list of children)**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取两个子组件的引用（返回子组件列表）**'
- en: '***3* Uses the lifecycle hook ngAfterViewInit()**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用生命周期钩子 ngAfterViewInit()**'
- en: '***4* Invokes the greet() method on the first child**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在第一个子组件上调用 greet() 方法**'
- en: '***5* Invokes the greet() method on both children**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在两个子组件上调用 greet() 方法**'
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this class, you use the component lifecycle hook `ngAfterViewInit()` to ensure
    that you use the child’s API after the child is rendered. See [section 9.2](kindle_split_018.xhtml#ch09lev1sec2)
    in [chapter 9](kindle_split_018.xhtml#ch09) for more details.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，你使用组件生命周期钩子 `ngAfterViewInit()` 来确保在子组件渲染后使用子组件的 API。有关更多详细信息，请参阅 [第 9
    章第 9.2 节](kindle_split_018.xhtml#ch09lev1sec2)。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you run this app, the browser renders the window shown in [figure 8.11](#ch08fig11).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此应用程序，浏览器将渲染 [图 8.11](#ch08fig11) 中所示的窗口。
- en: Figure 8.11\. Accessing the children API
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.11\. 访问子组件 API
- en: '![](Images/08fig11.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig11.jpg)'
- en: 'You’ll also see following line on the browser console:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将在浏览器控制台中看到以下行：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On app startup, John is greeted, but to be fair, both children should be greeted.
    Clicking the button will use the reference to the entire list of children and
    produce the following output:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动时，John 被问候，但为了公平起见，两个子组件都应该被问候。点击按钮将使用整个子组件列表的引用并产生以下输出：
- en: '[PRE28]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To see this app in action, run the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行效果，请运行以下命令：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You used different techniques for component communications to send data or invoke
    the API, but can you send an HTML fragment from one component to be used in another?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用了不同的技术进行组件通信来发送数据或调用 API，但你能否从一个组件发送一个 HTML 片段到另一个组件中使用？
- en: 8.5\. Projecting templates at runtime with ngContent
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 使用 ngContent 在运行时投影模板
- en: 'In some cases, a parent component needs to render arbitrary markup within a
    child at runtime, and you can do that in Angular using *projection*. You can project
    a fragment of the parent component’s template onto its child’s template by using
    the `ngContent` directive. This is a two-step process:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，父组件需要在运行时在子组件中渲染任意标记，你可以在 Angular 中使用 *投影* 来实现这一点。你可以通过使用 `ngContent`
    指令将父组件模板的一部分投影到其子组件模板上。这是一个两步的过程：
- en: '**1**.  In the child component’s template, include the tags `<ng-content></ng-content>`
    (the *insertion point*).'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 在子组件的模板中，包含 `<ng-content></ng-content>` 标签（*插入点*）。'
- en: '**2**.  In the parent component, include the HTML fragment that you want to
    project into the child’s insertion point between tags representing the child component
    (for example, `<my-child>`):'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在父组件中，包含你想要投影到子组件插入点之间的 HTML 片段，这些标签代表子组件（例如，`<my-child>`）：'
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '``template: ` ... <my-child> <div>Passing this div to the child</div> </my-child>
    ...``'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '``template: ` ... <my-child> <div>将此 div 传递给子组件</div> </my-child> ...``'
- en: In this example, the parent component won’t render the content placed between
    `<my-child>` and `</my-child>`. [Listings 8.17](#ch08ex17) and [8.18](#ch08ex18)
    illustrate this technique. Notice that both components declare a CSS style selector
    with the same name, `.wrapper`, but each of them defines a different background
    color. This illustrates what Angular has to offer in terms of style encapsulation,
    described in the next section.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，父组件不会渲染放置在 `<my-child>` 和 `</my-child>` 之间的内容。[列表 8.17](#ch08ex17) 和 [8.18](#ch08ex18)
    展示了这种技术。请注意，这两个组件都声明了一个具有相同名称的 CSS 样式选择器 `.wrapper`，但每个都定义了不同的背景颜色。这展示了 Angular
    在样式封装方面能提供什么，下一节将进行描述。
- en: Consider an example with two components—parent and child. The parent component
    will pass an HTML fragment to the child for rendering. The code of the child component
    is shown in the following listing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个有两个组件的例子——父组件和子组件。父组件将传递一个 HTML 片段给子组件进行渲染。子组件的代码如下所示。
- en: Listing 8.17\. child.component.ts
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17\. child.component.ts
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* The class selector to render the UI on the light green background**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于在浅绿色背景上渲染 UI 的类选择器**'
- en: '***2* The content that comes from the parent is displayed here.**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 来自父组件的内容在这里显示。**'
- en: '***3* For styles, use the ViewEncapsulation.Native mode (we explain view encapsulation
    modes in the next section).**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对于样式，使用 ViewEncapsulation.Native 模式（我们将在下一节中解释视图封装模式）。**'
- en: The parent component is shown in the next listing.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件的代码如下所示。
- en: Listing 8.18\. app.component.ts
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. app.component.ts
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* The class selector to render the UI on the light green background**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于在浅绿色背景上渲染 UI 的类选择器**'
- en: '***2* The content will be projected onto the child’s template.**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 内容将被投影到子组件的模板上。**'
- en: 'Run this app with the following command in the Chrome browser:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 浏览器中使用以下命令运行此应用：
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The Chrome browser will render the UI shown in [figure 8.12](#ch08fig12).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 浏览器将渲染 [图 8.12](#ch08fig12) 中所示的 UI。
- en: Figure 8.12\. Running the projection1 app with `ViewEncapsulation.Native`
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.12\. 使用 `ViewEncapsulation.Native` 运行 projection1 应用
- en: '![](Images/08fig12.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig12.jpg)'
- en: 'The text “Child got this line from parent” was projected from the `AppComponent`
    onto the `Child-Component`. You may ask why you would want to run this app in
    the Chrome browser: because you specified `ViewEncapsulation.Native`, assuming
    that the browser supports Shadow DOM, and Chrome supports this feature. The next
    section provides more details.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 文本“子组件从父组件获取了这一行”是从 `AppComponent` 投影到 `Child-Component` 的。你可能想知道为什么你想在 Chrome
    浏览器中运行这个应用：因为你指定了 `ViewEncapsulation.Native`，假设浏览器支持 Shadow DOM，而 Chrome 支持这项功能。下一节将提供更多细节。
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`ViewEncapsulation` modes aren’t related to projection and can be used in any
    component, but we wanted to use the app that has a differently styled parent and
    child components to introduce this feature.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewEncapsulation` 模式与投影无关，可以在任何组件中使用，但我们想使用具有不同样式的父组件和子组件的应用来介绍这个功能。'
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.5.1\. View encapsulation modes
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1\. 视图封装模式
- en: JavaScript modules allow you to introduce scope to your scripts so they don’t
    pollute the global space in the browser or any other execution environment. What
    about CSS? Imagine a parent and child components that coincidentally declare a
    style with the same CSS class selector name, but define different background colors.
    Will the browser render components using different backgrounds or will both of
    them have the same background?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块允许你在脚本中引入范围，这样它们就不会污染浏览器或任何其他执行环境中的全局空间。那么 CSS 呢？想象一下，父组件和子组件意外地声明了具有相同
    CSS 类选择器名称的样式，但定义了不同的背景颜色。浏览器会使用不同的背景渲染组件，还是两个组件都会有相同的背景？
- en: 'In short, Shadow DOM introduces scopes for CSS styles and encapsulation of
    DOM nodes in the browser. Shadow DOM allows you to hide the internals of a selected
    component from the global DOM tree. Shadow DOM is well explained in the article
    “Shadow DOM v1: Self-Contained Web Components” by Eric Bidelman, available at
    [http://mng.bz/6VV6](http://mng.bz/6VV6).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '简而言之，Shadow DOM 在浏览器中引入了 CSS 样式的范围和 DOM 节点的封装。Shadow DOM 允许你隐藏所选组件的内部结构，使其不显示在全局
    DOM 树中。Shadow DOM 在 Eric Bidelman 的文章“Shadow DOM v1: Self-Contained Web Components”中有很好的解释，该文章可在
    [http://mng.bz/6VV6](http://mng.bz/6VV6) 找到。'
- en: 'We’ll use the app from the previous section to illustrate how Shadow DOM and
    Angular’s `ViewEncapsulation` mode works. The `encapsulation` property of the
    `@Component()` decorator can have one of three values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一节中的应用来展示 Shadow DOM 和 Angular 的 `ViewEncapsulation` 模式是如何工作的。`@Component()`
    装饰器的 `encapsulation` 属性可以有三个值之一：
- en: '**`ViewEncapsulation.Native`—** This can be used with browsers that support
    Shadow DOM.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ViewEncapsulation.Native`—** 这可以与支持Shadow DOM的浏览器一起使用。'
- en: '**`ViewEncapsulation.Emulated`—** By default, Angular emulates Shadow DOM support.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ViewEncapsulation.Emulated`—** 默认情况下，Angular模拟Shadow DOM支持。'
- en: '**`ViewEncapsulation.None`—** If the styles have the same selectors, the last
    one wins.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ViewEncapsulation.None`—** 如果样式有相同的选择器，最后一个获胜。'
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Read about CSS specificity at [https://css-tricks.com/specifics-on-css-specificity](https://css-tricks.com/specifics-on-css-specificity).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有关CSS特异性的更多信息，请参阅[https://css-tricks.com/specifics-on-css-specificity](https://css-tricks.com/specifics-on-css-specificity)。
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As mentioned earlier, both parent and child components use the `.wrapper` style.
    In a regular HTML page, this would mean that the CSS rules of the child’s `.wrapper`
    would override the parent’s. Let’s see if you can encapsulate styles in child
    components so they don’t clash with parent styles, even if their names are the
    same.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，父组件和子组件都使用 `.wrapper` 样式。在一个普通的HTML页面中，这意味着子组件的 `.wrapper` 的CSS规则将覆盖父组件的。让我们看看你是否能封装子组件中的样式，这样它们就不会与父组件的样式冲突，即使它们的名称相同。
- en: '[Figure 8.13](#ch08fig13) shows the running application in `ViewEncapsulation.Native`
    mode with the Developer Tools panel open. The browser creates `#shadow-root` nodes
    for parent and child (see the two `#shadow-root` nodes on the right). If you’re
    reading this book in color (the e-book), you’ll see that the `.wrapper` style
    paints the background of the `<app-root>` a deep pink color. The fact that the
    child also has the `.wrapper` style that uses a light green color doesn’t affect
    the parent. Styles are encapsulated. The child’s `#shadow-root` acts like a wall
    preventing the child’s styles from overriding the parent’s styles. You can use
    `ViewEncapsulation.Native` only if you’re sure that the users of your app will
    use browsers that support Shadow DOM.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.13](#ch08fig13) 展示了在 `ViewEncapsulation.Native` 模式下打开开发者工具面板时运行的运行中的应用程序。浏览器为父元素和子元素创建了
    `#shadow-root` 节点（见右侧的两个 `#shadow-root` 节点）。如果你是在彩色版（电子书）中阅读这本书，你会看到 `.wrapper`
    样式将 `<app-root>` 的背景涂成深粉色。子组件也有使用浅绿色颜色的 `.wrapper` 样式，但这不会影响父组件。样式是封装的。子组件的 `#shadow-root`
    作用就像一堵墙，阻止子组件的样式覆盖父组件的样式。只有当你确信你的应用程序的用户将使用支持Shadow DOM的浏览器时，你才能使用 `ViewEncapsulation.Native`。'
- en: Figure 8.13\. Browser creating two `#shadow-root` nodes
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.13\. 浏览器创建两个 `#shadow-root` 节点
- en: '![](Images/08fig13_alt.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13的替代文本](Images/08fig13_alt.jpg)'
- en: '[Figure 8.13](#ch08fig13) shows what happens after changing the value of the
    `encapsulation` property to `ViewEncapsulation.Emulated`. Angular uses this mode
    by default, so the effect is the same as if you didn’t add the `encapsulation`
    property to the `@Component()` decorator. The DOM doesn’t have any `#shadow-root`
    nodes inside the `<app-root>` element, but Angular generates additional attributes
    for the parent and child elements to differentiate styles in parent and child.
    Angular modifies all CSS selectors in component styles to incorporate generated
    attributes:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.13](#ch08fig13) 展示了将 `encapsulation` 属性的值更改为 `ViewEncapsulation.Emulated`
    后发生的情况。Angular默认使用此模式，因此效果与未向 `@Component()` 装饰器添加 `encapsulation` 属性相同。DOM在 `<app-root>`
    元素内部没有任何 `#shadow-root` 节点，但Angular为父元素和子元素生成额外的属性以区分父元素和子元素的样式。Angular修改组件样式中的所有CSS选择器，以包含生成的属性：'
- en: '[PRE33]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* The styles in the <app-root> component**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `<app-root>` 组件中的样式**'
- en: '***2* The styles in the <child> component**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `<child>` 组件中的样式**'
- en: The UI is rendered the same way, using different background colors for these
    components as in [figure 8.14](#ch08fig14), but the underlying code is not the
    same compared to [figure 8.13](#ch08fig13).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: UI以相同的方式渲染，使用不同的背景颜色渲染这些组件，如[图8.14](#ch08fig14)所示，但与[图8.13](#ch08fig13)相比，底层代码并不相同。
- en: Figure 8.14\. Running the projection1 app with `ViewEncapsulation.Emulated`
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.14\. 使用 `ViewEncapsulation.Emulated` 运行projection1应用程序
- en: '![](Images/08fig14_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14的替代文本](Images/08fig14_alt.jpg)'
- en: '[Figure 8.15](#ch08fig15) shows the same example running with encapsulation
    set to `ViewEncapsulation.None`. In this case, the child’s `wrapper` wins, and
    the entire window is shown with the child’s light green background.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.15](#ch08fig15) 展示了将封装设置为 `ViewEncapsulation.None` 时运行的相同示例。在这种情况下，子组件的
    `wrapper` 获胜，整个窗口都显示为子组件的浅绿色背景。'
- en: Figure 8.15\. Running the projection1 app with `ViewEncapsulation.None`
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.15\. 使用 `ViewEncapsulation.None` 运行projection1应用程序
- en: '![](Images/08fig15_alt.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15的替代文本](Images/08fig15_alt.jpg)'
- en: Now that you understand encapsulation modes and basic projection, you may be
    wondering whether it’s possible to project content into multiple areas of the
    component template.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了封装模式和基本投影，你可能想知道是否可以将内容投影到组件模板的多个区域。
- en: 8.5.2\. Projecting onto multiple areas
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2\. 投影到多个区域
- en: 'A component can have more than one `<ng-content>` tag in its template. Let’s
    consider an example where a child component’s template is split into three areas:
    header, content, and footer, as in [figure 8.16](#ch08fig16). The HTML markup
    for the header and footer could be projected by the parent component, and the
    content area could be defined in the child component. To implement this, the child
    component needs to include two separate pairs of `<ng-content></ng-content>`s
    populated by the parent (header and footer).'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件的模板中可以包含多个 `<ng-content>` 标签。让我们考虑一个例子，其中子组件的模板被分为三个区域：标题、内容和页脚，如[图8.16](#ch08fig16)所示。标题和页脚的HTML标记可以由父组件投影，而内容区域可以在子组件中定义。为了实现这一点，子组件需要包含两个由父组件填充的单独的
    `<ng-content></ng-content>` 对，分别是标题和页脚。
- en: Figure 8.16\. Running the projection2 app
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.16\. 运行projection2应用
- en: '![](Images/08fig16.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig16.jpg)'
- en: 'To ensure that the header and footer content will be rendered in the proper
    `<ng-content>` areas, you’ll use the `select` attribute, which can be any valid
    CSS selector (a CSS class, tag name, and so on). The child’s template could look
    like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保页眉和页脚内容将在正确的 `<ng-content>` 区域中渲染，你将使用 `select` 属性，它可以是一个有效的CSS选择器（CSS类、标签名等）。子组件的模板可能看起来像这样：
- en: '[PRE34]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The content that arrives from the parent will be matched by the selector and
    rendered in the corresponding area. We created a separate app in the folder projection2
    to illustrate projection onto multiple areas. The following listing shows the
    child component.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从父组件到达的内容将通过选择器进行匹配，并在相应的区域中渲染。我们创建了一个单独的应用程序在文件夹projection2中，以说明投影到多个区域。以下列表显示了子组件。
- en: Listing 8.19\. child.component.ts
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.19\. child.component.ts
- en: '[PRE35]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that you have two `<ng-content>` slots now—one with the selector `.header`
    and another with `.footer`. The parent component will project different content
    into each slot. To make this example more dynamic, you use binding to display
    today’s date in the header, as shown in the following listing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你现在有两个 `<ng-content>` 插槽——一个带有选择器 `.header`，另一个带有 `.footer`。父组件将不同内容投影到每个插槽。为了使这个例子更具动态性，你使用绑定在标题中显示今天的日期，如下面的列表所示。
- en: Listing 8.20\. app.component.ts
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.20\. app.component.ts
- en: '[PRE36]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Projects this div onto the child’s element with the header selector**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将此div投影到具有标题选择器的子元素上**'
- en: '***2* Binds the current date to the projected content**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将当前日期绑定到投影的内容**'
- en: '***3* Projects this div onto the child’s element with the footer selector**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将此div投影到具有页脚选择器的子元素上**'
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The projected HTML can only bind the properties visible in the parent’s scope,
    so you can’t use the child’s properties in the parent’s binding expression.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 投影的HTML只能绑定在父作用域中可见的属性，因此你无法在父组件的绑定表达式中使用子组件的属性。
- en: '|  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To see this example in action, run the following command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此示例的实际效果，请运行以下命令：
- en: '[PRE37]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Running this app will render the page shown earlier in [figure 8.16](#ch08fig16).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用将渲染[图8.16](#ch08fig16)中显示的页面。
- en: Using `<ng-content>` with the `select` attribute allows you to create a universal
    component with a view divided into several areas that get their markup from the
    parent.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<ng-content>` 和 `select` 属性可以创建一个具有多个区域视图的通用组件，这些区域从父组件获取其标记。
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Projection vs. direct binding to innerHTML**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**投影与直接绑定到innerHTML的比较**'
- en: 'Alternatively, you can programmatically change the HTML content of a component
    by binding a component to `innerHTML`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过将组件绑定到 `innerHTML` 来编程更改组件的HTML内容：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But using `<ng-content>` is preferable to binding to `innerHTML` for these
    reasons:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，出于以下原因，使用 `<ng-content>` 而不是绑定到 `innerHTML` 更可取：
- en: '`innerHTML` is a browser-specific API, whereas `<ng-content>` is platform independent.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerHTML` 是一个浏览器特定的API，而 `<ng-content>` 是平台无关的。'
- en: With `<ng-content>`, you can define multiple slots where the HTML fragments
    will be inserted.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `<ng-content>`，你可以定义多个插槽，其中HTML片段将被插入。
- en: '`<ng-content>` allows you to bind the parent component’s properties into projected
    HTML.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ng-content>` 允许你将父组件的属性绑定到投影的HTML中。'
- en: '|  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Parent and child components should avoid direct access to each other’s internals
    but should communicate via input and output properties.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父组件和子组件应避免直接访问彼此的内部结构，而应通过输入和输出属性进行通信。
- en: A component can emit custom events via its output properties, and these events
    can carry an application-specific payload.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件可以通过其输出属性发出自定义事件，并且这些事件可以携带特定于应用程序的有效负载。
- en: Communications between unrelated components should be arranged using the Mediator
    design pattern. Either a common parent component or an injectable service can
    serve as a mediator.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信无关组件之间应使用中介者设计模式进行安排。一个公共父组件或可注入的服务可以作为中介。
