- en: 13 Dockerizing microservice APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 Docker 化微服务 API
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: How to Dockerize an application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何 Docker 化一个应用程序
- en: How to run Docker containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行 Docker 容器
- en: How to run an application with Docker Compose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Docker Compose 运行应用程序
- en: Publishing a Docker image to AWS Elastic Container Registry
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Docker 镜像发布到 AWS 弹性容器注册库
- en: Docker is a virtualization technology that allows us to run our applications
    anywhere by simply having a Docker execution runtime. Docker takes away the pain
    and effort required to tune and configure an environment to run code. It also
    makes deployments more predictable since it produces replicable artifacts (container
    images) that we can run locally as well as in the cloud.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一种虚拟化技术，它允许我们通过简单地拥有 Docker 执行运行时在任何地方运行我们的应用程序。Docker 去除了调整和配置环境以运行代码所需的所有痛苦和努力。它还使部署更加可预测，因为它产生可复制的工件（容器镜像），我们可以在本地以及云中运行。
- en: In this chapter, you’ll learn to Dockerize a Python application. Dockerizing
    is the process of packaging an application as a Docker image. You can think of
    a Docker image as a build or artifact that is ready to be deployed and executed.
    To execute an image, Docker creates running instances of the image, known as *containers*.
    To deploy Docker images, we typically use a container orchestrator, such as Kubernetes,
    which takes care of managing the life cycle of a container. In the next chapter,
    you’ll learn to deploy Docker builds with Kubernetes. We’ll illustrate how to
    Dockerize an application using the orders service of the CoffeeMesh platform.
    You’ll also learn to publish your Docker builds to a container registry by uploading
    images to AWS’s Elastic Container Registry (ECR).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将 Python 应用程序 Docker 化。Docker 化是将应用程序打包成 Docker 镜像的过程。你可以将 Docker
    镜像视为一个构建或工件，它已准备好部署和执行。要执行镜像，Docker 会创建镜像的运行实例，称为 *容器*。为了部署 Docker 镜像，我们通常使用容器编排器，如
    Kubernetes，它负责管理容器的生命周期。在下一章中，你将学习如何使用 Kubernetes 部署 Docker 构建。我们将演示如何使用 CoffeeMesh
    平台的订单服务来 Docker 化应用程序。你还将学习如何通过将镜像上传到 AWS 的弹性容器注册库（ECR）来发布你的 Docker 构建。
- en: All the code examples are available under folder ch13 in the GitHub repository
    for this book. We’ll begin by setting up the environment to work on this chapter
    in section 13.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例都可在本书 GitHub 仓库的 ch13 文件夹中找到。我们将从设置环境开始，以便在 13.1 节中处理本章内容。
- en: 13.1 Setting up the environment for this chapter
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 设置本章环境
- en: 'In this section, we set up the environment so that you can follow along with
    the examples in the rest of the chapter. We continue the implementation of the
    orders service where we left it in chapter 11, where we added the authentication
    and authorization layers. First, copy over the code from chapter 11 into a new
    folder called ch13:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们设置环境，以便你可以跟随本章其余部分的示例。我们继续实现订单服务，其中我们在第 11 章中停止，那时我们添加了身份验证和授权层。首先，将第
    11 章的代码复制到一个名为 ch13 的新文件夹中：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`cd` into ch13, and install the dependencies and activate the virtual environment
    by running the following commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ch13 中 `cd`，并运行以下命令安装依赖项并激活虚拟环境：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we deploy the application, we use a PostgreSQL engine, which is one of
    the most popular SQL engines for running applications in production. To communicate
    with the database, we use `psycopg2`, which is one of Python’s most popular PostgreSQL
    drivers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们部署应用程序时，我们使用 PostgreSQL 引擎，这是在生产环境中运行应用程序最受欢迎的 SQL 引擎之一。为了与数据库通信，我们使用 `psycopg2`，这是
    Python 最受欢迎的 PostgreSQL 驱动之一：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing PSYCOPG2 If you run into issues installing and compiling `psycopg2`,
    try installing the compiled package by running `pipenv` `install` `psycopg2-binary`,
    or pull ch13/Pipfile and ch13/Pipfile.lock from this book’s GitHub repository
    and run `pipenv` `install` `--dev`. Two other powerful PostgreSQL drivers are
    `asyncpg` ([https://github.com/MagicStack/asyncpg](https://github.com/MagicStack/asyncpg))
    and `pscycopg3` ([https://github.com/psycopg/psycopg](https://github.com/psycopg/psycopg)),
    both of which support asynchronous operations. I encourage you to check them out!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 PSYCOPG2 如果你在安装和编译 `psycopg2` 时遇到问题，尝试通过运行 `pipenv install psycopg2-binary`
    安装编译好的包，或者从本书的 GitHub 仓库中拉取 ch13/Pipfile 和 ch13/Pipfile.lock，然后运行 `pipenv install
    --dev`。还有两个强大的 PostgreSQL 驱动程序是 `asyncpg` ([https://github.com/MagicStack/asyncpg](https://github.com/MagicStack/asyncpg))
    和 `pscycopg3` ([https://github.com/psycopg/psycopg](https://github.com/psycopg/psycopg))，它们都支持异步操作。我鼓励你检查它们！
- en: To build and run Docker containers, you’ll need a Docker runtime on your machine.
    Installation instructions are platform specific, so please see the official documentation
    to learn how to install Docker on your system ([https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行 Docker 容器，您需要在您的机器上安装 Docker 运行时。安装说明因平台而异，请参阅官方文档了解如何在您的系统上安装 Docker
    ([https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/))。
- en: 'Since we’re going to publish our Docker images to AWS’s ECR, we need to install
    the AWS CLI:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算将 Docker 镜像发布到 AWS 的 ECR，我们需要安装 AWS CLI：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, go to [https://aws.amazon.com/](https://aws.amazon.com/). Create an AWS
    account and obtain an access key to be able to access AWS services programmatically.
    The user profile you use to create the AWS account is the account’s root user.
    For security, it is recommended that you don’t use the root user to generate your
    access key. Instead, create an IAM user and generate an access key for that user.
    IAM is AWS’s Identity Access Management service, which allows you to create users,
    roles, and granular policies for granting access to other services in your account.
    Follow the AWS documentation to learn how to create an IAM user ([http://mng.bz/neP8](http://mng.bz/neP8))
    and to learn how to generate your access keys and configure the AWS CLI ([http://mng.bz/vXxq](http://mng.bz/vXxq)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，访问 [https://aws.amazon.com/](https://aws.amazon.com/)。创建一个 AWS 账户并获取一个访问密钥，以便能够以编程方式访问
    AWS 服务。您用于创建 AWS 账户的用户配置文件是账户的根用户。出于安全考虑，建议您不要使用根用户生成您的访问密钥。相反，创建一个 IAM 用户并为该用户生成一个访问密钥。IAM
    是 AWS 的身份访问管理服务，它允许您创建用户、角色和细粒度的策略，以授予对您账户中其他服务的访问权限。按照 AWS 文档了解如何创建 IAM 用户 ([http://mng.bz/neP8](http://mng.bz/neP8))
    以及如何生成您的访问密钥和配置 AWS CLI ([http://mng.bz/vXxq](http://mng.bz/vXxq))。
- en: Now that our environment is ready, it’s time to Dockerize our applications!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了环境，是时候将我们的应用程序 Docker 化了！
- en: 13.2 Dockerizing a microservice
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 Docker 化微服务
- en: What does Dockerizing an application mean? *Dockerizing* is the process of packaging
    an application as a Docker image. You can think of a Docker image as a build or
    artifact that can be deployed and executed in a Docker runtime. All the system
    dependencies are already installed in the Docker image, and to run the image,
    we only need a Docker runtime. To execute the image, the Docker runtime creates
    a container, which is a running instance of the image. As you can see in figure
    13.1, working with Docker is very convenient since it allows us to run our applications
    in isolated processes. There are different options for installing a Docker runtime
    depending on your platform, so please see the official documentation to determine
    which option works best for you ([https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序 Docker 化意味着什么？*Docker 化*是将应用程序打包成 Docker 镜像的过程。您可以将 Docker 镜像想象为一个可以在
    Docker 运行时部署和执行的构建或工件。所有系统依赖项都已安装在 Docker 镜像中，要运行镜像，我们只需要一个 Docker 运行时。要执行镜像，Docker
    运行时会创建一个容器，这是镜像的运行实例。如图 13.1 所示，使用 Docker 非常方便，因为它允许我们在隔离进程中运行我们的应用程序。根据您的平台，安装
    Docker 运行时有不同的选项，请参阅官方文档以确定哪个选项最适合您 ([https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/))。
- en: '![](../Images/13-01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13-01.png)'
- en: Figure 13.1 Docker containers run in isolated processes on top of the host operating
    system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 Docker 容器在主机操作系统之上运行在隔离进程中。
- en: In this section, we create an optimized Docker image of the orders service.
    Along the way, you’ll learn how to write a Dockerfile, which is a document that
    contains all the instructions required to build a Docker image. You’ll also learn
    how to run Docker containers and to map ports from the container to the host operating
    system so that you can interact with the application running inside the container.
    Finally, you’ll also learn how to manage containers with the Docker CLI.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个优化后的订单服务的 Docker 镜像。在这个过程中，您将学习如何编写 Dockerfile，这是一个包含构建 Docker 镜像所需所有指令的文档。您还将学习如何运行
    Docker 容器，以及如何将容器端口映射到主机操作系统，以便您能够与容器内运行的应用程序交互。最后，您还将学习如何使用 Docker CLI 管理容器。
- en: Docker Fundamentals If you want to know more about how Docker works and how
    it interacts with the host operating system, check out Prabath Siriwardena and
    Nuwan Dias’s excellent “Docker Fundamentals” from their book *Microservices Security
    in Action* (Manning, 2020, [http://mng.bz/49Ag](http://mng.bz/49Ag)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker基础知识 如果你想了解更多关于Docker如何工作以及它与宿主操作系统的交互方式，请查看Prabath Siriwardena和Nuwan
    Dias在他们所著的《Microservices Security in Action》（Manning，2020）一书中优秀的“Docker基础知识”部分。[http://mng.bz/49Ag](http://mng.bz/49Ag)。
- en: Before we build the image, we need to make two small changes to our application
    code to get it ready for deployment. So far, the orders service has been using
    a hardcoded database URL, but to operate the service in different environments,
    we need to make this setting configurable. The following code shows the changes
    needed to the orders/repository/unit_of_work.py file to pull the database URL
    from the environment, with the newly added code in bold characters. We use an
    assert statement to exit the application immediately if no database URL is provided.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像之前，我们需要对我们的应用程序代码进行两项小的修改，以便为部署做好准备。到目前为止，订单服务一直在使用硬编码的数据库URL，但为了在不同的环境中运行服务，我们需要使这个设置可配置。以下代码展示了需要修改`orders/repository/unit_of_work.py`文件以从环境中获取数据库URL的更改，其中新添加的代码以粗体字符显示。我们使用断言语句，如果未提供数据库URL，则立即退出应用程序。
- en: Listing 13.1 Pulling the database URL from the environment
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.1 从环境中获取数据库URL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① We pull the database URL from the DB_URL environment variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从DB_URL环境变量中获取数据库URL。
- en: ② We exit the application if DB_URL isn’t set.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果未设置DB_URL，则退出应用程序。
- en: ③ We use the value from DB_URL to connect to the database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用DB_URL的值连接到数据库。
- en: We also need to update our Alembic files to pull the database URL from the environment.
    The following code shows the changes required to migrations/env.py to accomplish
    that, with the newly added code in bold. We omitted nonrelevant parts of the code
    with ellipses to make it easier to observe the changes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的Alembic文件，以便从环境中获取数据库URL。以下代码展示了需要修改`migrations/env.py`以实现此目的的更改，其中新添加的代码以粗体显示。我们使用省略号省略了代码的非相关部分，以便更容易观察更改。
- en: Listing 13.2 Pulling the database URL from the environment for `alembic`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.2 从环境中获取`alembic`的数据库URL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① We pull the database URL from the DB_URL environment variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从DB_URL环境变量中获取数据库URL。
- en: ② We exit the application if DB_URL isn’t set.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果未设置DB_URL，则退出应用程序。
- en: Now that our code is ready, it’s time to Dockerize it! To build a Docker image,
    we need to write a Dockerfile. Create a file named Dockerfile. Listing 13.3 shows
    this file’s contents. We use the slim version of the official Python 3.9 Docker
    image as our base image. Slim images contain just the dependencies that we need
    to run our applications, which results in lighter images. To use a base image,
    we use Docker’s `FROM` directive. Then we create the folder for the application
    code called /orders/orders. To run bash commands, such as `mkdir` in this case,
    we use Docker’s `RUN` directive. We also set /orders/orders as the working directory
    using Docker’s `WORKDIR` directive. The working directory is the directory from
    which the application runs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经准备好了，是时候将其Docker化了！要构建一个Docker镜像，我们需要编写一个Dockerfile。创建一个名为Dockerfile的文件。表13.3显示了该文件的包含内容。我们使用官方Python
    3.9 Docker镜像的精简版作为我们的基础镜像。精简镜像只包含运行我们的应用程序所需的依赖项，这导致了更轻的镜像。要使用基础镜像，我们使用Docker的`FROM`指令。然后我们创建一个名为/orders/orders的应用程序代码文件夹。要运行bash命令，例如本例中的`mkdir`，我们使用Docker的`RUN`指令。我们还使用Docker的`WORKDIR`指令将/orders/orders设置为工作目录。工作目录是应用程序运行时的目录。
- en: Next, we install `pipenv`, copy our Pipenv files, and install the dependencies.
    We use Docker’s `COPY` directive to copy files from our filesystem into the Docker
    image. Since we’re running in Docker, we don’t need a virtual environment, so
    we install the dependencies using `pipenv`’s `--system` flag. We also use `pipenv`’s
    `--deploy` flag, which checks that our Pipenv files are up to date. Finally, we
    copy over our source code and specify the command that needs to be executed to
    get the orders service up and running. The command that Docker must use to execute
    our application is specified using Docker’s `CMD` directive. We also use Docker’s
    `EXPOSE` directive to make sure the running container listens on port 8000, the
    port on which our API runs. If we don’t expose the port, we can’t interact with
    the API.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装 `pipenv`，复制我们的Pipenv文件，并安装依赖项。我们使用Docker的 `COPY` 指令将文件从我们的文件系统复制到Docker镜像中。由于我们在Docker中运行，我们不需要虚拟环境，所以我们使用
    `pipenv` 的 `--system` 标志来安装依赖项。我们还使用 `pipenv` 的 `--deploy` 标志来检查我们的Pipenv文件是否是最新的。最后，我们复制我们的源代码并指定需要执行的命令以启动订单服务。Docker必须使用Docker的
    `CMD` 指令来执行我们的应用程序。我们还使用Docker的 `EXPOSE` 指令确保正在运行的容器监听端口 8000，这是我们的API运行的端口。如果我们不暴露端口，我们就无法与API交互。
- en: The order of our statements in the Dockerfile matters because Docker caches
    each step of the build. Docker will only execute a step again if the previous
    step changed, for example, if we installed a new dependency, or if one of our
    files changed. Since our application code is likely to change more often than
    our dependencies, we copy the code at the end of the build. That way, Docker will
    only install the dependencies once and cache the step until they change.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Dockerfile中的语句顺序很重要，因为Docker会缓存构建的每个步骤。如果上一个步骤发生了变化，例如，如果我们安装了新的依赖项，或者我们的某个文件发生了变化，Docker才会再次执行一个步骤。由于我们的应用程序代码可能比我们的依赖项变化更频繁，所以我们将在构建的最后复制代码。这样，Docker将只安装一次依赖项并缓存该步骤，直到它们发生变化。
- en: Listing 13.3 Dockerfile for the orders service
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.3 订单服务的Dockerfile
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① The base image
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ① 基础镜像
- en: ② Base folder structure for our application
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们应用程序的基本文件夹结构
- en: ③ Working directory from which we’ll run the code
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们将运行代码的工作目录
- en: ④ We copy our pipenv files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们复制我们的pipenv文件。
- en: ⑤ We install the dependencies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们安装依赖项。
- en: ⑥ We copy the rest of the application files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们复制应用程序的其他文件。
- en: ⑦ We expose the application’s port to the host machine.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们将应用程序的端口暴露给主机机器。
- en: ⑧ The API server’s startup command
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ API服务器的启动命令
- en: 'To build the Docker image from listing 13.3, you need to run the following
    command from the ch13 directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表 13.3 构建Docker镜像，你需要从 ch13 目录运行以下命令：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `-t` flag stands for *tag*. A Docker tag has two parts: the image name
    on the left of the colon and the tag name on the right of the colon. The tag name
    is typically the version of the build. In this case, we’re naming the image orders
    and tagging it with `1.0`. Make sure you don’t miss the period at the end of the
    build statement: it represents the path to the source code for the build (the
    *context* in Docker parlance). A period means the current directory.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 标志代表 *标签*。Docker标签有两个部分：冒号左侧的镜像名称和冒号右侧的标签名称。标签名称通常是构建的版本。在这种情况下，我们命名镜像为
    orders 并将其标记为 `1.0`。确保你不要漏掉构建语句末尾的点：它代表构建的源代码路径（在Docker术语中称为 *上下文*）。一个点表示当前目录。'
- en: 'Once the image has built, you can execute it with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，你可以使用以下命令来执行它：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in figure 13.2, the `--env` flag allows us to set environment
    variables in the container, and we use it to set the URL of the database. To make
    the application accessible to the host machine, we use the `-p` flag, which allows
    us to bind the port on which the application is running inside the container to
    a port in the host machine. We also use the `-v` flag to mount a volume on the
    SQLite database file. Docker volumes allow containers to access files from the
    host machine’s file system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在图 13.2 中所见，`--env` 标志允许我们在容器中设置环境变量，我们用它来设置数据库的URL。为了使应用程序对主机机器可访问，我们使用 `-p`
    标志，它允许我们将容器内应用程序运行的端口绑定到主机机器上的端口。我们还使用 `-v` 标志将卷挂载到SQLite数据库文件上。Docker卷允许容器从主机机器的文件系统中访问文件。
- en: '![](../Images/13-02.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13-02.png)'
- en: Figure 13.2 When we run a container, we can include various configurations to
    set environment variables within the container or to allow it to access files
    in the host operating system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 当我们运行容器时，我们可以包含各种配置来在容器内设置环境变量，或者允许它访问宿主操作系统的文件。
- en: 'You can now access the application on the following URL: http://127.0.0.1:8000/docs/orders.
    The previous command executes the container attached to your current terminal
    session, which allows you to see the logs unfold as you interact with the application.
    In this case, you can stop the container just like any other process by pressing
    the Ctrl-C key combination.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过以下 URL 访问应用程序：http://127.0.0.1:8000/docs/orders。之前的命令执行了连接到您当前终端会话的容器，这使得您可以在与应用程序交互时看到日志展开。在这种情况下，您可以通过按
    Ctrl-C 组合键来停止容器，就像停止任何其他进程一样。
- en: 'You can also run containers in detached mode, which means the process isn’t
    linked to your terminal session, so when you close your terminal, the process
    will continue running. This is convenient if you just want to run a container
    to interact with it, and you don’t need to watch the logs. We typically run containerized
    databases in detached mode. To run the container in detached mode, you use the
    `-d` flag:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以以分离模式运行容器，这意味着进程没有连接到您的终端会话，因此当您关闭终端时，进程将继续运行。如果您只想运行容器与之交互，而不需要查看日志，这很方便。我们通常以分离模式运行容器化的数据库。要分离模式运行容器，您使用
    `-d` 标志：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, you’ll need to stop the container with the `docker` `stop` command.
    First, you need to figure out the ID of the running container with the following
    command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您需要使用 `docker` 的 `stop` 命令停止容器。首先，您需要使用以下命令找出运行中容器的 ID：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command will list all currently running containers in your machine. The
    output looks like this (output truncated with ellipses):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将列出您机器上当前运行的所有容器。输出看起来像这样（输出已使用省略号截断）：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Pick up the container ID (in this case `83e6189a02ee`) and use it to stop the
    process with the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到容器 ID（在本例中为 `83e6189a02ee`），然后使用以下命令停止进程：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That’s all it takes to build and run Docker containers! There’s a lot more to
    Docker than we’ve seen in this section, and if you’re interested in learning more
    about this technology, I recommend you look at *Docker in Practice* by Ian Miell
    and Aidan Hobson Sayers (Manning, 2019) and *Docker in Action* by Jeff Nickoloff
    and Stephen Kuenzli (Manning, 2019).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行 Docker 容器只需这些步骤！Docker 的功能远不止我们在本节中看到的，如果您想了解更多关于这项技术的信息，我推荐您阅读 Ian Miell
    和 Aidan Hobson Sayers 所著的 *Docker in Practice*（Manning, 2019）以及 Jeff Nickoloff
    和 Stephen Kuenzli 所著的 *Docker in Action*（Manning, 2019）。
- en: 13.3 Running applications with Docker Compose
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 使用 Docker Compose 运行应用程序
- en: In the previous section, we ran the orders service’s container by mounting it
    on our local SQLite database. This is fine for a quick test, but it doesn’t really
    tell us whether our application will work as expected with a PostgreSQL database.
    A common strategy to connect our containerized applications to a database is using
    Docker Compose, which allows us to run multiple containers within a shared network,
    so they can talk to each other. In this section, you’ll learn how to run the orders
    service with a PostgreSQL database using `docker-compose`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们通过将其挂载到我们的本地 SQLite 数据库上来运行了订单服务的容器。这对于快速测试来说是可以的，但它并不能真正告诉我们我们的应用程序是否能够像预期的那样与
    PostgreSQL 数据库一起工作。将我们的容器化应用程序连接到数据库的常见策略是使用 Docker Compose，它允许我们在共享网络中运行多个容器，这样它们就可以相互通信。在本节中，您将学习如何使用
    `docker-compose` 运行带有 PostgreSQL 数据库的订单服务。
- en: 'To use Docker Compose, first we need to install it. It is a Python package,
    so we install it with `pip`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker Compose，首先我们需要安装它。它是一个 Python 包，所以我们使用 `pip` 来安装它：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let’s write our Docker Compose file—a declaration of the resources we
    need to run our application. Listing 13.4 shows the `docker-compose` file for
    the orders service. We use Docker Compose’s latest specification format, version
    3.9, and we declare two services: `database` and `api`. `database` runs PostgreSQL’s
    official Docker image, while `api` runs the orders service. We use the `build`
    keyword to point to the Docker build context, and we give it a period value (`.`).
    By using a period, we instruct Docker Compose to look for a Dockerfile and build
    the image relative to the current directory. Through the `environment` keyword,
    we configure the environment variables required to run our applications. We expose
    `database`’s 5432 port so that we can connect to the database from our host machine,
    as well as `api`’s 8000 port so that we can access the API. Finally, we use a
    volume called `database-data`, which `docker-compose` will use to persist our
    data. This means that if you restart `docker-compose`, you won’t lose your data.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写我们的 Docker Compose 文件——声明我们运行应用程序所需的资源。列表 13.4 显示了订单服务的 `docker-compose`
    文件。我们使用 Docker Compose 的最新规范格式，版本 3.9，并声明了两个服务：`database` 和 `api`。`database` 运行
    PostgreSQL 的官方 Docker 镜像，而 `api` 运行订单服务。我们使用 `build` 关键字指向 Docker 构建上下文，并给它一个点值（`.`）。通过使用点，我们指示
    Docker Compose 在当前目录中查找 Dockerfile 并构建镜像。通过 `environment` 关键字，我们配置运行我们的应用程序所需的环境变量。我们暴露
    `database` 的 5432 端口，以便我们可以从我们的主机机器连接到数据库，以及 `api` 的 8000 端口，以便我们可以访问 API。最后，我们使用一个名为
    `database-data` 的卷，`docker-compose` 将使用它来持久化我们的数据。这意味着如果你重启 `docker-compose`，你不会丢失你的数据。
- en: Listing 13.4 `docker-compose` file for the orders service
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.4 为订单服务的 `docker-compose` 文件
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① The version of docker-compose’s format for this file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此文件的 docker-compose 格式版本。
- en: ② We declare our services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们声明我们的服务。
- en: ③ The database service
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 数据库服务
- en: ④ The database service’s Docker image
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 数据库服务的 Docker 镜像
- en: ⑤ We expose the database ports to the host machine.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们将数据库端口暴露给主机机器。
- en: ⑥ Database environment configuration
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 数据库环境配置
- en: ⑦ We mount our database’s data folder on a local volume.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们将数据库的数据文件夹挂载到本地卷上。
- en: ⑧ The API service
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ API 服务
- en: ⑨ The API’s build context
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ API 的构建上下文
- en: ⑩ We expose the API’s port to the host machine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 我们将 API 的端口暴露给主机机器。
- en: ⑪ The API depends on the database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ API 依赖于数据库。
- en: ⑫ The API’s environment configuration
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ API 的环境配置
- en: ⑬ The database’s volume
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 数据库的卷
- en: 'Execute the following command to run our Docker Compose file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行我们的 Docker Compose 文件：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `--build` flag instructs Docker Compose to rebuild your images if your
    files changed. Once the web API is up and running, you can access it on http://localhost:
    8000/docs/orders. If you try any of the endpoints, your tables don’t exist. That’s
    because we haven’t run the migrations against our fresh PostgreSQL database! To
    run the migrations, open a new terminal window, `cd` into the ch13 folder, activate
    your `pipenv` environment, and run the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`--build` 标志指示 Docker Compose 在你的文件更改时重新构建你的镜像。一旦 Web API 启动并运行，你可以在 http://localhost:8000/docs/orders
    上访问它。如果你尝试任何端点，你的表不存在。那是因为我们没有在我们的新 PostgreSQL 数据库上运行迁移！要运行迁移，打开一个新的终端窗口，`cd`
    进入 ch13 文件夹，激活你的 `pipenv` 环境，并运行以下命令：'
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the migrations have been applied, you can hit the API endpoints again,
    and everything should work. To stop `docker-compose`, run the following command
    from another terminal window and inside the ch13 folder:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了迁移，你就可以再次点击 API 端点，一切应该都会正常工作。要停止 `docker-compose`，请在另一个终端窗口中，在 ch13 文件夹内运行以下命令：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is all it takes to run Docker Compose! You’ve just learned to use one of
    the most powerful automation tools. Docker Compose is often used to run integration
    tests and to have an easy way to run the backend for developers who work on client
    applications, such as SPAs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是运行 Docker Compose 所需的全部！你已经学会了使用最强大的自动化工具之一。Docker Compose 经常用于运行集成测试，并为在客户端应用程序（如
    SPAs）上工作的开发者提供一个简单的方式来运行后端。
- en: With our Docker stack ready and our images tested, it’s time to learn how to
    push images to a container registry. Move on to the next section to learn how!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 Docker 栈准备就绪且我们的镜像经过测试后，是时候学习如何将镜像推送到容器注册库了。继续阅读下一节，了解如何操作！
- en: 13.4 Publishing Docker builds to a container registry
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 将 Docker 构建发布到容器注册库
- en: To deploy our Docker builds, we need to publish them first to a Docker container
    registry. A container registry is a repository of Docker images. In the next chapter,
    we will deploy our applications to AWS’s Elastic Kubernetes Service, so we publish
    our builds to AWS’s ECR. Keeping our Docker images within AWS will make it easier
    to deploy them to EKS.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署我们的 Docker 构建，我们需要首先将它们发布到一个 Docker 容器注册库。容器注册库是 Docker 镜像的存储库。在下一章中，我们将部署我们的应用程序到
    AWS 的 Elastic Kubernetes 服务，因此我们将我们的构建发布到 AWS 的 ECR。将我们的 Docker 镜像保留在 AWS 中将使它们部署到
    EKS 更容易。
- en: 'First, let’s create an ECR repository for our images with the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令为我们的镜像创建一个 ECR 仓库：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this command, we create a ECR repository named `coffeemesh-orders`. The
    output from the command is a payload describing the repository we just created.
    When you run the command, the placeholder for `<aws_account_id>` in the output
    payload will contain your AWS account ID, and `<aws_region>` will contain your
    default AWS region. To publish our Docker build to ECR, we need to tag our build
    with the name of the ECR repository. Get hold of the `repository.repositoryArn`
    property of the previous command’s output (in bold), and use it to tag the Docker
    build we created in section 13.2 with the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，我们创建了一个名为 `coffeemesh-orders` 的 ECR 仓库。命令的输出是一个描述我们刚刚创建的仓库的有效负载。当你运行此命令时，输出有效负载中的
    `<aws_account_id>` 占位符将包含你的 AWS 账户 ID，而 `<aws_region>` 将包含你的默认 AWS 区域。要将我们的 Docker
    构建发布到 ECR，我们需要用 ECR 仓库的名称标记我们的构建。获取上一条命令输出中的 `repository.repositoryArn` 属性（加粗），并使用它来标记我们在
    13.2 节中创建的 Docker 构建，如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To publish our images to ECR, we need to obtain login credentials with the
    following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的镜像发布到 ECR，我们需要使用以下命令获取登录凭证：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Make sure you replace `<aws_region>` in this command for the AWS region where
    you created the Docker repository, such as eu-west-1 for Europe (Ireland) or us-east-2
    for US East (Ohio). Also replace `<aws_account_id>` with your AWS account ID.
    Check out the AWS documentation to learn how to find your AWS account ID ([http://mng.bz/Qnye](http://mng.bz/Qnye)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将此命令中的 `<aws_region>` 替换为你创建 Docker 仓库的 AWS 区域，例如欧洲（爱尔兰）的 eu-west-1 或美国东部（俄亥俄州）的
    us-east-2。同时将 `<aws_account_id>` 替换为你的 AWS 账户 ID。查看 AWS 文档了解如何找到你的 AWS 账户 ID ([http://mng.bz/Qnye](http://mng.bz/Qnye))。
- en: AWS REGIONS When you deploy services to AWS, you deploy them to specific regions.
    Each region has an identifier, such as eu-west-1 for Ireland and eu-east-2 for
    Ohio. For an up-to-date list of the regions available in AWS, see [http://mng.bz/XaPM](http://mng.bz/XaPM).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 区域 当你在 AWS 上部署服务时，你将它们部署到特定的区域。每个区域都有一个标识符，例如爱尔兰的 eu-west-1 或俄亥俄州的 eu-east-2。有关
    AWS 中可用区域的最新列表，请参阅 [http://mng.bz/XaPM](http://mng.bz/XaPM)。
- en: 'The `aws` `ecr` `get-login-password` command produces an instruction that Docker
    knows how to use to log in to ECR. We’re now ready to publish our build! Run the
    following command to push the image to ECR:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws ecr get-login-password` 命令生成一个 Docker 可以使用的指令来登录到 ECR。我们现在已经准备好发布我们的构建了！运行以下命令将镜像推送到
    ECR：'
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Voila! Our Docker build is now in ECR. In the next chapter, you’ll learn how
    to deploy this build to a Kubernetes cluster in AWS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的 Docker 构建现在已经在 ECR 中了。在下一章中，你将学习如何将此构建部署到 AWS 的 Kubernetes 集群。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Docker is a virtualization technology that allows us to run our applications
    anywhere by simply having a Docker execution runtime. A Docker build is called
    an image, which is executed in processes called Docker containers.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 是一种虚拟化技术，它允许我们通过简单地拥有一个 Docker 执行运行时，在任何地方运行我们的应用程序。Docker 构建被称为镜像，它是在称为
    Docker 容器的进程中执行的。
- en: Docker Compose is a container orchestration framework that allows you to run
    multiple containers simultaneously, such as databases and APIs. Using Docker Compose
    is an easy and effective way to run your whole backend without having to install
    and configure additional dependencies.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 是一个容器编排框架，它允许你同时运行多个容器，例如数据库和 API。使用 Docker Compose 是运行整个后端的一种简单而有效的方式，无需安装和配置额外的依赖项。
- en: To deploy Docker images, we publish them to a container registry, such as AWS’s
    ECR—a robust and secure container registry that makes it easy to deploy our containers
    to AWS services.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要部署 Docker 镜像，我们需要将它们发布到一个容器注册库，例如 AWS 的 ECR——一个强大且安全的容器注册库，它使得将我们的容器部署到 AWS
    服务变得容易。
