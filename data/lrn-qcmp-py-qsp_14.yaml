- en: 11 Searching with quantum computers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 使用量子计算机进行搜索
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Searching unstructured data with a quantum algorithm
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用量子算法搜索非结构化数据
- en: Using the QDK resources estimator to understand the costs of running algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 QDK 资源估算器理解运行算法的成本
- en: Reflecting quantum registers about states
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转量子寄存器关于状态
- en: In chapter 10, we got to dig into our first application of quantum computing
    by working with our colleague Marie to help calculate the ground state energy
    of a hydrogen molecule. To do so, we implemented a Hamiltonian simulation algorithm
    that used some of the phase-estimation techniques we developed in chapter 9.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 章中，我们通过与我们的同事玛丽合作，帮助计算氢分子的基态能量，从而深入了解了量子计算的第一项应用。为此，我们实现了一个哈密顿量模拟算法，该算法使用了我们在第
    9 章中开发的某些相位估计技术。
- en: 'In this chapter, we’ll look at another application of quantum computing: searching
    data. This application area is always a hot topic in high-performance computing
    areas and shows off another way we can use techniques we learned previously to
    build up another quantum program, in this case based on phase kickback. We also
    look at the *resources estimator* built into the Quantum Development Kit (QDK)
    to see how it can help us understand the scaling of our quantum programs, even
    when they get too big to run locally.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨量子计算的另一项应用：搜索数据。这个应用领域一直是高性能计算领域的热门话题，展示了我们可以如何使用之前学到的技术构建另一个量子程序，在这种情况下是基于相位回弹。我们还研究了内置在量子开发工具包（QDK）中的*资源估算器*，以了解它如何帮助我们理解量子程序的扩展性，即使它们变得太大而无法在本地运行。
- en: 11.1 Searching unstructured data
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 搜索非结构化数据
- en: 'Suppose we want to search through some data to find a contact’s phone number.
    If the list of contacts is sorted by name, then it’s pretty easy to find the phone
    number associated with a particular name by using a *binary search*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要搜索一些数据以找到联系人的电话号码。如果联系人列表按名字排序，那么通过使用*二分搜索*来找到与特定名字关联的电话号码就非常容易：
- en: '*Algorithm 11.1: Pseudocode for binary search*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法 11.1：二分搜索的伪代码*'
- en: Pick a name/phone number pair in the middle of our list. Call this pair our
    pivot.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的列表中间选择一个名字/电话号码对。称这个对为我们的枢轴。
- en: If the pivot’s name is the name we’re looking for, return the pivot’s phone
    number.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果枢轴的名字是我们正在寻找的名字，则返回枢轴的电话号码。
- en: If the name we’re looking for comes before the pivot’s name, repeat the search
    on the first half of the list.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们正在寻找的名字在枢轴的名字之前，则在列表的前半部分重复搜索。
- en: Else, if the name we’re looking for comes after the pivot’s name, repeat the
    search on the second half of the list.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果我们正在寻找的名字在枢轴的名字之后，则在列表的后半部分重复搜索。
- en: Not just a character on Star Trek
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不只是《星际迷航》中的一个角色
- en: 'In this chapter, we’ll talk a lot about searching through data. That data can
    come in a lot of different forms:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将大量讨论通过数据搜索的内容。这些数据可以以很多不同的形式出现：
- en: Phone numbers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码
- en: Names of dogs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 狗的名字
- en: Weather measurements
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气象测量
- en: Types of doorbells
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门铃的类型
- en: What all of these have in common is that we can represent them on classical
    computers as strings of bits, using a variety of different conventions about how
    that representation should work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的共同之处在于，我们可以将它们在经典计算机上表示为位串，使用各种不同的约定来定义这种表示应该如何工作。
- en: Searching this way can be done pretty quickly and is key to how we can search
    databases full of information. The problem is that in algorithm 11.1, we critically
    depend on our list of names and phone numbers being sorted. If it’s not sorted,
    binary searching simply doesn’t work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式搜索可以非常快，这是我们能够搜索充满信息的数据库的关键。问题是，在算法 11.1 中，我们严重依赖于我们的名字和电话号码列表是排序的。如果它没有排序，二分搜索就根本不起作用。
- en: 'Note Now that we have what we need to solve harder problems with quantum computers,
    this chapter’s scenario is a bit more complicated than most of our earlier games
    and scenarios. Don’t worry if things don’t make sense off the bat: take your time
    and read more slowly. We promise it will be worth your while!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现在我们有了解决量子计算机更难问题的所需工具，本章的场景比我们之前的大部分游戏和场景都要复杂一些。如果一开始事情不太明白，请不要担心：慢慢来，仔细阅读。我们保证这会值得你的付出！
- en: 'Put differently, to search our data quickly, we need to apply some kind of
    structure to the data: sorting the data or making some other kind of assumption
    that lets us avoid having to look at every single item. If we don’t have any structure,
    the best thing we can do is to randomly look through the data until we find what
    we want. The steps listed in algorithm 11.2 show pseudocode for how we would search
    a list without structure. We might get lucky, but on average, random searching
    is only ever twice as fast as looking at every single item:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，为了快速搜索我们的数据，我们需要对数据进行某种结构化：对数据进行排序或做出其他假设，使我们能够避免查看每个单独的项目。如果我们没有任何结构，我们能做的最好的事情就是随机浏览数据，直到找到我们想要的东西。算法11.2中列出的步骤显示了如何在没有结构的情况下搜索列表的伪代码。我们可能会走运，但平均而言，随机搜索的速度最多只有查看每个项目速度的两倍：
- en: '*Algorithm 11.2: Pseudocode for searching unstructured lists*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法11.2：搜索无结构列表的伪代码*'
- en: Pick a random element from our list.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的列表中随机选择一个元素。
- en: If it’s the right element, return it. Otherwise, pick a new element and repeat.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它是正确的元素，则返回它。否则，选择一个新的元素并重复。
- en: The fact that searching unstructured lists is hard is the basis of much of cryptography
    as well. In that case, rather than writing the list explicitly, our task in trying
    to break an encryption algorithm is to try different keys until one works. We
    can think of the decryption function as *implicitly* defining a list, where there’s
    one special “marked item” that corresponds to the correct secret key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索无结构列表的困难性是许多密码学基础的基础。在这种情况下，我们尝试破解加密算法的任务不是明确写出列表，而是尝试不同的密钥，直到找到一个有效的密钥。我们可以将解密函数视为*隐式地*定义了一个列表，其中有一个特殊的“标记项”对应于正确的秘密密钥。
- en: 'The pseudocode in algorithm 11.3 could represent this decryption task. The
    random input we pick is the key, which we use with the decryption “function” or
    algorithm to see if it decrypts the message:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 算法11.3中的伪代码可以代表这个解密任务。我们随机选择的输入是密钥，我们使用解密“函数”或算法来查看它是否解密了信息：
- en: '*Algorithm 11.3: Pseudocode for searching unstructured inputs to a function*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法11.3：搜索无结构函数输入的伪代码*'
- en: Pick a random input.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择一个输入。
- en: Call our function with that input. If it worked, return our input.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该输入调用我们的函数。如果它有效，则返回我们的输入。
- en: Otherwise, pick a new random input and repeat.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，选择一个新的随机输入并重复。
- en: If we could search unstructured lists more quickly, that would let us sort through
    databases, solve mathematical problems, or—yes—even break some kinds of classical
    encryption.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够更快地搜索无结构列表，那么这将使我们能够排序数据库，解决数学问题，甚至——是的——破解某些类型的经典加密。
- en: Perhaps surprisingly, if the function that defines our list can be written out
    as a quantum operation (using what we learned about oracles in chapter 8), then
    we can use a quantum algorithm known as *Grover’s algorithm* to find an input
    much faster than with algorithm 11.3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 比起意外的是，如果定义我们的列表的函数可以写成量子操作（使用我们在第8章中学到的关于预言机的知识），那么我们可以使用一种名为*Grover算法*的量子算法，比算法11.3更快地找到一个输入。
- en: Tip We’re getting toward the end of the book, meaning we have the opportunity
    to put together what we’ve learned throughout the book. In particular, in this
    chapter, we’ll use what we learned about *oracles* from Nimue’s and Merlin’s game
    in chapter 8 to represent the input to Grover’s algorithm. If you need a refresher
    on what oracles are, no worries; chapter 8 is there to help.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：我们正在接近本书的结尾，这意味着我们有机会将本书中学到的知识整合起来。特别是，在本章中，我们将使用第8章中从Nimue和Merlin的游戏中学到的关于*预言机*的知识来表示Grover算法的输入。如果你需要复习预言机是什么，不用担心；第8章就是为了帮助你的。
- en: When we run Grover’s algorithm, we’re searching for one or more particular values
    of a function over all possible inputs to a function. If we want to search an
    unstructured list of data, we can consider defining a function that is responsible
    for looking up a particular entry in the list. We can then search through the
    inputs to this function to find the particular function output values we want.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行Grover算法时，我们正在搜索函数在所有可能的函数输入上的一个或多个特定值。如果我们想要搜索无结构的数据列表，我们可以考虑定义一个函数，该函数负责查找列表中的特定条目。然后我们可以搜索这个函数的输入，以找到我们想要的特定函数输出值。
- en: Consider a scenario where we need to decrypt a message in 1 minute. There are
    2.5 million different keys we need to try, but only one works to decrypt the message,
    and trying one key at a time will take too long. We can use Grover’s algorithm
    and a function representing the problem, like “Does this cryptographic key decrypt
    a particular message?” to find the right key much more quickly and without having
    to test each key individually! This is a lot like the padlock example shown in
    figure 11.1, where we think of the different possible keys as inputs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，我们需要在1分钟内解密一条信息。我们需要尝试250万个不同的密钥，但只有一个可以解密信息，逐个尝试密钥将花费太长时间。我们可以使用Grover算法和一个表示问题的函数，例如“这个加密密钥能否解密特定的信息？”来更快地找到正确的密钥，而无需逐个测试每个密钥！这就像图11.1中展示的挂锁示例，我们将不同的可能密钥视为输入。
- en: '![](../Images/11-1.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-1.png)'
- en: Figure 11.1 Structured and unstructured searches. If we are looking through
    an alphabetized address book, there is some structure to the data that we can
    exploit to find data more quickly. In the case of a box of random keys, we just
    have to keep trying random ones until the lock opens.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 结构化和非结构化搜索。如果我们正在查阅一个按字母顺序排列的地址簿，数据中存在一些我们可以利用的结构来更快地找到数据。在随机密钥盒的情况下，我们只能不断尝试随机密钥，直到锁打开。
- en: 'We’ll make the function we need for Grover’s algorithm to represent this problem
    more precise when we revisit oracles later in the chapter; but it’s helpful to
    remember that when we search with Grover’s algorithm, we’re searching over *inputs
    to a function*, not a list of data. With that in mind, here is the pseudocode
    for Grover’s algorithm:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章稍后回顾或acles时，我们将使Grover算法所需的函数更精确地表示这个问题；但记住，当我们使用Grover算法进行搜索时，我们是在搜索函数的*输入*，而不是数据列表。考虑到这一点，以下是Grover算法的伪代码：
- en: '*Algorithm 11.4: Pseudocode for performing an unstructured search (Grover’s
    algorithm)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法11.4：执行非结构化搜索（Grover算法）的伪代码*'
- en: Allocate a register of qubits large enough to represent all inputs to the function
    we are searching over.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个足够大的量子寄存器来表示我们正在搜索的函数的所有输入。
- en: 'Prepare the register in a uniform superposition state: i.e., all possible states
    have the same amplitude. This is because, due to the type of problem, we don’t
    have any additional information about which input is the “correct” one, so this
    represents a uniform probability distribution (or *prior*) on the data.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备寄存器处于均匀叠加状态：即所有可能状态具有相同的振幅。这是因为由于问题的类型，我们没有关于哪个输入是“正确”的任何额外信息，所以这代表了对数据的一个均匀概率分布（或*先验*）。
- en: Reflect the register about the marked state or the state we are searching for.
    Here, a *reflection* means picking a particular state and flipping the sign on
    it; we’ll see more detail in the next section, as well as how to implement reflections
    in Q#.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射寄存器关于标记状态或我们正在搜索的状态。在这里，*反射*意味着选择一个特定的状态并翻转其符号；我们将在下一节中看到更多细节，以及如何在Q#中实现反射。
- en: Reflect the register about the initial state (uniform superposition).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于初始状态（均匀叠加）对寄存器进行反射。
- en: Repeat steps 3 and 4 until the probability of measuring the item we are searching
    for is sufficiently high. Then measure the register. We can mathematically work
    out the optimal number of times we need to do this so that we maximize the correct
    answer.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤3和4，直到测量我们正在寻找的项目的概率足够高。然后测量寄存器。我们可以从数学上计算出需要执行此操作的优化次数，以最大化正确答案。
- en: Figure 11.2 shows these steps.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2展示了这些步骤。
- en: '![](../Images/11-2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-2.png)'
- en: Figure 11.2 The steps to Grover’s algorithm, which searches over inputs to a
    function, looking for a particular function output. We start by allocating a register
    of qubits large enough to represent all of the inputs we want to search over and
    then put it in a uniform superposition state. Finally, we can reflect the state
    of the register the right number of times to maximize the probability of measuring
    the answer we are looking for.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 Grover算法的步骤，该算法搜索函数的输入，寻找特定的函数输出。我们首先分配一个足够大的量子寄存器来表示我们想要搜索的所有输入，并将其置于均匀叠加状态。最后，我们可以通过正确地反射寄存器的状态来最大化测量我们正在寻找的答案的概率。
- en: 'Note As we go through this chapter, we’ll see that one way to think of Grover’s
    algorithm is as a kind of rotation between the states representing whether we’ve
    found the right marked item: the decryption key for our scenario. If we apply
    steps 3 and 4 of Grover’s algorithm too many times, we’ll rotate right past the
    state we’re looking for, so choosing the number of iterations is an integral part
    of the algorithm!'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章的讨论过程中，我们会看到将Grover算法视为一种在表示我们是否找到了正确标记项的状态之间旋转的方法：我们场景中的解密密钥。如果我们多次应用Grover算法的步骤3和4，我们将旋转到我们寻找的状态之外，因此选择迭代次数是算法的一个关键部分！
- en: Figure 11.3 shows an example of how the cost of classically searching an unstructured
    list might compare to using Grover’s algorithm.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3展示了使用Grover算法在经典方式下搜索非结构化列表的成本可能如何进行比较。
- en: '![](../Images/11-3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-3.png)'
- en: Figure 11.3 An example of how the time taken to search unstructured lists might
    scale for classical and quantum computers. We can see that for smaller numbers
    of items, the quantum approach takes more time; but as we increase the number
    of items in the search, the quantum approach to search takes less time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3展示了经典计算机和量子计算机搜索非结构化列表所需时间可能如何缩放。我们可以看到，对于较小的项目数量，量子方法需要更多的时间；但随着搜索中项目数量的增加，量子搜索方法所需的时间减少。
- en: Tip One way to describe what’s shown in figure 11.3 is to use a concept called
    *asymptotic complexity*. In particular, we say that a classical unstructured search
    requires *O*(*N*) function calls to search through *N* inputs, while Grover’s
    algorithm requires *O*(√*N*) calls. Don’t worry if this isn’t familiar; but if
    you’re curious about how to understand algorithms this way, check out chapter
    1 of *Grokking Algorithms* by Aditya Y. Bhargava (Manning, 2016).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：描述图11.3中所示内容的一种方法是用一个称为“渐近复杂度”的概念。具体来说，我们说经典非结构化搜索需要*O*(*N*)次函数调用以搜索*N*个输入，而Grover算法需要*O*(√*N*)次调用。如果你对此不熟悉，不要担心；但如果你对如何以这种方式理解算法感兴趣，可以查看Aditya
    Y. Bhargava所著的《Grokking Algorithms》（Manning, 2016）的第1章。
- en: As before, let’s jump in and see what that code looks like. Listing 11.1 is
    an example of a Q# operation that uses Grover’s algorithm to search an unstructured
    list for a marked item. Here, rather than 2.5 million keys, we will reduce the
    scope to 8 keys, with the marked item or correct key indicated by an integer in
    the range 0 to 7\. Yes, that means we might be able to solve this just as fast
    on a classical computer. However, at the end of the chapter, we will see how,
    as the number of keys we need to search through grows, the number of steps or
    computations required to find the correct key is much lower when using Grover’s
    algorithm. Also, for our sample code here, the function representing the decryption
    algorithm doesn’t really do any decrypting; it just acts like it is playing a
    guessing game and returns a Boolean if it is given the right key. Implementing
    a particular decryption algorithm for this chapter is out of scope and would likely
    need a bit of research to pull off. The goal here is to show how using Grover’s
    algorithm to search through the inputs to a function can speed up particular problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们跳进去看看这段代码的样子。列表11.1是一个使用Grover算法在非结构化列表中搜索标记项的Q#操作的示例。在这里，我们将范围缩小到8个键，标记项或正确键由0到7范围内的整数表示。是的，这意味着我们可能在经典计算机上也能以同样的速度解决这个问题。然而，在本章的结尾，我们将看到随着我们需要搜索的键的数量增加，使用Grover算法找到正确键所需的步骤或计算量要低得多。此外，对于这里的示例代码，代表解密算法的函数实际上并没有进行任何解密；它只是像在玩猜谜游戏一样，如果给出了正确的键，就返回一个布尔值。为本章实现特定的解密算法超出了范围，并且可能需要进行一些研究才能实现。这里的目的是展示如何使用Grover算法搜索函数的输入可以加快特定问题的解决。
- en: 'Listing 11.1 operations.qs: Q# code that runs Grover’s search'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 operations.qs：运行Grover搜索的Q#代码
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ We can use partial application to include the index of the marked item in
    the oracle that we provide to the search algorithm.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以使用部分应用来在提供给搜索算法的预言者中包含标记项的索引。
- en: ❷ Runs Grover’s search algorithm on a register of three qubits and provides
    the oracle markItem that we defined earlier
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在三个量子比特的寄存器上运行Grover搜索算法，并提供了我们之前定义的预言者markItem
- en: ❸ Issues a message to verify that it found the right item
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发出消息以验证它找到了正确的项
- en: 'If we run the sample in listing 11.1, we should get the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行列表11.1中的示例，我们应该得到以下输出：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see from running the sample of Grover’s algorithm that the decryption
    key we were looking for was the one indexed or marked by the number 6, and the
    algorithm found the key as number 6 as well. Now, since the `SearchForMarkedItem`
    operation is really the meat of this example, let’s look at its implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行Grover算法的示例中，我们可以看到我们寻找的解密密钥是索引或标记为数字6的那个，算法也找到了标记为数字6的密钥。现在，由于`SearchForMarkedItem`操作确实是这个示例的核心，让我们看看它的实现。
- en: 'Listing 11.2 operations.qs: writing Grover’s as a Q# operation'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2 operations.qs：将Grover算法编写为Q#操作
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ As usual, we start by defining a new operation, using the “operation” keyword.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如同往常，我们首先定义一个新的操作，使用“operation”关键字。
- en: ❷ The first input our operation needs is the number of items in our list.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的操作需要的第一输入是我们列表中的项目数量。
- en: ❸ The next input is a representation of our search problem. We can implicitly
    define our search problem by an oracle that marks whether an item in our list
    is the right one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 下一个输入是我们搜索问题的表示。我们可以通过一个标记我们列表中项目是否正确的预言机来隐式定义我们的搜索问题。
- en: ❹ When we’re done with our search, we’ll have an index for where the marked
    item was. Defining our output as an Int lets us return that index.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 当我们完成搜索后，我们将有一个标记项的位置索引。将我们的输出定义为Int允许我们返回该索引。
- en: ❺ To start the search, we need to allocate a big enough register to store an
    index into our list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为了开始搜索，我们需要分配一个足够大的寄存器来存储列表中的索引。
- en: ❻ Since we’re starting a search on an unstructured list, all items are equally
    good places to look. We represent this by preparing a uniform superposition over
    all indices into our list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 由于我们是在一个无结构的列表上开始搜索，所以所有项目都是同样好的查找位置。我们通过在列表的所有索引上准备一个均匀叠加来表示这一点。
- en: ❼ The heart of Grover’s algorithm comes down to repeatedly reflecting about
    our start state and the index of the item we’re looking for.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ Grover算法的核心在于反复关于我们的起始状态和我们正在寻找的项目索引进行反思。
- en: ❽ Once we’re done, measuring our qubit register tells us the index of the item
    that Grover’s algorithm found.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 完成后，测量我们的量子寄存器会告诉我们Grover算法找到的项目索引。
- en: The Q# standard library provides a useful operation, `MeasureInteger`, that
    interprets measurement results as a classical integer. To use `MeasureInteger`
    as in listing 11.2, we can mark our register as encoding an integer in a little-endian
    register by using the `Microsoft.Quantum.Arithmetic.LittleEndian` user-defined
    type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Q#标准库提供了一个有用的操作`MeasureInteger`，它将测量结果解释为经典整数。要像列表11.2中那样使用`MeasureInteger`，我们可以通过使用`Microsoft.Quantum.Arithmetic.LittleEndian`用户定义类型来标记我们的寄存器，表示它以小端格式编码一个整数。
- en: User-defined types If you need a reminder about what user-defined types (UDTs)
    are and how to use them, check out chapter 9, where we used them to help Lancelot
    and Dagonet play their angle-guessing game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义类型 如果你需要提醒一下用户定义类型（UDTs）是什么以及如何使用它们，请查看第9章，我们在那里使用它们来帮助Lancelot和Dagonet玩他们的角度猜测游戏。
- en: By this point in the book, we have almost all the quantum concepts we need to
    make sense of listing 11.2\. In the rest of this chapter, we’ll see how to use
    what we’ve learned to implement an example oracle that can define a simple search
    problem and how to implement the two reflections that make up Grover’s algorithm
    to solve that problem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，我们几乎已经拥有了理解列表11.2所需的所有量子概念。在本章的其余部分，我们将看到如何使用我们所学到的知识来实现一个示例预言机，它可以定义一个简单的搜索问题，以及如何实现构成Grover算法的两个反射来解决该问题。
- en: My good fellow—I have a quarrel with your query!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我的好朋友——我对你的查询有异议！
- en: It may seem a little contrived to use an operation like `ReflectAboutMarkedState`
    as the oracle to define the query for Grover’s algorithm. After all, since the
    marked item’s index is baked in as an input to `ReflectAboutMarkedState`, it may
    seem as though we’re cheating rather badly with this example. That said, `SearchForMarkedItem`
    only sees our oracle as an opaque box and does not see its inputs, such that baking
    in the input this way doesn’t let us cheat after all.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`ReflectAboutMarkedState`这样的操作作为预言机来定义Grover算法的查询可能显得有些牵强。毕竟，由于标记项目的索引作为输入嵌入到`ReflectAboutMarkedState`中，这似乎意味着我们在这个例子中严重作弊。话虽如此，`SearchForMarkedItem`只看到我们的预言机作为一个不透明的盒子，并且看不到它的输入，这样嵌入输入实际上并没有让我们作弊。
- en: Using a simple oracle like this helps us focus on how Grover’s algorithm works
    without having to understand a more complicated oracle. In practice, however,
    we want to use a more sophisticated oracle that represents a more difficult search
    problem. To search some data represented as a list of items, for example, we could
    use a technique called *quantum RAM* (qRAM) to turn our list into an oracle. The
    details of qRAM are beyond the scope of this book, but there are some great resources
    online about qRAM and how expensive it may be to use in a particular application.
    Check out [https://github.com/qsharp-community/qram](https://github.com/qsharp-community/qram)
    for an excellent primer on qRAM and a Q# library you can get started with.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样一个简单的预言机有助于我们专注于Grover算法的工作原理，而无需理解更复杂的预言机。然而，在实践中，我们希望使用更复杂的预言机来代表更困难的搜索问题。例如，为了搜索表示为项目列表的数据，我们可以使用称为*量子随机存取存储器*（qRAM）的技术将我们的列表转换为预言机。qRAM的细节超出了本书的范围，但网上有一些关于qRAM及其在特定应用中可能多么昂贵的优秀资源。查看[https://github.com/qsharp-community/qram](https://github.com/qsharp-community/qram)以了解qRAM的出色入门指南和可以开始使用的Q#库。
- en: Another area where Grover’s algorithm is used a lot is in symmetric key encryption
    (as contrasted with a public key, which we’ll cover in chapter 12). For example,
    [https://github.com/microsoft/grover-blocks](https://github.com/microsoft/grover-blocks)
    provides implementations of oracles representing key parts of the AES and LowMC
    ciphers so that those ciphers can be understood using Grover’s algorithm.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多领域，Grover算法都得到了广泛的应用，特别是在对称密钥加密中（与第12章将要介绍的公钥加密相对）。例如，[https://github.com/microsoft/grover-blocks](https://github.com/microsoft/grover-blocks)提供了代表AES和LowMC密码关键部分的预言机实现，这样就可以使用Grover算法来理解这些密码。
- en: 11.2 Reflecting about states
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 关于状态的反射
- en: 'In algorithm 11.4 and listing 11.2, we used two operations repeatedly in the
    `for` loop: `ReflectAboutInitialState` and `ReflectAboutMarkedState`. Let’s dig
    into how these operations help search the input of the function representing our
    decryption scenario.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法11.4和列表11.2中，我们在`for`循环中反复使用了两个操作：`ReflectAboutInitialState`和`ReflectAboutMarkedState`。让我们深入了解这些操作是如何帮助搜索代表我们解密场景的函数的输入的。
- en: Each of these operations is an example of a reflection about a particular state.
    This is an example of a new kind of quantum operation, but we can still simulate
    it with a unitary matrix as before. The term *reflecting about a state* means
    when we have a register of qubits, we pick a particular state it could be in,
    and if it happens to be in that state, we flip the sign on the state (change the
    phase of that state). If you think this sounds like some of the controlled operations
    we looked at before, you are correct; we will use controlled operations to implement
    these reflections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的每一个都是关于特定状态的反射的例子。这是一个新型量子操作的例子，但我们可以像以前一样使用单位矩阵来模拟它。术语*关于状态的反射*意味着当我们有一个量子比特寄存器时，我们选择它可能处于的特定状态，如果它恰好处于该状态，我们就翻转该状态上的符号（改变该状态相）。如果你认为这听起来像我们之前查看的一些受控操作，你是正确的；我们将使用受控操作来实现这些反射。
- en: 11.2.1 Reflection about the all-ones state
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 全1态的反射
- en: 'Let’s start by looking at a particularly useful example: a reflection about
    the all-ones state, |11⋅⋅⋅1〉. We can implement this reflection using the `CZ`
    (controlled-`Z`) operation we first saw in chapter 9.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个特别有用的例子开始：关于全1态的反思，|11⋅⋅⋅1〉。我们可以使用在第9章首次看到的`CZ`（受控`Z`）操作来实现这种反射。
- en: Tip Remember that the `Controlled` functor isn’t just a fancy `if` block, but
    rather can be used in superposition. For a review of how the `Controlled` functor
    works, check out chapter 9, where we used it to help Lancelot and Dagonet play
    their game.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：记住，`Controlled`函子不仅仅是一个花哨的`if`块，而可以用于叠加。要了解`Controlled`函子是如何工作的，请参阅第9章，在那里我们使用它来帮助Lancelot和Dagonet玩游戏。
- en: 'Listing 11.3 operations.qs: reflecting about the |11⋅⋅⋅1〉 state'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 operations.qs：关于|11⋅⋅⋅1〉状态的反射
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The Controlled functor allows us to use the Z operation in a controlled fashion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 受控函子允许我们以受控的方式使用Z操作。
- en: 'Like other `Controlled` operations, `Controlled Z` takes two inputs: the register
    that should be used as control qubits and the qubit the `Z` operation will be
    applied to if all the qubits in the control register are in the |1〉 state. In
    listing 11.3, we can use the `Most` function from `Microsoft.Quantum.Arrays` to
    get all but the last qubit and `Tail` to get only the last qubit.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他`Controlled`操作一样，`Controlled Z`需要两个输入：用作控制量子比特的寄存器以及如果控制寄存器中的所有量子比特都处于|1〉状态，则将对该量子比特应用`Z`操作的量子比特。在列表11.3中，我们可以使用`Microsoft.Quantum.Arrays`中的`Most`函数来获取除最后一个量子比特之外的所有量子比特，并使用`Tail`来获取最后一个量子比特。
- en: Tip By using `CZ` together with `Most` and a `Tail`, our implementation works
    no matter how many qubits are in our register. This will be useful later, as we
    might need different numbers of qubits to represent the data in our list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：通过使用`CZ`与`Most`和`Tail`一起，我们的实现不依赖于寄存器中有多少量子比特。这将在以后很有用，因为我们可能需要不同数量的量子比特来表示列表中的数据。
- en: Recall from chapter 9 that the `CZ` operation applies a phase of –1 to the |11⋅⋅⋅1〉
    state and does nothing to every other computational basis state. Thinking back
    to chapter 2, where each computational basis state is a kind of direction, that
    means a single direction is flipped by `CZ`, while all other input states are
    left alone. That kind of picture is why we call operations that behave in this
    way *reflections*, although an actual graphical representation is tricky due to
    the number of dimensions that can be involved.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第9章，`CZ`操作将对|11⋅⋅⋅1〉状态应用-1的相移，并对每个其他计算基态不做任何操作。回想第2章，每个计算基态都是一种方向，这意味着单个方向会被`CZ`翻转，而所有其他输入状态保持不变。这种图像是我们称之为*反射*的原因，尽管由于涉及到的维度数量，实际的图形表示很复杂。
- en: Matrix representations of CZ
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CZ的矩阵表示
- en: 'One way to see that the `CZ` operation flips the sign of a single input state,
    as described previously, is to write a unitary matrix that simulates `CZ`. Here
    is an example with a single control qubit:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可以看到`CZ`操作翻转单个输入状态的符号，如前所述，的方法是编写一个模拟`CZ`的单位矩阵。以下是一个只有一个控制量子比特的例子：
- en: '![](../Images/equation_11-1K.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_11-1K.png)'
- en: 'And here is an example for two control qubits:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个有两个控制量子比特的例子：
- en: '![](../Images/equation_11-2K.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_11-2K.png)'
- en: Using what we’ve learned about unitary matrices throughout the book, these matrices
    make it clear that the input states |11〉 and |111〉, respectively, are flipped
    by –1, while all other input states are left alone (get a phase of +1). The same
    pattern continues no matter how many control qubits we use with `CZ`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本书中关于单位矩阵所学到的知识，这些矩阵清楚地表明，输入状态|11〉和|111〉分别被-1翻转，而所有其他输入状态保持不变（获得+1的相移）。无论我们使用多少控制量子比特与`CZ`一起使用，这种模式都会持续。
- en: 'Exercise 11.1: Diagnostics on CZ'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.1：CZ的诊断
- en: Use `DumpMachine` to see how `CZ` acts on the uniform superposition state |+⋅⋅⋅〉.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DumpMachine`来查看`CZ`如何作用于均匀叠加态|+⋅⋅⋅〉。
- en: '*Hint*: Recall that |+〉 = *H*|0〉, so we can use the program `ApplyToEachCA(H,
    register)` to prepare |+⋅⋅⋅+〉 on a register that starts in the |00⋅⋅⋅0〉 state.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：回想一下|+〉 = *H*|0〉，因此我们可以使用程序`ApplyToEachCA(H, register)`在以|00⋅⋅⋅0〉状态开始的寄存器上准备|+⋅⋅⋅+〉。'
- en: Exercise solutions
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题解决方案
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter we are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有练习题的解决方案都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入我们所在的章节文件夹，并打开提及练习题解决方案的Jupyter笔记本。
- en: 11.2.2 Reflection about an arbitrary state
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 对任意状态的反射
- en: Once we have a reflection about |11⋅⋅⋅1〉 under our belt, we can use it to reflect
    about other states as well. This is important as we probably cannot set up our
    oracle function representing the decryption algorithm so that the input or key
    we want is represented by the all-ones input. Also recall from our sample code
    that the oracle only implements a guessing-game sort of decryption, not a real
    decryption algorithm.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对|11⋅⋅⋅1〉有了反思，我们就可以用它来对其他状态进行反思。这很重要，因为我们可能无法设置代表解密算法的预言函数，以便我们想要的输入或密钥由全1输入表示。也请从我们的示例代码中回忆，预言函数仅实现了一种猜谜游戏式的解密，而不是真正的解密算法。
- en: 'Deep dive: Reflections are rotations?'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：反射是旋转吗？
- en: 'Given our geometrical understanding of reflections, it would be natural to
    think of them as a kind of rotation by 180° degrees. That turns out to be true
    only because quantum states are vectors of complex numbers; if we only had access
    to real numbers, we wouldn’t be able to get a reflection by using rotations! We
    can see this by thinking back to how we described states and rotations in chapters
    2 and 3: as rotations of a 2D circle.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对反射的几何理解，我们自然会认为它们是一种180°的旋转。这之所以成立，仅仅是因为量子状态是复数的向量；如果我们只能访问实数，我们就无法通过旋转来获得反射！我们可以通过回想我们在第二章和第三章中如何描述状态和旋转来看到这一点：作为二维圆的旋转。
- en: If we pick up a two-dimensional object, flip it over, and put it back down,
    there’s no way to transform it back to the way it was without picking it back
    up. On the other hand, three-dimensional space gives us enough extra room to combine
    different rotations to make a reflection. Since complex numbers give us a third
    axis when describing the states of qubits (namely, the *Y*-axis), that’s also
    what lets us do the reflections we need in Grover’s algorithm.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拿起一个二维物体，将其翻转，然后放回原处，没有拿起它就无法将其转换回原来的样子。另一方面，三维空间为我们提供了足够的空间来组合不同的旋转以进行反射。由于复数在描述量子位的状态时提供了第三个轴（即*Y*轴），这也使我们能够在Grover算法中进行所需的反射。
- en: The trick to reflecting about states other than all-ones is to turn whatever
    state we want to reflect about into the all-ones state, call `ReflectAboutAllOnes`,
    and then undo the operation we used to map our reflection onto the all-ones state.
    We can describe any state by starting from the all-zeros state, so we need a way
    to go from the all-zeros state to the all-ones state where we can use the reflection
    we just learned. The following listing shows an example of preparing a register
    in the all-ones state from the all-zeros state.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于除了全一状态以外的状态的反射技巧是将我们想要反射的任何状态转换为全一状态，调用`ReflectAboutAllOnes`，然后撤销我们用来将反射映射到全一状态的运算。我们可以通过从全零状态开始来描述任何状态，因此我们需要一种方法从全零状态转换到我们可以使用我们刚刚学到的反射的全一状态。下面的列表显示了从全零状态准备寄存器到全一状态的示例。
- en: 'Listing 11.4 operations.qs: preparing the all-ones state'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 operations.qs：准备全一状态
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The ApplyToEachCA operation allows us to apply the first input (an operation)
    to each qubit in a register (the second input).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ ApplyToEachCA操作允许我们将第一个输入（一个操作）应用于寄存器中的每个量子位（第二个输入）。
- en: In Q#, all freshly allocated registers start in the |00⋅⋅⋅0〉 state. Thus, in
    listing 11.4, when we apply `X` to each newly allocated qubit, that prepares our
    new register it the |11⋅⋅⋅1〉 state.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Q#中，所有新分配的寄存器都从|00⋅⋅⋅0〉状态开始。因此，在列表11.4中，当我们对每个新分配的量子位应用`X`时，我们就将我们的新寄存器准备成|11⋅⋅⋅1〉状态。
- en: For the next step, we need to consider the operation that prepares the state
    we want to reflect around. If we have an adjointable operation (`is Adj`) that
    prepares a particular state that we want to reflect about, then all we have to
    do is *unprepare* the state, prepare the all-ones state, reflect about the all-ones
    state (|11⋅⋅⋅1〉), unprepare the all-ones state, and then *re-prepare* the state
    we are trying to reflect about.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，我们需要考虑准备我们想要反射的状态的操作。如果我们有一个可伴随的操作（`is Adj`），它可以准备我们想要反射的特定状态，那么我们只需要*解除准备*该状态，准备全一状态，关于全一状态（|11⋅⋅⋅1〉）进行反射，解除全一状态的准备，然后*重新准备*我们试图反射的状态。
- en: Why we love Dirac notation
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么喜欢Dirac符号
- en: In understanding the steps in algorithm 11.5, it is helpful to think of what
    each operation in that sequence of steps does to its input state. Fortunately,
    Dirac notation (first encountered way back in chapter 2) can help write how unitary
    matrices transform different states so that we can understand and predict what
    the corresponding Q# operations will do to our qubits.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解算法11.5中的步骤时，思考每个操作在该步骤序列中对输入状态做了什么是有帮助的。幸运的是，Dirac符号（首次在第二章中遇到）可以帮助我们写出单位矩阵如何转换不同的状态，这样我们就可以理解和预测相应的Q#操作将对我们的量子位做什么。
- en: 'For example, consider the Hadamard operation `H`. As we’ve seen throughout
    the book, `H` can be simulated by the following unitary matrix:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑Hadamard操作`H`。正如我们在整本书中看到的那样，`H`可以通过以下单位矩阵来模拟：
- en: '![](../Images/equation_11-3K.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_11-3K.png)'
- en: This unitary matrix acts as a kind of truth table, telling us that *H* transforms
    the |0〉 state into the 1 / √2 (|0〉 + |1〉) state. Using Dirac notation, we can
    make this clearer by writing *H* = |+〉〈0| + |−〉〈1|. By thinking of kets (|⋅〉)
    as denoting inputs and bras (〈⋅|), we can read this as saying “The `H` operation
    transforms |0〉 into |+〉 and |1〉.”
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个幺正矩阵充当一种真值表，告诉我们*H*将|0〉状态转换成1 / √2 (|0〉 + |1〉)状态。使用狄拉克符号，我们可以通过写出*H* = |+〉〈0|
    + |−〉〈1|来使这一点更清晰。通过将基（|⋅〉）视为表示输入，将共轭基（〈⋅|）视为表示输出，我们可以将其读作“`H`操作将|0〉转换成|+〉和|1〉”。
- en: This figure shows how Dirac notation acts as a sort of visual language that
    tells us about the inputs and outputs for different unitary matrices, making it
    easier to understand how sequences of Q# operations work together.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了狄拉克符号如何作为一种视觉语言，告诉我们不同幺正矩阵的输入和输出，这使得理解Q#操作序列如何协同工作变得更容易。
- en: '![](../Images/11-unnumb.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/11-unnumb.png)'
- en: Breaking down reflections about states with Dirac (aka braket) notation. Each
    step of `ReflectAboutMarkedState` is split up, and we show the Dirac notation
    for that operation. When all the individual steps are connected, the resulting
    state is –2|*Ψ*〉〈*Ψ*|.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用狄拉克（又称括号）符号分解关于状态的反思。`ReflectAboutMarkedState`的每一步都被拆分，我们展示了该操作的狄拉克符号。当所有单独的步骤连接起来时，得到的结果状态是-2|*Ψ*〉〈*Ψ*〉。
- en: '*Algorithm 11.5: How to reflect about an arbitrary state*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法11.5：如何反思任意状态*'
- en: Using the `Adjoint` functor, “un-prepare” our arbitrary state, mapping it to
    the all-zeros |00⋅⋅⋅0〉 state.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Adjoint`函子，“取消准备”我们的任意状态，将其映射到全零的`|00⋅⋅⋅0〉`状态。
- en: Prepare the all-ones state |11⋅⋅⋅1〉 from the all-zeros state.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从全零状态准备全一状态`|11⋅⋅⋅1〉`。
- en: Use `CZ` to reflect about |11⋅⋅⋅1〉.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CZ`来反思`|11⋅⋅⋅1〉`。
- en: Un-prepare the all-ones state, mapping it back to the all-zeros state.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消准备全一状态，将其映射回全零状态。
- en: Prepare our state again, mapping the all-zeros state to our arbitrary state.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次准备我们的状态，将全零状态映射到我们的任意状态。
- en: Tip In algorithm 11.5, steps 1 and 5 cancel adjoints of each other, as do steps
    2 and 4\. Using what we’ve learned about “shoes-and-socks” thinking, this makes
    the procedure of algorithm 11.5 ideal for implementing the `within`/`apply` feature
    of Q#! For a reminder of how this feature works, check out chapter 8, where we
    used `within`/`apply` blocks to implement the Deutsch–Jozsa algorithm for Nimue
    and Merlin.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在算法11.5中，步骤1和5相互抵消伴随，同样步骤2和4也是如此。利用我们关于“鞋袜”思维的所学，这使得算法11.5的流程非常适合实现Q#!的`within`/`apply`特性。为了了解此功能的工作方式，请查看第8章，其中我们使用了`within`/`apply`块来实现Nimue和Merlin的Deutsch–Jozsa算法。
- en: Since we don’t have any prior notion about what the right input to our oracle
    is when we run Grover’s algorithm, we want to start our search from the uniform
    superposition |+⋅⋅⋅〉 to represent that any input could be the right one. This
    gives us a chance to use what we learned from algorithm 11.5 to practice implementing
    reflections in Q#! Following the steps to reflect the initial state, we can implement
    the `ReflectAboutInitialState` operation used in listing 11.2\. The following
    listing shows how we can follow algorithm 11.5 in a Q# operation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在运行Grover算法时对或acle的正确输入没有任何先验概念，我们希望从均匀叠加|+⋅⋅⋅〉开始搜索，以表示任何输入都可能是正确的。这给了我们一个机会来使用我们从算法11.5中学到的知识来练习在Q#中实现反思。遵循反思初始状态的步骤，我们可以实现列表11.2中使用的`ReflectAboutInitialState`操作。以下列表显示了如何在Q#操作中遵循算法11.5。
- en: 'Listing 11.5 operations.qs: reflecting about an arbitrary state'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5操作.qs：反思任意状态
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The uniform superposition state represents that we have no prior information
    for our search (after all, it is an unstructured search problem).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶均匀叠加状态表示我们在搜索中没有任何先验信息（毕竟，它是一个无结构搜索问题）。
- en: ❷ Following algorithm 11.5, to reflect about the initial state, we need to provide
    an operation that prepares it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷遵循算法11.5，为了反思初始状态，我们需要提供一个准备它的操作。
- en: ❸ Of course, we also need a register of qubits to apply our reflection to!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸当然，我们还需要一个量子比特寄存器来应用我们的反思！
- en: ❹ Performs steps 1 and 2 from algorithm 11.5
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❹执行算法11.5中的步骤1和2
- en: ❺ The Adjoint functor indicates that we want to do the “reverse” or opposite
    of the operation that prepares the initial state. In other words, if we started
    with the initial state, applying the Adjoint prepareInitialState operation would
    take us back to the |00⋅⋅⋅0〉 state.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❺伴随函子表明我们想要执行“反向”或相反的操作，以准备初始状态。换句话说，如果我们从初始状态开始，应用伴随的`prepareInitialState`操作将带我们回到`|00⋅⋅⋅0〉`状态。
- en: We now have the code to reflect about that initial state, so how can we check
    to see if it does what we expect? When running the simulator target machine, we
    can use commands like `DumpRegister` to show all the information it uses to simulate
    our register of qubits. Figure 11.4 shows the output of `DumpRegister` after preparing
    a uniform superposition.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了关于那个初始状态的反射代码，那么我们如何检查它是否如我们所期望的那样工作？当运行模拟目标机器时，我们可以使用`DumpRegister`等命令来显示它用于模拟我们的量子比特寄存器的所有信息。图11.4显示了`DumpRegister`在准备均匀叠加后的输出。
- en: '![](../Images/11-4.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-4.png)'
- en: Figure 11.4 Using `DumpRegister` to view the initial state prepared by our `PrepareInitialState`
    operation. Each possible basis state has the same amplitude (and so the same measurement
    probability), which is known as a uniform superposition.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 使用`DumpRegister`查看`PrepareInitialState`操作准备的初始状态。每个可能的本征态具有相同的振幅（因此相同的测量概率），这被称为均匀叠加。
- en: For reflecting about the marked state, the other reflection we need for Grover’s
    algorithm, we must use a slightly different approach. After all, we don’t know
    how to prepare the marked state—that’s the problem we’re using Grover’s algorithm
    to solve! Fortunately, thinking back to chapter 8, we can use what we learned
    from Nimue’s and Merlin’s game to implement a reflection about a state *even when
    we don’t know what that state is*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关于标记态的反射，这是Grover算法所需的另一个反射，我们必须采用稍微不同的方法。毕竟，我们不知道如何准备标记态——这正是我们使用Grover算法要解决的问题！幸运的是，回想第8章，我们可以利用我们从Nimue和Merlin的游戏中学到的知识来实现关于一个状态的反射，即使我们不知道那个状态是什么。
- en: 'Note This is the crux of Grover’s algorithm: we can use our oracle to reflect
    about the marked state by calling it once with the right superposition of inputs.
    As we see in the next section, each of these reflections gives us some information
    about the marked item. In contrast, each classical function call can eliminate
    at most one possible input.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这是Grover算法的核心：我们可以通过用正确的输入叠加调用预言机一次来使用我们的预言机来反射关于标记态。正如我们在下一节中看到的，这些反射中的每一个都给我们关于标记项的一些信息。相比之下，每个经典函数调用最多可以消除一个可能的输入。
- en: 'To see how that works in this case, let’s first take a step back and look at
    what our marked state is. Since our list is defined by an oracle, we can write
    a unitary operator *O* that lets us simulate that oracle. Here is the Dirac notation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这种情况下的工作原理，让我们首先退一步，看看我们的标记态是什么。由于我们的列表是由预言机定义的，我们可以写一个单位算子*O*，它允许我们模拟那个预言机。以下是狄拉克符号：
- en: '![](../Images/equation_11-4.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_11-4.png)'
- en: 'In chapter 8, we saw that applying an `X` operation to a qubit in |−〉 applied
    a phase of –1, since |−〉 is an eigenstate of the `X` operation. Using the same
    trick here, we can write what our oracle does when the flag qubit (the |*y*〉 register)
    is in the |−〉 state:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们了解到对一个处于|−〉态的量子比特应用`X`操作会引入一个-1的相因子，因为|−〉是`X`操作的本征态。使用同样的技巧，我们可以写出当标志量子比特（即|*y*〉寄存器）处于|−〉态时，我们的预言机所执行的操作：
- en: '![](../Images/equation_11-5.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_11-5.png)'
- en: 'This is precisely the operation we need to implement the reflection! Thus,
    following what we learned in chapter 8, we can implement it the same way: simply
    apply our oracle to a qubit that starts in the |−〉 state. This oracle then represents
    the decryption algorithm for the scenario, here simplified to a function that
    takes possible keys as input and just returns a bool indicating whether it is
    the correct key. The next listing shows an example Q# operation that uses this
    approach; recall that in Q#, we can pass an operation as an input to another function
    or operation.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要实现反射的操作！因此，根据我们在第8章中学到的知识，我们可以以相同的方式实现它：只需将我们的预言机应用于一个从|−〉态开始的量子比特。这个预言机代表了该场景的解密算法，这里简化为一个接受可能的密钥作为输入并仅返回一个bool值以指示它是否是正确密钥的函数。接下来的列表显示了一个使用此方法的Q#操作示例；请记住，在Q#中，我们可以将一个操作作为输入传递给另一个函数或操作。
- en: 'Listing 11.6 operations.qs: reflecting about a marked state'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.6 operations.qs：关于标记态的反射
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The operation for our item-marking oracle has type ((Qubit[], Qubit) => Unit
    is Adj), indicating that it takes a register of qubits plus one additional qubit
    and is adjointable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的项目标记预言机的操作类型为((Qubit[], Qubit) => Unit is Adj)，表示它接受一个量子比特寄存器加上一个额外的量子比特，并且是可伴随的。
- en: ❷ The second input to reflect about the marked state is a register to which
    we want to apply our reflection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 反射关于标记态的第二个输入是一个我们想要应用反射的寄存器。
- en: ❸ We need to allocate one additional qubit (called a flag) to apply our oracle,
    which corresponds to the *y* register in earlier equations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们需要分配一个额外的量子比特（称为标志）来应用我们的预言者，这对应于早期方程中的*y*寄存器。
- en: ❹ In the same way that we used the H and X operations in chapter 8 to prepare
    Nimue’s qubit in the |−〉 state, we use that |−〉 = *HX*|0〉 here to prepare our
    flag qubit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 就像我们在第8章中使用H和X操作来准备Nimue的量子比特在|−〉状态一样，我们在这里使用|−〉 = *HX*|0〉来准备我们的标志量子比特。
- en: ❺ We apply our oracle to use the Deutsch–Jozsa trick and apply a phase of –1
    to the state marked by our oracle.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们应用我们的预言者来使用Deutsch–Jozsa技巧，并将-1的相位应用于我们的预言者标记的状态。
- en: In listing 11.6, since this preparation is in a `within`/`apply` block, Q# automatically
    puts our qubit back into the |0〉 state for us by undoing the `X` and `H` operations.
    After all, as we saw in chapter 8, applying our oracle leaves its target in the
    |−〉 state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表11.6中，由于这个准备是在`within`/`apply`块中，Q#会自动通过撤销`X`和`H`操作来将我们的量子比特放回|0〉状态。毕竟，正如我们在第8章中看到的，应用我们的预言者会将其目标留在|−〉状态。
- en: 'Exercise 11.2: Flag preparation'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.2：标志准备
- en: In listing 11.6, we can also write `H(flag); Z(flag);`. Using either or both
    of QuTiP and `AssertOperationsEqualReferenced` proves that these two ways of preparing
    our flag qubit give us the same reflection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表11.6中，我们也可以写`H(flag); Z(flag);`。使用QuTiP和`AssertOperationsEqualReferenced`中的任意一种或两种方法都可以证明这两种准备我们的标志量子比特的方式给我们带来了相同的反射。
- en: 'What’s amazing is that we used the Deutsch–Jozsa trick to reflect about a state
    that was *implicitly* defined by our oracle! We didn’t have to explicitly know
    what the marked state was to apply the reflection: perfect for use in an unstructured
    search.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们使用了Deutsch–Jozsa技巧来反思一个由我们的预言者*隐式地*定义的状态！我们不必明确知道标记状态是什么，就可以应用反思：非常适合用于无结构的搜索。
- en: In the next section, we see how to combine the initial and marked state reflections
    to bring everything together, fully implement Grover’s algorithm, and find our
    key.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何结合初始状态和标记状态反射，将所有内容整合在一起，完全实现Grover算法，并找到我们的密钥。
- en: 11.3 Implementing Grover’s search algorithm
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 实现Grover搜索算法
- en: 'Now that we have learned about rotating about states and revisited oracles,
    it’s time to put it all together to do some unstructured searching! Let’s start
    by reviewing all the steps to implement Grover’s algorithm (figure 11.5):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了关于状态旋转的知识，并回顾了预言者，是时候将所有这些整合起来进行一些无结构的搜索了！让我们首先回顾实现Grover算法的所有步骤（图11.5）：
- en: Allocate a register of qubits large enough to index the data set we are searching
    over.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个足够大的量子比特寄存器来索引我们正在搜索的数据集。
- en: 'Prepare the register in a uniform superposition state: i.e., all possible states
    have the same amplitude. This is because due to the type of problem, we don’t
    have any additional information about the data set, so this represents a uniform
    probability distribution (or prior) on the data.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备寄存器在均匀叠加状态：即所有可能的状态具有相同的振幅。这是因为由于问题的类型，我们没有关于数据集的任何额外信息，所以这代表了对数据的一个均匀概率分布（或先验）。
- en: Reflect the register about the marked state or the state we are searching for.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射寄存器关于标记状态或我们正在搜索的状态。
- en: Reflect the register about the initial state (uniform superposition).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反射寄存器关于初始状态（均匀叠加）。
- en: Repeat steps 3 and 4 until the probability of measuring the item we are searching
    for is sufficiently high. Then measure the register. We can mathematically work
    out the optimal number of times we need to do this to maximize the probability
    of getting back the marked item.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤3和4，直到测量我们正在搜索的项目的概率足够高。然后测量寄存器。我们可以从数学上计算出我们需要这样做多少次才能最大化得到标记项目的概率。
- en: '![](../Images/11-5.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-5.png)'
- en: Figure 11.5 Recall the Grover’s algorithm steps that search over inputs to a
    function, looking for a particular function output. We start by allocating a register
    of qubits large enough to represent all of the inputs we want to search over and
    then put it in a uniform superposition state. Finally, we can reflect the state
    of the register the right number of times to maximize the probability of measuring
    the answer we are looking for.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 回顾Grover算法的步骤，该算法搜索函数的输入，寻找特定的函数输出。我们首先分配一个足够大的量子比特寄存器来表示我们想要搜索的所有输入，并将其置于均匀叠加状态。最后，我们可以通过正确地反射寄存器的状态来最大化测量我们正在寻找的答案的概率。
- en: As close as you can without going over
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能接近但不超出
- en: 'If we apply too many iterations of Grover’s algorithm, the amplitude of the
    state we want to measure decreases. This is because each iteration is effectively
    a rotation; the trick is to stop that rotation at the right point. To work out
    the trigonometry for the stopping criteria, we write the state of the register
    used in Grover’s algorithm as a superposition of the unmarked and marked states.
    We won’t cover the details of this derivation here, but check out [https://docs.microsoft.com/quantum/libraries/standard/algorithms](https://docs.microsoft.com/quantum/libraries/standard/algorithms)
    or section 6.1.3 of *Quantum Computation and Quantum Information* by Michael A.
    Nielsen and Isaac L. Chuang (Cambridge University Press, 2010) if you’re interested
    in learning more about the math behind the scenes. It is implemented for you in
    the samples repo for this book, but the formula is below if you want to try to
    program it in Q# yourself:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用太多的Grover算法迭代，我们想要测量的状态的振幅会减小。这是因为每次迭代实际上是一个旋转；关键是停止在正确的点上。为了确定停止标准的三角学，我们将Grover算法中使用的寄存器状态写成未标记和标记状态的叠加。我们不会在这里详细说明这个推导过程，但如果你对幕后数学感兴趣，可以查看[https://docs.microsoft.com/quantum/libraries/standard/algorithms](https://docs.microsoft.com/quantum/libraries/standard/algorithms)或Michael
    A. Nielsen和Isaac L. Chuang所著的《量子计算与量子信息》（Cambridge University Press，2010）的第6.1.3节。这个公式在本书的示例仓库中已经实现，但如果你想在Q#中自己编程实现，公式如下：
- en: '![](../Images/equation_11-6K.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![方程式11-6K](../Images/equation_11-6K.png)'
- en: In the previous section, we developed some of the operations we need for the
    full implementation. For example, we have implemented step 2 with the `PrepareInitialState`
    operation and the reflections in steps 3 and 4 as the `ReflectAboutMarkedState`
    and `ReflectAboutInitialState` operations, respectively. We still need a function
    to help figure out how many times to loop over steps 3 and 4 and an implementation
    of the oracle that identifies the item we are looking for. Let’s start with the
    function that helps define the stopping criteria for Grover’s algorithm.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们开发了一些完整实现所需的操作。例如，我们用 `PrepareInitialState` 操作实现了步骤2，用 `ReflectAboutMarkedState`
    和 `ReflectAboutInitialState` 操作分别实现了步骤3和4中的反射。我们仍然需要一个函数来确定步骤3和4需要循环多少次，以及一个识别我们要找的项的预言者的实现。让我们从帮助定义Grover算法停止标准的函数开始。
- en: 'Listing 11.7 operations.qs: the stopping criteria for Grover’s'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 operations.qs：Grover算法的停止标准
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ <<< is the left-bitshift operator, used to compute 2^(nQubits), which represents
    the maximum number of items that can be indexed by a quantum register of nQubits.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ <<< 是左移位运算符，用于计算 2^(nQubits)，它代表nQubits量子寄存器可以索引的最大项目数。
- en: ❷ Figures out the effective rotation angle applied by each iteration of Grover’s
    algorithm
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确定Grover算法每次迭代的实际旋转角度
- en: ❸ Using the effective rotation angle together with some trigonometry, we can
    compute how many iterations will maximize the probability that we’ll measure the
    marked item.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用有效旋转角度和一些三角学，我们可以计算出多少次迭代将最大化我们测量标记项的概率。
- en: 'Now that we can calculate when to stop the loop in our implementation of Grover’s
    algorithm, the last thing we need is an oracle that can—given the item we are
    looking for and a potential item from the data set—flip the phase on part of our
    register if the potential item is the item we are looking for. For the purpose
    of an example, let’s think of the oracle as representing a kind of guessing game.
    If someone is thinking of the number 4 and asks us to guess their number, that’s
    an example of a kind of classical function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在Grover算法的实现中计算何时停止循环，我们最后需要的是一个可以——给定我们要找的项和数据集中的潜在项——如果潜在项是我们正在寻找的项，则翻转寄存器部分相位的预言者。为了举例说明，让我们将预言者视为代表一种猜测游戏。如果有人正在想数字4并让我们猜他们的数字，那就是一个经典函数的例子：
- en: '![](../Images/equation_11-7.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![方程式11-7](../Images/equation_11-7.png)'
- en: 'Classically, we’d have no better strategy than to try different inputs to *f*
    until we tried *x* = 4\. If we want to try Grover’s algorithm instead, using what
    we learned in chapter 8, we know we need an operation that represents *f*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典情况下，我们最好的策略就是尝试不同的输入到 *f*，直到我们尝试 *x* = 4。如果我们想尝试Grover算法，利用我们在第8章学到的知识，我们知道我们需要一个表示
    *f* 的操作：
- en: '![](../Images/equation_11-8.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![方程式11-8](../Images/equation_11-8.png)'
- en: It’s pretty easy to implement an operation that can be simulated by *Uf* using
    the Q# function `ControlledOnInt`, provided as a part of the Q# standard libraries.
    Like the `Controlled` functor, the `ControlledOnInt` function allows us to control
    an operation on another register’s state. The difference is that while `Controlled`
    always controls on the all-ones state |11⋅⋅⋅1〉, the `ControlledOnInt` function
    allows us to control on a different state, specified by an integer. For example,
    if `Length(register)` is 3, then `(ControlledOnInt(4, X))(register, flag)` flips
    the state of `flag` whenever `register` is in the state |100〉, since 4 is written
    as `100` in little-endian notation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Q#函数`ControlledOnInt`（作为Q#标准库的一部分提供）实现一个可以被模拟的*Uf*操作相当简单。与`Controlled`函子类似，`ControlledOnInt`函数允许我们控制另一个寄存器状态的运算。区别在于，`Controlled`总是控制于全1状态|11⋅⋅⋅1〉，而`ControlledOnInt`函数允许我们控制于一个不同的状态，该状态由一个整数指定。例如，如果`Length(register)`是3，那么`(ControlledOnInt(4,
    X))(register, flag)`会在`register`处于状态|100〉时翻转`flag`的状态，因为4在小端表示法中写作`100`。
- en: 'Exercise 11.3: Action of ControlledOnInt'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.3：ControlledOnInt的作用
- en: Try writing what `(ControlledOnInt(4, X))(register, flag)` does to the state
    of `register + [flag]` either using Dirac notation (check out chapters 2 and 4
    if you need a refresher) or by writing a unitary matrix that can be used to simulate
    `(ControlledOnInt(4, X))` acting on a three-qubit register and a flag qubit.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用狄拉克符号（如果需要复习，请查看第2章和第4章）或编写一个可以用来模拟`(ControlledOnInt(4, X))`在三个量子比特寄存器和标志量子比特上作用的单位矩阵，来描述`(ControlledOnInt(4,
    X))(register, flag)`对`register + [flag]`状态的影响。
- en: '*Hint*: Since `(ControlledOnInt(4, X))` acts on four qubits in this example
    (three control qubits and a target qubit), the unitary matrix should be a 16 ×
    16 matrix.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：由于在这个例子中`(ControlledOnInt(4, X))`作用于四个量子比特（三个控制量子比特和一个目标量子比特），单位矩阵应该是一个16
    × 16的矩阵。'
- en: Try doing the same thing, but for `(ControlledOnInt(4, Z))`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试做同样的事情，但对于`(ControlledOnInt(4, Z))`。
- en: Using the `ControlledOnInt` function, we can quickly write an oracle that flips
    the state of a flag qubit based on an input to that oracle, as shown in the next
    listing. Here, our oracle should flip its flag qubit whenever the input to the
    oracle is in the marked state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ControlledOnInt`函数，我们可以快速编写一个预言机，该预言机根据对预言机的输入翻转标志量子比特的状态，如下一列表所示。在这里，我们的预言机应该在预言机的输入处于标记状态时翻转其标志量子比特。
- en: 'Listing 11.8 operations.qs: an oracle marking the state we want'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 operations.qs：标记我们想要的状态的预言机
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Indicates the index of the item we are looking for as an integer (the sample
    here uses three qubits, so we can input any integer 0 to 2³ − 1 = 7)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将我们正在寻找的项目索引作为一个整数表示（这里的示例使用三个量子比特，因此我们可以输入任何0到2³ − 1 = 7的整数）
- en: ❷ The ControlledOnInt function that we learned about earlier can apply an X
    on the flag, controlled on the input register being in the right marked item.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们之前学到的`ControlledOnInt`函数可以在输入寄存器处于正确标记的项目时对标志应用X操作。
- en: With these two code snippets to add, we can return to the sample code from earlier.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这两个代码片段后，我们可以回到之前提供的示例代码。
- en: 'Listing 11.9 operations.qs: Grover’s algorithm as a Q# operation'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 operations.qs：Grover算法作为Q#操作
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ As usual, we start by defining a new operation, using the “operation” keyword.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如同往常，我们首先通过使用“operation”关键字定义一个新的操作。
- en: ❷ The first input is the number of items in our list.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一个输入是我们列表中的项目数量。
- en: ❸ Just as with the cryptography example, we can implicitly define our list with
    an oracle that marks whether an item in our list is the right one.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正如加密示例一样，我们可以通过一个标记我们列表中项目是否正确的预言机隐式定义我们的列表。
- en: ❹ When we’re done with our search, we have an index for where the marked item
    was. Defining our output as an Int lets us return that index.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当我们完成搜索后，我们有一个标记项目的索引。将我们的输出定义为Int允许我们返回该索引。
- en: ❺ To start the search, we need to allocate a big enough register to store an
    index into our list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为了开始搜索，我们需要分配一个足够大的寄存器来存储列表中的索引。
- en: ❻ Since we’re searching an unstructured list, when we first start the search,
    all items are equally good places to look.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 由于我们正在搜索一个无结构的列表，当我们开始搜索时，所有项目都是同样好的查找位置。
- en: ❼ The heart of Grover’s algorithm comes down to repeatedly reflecting about
    our start state and the index for the item that we’re looking for.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Grover算法的核心在于反复关于我们的起始状态和我们正在寻找的项目索引进行反思。
- en: ❽ Once we’re done, measuring our qubit register tells us the index of the item
    that Grover’s algorithm found.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 完成后，测量我们的量子比特寄存器会告诉我们Grover算法找到的项目索引。
- en: The Q# standard library provides a useful operation, `MeasureInteger`, that
    interprets measurement results as a classical integer. To use `MeasureInteger`,
    as in listing 11.10, we can mark our register as encoding an integer in a little-endian
    register by using the `Microsoft.Quantum.Arithmetic.LittleEndian` UDT.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Q#标准库提供了一个有用的操作`MeasureInteger`，它将测量结果解释为经典整数。要使用`MeasureInteger`，如列表11.10所示，我们可以使用`Microsoft.Quantum.Arithmetic.LittleEndian`
    UDT将我们的寄存器标记为编码在little-endian寄存器中的整数。
- en: We have all the code we need, so let’s run an example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有需要的代码，所以让我们运行一个示例。
- en: 'Listing 11.10 operations.qs: a specific example of Grover’s'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.10 operations.qs：Grover算法的一个具体示例
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ We can use partial application to include the index of the marked item in
    the oracle we provide to the search algorithm.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以使用部分应用来将标记项的索引包含在我们提供给搜索算法的或门中。
- en: ❷ Runs Grover’s algorithm on a register of three qubits and provides the oracle
    markItem that we defined earlier
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在三个量子比特的寄存器上运行Grover算法，并提供了我们之前定义的markItem或门
- en: ❸ Issues a message to verify that it found the right item
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发送消息以验证它找到了正确的项
- en: 'If we run this sample, we should get the following output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例，我们应该得到以下输出：
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Exercise 11.4: Changing oracles'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.4：更改或门
- en: Try changing the definition of the oracle to control on a different integer.
    Does this change the output when you run Grover’s algorithm?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改或门的定义以控制不同的整数。当你运行Grover算法时，这会改变输出吗？
- en: 'Congratulations: we can now use a quantum program to do unstructured searches!
    But what’s actually going on? The key insight from geometry that makes Grover’s
    algorithm works is that when we reflect about two different axes, we get a rotation.
    Figure 11.6 shows an example of how that works for maps.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜：我们现在可以使用量子程序进行无结构搜索了！但实际上发生了什么？使Grover算法工作的几何关键洞察是，当我们关于两个不同的轴进行反射时，我们得到一个旋转。图11.6展示了映射如何工作的一个例子。
- en: '![](../Images/11-6.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-6.png)'
- en: Figure 11.6 How pairs of reflections can make a rotation. If we reflect the
    map over a line at 25° up from the horizontal and then reflect about the horizontal,
    that’s the same as a rotation of the map by 50° down from the horizontal.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 展示了成对的反射如何进行旋转。如果我们把映射反射到从水平线向上25°的线上，然后再反射到水平线上，这相当于将映射绕水平线旋转50°向下。
- en: The same idea works for quantum states. In Grover’s algorithm, the initial and
    marked state reflections combine into a single rotation from the unmarked states
    into the marked state. To understand how that works, we can use the techniques
    we’ve learned throughout the book to look at what’s happening to the amplitudes
    of each state of the register as we go through the algorithm’s steps.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的想法也适用于量子状态。在Grover算法中，初始和标记状态反射组合成一个从未标记状态到标记状态的单一旋转。为了理解这是如何工作的，我们可以使用我们在整本书中学到的技术来查看寄存器每个状态振幅在算法步骤中发生的变化。
- en: We can see from figure 11.7 that each round of reflections seems to *amplify*
    the amplitude of the state that corresponds to the index we are looking for. By
    rotating between the unmarked and marked states, we can make the state of our
    qubits line up with the marked state we want to find.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从图11.7中我们可以看到，每一轮反射似乎都会*放大*对应于我们正在寻找的索引的状态振幅。通过在未标记和标记状态之间旋转，我们可以使我们的量子比特状态与我们要找到的标记状态对齐。
- en: '![](../Images/11-7.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-7.png)'
- en: Figure 11.7 A schematic showing how the amplitudes of the state of our qubit
    register change as we step through Grover’s algorithm. As we continue doing reflections,
    some amplitudes are amplified and the rest are reduced.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 展示了随着我们逐步通过Grover算法，我们量子寄存器状态的振幅如何变化。当我们继续进行反射时，一些振幅被放大，而其余的振幅被减小。
- en: We can use the same kinds of ideas in other applications as well, as it turns
    out. Grover’s algorithm is an example of a broader class of quantum algorithms
    that do what is called *amplitude amplification*. This means we have greatly amplified
    the chances that when we measure our qubit register, the classical bit string
    of measurement results will be the item we are looking for.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们还可以在其他应用中使用相同类型的想法。Grover算法是更广泛类别的量子算法的一个例子，这些算法执行所谓的*振幅放大*。这意味着当我们测量我们的量子比特寄存器时，测量结果的经典比特字符串有很大可能是我们正在寻找的项。
- en: Deterministic vs. probabilistic quantum algorithms
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性量子算法与概率性量子算法
- en: Grover’s algorithm works by increasing the probability that we get the right
    answer with each iteration. In general, though, Grover’s algorithm may not be
    able to increase that probability all the way to 100%. Thus, Grover’s algorithm
    is an example of a probabilistic quantum algorithm, meaning we are not guaranteed
    to get the answer we are looking for every single time we run it. This isn’t a
    problem in practice since we can always run it a small number of times to get
    an even higher probability of success.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Grover算法通过在每次迭代中增加我们得到正确答案的概率来工作。然而，一般来说，Grover算法可能无法将这个概率增加到100%。因此，Grover算法是一个概率量子算法的例子，这意味着我们并不能保证每次运行都能得到我们想要的答案。在实践中，这并不是一个问题，因为我们总是可以运行它几次，以获得更高的成功概率。
- en: It may be tempting to conclude that all quantum algorithms are probabilistic
    this way—but that turns out not to be the case. As we saw in chapter 8, the Deutsch–Jozsa
    algorithm is an example of a *deterministic* quantum algorithm, which gives the
    same results each time we run it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使我们得出结论，所有量子算法都是通过这种方式概率性的——但事实并非如此。正如我们在第8章中看到的，Deutsch-Jozsa算法是一个*确定性*量子算法的例子，每次运行都会给出相同的结果。
- en: 'Exercise 11.5: Exploring Grover’s algorithm with DumpMachine'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.5：使用DumpMachine探索Grover算法
- en: We’ve learned a lot about rotations so far in this book, which can help with
    understanding the rotation applied by each iteration of Grover’s algorithm. Try
    modifying the implementation of Grover’s algorithm to apply twice as many iterations,
    and use `DumpMachine` to look at the resulting state. Does it seem like what you’d
    expect from applying a rotation twice?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经学到了很多关于旋转的知识，这有助于理解Grover算法每次迭代的旋转应用。尝试修改Grover算法的实现，使其迭代次数加倍，并使用`DumpMachine`来查看结果状态。这看起来像是应用旋转两次后你所期望的吗？
- en: More general amplitude amplification examples
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般的振幅放大示例
- en: Along with phase estimation, amplitude amplification is one of the most fundamental
    techniques used throughout quantum algorithms. In the 25 years since Grover’s
    algorithm first introduced the concept of amplitude amplification, a huge number
    of variants have been developed to cover a wide range of different problems, such
    as when there are multiple marked items, when we want to optimize a function rather
    than find a marked item, or even when we can only *sometimes* correctly prepare
    the initial state. Many of these techniques are available under the `Microsoft.Quantum.Amplitude
    .Amplification` namespace in the Q# standard libraries. Go take a look!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了相位估计之外，振幅放大是量子算法中使用的最基本技术之一。自从Grover算法首次引入振幅放大的概念以来，已经开发出大量变体来覆盖广泛的问题，例如当存在多个标记项时，当我们想要优化一个函数而不是寻找标记项时，或者当我们只能*有时*正确准备初始状态时。许多这些技术都可在Q#标准库中的`Microsoft.Quantum.Amplitude.Amplification`命名空间下找到。去看看吧！
- en: Before we close out this chapter, it will be helpful to have a short discussion
    of how doing searches like the one we just implemented on quantum hardware scales
    compared to using classical hardware.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，简要讨论一下，与使用经典硬件相比，在量子硬件上执行我们刚刚实现的搜索操作如何进行扩展，这将是有益的。
- en: 11.4 Resource estimation
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 资源估计
- en: We mentioned earlier, when we simplified our scenario from 2.5 million keys
    to 8, that there would be an advantage to using Grover’s algorithm as the number
    of keys we needed to search grew. So, how long does it take to run Grover’s algorithm
    in practice? This turns out to be a pretty complicated question—we could write
    several books about it. In part, this is a complicated question because estimating
    resource requirements necessarily depends on a lot of different parts of our quantum
    computing stack.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，当我们从250万个密钥简化到8个密钥时，使用Grover算法将会有优势。那么，在实践中运行Grover算法需要多长时间？这实际上是一个相当复杂的问题——我们可以为此写几本书。部分原因是，估计资源需求必然取决于我们量子计算堆栈的许多不同部分。
- en: For example, errors are common in quantum devices, so we need to use error correction
    to protect our computation as it runs. Which error-correction method is used to
    protect our computation has a massive effect on what’s required to run our program.
    Entire conferences are dedicated to finding better error-correcting codes for
    just this reason.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，量子设备中常见的错误，我们需要在运行过程中使用纠错来保护我们的计算。我们用来保护计算的错误纠正方法对我们的程序运行所需条件有巨大影响。整个会议都是因为这个原因，致力于寻找更好的纠错码。
- en: Fortunately, Q# and the Quantum Development Kit provide some of the tools we
    need to start getting a handle on what’s required to run different quantum programs.
    Instead of running our program on a simulator that models how a real quantum computer
    would work, we can run it on a *resources estimator*, which tells us how many
    of each kind of intrinsic operation we need to call, how many qubits our program
    needs, and how many of the quantum operations in our program can be called in
    parallel. Let’s look at a small example, using what we learned about the Deutsch–Jozsa
    algorithm in chapter 8.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Q#和量子开发工具包提供了一些我们需要开始了解运行不同量子程序所需工具的工具。我们不必在模拟器上运行我们的程序，该模拟器模拟真实量子计算机的工作方式，我们可以在*资源估算器*上运行它，它会告诉我们需要调用每种类型的基本操作的次数，程序需要多少量子位，以及程序中可以并行调用的量子操作的次数。让我们看看一个小例子，使用我们在第8章中学到的Deutsch–Jozsa算法。
- en: Listing 11.11 Defining the Deutsch–Jozsa algorithm again
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 再次定义Deutsch–Jozsa算法
- en: '[PRE12]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ The same ApplyNotOracle we saw earlier, except that now it uses a within/apply
    flow
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 与我们之前看到的相同的ApplyNotOracle，但现在它使用的是within/apply流程
- en: ❷ Remember that when using Q# Jupyter Notebooks, we have to open namespaces
    in each cell we want to use them in.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记住，当使用Q# Jupyter笔记本时，我们必须在每个我们想要使用它们的单元中打开命名空间。
- en: ❸ The operation CheckIfOracleIsBalanced is the same as before, except that a
    within/apply block is again used to replace the repeated H and X operations.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查IfOracleIsBalanced操作与之前相同，除了再次使用within/apply块来替换重复的H和X操作。
- en: ❹ In Q# notebooks, we need an operation with no arguments to use with the %simulate
    and %estimate commands.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在Q#笔记本中，我们需要一个无参数的操作来与%simulate和%estimate命令一起使用。
- en: When we run the `%estimate` magic command in an IQ# notebook, we get back a
    table much like the one shown in figure 11.8\. This table reports the kinds of
    resources the Quantum Development Kit estimates our program would take to run.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在IQ#笔记本中运行`%estimate`魔法命令时，我们会得到一个类似于图11.8所示的表格。这个表格报告了量子开发工具包估计我们的程序运行所需资源类型。
- en: '![](../Images/11-8.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-8.png)'
- en: Figure 11.8 Output from running `%estimate RunDeutschJozsaAlgorithm` on the
    program in listing 11.11\. When we use `%estimate`, we get a count of various
    types of resources that our quantum device (or simulator) would need to provide
    to make it possible to run the program. Check out table 11.1 to learn more about
    the meaning of each of these counts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 在列表11.11的程序上运行`%estimate RunDeutschJozsaAlgorithm`的输出。当我们使用`%estimate`时，我们得到一个计数，表示我们的量子设备（或模拟器）需要提供各种类型的资源，以便运行程序。查看表11.1以了解更多关于这些计数的含义。
- en: Table 11.1 Kinds of resources tracked by the `%estimate` magic command
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 `%estimate`魔法命令跟踪的资源类型
- en: '| Resource kind | Description |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 资源类型 | 描述 |'
- en: '| `CNOT` | How many times the `CNOT` operation is called |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `CNOT` | `CNOT`操作被调用的次数|'
- en: '| `QubitClifford` | How many times the `X`, `Y`, `Z`, `H`, and `S` operations
    are called |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `QubitClifford` | `X`、`Y`、`Z`、`H`和`S`操作被调用的次数|'
- en: '| `R` | How many times single-qubit rotation operations are called |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `R` | 单量子位旋转操作被调用的次数|'
- en: '| `Measure` | How many measurement operations are called |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Measure` | 调用测量操作的次数|'
- en: '| `T` | How many times the `T` operation is called |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `T` | `T`操作被调用的次数|'
- en: '| `Depth` | How many `T` operations need to be called in a row on a single
    qubit |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `Depth` | 在单个量子位上需要连续调用多少次`T`操作|'
- en: '| `Width` | How many qubits our program needs |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `Width` | 我们程序需要多少量子位|'
- en: '| `BorrowedWidth` | How many qubits our program needs to be able to borrow
    (a more advanced technique than we cover in this book) |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `BorrowedWidth` | 我们程序需要多少量子位才能借用（一种比本书中介绍的高级技术）|'
- en: Tip We can also estimate resources from Python! Just use the `estimate_ resources`
    method instead of the `simulate` method that we learned about in previous chapters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们也可以从Python中估算资源！只需使用`estimate_resources`方法代替我们在前几章中学到的`simulate`方法。
- en: As we can see from running `%estimate` in the notebook and table 11.1, some
    categories probably make sense, like the width, how many measurements are made,
    and R for the number of single-qubit rotations used. Others are new, like counting
    `T` operations and depth. We have not seen `T` operations before, but they are
    just another kind of single-qubit operation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从笔记本中的`%estimate`运行和表11.1中看到的那样，一些类别可能是有意义的，比如宽度、测量次数和R表示单量子位旋转使用的次数。其他的是新的，比如计数`T`操作和深度。我们之前没有见过`T`操作，但它们只是另一种单量子位操作。
- en: Meet Mr. *T*
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 见先生*T*
- en: 'Like most other operations we’ve seen so far in this book, the `T` operation
    can be simulated by a unitary matrix:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中迄今为止看到的大多数其他操作一样，`T`操作可以通过一个单位矩阵来模拟：
- en: '![](../Images/equation_11-9K.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![方程11-9K](../Images/equation_11-9K.png)'
- en: That is, `T` is a 45° (*π* / 4) rotation about the *Z*-axis.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 即，`T`是在*Z*轴上的45°（*π* / 4）旋转。
- en: Another way of thinking of the `T` operation is as the fourth root of the `Z`
    operation we’ve seen quite a bit of. Since 45° × 4 = 180°, if we apply `T` four
    times in a row, that’s an expensive way of applying the `Z` operation once.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考`T`操作的方式是将其视为我们之前看到很多次的`Z`操作的四次方根。由于45° × 4 = 180°，如果我们连续四次应用`T`，那是一种昂贵的方式来应用一次`Z`操作。
- en: In Q#, the `T` operation is made available as `Microsoft.Quantum.Intrinsic.T`
    and has type `Qubit` => `Unit is Adj + Ctl`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Q#中，`T`操作作为`Microsoft.Quantum.Intrinsic.T`提供，类型为`Qubit` => `Unit is Adj + Ctl`。
- en: 'Exercise 11.6: Four T’s make a Z'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.6：四个T构成一个Z
- en: Use `AssertOperationsEqualReferenced` to prove that applying the `T` operation
    four times does the same thing as applying `Z` once. There’s another operation,
    `S`, that can be thought of as the square root of `Z` (a 90° rotation about the
    *Z*-axis); check that applying `T` twice is the same as applying `S` once.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AssertOperationsEqualReferenced`来证明应用四次`T`操作与应用一次`Z`操作相同。还有一个操作`S`，可以将其视为`Z`的平方根（*Z*轴上的90°旋转）；检查应用两次`T`与应用一次`S`相同。
- en: 'What makes `T` operations somewhat special and thus worthy of focusing on so
    heavily when estimating resources is that they are expensive to use with error-correcting
    methods that are needed when running on larger quantum devices. Most of the operations
    we’ve used so far are part of the *Clifford group*: operations that are easier
    to use with error correction. As noted before, getting into the details of error
    correction here is out of scope for this book; but in short, the more operations
    we have that are not Clifford operations, the harder it will be to implement our
    program on error-corrected hardware. Thus it is important to count the number
    of “expensive” operations (like `T`) for running on our currently available hardware.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使`T`操作在估计资源时显得特别并因此值得高度重视的原因是，当在更大的量子设备上运行时，它们与所需的错误纠正方法一起使用时成本较高。我们迄今为止使用的多数操作都属于**克利福德群**：易于与错误纠正一起使用的操作。正如之前所述，详细讨论错误纠正超出了本书的范围；但简而言之，我们拥有的非克利福德操作越多，在错误纠正硬件上实现我们的程序就越困难。因此，统计“昂贵”操作（如`T`）的数量对于运行我们目前可用的硬件来说非常重要。
- en: Tip At a high level, the number of `T` operations that must be applied in sequence
    (that is, that can’t be run in parallel) is a pretty good approximation of how
    long a quantum program takes to run on error-corrected quantum computers. This
    is reported by the resources estimator as the Depth metric.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：从高层次来看，必须按顺序应用（即不能并行运行）的`T`操作的数量是量子程序在错误纠正量子计算机上运行时间的良好近似。资源估计器将其报告为深度指标。
- en: So, what are typical or exceptional values for the resources we can count with
    the resources estimator in Q#? For a simple program like `RunDeutschJozsaAlgorithm`,
    the resources required are very modest. Looking at table 11.1, though, there’s
    a lot of focus on the `T` operation, so let’s delve into it a bit to see what
    that operation is and why it’s essential for resource estimation. Figure 11.9
    shows the output from estimating the resources required to call the `CCNOT` operation
    that we learned about in chapter 9.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Q#的资源估计器中，我们可以计数资源的典型或异常值是什么？对于一个简单的程序如`RunDeutschJozsaAlgorithm`，所需的资源非常有限。然而，查看表11.1时，对`T`操作的关注很多，因此让我们深入探讨一下，看看这个操作是什么以及为什么它对资源估计至关重要。图11.9显示了估计调用我们在第9章中学习的`CCNOT`操作所需资源的结果。
- en: '![](../Images/11-9.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图11-9](../Images/11-9.png)'
- en: Figure 11.9 Output from estimating the resources required to call `CCNOT`. From
    the code, it may seem that there should be only one operation; but in reality,
    `CCNOT` is decomposed into more easily implemented operations depending on the
    target machine.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9为估计调用`CCNOT`所需资源的结果。从代码中看起来似乎只有一个操作；但事实上，`CCNOT`根据目标机器被分解成更容易实现的操作。
- en: 'Exercise 11.7: Resetting registers'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.7：重置寄存器
- en: Why don’t we need to reset the register of qubits allocated in `EstimateCcnotResources`,
    as shown in figure 11.9?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不需要重置如图11.9所示的`EstimateCcnotResources`中分配的量子比特寄存器？
- en: This output is a bit surprising, in that our tiny program requires 10 `CNOT`
    operations, 5 single-qubit operations, and 7 `T` operations, even though we don’t
    call any of them directly. As it turns out, it’s very difficult to apply operations
    like `CCNOT` directly in an error-corrected quantum program. So, the Q# resources
    estimator first turns our program into something closer to what would actually
    be run on hardware, using calls to more basic operations like `CNOT` and `T`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出有点令人惊讶，因为我们的小程序需要10次`CNOT`操作，5次单量子位操作和7次`T`操作，尽管我们没有直接调用它们。实际上，在纠错量子程序中直接应用`CCNOT`之类的操作非常困难。因此，Q#资源估算器首先将我们的程序转换为更接近实际在硬件上运行的程序，使用对更基本操作（如`CNOT`和`T`）的调用。
- en: 'Exercise 11.8: T scaling'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.8：T缩放
- en: How does the number of `T` operation calls change as you increase the number
    of control qubits? A rough trend is fine.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 随着控制量子位数量的增加，`T`操作调用次数如何变化？一个粗略的趋势就足够了。
- en: '*Hint*: As we saw previously, a controlled-NOT operation with an arbitrary
    number of qubits can be written as `Controlled X(Most(qs), Tail(qs));` using functions
    provided by the `Microsoft.Quantum.Arrays` namespace.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：正如我们之前所看到的，一个具有任意数量量子位的受控-NOT操作可以写成`Controlled X(Most(qs), Tail(qs));`，这是使用`Microsoft.Quantum.Arrays`命名空间提供的函数实现的。'
- en: This comes in handy when we want to estimate what resources it would take to
    run a program that is too large for us to simulate on a classical computer. Figure
    11.10 shows the output from running Grover’s algorithm on a 20-qubit list (about
    1 million items).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要估算运行一个太大而无法在经典计算机上模拟的程序所需的资源时，这非常有用。图11.10显示了在20位量子列表（约100万项）上运行Grover算法的输出。
- en: '![](../Images/11-10.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-10.png)'
- en: Figure 11.10 The result of running the resources estimator on Grover’s algorithm.
    These resource counts make it clear why we can’t directly simulate an instance
    of Grover’s this big, as we would need 39 qubits. However, we can use this data
    from multiple search sizes to get a sense of how our implementation of Grover’s
    will scale.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 运行资源估算器在Grover算法上的结果。这些资源计数清楚地说明了为什么我们无法直接模拟这么大的Grover实例，因为我们需要39个量子位。然而，我们可以使用来自多个搜索大小的数据来了解我们的Grover实现将如何扩展。
- en: If we run this for various list sizes, we get a curve like the one shown in
    figure 11.11\. For our scenario with 2.5 million keys, the quantum number of steps
    is much lower than the classical step cost. That’s not the whole story, of course,
    since each step on a quantum computer will probably be much slower than a corresponding
    step on a classical computer; but it’s a really good move toward understanding
    what it would take to run different quantum programs in practice.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为各种列表大小运行这个程序，我们会得到图11.11中所示的那种曲线。对于我们的2.5百万个密钥的场景，量子步骤数远低于经典步骤成本。当然，这并不是全部故事，因为量子计算机上的每一步可能比经典计算机上的对应步骤慢得多；但这确实是理解在实践中运行不同的量子程序所需条件的一个很好的起点。
- en: '![](../Images/11-11.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-11.png)'
- en: Figure 11.11 Output from estimating the resources required to run Grover's algorithm
    for a variety of different-sized lists
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 估计运行不同大小列表的Grover算法所需的资源输出
- en: We have now learned how to combine the oracles we learned in chapter 7 and a
    new flavor of quantum operation (reflections) to search over the inputs to functions.
    This was helpful in the scenario to help find decryption keys more quickly when
    there is a tight time constraint.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何将我们在第7章中学到的预言机与一种新的量子操作（反射）结合起来，以搜索函数的输入。这在有严格时间约束的场景中非常有用，有助于更快地找到解密密钥。
- en: 'In the next chapter, we’ll use the skills from this chapter to answer one of
    the most important questions posed by quantum computing: how long would it take
    a quantum computer to break modern encryption?'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用本章中学到的技能来回答量子计算提出的最重要问题之一：量子计算机需要多长时间才能破解现代加密？
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Another application for quantum computers is to search inputs to an opaque function
    for an input that produces a desired output (that is, a *marked* input). We can
    use Grover’s algorithm to search using fewer calls to our oracle than is possible
    with classical computing.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子计算机的另一个应用是搜索一个不透明函数的输入，以找到一个产生所需输出的输入（即，一个*标记*输入）。我们可以使用Grover算法通过比经典计算更少的调用我们的预言机来搜索。
- en: Grover’s algorithm uses reflections, quantum operations in which the phase of
    one input state is flipped while all other input states are left unmodified. We
    can build up many different kinds of reflections using rotations together with
    the shoes-and-socks patterns we saw in chapter 8.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grover算法使用反思，这是一种量子操作，其中一个输入状态的相位被翻转，而所有其他输入状态保持不变。我们可以通过旋转以及我们在第8章中看到的鞋袜模式来构建许多不同类型的反思。
- en: Using the various rotations provided by Q# together with `within` and `apply`,
    we can define an oracle that marks a particular item and then reflect about that
    marked item using a single oracle call. Taken together, these techniques let us
    implement Grover’s algorithm.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Q#提供的各种旋转操作，结合`within`和`apply`，我们可以定义一个预言机来标记特定项目，然后通过单个预言机调用对该标记项目进行反思。综合这些技术，我们可以实现Grover算法。
- en: To verify that Grover’s algorithm outperforms classical approaches for large
    enough problems, we can run our Q# program on the resources estimator. Unlike
    the simulator provided with the Quantum Development Kit, the resources estimator
    doesn’t simulate quantum programs but counts how many qubits they require and
    how many operations they would need to call on a quantum device.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了验证Grover算法在足够大的问题上的性能优于经典方法，我们可以在资源估算器上运行我们的Q#程序。与量子开发工具包中提供的模拟器不同，资源估算器并不模拟量子程序，而是计算它们需要多少个量子比特以及它们在量子设备上需要调用多少操作。
