- en: 8 Alternative JVM languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 种替代 JVM 语言
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Language zoology
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言动物学
- en: Why you should use alternative JVM languages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该使用替代 JVM 语言
- en: Selection criteria for alternative languages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代语言的选取标准
- en: How the JVM handles alternative languages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 如何处理替代语言
- en: If you’ve used Java for any sizable amount of work, you’ve probably noticed
    that it can tend toward being a bit verbose and clumsy at times. You may even
    have found yourself wishing that things were different—easier somehow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用 Java 做过任何规模的工作，你可能已经注意到它有时会显得有点冗长和笨拙。你甚至可能发现自己希望事情有所不同——以某种方式变得更容易。
- en: Fortunately, as you’ve seen in the last few chapters, the JVM is awesome—so
    awesome, in fact, that it provides a natural home for programming languages other
    than Java. In this chapter, we’ll show you why and how you might want to start
    mixing another JVM programming language into your project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如你在前几章中看到的，JVM 真的很棒——实际上，它为除了 Java 之外的其他编程语言提供了一个自然的家园。在本章中，我们将向你展示为什么以及如何可能想要将另一种
    JVM 编程语言混合到你的项目中。
- en: In this chapter, we’ll cover ways of describing the different language types
    (such as static versus dynamic typing), why you might want to use alternative
    languages, and what criteria to look for in choosing them. You’ll also be introduced
    to the two languages (Kotlin and Clojure) that we’ll cover in more depth throughout
    the remainder of this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍描述不同语言类型（如静态类型与动态类型）的方法，为什么你可能想要使用替代语言，以及在选择它们时应该寻找哪些标准。你还将被介绍到本书剩余部分我们将更深入探讨的两种语言（Kotlin
    和 Clojure）。
- en: 8.1 Language zoology
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 语言动物学
- en: Programming languages come in many different flavors and classifications. Another
    way of saying this is that a wide range of styles and approaches to programming
    are embodied in different languages. Mastering these different styles is often
    easier when you understand how to classify the differences between languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言有多种不同的风味和分类。另一种说法是，广泛的编程风格和方法体现在不同的语言中。当你了解如何分类语言之间的差异时，掌握这些不同的风格通常更容易。
- en: Note These classifications are an aid to thinking about the diversity of languages.
    Some of these divisions are more clear-cut than others, but none of the classifying
    schemes is perfect. Different people have different ideas about how the classification
    should be laid out.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些分类有助于思考语言的多样性。这些划分中的一些比其他划分更为明确，但没有任何分类方案是完美的。不同的人对如何安排分类有不同的看法。
- en: In recent years, a trend has existed for languages to add features from across
    the spectrum of possibilities. It’s often helpful to think of a given language
    as being “less functional” than another language, or “dynamically typed but with
    optional static typing when needed.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，一种趋势是语言从可能性范围中添加功能。通常，将一种语言视为“比另一种语言功能更少”或“动态类型但在需要时具有可选静态类型”是有帮助的。
- en: The classifications we’ll cover are “interpreted versus compiled,” “dynamic
    versus static,” “imperative versus functional,” and reimplementations of a language
    versus the original. In general, these classifications are tools for thinking
    about the space, rather than complete and precise academic schemes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的分类包括“解释型与编译型”、“动态与静态”、“命令式与函数式”，以及语言的重新实现与原始版本。一般来说，这些分类是思考空间的方法，而不是完整精确的学术方案。
- en: For example, we can say Java is a runtime-compiled, statically typed, imperative
    language with some functional features. It emphasizes safety, code clarity, backward
    compatibility, and performance, and it’s happy to accept a certain amount of verbosity
    and *ceremony* (such as in deployment) to achieve those goals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样说，Java 是一种运行时编译的、静态类型的、命令式语言，并具有一些函数式特性。它强调安全性、代码清晰度、向后兼容性和性能，并且愿意接受一定程度的冗长和*仪式感*（例如在部署中）来实现这些目标。
- en: Note Different languages may have different priorities; for example, dynamically
    typed languages may emphasize deployment speed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：不同的语言可能有不同的优先级；例如，动态类型语言可能强调部署速度。
- en: Let’s get started with the interpreted versus compiled classification.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解释型与编译型分类开始。
- en: 8.1.1 Interpreted vs. compiled languages
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 解释型语言与编译型语言
- en: An *interpreted language* is one in which each step of the source code is executed
    as is, rather than the entire program being transformed to machine code before
    execution begins. This contrasts with a compiled language, which is one that uses
    a compiler to convert the human-readable source code into a binary form as an
    initial task.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释型语言**是一种在执行源代码的每一步时直接执行，而不是在执行开始之前将整个程序转换为机器码的语言。这与编译型语言形成对比，编译型语言使用编译器将人类可读的源代码转换为二进制形式作为初始任务。'
- en: 'This distinction has become less clear recently. In the early ‘90s, the divide
    was fairly clear: C/C++, FORTRAN, and their friends were compiled languages, and
    Perl and Python were interpreted languages. But as we alluded to in chapter 1,
    Java has features of both compiled and interpreted languages. The use of bytecode
    further muddies the issue. Bytecode is certainly not human readable, but neither
    is it machine code.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别最近变得不那么明显了。在20世纪90年代初，这种划分相当清晰：C/C++、FORTRAN及其朋友是编译型语言，而Perl和Python是解释型语言。但正如我们在第一章中提到的，Java具有编译型和解释型语言的特点。字节码的使用进一步模糊了这个问题。字节码当然不是人类可读的，但也不是机器码。
- en: For the JVM languages we’ll study in this part of the book, the distinction
    we’ll make is whether the language produces a class file from the source code
    and executes that—or not. In the latter case, an interpreter (probably written
    in Java) is used to execute the source code, line by line. Some languages provide
    both a compiler and an interpreter, and some provide an interpreter and a just-in-time
    (JIT) compiler that will emit JVM bytecode.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将研究JVM语言，我们将区分语言是否从源代码生成类文件并执行它。在后一种情况下，使用解释器（可能用Java编写）逐行执行源代码。一些语言提供编译器和解释器，而一些语言提供解释器和即时（JIT）编译器，该编译器将生成JVM字节码。
- en: 8.1.2 Dynamic vs. static typing
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 动态类型与静态类型
- en: 'In languages with dynamic typing, a variable can contain different types at
    different times during a program’s execution. As an example, let’s look at a simple
    bit of code in a well-known dynamic language, JavaScript. This example should
    hopefully be comprehensible, even if you don’t know the language in detail:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态类型语言中，一个变量可以在程序执行的不同时间包含不同的类型。作为一个例子，让我们看看一个在知名动态语言JavaScript中的简单代码片段。希望这个例子即使你不详细了解该语言也能理解：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `var` keyword used here creates a new variable. In JavaScript’s dynamic
    type system, this variable can contain a value of any type. This variable starts
    off set to `40`, which is, of course, a numeric value. We then add `2` to it,
    giving `42`. Then we change track slightly and make `answer` hold a string value.
    This is a common technique in a dynamic language, and it causes no syntax errors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`var`关键字创建了一个新变量。在JavaScript的动态类型系统中，这个变量可以包含任何类型的值。这个变量最初被设置为`40`，当然是一个数值。然后我们向它添加`2`，得到`42`。然后我们稍微改变一下方向，让`answer`持有字符串值。这在动态语言中是一种常见的技术，并且不会引起语法错误。
- en: The JavaScript interpreter is also able to distinguish between the two uses
    of the `+` operator. The first use of `+` is numeric addition— adding `2` to `40`—whereas
    in the following line, the interpreter figures out from context that the developer
    meant string concatenation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript解释器也能够区分`+`操作符的两种用法。`+`的第一个用法是数值加法——将`2`加到`40`上——而在下一行中，解释器根据上下文推断出开发者意图进行字符串连接。
- en: 'Let’s try this trick again in Java using JShell:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Java中使用JShell再次尝试这个技巧：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Boom. Even though the exact same source code looked legal in both languages,
    Java’s *static type system* prevented the final line from working. Java’s `var`
    keyword does more than simply create the variable `answer`. As we learned in section
    1.3, Java’s `var` also inferred the type of this new variable from the right-hand
    side of the expression. We didn’t have to specify the type of `answer` explicitly,
    but Java’s static type system assigns a type that never subsequently changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 哗啦。尽管在两种语言中，完全相同的源代码看起来都是合法的，但Java的**静态类型系统**阻止了最后一行代码的执行。Java的`var`关键字不仅仅创建了一个名为`answer`的变量。正如我们在1.3节中学到的，Java的`var`还会从表达式的右侧推断出这个新变量的类型。我们不必显式指定`answer`的类型，但Java的静态类型系统会分配一个永远不会改变的类型。
- en: Note The key point here is that dynamic typing tracks type information with
    the *value* a variable contains (e.g., a number or a string), where static typing
    tracks the type with the *variable* definition instead.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这里的关键点是，动态类型跟踪变量包含的**值**（例如，数字或字符串）的类型信息，而静态类型跟踪的是**变量定义**的类型信息。
- en: Static typing can be a good fit for a compiled language because the type information
    is all about the variables, not the values in them. This allows reasoning about
    potential type system violations at compile time, before the code even has a chance
    to run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型对于编译型语言来说是一个很好的匹配，因为类型信息全部关于变量，而不是变量中的值。这允许在代码甚至有机会运行之前，在编译时对潜在的类型系统违规进行推理。
- en: Dynamically typed languages carry type information on the values held in variables.
    This provides a lot of flexibility but means type violations (e.g., “I thought
    this was a number, but it’s a string”) happen during execution. This can lead
    to more runtime errors, which can be harder and more expensive to debug than compile-time
    errors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型语言在变量持有的值上携带类型信息。这提供了很多灵活性，但意味着类型违规（例如，“我以为这是一个数字，但它是一个字符串”）会在执行期间发生。这可能导致更多的运行时错误，这些错误可能比编译时错误更难调试且成本更高。
- en: 8.1.3 Imperative vs. functional languages
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 命令式与函数式语言
- en: Java is a classic example of an imperative language. Imperative languages can
    be thought of as languages that model the running state of a program as mutable
    data and issue a list of instructions that transform that running state. Program
    state is thus the concept that has center stage in imperative languages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种命令式语言的经典例子。命令式语言可以被视为将程序的运行状态建模为可变数据并发布一系列指令以转换该运行状态的语言。因此，程序状态是命令式语言中占据中心舞台的概念。
- en: Two main subtypes of imperative languages exist. Procedural languages, such
    as BASIC and FORTRAN, treat code and data as completely separate and have a simple
    code-operates-on-data paradigm. The other subtype is object-oriented (OO) languages,
    where data and code (in the form of methods) are bundled together into objects.
    The program state in an object-oriented system is the state of all the objects
    in the program. In OO languages, additional structure is imposed to a greater
    or lesser degree by metadata (such as class information). The differences between
    these subtypes, though, may not always be clear. C++, for instance, is explicitly
    intended to support both OO and procedural coding, and some later varieties of
    BASIC sport object-oriented features.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式语言存在两种主要子类型。过程式语言，如BASIC和FORTRAN，将代码和数据视为完全分离的，并具有简单的代码操作数据范式。另一种子类型是面向对象（OO）语言，其中数据和代码（以方法的形式）捆绑在一起形成对象。面向对象系统中的程序状态是程序中所有对象的状态。在OO语言中，通过元数据（如类信息）在更大或更小的程度上强加了额外的结构。然而，这些子类型之间的差异可能并不总是清晰的。例如，C++明确旨在支持OO和过程式编码，而一些BASIC的后期版本也具有面向对象的功能。
- en: '*Functional languages* take the view that computation itself is the most important
    concept. Functions operate on values, as in procedural languages, but instead
    of altering their inputs, functions are seen as acting like mathematical functions
    and return new values. Composing separate functions together in new and novel
    ways is also fundamental in this model.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式语言*认为计算本身是最重要的概念。函数在值上操作，就像过程式语言一样，但与改变它们的输入不同，函数被视为像数学函数一样行动，并返回新的值。以新的和独特的方式组合不同的函数也是这种模型的基本内容。'
- en: As illustrated in figure 8.1, functions are seen as “little processing machines”
    that take in values and output new values. They don’t have any state of their
    own, and it doesn’t really make sense to bundle them up with any external state.
    The object- centered view of the world is somewhat at odds with the natural viewpoint
    of functional languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 8.1 所示，函数被视为“小处理机”，它们接受值并输出新的值。它们没有自己的状态，将它们与任何外部状态捆绑在一起实际上并不合理。以对象为中心的世界观与函数式语言的自然观点有些不一致。
- en: '![](../Images/CH08_F01_Evans2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F01_Evans2.png)'
- en: Figure 8.1 Imperative and functional languages
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 命令式与函数式语言
- en: A key feature of functional languages is *first-class functions*—the ability
    to treat a function as a value, assigning it to variables, passing it to other
    functions, and even returning functions from other functions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言的一个关键特性是*一等函数*——将函数视为值的能力，将其分配给变量，传递给其他函数，甚至从其他函数返回函数。
- en: This is a great example of the feature spectrum we discussed earlier, because
    Java 8 added the lambda expression syntax, which enables Java programmers to treat
    functions as value. However, as a recent addition, the feature isn’t used everywhere
    it could be in the platform, and older techniques for getting similar behavior,
    such as the `Runnable` and `Callable` interfaces, remain in use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们之前讨论过的功能谱系的绝佳例子，因为 Java 8 添加了 lambda 表达式语法，这使得 Java 程序员可以将函数视为值。然而，作为一个较新的特性，这个特性并没有在平台的所有可能位置使用，而且用于获得类似行为的旧技术，如
    `Runnable` 和 `Callable` 接口，仍然在使用中。
- en: In the next two chapters we’ll learn about different languages, and a key focus
    will be on how they support functional programming approaches. With Kotlin, we’ll
    see how even an imperative language can be designed to smoothly support functional
    ideas. Then we’ll look at Clojure, a much purer functional language that no longer
    centers on object orientation at all.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将学习不同的语言，一个关键焦点将是它们如何支持函数式编程方法。使用 Kotlin，我们将看到即使是命令式语言也可以被设计成平滑地支持函数式思想。然后我们将探讨
    Clojure，这是一种更加纯粹的函数式语言，它根本不再以面向对象为中心。
- en: 8.1.4 Reimplementation vs. original
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4 重新实现与原始版本
- en: Another important distinction between JVM languages is the division into those
    that are reimplementations of existing languages versus those that were specifically
    written to target the JVM. In general, languages that were specifically written
    to target the JVM provide a much tighter binding between their type systems and
    the native types of the JVM.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 语言之间的另一个重要区别是，将它们分为现有语言的重新实现和专门为 JVM 编写的语言。一般来说，专门为 JVM 编写的语言在其类型系统和 JVM
    的原生类型之间提供了更紧密的绑定。
- en: 'The following three languages are JVM reimplementations of existing languages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三种语言是现有语言的 JVM 重新实现：
- en: '*JRuby* is a JVM reimplementation of the Ruby programming language. Ruby is
    a dynamically typed OO language with some functional features. It’s basically
    interpreted on the JVM, but recent versions have included a runtime JIT compiler
    to produce JVM bytecode under favorable conditions.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JRuby* 是 Ruby 编程语言的 JVM 重新实现。Ruby 是一种动态类型面向对象语言，并具有一些函数式特性。它基本上是在 JVM 上进行解释，但最近版本已经包含了一个运行时
    JIT 编译器，在有利条件下可以生成 JVM 字节码。'
- en: '*Jython* was started in 1997 by Jim Hugunin as a way to use high-performance
    Java libraries from Python. It’s a reimplementation of Python on the JVM, so it’s
    a dynamic, mostly OO language. It operates by generating internal Python bytecode,
    then translating that to JVM bytecode. Sadly, the project has seen little activity
    since 2015 and supports only Python 2.7, not the current Python 3.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jython* 是由 Jim Hugunin 于 1997 年启动的，作为一种使用高性能 Java 库的方式。它是在 JVM 上对 Python 的重新实现，因此它是一种动态的、主要是面向对象的语言。它通过生成内部
    Python 字节码，然后将其转换为 JVM 字节码来运行。遗憾的是，自 2015 年以来，该项目活动很少，并且只支持 Python 2.7，不支持当前的
    Python 3。'
- en: '*Rhino* was originally developed by Netscape and later the Mozilla project.
    It provided an implementation of JavaScript on the JVM and shipped up through
    JDK.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Rhino* 最初由 Netscape 开发，后来由 Mozilla 项目继续开发。它提供了 JVM 上的 JavaScript 实现，并一直随着
    JDK 一起发布。'
- en: JDK 8 included a new JavaScript engine, *Nashorn* (The name “Nashorn” is a bit
    of a pun—it’s the German word for “Rhino”), but the increasing pace of JavaScript
    language changes forced its deprecation with JDK 11 and removal in JDK 15\. Although
    no JavaScript implementation will ship directly with future JDKs, both may still
    be found independently. (Rhino from Mozilla ([https://github.com/mozilla/rhino](https://github.com/mozilla/rhino))
    and Nashorn ([https://openjdk.java.net/projects/nashorn/](https://openjdk.java.net/projects/nashorn/))
    as an independent OpenJDK project, which intends to live on and should be supported
    on future JDKs.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8 包含了一个新的 JavaScript 引擎，*Nashorn*（“Nashorn”这个名字有点双关——它是德语中“犀牛”的意思），但随着 JavaScript
    语言变化的加速，它被迫在 JDK 11 中弃用，并在 JDK 15 中移除。尽管未来的 JDK 不会直接提供 JavaScript 实现，但它们仍然可以独立找到。（Mozilla
    的 Rhino ([https://github.com/mozilla/rhino](https://github.com/mozilla/rhino)）和
    Nashorn ([https://openjdk.java.net/projects/nashorn/](https://openjdk.java.net/projects/nashorn/))
    作为独立的 OpenJDK 项目，它打算继续存在，并且应该在未来的 JDK 中得到支持。
- en: NOTE The earliest JVM language? The earliest non-Java JVM language is hard to
    pin down. Certainly, Kawa, an implementation of Lisp, dates to 1997 or so. In
    the years since then, we’ve seen an explosion of languages, to the point that
    it’s almost impossible to keep track of them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：最早的 JVM 语言？最早的非 Java JVM 语言难以确定。当然，Kawa（Lisp 的一个实现）可以追溯到 1997 年左右。从那时起，我们看到了语言的爆炸性增长，以至于几乎不可能跟踪它们。
- en: A reasonable guess at the time of writing is that at least 200 languages target
    the JVM. Not all can be considered to be active or widely used (and some are really
    very niche), but the large number indicates that the JVM is a very active platform
    for language development and implementation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，一个合理的猜测是至少有200种语言针对JVM。并非所有都可以被认为是活跃的或广泛使用的（有些实际上非常细分），但大量表明JVM是一个非常活跃的语言开发和实现平台。
- en: Note In the versions of the language and VM spec that debuted with Java 7, all
    direct references to the Java language have been removed from the VM spec. Java
    is now simply one language among many that run on the JVM—it no longer enjoys
    a privileged status.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Java 7发布时首次亮相的语言和VM规范版本中，所有直接引用Java语言的条目都已从VM规范中删除。Java现在只是许多在JVM上运行的许多语言之一——它不再享有特权地位。
- en: The key piece of technology that enables so many different languages to target
    the JVM is the class file format, as we discussed in chapter 4\. Any language
    that can produce a class file is considered a compiled language on the JVM.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使许多不同语言能够针对JVM的关键技术是类文件格式，正如我们在第4章中讨论的那样。任何可以生成类文件的语言都被认为是JVM上的编译语言。
- en: Let’s move on to discuss how polyglot programming came to be an area of interest
    for Java programmers. We’ll explain the basic concepts and why and how to choose
    an alternative JVM language for your project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论多语言编程如何成为Java程序员感兴趣的一个领域。我们将解释基本概念以及为什么以及如何为您的项目选择替代JVM语言。
- en: 8.2 Polyglot programming on the JVM
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 JVM上的多语言编程
- en: The phrase *polyglot programming on the JVM* was coined to describe projects
    using one or more non-Java JVM languages alongside a core of Java code. One common
    way to think about polyglot programming is as a form of separation of concerns.
    As you can see in figure 8.2, potentially three layers exist where non-Java technologies
    can play a useful role. This diagram is sometimes called the polyglot programming
    pyramid, and it’s originally due to the work of Ola Bini ([https://olabini.com/blog/tag/polyglot/](https://olabini.com/blog/tag/polyglot/)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “在JVM上使用多语言编程”这个短语被用来描述使用一个或多个非Java JVM语言与Java代码核心一起使用的项目。思考多语言编程的一种常见方式是作为一种关注点分离的形式。如图8.2所示，可能存在三个层次，其中非Java技术可以发挥有用的作用。这个图表有时被称为多语言编程金字塔，它最初归功于Ola
    Bini的工作（[https://olabini.com/blog/tag/polyglot/](https://olabini.com/blog/tag/polyglot/))）。
- en: '![](../Images/CH08_F02_Evans2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F02_Evans2.png)'
- en: Figure 8.2 The polyglot programming pyramid
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 多语言编程金字塔
- en: Within the pyramid, dependencies run in one direction—the stable layer is relatively
    independent, the dynamic layer uses the stable, and domain-specific code can pull
    in from both layers below it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔中，依赖关系只有一个方向——稳定层相对独立，动态层使用稳定层，领域特定代码可以从其下两个层中拉取。
- en: Defining these layers in a given system isn’t always easy; gray areas exist,
    and not all systems fit perfectly. However, it’s a useful tool to identify the
    seams where different parts of the system have different needs and could benefit
    from different languages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的系统中定义这些层并不总是容易的；存在灰色区域，并非所有系统都完美匹配。然而，这是一个有用的工具，可以识别不同部分系统有不同的需求，并可能从不同的语言中受益的接缝。
- en: The stable layer contains core APIs and abstractions for your system. Type safety,
    thorough testing, and performance are all critical.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定层包含您系统的核心API和抽象。类型安全、彻底的测试和性能都是至关重要的。
- en: The dynamic layer uses the stable layer’s abstractions to create a working system.
    This may include code such as how a system exposes itself over HTTP or interacts
    with other backend systems. Issues like compilation time and flexibility may make
    it worth considering a different language at the dynamic layer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 动态层使用稳定层的抽象来创建一个工作系统。这可能包括如何一个系统通过HTTP公开自己或与其他后端系统交互的代码。编译时间和灵活性等问题可能使考虑在动态层使用不同的语言变得值得。
- en: The domain-specific layer handles application-specific concerns such as presentation,
    customization of rules and processing, or CI/CD. This code is all about specific
    aspects of the application domain and may benefit from language choices that would
    be constraining in other layers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定层处理特定于应用程序的关注点，例如展示、规则定制和处理的定制，或CI/CD。这段代码完全关于应用程序领域的特定方面，可能从其他层中约束性的语言选择中受益。
- en: Note Polyglot programming makes sense because different pieces of code have
    different lifetimes. A risk calculation engine in a bank may last for five or
    more years. JSP pages for a website could last for a few months. The most short-lived
    code for a startup could be live for just a few days. The longer the code lives,
    the closer to the stable layer of the pyramid it is. See table 8.1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：多语言编程是有意义的，因为不同的代码片段有不同的生命周期。银行中的风险计算引擎可能持续五年或更长时间。网站上的JSP页面可能持续几个月。初创公司中最短命的代码可能只存活几天。代码存活的时间越长，就越接近金字塔的稳定层。参见表8.1。
- en: Table 8.1 Three layers of the polyglot programming pyramid
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 多语言编程金字塔的三个层级
- en: '| Name | Description | Examples |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Domain-specific | Domain-specific language. Tightly coupled to a specific
    part of the application domain | Apache Camel, DSLs, Drools, web templating |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 领域特定 | 领域特定语言。紧密耦合到应用程序的特定部分 | Apache Camel, DSLs, Drools, 网页模板 |'
- en: '| Dynamic | Rapid, productive, flexible development of functionality | Clojure,
    Groovy, JRuby |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 动态 | 功能的快速、高效、灵活的开发 | Clojure, Groovy, JRuby |'
- en: '| Stable | Core functionality, stable, well-tested, performant | Java, Kotlin,
    Scala |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 稳定 | 核心功能，稳定，经过充分测试，性能良好 | Java, Kotlin, Scala |'
- en: As you can see, patterns occur in the layers—the statically typed languages
    tend to gravitate toward tasks in the stable layer. Conversely, the technologies
    intended for more of a specific purpose tend to be well-suited to roles at the
    top of the pyramid.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，模式出现在层级中——静态类型语言倾向于向稳定层任务靠拢。相反，针对更具体目的的技术往往非常适合金字塔顶部的角色。
- en: Let’s dig a little deeper to look at why Java isn’t the best choice for everything
    in the pyramid. We’ll begin by discussing why you should consider a non-Java language,
    and then we’ll cover some of the major criteria to look at in choosing a non-Java
    language for your project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下为什么Java不是金字塔中所有事物的最佳选择。我们将从讨论为什么你应该考虑使用非Java语言开始，然后我们将讨论在选择非Java语言时需要考虑的一些主要标准。
- en: 8.2.1 Why use a non-Java language?
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 为什么使用非Java语言？
- en: 'Java’s nature as a general-purpose, statically typed, compiled language provides
    many advantages. These qualities make it a great choice for implementing functionality
    in the stable layer. But these same attributes become a burden in the upper tiers
    of the pyramid, as described here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java作为通用、静态类型、编译型语言的本质提供了许多优势。这些品质使其成为在稳定层实现功能的一个很好的选择。但正如这里所描述的，这些相同的属性在金字塔的上层成为负担：
- en: Recompilation is laborious.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编译是费时的。
- en: Static typing can be inflexible.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型可能不够灵活。
- en: Deployment is a heavyweight process.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署是一个重量级的过程。
- en: Java’s syntax can be rigid and isn’t a natural fit for producing DSLs.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的语法可能很严格，并且不适合产生领域特定语言（DSL）。
- en: The recompilation and rebuild time of a Java project often reaches the 90 seconds
    to two-minute mark. This is a long enough to seriously break a developers’ flow,
    and it’s a bad fit for developing code that may live in production for only a
    few weeks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Java项目的重新编译和重建时间通常达到90秒到两分钟。这已经足够长，足以严重破坏开发者的工作流程，而且对于可能只在生产环境中存活几周的项目来说，这不是一个好的选择。
- en: Java’s rigid syntax
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Java的严格语法
- en: The Java language has a very rigid grammar. The fundamental language components
    are the keywords that are supplied. You cannot “make up new syntax” or create
    any new form that could be mistaken for a keyword.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言具有非常严格的语法。基本语言组件是提供的关键字。你不能“创造新的语法”或创建任何可能被误认为是关键字的新的形式。
- en: 'The programmer can create new classes, and the capabilities of those classes
    consist of storing state in fields and calling methods on classes or objects.
    However, this is as far as it goes—the programmer cannot create anything that
    resembles a control structure. In other words, a field access will always look
    like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以创建新的类，这些类的功能包括在字段中存储状态以及在类或对象上调用方法。然而，这仅限于此——程序员不能创建任何类似控制结构的任何东西。换句话说，字段访问将始终看起来像以下这样：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And a method call will always look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用将始终看起来像这样：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Java, the method parameters are never optional (unlike in some other languages,
    such as Kotlin), so even the distinction between field access and methods calls
    cannot be blurred. For example, we cannot create constructs that look like keywords.
    For instance, we’d like to be able to create a `when` that looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，方法参数从不可选（与某些其他语言不同，如Kotlin），因此即使在字段访问和方法调用之间也不能模糊界限。例如，我们不能创建看起来像关键字的结构。例如，我们希望能够创建一个类似于以下的`when`：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But the best we can do is something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们能做到的最好的事情可能就像这样：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This lack of redefinable syntax also shows up when trying to use Java to make
    DSLs. We’ll see how our non-Java languages handle this issue in the next two chapters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不可重定义的语法在尝试使用Java创建领域特定语言（DSL）时也会显现出来。我们将在下一章中看到我们的非Java语言如何处理这个问题。
- en: Overall, one pragmatic solution is to play to Java’s strengths. Take advantage
    of its rich API and library support to do the heavy lifting for the application
    down in the stable layer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，一个实用的解决方案是发挥Java的优势。利用其丰富的API和库支持，在稳定层中为应用程序做大量工作。
- en: 'Even within the stable layer you may find there are reasons a language other
    than Java may be desirable, such as the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在稳定层内，你也可能发现除了Java之外的其他语言可能更受欢迎，例如以下情况：
- en: Java’s verbosity can be off-putting for some developers, and it can hide certain
    classes of bugs.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的冗长可能会让一些开发者望而却步，它也可能隐藏某些类别的错误。
- en: Although Java increasingly supports functional programming, limits in the ease
    of applying some patterns remain.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管Java越来越多地支持函数式编程，但应用某些模式仍然存在限制。
- en: Other languages present alternatives for concurrency that are not present in
    Java (coroutines in Kotlin, agents in Clojure).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他语言提供了Java中不存在的并发解决方案（Kotlin中的协程，Clojure中的代理）。
- en: Note Even if you choose another language to use in your stable layer for features
    it supports, you shouldn’t throw out working code just to rewrite it so the languages
    match. Consider using the new language for new features or for low-risk areas
    we’ll talk about identifying later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：即使你选择另一种语言来支持你的稳定层中的功能，也不应该为了使语言匹配而丢弃现有的代码。考虑使用新语言来添加新功能或低风险区域，我们将在本章后面讨论如何识别这些区域。
- en: At this point, you may be asking yourself, What type of programming challenges
    fit inside these layers? Which languages should I choose? A well-grounded Java
    developer knows that there is no silver bullet, but we do have criteria to consider
    when evaluating your choices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能正在自问，哪些类型的编程挑战适合这些层级？我应该选择哪种语言？一个经验丰富的Java开发者知道没有一劳永逸的解决方案，但我们确实有一些标准来评估你的选择。
- en: 8.2.2 Up-and-coming languages
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 新兴语言
- en: For the rest of the book, we’ve picked two languages that we see having great
    potential longevity and influence. These are two of the languages on the JVM (Kotlin
    and Clojure) that already have well-established mind share among polyglot programmers.
    Why are these languages gaining traction? Let’s look at each in turn.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们选择了两种我们认为具有巨大潜力和影响力的语言。这两种语言都是运行在JVM上的（Kotlin和Clojure），在多语言程序员中已经建立了良好的认知度。为什么这些语言会受到青睐？让我们逐一分析。
- en: Kotlin
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin
- en: Kotlin is an imperative, static-typed, OO language from JetBrains (makers of
    IntelliJ IDEA). It aims to address the most common complaints about Java, while
    keeping a familiar development environment. Kotlin is a compiled language and
    has a high degree of compatibility beyond the basics that just running on the
    JVM provides.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是由JetBrains（IntelliJ IDEA的制作者）开发的一种命令式、静态类型、面向对象的编程语言。它的目标是解决Java最常见的问题，同时保持熟悉的开发生态。Kotlin是一种编译型语言，它提供了比仅运行在JVM上更高级别的兼容性。
- en: Key features in Kotlin include concise syntax, `null` safety, extremely strong
    interoperability with Java code, and coroutines—an alternate concurrency mechanism
    to Java’s traditional threading model. A number of features from Kotlin have found
    their way back into Java in recent releases, confirming the value those changes
    presented to developers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的关键特性包括简洁的语法、`null`安全性、与Java代码的极强互操作性，以及协程——一种Java传统线程模型的替代并发机制。Kotlin的一些特性已经在最近的Java版本中得到了应用，这证实了这些变化对开发者带来的价值。
- en: Although it has established itself as a key JVM language option in multiple
    areas, Kotlin has shown particular success in mobile, with the Android platform
    adopting it as the recommended language in 2019\. Kotlin is also supported for
    Gradle build scripting at the same level as Groovy. It’s also been embraced by
    many other frameworks, such as Spring. The wide range of convenience and safety
    improvements for developers are worth considering regardless of where your JVM
    is running. Chapter 9 gives an introduction to Kotlin.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它在多个领域确立了自身作为关键JVM语言选项的地位，但Kotlin在移动领域取得了特别的成功，2019年，Android平台将其作为推荐语言采用。Kotlin也支持与Groovy相同的级别用于Gradle构建脚本。它还被许多其他框架所接受，例如Spring。无论您的JVM运行在何处，开发者广泛的安全性和便利性改进都值得考虑。第9章介绍了Kotlin。
- en: Kotlin will be used in chapter 11 as the primary scripting language for Gradle
    builds. We will also revisit it to demonstrate some unique approaches to functional
    programming in chapter 15 and concurrent programming (coroutines) in chapter 16\.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kotlin将在第11章中作为Gradle构建的主要脚本语言使用。我们还将重新审视它，以展示第15章中函数式编程的独特方法以及第16章中的并发编程（协程）。 '
- en: Clojure
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure
- en: Clojure, designed by Rich Hickey, is a language from the Lisp family. It inherits
    many syntactic features (and lots of parentheses) from that heritage. It’s a dynamically
    typed, functional language, as is usual for Lisps. It’s a compiled language but
    usually distributes code in source form for reasons we’ll see later. It also adds
    a significant number of new features (especially in the arena of concurrency)
    to its Lisp core.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure，由Rich Hickey设计，是一种Lisp家族的语言。它继承了该遗产的许多语法特性（以及大量的括号）。它是一种动态类型、函数式语言，这与Lisp的常规做法一致。它是一种编译型语言，但通常以源代码形式分发，原因我们稍后会看到。它还为其Lisp核心添加了大量的新特性（特别是在并发领域）。
- en: Lisps are usually seen as experts-only languages. Clojure is somewhat easier
    to learn than other Lisps, yet it still provides the developer with formidable
    power (and also lends itself very nicely to the test-driven development style).
    But it’s likely to remain outside the mainstream, being primarily used by enthusiasts
    and for specialized jobs (e.g., some financial applications find its combination
    of features very appealing).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp通常被视为专家语言。Clojure比其他Lisp更容易学习，但仍为开发者提供了强大的功能（并且非常适合测试驱动开发风格）。但它可能仍然处于主流之外，主要用于爱好者以及一些专业工作（例如，一些金融应用发现其功能组合非常吸引人）。
- en: Clojure is best thought of as sitting in the dynamic layer but, due to its concurrency
    support and other features, can be seen as capable of performing many of the roles
    of a stable layer language. Chapter 10 provides an introduction to Clojure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure最好将其视为位于动态层，但由于其并发支持和其他特性，它也可以被视为能够执行稳定层语言的大部分角色。第10章介绍了Clojure。
- en: We will use Clojure extensively in learning more about functional programming
    beyond what Java can do in chapter 15\. It will also feature in introducing the
    actor model, a powerful alternative in concurrent programming in chapter 16\.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第15章中广泛使用Clojure来学习关于函数式编程的知识，这些知识超出了Java的能力。它还将出现在第16章中介绍演员模型，这是并发编程中的一个强大替代方案。
- en: 8.2.3 Languages we could have picked but didn’t
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 我们本可以选择但未选择的语言
- en: As noted earlier, a huge variety of languages exist that we could look at. Here’s
    a little more about a few other contenders that may be practical for you to look
    at more deeply yourself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，存在大量我们可以考虑的语言。以下是一些其他可能的竞争者，您可能需要更深入地研究。
- en: Groovy
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy
- en: The Groovy language was invented by James Strachan in 2003\. It’s a dynamic,
    compiled language with syntax very similar to Java’s but more flexible. It’s widely
    used for scripting and testing. It was the original language used by the Gradle
    build tool and is used for configuring Jenkins, an extremely common CI/CD tool.
    It’s often the first non-Java language that developers or teams investigate on
    the JVM. Groovy can be seen as sitting in the dynamic layer and is also known
    for being great for building DSLs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy语言是由James Strachan于2003年发明的。它是一种动态、编译型语言，语法与Java非常相似，但更灵活。它被广泛用于脚本和测试。它是Gradle构建工具的原始语言，也用于配置Jenkins，这是一种极其常见的CI/CD工具。它通常是开发人员或团队在JVM上调查的第一种非Java语言。Groovy可以被视为位于动态层，并且也因其非常适合构建领域特定语言（DSLs）而闻名。
- en: We’ve chosen not to cover Groovy in more detail because it has seen declining
    mindshare in the prototyping and application use cases in the face of improving
    frameworks and other languages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择不更详细地介绍 Groovy，因为在框架和其他语言的改进面前，它在原型设计和应用程序使用案例中的市场份额正在下降。
- en: Scala
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Scala
- en: Scala is an OO language that also supports many aspects of functional programming.
    It traces its origins to 2003, when Martin Odersky began work on it in an academic
    setting, following his earlier projects related to generics in Java. It’s a statically
    typed, compiled language like Java, and it performs a large amount of type inference,
    so it often has the feel of a dynamic language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种支持许多函数式编程方面的面向对象语言。它的起源可以追溯到 2003 年，当时马丁·奥德斯基在学术环境中开始研究它，这是在他之前与 Java
    泛型相关项目之后。它是一种类似于 Java 的静态类型、编译型语言，并且执行大量的类型推断，因此它通常给人一种动态语言的感觉。
- en: Scala learned a great deal from Java, and its language design “fixes” several
    common annoyances with Java. However, Scala has ended up with a very large set
    of features, though, and a much more advanced type system compared to Java’s.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 从 Java 中学到了很多，其语言设计“修复”了 Java 中一些常见的烦恼。然而，Scala 最终拥有一个非常大的功能集，与 Java 相比，它有一个更先进的类型系统。
- en: It can be complicated to program and is not easy to learn thoroughly. As such
    we’ve chosen to focus on Kotlin for developers who just want improvements to the
    state of the Java language.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编程可能很复杂，而且不容易彻底学习。因此，我们选择专注于 Kotlin，为那些只想改进 Java 语言状态的开发者。
- en: GraalVM
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM
- en: Oracle Labs have produced GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/)),
    which they describe as a polyglot virtual machine and platform that is partly
    derived from Java and JVM codebases. The current release includes the capability
    to run Java and other JVM languages (as bytecode) as well as support for JavaScript
    and LLVM bitcode (the intermediate representation from the popular LLVM compiler),
    with beta support for Ruby, Python, R, and WASM.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Labs 开发了 GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/))，他们将其描述为部分源自
    Java 和 JVM 代码库的多语言虚拟机和平台。当前版本包括运行 Java 和其他 JVM 语言（作为字节码）以及支持 JavaScript 和 LLVM
    位码（来自流行的 LLVM 编译器的中间表示），并提供 Ruby、Python、R 和 WASM 的测试版支持。
- en: 'The overall platform comprises the following components:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 整个平台包括以下组件：
- en: Java HotSpot VM
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java HotSpot 虚拟机
- en: A Node.js JavaScript runtime environment
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js JavaScript 运行时环境
- en: LLVM runtime to execute LLVM bitcode
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 运行时用于执行 LLVM 位码
- en: Graal—a JIT compiler written in Java
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graal——用 Java 编写的 JIT 编译器
- en: Truffle—a toolkit and API for building language interpreters
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Truffle——构建语言解释器的工具包和 API
- en: SubstrateVM—a lightweight execution container for native images
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SubstrateVM——原生图像的轻量级执行容器
- en: Within a GraalVM project, languages can be very freely bridged to each other,
    and the aim is to allow components implemented in different technologies to be
    combined and used in a single application process. This is a very different approach
    to polyglot programming, but it is close enough to the subject of interest that
    we wanted to at least mention it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraalVM 项目中，语言之间可以非常自由地相互桥接，目标是允许使用不同技术实现的组件在单个应用程序过程中组合和使用。这是一种与多语言编程非常不同的方法，但它足够接近我们感兴趣的主题，所以我们至少想提到它。
- en: Non-JVM languages
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 非 JVM 语言
- en: This chapter focuses on alternative languages that run on the JVM. It’s worth
    admitting, though, that sometimes the polyglot programmer may have a reason that
    part of their system needs to leave the JVM behind entirely.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍在 JVM 上运行的替代语言。然而，值得承认的是，有时多语言程序员可能有一个理由，使得他们的系统的一部分需要完全离开 JVM。
- en: 'Examples of technologies which have broader support outside the JVM follow:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在 JVM 之外有更广泛支持的技术的例子：
- en: Native system code (C, Go, or Rust)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生系统代码（C、Go 或 Rust）
- en: Machine learning (Python)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习（Python）
- en: Run in a user’s web browser (JavaScript)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户的网络浏览器中运行（JavaScript）
- en: Although JVM-based approaches exist for many of these, it’s worth taking stock
    of the maturity of alternatives and the composition of our team before trying
    to keep every line of code entirely on the JVM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于这些中的许多都有基于 JVM 的方法，但在尝试将每一行代码完全保留在 JVM 上之前，评估替代方案的成熟度和我们团队的构成是值得的。
- en: Now that we’ve outlined some possible choices, let’s discuss the issues that
    should drive your decision of which language to choose.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了一些可能的选择，让我们讨论应该驱动您选择哪种语言的决策问题。
- en: 8.3 How to choose a non-Java language for your project
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 如何为您的项目选择非 Java 语言
- en: Once you’ve decided to experiment with non-Java languages in your project, you
    need to identify which parts of your project naturally fit into the stable, dynamic,
    or domain-specific layers. Table 8.2 highlights tasks that might be suitable for
    each layer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定在项目中尝试使用非Java语言，您需要确定哪些项目部分自然适合稳定、动态或特定领域的层。表8.2突出了可能适合每一层的任务。
- en: Table 8.2 Project areas suited for domain-specific, dynamic, and stable layers
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2适用于特定领域、动态和稳定层的项目领域
- en: '| Name | Example problem domains |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 示例问题领域 |'
- en: '| --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Domain-specificDomain-specific areas often benefit from readability by experts
    who may not know Java. Software life cycle tooling also frequently has domain-specific
    languages and configuration. | Build, continuous integration, continuous deploymentDev-opsBusiness
    rules modeling |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 特定领域特定领域通常受益于专家的可读性，这些专家可能不知道Java。软件生命周期工具也经常有特定领域的语言和配置。 | 构建、持续集成、持续部署Dev-ops业务规则建模
    |'
- en: '| DynamicDynamic layers of the system may benefit from greater flexibility
    and speed of development available in other languages. This may be especially
    true for tooling that is internally facing (testing and administrative). | Rapid
    web developmentPrototypingInteractive administrative and user consolesScriptingTesting
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 动态动态层的系统可能从其他语言中可用的更大灵活性和开发速度中受益。这尤其适用于内部面向的工具（测试和管理）。 | 快速Web开发原型交互式管理和用户控制台脚本测试
    |'
- en: '| StableStable layer code expresses a system’s core abstractions. More rigorous
    type safety and testing are worth the additional developer overhead. | Concurrent
    codeApplication containersCore business functionality |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 稳定稳定层的代码表达了系统的核心抽象。更严格的数据类型安全和测试值得额外的开发者开销。 | 并发代码应用容器核心业务功能 |'
- en: 'As you can see, a wide range of use cases for alternative languages exists.
    But identifying a task that could be resolved with an alternative language is
    just the beginning. You next need to evaluate whether using an alternative language
    is appropriate. Here are some useful criteria that we take into account when considering
    technology stacks:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，存在广泛的使用替代语言用例。但确定可以用替代语言解决的问题只是开始。接下来，您需要评估使用替代语言是否合适。以下是我们考虑技术堆栈时考虑的一些有用标准：
- en: Is the project area low-risk?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目领域是否存在低风险？
- en: How easily does the language interoperate with Java?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该语言与Java的互操作性如何？
- en: What tooling support (e.g., IDE support) is there for the language?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该语言有哪些工具支持（例如，IDE支持）？
- en: How steep is the learning curve for this language?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习这门语言的曲线陡峭吗？
- en: How easy is it to hire developers with experience in this language?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 招聘具有该语言经验的开发人员有多容易？
- en: Let’s dive into each of these areas so you get an idea of the sorts of questions
    you need to be asking.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些领域，以便您了解需要提出哪些类型的问题。
- en: 8.3.1 Is the project area low-risk?
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 项目领域是否存在低风险？
- en: Let’s say you have a core payment-processing rules engine that handles millions
    of transactions a day. This is a stable piece of Java software that has been around
    for over seven years, but there aren’t a lot of tests and plenty of dark corners
    are present in the code. The core of the payment-processing engine is clearly
    a high-risk area to bring a new language into, especially when it’s running successfully
    and there’s a lack of test coverage and of developers who fully understand it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个核心支付处理规则引擎，每天处理数百万笔交易。这是一块稳定的Java软件，已经存在超过七年，但测试不多，代码中存在许多暗角。支付处理引擎的核心显然是一个高风险区域，引入新语言，尤其是在它运行成功且缺乏测试覆盖和完全理解它的开发者时。
- en: But there’s more to a system than its core processing. For example, this is
    a situation where better tests would clearly help. Kotlin has a number of good
    options, including the Spek framework ([https://www.spekframework.org/](https://www.spekframework.org/))
    and Kotest ([https://kotest.io](https://kotest.io)), which leverage the language
    to enable clear, readable specifications without the typical JUnit boilerplate.
    Or perhaps your rules engine would benefit from *property testing*, where tests
    are written to validate conditions against generated inputs and Clojure’s `test.check`
    ([https://clojure.org/guides/test_check_beginner](https://clojure.org/guides/test_check_beginner))
    would be a valuable tool in the mix.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个系统不仅仅是其核心处理。例如，这是一个更好的测试会明显有帮助的情况。Kotlin 有许多好的选择，包括 Spek 框架([https://www.spekframework.org/](https://www.spekframework.org/))和
    Kotest ([https://kotest.io](https://kotest.io))，它们利用语言来启用清晰、可读的规范，而不需要典型的 JUnit
    烂模板。或者，也许你的规则引擎会从*属性测试*中受益，其中测试是编写来验证生成的输入条件，Clojure 的 `test.check` ([https://clojure.org/guides/test_check_beginner](https://clojure.org/guides/test_check_beginner))
    将是混合中的宝贵工具。
- en: Or suppose you need to build a web console so that the operations users can
    administer some of the noncritical static data behind the payment-processing system.
    The development team members already know Struts and JSF but don’t feel any enthusiasm
    for either technology. This is another low-risk area to try out a new language
    and technology stack. Spring Boot with Kotlin would be one obvious choice.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，假设你需要构建一个网络控制台，以便操作用户可以管理支付处理系统背后的某些非关键静态数据。开发团队成员已经熟悉 Struts 和 JSF，但对这两种技术都没有任何热情。这是尝试新语言和技术栈的另一个低风险领域。Spring
    Boot 与 Kotlin 将是一个明显的选择。
- en: By focusing on a limited pilot in an area that is low-risk, there’s always the
    option of terminating the project and porting to a different delivery technology
    without too much disruption if the new technology stack isn’t a good fit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在一个低风险领域进行有限的试点，如果新技术栈不适合，总有终止项目并转移到不同交付技术的选项，而不会造成太大的干扰。
- en: 8.3.2 Does the language interoperate well with Java?
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 语言与 Java 的交互操作如何？
- en: You don’t want to lose the value of all of that great Java code you’ve already
    written! This is one of the main reasons organizations are hesitant to introduce
    a new programming language into their technology stack. But with alternative languages
    that run on the JVM, you can turn this on its head, so it becomes about maximizing
    your existing value in the codebase and not throwing away working code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望丢失你已经编写的所有优秀 Java 代码的价值！这是组织犹豫在技术堆栈中引入新编程语言的主要原因之一。但是，使用在 JVM 上运行的替代语言，你可以扭转这一局面，使其成为最大化代码库中现有价值，而不是丢弃有效代码。
- en: Alternative languages on the JVM are able to cleanly interoperate with Java
    and can, of course, be deployed on a preexisting environment. This is especially
    important to avoid impacting whoever owns deployment, whether a production management
    team or DevOps folks in your own team. By using a non-Java JVM language as part
    of your system, you retain your organization’s operational expertise, which can
    help alleviate worries and reduce risk around supporting the new solution.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 上运行的替代语言能够与 Java 清晰地交互操作，并且当然可以部署在现有的环境中。这对于避免影响部署的所有者来说尤为重要，无论是生产管理团队还是你团队中的
    DevOps 人员。通过将非 Java JVM 语言作为你系统的一部分，你保留了组织的运营专业知识，这有助于减轻担忧并降低支持新解决方案的风险。
- en: Note DSLs are typically built using a dynamic (or, in some cases, stable) layer
    language, so many of them run on the JVM via the languages that they were built
    in.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 DSL 通常使用动态（或在某些情况下，稳定的）层语言构建，因此许多 DSL 都是通过它们构建的语言在 JVM 上运行的。
- en: Some languages interoperate with Java more easily than others. We’ve found that
    most popular JVM alternatives (such as Kotlin, Clojure, JRuby, Groovy, and Scala)
    all have good interoperability with Java (and for some of the languages, the integration
    is excellent, almost completely seamless). If you’re a really cautious shop, it’s
    quick and easy to run a few experiments first and make certain that you understand
    how the integration can work for you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言与 Java 的交互比其他语言更容易。我们发现，大多数流行的 JVM 替代语言（如 Kotlin、Clojure、JRuby、Groovy 和
    Scala）都与 Java 有良好的互操作性（对于某些语言，集成非常好，几乎无缝）。如果你是一个非常谨慎的商店，运行一些实验很快很容易，并确保你理解集成如何为你工作。
- en: Let’s take Kotlin, for example. You can import Java packages directly into its
    code via the familiar import statement. From here you could easily write a small
    Kotlin script, or even use the interactive Kotlin shell, to poke at your Java
    model objects and see what the interoperation surfaces will look like. We’ll talk
    specifically about Java interoperability in the language chapters coming up next.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以Kotlin为例。你可以通过熟悉的导入语句直接将其代码中的Java包导入。从这里，你可以轻松地编写一个小型的Kotlin脚本，甚至可以使用交互式的Kotlin
    shell来检查你的Java模型对象，看看交互表面会是什么样子。我们将在接下来的语言章节中具体讨论Java互操作性。
- en: 8.3.3 Is there good tooling and test support for the language?
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 这种语言有良好的工具和测试支持吗？
- en: Most developers underestimate the amount of time they save once they’ve become
    comfortable in their environment. Their powerful IDEs and build and test tools
    help them to rapidly produce high quality software. Java developers have benefited
    from great tooling support for years, so it’s important to remember that other
    languages may not be at quite the same level of maturity.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者低估了他们在熟悉环境后节省的时间量。他们强大的IDE和构建及测试工具帮助他们快速生产高质量的软件。Java开发者已经从多年的优秀工具支持中受益，因此记住其他语言可能并不处于完全相同的成熟水平是很重要的。
- en: Some languages (such as Kotlin) have had longstanding IDE support for compiling,
    testing, and deploying the end result. Other languages may have tooling that hasn’t
    matured as fully.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言（如Kotlin）长期以来一直支持IDE进行编译、测试和部署最终结果。其他语言可能具有尚未完全成熟的工具。
- en: A related issue is that when an alternative language has developed a powerful
    tool for its own use (such as Clojure’s awesome Leiningen build tool), the tool
    may not be well adapted to handle other languages. Therefore, the team will need
    to think carefully about how to divide up a project, especially for deployment
    of separate but related components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 相关问题是，当一种替代语言为其自身开发了一个强大的工具（如Clojure的出色的Leiningen构建工具）时，这个工具可能并不适合处理其他语言。因此，团队需要仔细思考如何划分项目，尤其是在部署相互关联但独立的组件时。
- en: 8.3.4 How hard is the language to learn?
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 学习这种语言有多难？
- en: It always takes time to learn a new language, and that time only increases if
    the paradigm of the language isn’t one that your development team is familiar
    with. Most Java development teams will be comfortable picking up a new language
    if it’s object-oriented with a C-like syntax (such as Kotlin).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新语言总是需要时间，而且如果这种语言的范式不是你的开发团队所熟悉的，那么所需的时间还会增加。大多数Java开发团队如果新语言是面向对象且具有类似C语言的语法（例如Kotlin），那么他们会比较容易掌握这门新语言。
- en: It gets harder for Java developers as they move further away from this paradigm.
    At the extreme of the popular alternative languages, a language such as Clojure
    can bring incredibly powerful benefits, but it can also represent a significant
    retraining requirement for development teams as they learn Clojure’s functional
    nature and Lisp syntax.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java开发者逐渐远离这种范式时，事情会变得更加困难。在流行的替代语言中，像Clojure这样的语言可以带来极其强大的好处，但它也可能要求开发团队在学习和理解Clojure的函数式特性和Lisp语法时进行重大的再培训。
- en: One alternative is to look at the JVM languages that are reimplementations of
    existing languages. Ruby and Python are well-established languages, with plenty
    of material available for developers to use to educate themselves. The JVM incarnations
    of these languages could provide a sweet spot for your teams to begin working
    with an easy-to-learn non-Java language.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方案是查看那些是现有语言重新实现的JVM语言。Ruby和Python是成熟的编程语言，为开发者提供了大量的资料来学习。这些语言的JVM实现可以为你的团队提供一个甜点，让他们开始使用易于学习的非Java语言。
- en: 8.3.5 Are there lots of developers using this language?
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.5 有很多开发者使用这种语言吗？
- en: Organizations have to be pragmatic; they can’t always hire the top 2% (despite
    what their advertising might say), and their development teams will change throughout
    the course of a year. Some languages, such as Kotlin or Scala, are becoming well-established
    enough that there is a pool of developers to hire from. But a language such as
    Clojure may present more difficulties. Managers may push back against using something
    out of the ordinary from concern for creating an unmaintainable codebase they’ll
    have difficulty hiring for.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 组织必须务实；他们不能总是雇佣最顶尖的2%（尽管他们的广告可能这么说），并且他们的开发团队在一年中会发生变化。有些语言，如Kotlin或Scala，已经足够成熟，以至于有一个可供雇佣的开发者池。但像Clojure这样的语言可能会带来更多困难。管理者可能会反对使用非同寻常的东西，担心会创建一个难以维护的代码库，他们将为雇佣而感到困难。
- en: 'Note A warning about the reimplemented languages: many existing packages and
    applications written in Ruby, for example, are tested only against the original
    C-based implementation. There may be problems when trying to use them on top of
    the JVM. When making platform decisions, you should factor in extra testing time
    if you’re planning to leverage an entire stack written in a reimplemented language.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于重新实现的语言的警告：例如，许多用Ruby编写的现有包和应用程序仅针对基于C的原生实现进行测试。当尝试在JVM上使用它们时可能会出现问题。在做出平台决策时，如果你计划利用用重新实现的语言编写的整个堆栈，你应该考虑额外的测试时间。
- en: Again, the reimplemented languages (JRuby, Jython, and so on) can potentially
    help here. Few developers may have JRuby on their CV, but because it’s just Ruby
    on the JVM, there’s actually a large pool of developers to hire from—a Ruby developer
    familiar with the C version can learn the differences induced by running on the
    JVM very easily.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，重新实现的语言（如JRuby、Jython等）可能在这里有所帮助。可能很少有开发者的简历上有JRuby，但由于它只是运行在JVM上的Ruby，实际上有一个庞大的开发者池可供雇佣——一个熟悉C版本的Ruby开发者可以很容易地学习在JVM上运行引起的差异。
- en: We now have a set of questions to ask when choosing an alternative language
    and an overview of some available options. At this point, it’s worth a deeper
    understanding of how the JVM supports multiple languages. This peek reveals the
    roots of some design choices and limitations in alternative languages on the JVM.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一系列问题要问，当选择替代语言时，以及一些可用选项的概述。在这个时候，深入了解JVM如何支持多种语言是值得的。这次窥视揭示了某些设计选择和JVM上替代语言的限制的根源。
- en: 8.4 How the JVM supports alternative languages
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 JVM如何支持替代语言
- en: 'A language can run on the JVM in two possible ways:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一种语言可以在JVM上以两种可能的方式运行：
- en: Have a source code compiler that emits class files. Kotlin and Clojure both
    function in this way.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个生成类文件的源代码编译器。Kotlin和Clojure都以这种方式运行。
- en: Have an interpreter that is implemented in JVM bytecode. JRuby is implemented
    in this way.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个用JVM字节码实现的解释器。JRuby就是这样实现的。
- en: In both cases, it’s usual to have a runtime environment that provides language-specific
    support for executing programs. Figure 8.3 shows the runtime environment stack
    for Java and for a typical non-Java language.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，通常会有一个运行时环境，它为执行程序提供特定语言的支持。图8.3显示了Java和典型非Java语言的运行时环境堆栈。
- en: '![](../Images/CH08_F03_Evans2.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Evans2.png)'
- en: Figure 8.3 Non-Java language runtime support
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 非Java语言运行时支持
- en: These runtime support systems vary in complexity, depending on the amount of
    hand-holding that a given non-Java language requires at runtime. In almost all
    cases, the runtime will be implemented as a set of JARs or modules that an executing
    program needs to have on its classpath. In the interpreted case, the interpreter
    will bootstrap as program execution starts and then read in the source file to
    be executed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运行时支持系统在复杂性上有所不同，这取决于特定非Java语言在运行时需要多少手动操作。在几乎所有情况下，运行时都将实现为一组JAR文件或模块，执行程序需要在它的类路径上拥有这些文件。在解释器的情况下，解释器将在程序执行开始时启动引导，然后读取要执行的源文件。
- en: 8.4.1 Performance
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 性能
- en: One question developers often ask about different languages is, How do they
    perform relative to each other? Although superficially attractive, this question
    is not simple to answer and, in fact, is not actually all that meaningful.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常对不同的语言提出一个问题，那就是它们相对于彼此的表现如何？虽然表面上看起来很有吸引力，但这个问题并不简单回答，实际上并不那么有意义。
- en: As we saw in chapter 7, the well-grounded developer knows that performance is
    driven by measurement. Measurement is done on individual programs, not on the
    abstract notion of a programming language. Treat any claim that language X “performs
    better” than Y without accompanying, reliable data as suspect.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第7章中看到的，经验丰富的开发者知道性能是由测量驱动的。测量是在单个程序上进行的，而不是在编程语言的抽象概念上。将任何声称语言X“性能优于”Y的主张视为可疑，除非有伴随的可靠数据。
- en: However, in practice, some overall performance characteristics of a JVM language
    can broadly be determined by how the language is implemented. A compiled language
    is just bytecode at runtime and will be JIT-compiled in the same way as Java is.
    An interpreted language will have very different performance behavior because
    the code that gets JIT-compiled is the interpreter, and not the program itself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，JVM语言的某些整体性能特征可以通过语言实现的方式大致确定。编译型语言在运行时只是字节码，将以与Java相同的方式进行即时编译。解释型语言将具有非常不同的性能行为，因为要即时编译的代码是解释器，而不是程序本身。
- en: Note Some languages (e.g., JRuby) have a hybrid strategy—they have an interpreter
    for scripts but can also dynamically compile individual source methods to JVM
    bytecode, which can then be compiled to machine code by the JVM’s JIT compilers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些语言（例如，JRuby）采用混合策略——它们为脚本提供解释器，但也可以动态地将单个源方法编译成JVM字节码，然后由JVM的即时编译器将其编译成机器代码。
- en: In this book, our focus is on compiled languages. The interpreted languages—such
    as Rhino—are mentioned for completeness, but we won’t spend too much time on them.
    We, therefore, expect that performance will be broadly similar between the languages
    that we’re considering. For a more detailed answer, you should undertake a detailed
    analysis of a specific program or workload.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们的重点是编译型语言。为了完整性，提到了像Rhino这样的解释型语言，但不会过多地涉及它们。因此，我们预计我们考虑的语言之间的性能将大致相似。要获得更详细的答案，你应该对特定的程序或工作负载进行详细分析。
- en: In the rest of this section, we’ll discuss the need for runtime support for
    alternative languages (even for compiled languages) and then talk about compiler
    fictions—language-specific features that are synthesized by the compiler and that
    may not appear in the low-level bytecode.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将讨论对替代语言（即使是编译型语言）的运行时支持的需求，然后讨论编译器虚构功能——由编译器合成的特定语言功能，这些功能可能不会出现在低级字节码中。
- en: 8.4.2 Runtime environments for non-Java languages
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 非Java语言的运行时环境
- en: One simple way to measure the complexity of the runtime environment that a particular
    language requires is to look at the size of the JAR files that provide the implementation
    of the runtime. Using this as a metric, we can see that Clojure is a relatively
    lightweight runtime, whereas JRuby is a language that requires more support.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单测量特定语言所需的运行时环境复杂性的方法是通过查看提供运行时实现的JAR文件的大小。使用这个指标，我们可以看到Clojure是一个相对轻量级的运行时环境，而JRuby是一个需要更多支持的编程语言。
- en: This isn’t a completely fair test, because some languages bundle much larger
    standard libraries and additional functionality into their standard distributions
    than others. However, it can be a useful (if rough) rule of thumb.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个完全公平的测试，因为一些语言的标准化库和附加功能比其他语言的标准化分布要大得多。然而，这可以是一个有用的（如果粗略的）经验法则。
- en: In general, the purpose of the runtime environment is to help the type system
    and other aspects of the non-Java language achieve the desired semantics. Alternative
    languages don’t always have exactly the same view as Java about basic programming
    concepts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，运行时环境的目的在于帮助非Java语言中的类型系统和其他方面实现所需的语义。替代语言并不总是与Java对基本编程概念有完全相同的看法。
- en: For example, Java’s approach to OO isn’t universally shared by other languages.
    In Java, all objects that are instances of a particular class all have exactly
    the same set of methods on them, and that set is fixed at compile time. In Ruby,
    on the other hand, an individual object instance can have additional methods attached
    to it at runtime that were not known when the class was defined and that aren’t
    necessarily defined on other instances of the same class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Java对面向对象的方法并不被其他语言普遍接受。在Java中，所有特定类的实例都具有完全相同的方法集，并且这个集合在编译时是固定的。另一方面，在Ruby中，一个单独的对象实例可以在运行时附加额外的、在定义类时未知且不一定在其他相同类的实例上定义的方法。
- en: Note The `invokedynamic` bytecode was, in fact, originally added to the JVM
    to facilitate the efficient implementation of these types of language features.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`invokedynamic` 字节码最初被添加到 JVM 中，是为了方便高效地实现这类语言特性。
- en: This ability to dynamically add methods (which is somewhat confusingly called
    “open classes”) needs to be replicated by the JRuby implementation. This is possible
    only with some advanced support from the JRuby runtime.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动态添加方法的能力（有些令人困惑地称为“开放类”）需要由 JRuby 实现来复制。这只有在 JRuby 运行时提供一些高级支持的情况下才可能实现。
- en: 8.4.3 Compiler fictions
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 编译器虚构
- en: Certain language features are synthesized by the programming environment and
    high-level language and aren’t present in the underlying JVM implementation. These
    are referred to as *compiler fictions*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 某些语言特性是由编程环境和高级语言合成的，并不存在于底层的 JVM 实现中。这些被称为 *编译器虚构*。
- en: Note It helps to have some knowledge of how these features are implemented;
    otherwise, you can find your code running slowly or, in some cases, even crashing
    the process. Sometimes the environment has to do a lot of work to synthesize a
    particular feature.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：了解这些特性是如何实现的会有所帮助；否则，你可能会发现代码运行缓慢，在某些情况下甚至会导致进程崩溃。有时环境需要做大量工作来合成特定的特性。
- en: Other examples in Java include checked exceptions and inner classes (which are
    always converted to top-level classes with specially synthesized access methods
    if necessary, as shown in figure 8.4). If you’ve ever looked inside a JAR file
    (using `jar tvf`) and seen a load of classes with `$` in their names, these are
    the inner classes unpacked and converted to “regular” classes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的其他例子包括检查型异常和内部类（如果需要，总是转换为顶级类，并带有特别合成的访问方法，如图 8.4 所示）。如果你曾经使用 `jar tvf`
    命令查看过 JAR 文件内部，并看到很多名字中带有 `$` 的类，这些就是已展开并转换为“常规”类的内部类。
- en: '![](../Images/CH08_F04_Evans2.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F04_Evans2.png)'
- en: Figure 8.4 Inner classes as a compiler fiction
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 内部类作为编译器虚构
- en: Alternative languages also have compiler fictions. In some cases, these compiler
    fictions even form a core part of the language’s functionality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言也有编译器虚构的概念。在某些情况下，这些编译器虚构甚至构成了语言功能的核心部分。
- en: In section 8.2, we introduced the key concept of *first-class functions* in
    functional programming—that functions should be values that can be put into variables.
    All the non-Java languages in part 3 of this book supported this feature long
    before Java added lambda expressions. How did they accomplish this when the JVM
    handles only classes as the smallest unit of code and functionality?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8.2 节中，我们介绍了函数式编程中的关键概念 *一等函数*——即函数应该是可以放入变量的值。本书第三部分的所有非 Java 语言在 Java 添加
    lambda 表达式之前就支持了这个特性。当 JVM 只处理类作为代码和功能的最小单元时，它们是如何实现这一点的呢？
- en: 'The original solution to this discrepancy between source code and JVM bytecode
    is to remember that objects are just bundles of data along with methods to act
    on that data. Imagine an object with no state and just one method—for example,
    a simple anonymous implementation of Java’s `Callable`. It wouldn’t be at all
    unusual to put such an object in a variable, pass it around, and then invoke its
    `call()` method later, like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解决源代码和 JVM 字节码之间差异的原始方案是记住对象只是数据包，以及操作这些数据的方法。想象一个没有任何状态且只有一个方法的对象——例如，Java
    的 `Callable` 的简单匿名实现。将这样的对象放入变量中，传递它，然后稍后调用它的 `call()` 方法，这在任何情况下都并不罕见：
- en: '[PRE6]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note The `myFn` variable in this example is an anonymous type, so it will show
    up after compilation as something like `NameOfEnclosingClass$1.class`. The class
    numbers start at 1 and go up for each anonymous type the compiler encounters.
    If they’re dynamically created, and there are a lot of them (as sometimes happens
    in languages like JRuby), this can place pressure in the off-heap memory where
    the definitions of classes are stored.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这个例子中，`myFn` 变量是一个匿名类型，因此编译后它将显示为类似于 `NameOfEnclosingClass$1.class` 的形式。类编号从
    1 开始，对于编译器遇到的每个匿名类型都会递增。如果它们是动态创建的，并且数量很多（如 JRuby 等语言中有时发生的情况），这可能会对存储类定义的堆外内存造成压力。
- en: Java lambda expressions don’t actually use this anonymous type approach but
    instead are built on a general JVM feature called `invokedynamic`, which we’ll
    discuss in detail in chapter 17\. Alternate languages are moving from their specialized
    implementations to use `invokedynamic`, too. It’s an interesting case of compiler
    fictions influencing the development of platform realities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 lambda 表达式实际上并不使用这种匿名类型的方法，而是建立在 JVM 的一种通用特性 `invokedynamic` 之上，我们将在第
    17 章中详细讨论。其他语言也在从它们的专用实现转向使用 `invokedynamic`。这是一个编译器虚构影响平台现实发展的有趣案例。
- en: For another example, in the next chapter we will meet Kotlin’s *data classes*—
    a language feature that helps to lower the amount of typing and *ceremony* required
    when declaring a class that is “just a dumb bunch of fields.” In Kotlin as it
    exists today, this is a compiler fiction, but Java 17 has added a feature called
    *records*, which may eventually provide an alternative basis for Kotlin to build
    data classes upon.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，在下一章中，我们将遇到 Kotlin 的 *数据类*——这是一种语言特性，有助于减少声明“只是一堆字段”的类时所需的输入和 *仪式*。在今天的
    Kotlin 中，这是一个编译器虚构，但 Java 17 添加了一个名为 *records* 的特性，这可能会最终为 Kotlin 提供构建数据类的基础。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Alternative languages on the JVM have come a long way to offer better solutions
    than Java for certain problems.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JVM 上的替代语言已经走得很远，为某些问题提供了比 Java 更好的解决方案。
- en: Languages can be classified in different ways (static versus dynamic, imperative
    versus functional, and compiled versus interpreted), which can assist in picking
    the right language for the right task.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言可以根据不同的方式分类（静态与动态、命令式与函数式、编译与解释），这有助于选择适合特定任务的正确语言。
- en: 'Polyglot programming is often separated into three layers: stable, dynamic,
    and domain-specific. Java and Kotlin are best for the stable layer of software
    development. Clojure may be more suited to tasks in the dynamic or domain-specific
    realms.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言编程通常分为三个层次：稳定层、动态层和领域特定层。Java 和 Kotlin 适用于软件开发中的稳定层。Clojure 可能更适合动态层或领域特定层的工作。
- en: Core business functionality of an existing production application is almost
    never the correct place to introduce a new language. Choose a low-risk area for
    your first deployment of an alternative language.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有生产应用程序的核心业务功能几乎永远不会是引入新语言的正确地方。为您的替代语言首次部署选择一个低风险区域。
- en: Teams and projects have unique characteristics that will impact language choice.
    There are no universal right answers here.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队和项目具有独特的特征，这将影响语言选择。这里没有普遍正确的答案。
