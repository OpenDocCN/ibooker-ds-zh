- en: 'Chapter 15\. Incrementality: The Holy Grail of Data Science?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。 增量性：数据科学的圣杯？
- en: 'In the [past](https://oreil.ly/or6gY) I’ve argued that *incrementality is the
    holy grail of data science*. This statement depends critically on the hypothesis
    that I’ve maintained throughout: that data science creates value by improving
    a company’s decision-making capabilities. This chapter expands on this topic,
    but most importantly, I will present some techniques that should build some basic
    intuitions that will become handy if and when you decide to delve deeper. As usual,
    the topic is worthy of a book-length treatment, so I will provide several references
    at the end of this chapter.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[过去](https://oreil.ly/or6gY) 中，我曾经争论过*增量性是数据科学的圣杯* 。 这一声明在很大程度上依赖于我一直维持的假设：即数据科学通过提升公司的决策能力来创造价值。
    本章扩展了这个主题，但更重要的是，我将介绍一些技术，这些技术应该建立一些基本的直觉，如果您决定更深入地研究时将会很有用。 通常情况下，这个主题值得一本书来详细阐述，因此我会在本章末尾提供几个参考资料。
- en: Defining Incrementality
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义增量性
- en: '*Incrementality* is just another name for *causal inference* applied to decision-making
    analytics. If you recall from [Figure 14-1](ch14.html#ch14_uncertainty), a typical
    decision comprises an action or lever, and an outcome that depends on the underlying
    uncertainty. If the lever *improves* the outcome, and you’re able to isolate any
    other factors that might explain the change, you can say (with some degree of
    confidence) that it was incremental. For later reference, the action is also known
    as the *treatment*, following the more classical medical literature of controlled
    experiments, where some patients receive a treatment, and the remaining *control
    group* receives a placebo.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*增量性* 只是应用于决策分析的*因果推断* 的另一个名称。 如果您还记得[图 14-1](ch14.html#ch14_uncertainty)，一个典型的决策包括一个行动或杠杆，以及依赖于潜在不确定性的结果。
    如果杠杆*改善* 结果，并且您能够分离可能解释变化的任何其他因素，那么您可以（以某种程度的信心）说这是增量的。 供日后参考，行动也被称为*治疗*，遵循更经典的医学文献中控制实验的做法，其中一些患者接受治疗，其余的*对照组*
    接受安慰剂。'
- en: 'Causality is commonly defined by use of *counterfactuals*. As opposed to facts—something
    that we observe—counterfactuals attempt to provide an answer to the question:
    *what if I had followed a different course of action?* You can then say that an
    action has a causal effect on the outcome if the result is unique against all
    possible counterfactuals.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因果关系通常通过使用*反事实* 来定义。 与事实（我们观察到的东西）相对，反事实试图回答这个问题：*如果我采取了不同的行动，会怎样？* 然后，您可以说一个行动对结果有因果影响，如果结果在所有可能的反事实中是唯一的。
- en: For instance, imagine you can pull a binary lever with only two possible actions,
    *A* and *B* (such as giving a price discount or not), and you observe an outcome
    *Y* (revenue). You end up giving a discount to all of your customers and find
    that revenue increases. Was the discount incremental on revenue? Alternatively,
    is this effect *causal*? To answer these questions, you need to estimate the counterfactual
    revenue, where every other factor is fixed and the only thing that changes is
    that you don’t give a discount. The difference in these *potential outcomes* is
    the causal effect of the discount.^([1](ch15.html#id769))
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，您可以拉动一个二元杠杆，只有两种可能的行动，*A* 和 *B*（例如提供价格折扣或不提供），并观察到一个结果 *Y*（收入）。 您最终给所有客户打折，并发现收入增加了。
    折扣对收入是增量的吗？ 或者，这种效果是*因果*的吗？ 要回答这些问题，您需要估算反事实收入，其中其他所有因素保持不变，唯一变化的是您不给折扣。 这些*潜在结果*
    的差异就是折扣的因果效应。^([1](ch15.html#id769))
- en: By quantifying incrementality, you are able to identify and choose actions that
    put the company on an improving path. This is commonly associated with *prescriptive*
    analytics, as opposed to its descriptive and predictive counterparts. Most data
    scientists working on machine learning (ML) strictly focus on prediction and devote
    little to no time to think about causality, so you might wonder if this is really
    a critical skill to learn. Before moving on to more practical matters, I’ll argue
    that it is.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过量化增量性，您能够识别并选择使公司走向改善路径的行动。 这通常与*指导性* 分析相关联，与其描述性和预测性的对应项相对。 大多数从事机器学习（ML）的数据科学家严格专注于预测，并几乎不花时间思考因果关系，因此您可能会想知道这是否真的是一个需要学习的关键技能。
    在转向更实际的事务之前，我将辩称它确实如此。
- en: Causal Reasoning to Improve Prediction
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用因果推理来改进预测
- en: 'Even if you restrict your role as data scientist to prediction, you ought to
    care about causality in a very broad sense. As argued in [Chapter 13](ch13.html#ch13_storytellingML),
    for engineering good, predictive features, you need to have some basic causal
    intuitions about the outcome you want to predict. This can be seen from the definition
    of supervised learning:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你将自己的角色限制为数据科学家仅仅进行预测，你也应该从非常广义的角度关注因果关系。正如在[第13章](ch13.html#ch13_storytellingML)中所论述的，要设计出良好的预测特征，你需要对你想预测的结果有一些基本的因果直觉。这可以从监督学习的定义中看出：
- en: <math alttext="y equals f left-parenthesis x 1 comma x 2 comma midline-horizontal-ellipsis
    right-parenthesis" display="block"><mrow><mi>y</mi> <mo>=</mo> <mi>f</mi> <mo>(</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>)</mo></mrow></math>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="y equals f left-parenthesis x 1 comma x 2 comma midline-horizontal-ellipsis
    right-parenthesis" display="block"><mrow><mi>y</mi> <mo>=</mo> <mi>f</mi> <mo>(</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>x</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>⋯</mo> <mo>)</mo></mrow></math>
- en: Given variation in your features and outcome <math alttext="StartSet x Subscript
    k Baseline comma y EndSet"><mrow><mo>{</mo> <msub><mi>x</mi> <mi>k</mi></msub>
    <mo>,</mo> <mi>y</mi> <mo>}</mo></mrow></math> , the task is to learn the data
    generating process ( <math alttext="f left-parenthesis right-parenthesis"><mrow><mi>f</mi>
    <mo>(</mo> <mo>)</mo></mrow></math> ). But this implicitly assumes a direction
    of causality from features to outcome. The process of feature engineering starts
    by formulating casual hypotheses of the type *a higher value of feature <math
    alttext="k"><mi>k</mi></math> increases outcome because…​*. Moreover, the predictive
    performance of your model may be negatively impacted if you include features that
    are spuriously correlated with the outcome, as explained in [Chapter 10](ch10.html#ch10_linreg).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于你的特征和结果<math alttext="StartSet x Subscript k Baseline comma y EndSet"><mrow><mo>{</mo>
    <msub><mi>x</mi> <mi>k</mi></msub> <mo>,</mo> <mi>y</mi> <mo>}</mo></mrow></math>的变化，任务是学习数据生成过程（<math
    alttext="f left-parenthesis right-parenthesis"><mrow><mi>f</mi> <mo>(</mo> <mo>)</mo></mrow></math>）。但这隐含地假设了从特征到结果的因果关系。特征工程的过程始于对类型为“高于特征<math
    alttext="k"><mi>k</mi></math>值增加结果”的因果假设的阐述。此外，如果你包括与结果虚假相关的特征，你的模型的预测性能可能会受到负面影响，正如在[第10章](ch10.html#ch10_linreg)中所解释的那样。
- en: Causal Reasoning as a Differentiator
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 因果推理作为一个区分因素
- en: At the time of writing this book, GPT-4 and similar large language models (LLMs)
    are making us rethink the role of humans in many areas. Data scientists have heard
    about these risks before with the advent of [automated machine learning](https://oreil.ly/afagR).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，GPT-4和类似的大型语言模型（LLMs）正在让我们重新思考人类在许多领域中的角色。数据科学家在[自动化机器学习的出现](https://oreil.ly/afagR)之前已经听说过这些风险。
- en: But these technologies can make you more productive if you let the machines
    take care of everything that can be automated and devote your unique human capabilities
    on top of them. Even with the most recent advances, it seems safe to predict that
    for now, humans are uniquely suited to engage in causal reasoning by way of counterfactuals
    and building models of how the world works. [Chapter 17](ch17.html#ch17_llms)
    discusses this topic in detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你让机器处理一切可以自动化的事情，并且把你独特的人类能力放在它们的顶部，这些技术可以使你变得更加高效。即使有了最新的进展，看起来可以安全地预测，目前人类唯一适合通过反事实推理和建立世界工作模型来进行因果推理。[第17章](ch17.html#ch17_llms)详细讨论了这个主题。
- en: Improved Decision Making
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升决策能力
- en: There is also the problem of how you create value for your organization. As
    I’ve argued throughout this book, data scientists are uniquely endowed with skills
    to improve a company’s decision-making capabilities. If you follow this route,
    incrementality *is* the holy grail and there’s no way you can escape thinking
    about causality.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题，即如何为你的组织创造价值。正如我在整本书中所论述的，数据科学家具备提升公司决策能力的技能。如果你选择这条路，增量性*是*圣杯，你无法逃避思考因果关系。
- en: But this route also requires you to rethink your role as data scientist, augmenting
    it from just prediction to enhanced decision making (where prediction plays an
    important, but secondary, role).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但这条路也要求你重新思考你作为数据科学家的角色，将其从仅仅预测增强到决策制定（其中预测起着重要但次要的角色）。
- en: A typical scenario is the launch of a new feature or new product. When you launch
    a new feature, you’d better have an outcome or metric that you are trying to optimize.
    For instance, you may care about customer engagement, as measured by activity
    time or page visit frequency. If you’re able to show that the feature was incremental
    on that metric, you can recommend expanding its use or augmenting it. Alternatively,
    if you don’t find it to be incremental, or even worse, that the metric deteriorated,
    the best course of action is to roll the feature back.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 典型场景是推出新功能或新产品。推出新功能时，最好有一个你试图优化的结果或指标。例如，你可能关心客户参与度，如活动时间或页面访问频率来衡量。如果你能够表明该功能对这一指标有增量影响，你可以建议扩展其使用或增强它。另外，如果你发现它并没有带来增量，甚至更糟的是，该指标恶化了，最好的做法是撤销这个功能。
- en: The launch of new products adds the more interesting concept of *cannibalization*.
    For example, when [Apple](https://oreil.ly/QarTm) decided to launch the iPhone,
    the sales of the iPod dropped significantly and were thus cannibalized. Similarly,
    the streaming business for [Netflix](https://oreil.ly/Zu5jM) eventually displaced
    and cannibalized the original online DVD rental business. A somewhat different
    final example is the case of [Starbucks](https://oreil.ly/BCgCA) opening a new
    store that may cannibalize the sales of neighboring stores. In all of these cases,
    estimating the incrementality for the new product or stores can have a deep impact
    on the company’s P&L and decision-making capabilities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 推出新产品还增加了更有趣的*蚕食*概念。例如，当[Apple](https://oreil.ly/QarTm)决定推出iPhone时，iPod的销售显著下降，因此被蚕食。类似地，[Netflix](https://oreil.ly/Zu5jM)的流媒体业务最终取代并蚕食了最初的在线DVD租赁业务。稍有不同的最后一个例子是[Starbucks](https://oreil.ly/BCgCA)开设一家新店可能会蚕食周围店铺的销售。在所有这些情况下，估算新产品或店铺的增量对公司的损益表和决策能力都有深远的影响。
- en: Confounders and Colliders
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆因素和碰撞因素
- en: '[Chapter 10](ch10.html#ch10_linreg) mentioned confounders and bad controls
    as examples of how things can go wrong with linear regression. Mastering these
    concepts is again of key practical importance when dealing with causality. I’ll
    now review these concepts and highlight some places where you should direct your
    attention when thinking about incrementality.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html#ch10_linreg)提到混淆因素和糟糕的控制是线性回归中可能出错的示例。掌握这些概念在处理因果关系时再次具有关键的实际意义。我现在将回顾这些概念，并突出一些你在考虑增量时应该注意的地方。'
- en: One very useful tool to think about causality is directed acyclic graphs (DAGs).
    A *graph* is a set of nodes and links between the nodes. In this setting, nodes
    represent variables, and links denote causal relationships. When links are interpreted
    directionally, the graph becomes *directed*. For instance, if *x* causes *y*,
    there will be a directed link <math alttext="x right-arrow y"><mrow><mi>x</mi>
    <mo>→</mo> <mi>y</mi></mrow></math> . The word *acyclic* precludes the existence
    of loops; if <math alttext="x right-arrow y"><mrow><mi>x</mi> <mo>→</mo> <mi>y</mi></mrow></math>
    , it can’t be that <math alttext="x left-arrow y"><mrow><mi>x</mi> <mo>←</mo>
    <mi>y</mi></mrow></math> , so causal relationships are unidirectional. Judea Pearl,
    a computer scientist and Turing Award winner for his work on Bayesian networks,
    developed and popularized an approach to causal analysis using DAGs. Given your
    data and your DAG, the question is whether you can *identify* a specific causal
    effect. Identification is different from *estimation*, which uses statistical
    techniques to compute the sample estimate.^([2](ch15.html#id778))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的思考因果关系的工具是有向无环图（DAGs）。*图* 是一组节点和节点之间的链接。在这种设置中，节点代表变量，链接表示因果关系。当链接被定向解释时，图变成*有向*
    的。例如，如果 *x* 导致 *y*，那么会有一个有向链接 <math alttext="x right-arrow y"><mrow><mi>x</mi>
    <mo>→</mo> <mi>y</mi></mrow></math> 。*无环* 一词排除了循环的存在；如果 <math alttext="x right-arrow
    y"><mrow><mi>x</mi> <mo>→</mo> <mi>y</mi></mrow></math>，那么不可能有 <math alttext="x
    left-arrow y"><mrow><mi>x</mi> <mo>←</mo> <mi>y</mi></mrow></math>，因此因果关系是单向的。计算机科学家和图灵奖获得者朱迪亚·珀尔（Judea
    Pearl）开发并推广了使用DAGs进行因果分析的方法。根据你的数据和DAG，问题是你能否*识别*特定的因果效应。识别与*估计*不同，估计使用统计技术计算样本估计量。^([2](ch15.html#id778))
- en: '[Figure 15-1](#ch15_confounder) shows DAGs for the simplest cases of a confounder
    and a collider where there’s no causal effect from *x* to *y*. The left DAG shows
    that there are two causal relations ( <math alttext="c right-arrow x comma c right-arrow
    y"><mrow><mi>c</mi> <mo>→</mo> <mi>x</mi> <mo>,</mo> <mi>c</mi> <mo>→</mo> <mi>y</mi></mrow></math>
    ), so *c* is a common cause for both *x* and *y*. On the right, there are also
    two causal relations ( <math alttext="c left-arrow x comma c left-arrow y"><mrow><mi>c</mi>
    <mo>←</mo> <mi>x</mi> <mo>,</mo> <mi>c</mi> <mo>←</mo> <mi>y</mi></mrow></math>
    ), so *c* is a common effect.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-1](#ch15_confounder) 展示了混杂因素和碰撞器的最简单情况的 DAG 图，这里没有从 *x* 到 *y* 的因果效应。左边的
    DAG 显示了两个因果关系（ <math alttext="c right-arrow x comma c right-arrow y"><mrow><mi>c</mi>
    <mo>→</mo> <mi>x</mi> <mo>,</mo> <mi>c</mi> <mo>→</mo> <mi>y</mi></mrow></math>
    ），因此 *c* 是 *x* 和 *y* 的共同原因。右边也有两个因果关系（ <math alttext="c left-arrow x comma c left-arrow
    y"><mrow><mi>c</mi> <mo>←</mo> <mi>x</mi> <mo>,</mo> <mi>c</mi> <mo>←</mo> <mi>y</mi></mrow></math>
    ），因此 *c* 是 *x* 和 *y* 的共同结果。'
- en: '![confounder and collider](assets/dshp_1501.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![混杂因素和碰撞器](assets/dshp_1501.png)'
- en: 'Figure 15-1\. DAGs with confounder and collider: no causal effect'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-1\. 有混杂因素和碰撞器的 DAG 图：没有因果效应
- en: Confounder bias arises when two possibly unrelated variables ( <math alttext="x
    comma y"><mrow><mi>x</mi> <mo>,</mo> <mi>y</mi></mrow></math> ) have a common
    cause ( <math alttext="c"><mi>c</mi></math> ). If you run a regression of <math
    alttext="y"><mi>y</mi></math> on <math alttext="x"><mi>x</mi></math> , *without
    controlling for <math alttext="c"><mi>c</mi></math>* , you will find that they
    are spuriously correlated. If the confounder is observed, all you need to do is
    condition on the confounder, and the causal relation, if any, will be identified.
    The problem arises with *unobserved* confounders, since by definition you can’t
    control for them. In this case, you won’t be able to identify the causal effect,
    if there is one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个可能无关的变量（ <math alttext="x comma y"><mrow><mi>x</mi> <mo>,</mo> <mi>y</mi></mrow></math>
    ）有一个共同的原因（ <math alttext="c"><mi>c</mi></math> ）时，会出现混杂因素偏差。如果你在 *y* 对 *x* 的回归中运行，*不控制
    <math alttext="c"><mi>c</mi></math>* ，你会发现它们是虚假相关的。如果混杂因素是可观察的，你只需要对混杂因素进行条件处理，如果有因果关系，它将被确定。问题出现在
    *未观察到* 的混杂因素上，因为根据定义，你无法控制它们。在这种情况下，你将无法确定因果效应是否存在。
- en: A *collider* is a common effect of two variables, and is a typical example of
    a bad control, in the sense that including it in your regression will bias your
    estimates. If you run a regression of *y* on *x* and control for *c*, you will
    find a spurious relation that doesn’t exist.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞器（*collider*）是两个变量的常见效应，是糟糕控制的典型例子，这意味着将其包含在回归中会偏离你的估计。如果你在 *y* 对 *x* 的回归中控制了
    *c*，你会发现一个不存在的虚假关系。
- en: 'To get a sense of what happens, I simulate the following data generating processes
    for a confounder (note that there’s no causal effect from *x* to *y*):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解发生的情况，我模拟了以下数据生成过程，涉及到混杂因素（请注意，从 *x* 到 *y* 没有因果效应）：
- en: <math alttext="StartLayout 1st Row 1st Column c 2nd Column tilde 3rd Column
    upper N left-parenthesis 0 comma 1 right-parenthesis 2nd Row 1st Column epsilon
    Subscript x 2nd Column tilde 3rd Column upper N left-parenthesis 0 comma 1 right-parenthesis
    3rd Row 1st Column epsilon Subscript y 2nd Column tilde 3rd Column upper N left-parenthesis
    0 comma 2 right-parenthesis 4th Row 1st Column x 2nd Column equals 3rd Column
    10 plus 0.5 c plus epsilon Subscript x 5th Row 1st Column y 2nd Column equals
    3rd Column negative 2 plus 3 c plus epsilon Subscript y EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>c</mi></mtd> <mtd><mo>∼</mo></mtd>
    <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><msub><mi>ϵ</mi> <mi>x</mi></msub></mtd>
    <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><msub><mi>ϵ</mi>
    <mi>y</mi></msub></mtd> <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi>
    <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>2</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mi>x</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mn>10</mn>
    <mo>+</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mi>c</mi> <mo>+</mo> <msub><mi>ϵ</mi>
    <mi>x</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mo>-</mo> <mn>2</mn> <mo>+</mo>
    <mn>3</mn> <mi>c</mi> <mo>+</mo> <msub><mi>ϵ</mi> <mi>y</mi></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column c 2nd Column tilde 3rd Column
    upper N left-parenthesis 0 comma 1 right-parenthesis 2nd Row 1st Column epsilon
    Subscript x 2nd Column tilde 3rd Column upper N left-parenthesis 0 comma 1 right-parenthesis
    3rd Row 1st Column epsilon Subscript y 2nd Column tilde 3rd Column upper N left-parenthesis
    0 comma 2 right-parenthesis 4th Row 1st Column x 2nd Column equals 3rd Column
    10 plus 0.5 c plus epsilon Subscript x 5th Row 1st Column y 2nd Column equals
    3rd Column negative 2 plus 3 c plus epsilon Subscript y EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mi>c</mi></mtd> <mtd><mo>∼</mo></mtd>
    <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><msub><mi>ϵ</mi> <mi>x</mi></msub></mtd>
    <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><msub><mi>ϵ</mi>
    <mi>y</mi></msub></mtd> <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi>
    <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>2</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mi>x</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mn>10</mn>
    <mo>+</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn> <mi>c</mi> <mo>+</mo> <msub><mi>ϵ</mi>
    <mi>x</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mo>-</mo> <mn>2</mn> <mo>+</mo>
    <mn>3</mn> <mi>c</mi> <mo>+</mo> <msub><mi>ϵ</mi> <mi>y</mi></msub></mrow></mtd></mtr></mtable></math>
- en: 'Similarly, the data generating processes for a collider are (again, there’s
    no causal effect from *x* to *y*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，碰撞器的数据生成过程如下（同样，从 *x* 到 *y* 没有因果效应）：
- en: <math alttext="StartLayout 1st Row 1st Column epsilon Subscript x 2nd Column
    tilde 3rd Column upper N left-parenthesis 0 comma 1 right-parenthesis 2nd Row
    1st Column epsilon Subscript y 2nd Column tilde 3rd Column upper N left-parenthesis
    0 comma 2 right-parenthesis 3rd Row 1st Column epsilon Subscript c 2nd Column
    tilde 3rd Column upper N left-parenthesis 0 comma 0.1 right-parenthesis 4th Row
    1st Column x 2nd Column equals 3rd Column 10 plus epsilon Subscript x 5th Row
    1st Column y 2nd Column equals 3rd Column negative 2 plus epsilon Subscript y
    6th Row 1st Column c 2nd Column equals 3rd Column 5 minus 2 x plus 10 y plus epsilon
    Subscript c EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>ϵ</mi>
    <mi>x</mi></msub></mtd> <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi>
    <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><msub><mi>ϵ</mi> <mi>y</mi></msub></mtd> <mtd><mo>∼</mo></mtd>
    <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>2</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><msub><mi>ϵ</mi> <mi>c</mi></msub></mtd>
    <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mn>0</mn> <mo>.</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mi>x</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mn>10</mn>
    <mo>+</mo> <msub><mi>ϵ</mi> <mi>x</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mo>-</mo> <mn>2</mn> <mo>+</mo>
    <msub><mi>ϵ</mi> <mi>y</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>c</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mn>5</mn> <mo>-</mo> <mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mi>y</mi> <mo>+</mo> <msub><mi>ϵ</mi> <mi>c</mi></msub></mrow></mtd></mtr></mtable></math>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column epsilon Subscript x 2nd Column
    tilde 3rd Column upper N left-parenthesis 0 comma 1 right-parenthesis 2nd Row
    1st Column epsilon Subscript y 2nd Column tilde 3rd Column upper N left-parenthesis
    0 comma 2 right-parenthesis 3rd Row 1st Column epsilon Subscript c 2nd Column
    tilde 3rd Column upper N left-parenthesis 0 comma 0.1 right-parenthesis 4th Row
    1st Column x 2nd Column equals 3rd Column 10 plus epsilon Subscript x 5th Row
    1st Column y 2nd Column equals 3rd Column negative 2 plus epsilon Subscript y
    6th Row 1st Column c 2nd Column equals 3rd Column 5 minus 2 x plus 10 y plus epsilon
    Subscript c EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>ϵ</mi>
    <mi>x</mi></msub></mtd> <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi>
    <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><msub><mi>ϵ</mi> <mi>y</mi></msub></mtd> <mtd><mo>∼</mo></mtd>
    <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mn>2</mn>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><msub><mi>ϵ</mi> <mi>c</mi></msub></mtd>
    <mtd><mo>∼</mo></mtd> <mtd columnalign="left"><mrow><mi>N</mi> <mo>(</mo> <mn>0</mn>
    <mo>,</mo> <mn>0</mn> <mo>.</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mi>x</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mn>10</mn>
    <mo>+</mo> <msub><mi>ϵ</mi> <mi>x</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mo>-</mo> <mn>2</mn> <mo>+</mo>
    <msub><mi>ϵ</mi> <mi>y</mi></msub></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>c</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mn>5</mn> <mo>-</mo> <mn>2</mn>
    <mi>x</mi> <mo>+</mo> <mn>10</mn> <mi>y</mi> <mo>+</mo> <msub><mi>ϵ</mi> <mi>c</mi></msub></mrow></mtd></mtr></mtable></math>
- en: I then run a Monte Carlo (MC) simulation where I estimate linear regressions
    of *y* on *x* with and without controlling for *c*. I report the estimated coefficient
    for the feature *x* and 95% confidence intervals in [Figure 15-2](#ch15_confounder_python).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我进行了一个蒙特卡洛（MC）模拟，在这里我估计了在是否控制 *c* 的情况下，*y* 对 *x* 的线性回归。我报告了特征 *x* 的估计系数和 95%
    置信区间在 [图 15-2](#ch15_confounder_python)。
- en: '![mc simulation confounder](assets/dshp_1502.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛模拟混杂因素](assets/dshp_1502.png)'
- en: Figure 15-2\. Confounder and collider bias (parameter estimate and 95% confidence
    interval)
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-2\. 混杂因素和碰撞器偏差（参数估计和 95% 置信区间）
- en: For the confounder case, not controlling for *c* creates a statistically significant
    spurious correlation that would incorrectly indicate that *x* and *y* are related
    (even worse, you might end up concluding that *x* causes *y*). Notably, this correlation
    disappears once you include the confounder in the regression, leading to a correct
    inference about the nonexistent relation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于混杂因素的情况，如果不控制 *c*，会产生一个统计显著的虚假相关，错误地表明 *x* 和 *y* 有关联（更糟糕的是，你可能会得出 *x* 导致 *y*
    的结论）。显著的是，一旦在回归中包含混杂因素，这种相关性就会消失，从而对不存在的关系做出正确推断。
- en: 'With the collider, the opposite happens: since it’s a bad control, *excluding*
    it from the regression allows you to estimate a statistically insignificant effect
    of *x* on *y*. If you mistakenly think that *c* should be included as a feature,
    you end up concluding that there’s a causal effect when there is none.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于碰撞者，情况恰恰相反：由于它是一个不好的控制变量，从回归中*排除*它可以让你估计到*x*对*y*的统计上不显著的影响。如果你错误地认为*c*应该作为一个特征包含进来，最终会得出在实际不存在因果效应的结论。
- en: Both of these biases are pervasive in applications and unfortunately depend
    critically on your causal model for the outcome. Put differently, before attempting
    to estimate a causal effect, you must come up with a model (a DAG) for your outcome.
    Only then can you decide whether your available data is sufficient for identification
    for a given causal effect. Specifically, you must control for any confounders
    and ensure that you don’t control for colliders (and sometimes these two considerations
    clash with each other, since a variable might be a confounder and a collider at
    the same time).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种偏倚在应用中普遍存在，不幸的是，它们在很大程度上取决于你对结果的因果模型。换句话说，在尝试估计因果效应之前，你必须提出一个（DAG）模型来描述你的结果。只有这样，你才能决定你的可用数据是否足以识别给定因果效应。具体来说，你必须控制任何混淆因素，并确保你不控制碰撞者（有时这两个考虑会互相冲突，因为一个变量可能既是混淆因素又是碰撞者）。
- en: 'This process is often called the *back-door criterion*: with confounders you
    have to close any back doors by controlling for them, and with colliders the opposite
    applies; otherwise, you open those back doors and can’t identify the causal effect.^([3](ch15.html#id780))'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程通常被称为*反门标准*：对于混淆因素，你必须通过控制它们关闭任何反门，而对于碰撞者则相反；否则，你会打开这些反门，无法确定因果效应。^([3](ch15.html#id780))
- en: 'Another practical problem that arises has to do with proxy confounders. As
    already mentioned, unobserved confounders preclude identification of a causal
    effect, so you might be tempted to use proxy variables that are somewhat correlated
    with the confounder. The hope is that you can still estimate a causal effect using
    these less-than-optimal substitutes. Unfortunately, the answer is not good: the
    extent of the bias depends critically on the strength of the correlation. [Figure 15-3](#ch15_confounder_proxy)
    shows this for an MC simulation for the case of a confounder and a true causal
    effect of *x* on *y*.^([4](ch15.html#id782))'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常出现的实际问题与代理混淆因素有关。如前所述，未观察到的混淆因素阻止了因果效应的识别，因此你可能会倾向于使用与混淆因素有一定相关性的代理变量。希望仍能使用这些不太理想的替代品来估计因果效应。不幸的是，答案并不乐观：偏倚的程度在很大程度上取决于相关性的强度。[图 15-3](#ch15_confounder_proxy)
    展示了这一点，这是一个关于混淆因素和*x*对*y*真实因果效应的 MC 模拟案例。^([4](ch15.html#id782))
- en: '![confounder proxy](assets/dshp_1503.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![代理混淆](assets/dshp_1503.png)'
- en: Figure 15-3\. Confounder bias with correlated proxies
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-3\. 具有相关代理的混淆偏倚
- en: Selection Bias
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择偏倚
- en: '*Selection bias* is a very important concept for causal analysis, but it has
    [different meanings](https://oreil.ly/TGxkr) to different schools of thought.
    For statisticians and economists, it’s associated with selection *into* the treatment,
    and for computer scientists it refers to a post-treatment selection that changes
    the sample of respondents; the former is a kind of confounding bias, and the latter
    produces a completely different DAG (better associated with survivorship bias,
    as discussed in [Chapter 6](ch06.html#ch06_lift)). In this section I’ll refer
    to the former (selection into the treatment), which is commonly associated with
    the potential outcomes literature. I will now introduce this notation.^([5](ch15.html#id783))'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择偏倚* 是因果分析中非常重要的概念，但它对不同学派有[不同的含义](https://oreil.ly/TGxkr)。对于统计学家和经济学家来说，它与进入治疗的选择相关，对于计算机科学家来说，则指的是改变受访者样本的治疗后选择；前者是一种混淆偏倚，后者产生完全不同的
    DAG（更好地与生存偏倚相关，如[第 6 章](ch06.html#ch06_lift) 中讨论的）。在本节中，我将引用前者（选择进入治疗），这通常与潜在结果文献相关。现在我将介绍这种标记法。^([5](ch15.html#id783))'
- en: 'The idea of potential outcomes is closely related to counterfactuals. Consider
    the case of a binary treatment ( <math alttext="upper D"><mi>D</mi></math> ),
    where each unit *i* either gets it ( <math alttext="upper D Subscript i Baseline
    equals 1"><mrow><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math>
    ) or not ( <math alttext="upper D Subscript i Baseline equals 0"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math> ). There’s a unique potential
    outcome associated with each level of the treatment, denoted by <math alttext="upper
    Y Subscript 1 i"><msub><mi>Y</mi> <mrow><mn>1</mn><mi>i</mi></mrow></msub></math>
    or <math alttext="upper Y Subscript 0 i"><msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub></math>
    , corresponding to getting or not getting the treatment, respectively. For each
    unit we observe one and only one of these potential outcomes, denoted by <math
    alttext="upper Y Subscript i"><msub><mi>Y</mi> <mi>i</mi></msub></math> ; the
    other potential outcome is counterfactual so you don’t observe it. The relation
    between the observed outcome and the potential outcomes can be summarized by:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在结果的概念与反事实情形密切相关。考虑二进制处理（<math alttext="upper D"><mi>D</mi></math> ），其中每个单元
    *i* 要么获得它（<math alttext="upper D Subscript i Baseline equals 1"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math> ），要么不获得它（<math alttext="upper
    D Subscript i Baseline equals 0"><mrow><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo>
    <mn>0</mn></mrow></math> ）。每种处理水平都有一个独特的潜在结果，分别表示获得或未获得处理，分别标记为 <math alttext="upper
    Y Subscript 1 i"><msub><mi>Y</mi> <mrow><mn>1</mn><mi>i</mi></mrow></msub></math>
    或 <math alttext="upper Y Subscript 0 i"><msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub></math>
    。对于每个单元，我们观察到其中一个且仅有一个潜在结果，标记为 <math alttext="upper Y Subscript i"><msub><mi>Y</mi>
    <mi>i</mi></msub></math> ；另一个潜在结果是反事实的，因此无法观察到。观察结果与潜在结果之间的关系可以总结为：
- en: <math alttext="StartLayout 1st Row 1st Column upper Y Subscript i 2nd Column
    equals 3rd Column StartLayout Enlarged left-brace 1st Row  upper Y Subscript 1
    i Baseline if upper D Subscript i Baseline equals 1 2nd Row  upper Y Subscript
    0 i Baseline if upper D Subscript i Baseline equals 0 EndLayout EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>Y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mfenced close="" open="{" separators=""><mtable><mtr><mtd
    columnalign="left"><mrow><msub><mi>Y</mi> <mrow><mn>1</mn><mi>i</mi></mrow></msub>
    <mtext>if</mtext> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mtext>if</mtext> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></mtd></mtr></mtable></math>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column upper Y Subscript i 2nd Column
    equals 3rd Column StartLayout Enlarged left-brace 1st Row  upper Y Subscript 1
    i Baseline if upper D Subscript i Baseline equals 1 2nd Row  upper Y Subscript
    0 i Baseline if upper D Subscript i Baseline equals 0 EndLayout EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><msub><mi>Y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mfenced close="" open="{" separators=""><mtable><mtr><mtd
    columnalign="left"><mrow><msub><mi>Y</mi> <mrow><mn>1</mn><mi>i</mi></mrow></msub>
    <mtext>if</mtext> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mtext>if</mtext> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></mtd></mtr></mtable></mfenced></mtd></mtr></mtable></math>
- en: Alternatively, <math alttext="upper Y Subscript i Baseline equals upper Y Subscript
    0 i Baseline plus left-parenthesis upper Y Subscript 1 i Baseline minus upper
    Y Subscript 0 i Baseline right-parenthesis upper D Subscript i"><mrow><msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>=</mo> <msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mo>+</mo> <mrow><mo>(</mo> <msub><mi>Y</mi> <mrow><mn>1</mn><mi>i</mi></mrow></msub>
    <mo>-</mo> <msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>)</mo></mrow>
    <msub><mi>D</mi> <mi>i</mi></msub></mrow></math> , which maps quite neatly to
    the structure of a linear regression of the outcome on the treatment dummy variable
    and an intercept.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，<math alttext="upper Y Subscript i Baseline equals upper Y Subscript 0 i
    Baseline plus left-parenthesis upper Y Subscript 1 i Baseline minus upper Y Subscript
    0 i Baseline right-parenthesis upper D Subscript i"><mrow><msub><mi>Y</mi> <mi>i</mi></msub>
    <mo>=</mo> <msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>+</mo>
    <mrow><mo>(</mo> <msub><mi>Y</mi> <mrow><mn>1</mn><mi>i</mi></mrow></msub> <mo>-</mo>
    <msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>)</mo></mrow> <msub><mi>D</mi>
    <mi>i</mi></msub></mrow></math> ，这与对结果在处理虚拟变量和截距上进行线性回归的结构非常吻合。
- en: One advantage of thinking about causality in terms of potential outcomes is
    that the problem is essentially one of missing data. [Table 15-1](#ch15_missingvals)
    shows one example, where each row denotes a customer. You only observe *Y* and
    *D*, from which you can immediately fill out the potential outcomes using the
    above logic. Were we able to observe each counterfactual outcome, we would be
    able to estimate the causal effect.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用潜在结果来思考因果关系的一个优势是问题本质上是缺失数据问题。[表 15-1](#ch15_missingvals) 展示了一个例子，其中每行代表一个客户。您只观察到
    *Y* 和 *D*，根据上述逻辑，您可以立即填写潜在结果。如果我们能够观察到每个反事实结果，我们就能够估计因果效应。
- en: Table 15-1\. Potential outcomes and missing values
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-1\. 潜在结果和缺失数值
- en: '|  | Y | Y0 | Y1 | D |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  | Y | Y0 | Y1 | D |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | 6.28 | 6.28 | NaN | 0 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 6.28 | 6.28 | NaN | 0 |'
- en: '| 2 | 8.05 | 8.05 | NaN | 0 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 8.05 | 8.05 | NaN | 0 |'
- en: '| 18 | 8.70 | NaN | 8.70 | 1 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 8.70 | NaN | 8.70 | 1 |'
- en: '| 7 | 8.90 | NaN | 8.90 | 1 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 8.90 | NaN | 8.90 | 1 |'
- en: '| 0 | 9.23 | 9.23 | NaN | 0 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 9.23 | 9.23 | NaN | 0 |'
- en: '| 16 | 9.44 | NaN | 9.44 | 1 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 9.44 | NaN | 9.44 | 1 |'
- en: To provide an example, suppose I want to estimate whether providing a GitHub
    repo with accompanying code for the book is incremental to the book’s sales. My
    intuition is that knowing that there’s available code increases the likelihood
    of a purchase, either because potential customers think the book is of higher
    quality, or because they know that the learning path is easier with code, I’d
    like to quantify the effect, since creating a code repo is costly. I will communicate
    and make it available to a sample of visitors to my web page ( <math alttext="upper
    D Subscript i Baseline equals 1"><mrow><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo>
    <mn>1</mn></mrow></math> ); to the remaining visitors I don’t make it available
    ( <math alttext="upper D Subscript i Baseline equals 0"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math> ). The outcome is a binary
    variable, denoting a sale ( <math alttext="upper Y Subscript i Baseline equals
    1"><mrow><msub><mi>Y</mi> <mi>i</mi></msub> <mo>=</mo> <mn>1</mn></mrow></math>
    ) or no sale ( <math alttext="upper Y Subscript i Baseline equals 0"><mrow><msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math> ).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设我想估计为书籍提供伴随代码的 GitHub 仓库是否增加了书籍的销量。我的直觉是，知道有可用的代码会增加购买的可能性，可能是因为潜在客户认为这本书质量更高，或者因为他们知道有代码可以更轻松地学习路径，我希望量化这种影响，因为创建代码仓库是昂贵的。我会与我的网页访客样本进行沟通并提供（
    <math alttext="上标 D 下标 i 基线 等于 1"><mrow><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo>
    <mn>1</mn></mrow></math> ）；对于其余访客，我不会提供（ <math alttext="上标 D 下标 i 基线 等于 0"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math> ）。结果是一个二进制变量，表示销售（ <math
    alttext="上标 Y 下标 i 基线 等于 1"><mrow><msub><mi>Y</mi> <mi>i</mi></msub> <mo>=</mo>
    <mn>1</mn></mrow></math> ）或无销售（ <math alttext="上标 Y 下标 i 基线 等于 0"><mrow><msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>=</mo> <mn>0</mn></mrow></math> ）。
- en: 'For each unit *i*, <math alttext="upper Y Subscript 1 i Baseline minus upper
    Y Subscript 0 i"><mrow><msub><mi>Y</mi> <mrow><mn>1</mn><mi>i</mi></mrow></msub>
    <mo>-</mo> <msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub></mrow></math>
    is the causal effect of providing code. Since only one of these is observed for
    each unit, we need to estimate it using the sample of those who get and don’t
    get the treatment. One natural way to estimate it is the *observed difference
    in means*: <math alttext="upper E left-parenthesis upper Y Subscript i Baseline
    vertical-bar upper D Subscript i Baseline equals 1 right-parenthesis minus upper
    E left-parenthesis upper Y Subscript i Baseline vertical-bar upper D Subscript
    i Baseline equals 0 right-parenthesis"><mrow><mi>E</mi> <mrow><mo>(</mo> <msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>|</mo> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>1</mn>
    <mo>)</mo></mrow> <mo>-</mo> <mi>E</mi> <mrow><mo>(</mo> <msub><mi>Y</mi> <mi>i</mi></msub>
    <mo>|</mo> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
    . In practice, you replace the expectations with sample moments to get <math alttext="upper
    Y overbar Subscript upper D Sub Subscript i Subscript equals 1 Baseline minus
    upper Y overbar Subscript upper D Sub Subscript i Subscript equals 0"><mrow><msub><mover><mi>Y</mi>
    <mo>¯</mo></mover> <mrow><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>1</mn></mrow></msub>
    <mo>-</mo> <msub><mover><mi>Y</mi> <mo>¯</mo></mover> <mrow><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>0</mn></mrow></msub></mrow></math> , explaining why I say it’s *observed*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个单元 *i*，<math alttext="上标 Y 下标 1 i 减去 上标 Y 下标 0 i"><mrow><msub><mi>Y</mi>
    <mrow><mn>1</mn><mi>i</mi></mrow></msub> <mo>-</mo> <msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub></mrow></math>
    是提供代码的因果效应。由于每个单元只观察到其中一个，我们需要使用接受和未接受治疗的样本来估计它。估计它的一种自然方式是*均值差的观察值*：<math alttext="上标
    E 左括号 上标 Y 下标 i 基线 竖线 上标 D 下标 i 基线 等于 1 右括号 减去 上标 E 左括号 上标 Y 下标 i 基线 竖线 上标 D 下标
    i 基线 等于 0 右括号"><mrow><mi>E</mi> <mrow><mo>(</mo> <msub><mi>Y</mi> <mi>i</mi></msub>
    <mo>|</mo> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>1</mn> <mo>)</mo></mrow>
    <mo>-</mo> <mi>E</mi> <mrow><mo>(</mo> <msub><mi>Y</mi> <mi>i</mi></msub> <mo>|</mo>
    <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo> <mn>0</mn> <mo>)</mo></mrow></mrow></math>
    。在实践中，您可以用样本矩代替期望得到<math alttext="上标 Y 横线 上标 D 下标 i 下标 等于 1 基线 减去 上标 Y 横线 上标 D
    下标 i 下标 等于 0"><mrow><msub><mover><mi>Y</mi> <mo>¯</mo></mover> <mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>=</mo><mn>1</mn></mrow></msub> <mo>-</mo> <msub><mover><mi>Y</mi>
    <mo>¯</mo></mover> <mrow><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>0</mn></mrow></msub></mrow></math>
    ，这解释了为什么我说它是*观察到的*。
- en: 'The bad news is that the observed difference does not estimate the causal effect
    in the presence of selection bias:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，观察到的差异在存在选择偏差时无法估计因果效应。
- en: <math alttext="ModifyingBelow upper E left-parenthesis upper Y Subscript i Baseline
    vertical-bar upper D Subscript i Baseline equals 1 right-parenthesis minus upper
    E left-parenthesis upper Y Subscript i Baseline vertical-bar upper D Subscript
    i Baseline equals 0 right-parenthesis With bottom-brace Underscript Observed Difference
    in Means Endscripts equals ModifyingBelow upper E left-parenthesis upper Y Subscript
    1 i Baseline minus upper Y Subscript 0 i Baseline vertical-bar upper D Subscript
    i Baseline equals 1 right-parenthesis With bottom-brace Underscript ATT left-parenthesis
    casual effect right-parenthesis Endscripts plus ModifyingBelow upper E left-parenthesis
    upper Y Subscript 0 i Baseline vertical-bar upper D Subscript i Baseline equals
    1 right-parenthesis minus upper E left-parenthesis upper Y Subscript 0 i Baseline
    vertical-bar upper D Subscript i Baseline equals 0 right-parenthesis With bottom-brace
    Underscript Selection Bias Endscripts" display="block"><mrow><munder><munder accentunder="true"><mrow><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>0</mn><mo>)</mo></mrow></mrow>
    <mo>︸</mo></munder> <mrow><mtext>Observed</mtext><mtext>Difference</mtext><mtext>in</mtext><mtext>Means</mtext></mrow></munder>
    <mo>=</mo> <munder><munder accentunder="true"><mrow><mi>E</mi><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>1</mn><mi>i</mi></mrow></msub> <mo>-</mo><msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>1</mn><mo>)</mo></mrow>
    <mo>︸</mo></munder> <mrow><mtext>ATT</mtext><mtext>(casual</mtext><mtext>effect)</mtext></mrow></munder>
    <mo>+</mo> <munder><munder accentunder="true"><mrow><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>0</mn><mo>)</mo></mrow></mrow> <mo>︸</mo></munder> <mrow><mtext>Selection</mtext><mtext>Bias</mtext></mrow></munder></mrow></math>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="ModifyingBelow upper E left-parenthesis upper Y Subscript i Baseline
    vertical-bar upper D Subscript i Baseline equals 1 right-parenthesis minus upper
    E left-parenthesis upper Y Subscript i Baseline vertical-bar upper D Subscript
    i Baseline equals 0 right-parenthesis With bottom-brace Underscript Observed Difference
    in Means Endscripts equals ModifyingBelow upper E left-parenthesis upper Y Subscript
    1 i Baseline minus upper Y Subscript 0 i Baseline vertical-bar upper D Subscript
    i Baseline equals 1 right-parenthesis With bottom-brace Underscript ATT left-parenthesis
    casual effect right-parenthesis Endscripts plus ModifyingBelow upper E left-parenthesis
    upper Y Subscript 0 i Baseline vertical-bar upper D Subscript i Baseline equals
    1 right-parenthesis minus upper E left-parenthesis upper Y Subscript 0 i Baseline
    vertical-bar upper D Subscript i Baseline equals 0 right-parenthesis With bottom-brace
    Underscript Selection Bias Endscripts" display="block"><mrow><munder><munder accentunder="true"><mrow><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mi>i</mi></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>0</mn><mo>)</mo></mrow></mrow>
    <mo>︸</mo></munder> <mrow><mtext>Observed</mtext><mtext>Difference</mtext><mtext>in</mtext><mtext>Means</mtext></mrow></munder>
    <mo>=</mo> <munder><munder accentunder="true"><mrow><mi>E</mi><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>1</mn><mi>i</mi></mrow></msub> <mo>-</mo><msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo><mn>1</mn><mo>)</mo></mrow>
    <mo>︸</mo></munder> <mrow><mtext>ATT</mtext><mtext>(casual</mtext><mtext>effect)</mtext></mrow></munder>
    <mo>+</mo> <munder><munder accentunder="true"><mrow><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>1</mn><mo>)</mo></mrow><mo>-</mo><mi>E</mi><mrow><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>0</mn><mo>)</mo></mrow></mrow> <mo>︸</mo></munder> <mrow><mtext>Selection</mtext><mtext>Bias</mtext></mrow></munder></mrow></math>
- en: 'This decomposition is quite handy because it shows that in the presence of
    selection bias, the observed difference in means will deviate from the causal
    effect of interest, commonly denoted by the *average treatment effect on the treated*
    (ATT). The ATT answers the following question: looking only at those who received
    the treatment, what is the expected difference in outcomes between what they got
    and what they would’ve gotten had they not received the treatment? The second
    outcome is counterfactual, so the difference provides the causal effect on them.^([6](ch15.html#id786))'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分解非常方便，因为它显示出在存在选择偏差的情况下，观察到的均值差异将偏离感兴趣的因果效应，通常用*接受治疗对象的平均处理效应*（ATT）表示。ATT回答以下问题：仅看接受治疗的人群，其结果与如果他们没有接受治疗时的预期结果有什么不同？第二个结果是反事实的，因此差异提供了对其的因果效应。^([6](ch15.html#id786))
- en: 'The third term represents selection bias and shows why the observed difference
    in means may deviate from the causal effect. To explain what this means, I will
    now use the following notation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三项表示选择偏差，并显示为什么观察到的均值差异可能偏离因果效应。为了解释这意味着什么，我现在将使用以下符号：
- en: <math alttext="Selection Bias equals ModifyingBelow upper E left-parenthesis
    upper Y Subscript 0 i Baseline vertical-bar upper D Subscript i Baseline equals
    1 right-parenthesis With bottom-brace Underscript upper A Endscripts minus ModifyingBelow
    upper E left-parenthesis upper Y Subscript 0 i Baseline vertical-bar upper D Subscript
    i Baseline equals 0 right-parenthesis With bottom-brace Underscript upper B Endscripts"
    display="block"><mrow><mtext>Selection</mtext> <mtext>Bias</mtext> <mo>=</mo>
    <munder><munder accentunder="true"><mrow><mi>E</mi><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>1</mn><mo>)</mo></mrow> <mo>︸</mo></munder> <mi>A</mi></munder>
    <mo>-</mo> <munder><munder accentunder="true"><mrow><mi>E</mi><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>0</mn><mo>)</mo></mrow> <mo>︸</mo></munder> <mi>B</mi></munder></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Selection Bias equals ModifyingBelow upper E left-parenthesis
    upper Y Subscript 0 i Baseline vertical-bar upper D Subscript i Baseline equals
    1 right-parenthesis With bottom-brace Underscript upper A Endscripts minus ModifyingBelow
    upper E left-parenthesis upper Y Subscript 0 i Baseline vertical-bar upper D Subscript
    i Baseline equals 0 right-parenthesis With bottom-brace Underscript upper B Endscripts"
    display="block"><mrow><mtext>Selection</mtext> <mtext>Bias</mtext> <mo>=</mo>
    <munder><munder accentunder="true"><mrow><mi>E</mi><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>1</mn><mo>)</mo></mrow> <mo>︸</mo></munder> <mi>A</mi></munder>
    <mo>-</mo> <munder><munder accentunder="true"><mrow><mi>E</mi><mo>(</mo><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>|</mo><msub><mi>D</mi> <mi>i</mi></msub>
    <mo>=</mo><mn>0</mn><mo>)</mo></mrow> <mo>︸</mo></munder> <mi>B</mi></munder></mrow></math>
- en: Going back to the example, you can think of the code repo as a costly lever
    for a company (in this case, me) that can be assigned to everyone, or assigned
    selectively. [Figure 15-4](#ch15_pos_selection) shows the two types of selection
    bias. When there’s positive (negative) selection, the causal effect tends to be
    overestimated (underestimated).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回到例子，你可以把代码库看作是一种昂贵的杠杆，公司（在这种情况下是我）可以分配给每个人，或者有选择性地分配。[图15-4](#ch15_pos_selection)展示了两种类型的选择偏差。当存在正向（负向）选择时，因果效应往往被高估（低估）。
- en: '![positive selection](assets/dshp_1505.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![正向选择](assets/dshp_1505.png)'
- en: Figure 15-4\. Positive and negative selection
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-4\. 正向和负向选择
- en: Let’s start with positive selection, which happens if I give the treatment to
    those that are already *more likely* to purchase the book. Alternatively, the
    probability of a sale is from the upstart higher for those who get the repo, independent
    of the incrementality of the lever. This means that <math alttext="upper A greater-than-or-equal-to
    upper B"><mrow><mi>A</mi> <mo>≥</mo> <mi>B</mi></mrow></math> , overestimating
    the casual effect. A similar argument shows that with negative selection <math
    alttext="upper A less-than-or-equal-to upper B"><mrow><mi>A</mi> <mo>≤</mo> <mi>B</mi></mrow></math>
    , and the casual effect is underestimated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从正向选择开始，如果我将治疗方法给予那些已经*更有可能*购买这本书的人。或者，销售概率对于获得代码库的人来说更高，独立于杠杆的增量性。这意味着 <math
    alttext="upper A greater-than-or-equal-to upper B"><mrow><mi>A</mi> <mo>≥</mo>
    <mi>B</mi></mrow></math> ，从而高估了因果效应。类似的论点表明，负向选择下 <math alttext="upper A less-than-or-equal-to
    upper B"><mrow><mi>A</mi> <mo>≤</mo> <mi>B</mi></mrow></math> ，因果效应被低估。
- en: Selection bias is pervasive in observational data. Either you (or someone from
    the company) selected the participants in the treatment, or the customers self-selected
    themselves. The code repo example is typical of selection by the company, but
    self-selection is also very common. In [Chapter 4](ch04.html#ch04_2x2_designs)
    I introduced the idea of *adverse selection* where the riskiest customers—​in
    terms of not being able to repay a loan—​are also more willing to accept the offer.
    Adverse selection is a common example of self-selection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察数据中，选择偏差普遍存在。要么你（或者公司的某人）选择了治疗的参与者，要么客户自行选择参与。代码库示例是公司选择的典型例子，但自我选择也非常常见。在[第四章](ch04.html#ch04_2x2_designs)中，我介绍了*逆向选择*的概念，即那些在无法偿还贷款方面最危险的客户也更愿意接受提议。逆向选择是自我选择的常见示例。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: A thorough understanding of selection bias in your specific use case can take
    you very far in your quest to understand and estimate causal relations. Whenever
    you are looking at incrementality, ask yourself if there’s any type of selection
    bias possible. This means that you have to think hard about the selection mechanism
    into the treatment you’re analyzing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 深入理解你特定用例中的选择偏差，能在理解和估计因果关系的过程中帮助你取得很大进展。每当你关注增量性时，要问自己是否可能存在任何类型的选择偏差。这意味着你必须认真考虑进入你分析的治疗方法的选择机制。
- en: 'Luckily, checking for selection bias is conceptually straightforward: take
    a set of *pretreatment* variables *X* and compute the difference for those in
    the treatment and control groups. Pretreatment variables are those that may affect
    selection into the treatment. [Chapter 6](ch06.html#ch06_lift) showed how lifts
    can be used, but for statistical reasons it’s more common to use difference in
    means instead of a ratio (as this gives rise to a standard *t*-test).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，检查选择偏倚在概念上是直观的：取一组*治疗前*变量*X*，并计算治疗组和对照组的差异。治疗前变量是可能影响选择进入治疗的变量。[第6章](ch06.html#ch06_lift)展示了如何使用提升度，但基于统计原因，更常见的是使用均值差异而不是比率（因为这会导致标准*t*检验）。
- en: '![dag unconfoundedness](assets/dshp_1506.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![dag unconfoundedness](assets/dshp_1506.png)'
- en: Figure 15-5\. Selection bias and confounders
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-5\. 选择偏倚和混杂因素
- en: '[Figure 15-5](#ch15_dag_unconf) shows an example of a DAG that can be used
    to model selection bias. There are two sets of pretreatment variables ( <math
    alttext="upper Z 1 comma midline-horizontal-ellipsis comma upper Z 4 comma upper
    X"><mrow><msub><mi>Z</mi> <mn>1</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>Z</mi>
    <mn>4</mn></msub> <mo>,</mo> <mi>X</mi></mrow></math> ), all affecting selection
    into treatment ( <math alttext="upper D"><mi>D</mi></math> ). Outcome ( <math
    alttext="upper Y"><mi>Y</mi></math> ) depends on the treatment and <math alttext="upper
    X"><mi>X</mi></math> . Note that *X* is a confounder, and that variables <math
    alttext="upper Z Subscript k"><msub><mi>Z</mi> <mi>k</mi></msub></math> create
    no bias if you control for the treatment. These other pretreatment variables may
    differ across treatment and control groups, but these differences don’t create
    selection bias.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-5](#ch15_dag_unconf)显示了一个可以用来建模选择偏倚的DAG示例。有两组治疗前变量（ <math alttext="upper
    Z 1 comma midline-horizontal-ellipsis comma upper Z 4 comma upper X"><mrow><msub><mi>Z</mi>
    <mn>1</mn></msub> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <msub><mi>Z</mi> <mn>4</mn></msub>
    <mo>,</mo> <mi>X</mi></mrow></math> ），都会影响选择进入治疗（ <math alttext="upper D"><mi>D</mi></math>
    ）。结果（ <math alttext="upper Y"><mi>Y</mi></math> ）取决于治疗和 <math alttext="upper X"><mi>X</mi></math>
    。注意*X*是一个混杂变量，变量 <math alttext="upper Z Subscript k"><msub><mi>Z</mi> <mi>k</mi></msub></math>
    如果你控制治疗就不会产生偏倚。这些其他治疗前变量可能在治疗和对照组之间有所不同，但这些差异不会造成选择偏倚。'
- en: Unconfoundedness Assumption
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无混杂假设
- en: With this in mind, it’s time to introduce the main assumption needed for the
    identification of causal effects. This assumption goes by different names, such
    as *unconfoundedness*, *ignorability*, *conditional exchangeability*, *selection
    on observables*, and *conditional independence*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，现在是时候介绍用于识别因果效应的主要假设了。这个假设有不同的名称，比如*无混杂性*、*可忽略性*、*条件交换性*、*可观察选择*和*条件独立性*。
- en: 'The assumption means that the potential outcomes and selection into treatment
    are statistically independent, conditional on a set of observed controls:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该假设意味着潜在结果和选择进入治疗在一组观察到的控制条件下是统计独立的：
- en: <math alttext="upper Y 0 comma upper Y 1 up-tack up-tack upper D vertical-bar
    upper X" display="block"><mrow><msub><mi>Y</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>Y</mi>
    <mn>1</mn></msub> <mrow><mo>⊥</mo> <mo>⊥</mo> <mi>D</mi> <mo>|</mo> <mi>X</mi></mrow></mrow></math>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper Y 0 comma upper Y 1 up-tack up-tack upper D vertical-bar
    upper X" display="block"><mrow><msub><mi>Y</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>Y</mi>
    <mn>1</mn></msub> <mrow><mo>⊥</mo> <mo>⊥</mo> <mi>D</mi> <mo>|</mo> <mi>X</mi></mrow></mrow></math>
- en: This critical assumption has two alternative interpretations, one from the point
    of view of the decision-maker (owner of the selection mechanism) and the other
    from the data scientist’s perspective.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这一关键假设有两种不同的解释，一种是从决策者（选择机制的所有者）的角度，另一种是从数据科学家的角度。
- en: Starting with the decision-maker, recall that selection into the treatment can
    either be done by the customer (self-selection) or by the owner of the treatment
    (you, or someone from your company). The assumption forbids that the decision-maker
    takes the potential outcomes into consideration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从决策者开始，记住选择进入治疗的方法可以由客户（自我选择）或治疗的所有者（你，或者你公司的某人）完成。该假设禁止决策者考虑潜在结果。
- en: 'For example, when discussing positive and negative selection, I was the owner
    of the selection mechanism, and it explicitly depended on whether I wanted to
    incentivize potential customers that were more or less likely to purchase organically.
    This is the same as saying that selection *depended on the potential outcomes*:
    if <math alttext="upper Y Subscript 0 i Baseline equals 0"><mrow><msub><mi>Y</mi>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub> <mo>=</mo> <mn>0</mn></mrow></math> ,
    the customer won’t purchase the book without access to the repo, so I may wish
    to incentivize them (negative selection). A similar rationale applies for positive
    selection. Both of these cases might lead to a violation of unconfoundedness.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在讨论正向和负向选择时，我是选择机制的所有者，这明确取决于我是否希望激励更有可能有机购买的潜在客户。这等同于说选择**取决于潜在结果**：如果 <math
    alttext="upper Y Subscript 0 i Baseline equals 0"><mrow><msub><mi>Y</mi> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mo>=</mo> <mn>0</mn></mrow></math> ，客户没有获取存储库的权限，则我可能希望激励他们（负向选择）。正向选择也有类似的理由。这两种情况都可能导致无混杂性的违反。
- en: 'From the data scientist’s perspective, you need to know in advance all of the
    relevant variables that could, in principle, affect the selection mechanism (you
    can then control for them and achieve conditional independence). I hope you can
    see why causal inference is so hard: not only do you need to have knowledge of
    the correct model for your outcome (the DAG), but you also need to observe all
    relevant variables. The latter explains why the assumption is also called *selection
    on observables*. Any unobserved confounders will result in selection bias. With
    observational data, both conditions are very hard to attain, which takes us to
    A/B testing.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据科学家的角度来看，您需要提前了解可能影响选择机制的所有相关变量（然后您可以控制它们并实现条件独立性）。希望您能明白因果推断之所以如此困难的原因：您不仅需要了解结果的正确模型（DAG），还需要观察所有相关变量。后者解释了为什么这个假设也被称为*可观测选择*。任何未观察到的混杂因素都会导致选择偏倚。对于观察数据，这两个条件都非常难以达到，这让我们进入了A/B测试。
- en: 'Breaking Selection Bias: Randomization'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破选择偏倚：随机化
- en: 'Randomized controlled trials (RCT), or A/B testing as it’s better known in
    the corporate jargon, are the quintessential method to estimate causal effects.
    The reason is that, by design, the unconfoundedness assumption is guaranteed:
    selection into the treatment depends only on the outcome of a pseudorandom draw,
    making it independent of the potential outcomes by construction.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随机对照试验（RCT）或者企业术语中更为人熟知的A/B测试，是估计因果效应的典型方法。原因在于，通过设计，无混杂性假设得到了保证：进入治疗组的选择仅依赖于伪随机抽取的结果，使得其独立于潜在结果。
- en: 'Let’s see how this works in practice. You need to first define the fraction
    of treated in a sample (*p*), which is usually set to one half in most common
    A/B test designs. You then draw from a uniform distribution (*u*) and define selection
    as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中是如何工作的。您需要首先定义样本中的受试者比例（*p*），在大多数常见的A/B测试设计中，通常将其设为一半。然后，您从均匀分布（*u*）中抽取，并定义选择为：
- en: <math alttext="StartLayout 1st Row  upper D Subscript i Baseline equals StartLayout
    Enlarged left-brace 1st Row 1st Column 1 2nd Column if 3rd Column u greater-than-or-equal-to
    p 2nd Row 1st Column 0 2nd Column if 3rd Column u less-than p EndLayout EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>=</mo> <mfenced close="" open="{" separators=""><mtable><mtr><mtd
    columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mtext>if</mtext></mtd>
    <mtd><mrow><mi>u</mi> <mo>≥</mo> <mi>p</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>0</mn></mtd>
    <mtd columnalign="left"><mtext>if</mtext></mtd> <mtd><mrow><mi>u</mi> <mo><</mo>
    <mi>p</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  upper D Subscript i Baseline equals StartLayout
    Enlarged left-brace 1st Row 1st Column 1 2nd Column if 3rd Column u greater-than-or-equal-to
    p 2nd Row 1st Column 0 2nd Column if 3rd Column u less-than p EndLayout EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>=</mo> <mfenced close="" open="{" separators=""><mtable><mtr><mtd
    columnalign="left"><mn>1</mn></mtd> <mtd columnalign="left"><mtext>if</mtext></mtd>
    <mtd><mrow><mi>u</mi> <mo>≥</mo> <mi>p</mi></mrow></mtd></mtr> <mtr><mtd columnalign="left"><mn>0</mn></mtd>
    <mtd columnalign="left"><mtext>if</mtext></mtd> <mtd><mrow><mi>u</mi> <mo><</mo>
    <mi>p</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: The following code snippet implements this random selection mechanism. The user
    provides the total sample size (`n_total`), the fraction of treated (`frac_treated`),
    and a seed for the random number generator, which allows for later replication.
    The outcome is a Boolean array that will indicate whether each unit in the sample
    is selected (`True`) or not (`False`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了这种随机选择机制。用户提供总样本大小（`n_total`）、受试者比例（`frac_treated`）和随机数生成器的种子，以便以后进行复制。结果是一个布尔数组，指示样本中每个单位是否被选择（`True`表示选择，`False`表示不选择）。
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As mentioned, unconfoudedness is also called (conditional) *exchangeability*.
    In the example, had I randomized selection into the treatment, thanks to exchangeability
    I would expect the fraction of those who would organically buy the book to be
    the same in the treatment and control groups. Any incremental sales in one group
    must depend *solely* on the lever I provided. This is the beauty of A/B tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，无混杂性也被称为（条件）*可交换性*。在这个例子中，如果我随机选择进入治疗组，由于可交换性，我期望那些有机购买书籍的人在治疗组和对照组中的比例相同。任何一组中的增量销售必须**仅**依赖于我提供的杠杆。这就是A/B测试的美妙之处。
- en: Warning
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'When randomizing, you must ensure that the *stable unit treatment value assumption*
    (SUTVA) is satisfied. SUTVA has two requirements: (i) the treatment is the same
    for all individuals who get it (for instance, in drug trials, all patients must
    get the same equivalent dosage), and (ii) there is no interference between units,
    so the potential outcome for a unit doesn’t vary with treatment assignment for
    other units.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机化时，必须确保满足*稳定单元处理值假设*（SUTVA）。SUTVA有两个要求：（i）所有接受处理的个体都接受相同的处理（例如，在药物试验中，所有患者必须接受相同的等效剂量），以及（ii）单位之间没有干扰，因此单位的潜在结果不会因为其他单位的处理分配而变化。
- en: The latter condition is often violated in online marketplaces, such as Uber,
    [Lyft](https://oreil.ly/Y3hWH), or Airbnb. Suppose you want to test if a demand-side
    price discount improves revenue.^([7](ch15.html#id802)) The treatment (discount)
    might reduce the available supply for the control group, creating an externality
    that affects their potential outcomes. In these cases, it’s better to use randomization
    by blocks, where the sample is first split into mutually exclusive clusters, and
    treatment is randomized across clusters instead of across units.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种情况在在线市场经常会违反，例如Uber，[Lyft](https://oreil.ly/Y3hWH)，或Airbnb。假设你想测试需求端价格折扣是否提高了收入。^([7](ch15.html#id802))
    处理（折扣）可能会减少对照组的供应，造成影响其潜在结果的外部性。在这些情况下，最好使用分块随机化，其中样本首先分成互斥的集群，然后在集群之间而不是单元之间随机分配处理。
- en: Matching
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配
- en: As great as it is, A/B testing may not always be at your disposal, especially
    when the treatment is sufficiently costly. For instance, suppose you work for
    a telecommunications company that wants to know if installing an antenna (with
    all the required components) is incremental on its revenues. You can come up with
    an A/B test design where you randomize installing new antennas across geographical
    locations. Given a large enough sample size, this setup will allow you to estimate
    their incrementality. Needless to say, this test is just too costly to perform.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管A/B测试很棒，但并非始终可以使用，特别是当处理成本足够高时。例如，假设你在一家电信公司工作，公司想知道安装天线（包括所有必需的组件）是否对其收入有增量影响。你可以设计一个A/B测试方案，随机在地理位置上安装新天线。通过足够大的样本量，这种设置将允许你估计它们的增量性。毋庸置疑，这种测试成本太高，无法执行。
- en: There are several techniques that will allow you to estimate causal effects
    with observational data, but they all depend on the critical unconfoundedness
    assumption to be satisfied. Here I just want to mention matching (and propensity
    score matching), because it nicely captures the intuition behind selection on
    observables, and how you can try to replicate randomization by finding a set of
    suitable units to be in the control group.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术可以用来估计观察数据的因果效应，但它们都依赖于满足关键的非混杂性假设。在这里，我只想提到匹配（和倾向得分匹配），因为它很好地捕捉了可观察变量选择的直觉，以及如何通过找到一组合适的单位来尝试复制随机化。
- en: One way to think about randomization is that the treatment and control groups
    are *ex ante* equal, meaning that if you randomly choose one unit from each group
    and compare them with regard to any set of variables ( <math alttext="upper X"><mi>X</mi></math>
    ), they should be pretty much the same. A natural question is whether we can create
    a valid control group *ex post*, so that selection on observables applies. This
    is what *matching* attempts to do.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 思考随机化的一种方式是处理组和对照组在*前*是相等的，这意味着如果你随机选择每组中的一个单位并比较它们关于任何一组变量（ <math alttext="upper
    X"><mi>X</mi></math> ），它们应该是相似的。一个自然的问题是我们是否可以*事后*创建一个有效的对照组，以便适用可观察变量的选择。这就是*匹配*试图做的事情。
- en: 'The matching algorithm works like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配算法工作如下：
- en: '*Propose a DAG for your outcome and ensure that selection on observables is
    valid*. In practice, this means that you have a reasonable causal model for the
    selection mechanism and you can observe *all* pretreatment features *X*.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为你的结果建议一个DAG，并确保可观察变量选择有效*。在实践中，这意味着你对选择机制有一个合理的因果模型，并且你可以观察*所有*前处理特征* X *。'
- en: '*Loop over all treated units*:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*遍历所有处理单元*：'
- en: '*Find suitable individual control groups*. For each unit *i*, find the group
    of <math alttext="m"><mi>m</mi></math> units that are *closest* to *i* in terms
    of *X*. Denote it by <math alttext="upper C left-parenthesis i right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <mi>i</mi> <mo>)</mo></mrow></math> . <math alttext="m"><mi>m</mi></math>
    is a metaparameter that controls the bias versus variance trade-off: most people
    use <math alttext="m equals 1"><mrow><mi>m</mi> <mo>=</mo> <mn>1</mn></mrow></math>
    , potentially leading to low bias but large variance. You can increase the number
    and play with this trade-off.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*寻找合适的个体对照组*。 对于每个单位 *i*，找到在 *X* 方面与 *i* 最接近的 <math alttext="m"><mi>m</mi></math>
    个单位的群体。用 <math alttext="upper C left-parenthesis i right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <mi>i</mi> <mo>)</mo></mrow></math> 表示。 <math alttext="m"><mi>m</mi></math>
    是一个控制偏差与方差折衷的元参数：大多数人使用 <math alttext="m equals 1"><mrow><mi>m</mi> <mo>=</mo>
    <mn>1</mn></mrow></math> ，可能导致低偏差但大方差。您可以增加数字并调整此折衷。'
- en: '*Compute the average outcome for the control group*. Once you have a control
    group for unit *i*, you can compute the average outcome <math alttext="y overbar
    Subscript 0 i Baseline equals left-parenthesis 1 slash m right-parenthesis sigma-summation
    Underscript j element-of upper C left-parenthesis i right-parenthesis Endscripts
    y Subscript j"><mrow><msub><mover><mi>y</mi> <mo>¯</mo></mover> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>/</mo> <mi>m</mi> <mo>)</mo></mrow>
    <msub><mo>∑</mo> <mrow><mi>j</mi><mo>∈</mo><mi>C</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub>
    <msub><mi>y</mi> <mi>j</mi></msub></mrow></math> .'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*计算对照组的平均结果*。 一旦您为单位 *i* 有了对照组，您可以计算平均结果 <math alttext="y overbar Subscript
    0 i Baseline equals left-parenthesis 1 slash m right-parenthesis sigma-summation
    Underscript j element-of upper C left-parenthesis i right-parenthesis Endscripts
    y Subscript j"><mrow><msub><mover><mi>y</mi> <mo>¯</mo></mover> <mrow><mn>0</mn><mi>i</mi></mrow></msub>
    <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>/</mo> <mi>m</mi> <mo>)</mo></mrow>
    <msub><mo>∑</mo> <mrow><mi>j</mi><mo>∈</mo><mi>C</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow></msub>
    <msub><mi>y</mi> <mi>j</mi></mrow></math> 。'
- en: '*Calculate the average treatment effect for unit i*. Compute the difference
    <math alttext="ModifyingAbove delta Subscript i Baseline With caret equals y Subscript
    i Baseline minus y overbar Subscript 0 i"><mrow><mover accent="true"><msub><mi>δ</mi>
    <mi>i</mi></msub> <mo>^</mo></mover> <mo>=</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>-</mo> <msub><mover><mi>y</mi> <mo>¯</mo></mover> <mrow><mn>0</mn><mi>i</mi></mrow></msub></mrow></math>
    .'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*计算单位 i 的平均处理效应*。 计算差值 <math alttext="ModifyingAbove delta Subscript i Baseline
    With caret equals y Subscript i Baseline minus y overbar Subscript 0 i"><mrow><mover
    accent="true"><msub><mi>δ</mi> <mi>i</mi></msub> <mo>^</mo></mover> <mo>=</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>-</mo> <msub><mover><mi>y</mi> <mo>¯</mo></mover>
    <mrow><mn>0</mn><mi>i</mi></mrow></msub></mrow></math> 。'
- en: '*Calculate the average treatment effect on the treated*. The ATT is the average
    across all <math alttext="n Subscript t"><msub><mi>n</mi> <mi>t</mi></msub></math>
    individual treatment effects for units in the treatment group ( <math alttext="upper
    N Subscript upper T"><msub><mi>N</mi> <mi>T</mi></msub></math> ):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*计算被处理单位的平均处理效应*。 ATT 是处理组中单位的所有 <math alttext="n Subscript t"><msub><mi>n</mi>
    <mi>t</mi></msub></math> 个体处理效应的平均值（ <math alttext="upper N Subscript upper T"><msub><mi>N</mi>
    <mi>T</mi></msub></math> ）：'
- en: <math alttext="upper A upper T upper T equals StartFraction 1 Over n Subscript
    t Baseline EndFraction sigma-summation Underscript i element-of upper N Subscript
    upper T Baseline Endscripts ModifyingAbove delta Subscript i Baseline With caret
    Subscript i" display="block"><mrow><mi>A</mi> <mi>T</mi> <mi>T</mi> <mo>=</mo>
    <mfrac><mn>1</mn> <msub><mi>n</mi> <mi>t</mi></msub></mfrac> <munder><mo>∑</mo>
    <mrow><mi>i</mi><mo>∈</mo><msub><mi>N</mi> <mi>T</mi></msub></mrow></munder> <msub><mover
    accent="true"><msub><mi>δ</mi> <mi>i</mi></msub> <mo>^</mo></mover> <mi>i</mi></msub></mrow></math>
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="upper A upper T upper T equals StartFraction 1 Over n Subscript
    t Baseline EndFraction sigma-summation Underscript i element-of upper N Subscript
    upper T Baseline Endscripts ModifyingAbove delta Subscript i Baseline With caret
    Subscript i" display="block"><mrow><mi>A</mi> <mi>T</mi> <mi>T</mi> <mo>=</mo>
    <mfrac><mn>1</mn> <msub><mi>n</mi> <mi>t</mi></msub></mfrac> <munder><mo>∑</mo>
    <mrow><mi>i</mi><mo>∈</mo><msub><mi>N</mi> <mi>T</mi></msub></mrow></munder> <msub><mover
    accent="true"><msub><mi>δ</mi> <mi>i</mi></msub> <mo>^</mo></mover> <mi>i</mi></msub></mrow></math>
- en: 'I hope you like the simplicity and intuitiveness of the matching algorithm.
    The key insight is that each treated unit is matched to a control group that is
    most *similar* to it, with respect to any confounder. With continuous features,
    all you need to do is compute the Euclidean distance between *i* and all nontreated
    units *j*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢匹配算法的简单性和直观性。关键的洞察是每个被处理的单位都与一个控制组匹配，这个控制组在任何混杂因素方面最*相似*。对于连续特征，您所需做的就是计算
    *i* 与所有未处理单位 *j* 之间的欧几里得距离：
- en: <math alttext="d Subscript i j Baseline equals StartRoot sigma-summation Underscript
    k Endscripts left-parenthesis x Subscript i k Baseline minus x Subscript j k Baseline
    right-parenthesis squared EndRoot" display="block"><mrow><msub><mi>d</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub>
    <mo>=</mo> <msqrt><mrow><msub><mo>∑</mo> <mi>k</mi></msub> <msup><mrow><mo>(</mo><msub><mi>x</mi>
    <mrow><mi>i</mi><mi>k</mi></mrow></msub> <mo>-</mo><msub><mi>x</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub>
    <mo>)</mo></mrow> <mn>2</mn></msup></mrow></msqrt></mrow></math>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="d Subscript i j Baseline equals StartRoot sigma-summation Underscript
    k Endscripts left-parenthesis x Subscript i k Baseline minus x Subscript j k Baseline
    right-parenthesis squared EndRoot" display="block"><mrow><msub><mi>d</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub>
    <mo>=</mo> <msqrt><mrow><msub><mo>∑</mo> <mi>k</mi></msub> <msup><mrow><mo>(</mo><msub><mi>x</mi>
    <mrow><mi>i</mi><mi>k</mi></mrow></msub> <mo>-</mo><msub><mi>x</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub>
    <mo>)</mo></mrow> <mn>2</mn></msup></mrow></msqrt></mrow></math>
- en: What happens if you have mixed data, where your features can be continuous or
    categorical? In principle you can apply a general enough distance function.^([8](ch15.html#id806))
    But there’s an alternative and very important result known as the *Propensity
    Score Theorem* (PST) that I will introduce now.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有混合数据，其中您的特征可以是连续的或分类的，会发生什么？原则上，您可以应用足够通用的距离函数。^([8](ch15.html#id806)) 但是有一个另外并且非常重要的结果被称为*倾向得分定理*（PST），我现在将介绍它。
- en: 'The *propensity score* is the probability that a given unit gets the treatment,
    conditional on some covariates or controls:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*倾向得分* 是一个单位获得处理的概率，条件是一些协变量或控制变量：'
- en: <math alttext="p left-parenthesis upper X Subscript i Baseline right-parenthesis
    equals Prob left-parenthesis upper D Subscript i Baseline equals 1 vertical-bar
    upper X Subscript i Baseline right-parenthesis" display="block"><mrow><mi>p</mi>
    <mrow><mo>(</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mtext>Prob</mtext> <mrow><mo>(</mo> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo>
    <mn>1</mn> <mo>|</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p left-parenthesis upper X Subscript i Baseline right-parenthesis
    equals Prob left-parenthesis upper D Subscript i Baseline equals 1 vertical-bar
    upper X Subscript i Baseline right-parenthesis" display="block"><mrow><mi>p</mi>
    <mrow><mo>(</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mtext>Prob</mtext> <mrow><mo>(</mo> <msub><mi>D</mi> <mi>i</mi></msub> <mo>=</mo>
    <mn>1</mn> <mo>|</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: 'PST says that if unconfoundedness holds conditional on features <math alttext="upper
    X"><mi>X</mi></math> , it also holds if you condition on <math alttext="p left-parenthesis
    upper X right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <mi>X</mi> <mo>)</mo></mrow></math>
    . The importance of this result is mainly computational: if you’ve already made
    the critical leap of *assuming* conditional independence using *X*, then you can
    use the propensity score to match treated with untreated units. The propensity
    score can be estimated with your favorite classification algorithm—such as a gradient
    boosting, a random, forest or a logistic classifier—that naturally takes care
    of mixed data.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: PST说，如果在特征 <math alttext="upper X"><mi>X</mi></math> 条件下不受干扰性的约束，那么如果你条件于 <math
    alttext="p left-parenthesis upper X right-parenthesis"><mrow><mi>p</mi> <mo>(</mo>
    <mi>X</mi> <mo>)</mo></mrow></math> ，也会保持不受干扰性。这一结果的重要性主要是计算方面的：如果你已经通过*假设*使用
    *X* 建立了条件独立性，那么你可以使用倾向得分将接受治疗的单位与未接受治疗的单位匹配。倾向得分可以用你喜欢的分类算法来估计，比如梯度提升、随机森林或逻辑分类器，这些算法自然地处理混合数据。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that unconfoundedness is an assumption that *cannot* be tested with
    any given dataset. You start with a DAG that captures your assumptions about any
    dependencies between the treatment, the outcome, and any other relevant controls.
    Everything that follows depends on this critical assumption.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，不受干扰性是一个*不能*用任何给定数据集测试的假设。你从一个捕捉你对治疗、结果和任何其他相关控制变量假设的DAG开始。接下来的一切都取决于这一关键假设。
- en: Because of this criticality, it’s always a good idea to discuss and document
    your identifying assumptions (your DAG) with your colleagues, data scientists
    or others. Many times, your business stakeholders can provide valuable insights
    into what drives the selection mechanism.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，讨论和记录你的识别假设（你的DAG）与你的同事、数据科学家或其他人是一个好主意。许多时候，你的业务利益相关者可以提供有价值的见解，说明是什么驱动了选择机制。
- en: 'I’ll sum up the propensity score matching algorithm now, skipping the common
    steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将总结倾向得分匹配算法，跳过常见的步骤：
- en: '*Train a classification algorithm to estimate the probability of getting the
    treatment*. Using a sample of treated and untreated units, estimate <math alttext="p
    left-parenthesis upper X Subscript i Baseline right-parenthesis"><mrow><mi>p</mi>
    <mo>(</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow></math> .'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*训练分类算法来估计接受治疗的概率*。使用已处理和未处理单位的样本，估计 <math alttext="p left-parenthesis upper
    X Subscript i Baseline right-parenthesis"><mrow><mi>p</mi> <mo>(</mo> <msub><mi>X</mi>
    <mi>i</mi></msub> <mo>)</mo></mrow></math> 。'
- en: '*Match treated units using the propensity score*. For each treated unit *i*,
    compute the absolute differences in propensity scores for all untreated units:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使用倾向得分匹配法匹配接受治疗的单位*。对于每个接受治疗的单位 *i*，计算所有未接受治疗单位的倾向得分的绝对差：'
- en: <math alttext="d Subscript i j Baseline equals bar ModifyingAbove p With caret
    left-parenthesis upper X Subscript i Baseline right-parenthesis minus ModifyingAbove
    p With caret left-parenthesis upper X Subscript j Baseline right-parenthesis bar"
    display="block"><mrow><msub><mi>d</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub>
    <mo>=</mo> <mo>∣</mo> <mover accent="true"><mi>p</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>-</mo> <mover accent="true"><mi>p</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <msub><mi>X</mi> <mi>j</mi></msub> <mo>)</mo></mrow>
    <mo>∣</mo></mrow></math>
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="d Subscript i j Baseline equals bar ModifyingAbove p With caret
    left-parenthesis upper X Subscript i Baseline right-parenthesis minus ModifyingAbove
    p With caret left-parenthesis upper X Subscript j Baseline right-parenthesis bar"
    display="block"><mrow><msub><mi>d</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub>
    <mo>=</mo> <mo>∣</mo> <mover accent="true"><mi>p</mi> <mo>^</mo></mover> <mrow><mo>(</mo>
    <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow> <mo>-</mo> <mover accent="true"><mi>p</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <msub><mi>X</mi> <mi>j</mi></msub> <mo>)</mo></mrow>
    <mo>∣</mo></mrow></math>
- en: '*Select the control group using the sorted differences*. Sort all differences
    in an increasing manner, and assign the top <math alttext="m"><mi>m</mi></math>
    to control group <math alttext="upper C left-parenthesis i right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <mi>i</mi> <mo>)</mo></mrow></math> .'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使用排序后的差异选择对照组*。以递增方式排序所有差异，并将前 <math alttext="m"><mi>m</mi></math> 个分配给控制组
    <math alttext="upper C left-parenthesis i right-parenthesis"><mrow><mi>C</mi>
    <mo>(</mo> <mi>i</mi> <mo>)</mo></mrow></math> 。'
- en: As intuitive as matching (and propensity score matching) is, it is computationally
    expensive since you have to loop through each treated unit, and for each of these
    you then have to loop over each untreated unit, and each feature, so you end up
    with a complexity of <math alttext="upper O left-parenthesis n Subscript t Baseline
    times n Subscript c Baseline times k right-parenthesis"><mrow><mi>O</mi> <mo>(</mo>
    <msub><mi>n</mi> <mi>t</mi></msub> <mo>×</mo> <msub><mi>n</mi> <mi>c</mi></msub>
    <mo>×</mo> <mi>k</mi> <mo>)</mo></mrow></math> in *Big O* notation. In the code
    [repo](https://oreil.ly/dshp-repo) you’ll find two versions of the algorithm,
    one using loops and one that uses Numpy’s and Pandas’ broadcasting capabilities,
    which considerably reduce the execution time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管匹配（以及倾向得分匹配）直觉上是直观的，但它在计算上是昂贵的，因为你必须遍历每个接受治疗的单位，并且对于每一个这样的单位，你还必须遍历每个未接受治疗的单位和每个特征，因此你最终会得到一个复杂度为
    <math alttext="upper O left-parenthesis n Subscript t Baseline times n Subscript
    c Baseline times k right-parenthesis"><mrow><mi>O</mi> <mo>(</mo> <msub><mi>n</mi>
    <mi>t</mi></msub> <mo>×</mo> <msub><mi>n</mi> <mi>c</mi></msub> <mo>×</mo> <mi>k</mi>
    <mo>)</mo></mrow></math> 的*大O*符号表示。在代码 [repo](https://oreil.ly/dshp-repo) 中，你会发现算法的两个版本，一个使用循环，另一个使用Numpy和Pandas的广播功能，这大大减少了执行时间。
- en: 'To see the two in practice, I simulate a model similar to the one described
    previously, with two confounders that affect the selection probability and the
    outcome, and the true treatment effect is equal to two.^([9](ch15.html#id808))
    For the propensity score, I use two alternative algorithms: an out-of-the-box
    gradient boosting classifier (GBC) and logistic regression. I bootstrap 95% confidence
    intervals for each estimator. [Figure 15-6](#ch15_matching_simu) shows the results,
    where the horizontal axis of each plot shows what happens when you play with the
    size of the control group (*m*).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这两者在实践中的效果，我模拟了一个类似于先前描述的模型，其中有两个混杂变量影响选择概率和结果，真实治疗效应等于两个。^([9](ch15.html#id808))对于倾向得分，我使用两种替代算法：开箱即用的梯度提升分类器（GBC）和逻辑回归。我为每个估计器引导95%置信区间。[图15-6](#ch15_matching_simu)显示了结果，其中每个图的水平轴显示了当您改变控制组大小（*m*）时发生的情况。
- en: '![matching and prop. score matching](assets/dshp_1507.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![匹配和倾向得分匹配](assets/dshp_1507.png)'
- en: Figure 15-6\. Results from matching and propensity score matching
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-6。匹配和倾向得分匹配的结果
- en: It’s clear that all methods correctly estimate the true causal effect, but propensity
    score matching with GBC slightly underestimates it (true estimate is still within
    95% confidence intervals). Increasing the size of the individual control groups
    doesn’t seem to have an effect, both in terms of bias and variance, for plain
    matching and propensity score matching with the logistic regression, but it slightly
    decreases the confidence intervals for GBC.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法都可以正确估计真实因果效应，但倾向得分匹配与GBC略微低估它（真实估计仍在95%置信区间内）。增加个体对照组的大小似乎对平凡匹配和倾向得分匹配与逻辑回归的偏差和方差没有影响，但略微缩小了GBC的置信区间。
- en: Machine Learning and Causal Inference
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习和因果推断
- en: Although ML has enjoyed impressive growth in the past few years, it’s safe to
    say that, other than A/B tests which are performed regularly at many organizations,
    causal inference is still quite niche. In this section I’ll try to summarize some
    of the most recent developments that link these two fields of study.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管机器学习在过去几年取得了令人印象深刻的增长，可以肯定的是，除了在许多组织中定期进行的A/B测试之外，因果推断仍然相当小众。在本节中，我将尝试总结将这两个研究领域联系起来的一些最新发展。
- en: Open Source Codebases
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源代码库
- en: Just as the availability of open source libraries for ML removed some of the
    barriers to entry for practitioners, several new initiatives try to do the same
    for causal inference.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像ML的开源库的可用性为从业者消除了一些进入障碍一样，几个新的倡议试图为因果推断做同样的事情。
- en: The causal inference research team at Microsoft has spun several projects that
    include [EconML](https://oreil.ly/8QMHp), [Azua](https://oreil.ly/rowav), and
    [DoWhy](https://oreil.ly/Ber5G).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft的因果推断研究团队推出了几个项目，包括[EconML](https://oreil.ly/8QMHp)、[Azua](https://oreil.ly/rowav)和[DoWhy](https://oreil.ly/Ber5G)。
- en: 'As the contributors to DoWhy [explain](https://oreil.ly/jaTr2), their aim is
    to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如DoWhy的贡献者们在[解释](https://oreil.ly/jaTr2)的那样，他们的目标是：
- en: Provide a modelling framework through casual graphs (DAGs)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供通过因果图（DAGs）建模框架
- en: Combine the best of the DAG and potential outcomes approaches
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合DAG和潜在结果方法的最佳实践
- en: “Automatically [test] for the validity of assumptions if possible and [assess]
    the robustness of the estimate to violations”
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如果可能，自动地[测试]假设的有效性和[评估]估计的健壮性”
- en: The last objective is probably the most appealing to practitioners, since by
    providing the treatment, outcome, other data, and a causal model, you can get
    enough information about whether you have identification and a range of plausible
    estimates. As you might expect, automation is at the core of the research program
    led by [Judea Pearl](https://oreil.ly/JmYKa) and the computer science crowd.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对从[Judea Pearl](https://oreil.ly/JmYKa)和计算机科学界带头的研究项目，通过提供治疗、结果、其他数据和因果模型，可以获得关于是否具有识别和一系列合理估计的足够信息，这可能是最吸引从业者的最后目标。
- en: EconML is a Python library that aims at using state-of-the-art ML techniques
    to estimate causal effects. As the name suggests, the provided methods are “at
    the intersection of econometrics and [ML].” You can find some very recent methods
    that work under the unconfoundedness assumption, such as double machine learning,
    doubly robust learning, and forest based estimators. I will say more about this
    later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: EconML 是一个旨在利用最先进的机器学习技术来估计因果效应的Python库。正如其名称所示，提供的方法处于“计量经济学与[ML]的交集”。你可以找到一些非常新的方法，这些方法在未混杂假设下工作，比如双机器学习、双重稳健学习和基于森林的估计器。稍后我会详细介绍这些内容。
- en: Azua is a library that aims at using state-of-the-art ML methods to improve
    decision making. The problem is divided into two independent stages called *next
    best question* and *next best action*. The former is concerned about which data
    needs to be collected to make better decisions, and includes problems in missing
    value imputation and how informative different variables are for a given problem.
    The latter uses causal inference to provide optimal actions for well-defined objective
    functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Azua 是一个旨在利用最先进的机器学习方法来改进决策的库。问题被分为两个独立阶段，称为“下一个最佳问题”和“下一个最佳行动”。前者关注于需要收集哪些数据以做出更好的决策，并包括缺失值填补中的问题，以及对于给定问题来说不同变量的信息性如何。后者使用因果推断为定义明确的目标函数提供最优行动。
- en: '[CausalML](https://oreil.ly/W2Vn8) is another Python library, created by Uber.
    It includes several ML-based causal inference estimators for uplift modeling,
    such as trees and meta-learners. A similar library is [pylift](https://oreil.ly/Akxdj).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[CausalML](https://oreil.ly/W2Vn8) 是由Uber创建的另一个Python库。它包括几个基于机器学习的因果推断估计器，用于提升建模，例如树和元学习器。类似的库还有[pylift](https://oreil.ly/Akxdj)。'
- en: To understand [uplift modeling](https://oreil.ly/3LMlX), imagine that you train
    a cross-selling classifier that will predict which of your customers will purchase
    a given product in your company. Once trained, you can plot the distribution of
    scores, as in [Figure 15-7](#ch15_uplift), where I’ve divided all scored customers
    into three groups. Group A are customers with a high probability of a purchase.
    Customers in group B are less likely, and C are deemed highly unlikely to purchase.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解[提升建模](https://oreil.ly/3LMlX)，想象一下你训练了一个交叉销售分类器，预测哪些客户会在你的公司购买特定产品。训练完成后，你可以绘制得分分布，如[图
    15-7](#ch15_uplift)，我将所有得分客户分为三组。A组是购买可能性高的客户。B组的客户可能性较小，而C组被认为购买可能性极低。
- en: Which customers should you target in your campaign? Many people decide to target
    group A, but these customers are most likely going to make an organic purchase,
    so you can use this costly incentive to target other customers. On the other side,
    group C are so unlikely that the incentive will be prohibitively costly. With
    this rationale, group B is a better candidate to be targeted.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的营销活动中应该瞄准哪些客户？许多人决定瞄准A组，但这些客户最有可能进行有机购买，所以你可以使用这种昂贵的激励来瞄准其他客户。另一方面，C组的可能性太小，激励成本太高。基于这种理由，B组更适合作为目标候选。
- en: '![uplift](assets/dshp_1508.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![uplift](assets/dshp_1508.png)'
- en: Figure 15-7\. Distribution of cross-selling probability scores
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-7\. 交叉销售概率分数分布
- en: The aim of uplift modeling is to formalize this intuitive discussion using the
    information on your treatment and control groups to estimate incrementality of
    the treatment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 提升建模的目标是利用治疗组和对照组的信息，形式化这种直觉讨论，以估计治疗的增量效果。
- en: Double Machine Learning
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双机器学习
- en: ML algorithms are great when the objective is to learn a general data generating
    process like <math alttext="y equals f left-parenthesis upper X right-parenthesis"><mrow><mi>y</mi>
    <mo>=</mo> <mi>f</mi> <mo>(</mo> <mi>X</mi> <mo>)</mo></mrow></math> . When using
    DAGs to describe a causal model, no mention is made of the functional form of
    the links, just their existence. Traditionally, causal effects are estimated using
    linear regression because of its simplicity and transparency. Double machine learning
    (DML) and similar techniques aim at using the increased predictive power and flexibility
    of nonlinear learners to estimate a causal effect.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标是学习类似<math alttext="y equals f left-parenthesis upper X right-parenthesis"><mrow><mi>y</mi>
    <mo>=</mo> <mi>f</mi> <mo>(</mo> <mi>X</mi> <mo>)</mo></mrow></math>的一般数据生成过程时，ML算法非常有效。当使用DAGs描述因果模型时，不提及链接的功能形式，只提及它们的存在。传统上，因果效应使用线性回归来估计，因为其简单和透明性。双机器学习（DML）和类似技术旨在利用非线性学习器增强的预测能力和灵活性来估计因果效应。
- en: 'To see how ML can improve the estimation of a causal effect, take the following
    partially linear model:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解机器学习如何改进因果效应的估计，考虑以下部分线性模型：
- en: <math alttext="StartLayout 1st Row 1st Column y 2nd Column equals 3rd Column
    theta upper D plus g left-parenthesis upper X right-parenthesis plus u 2nd Row
    1st Column upper D 2nd Column equals 3rd Column h left-parenthesis upper X right-parenthesis
    plus v EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi>θ</mi> <mi>D</mi> <mo>+</mo>
    <mi>g</mi> <mo>(</mo> <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>u</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>D</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi>h</mi>
    <mo>(</mo> <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>v</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column y 2nd Column equals 3rd Column
    theta upper D plus g left-parenthesis upper X right-parenthesis plus u 2nd Row
    1st Column upper D 2nd Column equals 3rd Column h left-parenthesis upper X right-parenthesis
    plus v EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>y</mi></mtd>
    <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi>θ</mi> <mi>D</mi> <mo>+</mo>
    <mi>g</mi> <mo>(</mo> <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>u</mi></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mi>D</mi></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><mi>h</mi>
    <mo>(</mo> <mi>X</mi> <mo>)</mo> <mo>+</mo> <mi>v</mi></mrow></mtd></mtr></mtable></math>
- en: As usual, the outcome depends on the treatment and some features, and the treatment
    also depends on the set of features (to create confounder or selection bias).
    The functions <math alttext="g"><mi>g</mi></math> and <math alttext="h"><mi>h</mi></math>
    are possibly nonlinear, the treatment effect is given by <math alttext="theta"><mi>θ</mi></math>
    , and <math alttext="u comma v"><mrow><mi>u</mi> <mo>,</mo> <mi>v</mi></mrow></math>
    are independent noise terms. Note that nonlinearity potentially kicks in only
    for the confounders, but these are not allowed to interact with the treatment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，结果取决于处理和一些特征，并且处理也取决于特征集（以创建混杂因素或选择偏差）。函数 <math alttext="g"><mi>g</mi></math>
    和 <math alttext="h"><mi>h</mi></math> 可能是非线性的，治疗效应由 <math alttext="theta"><mi>θ</mi></math>
    给出，而 <math alttext="u comma v"><mrow><mi>u</mi> <mo>,</mo> <mi>v</mi></mrow></math>
    是独立的噪声项。注意，非线性可能仅在混杂因素中出现，但不允许这些因素与处理交互。
- en: 'The idea of the DML estimator is to use the power of nonlinear learners (such
    as random forests or gradient boosting) to learn each of these functions and estimate
    the treatment effect. Without going into the details, the process involves two
    critical concepts:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: DML 估计器的思想是利用非线性学习器（如随机森林或梯度提升）学习每个函数并估计治疗效应。不深入细节，这个过程涉及两个关键概念：
- en: Orthogonalization
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正交化
- en: As described in [Chapter 10](ch10.html#ch10_linreg), orthogonalization consists
    of partialling out the effect of the covariates *X* on the outcome and the treatment.
    You use the desired flexible learner and regress the residuals to obtain the causal
    effect.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 10 章](ch10.html#ch10_linreg) 中所述，正交化包括部分剔除协变量 *X* 对结果和处理的影响。您使用期望的灵活学习器并对残差进行回归，以获取因果效应。
- en: Sample splitting
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 样本分割
- en: The sample is randomly split in halves, one used for training and the other
    for estimation and evaluation. This is necessary to avoid bias from overfitting,
    and provides some desirable large sample properties.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 样本随机分成两半，一半用于训练，另一半用于估计和评估。这是为了避免过拟合的偏差，并提供一些理想的大样本特性。
- en: 'The algorithm works like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的工作原理如下：
- en: 'Randomly split the sample in two halves: <math alttext="upper S Subscript k
    Baseline comma k equals 1 comma 2"><mrow><msub><mi>S</mi> <mi>k</mi></msub> <mo>,</mo>
    <mi>k</mi> <mo>=</mo> <mn>1</mn> <mo>,</mo> <mn>2</mn></mrow></math> .'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机将样本分为两半：<math alttext="upper S Subscript k Baseline comma k equals 1 comma
    2"><mrow><msub><mi>S</mi> <mi>k</mi></msub> <mo>,</mo> <mi>k</mi> <mo>=</mo> <mn>1</mn>
    <mo>,</mo> <mn>2</mn></mrow></math> 。
- en: Using sample *l*, train your learners on <math alttext="upper S Subscript l"><msub><mi>S</mi>
    <mi>l</mi></msub></math> for both *g()* and *h()*.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用样本 *l* ，对 *g()* 和 *h()* 在 <math alttext="upper S Subscript l"><msub><mi>S</mi>
    <mi>l</mi></msub></math> 上进行训练。
- en: 'Using units *i* in sample <math alttext="m not-equals l"><mrow><mi>m</mi> <mo>≠</mo>
    <mi>l</mi></mrow></math> , estimate the residuals:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单位 *i* 在样本 <math alttext="m not-equals l"><mrow><mi>m</mi> <mo>≠</mo> <mi>l</mi></mrow></math>
    ，估计残差：
- en: <math alttext="StartLayout 1st Row 1st Column ModifyingAbove u With caret Subscript
    i 2nd Column equals 3rd Column y Subscript i Baseline minus ModifyingAbove g With
    caret left-parenthesis upper X Subscript i Baseline right-parenthesis 2nd Row
    1st Column ModifyingAbove v With caret Subscript i 2nd Column equals 3rd Column
    upper D Subscript i Baseline minus ModifyingAbove h With caret left-parenthesis
    upper X Subscript i Baseline right-parenthesis EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mi>i</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>-</mo> <mover accent="true"><mi>g</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mover accent="true"><mi>v</mi> <mo>^</mo></mover>
    <mi>i</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>-</mo> <mover accent="true"><mi>h</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column ModifyingAbove u With caret Subscript
    i 2nd Column equals 3rd Column y Subscript i Baseline minus ModifyingAbove g With
    caret left-parenthesis upper X Subscript i Baseline right-parenthesis 2nd Row
    1st Column ModifyingAbove v With caret Subscript i 2nd Column equals 3rd Column
    upper D Subscript i Baseline minus ModifyingAbove h With caret left-parenthesis
    upper X Subscript i Baseline right-parenthesis EndLayout" display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><msub><mover accent="true"><mi>u</mi>
    <mo>^</mo></mover> <mi>i</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>-</mo> <mover accent="true"><mi>g</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msub><mover accent="true"><mi>v</mi> <mo>^</mo></mover>
    <mi>i</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd columnalign="left"><mrow><msub><mi>D</mi>
    <mi>i</mi></msub> <mo>-</mo> <mover accent="true"><mi>h</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <msub><mi>X</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
- en: Calculate the estimator:^([10](ch15.html#id824))
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算估计器：^([10](ch15.html#id824))
- en: <math alttext="StartLayout 1st Row  ModifyingAbove theta With caret left-parenthesis
    upper S Subscript l Baseline comma upper S Subscript m Baseline right-parenthesis
    equals left-parenthesis StartFraction 1 Over n Subscript m Baseline EndFraction
    sigma-summation Underscript i element-of upper S Subscript m Baseline Endscripts
    ModifyingAbove v With caret Subscript i Baseline upper D Subscript i Baseline
    right-parenthesis Superscript negative 1 Baseline left-parenthesis StartFraction
    1 Over n Subscript m Baseline EndFraction sigma-summation Underscript i element-of
    upper S Subscript m Baseline Endscripts ModifyingAbove v With caret Subscript
    i Baseline ModifyingAbove u With caret Subscript i Baseline right-parenthesis
    EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>θ</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <msub><mi>S</mi>
    <mi>l</mi></msub> <mo>,</mo> <msub><mi>S</mi> <mi>m</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mfenced close=")" open="(" separators=""><mfrac><mn>1</mn> <msub><mi>n</mi>
    <mi>m</mi></msub></mfrac> <munder><mo>∑</mo> <mrow><mi>i</mi><mo>∈</mo><msub><mi>S</mi>
    <mi>m</mi></msub></mrow></munder> <msub><mover accent="true"><mi>v</mi> <mo>^</mo></mover>
    <mi>i</mi></msub> <msub><mi>D</mi> <mi>i</mi></msub></mfenced> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mfenced close=")" open="(" separators=""><mfrac><mn>1</mn> <msub><mi>n</mi> <mi>m</mi></msub></mfrac>
    <munder><mo>∑</mo> <mrow><mi>i</mi><mo>∈</mo><msub><mi>S</mi> <mi>m</mi></msub></mrow></munder>
    <msub><mover accent="true"><mi>v</mi> <mo>^</mo></mover> <mi>i</mi></msub> <msub><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mi>i</mi></msub></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  ModifyingAbove theta With caret left-parenthesis
    upper S Subscript l Baseline comma upper S Subscript m Baseline right-parenthesis
    equals left-parenthesis StartFraction 1 Over n Subscript m Baseline EndFraction
    sigma-summation Underscript i element-of upper S Subscript m Baseline Endscripts
    ModifyingAbove v With caret Subscript i Baseline upper D Subscript i Baseline
    right-parenthesis Superscript negative 1 Baseline left-parenthesis StartFraction
    1 Over n Subscript m Baseline EndFraction sigma-summation Underscript i element-of
    upper S Subscript m Baseline Endscripts ModifyingAbove v With caret Subscript
    i Baseline ModifyingAbove u With caret Subscript i Baseline right-parenthesis
    EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>θ</mi> <mo>^</mo></mover> <mrow><mo>(</mo> <msub><mi>S</mi>
    <mi>l</mi></msub> <mo>,</mo> <msub><mi>S</mi> <mi>m</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <msup><mfenced close=")" open="(" separators=""><mfrac><mn>1</mn> <msub><mi>n</mi>
    <mi>m</mi></msub></mfrac> <munder><mo>∑</mo> <mrow><mi>i</mi><mo>∈</mo><msub><mi>S</mi>
    <mi>m</mi></msub></mrow></munder> <msub><mover accent="true"><mi>v</mi> <mo>^</mo></mover>
    <mi>i</mi></msub> <msub><mi>D</mi> <mi>i</mi></msub></mfenced> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mfenced close=")" open="(" separators=""><mfrac><mn>1</mn> <msub><mi>n</mi> <mi>m</mi></msub></mfrac>
    <munder><mo>∑</mo> <mrow><mi>i</mi><mo>∈</mo><msub><mi>S</mi> <mi>m</mi></msub></mrow></munder>
    <msub><mover accent="true"><mi>v</mi> <mo>^</mo></mover> <mi>i</mi></msub> <msub><mover
    accent="true"><mi>u</mi> <mo>^</mo></mover> <mi>i</mi></msub></mfenced></mrow></mtd></mtr></mtable></math>
- en: 'Average the estimates from each subsample:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个子样本的估计值取平均：
- en: <math alttext="StartLayout 1st Row  ModifyingAbove theta With caret equals 0.5
    times left-parenthesis ModifyingAbove theta With caret left-parenthesis upper
    S Subscript l Baseline comma upper S Subscript m Baseline right-parenthesis plus
    ModifyingAbove theta With caret left-parenthesis upper S Subscript m Baseline
    comma upper S Subscript l Baseline right-parenthesis right-parenthesis EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>θ</mi> <mo>^</mo></mover> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn>
    <mo>×</mo> <mrow><mo>(</mo> <mover accent="true"><mi>θ</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <msub><mi>S</mi> <mi>l</mi></msub> <mo>,</mo> <msub><mi>S</mi>
    <mi>m</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mover accent="true"><mi>θ</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <msub><mi>S</mi> <mi>m</mi></msub> <mo>,</mo>
    <msub><mi>S</mi> <mi>l</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row  ModifyingAbove theta With caret equals 0.5
    times left-parenthesis ModifyingAbove theta With caret left-parenthesis upper
    S Subscript l Baseline comma upper S Subscript m Baseline right-parenthesis plus
    ModifyingAbove theta With caret left-parenthesis upper S Subscript m Baseline
    comma upper S Subscript l Baseline right-parenthesis right-parenthesis EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mover
    accent="true"><mi>θ</mi> <mo>^</mo></mover> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>5</mn>
    <mo>×</mo> <mrow><mo>(</mo> <mover accent="true"><mi>θ</mi> <mo>^</mo></mover>
    <mrow><mo>(</mo> <msub><mi>S</mi> <mi>l</mi></msub> <mo>,</mo> <msub><mi>S</mi>
    <mi>m</mi></msub> <mo>)</mo></mrow> <mo>+</mo> <mover accent="true"><mi>θ</mi>
    <mo>^</mo></mover> <mrow><mo>(</mo> <msub><mi>S</mi> <mi>m</mi></msub> <mo>,</mo>
    <msub><mi>S</mi> <mi>l</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>
- en: In the code [repo](https://oreil.ly/dshp-repo) you can find an implementation
    and results for simulations using linear and nonlinear data generating processes.
    Here I just wanted to show one avenue where ML has impacted causal inference by
    providing more powerful and general predictive algorithms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码 [repo](https://oreil.ly/dshp-repo) 中，您可以找到使用线性和非线性数据生成过程进行模拟的实现和结果。这里我只想展示一个
    ML 通过提供更强大和通用的预测算法影响因果推断的途径。
- en: Key Takeaways
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键要点
- en: 'These are the key takeaways from this chapter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本章的关键要点：
- en: What is incrementality?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是增量性？
- en: Incrementality is causal inference applied to estimating whether a change in
    a lever improved a business outcome.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 增量性是应用于估计某个杠杆变动是否改善了业务结果的因果推断。
- en: Why care about incrementality (v.0)?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么关注增量性（v.0）？
- en: Under the assumption that data science creates value by improving our decision-making
    capabilities, incrementality is critical to understand which decisions are worthy
    of expanding and which should be rolled back.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据科学通过提高我们的决策能力创造价值的假设，增量性对于理解哪些决策值得扩展，哪些应该回滚至关重要。
- en: Why care about incrementality (v.1)?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么关注增量性（v.1）？
- en: Even if improved decision making is not a top priority for you or your team,
    having a broad understanding of causality should help you improve the predictive
    performance of your ML models.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对您或您的团队来说，改善决策并非头等大事，对因果性有广泛的理解也应有助于提高您的机器学习模型的预测性能。
- en: Approaches to causality
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因果推断的方法
- en: 'Generally speaking, there are two alternative (and complementary) approaches
    to identification and estimation of causal effects: the DAG and potential outcomes
    methodologies. The former takes advantage of graphs (and the do-calculus) to find
    conditions for identification. The latter transforms the problem into one of missing
    data and selection mechanisms, since at any given time, only one potential outcome
    can be observed for each unit.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，有两种替代（及互补）方法可以识别和估计因果效应：DAG 和潜在结果方法论。前者利用图表（及因果推断）找到识别的条件。后者将问题转化为缺失数据和选择机制，因为在任何给定时间，每个单位只能观察到一个潜在结果。
- en: Confounders and colliders
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Confounders and colliders
- en: Confounders are common causes, and colliders are common effects for a treatment
    and an outcome. Not conditioning for a confounder *opens a back door* and results
    in biased causal estimates. Alternatively, a collider is an example of a bad control
    in the sense that including it as a feature in your model (or more generally,
    conditioning on it) will also open a back door and create bias.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆因素是治疗和结果的共同原因，而碰撞体是治疗和结果的共同效应。不考虑混淆因素会“打开一扇后门”，导致偏倚的因果估计结果。相反，碰撞体是一个坏的控制的例子，因为在您的模型中包含它（或更普遍地，在它上面进行条件处理）也会打开一扇后门，并造成偏倚。
- en: Selection bias
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 选择偏倚
- en: For statisticians and economists, selection bias is a type of confounder bias
    applied to selection *into* the treatment. For epidemiologists and computer scientists,
    it refers to selection into a sample *after* the treatment was administered. Randomization,
    in the form of RCTs or A/B tests, solves the former but not the latter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统计学家和经济学家来说，选择偏倚是应用于选择“进入”治疗的混淆偏倚的一种类型。对于流行病学家和计算机科学家来说，它指的是在治疗后选择进入样本的选择偏倚。随机化，以随机对照试验（RCTs）或
    A/B 测试的形式，解决了前者，但未解决后者。
- en: Randomization and matching
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化和匹配
- en: By randomizing selection into the treatment, you effectively break selection
    (into the treatment) bias. This explains why A/B tests have become an industry
    standard whenever the option is available. With observational data there are many
    techniques that can be used to estimate causal effects, but they all rely on the
    unconfoundedness assumption to be valid. Here I discussed matching and propensity
    score matching only.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将选择随机化到治疗中，您有效地打破了选择（进入治疗）偏倚。这解释了为什么 A/B 测试在可行时已成为行业标准。使用观察数据时，有许多技术可以用来估计因果效应，但它们都依赖于无混杂假设的有效性。这里我仅讨论匹配和倾向得分匹配。
- en: Further Reading
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In my book, *Analytical Skills for AI and Data Science*, I discuss in depth
    the relevance of incrementality and causality for prescriptive data science. A
    similar view can be found in Ajay Agrawal et al., *Prediction Machines: The Simple
    Economics of Artificial Intelligence* (Harvard Business Review Press) and the
    more recent *Power and Prediction: The Disruptive Economics of Artificial Intelligence*
    (Harvard Business Review Press).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的书《AI与数据科学的分析技能》中，我深入讨论了关于处方数据科学的增量性和因果性的相关性。阿贾伊·阿格拉瓦尔等人的《预测机器：人工智能的简单经济学》（哈佛商业评论出版社）和更近期的《权力与预测：人工智能的颠覆性经济学》（哈佛商业评论出版社）中也有类似的观点。
- en: An introductory treatment of casual inference can be found in [Chapter 9](https://oreil.ly/j2JfH)
    of *Data Analysis Using Regression and Multilevel/Hierarchical Models* by Andrew
    Gelman and Jennifer Hill (Cambridge University Press).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在《使用回归和多级/层次模型进行数据分析》（剑桥大学出版社）的第 9 章中找到关于因果推断的入门论述。
- en: 'If you’re interested in the DAG approach to causality, an introduction can
    be found in Judea Pearl and Dana Mackenzie, *The Book of Why: The New Science
    of Cause and Effect* (Basic Books). A more technical treatment can be found in
    Pearl’s *Causality: Models, Reasoning and Inference*, 2nd ed. (Cambridge University
    Press). The former is better suited if you first want to gain some intuition,
    and the latter provides an in-depth presentation of DAGS and the do-calculus.
    Of critical importance are the back- and front-door criteria for identification.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对DAG方法对因果性的方法感兴趣，可以在Judea Pearl和Dana Mackenzie的《为什么之书：因果关系的新科学》（基础图书）中找到简介。更技术性的处理可以在Pearl的《因果性：模型、推理和推断》，第二版（剑桥大学出版社）中找到。前者更适合如果你想先获得一些直觉，而后者提供了DAGS和do-calculus的深入介绍。识别的关键是背门和前门标准。
- en: 'The potential outcomes approach has been championed by economists and statisticians.
    *Mostly Harmless Econometrics: An Empiricist’s Companion* by Joshua Angrist and
    Jorn-Steffen Pischke (Princeton University Press) is a great reference if you’re
    interested in understanding selection bias and the many facets of linear regression
    as compared to other methods, such as the matching estimators discussed in the
    chapter. You can also find a complete treatment of instrumental variables, discussed
    in a footnote of the DML estimator.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在结果方法一直受到经济学家和统计学家的支持。Joshua Angrist和Jorn-Steffen Pischke的《大部分无害计量经济学：实证主义者的同伴》（普林斯顿大学出版社）是一个很好的参考书，如果你对理解选择偏差及线性回归的多个方面感兴趣，比如在章节中讨论的匹配估计器。你也可以找到仪器变量的完整处理，该项在DML估计器的脚注中讨论。
- en: '*Causal Inference for Statistics, Social, and Biomedical Sciences: An Introduction*
    by Guido Imbens and Donald Rubin (Cambridge University Press) provides a thorough
    introduction to the subject from a potential outcomes perspective, also known
    as Rubin’s causal model (Donald Rubin originally formalized and developed the
    theory). This is a great reference if you want to understand the role that selection
    mechanisms play. SUTVA is also discussed in great detail.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学、社会科学和生物医学领域的因果推断：引言由Guido Imbens和Donald Rubin（剑桥大学出版社）提供了从潜在结果视角全面介绍该主题，也被称为Rubin的因果模型（Donald
    Rubin最初正式化和发展了该理论）。如果你想了解选择机制在其中扮演的角色，这是一个很好的参考书。SUTVA也被详细讨论。
- en: 'In recent years, several authors have tried to make the best of both approaches.
    On the economist’s side, Scott Cunningham’s [*Causal Inference: The Mixtape*](https://oreil.ly/mlTOy)
    (Yale University Press) and Nick Huntington-Klein’s [*The Effect: An Introduction
    to Research Design and Causality*](https://oreil.ly/DewAm) (Chapman and Hall/CRC)
    discuss several methods for identification and estimation, and also provide clear
    introductions to DAGs.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，一些作者试图兼顾两种方法的优势。在经济学家方面，Scott Cunningham的《因果推断：混音磁带》（耶鲁大学出版社）和Nick Huntington-Klein的《影响：研究设计和因果性介绍》（查普曼与霍尔/CRC出版社）讨论了几种识别和估计方法，并清晰介绍了DAGs。
- en: 'While Miguel Hernan and James Robins are very respected in the DAG literature,
    their book *Causal Inference: What If* (CRC Press) uses potential outcomes to
    introduce causality and counterfactuals, and derive many important results using
    DAGs.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Miguel Hernan和James Robins在DAG文献中非常受尊重，他们的书《因果推断：假如》（CRC出版社）使用潜在结果来介绍因果关系和反事实情况，并使用DAGs推导了许多重要结果。
- en: 'Guido Imbens, who shared the [Nobel Prize in economics](https://oreil.ly/8p3Yr)
    with David Card and Joshua Angrist in 2021, has been involved in several discussions
    with Judea Pearl on the relative usefulness of both approaches. You can find his
    view and review in “Potential Outcome and Directed Acyclic Graph Approaches to
    Causality: Relevance for Empirical Practice in Economics” ([working paper](https://oreil.ly/OcAm8),
    2020). You might also be interested in reading Judea Pearl’s [response](https://oreil.ly/tz8Hl).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Guido Imbens与David Card和Joshua Angrist共同获得了2021年经济学诺贝尔奖，并与Judea Pearl就两种方法的相对有用性进行了几次讨论。你可以在“潜在结果和有向无环图因果方法：对经济学中实证实践的相关性”的工作论文（2020）中找到他的观点和评论（[工作论文](https://oreil.ly/OcAm8)）。你可能也会对Judea
    Pearl的[回应](https://oreil.ly/tz8Hl)感兴趣。
- en: Also, if you’re interested in how these different schools of thought evolved
    and their views, you can check the [ungated special issue](https://oreil.ly/MXYlp)
    of *Observation Studies* 8, no. 2 (2022). It has interviews with Judea Pearl,
    James Heckman (another Nobel Prize winner in economics), and James Robins (an
    epidemiologist who has led the research on causal inference through structural
    modeling) on their views about the subject and the different approaches.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你对这些不同的思想流派的发展及其观点感兴趣，可以查阅*观察研究*8卷2号（2022年）的[非门户专题](https://oreil.ly/MXYlp)。该期刊对朱迪亚·珀尔、詹姆斯·赫克曼（另一位经济学诺贝尔奖获得者）和詹姆斯·罗宾斯（一位通过结构建模引领因果推断研究的流行病学家）关于这一主题及不同方法的观点进行了采访。
- en: Carlos Cinelli et al., “A Crash Course in Good and Bad Controls” (*Sociological
    Methods and Research*, 2022, available [online](https://oreil.ly/TqTkX)), is a
    systematic discussion on the problem of bad controls.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Carlos Cinelli 等人在“好与坏控制的速成课程”（*社会方法与研究*，2022年，可以在线查阅[此处](https://oreil.ly/TqTkX)）中系统讨论了坏控制的问题。
- en: 'Elias Bareinboim et al., “Recovering from Selection Bias in Causal and Statistical
    Inference” (*Proceedings of the AAAI Conference on Artificial Intelligence* 28,
    no. 1, 2014, also available [online](https://oreil.ly/ZCxGS)) discuss selection
    bias from the point of view of post-treatment sample selection. On this topic,
    you can also read Miguel Hernan’s discussion of different [types of bias](https://oreil.ly/B6rey),
    and Louisa H. Smith’s paper “Selection Mechanisms and Their Consequences: Understanding
    and Addressing Selection Bias” (*Current Epidemiology Reports* 7, 2020, also available
    [online](https://oreil.ly/uqNR4)).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Elias Bareinboim 等人在“消除因果推断和统计推断中的选择偏差”（*人工智能AAAI会议论文集* 28卷1号，2014年，也可以在线查阅[此处](https://oreil.ly/ZCxGS)）中讨论了从治疗后样本选择的角度看选择偏差的问题。关于这个话题，你还可以阅读米格尔·埃尔南对不同[偏倚类型](https://oreil.ly/B6rey)的讨论，以及Louisa
    H. Smith的论文“选择机制及其后果：理解和解决选择偏差”（*当前流行病学报告* 7卷，2020年，也可以在线查阅[此处](https://oreil.ly/uqNR4)）。
- en: '*Trustworthy Online Controlled Experiments* by Ron Kohavi et al. (Cambridge
    University Press) discusses many important topics in A/B test design, including
    the problem of interference or SUTVA violations. You can also check Peter Aronow
    et al., “Spillover Effects in Experimental Data,” in J. Druckman and D. Green,
    eds., *Advances in Experimental Political Science* (Cambridge University Press,
    [arXiv](https://oreil.ly/ZrQQa)).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*可信的在线控制实验*由Ron Kohavi等人（剑桥大学出版社）讨论了A/B测试设计中的许多重要主题，包括干扰或SUTVA违规问题。你还可以查阅Peter
    Aronow等人在J. Druckman和D. Green编辑的《实验政治科学进展》（剑桥大学出版社，[arXiv](https://oreil.ly/ZrQQa)）中的“实验数据中的溢出效应”一文。'
- en: Matheus Facure’s *Causal Inference in Python* (O’Reilly) provides an overview
    of many of the topics discussed here in a book-length treatment. You can also
    check online his [“Causal Inference for the Brave and True”](https://oreil.ly/IgsQE).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Matheus Facure的《Python中的因果推断》（O'Reilly）在书中全面介绍了本文讨论的许多主题。你还可以在线查阅他的[《为勇者和真实者的因果推断》](https://oreil.ly/IgsQE)。
- en: 'On uplift modeling, you can check Shelby Temple’s [“Uplift Modeling: A Quick
    Introduction”](https://oreil.ly/uqdHd) post (*Towards Data Science*, June 2020).
    Chapter 7 in Eric Siegel’s *Predictive Analytics: The Power to Predict Who Will
    Click, Buy, Lie, or Die* (Wiley) has an introduction to the topic for the general
    public.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提升建模，你可以查看Shelby Temple的[《提升建模：快速介绍》](https://oreil.ly/uqdHd)文章（*Towards Data
    Science*，2020年6月）。Eric Siegel的《预测分析：预测谁将点击、购买、撒谎或死亡的力量》（Wiley）第7章向普通公众介绍了这个主题。
- en: 'Jean Kaddour et al., “Causal Machine Learning: A Survey and Open Problems”
    (2022, [arXiv](https://oreil.ly/OBIUu)), provides an up-to-date summary of many
    important topics aside from ML and causality that were not discussed in this chapter.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Jean Kaddour 等人在“因果机器学习：调查与开放问题”（2022年，[arXiv](https://oreil.ly/OBIUu)）中提供了除了机器学习和因果性之外的许多重要主题的最新总结，这些主题在本章没有讨论。
- en: If you want to learn about double machine learning, the [original article](https://oreil.ly/TIcnB)
    is written by Victor Chernozhukov and his coauthors, “Double/Debiased Machine
    Learning for Treatment and Structural Parameters” (*Econometrics Journal* 21,
    no. 1, 2018). I also found useful Chris Felton’s [lecture notes](https://oreil.ly/3ZkfG)
    and Arthur Turrell’s “Econometrics in Python Part I—​Double Machine Learning”
    [post](https://oreil.ly/89gBR). There are [Python and R packages](https://oreil.ly/3M6bU).
    The [EconML](https://oreil.ly/Ks5RT) package also has methods to estimate DML.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解双机器学习，请参考Victor Chernozhukov及其合著者在《计量经济学期刊》2018年发表的原始文章“Double/Debiased
    Machine Learning for Treatment and Structural Parameters”。Chris Felton的[讲义](https://oreil.ly/3ZkfG)和Arthur
    Turrell的“Python中的计量经济学第一部分——双机器学习”[文章](https://oreil.ly/89gBR)也很有用。有[Python和R包](https://oreil.ly/3M6bU)可以使用。[EconML](https://oreil.ly/Ks5RT)包还提供了估计DML的方法。
- en: ^([1](ch15.html#id769-marker)) Just in passing, note that in this example there
    are alternative counterfactual stories that could explain the higher revenue.
    A very common one is peak seasonal sales, where customers are just more willing
    to spend more on your product.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.html#id769-marker)) 顺便提一下，在这个例子中，有几个替代的反事实故事可以解释更高的收入。一个非常常见的情况是高峰季节销售，客户更愿意在您的产品上花费更多。
- en: ^([2](ch15.html#id778-marker)) The DAG approach to identification is popular
    among computer scientists and epidemiologists, and the *potential outcomes approach*
    is most popular among statisticians and economists. I will talk more about the
    latter in what follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.html#id778-marker)) DAG方法在计算机科学家和流行病学家中很受欢迎，而*潜在结果方法*在统计学家和经济学家中最受欢迎。接下来我会更多地讨论后者。
- en: ^([3](ch15.html#id780-marker)) Note that the back-door criterion also includes
    a condition to not control for the descendants of the treatment (the variable
    that causes an outcome).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch15.html#id780-marker)) 请注意，反门后准则还包括一个条件，即不控制治疗的后代（导致结果的变量）。
- en: "^([4](ch15.html#id782-marker)) The DGP is essentially the same as before, but\
    \ I introduced two changes: I draw <math alttext=\"c comma proxy tilde upper N\
    \ left-parenthesis 0 comma normal upper Sigma left-parenthesis rho right-parenthesis\
    \ right-parenthesis\"><mrow><mi>c</mi> <mo>,</mo> <mtext>proxy</mtext> <mo>∼</mo>\
    \ <mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>Σ</mi> <mo>(</mo> <mi>ρ</mi>\
    \ <mo>)</mo> <mo>)</mo></mrow></math> to allow for different correlation coefficients\
    \ between the true unobserved confounder (*c*) and the observed proxy, and I model\
    \ the outcome as <math alttext=\"y equals en-dash 2 plus 3 c minus 2 x plus epsilon\
    \ Subscript y Baseline\"><mrow><mi>y</mi> <mo>=</mo> <mi>â</mi> <mi>\x80</mi>\
    \ <mi>\x93</mi> <mn>2</mn> <mo>+</mo> <mn>3</mn> <mi>c</mi> <mo>-</mo> <mn>2</mn>\
    \ <mi>x</mi> <mo>+</mo> <msub><mi>ϵ</mi> <mi>y</mi></msub></mrow></math> so that\
    \ there is a causal effect from *x* to *y*."
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: "^([4](ch15.html#id782-marker)) DGP基本上与之前相同，但我引入了两个变化：我画出 <math alttext=\"c\
    \ comma proxy tilde upper N left-parenthesis 0 comma normal upper Sigma left-parenthesis\
    \ rho right-parenthesis right-parenthesis\"><mrow><mi>c</mi> <mo>,</mo> <mtext>proxy</mtext>\
    \ <mo>∼</mo> <mi>N</mi> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>Σ</mi> <mo>(</mo>\
    \ <mi>ρ</mi> <mo>)</mo> <mo>)</mo></mrow></math> 来允许真实未观察到的混杂因子（*c*）与观察到的代理之间有不同的相关系数，并且我将结果建模为\
    \ <math alttext=\"y equals en-dash 2 plus 3 c minus 2 x plus epsilon Subscript\
    \ y Baseline\"><mrow><mi>y</mi> <mo>=</mo> <mi>â</mi> <mi>\x80</mi> <mi>\x93</mi>\
    \ <mn>2</mn> <mo>+</mo> <mn>3</mn> <mi>c</mi> <mo>-</mo> <mn>2</mn> <mi>x</mi>\
    \ <mo>+</mo> <msub><mi>ϵ</mi> <mi>y</mi></msub></mrow></math>，以便从*x*到*y*存在因果效应。"
- en: ^([5](ch15.html#id783-marker)) The distinction between the different types of
    selection bias is important. As I will show later, randomization precludes selection
    into the treatment, but doesn’t solve the problem of post-treatment selection.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch15.html#id783-marker)) 区分不同类型的选择偏差很重要。正如我后面将展示的那样，随机化可以防止进入治疗，但不能解决治疗后选择的问题。
- en: ^([6](ch15.html#id786-marker)) Note that there are alternative casual effects
    you can estimate, namely the average treatment effect (ATE) or the average treatment
    effect on the untreated (ATU). I provide references at the end of this chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch15.html#id786-marker)) 请注意，您可以估计的替代因果效应包括平均治疗效应（ATE）或未治疗的平均治疗效应（ATU）。本章末尾提供了参考文献。
- en: ^([7](ch15.html#id802-marker)) Marketplaces have demand and supply sides. Examples
    of demand are the passenger in ridesharing, or guests for Airbnb.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch15.html#id802-marker)) 市场有需求和供给两个方面。例如，乘车共享的乘客或者Airbnb的客人就是需求的例子。
- en: ^([8](ch15.html#id806-marker)) For instance, see Kacper Kubara’s post, [“The
    Proper Way of Handling Mixed-Type Data. State-of-the-Art Distance Metrics”](https://oreil.ly/gEn5R).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch15.html#id806-marker)) 例如，查看卡普尔·库巴拉的文章，“[处理混合类型数据的正确方法。最先进的距离度量](https://oreil.ly/gEn5R)”。
- en: ^([9](ch15.html#id808-marker)) Details can be found in the code [repo](https://oreil.ly/dshp-repo).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch15.html#id808-marker)) 详细信息可以在代码[存储库](https://oreil.ly/dshp-repo)中找到。
- en: ^([10](ch15.html#id824-marker)) Note that this expression isn’t exactly what
    you would obtain from the Frisch-Waugh-Lovell procedure of regressing partialled
    out residuals. This expression is actually closer to an *instrumental variables*
    estimator (see the references at the end of this chapter). The creators of double
    machine learning present another estimator that follows more closely the FWL logic
    (see their Section 4).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch15.html#id824-marker)) 请注意，这个表达式并不完全等同于用弗里施-沃夫-洛维尔程序回归部分化残差所得的结果。这个表达式实际上更接近于*工具变量*估计量（见本章末尾的参考文献）。双重机器学习的创建者提出了另一个更符合FWL逻辑的估计量（见他们的第4节）。
