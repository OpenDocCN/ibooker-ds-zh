- en: 11 Geographic location visualization and analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 地理位置可视化与分析
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: Computing the distance between geographic locations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算地理位置之间的距离
- en: Plotting locations on a map using the Cartopy library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cartopy库在地图上绘制位置
- en: Extracting geo-coordinates from location names
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从位置名称中提取地理坐标
- en: Finding location names in text using regular expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式在文本中查找位置名称
- en: 'People have relied on location information since before the dawn of recorded
    history. Cave dwellers once carved maps of hunting routes into mammoth tusks.
    Such maps evolved as civilizations flourished. The ancient Babylonians fully mapped
    the borders of their vast empire. Much later, in 3000 BC, Greek scholars improved
    cartography using mathematical innovations. The Greeks discovered that the Earth
    was round and accurately computed the planet’s circumference. Greek mathematicians
    laid the groundwork for measuring distances across the Earth’s curved surface.
    Such measurements required the creation of a geographic coordinate system: a rudimentary
    system based on latitude and longitude was introduced in 2000 BC.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 人们依赖位置信息的历史可以追溯到有记录历史之前。穴居人曾经将狩猎路线刻在猛犸象的牙齿上。随着文明的繁荣，这样的地图逐渐发展。古巴比伦人全面绘制了他们庞大帝国的边界。后来，在公元前3000年，希腊学者利用数学创新改进了制图术。希腊人发现地球是圆的，并准确计算了地球的周长。希腊数学家为测量地球曲面的距离奠定了基础。这样的测量需要创建一个地理坐标系统：一个基于纬度和经度的原始系统在公元前2000年被引入。
- en: 'Combining cartography with latitude and longitude helped revolutionize maritime
    navigation. Sailors could more freely travel the seas by checking their positions
    on a map. Roughly speaking, maritime navigation protocols followed these three
    steps:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将制图术与纬度和经度相结合，有助于彻底改变航海导航。水手们可以通过查看地图上的位置来更自由地航行大海。大致来说，航海导航协议遵循以下三个步骤：
- en: '*Data observation*—A sailor recorded a series of observations including wind
    direction, the position of the stars, and (after approximately AD 1300) the northward
    direction of a compass.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*数据观察*——水手记录了一系列观察，包括风向、星星的位置，以及（大约在公元1300年后）指南针的北向方向。'
- en: '*Mathematical and algorithmic analysis of data*—A navigator analyzed all of
    the data to estimate the ship’s position. Sometimes the analysis required trigonometric
    calculations. More commonly, the navigator consulted a series of rule-based measurement
    charts. By algorithmically adhering to the rules in the charts, the navigator
    could figure out the ship’s coordinates.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*数学和算法数据分析*——领航员分析了所有数据，以估计船的位置。有时分析需要三角计算。更常见的是，领航员查阅一系列基于规则的测量图表。通过算法遵循图表中的规则，领航员可以确定船的坐标。'
- en: '*Visualizing and decision making*—The captain examined the computed location
    on a map relative to the expected destination. Then the captain would give orders
    to adjust the ship’s orientation based on the visualized results.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*可视化和决策*——船长检查地图上计算出的位置相对于预期目的地的情况。然后船长会根据可视化的结果下达调整船的航向的命令。'
- en: This navigation paradigm perfectly encapsulates the standard data science process.
    As data scientists, we are offered raw observations. We algorithmically analyze
    that data. Then, we visualize the results to make critical decisions. Thus, data
    science and location analysis are linked. That link has only grown stronger through
    the centuries. Today, countless corporations analyze locations in ways the ancient
    Greeks could never have imagined. Hedge funds study satellite photos of farmlands
    to make bets on the global soybean market. Transport-service providers analyze
    vast traffic patterns to efficiently route fleets of cars. Epidemiologists process
    newspaper data to monitor the global spread of disease.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导航范式完美地概括了标准的数据科学流程。作为数据科学家，我们得到了原始观察数据。我们通过算法分析这些数据。然后，我们可视化结果以做出关键决策。因此，数据科学和位置分析是相互关联的。这种联系在几个世纪中变得越来越紧密。今天，无数公司以古希腊人无法想象的方式分析位置。对冲基金研究农田的卫星照片，以在全球大豆市场上进行投注。运输服务提供商分析庞大的交通模式，以高效地规划车队。流行病学家处理报纸数据，以监测全球疾病的传播。
- en: In this section, we explore a variety of techniques for analyzing and visualizing
    geographic locations. We begin with the simple task of calculating the distance
    between two geographic points.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了分析和可视化地理位置的各种技术。我们从计算两个地理位置之间距离的简单任务开始。
- en: '11.1 The great-circle distance: A metric for computing the distance between
    two global points'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 大圆距离：计算全球两点之间距离的度量
- en: What is the shortest travel distance between any pair of points on Earth? The
    distance cannot be a straight line since direct linear travel would require burrowing
    deep through the Earth’s crust. A much more realistic path entails traveling along
    our spherical planet’s curved surface. This direct path between two points along
    the surface of a sphere is called the *great-circle distance* (figure 11.1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 地球上任何一对点之间的最短旅行距离是什么？由于直接线性旅行需要穿过地球的地壳，所以距离不能是直线。一个更现实的路径是沿着我们球形地球的曲面旅行。球面上两点之间的这种直接路径称为*大圆距离*（图11.1）。
- en: '![](../Images/11-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-01.png)'
- en: Figure 11.1 Visualizing the great-circle distance between two points on the
    surface of a sphere. These points are labeled r[1] and r[2]. A curved arc designates
    the traveling distance between them. The arc length is equal to the radius of
    the sphere multiplied by α, where α is the angle between points relative to the
    sphere’s center at C.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 展示了球面上两点之间的大圆距离。这些点被标记为r[1]和r[2]。一条弯曲的弧线表示它们之间的旅行距离。弧长等于球面半径乘以α，其中α是相对于球心C的两点之间的角度。
- en: We can compute the great-circle distance given a sphere and two points on that
    sphere. Any point on the sphere’s surface can be represented using *spherical
    coordinates* x and y, where x and y measure the angles of the point relative to
    the x-axis and y-axis (figure 11.2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算给定球面上两点之间的大圆距离。球面上的任何点都可以使用*x和y*球坐标来表示，其中x和y衡量点相对于x轴和y轴的角度（图11.2）。
- en: '![](../Images/11-02.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-02.png)'
- en: Figure 11.2 Representing a point on the surface of a sphere using spherical
    coordinates. The point is reached as we rotate 70 degrees away from the x-axis
    and 40 degrees toward the y-axis. Hence, its spherical coordinates are (70, 40).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 使用球坐标表示球面上的一个点。当我们从x轴旋转70度并向y轴旋转40度时，我们到达这个点。因此，它的球坐标是(70, 40)。
- en: Let’s define a basic `great_circle_distance` function that takes as input two
    pairs of spherical coordinates. For simplicity’s sake, we will assume that the
    coordinates are present on a unit sphere with a radius of 1\. This simplification
    allows us to define `great_circle_distance` in just four lines of code. The function
    depends on a series of well-known trigonometric operations; a detailed derivation
    of these operations is beyond the scope of this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个基本的`great_circle_distance`函数，该函数接受两个球坐标对作为输入。为了简化起见，我们将假设这些坐标位于半径为1的单位球上。这种简化使我们能够只用四行代码来定义`great_circle_distance`函数。该函数依赖于一系列众所周知的三角运算；这些运算的详细推导超出了本书的范围。
- en: Listing 11.1 Defining a great-circle distance function
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 定义大圆距离函数
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Imports three common trigonometric functions from Python’s math module
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从Python的math模块导入三个常见的三角函数
- en: ❷ Computes the angular difference between the two pairs of spherical coordinates
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算两个球坐标对之间的角度差
- en: ❸ Executes a series of well-known trigonometric operations to obtain the great-circle
    distance on a unit sphere. The np.product function multiplies together three of
    the trigonometric values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行一系列众所周知的三角运算，以获得单位球面上的大圆距离。np.product函数将三个三角函数值相乘。
- en: Python’s trigonometric functions assume that the input angle is in radians,
    where 0 degrees equal 0 radians and 180 degrees equal *π* radians. Let’s calculate
    the great-circle distance between two points that lie 180 degrees apart relative
    to both the x-axis and the y-axis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python的三角函数假设输入角度是以弧度为单位的，其中0度等于0弧度，180度等于*π*弧度。让我们计算两个点之间的大圆距离，这两个点在x轴和y轴上相隔180度。
- en: Note Radians measure the length of a unit circle arc relative to an angle. The
    maximum arc length equals the unit-circle circumference of 2*π*. Traversing the
    circumference of a circle requires a 360-degree angle. Thus, 2*π* radians equal
    360 degrees, and a single degree equals *π* / 180 radians.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意弧度是相对于角度来衡量单位圆弧长度的。最大弧长等于单位圆的周长2*π*。环绕圆的周长需要360度的角度。因此，2*π*弧度等于360度，一个度等于*π*
    / 180弧度。
- en: Listing 11.2 Computing the great-circle distance
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2 计算大圆距离
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The points are exactly *π* units apart, half the distance required to circumnavigate
    a unit circle. That value is the longest possible distance we can travel between
    two spherical points. This is akin to traveling between the North and South Poles
    of any planet. We’ll confirm by analyzing the latitudes and longitudes of Earth’s
    North Pole and South Pole. Terrestrial latitudes and longitudes are spherical
    coordinates measured in degrees. Let’s begin by recording the known coordinates
    of each pole.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点之间的距离正好是 *π* 单位，是环绕单位圆所需距离的一半。这个值是我们可以在两个球面点之间旅行的最长可能距离。这类似于在任何一个行星的北极和南极之间旅行。我们将通过分析地球北极和南极的纬度和经度来确认这一点。地球的经纬度是度量的球面坐标。让我们首先记录每个极点的已知坐标。
- en: Listing 11.3 Defining the coordinates of Earth’s poles
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 定义地球两极的坐标
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Technically speaking, the North Pole and South Pole do not have an official
    longitude coordinate. However, we’re mathematically justified in assigning a zero
    longitude to each pole.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从技术角度讲，北极和南极没有官方的经度坐标。然而，我们在数学上为每个极点分配零经度是有道理的。
- en: Latitudes and longitudes measure spherical coordinates in degrees, not radians.
    We’ll thus convert to radians from degrees using the `np.radians` function. The
    function takes as input a list of degrees and returns a radian array. This result
    can subsequently be inputted into `great_circle_distance`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度和经度以度为单位测量球面坐标，而不是弧度。因此，我们将使用 `np.radians` 函数将度转换为弧度。该函数接受一个度数的列表作为输入，并返回一个弧度数组。此结果随后可以输入到
    `great_circle_distance`。
- en: Listing 11.4 Computing the great-circle distance between poles
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 计算两极之间的大圆距离
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ As a reminder, running func(*[arg1, arg2]) is a Python shortcut for executing
    func(arg1, arg2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为提醒，运行 func(*[arg1, arg2]) 是 Python 中执行 func(arg1, arg2) 的快捷方式。
- en: As expected, the distance between poles on a unit sphere is *π*. Now, let’s
    measure the distance between two poles here on Earth. The radius of Earth is not
    1 hypothetical unit but rather 3956 actual miles, so we must multiply `distance`
    by 3956 to obtain a terrestrial measurement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，单位球体上两极之间的距离是 *π*。现在，让我们测量地球上两个极点之间的距离。地球的半径不是 1 个假设的单位，而是 3956 英里，因此我们必须将
    `distance` 乘以 3956 以获得地球上的测量值。
- en: Listing 11.5 Computing the travel distance between Earth’s poles
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 计算地球两极之间的旅行距离
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The distance between the two poles is approximately 12,400 miles. We were able
    to compute it by converting the latitudes and longitudes to radians, calculating
    their unit-sphere distance, and then multiplying that value by the radius of Earth.
    We can now create a general `travel_distance` function to calculate the travel
    mileage between any two terrestrial points.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 两个极点之间的距离大约是 12,400 英里。我们能够通过将纬度和经度转换为弧度，计算它们的单位球体距离，然后将该值乘以地球的半径来计算它。现在我们可以创建一个通用的
    `travel_distance` 函数来计算任何两个地球上的点之间的旅行里程。
- en: Listing 11.6 Defining a travel distance function
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 定义旅行距离函数
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our `travel_distance` function is a non-Euclidean metric for measuring distances
    between locations. As discussed in the previous section, we can pass such metrics
    into the DBSCAN clustering algorithm, so we can use `travel_distance` to cluster
    locations based on their spatial distributions. Then we can visually validate
    the clusters by plotting the locations on a map. This map plot can be executed
    using the external Cartopy visualization library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `travel_distance` 函数是一个非欧几里得度量，用于测量地点之间的距离。正如前一小节所讨论的，我们可以将此类度量传递给 DBSCAN
    聚类算法，因此我们可以使用 `travel_distance` 根据地点的空间分布进行聚类。然后我们可以通过在地图上绘制地点来直观地验证聚类。此地图绘制可以使用外部
    Cartopy 可视化库执行。
- en: 11.2 Plotting maps using Cartopy
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用 Cartopy 绘制地图
- en: 'Visualizing geographic data is a common data science task. One external library
    used to map such data is Cartopy: a Matplotlib-compatible tool for generating
    maps in Python. Unfortunately, Cartopy can be a little tricky to install. Every
    other library in this book can be installed with the one-line `pip install` command.
    This calls the `pip` package-management system, which then connects to an external
    server of Python libraries. Pip subsequently installs the selected library along
    with all its Python dependencies, which represent additional library requirements.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化地理数据是常见的数据科学任务。用于映射此类数据的一个外部库是 Cartopy：一个用于在 Python 中生成地图的与 Matplotlib 兼容的工具。不幸的是，Cartopy
    的安装可能有点棘手。本书中的其他所有库都可以使用单行 `pip install` 命令安装。这会调用 `pip` 包管理系统，然后连接到 Python 库的外部服务器。Pip
    随后安装所选库及其所有 Python 依赖项，这些依赖项代表了额外的库需求。
- en: Note For example, NumPy is a dependency of Matplotlib. Calling `pip install
    matplotlib` automatically installs NumPy on a local machine, if NumPy has not
    been installed already.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：例如，NumPy 是 Matplotlib 的依赖项。调用 `pip install matplotlib` 会自动在本地机器上安装 NumPy，如果尚未安装的话。
- en: 'Pip works well when the dependencies are all written in Python. However, Cartopy
    has a dependency that’s written in C++. The GEOS library is a geo-spatial engine
    that underlies Cartopy’s visualizations. It cannot be installed using pip, so
    Cartopy also cannot be installed directly using pip. We’re left with two options:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有依赖项都使用 Python 编写时，Pip 运作良好。然而，Cartopy 有一个用 C++ 编写的依赖项。GEOS 库是一个地理空间引擎，是 Cartopy
    可视化的基础。它不能使用 pip 安装，因此 Cartopy 也不能直接使用 pip 安装。我们只剩下两个选项：
- en: Manually installing GEOS and Cartopy
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动安装 GEOS 和 Cartopy
- en: Installing the Cartopy library using the Conda package manager
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Conda 软件包管理器安装 Cartopy 库
- en: Let’s discuss the pros and cons of each approach.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每种方法的优缺点。
- en: 'Note For a deeper dive into Python dependencies, see Manning’s “Managing Python
    Dependencies” liveVideo: [www.manning.com/livevideo/talk-python-managing-python-dependencies](http://www.manning.com/livevideo/talk-python-managing-python-dependencies).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要深入了解 Python 依赖项，请参阅 Manning 的“Managing Python Dependencies”直播视频：[www.manning.com/livevideo/talk-python-managing-python-dependencies](http://www.manning.com/livevideo/talk-python-managing-python-dependencies)。
- en: 11.2.1 Manually installing GEOS and Cartopy
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 手动安装 GEOS 和 Cartopy
- en: 'The GEOS installation varies based on the operating system. On macOS, it can
    be installed by calling `brew install proj geos` from the command line; and on
    Linux, it can be installed by calling `apt-get` instead of `brew`. Additionally,
    Windows users can download and install the library from [https://trac.osgeo.org/geos](https://trac.osgeo.org/geos).
    Once GEOS is installed, Cartopy and its dependencies can be added with the following
    sequential pip commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: GEOS 的安装取决于操作系统。在 macOS 上，可以通过在命令行中调用 `brew install proj geos` 来安装；在 Linux 上，可以通过调用
    `apt-get` 而不是 `brew` 来安装。此外，Windows 用户可以从 [https://trac.osgeo.org/geos](https://trac.osgeo.org/geos)
    下载并安装库。一旦安装了 GEOS，就可以使用以下顺序 pip 命令添加 Cartopy 和其依赖项：
- en: '`pip install --upgrade cython numpy pyshp six`'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pip install --upgrade cython numpy pyshp six`'
- en: This installs all Python dependencies except the Shapely shape-rendering library.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装所有 Python 依赖项，除了 Shapely 形状渲染库。
- en: '`pip install shapely --no-binary shapely`'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pip install shapely --no-binary shapely`'
- en: The Shapely library must be compiled from scratch so that it links to GEOS.
    The `no-binary` command ensures a fresh compilation.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Shapely 库必须从头开始编译，以便链接到 GEOS。`no-binary` 命令确保了全新的编译。
- en: '`pip install cartopy`'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pip install cartopy`'
- en: Now that the dependencies are ready, we call Cartopy using pip.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在依赖项都已准备就绪，我们可以使用 pip 调用 Cartopy。
- en: Manual installation can be cumbersome. Our alternative is to utilize the Conda
    package manager.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 手动安装可能很麻烦。我们的替代方案是利用 Conda 软件包管理器。
- en: 11.2.2 Utilizing the Conda package manager
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 利用 Conda 软件包管理器
- en: 'Conda, like pip, is a package manager that can download and install external
    libraries. Unlike pip, Conda can easily handle non-Python dependencies. Also unlike
    pip, Conda does not come preinstalled on most machines: it must be downloaded
    and installed from [https://docs.conda.io/en/latest/miniconda.html](https://docs.conda.io/en/latest/miniconda.html).
    Then we can easily install the Cartopy library by running `conda install -c conda-forge
    cartopy`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Conda 与 pip 类似，是一个可以下载和安装外部库的包管理器。与 pip 不同，Conda 可以轻松处理非 Python 依赖项。而且与 pip
    不同，Conda 并未预安装在大多数机器上：它必须从 [https://docs.conda.io/en/latest/miniconda.html](https://docs.conda.io/en/latest/miniconda.html)
    下载并安装。然后我们可以通过运行 `conda install -c conda-forge cartopy` 来轻松安装 Cartopy 库。
- en: 'Unfortunately, using Conda has some trade-offs. When Conda installs a new Python
    library, it does so in an isolated environment called a *virtual environment*.
    The virtual environment has its own version of Python, which is separated from
    the main version of Python that resides on a user’s machine. Consequently, the
    Cartopy library is installed in the virtual environment but not the main environment.
    This can cause confusion when importing Cartopy, especially in a Jupyter notebook,
    because Jupyter points to the main environment by default. To add the Conda environment
    to Jupyter, we must run the following two commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用Conda有一些权衡。当Conda安装一个新的Python库时，它会在一个称为*虚拟环境*的隔离环境中进行安装。虚拟环境有自己的Python版本，它与用户机器上的主Python版本分开。因此，Cartopy库安装在虚拟环境中，而不是主环境中。这可能导致导入Cartopy时产生混淆，尤其是在Jupyter笔记本中，因为Jupyter默认指向主环境。为了将Conda环境添加到Jupyter，我们必须运行以下两个命令：
- en: '`conda install -c anaconda ipykernel`'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`conda install -c anaconda ipykernel`'
- en: '`python -m ipykernel install --user --name=base`'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`python -m ipykernel install --user --name=base`'
- en: Doing so ensures that the Jupyter notebook can interact with a Conda environment
    called `base`, which is the default name of the environment created by Conda.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做确保了Jupyter笔记本可以与名为`base`的Conda环境交互，这是Conda创建的环境的默认名称。
- en: Now we can select the `base` environment from Jupyter’s drop-down menu when
    creating a new notebook (figure 11.3). Then we’ll be able to import Cartopy in
    the notebook.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在创建新笔记本时从Jupyter的下拉菜单中选择`base`环境（图11.3）。然后我们就能在笔记本中导入Cartopy。
- en: '![](../Images/11-03.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-03.png)'
- en: Figure 11.3 Selecting the environment when creating a new notebook. Conda’s
    `base` environment can be selected from the drop-down menu. Choosing `base` allows
    us to import the installed Cartopy library.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 创建新笔记本时选择环境。可以从下拉菜单中选择Conda的`base`环境。选择`base`环境允许我们导入已安装的Cartopy库。
- en: Note Conda’s default virtual environment is called `base`. However, Conda allows
    us to create and track multiple environments. To create a new virtual environment
    called `new_env`, we need to execute `conda create -n new_env` from the command
    line. Then we can switch to the new environment by running `conda activate new_env`.
    Running `conda activate base` switches back to `base`, where Cartopy is installed.
    Additionally, the `conda deactivate` command switches to our machine’s default
    Python settings. We can also check the current environment’s name by running `conda
    info`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Conda的默认虚拟环境被称为`base`。然而，Conda允许我们创建和跟踪多个环境。要创建一个名为`new_env`的新虚拟环境，我们需要在命令行中执行`conda
    create -n new_env`。然后我们可以通过运行`conda activate new_env`切换到新环境。运行`conda activate
    base`将切换回`base`环境，其中已安装Cartopy。此外，`conda deactivate`命令将切换到机器的默认Python设置。我们还可以通过运行`conda
    info`来检查当前环境的名称。
- en: Let’s confirm installation by running `import cartopy` from within a Jupyter
    notebook.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在Jupyter笔记本中运行`import cartopy`来确认安装。
- en: Listing 11.7 Importing the Cartopy library
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7 导入Cartopy库
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cartopy installation can be confusing, but the confusion is worth it. Cartopy
    is the best, most commonly used map visualization tool for Python. Let’s plot
    some maps.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Cartopy的安装可能会让人感到困惑，但这份困惑是值得的。Cartopy是Python中最好的、最常用的地图可视化工具。让我们来绘制一些地图。
- en: 11.2.3 Visualizing maps
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 地图可视化
- en: 'A geographic map is a 2D representation of a 3D surface on a globe. Flattening
    the spherical globe is carried out using a process called *projection*. There
    are many different types of map projections: the simplest involves superimposing
    the globe on an unrolled cylinder, which yields a 2D map whose `(x, y)` coordinates
    perfectly correspond with longitude and latitude.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 地理地图是地球球面上三维表面的二维表示。通过称为*投影*的过程将球面地球展开成平面。存在许多不同类型的地图投影：最简单的一种是将地球叠加在一个展开的圆柱上，从而得到一个二维地图，其`(x,
    y)`坐标完美地对应于经度和纬度。
- en: Note In most other projections, the 2D grid coordinates don’t equal the spherical
    coordinates. Hence, they require conversion from one coordinate system to another.
    We encounter this issue later in the section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在大多数其他投影中，二维网格坐标不等于球面坐标。因此，它们需要从一种坐标系转换到另一种坐标系。我们将在本节后面遇到这个问题。
- en: This technique is called the *equidistant cylindrical projection* or *plate
    carrée projection*. We utilize this standard projection in our plots by importing
    `PlateCarree` from `cartopy.crs`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为*等距圆柱投影*或*平面圆柱投影*。我们通过从`cartopy.crs`导入`PlateCarree`来使用这种标准投影。
- en: 'Note The `cartopy.crs` module includes many other projection types. We can,
    for instance, import `Orthographic`: doing so returns an *orthographic projection*
    in which the Earth is represented from the perspective of a viewer in the outer
    reaches of the galaxy.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`cartopy.crs` 模块包含许多其他投影类型。例如，我们可以导入 `Orthographic`：这样做会返回一个*正射投影*，其中地球是从银河系外缘观察者的视角来表示的。
- en: Listing 11.8 Importing the plate carrée projection
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 导入平板圆投影
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `PlateCarree` class can be used in conjunction with Matplotlib to visualize
    the Earth. For instance, running `plt.axes(projection=PlateCarree()).coastlines()`
    plots the outlines of the Earth’s seven continents. More precisely, `plt.axes(projection=PlateCarree())`
    initializes a custom Matplotlib axis capable of visualizing maps. Subsequently,
    the `coastlines` method call draws the coastline boundaries of the continents
    (figure 11.4).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlateCarree` 类可以与 Matplotlib 结合使用来可视化地球。例如，运行 `plt.axes(projection=PlateCarree()).coastlines()`
    会绘制地球七大洲的轮廓。更精确地说，`plt.axes(projection=PlateCarree())` 初始化了一个能够可视化地图的自定义 Matplotlib
    轴。随后，调用 `coastlines` 方法会绘制大陆的海岸线边界（图11.4）。'
- en: Listing 11.9 Visualizing the Earth using Cartopy
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 使用 Cartopy 可视化地球
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/11-04.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-04.png)'
- en: Figure 11.4 A standard map of the Earth on which the coastlines of the continents
    have been plotted
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 在地球上绘制了大陆海岸线的标准地图
- en: Our plotted map is a bit small. We can increase the map size using Matplotlib’s
    `plt.figure` function. Calling `plt.figure(figsize=(width, height))` creates a
    figure that is `width` inches wide and `height` inches high. Listing 11.10 increases
    the figure size to 12 x 8 inches before generating the world map (figure 11.5).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制的地图有点小。我们可以使用 Matplotlib 的 `plt.figure` 函数增加地图的大小。调用 `plt.figure(figsize=(width,
    height))` 会创建一个宽度为 `width` 英寸、高度为 `height` 英寸的图表。列表11.10在生成世界地图（图11.5）之前将图的大小增加到12
    x 8英寸。
- en: Note The actual dimensions of the figure in the book are not 12 x 8 inches due
    to image formatting.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于图像格式化，书中图的实际尺寸并非12 x 8英寸。
- en: Listing 11.10 Visualizing a larger map of the Earth
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.10 可视化更大的地球地图
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Creates a larger figure that is 12 inches wide and 8 inches high
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个宽度为12英寸、高度为8英寸的大图
- en: '![](../Images/11-05.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-05.png)'
- en: Figure 11.5 A standard map of the Earth on which the coastlines of the continents
    have been plotted. The map’s size has been increased using Matplotlib’s `plt.figure`
    function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 在地球上绘制了大陆海岸线的标准地图。使用 Matplotlib 的 `plt.figure` 函数增加了地图的大小。
- en: 'So far, our map looks sparse and uninviting. We can improve the quality by
    calling `plt.axes(projection=PlateCarree()).stock_img()`. The method call colors
    the map using topographic information: oceans are colored blue, and forested regions
    are colored green (figure 11.6).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的地图看起来有点稀疏，不太吸引人。我们可以通过调用 `plt.axes(projection=PlateCarree()).stock_img()`
    来提高地图的质量。该方法调用使用地形信息着色地图：海洋被着色为蓝色，森林地区被着色为绿色（图11.6）。
- en: Listing 11.11 Coloring a map of the Earth
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 着色地球地图
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/11-06.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-06.png)'
- en: Figure 11.6 A standard map of the Earth that has been colored to display oceanographic
    and topographic details
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 一个经过着色以显示海洋和地形细节的地球标准地图
- en: 'Our colored map does not include the border lines demarcating coastal boundaries.
    Adding these boundaries will improve the map’s quality. However, we are unable
    to add both color and boundaries in a single line of code. Instead, we need to
    execute the following three lines (figure 11.7):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们着色的地图没有包括划分海岸边界的线条。添加这些边界将提高地图的质量。然而，我们无法在单行代码中添加颜色和边界。相反，我们需要执行以下三行（图11.7）：
- en: '`ax = plt.axes(projection=PlateCarree())`'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ax = plt.axes(projection=PlateCarree())`'
- en: This line initializes a custom Matplotlib axis capable of visualizing maps.
    Per standard convention, the axis is assigned to the `ax` variable.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码初始化了一个能够可视化地图的自定义 Matplotlib 轴。按照标准惯例，该轴被分配给 `ax` 变量。
- en: '`ax.coastlines()`'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ax.coastlines()`'
- en: This line adds the coastlines to the plot.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码将海岸线添加到图表中。
- en: '`ax.stock_img()`'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ax.stock_img()`'
- en: This line adds the topographic colors to the plot.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码将地形颜色添加到图表中。
- en: '![](../Images/11-07.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-07.png)'
- en: Figure 11.7 A standard map of the Earth that has been colored to display oceanographic
    and topographic details. Furthermore, plotted coastlines provide crisp details
    for the continental boundaries.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 一个经过着色以显示海洋和地形细节的地球标准地图。此外，绘制的海岸线为大陆边界提供了清晰的细节。
- en: Let’s run these steps to generate a crisp, colorful map.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这些步骤以生成一个清晰、多彩的地图。
- en: Listing 11.12 Plotting coastlines together with map colors
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.12 与地图颜色一起绘制海岸线
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that `ax.stock_img()` relies on a saved stock image of the Earth to color
    the map. This image renders poorly when a user zooms in on the map (which we’ll
    do shortly). Alternatively, we can color the oceans and continents using the `ax.add_feature`
    method, which displays special Cartopy features stored in the `cartopy.feature`
    module. For example, calling `ax.add_feature(cartopy.feature.OCEAN)` colors all
    the oceans blue, and inputting `cartopy.feature.LAND` colors all land masses beige.
    Let’s utilize these features to color the map (figure 11.8).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ax.stock_img()`依赖于保存的地球库存图像来着色地图。当用户放大地图时（我们很快就会这样做），此图像的渲染效果不佳。作为替代，我们可以使用`ax.add_feature`方法来着色海洋和大陆，该方法显示存储在`cartopy.feature`模块中的特殊Cartopy特性。例如，调用`ax.add_feature(cartopy.feature.OCEAN)`将所有海洋着色为蓝色，输入`cartopy.feature.LAND`将所有陆地着色为米色。让我们利用这些特性来着色地图（图11.8）。
- en: Listing 11.13 Adding colors with the `feature` module
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.13 使用`feature`模块添加颜色
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ We continue to display the coastlines to add crispness to the image.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们继续显示海岸线，以增加图像的清晰度。
- en: '![](../Images/11-08.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-08.png)'
- en: Figure 11.8 A standard map of the Earth that has been colored using the `feature`
    module
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 使用`feature`模块着色的标准地球地图
- en: Currently, national borders are missing from the plot. Cartopy treats these
    borders as a feature in the `feature` module. We can incorporate country borders
    by calling `ax.add_feature(cartopy.feature.BORDERS)` (figure 11.9).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，图中缺少国家边界。Cartopy将这些边界视为`feature`模块中的一个特性。我们可以通过调用`ax.add_feature(cartopy.feature.BORDERS)`（图11.9）来包含国家边界。
- en: Listing 11.14 Adding national borders to the plot
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.14 向图中添加国家边界
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/11-09.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-09.png)'
- en: Figure 11.9 A standard map of the Earth including national borderlines
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 包含国家边界的标准地球地图
- en: Suppose we are given a list of locations defined by pairs of latitudes and longitudes.
    We can plot these locations on a global map as a standard scatter plot by calling
    `ax.scatter(longitudes, latitudes)`. However, Matplotlib zooms in on the scattered
    points by default, making the mapped image incomplete. We can prevent this by
    calling `ax.set_global()`, which extends the plotted image to all four edges of
    the globe. Listing 11.15 plots some geographic points; for simplicity, we limit
    our map content to the coastal boundaries (figure 11.10).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们给定一个由纬度和经度对定义的位置列表。我们可以通过调用`ax.scatter(longitudes, latitudes)`将这些位置作为一个标准散点图绘制在全局地图上。然而，Matplotlib默认会放大散点，使得绘制的图像不完整。我们可以通过调用`ax.set_global()`来防止这种情况，这将扩展绘制的图像到地球的四个边缘。列表11.15绘制了一些地理点；为了简单起见，我们将地图内容限制在海岸边界（图11.10）。
- en: '![](../Images/11-10.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-10.png)'
- en: Figure 11.10 A standard map of the Earth with plotted latitude and longitude
    coordinates
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 绘制了纬度和经度坐标的标准地球地图
- en: 'Note As previously mentioned, the plate carrée projection yields a 2D grid
    in which `longitudes` and `latitudes` can be plotted directly on the axes. For
    other projections, this is not the case: they require a transformation of `longitudes`
    and `latitudes` before the scatter plot is generated. Shortly, we discuss how
    to properly handle that transformation.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如前所述，平板正射投影产生一个二维网格，其中可以直接在轴上绘制`经度`和`纬度`。对于其他投影，情况并非如此：在生成散点图之前，需要将`经度`和`纬度`进行转换。简而言之，我们将讨论如何正确处理这种转换。
- en: Listing 11.15 Plotting coordinates on a map
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.15 在地图上绘制坐标
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The plotted points all fall within the borders of North America. We can simplify
    the map by zooming in on that continent. However, first we need to adjust the
    *map extent*, which is the geographic area shown on a map. The extent is determined
    by a rectangle whose corners are positioned on the minimum and maximum latitude
    and longitude coordinates on display. In Cartopy, these corners are defined by
    a four-element tuple of the form `(min_lon, max_lon, min_lat, max_lat)`. Passing
    that list into `ax.set_ extent` adjusts the boundaries of the map.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所绘制的点都位于北美洲的边界内。我们可以通过放大该大陆来简化地图。然而，首先我们需要调整`地图范围`，这是地图上显示的地理区域。范围由一个矩形确定，其角落位于显示的最小和最大纬度和经度坐标。在Cartopy中，这些角落由一个形式为`(min_lon,
    max_lon, min_lat, max_lat)`的四个元素的元组定义。将此列表传递给`ax.set_extent`调整地图的边界。
- en: We now assign a common North American extent to a `north_america_extent` variable.
    Then we utilize the `ax.set_extent` method to zoom in on North America. We regenerate
    our scatter plot, this time adding color by passing `color='r'` into `ax.scatter`;
    we also utilize the `feature` module to color the map while adding national borders
    (figure 11.11).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将一个常见的北美洲范围分配给 `north_america_extent` 变量。然后我们使用 `ax.set_extent` 方法来放大北美洲。我们重新生成我们的散点图，这次通过将
    `color='r'` 传递给 `ax.scatter` 来添加颜色；我们还利用 `feature` 模块在添加国家边界的同时给地图上色（图 11.11）。
- en: Listing 11.16 Plotting North American coordinates
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.16 绘制北美洲坐标
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ The North American extent occurs between –145 and –50 degrees longitude and
    between 0 and 90 degrees latitude.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 北美洲范围位于经度 -145 到 -50 度之间，纬度 0 到 90 度之间。
- en: ❷ This function adds common features to a map. It is reused elsewhere in this
    section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此函数向地图添加常用功能。在本节的其他地方被重复使用。
- en: '![](../Images/11-11.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-11.png)'
- en: Figure 11.11 A map of North America with plotted latitude and longitude coordinates
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 一张带有纬度和经度坐标的北美洲地图
- en: 'We successfully zoomed in on North America. Now we’ll zoom in further, to the
    United States. Unfortunately, the plate carrée projection is insufficient for
    this purpose: that technique distorts the map if we zoom in too close on any country.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地将地图放大到北美洲。现在我们将进一步放大，到美国。不幸的是，等角投影对于这个目的来说是不够的：如果我们对任何国家进行过于接近的放大，该技术会扭曲地图。
- en: Instead, we will rely on the *Lambert conformal conic projection*. In this projection,
    a cone is placed on top of the spherical Earth. The cone’s circular base covers
    the region we intend to map. Then, coordinates in the region are projected onto
    the surface of the cone. Finally, the cone is unrolled to create a 2D map. However,
    that map’s 2D coordinates don’t directly equal longitude and latitude.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将依赖 *Lambert 正形圆锥投影*。在这个投影中，一个圆锥放置在球形地球的顶部。圆锥的圆形底部覆盖了我们打算绘制的区域。然后，该区域的坐标被投影到圆锥的表面上。最后，将圆锥展开以创建一个二维地图。然而，该地图的二维坐标并不直接等于经度和纬度。
- en: 'Cartopy includes a `LambertConformal` class in the `csr` module. Executing
    `plt.axes(projection=LambertConformal())` yields axes corresponding to the Lambert
    conformal coordinate system. Subsequently, passing the US extent into `ax.set_
    extent` will zoom the map onto the United States. Listing 11.17 defines `us_extent`
    and passes it into the method. We’ll also plot our geographic data, but first
    we need to transform `longitudes` and `latitudes` into coordinates that are compatible
    with `LambertConformal`: in other words, we must transform the data from `PlateCarree`-compatible
    coordinates to something different. This can be done by passing `transform=PlateCarree()`
    into `ax.scatter()`. Let’s run this transformation to visualize our points on
    a US map (figure 11.12).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Cartopy 在 `csr` 模块中包含了一个 `LambertConformal` 类。执行 `plt.axes(projection=LambertConformal())`
    会产生与 Lambert 正形坐标系相对应的坐标轴。随后，将美国范围传递给 `ax.set_extent` 将地图放大到美国。列表 11.17 定义了 `us_extent`
    并将其传递给该方法。我们还将绘制我们的地理数据，但首先我们需要将 `longitudes` 和 `latitudes` 转换为与 `LambertConformal`
    兼容的坐标：换句话说，我们必须将数据从 `PlateCarree` 兼容坐标转换为不同的坐标。这可以通过将 `transform=PlateCarree()`
    传递给 `ax.scatter()` 来完成。让我们运行这个转换来可视化我们在美国地图上的点（图 11.12）。
- en: '![](../Images/11-12.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-12.png)'
- en: Figure 11.12 A Lambert conformal view of the United States with plotted latitude
    and longitude coordinates
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 一张带有纬度和经度坐标的 Lambert 正形投影的美国视图
- en: Note When this code is first run, Cartopy downloads and installs the Lambert
    conformal projection. Hence, an internet connection is required to execute the
    code for the very first time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当此代码首次运行时，Cartopy 会下载并安装 Lambert 正形投影。因此，执行代码需要互联网连接，尤其是在第一次执行时。
- en: Listing 11.17 Plotting US coordinates
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.17 绘制美国坐标
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Imports the Lambert conformal conic projection
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 Lambert 正形圆锥投影
- en: ❷ The ax axis corresponds with LambertConformal coordinates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ ax 轴与 LambertConformal 坐标相对应。
- en: ❸ The US extent occurs between –120 and –75 degrees longitude and between 20
    and 50 degrees latitude.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 美国范围位于经度 -120 到 -75 度之间，纬度 20 到 50 度之间。
- en: ❹ Transforms longitudes and latitudes from PlateCarree-compatible coordinates
    to ax.projection-compatible coordinates (where ax.projection equals LambertConformal).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将经度和纬度从 PlateCarree 兼容坐标转换为 ax.projection 兼容坐标（其中 ax.projection 等于 LambertConformal）。
- en: ❺ The s parameter specifies the plotted marker size. We increase that size for
    better visibility.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ s 参数指定了绘制的标记大小。我们增加该大小以提高可见性。
- en: Our map of the United States is looking a little sparse. Let’s add state borders
    by calling `ax.add_feature(cartopy.feature.STATES)` (figure 11.13).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的美国地图看起来有点稀疏。让我们通过调用 `ax.add_feature(cartopy.feature.STATES)`（图 11.13）来添加州边界。
- en: '![](../Images/11-13.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-13.png)'
- en: Figure 11.13 A Lambert conformal view of the United States including state borders
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 包含州边界的美国 Lambert 等角圆锥视图
- en: Listing 11.18 Plotting a US map including state borders
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.18 绘制包含州边界的美国地图
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Common Cartopy methods
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 常见 Cartopy 方法
- en: '`ax = plt.axes(projection=PlateCarree())`—Creates a custom Matplotlib axis
    for generating a map using a plate carrée projection'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax = plt.axes(projection=PlateCarree())`—创建一个自定义的 Matplotlib 轴，用于使用平板圆投影生成地图'
- en: '`ax = plt.axes(projection=LambertConformal())`—Creates a custom Matplotlib
    axis for generating a map using a Lambert conformal conic projection'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax = plt.axes(projection=LambertConformal())`—创建一个自定义的 Matplotlib 轴，用于使用 Lambert
    等角圆锥投影生成地图'
- en: '`ax.coastlines()`—Plots continental coastlines on a map'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.coastlines()`—在地图上绘制大陆海岸线'
- en: '`ax.add_feature(cartopy.feature.BORDERS)`—Plots national boundaries on a map'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.add_feature(cartopy.feature.BORDERS)`—在地图上绘制国家边界'
- en: '`ax.add_feature(cartopy.feature.STATES)`— Plots US state boundaries on a map'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.add_feature(cartopy.feature.STATES)`—在地图上绘制美国州边界'
- en: '`ax.stock_img()`—Colors a plotted map using topographic information'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.stock_img()`—使用地形信息为绘制的地图着色'
- en: '`ax.add_feature(cartopy.feature.OCEAN)`—Colors all the oceans blue on the map'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.add_feature(cartopy.feature.OCEAN)`—在地图上将所有海洋涂成蓝色'
- en: '`ax.add_feature(cartopy.feature.LAND)`—Colors all the land masses beige on
    the map'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.add_feature(cartopy.feature.LAND)`—在地图上将所有陆地涂成米色'
- en: '`ax.set_global()`—Extends the plotted image to all four edges of the globe'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.set_global()`—将绘制的图像扩展到地球的四个边缘'
- en: '`ax.set_extent(min_lon, max_lon, min_lat, max_lat)`—Adjusts the plotted map
    extent, which is the geographic area shown on a map, using minimum and maximum
    latitudes and longitudes'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.set_extent(min_lon, max_lon, min_lat, max_lat)`—使用最小和最大纬度和经度调整绘制的地图范围，即地图上显示的地理区域'
- en: '`ax.scatter(longitudes, latitudes)`—Plots latitude and longitude coordinates
    on a map'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.scatter(longitudes, latitudes)`—在地图上绘制纬度和经度坐标'
- en: '`ax.scatter(longitudes, latitudes, transform=PlateCarree())`—Plots latitude
    and longitude coordinates on a map while transforming the data from `PlateCarree`-compatible
    coordinates to something different (such as Lambert conformal conic coordinates)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax.scatter(longitudes, latitudes, transform=PlateCarree())`—在地图上绘制纬度和经度坐标，同时将数据从
    `PlateCarree` 兼容坐标转换为不同的坐标（如 Lambert 等角圆锥坐标）'
- en: Cartopy allows us to plot any location on a map. All we need is the location’s
    latitude and longitude. Of course, we must know these geographic coordinates before
    plotting them on a map, so we need a mapping between location names and their
    geographic properties. That mapping is provided by the GeoNamesCache location-tracking
    library.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Cartopy 允许我们在地图上绘制任何位置。我们需要的只是位置的纬度和经度。当然，在地图上绘制它们之前，我们必须知道这些地理坐标，因此我们需要一个位置名称与其地理属性之间的映射。这个映射由
    GeoNamesCache 位置跟踪库提供。
- en: 11.3 Location tracking using GeoNamesCache
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 使用 GeoNamesCache 进行位置跟踪
- en: The GeoNames database ([http://geonames.org](http://geonames.org)) is an excellent
    resource for obtaining geographic data. GeoNames contains over 11 million place
    names spanning all the countries in the world. In addition, GeoNames stores valuable
    information such as latitude and longitude. Thus, we can use the database to determine
    the precise geographic locations of cities and countries discovered in text.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: GeoNames 数据库 ([http://geonames.org](http://geonames.org)) 是获取地理数据的优秀资源。GeoNames
    包含超过 1100 万个地名，覆盖世界上所有国家。此外，GeoNames 还存储了诸如纬度和经度等有价值的信息。因此，我们可以使用数据库来确定文本中发现的城市的精确地理位置。
- en: How do we access the GeoNames data? Well, we could manually download the GeoNames
    data dump ([http://download.geonames.org/export/dump](http://download.geonames.org/export/dump)),
    parse it, and then store the output data structure. That would take a lot of work.
    Fortunately, someone has already done the hard work for us by creating the GeoNamesCache
    library.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何访问 GeoNames 数据？嗯，我们可以手动下载 GeoNames 数据库快照 ([http://download.geonames.org/export/dump](http://download.geonames.org/export/dump))，解析它，然后存储输出数据结构。这将需要大量工作。幸运的是，有人已经为我们做了这项艰苦的工作，创建了
    GeoNamesCache 库。
- en: 'GeoNamesCache is designed to efficiently retrieve data about continents, countries,
    cities, and US counties and states. The library provides six easy-to-use methods
    to support access to location data: `get_continents`, `get_countries`, `get_cities`,
    `get_ countries_by_name`, `get_cities_by_name`, and `get_us_counties`. Let’s install
    the library and explore its usage in more detail. We begin by initializing a `GeonamesCache`
    location-tracking object.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GeoNamesCache 被设计用来高效地检索有关大陆、国家、城市以及美国县和州的数据。该库提供了六个易于使用的函数来支持对位置数据的访问：`get_continents`、`get_countries`、`get_cities`、`get_countries_by_name`、`get_cities_by_name`
    和 `get_us_counties`。让我们安装这个库并更详细地探索其用法。我们首先初始化一个 `GeonamesCache` 位置跟踪对象。
- en: Note Call `pip install geonamescache` from the command line terminal to install
    the GeoNamesCache library.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 从命令行终端调用 `pip install geonamescache` 来安装 GeoNamesCache 库。
- en: Listing 11.19 Initializing a `GeonamesCache` object
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.19 初始化 `GeonamesCache` 对象
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s use our `gc` object to explore the seven continents. We run `gc.get_continents()`
    to retrieve a dictionary of continent-related information. Then we investigate
    the dictionary’s structure by printing out its keys.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的 `gc` 对象来探索七个大洲。我们运行 `gc.get_continents()` 来检索一个包含大陆相关信息的字典。然后我们通过打印其键来调查字典的结构。
- en: Listing 11.20 Fetching all seven continents from GeoNamesCache
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.20 从 GeoNamesCache 获取所有七个大洲
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The dictionary keys represent shorthand encoding of continent names in which
    *Africa* is transformed into `'AF'` and *North America* is transformed into `'NA'`.
    Let’s check the values mapped to every key by passing in the code for *North America*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 字典键代表大陆名称的简写编码，其中 *非洲* 转换为 `'AF'`，*北美* 转换为 `'NA'`。让我们通过传递 *北美* 的代码来检查每个键映射的值。
- en: Note `continents` is a nested dictionary. Thus, the seven top-level keys map
    to content-specific dictionary structures. Listing 11.21 outputs the content-specific
    keys contained in the `continents['NA']` dictionary.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `continents` 是一个嵌套字典。因此，七个顶级键映射到特定内容的数据结构。列表 11.21 输出了 `continents['NA']`
    字典中包含的特定内容键。
- en: Listing 11.21 Fetching North America from GeoNamesCache
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.21 从 GeoNamesCache 获取北美
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Many of the `north_america` data elements represent various naming schemes for
    the North American continent. Such information is not very useful.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 `north_america` 数据元素代表北美大陆的各种命名方案。此类信息并不十分有用。
- en: Listing 11.22 Printing North America’s naming schemes
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.22 打印北美命名方案
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, other elements hold more value. For example, the `'lat'` and `'lng'`
    keys map to the latitude and longitude of the most central location in North America.
    Let’s visualize this location on a map (figure 11.14).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他元素持有更多价值。例如，`'lat'` 和 `'lng'` 键映射到北美最中心位置的纬度和经度。让我们在地图上可视化这个位置（图 11.14）。
- en: Listing 11.23 Mapping North America’s central coordinates
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.23 映射北美中央坐标
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ The lat and lng keys map to North American’s central latitude and longitude.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `lat` 和 `lng` 键映射到北美中央的纬度和经度。
- en: '![](../Images/11-14.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-14.png)'
- en: Figure 11.14 The central North American latitude and longitude plotted on a
    map of North America
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 北美中央纬度和经度在北美地图上的绘制
- en: 11.3.1 Accessing country information
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 访问国家信息
- en: The ability to access continental data is useful, although our primary concern
    is analyzing cities and countries. We can analyze countries using the `get_countries`
    method. It returns a dictionary whose two-character keys encode the names of 252
    different countries. As with the continents, the country codes capture the abbreviated
    country names. For example, the code for *Canada* is `'CA'`, and the code for
    *United States* is `'US'`. Accessing `gc.get_countries()['US']` returns a dictionary
    containing useful US data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 访问大陆数据的能力是有用的，尽管我们的主要关注点是分析城市和国家。我们可以使用 `get_countries` 方法来分析国家。它返回一个字典，其中两个字符的键编码了
    252 个不同国家的名称。与大陆一样，国家代码捕获了简写国家名称。例如，*加拿大* 的代码是 `'CA'`，*美国* 的代码是 `'US'`。访问 `gc.get_countries()['US']`
    返回一个包含有用美国数据的字典。
- en: Listing 11.24 Fetching US data from GeoNamesCache
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.24 从 GeoNamesCache 获取美国数据
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ US continent code
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 美国大陆代码
- en: ❷ Capital of the US
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 美国首都
- en: ❸ US area, in square kilometers
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 美国面积，以平方公里为单位
- en: ❹ US population
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 美国人口
- en: ❺ Currency of the US
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 美元货币
- en: ❻ Common spoken languages in the US
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 美国常用口语语言
- en: ❼ US neighboring territories
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 美国邻近领土
- en: The outputted country data includes many useful elements, such as the country’s
    capital, currency, area, spoken languages, and population. Regrettably, GeoNamesCache
    fails to provide the central latitude and longitude associated with the country’s
    area. However, as we shortly discover, a country’s centrality can be estimated
    using city coordinates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的国家数据包括许多有用的元素，例如国家的首都、货币、面积、使用的语言和人口。遗憾的是，GeoNamesCache未能提供与国家面积相关的中央纬度和经度。然而，正如我们很快将发现的，一个国家的中心性可以使用城市坐标来估计。
- en: Additionally, there is valuable information in each country’s `'neighbours'`
    element (the spelling is written in British English). The `'neighbours'` key maps
    to a comma-delimited string of country codes that signify neighboring territories.
    We can obtain more details about each neighbor by splitting the string and passing
    the codes into the `'countries'` dictionary.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个国家的 `'neighbours'` 元素（拼写为英国英语）中也有有价值的信息。`'neighbours'` 键映射到一个逗号分隔的国家代码字符串，表示邻近领土。我们可以通过拆分字符串并将代码传递到
    `'countries'` 字典中，来获取每个邻居的更多详细信息。
- en: Listing 11.25 Fetching neighboring countries
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.25 获取邻近国家
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: According to GeoNamesCache, the immediate neighbors of the United States are
    Canada, Mexico, and Cuba. We can all agree on the first two locations, although
    whether Cuba is a neighbor remains questionable. Cuba does not directly border
    the United States. Also, if the Caribbean island nation is really a neighbor,
    why isn’t Haiti included in that list? More importantly, how did Cuba get included
    in the first place? Well, GeoNames is a collaborative project run by a community
    of editors (like a location-focused Wikipedia). At some point, an editor decided
    that Cuba is a neighbor of the United States. Some might disagree with this decision,
    so it is important to remember that GeoNames is not a gold standard repository
    of location information. Instead, it is a tool for quickly accessing large quantities
    of location data. Some of that data may be imprecise, so please be cautious when
    using GeoNamesCache.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据GeoNamesCache，美国的直接邻国是加拿大、墨西哥和古巴。我们都可以同意前两个位置，尽管古巴是否是邻国还有待商榷。古巴并不直接与美国的边界相邻。此外，如果加勒比海岛国真的是邻国，为什么海地没有被包括在那个列表中？更重要的是，古巴最初是如何被包括在内的？好吧，GeoNames是一个由一群编辑（就像以位置为重点的维基百科）运行的协作项目。在某个时候，一位编辑决定古巴是美国的一个邻国。有些人可能不同意这个决定，因此重要的是要记住GeoNames不是一个位置信息的黄金标准存储库。相反，它是一个快速访问大量位置数据的工具。其中一些数据可能不够精确，因此在使用GeoNamesCache时请谨慎。
- en: The `get_countries` method requires a country’s two-character code. However,
    for most countries, we will not know the code. Fortunately, we can query all countries
    by name using the `get_countries_by_names` method, which returns a dictionary
    whose elements are country names rather than codes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_countries` 方法需要一个国家的两位代码。然而，对于大多数国家，我们可能不知道代码。幸运的是，我们可以使用 `get_countries_by_names`
    方法按名称查询所有国家，该方法返回一个字典，其元素是国家名称而不是代码。'
- en: Listing 11.26 Fetching countries by name
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.26 按名称获取国家
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 11.3.2 Accessing city information
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 访问城市信息
- en: Now, let’s turn our attention to analyzing cities. The `get_cities` method returns
    a dictionary whose keys are unique IDs mapping back to city data. The following
    code outputs that data for a single city.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向分析城市。`get_cities` 方法返回一个字典，其键是唯一ID，映射回城市数据。以下代码输出单个城市的数据。
- en: Listing 11.27 Fetching `cities` from GeoNamesCache
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.27 从GeoNamesCache获取`cities`
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`cities` is a dictionary mapping a unique `city_id` to geographic information.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`cities` 是一个字典，将唯一的 `city_id` 映射到地理信息。'
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Unique city ID
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 唯一城市ID
- en: ❷ City name
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 城市名称
- en: ❸ Latitude
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 纬度
- en: ❹ Longitude
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 经度
- en: ❺ Code of the country where the city is found
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 该城市所在国家的代码
- en: ❻ Population
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 人口
- en: ❼ Time zone
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 时区
- en: The data for each city contains the city name, its latitude and longitude, its
    population, and the reference code for the country where that city is located.
    By utilizing the country code, we can create a new mapping between a country and
    all of its territorial cities. Let’s isolate and count all US cities stored in
    GeoNamesCache.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个城市的数据包含城市名称、其纬度和经度、其人口以及该城市所在国家的参考代码。通过利用国家代码，我们可以创建一个国家与其所有领土城市之间的新映射。让我们隔离并计算存储在GeoNamesCache中的所有美国城市。
- en: Note As we’ve discussed, GeoNames is not perfect. Certain US cities may be missing
    from the database. Over time, these cities will be added. Thus, the observed city
    count may increase with every library update.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正如我们之前讨论的，GeoNames并不完美。数据库中可能缺少某些美国城市。随着时间的推移，这些城市将被添加。因此，观察到的城市数量可能会随着每个库更新而增加。
- en: Listing 11.28 Fetching US cities from GeoNamesCache
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.28 从GeoNamesCache获取美国城市
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: GeoNamesCache contains information about more than 3,000 US cities. Each city’s
    data dictionary contains a latitude and a longitude. Let’s find the average US
    latitude and longitude, which will approximate the central coordinates of the
    United States.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: GeoNamesCache包含关于3000多个美国城市的信息。每个城市的数据字典包含纬度和经度。让我们找到平均美国纬度和经度，这将近似美国的中心坐标。
- en: Note that the approximation is not perfect. The calculated average does not
    take into account the curvature of the Earth and is inappropriately weighted by
    city location. A disproportionate number of US cities are located near the Atlantic
    Ocean, and thus the approximation is skewed toward the East. In the following
    code, we approximate and plot the US center while remaining fully aware that our
    approximation is not ideal (figure 11.15).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种近似并不完美。计算出的平均值没有考虑到地球的曲率，并且城市位置被不适当地加权。美国城市中有不成比例的数量位于大西洋沿岸，因此近似结果偏向于东部。在以下代码中，我们近似并绘制了美国中心，同时完全意识到我们的近似并不理想（图11.15）。
- en: '![](../Images/11-15.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-15.png)'
- en: Figure 11.15 The central location of the United States is approximated by averaging
    the coordinates of every US city in GeoNamesCache. The approximation is slightly
    skewed toward the east.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 通过平均GeoNamesCache中每个美国城市的坐标，近似了美国的中心位置。近似结果略微偏向于东部。
- en: Listing 11.29 Approximating US central coordinates
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.29 近似美国中心坐标
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `get_cities` method is suitable for iterating over city information but
    not querying cities by name. To search by name, we must rely on `get_cities_by_name`.
    This method takes as an input a city name and returns a list of data outputs for
    all cities with that name.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_cities`方法适合遍历城市信息，但不适合按名称查询城市。要按名称搜索，我们必须依赖于`get_cities_by_name`。此方法接受一个城市名称作为输入，并返回具有该名称的所有城市的输出数据列表。'
- en: Listing 11.30 Fetching cities by name
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.30 通过名称获取城市
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `get_cities_by_name` method may return more than one city because city names
    are not always unique. For example, GeoNamesCache contains six different instances
    of the city name San Francisco in five different countries. Calling `gc.get_cities_
    by_name('San Francisco')` returns data for each of these San Francisco instances.
    Let’s iterate over that data and print the country where each San Francisco is
    found.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_cities_by_name`方法可能返回多个城市，因为城市名称并不总是唯一的。例如，GeoNamesCache包含六个不同的城市名称“旧金山”实例，分别位于五个不同的国家。调用`gc.get_cities_by_name(''San
    Francisco'')`将返回这些旧金山实例中的每个实例的数据。让我们遍历这些数据并打印出每个旧金山所在的国家。'
- en: Listing 11.31 Fetching multiple cities with a shared name
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.31 获取具有相同名称的多个城市
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Multiple cities commonly share an identical name, and choosing among such cities
    can be difficult. Suppose, for instance, that someone queries a search engine
    for the "weather in Athens." The search engine must then choose between Athens,
    Ohio and Athens, Greece. Additional context is required to correctly disambiguate
    between the locations. Is the user from Ohio? Are they planning a trip to Greece?
    Without that context, the search engine must guess. Usually, the safest guess
    is the city with the largest population. From a statistical standpoint, the more
    populous cities are more likely to be referenced in everyday conversation. Choosing
    the most-populated city isn’t guaranteed to work all the time, but it’s still
    better than making a completely random choice. Let’s see what happens when we
    plot the most populated San Francisco location (figure 11.16).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 多个城市通常具有相同名称，选择这样的城市可能很困难。例如，假设有人通过搜索引擎查询“雅典的天气”。搜索引擎必须在这两个雅典之间做出选择：俄亥俄州的雅典和希腊的雅典。需要额外的上下文来正确区分这些位置。用户来自俄亥俄州吗？他们是否计划去希腊旅行？没有那个上下文，搜索引擎必须猜测。通常，最安全的猜测是人口最多的城市。从统计学的角度来看，人口较多的城市在日常对话中更有可能被引用。选择人口最多的城市并不保证总是有效，但仍然比完全随机选择要好。让我们看看当我们绘制人口最多的旧金山位置时会发生什么（图11.16）。
- en: '![](../Images/11-16.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-16.png)'
- en: Figure 11.16  Among the six San Franciscos stored in GeoNamesCache, the city
    with the largest population is in California, as expected.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 在 GeoNamesCache 中存储的六个旧金山中，人口最多的城市位于加利福尼亚州，正如预期的那样。
- en: Listing 11.32 Mapping the most populous San Francisco
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.32 将人口最多的旧金山进行映射
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ The ax.text method allows us to write "San Francisco" at the specified longitude
    and latitude. We slightly shift the longitude to the right to avoid overlapping
    the scatter plot dot. Also, on this map, the state borders are not plotted to
    better display the written text.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ ax.text 方法允许我们在指定的经纬度处写入 "San Francisco"。我们稍微将经度向右移动以避免与散点图点重叠。此外，在这张地图上，没有绘制州边界以更好地显示文字。
- en: Selecting the San Francisco with the largest population returns the well-known
    Californian city rather than any of the lesser-known locations outside of the
    United States.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 选择人口最多的旧金山返回的是众所周知的加利福尼亚州城市，而不是美国以外的任何不太知名的地方。
- en: Common GeoNamesCache methods
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 GeoNamesCache 方法
- en: '`gc = GeonamesCache()`—Initializes a `GeonamesCache` object'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc = GeonamesCache()`—初始化一个 `GeonamesCache` 对象'
- en: '`gc.get_continents()`—Returns a dictionary mapping continent IDs to continent
    data'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.get_continents()`—返回一个字典，将大陆 ID 映射到大陆数据'
- en: '`gc.get_countries()`—Returns a dictionary mapping country IDs to country data'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.get_countries()`—返回一个字典，将国家 ID 映射到国家数据'
- en: '`gc.get_countries_by_names()`—Returns a dictionary mapping country names to
    country data'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.get_countries_by_names()`—返回一个字典，将国家名称映射到国家数据'
- en: '`gc.get_cities()`—Returns a dictionary mapping city IDs to city data'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.get_cities()`—返回一个字典，将城市 ID 映射到城市数据'
- en: '`gc.get_cities_by_name(city_name)`—Returns a list of cities that share the
    name `city_name`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.get_cities_by_name(city_name)`—返回与名称 `city_name` 共享的城市列表'
- en: 11.3.3 Limitations of the GeoNamesCache library
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 GeoNamesCache 库的局限性
- en: GeoNamesCache is a useful tool, but it does have some significant flaws. First,
    the library’s record of cities is far from complete. Certain sparsely populated
    locations in rural areas (whether the rural United States or rural China) are
    missing from the stored database records. Furthermore, the `get_cities_by_name`
    method maps only one version of a city’s name to its geographic data. This poses
    a problem for cities like New York that have more than one commonly referenced
    name.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: GeoNamesCache 是一个有用的工具，但它确实有一些显著的缺陷。首先，该库的城市记录远非完整。农村地区（无论是美国的农村地区还是中国的农村地区）的一些人口稀少的地方缺失在存储的数据库记录中。此外，`get_cities_by_name`
    方法仅将一个城市名称的版本映射到其地理数据。这对像纽约这样的有多个常用名称的城市来说是一个问题。
- en: Listing 11.33 Fetching New York City from GeoNamesCache
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.33 从 GeoNamesCache 中获取纽约市
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The single name-to-city mapping is particularly problematic due to the presence
    of diacritics in city names. *Diacritics* are accent marks that designate the
    proper pronunciation of non-English-sounding words. They are commonly found in
    city names: for example, Cañon City, Colorado; and Hagåtña, Guam.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于城市名称中存在重音符号，单名称到城市的映射尤其成问题。*重音符号*是表示非英语发音单词正确发音的符号。它们在地名中很常见：例如，Cañon City，Colorado；以及
    Hagåtña，Guam。
- en: Listing 11.34 Fetching accented cities from GeoNamesCache
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.34 从 GeoNamesCache 中获取带重音符号的城市
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How many of the cities stored in GeoNamesCache contain diacritics in their name?
    We can find out using the `unidecode` function from the external Unidecode library.
    The function strips all accent marks out of input text. By checking for differences
    between the input text and output text, we should be able to detect all city names
    containing accent marks.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: GeoNamesCache 中存储的城市中有多少包含名称中的重音符号？我们可以使用外部 Unidecode 库中的 `unidecode` 函数来找出答案。该函数从输入文本中删除所有重音符号。通过检查输入文本和输出文本之间的差异，我们应该能够检测到所有包含重音符号的城市名称。
- en: Note Call `pip install Unidecode` from the command line terminal to install
    the Unidecode library.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：从命令行终端调用 `pip install Unidecode` 以安装 Unidecode 库。
- en: Listing 11.35 Counting all accented cities in GeoNamesCache
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.35 统计 GeoNamesCache 中所有带重音符号的城市
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Approximately 5,000 stored cities have diacritics in their names. These cities
    are commonly referenced without an accent in published text data. One way to ensure
    that we match all such cities is to create a dictionary of alternative city names;
    in it, the accent-free `unidecode` output maps back to the original accented names.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 大约 5,000 个存储的城市名称中包含重音符号。这些城市在发布的文本数据中通常不带重音符号被引用。确保我们匹配所有此类城市的一种方法是为备选城市名称创建一个字典；在其中，无重音的
    `unidecode` 输出映射回原始的重音名称。
- en: Listing 11.36 Stripping accents from alternative city names
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.36 从备选城市名称中去除重音符号
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can now match the stripped dictionary keys against all inputted text by passing
    the accented dictionary values into GeoNamesCache whenever a key match is found.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到键匹配时，我们可以通过将带重音的字典值传递给 GeoNamesCache 来将清理后的字典键与所有输入文本进行匹配。
- en: Listing 11.37 Finding accent-free city names in text
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.37 在文本中查找不带重音的城市名称
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: GeoNamesCache allows us to easily track locations along with their geographical
    coordinates. Using the library, we can also search for mentioned location names
    within any inputted text. However, finding names in text is not a trivial process.
    If we wish to match location names appropriately, we must learn proper Python
    text-matching techniques while also avoiding common pitfalls.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: GeoNamesCache 允许我们轻松跟踪地理位置及其地理坐标。使用该库，我们还可以在任意输入文本中搜索提到的地点名称。然而，在文本中查找名称并非易事。如果我们希望适当地匹配地点名称，我们必须学习适当的
    Python 文本匹配技术，同时避免常见的陷阱。
- en: Note The final subsection is intended for readers who are unfamiliar with basic
    string matching and regular expressions. If you are already familiar with these
    techniques, feel free to skip ahead.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：最后的子节旨在为不熟悉基本字符串匹配和正则表达式的读者提供。如果您已经熟悉这些技术，请随意跳过。
- en: 11.4 Matching location names in text
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 在文本中匹配地点名称
- en: In Python, we can easily determine whether one string is a substring of another
    or if the start of a string contains some predefined text.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以轻松地确定一个字符串是否是另一个字符串的子串，或者字符串的起始部分是否包含某些预定义的文本。
- en: Listing 11.38 Basic string matching
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.38 基本字符串匹配
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Unfortunately, Python’s basic string syntax is quite limited. For example, there
    is no direct string method for executing a case-insensitive substring comparison.
    Furthermore, Python’s string methods can’t directly distinguish between sub-characters
    in a string and sub-phrases in a sentence. So if we wish to determine whether
    the phrase `'in a'` is present in a sentence, we cannot safely rely on basic matching.
    Otherwise, we run the risk of incorrectly matching character sequences such as
    `'sin apple'` or `'win attached'`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 的基本字符串语法相当有限。例如，没有直接的方法来执行不区分大小写的子字符串比较。此外，Python 的字符串方法不能直接区分字符串中的子字符和句子中的子短语。因此，如果我们想确定短语
    `'in a'` 是否存在于句子中，我们不能安全地依赖于基本匹配。否则，我们可能会错误地匹配字符序列，如 `'sin apple'` 或 `'win attached'`。
- en: Listing 11.39 Basic substring matching errors
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.39 基本子字符串匹配错误
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To overcome these limitations, we must rely on Python’s built-in regular expression
    processing library, `re`. A *regular expression* (or *regex* for short) is a string-encoded
    pattern that can be compared against some text. Coded regex patterns range from
    simple string copies to incredibly complex formulations that very few people can
    decipher. In this subsection, we focus on simple regex composition and matching.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些限制，我们必须依赖 Python 的内置正则表达式处理库 `re`。*正则表达式*（或简称为 *regex*）是一种字符串编码模式，可以与某些文本进行比较。编码的正则表达式模式范围从简单的字符串复制到极其复杂的公式，而很少有人能够解读。在本节中，我们专注于简单的正则表达式组合和匹配。
- en: 'Most regex matching in Python can be executed with the `re.search` function.
    This function takes two inputs: a regex pattern and the text against which the
    pattern will be matched. It returns a `Match` object if a match is found or `None`
    otherwise. The `Match` object contains a `start` method and an `end` method; these
    methods return the start index and end index of the matched string in the text.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的大多数正则表达式匹配都可以使用 `re.search` 函数执行。该函数接受两个输入：一个正则表达式模式和将要对该模式进行匹配的文本。如果找到匹配项，则返回一个
    `Match` 对象，否则返回 `None`。`Match` 对象包含一个 `start` 方法和一个 `end` 方法；这些方法返回匹配字符串在文本中的起始索引和结束索引。
- en: Listing 11.40 String matching using regexes
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.40 使用正则表达式进行字符串匹配
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Additionally, case-insensitive string matching is a breeze with `re.search`.
    We simply pass `re.IGNORECASE` as an added `flags` parameter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 `re.search` 进行不区分大小写的字符串匹配非常简单。我们只需将 `re.IGNORECASE` 作为额外的 `flags` 参数传递。
- en: Listing 11.41 Case-insensitive matching using regexes
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.41 使用正则表达式进行不区分大小写的匹配
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ We can achieve the same result by passing flags=re.I into re.search.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以通过将 flags=re.I 传递给 re.search 来达到相同的结果。
- en: Regexes also allow us to match exact words using word boundary detection. Adding
    the `\b` pattern to a regex string captures the start and end points of words
    (as defined by whitespaces and punctuation). However, because the backslash is
    a special character in the standard Python lexicon, we must take measures to ensure
    that the backslash is interpreted like a regular raw character. We do this by
    either adding another backslash to the backslash (a rather cumbersome approach)
    or preceding the string with an `r` literal. The latter solution ensures that
    the regex is treated as a raw string during analysis.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式还允许我们使用单词边界检测来匹配精确的单词。将 `\b` 模式添加到正则表达式字符串中可以捕获单词的开始和结束点（由空白和标点符号定义）。然而，由于反斜杠在标准的
    Python 词汇中是一个特殊字符，我们必须采取措施确保反斜杠被解释为一个普通的原始字符。我们可以通过在反斜杠前添加另一个反斜杠（一种相当繁琐的方法）或者使用
    `r` 文字前缀来做到这一点。后者确保正则表达式在分析期间被当作原始字符串处理。
- en: Listing 11.42 Word boundary matching using regexes
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.42 使用正则表达式进行单词边界匹配
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let’s carry out a more complicated match. We match against the sentence
    `f''I visited {city} yesterday`, where `{city}` represents one of three possible
    locations: Boston, Philadelphia, or San Francisco. The correct regex syntax for
    executing the match is `r''I visited \b(Boston|Philadelphia|San Francisco)\b yesterday''`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一个更复杂的匹配。我们匹配的句子是 `f'I visited {city} yesterday'`，其中 `{city}` 代表三个可能的位置之一：波士顿、费城或旧金山。执行匹配的正确正则表达式语法是
    `r'I visited \b(Boston|Philadelphia|San Francisco)\b yesterday'`。
- en: Note The pipe `|` is an *Or* condition. It requires the regex to match from
    one of the three cities in our list. Furthermore, the parentheses limit the scope
    of the matched cities. Without them, the matched text range would stretch beyond
    `'San Francisco'`, all the way to `'San Francisco yesterday'`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：管道 `|` 是一个 *或* 条件。它要求正则表达式匹配列表中的三个城市之一。此外，括号限制了匹配城市的范围。如果没有它们，匹配的文本范围将延伸到
    `'San Francisco'`，一直延伸到 `'San Francisco yesterday'`。
- en: Listing 11.43 Multicity matching using regexes
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.43 使用正则表达式进行多城市匹配
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, let’s discuss how to run a regex search efficiently. Suppose we want
    to match a regex against 100 strings. For every match, `re.search` transforms
    the regex into a Python `PatternObject.` Each such transformation is computationally
    costly. We’re better off executing the transformation only once using `re.compile`,
    which returns a compiled `PatternObject`. Then we can use the object’s built-in
    `search` method while avoiding any additional compilation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论如何高效地运行正则表达式搜索。假设我们想要将正则表达式与 100 个字符串进行匹配。对于每个匹配项，`re.search` 将正则表达式转换为
    Python 的 `PatternObject`。每次这样的转换都是计算成本高昂的。我们最好只使用 `re.compile` 执行一次转换，它返回一个编译后的
    `PatternObject`。然后我们可以使用该对象的内置 `search` 方法，同时避免任何额外的编译。
- en: Note If we intend to use the compiled pattern for case-independent matching,
    we must pass `flags=re.IGNORECASE` into `re.compile`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果我们打算使用编译后的模式进行不区分大小写的匹配，我们必须将 `flags=re.IGNORECASE` 传递给 `re.compile`。
- en: Listing 11.44 String matching using compiled regexes
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.44 使用编译后的正则表达式进行字符串匹配
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Common regex matching techniques
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 常见正则表达式匹配技术
- en: '`match = re.search(regex, text)`—Returns a `Match` object if `regex` is present
    in `text` or `None` otherwise.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match = re.search(regex, text)`—如果 `regex` 在 `text` 中存在，则返回一个 `Match` 对象，否则返回
    `None`。'
- en: '`match = re.search(regex, text, flags=re.IGNORECASE)`—Returns a `Match` object
    if `regex` is present in `text` or `None` otherwise. Matching is carried out independent
    of case.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match = re.search(regex, text, flags=re.IGNORECASE)`—如果 `regex` 在 `text` 中存在，则返回一个
    `Match` 对象，否则返回 `None`。匹配操作不区分大小写。'
- en: '`match.start()`—Returns the start index of a regex matched to an input text.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match.start()`—返回与输入文本匹配的正则表达式的开始索引。'
- en: '`match.end()`—Returns an end index of a regex matched to an input text.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match.end()`—返回与输入文本匹配的正则表达式的结束索引。'
- en: '`compiled_regex = re.compile(regex)`—Transforms the `regex` string into a compiled
    pattern-matching object.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compiled_regex = re.compile(regex)`—将 `regex` 字符串转换为编译后的模式匹配对象。'
- en: '`match = compiled_regex.search(text)`— Uses the compiled object’s built-in
    `search` method to match a regex against `text`.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match = compiled_regex.search(text)`—使用编译对象的内置 `search` 方法将正则表达式与 `text` 进行匹配。'
- en: '`re.compile(''Boston'')`—Compiles a regex to match the string `''Boston''`
    against the text.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.compile(''Boston'')`—编译一个正则表达式以匹配文本中的字符串 `''Boston''`。'
- en: '`re.compile(''Boston'', flags=re.IGNORECASE)`—Compiles a regex to match the
    string `''Boston''` against the text. The matching is independent of text case.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.compile(''Boston'', flags=re.IGNORECASE)`—编译一个正则表达式以匹配文本中的字符串 `''Boston''`。匹配不区分文本大小写。'
- en: '`re.compile(''\\bBoston\\b'')`—Compiles a regex to match the word `''Boston''`
    against the text. Word boundaries are used to execute an exact word match.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.compile(''\\bBoston\\b'')`—编译一个正则表达式以匹配文本中的单词`''Boston''`。使用单词边界来执行精确的单词匹配。'
- en: '`re.compile(r''\bBoston\b'')`—Compiles a regex to match the word `''Boston''`
    against the text. The inputted regex is treated as a raw string because of the
    `r` literal. Thus, we don’t need to add additional backslashes to our `\b` word
    boundary delimiters.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.compile(r''\bBoston\b'')`—编译一个正则表达式以匹配文本中的单词`''Boston''`。由于`r`字面量，输入的正则表达式被视为原始字符串。因此，我们不需要在我们的`\b`单词边界界定符中添加额外的反斜杠。'
- en: '`re.compile(r''\b(Boston|Chicago)\b'')`—Compiles a regex to match either the
    word `''Boston''` or the word `''Chicago''` to the text.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.compile(r''\b(Boston|Chicago)\b'')`—编译一个正则表达式以匹配文本中的单词`''Boston''`或`''Chicago''`。'
- en: Regex matching allows us to find location names in text. Thus, the `re` module
    will prove invaluable for solving case study 3\.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式匹配使我们能够在文本中找到地点名称。因此，`re`模块对于解决案例研究3将非常有价值。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The shortest travel distance between terrestrial points is along our planet’s
    spherical surface. This *great-circle distance* can be computed using a series
    of well-known trigonometric operations.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地球上两点之间的最短旅行距离是沿着我们的球面。这个*大圆距离*可以通过一系列已知的三角运算来计算。
- en: The latitude and longitude are *spherical coordinates*. These coordinates measure
    the angular position of a point on the surface of the Earth relative to the x-axis
    and y-axis.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纬度和经度是*球面坐标*。这些坐标测量地球表面上一点相对于x轴和y轴的角位置。
- en: We can plot a latitude and longitude on a map using the Cartopy library. The
    library can visualize mapped data using multiple projection types. Our choice
    of projection is dependent on the plotted data. If the data spans the globe, we
    can use the standard *plate carrée*. If the data is confined to North America,
    we might consider using the *orthographic projection*. If the data points are
    located in the continental United States, we should use the *Lambert conformal
    conic projection*.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Cartopy库在地图上绘制纬度和经度。该库可以使用多种投影类型可视化映射数据。我们的投影选择取决于绘制的数据。如果数据跨越全球，我们可以使用标准的*等角圆柱投影*。如果数据局限于北美洲，我们可能考虑使用*正射投影*。如果数据点位于美国大陆，我们应该使用*兰伯特圆锥投影*。
- en: We can obtain latitudes and longitudes from location names using the GeoNamesCache
    library. GeoNamesCache maps city names to latitudes and longitudes. It also maps
    country names to cities. Thus, given a country name, we can approximate its central
    coordinates by averaging the latitudes and longitudes of its cities. However,
    that approximation will not be perfect due to city bias and the curved shape of
    the Earth.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用GeoNamesCache库从地点名称中获取经纬度。GeoNamesCache将城市名称映射到经纬度。它还将国家名称映射到城市。因此，给定一个国家名称，我们可以通过平均其城市的经纬度来近似其中心坐标。然而，由于城市偏差和地球的弯曲形状，这种近似将不会完美。
- en: Multiple cities commonly share an identical name. Thus, GeoNamesCache can map
    multiple coordinates to a single city name. Given only a city name without any
    other context, it is advisable to return the coordinates of the most populous
    city with that name.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个城市通常共享相同的名称。因此，GeoNamesCache可以将多个坐标映射到单个城市名称。如果只有一个城市名称而没有其他上下文，建议返回该名称人口最多的城市的坐标。
- en: GeoNamesCache maps coordinates to accented versions of each city name. We can
    strip out these accents using the `unidecode` function from the external `Unidecode`
    library.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeoNamesCache将坐标映射到每个城市名称的重音版本。我们可以使用外部`Unidecode`库中的`unidecode`函数去除这些重音。
- en: '*Regular expressions* can find location names in text. By combining GeoNamesCache
    with Cartopy and regular expressions, we can plot locations mentioned in text.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式*可以在文本中找到地点名称。通过结合GeoNamesCache、Cartopy和正则表达式，我们可以绘制文本中提到的地点。'
