- en: Chapter 9\. Service virtualization
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. 服务虚拟化
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Appreciating service virtualization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏服务虚拟化
- en: Simulating internal and external services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟内部和外部服务
- en: Understanding service virtualization and Java
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务虚拟化和Java
- en: In a microservices architecture, the application as a whole can be composed
    of many interconnected services. These services can be either internal services,
    as in members of the same application domain, or external, third-party services
    that are totally out of your control.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，整个应用程序可以由许多相互连接的服务组成。这些服务可以是内部服务，例如同一应用域的成员，也可以是完全不受你控制的外部、第三方服务。
- en: As you’ve seen throughout the book, this approach implies that some changes
    are required when continuous application testing is part of your delivery pipeline.
    Back in [chapter 7](kindle_split_016_split_000.xhtml#ch07), we observed that one
    of the biggest challenges faced when testing a microservices architecture is having
    a clean test environment readily available. Getting multiple services up, running,
    and prepared is no trivial task. It takes time to prepare and execute tests, and
    it’s highly likely that you’ll end up with several flaky tests—tests that fail
    not due to code issues, but because of a failures within the testing environment.
    One of the techniques you can adopt to fix this is service virtualization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在整本书中看到的，这种方法意味着当持续应用程序测试成为你的交付管道的一部分时，需要做出一些改变。在[第7章](kindle_split_016_split_000.xhtml#ch07)中，我们观察到在测试微服务架构时面临的最大挑战之一是拥有一个干净且随时可用的测试环境。启动、运行并准备多个服务不是一件简单的事情。准备和执行测试需要时间，而且你很可能会有几个不可靠的测试——这些测试失败不是因为代码问题，而是因为测试环境中的失败。你可以采用的一种技术是服务虚拟化。
- en: 9.1\. What is service virtualization?
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 什么是服务虚拟化？
- en: '*Service virtualization* is a technique used to emulate the behavior of dependencies
    of component-based applications. Generally speaking, in a microservices architecture,
    these dependencies are usually REST API–based services, but the concept can also
    be applied to other kinds of dependencies such as databases, enterprise service
    buses (ESBs), web services, Java Message Service (JMS), or any other system that
    communicates using messaging protocols.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务虚拟化*是一种用于模拟基于组件的应用程序依赖项行为的技巧。一般来说，在微服务架构中，这些依赖项通常是基于REST API的服务，但这个概念也可以应用于其他类型的依赖项，如数据库、企业服务总线（ESBs）、Web服务、Java消息服务（JMS）或任何使用消息协议进行通信的系统。'
- en: 9.1.1\. Why use service virtualization?
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 为什么使用服务虚拟化？
- en: 'Following are several situations in which you might want to use service virtualization:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可能想要使用服务虚拟化的场景：
- en: When the current service (consumer) depends on another service (provider) that
    hasn’t been developed yet or is still in development.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前服务（消费者）依赖于另一个尚未开发或仍在开发中的服务（提供者）时。
- en: When provisioning a new instance of the required service (provider) is difficult
    or too slow for testing purposes.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当为新实例配置所需的服务（提供者）困难或太慢，不适合测试目的时。
- en: When configuring the service (provider) isn’t a trivial task. For example, you
    might need to prepare a huge number of database scripts for running the tests.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当配置服务（提供者）不是一个简单任务时。例如，你可能需要准备大量的数据库脚本以运行测试。
- en: When services need to be accessed in parallel by different teams that have completely
    different setups.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不同团队需要并行访问服务，而这些团队有完全不同的设置时。
- en: When the provider service is controlled by a third party or partner, and you
    have a rate-limited quota on daily requests. You don’t want to consume the quota
    with tests!
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提供者服务由第三方或合作伙伴控制，并且你每天有请求配额限制时。你不想用测试消耗配额！
- en: When the provider service is available only intermittently or at certain times
    of the day or night.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提供者服务仅在特定时间或夜间某些时间可用时。
- en: Service virtualization can resolve all these challenges by simulating the behavior
    of the required service. With service virtualization, you model and deploy a *virtual
    asset* that represents the provider service, simulating the parts required for
    your test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 服务虚拟化可以通过模拟所需服务的行怍来解决所有这些挑战。通过服务虚拟化，你可以建模和部署一个代表提供者服务的*虚拟资产*，模拟测试所需的各个部分。
- en: '[Figure 9.1](kindle_split_018_split_001.xhtml#ch09fig01) shows the difference
    between provisioning a real environment and a virtualized one for running tests.
    On the left, you can see that writing a test for service A requires that you boot
    up service B, including its database. At the same time, you might also need to
    start *transitive* services such as services C and D. On the right side, you can
    see that service B and all of its dependencies are replaced by a virtualized version
    that emulates the behavior of service B.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](kindle_split_018_split_001.xhtml#ch09fig01)展示了为运行测试而配置真实环境与虚拟化环境之间的差异。在左侧，你可以看到编写服务A的测试需要启动服务B，包括其数据库。同时，你可能还需要启动*传递*服务，如服务C和D。在右侧，你可以看到服务B及其所有依赖项都被一个模拟版本所取代，该版本模拟了服务B的行为。'
- en: Figure 9.1\. Real versus virtualized services
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 真实服务与虚拟化服务
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: It’s important to note that this diagram isn’t much different than the one you
    saw when you learned about mocking and stubbing in [chapter 3](kindle_split_012_split_000.xhtml#ch03);
    but rather than simulating classes, you’re simulating service calls. Streamlining
    that thought, you can imagine service virtualization as mocking at the enterprise
    level.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个图表与你在[第3章](kindle_split_012_split_000.xhtml#ch03)学习模拟和存根时看到的图表并没有太大的不同；但与模拟类不同，你是在模拟服务调用。简化这个想法，你可以将服务虚拟化想象为在企业层面的模拟。
- en: Service virtualization shouldn’t be used only for testing optimal path cases,
    but also for testing edge cases, so that you test the entire application (negative
    testing). Sometimes it’s difficult to test edge cases against real services. For
    example, you might want to test how a client behaves with low-latency responses
    from the provider, or how it acts when characters are sent with a different character
    encoding than expected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 服务虚拟化不仅应该用于测试最佳路径情况，还应该用于测试边缘情况，以便测试整个应用程序（负面测试）。有时很难对真实服务进行边缘测试。例如，你可能想测试客户端在从提供者那里获得低延迟响应时的行为，或者当发送与预期不同的字符编码时它的行为。
- en: Think back to the Gamer application—you can’t ask igdb.com and youtube.com to
    shut down their APIs for an afternoon while you perform negative testing. (Well,
    you could, but don’t hold your breath waiting for an answer!) In such cases, it
    should be apparent why service virtualization is so useful.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想想Gamer应用程序——你不能要求igdb.com和youtube.com在下午关闭他们的API，以便你进行负面测试。（好吧，你可以，但别抱太大希望得到答复！）在这种情况下，服务虚拟化的有用性应该很明显。
- en: 9.1.2\. When to use service virtualization
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 何时使用服务虚拟化
- en: The book has presented many different kinds of tests, from unit tests to end-to-end
    tests. When is service virtualization useful?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本书介绍了许多不同类型的测试，从单元测试到端到端测试。何时使用服务虚拟化是有用的？
- en: '*Unit tests*—You’re unlikely to need service virtualization for unit tests.
    In 99% of cases, using traditional mock, dummy, and stub techniques will be enough.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*—对于单元测试，你不太可能需要服务虚拟化。在99%的情况下，使用传统的模拟、虚拟和存根技术就足够了。'
- en: '*Component tests*—This is where service virtualization shines: you can test
    how components interact with each other without relying on external services.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件测试*—这是服务虚拟化大放异彩的地方：你可以测试组件之间如何相互交互，而不依赖于外部服务。'
- en: '*Integration tests*—By their nature, integration tests are run against real
    services. In test cases, this might be a problem (such as edge cases, third-party
    services, and so on), so you might opt for service virtualization.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成测试*—由于集成测试的本质是针对真实服务运行的，在测试用例中可能会遇到问题（例如边缘情况、第三方服务等），因此你可能选择使用服务虚拟化。'
- en: '*Contract tests*—When testing a contract against a provider, you might need
    service virtualization to simulate dependencies of the provider service.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*契约测试*—当测试提供者的契约时，你可能需要服务虚拟化来模拟提供者服务的依赖项。'
- en: '*End-to-end tests*—By definition, end-to-end tests shouldn’t rely on service
    virtualization, because you’re testing against the real system. In some rare cases
    where you relay on flaky third-party services, service virtualization might still
    be a viable solution.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*端到端测试*—根据定义，端到端测试不应该依赖于服务虚拟化，因为你是针对真实系统进行测试的。在某些罕见的情况下，如果你依赖于不可靠的第三方服务，服务虚拟化可能仍然是一个可行的解决方案。'
- en: As you can see, virtual assets are replaced by progressively more real services
    as you move to more functional tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，随着你转向更功能性的测试，虚拟资产逐渐被更多真实的服务所取代。
- en: In [chapter 4](kindle_split_013_split_000.xhtml#ch04), we discussed the concept
    of simulating external services with WireMock. In this chapter, we’ll introduce
    a new tool called *Hoverfly*, which is designed specifically for service virtualization.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_013_split_000.xhtml#ch04)中，我们讨论了使用WireMock模拟外部服务的概念。在本章中，我们将介绍一个名为*Hoverfly*的新工具，它专门用于服务虚拟化。
- en: 9.2\. Mimicking service responses with Hoverfly
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 使用Hoverfly模拟服务响应
- en: Hoverfly ([https://hoverfly.readthedocs.io](https://hoverfly.readthedocs.io))
    is an open source, lightweight, service-virtualization proxy written in the Go
    programming language. It allows you to emulate HTTP and HTTPS services. As you
    can see in [figure 9.2](kindle_split_018_split_002.xhtml#ch09fig02), Hoverfly
    starts a proxy that responds to requests with stored (canned) responses. These
    responses should be exactly the same as the ones the real service would generate
    for the provided requests. If this process is performed correctly, and if the
    stored responses are accurate for the real service, Hoverfly will mimic the real
    service responses perfectly, and your tests will be accurate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停蝇 ([https://hoverfly.readthedocs.io](https://hoverfly.readthedocs.io)) 是一个用Go编程语言编写的开源、轻量级的服务虚拟化代理。它允许您模拟HTTP和HTTPS服务。如图9.2所示，悬停蝇启动了一个代理，该代理对请求返回存储（罐头）响应。这些响应应与真实服务为提供的请求生成的响应完全相同。如果这个过程执行正确，并且存储的响应对真实服务准确无误，悬停蝇将完美地模仿真实服务的响应，并且您的测试将准确无误。
- en: Figure 9.2\. Hoverfly proxy
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. Hoverfly代理
- en: '![](Images/09fig02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig02.jpg)'
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '*Hoverfly Java* ([https://hoverfly-java.readthedocs.io](https://hoverfly-java.readthedocs.io))
    is a Java wrapper for Hoverfly that abstracts you away from the actual binary
    and API calls, and also provides tight integration with JUnit. From this point
    on, when we talk about Hoverfly, we mean the Java wrapper.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hoverfly Java* ([https://hoverfly-java.readthedocs.io](https://hoverfly-java.readthedocs.io))
    是Hoverfly的Java包装器，它抽象了您对实际二进制和API调用的操作，并提供了与JUnit的紧密集成。从现在起，当我们谈论Hoverfly时，我们指的是Java包装器。'
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.2.1\. Hoverfly modes
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. Hoverfly模式
- en: 'Hoverfly has three working modes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Hoverfly有三种工作模式：
- en: '*Capture*—Makes requests against real services as normal. Requests and responses
    are intercepted and recorded by the Hoverfly proxy so they can be used later.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*捕获*—以正常方式对真实服务进行请求。请求和响应被Hoverfly代理拦截并记录，以便以后使用。'
- en: '*Simulate*—Returns simulated responses for the provided requests. Simulations
    might be loaded from different kinds of sources such as files, classpath resources,
    or URLs, or programmatically defined using the Hoverfly domain-specific language
    (DSL). This is the preferred mode for services under development.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟*—为提供的请求返回模拟响应。模拟可以从不同的来源加载，例如文件、类路径资源或URL，或者使用Hoverfly领域特定语言（DSL）编程定义。这是开发中的服务的首选模式。'
- en: '*Capture or simulate*—A combination of the other two modes. The proxy starts
    in capture mode if the simulation file doesn’t exist, or in simulate mode otherwise.
    This mode is preferred when already developed services or third-party services
    are available.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*捕获或模拟*—其他两种模式的组合。如果模拟文件不存在，代理以捕获模式启动，否则以模拟模式启动。当已经开发的服务或第三方服务可用时，此模式更受欢迎。'
- en: '[Figure 9.3](kindle_split_018_split_002.xhtml#ch09fig03) shows a schema for
    capture mode:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.3](kindle_split_018_split_002.xhtml#ch09fig03) 展示了捕获模式的方案：'
- en: '**1**.  A request is performed using a real service, which is probably deployed
    outside of the machine where the test is running.'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  使用真实服务执行请求，该服务可能部署在运行测试的机器之外。'
- en: '**2**.  The Hoverfly proxy redirects traffic to the real host, and the response
    is returned.'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  Hoverfly代理将流量重定向到真实主机，并返回响应。'
- en: '**3**.  The Hoverfly proxy stores a script file for the matching request and
    response that were generated by the real service interaction.'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  Hoverfly代理存储由真实服务交互生成的匹配请求和响应的脚本文件。'
- en: '**4**.  The real response is returned to the caller.'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  将真实响应返回给调用者。'
- en: Figure 9.3\. Hoverfly capture mode
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 悬停蝇捕获模式
- en: '![](Images/09fig03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig03.jpg)'
- en: '[Figure 9.4](kindle_split_018_split_002.xhtml#ch09fig04) illustrates simulate
    mode:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.4](kindle_split_018_split_002.xhtml#ch09fig04) 阐述了模拟模式：'
- en: '**1**.  A request is performed, but instead the call being routed to the real
    service, it’s routed to the Hoverfly proxy.'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  执行了一个请求，但调用不是路由到真实服务，而是路由到Hoverfly代理。'
- en: '**2**.  The Hoverfly proxy checks the corresponding response script for the
    provided request.'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  Hoverfly 代理检查提供的请求对应的响应脚本。'
- en: '**3**.  A canned response is replayed back to the caller.'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  将预定义的响应回放给调用者。'
- en: Figure 9.4\. Hoverfly simulate mode
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 悬停飞虫模拟模式
- en: '![](Images/09fig04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04.jpg)'
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Hoverfly and JVM proxy settings**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hoverfly 和 JVM 代理设置**'
- en: Hoverfly Java sets the network Java system properties to use the Hoverfly proxy.
    This means if the client API you’re using to communicate with other services honors
    these properties, you don’t need to change anything to work with Hoverfly. If
    that isn’t the case, you need to set `http.proxyHost`, `http.proxyPort`, `https.proxyHost`,
    `https.proxyPort`, and, optionally, `http.nonProxyHosts` to your client proxy
    configuration.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Hoverfly Java 设置网络 Java 系统属性以使用 Hoverfly 代理。这意味着如果您使用的客户端 API 识别这些属性，则无需更改任何内容即可与
    Hoverfly 一起工作。如果不是这种情况，您需要将 `http.proxyHost`、`http.proxyPort`、`https.proxyHost`、`https.proxyPort`
    以及可选的 `http.nonProxyHosts` 设置到您的客户端代理配置中。
- en: 'When this override is in place, all communication between the Java runtime
    and the physical network (except `localhost` by default) will pass through the
    Hoverfly proxy. For example, when using the `okhttp` client, which honors network
    system properties, you might do this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当此覆盖生效时，Java 运行时与物理网络之间的所有通信（默认情况下除 `localhost` 外）将通过 Hoverfly 代理进行。例如，当使用尊重网络系统属性的
    `okhttp` 客户端时，您可能这样做：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because the proxy settings are now overridden, the request is performed through
    the Hoverfly proxy. Depending on the selected configuration mode, the request
    will either be sent to www.myexample.com or simulated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代理设置已被覆盖，请求是通过 Hoverfly 代理执行的。根据所选的配置模式，请求将发送到 www.myexample.com 或进行模拟。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.2.2\. JUnit Hoverfly
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. JUnit Hoverfly
- en: Let’s look at some examples of how to use Hoverfly with JUnit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Hoverfly 与 JUnit 的一些示例。
- en: JUnit Hoverfly simulate mode
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JUnit Hoverfly 模拟模式
- en: 'Hoverfly comes in the form of a JUnit rule. You can use either `@ClassRule`
    for static initialization, or `@Rule` for each test. We recommend using `@ClassRule`,
    to avoid the overhead of starting the Hoverfly proxy for each test method execution.
    Here’s an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Hoverfly 以 JUnit 规则的形式提供。您可以使用 `@ClassRule` 进行静态初始化，或 `@Rule` 对每个测试进行初始化。我们建议使用
    `@ClassRule`，以避免每次测试方法执行时启动 Hoverfly 代理的开销。以下是一个示例：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Reads simulation.json from the default Hoverfly resource path**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从默认的 Hoverfly 资源路径读取 simulation.json***'
- en: Here, the Hoverfly proxy is started, and it then loads the simulation.json simulation
    file from the default Hoverfly resource path, src/test/resources/hoverfly. After
    that, all tests are executed, and the Hoverfly proxy is stopped.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Hoverfly 代理启动，然后从默认的 Hoverfly 资源路径，src/test/resources/hoverfly，加载 simulation.json
    模拟文件。之后，所有测试都执行完毕，Hoverfly 代理停止。
- en: 'In addition to loading simulations from a file, you can specify request matchers
    and responses using the DSL, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从文件加载模拟之外，您还可以使用 DSL 指定请求匹配器和响应，如下所示：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Starts Hoverfly using the DSL method**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 DSL 方法启动 Hoverfly***'
- en: '***2* Sets the host where the connection is to be made**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置连接要建立的宿主***'
- en: '***3* Creates a request and a response for a POST method**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为 POST 方法创建请求和响应***'
- en: '***4* Creates a request and a response for a GET method**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为 GET 方法创建请求和响应***'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Request-field matchers**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求字段匹配器**'
- en: 'Hoverfly has the concept of *request-field matchers*, which let you use different
    kinds of matchers in the DSL elements. Here’s an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Hoverfly 有 *请求字段匹配器* 的概念，它允许您在 DSL 元素中使用不同类型的匹配器。以下是一个示例：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Matches the URL using a wildcard**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用通配符匹配 URL***'
- en: '***2* Matches the request path that starts with /api/games/**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 匹配以 /api/games/** 开头的请求路径***'
- en: '***3* Matches the page query parameter with any value**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 匹配页面查询参数的任何值***'
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: JUnit Hoverfly capture mode
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JUnit Hoverfly 捕获模式
- en: 'Starting Hoverfly in capture mode is the same as it is in simulate mode, but
    you use `inCaptureMode` to indicate that you want to store the interaction:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获模式下启动 Hoverfly 与在模拟模式下相同，但您使用 `inCaptureMode` 来指示您想要存储交互：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Starts Hoverfly in capture mode, and records the result**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在捕获模式下启动 Hoverfly 并记录结果***'
- en: In this example, Hoverfly is started in capture mode. This effectively means
    the traffic is redirected/routed to the real service, but now these interactions
    are recorded in a file located by default at src/test/resources/hoverfly/simulation.json.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，Hoverfly 以捕获模式启动。这意味着流量被重定向/路由到真实服务，但现在这些交互被记录在默认位于 src/test/resources/hoverfly/simulation.json
    的文件中。
- en: JUnit Hoverfly capture or simulate mode
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JUnit Hoverfly 捕获或模拟模式
- en: 'This mode is the combination of both previous modes, using capture mode if
    no previously recorded file is present. The generated files can then be added
    to your version control to complete the test case for others to use without the
    real service. Here’s an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式是前两种模式的组合，如果没有先前记录的文件，则使用捕获模式。生成的文件可以添加到您的版本控制中，以完成测试用例，供其他人使用而无需真实服务。以下是一个示例：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 9.2.3\. Configuring Hoverfly
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3. 配置 Hoverfly
- en: Hoverfly ships with defaults that may work in all cases, but you can override
    them by providing an `io.specto.hoverfly.junit.core.HoverflyConfig` instance to
    the previous methods. For example, you can change the proxy port where the Hoverfly
    proxy is started by setting `inCaptureMode("simulation.json", HoverflyConfig.configs().proxyPort(8080))`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Hoverfly 默认提供了一些可能适用于所有情况的配置，但您可以通过向先前方法提供一个 `io.specto.hoverfly.junit.core.HoverflyConfig`
    实例来覆盖它们。例如，您可以通过设置 `inCaptureMode("simulation.json", HoverflyConfig.configs().proxyPort(8080))`
    来更改 Hoverfly 代理启动的代理端口。
- en: By default, all hostnames are proxied, but you can also restrict this behavior
    to specific hostnames. For example, `configs().destination("www.myexample.com")`
    configures the Hoverfly proxy to only process requests to www.myexample.com.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有主机名都会被代理，但您也可以将此行为限制为特定的主机名。例如，`configs().destination("www.myexample.com")`
    配置 Hoverfly 代理仅处理对 www.myexample.com 的请求。
- en: Localhost calls are *not* proxied by default. But if your provider service is
    running on localhost, you can configure Hoverfly to proxy localhost calls by using
    `configs().proxyLocalHost()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，本地主机调用不会被代理。但如果您的提供者服务运行在本地主机上，您可以通过使用 `configs().proxyLocalHost()` 配置
    Hoverfly 来代理本地主机调用。
- en: Configuring SSL
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置 SSL
- en: If your service uses Secure Sockets Layer (SSL), Hoverfly needs to decrypt the
    messages in order to persist them to a file in capture mode, or to perform the
    matching in simulate mode. Effectively, you have one SSL connection between the
    client and the Hoverfly proxy, and another between the Hoverfly proxy and the
    real service.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的服务使用安全套接字层 (SSL)，Hoverfly 需要解密消息以便在捕获模式下将它们持久化到文件，或在模拟模式下执行匹配。实际上，您在客户端和
    Hoverfly 代理之间有一个 SSL 连接，在 Hoverfly 代理和真实服务之间还有一个 SSL 连接。
- en: To make things simple, Hoverfly comes with its own self-signed certificate that
    must be trusted by your client. The good news is that Hoverfly’s certificate is
    trusted automatically when you instantiate it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，Hoverfly 附带了自己的自签名证书，客户端必须信任它。好消息是，当您实例化 Hoverfly 时，其证书会自动信任。
- en: 'You can override this behavior and provide your own certificate and key using
    the `HoverflyConfig` class: for example, `configs().sslCertificatePath("ssl/ca.crt").sslKeyPath("ssl/ca.key")`.
    Note that these files are relative to the classpath.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `HoverflyConfig` 类覆盖此行为并提供自己的证书和密钥：例如，`configs().sslCertificatePath("ssl/ca.crt").sslKeyPath("ssl/ca.key")`。请注意，这些文件相对于类路径。
- en: Configuring an external instance
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置外部实例
- en: 'It’s possible to configure Hoverfly to use an existing Hoverfly proxy instance.
    This situation might arise when you’re using a Docker image hosting a Hoverfly
    proxy. Again, you can configure these parameters easily by using the `HoverflyConfig`
    class: for example, `configs().remote().host("192.168.99.100").proxyPort(8081)`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置 Hoverfly 使用现有的 Hoverfly 代理实例。这种情况可能发生在您使用托管 Hoverfly 代理的 Docker 镜像时。同样，您可以通过使用
    `HoverflyConfig` 类轻松配置这些参数：例如，`configs().remote().host("192.168.99.100").proxyPort(8081)`。
- en: 9.3\. Build-script modifications
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 构建脚本修改
- en: 'Now that you’ve learned about service virtualization and Hoverfly, let’s look
    at the involved dependencies. Hoverfly requires only a single group, artifact,
    version (GAV) dependency definition:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了服务虚拟化和 Hoverfly，让我们看看涉及的依赖项。Hoverfly 只需要一个组、工件、版本（GAV）依赖项定义：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This pulls in all the required transient dependencies to the test scope.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将所有必需的临时依赖项拉入测试范围。
- en: 9.4\. Using service virtualization for the Gamer application
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 使用服务虚拟化处理 Gamer 应用程序
- en: As you’ve seen throughout the book, in the Gamer application, the aggregator
    service communicates with three services to compose the final request to the end
    user with all information about games, as shown in [figure 9.5](kindle_split_018_split_004.xhtml#ch09fig05).
    Let’s write a component test for the code that connects to the comments service.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在整本书中看到的，在Gamer应用程序中，聚合器服务与三个服务进行通信，以向最终用户组成包含所有游戏信息的最终请求，如图9.5所示。[figure
    9.5](kindle_split_018_split_004.xhtml#ch09fig05)。让我们为连接到评论服务的代码编写一个组件测试。
- en: Figure 9.5\. The aggregator service
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. 聚合器服务
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig05_alt.jpg)'
- en: In the following listing (code/aggregator/cp-tests/src/test/java/book/aggr/CommentsGatewayTest.java),
    the comments service is deployed in (pre)production at comments.gamers.com, and
    you’ll use capture or simulate mode so that initial requests are sent to the real
    service. All subsequent calls will be simulated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表（code/aggregator/cp-tests/src/test/java/book/aggr/CommentsGatewayTest.java）中，评论服务在（预）生产环境中部署在comments.gamers.com，你将使用捕获或模拟模式，以便初始请求发送到真实服务。所有后续调用都将进行模拟。
- en: Listing 9.1\. Testing the `CommentsGateway` class
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. 测试`CommentsGateway`类
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Instantiates the Hoverfly rule**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化Hoverfly规则**'
- en: '***2* Makes the call to the real host**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用真实主机**'
- en: '***3* Asserts that the location is valid**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 断言位置有效**'
- en: The big difference between this and the other test cases is that the first time
    you run this test, the request is sent to the comments service deployed at comments.gamers.com
    via the Hoverfly proxy, and requests and responses are recorded. The src/test/resources/hoverfly/simulation.json
    file is created because it doesn’t yet exist. The next time you run the test,
    communication is still proxied through the Hoverfly proxy, but because the file
    now exists, the canned responses are returned.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他测试用例相比，最大的不同之处在于，第一次运行此测试时，请求通过Hoverfly代理发送到部署在comments.gamers.com的评论服务，并记录请求和响应。由于该文件尚不存在，因此会创建src/test/resources/hoverfly/simulation.json文件。下次运行测试时，通信仍然通过Hoverfly代理进行代理，但由于该文件现在存在，将返回预定义的响应。
- en: In case you’re curious (we know you are), the recorded file looks like the next
    listing (src/test/resources/hoverfly/simulation.json).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇（我们知道你是），记录的文件看起来像下面的列表（src/test/resources/hoverfly/simulation.json）。
- en: Listing 9.2\. Simulation file with canned responses
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 带有预定义响应的模拟文件
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Service virtualization isn’t a substitute for contract tests but something to
    use with them, mostly in provider-validation scenarios.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务虚拟化不是合同测试的替代品，而是一种与它们一起使用的东西，主要在提供者验证场景中使用。
- en: Service virtualization is used for removing the flakiness of tests that depend
    on external and potentially unreliable services.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务虚拟化用于消除依赖于外部和可能不可靠服务的测试的不可靠性。
- en: A virtual asset is the service you’re simulating.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟资产是你所模拟的服务。
- en: You can use service virtualization to emulate unfinished services in addition
    to existing services, thus allowing rapid development in parallel teams.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用服务虚拟化来模拟现有服务之外的未完成服务，从而允许并行团队快速开发。
- en: Hoverfly Java takes care of all network redirections and lets you get on with
    writing the test.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hoverfly Java负责所有网络重定向，让你继续编写测试。
