- en: '12 Ransom: Randomly capitalizing text'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 勒索：随机大写文本
- en: '| All this hard work writing code is getting on my nerves. I’m ready to turn
    to a life of crime! I’ve kidnapped (cat-napped?) the neighbor’s cat, and I want
    to send them a ransom note. In the good old days, I’d cut letters from magazines
    and paste them onto a piece of paper to spell out my demands. That sounds like
    too much work. Instead, I’m going to write a Python program called ransom.py that
    will encode text into randomly capitalized letters:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '| 所有这些编写代码的辛勤工作让我感到烦躁。我准备好过上犯罪的生活了！我绑架了（猫绑架？）邻居的猫，我想给他们发送一份勒索信。在美好的旧日子里，我会从杂志上剪下字母，然后粘贴到一张纸上以拼写我的要求。这听起来像太多的工作。相反，我将编写一个名为ransom.py的Python程序，该程序将文本编码为随机大写的字母：'
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '| ![](../Images/12-unnumb-1.png)  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/12-unnumb-1.png)  |'
- en: 'As you can see, my diabolical program accepts the heinous input text as a positional
    argument. Since this program uses the `random` module, I want to accept an `-s`
    or `--seed` option so I can replicate the vile output:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我的邪恶程序接受邪恶的输入文本作为位置参数。由于这个程序使用`random`模块，我想接受一个`-s`或`--seed`选项，这样我就可以复制邪恶的输出：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| The dastardly positional argument might name a vicious file, in which case
    that should be read for the demoniac input text:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '| 勇敢的位置参数可能指定一个邪恶的文件，在这种情况下，应该读取该文件以获取恶魔般的输入文本：'
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| ![](../Images/12-unnumb-2.png)  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/12-unnumb-2.png)  |'
- en: 'If the unlawful program is run with no arguments, it should print a short,
    infernal usage statement:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果非法程序在没有参数的情况下运行，它应该打印一个简短的、令人讨厌的使用说明：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the nefarious program is run with `-h` or `--help` flags, it should print
    a longer, fiendish usage:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邪恶程序以`-h`或`--help`标志运行，它应该打印一个更长、更邪恶的使用说明：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Figure 12.1 shows a noxious string diagram to visualize the inputs and outputs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1展示了一个有害的字符串图，用于可视化输入和输出。
- en: '![](../Images/12-1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-1.png)'
- en: Figure 12.1 The awful program will transform input text into a ransom note by
    randomly capitalizing letters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1这个糟糕的程序将通过随机大写字母将输入文本转换为勒索信。
- en: In this chapter, you will
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将
- en: Learn how to use the `random` module to figuratively “flip a coin” to decide
    between two choices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`random`模块来象征性地“抛硬币”以在两个选择之间做出决定
- en: Explore ways to generate new strings from an existing one, incorporating random
    decisions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索从现有字符串生成新字符串的方法，结合随机决策
- en: Study the similarities of `for` loops, list comprehensions, and the `map()`
    function
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究循环、列表推导式和`map()`函数的相似性
- en: 12.1 Writing ransom.py
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 编写ransom.py
- en: I suggest starting with new.py or copying the template/template.py file to create
    ransom.py in the 12_ransom directory. This program, like several before it, accepts
    a required, positional string for the `text` and an optional integer (default
    `None`) for the `--seed`. Also, as in previous exercises, the `text` argument
    may name a file that should be read for the `text` value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议从new.py开始，或者将template/template.py文件复制到12_ransom目录中创建ransom.py。这个程序，就像之前的几个程序一样，接受一个必需的位置字符串`text`和一个可选的整数（默认`None`）作为`--seed`。同样，在之前的练习中，`text`参数可以指定一个文件名，该文件应被读取以获取`text`值。
- en: 'To start out, use this for your `main()` code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请使用以下`main()`代码：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Get the processed command-line arguments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取处理过的命令行参数。
- en: ② Set the random.seed() with the value from the user. The default is None, which
    is the same as not setting it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用用户提供的值设置`random.seed()`。默认是`None`，这与没有设置相同。
- en: ③ Start off by echoing back the input.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 首先回显输入。
- en: 'If you run this program, it should echo the input from the command line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，它应该回显命令行中的输入：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or the text from an input file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从输入文件中的文本：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The important thing when writing a program is to take baby steps. You should
    run your program *after every change*, checking manually and with the tests to
    see if you are progressing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序时的重要事情是要采取小步骤。你应该在每次更改后运行你的程序，手动和通过测试来检查你是否在进步。
- en: Once you have this working, it’s time to think about how to randomly capitalize
    this awful message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个功能正常工作，就是时候考虑如何随机大写这个糟糕的消息了。
- en: 12.1.1 Mutating the text
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 修改文本
- en: 'You’ve seen before that you can’t directly modify a `str` value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经看到你不能直接修改一个`str`值：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So how can we randomly change the case of some of the letters?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何随机改变一些字母的大小写呢？
- en: 'I suggest that instead of thinking about how to change many letters, you should
    think about how to change *one* letter. That is, given a single letter, how can
    you randomly return the upper- or lowercase version of the letter? Let’s create
    a dummy `choose()` function that accepts a single character. For now, we’ll have
    the function return the character unchanged:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你与其考虑如何改变许多字母，不如考虑如何改变**一个**字母。也就是说，给定一个字母，你如何随机返回该字母的大写或小写版本？让我们创建一个模拟的`choose()`函数，它接受一个单个字符。现在，我们将让函数返回未更改的字符：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s a test for it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个测试用例：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① The state of the random module is global to the program. Any change we make
    here could affect unknown parts of the program, so we save our current state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ① 随机模块的状态是程序的全局状态。我们在这里所做的任何更改都可能影响程序未知的部分，因此我们保存当前状态。
- en: ② Set the random seed to a known value. This is a global change to our program.
    Any other calls to functions from the random module will be affected!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将随机种子设置为已知值。这是对我们程序的全局更改。对随机模块中函数的任何其他调用都将受到影响！
- en: ③ The choose() function is given a series of letters, and we use the assert
    statement to test if the value returned by the function is the expected letter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `choose()`函数接受一系列字母，我们使用`assert`语句来测试函数返回的值是否是预期的字母。
- en: ④ Reset the global state to the original value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将全局状态重置为原始值。
- en: Random seeds
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随机种子
- en: Have you wondered how I knew what would be the result of `choose()` for a given
    random seed? Well, I confess that I wrote the function, then set the seed, and
    ran it with the given inputs. I recorded the results as the assertions you see.
    In the future, these results should still be the same. If they are not, I’ve changed
    something and probably broken my program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想过我是如何知道给定随机种子`choose()`的结果会是什么？好吧，我承认我写了这个函数，然后设置了种子，并用给定的输入运行了它。我把结果记录成了你看到的断言。在未来，这些结果应该仍然是相同的。如果它们不是，那么我可能改动了某些东西，可能破坏了我的程序。
- en: 12.1.2 Flipping a coin
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 抛硬币
- en: '| We need to `choose()` between returning the upper- or lowercase version of
    the character you are given. It’s a *binary* choice, meaning we have two options,
    so we can use the analogy of flipping a coin. Heads or tails? Or, for our purposes,
    0 or 1:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我们需要在返回给定字符的大写或小写版本之间进行选择。这是一个**二进制**选择，意味着我们有两个选项，因此我们可以使用抛硬币的类比。正面或反面？或者，就我们的目的而言，0或1：'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or `True` or `False` if you prefer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者`True`或`False`，如果你更喜欢：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| ![](../Images/12-unnumb-3.png)  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/12-unnumb-3.png) |'
- en: Think about using an `if` expression where you return the uppercase answer when
    the `0` or `False` option is selected and the lowercase version otherwise. My
    entire `choose()` function is this one line.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用一个`if`表达式，当选择`0`或`False`选项时返回大写答案，否则返回小写版本。我的整个`choose()`函数就是这一行。
- en: 12.1.3 Creating a new string
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 创建一个新的字符串
- en: Now we need to apply our `choose()` function to each character in the input
    string. I hope this is starting to feel like a familiar tactic. I encourage you
    to start by mimicking the first approach from chapter 8 where we used a `for`
    loop to iterate through each character of the input text and replace all the vowels
    with a single vowel. In this program, we can iterate through the characters of
    text and use them as the argument to the `choose()` function. The result will
    be a new `list` (or `str`) of the transformed characters. Once you can pass the
    test with a `for` loop, try to rewrite it as a list comprehension, and then a
    `map()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的`choose()`函数应用到输入字符串中的每个字符上。我希望这开始感觉像是一种熟悉的策略。我鼓励你从模仿第8章中的第一个方法开始，在那里我们使用`for`循环遍历输入文本的每个字符，并将所有元音替换为单个元音。在这个程序中，我们可以遍历文本的字符，并将它们作为`choose()`函数的参数。结果将是一个新的转换字符的`list`（或`str`）。一旦你能通过`for`循环的测试，尝试将其重写为列表推导式，然后是`map()`。
- en: Now off you go! Write the program, pass the tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始吧！编写程序，通过测试。
- en: 12.2 Solution
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 解答
- en: We’re going to explore many ways to process all the characters in the input
    text. We’ll start off with a `for` loop that builds up a new list, and I hope
    to convince you that a list comprehension is a better way to do this. Finally,
    I’ll show you how to use `map()` to create a very terse (perhaps even elegant)
    solution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索许多处理输入文本中所有字符的方法。我们将从一个构建新列表的`for`循环开始，并希望说服你列表推导式是更好的方法。最后，我将向你展示如何使用`map()`创建一个非常简洁（甚至可能是优雅）的解决方案。
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① The text argument is a positional string value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ① 文本参数是一个位置字符串值。
- en: ② The --seed option is an integer that defaults to None.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ② `--seed`选项是一个默认为`None`的整数。
- en: ③ Process the command-line arguments into the args variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将命令行参数处理到`args`变量中。
- en: ④ If the args.text is a file, use the contents of that as the new args.text
    value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果`args.text`是一个文件，则使用该文件的内容作为新的`args.text`值。
- en: ⑤ Return the arguments to the caller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将参数返回给调用者。
- en: ⑥ Set the random.seed() to the given args.seed value. The default is None, which
    is the same as not setting it. That means the program will appear random when
    no seed is given but will be testable when we do provide a seed value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将`random.seed()`设置为给定的`args.seed`值。默认值为`None`，这与未设置相同。这意味着如果没有给出种子值，程序将看起来是随机的，但如果我们提供了种子值，则可以进行测试。
- en: ⑦ Create an empty list to hold the new ransom message.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建一个空列表来保存新的密文消息。
- en: ⑧ Use a for loop to iterate through each character of args.text.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用`for`循环遍历`args.text`中的每个字符。
- en: ⑨ Append the chosen letter to the ransom list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 将选定的字母追加到密文列表中。
- en: ⑩ Join the ransom list on the empty string to create a new string to print.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 使用空字符串将密文列表连接起来，以创建一个新的字符串进行打印。
- en: ⑪ Define a function to randomly return the upper- or lowercase version of a
    given character.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 定义一个函数，随机返回给定字符的大写或小写版本。
- en: ⑫ Use random.choice() to select either 0 or 1, which, in the Boolean context
    of the if expression, evaluates to False or True, respectively.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 使用`random.choice()`选择0或1，在`if`表达式的布尔上下文中，分别评估为False或True。
- en: ⑬ Define a test_choose() function that will be run by Pytest. The function takes
    no arguments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 定义一个`test_choose()`函数，该函数将由Pytest运行。该函数不接受任何参数。
- en: ⑭ Save the current state of the random module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 保存随机模块的当前状态。
- en: ⑮ Set the random.seed() to a known value for the purposes of the test.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 将`random.seed()`设置为已知值，以便进行测试。
- en: ⑯ Use the assert statement to verify that we get the expected result from the
    choose() for a known argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 使用`assert`语句验证从`choose()`函数得到的预期结果是否与已知参数相符。
- en: ⑰ Reset the random module’s state so that our changes won’t affect any other
    part of the program.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 重置随机模块的状态，以确保我们的更改不会影响程序的任何其他部分。
- en: 12.3 Discussion
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 讨论部分
- en: '| I like this problem because there are so many interesting ways to solve it.
    I know, I know, Python likes there to be “one obvious way” to solve it, but let’s
    explore, shall we? There’s nothing in `get_args()` that we haven’t seen several
    times by now, so let’s skip that. | ![](../Images/12-unnumb-4.png)  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 我喜欢这个问题，因为它有如此多的有趣解决方法。我知道，我知道，Python喜欢有“一个明显的方法”来解决问题，但让我们探索一下，好吗？`get_args()`中没有我们之前没有看到过的内容，所以让我们跳过它。|
    ![](../Images/12-unnumb-4.png)  |'
- en: 12.3.1 Iterating through elements in a sequence
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 遍历序列中的元素
- en: 'Assume that we have the following cruel message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下残酷的信息：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I want to randomly upper- and lowercase the letters. As suggested in the earlier
    description of the problem, we can use a `for` loop to iterate over each character.
    One way to print an uppercase version of the `text` is to print an uppercase version
    *of each letter*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我想随机地将字母的大小写。正如问题早期描述中建议的那样，我们可以使用一个`for`循环来遍历每个字符。打印`text`的大写版本的一种方法是将每个字母的大写版本打印出来：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| That would give me “2 MILLION DOLLARS OR THE CAT SLEEPS WITH THE FISHES!”
    Now, instead of always printing `char.upper()`, I can randomly choose between
    `char.upper()` and `char.lower()`. For that, I’ll use `random.choice()` to choose
    between two values like `True` and `False` or `0` and `1`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这将给出“200万美元，否则猫和鱼一起睡觉！”现在，我不再总是打印`char.upper()`，我可以随机选择`char.upper()`和`char.lower()`。为此，我将使用`random.choice()`在两个值（如`True`和`False`或`0`和`1`）之间进行选择：'
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| ![](../Images/12-unnumb-5.png)  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/12-unnumb-5.png)  |'
- en: 'Following the first solution from chapter 8, I created a new `list` to hold
    the ransom message and added these random choices:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着第8章的第一个解决方案，我创建了一个新的`list`来保存密文消息，并添加了这些随机选择：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then I joined the new characters on the empty string to print a new string:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将新字符连接到空字符串上，以打印一个新的字符串：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s far less code to write this with an `if` expression to select whether
    to take the upper- or lowercase character, as shown in figure 12.2:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`表达式来选择是否取大写或小写字符，代码更少，如图12.2所示：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](../Images/12-2.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-2.png)'
- en: Figure 12.2 A binary if/else branch is more succinctly written using an `if`
    expression.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 使用`if`表达式可以更简洁地编写二进制if/else分支。
- en: 'You don’t have to use actual Boolean values (`False` and `True`). You could
    use `0` and `1` instead:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用实际的布尔值（`False`和`True`）。你可以用`0`和`1`来代替：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When numbers are evaluated *in a Boolean context* (that is, in a place where
    Python expects to see a Boolean value), `0` is considered `False`, and every other
    number is `True`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当数字在布尔上下文中被评估时（也就是说，在Python期望看到布尔值的地方），`0` 被认为是 `False`，而其他所有数字都是 `True`。
- en: 12.3.2 Writing a function to choose the letter
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 编写一个选择字母的函数
- en: The `if` expression is a bit of code that could be put into a function. I find
    it hard to read inside the `ransom.append()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 表达式是一段可以放入函数中的代码。我发现它在 `ransom.append()` 中的可读性较差。'
- en: 'By putting it into a function, I can give it a descriptive name and write a
    test for it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其放入函数中，我可以给它一个描述性的名称，并为其编写测试：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now I can run the `test_choose()` function to test that my function does what
    I think. This code is much easier to read:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以运行 `test_choose()` 函数来测试我的函数是否按预期工作。这段代码的可读性要好得多：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 12.3.3 Another way to write list.append()
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 另一种写法：list.append()
- en: The solution in section 12.2 creates an empty `list`, to which I `list.append()`
    the return from `choose()`. Another way to write `list.append()` is to use the
    `+=` operator to add the right-hand value (the element to add) to the left-hand
    side (the list), as in figure 12.3.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2 节中的解决方案创建了一个空的 `list`，然后我将 `choose()` 的返回值 `list.append()` 到其中。另一种写法 `list.append()`
    是使用 `+=` 运算符将右侧值（要添加的元素）添加到左侧（列表），如图 12.3 所示。
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/12-3.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-3.png)'
- en: Figure 12.3 The `+=` operator is another way to write `list.append()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 `+=` 运算符是另一种写法 `list.append()`.
- en: This is the same syntax for concatenating a character to a string or adding
    a number to another number.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将字符连接到字符串或将数字添加到另一个数字上的相同语法。
- en: 12.3.4 Using a str instead of a list
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 使用字符串而不是列表
- en: 'The two previous solutions require that the lists be joined on the empty string
    to make a new string to print. We could, instead, start off with an empty string
    and build that up, one character at a time, using the `+=` operator:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种解决方案都需要将列表连接到空字符串上，以创建一个新的字符串进行打印。相反，我们可以从一个空字符串开始，逐个字符地使用 `+=` 运算符构建：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we just noted, the `+=` operator is another way to append an element to a
    list. Python often treats strings and lists interchangeably, often implicitly,
    for better or worse.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，`+=` 运算符是另一种向列表中添加元素的方法。Python经常将字符串和列表互换使用，有时是隐式的，不管是有益还是有害。
- en: 12.3.5 Using a list comprehension
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.5 使用列表推导式
- en: 'The previous patterns all initialize an empty `str` or `list` and then build
    it up with a `for` loop. I’d like to convince you that it’s almost always better
    to express this using a list comprehension, because its entire raison d’être is
    to return a new list. We can condense our three lines of code to just one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的模式都是先初始化一个空的 `str` 或 `list`，然后通过 `for` 循环逐步构建。我想说服你，几乎总是最好使用列表推导式来表达，因为它的整个存在目的就是返回一个新的列表。我们可以将我们的三行代码压缩成一行：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or you can skip creating the `ransom` variable altogether. As a general rule,
    I only assign a value to a variable if I use it more than once or if I feel it
    makes my code more readable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以完全跳过创建 `ransom` 变量的步骤。一般来说，我只在需要多次使用变量或觉得它可以使我的代码更易读时才给它赋值：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A `for` loop is really for iterating through some sequence and producing *side
    effects*, like printing values or handling lines in a file. If your goal is to
    create a new `list`, a list comprehension is probably the best tool. Any code
    that would go into the body of the `for` loop to process an element is better
    placed in a function with a test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环实际上是在遍历某个序列并产生 *副作用*，如打印值或处理文件中的行。如果你的目标是创建一个新的 `list`，那么列表推导式可能是最好的工具。任何本应放入
    `for` 循环体中以处理元素的代码都最好放在一个带有测试的函数中。'
- en: 12.3.6 Using a map() function
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.6 使用 map() 函数
- en: 'I’ve mentioned before that `map()` is just like a list comprehension, though
    usually with less typing. Both approaches generate a new `list` from some iterable,
    as shown in figure 12.4\. In this case, the resulting list from `map()` is created
    by applying the `choose()` function to each character of `args.text`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，`map()` 和列表推导式非常相似，尽管通常需要更少的输入。两种方法都是从一些可迭代对象中生成一个新的 `list`，如图 12.4 所示。在这种情况下，`map()`
    返回的列表是通过将 `choose()` 函数应用于 `args.text` 的每个字符来创建的：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](../Images/12-4.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-4.png)'
- en: Figure 12.4 The ideas of the list comprehension can be expressed more succinctly
    with `map()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 列表推导式的思想可以用 `map()` 更简洁地表达。
- en: 'Or, again, you could leave out the `ransom` assignment and use the `list` that
    comes back from `map()` directly:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，再次，你可以省略 `ransom` 赋值，并直接使用 `map()` 返回的 `list`：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 12.4 Comparing methods
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 比较方法
- en: It may seem silly to spend so much time working through so many ways to solve
    what is essentially a trivial problem, but one of the goals of this book is to
    explore the various ideas available in Python. The first solution in section 12.2
    is a very imperative solution that a C or Java programmer would probably write.
    The version using a list comprehension is very idiomatic to Python--it is “Pythonic,”
    as Pythonistas would say. The `map()` solution would look very familiar to someone
    coming from a purely functional language like Haskell.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 花这么多时间解决一个本质上微不足道的问题似乎很愚蠢，但本书的一个目标就是探索 Python 中可用的各种思想。第 12.2 节中的第一个解决方案是一个非常命令式的解决方案，C
    或 Java 程序员可能会编写。使用列表推导式的版本非常符合 Python 的风格——它就是“Pythonic”，正如 Pythonista 们所说的。`map()`
    解决方案对来自纯函数式语言（如 Haskell）的人来说会非常熟悉。
- en: All these approaches accomplish the same goal, but they embody different aesthetics
    and programming paradigms. My preferred solution would be the last one, using
    `map()`, but you should choose an approach that makes the most sense to you.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都实现了相同的目标，但它们体现了不同的美学和编程范式。我首选的解决方案是最后一个，使用 `map()`，但你应该选择对你最有意义的方案。
- en: MapReduce
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce
- en: In 2004, Google released a paper on their “MapReduce” algorithm. The “map” phase
    applies some transformation to all the elements in a collection, such as all the
    pages of the internet that need to be indexed for searching. These operations
    can happen in *parallel*, meaning you can use many machines to process the pages
    separately from each other and in any order. The “reduce” phase then brings all
    the processed elements back together, maybe to put the results into a unified
    database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 2004 年，谷歌发布了一篇关于他们“MapReduce”算法的论文。在“map”阶段，对集合中的所有元素应用一些转换，例如需要索引以供搜索的互联网上的所有页面。这些操作可以并行进行，这意味着你可以使用多台机器分别处理页面，并且可以按任何顺序处理。然后，“reduce”阶段将所有处理过的元素重新组合在一起，可能将结果放入统一的数据库中。
- en: In our ransom.py program, the “map” part selected a randomized case for the
    given letter, and the “reduce” part was putting all those bits back together into
    a new string. Conceivably, `map()` could make use of multiple processors to run
    the functions *in parallel* as opposed to *sequentially* (like with a `for` loop),
    possibly cutting the time to produce the results.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 ransom.py 程序中，“map”部分为给定的字母选择了一个随机的案例，而“reduce”部分则是将这些比特重新组合成一个新的字符串。理论上，`map()`
    可以利用多个处理器并行运行函数，而不是按顺序（如使用 `for` 循环）运行，这可能会缩短产生结果的时间。
- en: The ideas of map/reduce can be found in many places, from indexing the internet
    to our ransom program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Map/Reduce 的思想可以在许多地方找到，从索引互联网到我们的 ransom 程序。
- en: Learning about MapReduce was, to me, a bit like learning the name of a new bird.
    I never even noticed that bird before, but, once I was told its name, I saw it
    everywhere. Once you understand this pattern, you’ll begin to see it in many places.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，了解 MapReduce 就像学习一个新鸟的名字。我以前甚至没有注意到那只鸟，但一旦我知道了它的名字，我就到处都看到了。一旦你理解了这个模式，你将开始在很多地方看到它。
- en: '![](../Images/12-unnumb-6.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-unnumb-6.png)'
- en: 12.5 Going further
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 深入学习
- en: Write a version of ransom.py that represents letters in other ways by combining
    ASCII characters, such as the following. Feel free to make up your own substitutions.
    Be sure to update your tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 ransom.py 的版本，通过组合 ASCII 字符以其他方式表示字母，如下所示。请随意创造自己的替换。确保更新你的测试。
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Whenever you have lots of things to process, try to think about how you’d process
    just one of them.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当你有很多东西要处理时，试着想想你将如何处理其中之一。
- en: Write a test that helps you imagine how you’d like to use the function to process
    one item. What will you pass in, and what do you expect back?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个测试，帮助你想象你如何使用该函数处理一个项目。你将传递什么，你期望得到什么？
- en: Write your function to pass your test. Be sure to think about what you’ll do
    with both good and bad input.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的函数以通过测试。确保考虑你将如何处理好的和坏的数据输入。
- en: To apply your function to each element in your input, use a `for` loop, a list
    comprehension, or a `map()`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将你的函数应用于输入中的每个元素，请使用 `for` 循环、列表推导式或 `map()`。
- en: '| ![](../Images/12-unnumb-7.png)  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/12-unnumb-7.png)  |'
