- en: Chapter 2\. Starting with R and data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。从R和数据开始
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Starting to work with R and data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用R和数据
- en: Mastering R’s data frame structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握R的数据框结构
- en: Loading data into R
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据加载到R中
- en: Recoding data for later analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据进行重新编码以供后续分析
- en: This chapter works through how to start working with R and how to import data
    into R from diverse sources. This will prepare you to work examples throughout
    the rest of the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何开始使用R以及如何从各种来源将数据导入R。这将为您在本书其余部分的工作做好准备。
- en: '[Figure 2.1](../Text/02.xhtml#ch02fig01) is a diagram representing a mental
    model for the book that has been reshaded to emphasize the purpose of this chapter:
    starting to work with R and importing data into R. The overall diagram shows the
    data science process diagram from [chapter 1](../Text/01.xhtml#ch01) combined
    with a rebus form of the book title. In each chapter, we will reshade this mental
    model to indicate the parts of the data science process we are emphasizing. For
    example: in this chapter, we are mastering the initial steps of collecting and
    managing data, and touching on issues of practicality, data, and R (but not yet
    the art of science).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](../Text/02.xhtml#ch02fig01) 是一个表示本书心智模型的图表，经过重新着色以强调本章的目的：开始使用R并将数据导入R。整体图表显示了从[第1章](../Text/01.xhtml#ch01)中的数据科学流程图与本书标题的象形文字形式相结合。在每一章中，我们将重新着色这个心智模型，以指明我们强调的数据科学流程的各个部分。例如：在本章中，我们将掌握收集和管理数据的初始步骤，并触及实用性、数据和R（但还不是科学艺术）的问题。'
- en: Figure 2.1\. [Chapter 2](../Text/02.xhtml#ch02) mental model
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1。[第2章](../Text/02.xhtml#ch02)心智模型
- en: '![](Images/02fig01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01.jpg)'
- en: 'Many data science projects start when someone points the analyst toward a bunch
    of data, and the analyst is left to make sense of it.^([[5](../Text/02.xhtml#ch02fn1)])
    Your first thought may be to use ad hoc tools and spreadsheets to sort through
    it, but you will quickly realize that you’re taking more time tinkering with the
    tools than actually analyzing the data. Luckily, there’s a better way: using R.
    By the end of the chapter, you’ll be able to confidently use R to extract, transform,
    and load data for analysis.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据科学项目始于有人将分析师指向一大堆数据，分析师则被留下去理解它。[5](../Text/02.xhtml#ch02fn1) 您的第一个想法可能是使用临时工具和电子表格来整理它，但您很快就会意识到，您花在调整工具上的时间比实际分析数据的时间要多。幸运的是，有一个更好的方法：使用R。到本章结束时，您将能够自信地使用R提取、转换和加载数据进行分析。
- en: ⁵
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We assume the reader is interested in working as an analyst, statistician, or
    data scientist, so we will alternate using these terms to represent people similar
    to the reader.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们假设读者对成为分析师、统计学家或数据科学家感兴趣，因此我们将交替使用这些术语来代表与读者类似的人。
- en: '*R without data is like going to the theater to watch the curtain go up and
    down.*'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*没有数据的R就像去剧院看帷幕上下摆动。*'
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Adapted from Ben Katchor’s Julius Knipl, Real Estate Photographer: Stories*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*改编自Ben Katchor的《Julius Knipl，房地产摄影师：故事》*'
- en: 2.1\. Starting with R
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1。从R开始
- en: 'R is open source software that runs well on Unix, Linux, Apple’s macOS, and
    Microsoft Windows. This book will concentrate on how to work as a data scientist.
    However, to work the examples, the reader must be familiar with R programming.
    If you want to pick up some prerequisite knowledge, we suggest consulting free
    manuals from CRAN (the main R package repository: [https://cran.r-project.org/manuals.html](https://cran.r-project.org/manuals.html))
    and other online materials. A number of good books for starting with R include
    these:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: R是开源软件，在Unix、Linux、Apple的macOS和Microsoft Windows上运行良好。本书将专注于如何作为数据科学家进行工作。然而，为了运行示例，读者必须熟悉R编程。如果您想获取一些先决知识，我们建议咨询CRAN（主要R包仓库：[https://cran.r-project.org/manuals.html](https://cran.r-project.org/manuals.html)）和其他在线材料。以下是一些适合R入门的好书：
- en: '*R in Action, Second Edition*, Robert Kabacoff, Manning, 2015'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《R编程艺术，第二版》，Robert Kabacoff，Manning，2015*'
- en: '*Beyond Spreadsheets with R*, Jonathan Carroll, Manning, 2018'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《超越电子表格的R》，Jonathan Carroll，Manning，2018*'
- en: '*The Art of R Programming*, Norman Matloff, No Starch Press, 2011'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《R编程的艺术》，Norman Matloff，No Starch Press，2011*'
- en: '*R for Everyone, Second Edition*, Jared P. Lander, Addison-Wesley, 2017'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《R编程人人用，第二版》，Jared P. Lander，Addison-Wesley，2017*'
- en: Each book has a different teaching style, and some include material on statistics,
    machine learning, and data engineering. A little research may tell you which books
    work well for you. This book will concentrate on working substantial data science
    examples, demonstrating the steps needed to overcome typical issues found in your
    own future real-world applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每本书都有不同的教学风格，其中一些包括统计学、机器学习和数据工程的内容。一点研究可能会告诉你哪些书籍适合你。本书将专注于处理大量的数据科学示例，展示在未来的实际应用中遇到的典型问题的解决步骤。
- en: 'It is our opinion that data science is repeatable: the same job rerun on the
    same data should give a similar quality result (the exact result may vary due
    to numeric issues, timing issues, issues arising from parallelism, and issues
    around pseudo-random numbers). In fact, we should insist on repeatability. This
    is why we are discussing programming in a data science book. Programming is the
    reliable way to specify a reusable sequence of operations. With this in mind,
    one should always consider a data refresh (getting newer, corrected, or larger
    data) as a good thing, because rerunning an analysis should be, by design, very
    easy. An analysis that has a number of steps performed by hand is never going
    to be easy to repeat.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为数据科学是可重复的：在相同的数据上重新运行相同的工作应该给出相似的质量结果（由于数值问题、时间问题、并行性问题以及伪随机数问题，确切的结果可能会有所不同）。实际上，我们应该坚持可重复性。这就是为什么我们在数据科学书中讨论编程的原因。编程是可靠地指定可重用操作序列的方法。考虑到这一点，我们应该始终将数据更新（获取更新、更正或更大的数据）视为好事，因为重新运行分析应该，按照设计，非常容易。一个由多个手动步骤执行的分析永远不会容易重复。
- en: 2.1.1\. Installing R, tools, and examples
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1\. 安装R、工具和示例
- en: We suggest you follows the steps in [section A.1](../Text/A.xhtml#app01lev1sec1)
    of [appendix A](../Text/A.xhtml#app01) to install R, packages, tools, and the
    book examples.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你遵循[附录A的A.1节](../Text/A.xhtml#app01lev1sec1)中的步骤来安装R、软件包、工具和本书的示例。
- en: '* * *'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Look for help
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找帮助
- en: R includes a very nice help system. To get help on an R command, just run the
    `help()` command in the R console. For example, to see details about how to change
    directories, you would type `help(setwd)`. You must know the name of the function
    to get help, so we strongly recommend keeping notes. For some simple functions,
    we will not explain the function and leave it to the reader to call `help()` to
    work out what the function does.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: R包含一个非常出色的帮助系统。要获取R命令的帮助，只需在R控制台中运行`help()`命令。例如，要查看如何更改目录的详细信息，你应该输入`help(setwd)`。你必须知道函数的名称才能获取帮助，所以我们强烈建议做笔记。对于一些简单的函数，我们不会解释函数，而是留给读者调用`help()`来找出函数的功能。
- en: '* * *'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 2.1.2\. R programming
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2\. R编程
- en: In this section, we will briefly describe some R programming conventions, semantics,
    and style issues. Details can be found in package-specific documentation, the
    R `help()` system, and by trying variations of the examples we present here. Here,
    we’ll concentrate on aspects that differ from other common programming languages,
    and conventions that we emphasize in the book. This should help you get into an
    R frame of mind.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍一些R编程的约定、语义和风格问题。详细信息可以在特定软件包的文档、R的`help()`系统中找到，也可以通过尝试我们在此处提供的示例的不同变体来获取。在这里，我们将专注于与其他常见编程语言不同的方面，以及我们在书中强调的约定。这应该有助于你进入R编程的思维模式。
- en: 'There are a number of common R coding style guides. *Coding style* is an attempt
    to make things more consistent, clear, and readable. This book will follow a style
    variation we have found to be very effective in teaching and code maintenance.
    Obviously, our style is just one among many, and is in no way mandatory. Good
    starting references include these:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多常见的R编程风格指南。*编程风格*是尝试使事物更加一致、清晰和易于阅读。本书将遵循我们在教学和代码维护中找到的非常有效的风格变体。显然，我们的风格只是众多风格中的一种，并不是强制性的。好的起始参考包括以下内容：
- en: The Google R Style Guide ([https://google.github.io/styleguide/Rguide.html](https://google.github.io/styleguide/Rguide.html))
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google R风格指南](https://google.github.io/styleguide/Rguide.html)'
- en: Hadley Wickham’s style guide from *Advanced R* ([http://adv-r.had.co.nz/Style.html](http://adv-r.had.co.nz/Style.html))
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hadley Wickham的来自《Advanced R》的风格指南([http://adv-r.had.co.nz/Style.html](http://adv-r.had.co.nz/Style.html))
- en: We will try to minimize differences from current convention and call out where
    we have such differences. We also recommend “R tips and tricks” from the author’s
    blog.^([[6](../Text/02.xhtml#ch02fn2)])
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽量减少与当前惯例的差异，并指出我们有哪些差异。我们还推荐作者博客中的“R 技巧和窍门”。^([[6](../Text/02.xhtml#ch02fn2)])
- en: ⁶
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [http://www.win-vector.com/blog/tag/r-tips/](http://www.win-vector.com/blog/tag/r-tips/).
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [http://www.win-vector.com/blog/tag/r-tips/](http://www.win-vector.com/blog/tag/r-tips/)。
- en: R is a rich and broad language, often with many ways to accomplish the same
    task. This represents a bit of an initial learning curve, as the meaning of R
    programs can be hard to discern until you get familiar with the notation. However,
    time spent reviewing some of the basic notation is well rewarded, as it will make
    working through the coming substantial examples much easier. We understand the
    grammar of R is itself uninteresting to the reader coming here to learn data science
    methods and practices (our exact target audience!), but this small initial exertion
    prevents a lot of confusion later. We will use this section to describe a bit
    of R’s notation and meaning, concentrating on that which is particularly useful
    and surprising. All the following are small and basic points, but many of them
    are subtle and worth experimenting with.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: R 是一种丰富而广泛的语言，通常有多种方式来完成同一项任务。这代表了一点点初始的学习曲线，因为直到你熟悉了符号，R 程序的含义可能很难辨别。然而，花时间复习一些基本符号是非常有回报的，因为它会使处理即将到来的大量示例变得更加容易。我们理解
    R 的语法对于来到这里学习数据科学方法和实践的读者来说可能并不有趣（我们的确切目标受众！），但这个小小的初始努力可以防止以后出现很多困惑。我们将使用本节来描述一些
    R 的符号和含义，重点关注特别有用和令人惊讶的部分。所有以下都是小而基本的内容，但其中许多都是微妙的，值得实验。
- en: '* * *'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Prefer working code
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于工作代码
- en: Prefer programs, scripts, or code that works but does not yet do what you want.
    Instead of writing a large, untested program or script that embodies every desired
    step of analysis, write a program that performs a step correctly, and then iteratively
    revise the script to perform more steps correctly. This discipline of moving from
    a working revision usually gets to final correct results much faster than attempting
    to debug a large, faulty system into correctness.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于使用程序、脚本或代码，这些代码可以工作但尚未实现你想要的功能。而不是编写一个大的、未经测试的程序或脚本，其中包含了分析的所有期望步骤，编写一个能够正确执行一个步骤的程序，然后迭代地修改脚本以正确执行更多步骤。这种从工作修订版开始的方法通常比尝试调试一个大的、有缺陷的系统到正确性要快得多。
- en: '* * *'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Examples and the comment character (#)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 示例和注释字符（#）
- en: 'In examples, we will show R commands as free text, with the results prefixed
    by the hash mark, `#`, which is R’s comment character. In many examples, we will
    include the results after the commands, prefixed with the comment character. R
    printing usually includes array cell indices in square braces and often involves
    line wrapping. For example, printing the integers 1 through 25 looks like the
    following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将以自由文本的形式展示 R 命令，结果以井号 `#` 开头，这是 R 的注释字符。在许多示例中，我们将在命令之后包括结果，前面加上注释字符。R
    打印通常包括方括号中的数组单元格索引，并且经常涉及换行。例如，打印整数 1 到 25 的样子如下：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the numbers were wrapped to three lines, and each line starts with the
    index of the first cell reported on the line inside square brackets. Sometimes
    we will not show results, an extra encouragement to work these particular examples.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数字被换行到三行，每行都以该行报告的第一个单元格的索引开始，位于方括号内。有时我们不会显示结果，这是额外鼓励你完成这些特定示例的一种方式。
- en: Printing
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: R has a number of rules that turn implicit or automatic printing on and off.
    Some packages such as `ggplot2` use printing to trigger their intended operations.
    Typing a value usually triggers printing the value. Care must be taken in a function
    or a for loop, as in these contexts, R’s automatic printing of results is disabled.
    Printing of very large objects can be a problem, so you want to avoid printing
    objects of unknown size. Implicit printing can often be forced by adding extra
    parentheses such as in “`(x <- 5)`”.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: R 有一些规则可以打开或关闭隐式或自动打印。一些包，如 `ggplot2`，使用打印来触发它们预期的操作。输入一个值通常会导致打印该值。在函数或 for
    循环中必须小心，因为这些上下文中 R 的自动打印结果是禁用的。打印非常大的对象可能是一个问题，因此你想要避免打印未知大小的对象。通常可以通过添加额外的括号来强制隐式打印，例如在“`(x
    <- 5)`”中。
- en: Vectors and lists
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和列表
- en: Vectors (sequential arrays of values) are fundamental R data structures. Lists
    can hold different types in each slot; vectors can only hold the same primitive
    or atomic type in each slot. In addition to numeric indexing, both vectors and
    lists support name-keys. Retrieving items from a list or vector can be done by
    the operators shown next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 向量（值序列的顺序数组）是 R 的基本数据结构。列表可以在每个槽位中持有不同类型；向量在每个槽位中只能持有相同的基本或原子类型。除了数字索引外，向量和列表都支持名称键。可以通过下面的操作符从列表或向量中检索项目。
- en: '* * *'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Vector indexing
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 向量索引
- en: R vectors and lists are indexed from 1, and not from 0 as with many other programming
    languages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的向量（R vectors）和列表（R lists）是从 1 开始索引的，而不是像许多其他编程语言那样从 0 开始。
- en: '* * *'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Builds an example vector. c() is R’s concatenate operator—it builds longer
    vectors and lists from shorter ones without nesting. For example, c(1) is just
    the number 1, and c(1, c(2, 3)) is equivalent to c(1, 2, 3), which in turn is
    the integers 1 through 3 (though stored in a floating-point format).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建一个示例向量。`c()` 是 R 的连接操作符——它从较短的向量或列表构建更长的向量或列表，而不需要嵌套。例如，`c(1)` 只是数字 1，而
    `c(1, c(2, 3))` 等价于 `c(1, 2, 3)`，这又等价于整数 1 到 3（尽管以浮点格式存储）。
- en: ❷ Builds an example list
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建一个示例列表
- en: ❸ Demonstrates vector and list use of []. Notice that for the list, [] returns
    a new short list, not the item.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 展示了使用 [] 的向量和列表的使用。注意，对于列表，[] 返回一个新的短列表，而不是项目本身。
- en: ❹ Demonstrates vector and list use of [[]]. In common cases, [[]] forces a single
    item to be returned, though for nested lists of complex type, this item itself
    could be a list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 展示了使用 [[]] 的向量和列表的使用。在常见情况下，[[]] 强制返回单个项目，尽管对于复杂类型的嵌套列表，这个项目本身也可以是一个列表。
- en: ❺ Vectors and lists can be indexed by vectors of logicals, integers, and (if
    the vector or list has names) characters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 向量和列表可以通过逻辑向量、整数向量以及（如果向量或列表有名称）字符向量进行索引。
- en: ❻ For named examples, the syntax example_list$b is essentially a short-hand
    for example_list[["b"]] (the same is true for named vectors).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于命名示例，example_list$b 的语法实际上是 example_list[["b"]] 的简写（对于命名向量也是如此）。
- en: We will not always share so many notes for every example, but we invite the
    reader to work as if there were such notes by calling `help()` on every function
    or command used. Also, we very much encourage trying variations. In R “errors”
    are just R’s way of saying it safely refused to complete an ill-formed operation
    (an error does not indicate “crash,” and results are not corrupted). So fear of
    errors should not limit experiments.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在每一个例子中都分享这么多笔记，但我们邀请读者通过在使用的每个函数或命令上调用 `help()` 来像有这些笔记一样工作。此外，我们非常鼓励尝试不同的变体。在
    R 中，“错误”只是 R 安全拒绝完成一个不良形成的操作（错误并不表示“崩溃”，结果也没有被破坏）。因此，对错误的恐惧不应限制实验。
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a value we are interested in and stores it in the variable x
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了一个我们感兴趣的价值并将其存储在变量 x 中
- en: ❷ Attempts, and fails, to assign a new result to x
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试将新的结果分配给 x，但失败了
- en: ❸ Notice that in addition to supplying a useful error message, R preserves the
    original value of x.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注意到除了提供有用的错误信息外，R 还保留了变量 x 的原始值。
- en: ❹ Tries the operation again, using the correct spelling of cumsum(). cumsum(),
    short for cumulative sum, is a useful function that computes running totals quickly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 再次尝试操作，使用 cumsum() 的正确拼写。cumsum()，即累积和，是一个有用的函数，可以快速计算运行总和。
- en: Another aspect of vectors in R is that most R operations are *vectorized*. A
    function or operator is called vectorized when applying it to a vector is shorthand
    for applying a function to each entry of the vector independently. For example,
    the function `nchar()` counts how many characters are in a string. In R this function
    can be used on a single string, or on a vector of strings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: R 中向量的另一个方面是大多数 R 操作都是**向量化的**。当一个函数或操作符应用于向量时，它被称作**向量化**，这意味着它独立地对向量的每个元素应用函数。例如，函数
    `nchar()` 用于计算字符串中的字符数。在 R 中，这个函数可以用于单个字符串，也可以用于字符串向量。
- en: '* * *'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Lists and vectors are R’s map structures
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和向量是 R 的映射结构
- en: Lists and vectors are R’s map structures. They can map strings to arbitrary
    objects. The primary list operations `[]`, `match ()`, and `%in%` are *vectorized*.
    This means that, when applied to a vector of values, they return a vector of results
    by performing one lookup per entry. For pulling individual elements out of a list,
    use the double-bracket notation `[[]]`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和向量是 R 的映射结构。它们可以将字符串映射到任意对象。主要的列表操作 `[]`、`match()` 和 `%in%` 都是**向量化的**。这意味着当它们应用于值向量时，通过每个条目执行一次查找来返回结果向量。要从列表中提取单个元素，请使用双括号表示法
    `[[]]`。
- en: '* * *'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '* * *'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Logical operations
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算
- en: 'R’s logical operators come in two flavors. R has standard infix scalar-valued
    operators that expect only one value and have the same behavior and same names
    as you would see in C or Java: `&&` and `||`. R also has vectorized infix operators
    that work on vectors of logical values: `&` and `|`. Be sure to always use the
    scalar versions (`&&` and `||`) in situations such as `if` statements, and the
    vectorized versions (`&` and `|`) when processing logical vectors.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: R的逻辑运算符有两种类型。R有标准的后缀标量值运算符，它们只期望一个值，并且具有与C或Java中相同的行为和名称：`&&`和`||`。R还有向量化后缀运算符，它们作用于逻辑值的向量：`&`和`|`。务必始终在`if`语句等情况下使用标量版本（`&&`和`||`），在处理逻辑向量时使用向量化版本（`&`和`|`）。
- en: '* * *'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: NULL and NANA (not available) values
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: NULL和NANA（不可用）值
- en: In R `NULL` is just a synonym for the empty or length-zero vector formed by
    using the concatenate operator `c()` with no arguments. For example, when we type
    `c()` into the R console, we will see the value `NULL` returned. In R `NULL` is
    not any sort of invalid pointer (as it is in most C/Java-related languages). `NULL`
    is simply a length-zero vector. Concatenating `NULL` is a safe and well-defined
    operation (in fact it’s a “no operation” or “no-op” that does nothing). For example,
    `c(c(), 1, NULL)` is perfectly valid and returns the value `1`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，`NULL`只是使用连接运算符`c()`不带参数形成的空或长度为零向量的同义词。例如，当我们把`c()`输入到R控制台时，我们会看到返回的值是`NULL`。在R中，`NULL`不是任何形式的无效指针（如在大多数C/Java相关语言中）。`NULL`只是一个长度为零的向量。连接`NULL`是一个安全且定义良好的操作（实际上是一个“无操作”或“no-op”，什么都不做）。例如，`c(c(),
    1, NULL)`是完全有效的，并返回值`1`。
- en: '`NA` stands for “not available” and is fairly unique to R. Most any simple
    type can take on the value `NA`. For example, the vector `c("a", NA, "c")` is
    a vector of three character strings where we do not know the value of the second
    entry. Having `NA` is a great convenience as it allows us to annotate missing
    or unavailable values in place, which can be critical in data processing. `NA`
    behaves a little bit like the `NaN` value in floating-point arithmetic,^([[7](../Text/02.xhtml#ch02fn3)])
    except we are not restricted to using it only with floating-point types. Also,
    `NA` means “not available,” not invalid (as `NaN` denotes), so `NA` has some convenient
    rules such as the logical expression `FALSE & NA` simplifying to `FALSE`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`NA`代表“不可用”，这在R中相当独特。大多数简单类型都可以取`NA`的值。例如，向量`c("a", NA, "c")`是一个包含三个字符字符串的向量，其中我们不知道第二个条目的值。`NA`的存在非常方便，因为它允许我们在数据中直接标注缺失或不可用的值，这在数据处理中可能至关重要。`NA`的行为有点像浮点运算中的`NaN`值，^([[7](../Text/02.xhtml#ch02fn3)])但我们不限于只使用它与浮点类型一起。此外，`NA`意味着“不可用”，而不是无效（如`NaN`表示），因此`NA`有一些方便的规则，例如逻辑表达式`FALSE
    & NA`简化为`FALSE`。'
- en: ⁷
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The limits of *floating-point arithmetic*, or how real numbers are commonly
    *approximated* in computers, is a common source of confusion and problems when
    working with numeric data. To appreciate the issues of working with numeric data,
    we recommend data scientists read David Goldberg’s 1991 *Computing Surveys*. “What
    Every Computer Scientist Should Know About Floating-Point Arithmetic” has been
    publicly shared from this issue ([https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)).
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*浮点运算的局限性*，或者说在计算机中通常如何*近似*实数，是处理数值数据时常见的混淆和问题来源。为了理解处理数值数据的问题，我们建议数据科学家阅读大卫·戈尔伯格1991年的《计算调查》。“关于浮点运算，每位计算机科学家都应该知道的内容”已从该期公开分享([https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html))。'
- en: Identifiers
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符
- en: Identifiers or symbol names are how R refers to variables and functions. The
    Google R Style Guide insists on writing symbol names in what is called “CamelCase”
    (word boundaries in names are denoted by uppercase letters, as in “CamelCase”
    itself). The Advanced R guide recommends an underscore style where names inside
    identifiers are broken up with underscores (such as “day_one” instead of “DayOne”).
    Also, many R users use a dot to break up names with identifiers (such as “day.one”).
    In particular, important built-in R types such as `data.frame` and packages such
    as `data.table` use the dot notation convention.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符或符号名称是R引用变量和函数的方式。Google R风格指南坚持使用所谓的“驼峰式命名法”（名称中的单词边界由大写字母表示，如“CamelCase”本身）。高级R指南建议使用下划线样式，其中标识符内的名称用下划线分隔（例如，“day_one”而不是“DayOne”）。此外，许多R用户使用点来分隔标识符的名称（例如，“day.one”）。特别是，重要的内置R类型，如`data.frame`和包如`data.table`，使用点表示法约定。
- en: We recommend using the underscore notation, but find we often must switch between
    conventions when working with others. If possible, avoid the dot convention, as
    this notation is usually used for other purposes in object-oriented languages
    and databases, and so needlessly confuses others.^([[8](../Text/02.xhtml#ch02fn4)])
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用下划线表示法，但发现在与他人合作时经常必须在这两种约定之间切换。如果可能，避免使用点约定，因为这种表示法通常在面向对象的语言和数据库中用于其他目的，因此会无端地混淆他人.^([[8](../Text/02.xhtml#ch02fn4)])
- en: ⁸
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The dot notation likely comes from the Lisp world (which strongly influenced
    R) and the aversion to underscores likely is a holdover from when “`_`” was one
    of the usable assignment operators in R (it is no longer used as an assignment
    operator in R).
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 点表示法可能来自Lisp世界（它强烈影响了R）和避免下划线的倾向可能是在“`_`”曾是R中可用的赋值运算符时遗留下来的（它现在不再用作R中的赋值运算符）。
- en: Line breaks
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 换行
- en: 'It is generally recommended to keep R source code lines at 80 columns or fewer.
    R accepts multiple-line statements as long as where the statement ends is unambiguous.
    For example, to break the single statement “`1 + 2`" into multiple lines, write
    the code as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议将R源代码行限制在80列或更少。只要语句结束是明确的，R接受多行语句。例如，要将单个语句“`1 + 2`”拆分为多行，可以这样编写代码：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Do not write code like the following, as the first line is itself a valid statement,
    creating ambiguity:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不要编写如下代码，因为第一行本身就是一个有效的语句，这会创建歧义：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The rule is this: force a syntax error every time reading the statement across
    multiple lines terminates early.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是这样的：每次在多行语句中读取时，如果语句提前结束，就强制产生语法错误。
- en: Semicolons
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 分号
- en: R allows semicolons as end-of-statement markers, but does not require them.
    Most style guides recommend not using semicolons in R code and certainly not using
    them at ends of lines.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: R允许使用分号作为语句结束标记，但不是必须的。大多数风格指南建议不要在R代码中使用分号，当然也不应在行尾使用它们。
- en: Assignment
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值
- en: R has many assignment operators (see [table 2.1](../Text/02.xhtml#ch02table01));
    the preferred one is `<-`. `=` can be used for assignment in R, but is also used
    to bind argument values to argument names by name during function calls (so there
    is some potential ambiguity in using `=`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: R有许多赋值运算符（见[表2.1](../Text/02.xhtml#ch02table01)）；首选的是`<-`。在R中，`=`也可以用于赋值，但它也用于在函数调用期间通过名称将参数值绑定到参数名（因此使用`=`存在一些潜在的歧义）。
- en: Table 2.1\. Primary R assignment operators
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1\. R的主要赋值运算符
- en: '| Operator | Purpose | Example |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 用途 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <- | Assign the value on the right to the symbol on the left. | x <- 5 #
    assign the value of 5 to the symbol x |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <- | 将右侧的值赋给左侧的符号。 | x <- 5 # 将5赋值给符号x |'
- en: '| = | Assign the value on the right to the symbol on the left. | x = 5 # assign
    the value of 5 to the symbol x |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| = | 将右侧的值赋给左侧的符号。 | x = 5 # 将5赋值给符号x |'
- en: '| -> | Assign left to right, instead of the traditional right to left. | 5
    -> x # assign the value of 5 to the symbol x |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| -> | 将左侧赋给右侧，而不是传统的从右到左。 | 5 -> x # 将5赋值给符号x |'
- en: Left-hand sides of assignments
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值的左侧
- en: 'Many popular programming languages only allow assignment of values into variable
    name or symbols. R allows slice expressions on the left-hand sides of assignments,
    and both numeric and logical array indexing. This allows for very powerful array-slicing
    commands and coding styles. For example, we can replace all the missing values
    (denoted by “`NA`") in a vector with zero as shown in the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的编程语言只允许将值赋给变量名或符号。R允许在赋值的左侧使用切片表达式，以及数值和逻辑数组索引。这允许使用非常强大的数组切片命令和编码风格。例如，我们可以像以下示例中那样，将向量中的所有缺失值（用“`NA`”表示）替换为零：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ “data.frame” is R’s tabular data type, and the most important data type in
    R. A data.frame holds data organized in rows and columns.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ “data.frame”是R的表格数据类型，也是R中最重要的一种数据类型。data.frame以行和列的形式组织数据。
- en: ❷ When printing data.frames, row numbers are shown in the first (unnamed) column,
    and column values are shown under their matching column names.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当打印data.frame时，行号显示在第一列（未命名的列）中，列值显示在其对应的列名下方。
- en: ❸ We can place a slice or selection of the x column of d on the left-hand side
    of an assignment to easily replace all NA values with zero.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们可以将d的x列的切片或选择放在赋值的左侧，以轻松地将所有NA值替换为零。
- en: Factors
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因子
- en: 'R can handle many kinds of data: numeric, logical, integer, strings (called
    *character* types), and *factors*. Factors are an R type that encodes a fixed
    set of strings as integers. Factors can save a lot on storage while appearing
    to behave as strings. However, factors can have potentially confusing interactions
    with the `as.numeric()` command (which returns the factor codes for factors, but
    parses text for character types). Factors also encode the entire set of allowed
    values, which is useful—but can make combining data from different sources (that
    saw different sets of values) a bit of a chore. To avoid issues, we suggest delaying
    conversion of strings to factors until late in an analysis. This is usually accomplished
    by adding the argument `stringsAsFactors = FALSE` to functions such as `data.frame()`
    or `read.table()`. We, however, do encourage using factors when you have a reason,
    such as wanting to use `summary()` or preparing to produce dummy indicators (see
    “[A bit more on factor coding](../Text/02.xhtml#ch02lev3sec25)” after [listing
    2.10](../Text/02.xhtml#ch02ex10) for more details on dummy indicators and their
    relation to factors).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: R 可以处理多种类型的数据：数值、逻辑、整数、字符串（称为 *字符* 类型）和 *因子*。因子是 R 的一种类型，它将一组固定的字符串编码为整数。因子可以在存储上节省很多空间，同时看起来像字符串一样行为。然而，因子可能与
    `as.numeric()` 命令（它为因子返回因子代码，但解析文本为字符类型）产生潜在的混淆。因子还编码了整个允许值的集合，这很有用——但可能会使将来自不同来源（看到了不同的值集合）的数据合并变得有些麻烦。为了避免问题，我们建议在分析后期再延迟将字符串转换为因子。这通常通过向
    `data.frame()` 或 `read.table()` 等函数添加 `stringsAsFactors = FALSE` 参数来实现。然而，我们确实鼓励在有理由的情况下使用因子，例如想要使用
    `summary()` 或准备生成虚拟指标（参见 [关于因子编码的更多内容](../Text/02.xhtml#ch02lev3sec25) 后的 [2.10
    列表](../Text/02.xhtml#ch02ex10)，了解更多关于虚拟指标及其与因子的关系）。
- en: Named arguments
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'R is centered around applying functions to data. Functions that take a large
    number of arguments rapidly become confusing and illegible. This is why R includes
    a named argument feature. As an example, if we wanted to set our working directory
    to “/tmp” we would usually use the `setwd()` command like so: `setwd("/tmp")`.
    However, `help(setwd)` shows us the first argument to `setwd()` has the name `dir`,
    so we could also write this as `setwd(dir = "/tmp")`. This becomes useful for
    functions that have a large number of arguments, and for setting optional function
    arguments. Note: named arguments must be set by `=`, and not by an assignment
    operator such as `<-`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: R 围绕着将函数应用于数据。具有大量参数的函数很快就会变得令人困惑和难以阅读。这就是为什么 R 包含命名参数功能的原因。例如，如果我们想将工作目录设置为
    “/tmp”，我们通常会使用 `setwd()` 命令如下：`setwd("/tmp")`。然而，`help(setwd)` 显示 `setwd()` 的第一个参数名为
    `dir`，因此我们也可以这样写：`setwd(dir = "/tmp")`。这对于具有大量参数的函数和设置可选函数参数非常有用。注意：命名参数必须通过 `=`
    设置，而不是通过赋值运算符如 `<-`。
- en: '*If you have a procedure with 10 parameters, you probably missed some.*'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果你有一个有 10 个参数的过程，你可能遗漏了一些。*'
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Alan Perlis, “Epigrams on Programming,” ACM SIGPLAN Notices 17*'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*艾伦·佩利斯，《编程格言》，ACM SIGPLAN 通告 17*'
- en: Package notation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 包符号
- en: In R there are two primary ways to use a function from a package. The first
    is to attach the package with the `library()` command and then use the function
    name. The second is to use the package name and then `::` to name the function.
    An example of this second method is `stats::sd(1:5)`. The `::` notation is good
    to avoid ambiguity or to leave a reminder of which package the function came from
    for when you read your own code later.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，使用包中的函数主要有两种方式。第一种是通过 `library()` 命令附加包，然后使用函数名。第二种是使用包名，然后使用 `::` 来指定函数。例如，`stats::sd(1:5)`
    就是一个这种方法的例子。`::` 符号有助于避免歧义，或者在你以后阅读自己的代码时留下关于函数来自哪个包的提示。
- en: Value semantics
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 值语义
- en: 'R is unusual in that it efficiently simulates “copy by value" semantics. Any
    time a user has two references to data, each evolves independently: changes to
    one do not affect the other. This is very desirable for part-time programmers
    and eliminates a large class of possible aliasing bugs when writing code. We give
    a quick example here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: R 在高效模拟“按值复制”语义方面很独特。任何用户拥有两个数据引用时，每个都会独立演变：对其中一个的更改不会影响另一个。这对于兼职程序员来说非常理想，并且在编写代码时消除了大量可能的别名错误。这里我们给出一个快速示例：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates some example data and refers to it by the name d
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一些示例数据，并通过名称 d 引用它们
- en: ❷ Creates an additional reference d2 to the same data
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建对同一数据的另一个引用 d2
- en: ❸ Alters the value referred to by d
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 修改 d 所引用的值
- en: Notice `d2` keeps the old value of `1` for `x`. This feature allows for very
    convenient and safe coding. Many programming languages protect references or pointers
    in function calls in this manner; however, R protects complex values and does
    so in all situations (not just function calls). Some care has to be taken when
    you want to share back changes, such as invoking a final assignment such as `d2
    <- d` after all desired changes have been made. In our experience, R’s value isolation
    semantics prevents far more issues than the copy-back inconvenience it introduces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `d2` 为 `x` 保留了旧值 `1`。这个特性使得编码非常方便和安全。许多编程语言以这种方式在函数调用中保护引用或指针；然而，R 保护复杂数值，并且在所有情况下都这样做（而不仅仅是函数调用）。当你想要共享回更改时，需要特别注意，例如在所有所需更改完成后调用最终的赋值操作，如
    `d2 <- d`。根据我们的经验，R 的值隔离语义防止了比它引入的复制回传不便更多的问题。
- en: Organizing intermediate values
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 组织中间值
- en: 'Long sequences of calculations can become difficult to read, debug, and maintain.
    To avoid this, we suggest reserving the variable named “`.`” to store intermediate
    values. The idea is this: work slow to move fast. For example: a common data science
    problem is to sort revenue records and then calculate what fraction of total revenue
    is achieved up to a given sorting key. In R this can be done easily by breaking
    this task into small steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 长序列的计算可能会变得难以阅读、调试和维护。为了避免这种情况，我们建议保留变量名 “.” 来存储中间值。想法是这样的：慢慢工作以快速前进。例如：一个常见的数据科学问题是排序收入记录，然后计算达到给定排序键的总收入比例。在
    R 中，可以通过将这个任务分解成小步骤轻松完成：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Our notional, or example, data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的概念性或示例数据。
- en: ❷ Assign our data to a temporary variable named “.”. The original values will
    remain available in the “data” variable, making it easy to restart the calculation
    from the beginning if necessary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将我们的数据赋值给一个名为 “.” 的临时变量。原始值将保留在 “data” 变量中，这使得在必要时从开始重新计算变得容易。
- en: ❸ Use the order command to sort the rows. drop = FALSE is not strictly needed,
    but it is good to get in the habit of including it. For single-column data.frames
    without the drop = FALSE argument, the [,] indexing operator will convert the
    result to a vector, which is almost never the R user's true intent. The drop =
    FALSE argument turns off this conversion, and it is a good idea to include it
    “just in case” and a definite requirement when either the data.frame has a single
    column or when we don’t know if the data.frame has more than one column (as the
    data.frame comes from somewhere else).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 `order` 命令对行进行排序。`drop = FALSE` 并非绝对必要，但养成包含它的习惯是好的。对于不带 `drop = FALSE`
    参数的单列数据框，`[,]` 索引操作符会将结果转换为向量，这几乎不是 R 用户真正的意图。`drop = FALSE` 参数关闭了这种转换，并且包含它是“以防万一”的好主意，并且在数据框只有一列或我们不确定数据框是否有多列（因为数据框来自其他地方）时，这是一个明确的要求。
- en: ❹ Assigns the result away from “.” to a more memorable variable name
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将结果从 “.” 赋值给一个更容易记忆的变量名
- en: The R package `dplyr` replaces the dot notation with what is called *piped notation*
    (supplied by a another package named `magrittr`, and similar to the JavaScript
    method, chaining). Because the `dplyr` is very popular, you are likely to see
    code written in this style, and we will use this style from time to time to help
    prepare you for such code. However, it is important to remember that `dplyr` is
    merely a popular alternative to standard R code, and not a superior alternative.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: R 包 `dplyr` 将点符号替换为所谓的 *管道符号*（由名为 `magrittr` 的另一个包提供，类似于 JavaScript 方法，链式调用）。由于
    `dplyr` 非常受欢迎，你可能会看到用这种风格编写的代码，我们有时会使用这种风格来帮助你为这样的代码做好准备。然而，重要的是要记住，`dplyr` 仅仅是标准
    R 代码的一个流行替代品，而不是一个更优越的替代品。
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each step of this example has been replaced by the corresponding `dplyr` equivalent.
    `arrange()` is `dplyr`’s replacement for `order()`, and `mutate()` is `dplyr`’s
    replacement for assignment. The code translation is line by line, with the minor
    exception that assignment is written first (even though it happens after all other
    steps). The calculation steps are sequenced by the `magrittr` pipe symbol `%>%`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的每一步都已被相应的 `dplyr` 等效项所取代。`arrange()` 是 `dplyr` 对 `order()` 的替代，而 `mutate()`
    是 `dplyr` 对赋值的替代。代码翻译是逐行进行的，唯一的例外是赋值是首先编写的（尽管它发生在所有其他步骤之后）。计算步骤是通过 `magrittr`
    管道符号 `%>%` 顺序排列的。
- en: 'The `magrittr` pipe allows you to write any of `x %>% f`, `x %>% f()`, or `x
    %>% f(.)` in place of `f(x)`. Typically, `x %>% f` is the notation taught: however,
    we feel `x %>% f(.)` is the most explicit in representing what is happening.^([[9](../Text/02.xhtml#ch02fn5)])'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`magrittr` 管道允许你用 `x %>% f`、`x %>% f()` 或 `x %>% f(.)` 代替 `f(x)`。通常，`x %>%
    f` 是教授的符号，然而，我们认为 `x %>% f(.)` 在表示所发生的事情方面最为明确。[^9](../Text/02.xhtml#ch02fn5)]'
- en: ⁹
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For our own work, we actual prefer to use the “dot pipe” `%.>%` from the `wrapr`
    package that enforces more notational consistency.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于我们自己的工作，我们实际上更喜欢使用 `wrapr` 包中的“点管道” `%.>%`，它强制执行更多的符号一致性。
- en: 'The details of the `dplyr` notation can be found here: [http://dplyr.tidyverse.org/articles/dplyr.html](http://dplyr.tidyverse.org/articles/dplyr.html).
    Be aware that debugging long `dplyr` pipelines is difficult, and during development
    and experimentation it makes sense to break `dplyr` pipelines into smaller steps,
    storing intermediate results into temporary variables.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 符号的详细信息可以在以下链接中找到：[http://dplyr.tidyverse.org/articles/dplyr.html](http://dplyr.tidyverse.org/articles/dplyr.html)。请注意，调试长的
    `dplyr` 管道是困难的，在开发和实验过程中，将 `dplyr` 管道分解成更小的步骤，并将中间结果存储到临时变量中是有意义的。'
- en: The intermediate result notation has the advantages that it is easy to both
    restart and step-debug. In this book, we will use different notations as convenient.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 中间结果符号的优点是它既容易重启，也容易逐步调试。在这本书中，我们将根据方便使用不同的符号。
- en: The data.frame class
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.frame` 类'
- en: The R `data.frame` class is designed to store data in a very good “ready for
    analysis” format. `data.frame`s are two-dimensional arrays where each column represents
    a variable, measurement, or fact, and each row represents an individual or instance.
    In this format, an individual cell represents what is known about a single fact
    or variable for a single instance. `data.frame`s are implemented as a named list
    of column vectors (list columns are possible, but they are more of the exception
    than the rule for `data.frame`s). In a `data.frame`, all columns have the same
    length, and this means we can think of the *`k`*th entry of all columns as forming
    a row.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: R 的 `data.frame` 类旨在以非常好的“分析就绪”格式存储数据。`data.frame` 是二维数组，其中每一列代表一个变量、测量或事实，每一行代表一个个体或实例。在这种格式中，单个单元格代表单个实例的单个事实或变量的已知信息。`data.frame`
    实现为列向量的命名列表（列表列是可能的，但它们通常是 `data.frame` 的例外），在 `data.frame` 中，所有列的长度都相同，这意味着我们可以将所有列的
    *`k`* 个条目视为一行。
- en: Operations on `data.frame` columns tend to be efficient and vectorized. Adding,
    looking up, and removing columns is fast. Operations per row on a `data.frame`
    can be expensive, so you should prefer vectorized column notations for large `data.frame`
    processing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `data.frame` 列的操作通常既高效又矢量化。添加、查找和删除列都很快速。在 `data.frame` 上的行操作可能很昂贵，因此对于大型
    `data.frame` 处理，你应该优先选择矢量化列符号。
- en: 'R’s `data.frame` is much like a database table in that it has schema-like information:
    an explicit list of column names and column types. Most analyses are best expressed
    in terms of transformations over `data.frame` columns.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: R 的 `data.frame` 与数据库表非常相似，因为它具有类似模式的信息：一个明确的列名和列类型列表。大多数分析最好用 `data.frame`
    列的转换来表示。
- en: Let R do the work for you
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让 R 为你做工作
- en: 'Most common statistical or data processing operations already have a good implementation
    either in “base R” (R itself and its core packages such as `utils` and `stats`)
    or in an extension package. If you do not delegate to R, you end up fighting R.
    For example, a programmer coming from Java might expect to have to use a for loop
    to add every row of values from two data columns. In R, adding two data columns
    is considered fundamental and achieved as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见的统计或数据处理操作已经在“基础 R”（R 本身及其核心包，如 `utils` 和 `stats`）或扩展包中有了很好的实现。如果你不委托给
    R，你最终会与 R 作对。例如，来自 Java 的程序员可能会期望必须使用 for 循环来添加两个数据列的每一行值。在 R 中，添加两个数据列被认为是基本的，并且如下实现：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`data.frame`s are in fact named lists of columns. We will use them throughout
    the book. In R one tends to work over columns and let R’s vectorized nature perform
    the specified operation over every row at once. If you find yourself iterating
    over rows in R, you are fighting the language.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.frame` 实际上是列的命名列表。我们将在这本书中广泛使用它们。在 R 中，人们倾向于在列上工作，并让 R 的矢量化特性一次性对每一行执行指定的操作。如果你发现自己正在
    R 中逐行迭代，你就是在与语言作对。'
- en: '* * *'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Search for ready-made solutions
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索现成的解决方案
- en: 'Searching for the right R function can be tedious, but it is well worth the
    time (especially if you keep searchable notes). R was designed for data analysis,
    so the most common steps needed in a data analysis have already been implemented
    well in R, though possibly under an obscure name and possibly with odd default
    settings. It is as chemist Frank Westheimer said, “A couple of months in the laboratory
    can frequently save a couple of hours in the library.”^([[10](../Text/02.xhtml#ch02fn6)])
    This is a deliberately ironic restatement of the move-fast-by-working-slow principle:
    researching available solutions costs time, but often saves far more direct coding
    time.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找正确的R函数可能很繁琐，但这是值得花费时间的（尤其是如果你保持可搜索的笔记）。R是为数据分析而设计的，因此数据分析中最常见的步骤已经在R中得到了很好的实现，尽管可能名称不为人知，并且可能有奇特的默认设置。正如化学家弗兰克·韦斯特海默所说，“在实验室里几个月的时间可以经常节省在图书馆里几个小时。”^([[10](../Text/02.xhtml#ch02fn6)])
    这是对快速行动慢思考原则的有意讽刺重述：研究现有解决方案需要时间，但通常可以节省大量的直接编码时间。
- en: ^(10)
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10)
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [https://en.wikiquote.org/wiki/Frank_Westheimer](https://en.wikiquote.org/wiki/Frank_Westheimer).
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 见[https://en.wikiquote.org/wiki/Frank_Westheimer](https://en.wikiquote.org/wiki/Frank_Westheimer)。
- en: '* * *'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 2.2\. Working with data from files
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 从文件中处理数据
- en: The most common ready-to-go data format is in fact a family of tabular formats
    called *structured values*. Most of the data you find will be in (or nearly in)
    one of these formats. When you can read such files into R, you can analyze data
    from an incredible range of public and private data sources. In this section,
    we’ll work on two examples of loading data from structured files, and one example
    of loading data directly from a relational database. The point is to get data
    quickly into R so we can then use R to perform interesting analyses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的现成数据格式实际上是一系列称为*结构化值*的表格格式。你找到的大部分数据都将是这些格式之一（或几乎是这样）。当你能够将这些文件读入R中时，你就可以分析来自各种公共和私人数据源的数据。在本节中，我们将通过两个从结构化文件加载数据的例子和一个直接从关系数据库加载数据的例子来展示。目的是快速将数据导入R，然后我们可以使用R进行有趣的分析。
- en: 2.2.1\. Working with well-structured data from files or URLs
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1\. 从文件或URL中处理结构化数据
- en: The easiest data format to read is table-structured data with headers. As shown
    in [figure 2.2](../Text/02.xhtml#ch02fig02), this data is arranged in rows and
    columns with a header showing the column names. Each column represents a different
    fact or measurement; each row represents an instance or datum about which we know
    the set of facts. A lot of public data is in this format, so being able to read
    it opens up a lot of opportunities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易读取的数据格式是带有标题的表格结构数据。如图2.2所示，这些数据按行和列排列，标题显示列名。每一列代表一个不同的事实或测量；每一行代表一个实例或数据，关于这个实例或数据，我们知道一组事实。大量的公共数据都是这种格式，因此能够读取它会打开很多机会。
- en: Figure 2.2\. Car data viewed as a table
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2\. 以表格形式查看的汽车数据
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig02_alt.jpg)'
- en: 'Before we load the German credit data we used in the previous chapter, let’s
    demonstrate the basic loading commands with a simple dataset originally from the
    University of California Irvine Machine Learning Repository ([http://archive.ics.uci.edu/ml/](http://archive.ics.uci.edu/ml/)).
    The UCI data files tend to come without headers, so to save steps (and to keep
    things simple) we’ve pre-prepared our first data example from the UCI car dataset:
    [http://archive.ics.uci.edu/ml/machine-learning-databases/car/](http://archive.ics.uci.edu/ml/machine-learning-databases/car/).
    Our pre-prepared file is included in the book support directory PDSwR2/UCICar
    (please see section FM.5.6 for instructions) and looks like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们加载上一章中使用的德国信贷数据之前，让我们用一个来自加州大学欧文分校机器学习存储库（[http://archive.ics.uci.edu/ml/](http://archive.ics.uci.edu/ml/））的简单数据集来演示基本的加载命令。UCI数据文件通常没有标题，因此为了节省步骤（并且使事情简单）我们预先准备了我们的第一个数据示例，来自UCI汽车数据集：[http://archive.ics.uci.edu/ml/machine-learning-databases/car/](http://archive.ics.uci.edu/ml/machine-learning-databases/car/)。我们的预准备文件包含在本书支持目录PDSwR2/UCICar中（请参阅第FM.5.6节以获取说明），如下所示：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The header row contains the names of the data columns, in this case separated
    by commas. When the separators are commas, the format is called comma-separated
    values, or .csv.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标题行包含数据列的名称，在这种情况下由逗号分隔。当分隔符是逗号时，这种格式称为逗号分隔值，或.csv。
- en: '❷ The data rows are in the same format as the header row, but each row contains
    actual data values. In this case, the first row represents the set of name/value
    pairs: buying=vhigh, maintenance=vhigh, doors=2, persons=2, and so on.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据行与标题行具有相同的格式，但每一行包含实际的数据值。在这种情况下，第一行代表一组名称/值对：购买=vhigh，维护=vhigh，车门=2，人员=2，等等。
- en: '* * *'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Avoid “by hand” steps outside of R
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在 R 外部手动操作
- en: We strongly encourage you to avoid performing steps “by hand” outside of R when
    importing data. It’s tempting to use an editor to add a header line to a file,
    as we did in our example. A better strategy is to write an R script to perform
    any necessary reformatting. Automating these steps greatly reduces the amount
    of trauma and work during the inevitable data refresh. Receiving new, better data
    should always feel like good news, and writing automated and replicable procedures
    is a big step in this direction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您在 R 外部避免手动执行步骤。使用编辑器向文件添加标题行，就像我们在示例中所做的那样，是很诱人的。更好的策略是编写一个 R 脚本来执行任何必要的格式转换。自动化这些步骤可以大大减少在不可避免的数据刷新过程中的痛苦和工作量。收到新的、更好的数据应该总是感觉像好消息，编写自动化和可重复的程序是朝着这个方向迈出的重要一步。
- en: Our example in [section 2.2.2](../Text/02.xhtml#ch02lev2sec4) will show how
    to add headers without editing files by hand as we did in this example.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 2.2.2 节](../Text/02.xhtml#ch02lev2sec4)的示例中将展示如何在不手动编辑文件的情况下添加标题，就像在这个示例中所做的那样。
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Notice that this presentation is structured like a spreadsheet with easy-to-identify
    rows and columns. Each (non-header) row represents a review of a different model
    of car. The columns represent facts about each car model. Most of the columns
    are objective measurements (purchase cost, maintenance cost, number of doors,
    and so on), and the final subjective column “rating” is marked with the overall
    rating (`vgood`, `good`, `acc`, and `unacc`). These sorts of details come from
    the documentation found with the original data, and are key to projects (so we
    suggest keeping a lab book or notes).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个演示的结构类似于电子表格，具有易于识别的行和列。每一行（非标题行）代表对不同车型的一次评估。列代表关于每个车型的事实。大多数列是客观测量值（购买成本、维护成本、车门数量等），最后的最终主观列“评级”标记为整体评级（`vgood`、`good`、`acc`和`unacc`）。这些细节来自原始数据中的文档，对于项目至关重要（因此我们建议保留实验记录本或笔记）。
- en: Loading well-structured data
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 加载结构良好的数据
- en: 'Loading data of this type into R is a one-liner: we use the R command `utils::read
    .table()` and we’re done.^([[11](../Text/02.xhtml#ch02fn7)]) To work this exercise,
    we assume that you have downloaded and unpacked the contents of this book’s GitHub
    repository [https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2)
    and changed your working directory to PDSwR2/UCICar as explained in section “[Working
    with this book](../Text/FM.xhtml#pref05lev1sec6)” in the front matter (to do this,
    you will use the `setwd()` R function, and you will need to type in the full path
    to where you have saved `PDSwR2`, not just the text fragment we have shown). Once
    R is in the PDSwR2/UCICar directory, reading the data is done as shown in the
    following listing.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将此类数据加载到 R 中是一行代码：我们使用 R 命令 `utils::read .table()` 并完成操作.^([[11](../Text/02.xhtml#ch02fn7)])
    为了完成这个练习，我们假设你已经下载并解压了本书 GitHub 存储库 [https://github.com/WinVector/PDSwR2](https://github.com/WinVector/PDSwR2)
    的内容，并将你的工作目录更改为 PDSwR2/UCICar，正如前言中“[使用本书](../Text/FM.xhtml#pref05lev1sec6)”一节中所述（为此，你将使用
    `setwd()` R 函数，并需要输入你保存 `PDSwR2` 的完整路径，而不仅仅是我们在示例中显示的文本片段）。一旦 R 处于 PDSwR2/UCICar
    目录，读取数据就像以下列表所示。
- en: ^(11)
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11](../Text/02.xhtml#ch02fn7))
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another option is using functions from the `readr` package.
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个选项是使用 `readr` 包中的函数。
- en: Listing 2.1\. Reading the UCI car data
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1\. 读取 UCI 汽车数据
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Command to read from a file or URL and store the result in a new data frame
    object called uciCar
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从文件或URL读取并存储结果为名为 uciCar 的新数据框对象的命令
- en: ❷ Filename or URL to get the data from
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取数据的文件名或 URL
- en: ❸ Specifies the column or field separator as a comma
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定列或字段分隔符为逗号
- en: ❹ Tells R to expect a header line that defines the data column names
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 告诉 R 预期一个标题行来定义数据列名
- en: ❺ Tells R to convert string values to factors. This is the default behavior,
    so we are just using this argument to document intent.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 告诉 R 将字符串值转换为因子。这是默认行为，所以我们只是使用这个参数来记录意图。
- en: ❻ Examines the data with R’s built-in table viewer
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用 R 的内置表格查看器检查数据
- en: '[Listing 2.1](../Text/02.xhtml#ch02ex01) loads the data and stores it in a
    new R data frame object called `uciCar`, which we show a `View()` of in [figure
    2.2](../Text/02.xhtml#ch02fig02).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.1](../Text/02.xhtml#ch02ex01) 加载数据并将其存储在一个新的 R 数据框对象 `uciCar` 中，我们在 [图
    2.2](../Text/02.xhtml#ch02fig02) 中展示了它的 `View()`。'
- en: The `read.table()` command is powerful and flexible; it can accept many different
    types of data separators (commas, tabs, spaces, pipes, and others), and it has
    many options for controlling quoting and escaping data. `read.table()` can read
    from local files or remote URLs. If a resource name ends with the *.gz* suffix,
    `read.table()` assumes the file has been compressed in gzip style and will automatically
    decompress it while reading.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`read.table()` 命令功能强大且灵活；它可以接受许多不同类型的数据分隔符（逗号、制表符、空格、管道和其他），并且有许多选项用于控制引号和数据转义。`read.table()`
    可以从本地文件或远程 URL 读取。如果一个资源名称以 *.gz* 后缀结尾，`read.table()` 假设文件已被 gzip 格式压缩，并在读取时自动解压缩。'
- en: Examining our data
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的数据
- en: 'Once we’ve loaded the data into R, we’ll want to examine it. These are the
    commands to always try first:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将数据加载到 R 中，我们就会想要检查它。以下是一些始终要尝试的命令：
- en: '**`class()`—** Tells you what kind of R object you have. In our case, `class(uciCar)`
    tells us the object `uciCar` is of class `data.frame`. Class is an object-oriented
    concept, which describes how an object is going to behave. R also has a (less
    useful) `typeof()` command, which reveals how the object’s storage is implemented.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`class()`—** 告诉你你有什么样的 R 对象。在我们的例子中，`class(uciCar)` 告诉我们对象 `uciCar` 是 `data.frame`
    类。类是一个面向对象的概念，它描述了一个对象将如何行为。R 还有一个（不太有用）的 `typeof()` 命令，它揭示了对象存储的实现方式。'
- en: '**`dim()`—** For data frames, this command shows how many rows and columns
    are in the data.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`dim()`—** 对于数据框，此命令显示数据中有多少行和列。'
- en: '**`head()`—** Shows the top few rows (or “head”) of the data. Example: `head(uciCar)`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`head()`—** 显示数据的前几行（或“头部”）。示例：`head(uciCar)`。'
- en: '**`help()`—** Provides the documentation for a class. In particular, try `help(class
    (uciCar))`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`help()`—** 提供类的文档。特别是尝试 `help(class (uciCar))`。'
- en: '**`str()`—** Gives you the structure for an object. Try `str(uciCar)`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`str()`—** 提供了对象的架构。尝试 `str(uciCar)`。'
- en: '**`summary()`—** Provides a summary of almost any R object. `summary(uciCar)`
    shows us a lot about the distribution of the UCI car data.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`summary()`—** 提供几乎所有 R 对象的摘要。`summary(uciCar)` 显示了 UCI 汽车数据的分布情况。'
- en: '**`print()`—** Prints all the data. Note: for large datasets, this can take
    a very long time and is something you want to avoid.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`print()`—** 打印所有数据。注意：对于大型数据集，这可能需要非常长的时间，并且是你想要避免的。'
- en: '**`View()`—** Displays the data in a simple spreadsheet-like grid viewer.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`View()`—** 以简单的电子表格样式的网格查看器显示数据。'
- en: '* * *'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Many R functions are generic
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 R 函数是通用的
- en: Many R functions are generic in that they work much the same on many data types,
    or even object-oriented in that they pick a correct behavior depending on the
    runtime class of the object they are working with. We suggest that if you see
    a function used in an example on one object or class, try it on others. Common
    R functions that can be used on many different classes and types include `length()`,
    `print()`, `saveRDS()`, `str()`, and `summary()`. The R runtime is very robust
    and rewards experimentation. Most common errors are caught and cannot corrupt
    your data or crash the R interpreter. So please, experiment!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 R 函数是通用的，因为它们在许多数据类型上工作方式几乎相同，或者甚至是面向对象的，因为它们根据它们正在处理的对象的运行时类选择正确的行为。我们建议如果你在一个对象的例子中看到某个函数被使用，尝试在其他对象上使用它。可以在许多不同类和类型上使用的常见
    R 函数包括 `length()`、`print()`、`saveRDS()`、`str()` 和 `summary()`。R 运行时非常健壮，并奖励实验。大多数常见错误都会被捕获，并且不能破坏你的数据或使
    R 解释器崩溃。所以，请实验吧！
- en: '* * *'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We show the results of a few of these steps next (R results are shown prefixed
    by “##” after each step).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将展示这些步骤的一些结果（R 结果在每个步骤后以“##”为前缀显示）。
- en: Listing 2.2\. Exploring the car data
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2\. 探索汽车数据
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The loaded object uciCar is of type data.frame.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载的对象 uciCar 是数据框类型。
- en: '❷ [1] is merely an output sequence marker. The actual information is this:
    uciCar has 1728 rows and 7 columns. Always try to confirm you got a good parse
    by at least checking that the number of rows is exactly one fewer than the number
    of lines of text in the original file. The difference of one is because the column
    header counts as a line of text, but not as a data row.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ [1] 仅仅是一个输出序列标记。实际信息如下：uciCar 有 1728 行和 7 列。始终尝试通过至少检查行数是否正好比原始文件中的文本行数少一行来确认您已正确解析。差一的原因是列标题算作一行文本，但不算作数据行。
- en: The `summary()` command shows us the distribution of each variable in the dataset.
    For example, we know each car in the dataset was declared to seat `2`, `4`, or
    `more` persons, and we know there were 576 two-seater cars in the dataset. Already
    we’ve learned a lot about our data, without having to spend a lot of time manually
    building pivot tables as we would have to in a spreadsheet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()`命令显示了数据集中每个变量的分布。例如，我们知道数据集中的每辆车都被声明为可容纳`2`、`4`或`更多`人，我们还知道数据集中有576辆两座车。我们已经从数据中了解了很多，而无需花费大量时间手动构建像在电子表格中那样必须构建的交叉表。'
- en: Working with other data formats
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 处理其他数据格式
- en: '.csv is not the only common data file format you’ll encounter. Other formats
    include .tsv (tab-separated values), pipe-separated (vertical bar) files, Microsoft
    Excel workbooks, JSON data, and XML. R’s built-in `read.table()` command can be
    made to read most separated value formats. Many of the deeper data formats have
    corresponding R packages:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: .csv并不是你将遇到的唯一常见数据文件格式。其他格式包括.tsv（制表符分隔值）、管道分隔（竖线）文件、Microsoft Excel工作簿、JSON数据和XML。R的内置`read.table()`命令可以读取大多数分隔值格式。许多更深层的数据格式都有相应的R包：
- en: '***CSV/TSV/FWF—*** The package `reader` ([http://readr.tidyverse.org](http://readr.tidyverse.org))
    supplies tools for reading “separated data” such as comma-separated values (CSV),
    tab-separated values (TSV), and fixed-width files (FWF).'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***CSV/TSV/FWF—*** 包`reader`([http://readr.tidyverse.org](http://readr.tidyverse.org))提供了读取“分隔数据”的工具，如逗号分隔值（CSV）、制表符分隔值（TSV）和固定宽度文件（FWF）。'
- en: '***SQL—*** [https://CRAN.R-project.org/package=DBI](https://CRAN.R-project.org/package=DBI)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***SQL—*** [https://CRAN.R-project.org/package=DBI](https://CRAN.R-project.org/package=DBI)'
- en: '***XLS/XLSX—*** [http://readxl.tidyverse.org](http://readxl.tidyverse.org)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***XLS/XLSX—*** [http://readxl.tidyverse.org](http://readxl.tidyverse.org)'
- en: '***.RData/.RDS—*** R has binary data formats (which can avoid complications
    of parsing, quoting, escaping, and loss of precision in reading and writing numeric
    or floating-point data as text). The .RData format is for saving sets of objects
    and object names, and is used through the `save()`/`load()` commands. The .RDS
    format is for saving single objects (without saving the original object name)
    and is used through the `saveRDS()`/`readRDS()` commands. For ad hoc work, .RData
    is more convenient (as it can save the entire R workspace), but for reusable work,
    the .RDS format is to be preferred as it makes saving and restoring a bit more
    explicit. To save multiple objects in .RDS format, we suggest using a *named list*.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***.RData/.RDS—*** R有二进制数据格式（可以避免解析、引号、转义和以文本形式读取和写入数值或浮点数据时的精度损失等复杂问题）。.RData格式用于保存对象集和对象名称，并通过`save()`/`load()`命令使用。.RDS格式用于保存单个对象（不保存原始对象名称）并通过`saveRDS()`/`readRDS()`命令使用。对于临时工作，.RData更方便（因为它可以保存整个R工作空间），但对于可重用工作，.RDS格式更可取，因为它使得保存和恢复更加明确。为了以.RDS格式保存多个对象，我们建议使用*命名列表*。'
- en: '***JSON—*** [https://CRAN.R-project.org/package=rjson](https://CRAN.R-project.org/package=rjson)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***JSON—*** [https://CRAN.R-project.org/package=rjson](https://CRAN.R-project.org/package=rjson)'
- en: '***XML—*** [https://CRAN.R-project.org/package=XML](https://CRAN.R-project.org/package=XML)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***XML—*** [https://CRAN.R-project.org/package=XML](https://CRAN.R-project.org/package=XML)'
- en: '***MongoDB—*** [https://CRAN.R-project.org/package=mongolite](https://CRAN.R-project.org/package=mongolite)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***MongoDB—*** [https://CRAN.R-project.org/package=mongolite](https://CRAN.R-project.org/package=mongolite)'
- en: 2.2.2\. Using R with less-structured data
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2\. 使用R处理非结构化数据
- en: Data isn’t always available in a ready-to-go format. Data curators often stop
    just short of producing a ready-to-go machine-readable format. The German bank
    credit dataset discussed in [chapter 1](../Text/01.xhtml#ch01) is an example of
    this. This data is stored as tabular data without headers; it uses a cryptic coding
    of values that requires the dataset’s accompanying documentation to untangle.
    This isn’t uncommon and is often due to habits or limitations of other tools that
    commonly work with the data. Instead of reformatting the data before we bring
    it into R, as we did in the last example, we’ll now show how to reformat the data
    using R. This is a much better practice, as we can save and reuse the R commands
    needed to prepare the data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 数据并不总是以现成的格式存在。数据管理员通常只是差一点就能制作出现成的机器可读格式。在[第1章](../Text/01.xhtml#ch01)中讨论的德国银行信贷数据集就是一个例子。这些数据以无标题的表格形式存储；它使用了一种神秘的编码方式，需要数据集的配套文档来解开。这种情况并不少见，通常是由于其他常用工具的习惯或限制造成的。在我们将数据带入R之前重新格式化数据，就像我们在上一个例子中所做的那样，我们现在将展示如何使用R来重新格式化数据。这是一个更好的实践，因为我们可以保存并重用准备数据所需的R命令。
- en: 'Details of the German bank credit dataset can be found at [http://mng.bz/mZbu](http://mng.bz/mZbu),
    and we have included a copy of this data in the directory PDSwR2/Statlog. We’ll
    show how to transform this data into something meaningful using R. After these
    steps, you can perform the analysis already demonstrated in [chapter 1](../Text/01.xhtml#ch01).
    As we can see in our file excerpt, the data appears to initially be an incomprehensible
    block of codes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 德国银行信贷数据集的详细信息可以在 [http://mng.bz/mZbu](http://mng.bz/mZbu) 找到，我们已经在 PDSwR2/Statlog
    目录中包含了这个数据集的副本。我们将展示如何使用 R 将这些数据转换成有意义的格式。完成这些步骤后，您可以执行 [第 1 章](../Text/01.xhtml#ch01)
    中已展示的分析。正如我们可以在我们的文件摘录中看到的那样，数据最初似乎是一块难以理解的代码块：
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Transforming data in R
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中转换数据
- en: Data often needs a bit of transformation before it makes sense. In order to
    decrypt troublesome data, you need what’s called the *schema documentation* or
    a *data dictionary*. In this case, the included dataset description says the data
    is 20 input columns followed by one result column. In this example, there’s no
    header in the data file. The column definitions and the meaning of the cryptic
    `A`-* codes are all in the accompanying data documentation. Let’s start by loading
    the raw data into R. Start a copy of R or RStudio and type in the commands in
    the following listing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常需要一些转换才能变得有意义。为了解密麻烦的数据，你需要所谓的 *模式文档* 或 *数据字典*。在这种情况下，包含的数据集描述说明数据有20个输入列，后面跟着一个结果列。在这个例子中，数据文件中没有标题。列定义和神秘的
    `A`-* 代码的含义都在随附的数据文档中。让我们首先将原始数据加载到 R 中。启动 R 或 RStudio 的副本，并输入以下列表中的命令。
- en: Listing 2.3\. Loading the credit dataset
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3\. 加载信贷数据集
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Replace this path with the actual path where you have saved PDSwR2.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将此路径替换为您保存 PDSwR2 的实际路径。
- en: As there was no column header in the file, our data.frame `d` will have useless
    column names of the form `V#`. We can change the column names to something meaningful
    with the `c()` command, as shown in the following listing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件中没有列标题，我们的数据框 `d` 将会有无用的列名形式 `V#`。我们可以使用 `c()` 命令将这些列名更改为有意义的名称，如下所示。
- en: Listing 2.4\. Setting column names
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4\. 设置列名
- en: '[PRE16]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `c()` command is R’s method to construct a vector.^([[12](../Text/02.xhtml#ch02fn8)])
    We copied the column names directly from the dataset documentation. By assigning
    our vector of names into the data frame’s `colnames()`, we’ve reset the data frame’s
    column names to something sensible.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`c()` 命令是 R 构造向量的方法.^([[12](../Text/02.xhtml#ch02fn8)]) 我们直接从数据集文档中复制了列名。通过将我们的名称向量分配给数据框的
    `colnames()`，我们已经将数据框的列名重置为有意义的名称。'
- en: ^(12)
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12)
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`c()` also concatenates lists or vectors, without introducing additional nesting.'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`c()` 还可以连接列表或向量，而不引入额外的嵌套。'
- en: '* * *'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Assigning to accessors
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给访问器
- en: In R the data frame class has a number of data accessors such as `colnames()`
    and `names()`. Many of these data accessors can be assigned to, as we saw when
    we assigned new names in [listing 2.3](../Text/02.xhtml#ch02ex03) with `colnames(d)
    <- c('Status_of_existing_checking_account', ...)`. This ability to assign into
    accessors is a bit unusual, but a very useful feature of R.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，数据框类有多个数据访问器，如 `colnames()` 和 `names()`。我们像在 [列表 2.3](../Text/02.xhtml#ch02ex03)
    中使用 `colnames(d) <- c('Status_of_existing_checking_account', ...)` 分配新名称时看到的那样，许多这些数据访问器可以被分配。这种将值分配给访问器的功能在
    R 中有点不寻常，但是一个非常有用的特性。
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'The data documentation further tells us the column names, and also has a code
    dictionary of the meanings of all of the cryptic `A`-* codes. For example, it
    says in column 4 (now called *Purpose*, meaning the purpose of the loan) that
    the code `A40` is a “new car loan,” `A41` is a “used car loan,” and so on. We
    can use R’s list-mapping capabilities to remap the values to more descriptive
    terms. The file PDSwR2/Statlog/GCDSteps.Rmd is an R Markdown that includes all
    the steps up through now and also remaps the values from the `A#` forms to clearer
    names. The file first implements the dataset documentation’s value mapping as
    an R named vector. This allows us to change the illegible names (such as `A11`)
    into somewhat meaningful descriptions (such as `... < 0 DM`, which itself is presumably
    shorthand for “zero or fewer deutsche marks reported”).^([[13](../Text/02.xhtml#ch02fn9)])
    The first few lines of this map definition look like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 数据文档还告诉我们列名，并且还有一个所有神秘`A`-*代码含义的代码字典。例如，它说在第4列（现在称为*Purpose*，表示贷款的目的）中，代码`A40`是“新车贷款”，`A41`是“二手车贷款”，等等。我们可以使用R的列表映射功能将值重新映射到更描述性的术语。文件PDSwR2/Statlog/GCDSteps.Rmd是一个R
    Markdown文件，它包含了到目前为止的所有步骤，并将`A#`形式的值重新映射到更清晰的名字。该文件首先将数据集文档的值映射实现为一个R命名向量。这使得我们可以将难以辨认的名字（如`A11`）改为更有意义的描述（如`...
    < 0 DM`，这本身可能是“报告零或更少德国马克”的缩写）。^([[13](../Text/02.xhtml#ch02fn9)]) 此映射定义的前几行如下所示：
- en: ^(13)
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13)
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: German currency at the time of data collection was the deutsche mark (DM).
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据收集时的德国货币是德国马克（DM）。
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note: In building a named map, you must use the argument binding symbol `=`,
    and not any of the assignment operators such as `<-`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在构建命名映射时，必须使用参数绑定符号`=`，而不是任何赋值运算符，如`<-`。
- en: With the mapping list defined, we can then use the following for loop to convert
    values in each column that was of type `character` from the original cryptic `A`-*
    codes into short level descriptions taken directly from the data documentation.
    We, of course, skip any such transform for columns that contain numeric data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了映射列表后，我们可以使用以下for循环将每列中类型为`character`的值从原始的神秘`A`-*代码转换为直接从数据文档中获取的简短级别描述。当然，对于包含数值数据的列，我们跳过任何此类转换。
- en: Listing 2.5\. Transforming the car data
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5\. 转换汽车数据
- en: '[PRE18]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ This file can be found at [https://github.com/WinVector/PDSwR2/blob/master/Statlog/mapping.R](https://github.com/WinVector/PDSwR2/blob/master/Statlog/mapping.R).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此文件可在[https://github.com/WinVector/PDSwR2/blob/master/Statlog/mapping.R](https://github.com/WinVector/PDSwR2/blob/master/Statlog/mapping.R)找到。
- en: ❷ Prefer using column names to column indices.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 建议使用列名而不是列索引。
- en: '❸ The [ [ ] ] notation is using the fact that data.frames are named lists of
    columns. So we are working on each column in turn. Notice the mapping lookup is
    vectorized: it is applied to all elements in the column in one step.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用[[ [ ]] ]]表示法是利用数据框是列命名的列表这一事实。因此，我们依次处理每一列。请注意，映射查找是向量化的：它一次性应用于列中的所有元素。
- en: As we mentioned, the complete set of column preparations for this is in the
    R Markdown file PDSwR2/Statlog/GCDSteps.Rmd. We encourage readers to examine this
    file and try all of these steps themselves. For convenience, the prepared data
    is saved in PDSwR2/Statlog/creditdata.RDS.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，完整的列准备集在R Markdown文件PDSwR2/Statlog/GCDSteps.Rmd中。我们鼓励读者检查此文件并尝试所有这些步骤。为了方便，准备好的数据已保存在PDSwR2/Statlog/creditdata.RDS中。
- en: Examining our new data
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的新数据
- en: We can now easily examine the purpose of the first three loans with the command
    `print(d[1:3,'Purpose'])`. We can look at the distribution of loan purpose with
    `summary(d$Purpose)`. This summary is why we converted the values into factors,
    as `summary()` does not report much for string/character types, though we could
    also use `table(d$Purpose, useNA = "always")` directly on character types. We
    can also start to investigate the relation of loan type to loan outcome, as shown
    in the following listing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地使用命令`print(d[1:3,'Purpose'])`检查前三笔贷款的目的。我们可以使用`summary(d$Purpose)`查看贷款目的的分布。这就是为什么我们将值转换为因子，因为`summary()`对于字符串/字符类型报告不多，尽管我们也可以直接在字符类型上使用`table(d$Purpose,
    useNA = "always")`。我们还可以开始研究贷款类型与贷款结果之间的关系，如下面的列表所示。
- en: Listing 2.6\. Summary of `Good_Loan` and `Purpose`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6\. `Good_Loan`和`Purpose`的摘要
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Sets the working directory. You will have to replace PDSwR2/Statlog with the
    actual full path to Statlog on your machine.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置工作目录。您需要将PDSwR2/Statlog替换为您机器上Statlog的实际完整路径。
- en: ❷ Reads the prepared statlog data
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 读取准备好的statlog数据
- en: From the output, we can see we have successfully loaded the data from the file.
    However, as mentioned, a lot of data is in other sources such as Excel spreadsheets
    (with the `readxl` package, these can be treated much like the way one works with
    files) and in databases (including big data systems such as Apache Spark). We
    will next discuss working with relational databases through the SQL query language
    and the DBI package.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到我们已经成功地将数据从文件中加载。然而，正如之前提到的，大量数据存储在其他来源，如Excel电子表格（使用`readxl`包，这些可以像处理文件一样处理）和数据库中（包括Apache
    Spark等大数据系统）。接下来，我们将讨论通过SQL查询语言和DBI包与关系数据库一起工作。
- en: 2.3\. Working with relational databases
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. 与关系数据库一起工作
- en: In many production environments, the data you want lives in a relational or
    SQL database, not in files. Public data is often in files (as they are easier
    to share), but your most important client data is often in databases. Relational
    databases scale easily to hundreds of millions of records and supply important
    production features such as parallelism, consistency, transactions, logging, and
    audits. Relational databases are designed to support online transaction processing
    (OLTP), so they’re likely where transactions you need to know about were actually
    produced.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多生产环境中，你想要的数据存储在关系或SQL数据库中，而不是文件中。公共数据通常存储在文件中（因为它们更容易共享），但你的最重要的客户数据通常存储在数据库中。关系数据库可以轻松扩展到数亿条记录，并提供重要的生产功能，如并行处理、一致性、事务、日志和审计。关系数据库旨在支持在线事务处理（OLTP），因此它们很可能是你需要了解的交易实际产生的位置。
- en: Often you can export the data into a structured file and use the methods from
    our previous sections to then transfer the data into R. But this is generally
    not the right way to do things. Exporting from databases to files is often unreliable
    and idiosyncratic due to loss of schema information, escaping, quoting, and character-encoding
    issues. The best way to work with data found in databases is to connect R directly
    to the database, which is what we’ll demonstrate in this section.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以将数据导出为结构化文件，然后使用我们之前章节中的方法将数据传输到R中。但这种方法通常不是处理数据的正确方式。由于模式信息丢失、转义、引号和字符编码问题，从数据库导出到文件通常不可靠且具有特殊性。与数据库中找到的数据的最佳工作方式是直接将R连接到数据库，这正是我们将在本节中演示的内容。
- en: As a step of the demonstration, we’ll first show how to load data into a database.
    Relational databases are a good place for transformations such as joins or sampling
    (though packages such as `sqldf` and `dplyr` give R similar capabilities), which
    will be the topic of [chapter 5](../Text/05.xhtml#ch05). We will start working
    with data in a database for our next example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示的一部分，我们首先将展示如何将数据加载到数据库中。关系数据库是进行诸如连接或采样等转换的好地方（尽管`sqldf`和`dplyr`等包为R提供了类似的功能），这将是第5章的主题。我们将从数据库中的数据开始我们的下一个示例。
- en: 2.3.1\. A production-size example
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1\. 一个生产规模的示例
- en: For our production-size example, we’ll use the 2016 United States Census American
    Community Survey (ACS) Public Use Microdata Sample (PUMS) data, often called “ACS
    PUMS.” We have documentation on how to download and prepare a sample of this data
    in the dictionary `PDSwR2/PUMS/download`. We also have a ready-to-work-with recoded
    sample in the R-data file PDSwR2/PUMS/PUMSsample.RDS, allowing you to skip the
    initial download and processing steps.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的生产规模示例，我们将使用2016年美国人口普查美国社区调查（ACS）公共使用微观数据样本（PUMS）数据，通常称为“ACS PUMS”。我们在字典`PDSwR2/PUMS/download`中有关于如何下载和准备该数据样本的文档。我们还有一个准备好的R数据文件PDSwR2/PUMS/PUMSsample.RDS，允许你跳过初始下载和处理步骤。
- en: 'The PUMS data is ideal for setting up somewhat realistic data science scenarios:
    summarizing data and building models predicting one column of the data from other
    columns. We will return to this dataset later in this book.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: PUMS数据非常适合设置相对现实的数据科学场景：汇总数据和构建模型，从其他列预测数据的一列。我们将在本书的后面部分回到这个数据集。
- en: 'The PUMS is a remarkable set of data involving around 3 million individuals
    and 1.5 million households. It is one of the few shared United States Census datasets
    that deals with individual people and households (instead of per-region summaries).
    This is important, as most common data science tasks are designed to use detailed
    per-individual records, so this is public data that is most like the private data
    a data scientist would work with. Each row contains over 200 facts about each
    individual or household (income, employment, education, number of rooms, and so
    on). The data has household cross-reference IDs so individuals can be joined to
    the household they’re in. The size of the dataset is interesting: a few gigabytes
    when compressed. So it’s small enough to store on a good network or thumb drive,
    but larger than is convenient to work with on a laptop with R in memory (which
    is more comfortable when working in the range of hundreds of thousands of rows).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: PUMS 是一组非常出色的数据，涉及大约 300 万人和 150 万个家庭。它是少数几个共享的美国人口普查数据集之一，涉及个人和家庭（而不是按地区汇总）。这一点很重要，因为大多数常见的数据科学任务都是设计用来使用详细的个人记录，因此这是最像数据科学家会处理的数据的公共数据。每一行包含关于每个个人或家庭的
    200 多个事实（收入、就业、教育、房间数量等）。数据包含家庭交叉引用 ID，因此个人可以与所在的 household 关联。数据集的大小很有趣：压缩后只有几吉字节。因此，它足够小，可以存储在良好的网络上或闪存驱动器上，但比在笔记本电脑上使用
    R 进行内存操作（在处理数十万行数据时更为舒适）更方便。
- en: '* * *'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summaries or marginals
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要或边缘数据
- en: Moving from individual-oriented data to summaries or marginals is an easy process
    called *summary statistics* or *basic analytics*. Converting the other way is
    often not possible, or at best a deep statistical problem (beyond the scope of
    basic data science). Most United States Census data is shared as regional summaries,
    so it often requires sophisticated statistical imputation methodology to generate
    useful individual-level predictive models. The PUMS data is very useful because
    it is individually oriented.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从面向个人的数据到摘要或边缘数据的转换是一个简单的过程，称为 *汇总统计* 或 *基本分析*。反向转换通常是不可能的，或者最多是一个深度的统计问题（超出了基本数据科学的范围）。大多数美国人口普查数据都是以地区汇总的形式共享的，因此通常需要复杂的统计插补方法来生成有用的个人级预测模型。PUMS
    数据非常有用，因为它面向个人。
- en: '* * *'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Tens of millions of rows is a sweet spot size for relational database or SQL-assisted
    analysis on a single machine. We’re not yet forced to move into a database cluster
    or a Apache Spark cluster to do our work.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 数百万行数据是关系数据库或 SQL 辅助的单机分析的理想大小。我们还没有被迫进入数据库集群或 Apache Spark 集群来完成我们的工作。
- en: Curating the data
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数据
- en: A hard rule of science is that you must be able to reproduce your results. At
    the very least, you should be able to repeat your own successful work through
    your recorded steps. Everything must either have directions on how to produce
    it or clear documentation on where it came from. We call this the “no alien artifacts”
    discipline. For example, when we said we’re using PUMS American Community Survey
    data, this statement isn’t precise enough for anybody to know what data we specifically
    mean. Our actual notebook entry (which we keep online, so we can search it) on
    the PUMS data is shown in the next listing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 科学的一个硬性规则是，你必须能够重现你的结果。至少，你应该能够通过你记录的步骤重复你自己的成功工作。一切都必须有如何生产的说明或清晰的来源文档。我们称这为“无外来物品”的学科。例如，当我们说我们正在使用
    PUMS 美国社区调查数据时，这个声明并不足够精确，以至于任何人都不清楚我们具体指的是什么数据。我们关于 PUMS 数据的实际笔记本条目（我们将其保存在线上，以便我们可以搜索）将在下一列表中展示。
- en: Listing 2.7\. PUMS data provenance documentation (PDSwR2/PUMS/download/LoadPUMS.Rmd)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7\. PUMS 数据来源文档（PDSwR2/PUMS/download/LoadPUMS.Rmd）
- en: '[PRE20]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ When we downloaded the data
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当我们下载数据时
- en: ❷ Where we found the data documentation. This is important to record, as many
    data files don’t contain links back to the documentation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们找到数据文档的地方。记录这一点很重要，因为许多数据文件不包含指向文档的链接。
- en: ❸ The exact steps we took
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们采取的精确步骤
- en: ❹ Cryptographic hashes of the file contents we downloaded. These are very short
    summaries (called hashes) that are highly unlikely to have the same value for
    different files. These summaries can later help us determine if another researcher
    in our organization is using the same data.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们下载的文件内容的加密哈希值。这些是非常短的摘要（称为哈希值），不同文件具有相同值的可能性极低。这些摘要可以后来帮助我们确定我们组织中的另一位研究人员是否正在使用相同的数据。
- en: '* * *'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Keep notes
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 记录笔记
- en: A big part of being a data scientist is being able to defend your results and
    repeat your work. We strongly advise keeping local copies of data and keeping
    a notebook. Notice that in [listing 2.7](../Text/02.xhtml#ch02ex07) we not only
    show how and when we got the data, we also show what cryptographic hash the download
    had at the time. This is important to help ensure reproducible results and also
    to diagnose if and where something has changed. We also strongly advise keeping
    all of your scripts and code under version control, as we'll discuss in [chapter
    11](../Text/11.xhtml#ch11). You absolutely need to be able to answer exactly what
    code and which data were used to build results you presented last week.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 成为数据科学家的一个重要部分是能够捍卫你的结果并重复你的工作。我们强烈建议保留数据的本地副本并保持一个笔记本。注意，在[列表 2.7](../Text/02.xhtml#ch02ex07)中，我们不仅展示了我们如何以及何时获取数据，还展示了当时下载的加密哈希值。这对于确保可重复的结果以及诊断是否以及在哪里发生了变化非常重要。我们还强烈建议将所有脚本和代码置于版本控制之下，我们将在第
    11 章中讨论。你绝对需要能够确切回答上周你展示的结果使用了哪些代码和哪些数据。
- en: A particularly important form of note maintenance is using Git source control,
    which we will discuss in [chapter 11](../Text/11.xhtml#ch11).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的笔记维护形式是使用 Git 源代码控制，我们将在第 11 章中讨论。
- en: '* * *'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: Starting with the PUMS data
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PUMS 数据开始
- en: 'It is important to at least skim the downloaded PUMS data documentation: PDSwR2/PUMS/ACS2016_PUMS_README.pdf
    (a file that was in the downloaded zip container) and PDSwR2/PUMS/PUMSDataDict16.txt
    (one of the files we downloaded). Three things stand out: the data is distributed
    as comma-separated structured files with column headers, the values are coded
    as indecipherable integers (much like our earlier `Statlog` example), and the
    individuals are weighted to represent varying numbers of additional households.
    The R Markdown^([[14](../Text/02.xhtml#ch02fn10)]) script PDSwR2/PUMS/download/LoadPUMS.Rmd
    reads the CSV files (from a compressed intermediate file), recodes the values
    to more-meaningful strings, and takes a pseudo-random sample of the data with
    probabilities proportional to the specified household sampling weights. The proportional
    sampling both cuts the file size down to around 10 megabytes (a size easy to be
    distributed through GitHub) and builds a sample that can be used in a statistically
    correct manner, without further reference to the Census weights.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 至少浏览一下下载的 PUMS 数据文档很重要：PDSwR2/PUMS/ACS2016_PUMS_README.pdf（一个位于下载的 zip 容器中的文件）和
    PDSwR2/PUMS/PUMSDataDict16.txt（我们下载的文件之一）。三个突出点：数据以逗号分隔的格式化文件形式分布，值以难以辨认的整数编码（类似于我们早期的`Statlog`示例），个人被加权以代表不同数量的额外家庭。R
    Markdown^([[14](../Text/02.xhtml#ch02fn10)])脚本PDSwR2/PUMS/download/LoadPUMS.Rmd读取
    CSV 文件（从一个压缩的中间文件中），将值重新编码为更有意义的字符串，并使用与指定家庭抽样权重成比例的概率对数据进行伪随机抽样。成比例的抽样不仅将文件大小减少到大约
    10 兆字节（一个易于通过 GitHub 分发的尺寸），而且构建了一个可以以统计正确的方式使用的样本，无需进一步参考人口普查权重。
- en: ^(14)
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^((14))
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will discuss R Markdown later in this book. It is an important format for
    storing both R code and text documentation together.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在本书的后面讨论 R Markdown。它是一种重要的格式，可以一起存储 R 代码和文本文档。
- en: '* * *'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: Sampling
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 抽样
- en: 'When we say “pseudo-random sample,” we simply mean a sample built from R’s
    pseudo-random number generator. R’s random number generator is called “pseudo-random”
    as it is actually a deterministic sequence of choices that are hoped to be hard
    to predict and thus behave much like a truly random unpredictable sample. Pseudo-random
    samples are good to work with as they are repeatable: start the pseudo-random
    generator with the same seed, and you get the same sequences of choices. Prior
    to the widespread availability of digital computers, statisticians used to achieve
    this repeatability by using pre-prepared tables such as Rand Corporation’s 1955
    book *A Million Random Digits with 100,000 Normal Deviates*. The intent is that
    a random sample should have properties very similar to the total population. The
    more common the feature you are working with, the more often this is in fact true.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“伪随机样本”时，我们只是指由R的伪随机数生成器构建的样本。R的随机数生成器被称为“伪随机”，因为它实际上是一系列希望难以预测的选择，其行为与真正的随机不可预测样本非常相似。伪随机样本易于处理，因为它们是可重复的：用相同的种子启动伪随机生成器，你将得到相同的序列选择。在数字计算机广泛可用之前，统计学家通常通过使用预先准备好的表格（如兰德公司1955年的书籍《一百万个随机数字及十万个正态偏差》）来实现这种可重复性。目的是使随机样本具有与总体非常相似的属性。你正在处理的特征越常见，这种情况就越有可能发生。
- en: 'Note: Some care must be taken around the repeatability of pseudo-random experiments.
    A number of things can interfere with the exact reproduction of pseudo-random
    samples and results. For example, using a different order of operation can produce
    different results (especially in the case of parallel algorithms), and R itself
    changed details of its pseudo-random number when it moved from version 3.5.* (used
    in the preparation of this book) to 3.6.* (the next version of R). As with things
    like floating-point representations, one must sometimes accept equivalent results
    in place of exactly identical results.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在伪随机实验的可重复性方面必须小心谨慎。许多因素可能会干扰伪随机样本和结果的精确再现。例如，使用不同的操作顺序可能会产生不同的结果（尤其是在并行算法的情况下），而且R在从版本3.5.*（本书的准备工作所使用的版本）迁移到3.6.*（R的下一个版本）时，其伪随机数的细节也发生了变化。与浮点表示法类似，有时我们必须接受等效结果而不是完全相同的结果。
- en: '* * *'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Structured data at a scale of millions of rows is best handled in a database,
    though R and the `data.table` package also work well at this scale. We will simulate
    working with data that lives in a database by copying our PUMS sample into an
    in-memory database, as shown next.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在数百万行数据的规模上，结构化数据最好在数据库中处理，尽管R和`data.table`包在这个规模上也能很好地工作。我们将通过将我们的PUMS样本复制到内存数据库中来模拟在数据库中处理数据，如下所示。
- en: Listing 2.8\. Loading data into R from a relational database
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8\. 从关系数据库将数据加载到R中
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Attaches some packages we wish to use commands and functions from.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 附上我们希望使用命令和函数的一些包。
- en: '❷ Loads the data from the compressed RDS disk format into R memory. Note: You
    will need to change the path PUMSsample to where you have saved the contents of
    PDSwR2/PUMS.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将压缩的RDS磁盘格式中的数据加载到R内存中。注意：您需要将路径PUMSsample更改为您保存PDSwR2/PUMS内容的路径。
- en: ❸ Connects to a new RSQLite in-memory database. We will use RSQLite for our
    examples. In practice you would connect to a preexisting database, such as PostgreSQL
    or Spark, with preexisting tables.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 连接到一个新的RSQLite内存数据库。我们将使用RSQLite作为我们的示例。在实际应用中，你会连接到一个预存在的数据库，例如PostgreSQL或Spark，以及预存在的表。
- en: ❹ Copies the data from the in-memory structure dlist into the database
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将内存中的结构dlist中的数据复制到数据库中
- en: ❺ Removes our local copy of the data, as we are simulating having found the
    data in the database
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 删除我们的本地数据副本，因为我们正在模拟在数据库中找到数据
- en: ❻ Uses the SQL query language for a quick look at up to five rows of our data
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用SQL查询语言快速查看我们数据的前五行
- en: ❻ Builds dplyr handles that refer to the remote database data
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ dplyr构建的引用远程数据库数据的处理程序
- en: ❽ Uses dplyr to examine and work with the remote data
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用dplyr检查和操作远程数据
- en: ❾ Uses the rquery package to get a summary of the remote data
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 使用rquery包获取远程数据的摘要
- en: In this listing, we have deliberately not shown any of the results the commands
    produce, as we would like you to try this example yourself.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们故意没有显示命令产生的任何结果，因为我们希望你自己尝试这个示例。
- en: '* * *'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Code examples
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例
- en: All code examples from this book are available in the directory PDSwR2/CodeExamples.
    Taking code from this directory can be easier than retyping it and more reliable
    than copying and pasting from an electronic copy of the book (avoiding issues
    of page breaks, character encodings, and formatting glitches such as smart quotes).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有代码示例都可在 PDSwR2/CodeExamples 目录中找到。从该目录中取代码可能比重新输入它更容易，也比从书的电子副本中复制粘贴更可靠（避免页面中断、字符编码和格式错误等问题）。
- en: '* * *'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note that this data, while small, is out of the range where using spreadsheets
    is convenient. Using `dim(dlist$ss16hus)` and `dim(dlist$ss16pus)` (before the
    `rm()` step, or after reloading the data), we see that our household sample has
    50,000 rows and 149 columns, and the people sample has 109,696 rows and 203 columns.
    All columns and value codes are defined in the Census documentation. Such documentation
    is critical, and we supply links to the documentation in PDSwR2/PUMS.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然这些数据量不大，但已经超出了使用电子表格方便的范围。使用 `dim(dlist$ss16hus)` 和 `dim(dlist$ss16pus)`（在
    `rm()` 步骤之前或重新加载数据之后），我们看到我们的家庭样本有 50,000 行和 149 列，而个人样本有 109,696 行和 203 列。所有列和值代码都在人口普查文档中定义。此类文档至关重要，我们在
    PDSwR2/PUMS 中提供了文档链接。
- en: Examining and conditioning the PUMS data
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 检查和调整 PUMS 数据
- en: The point of loading data into R is to facilitate modeling and analysis. Data
    analysts should always have their “hands in the data” and always take a quick
    look at their data after loading it. As our example, we’ll demonstrate how to
    perform a quick examination of some of the PUMS columns or fields.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据加载到 R 中的目的是为了便于建模和分析。数据分析师应该始终“手握数据”，并在加载数据后快速查看数据。作为我们的示例，我们将演示如何快速检查一些
    PUMS 的列或字段。
- en: 'Each row of PUMS data represents a single anonymized person or household. Personal
    data recorded includes occupation, level of education, personal income, and many
    other demographics variables. We loaded the data in [listing 2.8](../Text/02.xhtml#ch02ex08),
    but before we continue, let’s discuss a few of the columns found in the dataset
    and its documentation:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: PUMS 数据的每一行代表一个单独的匿名个人或家庭。记录的个人数据包括职业、教育水平、个人收入以及许多其他人口统计变量。我们在[列表 2.8](../Text/02.xhtml#ch02ex08)中加载了数据，但在继续之前，让我们讨论一下数据集中及其文档中的一些列：
- en: '***Age—*** An integer found in column AGEP'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***年龄—*** 在 AGEP 列中找到的整数'
- en: '***Employment class—*** Examples: for-profit company, nonprofit company, and
    so on, found in column COW'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***就业类别—*** 例如：营利性公司、非营利性公司等，在 COW 列中找到'
- en: '***Education level—*** Examples: no high school diploma, high school, college,
    and so on, found in column SCHL'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***教育水平—*** 例如：无高中文凭、高中、大学等，在 SCHL 列中找到'
- en: '***Total person’s income—*** Found in column PINCP'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***总收入—*** 在 PINCP 列中找到'
- en: '***Sex of worker—*** Found in column SEX'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工人性别—*** 在 SEX 列中找到'
- en: 'We will make our example problem to relate income (represented in US dollars
    in the field) to these variables. This is a typical predictive modeling task:
    relating some variables we know the values of (age, employment, and so on) to
    a variable we wish to know (in this case, income). This task is an example of
    supervised learning, meaning we use a dataset where both the observable variables
    (denoted “independent variables” in statistics) and the unobserved outcome (or
    the “dependent variable”) are both available at the same time. You usually get
    such labeled data by buying data, employing annotators, or using older data where
    you have had time to observe the desired outcome.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个示例问题，将收入（在字段中以美元表示）与这些变量相关联。这是一个典型的预测建模任务：将一些我们知道其值的变量（年龄、就业等）与一个我们希望知道的变量（在这种情况下，收入）相关联。这个任务是一个监督学习的例子，这意味着我们使用一个数据集，其中可观察的变量（在统计学中称为“独立变量”）和未观察到的结果（或“因变量”）都同时可用。您通常通过购买数据、雇佣标注者或使用您已有时间观察所需结果的老数据来获得此类标记数据。
- en: '* * *'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Don’t be too proud to sample
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于骄傲自满而采样
- en: Many data scientists spend too much time adapting algorithms to work directly
    with big data. Often this is wasted effort, as for many model types you would
    get almost exactly the same results on a reasonably sized data sample. You only
    need to work with “all of your data” when what you’re modeling isn’t well served
    by sampling, such as when characterizing rare events or performing linkage calculations
    over social networks.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据科学家花费太多时间调整算法以直接处理大数据。通常这是徒劳的努力，因为对于许多模型类型，你会在合理大小的数据样本上得到几乎完全相同的结果。只有在你所建模的内容不适合采样时，你才需要处理“所有你的数据”，例如在描述罕见事件或在社会网络上执行链接计算时。
- en: '* * *'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'We don’t want to spend too much on time on the artificial aspects of the example
    problem; our goal is to illustrate modeling and data-handling procedures. Conclusions
    are very dependent on choices of data conditioning (what subset of the data you
    use) and data coding (how you map records to informative symbols). This is why
    empirical scientific papers have a mandatory “materials and methods” section describing
    how data was chosen and prepared. Our data treatment is to select a subset of
    “typical full-time workers” by restricting the subset to data that meets all of
    the following conditions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在示例问题的非人工方面花费太多时间；我们的目标是说明建模和数据处理的程序。结论非常依赖于数据条件的选择（你使用的数据的子集）和数据编码（你如何将记录映射到信息符号）。这就是为什么经验科学论文有一个强制性的“材料和方法”部分，描述了数据是如何选择和准备的。我们的数据处理是通过限制子集以满足以下所有条件来选择“典型的全职工人”子集：
- en: Workers self-described as full-time employees
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自称全职员工的工人
- en: Workers reporting at least 30 hours a week of activity
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周至少报告30小时活动的工人
- en: Workers 18–65 years of age
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 18至65岁的工人
- en: Workers with an annual income between $1,000 and $250,000.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年收入在1,000美元到250,000美元之间的工人。
- en: The following listing shows the code to limit to our desired subset of the data.
    Continuing with our data from [listing 2.8](../Text/02.xhtml#ch02ex08), we work
    as shown in [listing 2.9](../Text/02.xhtml#ch02ex09). As our data is small (just
    a sample from PUMS), we use the DBI package to bring the data into R where we
    can work with it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了限制我们所需数据子集的代码。继续使用我们的[列表2.8](../Text/02.xhtml#ch02ex08)中的数据，我们按照[列表2.9](../Text/02.xhtml#ch02ex09)中的说明进行操作。由于我们的数据量很小（只是PUMS的一个样本），我们使用DBI包将数据带入R，以便我们可以处理它。
- en: Listing 2.9\. Loading data from a database
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9\. 从数据库加载数据
- en: '[PRE22]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Copies data from the database into R memory. This assumes we are continuing
    from the previous example, so the packages we have attached are still available
    and the database handle db is still valid.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据从数据库复制到R内存中。这假设我们正在继续上一个示例，所以我们附加的包仍然可用，数据库句柄db仍然有效。
- en: ❷ All the columns in this copy of PUMS data are stored as the character type
    to preserve features such as leading zeros from the original data. Here we are
    converting columns we wish to treat as numeric to the numeric type. Non-numeric
    values, often missing entries, get coded with the symbol NA, which stands for
    not available.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这个PUMS数据副本中，所有列都存储为字符类型，以保留原始数据中的特征，例如前导零。在这里，我们将希望作为数值处理的列转换为数值类型。非数值值，通常是缺失条目，用符号NA编码，代表不可用。
- en: ❸ Selects a subset of columns we want to work with. Restricting columns is not
    required, but improves legibility of later printing.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择我们想要工作的列的子集。限制列不是必需的，但可以提高后续打印的可读性。
- en: ❹ The PUMS level names are very long (which is one of the reasons these columns
    are distributed as integers), so for this dataset that has level names instead
    of level codes, we are shortening the employment codes to no more than 50 characters.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ PUMS级别的名称非常长（这也是这些列被分配为整数的原因之一），因此对于这个具有级别名称而不是级别代码的数据集，我们将就业代码缩短到不超过50个字符。
- en: ❺ Looks at the first few rows of data in a column orientation.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 以列方向查看数据的前几行。
- en: '* * *'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Watch out for NAs
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意NA值
- en: R’s representation for blank or missing data is *NA*. Unfortunately, a lot of
    R commands quietly skip NAs without warning. The command `table(dpus$COW, useNA
    = 'always')` will show NAs much like `summary(dpus$COW)` does.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: R表示空白或缺失数据的是*NA*。不幸的是，许多R命令在没有任何警告的情况下静默地跳过NA。命令`table(dpus$COW, useNA = 'always')`将显示NA，就像`summary(dpus$COW)`做的那样。
- en: '* * *'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'We have now performed a few standard data analysis steps: loading the data,
    reprocessing a few columns, and taking a look at the data. These steps have been
    performed using what we call “base R,” which means using features and functions
    coming from the R language itself and the basic packages that are automatically
    attached (such as `base`, `stats`, and `utils`). R is well suited to data processing
    tasks, as this is what most users come to R to do. There are extension packages
    such as `dplyr` that have their own data processing notation and can perform many
    steps directly against data in a database in addition to being able to work on
    data held in memory. We share examples showing how to perform the same data processing
    steps using base R in the R Markdown example PDSwR2/PUMS/PUMS1.Rmd, or using `dplyr`
    in PDSwR2/PUMS/PUMS1_dplyr.Rmd, or using the advanced query generation package
    `rquery` in PDSwR2/PUMS/PUMS1_rquery.Rmd.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经执行了一些标准的数据分析步骤：加载数据，重新处理几个列，并查看数据。这些步骤是使用我们所说的“基础R”来执行的，这意味着使用来自R语言本身和自动附加的基本包（如`base`、`stats`和`utils`）的功能和函数。R非常适合数据处理任务，因为这是大多数用户来到R要做的事情。还有一些扩展包，如`dplyr`，它们有自己的数据处理符号，可以直接对数据库中的数据进行许多步骤，同时还能在内存中处理数据。我们在R
    Markdown示例PDSwR2/PUMS/PUMS1.Rmd中展示了如何使用基础R执行相同的数据处理步骤，或者在PDSwR2/PUMS/PUMS1_dplyr.Rmd中使用`dplyr`，或者在PDSwR2/PUMS/PUMS1_rquery.Rmd中使用高级查询生成包`rquery`。
- en: 'We are now ready to work our notional problem in [listing 2.10](../Text/02.xhtml#ch02ex10):
    characterizing income with relation to other facts known about individuals. We
    will start with some domain-specific steps: we will remap some level names and
    convert the levels to factors, each with a chosen reference level. Factors are
    strings taken from a specified set (much like an enumerate type in other languages).
    Factors also have one special level called the *reference level* ; it is convention
    that each level is considered to be a difference from the reference level. For
    example, we will set all less-than-bachelors-degree education levels to a new
    level called *No Advanced Degree* and make No Advanced Degree our reference level.
    Some R modeling functions will then score education levels such as Master’s Degree
    as how they differ from the reference level No Advanced Degree. This will be made
    clear in our example.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始处理我们的假设问题[列表2.10](../Text/02.xhtml#ch02ex10)：根据个人已知的其他事实来描述收入。我们将从一些领域特定的步骤开始：我们将重新映射一些级别名称并将级别转换为因子，每个因子都有一个选择的参考级别。因子是从指定集合中取出的字符串（类似于其他语言中的枚举类型）。因子还有一个特殊级别，称为*参考级别*；惯例是每个级别都被认为是与参考级别的差异。例如，我们将所有低于学士学位的教育水平设置为一个新的级别，称为*无高级学位*，并将无高级学位作为我们的参考级别。一些R建模函数将根据与参考级别无高级学位的差异来评分教育水平，如硕士学位。这将在我们的示例中变得清晰。
- en: Listing 2.10\. Remapping values and selecting rows from data
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10\. 重新映射值和从数据中选择行
- en: '[PRE23]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Defines a vector of employment definitions we consider “standard”
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个我们认为是“标准”的就业定义向量
- en: ❷ Builds a new logical vector indicating which rows have valid values in all
    of our columns of interest. In real applications, dealing with missing values
    is important and cannot always be handled by skipping incomplete rows. We will
    return to the issue of properly dealing with missing values when we discuss managing
    data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建一个新的逻辑向量，指示哪些行在我们所有感兴趣的列中都有有效值。在实际应用中，处理缺失值非常重要，并且不能总是通过跳过不完整的行来处理。当我们讨论数据管理时，我们将回到正确处理缺失值的问题。
- en: ❸ Builds a new logical vector indicating which workers we consider typical full-time
    employees. All of these column names are the ones we discussed earlier. The results
    of any analysis will be heavily influenced by this definition, so, in a real task,
    we would spend a lot of time researching the choices in this step. It literally
    controls who and what we are studying. Notice that to keep things simple and homogeneous,
    we restricted this study to civilians, which would be an unacceptable limitation
    in a complete work.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 构建一个新的逻辑向量，指示我们认为的典型全职员工。所有这些列名都是我们之前讨论过的。任何分析的结果都将受到这个定义的严重影响，因此，在实际任务中，我们会花很多时间研究这一步骤的选择。这实际上控制了我们研究和研究的内容。请注意，为了使事情简单和统一，我们将这项研究限制在平民中，这在完整的工作中将是不可接受的限制。
- en: ❹ Restricts to only rows or examples that meet our definition of a typical worker
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅限于符合我们典型工人定义的行或示例
- en: ❺ Recodes education, merging the less-than-bachelor’s-degree levels to the single
    level No Advanced Degree
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将教育重新编码，将低于学士学位的级别合并到单个级别“无高级学位”
- en: ❻ Converts our string-valued columns to factors, picking the reference level
    with the relevel() function
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将我们的字符串值列转换为因子，使用relevel()函数选择参考级别
- en: ❻ Save this data to a file so we can use it in later examples. This file is
    also already available at the path PDSwR2/PUMS/dpus_std_employee.RDS.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将此数据保存到文件中，以便我们可以在后面的示例中使用。此文件也已在路径PDSwR2/PUMS/dpus_std_employee.RDS中可用。
- en: ❽ Takes a look at our data. One of the advantages of factors is that summary()
    builds up useful counts for them. However, it was best to delay having string
    codes as factors until after we finished with remapping level codes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 查看我们的数据。因子的一个优点是summary()会为它们构建有用的计数。然而，最好是在完成重新映射级别代码后，再将字符串代码作为因子。
- en: A bit more on factor coding
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 关于因子编码的更多内容
- en: 'R’s factor type encodes strings as integer indices into a known set of possible
    strings. For example, our SCHL column is represented in R as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: R的因子类型将字符串编码为已知可能字符串集中的整数索引。例如，我们的SCHL列在R中的表示如下：
- en: '[PRE24]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Shows the possible levels for SCHL
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示SCHL的可能级别
- en: ❷ Shows how the first few levels are represented as codes
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示前几个级别如何表示为代码
- en: ❸ Shows the first few string values for SCHL
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 显示SCHL的前几个字符串值
- en: 'Non-statisticians are often surprised that you can use non-numeric columns
    (such as strings or factors) as inputs to or variables in models. This can be
    accomplished a number of ways, and the most common one is a method called *introducing
    indicators* or *dummy variables*. In R this encoding is often automatic and unseen.
    In other systems (such as Python’s scikit-learn), the analyst must specify an
    encoding (through a method name such as “one-hot”). In this book, we will use
    this encoding and additional, more sophisticated encodings from the `vtreat` package.
    The SCHL column can be explicitly converted into basic dummy variables as we show
    next. This recoding strategy will be used both implicitly and explicitly in the
    book, so we will demonstrate it here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 非统计学家常常惊讶地发现，你可以将非数值列（如字符串或因子）用作模型的输入或变量。这可以通过多种方式实现，最常见的一种方法是称为*引入指标*或*虚拟变量*的方法。在R中，这种编码通常是自动的且不可见的。在其他系统（如Python的scikit-learn）中，分析师必须指定一个编码（通过方法名如“one-hot”）。在这本书中，我们将使用这种编码以及来自`vtreat`包的附加、更复杂的编码。SCHL列可以明确地转换为基本虚拟变量，正如我们接下来所展示的。这种重新编码策略将在书中隐式和显式地使用，因此我们在这里进行演示：
- en: '[PRE25]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ The cbind operator combines two data frames by columns, or each row is built
    by matching columns from rows in each data frame.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ cbind运算符通过列组合两个数据框，或者每行是通过匹配每个数据框中的行来构建的。
- en: ❷ Builds a data.frame with the SCHL column recoded as character strings instead
    of as a factor
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个将SCHL列重新编码为字符字符串而不是因子的data.frame
- en: ❸ Builds a matrix with dummy variables generated from the SCHL factor column
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用SCHL因子列生成的虚拟变量构建一个矩阵
- en: ❹ Removes a column named "(Intercept)" from the data.frame, as it is a side
    effect of model.matrix that we are not interested in at this time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从data.frame中删除名为“(Intercept)”的列，因为它是我们目前不感兴趣的model.matrix的副作用。
- en: ❺ Shows the structure that presents the original SCHL string form along with
    the indicators. str() presents the first few rows in transpose format (flipped
    so rows are now up and down and columns are across).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 显示包含原始SCHL字符串形式及其指标的结构。str()以转置格式（翻转，使行现在是上下，列是左右）显示前几行。
- en: Notice that the reference level No Advanced Degree did not get a column, and
    new indicator columns have a 1, which reveals which value is in the original SCHL
    column. The No Advanced Degree columns have all-zero dummies, so we can also tell
    which examples had that value. This coding can be read as “all-zero rows are the
    base or normal case and other rows differ from the all-zero case by having one
    indicator on (showing which case we are talking about).” Notice that this encoding
    contains all the information of the original string form, but all columns are
    now numeric (which is a format many machine learning and modeling procedures require).
    This format is implicitly used in many R machine learning and modeling functions,
    and the user may not even be aware of the conversion.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有高级学位的参考水平没有获得列，而新的指标列有一个 1，这揭示了原始 SCHL 列中的哪个值。没有高级学位的列都是全零虚拟变量，因此我们也可以知道哪些示例具有该值。这种编码可以读作“所有零行是基准或正常情况，其他行与全零情况不同，因为有一个指标被打开（显示我们正在讨论哪种情况）。”注意，这种编码包含了原始字符串形式的所有信息，但所有列现在都是数值的（这是许多机器学习和建模过程所需的一种格式）。这种格式在许多
    R 机器学习和建模函数中隐式使用，用户甚至可能没有意识到转换。
- en: Working with the PUMS data
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PUMS 数据进行工作
- en: 'At this point, we are ready to practice working on our problem with data. As
    we have seen, `summary(dpus)` already gives us information about the distribution
    of every variable in our dataset. We can also look at relations between variables
    with one of the tabulating commands: `tapply()` or `table()`. For example, to
    see a count of examples simultaneously broken down by level of schooling and sex,
    we could type in the command `table(schooling = dpus$SCHL, sex = dpus$SEX)`. To
    get the mean income broken down the same way, we could use the command `tapply(dpus$PINCP,
    list(dpus$SCHL, dpus$SEX), FUN = mean)`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好使用数据来练习我们的问题。正如我们所见，`summary(dpus)` 已经给出了我们数据集中每个变量的分布信息。我们还可以使用一些汇总命令查看变量之间的关系：`tapply()`
    或 `table()`。例如，要查看按教育水平和性别同时分解的示例计数，我们可以输入命令 `table(schooling = dpus$SCHL, sex
    = dpus$SEX)`。要按相同方式获取平均收入，我们可以使用命令 `tapply(dpus$PINCP, list(dpus$SCHL, dpus$SEX),
    FUN = mean)`。
- en: '[PRE26]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Uses the table command to count how often each pair of SCHL and SEX occurs
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 table 命令来统计每个 SCHL 和 SEX 配对的频率
- en: ❷ Uses tapply to tally how often each pair of SCHL of SEX occurs
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 tapply 来统计每个 SCHL 和 SEX 配对的频率
- en: ❸ This argument is the vector of data we are aggregating or summarizing in the
    tapply.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此参数是我们正在 tapply 中聚合或汇总的数据向量。
- en: ❹ This argument list specifies how we are grouping the data, in this case simultaneously
    by SCHL and SEX.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此参数列表指定了数据的分组方式，在这种情况下是同时按 SCHL 和 SEX 分组。
- en: ❺ This argument specifies how we are aggregating values; in this case, we are
    taking the mean or average using the mean function.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 此参数指定了我们如何聚合值；在这种情况下，我们使用 mean 函数计算平均值。
- en: 'The same calculation in `dplyr` idiom is as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 语法中的相同计算如下：'
- en: '[PRE27]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`dplyr` pipelines express tasks as sequences of basic data transformations.
    Also, notice that the `tapply()` result was in a so-called wide format (data cells
    keyed by row and column), and the `dplyr` output is in a tall format (data cells
    keyed by key columns in each row).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 管道将任务表示为基本数据转换的序列。注意，`tapply()` 的结果是在所谓的宽格式（数据单元格按行和列键）中，而 `dplyr`
    的输出是在高格式（数据单元格按每行的关键列键）中。'
- en: We can even graph relations, as shown in [listing 2.11](../Text/02.xhtml#ch02ex11).
    Finally, if we want a model estimating income as a joint function of all of our
    other variables simultaneously, we can try a regression, which is the topic of
    [chapter 8](../Text/08.xhtml#ch08). Converting between such formats is one of
    the key topics covered in [chapter 5](../Text/05.xhtml#ch05).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以绘制关系图，如图 [列表 2.11](../Text/02.xhtml#ch02ex11) 所示。最后，如果我们想同时估计所有其他变量的收入模型，我们可以尝试回归分析，这是第
    8 章的主题。[第 5 章](../Text/05.xhtml#ch05) 覆盖了在转换此类格式时的关键主题。
- en: Listing 2.11\. Plotting the data
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11\. 绘制数据
- en: '[PRE28]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a moment to celebrate, as we have finally achieved a data science goal.
    In [figure 2.3](../Text/02.xhtml#ch02fig03), we are looking at the data and relations
    in the data. The technical task of explaining the summary information in the graph
    will be covered in [chapter 8](../Text/08.xhtml#ch08).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值得庆祝的时刻，因为我们终于实现了数据科学的目标。在 [图 2.3](../Text/02.xhtml#ch02fig03) 中，我们正在查看数据和数据中的关系。在图中解释汇总信息的技术任务将在第
    8 章[第 8 章](../Text/08.xhtml#ch08) 中介绍。
- en: Figure 2.3\. Scatter plot of income (PINCP) as a function of age (AGEP)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3. 收入（PINCP）随年龄（AGEP）的变化散点图
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig03_alt.jpg)'
- en: We’ll return to the Census data and demonstrate more-sophisticated modeling
    techniques a few times in this book. In all cases, we are working these examples
    to demonstrate the basic challenges one encounters in working with their hands
    on the data, and to introduce some of the R tools that are ready to help. As a
    follow-up, we strongly advise running these examples, consulting the `help()`
    on all of these functions, and also searching online for official documentation
    and user guides.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将多次回到人口普查数据，并展示更复杂的建模技术。在所有情况下，我们都在通过这些示例来展示在实际处理数据时遇到的基本挑战，并介绍一些准备好的R工具来帮助。作为后续步骤，我们强烈建议运行这些示例，查阅所有这些函数的
    `help()`，并在线搜索官方文档和用户指南。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we’ve worked through the basics of how to initially extract,
    transform, and load data for analysis. For smaller datasets, we perform the transformations
    using R and in memory. For larger datasets, we advise using a SQL database or
    even a big data system such as Spark (via the `sparklyr` package plus `SQL`, `dplyr`,
    or `rquery`). In any case, we save *all* the transformation steps as code (either
    in SQL or in R) that can be reused in the event of a data refresh. The intent
    of this chapter was to prepare for the actual interesting work in our next chapters:
    exploring, managing, correcting, and modeling data.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何最初提取、转换和加载数据以进行分析的基本方法。对于小型数据集，我们使用R和在内存中执行转换。对于大型数据集，我们建议使用SQL数据库，甚至使用如Spark（通过
    `sparklyr` 包加上 `SQL`、`dplyr` 或 `rquery`）这样的大数据系统。在任何情况下，我们都将所有转换步骤保存为代码（无论是SQL还是R），以便在数据刷新时可以重用。本章的目的是为下一章中实际有趣的工作做准备：探索、管理、纠正和建模数据。
- en: R is built to work with data, and the purpose of loading data into R is to examine
    and work with it. In [chapter 3](../Text/03.xhtml#ch03), we’ll demonstrate how
    to characterize your data through summaries, exploration, and graphing. These
    are key steps early in any modeling effort because it is through these steps that
    you learn the actual details and nature of the problem you’re hoping to model.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: R被构建来处理数据，将数据加载到R中的目的是检查和处理它。在第[3章](../Text/03.xhtml#ch03)中，我们将演示如何通过汇总、探索和绘图来描述您的数据。这些是在任何建模努力早期的重要步骤，因为这些步骤可以帮助您了解您希望建模的实际问题和性质。
- en: In this chapter you have learned
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学到了
- en: Data frames, with their discipline of each row being an instance and each column
    being a variable or measurement, are a preferred data structure for data analysis.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据框，其每一行代表一个实例，每一列代表一个变量或测量值，是数据分析中首选的数据结构。
- en: Use `utils::read.table()` or the `readr` package to load small, structured datasets
    into R.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `utils::read.table()` 或 `readr` 包将小型、结构化数据集加载到R中。
- en: The `DBI` package allows you to work directly with databases or Apache Spark
    using any of `SQL`, `dplyr`, or `rquery`.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBI` 包允许您使用 `SQL`、`dplyr` 或 `rquery` 中的任何一种直接与数据库或Apache Spark工作。'
- en: R is designed to work with data in high-level steps, and has many ready-made,
    data-transforming commands and functions. Generally, if a task becomes difficult
    in R, it is because you are accidentally attempting to reimplement high-level
    data transforms in terms of low-level programming steps.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R被设计成以高级步骤与数据工作，并拥有许多现成的、用于数据转换的命令和函数。通常，如果在R中某个任务变得困难，那是因为您不小心尝试用低级编程步骤重新实现高级数据转换。
