- en: 14 Lazy computations, continuations, and the beauty of monadic composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 懒计算、延续和单子组合的美丽
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Lazy computations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒计算
- en: Exception handling with `Try`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Try` 进行异常处理
- en: Monadically composing functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子组合函数
- en: Escaping the pyramid of doom with continuations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延续逃离厄运金字塔
- en: In this chapter, you’ll first learn why it’s sometimes desirable to define *lazy
    computations*, functions that may or may not be evaluated. You’ll then see how
    these functions can be composed with other functions independently of their evaluation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先了解为什么有时定义**懒计算**（可能或可能不进行评估的函数）是可取的。然后，你将看到这些函数如何与其他函数独立于它们的评估进行组合。
- en: Once you’ve got your feet wet with lazy computations, which are just plain functions,
    you’ll see how the same techniques can be extended to computations that have some
    useful effect other than laziness. Namely, you’ll learn how to use the `Try` delegate
    to safely run code that may throw an exception and how to compose several `Try`s.
    You’ll then learn how to compose functions that take a callback without ending
    up in *callback hell*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对懒计算有了基本的了解，懒计算只是普通的函数，你就会看到相同的技巧可以扩展到除了懒性之外还有其他有用效果的计算。具体来说，你将学习如何使用 `Try`
    代理安全地运行可能抛出异常的代码，以及如何组合多个 `Try`。然后，你将学习如何组合带有回调的函数，而不会陷入**回调地狱**。
- en: What holds all these techniques together is that, in all cases, you’re treating
    functions as *things* that have certain specific characteristics, and you can
    compose them independently of their execution. This requires a leap in abstraction,
    but the result is quite powerful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧共同之处在于，在所有情况下，你都将函数视为具有某些特定特性的**事物**，并且可以独立于它们的执行进行组合。这需要抽象上的飞跃，但结果是相当强大的。
- en: NOTE The contents of this chapter are challenging, so don’t be discouraged if
    you don’t get it all on your first reading.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章内容具有挑战性，所以如果你在第一次阅读时没有完全理解，请不要气馁。
- en: 14.1 The virtue of laziness
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 懒性的美德
- en: '*Laziness* in computing means deferring a computation until its result is needed.
    This is beneficial when the computation is expensive, and its result may not be
    needed.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中的**懒性**意味着将计算推迟到结果需要时。当计算昂贵且其结果可能不需要时，这很有益。
- en: 'To introduce the idea of laziness, consider the following example of a method
    that randomly picks one of two given elements. You can try it out in the REPL:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入懒性的概念，考虑以下一个随机选择两个给定元素之一的方法的例子。你可以在 REPL 中尝试它：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The interesting thing to point out here is that when you invoke `Pick`, both
    the expressions `1 + 2` and `3 + 4` are evaluated, even though only one of them
    is needed in the end.[¹](#pgfId-1145723) So, the program is performing some unnecessary
    computation. This is suboptimal and should be avoided if the computation is expensive
    enough. To prevent this, we could rewrite `Pick` to take not two values but two
    lazy computations instead; that is, functions that can produce the required values:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得指出的是，当你调用 `Pick` 时，即使最终只需要其中一个，`1 + 2` 和 `3 + 4` 这两个表达式都会被评估。[¹](#pgfId-1145723)
    因此，程序执行了一些不必要的计算。这是次优的，如果计算足够昂贵，应该避免这种情况。为了防止这种情况，我们可以将 `Pick` 重新编写为不是接受两个值，而是接受两个懒计算；也就是说，可以产生所需值的函数：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Pick` now first chooses between the two functions and then evaluates one of
    them. As a result, only one computation is performed.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pick` 现在首先在两个函数之间进行选择，然后评估其中一个。结果，只执行了一个计算。'
- en: In summary, if you’re not sure whether a value will be required and it may be
    expensive to compute it, pass the value lazily by wrapping it in a function that
    computes the value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果你不确定一个值是否会被需要，并且计算它可能很昂贵，可以通过将值包装在一个计算该值的函数中来懒性地传递该值。
- en: NOTE Integer addition is an extremely fast operation, so in this particular
    example, the cost of allocating the two lambdas outweighs the benefit of making
    the computations lazy. This technique is only justified in case of operations
    that are computationally intensive or that perform I/O.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：整数加法是一个极快的操作，所以在这个特定的例子中，分配两个 lambda 的成本超过了使计算懒性的好处。这种技术只有在计算密集型操作或执行 I/O
    的操作中才是合理的。
- en: Next, you’ll see how such a lazy API can be beneficial when working with `Option`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到这种懒 API 在处理 `Option` 时如何有益。
- en: 14.1.1 Lazy APIs for working with Option
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 用于处理 Option 的懒 API
- en: The `Option` API provides a couple of examples that nicely illustrate how laziness
    can be useful. Let’s look at those.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` API 提供了一些很好的例子，说明了懒性如何有用。让我们看看这些例子。'
- en: Providing a fallback Option
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 提供回退 `Option`
- en: 'Imagine you have an operation that returns an `Option`, and you want to provide
    a fallback—another `Option`-producing operation to use if the first operation
    returns `None`. Combining two such `Option`-returning functions in this way is
    a common scenario and is achieved through the `OrElse` function, which is defined
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个返回 `Option` 的操作，并且你想提供一个回退——如果第一个操作返回 `None`，则使用另一个产生 `Option` 的操作。以这种方式组合两个这样的
    `Option` 返回函数是常见场景，通过定义如下 `OrElse` 函数来实现：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`OrElse` simply yields the left `Option` if it’s `Some`; otherwise, it falls
    back to the right `Option`. For example, say you define a repository that looks
    items up from a cache, failing which, it goes to the DB:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrElse` 简单地返回左边的 `Option` 如果它是 `Some`；否则，它回退到右边的 `Option`。例如，假设你定义了一个从缓存中查找项目的存储库，如果失败，则转到数据库：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Can you see the problem in the preceding code? Because `OrElse` is always called,
    its argument is always evaluated, meaning that you’re hitting the DB even if the
    item is found in the cache. This defeats the purpose of the cache altogether!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在前面的代码中看到问题吗？因为 `OrElse` 总是被调用，其参数总是被评估，这意味着即使项目在缓存中找到，你也会击中数据库。这完全违背了缓存的目的！
- en: 'This can be solved by using laziness. For such scenarios, I’ve defined an overload
    of `OrElse`, taking not a fallback `Option` but a function that will be evaluated,
    if necessary, to produce the fallback `Option`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用惰性来解决。对于此类场景，我定义了一个 `OrElse` 的重载，它接受一个回退 `Option` 而不是将被评估以产生回退 `Option`
    的函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Only evaluates the fallback function in the `None` case
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在 `None` 的情况下评估回退函数
- en: 'In this implementation, the `fallback` function will only be evaluated if `opt`
    is `None`. (Compare this to the previously shown overload, where the fallback
    option `right` is always evaluated.) You can accordingly fix the implementation
    of the caching repository as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，只有当 `opt` 为 `None` 时，`fallback` 函数才会被评估。（与之前显示的重载相比，其中回退选项 `right` 总是被评估。）你可以相应地修复缓存存储库的实现，如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, if the cache lookup returns `Some`, `OrElse` is still called, but not `db.Lookup`,
    achieving the desired behavior.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果缓存查找返回 `Some`，则仍然会调用 `OrElse`，但不会调用 `db.Lookup`，从而实现所需的行为。
- en: As you can see, to make the evaluation of an expression lazy, instead of providing
    an expression, you provide a function that when called will evaluate that expression.
    Instead of a `T`, provide a `Func<T>`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，为了使表达式的评估是惰性的，你提供的是一个函数，当调用时将评估该表达式。而不是提供 `T`，提供 `Func<T>`。
- en: Using the `||` operator as a terse alternative to `OrElse`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `||` 运算符作为 `OrElse` 的简洁替代
- en: 'Here’s an interesting aside that is relevant to this example, although unrelated
    to the main topic of this chapter. C# allows you to overload logical operators,
    which I’ve done in `Option` for `|`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个与这个例子相关但与本章主题无关的有趣旁白。C# 允许你重载逻辑运算符，我在 `Option` 的 `|` 上已经做到了这一点：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a result, you can use the short-circuiting `||` operator instead of `OrElse`,
    and our `Lookup` function can be rewritten as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用短路 `||` 运算符而不是 `OrElse`，并且我们可以将 `Lookup` 函数重写如下：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because `||` is short-circuiting, if the left side (the lookup from the cache)
    is `Some`, the right side will not be evaluated. The code is terse and efficient
    and gives us the behavior that we want.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `||` 是短路的，如果左边（从缓存中查找）是 `Some`，则不会评估右边。代码简洁高效，并为我们提供了所需的行为。
- en: Providing a default value
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 提供默认值
- en: 'A similar scenario is when you want to extract the inner value from an `Option`,
    providing a fallback value in case it’s `None`. This operation is called `GetOrElse`.
    For instance, you may need to look up a value from configuration and use a default
    value instead if no value is specified:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要从一个 `Option` 中提取内部值，并提供一个回退值以备 `None` 的情况时，这是一个类似的场景。这个操作称为 `GetOrElse`。例如，你可能需要从配置中查找值，如果没有指定值，则使用默认值：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Assume that `Lookup` returns a duly populated `Option` whose state depends on
    whether the value was specified in configuration. Notice that the `DefaultApiRoot`
    property is evaluated regardless of the state of the `Option`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `Lookup` 返回一个适当填充的 `Option`，其状态取决于值是否在配置中指定。注意，无论 `Option` 的状态如何，`DefaultApiRoot`
    属性都会被评估。
- en: 'In this case, that’s OK because it simply returns a constant value. But if
    `DefaultApiRoot` involved an expensive computation, you’d prefer to only perform
    it if needed by passing the default value lazily. This is why I’ve also provided
    two overloads of `GetOrElse`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这是可以的，因为它只是简单地返回一个常量值。但如果 `DefaultApiRoot` 涉及到昂贵的计算，你宁愿只在其需要时执行它，通过传递延迟的默认值。这就是为什么我也提供了两个
    `GetOrElse` 的重载：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first overload takes a regular fallback value, `T`, which is evaluated when
    `GetOrElse` is called. The second overload takes a `Func<T>`, a function that
    is evaluated only when necessary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载接受一个常规回退值 `T`，它在调用 `GetOrElse` 时被评估。第二个重载接受一个 `Func<T>`，这是一个仅在必要时才被评估的函数。
- en: When should an API take values lazily?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 何时应该让 API 延迟获取值？
- en: As a guideline, when a function might not use some of its arguments, those arguments
    should be specified as lazy computations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指导原则，当一个函数可能不会使用其某些参数时，那些参数应该指定为延迟计算。
- en: 'In some cases, you may choose to provide two overloads: one taking a value
    as an argument and another taking a lazy computation. Then the client code can
    decide on the most appropriate overload to call:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能会选择提供两个重载：一个接受一个值作为参数，另一个接受一个延迟计算。然后客户端代码可以决定调用最合适的重载：
- en: If computing the value is expensive enough, pass the value lazily (more efficient).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计算值成本足够高，则延迟传递该值（更高效）。
- en: If the cost of computing the value is negligible, pass the value (more readable).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计算值的成本可以忽略不计，则传递该值（更易读）。
- en: 14.1.2 Composing lazy computations
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 组合延迟计算
- en: In the rest of this chapter, you’ll see how lazy computations can be composed
    and why doing so is a powerful technique. We’ll start with the plain-vanilla lazy
    computation, `Func<T>`, and then move on to lazy computations that include some
    useful effect, such as handling errors or state.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，你将看到如何组合延迟计算以及为什么这样做是一种强大的技术。我们将从普通的延迟计算 `Func<T>` 开始，然后转向包含一些有用效果的延迟计算，例如处理错误或状态。
- en: You saw that `Func<T>` is a lazy computation that can be invoked to obtain a
    `T`. It turns out that `Func<T>` can be treated as a functor over `T`. Remember,
    a functor is something that has an inner value over which you can `Map` a function.
    How is that possible? The functors you’ve seen so far are all containers of some
    sort. How can a function possibly be a container, and what’s its inner value?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了 `Func<T>` 是一种可以调用以获取 `T` 的延迟计算。实际上，`Func<T>` 可以被看作是 `T` 上的函子。记住，函子是你可以对其内部值应用
    `Map` 函数的东西。这是怎么可能的？你迄今为止看到的函子都是某种容器。一个函数怎么可能是一个容器，它的内部值是什么？
- en: Well, you can think of a function as containing its potential result. If, say,
    `Option<T>` “maybe-contains” some value of type `T`, you can say that `Func<T>`
    “potentially-contains” some value of type `T` or, perhaps more accurately, contains
    the potential to produce a value of type `T`. A function’s inner value is the
    value it yields when it’s evaluated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可以把一个函数看作是包含其潜在结果。比如说，`Option<T>` “可能包含”类型为 `T` 的某个值，你可以说 `Func<T>` “可能包含”类型为
    `T` 的某个值，或者，也许更准确地说，它包含产生类型为 `T` 的值的潜力。函数的内部值是它在被评估时产生的值。
- en: 'You may know the tale of Aladdin’s magic lamp. When rubbed, it would produce
    a powerful genie. Clearly, such a lamp could have the power to contain anything:
    put a genie into it, and you can rub it to get the genie back out; put your grandma
    in it, and you can rub it to get grandma back. And you can think of it as a functor:
    map a “turn blue” function onto the lamp and, when you rub the lamp, you’ll get
    the contents of the lamp turned blue. `Func<T>` is such a container, where rubbing
    is function invocation.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道《阿里巴巴和四十大盗》的故事。当擦亮它时，它会产生一个强大的神灯精灵。显然，这样的灯可以包含任何东西：把精灵放进去，你可以擦亮它来得到精灵；把你的祖母放进去，你可以擦亮它来得到祖母。你可以把它看作是一个函子：将一个“变蓝”函数映射到灯上，当你擦亮灯时，你会得到灯的内容变蓝。`Func<T>`
    就是这样一种容器，其中擦亮就是函数调用。
- en: In reality, you know that a functor must expose a `Map` method with a suitable
    signature. If you follow the functor pattern (see section 6.1.4), the signature
    of `Map` for `Func<T>` will involve
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你知道一个函子必须公开一个具有适当签名的 `Map` 方法。如果你遵循函子模式（见第 6.1.4 节），`Func<T>` 的 `Map` 签名将涉及
- en: An input functor of type `()` `→` `T`, a function that can be called to generate
    a `T`. Let’s call it `f`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入函子类型为 `()` `→` `T`，这是一个可以被调用以生成 `T` 的函数。让我们称它为 `f`。
- en: A function to be mapped of type `T` `→` `R`. Let’s call it `g`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个要映射的函数类型为 `T` `→` `R`。让我们称它为 `g`。
- en: An expected result of type `()` `→` `R`, a function that can be called to generate
    an `R`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个预期的结果类型 `()` `→` `R`，一个可以调用以生成 `R` 的函数。
- en: 'The implementation is quite simple: invoke `f` to obtain a `T`, and then pass
    it to `g` to obtain an `R`, as figure 14.1 illustrates. Listing 14.1 shows the
    corresponding code.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当简单：调用 `f` 获取一个 `T`，然后将其传递给 `g` 获取一个 `R`，如图 14.1 所示。列表 14.1 展示了相应的代码。
- en: '![](Images/CH14_F01_Buonanno2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH14_F01_Buonanno2.png)'
- en: Figure 14.1 Definition of `Map` for `Func<T>`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 `Func<T>` 的 `Map` 定义
- en: Listing 14.1 Definition of `Map` for `Func<T>`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.1 `Func<T>` 的 `Map` 定义
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that `Map` doesn’t invoke `f`. It takes a lazily evaluated `T` and returns
    a lazily evaluated `R`. Also notice that the implementation is just function composition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Map` 并没有调用 `f`。它接受一个延迟评估的 `T` 并返回一个延迟评估的 `R`。同时注意，实现只是函数组合。
- en: 'To see this in action, open the REPL, import `LaYumba.Functional` as usual,
    and type the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个动作，打开 REPL，像往常一样导入 `LaYumba.Functional`，并输入以下内容：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To better understand the laziness of the whole computation, you can bake in
    some debug statements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解整个计算的延迟性，你可以嵌入一些调试语句：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ None of the functions are evaluated yet.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有函数尚未被评估。
- en: ❷ All previously composed functions are evaluated now.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 所有之前组合的函数现在都被评估了。
- en: As you can see, the functions `lazyGrandma` and `turnBlue` aren’t invoked until
    the last line. This shows that you can build up complex logic without executing
    anything until you decide to fire things off.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，函数 `lazyGrandma` 和 `turnBlue` 都是在最后一行才被调用的。这表明你可以在不执行任何操作的情况下构建复杂的逻辑，直到你决定启动它们。
- en: Once you’ve thoroughly understood the preceding examples, experimented in the
    REPL, and understood the definition of `Map`, it will be easy to understand the
    definition of `Bind` shown in the following listing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你彻底理解了前面的示例，在 REPL 中进行了实验，并理解了 `Map` 的定义，理解以下列表中显示的 `Bind` 定义将会变得容易。
- en: Listing 14.2 Definition of `Bind` for `Func<T>`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.2 `Func<T>` 的 `Bind` 定义
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Bind` returns a function that, when evaluated, will evaluate `f` to get a
    `T`, apply `g` to it to get a `Func<R>`, and evaluate it to get the resulting
    `R`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 返回一个函数，当评估时，将评估 `f` 以获取一个 `T`，将 `g` 应用到它以获取一个 `Func<R>`，然后评估它以获取结果 `R`。'
- en: This is all very interesting, but how useful is it exactly? Because functions
    are already built into the language, being able to treat `Func` as a monad might
    not give you a lot. On the other hand, knowing that functions can be composed
    like any other monad, we can bake some interesting effects into how those functions
    behave. This is what the rest of this chapter is about.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很有趣，但它的实际用途究竟有多大？因为函数已经内置到语言中，能够将 `Func` 作为单子处理可能不会给你带来太多。另一方面，知道函数可以像任何其他单子一样组合，我们可以将一些有趣的效果嵌入到函数的行为中。这就是本章剩余部分的内容。
- en: 14.2 Exception handling with Try
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 使用 Try 进行异常处理
- en: 'In chapter 8, I showed how you could go from an `Exception`-based API to a
    functional one by catching exceptions and returning them in an `Exceptional`—a
    structure that can hold either an exception or a successful result. For instance,
    if you want to safely create a `Uri` from a `string`, you could write a method
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，我展示了如何通过捕获异常并将它们返回在 `Exceptional` 结构中（一个可以包含异常或成功结果的构造）来从基于 `Exception`
    的 API 转换为函数式 API。例如，如果你想安全地从 `string` 创建一个 `Uri`，你可以编写如下方法：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This works, but should you do this for every method that can throw an exception?
    Surely, after a couple of times, you’ll start to feel that all this trying and
    catching is boilerplate. Can we abstract it away?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法可行，但你真的应该为每个可能抛出异常的方法都这样做吗？显然，经过几次尝试和捕获后，你可能会开始觉得所有这些尝试和捕获都是模板代码。我们能将其抽象化吗？
- en: 14.2.1 Representing computations that may fail
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 表示可能失败的计算
- en: 'Indeed we can, with `Try`—a delegate representing an operation that may throw
    an exception. It’s defined as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确实可以，使用 `Try`——一个表示可能抛出异常的操作的委托。它被定义为如下：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Try<T>` is simply a delegate you can use to represent a computation that normally
    returns a `T` but may throw an exception instead; hence, its return value is wrapped
    in an `Exceptional`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Try<T>` 只是一个你可以用来表示通常返回 `T` 但可能抛出异常的计算的委托；因此，其返回值被包装在 `Exceptional` 中。'
- en: 'Defining `Try` as a separate type allows you to define extension methods specific
    to `Try` (most importantly, `Run`), which safely invokes it and returns a suitably
    populated `Exceptional`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Try` 定义为单独的类型允许你定义针对 `Try` 的特定扩展方法（最重要的是 `Run`），它安全地调用它并返回一个适当填充的 `Exceptional`：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Run` does the `try`-`catch` ceremony once and for all, so you never have to
    write a `try`-`catch` statement again. Refactoring the previous `CreateUri` method
    to use `Try`, you can write:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run` 一次完成 `try`-`catch` 仪式，因此你永远不需要再次编写 `try`-`catch` 语句。将之前的 `CreateUri`
    方法重构为使用 `Try`，你可以编写：'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice how `Try` enables you to define `CreateUri` without any boilerplate
    code for handling exceptions, and yet, you can still execute `CreateUri` safely
    by using `Run` to invoke it. Test it for yourself by typing the following into
    the REPL:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Try` 如何使你能够在不编写任何处理异常的样板代码的情况下定义 `CreateUri`，同时仍然可以通过使用 `Run` 来安全地执行 `CreateUri`。通过在
    REPL 中输入以下内容来自行测试：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also notice that the body of `CreateUri` returns a `Uri`, but `Try<Uri>` is
    defined to return an `Exceptional<Uri>`. This is fine because I’ve defined implicit
    conversion from `T` to `Exceptional<T>`. Here again, the details of error handling
    have been abstracted away, so you can concentrate on the code that matters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`CreateUri` 的主体返回一个 `Uri`，但 `Try<Uri>` 被定义为返回一个 `Exceptional<Uri>`。这是可以的，因为我已经定义了从
    `T` 到 `Exceptional<T>` 的隐式转换。在这里，错误处理的细节已经被抽象化，因此你可以专注于重要的代码。
- en: 'As a shorthand notation, if you didn’t want to define `CreateUri` as a dedicated
    function, you could use the `Try` function (defined in `F`), which simply transforms
    a `Func<T>` into a `Try<T>`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种简写符号，如果你不想将 `CreateUri` 定义为一个专用函数，你可以使用在 `F` 中定义的 `Try` 函数，该函数简单地将 `Func<T>`
    转换为 `Try<T>`：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 14.2.2 Safely extracting information from a JSON object
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 从JSON对象中安全地提取信息
- en: 'Now comes the interesting part—the reason why it’s important that you can compose
    lazy computations. If you have two (or more) computations that may fail, you can
    “monadically” compose them into a single computation that may fail by using `Bind`.
    For example, imagine you have a string representing an object in JSON format with
    the following structure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分——能够组合延迟计算的重要性。如果你有两个（或更多）可能失败的计算，你可以使用 `Bind` 将它们“单调地”组合成一个可能失败的单个计算。例如，想象你有一个表示JSON格式的对象的字符串，其结构如下：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You want to define a method that creates a `Uri` from the value in the “Uri”
    field of the JSON object. The following listing shows an *unsafe* way to do this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要定义一个方法，从JSON对象的“Uri”字段中的值创建一个 `Uri`。以下列表显示了进行此操作的不安全方式。
- en: Listing 14.3 Unsafely extracting data from a JSON object
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.3 从JSON对象中不安全地提取数据
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Deserializes the string into a `Website`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将字符串反序列化为 `Website`
- en: ❷ Creates a `Uri` instance
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个 `Uri` 实例
- en: Both `JsonSerializer.Deserialize` and the `Uri` constructor throw an exception
    if their input isn’t well formed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSerializer.Deserialize` 和 `Uri` 构造函数如果它们的输入格式不正确，都会抛出异常。'
- en: 'Let’s use `Try` to make the implementation safe. We can start by wrapping the
    method calls that can throw an exception into a `Try` as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Try` 来确保实现的安全性。我们可以通过将可能抛出异常的方法调用包装到 `Try` 中来开始，如下所示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As usual, the way to compose several operations that return a `Try` is with
    `Bind`. We’ll look at its definition in a moment. For now, trust that it works,
    and let’s use it to define a method that combines the two preceding operations
    into another `Try`-returning function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，组合返回 `Try` 的多个操作的方式是使用 `Bind`。我们稍后将查看其定义。现在，相信它的工作，让我们使用它来定义一个方法，将前两个操作组合成另一个返回
    `Try` 的函数：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This works, but it’s not particularly readable. The `LaYumba.Functional` library
    includes the implementation of the LINQ query pattern (see the sidebar “A reminder
    on the LINQ query pattern”) for `Try` and all other included monads, so we can
    improve readability by using a LINQ expression instead, as the following listing
    demonstrates.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但可读性并不高。`LaYumba.Functional` 库包括了 `Try` 和所有其他包含的单子的 LINQ 查询模式实现（见侧边栏“关于LINQ查询模式的提醒”），因此我们可以通过使用LINQ表达式来提高可读性，如下列所示。
- en: Listing 14.4 Safely extracting data from a JSON object
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.4 从JSON对象中安全地提取数据
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Deserializes the string into a `Website`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将字符串反序列化为 `Website`
- en: ❷ Creates a `Uri` instance
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个 `Uri` 实例
- en: 'Listing 14.4 is the safe counterpart to the unsafe code in listing 14.3\. You
    can see that we could make this refactoring without compromising on readability.
    Let’s feed a few sample values to `ExtractUri` to see that it works as intended:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.4 是列表 14.3 中不安全代码的安全对应版本。你可以看到，我们可以在不牺牲可读性的情况下进行重构。让我们向 `ExtractUri` 提供一些样本值，以验证它是否按预期工作：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remember, everything happens lazily. When you call `ExtractUri`, you just get
    a `Try` that can eventually perform some computation. Nothing really happens until
    you call `Run`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一切都是惰性的。当你调用`ExtractUri`时，你只是得到一个可以最终执行某些计算的`Try`。直到你调用`Run`之前，实际上什么都没有发生。
- en: 14.2.3 Composing computations that may fail
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 组合可能失败的计算
- en: Now that you’ve seen how to use `Bind` to compose several computations that
    may fail, let’s look under the hood and see how `Bind` is defined for `Try`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何使用`Bind`来组合几个可能失败的计算，让我们看看`Bind`是如何为`Try`定义的。
- en: 'Remember that a `Try<T>` is just like a `Func<T>` for which we now know that
    invocation may throw an exception. Let’s start by quickly looking at `Bind` for
    `Func` again:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Try<T>`就像一个`Func<T>`，我们现在知道调用可能会抛出异常。让我们先快速回顾一下`Func`的`Bind`：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A cavalier way of describing this code is that it first invokes `f` and then
    `g`. Now we need to adapt this to work with `Try`. First, replacing `Func` with
    `Try` gives us the correct signature. (This is often half of the work because
    for the core functions, if the implementation type checks, it usually works.)
    Second, because invoking a `Try` directly may throw an exception, we need to use
    `Run` instead. Finally, we don’t want to run the second function if the first
    function fails. The following listing shows the implementation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 描述这段代码的一种鲁莽的方式是，它首先调用`f`，然后调用`g`。现在我们需要将其修改为与`Try`一起工作。首先，将`Func`替换为`Try`给出了正确的签名。（这通常是工作的一半，因为对于核心函数，如果实现类型检查，通常就能工作。）其次，因为直接调用`Try`可能会抛出异常，我们需要使用`Run`。最后，我们不想在第一个函数失败时运行第二个函数。下面的列表显示了实现。
- en: Listing 14.5 Definition of `Bind` for `Try<T>`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.5 `Try<T>`的`Bind`定义
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Uses `Run` to safely execute each `Try`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用`Run`安全地执行每个`Try`
- en: ❷ If the first `Try` fails, doesn’t execute the second one
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果第一个`Try`失败，则不执行第二个
- en: '`Bind` takes a `Try` and a `Try`-returning function `g`. It then returns a
    function that when invoked runs the `Try` and, if it succeeds, runs `g` on the
    result to obtain another `Try`, which is also run.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind`接受一个`Try`和一个返回`Try`的函数`g`。然后它返回一个函数，当被调用时，运行`Try`，如果成功，则在结果上运行`g`以获得另一个`Try`，该`Try`也会被运行。'
- en: If we can define `Bind`, we can always define `Map`, which is usually simpler.
    I suggest you define `Map` as an exercise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以定义`Bind`，我们就可以始终定义`Map`，这通常更简单。我建议你将`Map`作为练习来定义。
- en: A reminder on the LINQ query pattern
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ查询模式的提醒
- en: A fundamental idea of this chapter is that you can use `Bind` to sequence computations,
    and for this reason, I’ll be showing the implementations of `Bind`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个基本思想是你可以使用`Bind`来序列化计算，因此我将展示`Bind`的实现。
- en: 'In order to use LINQ expressions with monadic types (in this case, `Try`),
    you additionally need to implement the LINQ query pattern that I discussed in
    section 10.4.2\. Here’s a reminder of how to do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用与单子类型（在这种情况下，`Try`）一起的LINQ表达式，你还需要实现我在第10.4.2节中讨论的LINQ查询模式。以下是如何做到这一点的提醒：
- en: Alias `Map` as `Select`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Map`别名为`Select`。
- en: Alias `Bind` as `SelectMany`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Bind`别名为`SelectMany`。
- en: Define an additional overload of `SelectMany` that takes a binary projection
    function. This additional overload can be defined in terms of `Map` and `Bind`,
    although a more efficient implementation can usually be defined.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个额外的`SelectMany`重载，它接受一个二元投影函数。这个额外的重载可以用`Map`和`Bind`来定义，尽管通常可以定义一个更高效的实现。
- en: I won’t clutter up this chapter by showing all these method implementations,
    which are available in the code samples. By now, you have all the tools to understand
    them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会通过展示所有这些方法实现来弄乱这一章，这些实现可以在代码示例中找到。到现在为止，你已经有了理解它们的工具。
- en: '14.2.4 Monadic composition: What does it mean?'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.4 单子组合：这意味着什么？
- en: In this chapter and the next, you’ll often read about *monadically composing*
    computations. That sounds complicated, but it really isn’t, so let’s take the
    mystery out of it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，你经常会读到关于*单子组合*计算的内容。这听起来很复杂，但实际上并不复杂，所以让我们揭开它的神秘面纱。
- en: 'First, let’s recap “normal” function composition, which I covered in chapter
    7\. Suppose you have two functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下“正常”函数组合，这是我在第7章中提到的。假设你有两个函数：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can compose them by simply piping the output of `f` into `g`, obtaining
    a function `A` `→` `C`. Now imagine you have the following functions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`f`的输出简单地管道到`g`来组合它们，得到一个函数`A` `→` `C`。现在想象你有了以下函数：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These functions obviously don’t compose because `f'` returns a `Try<B>`, whereas
    `g'` expects a `B`, but it’s fairly clear that you may want to combine them by
    extracting the `B` from the `Try<B>` and feeding it to `g'`. This is monadic composition,
    and it’s exactly what `Bind` for `Try` does, as you’ve seen.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数显然不能组合，因为 `f'` 返回一个 `Try<B>`，而 `g'` 期望一个 `B`，但很清楚，你可能希望通过从 `Try<B>` 中提取
    `B` 并将其提供给 `g'` 来组合它们。这是单子组合，这正是 `Try` 的 `Bind` 所做的，正如你所看到的。
- en: In other words, monadic composition is a way to combine functions that’s more
    general than function composition and involves some logic dictating how the functions
    are composed. This logic is captured in the `Bind` function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，单子组合是一种比函数组合更通用的组合函数的方法，它涉及一些逻辑，该逻辑决定了函数如何组合。这种逻辑在 `Bind` 函数中得到了体现。
- en: 'There are several variations on this pattern. Imagine the following functions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种这种模式的变体。想象以下函数：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Could we compose these into a new function of type `A` `→` `(C,` `K)`? Given
    an `A`, it’s easy to compute a `C`: run `f"` on the `A`, extract the `B` from
    the resulting tuple, and feed it to `g"`. In the process, we’ve computed two `K`''s,
    so what should we do with them? If there’s a way to combine two `K`''s into a
    single `K`, then we could return the combined `K`. For example, if `K` is a list,
    we could return all elements from both lists. Functions in the preceding form
    can be monadically composed if `K` is of a suitable type.[²](#pgfId-1146062)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将它们组合成一个新的类型为 `A → (C, K)` 的函数？给定一个 `A`，计算一个 `C` 很容易：在 `A` 上运行 `f"`，从结果元组中提取
    `B`，并将其提供给 `g"`)。在这个过程中，我们已经计算了两个 `K`，那么我们应该如何处理它们呢？如果有一种方法可以将两个 `K` 合并成一个 `K`，那么我们可以返回合并后的
    `K`。例如，如果 `K` 是一个列表，我们可以返回两个列表的所有元素。如果 `K` 是一个合适的类型，前面形式的功能可以单子组合。[²](#pgfId-1146062)
- en: The functions for which I’ll demonstrate monadic composition in this book are
    listed in table 14.1, but there are many more possible variations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本书中演示单子组合的函数列在表14.1中，但还有许多其他可能的变体。
- en: Table 14.1 Monadically composable computations demonstrated in this book
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1本书中展示的单子组合计算
- en: '| Delegate | Signature | Section | Scenario |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Delegate | 签名 | 部分 | 场景 |'
- en: '| `Try<T>` | `()` `→` `T` | 14.2 | Exception handling |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Try<T>` | `() → T` | 14.2 | 异常处理 |'
- en: '| `Middleware<T>` | `(T` `→` `R)` `→` `R` | 14.3 | Adding behavior before or
    after a given function |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `Middleware<T>` | `(T → R)` → `R` | 14.3 | 在给定函数前后添加行为 |'
- en: '| `Generator<T>` | `int` `→` `(T, int)` | 15.2 | Generating random data |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `Generator<T>` | `int → (T, int)` | 15.2 | 生成随机数据 |'
- en: '| `StatefulComputation<S,` `T>` | `S` `→` `(T, S)` | 15.3 | Keeping state between
    computations |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `StatefulComputation<S, T>` | `S → (T, S)` | 15.3 | 在计算之间保持状态 |'
- en: 14.3 Creating a middleware pipeline for DB access
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 为数据库访问创建中间件管道
- en: In this section, I’ll start by showing how using HOFs in some cases leads to
    deeply nested callbacks, affectionately called “callback hell” or “the pyramid
    of doom.” I’ll use DB access as the specific scenario to illustrate this problem
    and show how you can leverage the LINQ query pattern to create flat, monadic workflows
    instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将首先展示在某些情况下使用HOFs如何导致深度嵌套的回调，亲切地称为“回调地狱”或“末日金字塔”。我将使用数据库访问作为具体场景来说明这个问题，并展示如何利用LINQ查询模式来创建平坦的单子工作流程。
- en: This section contains advanced material that isn’t required to understand coming
    chapters, so if this is your first reading, feel free to skip to chapter 15.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含了一些高级材料，这些材料不是理解后续章节所必需的，所以如果你是第一次阅读，请随意跳到第15章。
- en: 14.3.1 Composing functions that perform setup/teardown
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 组合执行设置/清理的函数
- en: 'In section 2.3, you learned about functions that perform some setup and teardown
    and are parameterized with a function to be invoked in between. An example of
    this was a function that managed a DB connection, parameterized with a function
    that used the connection to interact with the DB:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.3节中，你学习了执行一些设置和清理的函数，并使用一个在中间调用的函数进行参数化。一个例子是管理数据库连接的函数，该函数使用一个与数据库交互的函数进行参数化：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This function can be consumed in client code like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以在客户端代码中这样使用：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s define a similar function that can be used to log a message before and
    after an operation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个类似的功能，可以在操作前后记录消息：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you want to use both functions (opening/closing a connection as well as tracing
    entering/leaving a block), you’d write something like the following listing shows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用这两个函数（打开/关闭连接以及跟踪进入/离开块），你将编写如下所示的内容。
- en: Listing 14.6 Nested callbacks are hard to read
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.6 嵌套回调难以阅读
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is starting to become hard to read. What if you wanted some other setup
    of work to be done as well? For every HOF you add, your callbacks are nested one
    level deeper, making the code harder to understand. That’s why it’s called “the
    pyramid of doom.”
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始变得难以阅读。如果你还想做一些其他的工作设置呢？对于你添加的每个高阶函数（HOF），你的回调会嵌套更深一层，使代码更难以理解。这就是为什么它被称为“灾难金字塔”。
- en: Instead, what we’d ideally like to have is a clean way to compose a *middleware
    pipeline*, as figure 14.2 illustrates. We want to add some behavior (like connection
    management, diagnostics, and so on) to each trip to the DB. Conceptually, this
    is similar to the middleware pipeline for handling HTTP requests in ASP.NET Core.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们理想中希望有一种干净的方式来组合 *中间件管道*，如图14.2所示。我们希望在每次访问数据库时添加一些行为（如连接管理、诊断等）。从概念上讲，这与ASP.NET
    Core中处理HTTP请求的中间件管道类似。
- en: '![](Images/CH14_F02_Buonanno2.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH14_F02_Buonanno2.png)'
- en: Figure 14.2 A middleware pipeline for accessing the DB
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 访问数据库的中间件管道
- en: 'In a normal, *linear* function pipeline, the output of each function is piped
    into the next function. Each function has no control over what happens downstream.
    A middleware pipeline, on the other hand, is U-shaped: each function passes some
    data along, but it also receives some data on the way out, so to speak. As a result,
    each function is able to perform some operations before *and* after the functions
    downstream.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个正常的、*线性*的函数管道中，每个函数的输出都会传递到下一个函数。每个函数都无法控制下游发生的事情。另一方面，中间件管道是U形的：每个函数传递一些数据，但也可以说在输出过程中接收一些数据。因此，每个函数都有能力在下游函数之前和之后执行一些操作。
- en: I’m going to call each of these functions or blocks a *middleware*. We want
    to be able to nicely compose such middleware pipelines to add logging, timing,
    and so on. But, because each middleware must take a callback function as an input
    argument (otherwise, it can’t intervene after the callback has returned), how
    can we escape the pyramid of doom?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算把这些函数或块称为 *中间件*。我们希望能够优雅地组合这样的中间件管道来添加日志记录、计时等功能。但是，因为每个中间件都必须接受一个回调函数作为输入参数（否则，它无法在回调返回后进行干预），我们如何才能摆脱“灾难金字塔”呢？
- en: 14.3.2 A recipe against the pyramid of doom
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 针对灾难金字塔的配方
- en: 'It turns out that one way we can look at `Bind` is as a recipe against the
    pyramid of doom. For instance, you may remember how in chapter 8, we used `Bind`
    to combine several `Either`-returning functions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以将`Bind`看作是一种针对“灾难金字塔”的配方。例如，你可能记得在第8章中，我们如何使用`Bind`来组合几个返回`Either`的函数：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you expand the calls to `Bind`, the preceding code looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开对`Bind`的调用，前面的代码看起来像这样：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can see that `Bind` effectively enables us to escape the pyramid of doom
    in this case: the same would apply to `Option` and so on. But can we define `Bind`
    for our middleware functions?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`Bind`实际上使我们能够在这个情况下摆脱“灾难金字塔”：同样也适用于`Option`等。但我们能否为我们的中间件函数定义`Bind`？
- en: 14.3.3 Capturing the essence of a middleware function
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 捕捉中间件函数的本质
- en: 'To answer this question, let’s look at the signatures of our middleware functions
    and see if there’s a pattern that we can identify and capture in an abstract way.
    These are the functions we’ve seen so far:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，让我们看看我们的中间件函数的签名，看看我们是否可以识别并以抽象的方式捕捉到一个模式。这些是我们迄今为止看到的函数：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s imagine a couple more examples where we might like to use middleware.
    We could use a timing middleware that logs how long an operation has taken and
    another middleware that begins and commits a DB transaction. The signatures would
    look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再想象一些可能需要使用中间件的例子。我们可以使用一个计时中间件来记录操作所花费的时间，以及另一个开始和提交数据库事务的中间件。签名看起来像这样：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Time` has the same signature as `Trace`: it takes a logger and a string (the
    name of the operation that’s being timed) and the function being timed. `Transact`
    is similar to `Connect`, but it takes a connection that’s used to create a transaction
    and a function that consumes the transaction.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Time`具有与`Trace`相同的签名：它接受一个日志记录器和字符串（正在计时操作的名称）以及被计时的函数。`Transact`类似于`Connect`，但它接受一个用于创建事务的连接和一个消耗事务的函数。'
- en: 'Now that we have four reasonable use cases, let’s see if there’s a pattern
    in the signatures:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了四个合理的用例，让我们看看签名中是否有某种模式：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Each function has some parameters that are specific to the functionality it
    exposes, but there’s definitely a pattern. If we abstract away these specific
    parameters (which we can provide with partial application) and only concentrate
    on the arguments shown in bold, all functions have a signature in this form:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有一些特定于其公开的功能的参数，但肯定有一个模式。如果我们抽象掉这些特定的参数（我们可以通过部分应用提供它们）并只关注显示为粗体的参数，所有函数都有这种形式的签名：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: They all take a callback function (although, in this context, it’s usually called
    a *continuation*) that produces an `R`, and they return an `R` (presumably, the
    very `R` returned by the continuation or a modified version of it). The essence
    of a middleware function is that it takes a continuation of type `T` `→` `R`,
    supplies a `T` to it to obtain an `R`, and returns an `R`, as figure 14.3 shows.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都接受一个产生 `R` 的回调函数（尽管，在这个上下文中，它通常被称为 *延续*），并返回一个 `R`（可能是延续返回的 `R` 或其修改版本）。中间件函数的本质是它接受一个类型为
    `T → R` 的延续，向其中提供一个 `T` 以获得一个 `R`，并返回一个 `R`，如图 14.3 所示。
- en: '![](Images/CH14_F03_Buonanno2.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH14_F03_Buonanno2.png)'
- en: Figure 14.3 A single middleware function
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 一个单独的中间件函数
- en: 'Let’s capture this essence with a delegate:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个代表者来捕捉这个本质：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But wait. Why is it returning `dynamic` rather than `R`?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。为什么它返回的是 `dynamic` 而不是 `R`？
- en: 'The problem is that `T` (the input to the continuation) and `R` (its output)
    are not known at the same time. For example, suppose you want to create a `Middleware`
    instance from a function such as `Connect`, which has this signature:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 `T`（延续的输入）和 `R`（其输出）不是同时知道的。例如，假设你想从一个具有此签名的函数（如 `Connect`）创建一个 `Middleware`
    实例：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The continuation accepted by `Connect` takes a `SqlConnection` as input, so
    we can use `Connect` to define a `Middleware<SqlConnection>`. That means the `T`
    type variable in `Middleware<T>` resolves to `SqlConnection`, but we don’t yet
    know what the given continuation will yield, so we can’t yet resolve the `R` type
    variable in `Connect<R>`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connect` 接受的延续接受一个 `SqlConnection` 作为输入，因此我们可以使用 `Connect` 来定义一个 `Middleware<SqlConnection>`。这意味着
    `Middleware<T>` 中的 `T` 类型变量解析为 `SqlConnection`，但我们还不知道给定的延续会产生什么，因此我们还不能解析 `Connect<R>`
    中的 `R` 类型变量。'
- en: Unfortunately, C# doesn’t allow us to partially apply type variables, hence,
    `dynamic`. So although, conceptually, we’re thinking of combining HOFs of this
    type
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C# 不允许我们部分应用类型变量，因此使用 `dynamic`。所以尽管在概念上，我们是在考虑组合这种类型的 HOF（高阶函数）
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'we’re in fact modeling them as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上是这样建模它们的：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Later, you’ll see that you can still work with `Middleware` without compromising
    on type safety.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将看到你仍然可以在不牺牲类型安全的情况下与 `Middleware` 一起工作。
- en: 'The interesting—and mind-bending—thing is that `Middleware<T>` is a monad over
    `T`, where (remember) `T` is the type of the *input* argument taken by the continuation
    that is given to the middleware function. This seems counterintuitive. A monad
    over `T` is usually something that contains a `T` or some `T`s. But this still
    applies here: if a function has the signature `(T` `→` `R)` `→` `R`, then it can
    provide a `T` to the given function `T` `→` `R`, so it must contain or somehow
    be able to produce a `T`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣且令人费解的是，`Middleware<T>` 是 `T` 上的一个 monad，其中（记住）`T` 是传递给中间件函数的延续所接受的 *输入* 参数的类型。这似乎不符合直觉。`T`
    上的 monad 通常是指包含一个或多个 `T` 的东西。但这里仍然适用：如果一个函数的签名是 `(T → R) → R`，那么它可以向给定的函数 `T →
    R` 提供一个 `T`，因此它必须包含或以某种方式能够产生一个 `T`。
- en: 14.3.4 Implementing the query pattern for middleware
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.4 实现中间件的查询模式
- en: It’s time to learn how to combine two middleware blocks with `Bind`. Essentially,
    `Bind` attaches a downstream middleware block to a pipeline, as figure 14.4 shows.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候学习如何使用 `Bind` 组合两个中间件块了。本质上，`Bind` 将下游中间件块附加到管道中，如图 14.4 所示。
- en: '![](Images/CH14_F04_Buonanno2.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH14_F04_Buonanno2.png)'
- en: Figure 14.4 `Bind` adds a middleware block to the pipeline.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 `Bind` 向管道中添加一个中间件块。
- en: 'The implementation of `Bind` is simple to write but not easy to fully grasp:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 的实现简单易写，但不容易完全理解：'
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have a `Middleware<T>` expecting a continuation of type `(T` `→` `dynamic)`.
    We then have a function, `f`, that takes a `T` and produces a `Middleware<R>`,
    expecting a continuation of type `(R` `→` `dynamic)`. What we get as a result
    is a `Middleware<R>` that, when supplied a continuation, `cont`, runs the initial
    middleware, giving it as continuation a function that runs the binder function
    `f` to obtain the second middleware, to which it will pass `cont`. Don’t worry
    if this doesn’t fully make sense at this point.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个期望类型为 `(T` `→` `dynamic)` 的后续函数的 `Middleware<T>`。然后有一个函数 `f`，它接受一个 `T`
    并生成一个期望类型为 `(R` `→` `dynamic)` 的 `Middleware<R>`。我们得到的结果是一个 `Middleware<R>`，当提供一个后续函数
    `cont` 时，它会运行初始中间件，并将一个运行绑定函数 `f` 以获得第二个中间件的函数作为后续函数，然后将其传递给第二个中间件。如果你现在还不完全理解这一点，请不要担心。
- en: 'Let’s look at `Map` now:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `Map`：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`Map` takes a `Middleware<T>` and a function `f` from `T` to `R`. The middleware
    knows how to create a `T` and supply it to a continuation that takes a `T`. By
    applying `f`, it now knows how to create an `R` and supply it to a continuation
    that takes an `R`. You can visualize `Map` as adding a transformation `T` `→`
    `R` before the continuation or, alternatively, as adding a new setup/teardown
    block to the pipeline, performing a transformation as the setup and passing the
    result along as the teardown, as figure 14.5 shows.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 接受一个 `Middleware<T>` 和一个从 `T` 到 `R` 的函数 `f`。中间件知道如何创建一个 `T` 并将其提供给接受
    `T` 的后续函数。通过应用 `f`，它现在知道如何创建一个 `R` 并将其提供给接受 `R` 的后续函数。你可以将 `Map` 视为在后续函数之前添加一个转换
    `T` `→` `R`，或者，作为替代，将其视为向管道添加一个新的设置/清理块，在设置时执行转换，并将结果作为清理传递，如图 14.5 所示。'
- en: '![](Images/CH14_F05_Buonanno2.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/CH14_F05_Buonanno2.png)'
- en: Figure 14.5 `Map` adds a transformation to the pipeline.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 `Map` 向管道添加一个转换。
- en: 'Finally, once we’ve composed the desired pipeline, we can run the whole pipeline
    by passing a continuation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们组合了所需的管道，我们可以通过传递一个后续函数来运行整个管道：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code shows that if you have a `Middleware<A>` and a continuation
    function `cont` of type `A` `→` `B`, you can directly supply the continuation
    to the middleware.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，如果你有一个 `Middleware<A>` 和一个类型为 `A` `→` `B` 的后续函数 `cont`，你可以直接将后续函数提供给中间件。
- en: 'There’s still a small crease to iron out. Notice that when we provide the continuation,
    we get a `dynamic` back, where we really expect a `B`. To maintain type safety,
    we can define a `Run` function that runs the pipeline with the identity function
    as continuation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个小问题需要解决。请注意，当我们提供后续函数时，我们得到一个 `dynamic` 返回值，而我们实际上期望得到一个 `B`。为了保持类型安全，我们可以定义一个
    `Run` 函数，该函数使用恒等函数作为后续函数来运行管道：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because `mw` is a `Middleware<T>` (meaning that `mw` can provide a value of
    type `T` to its continuation) and because the continuation in this case is the
    identity function, we know that the continuation produces a `T`, so we can confidently
    cast the result of running the middleware to `T`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `mw` 是一个 `Middleware<T>`（这意味着 `mw` 可以向其后续函数提供类型为 `T` 的值）并且因为在这个情况下后续函数是恒等函数，我们知道后续函数会生成一个
    `T`，所以我们有信心将中间件运行的结果转换为 `T` 类型。
- en: 'When we want to run a pipeline, instead of directly providing the continuation,
    we can use `Map` to map the continuation and then call `Run`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要运行一个管道时，我们不必直接提供后续函数，可以使用 `Map` 来映射后续函数，然后调用 `Run`：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here we map our continuation `A` `→` `B` onto our `Middleware<A>`, obtaining
    a `Middleware<B>`, and then run it (with the identity function) to obtain a `B`.
    Notice that `exp2` from this snippet is identical to `exp1` from the previous
    one, but we’ve regained type safety.[³](#pgfId-1146272)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的后续函数 `A` `→` `B` 映射到我们的 `Middleware<A>` 上，得到一个 `Middleware<B>`，然后运行它（使用恒等函数）以获得一个
    `B`。请注意，这个片段中的 `exp2` 与上一个片段中的 `exp1` 相同，但我们已经恢复了类型安全。[³](#pgfId-1146272)
- en: 'Let’s put this all to work by refactoring the `DbLogger` from section 2.3 to
    use `Middleware` rather than HOFs:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重构第 2.3 节中的 `DbLogger` 来使用 `Middleware` 而不是高阶函数（HOFs）来实现这一点：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the constructor, we essentially use partial application to bake the connection
    string into the `Connect` function, which now has the right signature to be used
    as a `Middleware<SqlConnection>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们实际上使用部分应用将连接字符串烘焙到 `Connect` 函数中，现在它具有正确的签名，可以用作 `Middleware<SqlConnection>`。
- en: In the `Log` method, we create a pipeline with a single middleware block, which
    creates the DB connection. We can then use LINQ syntax to refer to `conn` (the
    connection that will be available when the pipeline is run) when calling `Execute`,
    the main operation that will interact with the DB.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Log`方法中，我们创建一个包含单个中间件块的管道，该块创建数据库连接。然后我们可以使用LINQ语法在调用`Execute`（与数据库交互的主要操作）时引用`conn`（管道运行时将可用的连接）。
- en: Of course, we could have written `Log` more concisely by just passing a callback
    to `Connect`. But the whole point here is to avoid callbacks. As we add more blocks
    to the pipeline, we’ll be able to do this by just adding `from` clauses to our
    LINQ comprehension. You’ll see this next.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过只向`Connect`传递一个回调来更简洁地编写`Log`。但这里的关键是避免回调。随着我们向管道中添加更多块，我们只需向我们的LINQ理解中添加`from`子句就能做到这一点。你将在下一节看到这一点。
- en: 14.3.5 Adding middleware that times the operation
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.5 添加计时操作的中件
- en: 'Suppose we have a DB operation that sometimes takes longer than expected, so
    we’d like to add another middleware that logs how long the DB access operation
    took. For this, we could define the following HOF:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个数据库操作，有时比预期耗时更长，因此我们希望添加另一个中间件来记录数据库访问操作耗时。为此，我们可以定义以下HOF：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Time` takes three arguments: a logger, to which it will log the diagnostic
    message; `op`, the name of the operation being performed, which will be included
    in the logged message; and a function representing the operation whose duration
    is being timed.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Time`接受三个参数：一个记录器，它将记录诊断消息；`op`，正在执行的操作的名称，它将包含在记录的消息中；以及一个表示正在计时操作功能的函数。'
- en: 'There’s a slight problem because `Time` takes a `Func<T>` (a function with
    *no* input arguments), whereas we defined the continuations accepted by our middleware
    to be in the form `T` `→` `dynamic` (there should always be an input parameter).
    We can bridge the gap with `Unit`, as usual, but this time on the input side.
    For this, I’ve defined an adapter function that converts a function taking `Unit`
    to a function that takes no arguments:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小问题，因为`Time`需要一个`Func<T>`（一个没有输入参数的函数），而我们已经定义了中间件接受的连续形式为`T` `→` `dynamic`（应该始终有一个输入参数）。我们可以像往常一样用`Unit`来弥合这个差距，但这次是在输入端。为此，我定义了一个适配函数，它将接受`Unit`的函数转换为不接受任何参数的函数：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With this in place, we can enrich our pipeline with a block for logging the
    time taken for DB access as the following listing shows.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以通过以下列表所示的方式，在管道中添加一个用于记录数据库访问时间的块。
- en: Listing 14.7 Combining timing and connection management
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.7 结合计时和连接管理
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Once we’ve wrapped the call to `Instrumentation.Time` in a `Middleware`, we
    can use it in the pipeline by adding an additional `from` clause. Notice that
    the `_` variable will be assigned the `Unit` value returned by `Time`. You can
    disregard it, but LINQ syntax doesn’t allow you to omit it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将对`Instrumentation.Time`的调用包装在一个`Middleware`中，我们就可以通过添加一个额外的`from`子句在管道中使用它。请注意，`_`变量将被分配由`Time`返回的`Unit`值。你可以忽略它，但LINQ语法不允许你省略它。
- en: 14.3.6 Adding middleware that manages a DB transaction
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.6 添加管理数据库事务的中件
- en: 'As a final example, let’s add one more type of middleware that manages a DB
    transaction. We can abstract simple transaction management into a HOF like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，让我们添加一种管理数据库事务的中间件类型。我们可以将简单的交易管理抽象成一个HOF，如下所示：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`Transact` takes a connection and a function `f` that consumes the transaction.
    Presumably, `f` involves multiple DB operations that we need to be performed atomically.
    As an effect of how the `using` declaration is interpreted, the transaction will
    be rolled back if an exception is thrown by `f`. The following listing provides
    an example of integrating `Transact` into a pipeline.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transact`接受一个连接和一个函数`f`，该函数消耗事务。假设`f`涉及多个需要原子执行的数据库操作。由于`using`声明是如何被解释的，如果`f`抛出异常，事务将被回滚。以下列表提供了一个将`Transact`集成到管道中的示例。'
- en: Listing 14.8 A pipeline that provides connection and transaction management
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.8 提供连接和事务管理的管道
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Adapters to turn existing HOFs into `Middleware`
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将现有HOFs转换为`Middleware`的适配器
- en: ❷ The connection string is injected.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 连接字符串被注入。
- en: '`Connect` and `Transact` simply wrap existing HOFs into a `Middleware`. `DeleteOrder`
    is written in curried form so that we can provide the connection string at startup
    and the ID of the order to delete at run time as explained in section 9.4\. Now
    look at the interesting bit—the middleware pipeline declared as `deleteOrder`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connect`和`Transact`简单地将现有的HOFs包装成`Middleware`。`DeleteOrder`以curried形式编写，这样我们可以在启动时提供连接字符串，并在运行时提供要删除的订单ID，如第9.4节所述。现在看看有趣的片段——声明为`deleteOrder`的中间件管道：'
- en: '`Connect` defines a block that creates (and then disposes) the connection.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connect`定义了一个块，它创建（然后处置）连接。'
- en: '`Transact` defines another block that consumes the connection and creates (and
    then disposes) a transaction.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transact`定义了另一个块，它消耗连接并创建（然后处置）一个事务。'
- en: Within the `select` clause, we have two DB actions that use the connection and
    the transaction and which will, therefore, be executed atomically. Because `Execute`
    returns an `int` (the number of affected rows), we can use `+` to combine the
    two operations.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`select`子句中，我们有两个使用连接和事务的数据库操作，因此将原子执行。因为`Execute`返回一个`int`（受影响的行数），我们可以使用`+`来组合这两个操作。
- en: As you already saw in previous chapters, the `Guid` of the order being deleted
    is used to populate the `Id` field of a `param` object, and as a result, it replaces
    the `@Id` token of the SQL template strings.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中已经看到的，正在删除的订单的`Guid`用于填充`param`对象的`Id`字段，因此它替换了SQL模板字符串中的`@Id`标记。
- en: 'Once the middleware functions are set up, adding or removing a step from the
    pipeline is a one-line change. If you’re logging timing information, do you only
    want to time the DB actions or also the time taken to acquire the connection?
    Whatever the case, you can change that by simply changing the order of middleware
    in the pipeline as the following snippets show:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦中间件函数设置完成，添加或从管道中移除一个步骤只需一行更改。如果你正在记录时间信息，你只想记录数据库操作的时间，还是也想记录获取连接所需的时间？无论哪种情况，你都可以通过简单地更改管道中中间件的顺序来更改它，如下面的代码片段所示：
- en: '|'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Acquiring the connection counts toward the time that will be logged. |
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取连接的时间计入将被记录的时间。 |
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❷ Only the DB action is timed. |
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只有数据库操作被计时。 |
- en: The flat layout of LINQ queries makes it easy to see and change the order of
    the middleware functions. And, of course, this solution avoids the pyramid of
    doom. Although I’ve used the idea of middleware and the somewhat specific scenario
    of DB access to illustrate it, the concept of continuations is wider and applies
    to any function in this form:[⁴](#pgfId-1146410)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ查询的扁平布局使得查看和更改中间件函数的顺序变得容易。当然，这个解决方案也避免了“灾难金字塔”。尽管我已经使用了中间件的想法和相对特定的数据库访问场景来展示它，但连续性的概念更广泛，适用于任何这种形式的函数：[⁴](#pgfId-1146410)
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This also means that we could have avoided defining a custom delegate `Middleware`.
    The definitions of `Map`, `Bind`, and `Run` have nothing specific to this scenario,
    and we could have used `Func<Func<T,` `dynamic>` `dynamic>` instead of `Middleware<T>`.
    This might even save a few lines of code because it removes the need for creating
    delegates of the correct type. I opted for `Middleware` as a more explicit, domain-specific
    abstraction, but that’s a personal preference.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们可以避免定义自定义委托`Middleware`。`Map`、`Bind`和`Run`的定义与这个场景无关，我们可以使用`Func<Func<T,
    dynamic, dynamic>>`而不是`Middleware<T>`。这甚至可能节省几行代码，因为它消除了创建正确类型委托的需求。我选择`Middleware`作为一个更明确的、特定领域的抽象，但这只是个人偏好。
- en: In this chapter, you’ve seen how delegate-based monads like `Try` and `Middleware`
    provide powerful and expressive constructs. They allow us to elegantly address
    general problems like exception handling and more specific scenarios like middleware
    pipelines. We’ll explore some more scenarios in chapter 15\.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了基于委托的monads如`Try`和`Middleware`如何提供强大和表达性的结构。它们允许我们优雅地处理一般问题，如异常处理，以及更具体的场景，如中间件管道。我们将在第15章中探讨更多场景。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Laziness means deferring a computation until its result is needed. It’s especially
    useful when the result may not be required in the end.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性意味着将计算推迟到结果需要时。当结果最终可能不需要时，这特别有用。
- en: Lazy computations can be composed to create more complex computations that can
    then be triggered as needed.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性计算可以组合成更复杂的计算，然后按需触发。
- en: When dealing with an exception-based API, you can use the `Try` delegate type.
    The `Run` function safely executes the code in the `Try` and returns the result
    wrapped in an `Exceptional`.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理基于异常的 API 时，您可以使用 `Try` 委托类型。`Run` 函数安全地执行 `Try` 中的代码，并将结果封装在 `Exceptional`
    中返回。
- en: HOFs in the form `(T` `→` `R)` `→` `R` (functions that take a callback or *continuation*)
    can also be composed monadically, enabling you to use flat LINQ expressions rather
    than deeply nested callbacks.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式为 `(T → R) → R` 的 HOF（接受回调或 *延续* 的函数）也可以单调组合，使您能够使用扁平 LINQ 表达式而不是深层嵌套的回调。
- en: '* * *'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ This is because C# is a language with strict or eager evaluation (expressions
    are evaluated as soon as they’re bound to a variable). Although strict evaluation
    is more common, there are languages, notably Haskell, that use lazy evaluation
    so that expressions are evaluated only as needed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 这是因为 C# 是一种具有严格或贪婪求值的语言（表达式在绑定到变量时立即求值）。尽管严格求值更为常见，但也有一些语言，特别是 Haskell，使用惰性求值，因此表达式仅在需要时才求值。
- en: ² This is referred to as the *writer monad* in the literature, and types for
    which two instances can always be combined into one are called *monoids*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ² 在文献中，这被称为 *writer monad*，对于可以始终组合成单个实例的类型称为 *monoids*。
- en: ³ This is because when computing `exp2`, we first compute `mw.Map(cont)`, which
    composes `cont` with the continuation that will eventually be given. Then, by
    calling `Run`, we provide the identity function as continuation. The resulting
    continuation is the composition of `cont` and identity, which is exactly the same
    as providing `cont` as the continuation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 这是因为在计算 `exp2` 时，我们首先计算 `mw.Map(cont)`，这是将 `cont` 与最终将提供的延续组合。然后，通过调用 `Run`，我们提供恒等函数作为延续。得到的延续是
    `cont` 和恒等函数的组合，这与提供 `cont` 作为延续完全相同。
- en: ⁴ In the literature, this is known as *the continuation monad*, which again
    is a misnomer because the monad here isn’t the continuation but the computation
    that takes a continuation as input.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 在文献中，这被称为 *延续 monad*，这再次是一个误称，因为这里的 monad 不是延续，而是接受延续作为输入的计算。
