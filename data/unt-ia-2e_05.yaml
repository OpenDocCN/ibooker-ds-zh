- en: 4 Developing graphics for your game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 为你的游戏开发图形
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding art assets used in game development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解游戏开发中使用的艺术资产
- en: Building prototype levels through whiteboxing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过白盒构建原型关卡
- en: Using 2D images in Unity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中使用2D图像
- en: Importing custom 3D models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入自定义3D模型
- en: Crafting particle effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作粒子效果
- en: We’ve been focusing mostly on how the game functions and not as much on how
    the game looks. That was no accident—this book is mostly about programming games
    in Unity. Still, it’s important to understand how to work on and improve the visuals.
    Before we get back to the book’s main focus on coding various parts of the game,
    let’s spend a chapter learning about game art so that your projects won’t always
    end up with just blank boxes sliding around.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注的是游戏的功能，而不是游戏的外观。这并非偶然——这本书主要关于在Unity中编程游戏。然而，了解如何处理和改进视觉效果同样重要。在我们回到书籍主要关注编码游戏各个部分之前，让我们花一章的篇幅学习游戏艺术，这样你的项目就不会总是以只有空白盒子四处滑动而告终。
- en: All of the visual content in a game is made up of art assets. But what exactly
    does that mean?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的所有视觉内容都是由艺术资产组成的。但那究竟意味着什么呢？
- en: 4.1 Understanding art assets
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 理解艺术资产
- en: 'An *art asset* is an individual unit of visual information (usually a file)
    used by the game. This overarching umbrella term applies to all visual content:
    image files are art assets, 3D models are art assets, and so on. Indeed, an art
    asset is simply a specific type of asset, which you’ve learned is any file used
    by the game (such as a script)—hence the main Assets folder in Unity. Table 4.1
    describes the five main kinds of art assets used in building a game.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*艺术资产*是游戏使用的单个视觉信息单元（通常是一个文件）。这个总称适用于所有视觉内容：图像文件是艺术资产，3D模型是艺术资产，等等。实际上，艺术资产只是资产的一种特定类型，你已了解到它是游戏使用的任何文件（如脚本）——因此Unity中的主要资产文件夹。表4.1描述了构建游戏时使用的五种主要艺术资产类型。'
- en: Table 4.1 Types of art assets
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 艺术资产类型
- en: '| Type of art asset | Definition |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 艺术资产类型 | 定义 |'
- en: '| 2D image | Flat pictures. To make a real-world analogy, 2D images are like
    paintings and photographs. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 2D图像 | 平面图片。为了进行现实世界的类比，2D图像就像绘画和照片。|'
- en: '| 3D model | 3D virtual objects (almost a synonym for mesh objects). To make
    a real-world analogy, 3D models are like sculptures. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 3D模型 | 3D虚拟对象（几乎是网格对象的同义词）。为了进行现实世界的类比，3D模型就像雕塑。|'
- en: '| Material | A packet of information that defines the surface properties of
    any object that the material is attached to. These surface properties can include
    color, shininess, and even subtle roughness. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 材质 | 定义附着在材质上的任何对象表面属性的信息包。这些表面属性可以包括颜色、光泽度，甚至细微的粗糙度。|'
- en: '| Animation | Packets of information that define the movement of the associated
    object. These are detailed movement sequences created ahead of time, as opposed
    to code that calculates positions on the fly. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 动画 | 定义相关对象运动的信包。这些是在事先创建的详细运动序列，而不是在实时计算位置代码。|'
- en: '| Particle system | An orderly mechanism for creating and controlling large
    numbers of small moving objects. Many visual effects, like fire, smoke, or spraying
    water, are created this way. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 粒子系统 | 一种有序的机制，用于创建和控制大量小移动对象。许多视觉效果，如火焰、烟雾或喷水，都是通过这种方式创建的。|'
- en: Creating art for a new game generally starts with either 2D images or 3D models
    because those assets form a base on which everything else relies. As the names
    imply, *2D images* are the foundation of 2D graphics, whereas *3D models* are
    the foundation of 3D graphics. Specifically, 2D images are flat pictures. Even
    if you have no previous familiarity with game art, you’re probably already familiar
    with 2D images from the graphics used on websites; 3D models, on the other hand,
    may need to be defined for a newcomer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为新游戏创建艺术通常从2D图像或3D模型开始，因为那些资产构成了其他一切的基础。正如名称所暗示的，*2D图像*是2D图形的基础，而*3D模型*是3D图形的基础。具体来说，2D图像是平面图片。即使你对游戏艺术没有先前的了解，你也可能已经从网站上的图形中熟悉了2D图像；另一方面，3D模型可能需要为新来者定义。
- en: DEFINITION A *model* is a 3D virtual object. Chapter 1 introduced the term *mesh
    object*, and *3D model* is practically a synonym. The terms are frequently used
    interchangeably, but *mesh object* strictly refers to the geometry of the 3D object
    (the connected lines and shapes), whereas *model* is a bit more ambiguous and
    often includes other attributes of the object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**一个**模型**是一个3D虚拟对象。第一章介绍了术语**网格对象**，而**3D模型**实际上是一个同义词。这两个术语经常互换使用，但**网格对象**严格指3D对象的几何形状（连接的线和形状），而**模型**则稍微模糊一些，通常包括对象的其它属性。'
- en: 'The next two types of assets on the list are *materials* and *animations*.
    Unlike 2D images and 3D models, materials and animations don’t do anything in
    isolation and are much harder for newcomers to understand. 2D images and 3D models
    are easily understood through real-world analogs: paintings for the former, sculptures
    for the latter. Materials and animations aren’t as directly relatable to the real
    world. Instead, both are abstract packets of information that layer onto 3D models.
    In fact, materials were already introduced in a basic sense in chapter 3.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中接下来的两种资源类型是**材质**和**动画**。与2D图像和3D模型不同，材质和动画在独立状态下不执行任何操作，并且对于新手来说理解起来更困难。2D图像和3D模型可以通过现实世界的类比来理解：前者是绘画，后者是雕塑。材质和动画与现实世界没有直接的联系。相反，两者都是抽象的信息包，叠加在3D模型之上。实际上，材质在第三章中已经以基本的形式被介绍过了。
- en: DEFINITION A *material* is a packet of information that defines the surface
    properties (color, shininess, and so forth) of any object that it’s attached to.
    Defining surface properties separately enables multiple objects to share a material
    (all the castle walls, for example).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**一个**材质**是定义它所附加的任何对象表面属性（如颜色、光泽等）的信息包。分别定义表面属性使得多个对象可以共享一个材质（例如，所有的城堡墙壁）。'
- en: Continuing the art analogy, you can think of a material as the medium (clay,
    brass, marble, and so on) that the sculpture is made of. Similarly, an animation
    is also an abstract layer of information that’s attached to a visible object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用艺术类比，你可以将材质视为雕塑所用的媒介（如粘土、黄铜、大理石等）。同样，动画也是附加到可见对象上的一个抽象信息层。
- en: DEFINITION An *animation* is a packet of information that defines the movement
    of the associated object. Because these movements can be defined independently
    from the object itself, they can be used in a mix-and-match way with multiple
    objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**一个**动画**是定义相关对象运动的信息包。因为这些运动可以独立于对象本身定义，所以它们可以以混合匹配的方式与多个对象一起使用。'
- en: For a concrete example, think about a character walking around. The overall
    position of the character is handled by the game’s code (for example, the movement
    scripts you wrote in chapter 2). But the detailed movements of feet hitting the
    ground, arms swinging, and hips rotating are an animation sequence that’s being
    played back; that animation sequence is an art asset.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，想象一个角色四处走动的场景。角色的整体位置由游戏代码处理（例如，你在第二章中编写的移动脚本）。但脚部触地、手臂摆动和臀部旋转的详细动作是一个正在回放的动画序列；这个动画序列是一个艺术资源。
- en: 'To help you understand how animations and 3D models relate, let’s make an analogy
    with puppeteering: the 3D model is the puppet, the animator is the puppeteer who
    makes the puppet move, and the animation is a recording of the puppet’s movements.
    The movements defined this way are created ahead of time and are usually small-scale
    movements that don’t change the overall positioning of the object. This is in
    contrast to the sort of large-scale movements that were done in code in previous
    chapters.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解动画和3D模型之间的关系，让我们用一个木偶戏的类比：3D模型是木偶，动画师是操纵木偶移动的木偶师，而动画是木偶动作的记录。这样定义的运动是在事先创建的，通常是小规模的运动，不会改变对象的整体定位。这与之前章节中在代码中执行的大型规模运动形成对比。
- en: The final kind of art asset from table 4.1 is a particle system. *Particle systems*
    are useful for creating visual effects, like fire, smoke, or spraying water.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1中的最后一种艺术资源是粒子系统。**粒子系统**对于创建视觉效果，如火焰、烟雾或喷水效果非常有用。
- en: DEFINITION A *particle system* is an orderly mechanism for creating and controlling
    large numbers of moving objects. These moving objects are usually small—hence
    the name *particle*—but they don’t have to be.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**一个**粒子系统**是创建和控制大量移动对象的有序机制。这些移动对象通常是小的——因此得名**粒子**——但不必总是这样。'
- en: The particles (the individual objects under the control of a particle system)
    can be any mesh object that you choose. But for most effects, the particles will
    be a square displaying a picture (a flame spark or a smoke puff, for example).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子（受粒子系统控制的单个对象）可以是任何你选择的网格对象。但为了大多数效果，粒子将是一个显示图片的方形（例如火焰火花或烟雾）。
- en: Much of the work of creating game art is done in external software, not within
    Unity itself. Materials and particle systems are created within Unity, but the
    other art assets are created using external software. Refer to appendix B to learn
    more about external tools; a variety of art applications are used for creating
    3D models and animation. 3D models created in an external tool are then saved
    as an art asset that’s imported by Unity. I use Blender when explaining how to
    model in appendix C (download it from [www.blender.org](https://www.blender.org/)),
    but that’s just because Blender is open source and thus available to all readers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建游戏艺术的大部分工作是在外部软件中完成的，而不是在Unity本身中。材质和粒子系统是在Unity中创建的，但其他艺术资产是使用外部软件创建的。有关外部工具的更多信息，请参阅附录B；用于创建3D模型和动画的多种艺术应用程序被使用。在外部工具中创建的3D模型然后被保存为Unity导入的艺术资产。我在附录C中解释如何建模时使用Blender（从[www.blender.org](https://www.blender.org/)下载），但这仅仅是因为Blender是开源的，因此所有读者都可以使用。
- en: NOTE The project download for this chapter includes a folder named *scratch*.
    Although that folder is in the same place as the Unity project, it’s not part
    of the Unity project; that’s where I put extra external files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章的项目下载中包含一个名为*scratch*的文件夹。尽管该文件夹与Unity项目位于同一位置，但它不是Unity项目的一部分；那里是我放置额外外部文件的地方。
- en: As you work through the project for this chapter, you’ll see examples of most
    of these types of art assets (animations are a bit too complex for now and are
    addressed later in the book). You’re going to build a scene that uses 2D images,
    3D models, materials, and a particle system. In some cases, you’ll bring in already
    existing art assets and learn how to import them into Unity, but at other times
    (especially with the particle system), you’ll create the art asset from scratch
    within Unity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章的项目时，你将看到大多数这些类型的艺术资产示例（动画目前较为复杂，将在本书后面的章节中讨论）。你将构建一个使用2D图像、3D模型、材质和粒子系统的场景。在某些情况下，你将引入已经存在的艺术资产并学习如何将它们导入Unity，但在其他时候（尤其是粒子系统），你将在Unity内部从头创建艺术资产。
- en: This chapter only scratches the surface of game art creation. Because this book
    focuses on how to program in Unity, extensive coverage of art disciplines would
    reduce how much the book could cover. Creating game art is a giant topic in and
    of itself, easily able to fill several books. In most cases, a game programmer
    would need to partner with a game artist who specializes in that discipline. That
    said, it’s extremely useful for game programmers to understand how Unity works
    with art assets and possibly even create their own rough stand-ins to be replaced
    later (commonly known as *programmer art*).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅对游戏艺术创作进行了初步探讨。因为本书侧重于Unity编程，对艺术学科的广泛覆盖将减少本书所能涵盖的内容。创建游戏艺术是一个庞大的主题，本身就能填满几本书。在大多数情况下，游戏程序员需要与专注于该领域的游戏艺术家合作。尽管如此，对于游戏程序员来说，了解Unity如何与艺术资产协同工作以及可能甚至创建自己的粗略替代品（通常称为*程序员艺术*）是非常有用的。
- en: NOTE Nothing in this chapter directly requires projects from the previous chapters.
    But you’ll want to have movement scripts like the ones from chapter 2 so that
    you can walk around the scene you’ll build. If necessary, you can grab the player
    object and scripts from the project download. Similarly, this chapter ends with
    moving objects that are similar to the ones created in previous chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章没有直接要求使用前几章的项目。但你会想要有类似于第2章中的移动脚本，这样你就可以在构建的场景中四处走动。如有必要，你可以从项目下载中获取玩家对象和脚本。同样，本章结束时将移动与之前章节中创建的对象相似的对象。
- en: '4.2 Building basic 3D scenery: Whiteboxing'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 构建基本3D场景：白盒建模
- en: The first content creation topic we’ll go over is *whiteboxing*. This process
    is usually the first step in building a level on the computer (after designing
    the level on paper). As the name suggests, you block out the walls of the scene
    with blank geometry (white boxes). Looking at the list of art assets in table
    4.1, this blank scenery is the most basic sort of 3D model, and it provides a
    base on which to display 2D images.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个内容创建主题是**白盒化**。这个过程通常是计算机上构建关卡的第一步（在纸上设计关卡之后）。正如其名所示，你用空白几何形状（白色盒子）遮挡场景的墙壁。查看表4.1中的艺术资产列表，这种空白场景是最基本的3D模型，它提供了一个基础，可以在其上显示2D图像。
- en: If you think back to the primitive scene you created in chapter 2, that was
    basically whiteboxing (you just hadn’t learned the term yet). Some of this section
    will be a rehash of work done in the beginning of chapter 2, but we’ll cover the
    process a lot faster this time, as well as discuss more new terminology.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起第二章中创建的原始场景，那基本上就是白盒化（你只是还没有学到这个术语）。本节的一些内容将是第二章开头所做工作的重复，但这次我们会更快地覆盖这个过程，并讨论更多新术语。
- en: NOTE Another term that is frequently used is *grayboxing*. It means the same
    thing. I tend to use *whiteboxing* because that was the term I first learned,
    but others use grayboxing, which is just as accepted. The actual color used varies
    anyway, similar to the way blueprints aren’t necessarily blue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 另一个经常使用的术语是**灰盒化**。它的意思相同。我倾向于使用**白盒化**，因为这是我首先学到的术语，但其他人使用灰盒化，这也是可以接受的。实际使用的颜色无论如何都会有所不同，就像蓝图不一定是蓝色一样。'
- en: 4.2.1 Whiteboxing explained
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 白盒化解释
- en: Blocking out the scene with blank geometry serves a couple of purposes. First,
    this process enables you to quickly build a sketch that will be progressively
    refined over time. This activity is closely associated with level design and/or
    level designers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空白几何形状遮挡场景有几个作用。首先，这个过程使你能够快速构建一个草图，这个草图会随着时间的推移逐步完善。这个活动与关卡设计密切相关，或者说是关卡设计师的工作。
- en: DEFINITION *Level design* is the discipline of planning and creating scenes
    (or levels) in the game. A *level designer* is a practitioner of level design.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 关卡设计是规划和创建游戏场景（或关卡）的学科。**关卡设计师**是关卡设计的实践者。'
- en: As game development teams have grown in size and team members have become more
    specialized, a common level-building workflow is for the level designer to create
    a first version of the level through whiteboxing. This rough level is then handed
    over to the art team for visual polish. But even on a tiny team, where the same
    person is both designing levels and creating art for the game, this workflow of
    first doing whiteboxing and then polishing the visuals generally works best. You
    have to start somewhere, after all, and whiteboxing gives a clear foundation on
    which to build up the visuals.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏开发团队规模的扩大和团队成员的专业化，一个常见的关卡构建工作流程是关卡设计师通过白盒化创建关卡的第一版。这个粗糙的关卡随后交给艺术团队进行视觉润色。但在小型团队中，即使同一个人既设计关卡又为游戏创建艺术，这种先进行白盒化然后润色视觉的工作流程通常效果最好。毕竟，你必须从某个地方开始，而白盒化提供了一个清晰的基础，可以在此基础上构建视觉元素。
- en: A second purpose served by whiteboxing is that the level quickly reaches a playable
    state. The level may not be finished (indeed, a level right after whiteboxing
    is *far* from finished), but this rough version is functional and can support
    gameplay. At a minimum, the player can walk around the scene (think of the demo
    in chapter 2). In this way, you can test to make sure the level is coming together
    well (for example, are the rooms the right size for this game?) before investing
    a lot of time and energy in detailed work. If something is off (say you realize
    the spaces need to be bigger), changing and retesting is much easier in the whiteboxing
    stage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒化的第二个作用是关卡可以快速达到可玩状态。这个关卡可能还没有完成（实际上，白盒化后的关卡离完成还**很远**），但这个粗糙版本是功能性的，可以支持游戏玩法。至少，玩家可以在场景中四处走动（想想第二章中的演示）。这样，你可以在投入大量时间和精力进行详细工作之前，测试以确保关卡组合得很好（例如，房间的大小是否适合这个游戏？）。如果有什么问题（比如说你意识到空间需要更大），在白盒化阶段进行更改和重新测试要容易得多。
- en: 'Moreover, being able to play the under-construction level is a huge morale
    boost. Don’t discount this benefit: building all the visuals for a scene can take
    a great deal of time, and having to wait a long time before you can experience
    any of that work in the game can start to feel like a slog. Whiteboxing builds
    a complete (if primitive) level right away, and it’s exciting to then play the
    game as it continually improves.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，能够玩到正在建造中的关卡是一种巨大的士气提升。不要低估这个好处：为场景制作所有视觉元素可能需要花费大量时间，而且不得不长时间等待才能在游戏中体验任何这些工作，这可能会开始感觉像是一场苦役。白箱建造立即构建一个完整的（如果有些原始）关卡，然后随着游戏的不断改进，玩这个游戏会变得非常兴奋。
- en: All right, so you understand why levels start with whiteboxing. Now let’s build
    a level!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在你理解了为什么关卡从白箱开始。现在让我们来构建一个关卡吧！
- en: 4.2.2 Drawing a floor plan for the level
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 为关卡绘制平面图
- en: Building a level on the computer follows designing the level on paper. We’re
    not going to get into a huge discussion about level design; just as chapter 2
    noted about game design, level design (which is a subset of game design) is a
    large discipline that could fill an entire book by itself. For our purposes, we’re
    going to draw a basic level, with little design going into the plan, in order
    to give us a target to work toward.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上构建关卡的过程与在纸上设计关卡的过程相似。我们不会深入讨论关卡设计；正如第二章关于游戏设计所述，关卡设计（它是游戏设计的一个子集）是一个庞大的学科，可以单独填满一本书。为了我们的目的，我们将绘制一个基本关卡，计划中涉及的设计很少，以便我们有一个目标去努力。
- en: 'Figure 4.1 is a top-down drawing of a simple layout with four rooms connected
    by a central hallway. That’s all we need for a plan right now: a bunch of separated
    areas and interior walls to place. In a real game, your plan would be more extensive
    and include things like enemies and items.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1是四个房间通过一个中央走廊连接的简单布局的俯视图。现在我们需要的计划就是这个：一些分隔的区域和内部墙壁来放置。在一个真正的游戏中，你的计划会更加广泛，包括敌人、物品等。
- en: '![CH04_F01_Hocking3](../Images/CH04_F01_Hocking3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Hocking3](../Images/CH04_F01_Hocking3.png)'
- en: 'Figure 4.1 Floor plan for the level: four rooms and a central corridor'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 关卡平面图：四个房间和一个中央走廊
- en: You could practice whiteboxing by building this floor plan, or you could draw
    your own simple level to practice that step too. The specifics of the room layout
    matter little for this exercise. The important thing for our purposes is to have
    a floor plan drawn so that we can move forward with the next step.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过构建这个平面图来练习白箱建造，或者你也可以自己绘制一个简单的关卡来练习这一步骤。对于这个练习来说，房间布局的具体细节并不重要。对我们来说，重要的是要绘制一个平面图，这样我们才能继续下一步。
- en: 4.2.3 Laying out primitives according to the plan
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 按照计划布置原语
- en: Building the whitebox level in accordance with the drawn floor plan involves
    positioning and scaling a bunch of blank boxes to be the walls in the diagram.
    As described in section 2.2.1, choose GameObject > 3D Object > Cube to create
    a blank box that you can position and scale as needed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据绘制的平面图构建白箱关卡涉及定位和缩放许多空白盒子，使其成为图中的墙壁。如2.2.1节所述，选择GameObject > 3D Object > Cube来创建一个空白盒子，你可以根据需要定位和缩放它。
- en: More advanced level editing within Unity
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中进行更高级别的关卡编辑
- en: In the workflow featured in this chapter, the level is first blocked out with
    primitives, and then the final-level geometry is built in an external 3D art tool.
    However, Unity also offers ProBuilder, a more robust tool for level editing. You
    could still choose to use that for blocking out a level that gets detailed in
    an external 3D art tool, but ProBuilder could even be your sole level-design tool.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章介绍的工作流程中，关卡首先使用原语进行初步布局，然后在外部3D艺术工具中构建最终关卡几何形状。然而，Unity还提供了ProBuilder，这是一个更强大的关卡编辑工具。你仍然可以选择使用它来为在外部3D艺术工具中详细化的关卡进行初步布局，但ProBuilder甚至可以成为你唯一的关卡设计工具。
- en: Open the Package Manager window (choose Window > Package Manager) and search
    the Unity Registry for ProBuilder. Once that package is installed, it operates
    as described on the Unity website ([https://unity.com/features/probuilder](https://unity.com/features/probuilder)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 打开包管理器窗口（选择Window > Package Manager），在Unity注册表中搜索ProBuilder。一旦安装了该包，它就会像Unity网站上描述的那样运行（[https://unity.com/features/probuilder](https://unity.com/features/probuilder)）。
- en: Meanwhile, a different approach to editing the level is called *constructive
    solid geometry* (CSG). In that approach, you use shapes referred to as brushes,
    and everything from the initial prototype to final-level geometry is built within
    Unity. Go to Realtime CSG ([https://realtimecsg.com](https://realtimecsg.com))
    for more information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，编辑关卡的不同方法被称为*构造实体几何学*（CSG）。在该方法中，你使用称为刷子的形状，从初始原型到最终关卡几何形状的所有内容都在Unity中构建。有关更多信息，请访问实时CSG（[https://realtimecsg.com](https://realtimecsg.com)）。
- en: The first object will be the floor of the scene. In the Inspector, rename the
    object and lower it to -0.5 Y to account for the height of the box itself (figure
    4.2 depicts this). Then stretch the object along the x- and z-axes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象将是场景的地板。在检查器中，重命名对象并将其降低到-0.5 Y，以考虑盒子的自身高度（图4.2展示了这一点）。然后沿x轴和z轴拉伸对象。
- en: '![CH04_F02_Hocking3](../Images/CH04_F02_Hocking3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Hocking3](../Images/CH04_F02_Hocking3.png)'
- en: Figure 4.2 Inspector view of the box positioned and scaled for the floor
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 检查器视图中的盒子已定位并缩放以适应地板
- en: Repeat these steps to create the walls of the scene. You probably want to clean
    up the Hierarchy view by making the walls children of a common base object (remember,
    position the root object at 0, 0, 0, and then drag objects onto it in Hierarchy),
    but that’s not required. Also put a few simple lights around the scene so that
    you can see it; referring to chapter 2, create lights by selecting them in the
    Light submenu of the GameObject menu. The level should look something like figure
    4.3 once you’re done with whiteboxing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重复这些步骤以创建场景的墙壁。你可能想要通过将墙壁设置为公共基对象的子对象来清理层次结构视图（记住，将根对象定位在0, 0, 0，然后在层次结构中将其拖动到上面），但这不是必需的。此外，在场景周围放置一些简单的灯光，以便你可以看到它；参照第2章，通过在GameObject菜单的Light子菜单中选择灯光来创建灯光。完成白盒化后，关卡应该看起来像图4.3所示。
- en: '![CH04_F03_Hocking3](../Images/CH04_F03_Hocking3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Hocking3](../Images/CH04_F03_Hocking3.png)'
- en: Figure 4.3 Whitebox level of the floor plan in figure 4.1
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 图4.1中地板平面图的白盒关卡
- en: Set up your player object or camera to move around (create the player with a
    character controller and movement scripts; refer to chapter 2 if you need a full
    explanation). Now you can walk around the primitive scene to experience your work
    and test it out. And that’s how you do whiteboxing! Pretty simple—but all you
    have right now is blank geometry, so let’s dress up the geometry with pictures
    on the walls.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 设置玩家对象或相机以移动（使用角色控制器和移动脚本创建玩家；如果需要完整说明，请参阅第2章）。现在你可以绕着原始场景走动，体验你的工作并对其进行测试。这就是白盒化的方法！很简单——但现在你只有空白几何形状，所以让我们用墙上的图片来装饰几何形状。
- en: Exporting whitebox geometry to external art tools
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将白盒几何形状导出到外部艺术工具
- en: Much of the work when adding visual polish to the level is done in external
    3D art applications like Blender. Because of this, you may want to have the whitebox
    geometry in your art tool to refer to. By default, there’s no export option for
    primitives laid out within Unity, but Unity offers an optional package (called
    FBX Exporter) that adds this functionality to the editor.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在为关卡添加视觉效果时，大部分工作都是在外部3D艺术应用程序（如Blender）中完成的。因此，你可能希望在艺术工具中保留白盒几何形状以供参考。默认情况下，Unity中没有导出Unity内部布局的原始形状的选项，但Unity提供了一个可选包（称为FBX
    Exporter），该包将此功能添加到编辑器中。
- en: Open the Package Manager and search for FBX Exporter. This is a preview package,
    so you’ll need to select Show Preview Packages in the Package Manager window’s
    Advanced menu. Once that package is installed, it operates as described in the
    Unity documentation ([http://mng.bz/AOYW](http://mng.bz/AOYW)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开包管理器并搜索FBX Exporter。这是一个预览包，因此你需要在包管理器窗口的高级菜单中选择显示预览包。安装该包后，它将按照Unity文档中的描述运行（[http://mng.bz/AOYW](http://mng.bz/AOYW)）。
- en: Incidentally, you don’t need this package for levels made with ProBuilder, the
    advanced level-editing tool mentioned earlier, since that tool already has a model
    exporter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的是，对于使用ProBuilder制作的关卡，你不需要这个包，因为之前提到的这个高级关卡编辑工具已经包含了模型导出功能。
- en: 4.3 Texturing the scene with 2D images
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用2D图像纹理化场景
- en: The level at this point is a rough sketch. It’s playable, but clearly a lot
    more work needs to be done on the visual appearance of the scene. The next step
    in improving the look of the level is applying textures.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关卡只是一个粗略的草图。它是可玩的，但很明显，场景的视觉效果还需要做更多的工作。提高关卡外观的下一步是应用纹理。
- en: DEFINITION A *texture* is a 2D image being used to enhance 3D graphics. That’s
    the totality of what the term means; don’t confuse yourself by thinking that any
    of the uses of textures are part of how the term is defined. No matter how the
    image is being used, it’s still referred to as a texture.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *纹理* 是指用于增强 3D 图形的 2D 图像。这就是该术语的全部含义；不要混淆，认为纹理的任何用途都是该术语定义的一部分。无论图像如何使用，它仍然被称为纹理。
- en: NOTE *Texture* is routinely used as both a verb and a noun. In addition to the
    noun definition, the word describes the action of using 2D images in 3D graphics.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 备注 *纹理* 通常既用作动词也用作名词。除了名词定义外，该词还描述了在 3D 图形中使用 2D 图像的动作。
- en: Textures have multiple uses in 3D graphics, but the most straightforward use
    is to be displayed on the surface of 3D models. Later in this chapter, we’ll discuss
    how this works for more complex models, but for our whiteboxed level, the 2D images
    will act as wallpaper covering the walls (see figure 4.4).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理在 3D 图形中有多种用途，但最直接的使用是将它们显示在 3D 模型的表面上。在本章的后面部分，我们将讨论这对于更复杂模型的工作方式，但对于我们的白盒级别，2D
    图像将充当覆盖墙壁的壁纸（见图 4.4）。
- en: '![CH04_F04_Hocking3](../Images/CH04_F04_Hocking3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_Hocking3](../Images/CH04_F04_Hocking3.png)'
- en: Figure 4.4 Comparing the level before and after textures
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 比较纹理前后级别
- en: As you can see from the comparison in figure 4.4, textures turn what was an
    obviously unreal digital construct into a brick wall. Other uses for textures
    include masks to cut out shapes and normal maps to make surfaces bumpy. Later,
    you may want to look up more information about textures in the resources mentioned
    in appendix D.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 4.4 所示的比较可知，纹理将原本明显不真实的数字结构变成了砖墙。纹理的其他用途包括用于切割形状的蒙版和用于使表面凹凸不平的法线贴图。稍后，你可能需要查阅附录
    D 中提到的资源中关于纹理的更多信息。
- en: 4.3.1 Choosing a file format
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 选择文件格式
- en: A variety of file formats is available for saving 2D images, so which should
    you use? Unity supports the use of many file formats, so you could choose any
    of the ones shown in table 4.2.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于保存 2D 图像的文件格式有很多，那么你应该使用哪一种呢？Unity 支持使用许多文件格式，因此你可以选择表 4.2 中显示的任何一种。
- en: Table 4.2 2D image file formats supported by Unity
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 Unity 支持的 2D 图像文件格式
- en: '| File type | Pros and cons |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 文件类型 | 优点和缺点 |'
- en: '| PNG | Commonly used on the web. Lossless compression; has an alpha channel.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| PNG | 常用于网络。无损压缩；具有 alpha 通道。|'
- en: '| JPG | Commonly used on the web. Lossy compression; no alpha channel. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| JPG | 常用于网络。有损压缩；无 alpha 通道。|'
- en: '| GIF | Commonly used on the web. Lossy compression; no alpha channel. (Technically,
    the loss isn’t from compression; rather, data is lost when the image is converted
    to 8-bit. Ultimately, it amounts to the same thing.) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| GIF | 常用于网络。有损压缩；无 alpha 通道。（技术上，损失并非来自压缩；而是当图像转换为 8 位时数据丢失。最终，这导致相同的结果。）|'
- en: '| BMP | Default image format on Windows. No compression; no alpha channel.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| BMP | Windows 上的默认图像格式。无压缩；无 alpha 通道。|'
- en: '| TGA | Commonly used for 3D graphics; obscure everywhere else. No or lossless
    compression; has an alpha channel. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| TGA | 常用于 3D 图形；在其他地方则较为罕见。无或有损压缩；具有 alpha 通道。|'
- en: '| TIFF | Commonly used for digital photography and publishing. No or lossless
    compression; no alpha channel. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| TIFF | 常用于数字摄影和出版。无或有损压缩；无 alpha 通道。|'
- en: '| PICT | Default image format on old Macs. Lossy compression; no alpha channel.
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| PICT | 旧 Mac 上的默认图像格式。有损压缩；无 alpha 通道。|'
- en: '| PSD | Native file format for Adobe Photoshop. No compression; has an alpha
    channel. The main reason to use this file format would be the advantage of using
    Photoshop files directly. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| PSD | Adobe Photoshop 的原生文件格式。无压缩；具有 alpha 通道。使用此文件格式的最主要原因可能是直接使用 Photoshop
    文件的优势。|'
- en: 'DEFINITION The *alpha channel* is used to store transparency information in
    an image. The visible colors come in three *channels* of information: Red, Green,
    and Blue. Alpha is an additional channel of information that isn’t visible but
    controls the transparency of the image.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *alpha 通道* 用于在图像中存储透明度信息。可见颜色包含三个信息通道：红色、绿色和蓝色。Alpha 是一个额外的信息通道，虽然不可见，但控制图像的透明度。
- en: 'Although Unity will accept any of the image types shown in table 4.2 to import
    and use as a texture, the file formats vary considerably in the features they
    support. Two factors are particularly important for 2D images imported as textures:
    how is the image compressed, and does it have an alpha channel?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity可以接受表4.2中显示的任何图像类型导入并用作纹理，但这些文件格式在它们支持的功能上差异很大。对于作为纹理导入的2D图像，有两个因素特别重要：图像是如何压缩的，以及它是否有alpha通道？
- en: The alpha channel is a straightforward consideration. Because the alpha channel
    is used often in 3D graphics, an image that has an alpha channel is preferred.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha通道是一个简单的考虑因素。由于alpha通道在3D图形中经常使用，因此具有alpha通道的图像更受欢迎。
- en: Image compression is a slightly more complicated consideration, but it boils
    down to “lossy compression is bad.” Both no compression and lossless compression
    preserve the image quality, whereas lossy compression reduces the image quality
    (hence the term *lossy*) as part of reducing the file size.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图像压缩是一个稍微复杂一些的考虑因素，但归结起来就是“有损压缩是坏事。”既不压缩又无损压缩都能保持图像质量，而有损压缩在减小文件大小的过程中会降低图像质量（因此得名*有损*）。
- en: Between these two considerations, the two file formats I recommend for Unity
    textures are PNG and TGA. Targas (TGA) used to be the favorite file format for
    texturing 3D graphics, before PNG became widely used on the internet. These days,
    PNG is almost equivalent technologically but is much more widespread, because
    it’s useful both on the web and as a texture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个考虑因素之间，我推荐的Unity纹理文件格式是PNG和TGA。在PNG广泛用于互联网之前，Targas（TGA）曾是纹理3D图形的首选文件格式。如今，PNG在技术上几乎相当，但更广泛地使用，因为它在网页和纹理中都很实用。
- en: PSD is also commonly recommended for Unity textures, because it’s an advanced
    file format and because it’s convenient that the same file you work on in Photoshop
    also works in Unity. But I tend to prefer keeping work files separate from “finished”
    files that are exported over to Unity (this same mindset comes up again later
    with 3D models).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: PSD也是Unity纹理的常用推荐格式，因为它是一个高级文件格式，而且方便的是，你在Photoshop中工作的同一个文件也可以在Unity中使用。但我倾向于将工作文件与导出到Unity的“完成”文件分开（这种思维方式稍后还会在3D模型中使用）。
- en: The upshot is that all the images I provide in the example projects are PNG,
    and I recommend that you work with that file format as well. With this decision
    made, it’s time to bring some images into Unity and apply them to the blank scene.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我在示例项目中提供的所有图像都是PNG格式，我也建议你使用该文件格式。做出这个决定后，是时候将一些图像导入Unity并将其应用到空白场景中了。
- en: 4.3.2 Importing an image file
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 导入图像文件
- en: Let’s start creating and preparing the textures we’ll use. The images used to
    texture levels are usually tileable so that they can be repeated across large
    surfaces like the floor.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建和准备我们将要使用的纹理。用于纹理级别的图像通常是可平铺的，这样它们就可以在地板等大面积上重复使用。
- en: DEFINITION A *tileable* image (sometimes referred to as a *seamless tile*) is
    an image in which opposite edges match up when placed side by side. This way,
    the image can be repeated without any visible seams between the repeats. The concept
    for 3D texturing is just like wallpaper on web pages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：一个*可平铺*的图像（有时也称为*无缝平铺*）是一个当并排放置时，相对边缘相匹配的图像。这样，图像可以重复使用，而重复之间没有任何可见的接缝。3D纹理的概念就像网页上的壁纸。
- en: You can obtain tileable images in several ways, including by manipulating photographs
    or even painting them by hand. Tutorials and explanations of these techniques
    can be found in numerous books and websites, but we don’t want to get bogged down
    with that right now. Instead, let’s grab a couple of tileable images from one
    of the many websites that offer a catalog of such images for 3D artists to use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式获取可平铺的图像，包括通过操纵照片甚至手工绘制。这些技术的教程和解释可以在许多书籍和网站上找到，但我们现在不想陷入其中。相反，让我们从提供此类图像目录的许多网站之一中获取一些可平铺的图像。
- en: I obtained a couple of images from [www.textures.com](https://www.textures.com/)
    (see figure 4.5) to apply to the walls and floor of the level. Find a couple of
    images you think look good for the floor and walls; I chose BrickRound0067 and
    BrickLargeBare0032.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我从[www.textures.com](https://www.textures.com/)（见图4.5）获取了一些图像，用于应用到该级别的墙壁和地板上。找到一些你认为适合地板和墙壁的图像；我选择了BrickRound0067和BrickLargeBare0032。
- en: '![CH04_F05_Hocking3](../Images/CH04_F05_Hocking3.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F05_Hocking3](../Images/CH04_F05_Hocking3.png)'
- en: Figure 4.5 Seamlessly tiling stone and brick images obtained from Textures.com
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 从Textures.com获取的无缝拼接的石头和砖块图像
- en: Download the images you want and prepare them for use as textures. Technically,
    you could use the images directly as they were downloaded, but they aren’t ideal
    for use as textures. Although they’re certainly tileable (the important reason
    you’re using these images), they aren’t the right size and are the wrong file
    format.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下载你想要的图像，并准备将它们用作纹理。技术上，你可以直接使用下载的图像，但它们并不理想用作纹理。尽管它们当然是可以平铺的（你使用这些图像的重要原因），但它们的大小不正确，文件格式也不正确。
- en: 'The size (in pixels) of a texture should be in powers of 2\. For reasons of
    technical efficiency, graphics chips like to handle textures in sizes that are
    2^N: 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048 (the next number is 4096, but
    at that point the image is too big to use as a texture). In your image editor
    (Photoshop, GIMP, or whatever; refer to appendix B), scale the downloaded image
    to 256 × 256 pixels, and save it as a PNG.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的大小（以像素为单位）应该是2的幂。出于技术效率的考虑，图形芯片喜欢处理大小为2^N的纹理：4、8、16、32、64、128、256、512、1024、2048（下一个数字是4096，但到那时图像太大，无法用作纹理）。在你的图像编辑器（Photoshop、GIMP或任何其他编辑器；参考附录B），将下载的图像缩放到256
    × 256像素，并保存为PNG格式。
- en: Now drag the files from their location in the computer into the Project view
    in Unity. This will copy the files into your Unity project (see figure 4.6), at
    which point they’re imported as textures and can be used in the 3D scene. If dragging
    the file over would be awkward, you could instead right-click in Project and select
    Import New Asset to access a file picker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将文件从计算机中的位置拖动到Unity的项目视图中。这将把文件复制到你的Unity项目中（见图4.6），此时它们被导入为纹理，可以在3D场景中使用。如果拖动文件会显得尴尬，你可以在项目上右键单击并选择“导入新资源”来访问文件选择器。
- en: '![CH04_F06_Hocking3](../Images/CH04_F06_Hocking3.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F06_Hocking3](../Images/CH04_F06_Hocking3.png)'
- en: Figure 4.6 Drag images from outside Unity to import them into the Project view.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 将图像从Unity外部拖动到项目视图中以导入它们。
- en: TIP Organizing your assets into separate folders is probably a good idea as
    your projects start to get more complex. In the Project view, create folders for
    Scripts and Textures and then move assets into the appropriate folders. Simply
    drag files to their new folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 当你的项目开始变得更加复杂时，将你的资源组织到单独的文件夹中可能是一个好主意。在项目视图中，为脚本和纹理创建文件夹，然后将资源移动到相应的文件夹中。只需将文件拖动到新文件夹即可。
- en: WARNING Unity has several keywords that it responds to in folder names, with
    special ways of handling the contents of these special folders. Those keywords
    are Resources, Plugins, Editor, and Gizmos. Later in the book, we’ll go over what
    some of these special folders do, but for now, avoid naming any folders with those
    words.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: WARNING Unity在文件夹名称中响应几个关键字，并以特殊方式处理这些特殊文件夹的内容。这些关键字是Resources、Plugins、Editor和Gizmos。本书后面将介绍一些特殊文件夹的功能，但到目前为止，请避免使用这些单词命名任何文件夹。
- en: Now the images are imported into Unity as textures, ready to use. But how do
    we apply the textures to objects in the scene?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图像已导入Unity作为纹理，准备使用。但我们如何将纹理应用到场景中的对象上呢？
- en: 4.3.3 Applying the image
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 应用图像
- en: Technically, textures aren’t applied to geometry directly. Instead, textures
    can be part of materials, and materials are applied to geometry. As explained
    in the introduction, a material is a set of information defining the properties
    of a surface; that information can include a texture to display on that surface.
    This indirection is significant because the same texture can be used with multiple
    materials. That said, typically each texture goes with a different material, so
    for convenience Unity allows you to drop a texture onto an object and then it
    creates a new material automatically.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，纹理不是直接应用到几何体上的。相反，纹理可以是材质的一部分，而材质则应用到几何体上。正如引言中解释的那样，材质是一组定义表面属性的信息；这些信息可以包括要显示在表面的纹理。这种间接性很重要，因为相同的纹理可以与多个材质一起使用。话虽如此，通常每个纹理都对应不同的材质，因此为了方便，Unity允许你将纹理拖放到对象上，然后它会自动创建一个新的材质。
- en: If you drag a texture from Project view onto an object in the scene, Unity will
    create a new material and apply it to the object. Figure 4.7 illustrates the maneuver.
    Try that now with the texture for the floor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将纹理从项目视图拖动到场景中的对象上，Unity将创建一个新的材质并将其应用到对象上。图4.7说明了这个操作。现在尝试使用地板的纹理来做这个操作。
- en: '![CH04_F07_Hocking3](../Images/CH04_F07_Hocking3.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F07_Hocking3](../Images/CH04_F07_Hocking3.png)'
- en: Figure 4.7 One way to apply textures is to drag them from Project onto Scene
    objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 应用纹理的一种方法是将它们从项目拖动到场景对象上。
- en: 'Besides this convenient method of automatically creating materials, the “proper”
    way to create a material is to choose Assets > Create > Material; the new asset
    will appear in the Project view. Now select the material to show its properties
    in the Inspector (you’ll see something like figure 4.8) and drag a texture to
    the main texture slot; the setting is called Albedo (that’s a technical term for
    the base color), and the texture slot is the square to the left side of the label.
    Meanwhile, drag the material up from Project onto an object in the scene to apply
    the material to that object. Try these steps now with the texture for the wall:
    create a new material, drag the wall texture into this material, and drag the
    material onto a wall in the scene.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种方便的自动创建材质的方法之外，创建材质的“正确”方法是选择 Assets > Create > Material；新资产将出现在项目视图中。现在选择材质以在检查器中显示其属性（你将看到类似于图4.8的内容），并将纹理拖动到主纹理槽中；这个设置被称为Albedo（这是基础颜色的技术术语），纹理槽是标签左侧的方形。同时，将材质从项目拖动到场景中的对象上以应用材质。现在尝试使用墙壁纹理执行这些步骤：创建一个新的材质，将墙壁纹理拖动到这个材质中，并将材质拖动到场景中的墙壁上。
- en: '![CH04_F08_Hocking3](../Images/CH04_F08_Hocking3.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F08_Hocking3](../Images/CH04_F08_Hocking3.png)'
- en: Figure 4.8 Select a material to see it in the Inspector and then drag textures
    to the material properties.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 选择一个材质以在检查器中查看它，然后拖动纹理到材质属性中。
- en: You should now see the stone and brick images appear on the surface of the floor
    and wall objects, but the images look rather stretched out and blurry. The single
    image is being stretched out to cover the entire floor. Instead, you want the
    image to repeat a few times over the floor surface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到石头和砖块图像出现在地板和墙壁对象表面，但这些图像看起来相当拉伸和模糊。单个图像被拉伸以覆盖整个地板。相反，你希望图像在地板表面上重复几次。
- en: You can set this appearance by using the tiling property of the material. Select
    the material in Project and then change the tiling number in the Inspector (with
    separate X and Y values for tiling in each direction). Make sure you’re setting
    the tiling of the main map and not the secondary map (this material optionally
    uses a secondary texture map for advanced effects). The default tiling is 1 (that’s
    no tiling, with the image being stretched over the entire surface); change the
    numbers to something like 8 and see what happens in the scene. Change the numbers
    in both materials to tiling that looks good.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用材质的平铺属性来设置这种外观。在项目中选择材质，然后在检查器中更改平铺数字（每个方向都有单独的X和Y值用于平铺）。确保你正在设置主贴图的平铺，而不是次级贴图（此材质可选地使用次级纹理贴图以实现高级效果）。默认平铺是1（这意味着没有平铺，图像被拉伸覆盖整个表面）；将数字更改为类似8的值，看看场景中会发生什么。将两个材质中的数字都更改为看起来不错的平铺。
- en: NOTE Adjusting the tiling property like this is useful only for texturing whitebox
    geometry. In a polished game, the floor and walls will be built with more intricate
    art tools, and that includes setting up their textures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：像这样调整平铺属性仅适用于纹理化白箱几何体。在一个精良的游戏中，地板和墙壁将使用更复杂的艺术工具构建，这包括设置它们的纹理。
- en: Great—now the scene has textures applied to the floor and walls! You can also
    apply textures to the sky of the scene. Let’s look at that process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——现在场景的地板和墙壁上已经应用了纹理！你还可以将纹理应用到场景的天空。让我们看看这个过程。
- en: 4.4 Generating sky visuals by using texture images
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用纹理图像生成天空视觉效果
- en: The brick and stone textures provide a much more natural look to the walls and
    floor. Yet the sky is currently blank and unnatural; we also want a realistic
    look for the sky. The most common approach to this task is a special kind of texturing
    using pictures of the sky.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 砖石纹理为墙壁和地板提供了更加自然的外观。然而，目前天空是空白的，看起来不自然；我们还想让天空看起来更真实。完成这项任务最常见的方法是使用天空的图片进行一种特殊的纹理处理。
- en: 4.4.1 What is a skybox?
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 什么是天空盒？
- en: By default, the camera’s background color is dark blue. Ordinarily, that color
    fills in any empty area of the view (for example, above the walls of this scene),
    but it’s possible to render pictures of the sky as background. This is where a
    skybox comes in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，相机的背景颜色是深蓝色。通常，这种颜色会填充视图中的任何空白区域（例如，这个场景的墙壁上方），但可以将天空的图片渲染为背景。这就是天空盒的作用所在。
- en: DEFINITION A *skybox* is a cube surrounding the camera with pictures of the
    sky on each side. No matter what direction the camera is facing, it’s looking
    at a picture of the sky.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一个 *天空盒* 是围绕相机的一个立方体，每个面都贴有天空的图片。无论相机朝向哪个方向，它都在看天空的图片。'
- en: Properly implementing a skybox can be tricky; figure 4.9 shows a diagram of
    how a skybox works. Rendering tricks are needed for the skybox to appear as a
    distant background. Fortunately, Unity already takes care of all that for you.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正确实现天空盒可能有些棘手；图 4.9 展示了天空盒是如何工作的示意图。为了使天空盒看起来像远处的背景，需要使用渲染技巧。幸运的是，Unity 已经为你处理了所有这些。
- en: '![CH04_F09_Hocking3](../Images/CH04_F09_Hocking3.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F09_Hocking3](../Images/CH04_F09_Hocking3.png)'
- en: Figure 4.9 Diagram of a skybox
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 天空盒的示意图
- en: New scenes come with a simple default skybox already assigned to them. This
    is why the sky has a gradient from light to dark blue, rather than being a flat
    dark blue. Open the lighting window (Window > Rendering > Lighting), switch to
    the Environment tab, and then note that the first setting is Skybox Material.
    This window has a multiple settings panels related to the advanced lighting system
    in Unity, but for now, we care about only the first setting.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 新场景已经预置了一个简单的默认天空盒。这就是为什么天空从浅蓝到深蓝有渐变，而不是一个平坦的深蓝色。打开照明窗口（窗口 > 渲染 > 照明），切换到环境标签，然后注意第一个设置是天空盒材质。此窗口有多个与
    Unity 的高级照明系统相关的设置面板，但到目前为止，我们只关心第一个设置。
- en: Just like the brick textures earlier, skybox images can be obtained from a variety
    of websites. Search for *skybox textures* or simply get them from the book’s sample
    project. For example, I obtained the TropicalSunnyDay set of skybox images from
    Heiko Irrgang at [https://93i.de/](https://93i.de/). Once this skybox is applied
    to the scene, you will see something like figure 4.10.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前提到的砖块纹理一样，天空盒图片可以从各种网站上获取。搜索 *skybox textures* 或从本书的示例项目中获取。例如，我从 Heiko
    Irrgang 在 [https://93i.de/](https://93i.de/) 获取了 TropicalSunnyDay 天空盒图片集。一旦将这个天空盒应用到场景中，你将看到类似于图
    4.10 的效果。
- en: '![CH04_F10_Hocking3](../Images/CH04_F10_Hocking3.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F10_Hocking3](../Images/CH04_F10_Hocking3.png)'
- en: Figure 4.10 Scene with background pictures of the sky
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 带有天空背景图片的场景
- en: As with other textures, skybox images are first assigned to a material, and
    that gets used in the scene. Let’s examine how to create a new skybox material.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他纹理一样，天空盒图片首先被分配给一个材质，然后在场景中使用。让我们看看如何创建一个新的天空盒材质。
- en: 4.4.2 Creating a new skybox material
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 创建新的天空盒材质
- en: First, create a new material (as usual, either right-click and choose Create,
    or choose Create from the Assets menu) and then select that material to see its
    settings in the Inspector. Next, you need to change the shader used by this material.
    The top of the material settings has a Shader menu (see figure 4.11). In section
    4.3, we pretty much ignored this menu because the default works fine for most
    standard texturing, but a skybox requires a special shader.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的材质（像往常一样，可以右键点击并选择创建，或者从资产菜单中选择创建），然后选择该材质以在检查器中查看其设置。接下来，你需要更改此材质使用的着色器。材质设置的顶部有一个着色器菜单（见图
    4.11）。在 4.3 节中，我们基本上忽略了此菜单，因为默认设置对大多数标准纹理化来说已经足够好，但天空盒需要特殊的着色器。
- en: '![CH04_F11_Hocking3](../Images/CH04_F11_Hocking3.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F11_Hocking3](../Images/CH04_F11_Hocking3.png)'
- en: Figure 4.11 The drop-down menu of available shaders
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 可用着色器的下拉菜单
- en: DEFINITION A *shader* is a short program that outlines instructions for drawing
    a surface, including whether to use any textures. The computer uses these instructions
    to calculate the pixels when rendering the image. The most common shader takes
    the color of the material and darkens it according to the light, but shaders can
    also be used for all sorts of visual effects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一个 *着色器* 是一个简短的程序，它概述了绘制表面的指令，包括是否使用任何纹理。计算机使用这些指令在渲染图像时计算像素。最常见的着色器会根据光线将材质的颜色变暗，但着色器也可以用于各种视觉效果。'
- en: Every material has a shader that controls it (you could think of a material
    as an instance of a shader). New materials are set to the Standard shader by default.
    This shader displays the color of the material (including the texture) while applying
    light and shadows across the surface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个材质都有一个控制它的着色器（你可以将材质视为着色器的一个实例）。新材质默认设置为标准着色器。此着色器显示材质的颜色（包括纹理），并在表面应用光线和阴影。
- en: For skyboxes, Unity has a different shader. Click the menu to see the drop-down
    list (see figure 4.11) of all the available shaders. Select the Skybox section
    and choose 6 Sided in the submenu. With this shader active, the material now has
    six large texture slots (instead of only the small Albedo texture slot that the
    standard shader has). These six texture slots correspond to the six sides of a
    cube, so these images should match up at the edges to appear seamless. For example,
    figure 4.12 shows the images for the sunny skybox.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于天空盒，Unity有一个不同的着色器。单击菜单以查看下拉列表（见图4.11）中所有可用的着色器。选择天空盒部分，并在子菜单中选择6面。使用此着色器后，材质现在有六个大纹理槽（而不是标准着色器中只有的小反照率纹理槽）。这六个纹理槽对应于立方体的六个面，因此这些图像应该在边缘处匹配以看起来无缝。例如，图4.12显示了晴朗天空盒的图像。
- en: '![CH04_F12_Hocking3](../Images/CH04_F12_Hocking3.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F12_Hocking3](../Images/CH04_F12_Hocking3.png)'
- en: Figure 4.12 Six images for the sides of a skybox
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 天空盒侧面的六个图像
- en: 'Import the skybox images into Unity the same way you brought in the brick textures:
    drag the files into the Project view or right-click in Project and select Import
    New Asset. We need to change one subtle import setting; click the imported texture
    to see its properties in the Inspector and change the Wrap Mode setting (shown
    in figure 4.13) from Repeat to Clamp. Don’t forget to click Apply when you’re
    done. Ordinarily, textures can be tiled repeatedly over a surface, and for this
    to appear seamless, opposite edges of the image bleed together. But this blending
    of edges can create faint lines in the sky where images meet, so the Clamp setting
    (similar to the Clamp() function in chapter 2) will limit the boundaries of the
    texture and get rid of this blending.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以与您导入砖块纹理相同的方式将天空盒图像导入Unity：将文件拖动到项目视图或右键单击项目并选择导入新资产。我们需要更改一个细微的导入设置；单击导入的纹理以在检查器中查看其属性，并将包裹模式设置（如图4.13所示）从重复更改为限制。完成时不要忘记单击应用。通常，纹理可以在表面上重复平铺，为了看起来无缝，图像的相对边缘会混合在一起。但这种边缘混合会在图像相遇的天空处产生微弱的线条，因此限制设置（类似于第2章中的限制()函数）将限制纹理的边界并消除这种混合。
- en: '![CH04_F13_Hocking3](../Images/CH04_F13_Hocking3.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F13_Hocking3](../Images/CH04_F13_Hocking3.png)'
- en: Figure 4.13 Correct faint edge lines by adjusting the Wrap mode.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 通过调整包裹模式来调整正确的微弱边缘线。
- en: Now you can drag these images to the texture slots of the skybox material. The
    image names correspond to the texture slot to assign them to (such as left or
    front). Once all six textures are linked up, you can use this new material as
    the skybox for the scene. Open the lighting window again and set this new material
    to the Skybox slot; either drag the material to that slot, or click the tiny circle
    icon to bring up a file picker. Now click Play to see the new skybox.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将这些图像拖动到天空盒材质的纹理槽中。图像名称对应于要分配给它们的纹理槽（例如左侧或前方）。一旦所有六个纹理都连接起来，您就可以使用这种新材料作为场景的天空盒。再次打开照明窗口，并将此新材料设置为天空盒槽；要么将材质拖到该槽中，要么单击小圆圈图标以打开文件选择器。现在单击播放以查看新的天空盒。
- en: TIP By default, Unity will display the skybox (or at least its main color) in
    the editor’s Scene view. You may find this color distracting while editing objects,
    so you can toggle the skybox on or off. Across the top of the Scene view’s pane
    are buttons that control what’s visible; look for the Effects button to toggle
    the skybox on or off.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 默认情况下，Unity将在编辑器的场景视图中显示天空盒（或至少其主要颜色）。在编辑对象时，您可能会发现这种颜色分散注意力，因此您可以切换天空盒的开启或关闭。在场景视图面板的顶部有按钮可以控制可见内容；查找效果按钮以切换天空盒的开启或关闭。
- en: Woo-hoo—you’ve learned how to create sky visuals for your scene! A skybox is
    an elegant way to create the illusion of a vast atmosphere surrounding the player.
    The next step in polishing the visuals in your level is to create more complex
    3D models.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦——您已经学会了如何为场景创建天空视觉效果！天空盒是一种优雅的方式来创建环绕玩家的广阔氛围的幻觉。在您的关卡中润色视觉效果的下一步是创建更复杂的3D模型。
- en: 4.5 Working with custom 3D models
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 使用自定义3D模型
- en: 'In the previous sections, we looked at applying textures to the large flat
    walls and floors of the level. But what about more detailed objects? What if you
    want, say, interesting furniture in the room? You can accomplish that by building
    3D models in external 3D art apps. Recall the definition from the introduction
    to this chapter: 3D models are the mesh objects in the game (the three-dimensional
    shapes). Well, you’re going to import a 3D mesh of a simple bench.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了将纹理应用到关卡的大平面墙壁和地板上。那么更详细的对象怎么办？如果你想在房间里放置有趣的家具怎么办？你可以通过在外部3D艺术应用程序中构建3D模型来实现这一点。回想一下本章引言中的定义：3D模型是游戏中的网格对象（三维形状）。好吧，你将导入一个简单长椅的3D网格。
- en: Applications widely used for modeling 3D objects include Autodesk Maya and Autodesk
    3ds Max. Both are expensive commercial tools, so the sample for this chapter uses
    the open source app Blender. The sample download includes a .blend file that you
    can use; figure 4.14 depicts the bench model in Blender. If you’re interested
    in learning how to model your own objects, you’ll find an exercise in appendix
    C about modeling this bench in Blender.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛用于建模3D对象的应用程序包括Autodesk Maya和Autodesk 3ds Max。这两个都是昂贵的商业工具，因此本章的示例使用开源应用程序Blender。示例下载包括一个可用的.blend文件；图4.14展示了Blender中的长椅模型。如果你对学习如何建模自己的对象感兴趣，你将在附录C中找到一个关于在Blender中建模这个长椅的练习。
- en: '![CH04_F14_Hocking3](../Images/CH04_F14_Hocking3.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F14_Hocking3](../Images/CH04_F14_Hocking3.png)'
- en: Figure 4.14 The bench model in Blender
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 Blender中的长椅模型
- en: Besides custom-made models created by yourself or an artist you’re working with,
    many 3D models are available for download from game art websites. One great resource
    for 3D models is the Unity Asset Store, accessible within Unity or at [https://assetstore.unity.com](https://assetstore.unity.com).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你自己或你合作的艺术家创建的定制模型外，许多3D模型可以从游戏艺术网站上下载。3D模型的一个很好的资源是Unity Asset Store，在Unity内部或[https://assetstore.unity.com](https://assetstore.unity.com)都可以访问。
- en: 4.5.1 Which file format to choose?
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 选择哪种文件格式？
- en: After you obtain a model made in an external art tool, you need to export the
    asset from that software. Just as with 2D images, multiple file formats are available
    for you to use when exporting the 3D model, and these file types have various
    pros and cons. Table 4.3 lists the 3D file formats that Unity supports.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在你获得外部艺术工具制作的模型后，你需要从该软件导出资产。就像2D图像一样，在导出3D模型时，有多种文件格式可供你使用，这些文件类型各有优缺点。表4.3列出了Unity支持的3D文件格式。
- en: Table 4.3 3D Model file formats supported by Unity
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 Unity支持的3D模型文件格式
- en: '| File type | Pros and cons |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 文件类型 | 优点和缺点 |'
- en: '| FBX | Mesh and animation; recommended option when available. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| FBX | 网格和动画；当可用时，推荐选项。|'
- en: '| COLLADA (DAE) | Mesh and animation; another good option when FBX isn’t available.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| COLLADA (DAE) | 网格和动画；当FBX不可用时，另一个不错的选择。|'
- en: '| OBJ | Mesh only; this is a text format, so sometimes useful for streaming
    over the internet. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| OBJ | 仅网格；这是一个文本格式，因此有时在互联网上流传输时很有用。|'
- en: '| 3DS | Mesh only; a pretty old and primitive model format. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 3DS | 仅网格；一个相当古老且原始的模型格式。|'
- en: '| DXF | Mesh only; a pretty old and primitive model format. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| DXF | 仅网格；一个相当古老且原始的模型格式。|'
- en: '| Maya | Works via FBX; requires this application to be installed. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| Maya | 通过FBX工作；需要安装此应用程序。|'
- en: '| 3ds Max | Works via FBX; requires this application to be installed. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 3ds Max | 通过FBX工作；需要安装此应用程序。|'
- en: '| Blender | Works via FBX; requires this application to be installed. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| Blender | 通过FBX工作；需要安装此应用程序。|'
- en: Choosing an option boils down to whether the file supports animation. Because
    COLLADA and FBX are the only two options that include animation data, those are
    the two options to choose. Whenever it’s available (not all 3D tools have it as
    an export option), FBX export tends to work best, but if you’re using a tool without
    FBX export, then COLLLADA works well too. In our case, Blender supports FBX export,
    so we’ll use that file format.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 选择选项归结为文件是否支持动画。因为COLLADA和FBX是唯一两个包含动画数据的选项，所以这两个选项是选择的对象。当它可用时（并非所有3D工具都有导出选项），FBX导出通常效果最佳，但如果你在没有FBX导出的工具上使用，COLLLADA也效果不错。在我们的案例中，Blender支持FBX导出，因此我们将使用该文件格式。
- en: glTF file format
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: glTF文件格式
- en: While FBX is the best 3D format with built-in support, you may instead want
    to use glTF files in Unity. This newer 3D file format sees increased use these
    days. The glTF specification is developed by the Khronos Group, the same people
    behind COLLADA, and they maintain a Unity add-on at [https://github.com/KhronosGroup/UnityGLTF](https://github.com/KhronosGroup/UnityGLTF).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FBX 是具有内置支持的最好3D格式，但你可能更愿意在Unity中使用glTF文件。这种较新的3D文件格式在当今越来越受欢迎。glTF规范由Khronos
    Group开发，他们是COLLADA背后的同一群人，并且他们在[https://github.com/KhronosGroup/UnityGLTF](https://github.com/KhronosGroup/UnityGLTF)维护了一个Unity插件。
- en: Personally, I find their glTF plugin unwieldy and prefer the GLTFUtility package
    made by a user named Siccity, available at [https://github.com/Siccity/GLTFUtility](https://github.com/Siccity/GLTFUtility).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我发现他们的glTF插件难以操控，更倾向于使用由名为Siccity的用户制作的GLTFUtility包，可在[https://github.com/Siccity/GLTFUtility](https://github.com/Siccity/GLTFUtility)找到。
- en: Note that the bottom of table 4.3 lists several 3D art applications. Unity allows
    you to directly drop those applications’ files into your project. This functionality
    seems handy at first but has some caveats.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表4.3的底部列出了几个3D艺术应用程序。Unity允许您直接将那些应用程序的文件拖放到您的项目中。这个功能看起来很方便，但也有一些注意事项。
- en: For starters, Unity doesn’t load those application files directly; instead,
    it exports the model behind the scenes and loads that exported file. Because the
    model is being exported to FBX anyway, it’s preferable to do that step explicitly.
    Furthermore, this export requires you to have the relevant application installed.
    This requirement is a big hassle if you plan to share files among multiple computers
    (for example, a team of developers working together). I don’t recommend using
    3D art application files directly in Unity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Unity不会直接加载那些应用程序文件；相反，它在幕后导出模型并加载那个导出的文件。因为模型无论如何都会被导出为FBX，所以最好显式执行这一步骤。此外，这个导出需要您安装相关的应用程序。如果您计划在多台计算机之间共享文件（例如，一个开发团队合作），这个要求会变得很麻烦。我不建议在Unity中直接使用3D艺术应用程序文件。
- en: 4.5.2 Exporting and importing the model
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 导出和导入模型
- en: All right, it’s time to export the model from Blender and then import it into
    Unity. First, open the bench in Blender and then choose File > Export > FBX. Once
    the file is saved, import it into Unity the same way that you import images. Drag
    the FBX file from the computer into Unity’s Project view or right-click in Project
    and choose Import New Asset. The 3D model will be copied into the Unity project
    and show up ready to be put in the scene.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在是时候从Blender中导出模型，然后将其导入到Unity中。首先，在Blender中打开长椅，然后选择文件 > 导出 > FBX。一旦文件保存，以相同的方式将其导入Unity，就像导入图片一样。将FBX文件从计算机拖到Unity的项目视图中，或者在项目上右键单击并选择导入新资产。3D模型将被复制到Unity项目中，并显示出来，准备放入场景中。
- en: NOTE The sample download includes the .blend file so that you can practice exporting
    the FBX file from Blender. Even if you don’t end up modeling anything yourself,
    you may need to convert downloaded models into a format Unity accepts. If you
    want to skip all steps involving Blender, use the provided FBX file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：示例下载包含 .blend 文件，以便您可以练习从Blender中导出FBX文件。即使您最终没有建模，您可能也需要将下载的模型转换为Unity接受的格式。如果您想跳过所有涉及Blender的步骤，请使用提供的FBX文件。
- en: You should change a few import settings immediately. First, Unity defaults imported
    models to a very small scale (refer to figure 4.15, which shows what you see in
    the Inspector when you select the model); change the Scale Factor to 50 to partially
    counteract the 0.01 unit conversion. You may also want to click the Generate Colliders
    check box, but that’s optional; without a collider, you can walk through the bench.
    Then, switch to the Animation tab in the import settings and deselect Import Animation
    (this model doesn’t have animation). Click Apply at the bottom after making these
    changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该立即更改一些导入设置。首先，Unity默认导入的模型规模非常小（参考图4.15，它显示了您在选择模型时在检查器中看到的内容）；将缩放因子更改为50以部分抵消0.01单位的转换。您还可能想点击生成碰撞体复选框，但这不是必需的；如果没有碰撞体，您可以穿过长椅。然后，切换到导入设置中的动画选项卡，并取消选择导入动画（此模型没有动画）。在做出这些更改后，在底部点击应用。
- en: '![CH04_F15_Hocking3](../Images/CH04_F15_Hocking3.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F15_Hocking3](../Images/CH04_F15_Hocking3.png)'
- en: Figure 4.15 Adjust import settings for the 3D model.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 调整3D模型的导入设置。
- en: 'That takes care of the imported mesh. Now for the texture. Import the bench
    texture (the image in figure 4.16) in the same way as the bricks for walls earlier:
    drag the image file from this project’s scratch folder into Unity’s Project view,
    or right-click in Project and select Import New Asset. The image looks somewhat
    odd, with different parts of the image appearing on different parts of the bench;
    the model’s texture coordinates were edited to define this mapping of image to
    mesh.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理好了导入的网格。现在轮到纹理了。以与之前为墙壁导入砖块相同的方式导入长椅纹理（图4.16中的图像）：将图像文件从本项目的初始文件夹拖到Unity的项目视图中，或者在项目中右键单击并选择导入新资产。图像看起来有些奇怪，图像的不同部分出现在长椅的不同部分；模型的纹理坐标被编辑以定义这种图像到网格的映射。
- en: '![CH04_F16_Hocking3](../Images/CH04_F16_Hocking3.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F16_Hocking3](../Images/CH04_F16_Hocking3.png)'
- en: Figure 4.16 The 2D image for the bench texture
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 长椅纹理的2D图像
- en: DEFINITION *Texture coordinates* are an extra set of values for each vertex
    that assign polygons to areas of the texture image. Think about it like wrapping
    paper; the 3D model is the box being wrapped, the texture is the wrapping paper,
    and the texture coordinates represent the points on the box where the wrapping
    paper will go.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 纹理坐标是每个顶点的一组额外值，用于将多边形分配到纹理图像的区域。把它想象成包装纸；3D模型是被包装的盒子，纹理是包装纸，而纹理坐标代表盒子上包装纸将放置的点。'
- en: NOTE Even if you don’t want to model the bench, you may want to read the detailed
    explanation of texture coordinates in appendix C. Texture coordinates (as well
    as other related terms like *UVs* and *mapping*) can be useful to understand when
    programming games.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 即使你不想建模长椅，你可能也想阅读附录C中关于纹理坐标的详细解释。纹理坐标（以及像*UVs*和*mapping*这样的其他相关术语）在游戏编程时可能很有用。'
- en: When Unity imported the FBX file, it also generated a material with the same
    settings as the material in Blender. If the image file used in Blender has been
    imported into Unity, the generated material will automatically link to that texture.
    If the automatic linkage doesn’t work right, or if you need to use a different
    texture image, then you can extract the model’s material for further editing.
    Refer back to figure 4.15; under the Materials tab, you should find a button labeled
    Extract Materials. Now you can select the material asset and then drag images
    to Albedo just as you did for brick walls.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity导入FBX文件时，它也会生成一个与Blender中材质设置相同的材质。如果Blender中使用的图像文件已经被导入Unity，生成的材质将自动链接到该纹理。如果自动链接不正确，或者你需要使用不同的纹理图像，那么你可以提取模型的材质进行进一步编辑。参考图4.15；在材质选项卡下，你应该找到一个标有提取材质的按钮。现在你可以选择材质资产，然后将图像拖到Albedo，就像你为砖墙所做的那样。
- en: New materials are often too shiny, so you may want to reduce the Smoothness
    setting to 0 (smoother surfaces are shinier). Finally, having adjusted everything
    as needed, you can put the bench in the scene. Drag the model up from the Project
    view and place it in one room of the level; as you drag the mouse, you should
    see it in the scene. Once you drop the bench in place, you should see something
    like figure 4.17\. Congratulations—you’ve created a textured model for the level!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 新材质通常太亮，所以你可能想将平滑度设置降低到0（更平滑的表面更亮）。最后，调整好所有需要调整的设置后，你可以将长椅放入场景中。从项目视图中拖动模型并将其放置在级别的某个房间中；当你拖动鼠标时，你应该能在场景中看到它。一旦将长椅放置到位，你应该能看到类似于图4.17的样子。恭喜你——你已经为级别创建了一个纹理模型！
- en: NOTE We’re not going to do it in this chapter, but typically, you’d also replace
    the whitebox geometry with models created in an external tool. The new geometry
    might look essentially identical, but you’ll have much more flexibility in controlling
    the texture.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 我们不会在本章中这样做，但通常，你还会用在外部工具中创建的模型替换白盒几何形状。新的几何形状可能看起来几乎相同，但你将拥有更多的灵活性来控制纹理。'
- en: '![CH04_F17_Hocking3](../Images/CH04_F17_Hocking3.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F17_Hocking3](../Images/CH04_F17_Hocking3.png)'
- en: Figure 4.17 The imported bench in the level
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 级别中导入的长椅
- en: Animating characters with Mecanim
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mecanim动画角色
- en: 'The model you created is static, sitting still where placed. You can also animate
    in Blender and then play the animation in Unity. The process of creating 3D animation
    is long and involved, and this isn’t a book about animation, so we’re not going
    to discuss that here. As has already been mentioned for modeling, a lot of existing
    resources can help you learn more about 3D animation. But be warned: it is a *huge*
    topic. There’s a reason *animator* is a specialized role within game development.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的模型是静态的，放置后保持静止。您也可以在Blender中动画化，然后在Unity中播放动画。创建3D动画的过程既漫长又复杂，但这不是一本关于动画的书，所以我们不会在这里讨论这个话题。正如已经提到的建模，许多现有资源可以帮助您学习更多关于3D动画的知识。但请注意：这是一个*巨大的*话题。*动画师*是游戏开发中的一个专门角色，这也是有原因的。
- en: Unity has a sophisticated system called Mecanim for managing animations on models.
    The special name Mecanim identifies the newer, more advanced animation system
    that was added to Unity as a replacement for the older animation system. The older
    system is still around, identified as legacy animation. But it may be phased out
    in a future version of Unity, at which point Mecanim will be *the* animation system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Unity有一个称为Mecanim的复杂系统，用于管理模型上的动画。特殊的名称Mecanim标识了作为旧动画系统的替代品添加到Unity中的较新、更先进的动画系统。旧的系统仍然存在，被称为遗留动画。但在Unity的下一个版本中，它可能会被淘汰，届时Mecanim将成为*唯一的*动画系统。
- en: Although we don’t work with any animations in this chapter, we’ll play animations
    on characters in future chapters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这个章节中没有处理任何动画，但我们在未来的章节中将在角色上播放动画。
- en: 4.6 Creating effects by using particle systems
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 通过粒子系统创建效果
- en: Besides 2D images and 3D models, the remaining type of visual content that game
    artists create is a particle system. The definition in this chapter’s introduction
    explained that particle systems are orderly mechanisms for creating and controlling
    large numbers of moving objects. Particle systems are useful for creating visual
    effects like fire, smoke, or spraying water. The fire effect in figure 4.18 was
    created using a particle system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了2D图像和3D模型之外，游戏艺术家创建的剩余视觉内容类型是粒子系统。本章引言中的定义解释说，粒子系统是创建和控制大量移动对象的有序机制。粒子系统对于创建如火焰、烟雾或喷水等视觉效果非常有用。图4.18中的火焰效果就是使用粒子系统创建的。
- en: '![CH04_F18_Hocking3](../Images/CH04_F18_Hocking3.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F18_Hocking3](../Images/CH04_F18_Hocking3.png)'
- en: Figure 4.18 Fire effect created using a particle system
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 使用粒子系统创建的火焰效果
- en: Whereas most other art assets are created in external tools and imported into
    the project, particle systems are created within Unity itself. Unity provides
    flexible and powerful tools for creating particle effects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他艺术资产在外部工具中创建并导入项目不同，粒子系统是在Unity内部创建的。Unity提供了灵活且强大的工具来创建粒子效果。
- en: NOTE Much like the situation with the Mecanim animation system, Unity used to
    have an older legacy particle system and gave its newer system a special name,
    Shuriken. At this point, the legacy particle system has been phased out, so the
    separate name is no longer necessary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与Mecanim动画系统的情况类似，Unity曾经有一个旧的遗留粒子系统，并为新的系统起了一个特殊名称，Shuriken。到目前为止，遗留粒子系统已经被淘汰，因此不再需要单独的名称。
- en: To begin, create a new particle system and watch the default effect play. From
    the GameObject menu, choose Effects > Particle System, and you’ll see basic white
    puffballs spraying upward from the new object. Or rather, you’ll see particles
    spraying upward while you have the object selected. When you select a particle
    system, the particle playback panel is displayed in the corner of the screen and
    indicates the amount of time that has elapsed (see figure 4.19).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的粒子系统并观察默认效果播放。从GameObject菜单中选择Effects > Particle System，您将看到基本白色烟雾球从新对象向上喷射。或者更确切地说，当您选择对象时，您会看到粒子向上喷射。当您选择粒子系统时，粒子播放面板显示在屏幕角落，并指示已过去的时间（见图4.19）。
- en: '![CH04_F19_Hocking3](../Images/CH04_F19_Hocking3.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F19_Hocking3](../Images/CH04_F19_Hocking3.png)'
- en: Figure 4.19 Playback panel for a particle system
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 粒子系统的播放面板
- en: The default effect looks pretty neat already, but let’s go through parameters
    you can use to customize the effect.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认效果看起来已经很漂亮了，但让我们来看看您可以用来自定义效果的参数。
- en: 4.6.1 Adjusting parameters on the default effect
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 调整默认效果的参数
- en: Figure 4.20 shows the entire list of settings for a particle system. We’re not
    going to go through every single setting in that list; instead, we’ll look at
    those relevant to making the fire effect. Once you understand how a few of the
    settings work, the rest should be fairly self-explanatory. Each setting’s label
    is, in fact, a whole information panel. Initially, only the first information
    panel is expanded; the rest of the panels are collapsed. Click the setting’s label
    to expand that information panel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20显示了粒子系统的所有设置列表。我们不会逐个查看列表中的每个设置；相反，我们将关注那些与制作火焰效果相关的设置。一旦你理解了几个设置的工作原理，其余的应该相当容易理解。实际上，每个设置的标签都是一个完整的信息面板。最初，只有第一个信息面板是展开的；其余的面板都是折叠的。点击设置的标签以展开该信息面板。
- en: 'TIP Many of the settings are controlled by a curve displayed at the bottom
    of the Inspector. That curve represents how the value changes over time: the left
    side of the graph indicates when the particle first appears, the right side indicates
    when the particle is gone, the bottom is a value of 0, and the top is the maximum
    value. Drag points around the graph and double-click or right-click the curve
    to insert new points.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：许多设置由检查器底部的曲线控制。这条曲线表示值随时间的变化：图表的左侧表示粒子首次出现的时间，右侧表示粒子消失的时间，底部是0的值，顶部是最大值。在图表周围拖动点，或双击或右击曲线以插入新点。
- en: Adjust parameters of the particle system as indicated in figure 4.20, and it’ll
    look more like a jet of flame.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图4.20中的指示调整粒子系统的参数，它看起来会更像一团火焰。
- en: '![CH04_F20_Hocking3](../Images/CH04_F20_Hocking3.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F20_Hocking3](../Images/CH04_F20_Hocking3.png)'
- en: Figure 4.20 The Inspector displays settings for a particle system (pointing
    out settings for the fire effect).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 检查器显示粒子系统的设置（突出显示火焰效果的设置）。
- en: 4.6.2 Applying a new texture for fire
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 为火焰应用新的纹理
- en: Now the particle system looks more like a jet of flame, but the effect still
    needs the particles to look like flame, not white blobs. That requires importing
    a new image into Unity. Figure 4.21 depicts the image I painted; I made an orange
    dot and used the Smudge tool to draw out the tendrils of the flame (and then I
    drew the same thing in yellow).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在粒子系统看起来更像一团火焰，但效果仍然需要粒子看起来像火焰，而不是白色的团块。这需要将一个新的图像导入到Unity中。图4.21展示了我所绘制的图像；我画了一个橙色的小点，并使用涂抹工具绘制出火焰的触须（然后我用黄色绘制了同样的东西）。
- en: '![CH04_F21_Hocking3](../Images/CH04_F21_Hocking3.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F21_Hocking3](../Images/CH04_F21_Hocking3.png)'
- en: Figure 4.21 The image used for fire particles
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 用于火焰粒子的图像
- en: Whether you use this image from the sample project, draw your own, or download
    a similar one, you need to import the image file into Unity. As explained previously,
    drag image files into the Project view, or choose Assets > Import New Asset.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用示例项目中的这个图像，绘制自己的图像，还是下载一个类似的图像，你都需要将图像文件导入到Unity中。如前所述，将图像文件拖动到项目视图中，或者选择“资产”>“导入新资产”。
- en: 'Just as with 3D models, textures aren’t applied to particle systems directly.
    You add the texture to a material and apply that material to the particle system.
    Create a new material and then select it to see its properties in the Inspector.
    Drag the fire image from Project up to the texture slot. That links the fire texture
    to the fire material, so now you want to apply the material to the particle system.
    Figure 4.22 shows how to do this: select the particle system, expand Renderer
    at the bottom of the settings, and drag the material onto the Material slot.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像3D模型一样，纹理不是直接应用于粒子系统的。你将纹理添加到材质中，然后将该材质应用于粒子系统。创建一个新的材质，然后选择它以在检查器中查看其属性。将火焰图像从项目拖动到纹理槽中。这样就将火焰纹理链接到火焰材质，因此现在你想要将材质应用于粒子系统。图4.22显示了如何进行此操作：选择粒子系统，在设置底部展开渲染器，然后将材质拖动到材质槽中。
- en: '![CH04_F22_Hocking3](../Images/CH04_F22_Hocking3.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F22_Hocking3](../Images/CH04_F22_Hocking3.png)'
- en: Figure 4.22 Assign a material to the particle system.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 将材质分配给粒子系统。
- en: As you did for the skybox material, you need to change the shader for a particle
    material. Click the Shader menu near the top of the material settings to see the
    list of available shaders. Instead of the standard default, a material for particles
    needs one of the shaders under the Particles submenu. As shown in figure 4.23,
    in this case, we want Standard Unlit. Now switch the material’s Rendering Mode
    to Additive. This will make the particles appear to be hazy and brighten the scene,
    just like a fire.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 就像为天空盒材质所做的，你需要更改粒子材质的着色器。在材质设置中靠近顶部的着色器菜单处单击，以查看可用的着色器列表。对于粒子材质，除了标准默认设置外，还需要在“粒子”子菜单下的着色器之一。如图4.23所示，在这种情况下，我们想要标准非光照。现在将材质的渲染模式切换到加性。这将使粒子看起来像雾蒙蒙的，并使场景变亮，就像火光一样。
- en: '![CH04_F23_Hocking3](../Images/CH04_F23_Hocking3.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F23_Hocking3](../Images/CH04_F23_Hocking3.png)'
- en: Figure 4.23 Setting the shader for the fire particle material
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 设置火粒子材质的着色器
- en: DEFINITION *Additive* is a shader effect that adds the color of the particle
    to the color behind it, as opposed to replacing the pixels. This makes the pixels
    brighter and makes black on the particle turn invisible. These shaders have the
    same visual effect as the Additive layer effect in Photoshop.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*加性*是一种着色器效果，它将粒子的颜色添加到其后面的颜色上，而不是替换像素。这使得像素变得更亮，使得粒子上的黑色变得不可见。这些着色器与Photoshop中加性图层效果具有相同的视觉效果。
- en: WARNING Changing this shader may cause Unity to emit a warning about needing
    to apply to systems. Click the Apply to Systems button at the bottom of the Inspector.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：更改此着色器可能会导致Unity发出需要应用到系统的警告。在检查器底部单击“应用到系统”按钮。
- en: With the fire material assigned to the fire particle effect, it’ll now look
    like figure 4.18\. This looks like a pretty convincing jet of flame, but the effect
    doesn’t work only when sitting still. Next, let’s attach it to an object that
    moves around.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将火材质分配给火粒子效果后，现在看起来就像图4.18所示。这看起来像一股相当逼真的火焰，但效果不仅仅在静止时才起作用。接下来，让我们将其附加到一个移动的对象上。
- en: 4.6.3 Attaching particle effects to 3D objects
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 将粒子效果附加到3D对象
- en: Create a sphere (remember, GameObject > 3D Object > Sphere). Create a new script
    called BackAndForth and attach it to the new sphere.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个球体（记住，GameObject > 3D Object > Sphere）。创建一个新的脚本，命名为BackAndForth，并将其附加到新球体上。
- en: Listing 4.1 Moving an object back and forth along a straight path
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 沿直线路径移动对象
- en: '[PRE0]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ These are the positions the object moves between.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些是对象移动之间的位置。
- en: ❷ Which direction is the object currently moving in?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对象当前正在向哪个方向移动？
- en: ❸ Toggle the direction back and forth.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 切换方向来回。
- en: ❹ Apply a second movement in the new direction if the object switched directions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果对象改变了方向，则在新的方向上应用第二个移动。
- en: Run this script, and the sphere glides back and forth in the central corridor
    of the level. Now you can make the particle system a child of the sphere, and
    the fire will move with the sphere. Just as with the walls of the level, in the
    Hierarchy view, drag the particle object onto the sphere object.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本，球体将在该级别的中央走廊来回滑动。现在你可以将粒子系统设置为球体的子对象，火光将随球体移动。就像该级别的墙壁一样，在层次结构视图中，将粒子对象拖动到球体对象上。
- en: WARNING You usually have to reset the position of an object after making it
    the child of another object. For example, we want the particle system at 0, 0,
    0 (this is relative to the parent). Unity will preserve the placement of an object
    from before it was linked as a child.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：通常在将对象设置为另一个对象的子对象后，需要重置对象的位置。例如，我们希望粒子系统位于0, 0, 0（这是相对于父对象的）。Unity将保留对象在链接为子对象之前的位置。
- en: Now the particle system moves along with the sphere. However, the fire isn’t
    deflecting from the movement, which looks unnatural. That’s because, by default,
    particles move correctly only in the local space of the particle system. To complete
    the flaming sphere, find Simulation Space in the particle system settings (it’s
    in the top panel of figure 4.20) and switch from Local to World.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在粒子系统会随球体移动。然而，火光并没有随着移动而偏转，这看起来很不自然。这是因为，默认情况下，粒子只在粒子系统的局部空间中正确移动。为了完成燃烧的球体，在粒子系统设置中找到“模拟空间”（位于图4.20顶部的面板中）并将它从局部切换到世界。
- en: NOTE In this script, the object moves back and forth in a straight line, but
    video games commonly have objects moving around complex paths. Unity comes with
    support for complex navigation and paths; see [https://docs.unity3d .com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html)
    to read about it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这个脚本中，对象在一条直线上来回移动，但视频游戏通常有对象在复杂的路径上移动。Unity提供了对复杂导航和路径的支持；请参阅[https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html)了解相关信息。
- en: I’m sure that, at this point, you’re itching to apply your own ideas and add
    more content to this sample game. You should do that—you could create more art
    assets, or even test your skills by bringing in the shooting mechanics developed
    in chapter 3\. In the next chapter, we’ll switch gears to a different game genre
    and start over with a new game. Even though future chapters will switch to other
    game genres, everything from these first four chapters will still apply and be
    useful.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，到这个时候，你一定迫不及待地想应用自己的想法，并为这个示例游戏添加更多内容。你应该这么做——你可以创建更多的艺术资产，或者甚至通过引入第3章中开发的射击机制来测试你的技能。在下一章中，我们将转换到不同的游戏类型，并从一个新的游戏开始。即使未来的章节将切换到其他游戏类型，这些前四章中的所有内容仍然适用并且有用。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '*Art asset* is the term for all individual graphics.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*艺术资产*是指所有单个图形的术语。'
- en: Whiteboxing is a useful first step for level designers to block out spaces.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白盒是关卡设计师用来勾勒空间的有用第一步。
- en: Textures are 2D images displayed on the surface of 3D models.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理是显示在3D模型表面的二维图像。
- en: 3D models are created outside Unity and imported as FBX files.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D模型是在Unity之外创建的，并以FBX文件的形式导入。
- en: Particle systems are used to create many visual effects (fire, smoke, water,
    and so on).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统用于创建许多视觉效果（如火焰、烟雾、水等）。
