- en: Appendix C. API authorization using an identity provider
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. 使用身份提供者进行API授权
- en: In chapter 11, you learned how the Open Authorization (OAuth) and the OpenID
    Connect (OIDC) protocols work. You also learned how to produce, inspect, and validate
    JSON Web Tokens (JWTs). Finally, you learned a pattern for adding authorization
    middleware to your APIs. The question we still need to answer is, how do we build
    an end-to-end authentication and authorization system?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中，你学习了开放授权（OAuth）和开放ID连接（OIDC）协议的工作原理。你还学习了如何生成、检查和验证JSON Web Tokens（JWT）。最后，你学习了向API添加授权中间件的模式。我们仍需回答的问题是，我们如何构建一个端到端的身份验证和授权系统？
- en: You can use various strategies to handle authentication and authorization. You
    can build your own authentication service, or you can use an identity-as-a-service
    provider, such as Auth0, Okta, Azure Active Directory, or AWS Cognito. Unless
    you’re an expert in web security and authentication protocols and have sufficient
    resources to build the system correctly, I recommend you use an identity service
    provider. In this appendix, you’ll learn to add authentication to your APIs with
    Auth0, which is one of the most popular identity management systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种策略来处理身份验证和授权。你可以构建自己的身份验证服务，或者使用身份即服务提供商，如Auth0、Okta、Azure Active Directory或AWS
    Cognito。除非你是网络安全和身份验证协议的专家，并且有足够的资源正确构建系统，否则我建议你使用身份服务提供商。在本附录中，你将学习如何使用Auth0为你的API添加身份验证，Auth0是最受欢迎的身份管理系统之一。
- en: We’ll use Auth0’s free plan. Auth0 takes care of managing user accounts and
    issuing secure tokens, and it also provides easy integrations for social login
    with identity providers such as Google, Facebook, Twitter, and others. Auth0’s
    authentication system is built on standards, so everything you learn about authenticating
    with Auth0 applies to any other provider. If you use a different authentication
    system in your own projects or at work, you’ll be able to take the lessons from
    this appendix and apply them to whichever other system you use.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Auth0的免费计划。Auth0负责管理用户账户和发放安全令牌，它还提供了与Google、Facebook、Twitter等身份提供者的社交登录的简单集成。Auth0的身份验证系统基于标准，因此你关于使用Auth0进行身份验证所学的所有内容都适用于任何其他提供商。如果你在自己的项目或工作中使用不同的身份验证系统，你将能够将本附录中的经验教训应用到你所使用的任何其他系统上。
- en: The code for this appendix is available under the appendix_c folder in the GitHub
    repository for this book. I recommend you pull this code to follow along with
    the examples, in particular, the folder named appendix_c/ui since you’ll need
    it to run the examples in section C.2.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的代码可在本书GitHub仓库的附录_c文件夹中找到。我建议你拉取此代码以跟随示例，特别是名为appendix_c/ui的文件夹，因为你将需要它来运行C.2节中的示例。
- en: C.1 Using an identity as a service provider
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 使用身份即服务提供商
- en: This section explains how to integrate our code with an identity-as-a-service
    (IDaaS) provider. An IDaaS provider is a service that takes care of handling user
    authentication and issuing access tokens for our users. Using an IDaaS provider
    is convenient, since it means we can focus our time and efforts on building our
    APIs. Good IDaaS providers are built on standards and with strong security protocols,
    which also reduces the security risks of our servers. In this section, you’ll
    learn how to build an integration with Auth0, which is one of the most popular
    IDaaS providers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何将我们的代码与身份即服务（IDaaS）提供商集成。IDaaS提供商是一种负责处理用户身份验证和为我们的用户提供访问令牌的服务。使用IDaaS提供商很方便，因为它意味着我们可以将时间和精力集中在构建我们的API上。好的IDaaS提供商基于标准并具有强大的安全协议，这也有助于降低我们服务器的安全风险。在本节中，你将学习如何与Auth0建立集成，Auth0是最受欢迎的IDaaS提供商之一。
- en: To work with Auth0, first create an account, and then create a tenant following
    Auth0’s documentation ([https://auth0.com/docs/get-started](https://auth0.com/docs/get-started)).
    As a first step, go to your dashboard and create an API to represent the orders
    API. Configure it as shown in figure C.1, giving it http://127.0.0.1:8000/orders
    as the identifier’s value and selecting the RS256 signing algorithm.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Auth0一起工作，首先创建一个账户，然后根据Auth0的文档（[https://auth0.com/docs/get-started](https://auth0.com/docs/get-started)）创建一个租户。作为第一步，前往你的仪表板并创建一个API来表示订单API。按照图C.1进行配置，将其标识符的值配置为http://127.0.0.1:8000/orders，并选择RS256签名算法。
- en: '![](../Images/C-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/C-1.png)'
- en: Figure C.1 To create a new API, click the Create API button, and fill in the
    form with the API’s name, its URL identifier, and the signing algorithm you want
    to use for its access tokens.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.1 要创建一个新的API，请点击创建API按钮，并在表单中填写API的名称、其URL标识符以及你想要用于其访问令牌的签名算法。
- en: Once you’ve created the API, go to Permissions and add a permission scope to
    the API, as shown in figure C.2.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了API，前往权限并添加一个权限范围到API，如图C.2所示。
- en: '![](../Images/C-2.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片C-2](../Images/C-2.png)'
- en: Figure C.2 To add permission scopes to the API, click on the Permissions tab,
    and fill in the Add a Permission (Scope) form.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.2 要向API添加权限范围，请点击权限选项卡，并填写添加权限（范围）表单。
- en: Next, click Settings on the left-side bar, and then click the Custom Domains
    tab, as shown in figure C.3.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击左侧栏的设置，然后点击自定义域名选项卡，如图C.3所示。
- en: '![](../Images/C-3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片C-3](../Images/C-3.png)'
- en: Figure C.3 To find out your tenant’s default domain, go to the tenant’s settings
    page and click the Custom Domains tab.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.3 要找出你的租户默认域名，请转到租户设置页面并点击自定义域名选项卡。
- en: 'You can add a custom domain if you want, or you can use Auth0’s default domain
    for your tenant. We use this domain to build the well-known URL of our authentication
    service:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要，你可以添加一个自定义域名，或者你可以使用Auth0为你的租户提供的默认域名。我们使用这个域名来构建我们认证服务的知名URL：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, for CoffeeMesh, the tenant’s domain is [https://coffeemesh-dev.eu.auth0.com/.well-known/openid-configuration](https://coffeemesh-dev.eu.auth0.com/.well-known/openid-configuration).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于CoffeeMesh，租户的域名是[https://coffeemesh-dev.eu.auth0.com/.well-known/openid-configuration](https://coffeemesh-dev.eu.auth0.com/.well-known/openid-configuration)。
- en: 'Now make a call to this URL, and capture the `jwks_uri` property, which represents
    the URL that returns the public keys we can use to verify Auth0’s tokens. Here’s
    an example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用这个URL，并捕获`jwks_uri`属性，它表示返回我们可以用来验证Auth0令牌的公钥的URL。以下是一个示例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you call this URL, you’ll get an array of objects, each of which contains
    information about each of your tenant’s public keys. Each object looks like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用这个URL，你会得到一个包含每个租户公钥信息的对象数组。每个对象看起来像这样：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The two most important fields in this payload are `kid` and `x5c`. `kid` is
    the ID of the key, and we use it to match the `kid` field of the JWT’s header
    section. It tells us which key we need to use to verify the token’s signature.
    The `x5c` field contains an array of public keys in the form of X.509 certificates,
    the first of which we use to verify the JWT’s signature.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个有效载荷中，最重要的两个字段是`kid`和`x5c`。`kid`是密钥的ID，我们用它来匹配JWT头部的`kid`字段。它告诉我们需要使用哪个密钥来验证令牌的签名。`x5c`字段包含一个以X.509证书形式存在的公钥数组，我们使用其中的第一个来验证JWT的签名。
- en: This is all the information we need to integrate our code with Auth0\. We’ll
    implement our Auth0 integration in the orders/web/api/auth.py module, which we
    created in chapter 11 (section 11.4.1) to encapsulate our authorization code.
    Delete the contents of orders/web/api/auth.py, and replace them with the contents
    of listing C.1\. We first import the necessary dependencies, create a template
    for the X.509 certificate, and load the public keys from the well-known endpoint.
    X.509 certificates are wrapped between `-----BEGIN` `CERTIFICATE-----` and `-----END`
    `CERTIFICATE-----` statements, so our template includes both statements with a
    template variable named `key`, which we’ll replace with the actual key.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们集成我们的代码与Auth0所需的所有信息。我们将在第11章（11.4.1节）中创建的orders/web/api/auth.py模块中实现我们的Auth0集成，该模块用于封装我们的授权代码。删除orders/web/api/auth.py的内容，并用列表C.1的内容替换。我们首先导入必要的依赖项，创建X.509证书的模板，并从知名端点加载公钥。X.509证书被包裹在`-----BEGIN
    CERTIFICATE-----`和`-----END CERTIFICATE-----`语句之间，因此我们的模板包括这两个语句，并使用一个名为`key`的模板变量，我们将用实际密钥替换它。
- en: Since Auth0 uses several keys to sign the tokens, we load the public keys by
    calling the JWKS endpoint, and we dynamically load the right key for the given
    token. As you can see in figure C.4, the `kid` property in the token’s headers
    tells us which key we need to use, and our custom function `_get_certificate_for_kid()`
    finds the X.509 certificate for the token’s `kid`. To load the key, we use `cryptography`’s
    `load_pem_x509_certificate()` function, passing in the public key formatted into
    our X.509 byte-encoded certificate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Auth0 使用多个密钥来签名令牌，我们通过调用 JWKS 端点来加载公钥，并动态加载给定令牌的正确密钥。如图 C.4 所示，令牌头部的 `kid`
    属性告诉我们需要使用哪个密钥，我们的自定义函数 `_get_certificate_for_kid()` 找到令牌的 `kid` 对应的 X.509 证书。为了加载密钥，我们使用
    `cryptography` 的 `load_pem_x509_certificate()` 函数，传入格式化为我们的 X.509 字节编码证书的公钥。
- en: '![](../Images/C-4.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/C-4.png)'
- en: Figure C.4 To validate a JWT, we verify its signature using its corresponding
    signing key. The signing key is available in the JWKS endpoint.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.4 要验证 JWT，我们使用其对应的签名密钥验证其签名。签名密钥可在 JWKS 端点找到。
- en: Since tokens can be signed with different algorithms, we fetch the algorithms
    directly from the token’s headers. Auth0 issues tokens that can access both our
    API and the user information API, so we include both services in the audience.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于令牌可以使用不同的算法进行签名，我们直接从令牌的头部获取算法。Auth0 签发的令牌可以访问我们的 API 和用户信息 API，因此我们在受众中包含这两个服务。
- en: Listing C.1 Adding an authorization module to the API
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.1 向 API 添加授权模块
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① Template for a X509 certificate
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ① X509 证书的模板
- en: ② We pull the list of signing keys from the tenant’s well-known endpoint.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们从租户的已知端点拉取签名密钥列表。
- en: ③ Function that returns the certificate for a given key ID
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 返回给定密钥 ID 的证书的函数
- en: ④ We look for the certificate that matches the supplied key ID.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们寻找与提供的密钥 ID 匹配的证书。
- en: ⑤ If a match isn’t found, we raise an exception.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果找不到匹配项，我们抛出异常。
- en: ⑥ Function that loads the public key object for a given certificate
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 加载给定证书的公钥对象的函数
- en: ⑦ We load the public key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们加载公钥。
- en: ⑧ Function that decodes and validates a JWT
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 解码和验证 JWT 的函数
- en: ⑨ We fetch the token’s headers without verification.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 我们获取令牌的头部信息而不进行验证。
- en: ⑩ We fetch the certificate corresponding to the token’s key ID.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 我们获取与令牌的密钥 ID 对应的证书。
- en: ⑪ We load the certificate’s public key object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 我们加载与令牌的密钥 ID 对应的证书的公钥对象。
- en: ⑫ We validate and decode the token.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 我们验证并解码令牌。
- en: ⑬ We verify the token’s signature using the algorithm indicated in the token’s
    header.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 我们使用令牌头部指示的算法验证令牌的签名。
- en: ⑭ We pass the list of expected audiences for the token.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 我们传递令牌预期的受众列表。
- en: We’re ready to go! The orders service is now able to validate tokens issued
    by Auth0\. The following sections illustrate how to leverage this integration
    to make our API server accessible to a single-page application (SPA) and to another
    microservice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备出发！订单服务现在能够验证由 Auth0 签发的令牌。以下章节将说明如何利用此集成使我们的 API 服务器对单页应用（SPA）和另一个微服务可用。
- en: C.2 Using the PKCE authorization flow
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 使用 PKCE 授权流程
- en: In the PKCE flow, the API client requests an ID token and an access token directly
    from the authorization server. As we explained in chapter 11, we must use the
    access token to interact with the API server. The ID token can be used in the
    UI to show the details of the user, but it must never be sent to our API server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PKCE 流程中，API 客户端直接从授权服务器请求 ID 令牌和访问令牌。正如我们在第 11 章中解释的，我们必须使用访问令牌与 API 服务器交互。ID
    令牌可以在 UI 中用于显示用户的详细信息，但它绝不能发送到我们的 API 服务器。
- en: To illustrate how this flow works, I’ve included an SPA under the appendix_c/ui
    directory in the GitHub repository for this book. The SPA is a simple application
    built with Vue.js that talks to the orders API, and it’s configured to authenticate
    with an Auth0 server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明此流程的工作原理，我在本书的 GitHub 仓库的附录_c/ui 目录下包含了一个 SPA。该 SPA 是一个使用 Vue.js 构建的简单应用程序，它与订单
    API 进行通信，并配置为使用 Auth0 服务器进行身份验证。
- en: 'We’ll first configure the application. Go to your Auth0 account, and create
    a new application. Select Single Page Web Applications, and give it a name, then
    click Create. In the application’s settings page, under the Application URIs section,
    give the value of http://localhost:8000 to the Allowed Callback URLs, the Allowed
    Logout URLs, the Allowed Web Origins, and the Allowed Origins (CORS) fields. From
    the application’s settings, we need two values to configure our application: the
    domain and the client ID. Open the ui/.env.local file, and replace the value for
    `VUE_APP_ AUTH_CLIENT_ID` with the client ID and `VUE_APP_AUTH_DOMAIN` with the
    domain from your application’s settings page in Auth0.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先配置应用程序。转到您的Auth0账户，创建一个新的应用程序。选择单页Web应用程序，给它一个名称，然后点击创建。在应用程序设置页面中，在应用程序URI部分，将http://localhost:8000的值分配给允许回调URL、允许注销URL、允许Web来源和允许来源（CORS）字段。从应用程序设置中，我们需要两个值来配置我们的应用程序：域名和客户端ID。打开ui/.env.local文件，并将`VUE_APP_AUTH_CLIENT_ID`的值替换为客户端ID，将`VUE_APP_AUTH_DOMAIN`替换为Auth0应用程序设置页面中的域名。
- en: 'To run the UI, you need an up-to-date version of Node.js and npm, which you
    can download from the node.js website ([https://nodejs.org/en/](https://nodejs.org/en/)).
    Once you’ve installed these, you need to install yarn with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行UI，您需要一个最新的Node.js和npm版本，您可以从node.js网站下载（[https://nodejs.org/en/](https://nodejs.org/en/)）。一旦安装了这些，您需要使用以下命令安装yarn：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, `cd` into the ui/ folder, and install the dependencies by running the
    following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`cd`到ui/文件夹，并运行以下命令来安装依赖项：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the application is configured, you can run it by executing the following
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了应用程序，您可以通过执行以下命令来运行它：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The application will become available under the http://localhost:8080 address.
    Make sure the orders API is also running, since the Vue.js application talks to
    it. To run the orders API, run the following command from the orders folder:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将在http://localhost:8080地址下可用。请确保订单API也在运行，因为Vue.js应用程序会与之通信。要从订单文件夹运行订单API，请执行以下命令：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you register a user through the UI, you’ll be able to see your authorization
    token in the UI. You can use this token to call the API directly from the terminal.
    For example, you can get a list of orders for your user by calling the API with
    the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您通过UI注册了用户，您将能够在UI中看到您的授权令牌。您可以使用此令牌直接从终端调用API。例如，您可以通过以下命令获取您用户的订单列表：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Through the Vue.js application, you can create new orders and display the orders
    placed by the user by clicking the Show My Orders button.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Vue.js应用程序，您可以通过点击“显示我的订单”按钮创建新订单并显示用户放置的订单。
- en: The PKCE flow works for users accessing your APIs through the browser. However,
    this flow isn’t convenient for machine-to-machine communication. To allow more
    programmatic access to your APIs, you need to support the client credentials flow.
    In the next section, we explain how to enable that flow!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PKCE流适用于通过浏览器访问您的API的用户。然而，这种流对于机器到机器通信来说并不方便。为了允许对API进行更多程序化访问，您需要支持客户端凭据流。在下一节中，我们将解释如何启用该流！
- en: C.3 Using the client credentials flow
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 使用客户端凭据流
- en: This section explains how to implement the client credentials flow for server-to-server
    communication. We use the server-to-server flow when we must authenticate our
    own services to access other APIs, or when we want to allow programmatic access
    to our APIs. In the client credentials flow, our services request an access token
    from the authentication service by providing a shared secret with the client ID
    and the desired audience. We can then use this access token to access the API
    of the target audience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何实现客户端凭据流以实现服务器到服务器的通信。当我们必须对我们的服务进行身份验证以访问其他API，或者当我们想允许对API进行程序化访问时，我们使用服务器到服务器的流。在客户端凭据流中，我们的服务通过提供与客户端ID和期望受众共享的秘密来从认证服务请求访问令牌。然后我们可以使用这个访问令牌来访问目标受众的API。
- en: To use this authorization flow, you need to register a server-to-server client
    with your IDaaS provider. In your Auth0 dashboard’s applications page, click Create
    Application and select Machine to Machine Applications. Give it a name, and click
    Create. On the next screen, where you’re asked to select the API you want to authorize
    this client for, select the orders API, and then select the permission we created
    in chapter 11 (section 11.6). Once you’ve registered the client, you get a client
    ID and a client secret, which you can use to obtain access tokens.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此授权流程，您需要使用您的IDaaS提供商注册一个服务器到服务器的客户端。在您的Auth0仪表板的“应用程序”页面中，点击“创建应用程序”并选择“机器到机器应用程序”。给它起一个名字，然后点击“创建”。在下一屏幕上，当您被要求选择要为此客户端授权的API时，选择订单API，然后选择我们在第11章（第11.6节）中创建的权限。一旦注册了客户端，您将获得一个客户端ID和一个客户端密钥，您可以使用它们来获取访问令牌。
- en: Listing C.2 shows how to implement server-to-server authorization to obtain
    an access token and make a call to the orders API. The code in listing C.2 is
    available in the book’s GitHub repository under the machine_to_machine_test.py
    file. We create a function to obtain the access token from the authorization server
    by calling the POST `https://coffeemesh-dev.eu.auth0.com/oauth/token` endpoint.
    In the payload, we provide the client ID and the client secret, and we specify
    the audience for which we want to generate the access token. We also declare that
    we want to use the client credentials flow under the `grant_type` property. If
    the client is correctly authenticated, we get back an access token, which we then
    use to call the orders API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.2展示了如何实现服务器到服务器的授权以获取访问令牌并调用订单API。列表C.2中的代码可在本书的GitHub仓库中找到，位于machine_to_machine_test.py文件下。我们创建了一个函数，通过调用POST
    `https://coffeemesh-dev.eu.auth0.com/oauth/token`端点从授权服务器获取访问令牌。在有效载荷中，我们提供了客户端ID和客户端密钥，并指定了我们想要生成访问令牌的受众。我们还声明我们想要在`grant_type`属性下使用客户端凭据流。如果客户端认证正确，我们将获得一个访问令牌，然后我们使用它来调用订单API。
- en: Listing C.2 Authorizing a client for machine-to-machine access to the orders
    API
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表C.2 为机器到机器访问订单API授权客户端
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s all it takes to use the client credentials flow! In the next section,
    you’ll learn to authenticate your requests using a Swagger UI so that you can
    test your API more easily.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端凭据流只需这些步骤！在下一节中，您将学习如何使用Swagger UI进行请求认证，以便您可以更轻松地测试您的API。
- en: C.4 Authorizing requests in the Swagger UI
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.4 在Swagger UI中授权请求
- en: 'Over the course of this book, you’ve learned to test your APIs using a Swagger
    UI. You can use the Swagger UI to test your API authorization as well, and in
    this section you’ll learn how. First, `cd` into appendix_c/orders and up the API
    server with authorization on:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，您已经学会了使用Swagger UI测试您的API。您可以使用Swagger UI来测试您的API授权，在本节中您将学习如何操作。首先，`cd`到附录C的orders目录，并带上授权启动API服务器：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can now access the Swagger UI on http://localhost:8000/docs/orders. As you
    can see in figure C.5, if you try any of the endpoints, you’ll get a 401 response
    since we haven’t authorized our requests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以访问http://localhost:8000/docs/orders上的Swagger UI。如图C.5所示，如果您尝试任何端点，您将收到401响应，因为我们尚未授权我们的请求。
- en: '![](../Images/C-5.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图C-5](../Images/C-5.png)'
- en: Figure C.5 If we make an unauthorized request with the Swagger UI, we’ll get
    a 401 response.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.5 如果我们使用Swagger UI进行未经授权的请求，我们将收到401响应。
- en: 'To authorize a request, click the Authorize button on the top-right corner
    of the screen. You’ll get a pop-up menu with the security schemes documented in
    the API specification: `openId` (authorization code and PKCE flows), `oauth2`
    (client credentials flow), and `bearerAuth`. The easiest way to test the API’s
    authorization layer is using the `bearerAuth` security scheme, since it only requires
    you to feed the authorization token. You can produce a token with the Vue.js application
    under appendix_c/ui or using the machine_to_machine_test.py script. For example,
    if you run the machine_to_machine_ test.py script, you’ll get a token and the
    result of creating an order:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要授权一个请求，点击屏幕右上角的“授权”按钮。您将获得一个弹出菜单，其中包含API规范中记录的安全方案：“openId”（授权代码和PKCE流程）、“oauth2”（客户端凭据流）和“bearerAuth”。测试API授权层最简单的方法是使用“bearerAuth”安全方案，因为它只需要您提供授权令牌。您可以使用Vue.js应用程序在附录C的ui或使用machine_to_machine_test.py脚本生成令牌。例如，如果您运行machine_to_machine_test.py脚本，您将获得一个令牌和创建订单的结果：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Copy the token, and paste it into the value input field of the `bearerAuth`’s
    security scheme, as shown in figure C.6, and then click Authorize. If you send
    a request to the GET `/orders` endpoint now, you’ll get a successful response.
    While the token is valid (i.e., before it expires), you can try any other endpoint,
    and your requests will be successfully processed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 复制令牌，并将其粘贴到`bearerAuth`安全方案的值输入字段中，如图C.6所示，然后点击授权。如果你现在向GET `/orders`端点发送请求，你会得到一个成功的响应。在令牌有效（即，在它过期之前），你可以尝试任何其他端点，你的请求将会被成功处理。
- en: '![](../Images/C-6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图C.6](../Images/C-6.png)'
- en: Figure C.6 To authorize a request, paste the authorization token into the value
    input from `bearerAuth`’s form.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.6 要授权一个请求，请将授权令牌粘贴到`bearerAuth`表单的值输入框中。
- en: This is all it takes to test your API authorization with a Swagger UI. You just
    learned how to add a robust authentication and authorization layer by integrating
    with an external identity provider, how to test the PKCE and the client credentials
    flows, and how to test your API authorization implementation with Swagger. You’re
    all set to go and build secure APIs!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Swagger UI测试你的API授权的全部步骤。你刚刚学习了如何通过集成外部身份提供者来添加一个强大的身份验证和授权层，如何测试PKCE和客户端凭证流程，以及如何使用Swagger测试你的API授权实现。你现在可以开始构建安全的API了！
