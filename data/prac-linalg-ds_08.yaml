- en: Chapter 8\. Matrix Inverse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章 矩阵的逆
- en: We are moving toward solving matrix equations. Matrix equations are like regular
    equations (e.g., solve for *x* in 4*x* = 8) but…they have matrices. By this point
    in the book, you are well aware that things get complicated when matrices get
    involved. Nonetheless, we must embrace that complexity, because solving matrix
    equations is a huge part of data science.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向解决矩阵方程迈进。矩阵方程类似于普通方程（例如，在 4*x* = 8 中解出 *x*），但是……它们包含矩阵。到了书的这一部分，你已经清楚，当涉及到矩阵时，事情变得复杂。尽管如此，我们必须接受这种复杂性，因为解矩阵方程是数据科学的重要组成部分。
- en: The matrix inverse is central to solving matrix equations in practical applications,
    including fitting statistical models to data (think of general linear models and
    regression). By the end of this chapter, you will understand what the matrix inverse
    is, when it can and cannot be computed, how to compute it, and how to interpret
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的逆在实际应用中解决矩阵方程中至关重要，包括将统计模型拟合到数据（想想一般线性模型和回归）。在本章末尾，您将了解什么是矩阵的逆，何时可以和不能计算它，如何计算它以及如何解释它。
- en: The Matrix Inverse
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵的逆
- en: The inverse of matrix <math alttext="bold upper A"><mi>𝐀</mi></math> is another
    matrix <math alttext="bold upper A Superscript negative 1"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    (pronounced “A inverse”) that multiplies <math alttext="bold upper A"><mi>𝐀</mi></math>
    to produce the identity matrix. In other words, <math alttext="bold upper A Superscript
    negative 1 Baseline bold upper A equals bold upper I"><mrow><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐀</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math> . That is how you “cancel” a matrix.
    Another conceptualization is that we want to linearly transform a matrix into
    the identity matrix; the matrix inverse contains that linear transformation, and
    matrix multiplication is the mechanism of applying that transformation to the
    matrix.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 <math alttext="bold upper A"><mi>𝐀</mi></math> 的逆是另一个矩阵 <math alttext="bold
    upper A Superscript negative 1"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>（发音为“A的逆”），它乘以
    <math alttext="bold upper A"><mi>𝐀</mi></math> 以产生单位矩阵。换句话说，<math alttext="bold
    upper A Superscript negative 1 Baseline bold upper A equals bold upper I"><mrow><msup><mi>𝐀</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐀</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>
    。这就是你如何“取消”一个矩阵。另一个概念是，我们希望将一个矩阵线性变换成单位矩阵；矩阵的逆包含了这种线性变换，并且矩阵乘法是应用该变换到矩阵的机制。
- en: 'But why do we even need to invert matrices? We need to “cancel” a matrix in
    order to solve problems that can be expressed in the form <math alttext="bold
    upper A bold x equals bold b"><mrow><mi>𝐀</mi> <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math>
    , where <math alttext="bold upper A"><mi>𝐀</mi></math> and <math alttext="bold
    b"><mi>𝐛</mi></math> are known quantities and we want to solve for <math alttext="bold
    x"><mi>𝐱</mi></math> . The solution has the following general form:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么我们需要求矩阵的逆？我们需要“取消”一个矩阵，以便解决可以表示为 <math alttext="bold upper A bold x equals
    bold b"><mrow><mi>𝐀</mi> <mi>𝐱</mi> <mo>=</mo> <mi>𝐛</mi></mrow></math> 形式的问题，其中
    <math alttext="bold upper A"><mi>𝐀</mi></math> 和 <math alttext="bold b"><mi>𝐛</mi></math>
    是已知量，我们想求解 <math alttext="bold x"><mi>𝐱</mi></math> 。解的一般形式如下：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold upper A Superscript negative 1 Baseline
    bold upper A bold x 2nd Column equals bold upper A Superscript negative 1 Baseline
    bold b 3rd Row 1st Column bold upper I bold x 2nd Column equals bold upper A Superscript
    negative 1 Baseline bold b 4th Row 1st Column bold x 2nd Column equals bold upper
    A Superscript negative 1 Baseline bold b EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>𝐀</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>𝐈</mi> <mi>𝐱</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>𝐱</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐛</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold upper A Superscript negative 1 Baseline
    bold upper A bold x 2nd Column equals bold upper A Superscript negative 1 Baseline
    bold b 3rd Row 1st Column bold upper I bold x 2nd Column equals bold upper A Superscript
    negative 1 Baseline bold b 4th Row 1st Column bold x 2nd Column equals bold upper
    A Superscript negative 1 Baseline bold b EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>𝐀</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐀</mi> <mi>𝐱</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>𝐈</mi> <mi>𝐱</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐛</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>𝐱</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐛</mi></mrow></mtd></mtr></mtable></math>
- en: That seems really straightforward, but computing the inverse is deceptively
    difficult, as you will soon learn.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常直接，但计算逆是非常棘手的，你很快会了解到。
- en: Types of Inverses and Conditions for Invertibility
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆的类型和可逆性条件
- en: '“Invert the matrix” sounds like it should always work. Who wouldn’t want to
    invert a matrix whenever it’s convenient? Unfortunately, life is not always so
    simple: not all matrices can be inverted.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “求矩阵的逆”听起来好像应该总是可行。谁不愿意在方便时求一个矩阵的逆？不幸的是，生活并非总是如此简单：并非所有的矩阵都可以求逆。
- en: 'There are three different kinds of inverses that have different conditions
    for invertibility. They are introduced here; details are in subsequent sections:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍了三种不同类型的逆，具有不同的可逆条件。它们在此处介绍；详细信息在后续章节中。
- en: Full inverse
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完全逆
- en: 'This means <math alttext="bold upper A Superscript negative 1 Baseline bold
    upper A equals bold upper A bold upper A Superscript negative 1 Baseline equals
    bold upper I"><mrow><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐀</mi> <mo>=</mo> <mi>𝐀</mi> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mi>𝐈</mi></mrow></math> . There are two conditions for a matrix to
    have a full inverse: (1) square and (2) full-rank. Every square full-rank matrix
    has an inverse, and every matrix that has a full inverse is square and full-rank.
    By the way, I’m using the term *full inverse* here to distinguish it from the
    next two possibilities; you would typically refer to the full inverse simply as
    the *inverse*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 <math alttext="粗体大写A 上标负一 上标线 粗体大写A 等于 粗体大写A 粗体大写A 上标负一 上标线 等于 粗体大写I"><mrow><msup><mi>𝐀</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mi>𝐀</mi><mo>=</mo><mi>𝐀</mi><msup><mi>𝐀</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>𝐈</mi></mrow></math>
    。矩阵具有全逆的两个条件是：（1）方阵和（2）满秩。每个方阵满秩矩阵都有一个逆矩阵，并且具有全逆的每个矩阵都是方阵和满秩的。顺便说一下，在这里我使用术语*全逆*来区分它与下面两种可能性；通常你会简单地称全逆为*逆*。
- en: One-sided inverse
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单边逆
- en: A one-sided inverse can transform a rectangular matrix into the identity matrix,
    but it works only for one multiplication order. In particular, a tall matrix <math
    alttext="bold upper T"><mi>𝐓</mi></math> can have a *left-inverse*, meaning <math
    alttext="bold upper L bold upper T equals bold upper I"><mrow><mi>𝐋</mi> <mi>𝐓</mi>
    <mo>=</mo> <mi>𝐈</mi></mrow></math> but <math alttext="bold upper T bold upper
    L not-equals bold upper I"><mrow><mi>𝐓</mi> <mi>𝐋</mi> <mo>≠</mo> <mi>𝐈</mi></mrow></math>
    . And a wide matrix <math alttext="bold upper W"><mi>𝐖</mi></math> can have a
    *right-inverse*, meaning that <math alttext="bold upper W bold upper R equals
    bold upper I"><mrow><mi>𝐖</mi> <mi>𝐑</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>
    but <math alttext="bold upper R bold upper W not-equals bold upper I"><mrow><mi>𝐑</mi>
    <mi>𝐖</mi> <mo>≠</mo> <mi>𝐈</mi></mrow></math> .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单边逆可以将一个矩形矩阵转换为单位矩阵，但它只对一个乘法顺序有效。特别地，一个高瘦矩阵 <math alttext="粗体大写T"><mi>𝐓</mi></math>
    可以有一个*左逆*，意味着 <math alttext="粗体大写L 粗体大写T 等于 粗体大写I"><mrow><mi>𝐋</mi><mi>𝐓</mi><mo>=</mo><mi>𝐈</mi></mrow></math>
    但 <math alttext="粗体大写T 粗体大写L 不等于 粗体大写I"><mrow><mi>𝐓</mi><mi>𝐋</mi><mo>≠</mo><mi>𝐈</mi></mrow></math>
    。而一个宽矮矩阵 <math alttext="粗体大写W"><mi>𝐖</mi></math> 可以有一个*右逆*，意味着 <math alttext="粗体大写W
    粗体大写R 等于 粗体大写I"><mrow><mi>𝐖</mi><mi>𝐑</mi><mo>=</mo><mi>𝐈</mi></mrow></math> 但
    <math alttext="粗体大写R 粗体大写W 不等于 粗体大写I"><mrow><mi>𝐑</mi><mi>𝐖</mi><mo>≠</mo><mi>𝐈</mi></mrow></math>
    。
- en: A nonsquare matrix has a one-sided inverse only if it has the maximum possible
    rank. That is, a tall matrix has a left-inverse if it is rank-*N* (full column
    rank) while a wide matrix has a right-inverse if it is rank-*M* (full row rank).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个非方阵矩阵具有最大可能的秩，则仅有一边逆。也就是说，高瘦矩阵具有左逆，如果它是秩-*N*（完全列秩），而宽矮矩阵具有右逆，如果它是秩-*M*（完全行秩）。
- en: Pseudoinverse
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 广义逆
- en: Every matrix has a pseudoinverse, regardless of its shape and rank. If the matrix
    is square full-rank, then its pseudoinverse equals its full inverse. Likewise,
    if the matrix is nonsquare and has its maximum possible rank, then the pseudoinverse
    equals its left-inverse (for a tall matrix) or its right-inverse (for a wide matrix).
    But a reduced-rank matrix still has a pseudoinverse, in which case the pseudoinverse
    transforms the singular matrix into another matrix that is close but not equal
    to the identity matrix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矩阵都有一个广义逆，不论其形状和秩。如果矩阵是方阵且满秩，那么它的广义逆等于其完全逆。同样地，如果矩阵是非方阵且具有其最大可能的秩，那么广义逆等于其左逆（对于高瘦矩阵）或右逆（对于宽矮矩阵）。但是，一个降秩矩阵仍然有一个广义逆，这种情况下，广义逆将奇异矩阵转换为另一个接近但不等于单位矩阵的矩阵。
- en: Matrices that do not have a full or one-sided inverse are called *singular*
    or *noninvertible*. That is the same thing as labeling a matrix *reduced-rank*
    or *rank-deficient*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 没有全逆或单边逆的矩阵被称为*奇异*或*不可逆*。这与标记矩阵为*降秩*或*秩不足*是一回事。
- en: Computing the Inverse
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算逆矩阵
- en: 'The matrix inverse sounds great! How do we compute it? Let’s start by thinking
    about how to compute the *scalar* inverse: you simply invert (take the reciprocal
    of) the number. For example, the inverse of the number 3 is 1/3, which is the
    same thing as 3^(−1). Then, <math alttext="3 times 3 Superscript negative 1 Baseline
    equals 1"><mrow><mn>3</mn> <mo>×</mo> <msup><mn>3</mn> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>1</mn></mrow></math> .'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的逆听起来很棒！我们如何计算呢？让我们先思考如何计算*标量*的倒数：简单地取（求）数的倒数。例如，数3的倒数是1/3，这与3^(−1)是一样的。然后，<math
    alttext="3 times 3 Superscript negative 1 Baseline equals 1"><mrow><mn>3</mn>
    <mo>×</mo> <msup><mn>3</mn> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo>
    <mn>1</mn></mrow></math>。
- en: 'Based on this reasoning, you might guess that the matrix inverse works the
    same way: invert each matrix element. Let’s try:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种推理，你可能会猜测矩阵的逆工作方式相同：倒置每个矩阵元素。我们来试试：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Superscript negative 1 Baseline equals Start
    2 By 2 Matrix 1st Row 1st Column 1 slash a 2nd Column 1 slash b 2nd Row 1st Column
    1 slash c 2nd Column 1 slash d EndMatrix" display="block"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd><mtd><mi>b</mi></mtd></mtr><mtr><mtd><mi>c</mi></mtd><mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>a</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Superscript negative 1 Baseline equals Start
    2 By 2 Matrix 1st Row 1st Column 1 slash a 2nd Column 1 slash b 2nd Row 1st Column
    1 slash c 2nd Column 1 slash d EndMatrix" display="block"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd><mtd><mi>b</mi></mtd></mtr><mtr><mtd><mi>c</mi></mtd><mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>a</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Unfortunately, this does not produce the desired outcome, which is readily
    demonstrated by multiplying the original matrix by the matrix of individually
    inverted elements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并没有产生预期的结果，这可以通过将原始矩阵乘以逐个倒置元素的矩阵来轻易地证明：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 1 slash
    a 2nd Column 1 slash b 2nd Row 1st Column 1 slash c 2nd Column 1 slash d EndMatrix
    equals Start 2 By 2 Matrix 1st Row 1st Column 1 plus b slash c 2nd Column a slash
    b plus b slash d 2nd Row 1st Column c slash a plus d slash c 2nd Column 1 plus
    c slash b EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>+</mo>
    <mi>b</mi> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mi>a</mi> <mo>/</mo>
    <mi>b</mi> <mo>+</mo> <mi>b</mi> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mo>/</mo> <mi>a</mi> <mo>+</mo> <mi>d</mi> <mo>/</mo> <mi>c</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>+</mo> <mi>c</mi> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 1 slash
    a 2nd Column 1 slash b 2nd Row 1st Column 1 slash c 2nd Column 1 slash d EndMatrix
    equals Start 2 By 2 Matrix 1st Row 1st Column 1 plus b slash c 2nd Column a slash
    b plus b slash d 2nd Row 1st Column c slash a plus d slash c 2nd Column 1 plus
    c slash b EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>+</mo>
    <mi>b</mi> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mi>a</mi> <mo>/</mo>
    <mi>b</mi> <mo>+</mo> <mi>b</mi> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mo>/</mo> <mi>a</mi> <mo>+</mo> <mi>d</mi> <mo>/</mo> <mi>c</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>+</mo> <mi>c</mi> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: That is a valid multiplication, but it does *not* produce the identity matrix,
    which means that the matrix with individual elements inverted is *not* the matrix
    inverse.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的乘法，但它*不*生成单位矩阵，这意味着逐个元素倒置的矩阵*不*是矩阵的逆。
- en: There is an algorithm for computing the matrix of any invertible matrix. It’s
    long and tedious (this is why we have computers do the number crunching for us!),
    but there are a few shortcuts for special matrices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个算法可以计算任何可逆矩阵的矩阵。这是一个冗长乏味的过程（这就是为什么我们让计算机来为我们进行数值运算的原因！），但对于特殊矩阵，有一些捷径。
- en: Inverse of a 2 × 2 Matrix
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 × 2 矩阵的逆
- en: To invert a <math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>
    matrix, swap the diagonal elements, multiply the off-diagonal elements by −1,
    and divide by the determinant. That algorithm will produce a matrix that transforms
    the original matrix into the identity matrix.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要求一个<math alttext="2 times 2"><mrow><mn>2</mn> <mo>×</mo> <mn>2</mn></mrow></math>矩阵的逆，交换对角元素，将非对角元素乘以−1，再除以行列式。该算法将生成一个将原始矩阵转换为单位矩阵的矩阵。
- en: 'Observe:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 观察：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐀</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo>
    <mi>b</mi> <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐀</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi>𝐀</mi> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo>
    <mi>b</mi> <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: 'Let’s work through a numerical example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个数值示例来进行详细说明：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 7 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 7 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 7 minus 8 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    7 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 14 minus 14 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 7 right-parenthesis EndMatrix StartFraction 1 Over negative 1
    EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 0 2nd Column 1 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>7</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>7</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mn>7</mn><mo>-</mo><mn>8</mn></mrow></mfrac> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>7</mn> <mo>-</mo>
    <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>4</mn></mrow>
    <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>14</mn> <mo>-</mo> <mn>14</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>7</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mo>-</mo><mn>1</mn></mrow></mfrac> <mo>=</mo> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 7 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 7 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 7 minus 8 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    7 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 14 minus 14 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 7 right-parenthesis EndMatrix StartFraction 1 Over negative 1
    EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 0 2nd Column 1 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>7</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>7</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mn>7</mn><mo>-</mo><mn>8</mn></mrow></mfrac> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>7</mn> <mo>-</mo>
    <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>4</mn></mrow>
    <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>14</mn> <mo>-</mo> <mn>14</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>7</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mo>-</mo><mn>1</mn></mrow></mfrac> <mo>=</mo> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: That worked out nicely.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那个运行得很顺利。
- en: 'Computing the inverse in Python is easy:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中计算逆矩阵很容易：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can confirm that `A@Ainv` gives the identity matrix, as does `Ainv@A`. Of
    course, `A*Ainv` does not give the identity matrix, because `*` is for Hadamard
    (element-wise) multiplication.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以确认`A@Ainv`得到单位矩阵，`Ainv@A`也是如此。当然，`A*Ainv`并不会得到单位矩阵，因为`*`是指Hadamard（逐元素）乘法。
- en: The matrix, its inverse, and their product are visualized in [Figure 8-1](#fig_8_1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵及其逆矩阵的乘积在[图 8-1](#fig_8_1)中可视化。
- en: '![A matrix and its inverse.](assets/plad_0801.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵及其逆矩阵。](assets/plad_0801.png)'
- en: Figure 8-1\. Inverse of a 2 × 2 matrix
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 2 × 2 矩阵的逆
- en: 'Let’s try another example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个例子：
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 8 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 8 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 0 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    8 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 16 minus 16 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 8 right-parenthesis EndMatrix StartFraction 1 Over 0 EndFraction
    equals question-mark question-mark question-mark" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>8</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>0</mn></mfrac> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo>
    <mn>8</mn> <mo>-</mo> <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>4</mn></mrow> <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>(</mo> <mn>16</mn> <mo>-</mo> <mn>16</mn> <mo>)</mo></mrow></mtd>
    <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>8</mn>
    <mo>)</mo></mrow></mtd></mtr></mtable></mfenced> <mfrac><mn>1</mn> <mn>0</mn></mfrac>
    <mo>=</mo> <mo>?</mo> <mo>?</mo> <mo>?</mo></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 8 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 8 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 0 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    8 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 16 minus 16 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 8 right-parenthesis EndMatrix StartFraction 1 Over 0 EndFraction
    equals question-mark question-mark question-mark" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>8</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>0</mn></mfrac> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo>
    <mn>8</mn> <mo>-</mo> <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>4</mn></mrow> <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>(</mo> <mn>16</mn> <mo>-</mo> <mn>16</mn> <mo>)</mo></mrow></mtd>
    <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>8</mn>
    <mo>)</mo></mrow></mtd></mtr></mtable></mfenced> <mfrac><mn>1</mn> <mn>0</mn></mfrac>
    <mo>=</mo> <mo>?</mo> <mo>?</mo> <mo>?</mo></mrow></math>
- en: There are several problems with this example. The matrix multiplication gives
    us <math alttext="bold 0"><mn mathvariant="bold">0</mn></math> instead of <math
    alttext="normal upper Delta bold upper I"><mrow><mi>Δ</mi> <mi>𝐈</mi></mrow></math>
    . But there is a bigger problem—the determinant is zero! Mathematicians have been
    warning us for ages that we cannot divide by zero. Let’s not start doing it now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有几个问题。矩阵乘法给出了<math alttext="bold 0"><mn mathvariant="bold">0</mn></math>而不是<math
    alttext="normal upper Delta bold upper I"><mrow><mi>Δ</mi> <mi>𝐈</mi></mrow></math>。但更大的问题是行列式为零！数学家们长期以来一直在警告我们不能除以零。现在不要开始这样做了。
- en: What’s different about the second example? It is a reduced-rank matrix (rank
    = 1). This shows a numerical example that reduced-rank matrices are not invertible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子有何不同？它是一个降秩矩阵（秩 = 1）。这显示了一个数值示例，降秩矩阵不可逆。
- en: 'What does Python do in this case? Let’s find out:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python会做什么？让我们来看看：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Python won’t even try to calculate the result like I did. Instead, it gives
    an error with the following message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python甚至不会像我这样尝试计算结果。相反，它给出了以下消息的错误：
- en: '`LinAlgError: Singular matrix`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinAlgError: Singular matrix`'
- en: Reduced-rank matrices do not have an inverse, and programs like Python won’t
    even try to calculate one. However, this matrix does have a pseudoinverse. I’ll
    get back to that in a few sections.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 降秩矩阵没有逆矩阵，像Python这样的程序甚至不会尝试计算。但是，该矩阵确实有一个伪逆。我将在几节后回到这个问题。
- en: Inverse of a Diagonal Matrix
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对角矩阵的逆
- en: 'There is also a shortcut to compute the inverse of a square diagonal matrix.
    The insight that leads to this shortcut is that the product of two diagonal matrices
    is simply the diagonal elements scalar multiplied (discovered in [Exercise 5-12](ch05.xhtml#exercise_5_12)).
    Consider the example below; before continuing with the text, try to figure out
    the shortcut for the inverse of a diagonal matrix:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算方阵的逆还有一种快捷方式。导致这种快捷方式的洞察是两个对角矩阵的乘积只是对角元素的标量乘积（在[练习 5-12](ch05.xhtml#exercise_5_12)中发现）。考虑下面的例子；在继续文本之前，请尝试找出对角矩阵逆的快捷方式：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 4 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column b 2nd Column 0
    3rd Column 0 2nd Row 1st Column 0 2nd Column c 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column d EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    2 b 2nd Column 0 3rd Column 0 2nd Row 1st Column 0 2nd Column 3 c 3rd Column 0
    3rd Row 1st Column 0 2nd Column 0 3rd Column 4 d EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mi>b</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mi>c</mi></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>2</mn> <mi>b</mi></mrow></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn>
    <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 4 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column b 2nd Column 0
    3rd Column 0 2nd Row 1st Column 0 2nd Column c 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column d EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    2 b 2nd Column 0 3rd Column 0 2nd Row 1st Column 0 2nd Column 3 c 3rd Column 0
    3rd Row 1st Column 0 2nd Column 0 3rd Column 4 d EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mi>b</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mi>c</mi></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>2</mn> <mi>b</mi></mrow></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn>
    <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Have you figured out the trick for computing the inverse of a diagonal matrix?
    The trick is that you simply invert each diagonal element, while ignoring the
    off-diagonal zeros. That’s clear in the previous example by setting <math alttext="b
    equals 1 slash 2"><mrow><mi>b</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></math>
    , <math alttext="c equals 1 slash 3"><mrow><mi>c</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo>
    <mn>3</mn></mrow></math> , and <math alttext="d equals 1 slash 4"><mrow><mi>d</mi>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></math> .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到计算对角矩阵的逆的窍门了吗？窍门就是你只需求每个对角元素的倒数，而忽略非对角线上的零。这在前面的例子中很明显，通过设置 <math alttext="b
    equals 1 slash 2"><mrow><mi>b</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></math>，
    <math alttext="c equals 1 slash 3"><mrow><mi>c</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo>
    <mn>3</mn></mrow></math> 和 <math alttext="d equals 1 slash 4"><mrow><mi>d</mi>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></math>。
- en: What happens when you have a diagonal matrix with a zero on the diagonal? You
    cannot invert that element because you’ll have 1/0\. So a diagonal matrix with
    at least one zero on the diagonal has no inverse. (Also remember from [Chapter 6](ch06.xhtml#Chapter_6)
    that a diagonal matrix is full-rank only if all diagonal elements are nonzero.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有一个对角矩阵，且对角线上有一个零时会发生什么？你无法对这个元素求逆，因为你会得到 1/0\. 因此，对角线上至少有一个零的对角矩阵没有逆矩阵。（另外请回想[第
    6 章](ch06.xhtml#Chapter_6)，对角矩阵只有当所有对角元素都非零时才是满秩的。）
- en: The inverse of a diagonal matrix is important because it directly leads to the
    formula for computing the pseudoinverse. More on this later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对角矩阵的逆是重要的，因为它直接导致计算伪逆的公式。稍后详细讨论。
- en: Inverting Any Square Full-Rank Matrix
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转任意方阵满秩矩阵
- en: To be honest, I debated whether to include this section. The full algorithm
    for inverting an invertible matrix is long and tedious, and you will never need
    to use it in applications (instead, you will use `np.linalg.inv` or other functions
    that call `inv`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，我在考虑是否包含这一部分时犹豫了。反转可逆矩阵的完整算法冗长且乏味，你在应用中永远不会需要使用它（相反，你会使用 `np.linalg.inv`
    或其他调用 `inv` 的函数）。
- en: On the other hand, implementing the algorithm in Python is an excellent opportunity
    for you to practice your skills of translating an algorithm, described in equations
    and English, into Python code. Therefore, I will explain how the algorithm works
    here without showing any code. I encourage you to code the algorithm in Python
    as you read this section, and you can check your solution against mine in [Exercise
    8-2](#exercise_8_2) in the online code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，用 Python 实现该算法是练习将算法描述为方程式和英文的良好机会。因此，我会在这里解释算法的工作原理，而不显示任何代码。我鼓励你在阅读本节时编写
    Python 中的算法，并可以在在线代码的[练习 8-2](#exercise_8_2)中与我的解决方案进行对比。
- en: 'The algorithm to compute the inverse involves four intermediate matrices, called
    the *minors*, *grid*, *cofactors,* and *adjugate matrices*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 计算逆矩阵的算法涉及四个中间矩阵，称为*子式*、*格子*、*余子式*和*伴随矩阵*：
- en: The minors matrix
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 子式矩阵
- en: This matrix comprises determinants of submatrices. Each element <math alttext="m
    Subscript i comma j"><msub><mi>m</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    of the minors matrix is the determinant of the submatrix created by excluding
    the *i*th row and the *j*th column. [Figure 8-2](#fig_8_2) shows an overview of
    the procedure for a <math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>
    matrix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵包含子矩阵的行列式。每个元素 <math alttext="m Subscript i comma j"><msub><mi>m</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    是排除第 *i* 行和第 *j* 列创建的子矩阵的行列式。[图 8-2](#fig_8_2)展示了一个 <math alttext="3 times 3"><mrow><mn>3</mn>
    <mo>×</mo> <mn>3</mn></mrow></math> 矩阵的过程概述。
- en: '![The minors matrix.](assets/plad_0802.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![子式矩阵。](assets/plad_0802.png)'
- en: Figure 8-2\. Computing the minors matrix (gray shaded areas are removed to create
    each submatrix)
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. 计算子式矩阵（灰色阴影区域被移除以创建每个子矩阵）
- en: The grid matrix
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 格子矩阵
- en: 'The grid matrix is a checkerboard of alternating +1s and −1s. It is computed
    using the following formula:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 网格矩阵是一个交替+1和-1的棋盘格。它是用以下公式计算的：
- en: <math alttext="g Subscript i comma j Baseline equals minus 1 Superscript i plus
    j" display="block"><mrow><msub><mi>g</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mo>-</mo> <msup><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msup></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g Subscript i comma j Baseline equals minus 1 Superscript i plus
    j" display="block"><mrow><msub><mi>g</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mo>-</mo> <msup><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msup></mrow></math>
- en: Be careful with the indexing and exponentiating when implementing that formula
    in Python. You should inspect the matrix carefully to make sure it is a checkerboard
    of alternating signs, with +1 in the top-left element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现该公式时，对索引和指数进行仔细检查。你应该仔细检查矩阵，确保它是一个交替符号的棋盘格，顶部左侧元素为+1。
- en: The cofactors matrix
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 余子式矩阵
- en: The cofactors matrix is the Hadamard multiplication of the minors matrix with
    the grid matrix.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 余子式矩阵是由子矩阵与网格矩阵进行哈达玛乘积得到的。
- en: Adjugate matrix
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随矩阵
- en: This is the transpose of the cofactors matrix, scalar multiplied by the inverse
    of the determinant of the original matrix (the matrix you are computing the inverse
    of, not the cofactors matrix).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是余子式矩阵的转置，乘以原始矩阵行列式的倒数（计算逆矩阵的那个矩阵，而不是余子式矩阵）。
- en: The adjugate matrix is the inverse of the original matrix.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随矩阵是原始矩阵的逆矩阵。
- en: '[Figure 8-3](#fig_8_3) shows the four intermediate matrices, the inverse returned
    by `np.linalg.inv`, and the identity matrix resulting from the multiplication
    of the original matrix with its inverse computed according to the procedure previously
    described. The original matrix was a random-numbers matrix.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](#fig_8_3)展示了四个中间矩阵，由`np.linalg.inv`返回的逆矩阵，以及由乘以先前描述的程序计算得到的原始矩阵与其逆矩阵相乘后得到的单位矩阵。原始矩阵是一个随机数矩阵。'
- en: '![The way to the inverse.](assets/plad_0803.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![通往逆矩阵的方式。](assets/plad_0803.png)'
- en: Figure 8-3\. Visualizations of inverse-producing matrices for a random-numbers
    matrix
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 随机数矩阵生成逆矩阵的可视化
- en: One-Sided Inverses
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单侧逆
- en: A tall matrix does not have a full inverse. That is, for matrix <math alttext="bold
    upper T"><mi>𝐓</mi></math> of size *M* > *N*, there is no tall matrix <math alttext="bold
    upper T Superscript negative 1"><msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    such that <math alttext="bold upper T bold upper T Superscript negative 1 Baseline
    equals bold upper T Superscript negative 1 Baseline bold upper T equals bold upper
    I"><mrow><mi>𝐓</mi> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐓</mi>
    <mo>=</mo> <mi>𝐈</mi></mrow></math> .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 高瘦矩阵没有完整的逆矩阵。也就是说，对于尺寸为*M* > *N*的矩阵<math alttext="bold upper T"><mi>𝐓</mi></math>，不存在这样一个高瘦矩阵<math
    alttext="bold upper T Superscript negative 1"><msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>，使得<math
    alttext="bold upper T bold upper T Superscript negative 1 Baseline equals bold
    upper T Superscript negative 1 Baseline bold upper T equals bold upper I"><mrow><mi>𝐓</mi>
    <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <msup><mi>𝐓</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>𝐓</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>。
- en: But there is a matrix <math alttext="bold upper L"><mi>𝐋</mi></math> such that
    <math alttext="bold upper L bold upper T equals bold upper I"><mrow><mi>𝐋</mi>
    <mi>𝐓</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math> . Our goal now is to find that
    matrix. We start by making matrix <math alttext="bold upper T"><mi>𝐓</mi></math>
    square. How do we make a nonsquare matrix into a square matrix? Of course you
    know the answer—we multiply it by its transpose.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是存在一个矩阵<math alttext="bold upper L"><mi>𝐋</mi></math>，满足<math alttext="bold
    upper L bold upper T equals bold upper I"><mrow><mi>𝐋</mi> <mi>𝐓</mi> <mo>=</mo>
    <mi>𝐈</mi></mrow></math>。我们的目标是找到这个矩阵。我们首先将矩阵<math alttext="bold upper T"><mi>𝐓</mi></math>转为方阵。如何将非方阵转为方阵？当然你知道答案——我们将其与其转置相乘。
- en: 'Here’s the next question: should we compute <math alttext="bold upper T Superscript
    upper T Baseline bold upper T"><mrow><msup><mi>𝐓</mi> <mtext>T</mtext></msup>
    <mi>𝐓</mi></mrow></math> or <math alttext="bold upper T bold upper T Superscript
    upper T"><mrow><mi>𝐓</mi> <msup><mi>𝐓</mi> <mtext>T</mtext></msup></mrow></math>
    ? Both are square…but <math alttext="bold upper T Superscript upper T Baseline
    bold upper T"><mrow><msup><mi>𝐓</mi> <mtext>T</mtext></msup> <mi>𝐓</mi></mrow></math>
    is full-rank if <math alttext="bold upper T"><mi>𝐓</mi></math> is full column-rank.
    And why is that important? You guessed it—all square full-rank matrices have an
    inverse. Before presenting the derivation of the left-inverse, let’s demonstrate
    in Python that a tall matrix times its transpose has a full inverse:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是：我们应该计算 <math alttext="bold upper T Superscript upper T Baseline bold
    upper T"><mrow><msup><mi>𝐓</mi> <mtext>T</mtext></msup> <mi>𝐓</mi></mrow></math>
    还是 <math alttext="bold upper T bold upper T Superscript upper T"><mrow><mi>𝐓</mi>
    <msup><mi>𝐓</mi> <mtext>T</mtext></msup></mrow></math> ？两者都是方阵……但是如果 <math alttext="bold
    upper T"><mi>𝐓</mi></math> 是满列秩，那么 <math alttext="bold upper T Superscript upper
    T Baseline bold upper T"><mrow><msup><mi>𝐓</mi> <mtext>T</mtext></msup> <mi>𝐓</mi></mrow></math>
    是全秩的。这为什么重要？你猜对了——所有方阵的全秩矩阵都有逆矩阵。在介绍左逆的推导之前，让我们在 Python 中演示一个高矩阵乘以其转置具有完整逆的事实：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can confirm in code that the final line produces the identity matrix (within
    machine-precision error).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码中确认最后一行产生了单位矩阵（在机器精度误差范围内）。
- en: 'Let me translate that Python code into a mathematical equation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我将那段 Python 代码翻译成一个数学方程式：
- en: <math alttext="left-parenthesis bold upper T Superscript upper T Baseline bold
    upper T right-parenthesis Superscript negative 1 Baseline left-parenthesis bold
    upper T Superscript upper T Baseline bold upper T right-parenthesis equals bold
    upper I" display="block"><mrow><msup><mrow><mo>(</mo><msup><mi>𝐓</mi> <mtext>T</mtext></msup>
    <mi>𝐓</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <msup><mi>𝐓</mi> <mtext>T</mtext></msup> <mi>𝐓</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>𝐈</mi></mrow></math>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis bold upper T Superscript upper T Baseline bold
    upper T right-parenthesis Superscript negative 1 Baseline left-parenthesis bold
    upper T Superscript upper T Baseline bold upper T right-parenthesis equals bold
    upper I" display="block"><mrow><msup><mrow><mo>(</mo><msup><mi>𝐓</mi> <mtext>T</mtext></msup>
    <mi>𝐓</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <msup><mi>𝐓</mi> <mtext>T</mtext></msup> <mi>𝐓</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>𝐈</mi></mrow></math>
- en: From the code and formula, you can see that because <math alttext="bold upper
    T Superscript upper T Baseline bold upper T"><mrow><msup><mi>𝐓</mi> <mtext>T</mtext></msup>
    <mi>𝐓</mi></mrow></math> is not the same matrix as <math alttext="bold upper T"><mi>𝐓</mi></math>
    , <math alttext="left-parenthesis bold upper T Superscript upper T Baseline bold
    upper T right-parenthesis Superscript negative 1"><msup><mrow><mo>(</mo><msup><mi>𝐓</mi>
    <mtext>T</mtext></msup> <mi>𝐓</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    is *not* the inverse of <math alttext="bold upper T"><mi>𝐓</mi></math> .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码和公式可以看出，因为 <math alttext="bold upper T Superscript upper T Baseline bold
    upper T"><mrow><msup><mi>𝐓</mi> <mtext>T</mtext></msup> <mi>𝐓</mi></mrow></math>
    不等于 <math alttext="bold upper T"><mi>𝐓</mi></math> ，所以 <math alttext="left-parenthesis
    bold upper T Superscript upper T Baseline bold upper T right-parenthesis Superscript
    negative 1"><msup><mrow><mo>(</mo><msup><mi>𝐓</mi> <mtext>T</mtext></msup> <mi>𝐓</mi><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> *不*是 <math alttext="bold upper
    T"><mi>𝐓</mi></math> 的逆。
- en: 'But—and here is the key insight—we’re looking for a matrix that left-multiplies
    <math alttext="bold upper T"><mi>𝐓</mi></math> to produce the identity matrix;
    we don’t actually care what other matrices need to multiply to produce that matrix.
    So let’s break apart and regroup the matrix multiplications:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是——这是关键——我们寻找的是一个左乘矩阵 <math alttext="bold upper T"><mi>𝐓</mi></math> 后得到单位矩阵的矩阵；我们实际上不关心其他矩阵需要乘以哪些矩阵来得到那个矩阵。因此，让我们拆分和重新组合矩阵乘法：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper L 2nd Column equals
    left-parenthesis bold upper T Superscript upper T Baseline bold upper T right-parenthesis
    Superscript negative 1 Baseline bold upper T Superscript upper T Baseline 2nd
    Row 1st Column bold upper L bold upper T 2nd Column equals bold upper I EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐋</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>𝐓</mi>
    <mtext>T</mtext></msup> <mi>𝐓</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>𝐓</mi> <mtext>T</mtext></msup></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>𝐋</mi>
    <mi>𝐓</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐈</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper L 2nd Column equals
    left-parenthesis bold upper T Superscript upper T Baseline bold upper T right-parenthesis
    Superscript negative 1 Baseline bold upper T Superscript upper T Baseline 2nd
    Row 1st Column bold upper L bold upper T 2nd Column equals bold upper I EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>𝐋</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>𝐓</mi>
    <mtext>T</mtext></msup> <mi>𝐓</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>𝐓</mi> <mtext>T</mtext></msup></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>𝐋</mi>
    <mi>𝐓</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>𝐈</mi></mrow></mtd></mtr></mtable></math>
- en: That matrix <math alttext="bold upper L"><mi>𝐋</mi></math> is the *left-inverse*
    of matrix <math alttext="bold upper T"><mi>𝐓</mi></math> .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 <math alttext="bold upper L"><mi>𝐋</mi></math> 是矩阵 <math alttext="bold upper
    T"><mi>𝐓</mi></math> 的*左逆*。
- en: 'Now we can finish the Python code to compute the left-inverse and confirm that
    it conforms to our specification. Left-multiply the original tall matrix to produce
    the identity matrix:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以完成 Python 代码以计算左逆并确认它符合我们的规格。左乘原始高矩阵以生成单位矩阵：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can also confirm in Python that <math alttext="bold upper T bold upper L"><mrow><mi>𝐓</mi>
    <mi>𝐋</mi></mrow></math> (that is, *right*-multiplying by the left-inverse) is
    *not* the identity matrix. That’s why the left-inverse is a one-sided inverse.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Python 中确认 <math alttext="bold upper T bold upper L"><mrow><mi>𝐓</mi>
    <mi>𝐋</mi></mrow></math>（即*右*-乘左逆）*不*是单位矩阵。这就是左逆是单侧逆的原因。
- en: '[Figure 8-4](#fig_8_4) illustrates a tall matrix, its left-inverse, and the
    two ways of multiplying the left-inverse by the matrix. Note that the left-inverse
    is not a square matrix and that postmultiplying by the left-inverse gives a result
    that is definitely not the identity matrix.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-4](#fig_8_4) 描述了一个高矩阵、它的左逆以及左逆乘以矩阵的两种方式。注意左逆不是方阵，并且左逆后乘以它会得到明显不是单位矩阵的结果。'
- en: '![Lefties are besties](assets/plad_0804.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![左乘最佳](assets/plad_0804.png)'
- en: Figure 8-4\. The left-inverse, visualized
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. 左逆，可视化
- en: The left-inverse is extremely important. In fact, once you learn about fitting
    statistical models to data and the least squares solution, you’ll see the left-inverse
    all over the place. It is no hyperbole to state that the left-inverse is one of
    the most important contributions of linear algebra to modern human civilization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 左逆是非常重要的。实际上，一旦你了解了如何将统计模型拟合到数据和最小二乘解，你就会发现左逆随处可见。毫不夸张地说，左逆是线性代数对现代人类文明最重要的贡献之一。
- en: 'One final note about the left-inverse, which was implicit in this discussion:
    the left-inverse is defined only for tall matrices that have full column-rank.
    A matrix of size *M* > *N* with rank *r* < *N* does not have a left-inverse. Why
    is that? The answer is in the footnote.^([1](ch08.xhtml#idm45733298305632))'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只有完整列秩的高矩阵来说，左逆是有定义的，这一点在讨论中是隐含的。对于尺寸为 *M* > *N* 且秩 *r* < *N* 的矩阵来说，它没有左逆。为什么呢？答案在脚注中。^([1](ch08.xhtml#idm45733298305632))
- en: Now you know how to compute the left-inverse. What about the right-inverse?
    I refuse to teach you how to compute it! That’s not because it’s secret knowledge
    that I’m keeping from you, and it’s certainly not because I don’t like you. Instead,
    it’s because I want you to challenge yourself to derive the math of the right-inverse
    and demonstrate it in code using Python. [Exercise 8-4](#exercise_8_4) has a few
    hints if you need them, or you can try to figure it out now before continuing
    to the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何计算左逆了。那右逆呢？我拒绝教你如何计算它！这并不是因为它是我对你保密的秘密知识，当然也不是因为我不喜欢你。相反，我希望你挑战自己去推导右逆的数学，并用Python代码演示它。如果需要的话，[Exercise
    8-4](#exercise_8_4) 提供了一些提示，或者你可以在继续下一节之前尝试自己找出答案。
- en: The Inverse Is Unique
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆矩阵是唯一的
- en: The matrix inverse is unique, meaning that if a matrix has an inverse, it has
    exactly one inverse. There cannot be two matrices <math alttext="bold upper B"><mi>𝐁</mi></math>
    and <math alttext="bold upper C"><mi>𝐂</mi></math> such that <math alttext="bold
    upper A bold upper B equals bold upper I"><mrow><mi>𝐀</mi> <mi>𝐁</mi> <mo>=</mo>
    <mi>𝐈</mi></mrow></math> and <math alttext="bold upper A bold upper C equals bold
    upper I"><mrow><mi>𝐀</mi> <mi>𝐂</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math> while
    <math alttext="bold upper B not-equals bold upper C"><mrow><mi>𝐁</mi> <mo>≠</mo>
    <mi>𝐂</mi></mrow></math> .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的逆是唯一的，这意味着如果一个矩阵有逆，它就有且只有一个逆。不能有两个矩阵 <math alttext="bold upper B"><mi>𝐁</mi></math>
    和 <math alttext="bold upper C"><mi>𝐂</mi></math> 满足 <math alttext="bold upper
    A bold upper B equals bold upper I"><mrow><mi>𝐀</mi> <mi>𝐁</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math>
    和 <math alttext="bold upper A bold upper C equals bold upper I"><mrow><mi>𝐀</mi>
    <mi>𝐂</mi> <mo>=</mo> <mi>𝐈</mi></mrow></math> 同时 <math alttext="bold upper B
    not-equals bold upper C"><mrow><mi>𝐁</mi> <mo>≠</mo> <mi>𝐂</mi></mrow></math>
    。
- en: 'There are several proofs of this claim. The one I’ll show relies on a technique
    called *proof by negation*. That means that we try but fail to prove a false claim,
    thereby proving the correct claim. In this case, we start with three assumptions:
    (1) matrix **A** is invertible, (2) matrices **B** and **C** are inverses of **A**,
    and (3) matrices **B** and **C** are distinct, meaning **B** <math alttext="not-equals"><mo>≠</mo></math>
    **C**. Follow each expression from left to right, and notice that each subsequent
    expression is based on adding or removing the identity matrix, expressed as the
    matrix times its inverse:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主张有几个证明。我将展示一个依赖于“否定证明”的技术的证明。这意味着我们试图但未能证明一个错误的主张，从而证明了正确的主张。在这种情况下，我们从三个假设开始：(1)
    矩阵 **A** 可逆，(2) 矩阵 **B** 和 **C** 是 **A** 的逆，(3) 矩阵 **B** 和 **C** 是不同的，即 **B**
    <math alttext="not-equals"><mo>≠</mo></math> **C**。从左到右跟随每个表达式，并注意每个后续表达式是基于添加或删除单位矩阵，表达为矩阵乘以其逆：
- en: <math alttext="bold upper C equals bold upper C bold upper I equals bold upper
    C bold upper A bold upper B equals bold upper I bold upper B equals bold upper
    B" display="block"><mrow><mi>𝐂</mi> <mo>=</mo> <mi>𝐂</mi> <mi>𝐈</mi> <mo>=</mo>
    <mi>𝐂</mi> <mi>𝐀</mi> <mi>𝐁</mi> <mo>=</mo> <mi>𝐈</mi> <mi>𝐁</mi> <mo>=</mo> <mi>𝐁</mi></mrow></math>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper C equals bold upper C bold upper I equals bold upper
    C bold upper A bold upper B equals bold upper I bold upper B equals bold upper
    B" display="block"><mrow><mi>𝐂</mi> <mo>=</mo> <mi>𝐂</mi> <mi>𝐈</mi> <mo>=</mo>
    <mi>𝐂</mi> <mi>𝐀</mi> <mi>𝐁</mi> <mo>=</mo> <mi>𝐈</mi> <mi>𝐁</mi> <mo>=</mo> <mi>𝐁</mi></mrow></math>
- en: All statements are equal, which means the first and final expressions are equal,
    which means that our assumption of **B** <math alttext="not-equals"><mo>≠</mo></math>
    **C** is false. The conclusion is that any two matrices that claim to be the inverse
    of the same matrix are equal. In other words, an invertible matrix has exactly
    one inverse.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声明都是相等的，这意味着第一个和最后一个表达式是相等的，这意味着我们假设 **B** <math alttext="not-equals"><mo>≠</mo></math>
    **C** 是错误的。结论是任何两个声称是同一矩阵逆的矩阵都是相等的。换句话说，可逆矩阵有且仅有一个逆。
- en: Moore-Penrose Pseudoinverse
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moore-Penrose 伪逆
- en: As I wrote earlier, it is simply impossible to transform a reduced-rank matrix
    into the identity matrix via matrix multiplication. That means that reduced-rank
    matrices do not have a full or a one-sided inverse. But singular matrices do have
    pseudoinverses. Pseudoinverses are transformation matrices that bring a matrix
    close to the identity matrix.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所写的，通过矩阵乘法将降秩矩阵转换为单位矩阵是完全不可能的。这意味着降秩矩阵没有完全的或单侧的逆矩阵。但奇异矩阵确实有伪逆。伪逆是将一个矩阵接近单位矩阵的转换矩阵。
- en: 'The plural *pseudoinverses* was not a typo: although the full matrix inverse
    is unique, the pseudoinverse is not unique. A reduced-rank matrix has an infinite
    number of pseudoinverses. But some are better than others, and there is really
    only one pseudoinverse worth discussing, because it is most likely the only one
    you’ll ever use.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 复数*伪逆*不是笔误：尽管完全的矩阵逆是唯一的，但伪逆并非唯一。降秩矩阵有无限多个伪逆。但有些伪逆比其他的好，实际上只有一个值得讨论的伪逆，因为这很可能是你唯一会使用的。
- en: That is called the *Moore-Penrose pseudoinverse*, sometimes abbreviated as the
    MP pseudoinverse. But because this is by far the most commonly used pseudoinverse,
    you can always assume that the term *pseudoinverse* refers to the Moore-Penrose
    pseudoinverse.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*Moore-Penrose伪逆*，有时缩写为MP伪逆。但因为这是迄今为止最常用的伪逆，你可以总是假设术语*伪逆*指的是Moore-Penrose伪逆。
- en: 'The following matrix is the pseudoinverse of the singular matrix you saw earlier
    in this chapter. The first line shows the pseudoinverse of the matrix, and the
    second line shows the product of the matrix and its pseudoinverse:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的矩阵是本章前面看到的奇异矩阵的伪逆。第一行显示了矩阵的伪逆，第二行显示了矩阵及其伪逆的乘积：
- en: <math alttext="StartLayout 1st Row 1st Column Start 2 By 2 Matrix 1st Row 1st
    Column 1 2nd Column 4 2nd Row 1st Column 2 2nd Column 8 EndMatrix Superscript
    dagger 2nd Column equals one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column
    1 2nd Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Row 1st Column
    Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row 1st Column 2 2nd
    Column 8 EndMatrix one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column 1 2nd
    Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Column equals Start 2
    By 2 Matrix 1st Row 1st Column .2 2nd Column .4 2nd Row 1st Column .4 2nd Column
    .8 EndMatrix EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><msup><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>2</mn></mtd><mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mo>†</mo></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn>
    <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>.2</mn></mrow></mtd>
    <mtd><mrow><mn>.4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>.4</mn></mrow></mtd>
    <mtd><mrow><mn>.8</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column Start 2 By 2 Matrix 1st Row 1st
    Column 1 2nd Column 4 2nd Row 1st Column 2 2nd Column 8 EndMatrix Superscript
    dagger 2nd Column equals one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column
    1 2nd Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Row 1st Column
    Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row 1st Column 2 2nd
    Column 8 EndMatrix one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column 1 2nd
    Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Column equals Start 2
    By 2 Matrix 1st Row 1st Column .2 2nd Column .4 2nd Row 1st Column .4 2nd Column
    .8 EndMatrix EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><msup><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>2</mn></mtd><mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mo>†</mo></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn>
    <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>.2</mn></mrow></mtd>
    <mtd><mrow><mn>.4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>.4</mn></mrow></mtd>
    <mtd><mrow><mn>.8</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: (The scaling factor of 85 was extracted to facilitate visual inspection of the
    matrix.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: （缩放因子85是提取出来用于视觉检查矩阵。）
- en: 'The pseudoinverse is indicated using a dagger, a plus sign, or an asterisk
    in the superscript: <math alttext="bold upper A Superscript dagger"><msup><mi>𝐀</mi>
    <mo>†</mo></msup></math> , <math alttext="bold upper A Superscript plus"><msup><mi>𝐀</mi>
    <mo>+</mo></msup></math> , or <math alttext="bold upper A Superscript asterisk"><msup><mi>𝐀</mi>
    <mo>*</mo></msup></math> .'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 伪逆在上标中使用一个†、加号或星号来表示：<math alttext="bold upper A Superscript dagger"><msup><mi>𝐀</mi>
    <mo>†</mo></msup></math>，<math alttext="bold upper A Superscript plus"><msup><mi>𝐀</mi>
    <mo>+</mo></msup></math>，或<math alttext="bold upper A Superscript asterisk"><msup><mi>𝐀</mi>
    <mo>*</mo></msup></math>。
- en: 'The pseudoinverse is implemented in Python using the function `np.linalg.pinv`.
    The following code computes the pseudoinverse of the singular matrix for which
    `np.linalg.inv` produced an error message:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用函数`np.linalg.pinv`来实现伪逆。下面的代码计算了一个奇异矩阵的伪逆，而`np.linalg.inv`则产生了一个错误消息：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'How is the pseudoinverse computed? The algorithm is either incomprehensible
    or intuitive, depending on whether you understand the singular value decomposition.
    I will explain the pseudoinverse computation briefly, but if you don’t understand
    it, then please don’t worry: I promise it will be intuitive by the end of [Chapter 13](ch13.xhtml#Chapter_13).
    To compute the pseudoinverse, take the SVD of a matrix, invert the nonzero singular
    values without changing the singular vectors, and reconstruct the matrix by multiplying
    <math alttext="bold upper U bold upper Sigma Superscript plus Baseline bold upper
    V Superscript upper T"><mrow><mi mathvariant="bold">U</mi><msup><mi mathvariant="bold">Σ</mi>
    <mo>+</mo></msup> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math>
    .'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 伪逆是如何计算的？算法要么令人难以理解，要么直观易懂，这取决于你是否理解奇异值分解。我会简要解释伪逆的计算，但如果你不理解，那就不要担心：我保证到[第13章](ch13.xhtml#Chapter_13)结束时，你会觉得这很直观。要计算伪逆，需要对矩阵进行奇异值分解，倒转非零奇异值而不改变奇异向量，然后通过乘以<math
    alttext="bold upper U bold upper Sigma Superscript plus Baseline bold upper V
    Superscript upper T"><mrow><mi mathvariant="bold">U</mi><msup><mi mathvariant="bold">Σ</mi>
    <mo>+</mo></msup> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math>来重构矩阵。
- en: Numerical Stability of the Inverse
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆的数值稳定性
- en: Computing the matrix inverse involves a lot of FLOPs (floating-point operations),
    including many determinants. You learned in [Chapter 6](ch06.xhtml#Chapter_6)
    that the determinant of a matrix can be numerically unstable, and therefore computing
    *many* determinants can lead to numerical inaccuracies, which can accumulate and
    cause significant problems when working with large matrices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 计算矩阵的逆涉及大量的FLOPs（浮点运算），包括许多行列式。您在[第6章](ch06.xhtml#Chapter_6)中学到，矩阵的行列式可能在数值上不稳定，因此计算*许多*行列式可能导致数值不准确，这些误差可能会积累并在处理大型矩阵时造成显著问题。
- en: For this reason, the low-level libraries that implement numerical computations
    (for example, LAPACK) generally strive to avoid explicitly inverting matrices
    when possible, or they decompose matrices into the product of other matrices that
    are more numerically stable (e.g., QR decomposition, which you will learn about
    in [Chapter 9](ch09.xhtml#Chapter_09)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实现数值计算的低级库（例如，LAPACK）通常在可能时避免显式求逆矩阵，或者将矩阵分解为更为数值稳定的其他矩阵的乘积（例如QR分解，在[第9章](ch09.xhtml#Chapter_09)中将会学习）。
- en: Matrices that have numerical values in roughly the same range tend to be more
    stable (though this is not guaranteed), which is why random-numbers matrices are
    easy to work with. But matrices with a large range of numerical values have a
    high risk of numerical instability. The “range of numerical values” is more formally
    captured as the *condition number* of a matrix, which is the ratio of the largest
    to smallest singular value. You’ll learn more about condition number in [Chapter 14](ch14.xhtml#Chapter_14);
    for now, suffice it to say that the condition number is a measure of the spread
    of numerical values in a matrix.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数值在大致相同范围内的矩阵往往更加稳定（虽然这并不保证），这就是为什么随机数矩阵易于处理的原因。但是数值范围较大的矩阵存在高风险的数值不稳定性。“数值范围”更正式地捕捉为矩阵的*条件数*，即最大奇异值与最小奇异值的比率。您将在[第14章](ch14.xhtml#Chapter_14)中更多地了解条件数；目前，可以说条件数是矩阵数值分布的度量。
- en: An example of a numerically unstable matrix is a Hilbert matrix. Each element
    in a Hilbert matrix is defined by the simple formula shown in [Equation 8-1](#hilbertmatrix).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数值上不稳定的矩阵的例子是希尔伯特矩阵。希尔伯特矩阵中的每个元素都由[方程式8-1](#hilbertmatrix)中显示的简单公式定义。
- en: Equation 8-1\. Formula to create a Hilbert matrix. *i* and *j* are row and column
    indices.
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式8-1\. 创建希尔伯特矩阵的公式。*i* 和 *j* 是行和列的索引。
- en: <math alttext="h Subscript i comma j Baseline equals StartFraction 1 Over i
    plus j minus 1 EndFraction" display="block"><mrow><msub><mi>h</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h Subscript i comma j Baseline equals StartFraction 1 Over i
    plus j minus 1 EndFraction" display="block"><mrow><msub><mi>h</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
- en: 'Here’s an example of a <math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo>
    <mn>3</mn></mrow></math> Hilbert matrix:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个<math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>希尔伯特矩阵的示例：
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 slash 2
    3rd Column 1 slash 3 2nd Row 1st Column 1 slash 2 2nd Column 1 slash 3 3rd Column
    1 slash 4 3rd Row 1st Column 1 slash 3 2nd Column 1 slash 4 3rd Column 1 slash
    5 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>3</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 slash 2
    3rd Column 1 slash 3 2nd Row 1st Column 1 slash 2 2nd Column 1 slash 3 3rd Column
    1 slash 4 3rd Row 1st Column 1 slash 3 2nd Column 1 slash 4 3rd Column 1 slash
    5 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>3</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced></math>
- en: As the matrix gets larger, the range of numerical values increases. As a consequence,
    the computer-calculated Hilbert matrix quickly becomes rank-deficient. Even full-rank
    Hilbert matrices have inverses in a very different numerical range. This is illustrated
    in [Figure 8-5](#fig_8_5), which shows a <math alttext="5 times 5"><mrow><mn>5</mn>
    <mo>×</mo> <mn>5</mn></mrow></math> Hilbert matrix, its inverse, and their product.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着矩阵变得更大，数值范围增加。因此，计算机计算的希尔伯特矩阵很快变为秩不足。即使全秩的希尔伯特矩阵其逆矩阵也在非常不同的数值范围内。这在[图8-5](#fig_8_5)中有所说明，该图展示了一个<math
    alttext="5 times 5"><mrow><mn>5</mn> <mo>×</mo> <mn>5</mn></mrow></math>希尔伯特矩阵及其逆矩阵及它们的乘积。
- en: '![Hilberts](assets/plad_0805.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Hilberts](assets/plad_0805.png)'
- en: Figure 8-5\. A Hilbert matrix, its inverse, and their product
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-5\. 一个希尔伯特矩阵，其逆矩阵及它们的乘积
- en: The product matrix certainly looks like the identity matrix, but in [Exercise
    8-9](#exercise_8_9) you will discover that looks can be deceiving, and rounding
    errors increase dramatically with matrix size.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积矩阵看起来确实像单位矩阵，但在[练习8-9](#exercise_8_9)中，您将发现外表可能具有欺骗性，而且舍入误差随矩阵大小显著增加。
- en: Geometric Interpretation of the Inverse
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆的几何解释
- en: In Chapters [6](ch06.xhtml#Chapter_6) and [7](ch07.xhtml#Chapter_7), you learned
    how to conceptualize matrix-vector multiplication as a geometric transformation
    of a vector or a set of points.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[6章](ch06.xhtml#Chapter_6)和第[7章](ch07.xhtml#Chapter_7)中，您学会了如何将矩阵向量乘法概念化为向量或一组点的几何变换。
- en: Following along these lines, we can think of the matrix inverse as *undoing*
    the geometric transformation imposed by matrix multiplication. [Figure 8-6](#fig_8_6)
    shows an example that follows from [Figure 7-8](ch07.xhtml#fig_7_8); I simply
    multiplied the transformed geometric coordinates by the inverse of the transformation
    matrix.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这些思路，我们可以将矩阵逆想象为通过矩阵乘法“撤销”矩阵乘法施加的几何变换。[图8-6](#fig_8_6)展示了一个示例，它遵循自[图7-8](ch07.xhtml#fig_7_8)；我只是将变换后的几何坐标乘以变换矩阵的逆。
- en: '![Geometry, undone](assets/plad_0806.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![几何图像，未完成](assets/plad_0806.png)'
- en: Figure 8-6\. The matrix inverse undoes a geometric transform. Code to produce
    this figure is part of [Exercise 8-8](#exercise_8_8).
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-6。矩阵逆取消了几何变换。生成此图的代码是 [Exercise 8-8](#exercise_8_8) 的一部分。
- en: 'This geometric effect is unsurprising when inspecting the math. In the following
    equations, <math alttext="bold upper P"><mi>𝐏</mi></math> is the <math alttext="2
    times upper N"><mrow><mn>2</mn> <mo>×</mo> <mi>N</mi></mrow></math> matrix of
    original geometric coordinates, <math alttext="bold upper T"><mi>𝐓</mi></math>
    is the transformation matrix, <math alttext="bold upper Q"><mi>𝐐</mi></math> is
    the matrix of transformed coordinates, and <math alttext="bold upper U"><mi>𝐔</mi></math>
    is the matrix of back-transformed coordinates:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查数学时，这种几何效果并不奇怪。在下面的方程中，<math alttext="bold upper P"><mi>𝐏</mi></math> 是原始几何坐标的<math
    alttext="2 times upper N"><mrow><mn>2</mn> <mo>×</mo> <mi>N</mi></mrow></math>矩阵，<math
    alttext="bold upper T"><mi>𝐓</mi></math> 是变换矩阵，<math alttext="bold upper Q"><mi>𝐐</mi></math>
    是变换后坐标的矩阵，<math alttext="bold upper U"><mi>𝐔</mi></math> 是反变换后坐标的矩阵：
- en: <math alttext="StartLayout 1st Row 1st Column bold upper Q 2nd Column equals
    bold upper T bold upper P 2nd Row 1st Column bold upper U 2nd Column equals bold
    upper T Superscript negative 1 Baseline bold upper Q 3rd Row 1st Column bold upper
    U 2nd Column equals bold upper T Superscript negative 1 Baseline bold upper T
    bold upper P EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>𝐐</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐓</mi> <mi>𝐏</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>𝐔</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐐</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>𝐔</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐓</mi> <mi>𝐏</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper Q 2nd Column equals
    bold upper T bold upper P 2nd Row 1st Column bold upper U 2nd Column equals bold
    upper T Superscript negative 1 Baseline bold upper Q 3rd Row 1st Column bold upper
    U 2nd Column equals bold upper T Superscript negative 1 Baseline bold upper T
    bold upper P EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>𝐐</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>𝐓</mi> <mi>𝐏</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>𝐔</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐐</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>𝐔</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>𝐓</mi> <mi>𝐏</mi></mrow></mtd></mtr></mtable></math>
- en: 'Although not a surprising result, I hope it helps build some geometric intuition
    for the purpose of the matrix inverse: *undoing the transform imposed by the matrix*.
    This interpretation will come in handy when you learn about diagonalizing a matrix
    through eigendecomposition.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个令人惊讶的结果，但我希望它有助于建立一些关于矩阵逆的几何直觉：通过矩阵施加的变换“撤销”。当你学习通过特征分解对矩阵进行对角化时，这种解释会很有用。
- en: 'This geometric interpretation also provides some intuition for why a reduced-rank
    matrix has no inverse: the geometric effect of transforming by a singular matrix
    is that at least one dimension is flattened. Once a dimension is flattened, it
    cannot be unflattened, just like you cannot see your back when facing a mirror.^([2](ch08.xhtml#idm45733298077104))'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种几何解释也为为何降秩矩阵没有逆的直观理解提供了一些启示：通过奇异矩阵变换的几何效果是至少有一个维度被压扁。一旦一个维度被压扁，它就无法恢复，就像你不能在面对镜子时看到自己的背面一样。^([2](ch08.xhtml#idm45733298077104))
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'I really enjoyed writing this chapter, and I hope you enjoyed learning from
    it. Here is a summary of the key take-home messages:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢写这一章，也希望你们从中学到了东西。以下是关键的要点总结：
- en: The matrix inverse is a matrix that, through matrix multiplication, transforms
    a maximum-rank matrix into the identity matrix. The inverse has many purposes,
    including moving matrices around in an equation (e.g., solve for **x** in **Ax**
    = **b**).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵逆是一个矩阵，通过矩阵乘法将最大秩矩阵转换为单位矩阵。逆具有多种用途，包括在方程中移动矩阵（例如，解**Ax** = **b**中的**x**）。
- en: A square full-rank matrix has a full inverse, a tall full column-rank matrix
    has a left-inverse, and a wide full row-rank matrix has a right-inverse. Reduced-rank
    matrices cannot be linearly transformed into the identity matrix, but they do
    have a pseudoinverse that transforms the matrix into another matrix that is closer
    to the identity matrix.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正方形全秩矩阵有一个完全逆，一个高且全列秩矩阵有一个左逆，而宽且全行秩矩阵有一个右逆。降秩矩阵不能被线性变换为单位矩阵，但它们确实有一个伪逆，可以将矩阵变换为另一个更接近单位矩阵的矩阵。
- en: The inverse is unique—if a matrix can be linearly transformed into the identity
    matrix, there is only one way to do it.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆是唯一的——如果一个矩阵可以线性变换为单位矩阵，那么只有一种方法可以做到。
- en: There are some tricks for computing the inverses of some kinds of matrices,
    including 2 × 2 and diagonal matrices. These shortcuts are simplifications of
    the full formula for computing a matrix inverse.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些技巧可以计算某些类型矩阵的逆，包括2×2和对角矩阵。这些快捷方式是计算矩阵逆的完整公式的简化。
- en: Due to the risk of numerical precision errors, production-level algorithms try
    to avoid explicitly inverting matrices, or will decompose a matrix into other
    matrices that can be inverted with greater numerical stability.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数值精度误差的风险，生产级算法尝试避免显式求逆矩阵，或将矩阵分解为其他可以更稳定地求逆的矩阵。
- en: Code Exercises
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码练习
- en: Exercise 8-1\.
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习8-1。
- en: The inverse of the inverse is the original matrix; in other words, <math alttext="left-parenthesis
    bold upper A Superscript negative 1 Baseline right-parenthesis Superscript negative
    1 Baseline equals bold upper A"><mrow><msup><mrow><mo>(</mo><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mi>𝐀</mi></mrow></math>
    . This is analgous to how <math alttext="1 slash left-parenthesis 1 slash a right-parenthesis
    equals a"><mrow><mn>1</mn> <mo>/</mo> <mo>(</mo> <mn>1</mn> <mo>/</mo> <mi>a</mi>
    <mo>)</mo> <mo>=</mo> <mi>a</mi></mrow></math> . Illustrate this using Python.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 逆的逆是原始矩阵；换句话说，<math alttext="left-parenthesis bold upper A Superscript negative
    1 Baseline right-parenthesis Superscript negative 1 Baseline equals bold upper
    A"><mrow><msup><mrow><mo>(</mo><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mi>𝐀</mi></mrow></math>。这类似于
    <math alttext="1 slash left-parenthesis 1 slash a right-parenthesis equals a"><mrow><mn>1</mn>
    <mo>/</mo> <mo>(</mo> <mn>1</mn> <mo>/</mo> <mi>a</mi> <mo>)</mo> <mo>=</mo> <mi>a</mi></mrow></math>。用
    Python 进行说明。
- en: Exercise 8-2\.
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-2。
- en: Implement the full algorithm described in [“Inverting Any Square Full-Rank Matrix”](#inverting-any-square)
    and reproduce [Figure 8-3](#fig_8_3). Of course, your matrices will look different
    from [Figure 8-3](#fig_8_3) because of random numbers, although the grid and identity
    matrices will be the same.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 [“求逆任意方阵”](#inverting-any-square) 中描述的完整算法，并复制 [Figure 8-3](#fig_8_3)。当然，你的矩阵由于随机数而不同，尽管网格和单位矩阵将相同。
- en: Exercise 8-3\.
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-3。
- en: Implement the full-inverse algorithm by hand for a 2 × 2 matrix using matrix
    elements *a*, *b*, *c*, and *d*. I don’t normally assign hand-solved problems
    in this book, but this exercise will show you where the shortcut comes from. Remember
    that the determinant of a scalar is its absolute value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 手动为一个2 × 2矩阵使用矩阵元素 *a*, *b*, *c*, 和 *d* 实现完全逆算法。我通常不会在这本书中分配手工解决的问题，但这个练习将向你展示快捷方式的来源。请记住，标量的行列式是它的绝对值。
- en: Exercise 8-4\.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-4。
- en: 'Derive the right-inverse for wide matrices by following the logic that allowed
    us to discover the left-inverse. Then reproduce [Figure 8-4](#fig_8_4) for a wide
    matrix. (Hint: start from the code for the left-inverse and adjust as necessary.)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过追随发现左逆的逻辑来推导宽矩阵的右逆。然后为一个宽矩阵复制 [Figure 8-4](#fig_8_4)。（提示：从左逆的代码开始，并根据需要进行调整。）
- en: Exercise 8-5\.
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-5。
- en: Illustrate in Python that the pseudoinverse (via `np.linalg.pinv`) equals the
    full inverse (via `np.linalg.inv`) for an invertible matrix. Next, illustrate
    that the pseudoinverse equals the left-inverse for a tall full column-rank matrix,
    and that it equals the right-inverse for a wide full row-rank matrix.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Python 示范伪逆（通过 `np.linalg.pinv`）等于完全逆（通过 `np.linalg.inv`）的可逆矩阵。接下来，用一个高列满秩矩阵展示伪逆等于左逆，以及用一个宽行满秩矩阵展示伪逆等于右逆。
- en: Exercise 8-6\.
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-6。
- en: 'The LIVE EVIL rule applies to the inverse of multiplied matrices. Test this
    in code by creating two square full-rank matrices <math alttext="bold upper A"><mi>𝐀</mi></math>
    and <math alttext="bold upper B"><mi>𝐁</mi></math> , then use Euclidean distance
    to compare (1) <math alttext="left-parenthesis bold upper A bold upper B right-parenthesis
    Superscript negative 1"><msup><mrow><mo>(</mo><mi>𝐀</mi><mi>𝐁</mi><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> , (2) <math alttext="bold upper
    A Superscript negative 1 Baseline bold upper B Superscript negative 1"><mrow><msup><mi>𝐀</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>𝐁</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    , and (3) <math alttext="bold upper B Superscript negative 1 Baseline bold upper
    A Superscript negative 1"><mrow><msup><mi>𝐁</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math> . Before
    starting to code, make a prediction about which results will be equal. Print out
    your results using formatting like the following (I’ve omitted my results so you
    won’t be biased!):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: LIVE EVIL规则适用于相乘矩阵的逆。通过创建两个方阵全秩矩阵 <math alttext="bold upper A"><mi>𝐀</mi></math>
    和 <math alttext="bold upper B"><mi>𝐁</mi></math> ，然后使用欧几里得距离比较以下三种情况的结果：(1) <math
    alttext="left-parenthesis bold upper A bold upper B right-parenthesis Superscript
    negative 1"><msup><mrow><mo>(</mo><mi>𝐀</mi><mi>𝐁</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>，(2)
    <math alttext="bold upper A Superscript negative 1 Baseline bold upper B Superscript
    negative 1"><mrow><msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>𝐁</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>，以及(3) <math alttext="bold
    upper B Superscript negative 1 Baseline bold upper A Superscript negative 1"><mrow><msup><mi>𝐁</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>𝐀</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>。开始编写代码之前，预测哪些结果将相等。使用类似以下格式的输出打印您的结果（我省略了我的结果，以免您受到影响！）：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As an extra challenge, you can confirm that the LIVE EVIL rule applies to a
    longer string of matrices, e.g., four matrices instead of two.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外挑战，您可以确认LIVE EVIL规则适用于更长的矩阵串联，例如四个矩阵而不是两个。
- en: Exercise 8-7\.
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-7。
- en: Does the LIVE EVIL rule also apply to the one-sided inverse? That is, does <math
    alttext="left-parenthesis bold upper T Superscript upper T Baseline bold upper
    T right-parenthesis Superscript negative 1 Baseline equals bold upper T Superscript
    hyphen upper T Baseline bold upper T Superscript negative 1"><mrow><msup><mrow><mo>(</mo><msup><mi>𝐓</mi>
    <mtext>T</mtext></msup> <mi>𝐓</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <msup><mi>𝐓</mi> <mtext>-T</mtext></msup> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    ? As with the previous exercise, make a prediction and then test it in Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: LIVE EVIL规则是否也适用于单侧逆矩阵？也就是说，是否 <math alttext="left-parenthesis bold upper T
    Superscript upper T Baseline bold upper T right-parenthesis Superscript negative
    1 Baseline equals bold upper T Superscript hyphen upper T Baseline bold upper
    T Superscript negative 1"><mrow><msup><mrow><mo>(</mo><msup><mi>𝐓</mi> <mtext>T</mtext></msup>
    <mi>𝐓</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo>
    <msup><mi>𝐓</mi> <mtext>-T</mtext></msup> <msup><mi>𝐓</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>？与前一个练习一样，先做出预测，然后在Python中进行测试。
- en: Exercise 8-8\.
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-8。
- en: Write code to reproduce [Figure 8-6](#fig_8_6). Start by copying the code from
    [Exercise 7-3](ch07.xhtml#exercise_7_3). After reproducing the figure, make the
    transformation matrix noninvertible by setting the lower-left element to `1`.
    What else needs to be changed in the code to prevent errors?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以再现[Figure 8-6](#fig_8_6)。首先从[Exercise 7-3](ch07.xhtml#exercise_7_3)复制代码。在复制图表后，通过将左下角元素设置为`1`使变换矩阵不可逆。代码中还需要更改什么以防止错误发生？
- en: Exercise 8-9\.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习 8-9。
- en: This and the next exercise will help you explore the matrix inverse and its
    risk of numerical instability, using the Hilbert matrix. Start by creating a Hilbert
    matrix. Write a Python function that takes an integer as input and produces a
    Hilbert matrix as output, following [Equation 8-1](#hilbertmatrix). Then reproduce
    [Figure 8-5](#fig_8_5).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个和下一个练习将帮助您探索矩阵的逆及其数值不稳定性，使用希尔伯特矩阵。首先创建一个希尔伯特矩阵。编写一个Python函数，该函数以整数作为输入并生成一个希尔伯特矩阵作为输出，遵循[Equation
    8-1](#hilbertmatrix)。然后再现[Figure 8-5](#fig_8_5)。
- en: 'I recommend writing your Python function using a double `for` loop over the
    rows and columns (*i* and *j* matrix indices), following the math formula. Once
    you confirm that the function is accurate, you can optionally challenge yourself
    to rewrite the function without any `for` loops (hint: outer product). You can
    confirm the accuracy of your function by comparing it to the `hilbert` function,
    which is in the `scipy.linalg` library.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议编写您的Python函数，使用双重`for`循环遍历行和列（*i*和*j*矩阵索引），按照数学公式操作。确认函数准确无误后，您可以选择性地挑战自己，尝试在没有任何`for`循环的情况下重写函数（提示：外积）。您可以通过将其与`scipy.linalg`库中的`hilbert`函数进行比较来确认函数的准确性。
- en: Exercise 8-10\.
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 练习8-10\.
- en: Using your Hilbert matrix function, create a Hilbert matrix, then compute its
    inverse using `np.linalg.inv`, and compute the product of the two matrices. That
    product should equal the identity matrix, which means the Euclidean distance between
    that product and the true identity matrix produced by `np.eye` should be 0 (within
    computer rounding error). Compute that Euclidean distance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的希尔伯特矩阵函数，创建一个希尔伯特矩阵，然后使用`np.linalg.inv`计算其逆，并计算这两个矩阵的乘积。该乘积应等于单位矩阵，这意味着该乘积与由`np.eye`生成的真实单位矩阵之间的欧几里德距离应为0（在计算机舍入误差内）。计算该欧几里德距离。
- en: Put this code into a `for` loop over a range of matrix sizes ranging from <math
    alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math> to <math
    alttext="12 times 12"><mrow><mn>12</mn> <mo>×</mo> <mn>12</mn></mrow></math> .
    For each matrix size, store the Euclidean distance and the condition number of
    the Hilbert matrix. As I wrote earlier, the condition number is a measure of the
    spread of numerical values in the matrix, and can be extracted using the function
    `np.linalg.cond`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入一个从<math alttext="3 times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math>到<math
    alttext="12 times 12"><mrow><mn>12</mn> <mo>×</mo> <mn>12</mn></mrow></math>的矩阵尺寸范围的`for`循环中。对于每个矩阵尺寸，存储希尔伯特矩阵的欧几里德距离和条件数。如前所述，条件数是矩阵中数值分布的一种度量，可以使用函数`np.linalg.cond`提取。
- en: Next, repeat the previous code, but using a Gaussian random-numbers matrix instead
    of the Hilbert matrix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，重复前述代码，但使用高斯随机数矩阵代替希尔伯特矩阵。
- en: Finally, plot all of the results as shown in [Figure 8-7](#fig_8_7). I plotted
    the distance and condition number in log scale to facilitate visual interpretation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照[图8-7](#fig_8_7)中所示，绘制所有结果。我将距离和条件数绘制在对数刻度上，以便进行视觉解释。
- en: '![Hilberts](assets/plad_0807.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Hilberts](assets/plad_0807.png)'
- en: Figure 8-7\. Results of Exercise 8-10
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-7\. 练习8-10的结果
- en: Please feel inspired to continue exploring linear algebra using this exercise!
    Try plotting the Hilbert matrix times its inverse (consider adjusting the color
    scaling), using larger matrices or different special matrices, extracting other
    properties of the matrix like rank or norm, etc. You’re on an adventure in the
    wonderful land of linear algebra, and Python is the magic carpet that whisks you
    across the landscape.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续探索线性代数，感受灵感吧！尝试绘制希尔伯特矩阵乘以其逆矩阵（考虑调整颜色缩放），使用更大的矩阵或不同的特殊矩阵，提取矩阵的其他属性，如秩或范数等。您正在探索线性代数的奇妙世界，而Python则是带您穿越这片风景的魔毯。
- en: ^([1](ch08.xhtml#idm45733298305632-marker)) Because **T^TT** is reduced-rank
    and thus cannot be inverted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.xhtml#idm45733298305632-marker)) 因为**T^TT**是降秩的，因此不能被反转。
- en: '^([2](ch08.xhtml#idm45733298077104-marker)) There’s a witty analogy to *Flatland*
    somewhere here that I’m not quite able to eloquate. The point is: read the book
    *Flatland*.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.xhtml#idm45733298077104-marker)) 在这里有一个与*Flatland*的机智类比，我无法准确表达。重点是：阅读书籍*Flatland*。
