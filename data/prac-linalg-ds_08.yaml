- en: Chapter 8\. Matrix Inverse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬å…«ç«  çŸ©é˜µçš„é€†
- en: We are moving toward solving matrix equations. Matrix equations are like regular
    equations (e.g., solve for *x* in 4*x* = 8) butâ€¦they have matrices. By this point
    in the book, you are well aware that things get complicated when matrices get
    involved. Nonetheless, we must embrace that complexity, because solving matrix
    equations is a huge part of data science.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ­£åœ¨å‘è§£å†³çŸ©é˜µæ–¹ç¨‹è¿ˆè¿›ã€‚çŸ©é˜µæ–¹ç¨‹ç±»ä¼¼äºæ™®é€šæ–¹ç¨‹ï¼ˆä¾‹å¦‚ï¼Œåœ¨ 4*x* = 8 ä¸­è§£å‡º *x*ï¼‰ï¼Œä½†æ˜¯â€¦â€¦å®ƒä»¬åŒ…å«çŸ©é˜µã€‚åˆ°äº†ä¹¦çš„è¿™ä¸€éƒ¨åˆ†ï¼Œä½ å·²ç»æ¸…æ¥šï¼Œå½“æ¶‰åŠåˆ°çŸ©é˜µæ—¶ï¼Œäº‹æƒ…å˜å¾—å¤æ‚ã€‚å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»æ¥å—è¿™ç§å¤æ‚æ€§ï¼Œå› ä¸ºè§£çŸ©é˜µæ–¹ç¨‹æ˜¯æ•°æ®ç§‘å­¦çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚
- en: The matrix inverse is central to solving matrix equations in practical applications,
    including fitting statistical models to data (think of general linear models and
    regression). By the end of this chapter, you will understand what the matrix inverse
    is, when it can and cannot be computed, how to compute it, and how to interpret
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„é€†åœ¨å®é™…åº”ç”¨ä¸­è§£å†³çŸ©é˜µæ–¹ç¨‹ä¸­è‡³å…³é‡è¦ï¼ŒåŒ…æ‹¬å°†ç»Ÿè®¡æ¨¡å‹æ‹Ÿåˆåˆ°æ•°æ®ï¼ˆæƒ³æƒ³ä¸€èˆ¬çº¿æ€§æ¨¡å‹å’Œå›å½’ï¼‰ã€‚åœ¨æœ¬ç« æœ«å°¾ï¼Œæ‚¨å°†äº†è§£ä»€ä¹ˆæ˜¯çŸ©é˜µçš„é€†ï¼Œä½•æ—¶å¯ä»¥å’Œä¸èƒ½è®¡ç®—å®ƒï¼Œå¦‚ä½•è®¡ç®—å®ƒä»¥åŠå¦‚ä½•è§£é‡Šå®ƒã€‚
- en: The Matrix Inverse
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„é€†
- en: The inverse of matrix <math alttext="bold upper A"><mi>ğ€</mi></math> is another
    matrix <math alttext="bold upper A Superscript negative 1"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    (pronounced â€œA inverseâ€) that multiplies <math alttext="bold upper A"><mi>ğ€</mi></math>
    to produce the identity matrix. In other words, <math alttext="bold upper A Superscript
    negative 1 Baseline bold upper A equals bold upper I"><mrow><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ€</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math> . That is how you â€œcancelâ€ a matrix.
    Another conceptualization is that we want to linearly transform a matrix into
    the identity matrix; the matrix inverse contains that linear transformation, and
    matrix multiplication is the mechanism of applying that transformation to the
    matrix.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math> çš„é€†æ˜¯å¦ä¸€ä¸ªçŸ©é˜µ <math alttext="bold
    upper A Superscript negative 1"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>ï¼ˆå‘éŸ³ä¸ºâ€œAçš„é€†â€ï¼‰ï¼Œå®ƒä¹˜ä»¥
    <math alttext="bold upper A"><mi>ğ€</mi></math> ä»¥äº§ç”Ÿå•ä½çŸ©é˜µã€‚æ¢å¥è¯è¯´ï¼Œ<math alttext="bold
    upper A Superscript negative 1 Baseline bold upper A equals bold upper I"><mrow><msup><mi>ğ€</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ€</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>
    ã€‚è¿™å°±æ˜¯ä½ å¦‚ä½•â€œå–æ¶ˆâ€ä¸€ä¸ªçŸ©é˜µã€‚å¦ä¸€ä¸ªæ¦‚å¿µæ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›å°†ä¸€ä¸ªçŸ©é˜µçº¿æ€§å˜æ¢æˆå•ä½çŸ©é˜µï¼›çŸ©é˜µçš„é€†åŒ…å«äº†è¿™ç§çº¿æ€§å˜æ¢ï¼Œå¹¶ä¸”çŸ©é˜µä¹˜æ³•æ˜¯åº”ç”¨è¯¥å˜æ¢åˆ°çŸ©é˜µçš„æœºåˆ¶ã€‚
- en: 'But why do we even need to invert matrices? We need to â€œcancelâ€ a matrix in
    order to solve problems that can be expressed in the form <math alttext="bold
    upper A bold x equals bold b"><mrow><mi>ğ€</mi> <mi>ğ±</mi> <mo>=</mo> <mi>ğ›</mi></mrow></math>
    , where <math alttext="bold upper A"><mi>ğ€</mi></math> and <math alttext="bold
    b"><mi>ğ›</mi></math> are known quantities and we want to solve for <math alttext="bold
    x"><mi>ğ±</mi></math> . The solution has the following general form:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦æ±‚çŸ©é˜µçš„é€†ï¼Ÿæˆ‘ä»¬éœ€è¦â€œå–æ¶ˆâ€ä¸€ä¸ªçŸ©é˜µï¼Œä»¥ä¾¿è§£å†³å¯ä»¥è¡¨ç¤ºä¸º <math alttext="bold upper A bold x equals
    bold b"><mrow><mi>ğ€</mi> <mi>ğ±</mi> <mo>=</mo> <mi>ğ›</mi></mrow></math> å½¢å¼çš„é—®é¢˜ï¼Œå…¶ä¸­
    <math alttext="bold upper A"><mi>ğ€</mi></math> å’Œ <math alttext="bold b"><mi>ğ›</mi></math>
    æ˜¯å·²çŸ¥é‡ï¼Œæˆ‘ä»¬æƒ³æ±‚è§£ <math alttext="bold x"><mi>ğ±</mi></math> ã€‚è§£çš„ä¸€èˆ¬å½¢å¼å¦‚ä¸‹ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold upper A Superscript negative 1 Baseline
    bold upper A bold x 2nd Column equals bold upper A Superscript negative 1 Baseline
    bold b 3rd Row 1st Column bold upper I bold x 2nd Column equals bold upper A Superscript
    negative 1 Baseline bold b 4th Row 1st Column bold x 2nd Column equals bold upper
    A Superscript negative 1 Baseline bold b EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>ğ€</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>ğˆ</mi> <mi>ğ±</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>ğ±</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ›</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper A bold x 2nd Column
    equals bold b 2nd Row 1st Column bold upper A Superscript negative 1 Baseline
    bold upper A bold x 2nd Column equals bold upper A Superscript negative 1 Baseline
    bold b 3rd Row 1st Column bold upper I bold x 2nd Column equals bold upper A Superscript
    negative 1 Baseline bold b 4th Row 1st Column bold x 2nd Column equals bold upper
    A Superscript negative 1 Baseline bold b EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mrow><mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><msup><mi>ğ€</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ€</mi> <mi>ğ±</mi></mrow></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>ğˆ</mi> <mi>ğ±</mi></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ›</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>ğ±</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ›</mi></mrow></mtd></mtr></mtable></math>
- en: That seems really straightforward, but computing the inverse is deceptively
    difficult, as you will soon learn.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çœ‹èµ·æ¥éå¸¸ç›´æ¥ï¼Œä½†è®¡ç®—é€†æ˜¯éå¸¸æ£˜æ‰‹çš„ï¼Œä½ å¾ˆå¿«ä¼šäº†è§£åˆ°ã€‚
- en: Types of Inverses and Conditions for Invertibility
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é€†çš„ç±»å‹å’Œå¯é€†æ€§æ¡ä»¶
- en: 'â€œInvert the matrixâ€ sounds like it should always work. Who wouldnâ€™t want to
    invert a matrix whenever itâ€™s convenient? Unfortunately, life is not always so
    simple: not all matrices can be inverted.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: â€œæ±‚çŸ©é˜µçš„é€†â€å¬èµ·æ¥å¥½åƒåº”è¯¥æ€»æ˜¯å¯è¡Œã€‚è°ä¸æ„¿æ„åœ¨æ–¹ä¾¿æ—¶æ±‚ä¸€ä¸ªçŸ©é˜µçš„é€†ï¼Ÿä¸å¹¸çš„æ˜¯ï¼Œç”Ÿæ´»å¹¶éæ€»æ˜¯å¦‚æ­¤ç®€å•ï¼šå¹¶éæ‰€æœ‰çš„çŸ©é˜µéƒ½å¯ä»¥æ±‚é€†ã€‚
- en: 'There are three different kinds of inverses that have different conditions
    for invertibility. They are introduced here; details are in subsequent sections:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œä»‹ç»äº†ä¸‰ç§ä¸åŒç±»å‹çš„é€†ï¼Œå…·æœ‰ä¸åŒçš„å¯é€†æ¡ä»¶ã€‚å®ƒä»¬åœ¨æ­¤å¤„ä»‹ç»ï¼›è¯¦ç»†ä¿¡æ¯åœ¨åç»­ç« èŠ‚ä¸­ã€‚
- en: Full inverse
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: å®Œå…¨é€†
- en: 'This means <math alttext="bold upper A Superscript negative 1 Baseline bold
    upper A equals bold upper A bold upper A Superscript negative 1 Baseline equals
    bold upper I"><mrow><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ€</mi> <mo>=</mo> <mi>ğ€</mi> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mi>ğˆ</mi></mrow></math> . There are two conditions for a matrix to
    have a full inverse: (1) square and (2) full-rank. Every square full-rank matrix
    has an inverse, and every matrix that has a full inverse is square and full-rank.
    By the way, Iâ€™m using the term *full inverse* here to distinguish it from the
    next two possibilities; you would typically refer to the full inverse simply as
    the *inverse*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ <math alttext="ç²—ä½“å¤§å†™A ä¸Šæ ‡è´Ÿä¸€ ä¸Šæ ‡çº¿ ç²—ä½“å¤§å†™A ç­‰äº ç²—ä½“å¤§å†™A ç²—ä½“å¤§å†™A ä¸Šæ ‡è´Ÿä¸€ ä¸Šæ ‡çº¿ ç­‰äº ç²—ä½“å¤§å†™I"><mrow><msup><mi>ğ€</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mi>ğ€</mi><mo>=</mo><mi>ğ€</mi><msup><mi>ğ€</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>ğˆ</mi></mrow></math>
    ã€‚çŸ©é˜µå…·æœ‰å…¨é€†çš„ä¸¤ä¸ªæ¡ä»¶æ˜¯ï¼šï¼ˆ1ï¼‰æ–¹é˜µå’Œï¼ˆ2ï¼‰æ»¡ç§©ã€‚æ¯ä¸ªæ–¹é˜µæ»¡ç§©çŸ©é˜µéƒ½æœ‰ä¸€ä¸ªé€†çŸ©é˜µï¼Œå¹¶ä¸”å…·æœ‰å…¨é€†çš„æ¯ä¸ªçŸ©é˜µéƒ½æ˜¯æ–¹é˜µå’Œæ»¡ç§©çš„ã€‚é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œåœ¨è¿™é‡Œæˆ‘ä½¿ç”¨æœ¯è¯­*å…¨é€†*æ¥åŒºåˆ†å®ƒä¸ä¸‹é¢ä¸¤ç§å¯èƒ½æ€§ï¼›é€šå¸¸ä½ ä¼šç®€å•åœ°ç§°å…¨é€†ä¸º*é€†*ã€‚
- en: One-sided inverse
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: å•è¾¹é€†
- en: A one-sided inverse can transform a rectangular matrix into the identity matrix,
    but it works only for one multiplication order. In particular, a tall matrix <math
    alttext="bold upper T"><mi>ğ“</mi></math> can have a *left-inverse*, meaning <math
    alttext="bold upper L bold upper T equals bold upper I"><mrow><mi>ğ‹</mi> <mi>ğ“</mi>
    <mo>=</mo> <mi>ğˆ</mi></mrow></math> but <math alttext="bold upper T bold upper
    L not-equals bold upper I"><mrow><mi>ğ“</mi> <mi>ğ‹</mi> <mo>â‰ </mo> <mi>ğˆ</mi></mrow></math>
    . And a wide matrix <math alttext="bold upper W"><mi>ğ–</mi></math> can have a
    *right-inverse*, meaning that <math alttext="bold upper W bold upper R equals
    bold upper I"><mrow><mi>ğ–</mi> <mi>ğ‘</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>
    but <math alttext="bold upper R bold upper W not-equals bold upper I"><mrow><mi>ğ‘</mi>
    <mi>ğ–</mi> <mo>â‰ </mo> <mi>ğˆ</mi></mrow></math> .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å•è¾¹é€†å¯ä»¥å°†ä¸€ä¸ªçŸ©å½¢çŸ©é˜µè½¬æ¢ä¸ºå•ä½çŸ©é˜µï¼Œä½†å®ƒåªå¯¹ä¸€ä¸ªä¹˜æ³•é¡ºåºæœ‰æ•ˆã€‚ç‰¹åˆ«åœ°ï¼Œä¸€ä¸ªé«˜ç˜¦çŸ©é˜µ <math alttext="ç²—ä½“å¤§å†™T"><mi>ğ“</mi></math>
    å¯ä»¥æœ‰ä¸€ä¸ª*å·¦é€†*ï¼Œæ„å‘³ç€ <math alttext="ç²—ä½“å¤§å†™L ç²—ä½“å¤§å†™T ç­‰äº ç²—ä½“å¤§å†™I"><mrow><mi>ğ‹</mi><mi>ğ“</mi><mo>=</mo><mi>ğˆ</mi></mrow></math>
    ä½† <math alttext="ç²—ä½“å¤§å†™T ç²—ä½“å¤§å†™L ä¸ç­‰äº ç²—ä½“å¤§å†™I"><mrow><mi>ğ“</mi><mi>ğ‹</mi><mo>â‰ </mo><mi>ğˆ</mi></mrow></math>
    ã€‚è€Œä¸€ä¸ªå®½çŸ®çŸ©é˜µ <math alttext="ç²—ä½“å¤§å†™W"><mi>ğ–</mi></math> å¯ä»¥æœ‰ä¸€ä¸ª*å³é€†*ï¼Œæ„å‘³ç€ <math alttext="ç²—ä½“å¤§å†™W
    ç²—ä½“å¤§å†™R ç­‰äº ç²—ä½“å¤§å†™I"><mrow><mi>ğ–</mi><mi>ğ‘</mi><mo>=</mo><mi>ğˆ</mi></mrow></math> ä½†
    <math alttext="ç²—ä½“å¤§å†™R ç²—ä½“å¤§å†™W ä¸ç­‰äº ç²—ä½“å¤§å†™I"><mrow><mi>ğ‘</mi><mi>ğ–</mi><mo>â‰ </mo><mi>ğˆ</mi></mrow></math>
    ã€‚
- en: A nonsquare matrix has a one-sided inverse only if it has the maximum possible
    rank. That is, a tall matrix has a left-inverse if it is rank-*N* (full column
    rank) while a wide matrix has a right-inverse if it is rank-*M* (full row rank).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸€ä¸ªéæ–¹é˜µçŸ©é˜µå…·æœ‰æœ€å¤§å¯èƒ½çš„ç§©ï¼Œåˆ™ä»…æœ‰ä¸€è¾¹é€†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé«˜ç˜¦çŸ©é˜µå…·æœ‰å·¦é€†ï¼Œå¦‚æœå®ƒæ˜¯ç§©-*N*ï¼ˆå®Œå…¨åˆ—ç§©ï¼‰ï¼Œè€Œå®½çŸ®çŸ©é˜µå…·æœ‰å³é€†ï¼Œå¦‚æœå®ƒæ˜¯ç§©-*M*ï¼ˆå®Œå…¨è¡Œç§©ï¼‰ã€‚
- en: Pseudoinverse
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å¹¿ä¹‰é€†
- en: Every matrix has a pseudoinverse, regardless of its shape and rank. If the matrix
    is square full-rank, then its pseudoinverse equals its full inverse. Likewise,
    if the matrix is nonsquare and has its maximum possible rank, then the pseudoinverse
    equals its left-inverse (for a tall matrix) or its right-inverse (for a wide matrix).
    But a reduced-rank matrix still has a pseudoinverse, in which case the pseudoinverse
    transforms the singular matrix into another matrix that is close but not equal
    to the identity matrix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªçŸ©é˜µéƒ½æœ‰ä¸€ä¸ªå¹¿ä¹‰é€†ï¼Œä¸è®ºå…¶å½¢çŠ¶å’Œç§©ã€‚å¦‚æœçŸ©é˜µæ˜¯æ–¹é˜µä¸”æ»¡ç§©ï¼Œé‚£ä¹ˆå®ƒçš„å¹¿ä¹‰é€†ç­‰äºå…¶å®Œå…¨é€†ã€‚åŒæ ·åœ°ï¼Œå¦‚æœçŸ©é˜µæ˜¯éæ–¹é˜µä¸”å…·æœ‰å…¶æœ€å¤§å¯èƒ½çš„ç§©ï¼Œé‚£ä¹ˆå¹¿ä¹‰é€†ç­‰äºå…¶å·¦é€†ï¼ˆå¯¹äºé«˜ç˜¦çŸ©é˜µï¼‰æˆ–å³é€†ï¼ˆå¯¹äºå®½çŸ®çŸ©é˜µï¼‰ã€‚ä½†æ˜¯ï¼Œä¸€ä¸ªé™ç§©çŸ©é˜µä»ç„¶æœ‰ä¸€ä¸ªå¹¿ä¹‰é€†ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œå¹¿ä¹‰é€†å°†å¥‡å¼‚çŸ©é˜µè½¬æ¢ä¸ºå¦ä¸€ä¸ªæ¥è¿‘ä½†ä¸ç­‰äºå•ä½çŸ©é˜µçš„çŸ©é˜µã€‚
- en: Matrices that do not have a full or one-sided inverse are called *singular*
    or *noninvertible*. That is the same thing as labeling a matrix *reduced-rank*
    or *rank-deficient*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¡æœ‰å…¨é€†æˆ–å•è¾¹é€†çš„çŸ©é˜µè¢«ç§°ä¸º*å¥‡å¼‚*æˆ–*ä¸å¯é€†*ã€‚è¿™ä¸æ ‡è®°çŸ©é˜µä¸º*é™ç§©*æˆ–*ç§©ä¸è¶³*æ˜¯ä¸€å›äº‹ã€‚
- en: Computing the Inverse
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è®¡ç®—é€†çŸ©é˜µ
- en: 'The matrix inverse sounds great! How do we compute it? Letâ€™s start by thinking
    about how to compute the *scalar* inverse: you simply invert (take the reciprocal
    of) the number. For example, the inverse of the number 3 is 1/3, which is the
    same thing as 3^(âˆ’1). Then, <math alttext="3 times 3 Superscript negative 1 Baseline
    equals 1"><mrow><mn>3</mn> <mo>Ã—</mo> <msup><mn>3</mn> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <mn>1</mn></mrow></math> .'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„é€†å¬èµ·æ¥å¾ˆæ£’ï¼æˆ‘ä»¬å¦‚ä½•è®¡ç®—å‘¢ï¼Ÿè®©æˆ‘ä»¬å…ˆæ€è€ƒå¦‚ä½•è®¡ç®—*æ ‡é‡*çš„å€’æ•°ï¼šç®€å•åœ°å–ï¼ˆæ±‚ï¼‰æ•°çš„å€’æ•°ã€‚ä¾‹å¦‚ï¼Œæ•°3çš„å€’æ•°æ˜¯1/3ï¼Œè¿™ä¸3^(âˆ’1)æ˜¯ä¸€æ ·çš„ã€‚ç„¶åï¼Œ<math
    alttext="3 times 3 Superscript negative 1 Baseline equals 1"><mrow><mn>3</mn>
    <mo>Ã—</mo> <msup><mn>3</mn> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo>
    <mn>1</mn></mrow></math>ã€‚
- en: 'Based on this reasoning, you might guess that the matrix inverse works the
    same way: invert each matrix element. Letâ€™s try:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºè¿™ç§æ¨ç†ï¼Œä½ å¯èƒ½ä¼šçŒœæµ‹çŸ©é˜µçš„é€†å·¥ä½œæ–¹å¼ç›¸åŒï¼šå€’ç½®æ¯ä¸ªçŸ©é˜µå…ƒç´ ã€‚æˆ‘ä»¬æ¥è¯•è¯•ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Superscript negative 1 Baseline equals Start
    2 By 2 Matrix 1st Row 1st Column 1 slash a 2nd Column 1 slash b 2nd Row 1st Column
    1 slash c 2nd Column 1 slash d EndMatrix" display="block"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd><mtd><mi>b</mi></mtd></mtr><mtr><mtd><mi>c</mi></mtd><mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>a</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Superscript negative 1 Baseline equals Start
    2 By 2 Matrix 1st Row 1st Column 1 slash a 2nd Column 1 slash b 2nd Row 1st Column
    1 slash c 2nd Column 1 slash d EndMatrix" display="block"><mrow><msup><mfenced
    close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd><mtd><mi>b</mi></mtd></mtr><mtr><mtd><mi>c</mi></mtd><mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>a</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr>
    <mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: 'Unfortunately, this does not produce the desired outcome, which is readily
    demonstrated by multiplying the original matrix by the matrix of individually
    inverted elements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œè¿™å¹¶æ²¡æœ‰äº§ç”Ÿé¢„æœŸçš„ç»“æœï¼Œè¿™å¯ä»¥é€šè¿‡å°†åŸå§‹çŸ©é˜µä¹˜ä»¥é€ä¸ªå€’ç½®å…ƒç´ çš„çŸ©é˜µæ¥è½»æ˜“åœ°è¯æ˜ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 1 slash
    a 2nd Column 1 slash b 2nd Row 1st Column 1 slash c 2nd Column 1 slash d EndMatrix
    equals Start 2 By 2 Matrix 1st Row 1st Column 1 plus b slash c 2nd Column a slash
    b plus b slash d 2nd Row 1st Column c slash a plus d slash c 2nd Column 1 plus
    c slash b EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>+</mo>
    <mi>b</mi> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mi>a</mi> <mo>/</mo>
    <mi>b</mi> <mo>+</mo> <mi>b</mi> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mo>/</mo> <mi>a</mi> <mo>+</mo> <mi>d</mi> <mo>/</mo> <mi>c</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>+</mo> <mi>c</mi> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column a 2nd Column b 2nd Row
    1st Column c 2nd Column d EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 1 slash
    a 2nd Column 1 slash b 2nd Row 1st Column 1 slash c 2nd Column 1 slash d EndMatrix
    equals Start 2 By 2 Matrix 1st Row 1st Column 1 plus b slash c 2nd Column a slash
    b plus b slash d 2nd Row 1st Column c slash a plus d slash c 2nd Column 1 plus
    c slash b EndMatrix" display="block"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>/</mo> <mi>a</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced>
    <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>1</mn> <mo>+</mo>
    <mi>b</mi> <mo>/</mo> <mi>c</mi></mrow></mtd> <mtd><mrow><mi>a</mi> <mo>/</mo>
    <mi>b</mi> <mo>+</mo> <mi>b</mi> <mo>/</mo> <mi>d</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mi>c</mi>
    <mo>/</mo> <mi>a</mi> <mo>+</mo> <mi>d</mi> <mo>/</mo> <mi>c</mi></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>+</mo> <mi>c</mi> <mo>/</mo> <mi>b</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: That is a valid multiplication, but it does *not* produce the identity matrix,
    which means that the matrix with individual elements inverted is *not* the matrix
    inverse.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ä¹˜æ³•ï¼Œä½†å®ƒ*ä¸*ç”Ÿæˆå•ä½çŸ©é˜µï¼Œè¿™æ„å‘³ç€é€ä¸ªå…ƒç´ å€’ç½®çš„çŸ©é˜µ*ä¸*æ˜¯çŸ©é˜µçš„é€†ã€‚
- en: There is an algorithm for computing the matrix of any invertible matrix. Itâ€™s
    long and tedious (this is why we have computers do the number crunching for us!),
    but there are a few shortcuts for special matrices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸€ä¸ªç®—æ³•å¯ä»¥è®¡ç®—ä»»ä½•å¯é€†çŸ©é˜µçš„çŸ©é˜µã€‚è¿™æ˜¯ä¸€ä¸ªå†—é•¿ä¹å‘³çš„è¿‡ç¨‹ï¼ˆè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬è®©è®¡ç®—æœºæ¥ä¸ºæˆ‘ä»¬è¿›è¡Œæ•°å€¼è¿ç®—çš„åŸå› ï¼ï¼‰ï¼Œä½†å¯¹äºç‰¹æ®ŠçŸ©é˜µï¼Œæœ‰ä¸€äº›æ·å¾„ã€‚
- en: Inverse of a 2 Ã— 2 Matrix
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 Ã— 2 çŸ©é˜µçš„é€†
- en: To invert a <math alttext="2 times 2"><mrow><mn>2</mn> <mo>Ã—</mo> <mn>2</mn></mrow></math>
    matrix, swap the diagonal elements, multiply the off-diagonal elements by âˆ’1,
    and divide by the determinant. That algorithm will produce a matrix that transforms
    the original matrix into the identity matrix.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æ±‚ä¸€ä¸ª<math alttext="2 times 2"><mrow><mn>2</mn> <mo>Ã—</mo> <mn>2</mn></mrow></math>çŸ©é˜µçš„é€†ï¼Œäº¤æ¢å¯¹è§’å…ƒç´ ï¼Œå°†éå¯¹è§’å…ƒç´ ä¹˜ä»¥âˆ’1ï¼Œå†é™¤ä»¥è¡Œåˆ—å¼ã€‚è¯¥ç®—æ³•å°†ç”Ÿæˆä¸€ä¸ªå°†åŸå§‹çŸ©é˜µè½¬æ¢ä¸ºå•ä½çŸ©é˜µçš„çŸ©é˜µã€‚
- en: 'Observe:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è§‚å¯Ÿï¼š
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>ğ€</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo>
    <mi>b</mi> <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>ğ€</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mi>ğ€</mi> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mi>a</mi></mtd>
    <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mi>d</mi></mrow></mtd> <mtd><mrow><mo>-</mo> <mi>b</mi></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mi>c</mi></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mi>a</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>d</mi><mo>-</mo><mi>b</mi><mi>c</mi></mrow></mfrac>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo>
    <mi>b</mi> <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mrow><mi>a</mi> <mi>d</mi> <mo>-</mo> <mi>b</mi> <mi>c</mi></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: 'Letâ€™s work through a numerical example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªæ•°å€¼ç¤ºä¾‹æ¥è¿›è¡Œè¯¦ç»†è¯´æ˜ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 7 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 7 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 7 minus 8 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    7 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 14 minus 14 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 7 right-parenthesis EndMatrix StartFraction 1 Over negative 1
    EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 0 2nd Column 1 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>7</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>7</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mn>7</mn><mo>-</mo><mn>8</mn></mrow></mfrac> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>7</mn> <mo>-</mo>
    <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>4</mn></mrow>
    <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>14</mn> <mo>-</mo> <mn>14</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>7</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mo>-</mo><mn>1</mn></mrow></mfrac> <mo>=</mo> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 7 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 7 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 7 minus 8 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    7 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 14 minus 14 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 7 right-parenthesis EndMatrix StartFraction 1 Over negative 1
    EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 0 2nd Row
    1st Column 0 2nd Column 1 EndMatrix" display="block"><mrow><mfenced close="]"
    open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd>
    <mtd><mn>7</mn></mtd></mtr></mtable></mfenced> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom>
    <mn>7</mn></mrow></mtd> <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mn>7</mn><mo>-</mo><mn>8</mn></mrow></mfrac> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo> <mn>7</mn> <mo>-</mo>
    <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>4</mn></mrow>
    <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mo>(</mo>
    <mn>14</mn> <mo>-</mo> <mn>14</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>7</mn> <mo>)</mo></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mrow><mo>-</mo><mn>1</mn></mrow></mfrac> <mo>=</mo> <mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></math>
- en: That worked out nicely.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¸ªè¿è¡Œå¾—å¾ˆé¡ºåˆ©ã€‚
- en: 'Computing the inverse in Python is easy:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­è®¡ç®—é€†çŸ©é˜µå¾ˆå®¹æ˜“ï¼š
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can confirm that `A@Ainv` gives the identity matrix, as does `Ainv@A`. Of
    course, `A*Ainv` does not give the identity matrix, because `*` is for Hadamard
    (element-wise) multiplication.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥ç¡®è®¤`A@Ainv`å¾—åˆ°å•ä½çŸ©é˜µï¼Œ`Ainv@A`ä¹Ÿæ˜¯å¦‚æ­¤ã€‚å½“ç„¶ï¼Œ`A*Ainv`å¹¶ä¸ä¼šå¾—åˆ°å•ä½çŸ©é˜µï¼Œå› ä¸º`*`æ˜¯æŒ‡Hadamardï¼ˆé€å…ƒç´ ï¼‰ä¹˜æ³•ã€‚
- en: The matrix, its inverse, and their product are visualized in [FigureÂ 8-1](#fig_8_1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µåŠå…¶é€†çŸ©é˜µçš„ä¹˜ç§¯åœ¨[å›¾Â 8-1](#fig_8_1)ä¸­å¯è§†åŒ–ã€‚
- en: '![A matrix and its inverse.](assets/plad_0801.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![çŸ©é˜µåŠå…¶é€†çŸ©é˜µã€‚](assets/plad_0801.png)'
- en: Figure 8-1\. Inverse of a 2 Ã— 2 matrix
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾Â 8-1\. 2 Ã— 2 çŸ©é˜µçš„é€†
- en: 'Letâ€™s try another example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°è¯•å¦ä¸€ä¸ªä¾‹å­ï¼š
- en: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 8 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 8 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 0 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    8 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 16 minus 16 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 8 right-parenthesis EndMatrix StartFraction 1 Over 0 EndFraction
    equals question-mark question-mark question-mark" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>8</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>0</mn></mfrac> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo>
    <mn>8</mn> <mo>-</mo> <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>4</mn></mrow> <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>(</mo> <mn>16</mn> <mo>-</mo> <mn>16</mn> <mo>)</mo></mrow></mtd>
    <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>8</mn>
    <mo>)</mo></mrow></mtd></mtr></mtable></mfenced> <mfrac><mn>1</mn> <mn>0</mn></mfrac>
    <mo>=</mo> <mo>?</mo> <mo>?</mo> <mo>?</mo></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row
    1st Column 2 2nd Column 8 EndMatrix Start 2 By 2 Matrix 1st Row 1st Column 8 2nd
    Column negative 4 2nd Row 1st Column negative 2 2nd Column 1 EndMatrix StartFraction
    1 Over 0 EndFraction equals Start 2 By 2 Matrix 1st Row 1st Column left-parenthesis
    8 minus 8 right-parenthesis 2nd Column left-parenthesis negative 4 plus 4 right-parenthesis
    2nd Row 1st Column left-parenthesis 16 minus 16 right-parenthesis 2nd Column left-parenthesis
    negative 8 plus 8 right-parenthesis EndMatrix StartFraction 1 Over 0 EndFraction
    equals question-mark question-mark question-mark" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd> <mtd><mn>4</mn></mtd></mtr>
    <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>8</mn></mrow></mtd>
    <mtd><mrow><mo>-</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mo>-</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mphantom><mo>-</mo></mphantom> <mn>1</mn></mrow></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>0</mn></mfrac> <mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mo>(</mo>
    <mn>8</mn> <mo>-</mo> <mn>8</mn> <mo>)</mo></mrow></mtd> <mtd><mrow><mo>(</mo>
    <mrow><mo>-</mo> <mn>4</mn></mrow> <mo>+</mo> <mn>4</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd><mrow><mo>(</mo> <mn>16</mn> <mo>-</mo> <mn>16</mn> <mo>)</mo></mrow></mtd>
    <mtd><mrow><mo>(</mo> <mrow><mo>-</mo> <mn>8</mn></mrow> <mo>+</mo> <mn>8</mn>
    <mo>)</mo></mrow></mtd></mtr></mtable></mfenced> <mfrac><mn>1</mn> <mn>0</mn></mfrac>
    <mo>=</mo> <mo>?</mo> <mo>?</mo> <mo>?</mo></mrow></math>
- en: There are several problems with this example. The matrix multiplication gives
    us <math alttext="bold 0"><mn mathvariant="bold">0</mn></math> instead of <math
    alttext="normal upper Delta bold upper I"><mrow><mi>Î”</mi> <mi>ğˆ</mi></mrow></math>
    . But there is a bigger problemâ€”the determinant is zero! Mathematicians have been
    warning us for ages that we cannot divide by zero. Letâ€™s not start doing it now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­æœ‰å‡ ä¸ªé—®é¢˜ã€‚çŸ©é˜µä¹˜æ³•ç»™å‡ºäº†<math alttext="bold 0"><mn mathvariant="bold">0</mn></math>è€Œä¸æ˜¯<math
    alttext="normal upper Delta bold upper I"><mrow><mi>Î”</mi> <mi>ğˆ</mi></mrow></math>ã€‚ä½†æ›´å¤§çš„é—®é¢˜æ˜¯è¡Œåˆ—å¼ä¸ºé›¶ï¼æ•°å­¦å®¶ä»¬é•¿æœŸä»¥æ¥ä¸€ç›´åœ¨è­¦å‘Šæˆ‘ä»¬ä¸èƒ½é™¤ä»¥é›¶ã€‚ç°åœ¨ä¸è¦å¼€å§‹è¿™æ ·åšäº†ã€‚
- en: Whatâ€™s different about the second example? It is a reduced-rank matrix (rank
    = 1). This shows a numerical example that reduced-rank matrices are not invertible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬äºŒä¸ªä¾‹å­æœ‰ä½•ä¸åŒï¼Ÿå®ƒæ˜¯ä¸€ä¸ªé™ç§©çŸ©é˜µï¼ˆç§© = 1ï¼‰ã€‚è¿™æ˜¾ç¤ºäº†ä¸€ä¸ªæ•°å€¼ç¤ºä¾‹ï¼Œé™ç§©çŸ©é˜µä¸å¯é€†ã€‚
- en: 'What does Python do in this case? Letâ€™s find out:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒPythonä¼šåšä»€ä¹ˆï¼Ÿè®©æˆ‘ä»¬æ¥çœ‹çœ‹ï¼š
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Python wonâ€™t even try to calculate the result like I did. Instead, it gives
    an error with the following message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonç”šè‡³ä¸ä¼šåƒæˆ‘è¿™æ ·å°è¯•è®¡ç®—ç»“æœã€‚ç›¸åï¼Œå®ƒç»™å‡ºäº†ä»¥ä¸‹æ¶ˆæ¯çš„é”™è¯¯ï¼š
- en: '`LinAlgError: Singular matrix`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinAlgError: Singular matrix`'
- en: Reduced-rank matrices do not have an inverse, and programs like Python wonâ€™t
    even try to calculate one. However, this matrix does have a pseudoinverse. Iâ€™ll
    get back to that in a few sections.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: é™ç§©çŸ©é˜µæ²¡æœ‰é€†çŸ©é˜µï¼ŒåƒPythonè¿™æ ·çš„ç¨‹åºç”šè‡³ä¸ä¼šå°è¯•è®¡ç®—ã€‚ä½†æ˜¯ï¼Œè¯¥çŸ©é˜µç¡®å®æœ‰ä¸€ä¸ªä¼ªé€†ã€‚æˆ‘å°†åœ¨å‡ èŠ‚åå›åˆ°è¿™ä¸ªé—®é¢˜ã€‚
- en: Inverse of a Diagonal Matrix
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¯¹è§’çŸ©é˜µçš„é€†
- en: 'There is also a shortcut to compute the inverse of a square diagonal matrix.
    The insight that leads to this shortcut is that the product of two diagonal matrices
    is simply the diagonal elements scalar multiplied (discovered in [Exercise 5-12](ch05.xhtml#exercise_5_12)).
    Consider the example below; before continuing with the text, try to figure out
    the shortcut for the inverse of a diagonal matrix:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—æ–¹é˜µçš„é€†è¿˜æœ‰ä¸€ç§å¿«æ·æ–¹å¼ã€‚å¯¼è‡´è¿™ç§å¿«æ·æ–¹å¼çš„æ´å¯Ÿæ˜¯ä¸¤ä¸ªå¯¹è§’çŸ©é˜µçš„ä¹˜ç§¯åªæ˜¯å¯¹è§’å…ƒç´ çš„æ ‡é‡ä¹˜ç§¯ï¼ˆåœ¨[ç»ƒä¹  5-12](ch05.xhtml#exercise_5_12)ä¸­å‘ç°ï¼‰ã€‚è€ƒè™‘ä¸‹é¢çš„ä¾‹å­ï¼›åœ¨ç»§ç»­æ–‡æœ¬ä¹‹å‰ï¼Œè¯·å°è¯•æ‰¾å‡ºå¯¹è§’çŸ©é˜µé€†çš„å¿«æ·æ–¹å¼ï¼š
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 4 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column b 2nd Column 0
    3rd Column 0 2nd Row 1st Column 0 2nd Column c 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column d EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    2 b 2nd Column 0 3rd Column 0 2nd Row 1st Column 0 2nd Column 3 c 3rd Column 0
    3rd Row 1st Column 0 2nd Column 0 3rd Column 4 d EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mi>b</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mi>c</mi></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>2</mn> <mi>b</mi></mrow></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn>
    <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 2 2nd Column 0 3rd Column
    0 2nd Row 1st Column 0 2nd Column 3 3rd Column 0 3rd Row 1st Column 0 2nd Column
    0 3rd Column 4 EndMatrix Start 3 By 3 Matrix 1st Row 1st Column b 2nd Column 0
    3rd Column 0 2nd Row 1st Column 0 2nd Column c 3rd Column 0 3rd Row 1st Column
    0 2nd Column 0 3rd Column d EndMatrix equals Start 3 By 3 Matrix 1st Row 1st Column
    2 b 2nd Column 0 3rd Column 0 2nd Row 1st Column 0 2nd Column 3 c 3rd Column 0
    3rd Row 1st Column 0 2nd Column 0 3rd Column 4 d EndMatrix" display="block"><mrow><mfenced
    close="]" open="["><mtable><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable></mfenced> <mfenced
    close="]" open="["><mtable><mtr><mtd><mi>b</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mi>c</mi></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mi>d</mi></mtd></mtr></mtable></mfenced> <mo>=</mo>
    <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>2</mn> <mi>b</mi></mrow></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mrow><mn>3</mn>
    <mi>c</mi></mrow></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd> <mtd><mrow><mn>4</mn> <mi>d</mi></mrow></mtd></mtr></mtable></mfenced></mrow></math>
- en: Have you figured out the trick for computing the inverse of a diagonal matrix?
    The trick is that you simply invert each diagonal element, while ignoring the
    off-diagonal zeros. Thatâ€™s clear in the previous example by setting <math alttext="b
    equals 1 slash 2"><mrow><mi>b</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></math>
    , <math alttext="c equals 1 slash 3"><mrow><mi>c</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo>
    <mn>3</mn></mrow></math> , and <math alttext="d equals 1 slash 4"><mrow><mi>d</mi>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></math> .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ‰¾åˆ°è®¡ç®—å¯¹è§’çŸ©é˜µçš„é€†çš„çªé—¨äº†å—ï¼Ÿçªé—¨å°±æ˜¯ä½ åªéœ€æ±‚æ¯ä¸ªå¯¹è§’å…ƒç´ çš„å€’æ•°ï¼Œè€Œå¿½ç•¥éå¯¹è§’çº¿ä¸Šçš„é›¶ã€‚è¿™åœ¨å‰é¢çš„ä¾‹å­ä¸­å¾ˆæ˜æ˜¾ï¼Œé€šè¿‡è®¾ç½® <math alttext="b
    equals 1 slash 2"><mrow><mi>b</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></math>ï¼Œ
    <math alttext="c equals 1 slash 3"><mrow><mi>c</mi> <mo>=</mo> <mn>1</mn> <mo>/</mo>
    <mn>3</mn></mrow></math> å’Œ <math alttext="d equals 1 slash 4"><mrow><mi>d</mi>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></math>ã€‚
- en: What happens when you have a diagonal matrix with a zero on the diagonal? You
    cannot invert that element because youâ€™ll have 1/0\. So a diagonal matrix with
    at least one zero on the diagonal has no inverse. (Also remember from [ChapterÂ 6](ch06.xhtml#Chapter_6)
    that a diagonal matrix is full-rank only if all diagonal elements are nonzero.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ æ‹¥æœ‰ä¸€ä¸ªå¯¹è§’çŸ©é˜µï¼Œä¸”å¯¹è§’çº¿ä¸Šæœ‰ä¸€ä¸ªé›¶æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä½ æ— æ³•å¯¹è¿™ä¸ªå…ƒç´ æ±‚é€†ï¼Œå› ä¸ºä½ ä¼šå¾—åˆ° 1/0\. å› æ­¤ï¼Œå¯¹è§’çº¿ä¸Šè‡³å°‘æœ‰ä¸€ä¸ªé›¶çš„å¯¹è§’çŸ©é˜µæ²¡æœ‰é€†çŸ©é˜µã€‚ï¼ˆå¦å¤–è¯·å›æƒ³[ç¬¬
    6 ç« ](ch06.xhtml#Chapter_6)ï¼Œå¯¹è§’çŸ©é˜µåªæœ‰å½“æ‰€æœ‰å¯¹è§’å…ƒç´ éƒ½éé›¶æ—¶æ‰æ˜¯æ»¡ç§©çš„ã€‚ï¼‰
- en: The inverse of a diagonal matrix is important because it directly leads to the
    formula for computing the pseudoinverse. More on this later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹è§’çŸ©é˜µçš„é€†æ˜¯é‡è¦çš„ï¼Œå› ä¸ºå®ƒç›´æ¥å¯¼è‡´è®¡ç®—ä¼ªé€†çš„å…¬å¼ã€‚ç¨åè¯¦ç»†è®¨è®ºã€‚
- en: Inverting Any Square Full-Rank Matrix
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åè½¬ä»»æ„æ–¹é˜µæ»¡ç§©çŸ©é˜µ
- en: To be honest, I debated whether to include this section. The full algorithm
    for inverting an invertible matrix is long and tedious, and you will never need
    to use it in applications (instead, you will use `np.linalg.inv` or other functions
    that call `inv`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: è€å®è¯´ï¼Œæˆ‘åœ¨è€ƒè™‘æ˜¯å¦åŒ…å«è¿™ä¸€éƒ¨åˆ†æ—¶çŠ¹è±«äº†ã€‚åè½¬å¯é€†çŸ©é˜µçš„å®Œæ•´ç®—æ³•å†—é•¿ä¸”ä¹å‘³ï¼Œä½ åœ¨åº”ç”¨ä¸­æ°¸è¿œä¸ä¼šéœ€è¦ä½¿ç”¨å®ƒï¼ˆç›¸åï¼Œä½ ä¼šä½¿ç”¨ `np.linalg.inv`
    æˆ–å…¶ä»–è°ƒç”¨ `inv` çš„å‡½æ•°ï¼‰ã€‚
- en: On the other hand, implementing the algorithm in Python is an excellent opportunity
    for you to practice your skills of translating an algorithm, described in equations
    and English, into Python code. Therefore, I will explain how the algorithm works
    here without showing any code. I encourage you to code the algorithm in Python
    as you read this section, and you can check your solution against mine in [Exercise
    8-2](#exercise_8_2) in the online code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢ï¼Œç”¨ Python å®ç°è¯¥ç®—æ³•æ˜¯ç»ƒä¹ å°†ç®—æ³•æè¿°ä¸ºæ–¹ç¨‹å¼å’Œè‹±æ–‡çš„è‰¯å¥½æœºä¼šã€‚å› æ­¤ï¼Œæˆ‘ä¼šåœ¨è¿™é‡Œè§£é‡Šç®—æ³•çš„å·¥ä½œåŸç†ï¼Œè€Œä¸æ˜¾ç¤ºä»»ä½•ä»£ç ã€‚æˆ‘é¼“åŠ±ä½ åœ¨é˜…è¯»æœ¬èŠ‚æ—¶ç¼–å†™
    Python ä¸­çš„ç®—æ³•ï¼Œå¹¶å¯ä»¥åœ¨åœ¨çº¿ä»£ç çš„[ç»ƒä¹  8-2](#exercise_8_2)ä¸­ä¸æˆ‘çš„è§£å†³æ–¹æ¡ˆè¿›è¡Œå¯¹æ¯”ã€‚
- en: 'The algorithm to compute the inverse involves four intermediate matrices, called
    the *minors*, *grid*, *cofactors,* and *adjugate matrices*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—é€†çŸ©é˜µçš„ç®—æ³•æ¶‰åŠå››ä¸ªä¸­é—´çŸ©é˜µï¼Œç§°ä¸º*å­å¼*ã€*æ ¼å­*ã€*ä½™å­å¼*å’Œ*ä¼´éšçŸ©é˜µ*ï¼š
- en: The minors matrix
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: å­å¼çŸ©é˜µ
- en: This matrix comprises determinants of submatrices. Each element <math alttext="m
    Subscript i comma j"><msub><mi>m</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    of the minors matrix is the determinant of the submatrix created by excluding
    the *i*th row and the *j*th column. [FigureÂ 8-2](#fig_8_2) shows an overview of
    the procedure for a <math alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>3</mn></mrow></math>
    matrix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªçŸ©é˜µåŒ…å«å­çŸ©é˜µçš„è¡Œåˆ—å¼ã€‚æ¯ä¸ªå…ƒç´  <math alttext="m Subscript i comma j"><msub><mi>m</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></math>
    æ˜¯æ’é™¤ç¬¬ *i* è¡Œå’Œç¬¬ *j* åˆ—åˆ›å»ºçš„å­çŸ©é˜µçš„è¡Œåˆ—å¼ã€‚[å›¾ 8-2](#fig_8_2)å±•ç¤ºäº†ä¸€ä¸ª <math alttext="3 times 3"><mrow><mn>3</mn>
    <mo>Ã—</mo> <mn>3</mn></mrow></math> çŸ©é˜µçš„è¿‡ç¨‹æ¦‚è¿°ã€‚
- en: '![The minors matrix.](assets/plad_0802.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![å­å¼çŸ©é˜µã€‚](assets/plad_0802.png)'
- en: Figure 8-2\. Computing the minors matrix (gray shaded areas are removed to create
    each submatrix)
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 8-2\. è®¡ç®—å­å¼çŸ©é˜µï¼ˆç°è‰²é˜´å½±åŒºåŸŸè¢«ç§»é™¤ä»¥åˆ›å»ºæ¯ä¸ªå­çŸ©é˜µï¼‰
- en: The grid matrix
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¼å­çŸ©é˜µ
- en: 'The grid matrix is a checkerboard of alternating +1s and âˆ’1s. It is computed
    using the following formula:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ç½‘æ ¼çŸ©é˜µæ˜¯ä¸€ä¸ªäº¤æ›¿+1å’Œ-1çš„æ£‹ç›˜æ ¼ã€‚å®ƒæ˜¯ç”¨ä»¥ä¸‹å…¬å¼è®¡ç®—çš„ï¼š
- en: <math alttext="g Subscript i comma j Baseline equals minus 1 Superscript i plus
    j" display="block"><mrow><msub><mi>g</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mo>-</mo> <msup><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msup></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="g Subscript i comma j Baseline equals minus 1 Superscript i plus
    j" display="block"><mrow><msub><mi>g</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mo>-</mo> <msup><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msup></mrow></math>
- en: Be careful with the indexing and exponentiating when implementing that formula
    in Python. You should inspect the matrix carefully to make sure it is a checkerboard
    of alternating signs, with +1 in the top-left element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­å®ç°è¯¥å…¬å¼æ—¶ï¼Œå¯¹ç´¢å¼•å’ŒæŒ‡æ•°è¿›è¡Œä»”ç»†æ£€æŸ¥ã€‚ä½ åº”è¯¥ä»”ç»†æ£€æŸ¥çŸ©é˜µï¼Œç¡®ä¿å®ƒæ˜¯ä¸€ä¸ªäº¤æ›¿ç¬¦å·çš„æ£‹ç›˜æ ¼ï¼Œé¡¶éƒ¨å·¦ä¾§å…ƒç´ ä¸º+1ã€‚
- en: The cofactors matrix
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä½™å­å¼çŸ©é˜µ
- en: The cofactors matrix is the Hadamard multiplication of the minors matrix with
    the grid matrix.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ä½™å­å¼çŸ©é˜µæ˜¯ç”±å­çŸ©é˜µä¸ç½‘æ ¼çŸ©é˜µè¿›è¡Œå“ˆè¾¾ç›ä¹˜ç§¯å¾—åˆ°çš„ã€‚
- en: Adjugate matrix
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼´éšçŸ©é˜µ
- en: This is the transpose of the cofactors matrix, scalar multiplied by the inverse
    of the determinant of the original matrix (the matrix you are computing the inverse
    of, not the cofactors matrix).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä½™å­å¼çŸ©é˜µçš„è½¬ç½®ï¼Œä¹˜ä»¥åŸå§‹çŸ©é˜µè¡Œåˆ—å¼çš„å€’æ•°ï¼ˆè®¡ç®—é€†çŸ©é˜µçš„é‚£ä¸ªçŸ©é˜µï¼Œè€Œä¸æ˜¯ä½™å­å¼çŸ©é˜µï¼‰ã€‚
- en: The adjugate matrix is the inverse of the original matrix.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼´éšçŸ©é˜µæ˜¯åŸå§‹çŸ©é˜µçš„é€†çŸ©é˜µã€‚
- en: '[FigureÂ 8-3](#fig_8_3) shows the four intermediate matrices, the inverse returned
    by `np.linalg.inv`, and the identity matrix resulting from the multiplication
    of the original matrix with its inverse computed according to the procedure previously
    described. The original matrix was a random-numbers matrix.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾Â 8-3](#fig_8_3)å±•ç¤ºäº†å››ä¸ªä¸­é—´çŸ©é˜µï¼Œç”±`np.linalg.inv`è¿”å›çš„é€†çŸ©é˜µï¼Œä»¥åŠç”±ä¹˜ä»¥å…ˆå‰æè¿°çš„ç¨‹åºè®¡ç®—å¾—åˆ°çš„åŸå§‹çŸ©é˜µä¸å…¶é€†çŸ©é˜µç›¸ä¹˜åå¾—åˆ°çš„å•ä½çŸ©é˜µã€‚åŸå§‹çŸ©é˜µæ˜¯ä¸€ä¸ªéšæœºæ•°çŸ©é˜µã€‚'
- en: '![The way to the inverse.](assets/plad_0803.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![é€šå¾€é€†çŸ©é˜µçš„æ–¹å¼ã€‚](assets/plad_0803.png)'
- en: Figure 8-3\. Visualizations of inverse-producing matrices for a random-numbers
    matrix
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾Â 8-3\. éšæœºæ•°çŸ©é˜µç”Ÿæˆé€†çŸ©é˜µçš„å¯è§†åŒ–
- en: One-Sided Inverses
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å•ä¾§é€†
- en: A tall matrix does not have a full inverse. That is, for matrix <math alttext="bold
    upper T"><mi>ğ“</mi></math> of size *M* > *N*, there is no tall matrix <math alttext="bold
    upper T Superscript negative 1"><msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    such that <math alttext="bold upper T bold upper T Superscript negative 1 Baseline
    equals bold upper T Superscript negative 1 Baseline bold upper T equals bold upper
    I"><mrow><mi>ğ“</mi> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ“</mi>
    <mo>=</mo> <mi>ğˆ</mi></mrow></math> .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: é«˜ç˜¦çŸ©é˜µæ²¡æœ‰å®Œæ•´çš„é€†çŸ©é˜µã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºå°ºå¯¸ä¸º*M* > *N*çš„çŸ©é˜µ<math alttext="bold upper T"><mi>ğ“</mi></math>ï¼Œä¸å­˜åœ¨è¿™æ ·ä¸€ä¸ªé«˜ç˜¦çŸ©é˜µ<math
    alttext="bold upper T Superscript negative 1"><msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>ï¼Œä½¿å¾—<math
    alttext="bold upper T bold upper T Superscript negative 1 Baseline equals bold
    upper T Superscript negative 1 Baseline bold upper T equals bold upper I"><mrow><mi>ğ“</mi>
    <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <msup><mi>ğ“</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mi>ğ“</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>ã€‚
- en: But there is a matrix <math alttext="bold upper L"><mi>ğ‹</mi></math> such that
    <math alttext="bold upper L bold upper T equals bold upper I"><mrow><mi>ğ‹</mi>
    <mi>ğ“</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math> . Our goal now is to find that
    matrix. We start by making matrix <math alttext="bold upper T"><mi>ğ“</mi></math>
    square. How do we make a nonsquare matrix into a square matrix? Of course you
    know the answerâ€”we multiply it by its transpose.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯å­˜åœ¨ä¸€ä¸ªçŸ©é˜µ<math alttext="bold upper L"><mi>ğ‹</mi></math>ï¼Œæ»¡è¶³<math alttext="bold
    upper L bold upper T equals bold upper I"><mrow><mi>ğ‹</mi> <mi>ğ“</mi> <mo>=</mo>
    <mi>ğˆ</mi></mrow></math>ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰¾åˆ°è¿™ä¸ªçŸ©é˜µã€‚æˆ‘ä»¬é¦–å…ˆå°†çŸ©é˜µ<math alttext="bold upper T"><mi>ğ“</mi></math>è½¬ä¸ºæ–¹é˜µã€‚å¦‚ä½•å°†éæ–¹é˜µè½¬ä¸ºæ–¹é˜µï¼Ÿå½“ç„¶ä½ çŸ¥é“ç­”æ¡ˆâ€”â€”æˆ‘ä»¬å°†å…¶ä¸å…¶è½¬ç½®ç›¸ä¹˜ã€‚
- en: 'Hereâ€™s the next question: should we compute <math alttext="bold upper T Superscript
    upper T Baseline bold upper T"><mrow><msup><mi>ğ“</mi> <mtext>T</mtext></msup>
    <mi>ğ“</mi></mrow></math> or <math alttext="bold upper T bold upper T Superscript
    upper T"><mrow><mi>ğ“</mi> <msup><mi>ğ“</mi> <mtext>T</mtext></msup></mrow></math>
    ? Both are squareâ€¦but <math alttext="bold upper T Superscript upper T Baseline
    bold upper T"><mrow><msup><mi>ğ“</mi> <mtext>T</mtext></msup> <mi>ğ“</mi></mrow></math>
    is full-rank if <math alttext="bold upper T"><mi>ğ“</mi></math> is full column-rank.
    And why is that important? You guessed itâ€”all square full-rank matrices have an
    inverse. Before presenting the derivation of the left-inverse, letâ€™s demonstrate
    in Python that a tall matrix times its transpose has a full inverse:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥çš„é—®é¢˜æ˜¯ï¼šæˆ‘ä»¬åº”è¯¥è®¡ç®— <math alttext="bold upper T Superscript upper T Baseline bold
    upper T"><mrow><msup><mi>ğ“</mi> <mtext>T</mtext></msup> <mi>ğ“</mi></mrow></math>
    è¿˜æ˜¯ <math alttext="bold upper T bold upper T Superscript upper T"><mrow><mi>ğ“</mi>
    <msup><mi>ğ“</mi> <mtext>T</mtext></msup></mrow></math> ï¼Ÿä¸¤è€…éƒ½æ˜¯æ–¹é˜µâ€¦â€¦ä½†æ˜¯å¦‚æœ <math alttext="bold
    upper T"><mi>ğ“</mi></math> æ˜¯æ»¡åˆ—ç§©ï¼Œé‚£ä¹ˆ <math alttext="bold upper T Superscript upper
    T Baseline bold upper T"><mrow><msup><mi>ğ“</mi> <mtext>T</mtext></msup> <mi>ğ“</mi></mrow></math>
    æ˜¯å…¨ç§©çš„ã€‚è¿™ä¸ºä»€ä¹ˆé‡è¦ï¼Ÿä½ çŒœå¯¹äº†â€”â€”æ‰€æœ‰æ–¹é˜µçš„å…¨ç§©çŸ©é˜µéƒ½æœ‰é€†çŸ©é˜µã€‚åœ¨ä»‹ç»å·¦é€†çš„æ¨å¯¼ä¹‹å‰ï¼Œè®©æˆ‘ä»¬åœ¨ Python ä¸­æ¼”ç¤ºä¸€ä¸ªé«˜çŸ©é˜µä¹˜ä»¥å…¶è½¬ç½®å…·æœ‰å®Œæ•´é€†çš„äº‹å®ï¼š
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can confirm in code that the final line produces the identity matrix (within
    machine-precision error).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨å¯ä»¥åœ¨ä»£ç ä¸­ç¡®è®¤æœ€åä¸€è¡Œäº§ç”Ÿäº†å•ä½çŸ©é˜µï¼ˆåœ¨æœºå™¨ç²¾åº¦è¯¯å·®èŒƒå›´å†…ï¼‰ã€‚
- en: 'Let me translate that Python code into a mathematical equation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘å°†é‚£æ®µ Python ä»£ç ç¿»è¯‘æˆä¸€ä¸ªæ•°å­¦æ–¹ç¨‹å¼ï¼š
- en: <math alttext="left-parenthesis bold upper T Superscript upper T Baseline bold
    upper T right-parenthesis Superscript negative 1 Baseline left-parenthesis bold
    upper T Superscript upper T Baseline bold upper T right-parenthesis equals bold
    upper I" display="block"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ“</mi> <mtext>T</mtext></msup>
    <mi>ğ“</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <msup><mi>ğ“</mi> <mtext>T</mtext></msup> <mi>ğ“</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>ğˆ</mi></mrow></math>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="left-parenthesis bold upper T Superscript upper T Baseline bold
    upper T right-parenthesis Superscript negative 1 Baseline left-parenthesis bold
    upper T Superscript upper T Baseline bold upper T right-parenthesis equals bold
    upper I" display="block"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ“</mi> <mtext>T</mtext></msup>
    <mi>ğ“</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mrow><mo>(</mo>
    <msup><mi>ğ“</mi> <mtext>T</mtext></msup> <mi>ğ“</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mi>ğˆ</mi></mrow></math>
- en: From the code and formula, you can see that because <math alttext="bold upper
    T Superscript upper T Baseline bold upper T"><mrow><msup><mi>ğ“</mi> <mtext>T</mtext></msup>
    <mi>ğ“</mi></mrow></math> is not the same matrix as <math alttext="bold upper T"><mi>ğ“</mi></math>
    , <math alttext="left-parenthesis bold upper T Superscript upper T Baseline bold
    upper T right-parenthesis Superscript negative 1"><msup><mrow><mo>(</mo><msup><mi>ğ“</mi>
    <mtext>T</mtext></msup> <mi>ğ“</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>
    is *not* the inverse of <math alttext="bold upper T"><mi>ğ“</mi></math> .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ä»ä»£ç å’Œå…¬å¼å¯ä»¥çœ‹å‡ºï¼Œå› ä¸º <math alttext="bold upper T Superscript upper T Baseline bold
    upper T"><mrow><msup><mi>ğ“</mi> <mtext>T</mtext></msup> <mi>ğ“</mi></mrow></math>
    ä¸ç­‰äº <math alttext="bold upper T"><mi>ğ“</mi></math> ï¼Œæ‰€ä»¥ <math alttext="left-parenthesis
    bold upper T Superscript upper T Baseline bold upper T right-parenthesis Superscript
    negative 1"><msup><mrow><mo>(</mo><msup><mi>ğ“</mi> <mtext>T</mtext></msup> <mi>ğ“</mi><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> *ä¸*æ˜¯ <math alttext="bold upper
    T"><mi>ğ“</mi></math> çš„é€†ã€‚
- en: 'Butâ€”and here is the key insightâ€”weâ€™re looking for a matrix that left-multiplies
    <math alttext="bold upper T"><mi>ğ“</mi></math> to produce the identity matrix;
    we donâ€™t actually care what other matrices need to multiply to produce that matrix.
    So letâ€™s break apart and regroup the matrix multiplications:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯â€”â€”è¿™æ˜¯å…³é”®â€”â€”æˆ‘ä»¬å¯»æ‰¾çš„æ˜¯ä¸€ä¸ªå·¦ä¹˜çŸ©é˜µ <math alttext="bold upper T"><mi>ğ“</mi></math> åå¾—åˆ°å•ä½çŸ©é˜µçš„çŸ©é˜µï¼›æˆ‘ä»¬å®é™…ä¸Šä¸å…³å¿ƒå…¶ä»–çŸ©é˜µéœ€è¦ä¹˜ä»¥å“ªäº›çŸ©é˜µæ¥å¾—åˆ°é‚£ä¸ªçŸ©é˜µã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬æ‹†åˆ†å’Œé‡æ–°ç»„åˆçŸ©é˜µä¹˜æ³•ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper L 2nd Column equals
    left-parenthesis bold upper T Superscript upper T Baseline bold upper T right-parenthesis
    Superscript negative 1 Baseline bold upper T Superscript upper T Baseline 2nd
    Row 1st Column bold upper L bold upper T 2nd Column equals bold upper I EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>ğ‹</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>ğ“</mi>
    <mtext>T</mtext></msup> <mi>ğ“</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ“</mi> <mtext>T</mtext></msup></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>ğ‹</mi>
    <mi>ğ“</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğˆ</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper L 2nd Column equals
    left-parenthesis bold upper T Superscript upper T Baseline bold upper T right-parenthesis
    Superscript negative 1 Baseline bold upper T Superscript upper T Baseline 2nd
    Row 1st Column bold upper L bold upper T 2nd Column equals bold upper I EndLayout"
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mi>ğ‹</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mrow><mo>(</mo><msup><mi>ğ“</mi>
    <mtext>T</mtext></msup> <mi>ğ“</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ“</mi> <mtext>T</mtext></msup></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mrow><mi>ğ‹</mi>
    <mi>ğ“</mi></mrow></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mi>ğˆ</mi></mrow></mtd></mtr></mtable></math>
- en: That matrix <math alttext="bold upper L"><mi>ğ‹</mi></math> is the *left-inverse*
    of matrix <math alttext="bold upper T"><mi>ğ“</mi></math> .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µ <math alttext="bold upper L"><mi>ğ‹</mi></math> æ˜¯çŸ©é˜µ <math alttext="bold upper
    T"><mi>ğ“</mi></math> çš„*å·¦é€†*ã€‚
- en: 'Now we can finish the Python code to compute the left-inverse and confirm that
    it conforms to our specification. Left-multiply the original tall matrix to produce
    the identity matrix:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥å®Œæˆ Python ä»£ç ä»¥è®¡ç®—å·¦é€†å¹¶ç¡®è®¤å®ƒç¬¦åˆæˆ‘ä»¬çš„è§„æ ¼ã€‚å·¦ä¹˜åŸå§‹é«˜çŸ©é˜µä»¥ç”Ÿæˆå•ä½çŸ©é˜µï¼š
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can also confirm in Python that <math alttext="bold upper T bold upper L"><mrow><mi>ğ“</mi>
    <mi>ğ‹</mi></mrow></math> (that is, *right*-multiplying by the left-inverse) is
    *not* the identity matrix. Thatâ€™s why the left-inverse is a one-sided inverse.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¹Ÿå¯ä»¥åœ¨ Python ä¸­ç¡®è®¤ <math alttext="bold upper T bold upper L"><mrow><mi>ğ“</mi>
    <mi>ğ‹</mi></mrow></math>ï¼ˆå³*å³*-ä¹˜å·¦é€†ï¼‰*ä¸*æ˜¯å•ä½çŸ©é˜µã€‚è¿™å°±æ˜¯å·¦é€†æ˜¯å•ä¾§é€†çš„åŸå› ã€‚
- en: '[FigureÂ 8-4](#fig_8_4) illustrates a tall matrix, its left-inverse, and the
    two ways of multiplying the left-inverse by the matrix. Note that the left-inverse
    is not a square matrix and that postmultiplying by the left-inverse gives a result
    that is definitely not the identity matrix.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[å›¾Â 8-4](#fig_8_4) æè¿°äº†ä¸€ä¸ªé«˜çŸ©é˜µã€å®ƒçš„å·¦é€†ä»¥åŠå·¦é€†ä¹˜ä»¥çŸ©é˜µçš„ä¸¤ç§æ–¹å¼ã€‚æ³¨æ„å·¦é€†ä¸æ˜¯æ–¹é˜µï¼Œå¹¶ä¸”å·¦é€†åä¹˜ä»¥å®ƒä¼šå¾—åˆ°æ˜æ˜¾ä¸æ˜¯å•ä½çŸ©é˜µçš„ç»“æœã€‚'
- en: '![Lefties are besties](assets/plad_0804.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![å·¦ä¹˜æœ€ä½³](assets/plad_0804.png)'
- en: Figure 8-4\. The left-inverse, visualized
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾ 8-4\. å·¦é€†ï¼Œå¯è§†åŒ–
- en: The left-inverse is extremely important. In fact, once you learn about fitting
    statistical models to data and the least squares solution, youâ€™ll see the left-inverse
    all over the place. It is no hyperbole to state that the left-inverse is one of
    the most important contributions of linear algebra to modern human civilization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: å·¦é€†æ˜¯éå¸¸é‡è¦çš„ã€‚å®é™…ä¸Šï¼Œä¸€æ—¦ä½ äº†è§£äº†å¦‚ä½•å°†ç»Ÿè®¡æ¨¡å‹æ‹Ÿåˆåˆ°æ•°æ®å’Œæœ€å°äºŒä¹˜è§£ï¼Œä½ å°±ä¼šå‘ç°å·¦é€†éšå¤„å¯è§ã€‚æ¯«ä¸å¤¸å¼ åœ°è¯´ï¼Œå·¦é€†æ˜¯çº¿æ€§ä»£æ•°å¯¹ç°ä»£äººç±»æ–‡æ˜æœ€é‡è¦çš„è´¡çŒ®ä¹‹ä¸€ã€‚
- en: 'One final note about the left-inverse, which was implicit in this discussion:
    the left-inverse is defined only for tall matrices that have full column-rank.
    A matrix of size *M* > *N* with rank *r* < *N* does not have a left-inverse. Why
    is that? The answer is in the footnote.^([1](ch08.xhtml#idm45733298305632))'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºåªæœ‰å®Œæ•´åˆ—ç§©çš„é«˜çŸ©é˜µæ¥è¯´ï¼Œå·¦é€†æ˜¯æœ‰å®šä¹‰çš„ï¼Œè¿™ä¸€ç‚¹åœ¨è®¨è®ºä¸­æ˜¯éšå«çš„ã€‚å¯¹äºå°ºå¯¸ä¸º *M* > *N* ä¸”ç§© *r* < *N* çš„çŸ©é˜µæ¥è¯´ï¼Œå®ƒæ²¡æœ‰å·¦é€†ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿç­”æ¡ˆåœ¨è„šæ³¨ä¸­ã€‚^([1](ch08.xhtml#idm45733298305632))
- en: Now you know how to compute the left-inverse. What about the right-inverse?
    I refuse to teach you how to compute it! Thatâ€™s not because itâ€™s secret knowledge
    that Iâ€™m keeping from you, and itâ€™s certainly not because I donâ€™t like you. Instead,
    itâ€™s because I want you to challenge yourself to derive the math of the right-inverse
    and demonstrate it in code using Python. [Exercise 8-4](#exercise_8_4) has a few
    hints if you need them, or you can try to figure it out now before continuing
    to the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ çŸ¥é“å¦‚ä½•è®¡ç®—å·¦é€†äº†ã€‚é‚£å³é€†å‘¢ï¼Ÿæˆ‘æ‹’ç»æ•™ä½ å¦‚ä½•è®¡ç®—å®ƒï¼è¿™å¹¶ä¸æ˜¯å› ä¸ºå®ƒæ˜¯æˆ‘å¯¹ä½ ä¿å¯†çš„ç§˜å¯†çŸ¥è¯†ï¼Œå½“ç„¶ä¹Ÿä¸æ˜¯å› ä¸ºæˆ‘ä¸å–œæ¬¢ä½ ã€‚ç›¸åï¼Œæˆ‘å¸Œæœ›ä½ æŒ‘æˆ˜è‡ªå·±å»æ¨å¯¼å³é€†çš„æ•°å­¦ï¼Œå¹¶ç”¨Pythonä»£ç æ¼”ç¤ºå®ƒã€‚å¦‚æœéœ€è¦çš„è¯ï¼Œ[Exercise
    8-4](#exercise_8_4) æä¾›äº†ä¸€äº›æç¤ºï¼Œæˆ–è€…ä½ å¯ä»¥åœ¨ç»§ç»­ä¸‹ä¸€èŠ‚ä¹‹å‰å°è¯•è‡ªå·±æ‰¾å‡ºç­”æ¡ˆã€‚
- en: The Inverse Is Unique
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é€†çŸ©é˜µæ˜¯å”¯ä¸€çš„
- en: The matrix inverse is unique, meaning that if a matrix has an inverse, it has
    exactly one inverse. There cannot be two matrices <math alttext="bold upper B"><mi>ğ</mi></math>
    and <math alttext="bold upper C"><mi>ğ‚</mi></math> such that <math alttext="bold
    upper A bold upper B equals bold upper I"><mrow><mi>ğ€</mi> <mi>ğ</mi> <mo>=</mo>
    <mi>ğˆ</mi></mrow></math> and <math alttext="bold upper A bold upper C equals bold
    upper I"><mrow><mi>ğ€</mi> <mi>ğ‚</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math> while
    <math alttext="bold upper B not-equals bold upper C"><mrow><mi>ğ</mi> <mo>â‰ </mo>
    <mi>ğ‚</mi></mrow></math> .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: çŸ©é˜µçš„é€†æ˜¯å”¯ä¸€çš„ï¼Œè¿™æ„å‘³ç€å¦‚æœä¸€ä¸ªçŸ©é˜µæœ‰é€†ï¼Œå®ƒå°±æœ‰ä¸”åªæœ‰ä¸€ä¸ªé€†ã€‚ä¸èƒ½æœ‰ä¸¤ä¸ªçŸ©é˜µ <math alttext="bold upper B"><mi>ğ</mi></math>
    å’Œ <math alttext="bold upper C"><mi>ğ‚</mi></math> æ»¡è¶³ <math alttext="bold upper
    A bold upper B equals bold upper I"><mrow><mi>ğ€</mi> <mi>ğ</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math>
    å’Œ <math alttext="bold upper A bold upper C equals bold upper I"><mrow><mi>ğ€</mi>
    <mi>ğ‚</mi> <mo>=</mo> <mi>ğˆ</mi></mrow></math> åŒæ—¶ <math alttext="bold upper B
    not-equals bold upper C"><mrow><mi>ğ</mi> <mo>â‰ </mo> <mi>ğ‚</mi></mrow></math>
    ã€‚
- en: 'There are several proofs of this claim. The one Iâ€™ll show relies on a technique
    called *proof by negation*. That means that we try but fail to prove a false claim,
    thereby proving the correct claim. In this case, we start with three assumptions:
    (1) matrix **A** is invertible, (2) matrices **B** and **C** are inverses of **A**,
    and (3) matrices **B** and **C** are distinct, meaning **B** <math alttext="not-equals"><mo>â‰ </mo></math>
    **C**. Follow each expression from left to right, and notice that each subsequent
    expression is based on adding or removing the identity matrix, expressed as the
    matrix times its inverse:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¸»å¼ æœ‰å‡ ä¸ªè¯æ˜ã€‚æˆ‘å°†å±•ç¤ºä¸€ä¸ªä¾èµ–äºâ€œå¦å®šè¯æ˜â€çš„æŠ€æœ¯çš„è¯æ˜ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬è¯•å›¾ä½†æœªèƒ½è¯æ˜ä¸€ä¸ªé”™è¯¯çš„ä¸»å¼ ï¼Œä»è€Œè¯æ˜äº†æ­£ç¡®çš„ä¸»å¼ ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä»ä¸‰ä¸ªå‡è®¾å¼€å§‹ï¼š(1)
    çŸ©é˜µ **A** å¯é€†ï¼Œ(2) çŸ©é˜µ **B** å’Œ **C** æ˜¯ **A** çš„é€†ï¼Œ(3) çŸ©é˜µ **B** å’Œ **C** æ˜¯ä¸åŒçš„ï¼Œå³ **B**
    <math alttext="not-equals"><mo>â‰ </mo></math> **C**ã€‚ä»å·¦åˆ°å³è·Ÿéšæ¯ä¸ªè¡¨è¾¾å¼ï¼Œå¹¶æ³¨æ„æ¯ä¸ªåç»­è¡¨è¾¾å¼æ˜¯åŸºäºæ·»åŠ æˆ–åˆ é™¤å•ä½çŸ©é˜µï¼Œè¡¨è¾¾ä¸ºçŸ©é˜µä¹˜ä»¥å…¶é€†ï¼š
- en: <math alttext="bold upper C equals bold upper C bold upper I equals bold upper
    C bold upper A bold upper B equals bold upper I bold upper B equals bold upper
    B" display="block"><mrow><mi>ğ‚</mi> <mo>=</mo> <mi>ğ‚</mi> <mi>ğˆ</mi> <mo>=</mo>
    <mi>ğ‚</mi> <mi>ğ€</mi> <mi>ğ</mi> <mo>=</mo> <mi>ğˆ</mi> <mi>ğ</mi> <mo>=</mo> <mi>ğ</mi></mrow></math>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="bold upper C equals bold upper C bold upper I equals bold upper
    C bold upper A bold upper B equals bold upper I bold upper B equals bold upper
    B" display="block"><mrow><mi>ğ‚</mi> <mo>=</mo> <mi>ğ‚</mi> <mi>ğˆ</mi> <mo>=</mo>
    <mi>ğ‚</mi> <mi>ğ€</mi> <mi>ğ</mi> <mo>=</mo> <mi>ğˆ</mi> <mi>ğ</mi> <mo>=</mo> <mi>ğ</mi></mrow></math>
- en: All statements are equal, which means the first and final expressions are equal,
    which means that our assumption of **B** <math alttext="not-equals"><mo>â‰ </mo></math>
    **C** is false. The conclusion is that any two matrices that claim to be the inverse
    of the same matrix are equal. In other words, an invertible matrix has exactly
    one inverse.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰å£°æ˜éƒ½æ˜¯ç›¸ç­‰çš„ï¼Œè¿™æ„å‘³ç€ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªè¡¨è¾¾å¼æ˜¯ç›¸ç­‰çš„ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å‡è®¾ **B** <math alttext="not-equals"><mo>â‰ </mo></math>
    **C** æ˜¯é”™è¯¯çš„ã€‚ç»“è®ºæ˜¯ä»»ä½•ä¸¤ä¸ªå£°ç§°æ˜¯åŒä¸€çŸ©é˜µé€†çš„çŸ©é˜µéƒ½æ˜¯ç›¸ç­‰çš„ã€‚æ¢å¥è¯è¯´ï¼Œå¯é€†çŸ©é˜µæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªé€†ã€‚
- en: Moore-Penrose Pseudoinverse
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moore-Penrose ä¼ªé€†
- en: As I wrote earlier, it is simply impossible to transform a reduced-rank matrix
    into the identity matrix via matrix multiplication. That means that reduced-rank
    matrices do not have a full or a one-sided inverse. But singular matrices do have
    pseudoinverses. Pseudoinverses are transformation matrices that bring a matrix
    close to the identity matrix.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä¹‹å‰æ‰€å†™çš„ï¼Œé€šè¿‡çŸ©é˜µä¹˜æ³•å°†é™ç§©çŸ©é˜µè½¬æ¢ä¸ºå•ä½çŸ©é˜µæ˜¯å®Œå…¨ä¸å¯èƒ½çš„ã€‚è¿™æ„å‘³ç€é™ç§©çŸ©é˜µæ²¡æœ‰å®Œå…¨çš„æˆ–å•ä¾§çš„é€†çŸ©é˜µã€‚ä½†å¥‡å¼‚çŸ©é˜µç¡®å®æœ‰ä¼ªé€†ã€‚ä¼ªé€†æ˜¯å°†ä¸€ä¸ªçŸ©é˜µæ¥è¿‘å•ä½çŸ©é˜µçš„è½¬æ¢çŸ©é˜µã€‚
- en: 'The plural *pseudoinverses* was not a typo: although the full matrix inverse
    is unique, the pseudoinverse is not unique. A reduced-rank matrix has an infinite
    number of pseudoinverses. But some are better than others, and there is really
    only one pseudoinverse worth discussing, because it is most likely the only one
    youâ€™ll ever use.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: å¤æ•°*ä¼ªé€†*ä¸æ˜¯ç¬”è¯¯ï¼šå°½ç®¡å®Œå…¨çš„çŸ©é˜µé€†æ˜¯å”¯ä¸€çš„ï¼Œä½†ä¼ªé€†å¹¶éå”¯ä¸€ã€‚é™ç§©çŸ©é˜µæœ‰æ— é™å¤šä¸ªä¼ªé€†ã€‚ä½†æœ‰äº›ä¼ªé€†æ¯”å…¶ä»–çš„å¥½ï¼Œå®é™…ä¸Šåªæœ‰ä¸€ä¸ªå€¼å¾—è®¨è®ºçš„ä¼ªé€†ï¼Œå› ä¸ºè¿™å¾ˆå¯èƒ½æ˜¯ä½ å”¯ä¸€ä¼šä½¿ç”¨çš„ã€‚
- en: That is called the *Moore-Penrose pseudoinverse*, sometimes abbreviated as the
    MP pseudoinverse. But because this is by far the most commonly used pseudoinverse,
    you can always assume that the term *pseudoinverse* refers to the Moore-Penrose
    pseudoinverse.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¢«ç§°ä¸º*Moore-Penroseä¼ªé€†*ï¼Œæœ‰æ—¶ç¼©å†™ä¸ºMPä¼ªé€†ã€‚ä½†å› ä¸ºè¿™æ˜¯è¿„ä»Šä¸ºæ­¢æœ€å¸¸ç”¨çš„ä¼ªé€†ï¼Œä½ å¯ä»¥æ€»æ˜¯å‡è®¾æœ¯è¯­*ä¼ªé€†*æŒ‡çš„æ˜¯Moore-Penroseä¼ªé€†ã€‚
- en: 'The following matrix is the pseudoinverse of the singular matrix you saw earlier
    in this chapter. The first line shows the pseudoinverse of the matrix, and the
    second line shows the product of the matrix and its pseudoinverse:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢çš„çŸ©é˜µæ˜¯æœ¬ç« å‰é¢çœ‹åˆ°çš„å¥‡å¼‚çŸ©é˜µçš„ä¼ªé€†ã€‚ç¬¬ä¸€è¡Œæ˜¾ç¤ºäº†çŸ©é˜µçš„ä¼ªé€†ï¼Œç¬¬äºŒè¡Œæ˜¾ç¤ºäº†çŸ©é˜µåŠå…¶ä¼ªé€†çš„ä¹˜ç§¯ï¼š
- en: <math alttext="StartLayout 1st Row 1st Column Start 2 By 2 Matrix 1st Row 1st
    Column 1 2nd Column 4 2nd Row 1st Column 2 2nd Column 8 EndMatrix Superscript
    dagger 2nd Column equals one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column
    1 2nd Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Row 1st Column
    Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row 1st Column 2 2nd
    Column 8 EndMatrix one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column 1 2nd
    Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Column equals Start 2
    By 2 Matrix 1st Row 1st Column .2 2nd Column .4 2nd Row 1st Column .4 2nd Column
    .8 EndMatrix EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><msup><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>2</mn></mtd><mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mo>â€ </mo></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn>
    <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>.2</mn></mrow></mtd>
    <mtd><mrow><mn>.4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>.4</mn></mrow></mtd>
    <mtd><mrow><mn>.8</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column Start 2 By 2 Matrix 1st Row 1st
    Column 1 2nd Column 4 2nd Row 1st Column 2 2nd Column 8 EndMatrix Superscript
    dagger 2nd Column equals one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column
    1 2nd Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Row 1st Column
    Start 2 By 2 Matrix 1st Row 1st Column 1 2nd Column 4 2nd Row 1st Column 2 2nd
    Column 8 EndMatrix one-eighty-fifth Start 2 By 2 Matrix 1st Row 1st Column 1 2nd
    Column 2 2nd Row 1st Column 4 2nd Column 8 EndMatrix 2nd Column equals Start 2
    By 2 Matrix 1st Row 1st Column .2 2nd Column .4 2nd Row 1st Column .4 2nd Column
    .8 EndMatrix EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><msup><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>2</mn></mtd><mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mo>â€ </mo></msup></mtd> <mtd columnalign="left"><mrow><mo>=</mo> <mfrac><mn>1</mn>
    <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mrow><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced>
    <mfrac><mn>1</mn> <mn>85</mn></mfrac> <mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>4</mn></mtd> <mtd><mn>8</mn></mtd></mtr></mtable></mfenced></mrow></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <mfenced close="]" open="["><mtable><mtr><mtd><mrow><mn>.2</mn></mrow></mtd>
    <mtd><mrow><mn>.4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>.4</mn></mrow></mtd>
    <mtd><mrow><mn>.8</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mtd></mtr></mtable></math>
- en: (The scaling factor of 85 was extracted to facilitate visual inspection of the
    matrix.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ï¼ˆç¼©æ”¾å› å­85æ˜¯æå–å‡ºæ¥ç”¨äºè§†è§‰æ£€æŸ¥çŸ©é˜µã€‚ï¼‰
- en: 'The pseudoinverse is indicated using a dagger, a plus sign, or an asterisk
    in the superscript: <math alttext="bold upper A Superscript dagger"><msup><mi>ğ€</mi>
    <mo>â€ </mo></msup></math> , <math alttext="bold upper A Superscript plus"><msup><mi>ğ€</mi>
    <mo>+</mo></msup></math> , or <math alttext="bold upper A Superscript asterisk"><msup><mi>ğ€</mi>
    <mo>*</mo></msup></math> .'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼ªé€†åœ¨ä¸Šæ ‡ä¸­ä½¿ç”¨ä¸€ä¸ªâ€ ã€åŠ å·æˆ–æ˜Ÿå·æ¥è¡¨ç¤ºï¼š<math alttext="bold upper A Superscript dagger"><msup><mi>ğ€</mi>
    <mo>â€ </mo></msup></math>ï¼Œ<math alttext="bold upper A Superscript plus"><msup><mi>ğ€</mi>
    <mo>+</mo></msup></math>ï¼Œæˆ–<math alttext="bold upper A Superscript asterisk"><msup><mi>ğ€</mi>
    <mo>*</mo></msup></math>ã€‚
- en: 'The pseudoinverse is implemented in Python using the function `np.linalg.pinv`.
    The following code computes the pseudoinverse of the singular matrix for which
    `np.linalg.inv` produced an error message:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨Pythonä¸­ï¼Œä½¿ç”¨å‡½æ•°`np.linalg.pinv`æ¥å®ç°ä¼ªé€†ã€‚ä¸‹é¢çš„ä»£ç è®¡ç®—äº†ä¸€ä¸ªå¥‡å¼‚çŸ©é˜µçš„ä¼ªé€†ï¼Œè€Œ`np.linalg.inv`åˆ™äº§ç”Ÿäº†ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼š
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'How is the pseudoinverse computed? The algorithm is either incomprehensible
    or intuitive, depending on whether you understand the singular value decomposition.
    I will explain the pseudoinverse computation briefly, but if you donâ€™t understand
    it, then please donâ€™t worry: I promise it will be intuitive by the end of [ChapterÂ 13](ch13.xhtml#Chapter_13).
    To compute the pseudoinverse, take the SVD of a matrix, invert the nonzero singular
    values without changing the singular vectors, and reconstruct the matrix by multiplying
    <math alttext="bold upper U bold upper Sigma Superscript plus Baseline bold upper
    V Superscript upper T"><mrow><mi mathvariant="bold">U</mi><msup><mi mathvariant="bold">Î£</mi>
    <mo>+</mo></msup> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math>
    .'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼ªé€†æ˜¯å¦‚ä½•è®¡ç®—çš„ï¼Ÿç®—æ³•è¦ä¹ˆä»¤äººéš¾ä»¥ç†è§£ï¼Œè¦ä¹ˆç›´è§‚æ˜“æ‡‚ï¼Œè¿™å–å†³äºä½ æ˜¯å¦ç†è§£å¥‡å¼‚å€¼åˆ†è§£ã€‚æˆ‘ä¼šç®€è¦è§£é‡Šä¼ªé€†çš„è®¡ç®—ï¼Œä½†å¦‚æœä½ ä¸ç†è§£ï¼Œé‚£å°±ä¸è¦æ‹…å¿ƒï¼šæˆ‘ä¿è¯åˆ°[ç¬¬13ç« ](ch13.xhtml#Chapter_13)ç»“æŸæ—¶ï¼Œä½ ä¼šè§‰å¾—è¿™å¾ˆç›´è§‚ã€‚è¦è®¡ç®—ä¼ªé€†ï¼Œéœ€è¦å¯¹çŸ©é˜µè¿›è¡Œå¥‡å¼‚å€¼åˆ†è§£ï¼Œå€’è½¬éé›¶å¥‡å¼‚å€¼è€Œä¸æ”¹å˜å¥‡å¼‚å‘é‡ï¼Œç„¶åé€šè¿‡ä¹˜ä»¥<math
    alttext="bold upper U bold upper Sigma Superscript plus Baseline bold upper V
    Superscript upper T"><mrow><mi mathvariant="bold">U</mi><msup><mi mathvariant="bold">Î£</mi>
    <mo>+</mo></msup> <msup><mi mathvariant="bold">V</mi> <mtext>T</mtext></msup></mrow></math>æ¥é‡æ„çŸ©é˜µã€‚
- en: Numerical Stability of the Inverse
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é€†çš„æ•°å€¼ç¨³å®šæ€§
- en: Computing the matrix inverse involves a lot of FLOPs (floating-point operations),
    including many determinants. You learned in [ChapterÂ 6](ch06.xhtml#Chapter_6)
    that the determinant of a matrix can be numerically unstable, and therefore computing
    *many* determinants can lead to numerical inaccuracies, which can accumulate and
    cause significant problems when working with large matrices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—çŸ©é˜µçš„é€†æ¶‰åŠå¤§é‡çš„FLOPsï¼ˆæµ®ç‚¹è¿ç®—ï¼‰ï¼ŒåŒ…æ‹¬è®¸å¤šè¡Œåˆ—å¼ã€‚æ‚¨åœ¨[ç¬¬6ç« ](ch06.xhtml#Chapter_6)ä¸­å­¦åˆ°ï¼ŒçŸ©é˜µçš„è¡Œåˆ—å¼å¯èƒ½åœ¨æ•°å€¼ä¸Šä¸ç¨³å®šï¼Œå› æ­¤è®¡ç®—*è®¸å¤š*è¡Œåˆ—å¼å¯èƒ½å¯¼è‡´æ•°å€¼ä¸å‡†ç¡®ï¼Œè¿™äº›è¯¯å·®å¯èƒ½ä¼šç§¯ç´¯å¹¶åœ¨å¤„ç†å¤§å‹çŸ©é˜µæ—¶é€ æˆæ˜¾è‘—é—®é¢˜ã€‚
- en: For this reason, the low-level libraries that implement numerical computations
    (for example, LAPACK) generally strive to avoid explicitly inverting matrices
    when possible, or they decompose matrices into the product of other matrices that
    are more numerically stable (e.g., QR decomposition, which you will learn about
    in [ChapterÂ 9](ch09.xhtml#Chapter_09)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå®ç°æ•°å€¼è®¡ç®—çš„ä½çº§åº“ï¼ˆä¾‹å¦‚ï¼ŒLAPACKï¼‰é€šå¸¸åœ¨å¯èƒ½æ—¶é¿å…æ˜¾å¼æ±‚é€†çŸ©é˜µï¼Œæˆ–è€…å°†çŸ©é˜µåˆ†è§£ä¸ºæ›´ä¸ºæ•°å€¼ç¨³å®šçš„å…¶ä»–çŸ©é˜µçš„ä¹˜ç§¯ï¼ˆä¾‹å¦‚QRåˆ†è§£ï¼Œåœ¨[ç¬¬9ç« ](ch09.xhtml#Chapter_09)ä¸­å°†ä¼šå­¦ä¹ ï¼‰ã€‚
- en: Matrices that have numerical values in roughly the same range tend to be more
    stable (though this is not guaranteed), which is why random-numbers matrices are
    easy to work with. But matrices with a large range of numerical values have a
    high risk of numerical instability. The â€œrange of numerical valuesâ€ is more formally
    captured as the *condition number* of a matrix, which is the ratio of the largest
    to smallest singular value. Youâ€™ll learn more about condition number in [ChapterÂ 14](ch14.xhtml#Chapter_14);
    for now, suffice it to say that the condition number is a measure of the spread
    of numerical values in a matrix.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°å€¼åœ¨å¤§è‡´ç›¸åŒèŒƒå›´å†…çš„çŸ©é˜µå¾€å¾€æ›´åŠ ç¨³å®šï¼ˆè™½ç„¶è¿™å¹¶ä¸ä¿è¯ï¼‰ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆéšæœºæ•°çŸ©é˜µæ˜“äºå¤„ç†çš„åŸå› ã€‚ä½†æ˜¯æ•°å€¼èŒƒå›´è¾ƒå¤§çš„çŸ©é˜µå­˜åœ¨é«˜é£é™©çš„æ•°å€¼ä¸ç¨³å®šæ€§ã€‚â€œæ•°å€¼èŒƒå›´â€æ›´æ­£å¼åœ°æ•æ‰ä¸ºçŸ©é˜µçš„*æ¡ä»¶æ•°*ï¼Œå³æœ€å¤§å¥‡å¼‚å€¼ä¸æœ€å°å¥‡å¼‚å€¼çš„æ¯”ç‡ã€‚æ‚¨å°†åœ¨[ç¬¬14ç« ](ch14.xhtml#Chapter_14)ä¸­æ›´å¤šåœ°äº†è§£æ¡ä»¶æ•°ï¼›ç›®å‰ï¼Œå¯ä»¥è¯´æ¡ä»¶æ•°æ˜¯çŸ©é˜µæ•°å€¼åˆ†å¸ƒçš„åº¦é‡ã€‚
- en: An example of a numerically unstable matrix is a Hilbert matrix. Each element
    in a Hilbert matrix is defined by the simple formula shown in [Equation 8-1](#hilbertmatrix).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ•°å€¼ä¸Šä¸ç¨³å®šçš„çŸ©é˜µçš„ä¾‹å­æ˜¯å¸Œå°”ä¼¯ç‰¹çŸ©é˜µã€‚å¸Œå°”ä¼¯ç‰¹çŸ©é˜µä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ç”±[æ–¹ç¨‹å¼8-1](#hilbertmatrix)ä¸­æ˜¾ç¤ºçš„ç®€å•å…¬å¼å®šä¹‰ã€‚
- en: Equation 8-1\. Formula to create a Hilbert matrix. *i* and *j* are row and column
    indices.
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: æ–¹ç¨‹å¼8-1\. åˆ›å»ºå¸Œå°”ä¼¯ç‰¹çŸ©é˜µçš„å…¬å¼ã€‚*i* å’Œ *j* æ˜¯è¡Œå’Œåˆ—çš„ç´¢å¼•ã€‚
- en: <math alttext="h Subscript i comma j Baseline equals StartFraction 1 Over i
    plus j minus 1 EndFraction" display="block"><mrow><msub><mi>h</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="h Subscript i comma j Baseline equals StartFraction 1 Over i
    plus j minus 1 EndFraction" display="block"><mrow><msub><mi>h</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>i</mi><mo>+</mo><mi>j</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
- en: 'Hereâ€™s an example of a <math alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo>
    <mn>3</mn></mrow></math> Hilbert matrix:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ª<math alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>3</mn></mrow></math>å¸Œå°”ä¼¯ç‰¹çŸ©é˜µçš„ç¤ºä¾‹ï¼š
- en: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 slash 2
    3rd Column 1 slash 3 2nd Row 1st Column 1 slash 2 2nd Column 1 slash 3 3rd Column
    1 slash 4 3rd Row 1st Column 1 slash 3 2nd Column 1 slash 4 3rd Column 1 slash
    5 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>3</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced></math>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="Start 3 By 3 Matrix 1st Row 1st Column 1 2nd Column 1 slash 2
    3rd Column 1 slash 3 2nd Row 1st Column 1 slash 2 2nd Column 1 slash 3 3rd Column
    1 slash 4 3rd Row 1st Column 1 slash 3 2nd Column 1 slash 4 3rd Column 1 slash
    5 EndMatrix" display="block"><mfenced close="]" open="["><mtable><mtr><mtd><mn>1</mn></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn> <mo>/</mo>
    <mn>2</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>3</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd></mtr> <mtr><mtd><mrow><mn>1</mn>
    <mo>/</mo> <mn>3</mn></mrow></mtd> <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>4</mn></mrow></mtd>
    <mtd><mrow><mn>1</mn> <mo>/</mo> <mn>5</mn></mrow></mtd></mtr></mtable></mfenced></math>
- en: As the matrix gets larger, the range of numerical values increases. As a consequence,
    the computer-calculated Hilbert matrix quickly becomes rank-deficient. Even full-rank
    Hilbert matrices have inverses in a very different numerical range. This is illustrated
    in [FigureÂ 8-5](#fig_8_5), which shows a <math alttext="5 times 5"><mrow><mn>5</mn>
    <mo>Ã—</mo> <mn>5</mn></mrow></math> Hilbert matrix, its inverse, and their product.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: éšç€çŸ©é˜µå˜å¾—æ›´å¤§ï¼Œæ•°å€¼èŒƒå›´å¢åŠ ã€‚å› æ­¤ï¼Œè®¡ç®—æœºè®¡ç®—çš„å¸Œå°”ä¼¯ç‰¹çŸ©é˜µå¾ˆå¿«å˜ä¸ºç§©ä¸è¶³ã€‚å³ä½¿å…¨ç§©çš„å¸Œå°”ä¼¯ç‰¹çŸ©é˜µå…¶é€†çŸ©é˜µä¹Ÿåœ¨éå¸¸ä¸åŒçš„æ•°å€¼èŒƒå›´å†…ã€‚è¿™åœ¨[å›¾8-5](#fig_8_5)ä¸­æœ‰æ‰€è¯´æ˜ï¼Œè¯¥å›¾å±•ç¤ºäº†ä¸€ä¸ª<math
    alttext="5 times 5"><mrow><mn>5</mn> <mo>Ã—</mo> <mn>5</mn></mrow></math>å¸Œå°”ä¼¯ç‰¹çŸ©é˜µåŠå…¶é€†çŸ©é˜µåŠå®ƒä»¬çš„ä¹˜ç§¯ã€‚
- en: '![Hilberts](assets/plad_0805.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Hilberts](assets/plad_0805.png)'
- en: Figure 8-5\. A Hilbert matrix, its inverse, and their product
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾8-5\. ä¸€ä¸ªå¸Œå°”ä¼¯ç‰¹çŸ©é˜µï¼Œå…¶é€†çŸ©é˜µåŠå®ƒä»¬çš„ä¹˜ç§¯
- en: The product matrix certainly looks like the identity matrix, but in [Exercise
    8-9](#exercise_8_9) you will discover that looks can be deceiving, and rounding
    errors increase dramatically with matrix size.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹˜ç§¯çŸ©é˜µçœ‹èµ·æ¥ç¡®å®åƒå•ä½çŸ©é˜µï¼Œä½†åœ¨[ç»ƒä¹ 8-9](#exercise_8_9)ä¸­ï¼Œæ‚¨å°†å‘ç°å¤–è¡¨å¯èƒ½å…·æœ‰æ¬ºéª—æ€§ï¼Œè€Œä¸”èˆå…¥è¯¯å·®éšçŸ©é˜µå¤§å°æ˜¾è‘—å¢åŠ ã€‚
- en: Geometric Interpretation of the Inverse
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é€†çš„å‡ ä½•è§£é‡Š
- en: In Chapters [6](ch06.xhtml#Chapter_6) and [7](ch07.xhtml#Chapter_7), you learned
    how to conceptualize matrix-vector multiplication as a geometric transformation
    of a vector or a set of points.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¬¬[6ç« ](ch06.xhtml#Chapter_6)å’Œç¬¬[7ç« ](ch07.xhtml#Chapter_7)ä¸­ï¼Œæ‚¨å­¦ä¼šäº†å¦‚ä½•å°†çŸ©é˜µå‘é‡ä¹˜æ³•æ¦‚å¿µåŒ–ä¸ºå‘é‡æˆ–ä¸€ç»„ç‚¹çš„å‡ ä½•å˜æ¢ã€‚
- en: Following along these lines, we can think of the matrix inverse as *undoing*
    the geometric transformation imposed by matrix multiplication. [FigureÂ 8-6](#fig_8_6)
    shows an example that follows from [FigureÂ 7-8](ch07.xhtml#fig_7_8); I simply
    multiplied the transformed geometric coordinates by the inverse of the transformation
    matrix.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æ²¿ç€è¿™äº›æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†çŸ©é˜µé€†æƒ³è±¡ä¸ºé€šè¿‡çŸ©é˜µä¹˜æ³•â€œæ’¤é”€â€çŸ©é˜µä¹˜æ³•æ–½åŠ çš„å‡ ä½•å˜æ¢ã€‚[å›¾8-6](#fig_8_6)å±•ç¤ºäº†ä¸€ä¸ªç¤ºä¾‹ï¼Œå®ƒéµå¾ªè‡ª[å›¾7-8](ch07.xhtml#fig_7_8)ï¼›æˆ‘åªæ˜¯å°†å˜æ¢åçš„å‡ ä½•åæ ‡ä¹˜ä»¥å˜æ¢çŸ©é˜µçš„é€†ã€‚
- en: '![Geometry, undone](assets/plad_0806.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![å‡ ä½•å›¾åƒï¼Œæœªå®Œæˆ](assets/plad_0806.png)'
- en: Figure 8-6\. The matrix inverse undoes a geometric transform. Code to produce
    this figure is part of [Exercise 8-8](#exercise_8_8).
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾8-6ã€‚çŸ©é˜µé€†å–æ¶ˆäº†å‡ ä½•å˜æ¢ã€‚ç”Ÿæˆæ­¤å›¾çš„ä»£ç æ˜¯ [Exercise 8-8](#exercise_8_8) çš„ä¸€éƒ¨åˆ†ã€‚
- en: 'This geometric effect is unsurprising when inspecting the math. In the following
    equations, <math alttext="bold upper P"><mi>ğ</mi></math> is the <math alttext="2
    times upper N"><mrow><mn>2</mn> <mo>Ã—</mo> <mi>N</mi></mrow></math> matrix of
    original geometric coordinates, <math alttext="bold upper T"><mi>ğ“</mi></math>
    is the transformation matrix, <math alttext="bold upper Q"><mi>ğ</mi></math> is
    the matrix of transformed coordinates, and <math alttext="bold upper U"><mi>ğ”</mi></math>
    is the matrix of back-transformed coordinates:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ£€æŸ¥æ•°å­¦æ—¶ï¼Œè¿™ç§å‡ ä½•æ•ˆæœå¹¶ä¸å¥‡æ€ªã€‚åœ¨ä¸‹é¢çš„æ–¹ç¨‹ä¸­ï¼Œ<math alttext="bold upper P"><mi>ğ</mi></math> æ˜¯åŸå§‹å‡ ä½•åæ ‡çš„<math
    alttext="2 times upper N"><mrow><mn>2</mn> <mo>Ã—</mo> <mi>N</mi></mrow></math>çŸ©é˜µï¼Œ<math
    alttext="bold upper T"><mi>ğ“</mi></math> æ˜¯å˜æ¢çŸ©é˜µï¼Œ<math alttext="bold upper Q"><mi>ğ</mi></math>
    æ˜¯å˜æ¢ååæ ‡çš„çŸ©é˜µï¼Œ<math alttext="bold upper U"><mi>ğ”</mi></math> æ˜¯åå˜æ¢ååæ ‡çš„çŸ©é˜µï¼š
- en: <math alttext="StartLayout 1st Row 1st Column bold upper Q 2nd Column equals
    bold upper T bold upper P 2nd Row 1st Column bold upper U 2nd Column equals bold
    upper T Superscript negative 1 Baseline bold upper Q 3rd Row 1st Column bold upper
    U 2nd Column equals bold upper T Superscript negative 1 Baseline bold upper T
    bold upper P EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>ğ</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ“</mi> <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>ğ”</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>ğ”</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ“</mi> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartLayout 1st Row 1st Column bold upper Q 2nd Column equals
    bold upper T bold upper P 2nd Row 1st Column bold upper U 2nd Column equals bold
    upper T Superscript negative 1 Baseline bold upper Q 3rd Row 1st Column bold upper
    U 2nd Column equals bold upper T Superscript negative 1 Baseline bold upper T
    bold upper P EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="right"><mi>ğ</mi></mtd> <mtd columnalign="left"><mrow><mo>=</mo>
    <mi>ğ“</mi> <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>ğ”</mi></mtd>
    <mtd columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ</mi></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mi>ğ”</mi></mtd> <mtd
    columnalign="left"><mrow><mo>=</mo> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mi>ğ“</mi> <mi>ğ</mi></mrow></mtd></mtr></mtable></math>
- en: 'Although not a surprising result, I hope it helps build some geometric intuition
    for the purpose of the matrix inverse: *undoing the transform imposed by the matrix*.
    This interpretation will come in handy when you learn about diagonalizing a matrix
    through eigendecomposition.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™ä¸æ˜¯ä¸€ä¸ªä»¤äººæƒŠè®¶çš„ç»“æœï¼Œä½†æˆ‘å¸Œæœ›å®ƒæœ‰åŠ©äºå»ºç«‹ä¸€äº›å…³äºçŸ©é˜µé€†çš„å‡ ä½•ç›´è§‰ï¼šé€šè¿‡çŸ©é˜µæ–½åŠ çš„å˜æ¢â€œæ’¤é”€â€ã€‚å½“ä½ å­¦ä¹ é€šè¿‡ç‰¹å¾åˆ†è§£å¯¹çŸ©é˜µè¿›è¡Œå¯¹è§’åŒ–æ—¶ï¼Œè¿™ç§è§£é‡Šä¼šå¾ˆæœ‰ç”¨ã€‚
- en: 'This geometric interpretation also provides some intuition for why a reduced-rank
    matrix has no inverse: the geometric effect of transforming by a singular matrix
    is that at least one dimension is flattened. Once a dimension is flattened, it
    cannot be unflattened, just like you cannot see your back when facing a mirror.^([2](ch08.xhtml#idm45733298077104))'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å‡ ä½•è§£é‡Šä¹Ÿä¸ºä¸ºä½•é™ç§©çŸ©é˜µæ²¡æœ‰é€†çš„ç›´è§‚ç†è§£æä¾›äº†ä¸€äº›å¯ç¤ºï¼šé€šè¿‡å¥‡å¼‚çŸ©é˜µå˜æ¢çš„å‡ ä½•æ•ˆæœæ˜¯è‡³å°‘æœ‰ä¸€ä¸ªç»´åº¦è¢«å‹æ‰ã€‚ä¸€æ—¦ä¸€ä¸ªç»´åº¦è¢«å‹æ‰ï¼Œå®ƒå°±æ— æ³•æ¢å¤ï¼Œå°±åƒä½ ä¸èƒ½åœ¨é¢å¯¹é•œå­æ—¶çœ‹åˆ°è‡ªå·±çš„èƒŒé¢ä¸€æ ·ã€‚^([2](ch08.xhtml#idm45733298077104))
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: 'I really enjoyed writing this chapter, and I hope you enjoyed learning from
    it. Here is a summary of the key take-home messages:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘éå¸¸å–œæ¬¢å†™è¿™ä¸€ç« ï¼Œä¹Ÿå¸Œæœ›ä½ ä»¬ä»ä¸­å­¦åˆ°äº†ä¸œè¥¿ã€‚ä»¥ä¸‹æ˜¯å…³é”®çš„è¦ç‚¹æ€»ç»“ï¼š
- en: The matrix inverse is a matrix that, through matrix multiplication, transforms
    a maximum-rank matrix into the identity matrix. The inverse has many purposes,
    including moving matrices around in an equation (e.g., solve for **x** in **Ax**
    = **b**).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: çŸ©é˜µé€†æ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œé€šè¿‡çŸ©é˜µä¹˜æ³•å°†æœ€å¤§ç§©çŸ©é˜µè½¬æ¢ä¸ºå•ä½çŸ©é˜µã€‚é€†å…·æœ‰å¤šç§ç”¨é€”ï¼ŒåŒ…æ‹¬åœ¨æ–¹ç¨‹ä¸­ç§»åŠ¨çŸ©é˜µï¼ˆä¾‹å¦‚ï¼Œè§£**Ax** = **b**ä¸­çš„**x**ï¼‰ã€‚
- en: A square full-rank matrix has a full inverse, a tall full column-rank matrix
    has a left-inverse, and a wide full row-rank matrix has a right-inverse. Reduced-rank
    matrices cannot be linearly transformed into the identity matrix, but they do
    have a pseudoinverse that transforms the matrix into another matrix that is closer
    to the identity matrix.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ­£æ–¹å½¢å…¨ç§©çŸ©é˜µæœ‰ä¸€ä¸ªå®Œå…¨é€†ï¼Œä¸€ä¸ªé«˜ä¸”å…¨åˆ—ç§©çŸ©é˜µæœ‰ä¸€ä¸ªå·¦é€†ï¼Œè€Œå®½ä¸”å…¨è¡Œç§©çŸ©é˜µæœ‰ä¸€ä¸ªå³é€†ã€‚é™ç§©çŸ©é˜µä¸èƒ½è¢«çº¿æ€§å˜æ¢ä¸ºå•ä½çŸ©é˜µï¼Œä½†å®ƒä»¬ç¡®å®æœ‰ä¸€ä¸ªä¼ªé€†ï¼Œå¯ä»¥å°†çŸ©é˜µå˜æ¢ä¸ºå¦ä¸€ä¸ªæ›´æ¥è¿‘å•ä½çŸ©é˜µçš„çŸ©é˜µã€‚
- en: The inverse is uniqueâ€”if a matrix can be linearly transformed into the identity
    matrix, there is only one way to do it.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€†æ˜¯å”¯ä¸€çš„â€”â€”å¦‚æœä¸€ä¸ªçŸ©é˜µå¯ä»¥çº¿æ€§å˜æ¢ä¸ºå•ä½çŸ©é˜µï¼Œé‚£ä¹ˆåªæœ‰ä¸€ç§æ–¹æ³•å¯ä»¥åšåˆ°ã€‚
- en: There are some tricks for computing the inverses of some kinds of matrices,
    including 2 Ã— 2 and diagonal matrices. These shortcuts are simplifications of
    the full formula for computing a matrix inverse.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ‰ä¸€äº›æŠ€å·§å¯ä»¥è®¡ç®—æŸäº›ç±»å‹çŸ©é˜µçš„é€†ï¼ŒåŒ…æ‹¬2Ã—2å’Œå¯¹è§’çŸ©é˜µã€‚è¿™äº›å¿«æ·æ–¹å¼æ˜¯è®¡ç®—çŸ©é˜µé€†çš„å®Œæ•´å…¬å¼çš„ç®€åŒ–ã€‚
- en: Due to the risk of numerical precision errors, production-level algorithms try
    to avoid explicitly inverting matrices, or will decompose a matrix into other
    matrices that can be inverted with greater numerical stability.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç”±äºæ•°å€¼ç²¾åº¦è¯¯å·®çš„é£é™©ï¼Œç”Ÿäº§çº§ç®—æ³•å°è¯•é¿å…æ˜¾å¼æ±‚é€†çŸ©é˜µï¼Œæˆ–å°†çŸ©é˜µåˆ†è§£ä¸ºå…¶ä»–å¯ä»¥æ›´ç¨³å®šåœ°æ±‚é€†çš„çŸ©é˜µã€‚
- en: Code Exercises
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»£ç ç»ƒä¹ 
- en: Exercise 8-1\.
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 8-1ã€‚
- en: The inverse of the inverse is the original matrix; in other words, <math alttext="left-parenthesis
    bold upper A Superscript negative 1 Baseline right-parenthesis Superscript negative
    1 Baseline equals bold upper A"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mi>ğ€</mi></mrow></math>
    . This is analgous to how <math alttext="1 slash left-parenthesis 1 slash a right-parenthesis
    equals a"><mrow><mn>1</mn> <mo>/</mo> <mo>(</mo> <mn>1</mn> <mo>/</mo> <mi>a</mi>
    <mo>)</mo> <mo>=</mo> <mi>a</mi></mrow></math> . Illustrate this using Python.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: é€†çš„é€†æ˜¯åŸå§‹çŸ©é˜µï¼›æ¢å¥è¯è¯´ï¼Œ<math alttext="left-parenthesis bold upper A Superscript negative
    1 Baseline right-parenthesis Superscript negative 1 Baseline equals bold upper
    A"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo> <mi>ğ€</mi></mrow></math>ã€‚è¿™ç±»ä¼¼äº
    <math alttext="1 slash left-parenthesis 1 slash a right-parenthesis equals a"><mrow><mn>1</mn>
    <mo>/</mo> <mo>(</mo> <mn>1</mn> <mo>/</mo> <mi>a</mi> <mo>)</mo> <mo>=</mo> <mi>a</mi></mrow></math>ã€‚ç”¨
    Python è¿›è¡Œè¯´æ˜ã€‚
- en: Exercise 8-2\.
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-2ã€‚
- en: Implement the full algorithm described in [â€œInverting Any Square Full-Rank Matrixâ€](#inverting-any-square)
    and reproduce [FigureÂ 8-3](#fig_8_3). Of course, your matrices will look different
    from [FigureÂ 8-3](#fig_8_3) because of random numbers, although the grid and identity
    matrices will be the same.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: å®ç° [â€œæ±‚é€†ä»»æ„æ–¹é˜µâ€](#inverting-any-square) ä¸­æè¿°çš„å®Œæ•´ç®—æ³•ï¼Œå¹¶å¤åˆ¶ [FigureÂ 8-3](#fig_8_3)ã€‚å½“ç„¶ï¼Œä½ çš„çŸ©é˜µç”±äºéšæœºæ•°è€Œä¸åŒï¼Œå°½ç®¡ç½‘æ ¼å’Œå•ä½çŸ©é˜µå°†ç›¸åŒã€‚
- en: Exercise 8-3\.
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-3ã€‚
- en: Implement the full-inverse algorithm by hand for a 2 Ã— 2 matrix using matrix
    elements *a*, *b*, *c*, and *d*. I donâ€™t normally assign hand-solved problems
    in this book, but this exercise will show you where the shortcut comes from. Remember
    that the determinant of a scalar is its absolute value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰‹åŠ¨ä¸ºä¸€ä¸ª2 Ã— 2çŸ©é˜µä½¿ç”¨çŸ©é˜µå…ƒç´  *a*, *b*, *c*, å’Œ *d* å®ç°å®Œå…¨é€†ç®—æ³•ã€‚æˆ‘é€šå¸¸ä¸ä¼šåœ¨è¿™æœ¬ä¹¦ä¸­åˆ†é…æ‰‹å·¥è§£å†³çš„é—®é¢˜ï¼Œä½†è¿™ä¸ªç»ƒä¹ å°†å‘ä½ å±•ç¤ºå¿«æ·æ–¹å¼çš„æ¥æºã€‚è¯·è®°ä½ï¼Œæ ‡é‡çš„è¡Œåˆ—å¼æ˜¯å®ƒçš„ç»å¯¹å€¼ã€‚
- en: Exercise 8-4\.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-4ã€‚
- en: 'Derive the right-inverse for wide matrices by following the logic that allowed
    us to discover the left-inverse. Then reproduce [FigureÂ 8-4](#fig_8_4) for a wide
    matrix. (Hint: start from the code for the left-inverse and adjust as necessary.)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿½éšå‘ç°å·¦é€†çš„é€»è¾‘æ¥æ¨å¯¼å®½çŸ©é˜µçš„å³é€†ã€‚ç„¶åä¸ºä¸€ä¸ªå®½çŸ©é˜µå¤åˆ¶ [FigureÂ 8-4](#fig_8_4)ã€‚ï¼ˆæç¤ºï¼šä»å·¦é€†çš„ä»£ç å¼€å§‹ï¼Œå¹¶æ ¹æ®éœ€è¦è¿›è¡Œè°ƒæ•´ã€‚ï¼‰
- en: Exercise 8-5\.
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-5ã€‚
- en: Illustrate in Python that the pseudoinverse (via `np.linalg.pinv`) equals the
    full inverse (via `np.linalg.inv`) for an invertible matrix. Next, illustrate
    that the pseudoinverse equals the left-inverse for a tall full column-rank matrix,
    and that it equals the right-inverse for a wide full row-rank matrix.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ç”¨ Python ç¤ºèŒƒä¼ªé€†ï¼ˆé€šè¿‡ `np.linalg.pinv`ï¼‰ç­‰äºå®Œå…¨é€†ï¼ˆé€šè¿‡ `np.linalg.inv`ï¼‰çš„å¯é€†çŸ©é˜µã€‚æ¥ä¸‹æ¥ï¼Œç”¨ä¸€ä¸ªé«˜åˆ—æ»¡ç§©çŸ©é˜µå±•ç¤ºä¼ªé€†ç­‰äºå·¦é€†ï¼Œä»¥åŠç”¨ä¸€ä¸ªå®½è¡Œæ»¡ç§©çŸ©é˜µå±•ç¤ºä¼ªé€†ç­‰äºå³é€†ã€‚
- en: Exercise 8-6\.
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-6ã€‚
- en: 'The LIVE EVIL rule applies to the inverse of multiplied matrices. Test this
    in code by creating two square full-rank matrices <math alttext="bold upper A"><mi>ğ€</mi></math>
    and <math alttext="bold upper B"><mi>ğ</mi></math> , then use Euclidean distance
    to compare (1) <math alttext="left-parenthesis bold upper A bold upper B right-parenthesis
    Superscript negative 1"><msup><mrow><mo>(</mo><mi>ğ€</mi><mi>ğ</mi><mo>)</mo></mrow>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></math> , (2) <math alttext="bold upper
    A Superscript negative 1 Baseline bold upper B Superscript negative 1"><mrow><msup><mi>ğ€</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>ğ</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    , and (3) <math alttext="bold upper B Superscript negative 1 Baseline bold upper
    A Superscript negative 1"><mrow><msup><mi>ğ</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math> . Before
    starting to code, make a prediction about which results will be equal. Print out
    your results using formatting like the following (Iâ€™ve omitted my results so you
    wonâ€™t be biased!):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: LIVE EVILè§„åˆ™é€‚ç”¨äºç›¸ä¹˜çŸ©é˜µçš„é€†ã€‚é€šè¿‡åˆ›å»ºä¸¤ä¸ªæ–¹é˜µå…¨ç§©çŸ©é˜µ <math alttext="bold upper A"><mi>ğ€</mi></math>
    å’Œ <math alttext="bold upper B"><mi>ğ</mi></math> ï¼Œç„¶åä½¿ç”¨æ¬§å‡ é‡Œå¾—è·ç¦»æ¯”è¾ƒä»¥ä¸‹ä¸‰ç§æƒ…å†µçš„ç»“æœï¼š(1) <math
    alttext="left-parenthesis bold upper A bold upper B right-parenthesis Superscript
    negative 1"><msup><mrow><mo>(</mo><mi>ğ€</mi><mi>ğ</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup></math>ï¼Œ(2)
    <math alttext="bold upper A Superscript negative 1 Baseline bold upper B Superscript
    negative 1"><mrow><msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>ğ</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>ï¼Œä»¥åŠ(3) <math alttext="bold
    upper B Superscript negative 1 Baseline bold upper A Superscript negative 1"><mrow><msup><mi>ğ</mi>
    <mrow><mo>-</mo><mn>1</mn></mrow></msup> <msup><mi>ğ€</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>ã€‚å¼€å§‹ç¼–å†™ä»£ç ä¹‹å‰ï¼Œé¢„æµ‹å“ªäº›ç»“æœå°†ç›¸ç­‰ã€‚ä½¿ç”¨ç±»ä¼¼ä»¥ä¸‹æ ¼å¼çš„è¾“å‡ºæ‰“å°æ‚¨çš„ç»“æœï¼ˆæˆ‘çœç•¥äº†æˆ‘çš„ç»“æœï¼Œä»¥å…æ‚¨å—åˆ°å½±å“ï¼ï¼‰ï¼š
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As an extra challenge, you can confirm that the LIVE EVIL rule applies to a
    longer string of matrices, e.g., four matrices instead of two.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºé¢å¤–æŒ‘æˆ˜ï¼Œæ‚¨å¯ä»¥ç¡®è®¤LIVE EVILè§„åˆ™é€‚ç”¨äºæ›´é•¿çš„çŸ©é˜µä¸²è”ï¼Œä¾‹å¦‚å››ä¸ªçŸ©é˜µè€Œä¸æ˜¯ä¸¤ä¸ªã€‚
- en: Exercise 8-7\.
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-7ã€‚
- en: Does the LIVE EVIL rule also apply to the one-sided inverse? That is, does <math
    alttext="left-parenthesis bold upper T Superscript upper T Baseline bold upper
    T right-parenthesis Superscript negative 1 Baseline equals bold upper T Superscript
    hyphen upper T Baseline bold upper T Superscript negative 1"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ“</mi>
    <mtext>T</mtext></msup> <mi>ğ“</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup>
    <mo>=</mo> <msup><mi>ğ“</mi> <mtext>-T</mtext></msup> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>
    ? As with the previous exercise, make a prediction and then test it in Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: LIVE EVILè§„åˆ™æ˜¯å¦ä¹Ÿé€‚ç”¨äºå•ä¾§é€†çŸ©é˜µï¼Ÿä¹Ÿå°±æ˜¯è¯´ï¼Œæ˜¯å¦ <math alttext="left-parenthesis bold upper T
    Superscript upper T Baseline bold upper T right-parenthesis Superscript negative
    1 Baseline equals bold upper T Superscript hyphen upper T Baseline bold upper
    T Superscript negative 1"><mrow><msup><mrow><mo>(</mo><msup><mi>ğ“</mi> <mtext>T</mtext></msup>
    <mi>ğ“</mi><mo>)</mo></mrow> <mrow><mo>-</mo><mn>1</mn></mrow></msup> <mo>=</mo>
    <msup><mi>ğ“</mi> <mtext>-T</mtext></msup> <msup><mi>ğ“</mi> <mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>ï¼Ÿä¸å‰ä¸€ä¸ªç»ƒä¹ ä¸€æ ·ï¼Œå…ˆåšå‡ºé¢„æµ‹ï¼Œç„¶ååœ¨Pythonä¸­è¿›è¡Œæµ‹è¯•ã€‚
- en: Exercise 8-8\.
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-8ã€‚
- en: Write code to reproduce [FigureÂ 8-6](#fig_8_6). Start by copying the code from
    [Exercise 7-3](ch07.xhtml#exercise_7_3). After reproducing the figure, make the
    transformation matrix noninvertible by setting the lower-left element to `1`.
    What else needs to be changed in the code to prevent errors?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™ä»£ç ä»¥å†ç°[FigureÂ 8-6](#fig_8_6)ã€‚é¦–å…ˆä»[Exercise 7-3](ch07.xhtml#exercise_7_3)å¤åˆ¶ä»£ç ã€‚åœ¨å¤åˆ¶å›¾è¡¨åï¼Œé€šè¿‡å°†å·¦ä¸‹è§’å…ƒç´ è®¾ç½®ä¸º`1`ä½¿å˜æ¢çŸ©é˜µä¸å¯é€†ã€‚ä»£ç ä¸­è¿˜éœ€è¦æ›´æ”¹ä»€ä¹ˆä»¥é˜²æ­¢é”™è¯¯å‘ç”Ÿï¼Ÿ
- en: Exercise 8-9\.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹  8-9ã€‚
- en: This and the next exercise will help you explore the matrix inverse and its
    risk of numerical instability, using the Hilbert matrix. Start by creating a Hilbert
    matrix. Write a Python function that takes an integer as input and produces a
    Hilbert matrix as output, following [Equation 8-1](#hilbertmatrix). Then reproduce
    [FigureÂ 8-5](#fig_8_5).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå’Œä¸‹ä¸€ä¸ªç»ƒä¹ å°†å¸®åŠ©æ‚¨æ¢ç´¢çŸ©é˜µçš„é€†åŠå…¶æ•°å€¼ä¸ç¨³å®šæ€§ï¼Œä½¿ç”¨å¸Œå°”ä¼¯ç‰¹çŸ©é˜µã€‚é¦–å…ˆåˆ›å»ºä¸€ä¸ªå¸Œå°”ä¼¯ç‰¹çŸ©é˜µã€‚ç¼–å†™ä¸€ä¸ªPythonå‡½æ•°ï¼Œè¯¥å‡½æ•°ä»¥æ•´æ•°ä½œä¸ºè¾“å…¥å¹¶ç”Ÿæˆä¸€ä¸ªå¸Œå°”ä¼¯ç‰¹çŸ©é˜µä½œä¸ºè¾“å‡ºï¼Œéµå¾ª[Equation
    8-1](#hilbertmatrix)ã€‚ç„¶åå†ç°[FigureÂ 8-5](#fig_8_5)ã€‚
- en: 'I recommend writing your Python function using a double `for` loop over the
    rows and columns (*i* and *j* matrix indices), following the math formula. Once
    you confirm that the function is accurate, you can optionally challenge yourself
    to rewrite the function without any `for` loops (hint: outer product). You can
    confirm the accuracy of your function by comparing it to the `hilbert` function,
    which is in the `scipy.linalg` library.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å»ºè®®ç¼–å†™æ‚¨çš„Pythonå‡½æ•°ï¼Œä½¿ç”¨åŒé‡`for`å¾ªç¯éå†è¡Œå’Œåˆ—ï¼ˆ*i*å’Œ*j*çŸ©é˜µç´¢å¼•ï¼‰ï¼ŒæŒ‰ç…§æ•°å­¦å…¬å¼æ“ä½œã€‚ç¡®è®¤å‡½æ•°å‡†ç¡®æ— è¯¯åï¼Œæ‚¨å¯ä»¥é€‰æ‹©æ€§åœ°æŒ‘æˆ˜è‡ªå·±ï¼Œå°è¯•åœ¨æ²¡æœ‰ä»»ä½•`for`å¾ªç¯çš„æƒ…å†µä¸‹é‡å†™å‡½æ•°ï¼ˆæç¤ºï¼šå¤–ç§¯ï¼‰ã€‚æ‚¨å¯ä»¥é€šè¿‡å°†å…¶ä¸`scipy.linalg`åº“ä¸­çš„`hilbert`å‡½æ•°è¿›è¡Œæ¯”è¾ƒæ¥ç¡®è®¤å‡½æ•°çš„å‡†ç¡®æ€§ã€‚
- en: Exercise 8-10\.
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ç»ƒä¹ 8-10\.
- en: Using your Hilbert matrix function, create a Hilbert matrix, then compute its
    inverse using `np.linalg.inv`, and compute the product of the two matrices. That
    product should equal the identity matrix, which means the Euclidean distance between
    that product and the true identity matrix produced by `np.eye` should be 0 (within
    computer rounding error). Compute that Euclidean distance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ‚¨çš„å¸Œå°”ä¼¯ç‰¹çŸ©é˜µå‡½æ•°ï¼Œåˆ›å»ºä¸€ä¸ªå¸Œå°”ä¼¯ç‰¹çŸ©é˜µï¼Œç„¶åä½¿ç”¨`np.linalg.inv`è®¡ç®—å…¶é€†ï¼Œå¹¶è®¡ç®—è¿™ä¸¤ä¸ªçŸ©é˜µçš„ä¹˜ç§¯ã€‚è¯¥ä¹˜ç§¯åº”ç­‰äºå•ä½çŸ©é˜µï¼Œè¿™æ„å‘³ç€è¯¥ä¹˜ç§¯ä¸ç”±`np.eye`ç”Ÿæˆçš„çœŸå®å•ä½çŸ©é˜µä¹‹é—´çš„æ¬§å‡ é‡Œå¾·è·ç¦»åº”ä¸º0ï¼ˆåœ¨è®¡ç®—æœºèˆå…¥è¯¯å·®å†…ï¼‰ã€‚è®¡ç®—è¯¥æ¬§å‡ é‡Œå¾·è·ç¦»ã€‚
- en: Put this code into a `for` loop over a range of matrix sizes ranging from <math
    alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>3</mn></mrow></math> to <math
    alttext="12 times 12"><mrow><mn>12</mn> <mo>Ã—</mo> <mn>12</mn></mrow></math> .
    For each matrix size, store the Euclidean distance and the condition number of
    the Hilbert matrix. As I wrote earlier, the condition number is a measure of the
    spread of numerical values in the matrix, and can be extracted using the function
    `np.linalg.cond`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ­¤ä»£ç æ”¾å…¥ä¸€ä¸ªä»<math alttext="3 times 3"><mrow><mn>3</mn> <mo>Ã—</mo> <mn>3</mn></mrow></math>åˆ°<math
    alttext="12 times 12"><mrow><mn>12</mn> <mo>Ã—</mo> <mn>12</mn></mrow></math>çš„çŸ©é˜µå°ºå¯¸èŒƒå›´çš„`for`å¾ªç¯ä¸­ã€‚å¯¹äºæ¯ä¸ªçŸ©é˜µå°ºå¯¸ï¼Œå­˜å‚¨å¸Œå°”ä¼¯ç‰¹çŸ©é˜µçš„æ¬§å‡ é‡Œå¾·è·ç¦»å’Œæ¡ä»¶æ•°ã€‚å¦‚å‰æ‰€è¿°ï¼Œæ¡ä»¶æ•°æ˜¯çŸ©é˜µä¸­æ•°å€¼åˆ†å¸ƒçš„ä¸€ç§åº¦é‡ï¼Œå¯ä»¥ä½¿ç”¨å‡½æ•°`np.linalg.cond`æå–ã€‚
- en: Next, repeat the previous code, but using a Gaussian random-numbers matrix instead
    of the Hilbert matrix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œé‡å¤å‰è¿°ä»£ç ï¼Œä½†ä½¿ç”¨é«˜æ–¯éšæœºæ•°çŸ©é˜µä»£æ›¿å¸Œå°”ä¼¯ç‰¹çŸ©é˜µã€‚
- en: Finally, plot all of the results as shown in [FigureÂ 8-7](#fig_8_7). I plotted
    the distance and condition number in log scale to facilitate visual interpretation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼ŒæŒ‰ç…§[å›¾8-7](#fig_8_7)ä¸­æ‰€ç¤ºï¼Œç»˜åˆ¶æ‰€æœ‰ç»“æœã€‚æˆ‘å°†è·ç¦»å’Œæ¡ä»¶æ•°ç»˜åˆ¶åœ¨å¯¹æ•°åˆ»åº¦ä¸Šï¼Œä»¥ä¾¿è¿›è¡Œè§†è§‰è§£é‡Šã€‚
- en: '![Hilberts](assets/plad_0807.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Hilberts](assets/plad_0807.png)'
- en: Figure 8-7\. Results of Exercise 8-10
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: å›¾8-7\. ç»ƒä¹ 8-10çš„ç»“æœ
- en: Please feel inspired to continue exploring linear algebra using this exercise!
    Try plotting the Hilbert matrix times its inverse (consider adjusting the color
    scaling), using larger matrices or different special matrices, extracting other
    properties of the matrix like rank or norm, etc. Youâ€™re on an adventure in the
    wonderful land of linear algebra, and Python is the magic carpet that whisks you
    across the landscape.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·ç»§ç»­æ¢ç´¢çº¿æ€§ä»£æ•°ï¼Œæ„Ÿå—çµæ„Ÿå§ï¼å°è¯•ç»˜åˆ¶å¸Œå°”ä¼¯ç‰¹çŸ©é˜µä¹˜ä»¥å…¶é€†çŸ©é˜µï¼ˆè€ƒè™‘è°ƒæ•´é¢œè‰²ç¼©æ”¾ï¼‰ï¼Œä½¿ç”¨æ›´å¤§çš„çŸ©é˜µæˆ–ä¸åŒçš„ç‰¹æ®ŠçŸ©é˜µï¼Œæå–çŸ©é˜µçš„å…¶ä»–å±æ€§ï¼Œå¦‚ç§©æˆ–èŒƒæ•°ç­‰ã€‚æ‚¨æ­£åœ¨æ¢ç´¢çº¿æ€§ä»£æ•°çš„å¥‡å¦™ä¸–ç•Œï¼Œè€ŒPythonåˆ™æ˜¯å¸¦æ‚¨ç©¿è¶Šè¿™ç‰‡é£æ™¯çš„é­”æ¯¯ã€‚
- en: ^([1](ch08.xhtml#idm45733298305632-marker)) Because **T^TT** is reduced-rank
    and thus cannot be inverted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.xhtml#idm45733298305632-marker)) å› ä¸º**T^TT**æ˜¯é™ç§©çš„ï¼Œå› æ­¤ä¸èƒ½è¢«åè½¬ã€‚
- en: '^([2](ch08.xhtml#idm45733298077104-marker)) Thereâ€™s a witty analogy to *Flatland*
    somewhere here that Iâ€™m not quite able to eloquate. The point is: read the book
    *Flatland*.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.xhtml#idm45733298077104-marker)) åœ¨è¿™é‡Œæœ‰ä¸€ä¸ªä¸*Flatland*çš„æœºæ™ºç±»æ¯”ï¼Œæˆ‘æ— æ³•å‡†ç¡®è¡¨è¾¾ã€‚é‡ç‚¹æ˜¯ï¼šé˜…è¯»ä¹¦ç±*Flatland*ã€‚
