- en: 3 Identity and access management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 身份和访问管理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: The basics of RBAC
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC 基础
- en: Creating Roles and Role bindings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建角色和角色绑定
- en: Using certificates to create users and groups
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用证书创建用户和组
- en: Creating Service Accounts with Roles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用角色创建服务账户
- en: Mounting Service Accounts to Pods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务账户挂载到 Pod 上
- en: In this chapter, we’ll focus on role-based access control, which is within the
    cluster architecture, installation, and configuration section of the exam curriculum.
    Now that you know how the Kubernetes API works, it’s essential to understand how
    to authenticate and authorize a user and/or a Service Account for the exam.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注基于角色的访问控制，这是考试课程中集群架构、安装和配置部分的内容。既然你已经了解了 Kubernetes API 的工作原理，那么了解如何对用户和/或服务账户进行身份验证和授权对于考试至关重要。
- en: The cluster architecture, installation, and configuration domain
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 集群架构、安装和配置领域
- en: This chapter covers part of the cluster architecture, installation, and configuration
    domain of the CKA curriculum. This domain covers what consists of a Kubernetes
    cluster and how we configure different aspects of the cluster. It encompasses
    the following competencies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 CKA 课程中集群架构、安装和配置领域的一部分。该领域涵盖了 Kubernetes 集群由什么组成以及我们如何配置集群的不同方面。它包括以下能力。
- en: '| Competency | Chapter section |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 能力 | 章节部分 |'
- en: '| --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Manage role-based access control (RBAC). | 3.1, 3.2 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 管理基于角色的访问控制 (RBAC)。 | 3.1, 3.2 |'
- en: '| Manage a highly available Kubernetes cluster. | 3.3 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 管理高可用性 Kubernetes 集群。 | 3.3 |'
- en: 3.1 Role-based access control
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 基于角色的访问控制
- en: To access the resources within a Kubernetes cluster, you must first be authenticated.
    If you remember from chapter 2, we used the `kubectl` tool to interface with the
    Kubernetes API. We were allowed to do this because we had a client certificate
    that carried a token with which to authenticate, as depicted in figure 3.1\. This
    is called role-based access control (RBAC) because, based on our Role in Kubernetes,
    we were able to list the running Pods in the `kube-system` namespace. There are
    different ways that we can control these actions and block them if we wish. The
    authentication and authorization system built into Kubernetes allows us the ability
    to control access of a given user or machine to a Kubernetes cluster. We’ll talk
    more about this in the following sections of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 Kubernetes 集群内的资源，你必须首先进行身份验证。如果你还记得第 2 章，我们使用了 `kubectl` 工具与 Kubernetes
    API 进行交互。我们之所以能够这样做，是因为我们有一个携带令牌的客户证书，如图 3.1 所示。这被称为基于角色的访问控制（RBAC），因为根据我们在 Kubernetes
    中的角色，我们能够列出 `kube-system` 命名空间中运行的 Pod。我们可以以不同的方式控制这些操作，如果需要，可以阻止它们。Kubernetes
    内置的身份验证和授权系统使我们能够控制特定用户或机器对 Kubernetes 集群的访问。我们将在本章的后续部分进一步讨论这个问题。
- en: '![](../../OEBPS/Images/03-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-01.png)'
- en: Figure 3.1 Using a certificate and token to access the Kubernetes API
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 使用证书和令牌访问 Kubernetes API
- en: 'For that matter, you can view resources within their API groups in Kubernetes
    by using curl and passing in the certificate. Following this paragraph is the
    location of our Pods and Deployments in the API, which are in the `/core` and
    `/apps` group, respectively. From a Kubernetes cluster built with kubeadm, you
    can access these resources in the same manner using the following commands, assuming
    the address of the control plane is `10.0.0.4,` which can be retrieved using the
    command `kubectl config view` and/or `kubectl cluster-info`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就此而言，你可以通过使用 curl 并传递证书来查看 Kubernetes 中它们 API 组内的资源。在接下来的段落中，我们的 Pod 和 Deployment
    在 API 中的位置分别在 `/core` 和 `/apps` 组中。从使用 kubeadm 构建的 Kubernetes 集群中，你可以使用以下命令以相同的方式访问这些资源，假设控制平面的地址是
    `10.0.0.4`，可以使用命令 `kubectl config view` 和/或 `kubectl cluster-info` 获取：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can authenticate in different ways via authentication plugins. Some of
    these plugins come out of the box with Kubernetes, so that’s why we didn’t need
    to install them separately. The built-in plugin that we use with `kubectl` is
    called the certificates plugin. Many other authentication plugins are sources
    for authentication. Here are some common plugins, also depicted in figure 3.2:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过不同的方式通过身份验证插件进行身份验证。其中一些插件是 Kubernetes 自带的，这就是为什么我们不需要单独安装它们。我们与 `kubectl`
    一起使用的内置插件称为证书插件。还有许多其他身份验证插件是身份验证的来源。以下是一些常见的插件，如图 3.2 所示：
- en: Static token file (e.g., CSV file)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态令牌文件（例如，CSV 文件）
- en: Third-party identity service (AWS IAM)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方身份服务（AWS IAM）
- en: Basic HTTP authentication (token passed in an HTTP header)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本HTTP身份验证（令牌通过 HTTP 头部传递）
- en: More plugins can be enabled when starting the API server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 API 服务器时可以启用更多插件。
- en: '![](../../OEBPS/Images/03-02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-02.png)'
- en: Figure 3.2 Many different authentication plugins can be used to access the Kubernetes
    API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 可以使用许多不同的身份验证插件来访问 Kubernetes API。](../../OEBPS/Images/03-02.png)'
- en: When you make a request to the Kubernetes API, all the plugins analyze this
    request and try to determine if they can read it in sequence. The first plugin
    able to translate the meaning of the request handles the authentication. This
    involves determining if the request is coming from a human or a machine. If the
    request is coming from a human—like when we are using `kubectl`—then the user
    is authenticated as a specific username, and that name is used for subsequent
    steps. If the request originates from a machine, it must have a Service Account,
    and its credentials must be stored as a Secret in Kubernetes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向 Kubernetes API 发起请求时，所有插件都会分析这个请求并尝试确定它们是否可以按顺序读取它。第一个能够翻译请求含义的插件处理身份验证。这涉及到确定请求是否来自人类或机器。如果请求来自人类——例如当我们使用
    `kubectl` 时——则用户将以特定的用户名进行身份验证，并且该名称将用于后续步骤。如果请求来自机器，它必须有一个服务账户，并且其凭证必须以秘密的形式存储在
    Kubernetes 中。
- en: Both Service Accounts and Secrets are Kubernetes resources, whereas users are
    not. A Service Account is an identity for processes that run inside of a Pod,
    providing a method to authenticate and perform actions in the cluster on behalf
    of a Pod. This allows other access-management systems to easily integrate with
    Kubernetes via SSO through LDAP (lightweight directory access protocol) or AD
    (active directory) for authentication.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户和秘密都是 Kubernetes 资源，而用户不是。服务账户是运行在 Pod 内部的进程的身份，提供了一种在集群中代表 Pod 进行身份验证和执行操作的方法。这允许其他访问管理系统通过
    LDAP（轻量级目录访问协议）或 AD（活动目录）通过单点登录（SSO）轻松地与 Kubernetes 集成进行身份验证。
- en: A Service Account is a Kubernetes resource; therefore, Kubernetes manages this
    along with other resources like Pods, Deployments, and persistent volumes. Service
    Accounts are often associated with Pods running in the cluster, which allow applications
    running inside the Pod (as containers) to access the Kubernetes API and make requests.
    A token is mounted to each Pod via a Service Account, as depicted in figure 3.3\.
    You can disable this feature, as most of the time you don’t need your Pods to
    talk to the API. We will go through an example of mounting a Service Account in
    a Pod and preventing Service Accounts from mounting to a Pod later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户是 Kubernetes 资源；因此，Kubernetes 会管理它以及其他资源，如 Pods、Deployments 和持久卷。服务账户通常与在集群中运行的
    Pods 关联，允许 Pod 内部运行的应用程序（作为容器）访问 Kubernetes API 并发起请求。如图 3.3 所示，通过服务账户将令牌挂载到每个
    Pod 上。你可以禁用此功能，因为在大多数情况下，你不需要你的 Pods 与 API 通信。我们将在本章后面通过一个在 Pod 中挂载服务账户并防止服务账户挂载到
    Pod 的示例进行说明。
- en: '![](../../OEBPS/Images/03-03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-03.png)'
- en: Figure 3.3 A Service Account can be used to mount a token in a Pod, so it can
    authenticate with the API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 服务账户可以用来在 Pod 中挂载令牌，以便它可以与 API 进行身份验证。](../../OEBPS/Images/03-03.png)'
- en: After the authentication phase, the request is passed on to the authorization
    plugins. RBAC is considered one of the authentication plugins, but there are others
    like the Node authorization plugin and the WebHook authorization plugin. For the
    purposes of the CKA exam, we are going to focus solely on RBAC, as you see depicted
    in figure 3.4\. RBAC prevents unauthorized users from viewing or modifying the
    cluster state through the principle of least privilege. That principle states
    that administrators can allow explicit access to a single subject in Kubernetes
    but provide no additional privileges to any other subjects (e.g., permissions
    to view Pods but not delete them).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在身份验证阶段之后，请求会被传递到授权插件。RBAC 被视为身份验证插件之一，但还有其他插件，如节点授权插件和 WebHook 授权插件。为了 CKA
    考试的目的，我们将专注于 RBAC，如图 3.4 所示。RBAC 通过最小权限原则阻止未经授权的用户通过查看或修改集群状态。该原则指出，管理员可以允许对 Kubernetes
    中单个主题进行明确的访问，但不会向任何其他主题提供额外的权限（例如，查看 Pods 的权限，但不允许删除它们）。
- en: '![](../../OEBPS/Images/03-04.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-04.png)'
- en: Figure 3.4 The RBAC plugin prevents unauthorized requests from accessing the
    Kubernetes API.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 RBAC 插件阻止未经授权的请求访问 Kubernetes API。](../../OEBPS/Images/03-04.png)'
- en: 'The authorization mode in our kind cluster was set to RBAC as well as Node
    authorization on the Kubernetes API server during the bootstrap process. We can
    view this setting in the `/etc/kubernetes/manifests` directory in our `kind-control-plane`
    container. You will see it under `spec`, in the list of container commands, as
    `--authorization-mode=Node,RBAC`. Let’s get the contents of that file and pipe
    it to `more` with the command `cat /etc/kubernetes/manifests/kube-apiserver.yaml
    | more`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的kind集群中，授权模式在引导过程中被设置为RBAC以及Kubernetes API服务器上的节点授权。我们可以在`kind-control-plane`容器中的`/etc/kubernetes/manifests`目录中查看此设置。您将在`spec`下看到它，在容器命令列表中，作为`--authorization-mode=Node,RBAC`。让我们使用命令`cat
    /etc/kubernetes/manifests/kube-apiserver.yaml | more`获取该文件的正文并将其通过`more`命令查看：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could have opened this file in a text editor just as easily, but we used
    the `cat` command instead. This YAML manifest is important to remember, as it
    contains the cluster configuration for many components in the Kubernetes cluster,
    such as the advertise address, privileged modes, and all the certificates and
    keys for etcd and the kubelet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以用文本编辑器打开这个文件，但我们还是使用了`cat`命令。这个YAML清单非常重要，因为它包含了Kubernetes集群中许多组件的集群配置，例如广告地址、特权模式，以及etcd和kubelet的所有证书和密钥。
- en: EXAM TIP Remember that the manifests for control plane components are in the
    `/etc/Kubernetes/manifests` directory. This directory will be located on the control
    plane server, which you will have to SSH into to view or modify. On the exam,
    the SSH keys are shared; therefore, you can simply type `ssh control-plane-node`
    to get a shell to the control plane node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：记住控制平面组件的清单位于`/etc/Kubernetes/manifests`目录中。此目录将位于控制平面服务器上，您需要通过SSH连接到该服务器以查看或修改。在考试中，SSH密钥是共享的；因此，您只需键入`ssh
    control-plane-node`即可获得控制平面节点的shell。
- en: When the RBAC authorization plugin receives the request, it determines what
    action is allowed to be performed by the user or group. Yes, groups are factored
    into RBAC as well, which simply means a group of users who are all assigned the
    same level of privilege in Kubernetes. We’ll go through creating users and groups
    later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当RBAC授权插件收到请求时，它会确定用户或组可以执行哪些操作。是的，组也被纳入了RBAC，这意味着在Kubernetes中，一组用户被分配了相同的权限级别。我们将在本章后面讨论创建用户和组。
- en: 3.1.1 Roles and Role bindings
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 角色和角色绑定
- en: 'So, how does RBAC know what actions are permitted? This is determined by four
    different types of objects in Kubernetes: the Role, the cluster Role, the Role
    binding, and the cluster Role binding, as depicted in figure 3.5\. Previously
    we talked about Kubernetes resources that are namespace scoped. Permissions for
    resources that are inside a namespace need to be scoped to that namespace as well.
    The same goes for resources that are not namespace scoped, such as persistent
    volumes, nodes, or namespaces themselves. These resources need properly defined
    cluster Roles (cluster-wide) or Roles (namespaced).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，RBAC是如何知道允许执行哪些操作的？这由Kubernetes中的四种不同类型的对象确定：角色、集群角色、角色绑定和集群角色绑定，如图3.5所示。之前我们讨论了Kubernetes中命名空间范围资源。命名空间内资源的权限也需要限定在那个命名空间内。对于不是命名空间范围资源的情况，例如持久卷、节点或命名空间本身，也是如此。这些资源需要正确定义的集群角色（集群范围内）或角色（命名空间内）。
- en: '![](../../OEBPS/Images/03-05.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 角色和角色绑定](../../OEBPS/Images/03-05.png)'
- en: Figure 3.5 Roles and Role bindings define privileges in a namespace, where cluster
    Roles and cluster Role bindings define cluster-wide privileges.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 角色和角色绑定定义了命名空间中的权限，而集群角色和集群角色绑定定义了集群范围内的权限。
- en: NOTE It helps to remember which type of user will be accessing namespaced resources
    versus cluster resources. Application developers will commonly be assigned Roles
    because they develop applications that exist inside a namespace. Cluster administrators
    will commonly be assigned cluster Roles because they are updating nodes and creating
    volumes and other operations outside of the namespace (cluster-wide).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：记住哪种类型的用户将访问命名空间资源与集群资源是有帮助的。应用程序开发者通常会被分配角色，因为他们开发的应用程序存在于命名空间内。集群管理员通常会被分配集群角色，因为他们更新节点、创建卷以及其他在命名空间之外（集群范围内）的操作。
- en: Roles are not only scoped to a namespace but also to a particular resource in
    Kubernetes (i.e., Pods) and will list the specific actions allowed within that
    Role. The actions are referred to as *request verbs*. They are like API requests,
    but because a resource can have multiple Endpoints, a request verb targets a specific
    Endpoint and uses the lower-cased HTTP method of the request as the verb. So,
    `get`, `list`, `create`, `update`, `patch`, `watch`, `delete`, and `deletecollection`
    are all API request verbs, which allow you to perform an action on a resource,
    as depicted in figure 3.6.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 角色不仅限于命名空间，还限于 Kubernetes 中的特定资源（例如 Pod），并列出该角色中允许的具体操作。这些操作被称为 *请求动词*。它们类似于
    API 请求，但由于资源可以有多个端点，请求动词针对特定的端点，并使用请求的 HTTP 方法的小写作为动词。因此，`get`、`list`、`create`、`update`、`patch`、`watch`、`delete`
    和 `deletecollection` 都是 API 请求动词，允许你在资源上执行操作，如图 3.6 所示。
- en: '![](../../OEBPS/Images/03-06.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-06.png)'
- en: Figure 3.6 Request verbs correspond roughly with HTTP verbs, as shown here.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 请求动词大致对应于 HTTP 动词，如图所示。
- en: Let’s look at an example by typing the command `kubectl create role pod-reader`
    `--verb=get,list,watch --resource=pods`, and you’ll see output similar to figure
    3.7\. The YAML output from the Role that we just created with the command `kubectl
    get role pod-reader -o yaml` shows output similar to figure 3.8.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过输入命令 `kubectl create role pod-reader` `--verb=get,list,watch --resource=pods`
    来查看一个示例，你会看到类似于图 3.7 的输出。我们刚刚使用命令 `kubectl get role pod-reader -o yaml` 创建的角色的
    YAML 输出类似于图 3.8。
- en: '![](../../OEBPS/Images/03-07.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-07.png)'
- en: Figure 3.7 With this imperative command, create a Role and assign request verbs
    for a resource.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 使用这个命令式命令创建一个角色并为资源分配请求动词。
- en: '![](../../OEBPS/Images/03-08.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-08.png)'
- en: Figure 3.8 The `kubectl` `get` `role` command shows which resources this Role
    applies to and which actions the Role allows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 `kubectl get role` 命令显示了该角色适用于哪些资源以及该角色允许哪些操作。
- en: Instead of creating the Role right away, we could have done a “dry run” and
    saved the contents to a YAML file. This comes in handy if you like to take a more
    declarative approach and keep your YAML files in a version control system. Let’s
    run the same command to create a Role, but this time we’ll perform a dry run and
    save the output of the command to a file named `role.yaml`. Run the command `kubectl
    create role pod-reader` `-verb=get,list,watch -resource=pods -dry-run=client -o
    yaml > role.yaml`, and you’ll see that the file has been created, as in figure
    3.9.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必立即创建角色，我们可以先进行“dry run”（模拟运行），并将内容保存到 YAML 文件中。如果你喜欢采用更声明性的方法，并将 YAML 文件保存在版本控制系统中的话，这会很有用。让我们运行相同的命令来创建一个角色，但这次我们将执行模拟运行，并将命令的输出保存到名为
    `role.yaml` 的文件中。运行命令 `kubectl create role pod-reader` `-verb=get,list,watch -resource=pods
    -dry-run=client -o yaml > role.yaml`，你会看到文件已经创建，如图 3.9 所示。
- en: '![](../../OEBPS/Images/03-09.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-09.png)'
- en: Figure 3.9 Instead of creating a Role, we perform a dry run and then save the
    contents of the YAML to a file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 我们不是创建角色，而是执行模拟运行，然后将 YAML 内容保存到文件中。
- en: In the first chapter, we looked at all the different Kubernetes API resources.
    Each resource had a path and at the end of that path led you to the object. In
    the case of Pods, the path is `/api/v1/pods`, so the API group is within `/api/v1/`.
    Deployments are in the API group `/apis/apps/v1`, which are listed separately
    in this Role definition, depicted in figure 3.10.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们探讨了所有的不同 Kubernetes API 资源。每个资源都有一个路径，路径的尽头指向对象。对于 Pod 来说，路径是 `/api/v1/pods`，因此
    API 组位于 `/api/v1/` 内。Deployment 位于 API 组 `/apis/apps/v1`，在本角色的定义中单独列出，如图 3.10
    所示。
- en: '![](../../OEBPS/Images/03-10.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-10.png)'
- en: Figure 3.10 The API group is used for specifying the resource in Roles and cluster
    Roles.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 API 组用于在角色和集群角色中指定资源。
- en: Notice that this Role doesn’t indicate permissions for a user at all. That’s
    where Role bindings come in. Role bindings will attach (or bind) a Role to a user,
    group, or Service Account and will provide that user, group, or Service Account
    with a Role. Let’s create a Role binding now with the command `kubectl create
    rolebinding` `pod-reader-binding --role=pod-reader --user=carol.`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个角色根本不表示任何用户权限。这就是角色绑定发挥作用的地方。角色绑定会将一个角色绑定到用户、组或服务账户上，并为该用户、组或服务账户提供角色。现在让我们使用命令
    `kubectl create rolebinding` `pod-reader-binding --role=pod-reader --user=carol.`
    创建一个角色绑定。
- en: The YAML output of our `pod-reader-binding` shows the Role reference (`roleRef`)
    and the user (`subjects`). This Role binding is how the user `carol` will be authorized
    to access Pods in our Kubernetes cluster.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `pod-reader-binding` 的 YAML 输出显示了角色引用（`roleRef`）和用户（`subjects`）。这个角色绑定就是用户
    `carol` 将如何被授权访问我们的 Kubernetes 集群中的 Pod。
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There’s a really useful tool built into `kubectl` to verify if users can perform
    certain actions in the Kubernetes cluster without explicitly assuming that user’s
    identity. This command is `kubectl auth can-i`. If you get the help pages for
    this command, you’ll see a plethora of examples you can use to test authorization
    as a user, group, or Service Account:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 中内置了一个非常有用的工具，用于验证用户是否可以在不明确假定该用户身份的情况下在 Kubernetes 集群中执行某些操作。此命令是
    `kubectl auth can-i`。如果您查看此命令的帮助页面，您将看到大量示例，您可以使用这些示例来测试作为用户、组或服务账户的授权：'
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s check if the user `carol` can list or delete Pods in the default namespace
    in our Kubernetes cluster using the command `kubectl auth can-i`. Notice the output
    just says `yes` or `no`. What an easy way to verify authorization in Kubernetes!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用命令 `kubectl auth can-i` 检查用户 `carol` 是否可以在我们的 Kubernetes 集群的默认命名空间中列出或删除
    Pod。注意输出只说“是”或“否”。这是在 Kubernetes 中验证授权多么简单的方法！
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: EXAM TIP I encourage you to use `kubectl auth can-i` on the exam, as it will
    allow you to verify that you’ve completed the task successfully and save precious
    time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：我鼓励您在考试中使用 `kubectl auth can-i`，因为它将允许您验证您是否已成功完成任务，并节省宝贵的时间。
- en: How you create a cluster Role and cluster Role binding are the same, so we won’t
    go over this in detail. The `kubectl` commands for creating cluster Roles and
    cluster Role bindings are `kubectl create clusterrole` and `kubectl create clusterrolebinding`,
    respectively.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集群角色和集群角色绑定的方式相同，所以我们不会详细说明这一点。创建集群角色的 `kubectl` 命令是 `kubectl create clusterrole`，创建集群角色绑定的命令是
    `kubectl create clusterrolebinding`。
- en: EXAM TIP Use the `-h` flag to get a list of examples for running your command
    (e.g., `kubectl create clusterrole -h`). This will save you time on the exam,
    as you can copy the examples without having to type out or remember the entire
    command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：使用 `-h` 标志获取运行您的命令的示例列表（例如，`kubectl create clusterrole -h`）。这将在考试中节省您的时间，因为您可以在不输入或记住整个命令的情况下复制示例。
- en: You can also use cluster Roles with Role bindings when you require a resource
    that is not scoped to a namespace (e.g., nodes) to be accessible from a user,
    group, or Service Account that is applied from within a namespace. You *cannot*
    attach a cluster Role binding to a Role because permissions from within a namespace
    (Role permissions) can’t be applied to a subject that is not namespace-scoped,
    as we see depicted in figure 3.11\. One thing you have to keep in mind is that
    permissions via cluster Roles will affect all namespaces, current and future.
    You must keep in mind the principle of least privilege to be cautious not to assign
    a Role or cluster Role that gives unfettered access to your Kubernetes cluster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要访问不在命名空间范围内（例如，节点）的资源时，您也可以使用集群角色与角色绑定。您**不能**将集群角色绑定附加到角色上，因为命名空间内的权限（角色权限）不能应用于非命名空间范围的主体，正如我们在图3.11中看到的那样。您必须记住的一点是，通过集群角色授予的权限将影响所有命名空间，包括当前和未来的。您必须牢记最小权限原则，谨慎地不要分配一个或集群角色，这会给您的
    Kubernetes 集群带来无限制的访问权限。
- en: '![](../../OEBPS/Images/03-11.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11](../../OEBPS/Images/03-11.png)'
- en: Figure 3.11 With the exception of cluster Role bindings to Roles, all other
    combinations are supported.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 除了将集群角色绑定到角色之外，所有其他组合都受到支持。
- en: 3.1.2 System Roles and groups
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 系统角色和组
- en: 'Now that we know what users, Service Accounts, Roles, and bindings are used
    for, let’s take a look at the built-in Roles and groups and what user and group
    we’ve been using for our own cluster thus far. The API server creates a set of
    default cluster Roles and cluster Role bindings. They are directly managed by
    the control plane. You will see they are `cluster-admin`, `admin`, `edit`, and
    `view` when you run the command `kubectl get clusterrole | grep -v system`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了用户、服务账户、角色和绑定用于什么，让我们看看内置的角色和组，以及到目前为止我们为我们的集群使用了哪些用户和组。API 服务器创建了一组默认的集群角色和集群角色绑定。它们由控制平面直接管理。当您运行命令
    `kubectl get clusterrole | grep -v system` 时，您将看到它们是 `cluster-admin`、`admin`、`edit`
    和 `view`：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `cluster-admin` cluster Role is intended to be used cluster-wide and allows
    read and write access for most objects, including Roles and Role bindings, with
    the exception of resource quotas, Endpoints, or the namespace itself. The edit
    cluster Role will not allow you to modify Roles or Role bindings; however, it
    will allow you to access Secrets and run Pods with any Service Accounts inside
    the namespace. The view cluster Role is just like it sounds, allowing you to view
    most namespaced objects except for Secrets because the contents of a Secret contain
    the credentials for API access.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster-admin` 集群角色旨在集群范围内使用，并允许对大多数对象进行读写访问，包括 Roles 和 Role bindings，但资源配额、Endpoints
    或命名空间本身除外。编辑集群角色将不允许你修改 Roles 或 Role bindings；然而，它将允许你访问 Secrets 并在命名空间内使用任何 Service
    Accounts 运行 Pods。视图集群角色正如其名，允许你查看大多数命名空间对象，但 Secrets 除外，因为 Secrets 的内容包含 API 访问的凭证。'
- en: EXAM TIP Kubernetes allows assigning (binding) a cluster Role to multiple users/groups/Service
    Accounts via Role or cluster Role binding, so, on the exam, it may save you time
    to create a Role binding and assign it to an existing Role (i.e., `view`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧 Kubernetes 允许通过 Role 或集群 Role 绑定将集群角色分配给多个用户/组/Service Accounts，因此，在考试中，创建一个
    Role 绑定并将其分配给现有的 Role（即 `view`）可能会节省你的时间。
- en: 'Now that we know all the Roles that are created by default, which one do we
    assume is the user of `kubectl`? For that, we’ll have to talk about groups in
    more detail—more specifically, the built-in groups that are managed by the Kubernetes
    API server. Like users, groups are not a managed resource in Kubernetes, so the
    group name is just an arbitrary name. However, these built-in groups are different.
    They are managed by the API server and cannot be modified. When the API server
    starts up, it reconciles with any missing permissions and updates the default
    cluster Role bindings with any missing subjects (i.e., groups). This allows the
    cluster to automatically repair any misconfigurations and keep the Roles and bindings
    up to date with new releases of Kubernetes. These built-in default cluster Role
    bindings are `system:authenticated`, `system:unauthenticated`, and `system:masters`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了所有默认创建的 Roles，那么我们假设哪个是 `kubectl` 的用户？为此，我们得更详细地谈谈组——更具体地说，是由 Kubernetes
    API 服务器管理的内置组。像用户一样，组在 Kubernetes 中不是一个受管理的资源，因此组名只是一个任意名称。然而，这些内置组是不同的。它们由 API
    服务器管理，不能被修改。当 API 服务器启动时，它会与任何缺失的权限进行协调，并使用任何缺失的主题（即组）更新默认的集群 Role 绑定。这允许集群自动修复任何配置错误，并确保
    Roles 和绑定与 Kubernetes 的新版本保持最新。这些内置的默认集群 Role 绑定是 `system:authenticated`、`system:unauthenticated`
    和 `system:masters`：
- en: The `system:authenticated` group assigns privileges to users who are successfully
    authenticated.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system:authenticated` 组将权限分配给成功认证的用户。'
- en: The `system:unauthenticated` group is used when none of the authentication plugins
    can validate the request.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有任何认证插件可以验证请求时，使用 `system:unauthenticated` 组。
- en: The `system:masters` group is used for super users and provides unfettered access
    to everything in Kubernetes.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system:masters` 组用于超级用户，并提供对 Kubernetes 中所有内容的无限制访问。'
- en: 'The `system:masters` group is the group we have been assuming this entire time.
    Yikes! We better tread carefully, so as to not misconfigure anything and deem
    our cluster incapable of running. All joking aside, you should never use this
    group for normal users, because if it were to fall into the wrong hands, it could
    be dangerous. To prove that we have unrestricted access to our cluster, we can
    use the command `kubectl auth can-i --list` to list the actions we can take on
    each and every object in the cluster:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`system:masters` 组是我们一直假设的组。哎呀！我们最好小心行事，以免配置错误，并认为我们的集群无法运行。开个玩笑，你永远不应该为普通用户使用这个组，因为如果它落入错误的手中，可能会很危险。为了证明我们对集群有不受限制的访问权限，我们可以使用命令
    `kubectl auth can-i --list` 来列出我们可以在集群中的每个对象上执行的操作：'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Furthermore, we can run the command `kubectl get clusterrolebinding cluster-admin
    -o yaml` to see the `clusterrolebinding` that binds the Role `cluster-admin` to
    our user, who is a part of the `system:masters` group:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以运行命令 `kubectl get clusterrolebinding cluster-admin -o yaml` 来查看将 Role
    `cluster-admin` 绑定到我们用户的 `clusterrolebinding`，该用户是 `system:masters` 组的成员：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we can see the Role, which also shows the actions we can take on cluster
    resources. You’ll notice that the asterisk (*) is a wildcard for everything. So,
    we have access to all resources in all API groups and are allowed to take any
    action (get, list, create, delete, update, patch, watch).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到角色，它还显示了我们可以对集群资源执行的操作。你会注意到星号 (*) 是代表所有内容的通配符。因此，我们有权访问所有 API 组中的所有资源，并且允许执行任何操作（获取、列出、创建、删除、更新、修补、监视）。
- en: EXAM TIP If you are ever stuck on how a cluster Role is formatted, you can send
    the output of `kubectl` to a file and edit it inline. To do this, use the command
    `kubectl create clusterrole pod-reader --verb get,list,watch --resource pods --dry-run=client
    -o yaml > pod-reader.yaml`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：如果你在如何格式化集群角色上遇到困难，可以将 `kubectl` 的输出发送到文件并直接编辑它。为此，使用命令 `kubectl create
    clusterrole pod-reader --verb get,list,watch --resource pods --dry-run=client
    -o yaml > pod-reader.yaml`。
- en: Exam exercises
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考试练习
- en: Create a new Role named `sa-creator` that will allow for creating Service Accounts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `sa-creator` 的新角色，允许创建服务账户。
- en: Create a Role binding that is associated with the previous `sa-creator` Role,
    named `sa-creator-binding`, that will bind to the user Sandra.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个与之前 `sa-creator` 角色关联的角色绑定，命名为 `sa-creator-binding`，它将绑定到用户 Sandra。
- en: 3.2 Users and groups
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 用户和组
- en: 'We’ve uncovered the greatest fear of every security engineer in the world:
    a back door to our Kubernetes cluster that allows full, unrestricted access to
    do anything! We can even expose our cluster publicly to anonymous users, inviting
    anyone and everyone to get into our cluster and do as they please. No, don’t do
    that. Let’s allow those security folks to rest easy at night and create a new
    user that follows the principle of least privilege. Remember carol? We created
    a Role binding that associates the `pod-reader` Role with the carol user. Let’s
    create the kubeconfig that carol can use to access the cluster, as depicted in
    figure 3.12.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们揭露了全世界每个安全工程师的最大恐惧：一个通向我们的 Kubernetes 集群的后门，允许完全无限制地访问做任何事情！我们甚至可以将我们的集群公开给匿名用户，邀请任何人和每个人进入我们的集群并随心所欲。不，不要这么做。让我们让那些安全人员晚上能安心休息，并创建一个新的用户，遵循最小权限原则。还记得卡罗尔吗？我们创建了一个将
    `pod-reader` 角色与 carol 用户关联的 Role binding。让我们创建 carol 可以用来访问集群的 kubeconfig，如图
    3.12 所示。
- en: '![](../../OEBPS/Images/03-12.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-12.png)'
- en: Figure 3.12 Creating a kubeconfig for a new user and generating a certificate
    using the certificate-signing request
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 为新用户创建 kubeconfig 并使用证书签名请求生成证书
- en: Because users and groups are arbitrary notations on a certificate and not managed
    by Kubernetes, let’s start by creating a new certificate-signing request. Remember
    we learned that the Kubernetes API is its own certificate authority? This means
    that it can sign certificates for us, rendering them valid authentication mechanisms
    for the Kubernetes API. How convenient!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为用户和组是在证书上的任意标记，并且不由 Kubernetes 管理，所以让我们先创建一个新的证书签名请求。还记得我们学到 Kubernetes API
    是它自己的证书颁发机构吗？这意味着它可以为我们签名证书，使它们成为 Kubernetes API 的有效认证机制。多么方便啊！
- en: 'First, let’s generate a private key using 2048-bit encryption with the command
    `openssl genrsa -out carol.key 2048`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用命令 `openssl genrsa -out carol.key 2048` 生成一个使用 2048 位加密的私钥：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s create a certificate-signing request file, using the private key
    we just created, that we’ll eventually give to the Kubernetes API. It’s important
    here that we specify our user and group in the common name of the certificate-signing
    request with the command `openssl req -new -key carol.key -subj "/CN=carol/O=developers"
    -out carol.csr`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个证书签名请求文件，使用我们刚刚创建的私钥，我们最终将把它交给 Kubernetes API。在这里，我们指定用户和组在证书签名请求的通用名称中非常重要，使用命令
    `openssl req -new -key carol.key -subj "/CN=carol/O=developers" -out carol.csr`：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s store the CSR file in an environment variable, as we’ll need it later.
    To do this, use the command `export REQUEST=$(cat carol.csr | base64 -w 0)` to
    store the Base64 encoded version of the CSR file in an environment variable named
    `REQUEST`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 CSR 文件存储在一个环境变量中，因为我们稍后会需要它。为此，使用命令 `export REQUEST=$(cat carol.csr | base64
    -w 0)` 将 CSR 文件的 Base64 编码版本存储在名为 `REQUEST` 的环境变量中。
- en: Now we have exactly what we need to create our certificate-signing request resource
    in Kubernetes. We go about creating this resource just like we would with so many
    other Kubernetes resources and objects (e.g., Deployments, Pods, Service Accounts,
    etc.), via a YAML file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了创建 Kubernetes 中证书签名请求资源所需的一切。我们创建这个资源的方式就像我们创建许多其他 Kubernetes 资源和对象（例如，部署、Pod、服务账户等）一样，通过一个
    YAML 文件。
- en: EXAM TIP Because you can have an additional tab open during the exam, utilize
    the search function in Kubernetes docs ([https://kubernetes.io/docs](https://kubernetes.io/docs)).
    This is allowed and encouraged. Before you click on the search result, hover over
    the link and ensure it’s staying within the `kubernetes.io/docs` subdomain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考试技巧：因为您可以在考试期间打开额外的标签页，请利用Kubernetes文档中的搜索功能([https://kubernetes.io/docs](https://kubernetes.io/docs))。这是允许的，也是鼓励的。在您点击搜索结果之前，将鼠标悬停在链接上，确保它保持在`kubernetes.io/docs`子域内。
- en: 'We can use the Kubernetes documentation to find a copy of the correct YAML
    structure for a certificate-signing request resource. You’ll need to become familiar
    with the Kubernetes documentation for the exam, as it is your lifeline and a great
    time saver for copying examples (i.e., YAML) and pasting them into your terminal.
    Let’s go to [http://mng.bz/vnaa](http://mng.bz/vnaa) and practice. Copy the YAML
    for the certificate-signing request—the big long string to the right of the word
    `request`—and paste it into your terminal, changing three elements: replace it
    with our `REQUEST` environment variable and change the name and the groups to
    match the common name in the CSR file. It’ll look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Kubernetes文档来找到证书签名请求资源的正确YAML结构的副本。您需要熟悉Kubernetes文档以备考试，因为它是您的生命线，也是复制示例（即YAML）并将其粘贴到终端的巨大节省时间。让我们去[http://mng.bz/vnaa](http://mng.bz/vnaa)并练习。复制证书签名请求的YAML——位于`request`一词右侧的长字符串——并将其粘贴到您的终端中，更改三个元素：将其替换为我们的`REQUEST`环境变量，并将名称和组更改为与CSR文件中的通用名称匹配。它看起来像这样：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you don’t want to bother with copying and pasting, or maybe you don’t have
    access to a browser right now, that’s fine. You can run the following command,
    and it will achieve the same result: `kubectl apply -f https://raw.githubusercontent.com/
    chadmcrowell/k8s/main/manifests/csr-carol.yaml.`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想麻烦复制粘贴，或者您现在可能无法访问浏览器，那也行。您可以运行以下命令，它将实现相同的结果：`kubectl apply -f https://raw.githubusercontent.com/chadmcrowell/k8s/main/manifests/csr-carol.yaml.`。
- en: 'Congratulations, you’ve successfully submitted a signing request to the Kubernetes
    API! Because this is an object that Kubernetes manages, we can run the command
    `kubectl get csr` to see a list of requests. You’ll notice that the one we just
    submitted is named `carol` and its condition is `Pending`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已成功向Kubernetes API提交了签名请求！因为这个对象是由Kubernetes管理的，我们可以运行命令`kubectl get csr`来查看请求列表。您会注意到我们刚刚提交的请求名为`carol`，其状态为`Pending`：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can simply approve the request with the command `kubectl certificate approve
    carol`, and we’ll see the condition change from `pending` to `Approved,Issued`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令`kubectl certificate approve carol`简单地批准请求，并且我们会看到状态从`pending`变为`Approved,Issued`：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that it’s been approved, we can extract the contents of the signed certificate—namely,
    the client certificate—Base64, decode it, and store it in a file named `carol.crt`
    using the command `kubectl get csr carol -o jsonpath=''{.status.certificate}''
    | base64 -d > carol.crt`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它已经被批准，我们可以提取已签名证书的内容——即客户端证书——Base64解码，并将其存储在名为`carol.crt`的文件中，使用命令`kubectl
    get csr carol -o jsonpath='{.status.certificate}' | base64 -d > carol.crt`：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have the key (`carol.key`) and client certificate (`carol.crt`) and can add
    these credentials to our kubeconfig. We can simultaneously embed the certificate
    and key values into the file (similar to our current kubeconfig) with the command
    `kubectl config set-credentials carol --client-key=carol.key --client-certificate=
    carol.crt --embed-certs.`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有密钥（`carol.key`）和客户端证书（`carol.crt`），可以将这些凭证添加到我们的kubeconfig中。我们可以使用命令`kubectl
    config set-credentials carol --client-key=carol.key --client-certificate=carol.crt
    --embed-certs`同时将证书和密钥值嵌入到文件中（类似于我们当前的kubeconfig）。
- en: NOTE If you don’t want to embed the certificate and key, you can leave off the
    `--embed-certs` option. This would list the path to the two files instead of the
    raw certificate values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您不想嵌入证书和密钥，可以省略`--embed-certs`选项。这将列出两个文件的路径而不是原始证书值。
- en: 'You will now see the credentials for `carol` in the kubeconfig by using the
    command `kubectl config view`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过使用命令`kubectl config view`在kubeconfig中看到`carol`的凭证：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To add the user carol to our context, we’ll run the command `kubectl config
    set-context carol --user=carol --cluster=kind`. Once you run this command, you’ll
    notice that the context has been added by running the command `kubectl config
    get-contexts`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要将用户carol添加到我们的上下文，我们将运行命令`kubectl config set-context carol --user=carol --cluster=kind`。一旦运行此命令，您会注意到通过运行命令`kubectl
    config get-contexts`已经添加了上下文：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The asterisk in the `current` column on the left indicates which context we
    are currently using. Before moving forward, let’s run the command `kubectl run
    nginx --image nginx` to create a Pod so we can properly test if the user carol
    has the appropriate permissions according to the Role `pod-reader`. Then, to switch
    contexts and use the `carol` context, run the command `kubectl config use-context
    carol`. You’ll notice the asterisk changed the current context to `carol`. Finally,
    just like with the `kubectl auth can-i` command, we can verify that carol can
    list Pods but cannot delete them:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧 `current` 列中的星号表示我们当前正在使用哪个上下文。在继续之前，让我们运行命令 `kubectl run nginx --image nginx`
    创建一个 Pod，这样我们就可以正确地测试用户 carol 是否根据 `pod-reader` 角色具有适当的权限。然后，要切换上下文并使用 `carol`
    上下文，请运行命令 `kubectl config use-context carol`。您会注意到星号已将当前上下文更改为 `carol`。最后，就像使用
    `kubectl auth can-i` 命令一样，我们可以验证 carol 可以列出 Pod 但不能删除它们：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s take it one step further and bind the Role (using a Role binding) to
    a group versus a user (which is what we have right now). To switch back to the
    admin user, type the command `kubectl config use-context kubernetes-admin@kind`.
    Then, delete the current Role binding with the command `kubectl delete rolebinding
    admin-binding`, and create a new Role binding with the command `kubectl create
    rolebinding pod-reader-bind --role=pod-reader --group=developers`. Let’s switch
    back to the user carol with the command `kubectl config use-context carol` and
    test our authorization (this time via groups) with the command `kubectl get po`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，将角色（使用角色绑定）绑定到一个组而不是用户（这是我们目前的情况）。要切换回管理员用户，请输入命令 `kubectl config use-context
    kubernetes-admin@kind`。然后，使用命令 `kubectl delete rolebinding admin-binding` 删除当前的角色绑定，并使用命令
    `kubectl create rolebinding pod-reader-bind --role=pod-reader --group=developers`
    创建一个新的角色绑定。让我们使用命令 `kubectl config use-context carol` 切换回用户 carol，并使用命令 `kubectl
    get po` 测试我们的授权（这次是通过组）：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are done testing with the user carol, so let’s switch back to the admin
    user again and continue on to the next topic in this chapter: Service Accounts.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用用户 carol 完成了测试，所以让我们再次切换回管理员用户，继续本章的下一个主题：服务账户。
- en: Exam exercises
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 练习考试
- en: Create a new user named Sandra by first creating the private key, then the certificate-signing
    request, and then using the CSR resource in Kubernetes to generate the client
    certificate. Add Sandra to your local kubeconfig using the `kubectl config` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先创建私钥，然后创建证书签名请求，最后使用 Kubernetes 中的 CSR 资源生成客户端证书，创建一个名为 Sandra 的新用户。使用 `kubectl
    config` 命令将 Sandra 添加到您的本地 kubeconfig 中。
- en: 3.3 Service Accounts
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 服务账户
- en: Users and groups are great, but what about machines? They need to access the
    Kubernetes API too, and sometimes we utilize tools like Helm or Jenkins or a load
    balancer controller—running as Pods in our cluster—that need to communicate with
    the Kubernetes API to carry out actions (read, write, delete, etc.) as a part
    of their primary function. We provide them with a similar authentication mechanism—namely,
    a token—to carry out these actions, as depicted in figure 3.13\. Then we can limit
    their privileges using Roles and Role bindings, again making sure that we are
    following the principle of least privilege. We don’t want a situation in which
    a Pod in our cluster has unrestricted access like our `system:masters` group had.
    The good news is that this default group is not applied to Service Accounts in
    the same way it was to our admin user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和组很棒，但机器怎么办？它们也需要访问 Kubernetes API，有时我们会使用像 Helm 或 Jenkins 或负载均衡器控制器这样的工具——作为我们集群中的
    Pod 运行，这些工具需要与 Kubernetes API 通信以执行其主要功能的一部分（读取、写入、删除等）。我们为它们提供类似的身份验证机制——即令牌——以执行这些操作，如图
    3.13 所示。然后我们可以使用角色和角色绑定来限制它们的权限，再次确保我们遵循最小权限原则。我们不希望我们的集群中的 Pod 有像我们的 `system:masters`
    组那样的无限制访问。好消息是，这个默认组不会像对我们的管理员用户那样应用到服务账户上。
- en: '![](../../OEBPS/Images/03-13.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13](../../OEBPS/Images/03-13.png)'
- en: Figure 3.13 Service Accounts mounted to Pods can access the API in the same
    way users can.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 服务账户挂载到 Pod 可以像用户一样访问 API。
- en: Service Accounts are namespace-scoped resources. You’ll find at least one in
    each namespace, and that one, called the default Service Account, is created automatically
    each time you generate a new namespace. Let’s try it!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户是命名空间范围内的资源。您在每个命名空间中至少会找到一个，那个被称为默认服务账户的，每次您生成一个新的命名空间时都会自动创建。让我们试试！
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This default Service Account is created automatically; you don’t have to do
    anything special to make this default behavior happen. If we run the command `kubectl
    describe secret -n web`, we can see the token that is also automatically generated
    with the Service Account as well:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个默认服务账户是自动创建的；我们不需要做任何特殊的事情来使这种默认行为发生。如果我们运行命令 `kubectl describe secret -n
    web`，我们可以看到与服务账户一起自动生成的令牌：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Furthermore, you can `cat` out the token and reveal its value with the command
    `kubectl describe secret default-token-mv8xd -n web`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用命令 `kubectl describe secret default-token-mv8xd -n web` 来 `cat` 出令牌并揭示其值：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Technically, we can use this token (as a user) to authenticate with the Kubernetes
    API. This is why the default `view` Role doesn’t allow viewing the Service Accounts
    and why we are hesitant to give read access of our Secrets to any user. These
    tokens can be used outside of the cluster as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们可以使用这个令牌（作为用户）来通过 Kubernetes API 进行身份验证。这就是为什么默认的 `view` 角色不允许查看服务账户，以及为什么我们犹豫是否给任何用户读取我们的机密数据的权限。这些令牌也可以在集群外部使用。
- en: 'When we create a Pod, this default Service Account is automatically mounted
    to the Pod, so the Pod can authenticate to the Kubernetes API. Let’s run the command
    `kubectl get po nginx -o yaml | grep volumeMounts -A14` to list the Service Account
    within the Pod YAML. You’ll see that the default Service Account is, in fact,
    mounted to the Pod at the path `/var/run/secrets/kubernetes.io/serviceaccount`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个 Pod 时，这个默认服务账户会自动挂载到 Pod 上，这样 Pod 就可以认证到 Kubernetes API。让我们运行命令 `kubectl
    get po nginx -o yaml | grep volumeMounts -A14` 来列出 Pod YAML 中的服务账户。你会看到默认服务账户实际上是在路径
    `/var/run/secrets/kubernetes.io/serviceaccount` 上挂载到 Pod 上的：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we `exec` into the Pod, we can view the token in the same manner as we did
    before by describing the Secret. To get a shell into the Pod’s container and `cat`
    out the token, we can run the command `kubectl exec -it nginx --sh`, followed
    by `cat /var/run/ secrets/kubernetes.io/serviceaccount/token` (# indicates that
    you have successfully entered a shell inside the container):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们 `exec` 进入 Pod，我们可以像之前描述 Secret 那样查看令牌。要进入 Pod 的容器并 `cat` 出令牌，我们可以运行命令 `kubectl
    exec -it nginx --sh`，然后 `cat /var/run/secrets/kubernetes.io/serviceaccount/token`（#
    表示你已经成功进入容器内部的 shell）：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we don’t want to automatically mount the token to every Pod that we create,
    then we can turn this feature off from the `serviceAccount` itself, or we can
    dismount the token for certain Pods in the Pod YAML specification, as depicted
    in figure 3.14\. We can even do both in case our team members accidentally forget
    to address this for the Pods they create.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望自动将令牌挂载到我们创建的每个 Pod 上，那么我们可以从 `serviceAccount` 本身关闭此功能，或者我们可以在 Pod YAML
    规范中卸载某些 Pod 的令牌，如图 3.14 所示。即使我们的团队成员不小心忘记为创建的 Pod 处理这个问题，我们也可以同时做这两件事。
- en: '![](../../OEBPS/Images/03-14.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-14.png)'
- en: Figure 3.14 You can choose to disable mounting Secrets from the Service Account
    or the Pod or both.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 您可以选择禁用从服务账户或 Pod 或两者挂载机密。
- en: 'Let’s create a new Service Account and tell the Service Account not to mount
    the token to the Pod automatically. The quickest way to do this is to create the
    framework for the Service Account YAML and then modify it in place with the command
    `kubectl create sa nomount-sa --dry-run=client -o yaml > nomount-sa.yaml`. Add
    the `automountServiceAccountToken: false` to the end of the file `nomount-sa.yaml`
    with the command `echo "automountServiceAccountToken: false" >> nomount-sa.yaml`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们创建一个新的服务账户，并告诉服务账户不要自动将令牌挂载到 Pod 上。最快的方法是创建服务账户 YAML 的框架，然后使用命令 `kubectl
    create sa nomount-sa --dry-run=client -o yaml > nomount-sa.yaml` 在原地修改它。使用命令 `echo
    "automountServiceAccountToken: false" >> nomount-sa.yaml` 将 `automountServiceAccountToken:
    false` 添加到文件 `nomount-sa.yaml` 的末尾：'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we have the YAML all set, we can create the Service Account object
    with the command `kubectl create -f nomount-sa.yaml`. If we create a new Pod and
    use this Service Account, we won’t see it mounted at all. Let’s create a new Pod
    named `no-mount` and specify within the YAML to use this new Service Account,
    much like figure 3.15.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 YAML，我们可以使用命令 `kubectl create -f nomount-sa.yaml` 创建服务账户对象。如果我们创建一个新的
    Pod 并使用这个服务账户，我们根本看不到它被挂载。让我们创建一个名为 `no-mount` 的新 Pod，并在 YAML 中指定使用这个新的服务账户，就像图
    3.15 所示。
- en: '![](../../OEBPS/Images/03-15.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/03-15.png)'
- en: Figure 3.15 A Role subject can be a user, group, or Service Account in authorizing
    against Kubernetes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 角色主体可以是用户、组或服务账户，用于对 Kubernetes 进行授权。
- en: We’ll use the same shortcut method of outputting a skeleton of the YAML manifest
    and modifying it afterward with the command `kubectl run no-mount --image nginx
    --dry-run=client -o yaml > no-mount-pod.yaml.`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的快捷方法输出YAML清单的骨架，并在之后使用命令`kubectl run no-mount --image nginx --dry-run=client
    -o yaml > no-mount-pod.yaml`对其进行修改。
- en: NOTE If you’ve created a new kind cluster since the last chapter, you’ll need
    to install Vim so you can edit the file. Use the command `apt update && apt install
    -y vim`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你从上一章开始创建了一个新的类型集群，你需要安装Vim以便可以编辑文件。使用命令`apt update && apt install -y vim`。
- en: 'Now that we have that file locally, we can edit it using our Vim text editor,
    so type the command `vim no-mount-pod.yaml` to open it. Just under the spec, indented
    two spaces, you should add `serviceAccountName: nomount-sa`. It will look like
    this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经将文件本地化了，我们可以使用我们的Vim文本编辑器来编辑它，所以输入命令`vim no-mount-pod.yaml`来打开它。在`spec`下面，缩进两个空格，你应该添加`serviceAccountName:
    nomount-sa`。它看起来像这样：'
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have explicitly told the Pod to use this Service Account, so let’s create
    the Pod and inspect it with the commands `kubectl create -f no-mount-pod.yaml`
    and `kubectl get po no-mount -o yaml | grep volumeMounts -A14`. You will notice
    that the correct Service Account is used, and you don’t see any volume mounts.
    This is a good thing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经明确告诉Pod使用这个服务账户，所以让我们使用命令`kubectl create -f no-mount-pod.yaml`创建Pod，并使用命令`kubectl
    get po no-mount -o yaml | grep volumeMounts -A14`检查它。你会注意到使用了正确的服务账户，并且没有看到任何卷挂载。这是好事。
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When creating yet another Pod, we’ll use the default token, which is set to
    automatically mount tokens to Pods, but we’ll explicitly tell it not to during
    the creation of our Pod. Create a new Pod YAML file with the command `kubectl
    run default-no-mount --image nginx --dry-run=client -o yaml > default-no-mount-pod.yaml`.
    Again, let’s open the file with Vim; just below the spec, indented two spaces,
    insert `automountServiceAccountToken: false`. We don’t have to tell the Pod to
    use the default token, because, if not specified, it will use the default Service
    Account automatically. This is the case for all Pods by default. The Pod YAML
    will look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '当创建另一个Pod时，我们将使用默认令牌，该令牌设置为自动将令牌挂载到Pod，但我们在创建我们的Pod时将明确告诉它不要这样做。使用命令`kubectl
    run default-no-mount --image nginx --dry-run=client -o yaml > default-no-mount-pod.yaml`创建一个新的Pod
    YAML文件。再次，让我们用Vim打开文件；在`spec`下面，缩进两个空格，插入`automountServiceAccountToken: false`。我们不需要告诉Pod使用默认令牌，因为如果没有指定，它将自动使用默认服务账户。默认情况下，所有Pod都是这种情况。Pod
    YAML将看起来像这样：'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s create the Pod with the command `kubectl create -f default-no-mount-pod.yaml`.
    We’ll see the default Service Account used with the Pod, but no volume mounts,
    which is what we want.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用命令`kubectl create -f default-no-mount-pod.yaml`创建Pod。我们将看到Pod使用了默认服务账户，但没有卷挂载，这正是我们想要的。
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we’ve learned about creating Service Accounts and mounting them to
    Pods (or explicitly not mounting them to Pods), let’s review assigning Roles and
    Role bindings to Service Accounts. This happens similarly to creating any other
    Role or Role binding, but the subject is a Service Account instead of a user or
    a group. Start by creating a Role that will only allow the action `list` for the
    resource `pods`. To do this, we can run the command `kubectl create role pod-list
    --verb=list --resource=pods`. We’ll create the Role binding named `pod-list-bind`
    to bind the Service Account to the Role `pod-list` for the Service Account `nomount-sa`
    by running `kubectl create rolebinding pod-list-bind --role=pod-list --serviceaccount=default:nomount-sa`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建服务账户并将它们挂载到Pod（或显式地不将它们挂载到Pod），让我们回顾一下将角色和角色绑定分配给服务账户的过程。这与其他任何角色的创建或角色绑定创建类似，但主题是服务账户而不是用户或组。首先创建一个只允许对资源`pods`执行`list`操作的`Role`。为此，我们可以运行命令`kubectl
    create role pod-list --verb=list --resource=pods`。我们将创建名为`pod-list-bind`的`Role
    binding`，通过运行`kubectl create rolebinding pod-list-bind --role=pod-list --serviceaccount=default:nomount-sa`将服务账户`nomount-sa`绑定到`pod-list`角色：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To test that our Role and Role binding worked, we can use the `kubectl auth
    can-i` command and determine if we can list Pods in this Service Account. To do
    this, we’ll run the command `kubectl auth can-i list pods --as system:serviceaccount
    :default:nomount-sa`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的角色和角色绑定是否工作正常，我们可以使用`kubectl auth can-i`命令，并确定我们是否可以列出此服务账户中的Pod。为此，我们将运行命令`kubectl
    auth can-i list pods --as system:serviceaccount :default:nomount-sa`：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Service Account is addressed as `system:serviceaccount:default:nomount-sa`
    because this is the username of the Service Account according to the RBAC plugin.
    This is the perspective from which we are looking at the Service Account, so we
    need to address it with the `system:serviceaccount` prefix, followed by the namespace
    (in our case, it was `default`), and then the Service Account API resource name.
    Congratulations! You have created a Service Account and assigned it to a Role
    via a Role binding in Kubernetes!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户被表示为 `system:serviceaccount:default:nomount-sa`，因为这是根据RBAC插件的服务账户的用户名。这是我们观察服务账户的角度，因此我们需要使用
    `system:serviceaccount` 前缀来引用它，后面跟着命名空间（在我们的例子中是 `default`），然后是服务账户API资源名称。恭喜！您已经创建了一个服务账户，并通过Kubernetes中的Role
    binding将其分配给了角色！
- en: You can now use this Service Account for multiple Pods at the same time, as
    long as those Pods exist within the same namespace. You can never use a Service
    Account from a different namespace for a Pod. Also, to use the `nomount-sa` service
    account for new Pods, you’ll have to specify the Service Account to use in the
    Pod YAML for each Pod, as we did in the previous example. You might think about
    deleting the default Service Account, but this is not possible. The Service Account
    resource has its own controller that automatically creates it when we generate
    a new namespace.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以同时使用这个服务账户为多个Pod提供服务，只要这些Pod存在于同一个命名空间中。您永远不能为Pod使用来自不同命名空间的Service Account。此外，为了使用
    `nomount-sa` 服务账户为新Pod提供服务，您必须在每个Pod的YAML文件中指定要使用的服务账户，就像我们在前面的例子中所做的那样。您可能会考虑删除默认服务账户，但这是不可能的。服务账户资源有自己的控制器，当我们生成新的命名空间时，它会自动创建。
- en: Exam exercises
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考试练习
- en: Create a new Service Account named `secure-sa`, and create a Pod that uses this
    Service Account. Make sure the token is not exposed to the Pod.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `secure-sa` 的新服务账户，并创建一个使用此服务账户的Pod。确保令牌不会被暴露给Pod。
- en: Create a new cluster Role named `acme-corp-role` that will allow the `create`
    action on Deployments, replicates, and DaemonSets. Bind that cluster Role to the
    Service Account `secure-sa` and make sure the Service Account can only create
    the assigned resources within the default namespace and nowhere else. Use `auth
    can-i` to verify that the `secure-sa` Service Account cannot create Deployments
    in the `kube-system` namespace, and output the result of the command plus the
    command itself to a file and share that file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `acme-corp-role` 的新集群角色，该角色将允许对Deployments、replicates和DaemonSets执行 `create`
    操作。将该集群角色绑定到服务账户 `secure-sa`，并确保服务账户只能在默认命名空间内创建分配的资源，而不会在其他地方创建。使用 `auth can-i`
    验证 `secure-sa` 服务账户不能在 `kube-system` 命名空间中创建Deployments，并将命令的结果以及命令本身输出到文件中，然后共享该文件。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Anything that tries to access Kubernetes must be authenticated via a certificate
    carrying a token with which to authenticate.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何尝试访问Kubernetes的东西都必须通过携带用于认证的令牌的证书进行认证。
- en: The authentication plugin is used in Kubernetes to provide a mechanism to accept
    or deny user requests.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证插件用于Kubernetes，以提供一个接受或拒绝用户请求的机制。
- en: Kubernetes has its own certificate-signing request object, which can sign certificates
    to make them valid for a user or anything trying to access the Kubernetes API.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes有自己的证书签名请求对象，可以签名证书，使其对用户或尝试访问Kubernetes API的任何东西有效。
- en: A common plugin called role-based access control (RBAC) is used to give permissions
    to users in a Kubernetes cluster.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为基于角色的访问控制（RBAC）的通用插件用于在Kubernetes集群中授予用户权限。
- en: Users and groups are arbitrary meanings in Kubernetes, so there is no user database
    or directory structure. The certificate is the only thing that’s checked, so the
    user or group can be any name.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和组在Kubernetes中具有任意含义，因此没有用户数据库或目录结构。证书是唯一需要检查的东西，因此用户或组可以是任何名称。
- en: You can assign RBAC permissions via Roles, cluster Roles, Role bindings, and
    cluster Role bindings, each applied to different use cases.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过角色、集群角色、角色绑定和集群角色绑定来分配RBAC权限，每种都适用于不同的用例。
- en: 'All combinations of Roles, cluster Roles, Role bindings, and cluster Role bindings
    can be used for the exam except for one: cluster Role binding to Roles.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了一个之外，所有角色、集群角色、角色绑定和集群角色绑定的组合都可以用于考试：那就是集群角色绑定到角色。
- en: 'There are two main subjects in RBAC: the user and Service Accounts. Users are
    not a managed resource in the Kubernetes API, whereas Service Accounts are.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC中有两个主要主题：用户和服务账户。在Kubernetes API中，用户不是一个受管理的资源，而服务账户是。
- en: When creating a user, the common name inside the certificate-signing request
    is required. You can generate a client certificate from the Kubernetes API, which
    is its own certificate authority.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建用户时，证书签名请求中的通用名称是必需的。你可以从 Kubernetes API 生成客户端证书，它是一个自己的证书颁发机构。
- en: When creating a Role for the exam, you can use the dry run option and save yourself
    some time typing the YAML for a Role where values need to be added.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建考试角色时，你可以使用预演选项，从而节省一些时间来手动输入需要添加值的角色的 YAML。
- en: Built-in groups are different than regular groups in Kubernetes. Built-in groups
    are managed by the API server and cannot be modified.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置组与 Kubernetes 中的常规组不同。内置组由 API 服务器管理，不能被修改。
- en: Service Accounts are automatically created when new namespaces are created.
    The token inside of a Service Account is mounted to a Pod unless otherwise specified
    in the YAML manifest.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建新的命名空间时，会自动创建 Service Accounts。除非在 YAML 清单中另有指定，否则 Service Account 中的令牌会挂载到
    Pod。
- en: To prevent the token from automatically mounting to a Pod, you can both add
    an instruction to your Pod YAML and disable mounting from the Service Account
    by adding an instruction to your Service Account YAML. You can also disable the
    mounting of a token when you first create a Service Account.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止令牌自动挂载到 Pod，你可以在 Pod YAML 中添加指令，并通过在 Service Account YAML 中添加指令来禁用从 Service
    Account 的挂载。你还可以在首次创建 Service Account 时禁用令牌的挂载。
- en: A useful tool during the exam is called `kubectl auth can-I`, and it can test
    permissions for users and Service Accounts.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考试期间的一个有用工具叫做 `kubectl auth can-I`，它可以测试用户和 Service Accounts 的权限。
