- en: appendix C. Graphs for processing patterns and workflows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. 用于处理模式和流程的图
- en: 'In many machine learning projects, including many of those described in this
    book, the graphs produced are large. The scale of these graphs makes processing
    them efficiently difficult. To deal with these challenges, a variety of distributed
    graph processing systems has emerged. In this appendix, we will explore one of
    these systems: Pregel, the first computational model (and still one of the most
    commonly used) for processing large-scale graphs.[¹](#pgfId-1000394) This topic
    suits the purpose of the appendix for two main reasons:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多机器学习项目中，包括本书中描述的许多项目，生成的图都是大的。这些图的规模使得高效处理它们变得困难。为了应对这些挑战，已经出现了各种分布式图处理系统。在本附录中，我们将探讨这些系统之一：Pregel，这是第一个用于处理大规模图的计算模型（并且仍然是使用最广泛的模型之一）。[¹](#pgfId-1000394)
    这个主题适合附录的目的主要有两个原因：
- en: It defines a processing model that’s useful for providing an alternative implementation
    of some of the algorithms discussed in this book (both graph-based and non-graph-based).
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个处理模型，这对于提供本书中讨论的一些算法的替代实现（基于图和非基于图）非常有用。
- en: It shows the expressive power of the graph and presents an alternative approach
    to the computation based on the graph representation of the information.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它展示了图的表达能力，并提出了基于信息图表示的计算的替代方法。
- en: C.1 Pregel
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 Pregel
- en: 'Suppose that you would like to execute the PageRank algorithm on a large graph,
    such as the whole internet. As stated in section 3.3.1, the PageRank algorithm
    was developed by the founders of Google for their search engine, so the algorithm’s
    primordial purpose was the same. We explored how the algorithm works in chapter
    3, so let’s focus now on how to solve a concrete problem: processing the PageRank
    values for such a large graph. This task will be complex to accomplish due to
    the high number of nodes (web pages) and edges (links between web pages), requiring
    a distributed approach.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在一个大图上执行PageRank算法，比如整个互联网。如第3.3.1节所述，PageRank算法是由Google的创始人为其搜索引擎开发的，因此算法的原始目的是相同的。我们在第3章中探讨了算法的工作原理，现在让我们专注于如何解决一个具体问题：处理如此大规模图的PageRank值。由于节点（网页）和边（网页之间的链接）数量众多，这项任务将非常复杂，需要分布式方法。
- en: The input to a Pregel computation is a directed graph in which each node has
    a unique identifier and is associated with a modifiable, user-defined value that
    is initialized in some way (also part of the input). Each directed edge is associated
    with
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Pregel计算输入是一个有向图，其中每个节点都有一个唯一的标识符，并关联一个可修改的、用户定义的值，该值以某种方式初始化（也是输入的一部分）。每条有向边都与
- en: A source node identifier
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个源节点标识符
- en: A target node identifier
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目标节点标识符
- en: A modifiable, user-defined value
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可修改的、用户定义的值
- en: 'In Pregel, the program is expressed as a sequence of iterations (called supersteps),
    separated by global synchronization points, that run until the algorithm terminates
    and produces its output. In each superstep S, a node can accomplish one or more
    of the following tasks, conceptually conducted in parallel [Malewicz et al., 2010]:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pregel中，程序被表示为一串迭代（称为超级步），由全局同步点分隔，直到算法终止并产生其输出。在每一个超级步S中，一个节点可以完成以下任务之一，概念上是在并行进行的
    [Malewicz et al., 2010]：
- en: Receive messages sent to it in the previous iteration, superstep S - 1
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收在上一迭代、超级步S - 1发送给它的消息
- en: Send messages to other nodes that will be read at superstep S + 1
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向其他节点发送将在超级步S + 1读取的消息
- en: Modify its own state and that of its outgoing edges, or mutate the graph topology
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改自己的状态和其出度边的状态，或突变图拓扑
- en: Messages are typically sent along outgoing edges (to the directly connected
    nodes), but a message can be sent to any node whose identifier is known. In superstep
    0, every node is active; all active nodes participate in the computation of any
    given superstep. At the end of each iteration, a node can decide to deactivate
    itself by voting to halt. At that point it becomes inactive and will not participate
    in subsequent supersteps unless it receives a message from another node, at which
    point it is reactivated. After being reactivated, a node that wants to halt must
    explicitly deactivate itself again. This simple state machine is illustrated in
    figure C.1\. The termination condition for the iterations is reached when all
    the nodes have voted to halt, so no further work is done in the next superstep.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通常沿着输出边（到直接连接的节点）发送，但可以向任何已知标识符的节点发送消息。在超级步 0 时，每个节点都是活跃的；所有活跃节点都参与任何给定超级步的计算。在每个迭代的末尾，一个节点可以通过投票停止来决定自己停止活动。此时它变为非活动状态，并且除非它从另一个节点收到消息，否则它将不会参与后续的超级步，此时它将被重新激活。在重新激活后，想要停止的节点必须再次显式地停止活动。这个简单的状态机在图
    C.1 中进行了说明。当所有节点都投票停止时，达到迭代的终止条件，因此在下一个超级步中不再进行任何工作。
- en: '![APPC_F01_Negro](../Images/APPC_F01_Negro.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F01_Negro](../Images/APPC_F01_Negro.png)'
- en: Figure C.1 Node statuses according to the Pregel computational model
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.1 根据Pregel计算模型显示的节点状态
- en: 'Before applying the Pregel framework to our PageRank use case, let’s consider
    a simpler example: given a strongly connected graph in which each node contains
    a value, find the highest value stored in the nodes. The Pregel implementation
    of this algorithm works this way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Pregel 框架应用于我们的 PageRank 用例之前，让我们考虑一个更简单的例子：给定一个强连通图，其中每个节点包含一个值，找到节点中存储的最高值。这个算法的
    Pregel 实现工作方式如下：
- en: The graph and the initial values of each node represent the input.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图和每个节点的初始值代表输入。
- en: At superstep 0, each node sends its initial value to all its neighbors.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在超级步 0 时，每个节点将其初始值发送给所有邻居。
- en: In each subsequent superstep S, if a node has learned a larger value from the
    messages it received in superstep S - 1, it sends that value to all its neighbors;
    otherwise, it deactivates itself and stops voting.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个后续的超级步 S 中，如果一个节点在超级步 S - 1 收到的消息中学习到一个更大的值，它将把这个值发送给所有它的邻居；否则，它将停止活动并停止投票。
- en: When all nodes have deactivated themselves and there are no further changes,
    the algorithm terminates.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有节点都停止活动并且没有进一步的变化时，算法终止。
- en: These steps are shown in figure C.2 with concrete numbers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在图 C.2 中用具体数字进行了展示。
- en: '![APPC_F02_Negro](../Images/APPC_F02_Negro.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F02_Negro](../Images/APPC_F02_Negro.png)'
- en: Figure C.2 Pregel implementation for finding the highest value stored in the
    nodes
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.2 Pregel 实现寻找节点中存储的最高值
- en: 'Pregel uses a pure message-passing model, for two reasons:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Pregel使用纯消息传递模型，原因有两个：
- en: Message passing is expressive enough for graph algorithms; there is no need
    for remote reads (reading data from other machines in the processing cluster)
    or other ways of emulating shared memory.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递对于图算法来说已经足够表达；不需要远程读取（从处理集群中的其他机器读取数据）或其他模拟共享内存的方式。
- en: By avoiding reading values from remote machines and delivering messages asynchronously
    in batches, it’s possible to reduce latency, thereby enhancing performance.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过避免从远程机器读取值并以批量异步发送消息，可以降低延迟，从而提高性能。
- en: Although Pregel’s nodecentric model is easy to program and has proved to be
    useful for many graph algorithms, it is worth noting that such a model hides the
    partitioning information from users and thus prevents many algorithm-specific
    optimizations, often resulting in longer execution times due to excessive network
    load. To address this limitation, other approaches exist. This approach can be
    defined as a graphcentric programming paradigm. In this graphcentric model, the
    partition structure is opened to the users and can be optimized so that communication
    within a partition can bypass heavy message-passing [Tian et al., 2013].
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Pregel的以节点为中心的模型易于编程，并且已被证明对许多图算法很有用，但值得注意的是，这种模型隐藏了分区信息，从而阻止了许多针对特定算法的优化，这通常会导致由于过度的网络负载而执行时间更长。为了解决这一限制，存在其他方法。这种方法可以定义为一种以图为中心的编程范式。在这个以图为中心的模型中，分区结构对用户开放，并且可以被优化，以便分区内的通信可以绕过繁重的消息传递[Tian
    等人，2013]。
- en: Now that the model is clear, and the advantages and drawbacks have been highlighted,
    let’s return to our scenario and examine the logical steps of the implementation
    of the PageRank algorithm using Pregel, which could look like figure C.3.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型已经明确，优势和劣势已经突出，让我们回到我们的场景，并检查使用 Pregel 实现PageRank 算法的逻辑步骤，这可能会像图 C.3 所示。
- en: '![APPC_F03_Negro](../Images/APPC_F03_Negro.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F03_Negro](../Images/APPC_F03_Negro.png)'
- en: Figure C.3 PageRank implemented with Pregel framework
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.3 使用 Pregel 框架实现的 PageRank
- en: 'The schema in figure C.3 can be further described as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.3 中的模式可以进一步描述如下：
- en: The graph is initialized so that in superstep 0, the value of each node is 1/
    NumNodes(). Each node sends along each outgoing edge this value divided by the
    number of outgoing edges.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的初始化方式是，在超级步 0 中，每个节点的值为 1/ NumNodes()。每个节点通过每个出边发送这个值除以出边的数量。
- en: In each subsequent superstep, each node sums up the values arriving in messages
    into sum and sets its own tentative PageRank to 0.15/NumNodes() + 0.85 × sum.
    Then it sends along each outgoing edge its tentative PageRank divided by the number
    of outgoing edges.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个后续的超级步中，每个节点将收到的消息中的值加到 sum 中，并将自己的临时 PageRank 设置为 0.15/NumNodes() + 0.85
    × sum。然后它通过每个出边发送自己的临时 PageRank 除以出边的数量。
- en: The algorithm terminates if all the overall changes in value are under some
    threshold or it reaches a predefined number of iterations.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有整体价值的变化都低于某个阈值，或者达到预定义的迭代次数，算法将终止。
- en: The fun aspect of the Pregel implementation of the PageRank algorithm in the
    internet scenario is that we have a graph-by-nature dataset (internet links),
    a pure graph algorithm (PageRank), and a graph-based processing paradigm.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Pregel 实现的 PageRank 算法在互联网场景中的有趣之处在于，我们有一个基于自然的数据集（互联网链接），一个纯图算法（PageRank），以及一个基于图的计算范式。
- en: C.2 Graphs for defining complex processing workflows
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 用于定义复杂处理工作流程的图
- en: In a machine learning project, graph models can be used not only for representing
    complex data structures, making it easy to store, process, or access them, but
    also for describing, in an effective way, complex processing workflows—the sequences
    of subtasks that are necessary to complete bigger tasks. The graph model allows
    us to visualize the entire algorithm or application, simplifies the identification
    of issues, and makes it easy to accomplish parallelization even with an automated
    process. Although this specific use of graphs will not be presented extensively
    in the book, it is important to introduce it because it shows the value of the
    graph model in representing complex rules or activities in contexts not necessarily
    related to machine learning.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习项目中，图模型不仅可以用于表示复杂的数据结构，使其易于存储、处理或访问，而且还可以有效地描述复杂的处理工作流程——完成更大任务所需的子任务序列。图模型使我们能够可视化整个算法或应用，简化问题的识别，并使得即使通过自动化过程也能轻松实现并行化。尽管本书不会详细介绍这种特定的图应用，但介绍它是很重要的，因为它展示了图模型在表示与机器学习不必要相关联的复杂规则或活动中的价值。
- en: Dataflow is a programming paradigm (often referred to as *DFP*, for *dataflow
    programming*) that uses directed graphs to represent complex applications and
    is extensively used for parallel computing. In a dataflow graph, nodes represent
    units of computation, and edges represent the data consumed or produced by a computation.
    TensorFlow[²](#pgfId-1000412) uses these graphs to represent computation in terms
    of the dependencies between individual operations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流是一种编程范式（通常称为 *DFP*，即 *数据流编程*），它使用有向图来表示复杂的应用，并且在并行计算中被广泛使用。在数据流图中，节点代表计算单元，边代表计算消耗或产生的数据。TensorFlow[²](#pgfId-1000412)
    使用这些图来表示计算，这些计算基于单个操作之间的依赖关系。
- en: C.3 Dataflow
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 数据流
- en: Suppose that you are expecting a baby, and during your last visit, the doctor
    predicted the weight of the newborn to be 7.5 pounds. You would like to figure
    out how that might differ from the baby’s actual measured weight.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在期待一个宝宝的出生，在你最后一次访问时，医生预测新生儿的体重为 7.5 磅。你可能会想知道这可能与婴儿的实际测量体重有何不同。
- en: Let’s design a function to describe the likelihood of all possible weights of
    the newborn. You would like to know if 8 pounds is more likely than 10 pounds,
    for example [Shukla, 2018]. For this kind of prediction, the Gaussian (otherwise
    known as normal) probability distribution function is generally used. This function
    takes as input a number and some other parameters, and outputs a nonnegative number
    describing the probability of observing the input. The probability density of
    the normal distribution is given by the equation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个函数来描述新生儿所有可能体重的可能性。你可能会想知道8磅是否比10磅更可能，例如[Shukla, 2018]。对于这种预测，通常使用高斯（也称为正态）概率分布函数。这个函数接受一个数字和一些其他参数作为输入，并输出一个非负数，描述观察输入的概率。正态分布的概率密度由以下方程给出
- en: '![APPC_F04_EQ01_Negro](../Images/APPC_F04_EQ01_Negro.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F04_EQ01_Negro](../Images/APPC_F04_EQ01_Negro.png)'
- en: where
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: μ is the mean or expectation of the distribution (and also its median and mode).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: μ是分布的均值或期望（也是它的中位数和众数）。
- en: σ is the standard deviation.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: σ是标准差。
- en: σ² is the variance.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: σ²是方差。
- en: This formula specifies how to compute the probability of x (the weight, in our
    scenario) considering the median value μ (in our case, 7.5 pounds) and the standard
    deviation (which specifies the variability from the mean). The median value is
    not random; it is the actual average value of a newborn in North America.[³](#pgfId-1000428)
    This function can be represented in an XY chart, as shown in figure C.4.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式指定了如何计算x（在我们的场景中是重量）的概率，考虑到中位数μ（在我们的例子中，是7.5磅）和标准差（它指定了与平均值的差异）。中位数不是随机的；它是北美新生儿实际的平均体重。[³](#pgfId-1000428)
    这个函数可以用XY图表表示，如图C.4所示。
- en: '![APPC_F04_Negro](../Images/APPC_F04_Negro.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F04_Negro](../Images/APPC_F04_Negro.png)'
- en: Figure C.4 Normal distribution curve (bell curve)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.4 正态分布曲线（钟形曲线）
- en: Depending on the value of σ (the standard deviation), the curve can be taller
    or fatter, whereas depending on the value of μ (the mean), it can move to the
    left or right side of the chart. Figure C.4 has the value of the mean centered
    to 7.5\. According to the value of the standard deviation, the probability of
    the nearest values could be more or less distributed. The taller curve has a variance
    of 0.2, and the fatter one has a variance of 5\. A smaller value of variance means
    that the most probable values are the closest to the mean (on both sides).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据σ（标准差）的值，曲线可以是更高的或更胖的，而根据μ（均值）的值，它可以移动到图表的左侧或右侧。图C.4将均值的值定为中心7.5。根据标准差的值，最近值的概率分布可能更多或更少。较高的曲线具有0.2的方差，而较胖的曲线具有5的方差。方差较小的值意味着最可能值最接近均值（在两侧）。
- en: In any case, the graph presents a similar structure that causes it to be informally
    called the *bell curve*. This formula and the related representation mean that
    events closer to the tip of the curve are more likely to happen than events on
    the sides. In our case, if the mean expected weight of a newborn is 7.5 pounds,
    and the variance is known, we can use this function to get the probability of
    a weight of 8 pounds compared with 10 pounds. This function shows up all the time
    in machine learning, and it’s easy to define in TensorFlow; it uses only multiplication,
    division, negation, and a few other fundamental operators.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，图表呈现的结构相似，因此非正式地被称为*钟形曲线*。这个公式及其相关表示意味着曲线尖端附近的事件比曲线两侧的事件更有可能发生。在我们的例子中，如果新生儿的预期平均体重是7.5磅，且已知方差，我们可以使用这个函数来获取8磅与10磅体重的概率。这个函数在机器学习中经常出现，并且在TensorFlow中很容易定义；它只使用乘法、除法、取反和一些其他基本运算符。
- en: To convert such a function to its graph representation in dataflow, it is possible
    to simplify it by setting the mean to 0 and the standard deviation to 1\. With
    these parameter values, the formula becomes
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此类函数转换为数据流中的图形表示，可以通过将均值设置为0和标准差设置为1来简化它。使用这些参数值，公式变为
- en: '![APPC_F05_EQ01_Negro](../Images/APPC_F05_EQ01_Negro.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F05_EQ01_Negro](../Images/APPC_F05_EQ01_Negro.png)'
- en: 'This new function has a specific name: the *standard normal distribution*.
    The conversion to graph format requires the following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数有一个特定的名称：*标准正态分布*。转换为图形格式需要以下步骤：
- en: Each operator becomes a node in the graph, so we will have nodes representing
    products, power, negation, square root, and so on.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个运算符都成为图中的一个节点，因此我们将有表示乘法、幂、取反、平方根等的节点。
- en: The edges between operators represent the composition of mathematical functions.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符之间的边表示数学函数的组合。
- en: Starting from these simple rules, the resulting graph representation of the
    Gaussian probability distribution is shown in figure C.5.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些简单的规则开始，结果的高斯概率分布的图形表示如图C.5所示。
- en: '![APPC_F05_Negro](../Images/APPC_F05_Negro.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![APPC_F05_Negro](../Images/APPC_F05_Negro.png)'
- en: Figure C.5 A graph representation of the normal distribution in dataflow programming
    (σ = 1)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.5 数据流编程中正态分布的图形表示（σ = 1）
- en: Small segments of the graph represent simple mathematical concepts. If a node
    has only an inbound edge, it is a *unary* operator (an operator that operates
    on a single input, such as negation or doubling), whereas a node with two inbound
    edges is a *binary* operator (an operator that operates on two input variables,
    such as addition or exponentiation). In the graph in figure C.5, passing 8 pounds
    (the weight we would like to consider for the newborn) as the input to the formula
    will provide the probability of this weight. The figure shows the different branches
    of the function clearly, which means that it is trivial to identify portions of
    the formula that can be processed in parallel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图的简单部分代表简单的数学概念。如果一个节点只有一个入边，它是一个*一元*操作符（一个操作单个输入的操作符，如否定或加倍），而一个有两个入边的节点是一个*二元*操作符（一个操作两个输入变量的操作符，如加法或指数）。在图C.5中，将8磅（我们希望考虑的新生儿的重量）作为公式的输入将提供这个重量的概率。该图清楚地显示了函数的不同分支，这意味着可以很容易地识别可以并行处理的公式部分。
- en: 'In TensorFlow, this approach makes it easy to visualize and process even algorithms
    that appear to be quite complex. DFP was a commonly forgotten paradigm despite
    its usefulness in certain scenarios, but TensorFlow revived it by showing the
    power of graph representations for complex processes and tasks. The advantages
    of the DFP approach can be summarized as follows [Johnstonet et al., 2004; Sousa,
    2012]:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '在TensorFlow中，这种方法使得即使是看似相当复杂的算法的可视化和处理也变得容易。尽管在某些场景中非常有用，但DFP范式通常被遗忘，但TensorFlow通过展示图形表示在复杂过程和任务中的力量而使其复兴。DFP方法的优势可以总结如下
    [Johnstonet et al., 2004; Sousa, 2012]:'
- en: It provides a visual programming language with a simplified interface that enables
    rapid prototyping and implementation of certain systems. We’ve already discussed
    the importance of the visual sense and graphs as a way to better understand complex
    data structures. DFP is capable of representing complex applications and algorithms
    while keeping them simple to understand and modify.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种具有简化界面的可视化编程语言，这使得某些系统的快速原型设计和实现成为可能。我们已讨论过视觉感知和图形作为更好地理解复杂数据结构的方法的重要性。DFP能够在保持简单易懂和易于修改的同时，表示复杂的应用程序和算法。
- en: It implicitly achieves concurrency. The original motivation for research on
    dataflow was the exploitation of massive parallelism. In a dataflow application,
    internally each node is an independent processing block that works independently
    from all the others and produces no side effects. Such an execution model allows
    nodes to execute as soon as data arrives at them without the risk of creating
    deadlocks, because there are no data dependencies in the system. This important
    feature of the dataflow model can greatly increase the performance of an application
    being executed on a multicore CPU without requiring any additional work by the
    programmer.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它隐式地实现了并发性。数据流研究最初的动机是利用大规模并行性。在数据流应用程序中，内部每个节点都是一个独立的处理块，它独立于所有其他节点工作，并且不会产生副作用。这种执行模型允许节点在数据到达时立即执行，而不会产生死锁的风险，因为系统中没有数据依赖。数据流模型的重要特性可以显著提高在多核CPU上执行的应用程序的性能，而无需程序员进行任何额外的工作。
- en: Dataflow applications represent another example of the expressive power of graphs
    for decomposing complex problems into subtasks that are easy to visualize, modify,
    and parallelize.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流应用程序是图形在将复杂问题分解为易于可视化、修改和并行化的子任务方面的表达能力的另一个例子。
- en: References
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[Malewicz, 2010] Malewicz, Grzegorz, Matthew H. Austern, Aart J. C. Bik, James
    C. Dehnert, Ilan Horn, Naty Leiser, and Grzegorz Cjajkowski. “Pregel: A System
    for Large-Scale Graph Processing.” *Proceedings of the 2010 ACM SIGMOD International
    Conference on Management of Data* (2010): 135-146.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[Malewicz, 2010] Malewicz, Grzegorz, Matthew H. Austern, Aart J. C. Bik, James
    C. Dehnert, Ilan Horn, Naty Leiser, and Grzegorz Cjajkowski. “Pregel: A System
    for Large-Scale Graph Processing.” *Proceedings of the 2010 ACM SIGMOD International
    Conference on Management of Data* (2010): 135-146.'
- en: '[Tianet et al., 2013] Tian, Yuanyuan, Andrey Balmin, Severin Andreas Corsten,
    Shirish Tatikonda, and John McPherson. “From ‘Think Like a Vertex’ to ‘Think Like
    a Graph.’” *Proceedings of the VLDB Endowment* 7:3 (2013): 193-204.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tianet al., 2013] Tian, Yuanyuan, Andrey Balmin, Severin Andreas Corsten,
    Shirish Tatikonda, 和 John McPherson. “从‘像顶点一样思考’到‘像图一样思考’。” *VLDB 奖励会议论文集* 7:3
    (2013): 193-204.'
- en: '[Johnston et al., 2004] Johnston, Wesley M., J. R. Paul Hanna, and Richard
    J. Millar. “Advances in Dataflow Programming Languages.” *ACM Computing Surveys*
    (CSUR) 36:1 (2004): 1-34.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[Johnston et al., 2004] Johnston, Wesley M., J. R. Paul Hanna, 和 Richard J.
    Millar. “数据流编程语言的发展。” *ACM 计算评论* (CSUR) 36:1 (2004): 1-34.'
- en: '[Sousa, 2012] Sousa, Tiago Boldt. “Dataflow Programming: Concept, Languages
    and Applications.” *Doctoral Symposium on Informatics Engineering* (2012).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[Sousa, 2012] Sousa, Tiago Boldt. “数据流编程：概念、语言和应用。” *信息工程博士研讨会* (2012).'
- en: '[Shukla, 2018] Shukla, Nishant. *Machine Learning with TensorFlow*. Shelter
    Island, NY: Manning, 2018.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[Shukla, 2018] Shukla, Nishant. *TensorFlow 机器学习*. 避风岛，纽约：Manning，2018.'
- en: '* * *'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Its name honors Leonhard Euler; the bridges of Königsberg, which inspired
    Euler’s theorem, spanned the Pregel River [Malewicz, 2010].
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ^(1.)其名称是为了纪念莱昂哈德·欧拉；启发欧拉定理的柯尼斯堡大桥横跨普雷格尔河 [Malewicz, 2010].
- en: ^(2.)[https://www.tensorflow.org](https://www.tensorflow.org).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ^(2.)[https://www.tensorflow.org](https://www.tensorflow.org).
- en: ^(3.)[https://www.uofmhealth.org/health-library/te6295](https://www.uofmhealth.org/health-library/te6295).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ^(3.)[https://www.uofmhealth.org/health-library/te6295](https://www.uofmhealth.org/health-library/te6295).
