- en: '9 Quantum sensing: It’s not just a phase'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 量子传感：不仅仅是相位
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How quantum operations can learn useful information about unknown operations
    with phase kickback
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过相位回弹学习关于未知操作的有用信息
- en: Creating new types in Q#
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Q# 中创建新类型
- en: Running Q# code from a Python host program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 主程序中运行 Q# 代码
- en: Recognizing important properties and behaviors of eigenstates and phase
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别本征态和相的重要性质和行为
- en: Programming controlled quantum operations in Q#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Q# 中编程受控量子操作
- en: In the last chapter, we implemented our first quantum algorithm, Deutsch–Jozsa,
    in Q#. By helping Nimue and Merlin play Kingmaker, we saw how quantum programming
    techniques like phase kickback can give us advantages in solving problems. In
    this chapter, we will take a look at *phase-estimation* algorithms we can use
    in our quantum programs to solve different types of problems. Again, we will return
    to Camelot; this time, we will use a game between Lancelot and Dagonet to illustrate
    the task at hand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在 Q# 中实现了我们的第一个量子算法，德-约萨算法。通过帮助 Nimue 和 Merlin 播演国王制造者，我们看到了量子编程技术，如相位回弹，如何帮助我们解决问题。在本章中，我们将探讨我们可以在量子程序中使用的
    *相位估计* 算法来解决不同类型的问题。再次回到 Camelot；这次，我们将使用 Lancelot 和 Dagonet 之间的游戏来展示手头的任务。
- en: '9.1 Phase estimation: Using useful properties of qubits for measurement'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 相位估计：利用量子比特的有用性质进行测量
- en: 'Throughout the book, we’ve seen that games can be a helpful way to learn quantum
    computing concepts. For instance, in the previous chapter, Nimue’s game with Merlin
    let us explore our first quantum algorithm: the Deutsch–Jozsa algorithm. In this
    chapter, we’ll use another game to discover how to learn the phases of quantum
    states using *phase kickback*, the quantum development technique used by Deutsch–Jozsa
    and many other quantum algorithms.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们看到了游戏可以是有助于学习量子计算概念的。例如，在上一章中，Nimue 与 Merlin 的游戏让我们探索了我们的第一个量子算法：德-约萨算法。在本章中，我们将使用另一个游戏来发现如何使用
    *相位回弹* 学习量子状态，这是德-约萨和许多其他量子算法使用的量子发展技术。
- en: For this chapter’s game, let’s go back and see what Lancelot has been up to.
    While Nimue and Merlin are deciding the fate of kings, we find Lancelot and the
    court jester, Dagonet, playing a guessing game. Since they’ve had a while to play,
    Dagonet has gotten bored and wants to “borrow” some of Nimue’s quantum tools to
    make their game a bit more interesting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的游戏，让我们回顾一下 Lancelot 一直在做什么。当 Nimue 和 Merlin 决定国王的命运时，我们发现 Lancelot 和宫廷小丑
    Dagonet 正在玩一个猜谜游戏。由于他们已经玩了一段时间，Dagonet 觉得无聊，并想“借用”Nimue 的量子工具，让他们的游戏更有趣。
- en: 9.1.1 Part and partial application
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 部分应用
- en: 'For Dagonet’s new game, rather than having Lancelot guess a number, Dagonet
    has Lancelot guess what a quantum operation does to a single qubit by letting
    Lancelot call it with different inputs. Given that all single-qubit operations
    are rotations, this works well for the game. Dagonet picks a rotation angle about
    a particular axis, and Lancelot gets to input a number to Dagonet’s operation,
    which changes how to scale the rotation that Dagonet applies. What axis Dagonet
    picks doesn’t really matter, as the game is to guess the rotation angle. For convenience
    here, Dagonet’s rotations are always around the *Z*-axis. Finally, Lancelot can
    measure the qubit and use his measurement to guess Dagonet’s original rotation
    angle. See figure 9.1 for a flowchart of the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Dagonet 的新游戏，而不是让 Lancelot 猜一个数字，Dagonet 让 Lancelot 通过用不同的输入调用它来猜测量子操作对一个单比特的作用。鉴于所有单比特操作都是旋转，这对游戏来说很适用。Dagonet
    选择一个特定轴的旋转角度，Lancelot 可以输入一个数字到 Dagonet 的操作中，这将改变 Dagonet 应用的缩放旋转。Dagonet 选择哪个轴并不重要，因为游戏的目的是猜测旋转角度。为了方便起见，Dagonet
    的旋转总是围绕 *Z* 轴。最后，Lancelot 可以测量量子比特，并使用他的测量结果来猜测 Dagonet 的原始旋转角度。参见图 9.1，以下步骤的流程图：
- en: Dagonet picks a secret angle for a single-qubit rotation operation.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dagonet 为单比特旋转操作选择一个秘密角度。
- en: Dagonet prepares an operation for Lancelot to use that hides the secret angle
    and allows Lancelot one additional input of a number (we’ll call it a scale) that
    will be multiplied with the secret angle to give the total rotation angle of the
    operation.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dagonet 为 Lancelot 准备了一个操作，这个操作隐藏了秘密角度，并允许 Lancelot 多输入一个数字（我们将它称为比例），这个数字将与秘密角度相乘，以给出操作的总体旋转角度。
- en: 'Lancelot’s best strategy for the game is to select many scale values and estimate
    the probability of measuring `One` for each value. To do this, he needs to perform
    the following steps many times for each of the many scale values:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 兰斯洛特在游戏中的最佳策略是选择许多尺度值，并估计每个值的测量`One`的概率。为此，他需要为每个许多尺度值执行以下步骤多次：
- en: Prepare the |+〉 state, and input the scale value in Dagonet’s rotation. He uses
    the |+〉 state because he knows Dagonet is rotating around the *Z*-axis; and for
    this state, these rotations will result in a local phase change he can measure.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备|+〉状态，并在达贡特的旋转中输入尺度值。他使用|+〉状态，因为他知道达贡特是围绕*Z*轴旋转的；并且对于这个状态，这些旋转将导致他可以测量的局部相位变化。
- en: After preparing each |+〉 state, Lancelot can rotate it with the secret operation,
    measure the qubit, and record the measurement.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在准备好每个|+〉状态后，兰斯洛特可以使用秘密操作旋转它，测量量子比特，并记录测量结果。
- en: Lancelot now has data relating his scale factor and the probability he measured
    a `One` for that scale factor. He can fit this data in his head and get Dagonet’s
    angle from the fitted parameters (he *is* the greatest knight in the land). We
    can use Python to help us do the same!
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 兰斯洛特现在有了与他尺度因子相关的数据，以及他测量该尺度因子为`One`的概率。他可以在脑海中拟合这些数据，并从拟合的参数中得到达贡特的角（他确实是这片土地上最伟大的骑士）。我们可以使用Python来帮助我们完成同样的工作！
- en: '![](../Images/9-1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-1.png)'
- en: Figure 9.1 Steps in Dagonet and Lancelot’s game. Dagonet hides a secret rotation
    angle in an operation, and Lancelot has to figure out what that angle is.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1达贡特和兰斯洛特游戏的步骤。达贡特在一个操作中隐藏一个秘密旋转角度，兰斯洛特必须找出这个角度。
- en: Note that this *is* a game, as there is no way for Lancelot to measure this
    rotation directly with just a single measurement. If he could, it would violate
    the no-cloning theorem, and he would transcend the laws of physics. As a Knight
    of the Round Table, Lancelot is bound not only by duty and honor but also by the
    laws of physics, so he must play Dagonet’s game by the rules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这确实是一个游戏，因为兰斯洛特无法仅通过一次测量直接测量这个旋转。如果他能够做到，这将违反不可克隆定理，他将超越物理定律。作为圆桌骑士团的骑士，兰斯洛特不仅受职责和荣誉的约束，还受物理定律的约束，所以他必须按照规则玩达贡特的这个游戏。
- en: 'Deep dive: Learning the axis with Hamiltonian learning'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：使用哈密顿学习学习轴
- en: In this chapter, we focus on the case where Dagonet’s rotation axis is known,
    but we need to learn his angle. This case corresponds to a common problem in physics
    where we are tasked with learning the *Larmor precession* of a qubit in a magnetic
    field. Learning Larmor precessions isn’t just useful in building qubits; it also
    allows for detecting very small magnetic fields and building very precise sensors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关注的是已知达贡特旋转轴的情况，但我们需要学习他的角度。这种情况对应于物理学中一个常见的问题，即我们被要求学习磁场中量子比特的拉莫进动。学习拉莫进动不仅对构建量子比特有用；它还允许检测非常小的磁场并构建非常精确的传感器。
- en: More generally, though, we can learn much more than a single rotation angle.
    The case in which the axis is also unknown is an example of a general kind of
    problem called *Hamiltonian learning*, a rich area of research in quantum computing.
    In Hamiltonian learning, we reconstruct a physical model for a qubit or register
    of qubits using a game very similar to the one explored in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更普遍地说，我们可以学习比单个旋转角度更多的内容。当轴也未知时的情况是一个称为*哈密顿学习*的一般类型问题的例子，这是量子计算中的一个研究领域。在哈密顿学习中，我们使用与本章中探索的游戏非常相似的游戏来重建量子比特或量子比特寄存器的物理模型。
- en: Let’s jump into prototyping this game in Q#. It will be helpful to have access
    to different parts of the Q# standard libraries, so we can start by adding the
    following `open` statements to the top of our Q# file, operations.qs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳入使用Q#原型化这个游戏。能够访问Q#标准库的不同部分将很有帮助，因此我们可以从在operations.qs文件的顶部添加以下`open`语句开始。
- en: 'Listing 9.1 operations.qs: opening Q# namespaces for the game'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 operations.qs：打开游戏中的Q#命名空间
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ All open statements in a Q# file come right after the namespace declaration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Q#文件中的所有开放语句都紧跟在命名空间声明之后。
- en: ❷ As before, opening Microsoft.Quantum.Intrinsic gives us access to all the
    fundamental instructions (R1, Rz, X, and so forth) that we can send to a quantum
    device.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如前所述，打开Microsoft.Quantum.Intrinsic为我们提供了访问所有基本指令（R1、Rz、X等等）的权限，我们可以将这些指令发送到量子设备。
- en: ❸ We can also give an alias to namespaces when we open them, similar to how
    we can alias Python packages and modules when we import them. Here we abbreviate
    Microsoft.Quantum.Convert so later we can use type conversion functions in that
    namespace by prefixing them with Convert.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在打开命名空间时，我们也可以给它们起别名，类似于我们在导入时可以给Python包和模块起别名。在这里，我们缩写Microsoft.Quantum.Convert，以便以后我们可以通过在它们前面加上Convert前缀来使用该命名空间中的类型转换函数。
- en: ❹ We can make the MResetZ operation from previous chapters available as Meas.MResetZ
    to document where the operation came from.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们可以将上一章中的 MResetZ 操作作为 Meas.MResetZ 提供出来，以记录操作的来源。
- en: ❺ The last namespace we need to open in this chapter is Microsoft.Quantum.Arrays,
    which provides useful functions and operations for working with arrays.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在本章中我们需要打开的最后一个命名空间是 Microsoft.Quantum.Arrays，它提供了用于处理数组的实用函数和操作。
- en: Listing 9.2 shows an example of the quantum operation Dagonet needs to implement
    the rotation he and Lancelot will play with. Like other rotations, our new rotation
    operation returns `Unit` (the type of the empty tuple `()`), indicating that there’s
    no meaningful return from the operation. For the actual body of the operation,
    we can find the angle to rotate by multiplying Dagonet’s hidden angle `angle`
    with Lancelot’s scale factor `scale`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2展示了Dagonet需要实现旋转的量子操作的示例。与其他旋转一样，我们的新旋转操作返回`Unit`（空元组`()`的类型），表示操作没有有意义的返回值。对于操作的真正主体，我们可以通过将Dagonet隐藏的角度`angle`与兰斯洛特的尺度因子`scale`相乘来找到旋转的角度。
- en: 'Listing 9.2 operations.qs: an operation to set up the game'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 operations.qs：设置游戏的操作
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '❶ To play the guessing game, we need a quantum operation that takes two classical
    arguments: one that Dagonet passes and one that Lancelot passes.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要玩猜谜游戏，我们需要一个量子操作，它接受两个经典参数：一个是Dagonet传递的，另一个是兰斯洛特传递的。
- en: ❷ The Adj + Ctl part of the signature indicates that this operation supports
    the Adjoint functor that we first saw in chapter 8 as well as the Controlled functor
    we’ll see later in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 签名中的 Adj + Ctl 部分表示此操作支持我们在第8章首次看到的伴随函子，以及我们将在本章后面看到的受控函子。
- en: ❸ The rotation operation R1 here is almost identical to the Rz operation we’ve
    seen a few times so far. The difference between R1 and Rz will become important
    when we add the Controlled functor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这里的旋转操作R1几乎与我们之前见过的Rz操作完全相同。当添加受控函子时，R1和Rz之间的区别将变得重要。
- en: 'Note When writing Q# in its own file (that is, not from a Jupyter Notebook),
    all operations and functions must be defined inside a namespace. This helps keep
    our code organized and makes it harder for our code to conflict with code in the
    various libraries we use in our quantum application. For brevity, we often don’t
    show the namespace declarations, but the full code can always be found in the
    samples repository for this book: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当在单独的文件中编写Q#（即不是从Jupyter Notebook中）时，所有操作和函数都必须在命名空间内定义。这有助于保持我们的代码整洁，并使我们的代码与我们在量子应用程序中使用的各种库中的代码发生冲突的可能性降低。为了简洁，我们通常不显示命名空间声明，但完整的代码始终可以在本书的示例存储库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。
- en: To see a visual representation of Dagonet’s setup of the game, see figure 9.2.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Dagonet设置游戏的视觉表示，请参阅图9.2。
- en: '![](../Images/9-2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-2.png)'
- en: Figure 9.2 Using partial application to hide the secret angle while playing
    Dagonet’s guessing game. The oracle that Lancelot gets has an input for his scale
    parameter, and he can then choose the target machine to use the operation with
    but cannot “peek inside” the operation to see the secret angle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 使用部分应用隐藏秘密角度，在玩Dagonet的猜谜游戏。兰斯洛特得到的占卜者有一个用于他的尺度参数的输入，然后他可以选择使用该操作的目标机器，但不能“窥视”操作以查看秘密角度。
- en: 'Deep dive: Why not just measure the angle?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：为什么不是直接测量角度？
- en: It may seem like Lancelot has to jump through a lot of hoops to guess Dagonet’s
    hidden angle. After all, what besides duty and honor is stopping Lancelot from
    passing a scale of `1.0` and then just reading out the angle from the phase applied
    to his qubit? It turns out that the no-cloning theorem strikes again in this case,
    telling us that Lancelot can never learn a phase from a single measurement.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来兰斯洛特必须跳过很多圈才能猜测达戈内特隐藏的角度。毕竟，除了职责和荣誉之外，还有什么能阻止兰斯洛特传递一个比例尺为 `1.0` 并直接从其量子比特上应用的相位中读取角度呢？结果证明，在这种情况下，不可克隆定理再次发挥作用，告诉我们兰斯洛特永远无法从单一测量中学习到一个相位。
- en: The easiest way to see this is to pretend for a moment that Lancelot could do
    that, and then see what goes wrong. Suppose that Dagonet hides an angle of *π*/2
    and that Lancelot prepares his qubit in the |+〉 = 1 / √2 (|0〉 + |1〉) state. If
    Lancelot then passes `1.0` as his scale, his qubit ends up in the 1 / √2 (|0〉
    + *i* |1〉) state. If Lancelot could directly measure the phase *e*^(*iπ*/2) =
    +*i* to guess Dagonet’s angle from a single measurement, he could use that to
    prepare another copy of the 1 / √2 (|0〉 + *i* |1〉) state, even though Lancelot
    didn’t know the right basis to measure in. Indeed, Lancelot’s magic measurement
    device should also work if Dagonet hides the angle *π*, in which case Lancelot
    winds up with a qubit in the 1 / √2 (|0〉 − |1〉) state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是暂时假设兰斯洛特能够做到这一点，然后看看会发生什么。假设达戈内特隐藏了一个 *π*/2 的角度，而兰斯洛特将他的量子比特准备在 |+〉 =
    1 / √2 (|0〉 + |1〉) 状态。如果兰斯洛特将 `1.0` 作为他的比例尺，他的量子比特最终会处于 1 / √2 (|0〉 + *i* |1〉)
    状态。如果兰斯洛特能够直接测量相位 *e*^(*iπ*/2) = +*i* 来从单一测量中猜测达戈内特的角度，他就可以使用这一点来准备另一个 1 / √2
    (|0〉 + *i* |1〉) 状态的副本，即使兰斯洛特不知道正确的基来测量。实际上，如果达戈内特隐藏的角度是 *π*，兰斯洛特的神奇测量设备也应该起作用，在这种情况下，兰斯洛特最终会得到一个处于
    1 / √2 (|0〉 − |1〉) 状态的量子比特。
- en: Put differently, if Lancelot could figure out Dagonet’s angle by measuring phases
    directly, he could make copies of arbitrary states of the form 1 / √2 (|0〉 + *e*^(*iϕ*)
    |1〉) for any angle *ϕ*, *without having to know* *ϕ* *ahead of time*. That rather
    badly violates the no-cloning theorem, so we can safely conclude that Lancelot
    will need to do a bit more work to win Dagonet’s game.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 换一种说法，如果兰斯洛特能够通过直接测量相位来计算出达戈内特的角，他就能为任何角度 *ϕ* 制作形式为 1 / √2 (|0〉 + *e*^(*iϕ*)
    |1〉) 的任意状态的副本，而无需事先知道 *ϕ*。这相当严重地违反了不可克隆定理，因此我们可以安全地得出结论，兰斯洛特需要做更多的工作才能赢得达戈内特的比赛。
- en: Once we’ve defined an operation this way, Dagonet can use the partial application
    feature of Q# that we first saw in chapter 8 to hide his input. Then Lancelot
    gets an operation that he can apply to his qubits, but not in a way that lets
    him directly see the angle he is trying to guess.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们以这种方式定义了一个操作，达戈内特就可以使用我们在第 8 章中首次看到的 Q# 的部分应用功能来隐藏他的输入。然后兰斯洛特得到一个可以应用于他的量子比特的操作，但不会让他直接看到他试图猜测的角度。
- en: Using `ApplyScaledRotation`, Dagonet can easily make an operation for Lancelot
    to call. For instance, if Dagonet picks the angle `0.123`, he can “hide” it by
    giving Lancelot the operation `ApplyScaledRotation(0.123, _, _)`. As with the
    examples of partial application in chapter 7, the `_` indicates a slot for future
    inputs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ApplyScaledRotation`，达戈内特可以轻松地为兰斯洛特创建一个可以调用的操作。例如，如果达戈内特选择了角度 `0.123`，他可以通过给兰斯洛特提供操作
    `ApplyScaledRotation(0.123, _, _)` 来“隐藏”它。就像第 7 章中部分应用的例子一样，`_` 表示未来输入的槽位。
- en: As shown in figure 9.3, since `ApplyScaledRotation` has type `(Double, Double,
    Qubit) => Unit is Adj + Ctl`, providing only the first input results in an operation
    of type `(Double, Qubit) => Unit is Adj + Ctl`. This means Lancelot can provide
    an input of type `Double`, a qubit he wants to apply his operation to, and use
    `Adjoint` and the functor we saw in chapter 6.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 9.3 所示，由于 `ApplyScaledRotation` 的类型是 `(Double, Double, Qubit) => Unit is
    Adj + Ctl`，只提供第一个输入会导致一个类型为 `(Double, Qubit) => Unit is Adj + Ctl` 的操作。这意味着兰斯洛特可以提供一个类型为
    `Double` 的输入，一个他想要对其应用操作的量子比特，并使用 `Adjoint` 和我们在第 6 章中看到的函子。
- en: '![](../Images/9-3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-3.png)'
- en: Figure 9.3 Partially applying `ApplyScaledRotation` to make an operation for
    Lancelot
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 部分应用 `ApplyScaledRotation` 以为兰斯洛特创建一个操作
- en: The fact that we can see the value of the angle in the syntax does *not* mean
    Lancelot can. Indeed, the only things Lancelot can do with a partially applied
    operation or function are call it, partially apply it further, or pass it to another
    function or operation. From Lancelot’s perspective, `ApplyScaledRotation(0.123,
    _, _)` is a black box. Thanks to this partial-application trick, he will just
    have an operation that takes his scale value and can be used to rotate a qubit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能在语法中看到角度的值**并不意味着**兰斯洛特可以看到。实际上，兰斯洛特对一个部分应用的操作或函数能做的事情只有调用它、进一步部分应用它，或者将其传递给另一个函数或操作。从兰斯洛特的角度来看，`ApplyScaledRotation(0.123,
    _, _)` 是一个黑盒。多亏了这个部分应用的小技巧，他只会得到一个接受他的缩放值并可用于旋转量子比特的操作。
- en: We can simplify our lives as Q# developers by giving a name to the type of Lancelot’s
    operation that’s a bit easier to read than `(Double, Qubit) => Unit is Adj + Ctl`.
    In the next section, we’ll learn how Q# lets us annotate the type signatures we
    use to play Dagonet and Lancelot’s guessing game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过给兰斯洛特的操作类型命名来简化我们的生活，这个命名比 `(Double, Qubit) => Unit is Adj + Ctl` 更容易阅读。在下一节中，我们将学习
    Q# 如何让我们注释我们使用的类型签名，以便玩达贡特和兰斯洛特的猜谜游戏。
- en: 9.2 User-defined types
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 用户定义类型
- en: We have already seen how types play a role in Q#, particularly in the signatures
    for functions and operations. We have also seen that both functions and operations
    are tuple-in, tuple-out. In this section, we’ll learn how to build up our own
    types in Q# and why that might be handy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到类型在 Q# 中扮演的角色，尤其是在函数和操作的签名中。我们也看到函数和操作都是元组输入、元组输出。在本节中，我们将学习如何在 Q# 中构建自己的类型，以及为什么这可能很有用。
- en: 'In Q# (as well as many other languages), several types are defined as part
    of the language itself: types like `Int`, `Qubit`, and `Result` that we have seen
    already.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Q#（以及许多其他语言）中，一些类型被定义为语言本身的一部分：例如我们之前见过的 `Int`、`Qubit` 和 `Result` 类型。
- en: Tip For a complete list of these basic types, see the Q# language docs at [https://docs.microsoft.com/azure/quantum/user-guide/language/typesystem/#primitive-types](https://docs.microsoft.com/azure/quantum/user-guide/language/typesystem/#primitive-types).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要获取这些基本类型的完整列表，请参阅 Q# 语言文档中的[https://docs.microsoft.com/azure/quantum/user-guide/language/typesystem/#primitive-types](https://docs.microsoft.com/azure/quantum/user-guide/language/typesystem/#primitive-types)。
- en: Building up from these basic types, we can make array types by adding `[]` after
    the type. For example, in this chapter’s game, we will likely need to input an
    array of doubles to represent Lancelot’s multiple inputs to Dagonet’s operation.
    We can use `Double[]` to indicate an array of `Double` values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些基本类型出发，我们可以在类型后添加 `[]` 来创建数组类型。例如，在本章的游戏中，我们可能需要输入一个表示兰斯洛特对达贡特的多次操作的数组，即
    `double` 类型的数组。我们可以使用 `Double[]` 来表示 `Double` 值的数组。
- en: Listing 9.3 Defining an array type of `Double`s of length `10`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 定义长度为 `10` 的 `Double` 数组类型
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ EmptyArray comes from the Microsoft.Quantum.Arrays namespace. Make sure to
    open it before running this code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `EmptyArray` 来自于 `Microsoft.Quantum.Arrays` 命名空间。确保在运行此代码之前将其打开。
- en: 'We can also define our own types in Q# with the `newtype` statement. This statement
    allows us to declare new *user-defined types* (UDTs). There are two main reasons
    to use UDTs:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `newtype` 语句在 Q# 中定义自己的类型。这个语句允许我们声明新的**用户定义类型**（UDTs）。使用 UDTs 的两个主要原因是：
- en: Convenience
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方便
- en: Communicating intent
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传达意图
- en: The first reason is a matter of *convenience*. Sometimes the type signature
    for a function or operation can get pretty long, so we can define our own type
    as a kind of shorthand. Another reason we may want to name our type is to communicate
    *intent*. Say our operation takes a tuple of two `Double` values that represents
    a complex number. Defining a new type `Complex` can remind us and our teammates
    what that tuple represents. The Quantum Development Kit provides several different
    functions, operations, and UDTs with the Q# libraries, such as the following sample,
    which defines the type `Complex`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是出于**方便**的考虑。有时函数或操作的类型签名可能会变得相当长，因此我们可以定义自己的类型作为简写。我们可能想要命名我们的类型的另一个原因是传达**意图**。比如说，我们的操作接受两个
    `Double` 值的元组，代表一个复数。定义一个新的类型 `Complex` 可以提醒我们和我们的队友这个元组代表什么。量子开发工具包提供了几个不同的函数、操作和用户定义类型（UDTs），例如以下示例，它定义了类型
    `Complex`。
- en: Listing 9.4 How complex numbers are defined in the Q# runtime
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4 在 Q# 运行时中复数的定义
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Complex numbers are implemented as a UDT in the Microsoft.Quantum.Math namespace.
    We can use this type by including the statement “open Microsoft.Quantum.Math;”
    in our quantum application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Complex 数在 Microsoft.Quantum.Math 命名空间中作为 UDT 实现。我们可以通过在量子应用程序中包含语句“open Microsoft.Quantum.Math;”来使用此类型。
- en: ❷ The Complex type is defined as a tuple of two Double values, where the first
    item is named Real and the second is named Imag.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Complex 类型定义为两个 Double 值的元组，其中第一个元素命名为 Real，第二个元素命名为 Imag。
- en: Tip The Quantum Development Kit is open source, so if you’re curious, you can
    always look up how various parts of the Q# language, runtime, compiler, and standard
    libraries work. For example, the definition of the `Complex` UDT is in the src/Simulation/QSharpFoundation/Math/Types.qs
    file in the Q# runtime repository at [https://github.com/microsoft/qsharp-runtime](https://github.com/microsoft/qsharp-runtime).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：量子开发工具包是开源的，所以如果你好奇，你总是可以查找 Q# 语言、运行时、编译器和标准库的各个部分是如何工作的。例如，`Complex` UDT
    的定义位于 Q# 运行时仓库中的 src/Simulation/QSharpFoundation/Math/Types.qs 文件，网址为 [https://github.com/microsoft/qsharp-runtime](https://github.com/microsoft/qsharp-runtime)。
- en: 'As shown in figure 9.4, there are two ways to get the different items back
    out of a UDT. We can either use named items together with the `::` operator or
    “unwrap” the UDT with the `!` operator to get back to the original type wrapped
    by the UDT:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 9.4 所示，有两种方式可以从 UDT 中获取不同的项。我们可以使用命名项与 `::` 操作符一起，或者使用 `!` 操作符“展开”UDT，以回到被
    UDT 包装的原始类型：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Since the Complex UDT is defined with a named item called Real, we can access
    that item as ::Real to get back the real part of our input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于 Complex UDT 是使用名为 Real 的命名项定义的，我们可以通过 ::Real 访问该项，以获取输入的实部。
- en: ❷ Alternatively, since Complex is defined as wrapping a tuple of type (Double,
    Double), the unwrap operator ! takes us back to the real and imaginary parts of
    complex without the UDT wrapper.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 或者，由于 Complex 被定义为包装一个类型为 (Double, Double) 的元组，unwrap 操作符 ! 将我们带回到复数的实部和虚部，而不需要
    UDT 包装器。
- en: '![](../Images/9-4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-4.png)'
- en: Figure 9.4 Using the `::` and `!` operators with UDTs. We can think of a UDT
    as a labeled tuple of data. The `::` operator lets us access that data by name,
    while the `!` operator unpacks a UDT into its base type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 使用 `::` 和 `!` 操作符与 UDT。我们可以将 UDT 视为带标签的数据元组。`::` 操作符允许我们通过名称访问数据，而 `!`
    操作符将 UDT 展开为其基础类型。
- en: Tip Both ways of working with UDTs are useful in different cases, but most of
    the time, we’ll stick with using named items and the `::` operator in this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：使用 UDT 的两种方式在不同的场景中都很有用，但在这本书中，我们大多数时候会坚持使用命名项和 `::` 操作符。
- en: Once a new UDT has been defined, it can also act as a way to instantiate a new
    instance of that type. For example, the `Complex` type acts as a function that
    creates a new complex number with the input of a tuple of two `Double` values.
    This is similar to Python, where types are also functions that create instances
    of that type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了新的 UDT，它也可以作为实例化该类型新实例的一种方式。例如，`Complex` 类型作为一个函数，通过输入两个 `Double` 值的元组来创建一个新的复数。这与
    Python 类似，在 Python 中，类型也是创建该类型实例的函数。
- en: Listing 9.5 Creating a complex number with the UDT `Complex`
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.5 使用 UDT `Complex` 创建复数
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Defining a UDT with newtype also defines a new function with the same name
    as that type that returns values of our new UDT. For instance, we can call Complex
    as a function with two Double inputs representing the real and imaginary parts
    of the new Complex value. Here, we define a Complex value representing 0 + 1.0*i*
    (0+1j in Python notation), also known as the imaginary unit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 newtype 定义 UDT 也定义了一个与该类型同名的新函数，该函数返回我们新 UDT 的值。例如，我们可以将 Complex 作为具有两个
    Double 输入的函数调用，这些输入代表新 Complex 值的实部和虚部。在这里，我们定义了一个表示 0 + 1.0*i*（Python 中的 0+1j）的
    Complex 值，也称为虚数单位。
- en: 'Exercise 9.1: UDTs for strategies'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.1：策略的 UDT
- en: In chapter 4, we used Python type annotations to represent the concept of a
    *strategy* in the CHSH game. UDTs in Q# can be used similarly. Give it a go by
    defining a new UDT for CHSH strategies, and then use our new UDT to wrap the constant
    strategy from chapter 4.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们使用 Python 类型注解来表示 CHSH 游戏中的策略概念。Q# 中的 UDT 可以以类似的方式使用。尝试定义一个新的 UDT
    用于 CHSH 策略，然后使用我们新的 UDT 来包装第 4 章中的常量策略。
- en: '*Hint*: Our and Eve’s parts of the strategy can each be represented as operations
    that take a `Result` and output a `Result`: that is, as operations of type `Result
    => Result`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：我们的和 Eve 的策略部分可以分别表示为接受 `Result` 并输出 `Result` 的操作：即 `Result => Result`
    类型的操作。'
- en: Exercise solutions
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 练习解答
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所有练习题的解决方案都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入你所在章节的文件夹，然后打开提及练习解决方案的Jupyter笔记本。
- en: For the game in this chapter, we have defined a new UDT, both to label how we
    intend to use it and as a convenient shorthand for the operation type that Lancelot
    gets as his part of the guessing game. In the following listing, we can see the
    definition of this new type, called `ScalableOperation`, as a tuple with one named
    input called `Apply`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的游戏，我们定义了一个新的UDT，既是为了标记我们打算如何使用它，也是为了方便地表示Lancelot在猜测游戏中获得的操作类型。在下面的列表中，我们可以看到这个新类型`ScalableOperation`的定义，它是一个包含一个名为`Apply`的命名输入的元组。
- en: 'Listing 9.6 operations.qs: setup for the quantum guessing game'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 operations.qs：量子猜测游戏的设置
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ We can declare a new UDT with the newtype statement by giving a name for our
    new type and defining the underlying type that our new type is based on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以通过使用newtype语句并给出我们新类型的名称以及定义新类型基于的基本类型来声明一个新的UDT（用户定义类型）。
- en: ❷ We can give names to the various items in a UDT using the same syntax as declaring
    the signature for an operation or a function. Here, the new UDT has a single item
    named Apply that allows for calling the operation wrapped by ScalableOperation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们可以使用与声明操作或函数签名相同的语法为UDT中的各种项命名。在这里，新的UDT有一个名为`Apply`的单个项，它允许调用被`ScalableOperation`包装的操作。
- en: ❸ Once defined, we can use a new UDT like any other type. Here, we define a
    function that outputs values of type ScalableOperation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一旦定义，我们就可以像使用任何其他类型一样使用新的UDT。在这里，我们定义了一个输出`ScalableOperation`类型值的函数。
- en: ❹ We can easily make output values by calling ScalableOperation with the operation
    to be wrapped in our new UDT. In this example, we can create new instances of
    ScalableOperation using the same partial application of ApplyScaledRotation that
    we saw earlier in the chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们可以通过调用ScalableOperation来轻松创建输出值，这个操作将被我们新的UDT包装。在这个例子中，我们可以使用我们在本章前面看到的相同部分应用`ApplyScaledRotation`来创建新的`ScalableOperation`实例。
- en: Tip When we define inputs to functions and operations in Q#, those inputs have
    names that start with lowercase letters. In listing 9.6, however, the named item
    `Apply` in `ScalableOperation` starts with an uppercase letter. This is because
    the inputs to a function or operation only have meaning within that callable,
    while named items mean something more broadly. We can use the capitalization of
    inputs and named items to make it obvious where to look for their definitions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当我们定义Q#中函数和操作的输入时，这些输入的名称以小写字母开头。然而，在列表9.6中，`ScalableOperation`中的命名项`Apply`以大写字母开头。这是因为函数或操作的输入只在其可调用范围内有意义，而命名项则具有更广泛的意义。我们可以使用输入和命名项的大小写来明确它们的定义位置。
- en: The function `HiddenRotation` defined in listing 9.6 helps us implement Lancelot’s
    and Dagonet’s game by giving us a way for Dagonet to hide his angle. Calling `HiddenRotation`
    with Dagonet’s angle returns a new `ScalableOperation` that Lancelot can call
    to gather the data he needs to guess the hidden angle. Figure 9.5 shows Dagonet’s
    new game setup.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6中定义的函数`HiddenRotation`帮助我们通过为Dagonet隐藏他的角度提供了一种方式来实现Lancelot和Dagonet的游戏。使用Dagonet的角度调用`HiddenRotation`会返回一个新的`ScalableOperation`，Lancelot可以调用它来收集他猜测隐藏角度所需的数据。图9.5展示了Dagonet新的游戏设置。
- en: '![](../Images/9-5.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-5.png)'
- en: Figure 9.5 Playing Dagonet’s guessing game with partial application and UDTs.
    Dagonet uses a function to construct the UDT that he passes to Lancelot, representing
    the rotation with his hidden angle.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：使用部分应用和UDT玩Dagonet的猜测游戏。Dagonet使用一个函数来构造他传递给Lancelot的UDT，代表他的隐藏角度的旋转。
- en: 'With some new types and a way for Dagonet to hide his angle, let’s continue
    implementing the rest of the game! We have everything we need for the next step:
    estimating the probability of each measurement we make during Lancelot’s and Dagonet’s
    game. This is very similar to how we would estimate the probability of flipping
    a coin; see figure 9.6.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了新的类型和Dagonet隐藏他的角度的方法之后，让我们继续实现游戏的其余部分！我们已经为下一步做好了准备：估计Lancelot和Dagonet游戏中我们进行的每次测量的概率。这与估计抛硬币的概率非常相似；见图9.6。
- en: '![](../Images/9-6.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-6.png)'
- en: Figure 9.6 Lancelot’s estimation is similar to estimating the outcome of a coin
    flip. He can estimate the bias of a coin by flipping it many times and counting
    the number of “heads.” Similarly, Lancelot can prepare the same qubit in the same
    state many times, measure it each time, and count the measurement outcomes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 兰斯洛特的估计类似于估计抛硬币的结果。他可以通过多次抛硬币并计数“正面”来估计硬币的偏差。同样，兰斯洛特可以多次准备处于相同状态的相同量子比特，每次都对其进行测量，并计数测量结果。
- en: Let’s see what the code will look like for this flipping estimation procedure
    in Dagonet’s game. Note that since Lancelot and Dagonet agreed that the *Z*-axis
    should be the rotation axis for their game, Lancelot can prepare his target qubit
    in the |+〉 state so that Dagonet’s rotation does something.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在达贡特的游戏中，这个抛硬币估计过程在代码中会是什么样子。注意，由于兰斯洛特和达贡特同意 *Z*- 轴应该是他们游戏的旋转轴，兰斯洛特可以准备他的目标量子比特处于
    |+〉 状态，以便达贡特的旋转能够发挥作用。
- en: 'Listing 9.7 operations.qs: estimating the probability of measuring |1〉'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 operations.qs：估计测量 |1〉 的概率
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Lancelot’s operation needs to take in a Double value representing what scale
    he picks to run the operation given to him by Dagonet.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 兰斯洛特的操作需要接收一个 Double 类型的值，表示他选择的缩放值来运行达贡特给他的操作。
- en: ❷ Lancelot picks a number of times to measure his qubit to get his estimate
    of the probability.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 兰斯洛特选择测量他的量子比特的次数，以得到他对概率的估计。
- en: ❸ The last input is of type ScalableOperation, the UDT declared earlier in the
    chapter. This input represents the operation that Dagonet gives Lancelot.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 最后一个输入是 ScalableOperation 类型，本章前面声明的 UDT。这个输入代表达贡特给兰斯洛特的操作。
- en: ❹ As output, Lancelot wants to return an estimated probability, so we can declare
    that as a Double output.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 作为输出，兰斯洛特希望返回一个估计的概率，因此我们可以将其声明为一个 Double 类型的输出。
- en: ❺ To keep track of the number of |1〉 outcomes observed so far, we define a mutable
    variable with the Int value 0.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为了跟踪到目前为止观察到的 |1〉 结果的数量，我们定义一个具有 Int 值 0 的可变变量。
- en: ❻ For each measurement, we need to allocate a qubit that’s the target for Dagonet’s
    operation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于每次测量，我们需要分配一个量子比特，它是达贡特操作的靶子。
- en: ❼ Uses the “within” and “apply” keywords for the shoes-and-socks pattern we
    learned about in chapter 8
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用我们在第 8 章中学到的“鞋子与袜子”模式中的“within”和“apply”关键字
- en: ❽ Implements Lancelot’s strategy by using the H operation to prepare a qubit
    in the |+〉 state
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 通过使用 H 操作来准备处于 |+〉 状态的量子比特来实现兰斯洛特的策略
- en: ❾ Once we have prepared the input to Dagonet’s operation, we call it by using
    ::Apply to unwrap the ScalableOperation UDT.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 准备好达贡特操作的输入后，我们通过使用 ::Apply 来调用它，以展开 ScalableOperation UDT。
- en: '❿ The ?| ternary operator (much like the if ... else operator in Python or
    the ?: operator in C, C++, and C#) provides a convenient way to increment nOnes.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '❿ ?| 三元运算符（类似于 Python 中的 if ... else 运算符或在 C、C++ 和 C# 中的 ?: 运算符）提供了一个方便的方式来增加
    nOnes。'
- en: ⓫ To get our final estimate of the probability of measuring |1〉, we calculate
    the ratio of Ones to total counts. The function Convert.IntAsDouble helps us return
    a floating-point number.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 为了得到测量 |1〉 的概率的最终估计，我们计算“1”的数量与总计数之比。函数 Convert.IntAsDouble 帮助我们返回一个浮点数。
- en: In listing 9.7, the `within`/`apply` block makes sure Lancelot’s qubit is back
    in the right axis. We can count how many times the final measurement returns a
    `One` result by adding either `1` or `0` to `nOnes`. Here, the `?|` ternary operator
    (much like the `if ... else` operator in Python or the `?:` operator in C, C++,
    and C#) provides a convenient way to increment `nOnes`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.7 中，`within`/`apply` 块确保兰斯洛特的量子比特回到了正确的轴。我们可以通过将 `1` 或 `0` 添加到 `nOnes`
    中来计数最终测量返回 `One` 结果的次数。在这里，`?|` 三元运算符（类似于 Python 中的 `if ... else` 运算符或在 C、C++
    和 C# 中的 `?:` 运算符）提供了一个方便的方式来增加 `nOnes`。
- en: An operation by any other name
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他名称的操作
- en: 'You may have noticed that operations tend to be named using verbs, while functions
    tend to be named as nouns. This helps with remembering the distinction you saw
    in chapter 7: a function *is* something, while an operation *does* something.
    Being consistent with names can help you make sense of how a quantum program works,
    so Q# uses conventions like this throughout the language and libraries.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，操作通常使用动词命名，而函数通常使用名词命名。这有助于记住你在第 7 章中看到的区别：函数 *是* 某物，而操作 *做* 某事。与名称的一致性可以帮助你理解量子程序的工作方式，因此
    Q# 在整个语言和库中使用了这样的约定。
- en: With this in place, we can now write an operation that runs the whole game and
    returns everything Lancelot needs to guess Dagonet’s hidden angle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们现在可以编写一个运行整个游戏并返回 Lancelot 需要猜测 Dagonet 隐藏角度的所有内容的操作。
- en: 'Listing 9.8 operations.qs: running the complete game'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 operations.qs：运行整个游戏
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Makes a new ScalableOperation value that hides Dagonet’s angle using the HiddenRotation
    function we wrote earlier
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用我们之前编写的 HiddenRotation 函数创建一个新的 ScalableOperation 值，以隐藏 Dagonet 的角度
- en: ❷ The ForEach operation in Microsoft.Quantum.Arrays (which we gave the shorthand
    name Arrays) takes an operation and applies it to every element of the scales
    array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Microsoft.Quantum.Arrays 中的 ForEach 操作（我们给它简称为 Arrays）接收一个操作并将其应用于 scales
    数组的每个元素。
- en: ❸ To get the operation we pass to ForEach, we use partial application to lock
    down how many measurements Lancelot does at each different scale and what hidden
    operation he was given by Dagonet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 要获取传递给 ForEach 的操作，我们使用部分应用来锁定 Lancelot 在每个不同尺度上进行的测量次数以及 Dagonet 给他的隐藏操作。
- en: ❹ When we pass “scales” as the second input to ForEach, each element of “scales”
    is substituted into the partial application slot _.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当我们将“scales”作为 ForEach 的第二个输入时，将“scales”的每个元素替换到部分应用的槽位 _ 中。
- en: Note It may seem funny that `ForEach` acts like `map` in Python and other languages
    when Q# also has `Microsoft.Quantum.Arrays.Mapped`. The critical difference is
    that `ForEach` takes an operation, while `Mapped` takes a function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当 Q# 也拥有 `Microsoft.Quantum.Arrays.Mapped` 时，`ForEach` 在 Python 和其他语言中表现得像
    `map`，这可能会显得有些奇怪。关键的区别在于 `ForEach` 接收一个操作，而 `Mapped` 接收一个函数。
- en: For Lancelot to actually make sense of all the data he gets out of his Q# program,
    it might help to use some good old classical data science techniques. Since Python
    is great at that, running our new `RunGame` operation from a Python host program
    can be an excellent way to help Lancelot.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Lancelot 真正理解他从 Q# 程序中获取的所有数据，使用一些经典的数据科学技术可能会有所帮助。由于 Python 在这方面非常出色，从
    Python 主程序运行我们的新 `RunGame` 操作可以是一个帮助 Lancelot 的绝佳方式。
- en: '9.3 Run, snake, run: Running Q# from Python'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 运行，蛇行，跑：从 Python 运行 Q#
- en: 'In previous chapters, we ran our Q# code in a Jupyter Notebook with a Q# kernel.
    In this chapter, we want to look at a different way to run Q# code: from Python.
    Calling Q# from Python can be helpful in different scenarios, especially if we
    want to preprocess data before using it in Q#, or if we want to visualize the
    output from our quantum program.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们在带有 Q# 内核的 Jupyter Notebook 中运行了我们的 Q# 代码。在本章中，我们想探讨另一种运行 Q# 代码的方法：从
    Python。从 Python 调用 Q# 在不同的场景中可能很有帮助，尤其是如果我们想在 Q# 中使用数据之前先预处理数据，或者如果我们想可视化量子程序的结果。
- en: 'Let’s start writing the files to implement Dagonet and Lancelot’s game. To
    try the Q# and Python interop, we will use a Python host program to run the Q#
    program. This means we will have two files for the game: operations.qs and a host.py
    file that we will use directly to run the game. Let’s dive into the host.py file
    to see how we can interact with Q# from Python; see figure 9.7.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写实现 Dagonet 和 Lancelot 游戏的文件。为了尝试 Q# 和 Python 的互操作性，我们将使用一个 Python 宿主程序来运行
    Q# 程序。这意味着我们将为游戏有两个文件：operations.qs 和一个 host.py 文件，我们将直接使用它来运行游戏。让我们深入 host.py
    文件，看看我们如何从 Python 与 Q# 交互；见图 9.7。
- en: '![](../Images/9-7.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/9-7.png)'
- en: Figure 9.7 Using host programs for Q# written in Python. Like the Jupyter Notebook
    host, a Python program can coordinate sending the Q# program to a particular target
    machine and collecting the results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 使用 Python 编写的宿主程序来运行 Q#。像 Jupyter Notebook 宿主一样，Python 程序可以协调将 Q# 程序发送到特定的目标机器并收集结果。
- en: All of the interoperable functionality we need between Python and Q# is provided
    by the `qsharp` Python package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 和 Q# 之间，我们需要的所有互操作性功能都由 `qsharp` Python 包提供。
- en: Tip Appendix A has full installation instructions for the `qsharp` Python package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：附录 A 包含 `qsharp` Python 包的完整安装说明。
- en: Once we have the `qsharp` package, we can import it just like any other Python
    package. Let’s look at a small sample Python file where we can see this in action.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `qsharp` 包，我们就可以像导入其他 Python 包一样导入它。让我们看看一个小型的 Python 文件，我们可以看到这个动作是如何发生的。
- en: 'Listing 9.9 qsharp-interop.py: using Q# code directly in Python'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 qsharp-interop.py：直接在 Python 中使用 Q# 代码
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ The qsharp Python package needs to be imported just like any other Python
    package.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ qsharp Python 包需要像其他 Python 包一样导入。
- en: ❷ Uses the qsharp.compile Python function to take a string containing Q# code
    and compile it for use in the Python file
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 qsharp.compile Python 函数将包含 Q# 代码的字符串编译成 Python 文件中使用的格式
- en: ❸ Just like a regular Q# file, we need to include open statements to use the
    different parts of the Q# standard library.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正如常规的 Q# 文件一样，我们需要包含打开语句来使用 Q# 标准库的不同部分。
- en: ❹ The operation this string of Q# code describes simply prepares a qubit in
    the |0〉 state and uses DumpMachine to show what the target machine knows about
    that qubit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这个 Q# 代码字符串描述的操作只是将量子比特准备在 |0〉 状态，并使用 DumpMachine 显示目标机器对该量子比特的了解。
- en: ❺ We also want to use the callable defined as prepare_qubit, so we can use the
    simulate method from the qsharp package, which runs previously compiled Q# code
    snippets.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们还希望使用定义为 prepare_qubit 的可调用函数，这样我们就可以使用 qsharp 包中的 simulate 方法，该方法运行之前编译的
    Q# 代码片段。
- en: Let’s try running the qsharp-interop.py script from listing 9.9.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行 9.9 列表中的 qsharp-interop.py 脚本。
- en: Listing 9.10 Running listing 9.9
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 运行 9.9 列表
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip If you are running code from a Q# Jupyter Notebook, the Q# snippet’s output
    will look different. See figure 9.9 later in the chapter for an example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您从 Q# Jupyter Notebook 运行代码，Q# 片段的输出将看起来不同。请参见本章后面的图 9.9 中的示例。
- en: From the output in listing 9.10, we can see that it does indeed prepare a |0〉
    state, as the only term in the output that has a coefficient of `1.0` is the |0〉
    state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从 9.10 列表中的输出中，我们可以看到它确实准备了一个 |0〉 状态，因为输出中唯一具有系数 `1.0` 的项是 |0〉 状态。
- en: The `qsharp` Python package also looks for Q# operations or functions defined
    in `*.qs` files in the same directory as our Python program. In this case, as
    we proceed through the rest of this chapter, we’ll add things to a Q# file called
    operations.qs. This is a pretty convenient way to start our host.py file for the
    game. The loaded `qsharp` package then allows us to import operations and functions
    from namespaces in Q# files in the same directory as host.py. We saw `RunGame`
    previously and will see `RunGameUsingControlledRotations` shortly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`qsharp` Python 包也会在包含我们的 Python 程序的同一目录中查找定义在 `*.qs` 文件中的 Q# 操作或函数。在这种情况下，随着我们继续本章的其余部分，我们将向名为
    operations.qs 的 Q# 文件中添加内容。这是一种开始游戏 host.py 文件相当方便的方法。加载的 `qsharp` 包然后允许我们从与 host.py
    同一目录中的 Q# 文件命名空间导入操作和函数。我们之前看到了 `RunGame`，很快我们也会看到 `RunGameUsingControlledRotations`。'
- en: 'Listing 9.11 host.py: the start of the phase estimation game'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 host.py：相位估计游戏的开始
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Imports the Q# Python package
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 Q# Python 包。
- en: ❷ Imports RunGame and RunGameUsingControlledRotations operations from operations.qs
    to automatically create Python objects representing each Q# operation that we
    import
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 operations.qs 中导入 RunGame 和 RunGameUsingControlledRotations 操作，以自动创建代表我们导入的每个
    Q# 操作的 Python 对象。
- en: ❸ The rest of the imports help with type hinting in Python, visualizing the
    results of our Q# simulation, and fitting measurement data to get Lancelot’s final
    guess.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 其余的导入有助于 Python 中的类型提示、可视化 Q# 模拟的结果以及将测量数据拟合以获得 Lancelot 的最终猜测。
- en: 'Now that we have imported and set up our Python file, let’s write `run_game_at_
    scales`: the function that calls the Q# operations.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入并设置了我们的 Python 文件，让我们编写 `run_game_at_scales`：调用 Q# 操作的函数。
- en: 'Listing 9.12 host.py: the Python function that calls Q# operations'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 host.py：调用 Q# 操作的 Python 函数
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Sets the return type hint to Any, which tells Python not to worry about type
    checking the return value of this function
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将返回类型提示设置为 Any，这告诉 Python 不要担心检查此函数的返回值类型。
- en: ❷ Dagonet chooses the hidden angle that he wants Lancelot to guess.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Dagonet 选择了他希望 Lancelot 猜测的隐藏角度。
- en: ❸ The return for run_game_at_scales is conditioned on control, which allows
    us to choose between two simulations we will develop for this game (we use control=False
    for now).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ run_game_at_scales 的返回值取决于控制条件，这允许我们在为这个游戏开发的两个模拟之间进行选择（我们现在使用 control=False）。
- en: ❹ When qsharp imports these operations, their Python representations have a
    method called “simulate” that takes the required arguments and passes them along
    to the Q# simulator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当 qsharp 导入这些操作时，它们的 Python 表示形式有一个名为“simulate”的方法，该方法接受所需的参数并将它们传递给 Q# 模拟器。
- en: 'This Python file should be runnable as a script, so we also need to define
    `__main__`. This is where we can do what Lancelot does in his head by using our
    host program in Python to take the measurements and scales and fit them to a model
    for Dagonet’s rotation. The best model for how the rotation angle changes the
    measurement results is given by where *θ* is Dagonet’s hidden angle and `scale`
    is Dagonet’s scale factor:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此Python文件应可作为脚本运行，因此我们还需要定义`__main__`。这就是我们可以在Python中使用宿主程序执行兰斯洛特在心中所做的事情，通过测量和刻度并拟合它们到Dagonet的旋转模型。旋转角度如何改变测量结果的最佳模型由以下公式给出，其中*θ*是Dagonet的隐藏角度，`scale`是Dagonet的缩放因子：
- en: '![](../Images/equation_9-1.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![方程式9-1](../Images/equation_9-1.png)'
- en: 'Exercise 9.2: Born again'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.2：重生
- en: This model can be found if we use Born’s rule! The definition from chapter 2
    is shown next. See if you can plot the resulting value as a function of Lancelot’s
    scale using Python. Does your plot look like a trigonometric function?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用波恩规则，就可以找到这个模型！第2章的定义如下。看看你是否可以用Python绘制结果值作为兰斯洛特刻度的函数。你的图表看起来像三角函数吗？
- en: Pr(measurement|state) = (〈measurement | state〉)|²
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 测量概率|状态> = (〈测量|状态〉)|²
- en: '*Hint:* For Lancelot’s measurements, the 〈measurement| part of Born’s rule
    is given by 〈1|. Immediately before measuring, his qubit is in the state *HR*[1]
    ( *θ* * scale) *H*|0〉. You can simulate the `R1` operation in QuTiP by using the
    matrix form in the Q# reference at [https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1](https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示:* 对于兰斯洛特的测量，波恩规则中的〈测量|部分由〈1|给出。在测量之前，他的量子比特处于状态*HR*[1]（*θ* * scale）*H|0〉。你可以通过使用Q#参考中的矩阵形式来模拟QuTiP中的`R1`操作，[https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1](https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.intrinsic.r1)。'
- en: Once we have that model and data, we can use the `scipy.optimize` function from
    the SciPy Python package to fit our data to the model. The value it finds for
    the *θ* parameter is Dagonet’s hidden angle! The next listing shows an example
    of how to pull this all together.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个模型和数据，我们就可以使用SciPy Python包中的`scipy.optimize`函数将我们的数据拟合到模型。它找到的*θ*参数值是Dagonet的隐藏角度！下一个列表显示了如何将这些全部组合起来的示例。
- en: 'Listing 9.13 host.py: running host.py as a script'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 host.py：以脚本方式运行host.py
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ This script plots the data and fitted results, so we need to import the friendly
    matplotlib.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此脚本绘制数据和拟合结果，因此我们需要导入友好的matplotlib库。
- en: ❷ Lancelot’s list of inputs to the game (that is, his scales) are generated
    as a regularly spaced, sequential list of numbers from np.linspace.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 兰斯洛特的输入列表（即他的刻度）由np.linspace生成的等间距、顺序数字列表生成。
- en: ❸ This script runs both versions of the game simulation so they can be compared.
    Don’t worry about the control = True case for now; we’ll come back to that shortly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此脚本运行游戏模拟的两个版本，以便进行比较。现在不用担心control = True的情况；我们很快就会回到这个问题。
- en: ❹ Stores the result from the Q# simulation that runs from Python in run_game_at_scales
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在run_game_at_scales中存储从Python运行的Q#模拟的结果
- en: ❺ Represents the operation on the qubit. Lancelot can take the data he gets,
    fit it to the model, and extract a guess for the angle.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 表示对量子比特的操作。兰斯洛特可以获取数据，将其拟合到模型中，并提取角度的猜测。
- en: ❻ The standard scipy function optimization.curve_fit takes a model of a function,
    inputs, measured data, and an initial guess to try to fit all the parameters of
    the model.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 标准的scipy函数optimization.curve_fit接受一个函数模型、输入、测量数据和初始猜测，以尝试拟合模型的全部参数。
- en: ❼ Validating the fit found by optimization.curve_fit is important so we can
    plot both the data and the fitted model to see if it looks right.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 验证由optimization.curve_fit找到的拟合结果非常重要，这样我们就可以绘制数据和拟合模型，看看它是否看起来正确。
- en: ❽ Displays the plots with the data and fit in a new window
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在新窗口中显示数据和拟合的图表
- en: Now that we have a host program we can use to run the whole game, we can see
    that Lancelot does a pretty reasonable job of figuring out what angle Dagonet
    hid in his Q# operation. By taking different measurements and using classical
    data science techniques, Lancelot can estimate the phase that Dagonet’s operation
    applies to his qubits. Running host.py should generate two pop-up windows that
    show plots of the measurement probabilities as a function of Lancelot’s scale
    for two strategies he can use (figure 9.8). The first is the approach we have
    already outlined. We’ll implement the latter in the last section of the chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以运行整个游戏的宿主程序，我们可以看到兰斯洛特在推断达戈内特在其Q#操作中隐藏的角度方面做得相当合理。通过进行不同的测量并使用经典的数据科学技术，兰斯洛特可以估算达戈内特操作对其量子比特施加的相位。运行host.py应该会生成两个弹出窗口，显示测量概率作为兰斯洛特两个可用策略的缩放函数的图表（图9.8）。第一个是我们已经概述的方法。我们将在本章的最后部分实现后者。
- en: '![](../Images/9-8.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-8.png)'
- en: Figure 9.8 An example of one of the two plots that should pop up when we run
    host.py
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 当我们运行host.py时应该弹出的两个图表之一
- en: 'Tip Since the SciPy fitting packages are not perfect, sometimes the fitted
    parameter it finds isn’t right. Run it a few times, and hopefully the fitting
    algorithm will do better the next time. If you have any questions about the plotting
    package `matplotlib`, check out these other titles from Manning: *Data Science
    Bootcamp* (chapter 2; by Leonard Apeltsin; forthcoming), and *Data Science with
    Python and Dask* (chapters 7 and 8; by Jesse C. Daniel; 2019).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 由于SciPy拟合包并不完美，有时它找到的拟合参数可能不正确。运行几次，希望拟合算法在下一次会做得更好。如果你对绘图包`matplotlib`有任何疑问，请查看Manning出版的这些其他标题：*数据科学训练营*（第2章；由Leonard
    Apeltsin编写；即将出版），以及*使用Python和Dask进行数据科学*（第7章和第8章；由Jesse C. Daniel编写；2019年）。
- en: We can see from these plots that we were able to fit Lancelot’s data fairly
    well. That means the fitted value we find in `angle_guess` is a pretty good approximation
    of Dagonet’s hidden angle!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些图表中我们可以看出，我们能够相当好地拟合兰斯洛特的数据。这意味着我们在`angle_guess`中找到的拟合值是达戈内特隐藏角度的一个相当好的近似值！
- en: 'There’s still one more nagging problem with Lancelot’s strategy, though: every
    time he performs a measurement, he needs to prepare the right input to pass to
    Dagonet’s operation. In this particular game, that may not be much of a problem,
    but as we explore bigger applications of this game in the next chapter, it can
    be expensive to prepare the input register in the right state every time. Fortunately,
    we can use *controlled operations* to reuse the same inputs over and over again,
    as we’ll see in the rest of this chapter.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，兰斯洛特策略中还有一个令人烦恼的问题：每次他进行测量时，他都需要准备正确的输入传递给达戈内特的操作。在这个特定的游戏中，这可能不是什么大问题，但当我们探索下一章中这个游戏的更大应用时，每次都正确准备输入寄存器可能会很昂贵。幸运的是，我们可以使用*控制操作*一次又一次地重复使用相同的输入，正如我们将在本章的其余部分看到的那样。
- en: 'You have seen examples of controlled operations already (like CNOT), but it
    turns out many other quantum operations can also be applied conditionally, which
    can be very useful. Controlled operations, along with the last new quantum computing
    concept we need (eigenstates), will help us to implement a technique we saw at
    the end of chapter 8: phase kickback.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了控制操作的例子（如CNOT），但结果证明，许多其他量子操作也可以条件性地应用，这可以非常有用。控制操作，以及我们需要的最后一个新量子计算概念（本征态），将帮助我们实现我们在第8章末看到的技巧：相位回弹。
- en: Tip There is a lot of discussion about local and global phases in the next few
    sections. Recall that global phase is a complex coefficient that can be factored
    out of all the terms of our state and cannot be observed. If you need a refresher
    on phase, check out chapters 4–6\.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 在接下来的几节中有很多关于局部和全局相位的讨论。回想一下，全局相位是一个可以从我们状态的所有项中提取的复系数，且无法观察到。如果你需要关于相位的复习，请查看第4-6章。
- en: 9.4 Eigenstates and local phases
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 本征态和局部相位
- en: By now, we’ve seen that the `X` quantum operation allows us to flip bits (|0〉
    ![](../Images/emoji-harrow.png) |1〉) and that the `Z` operation allows us to flip
    phases (|+〉 ![](../Images/emoji-harrow.png) |−〉). Both of these operations, though,
    only apply global phases to some input states. As we saw in previous chapters,
    we can’t actually learn anything about global phases, so understanding what states
    each operation leaves alone is essential to understanding what we can learn by
    applying that operation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到 `X` 量子操作允许我们翻转比特（|0〉 ![](../Images/emoji-harrow.png) |1〉），而 `Z`
    操作允许我们翻转相位（|+〉 ![](../Images/emoji-harrow.png) |−〉）。然而，这两个操作都只对某些输入状态应用全局相位。正如我们在前面的章节中看到的，我们实际上无法了解全局相位，因此了解每个操作留下哪些状态不变对于理解应用该操作可以学到什么至关重要。
- en: For example, let’s revisit the `Z` operation. In the following listing, we can
    see what happens when we try to use `Z` not to flip a qubit between the |+〉 and
    |−〉 states, but on an input qubit in the |0〉 state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回顾一下 `Z` 操作。在下面的列表中，我们可以看到当我们尝试使用 `Z` 来翻转处于 |+〉 和 |−〉 状态之间的 `qubit`，而不是在输入
    `qubit` 处于 |0〉 状态时会发生什么。
- en: Listing 9.14 Applying `Z` to a qubit in the |0〉 state
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 将 `Z` 应用于处于 |0〉 状态的 `qubit`
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ As usual in Q#, we start by allocating a Qubit with a use statement. This
    provides a fresh qubit in the |0〉 state.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Q# 中，我们通常首先通过使用语句分配一个 Qubit。这提供了一个新的处于 |0〉 状态的 `qubit`。
- en: ❷ Applies a Z operation, such that the qubit’s state is transformed to *Z*|0〉
    = |0〉
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用一个 Z 操作，使得 `qubit` 的状态转换为 *Z*|0〉 = |0〉
- en: ❸ To confirm that the Z operation didn’t do anything, we use the DumpRegister
    function to instruct the simulator to print out the full state vector.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了确认 `Z` 操作没有做任何事情，我们使用 DumpRegister 函数来指示模拟器打印出完整的态矢量。
- en: ❹ Resets the qubit before releasing it. This isn’t strictly needed since we
    know beforehand that the qubit is still in the |0〉 state.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在释放 `qubit` 之前重置它。这不是严格必要的，因为我们事先知道 `qubit` 仍然处于 |0〉 状态。
- en: In listing 9.14, we can confirm that the `Z` operation didn’t do anything by
    using the `DumpRegister` function to instruct the simulator to print out all of
    its diagnostic information—in this case, the full state vector. Figure 9.9 shows
    what this diagnostic printout looks like.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 9.14 中，我们可以通过使用 `DumpRegister` 函数来指示模拟器打印出所有诊断信息（在这种情况下，完整的态矢量）来确认 `Z` 操作没有做任何事情。图
    9.9 显示了这种诊断打印输出的样子。
- en: Tip If we run this on a target machine other than a simulator, we get not a
    state vector but whatever other diagnostics the machine offers (e.g., hardware
    IDs).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果我们在一个不是模拟器的目标机器上运行此操作，我们得到的是一个状态矢量，而不是机器提供的其他诊断信息（例如，硬件 ID）。
- en: '![](../Images/9-9.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-9.png)'
- en: Figure 9.9 Output of running listing 9.14
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 列表 9.14 的输出
- en: Note that in listing 9.14, `Z` doesn’t do anything to `qubit` since *Z*|0〉 =
    |0〉. If we modify the listing to prepare |1〉 instead by using `X` before `Z`,
    we see something very similar.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在列表 9.14 中，`Z` 对 `qubit` 没有任何作用，因为 *Z*|0〉 = |0〉。如果我们修改列表以通过在 `Z` 前使用 `X`
    来准备 |1〉，我们会看到非常相似的情况。
- en: Listing 9.15 Applying `Z` to a qubit in the |1〉 state
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 将 `Z` 应用于处于 |1〉 状态的 `qubit`
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ As before, to prepare a |1〉 state, we can use that |1〉 = *X*|0〉.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述，为了准备 |1〉 状态，我们可以使用 |1〉 = *X*|0〉。
- en: ❷ Repeats our experiment from above, but with a different input
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 重复我们上面的实验，但使用不同的输入
- en: ❸ As before, we can write the state of qubit to a text file, using that we’re
    running on a simulator that keeps the state internally.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如前所述，我们可以将 `qubit` 的状态写入一个文本文件，因为我们正在运行一个内部保持状态的模拟器。
- en: 'The output is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ This file represents the vector [[0], [–1]], or –|1〉 in Dirac notation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此文件表示向量 [[0], [–1]]，或狄拉克表示法中的 –|1〉。
- en: The effect of applying the `Z` operation to a |1〉 state is to flip the sign
    of the state of `qubit`. This is another example of a *global phase*, as we saw
    in chapters 6 and 8.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Z` 操作应用于 |1〉 态的效果是翻转 `qubit` 的状态符号。这是另一个 *全局相位* 的例子，正如我们在第 6 章和第 8 章中看到的。
- en: Whenever two states |*Ψ*〉 and |*ϕ*〉 are only different by a complex number *e^(iθ)*,
    |*ϕ*〉 = *e^(iθ)* |*Ψ*〉, we say that |*Ψ*〉 and |*ϕ*〉 vary by a *global phase*.
    For example, |0〉 and –|0〉 differ by a global phase of –1 = *e*^(*iπ*).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个状态 |*Ψ*〉 和 |*ϕ*〉 仅通过一个复数 *e^(iθ)* 不同时，|*ϕ*〉 = *e^(iθ)* |*Ψ*〉，我们说 |*Ψ*〉 和
    |*ϕ*〉 通过一个 *全局相位* 变化。例如，|0〉 和 –|0〉 通过全局相位 –1 = *e*^(*iπ*) 不同。
- en: The global phase of a state doesn’t affect any measurement probabilities, so
    we cannot ever detect whether we applied a `Z` operation when its input is in
    either the |0〉 or |1〉 state. We can confirm this by using the `AssertQubit` operation,
    which checks the probability of a particular measurement result.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的全局相位不会影响任何测量概率，因此我们永远无法检测到当输入处于 |0〉 或 |1〉 状态时是否应用了 `Z` 操作。我们可以通过使用 `AssertQubit`
    操作来确认这一点，该操作检查特定测量结果的概率。
- en: Listing 9.16 Using `AssertQubit` to check a measurement result
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 使用 `AssertQubit` 检查测量结果
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Checks that measuring the qubit returns the result Zero, and terminates the
    program if that’s not the case
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查测量量子比特返回的结果是否为零，如果不是，则终止程序
- en: ❷ After this, the qubit is in the –|0〉 state as opposed to the |0〉 state. That
    is, the Z operation applies a global phase to the state of qubit.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 之后，量子比特处于 –|0〉 状态，而不是 |0〉 状态。也就是说，Z 操作对该量子比特的状态应用了一个全局相位。
- en: ❸ Calls AssertQubit again to check that the probability of obtaining a Zero
    result is still 1
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 再次调用 AssertQubit 以检查获得零结果的概率仍然是 1
- en: ❹ Prints a message to check that the quantum program proceeds past both assertions
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 打印一条消息以检查量子程序是否通过了这两个断言
- en: Running this snippet simply prints `Passed test!` since the calls to `AssertQubit`
    don’t do anything in the case that the assertion succeeds. Using assertions like
    this lets us write unit tests that use simulators to confirm our understanding
    of how particular quantum programs behave. On actual quantum hardware, since we
    can’t do this kind of check due to the no-cloning theorem, assertions can be safely
    stripped out.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段仅简单地打印 `Passed test!`，因为当断言成功时，对 `AssertQubit` 的调用并不做任何事情。使用这种断言，我们可以编写使用模拟器来确认我们对特定量子程序行为的理解的单元测试。在实际的量子硬件上，由于克隆定理，我们无法进行此类检查，因此可以安全地删除断言。
- en: Important Assertions can be really useful tools for writing unit tests and checking
    the correctness of our quantum programs. That said, it’s important to remember
    that they will be stripped out when running our program on actual quantum hardware,
    so we don’t use assertions to *make* our program run correctly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的断言可以是编写单元测试和检查量子程序正确性的非常有用的工具。尽管如此，重要的是要记住，当我们在实际的量子硬件上运行程序时，它们将被删除，所以我们不使用断言来
    *使* 程序运行正确。
- en: Of course, this is also just good programming practice; assertions in classical
    languages like Python can often be disabled for performance reasons, such that
    we can’t rely on assertions always being there for us.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这同样是良好的编程实践；在像 Python 这样的经典语言中，断言有时可以因为性能原因而被禁用，这样我们就不能依赖断言始终存在。
- en: Identifying which quantum states are assigned global phases by an operation
    `U` gives us a way to understand that quantum operation’s behavior. We call such
    states *eigenstates* of the operation `U`. If two operations have the same eigenstates
    and apply the same global phases to each of those eigenstates, there is no way
    to tell those two operations apart—just as if two classical functions have the
    same truth table, we can’t tell which one is which, no matter what state our qubits
    are in when we apply each operation. This means we can understand operations not
    only by a matrix representation of them, but also by understanding what their
    eigenstates are and what global phase the operation applies to each. As we have
    seen, we cannot directly learn about the global phase of a qubit; so in the next
    section, we’ll learn how to use controlled versions of an operation to turn that
    global phase into a local one we can measure. For now, though, let’s summarize
    with a more formal definition of what an eigenstate is.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过识别操作 `U` 分配给量子态的全局相位的量子态，我们获得了一种理解该量子操作行为的方法。我们称这些状态为操作 `U` 的 *本征态*。如果两个操作具有相同的本征态，并且对每个本征态应用相同的全局相位，那么我们无法区分这两个操作——就像两个经典函数具有相同的真值表一样，无论我们在应用每个操作时量子比特处于何种状态，我们都无法判断哪个是哪个。这意味着我们不仅可以通过它们的矩阵表示来理解操作，还可以通过理解它们的本征态以及操作应用于每个本征态的全局相位来理解操作。正如我们所见，我们无法直接了解量子比特的全局相位；因此，在下一节中，我们将学习如何使用操作的受控版本将全局相位转换为可测量的局部相位。然而，现在，让我们用一个更正式的定义来总结什么是本征态。
- en: If, after applying an operation `U`, the state of a register of qubits `qs`
    is only modified by a global phase, we say that the state of that register is
    an *eigenstate* of `U`. For example, |0〉 and |1〉 are both eigenstates of the `Z`
    operation. Similarly, |+〉 and |−〉 are both eigenstates of `X`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用操作 `U` 之后，量子比特寄存器 `qs` 的状态仅通过全局相变而修改，那么我们说该寄存器的状态是 `U` 的 *本征态*。例如，|0〉 和
    |1〉 都是 `Z` 操作的本征态。同样，|+〉 和 |−〉 都是 `X` 的本征态。
- en: Try the next exercise to practice working with eigenstates.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试下一项练习来练习使用本征态。
- en: 'Exercise 9.3: Diagnostic practice'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.3：诊断练习
- en: 'Try writing Q# programs that use `AssertQubit` and `DumpMachine` to verify
    the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写使用 `AssertQubit` 和 `DumpMachine` 的 Q# 程序来验证以下内容：
- en: '|+〉 and |−〉 are both eigenstates of the `X` operation.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '|+〉 和 |−〉 都是 `X` 操作的本征态。'
- en: '|0〉 and |1〉 are both eigenstates of the `Rz` operation, regardless of what
    angle you choose to rotate by.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '|0〉 和 |1〉 都是 `Rz` 操作的本征态，无论你选择旋转的角度是多少。'
- en: For even more practice, try to figure out the eigenstates of the `Y` and `CNOT`
    operations, and write a Q# program to verify your guesses!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更多的练习，尝试找出 `Y` 和 `CNOT` 操作的本征态，并编写一个 Q# 程序来验证你的猜测！
- en: '*Hint:* You can find the vector form of the eigenstates of a unitary operation
    using QuTiP. For instance, the eigenstates of the `Y` operation are given by `qt.sigmay()
    .eigenstates()`. From there, you can use what you learned about rotations in chapters
    4–6 to determine which Q# operations prepare those states.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示:* 你可以使用 QuTiP 找到幺正操作的本征态的向量形式。例如，`Y` 操作的本征态由 `qt.sigmay() .eigenstates()`
    给出。从那里，你可以使用你在第4-6章中学到的关于旋转的知识来确定哪些 Q# 操作可以准备这些状态。'
- en: Don’t forget, you can always test if a particular state is an eigenstate of
    an operation by writing a quick test in Q#!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你总是可以通过在 Q# 中编写快速测试来测试一个特定的状态是否是操作的本征态！
- en: Eigenstates are a very useful concept and can be used in a variety of quantum
    computing algorithms. We’ll use them in the next section along with controlled
    operations to implement a quantum development technique called *phase kickback*,
    which we were introduced to at the end of chapter 7.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本征态是一个非常有用的概念，可以在各种量子计算算法中使用。我们将在下一节中使用它们，结合受控操作来实现一种称为 *相位回弹* 的量子开发技术，这是我们在第7章末介绍的。
- en: 'Deep dive: It’s only proper'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：这是非常合适的
- en: Eigenstates get their name from a concept used throughout linear algebra, known
    as *eigenvectors*. Just as an eigenstate is a state that is left alone by a quantum
    operation (i.e., at most a global phase is applied), an eigenvector is a vector
    that is preserved up to a scaling factor when multiplied by a matrix. That is,
    if for a matrix *A*, *A* ![](../Images/AR_x.png) = ¸![](../Images/AR_x.png) for
    some number *λ*¸, then ![](../Images/AR_x.png) is an eigenvector of *A*. We say
    that *λ* is the corresponding *eigenvalue*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本征态的名字来源于线性代数中一个广泛使用的基本概念，称为 *本征向量*。正如本征态是量子操作不改变的状态（即，最多应用全局相变），本征向量是乘以矩阵后仅按缩放因子保留的向量。也就是说，对于矩阵
    *A*，如果对于某个数 *λ*，*A* *v* = *λ* *v*，那么 *v* 是 *A* 的本征向量。我们说 *λ* 是相应的 *本征值*。
- en: 'The prefix “eigen-,” German for “proper” or “characteristic,” indicates that
    eigenvectors and eigenvalues help us to understand the properties or characteristics
    of matrices. In particular, if a matrix *A* commutes with its conjugate transpose
    (that is, if *AA*^† = *A*^†*A*), then it can be *decomposed* into projectors onto
    eigenvectors, each scaled by its eigenvalues:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀“eigen-”，德语中意为“合适的”或“特征的”，表明本征向量和本征值帮助我们理解矩阵的性质或特征。特别是，如果一个矩阵 *A* 与其共轭转置矩阵交换（即，如果
    *AA*^† = *A*^†*A*），那么它可以被 *分解* 为投影到本征向量上的投影算符，每个算符都按其本征值缩放：
- en: '![](../Images/equation_9-3.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![equation_9-3.png]'
- en: Since this condition always holds for unitary matrices, we can always understand
    quantum operations by decomposing them into their eigenstates and the phases applied
    to each eigenstate. For example, *Z* = |0〉〈0| − |1〉〈1| and *X* = |+〉〈+| − |−〉〈–|.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个条件对于幺正矩阵始终成立，我们可以通过将量子操作分解为其本征态和每个本征态上应用到的相来理解量子操作。例如，*Z* = |0〉〈0| − |1〉〈1|
    和 *X* = |+〉〈+| − |−〉〈–|。
- en: One significant consequence of decomposing matrices this way is that if two
    matrices *A* and *B* have the same eigenvectors and eigenvalues, they are the
    same matrix. Similarly, if two operations can be represented by the same eigenstates
    and eigenphases, the operations are indistinguishable from each other.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式分解矩阵的一个显著后果是，如果两个矩阵 *A* 和 *B* 有相同的本征向量和本征值，它们就是同一个矩阵。同样，如果两个操作可以用相同的本征态和本征相位来表示，那么这两个操作是无法区分的。
- en: This way of thinking about states and operations can often help us make sense
    of different quantum computing concepts. Another way of thinking about the phase
    estimation game you’re working on in this chapter is as an algorithm for learning
    the phases associated with each eigenstate! In chapter 10, you’ll see that this
    connects especially well to certain applications such as learning properties of
    chemical systems.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关于状态和操作思考方式常常帮助我们理解不同的量子计算概念。另一种思考本章你所工作的相位估计游戏的方式是将其视为学习每个本征态相关相位的算法！在第10章，你将看到这特别适合某些应用，例如学习化学系统的性质。
- en: '9.5 Controlled application: Turning global phases into local phases'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 控制应用：将全局相位转换为局部相位
- en: From what we have seen and can test, *global* phases of states are unobservable,
    while *local* phases of states can be measured. For example, consider the state
    1 / √2 (–*i* |0〉 –*i* |1〉) = –*i* / √2 (|0〉 + |1〉). There is no measurement we
    could do to differentiate that state from (|0〉 + |1〉) / √2. However, we could
    distinguish either of those two states from (|0〉 − |1〉) / √2 as it differs by
    a *local* phase; that is, one of the states has a + in front of the |1〉, and the
    other has a –.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们所看到和可以测试的来看，状态的**全局**相位是不可观测的，而状态的**局部**相位是可以测量的。例如，考虑状态 1 / √2 (–*i* |0〉
    –*i* |1〉) = –*i* / √2 (|0〉 + |1〉)。我们无法通过任何测量来区分该状态与 (|0〉 + |1〉) / √2。然而，我们可以通过一个**局部**相位来区分这两个状态与
    (|0〉 − |1〉) / √2；也就是说，一个状态在 |1〉 前面有一个 +，而另一个状态有一个 –。
- en: Tip If you want a refresher on phases and how to think of them as rotations,
    see chapters 4 and 5\. When you are using the simulator as your target machine,
    the output of `DumpMachine` and `DumpRegister` can also help you learn about the
    phases of states.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你想要复习相位以及如何将其视为旋转，请参阅第4章和第5章。当你使用模拟器作为目标机器时，`DumpMachine` 和 `DumpRegister`
    的输出也可以帮助你了解状态相位。
- en: 'In the last section, we played around with eigenstates and saw that the global
    phases of eigenstates can carry information about an operation: let’s call it
    `U`. If we want to learn this global phase information about the eigenstates,
    then it seems like we’re stuck. If Lancelot were to only prepare eigenstates of
    Dagonet’s operation, he’d never be able to learn what angle Dagonet had hidden.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们围绕本征态进行了实验，并看到本征态的全局相位可以携带关于一个操作的信息：我们可以称之为 `U`。如果我们想学习本征态的这种全局相位信息，那么我们似乎陷入了困境。如果兰斯洛特只准备
    Dagonet 操作的本征态，他将永远无法了解 Dagonet 隐藏的角度。
- en: 'Quantum algorithms to the rescue! There’s a very useful trick we can apply
    to turn global phases applied by an operation `U` into *local* phases applied
    by a closely related operation. To see how this works, let’s return to the `CNOT`
    operation. Recall from chapter 6 that we can simulate `CNOT` using a unitary matrix:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 量子算法来拯救！有一个非常有用的技巧我们可以应用，将操作 `U` 应用到的全局相位转换为由一个与之密切相关操作应用的局部相位。为了了解这是如何工作的，让我们回到
    `CNOT` 操作。回想第6章，我们可以使用一个幺正矩阵来模拟 `CNOT` 操作：
- en: '![](../Images/equation_9-4.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_9-4.png)'
- en: 'When we first encountered this matrix in chapter 6, we used the analogy between
    unitary matrices and classical truth tables to work out that the `CNOT` operation
    swaps the |10〉 and |11〉 states but leaves qubits in the |00〉 and |01〉 states alone.
    That is, `CNOT` flips the state of its second qubit, *controlled* on the state
    of the first qubit. As shown in figure 9.10, we can read the unitary matrix for
    the `CNOT` operation as describing a kind of “quantum if” statement: “*If* the
    control qubit is in the |1〉 state, *then* apply the `X` operation to the target
    qubit.”'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第6章首次遇到这个矩阵时，我们使用了幺正矩阵与经典真值表之间的类比，来推断 `CNOT` 操作交换 |10〉 和 |11〉 状态，但将 |00〉
    和 |01〉 状态的量子位保持不变。也就是说，`CNOT` 操作翻转其第二个量子位的状态，受第一个量子位的状态控制。如图9.10所示，我们可以将 `CNOT`
    操作的幺正矩阵读作描述一种“量子如果”语句：“*如果*控制量子位处于 |1〉 状态，*那么*对目标量子位应用 `X` 操作。”
- en: '![](../Images/9-10.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9-10.png)'
- en: Figure 9.10 Writing unitary matrices for controlled operations
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 控制操作的幺正矩阵
- en: To use the `CNOT` operation in Q#, we can try the following code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Q# 中使用 `CNOT` 操作，我们可以尝试以下代码。
- en: Listing 9.17 Using the `CNOT` operation in Q#
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.17 在 Q# 中使用 `CNOT` 操作
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Prepares the control qubit in |+〉
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 准备控制量子比特为 |+〉
- en: ❷ Prepares the target qubit in |1〉
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 准备目标量子比特为 |1〉
- en: ❸ Applies CNOT and prints out the state of the simulator
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 应用 CNOT 并打印出模拟器的状态
- en: 'By thinking about `CNOT` as a quantum analogue to a conditional statement,
    we can write its unitary matrix a bit more directly. In particular, we can look
    at the unitary matrix for the `CNOT` operation as a kind of “block matrix” that
    we can build up using the tensor product we saw in chapter 4:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `CNOT` 视为量子条件语句的类似物，我们可以更直接地编写其幺正矩阵。特别是，我们可以将 `CNOT` 操作的幺正矩阵视为一种“分块矩阵”，我们可以使用第
    4 章中看到的张量积构建它：
- en: '![](../Images/equation_9-5.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![方程式 9-5](../Images/equation_9-5.png)'
- en: 'Exercise 9.4: Verifying the CNOT matrix'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.4：验证 CNOT 矩阵
- en: Verify that |0〉 〈0| ⊗ 𝟙 + |1〉 〈1| ⊗ *X* is the same as the previous equation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 |0〉 〈0| ⊗ 𝟙 + |1〉 〈1| ⊗ *X* 与前面的方程式相同。
- en: '*Hint:* You can verify this by hand using NumPy’s `np.kron` function or QuTiP’s
    `qt.tensor` function. If you need a refresher, check out how you simulated teleportation
    in chapter 6, or look at the derivation of the Deutsch–Jozsa algorithm in chapter
    8.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示:* 您可以使用 NumPy 的 `np.kron` 函数或 QuTiP 的 `qt.tensor` 函数手动验证此操作。如果您需要复习，请查看第
    6 章中如何模拟量子隐形传态，或者查看第 8 章中 Deutsch–Jozsa 算法的推导。'
- en: 'We can construct other operations following this pattern, such as the `CZ`
    (controlled-`Z`) operation:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照这种模式构造其他操作，例如 `CZ` (受控-`Z`) 操作：
- en: '![](../Images/equation_9-6.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![方程式 9-6](../Images/equation_9-6.png)'
- en: Much like the `CNOT` operation does the same thing as an `X` operation (applies
    a bit flip), but controlled on the state of another qubit, when its control qubit
    is in the |1〉 state, the `CZ` operation flips a phase like the `Z` operation.
    Figure 9.10 shows an example of how this works. Let’s see how controlling `Z`
    works in practice by writing some Q# to give `CZ` a try.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `CNOT` 操作类似，它执行与 `X` 操作相同的功能（应用位翻转），但受控于另一个量子比特的状态，当其控制量子比特处于 |1〉 状态时，`CZ`
    操作会翻转相位，就像 `Z` 操作一样。图 9.10 展示了这种操作的一个示例。让我们通过编写一些 Q# 代码来尝试 `CZ` 操作，看看如何在实际中控制
    `Z`。
- en: Listing 9.18 Testing the Q# operation `CZ`
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.18 测试 Q# 操作 `CZ`
- en: '[PRE19]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Prepares the control qubit in |+〉
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 准备控制量子比特为 |+〉
- en: ❷ Prepares the target qubit in |1〉
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 准备目标量子比特为 |1〉
- en: ❸ Applies CZ and saves out the resulting state
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 应用 CZ 并保存结果状态
- en: 'The output is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we run this, the contents of `cz-output.txt` will show that the final state
    of the `[control, target]` register is *U*CZ |+1〉 = |−1〉.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，`cz-output.txt` 中的内容将显示 `[control, target]` 寄存器的最终状态为 *U*CZ |+1〉 =
    |−1〉。
- en: 'Exercise 9.5: Verifying the `CZ` output'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.5：验证 `CZ` 输出
- en: Either by hand or using QuTiP, verify that the previous output is the same as
    |–1〉 = |−〉 ⊗ |1〉.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要么手动验证，要么使用 QuTiP，确保前面的输出与 |–1〉 = |−〉 ⊗ |1〉 相同。
- en: If the qubits’ order is swapped but, other than that, the answer is correct,
    note that `DumpMachine` uses a *little-endian* representation to order states.
    In little-endian, |2〉 is shorthand for |01〉, not |10〉. If this seems confusing,
    blame the x86 processor architecture.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果量子比特的顺序被交换，但除此之外答案正确，请注意 `DumpMachine` 使用 *小端* 表示法来排序状态。在小端表示法中，|2〉是 |01〉的简写，而不是
    |10〉。如果这看起来很令人困惑，请归咎于 x86 处理器架构。
- en: That is, based on the state of the *target*, the state of the *control* changed
    as a result, just as we saw in chapter 8 with the Deutsch–Jozsa algorithm! This
    is because the phase applied by `Z` in the case where `control` is in the |0〉
    state is not the same as when `control` is in the |1〉 state, an effect known as
    *phase kickback*. In chapter 8, we used phase kickback with a pair of qubits in
    the |+−〉 state to tell whether the `CNOT` operation had been applied. Here, we’ve
    seen that we can use the `CZ` operation to learn about the global phase applied
    by the `Z` operation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 即，基于 *目标* 的状态，*控制* 的状态发生了变化，就像我们在第 8 章中用 Deutsch–Jozsa 算法看到的那样！这是因为当 `control`
    处于 |0〉 状态时，`Z` 应用到的相位与 `control` 处于 |1〉 状态时不同，这种现象称为 *相位回弹*。在第 8 章中，我们使用处于 |+−〉
    状态的一对量子比特的相位回弹来判断 `CNOT` 操作是否已应用。在这里，我们已经看到我们可以使用 `CZ` 操作来了解 `Z` 操作施加的全局相位。
- en: Important
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Even though |1〉 is an eigenstate of the `Z` operation, |+1〉 is *not* an eigenstate
    of the `CZ` operation. This means calling `CZ` on a register in the |+1〉 state
    has an observable effect!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 |1〉 是 `Z` 操作的本征态，但 |+1〉 不是 `CZ` 操作的本征态。这意味着在 |+1〉 状态的寄存器上调用 `CZ` 会有可观察的效果！
- en: Phase kickback is a common quantum programming technique, as it allows us to
    turn what would otherwise be global phases into a phase between the |0〉 and |1〉
    branches of the control qubit. In the `CZ` example, both the input state |+〉|1〉
    and the output state |–〉|1〉 are product states, allowing us to measure the control
    qubit without affecting the target qubit.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 相位回弹是一种常见的量子编程技术，因为它允许我们将本将是全局相位的部分转换为控制量子比特的 |0〉 和 |1〉 分支之间的相位。在 `CZ` 示例中，输入状态
    |+〉|1〉 和输出状态 |–〉|1〉 都是乘积状态，这使得我们可以在不影响目标量子比特的情况下测量控制量子比特。
- en: Think globally, learn phases locally
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 全局思考，局部学习相位
- en: Note that a global phase difference between |1〉 and *Z* |1〉 = –|1〉 became a
    *local* phase difference between |1〉 and *U[CZ]* |+1〉 = |−1〉. That is, by controlling
    the `Z` instruction on a qubit in the |+〉 state, we were able to learn what would
    have been a global phase without control.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，|1〉 和 *Z* |1〉 = –|1〉 之间的全局相位差变成了 |1〉 和 *U[CZ]* |+1〉 = |−1〉 之间的局部相位差。也就是说，通过控制处于
    |+〉 状态的量子比特上的 `Z` 指令，我们能够了解在没有控制的情况下本将是全局相位的情况。
- en: Using the `CZ` operation, we can implement the phase kickback technique to turn
    a global phase into a local phase, which we can then measure.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CZ` 操作，我们可以实现相位回弹技术，将全局相位转换为局部相位，然后我们可以进行测量。
- en: Listing 9.19 Using `CZ` to implement phase kickback
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 使用 `CZ` 操作实现相位回弹
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Prepares the control qubit in |+〉 and the target qubit in |1〉
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 准备控制量子比特在 |+〉 状态，目标量子比特在 |1〉 状态
- en: ❷ Applies CZ and saves the resulting state. Before we dump the target qubit’s
    state, though, let’s measure and reset the control qubit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用 CZ 操作并保存结果状态。然而，在我们丢弃目标量子比特的状态之前，让我们先测量并重置控制量子比特。
- en: '❸ Fun fact: this is actually how the Reset operation is implemented in Q#.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 有趣的事实：实际上，这就是 Q# 中重置操作是如何实现的。
- en: ❹ Now let’s dump only the state of the target.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 现在让我们只丢弃目标状态。
- en: ❺ We already reset control, so we don’t need to reset it again here.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们已经重置了控制量子比特，所以在这里不需要再次重置。
- en: 'Here’s the output:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ As expected, we get that the target qubit stays in the |1〉 state, ready to
    feed into another CZ operation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如预期，目标量子比特保持在 |1〉 状态，准备好输入到另一个 CZ 操作中。
- en: 9.5.1 Controlling any operation
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 控制任何操作
- en: Thinking back to Lancelot’s and Dagonet’s game, it would be really useful if
    we could help Lancelot reuse the qubit that he passes into Dagonet’s operation
    so that he doesn’t have to re-prepare it every time. Fortunately, using controlled
    operations to implement phase kickback gives a hint as to how we can do so. In
    particular, when we used phase kickback in chapters 7 and 8 to implement the Deutsch–Jozsa
    algorithm, the target qubit was in the |−〉 state at both the start and end of
    the algorithm. That means Lancelot could reuse the same qubit for each round of
    his game and not need to re-prepare each time. That didn’t matter for Deutsch–Jozsa
    since we only ran one round of Nimue’s and Merlin’s game. But it’s exactly the
    right trick for Lancelot to win his game with Dagonet, so let’s look at how we
    can help him use phase kickback.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下兰斯洛特和达戈内特的比赛，如果我们能帮助兰斯洛特重用他传递给达戈内特操作的量子比特，这样他就不必每次都重新准备它，那将非常有用。幸运的是，使用受控操作实现相位回弹为我们提供了如何做到这一点的线索。特别是，当我们使用相位回弹在第
    7 章和第 8 章中实现 Deutsch–Jozsa 算法时，目标量子比特在算法的开始和结束时都处于 |−〉 状态。这意味着兰斯洛特可以为他的每一轮游戏重用同一个量子比特，而不必每次都重新准备。这对
    Deutsch–Jozsa 来说并不重要，因为我们只运行了一轮尼缪和梅林的游戏。但对于兰斯洛特在与达戈内特的游戏中获胜来说，这正是正确的技巧，所以让我们看看我们如何帮助他使用相位回弹。
- en: 'The trouble is that, while phase kickback is a useful tool to have in our toolbox
    as a quantum developer, so far we have only seen how to use it with the `X` and
    `Z` operations. We know that for our game, Dagonet told Lancelot he will use the
    `R1` operation; is there a way we can use phase kickback to help here? The pattern
    we used to implement phase kickback in the previous section only required us to
    control an operation, so what we need is a way to control the `op::Apply` operation
    that Dagonet gives Lancelot. In Q#, this is as simple as writing `Controlled op::Apply`
    instead of `op::Apply`, thanks to the `Controlled` functor. Much like the `Adjoint`
    functor in chapter 6, `Controlled` is a Q# keyword that modifies how an operation
    behaves: in this case, to turn it into its controlled version.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，虽然相位回弹是我们作为量子开发者工具箱中的一个有用工具，但到目前为止，我们只看到了如何使用它与`X`和`Z`操作。我们知道在我们的游戏中，Dagonet告诉兰斯洛特他将使用`R1`操作；我们能否用相位回弹来帮助这里？我们在上一节中实现相位回弹的模式只要求我们控制一个操作，因此我们需要一种控制Dagonet给兰斯洛特的`op::Apply`操作的方法。在Q#中，这就像写`Controlled
    op::Apply`而不是`op::Apply`一样简单，多亏了`Controlled`函子。与第6章中的`Adjoint`函子类似，`Controlled`是一个Q#关键字，它修改了操作的行为：在这种情况下，将其转换为它的受控版本。
- en: Tip Just like `is Adj` indicates that an operation can be used with `Adjoint`,
    `is Ctl` in the type of an operation indicates that it can be used with the `Controlled`
    functor. To denote that an operation supports both, we can write `is Adj + Ctl`.
    For example, the type of the `X` operation is `(Qubit => Unit is Adj + Ctl)`,
    letting us know that `X` is both adjointable and controllable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：就像`is Adj`表示一个操作可以与`Adjoint`一起使用一样，操作类型中的`is Ctl`表示它可以与`Controlled`函子一起使用。为了表示一个操作支持两者，我们可以写`is
    Adj + Ctl`。例如，`X`操作的类型是`(Qubit => Unit is Adj + Ctl)`，这让我们知道`X`既是可逆的也是可控制的。
- en: Thus, to help Lancelot, we can change the `op::Apply(scale, target)` line to
    `Controlled op::Apply([control], (scale, target))`, and we have the controlled
    version of `R1`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了帮助兰斯洛特，我们可以将`op::Apply(scale, target)`行更改为`Controlled op::Apply([control],
    (scale, target))`，这样我们就有了`R1`的受控版本。
- en: 'While that does solve Lancelot’s problem, it can be helpful to unpack what’s
    happening under the hood a little more. Any unitary operation (that is, a quantum
    operation that doesn’t allocate, deallocate, or measure qubits) can be controlled,
    the same way we controlled the `Z` operation to get `CZ`, and as we controlled
    `X` to get `CNOT`. For instance, we can define a controlled-controlled-NOT (`CCNOT`,
    also known as Toffoli) operation as an operation that takes two control qubits
    and flips its target if *both* controls are in the |1〉 state. Mathematically,
    we write that the `CCNOT` operation transforms an input state |*x*〉|*y*〉|*z*〉
    to the output |*x*〉|*y*〉|*z* XOR (*y* AND *z*)〉. We can also write a matrix that
    lets us simulate the `CCNOT` operation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这解决了兰斯洛特的问题，但更深入地了解底层发生的事情可能会有所帮助。任何幺正操作（即不分配、释放或测量量子位的量子操作）都可以被控制，就像我们控制`Z`操作得到`CZ`，以及我们控制`X`得到`CNOT`一样。例如，我们可以定义一个受控-受控-NOT（`CCNOT`，也称为Toffoli）操作，它接受两个控制量子位，并且当*两个*控制都在|1〉状态时翻转其目标。从数学上讲，我们写出`CCNOT`操作将输入状态|*x*〉|*y*〉|*z*〉转换为输出|*x*〉|*y*〉|*z*
    XOR (*y* AND *z*)〉。我们还可以编写一个矩阵，让我们模拟`CCNOT`操作：
- en: '![](../Images/equation_9-7.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![equation_9-7.png](../Images/equation_9-7.png)'
- en: Similarly, the controlled-SWAP operation (also known as the Fredkin operation)
    transforms its input states from |1〉|*y*〉|*z*〉 to |1〉|*z*〉|*y*〉 and leaves its
    input the same when the first qubit is in the state |0〉.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，受控-SWAP操作（也称为Fredkin操作）将其输入状态从|1〉|*y*〉|*z*〉转换为|1〉|*z*〉|*y*〉，并且当第一个量子位处于|0〉状态时，其输入保持不变。
- en: 'Tip We can make a controlled-SWAP out of three `CCNOT` operations: `CCNOT(a,
    b, c); CCNOT(a, c, b); CCNOT(a, b, c);` is equivalent to `Controlled SWAP([*a*],
    (b, c));`. To see this, note that we can also make the uncontrolled `SWAP` operation
    from three `CNOT` operations for the same reason we can swap two classical registers
    in place using a sequence of three classical XOR operations.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们可以用三个`CCNOT`操作制作一个受控-SWAP：`CCNOT(a, b, c); CCNOT(a, c, b); CCNOT(a, b,
    c);`等价于`Controlled SWAP([*a*], (b, c));`。为了看到这一点，请注意，我们也可以用三个`CNOT`操作制作不受控的`SWAP`操作，原因是我们可以用一系列三个经典XOR操作在原地交换两个经典寄存器。
- en: We can generalize this pattern for any unitary operation `U` (that is, any operation
    that does not allocate, deallocate, or measure its qubits). In Q#, the transformation
    performed using the `Controlled` functor adds a new input to an operation representing
    which qubits should be used as controls.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种模式推广到任何幺正操作 `U`（即任何不分配、释放或测量其量子比特的操作）。在 Q# 中，使用 `Controlled` 函子执行的操作会给表示哪些量子比特用作控制器的操作添加一个新的输入。
- en: Tip This is where the fact that Q# is a tuple-in tuple-out language comes in
    very handy. Since every operation takes exactly one input, for any operation `U`,
    `Controlled U` takes the original input to `U` as its second input.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：这正是 Q# 作为元组-元组语言的事实非常有用的地方。由于每个操作恰好需要一个输入，对于任何操作 `U`，`Controlled U` 将 `U`
    的原始输入作为其第二个输入。
- en: The `CNOT` and `CZ` operations are simply shorthand for appropriate calls to
    `Controlled`. Table 9.1 shows more examples of this pattern.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`CNOT` 和 `CZ` 操作只是对 `Controlled` 的适当调用的简写。表 9.1 展示了更多这种模式的示例。'
- en: Tip Just like `Adjoint` works on any operation that has `is Adj` in its type
    (as we saw in chapter 8), the `Controlled` functor works on any operation that
    has `is Ctl` in its type.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：就像 `Adjoint` 在其类型中有 `is Adj` 的任何操作上工作一样（如我们在第 8 章中看到的），`Controlled` 函子在具有
    `is Ctl` 的任何操作上工作。
- en: Table 9.1 Some examples of controlled operations in Q#
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 Q# 中控制操作的几个示例
- en: '| Description | Shorthand | Definition |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 速记 | 定义 |'
- en: '| Controlled-NOT | `CNOT(control, target)` | `Controlled X([control], target)`
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 控制非 | `CNOT(control, target)` | `Controlled X([control], target)` |'
- en: '| Controlled-controlled-NOT (Toffoli) | `CCNOT(control0, control1, target)`
    | `Controlled X([control0, control1], target)` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 控制控制-NOT (Toffoli) | `CCNOT(control0, control1, target)` | `Controlled X([control0,
    control1], target)` |'
- en: '| Controlled-SWAP (Fredkin) | n/a | `Controlled SWAP([control], (target1, target2))`
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 控制交换 (Fredkin) | n/a | `Controlled SWAP([control], (target1, target2))` |'
- en: '| Controlled Y | `CY(control, target)` | `Controlled Y([control], target)`
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 控制Y | `CY(control, target)` | `Controlled Y([control], target)` |'
- en: '| Controlled-PHASE | `CZ(control, target)` | `Controlled Z([control], target)`
    |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 控制相位 | `CZ(control, target)` | `Controlled Z([control], target)` |'
- en: As we saw with the `CZ` example, controlling operations this way lets us turn
    global phases such as those applied to eigenstates into relative phases that we
    can learn through measurements.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `CZ` 示例中所看到的，以这种方式控制操作使我们能够将全局相位（如应用于本征态的相位）转换为我们可以通过测量学习的相对相位。
- en: More than that, by using controlled rotations to kick back phase onto the control
    register, we can also reuse the same target qubit over and over. When we applied
    `CZ` to a target register in an eigenstate of `Z`, that target register stayed
    in the same state even though the control register changed. In the rest of this
    chapter, we’ll see how to use that fact to finish Lancelot’s strategy for his
    little game with Dagonet.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '更多的是，通过使用控制旋转将相位反弹到控制寄存器，我们还可以反复重用相同的靶量子比特。当我们对 `Z` 的本征态中的目标寄存器应用 `CZ` 时，尽管控制寄存器发生了变化，但目标寄存器仍然保持在相同的状态。在本章的其余部分，我们将看到如何利用这一事实来完成
    Lancelot 与 Dagonet 小游戏的策略。 '
- en: 9.6 Implementing Lancelot’s best strategy for the phase-estimation game
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 实现Lancelot在相位估计游戏中的最佳策略
- en: We now have everything we need to write a slightly different strategy for Lancelot
    that will allow him to use controlled operations to reuse the same qubits. As
    noted before, this may not make a huge impact for Dagonet’s game, but it does
    for other applications of quantum computing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了编写一个略微不同的 Lancelot 策略所需的一切，这将允许他使用控制操作重用相同的量子比特。正如之前所提到的，这可能对 Dagonet
    的游戏影响不大，但对量子计算的其它应用来说却很重要。
- en: For example, in chapter 10, we’ll see how problems in quantum chemistry can
    be solved using a game very similar to the one Dagonet and Lancelot are playing.
    There, however, preparing the right input state can require calling a lot of different
    quantum operations, such that if we can preserve the target qubit for later use,
    we can gain quite a lot of performance.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第 10 章中，我们将看到如何使用一个非常类似于 Dagonet 和 Lancelot 所玩的游戏来解决量子化学中的问题。然而，在那里，准备正确的输入状态可能需要调用很多不同的量子操作，因此如果我们能够保留目标量子比特以供以后使用，我们就可以获得相当多的性能提升。
- en: 'Let’s briefly review the game’s steps:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下游戏的步骤：
- en: Dagonet picks a secret angle for a single-qubit rotation operation.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dagonet 为单量子比特旋转操作选择一个秘密角度。
- en: Dagonet prepares an operation for Lancelot to use that hides the secret angle
    and allows Lancelot one additional input of a number (we’ll call it a scale) that
    will be multiplied with the secret angle to give the total rotation angle of the
    operation.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 达戈内特为兰斯洛特准备了一个操作，该操作隐藏了秘密角度并允许兰斯洛特额外输入一个数字（我们将它称为尺度），该数字将与秘密角度相乘以给出操作的总体旋转角度。
- en: 'Lancelot’s best strategy for the game is to select many scale values and estimate
    the probability of measuring `One` for each value:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 兰斯洛特在游戏中的最佳战略是选择许多尺度值并估计每个值测量到`One`的概率：
- en: Prepare the |+〉 state, and input the scale value in Dagonet’s rotation. He uses
    the |+〉 state because he knows Dagonet is rotating around the *Z*-axis; and for
    this state, these rotations will result in a local phase change he can measure.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备|+〉状态，并在达戈内特的旋转中输入尺度值。他使用|+〉状态，因为他知道达戈内特是围绕*Z*轴旋转的；并且对于这个状态，这些旋转将导致他可以测量的局部相位变化。
- en: After preparing each |+〉 state, Lancelot can rotate it with the secret operation,
    measure the qubit, and record the measurement.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在准备每个|+〉状态后，兰斯洛特可以使用秘密操作旋转它，测量量子比特，并记录测量结果。
- en: Lancelot now has data relating his scale factor and the probability he measured
    a `One` for that scale factor. He can fit this data in his head and get Dagonet’s
    angle from the fitted parameters (he *is* the greatest knight in the land). We
    can use Python to help us do the same!
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 兰斯洛特现在有了与他的尺度因子和他测量的该尺度因子的`One`概率相关联的数据。他可以将这些数据拟合到脑海中，并从拟合参数中得到达戈内特的角（他确实是这个国家最伟大的骑士）。我们可以使用Python来帮助我们做到同样的事情！
- en: The step that needs to change to use our newfound skills with *controlled* rotations
    is step 3\. For step 3a, the *allocation* of the qubits will change. Rather than
    allocating, preparing, and measuring one qubit per measurement, Lancelot can allocate
    one `target` qubit to rotate with Dagonet’s black box and instead allocate and
    measure `control` qubits. He still can repeat the measurements but won’t have
    to measure or re-prepare the `target` each time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 需要改变以使用我们新发现的技能进行**受控**旋转的是第3步。对于第3a步，量子比特的**分配**将改变。兰斯洛特不再为每次测量分配、准备和测量一个量子比特，而是可以分配一个`目标`量子比特与达戈内特的黑盒旋转，并分配和测量`控制`量子比特。他仍然可以重复测量，但不必每次都测量或重新准备`目标`量子比特。
- en: 'We could summarize these changes by rewriting step 3 like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过如下重写第3步来总结这些变化：
- en: '1'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2'
- en: 'Lancelot’s best strategy for the game is to select many scale values and estimate
    the probability of measuring `One` for each value. To do this, he must perform
    the following steps many times for each of the many scale values. He prepares
    one qubit in the |1〉 state to use as the `target` for all of his measurements
    as it’s an eigenstate of the hidden rotation:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 兰斯洛特在游戏中最佳的战略是选择许多尺度值并估计每个值测量到`One`的概率。为此，他必须对每个许多尺度值多次执行以下步骤。他准备一个处于|1〉状态的量子比特作为所有测量的`目标`，因为它是对称旋转的本征态：
- en: Prepare a second `control` qubit in the |+〉 state.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个处于|+〉状态的第二个`控制`量子比特。
- en: Apply the new controlled version of the secret rotation with Lancelot’s scale
    value, un-prepare the `control` qubit and measure it, and then record the measurement.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用兰斯洛特的尺度值应用新的受控版本的秘密旋转，未准备`控制`量子比特并测量它，然后记录测量结果。
- en: In our code, these changes can be accomplished by modifying the previous `EstimateProbabilityAtScale`
    operation. Since the rotation axis could be anything Dagonet chooses (here, it’s
    the *Z*-axis for convenience), Lancelot needs to know how to control an arbitrary
    rotation. We can do this with the `Controlled` functor before calling the `ScalableOperation`
    passed from Dagonet. The `Controlled` functor is very similar to the `Adjoint`
    functor in that it takes an operation and returns a new operation. `Controlled
    U(control, target)` is an example of the syntax that allows us to apply `U` to
    our `target` qubit, controlled on one or more `control` qubits. The following
    listing shows how we can modify `EstimateProbabilityAtScale` to use the `Controlled`
    functor.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，这些变化可以通过修改之前的`EstimateProbabilityAtScale`操作来实现。由于旋转轴可以是达戈内特选择的任何东西（这里，为了方便，是*Z*轴），兰斯洛特需要知道如何控制任意旋转。我们可以通过在调用达戈内特传递的`ScalableOperation`之前使用`Controlled`函子来实现这一点。`Controlled`函子与`Adjoint`函子非常相似，因为它接受一个操作并返回一个新的操作。`Controlled
    U(control, target)`是允许我们将`U`应用于我们的`目标`量子比特，并通过一个或多个`控制`量子比特进行控制的语法示例。以下列表显示了如何修改`EstimateProbabilityAtScale`以使用`Controlled`函子。
- en: 'Listing 9.20 operations.qs: Lancelot''s new strategy'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.20 operations.qs：兰斯洛特的新战略
- en: '[PRE23]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ The guessing operation now takes the target register as an input and reuses
    it. Thus, we only need to allocate and prepare the control register each time.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 猜测操作现在将目标寄存器作为输入并重用它。因此，我们每次只需要分配和准备控制寄存器。
- en: ❷ The only other change we need to make is to call Controlled op::Apply instead
    of op::Apply, passing the new control qubit along with the original inputs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们需要做的唯一其他更改是调用Controlled op::Apply而不是op::Apply，并将新的控制量子比特连同原始输入一起传递。
- en: The other modification we have to make (step 5) is the operation that runs the
    game. Since using the controlled operation allows Lancelot to reuse the target
    qubit, it only needs to be allocated once at the beginning of the game. See the
    next listing for how we can implement this.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须进行的其他修改（步骤5）是运行游戏的操作。由于使用受控操作允许Lancelot重用目标量子比特，它只需要在游戏开始时分配一次。请参阅下一列表了解我们如何实现这一点。
- en: 'Listing 9.21 operations.qs: Implementing `RunGameUsingControlledRotations`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.21 operations.qs：实现`RunGameUsingControlledRotations`
- en: '[PRE24]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Using EstimateProbabilityAtScaleUsingControlledRotations, we can allocate
    the target qubit once since we use it over and over again through each guess.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用EstimateProbabilityAtScaleUsingControlledRotations，我们可以一次分配目标量子比特，因为我们反复使用它进行每个猜测。
- en: ❷ Using the X operation, we can prepare the target in the |1〉 state, an eigenstate
    of the (uncontrolled) R1 operation in which Dagonet hid his angle.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用X操作，我们可以将目标状态准备为|1〉状态，这是（未控制的）R1操作的本征态，Dagonet在其中隐藏了他的角度。
- en: Using the `X` operation as in listing 9.21, we can prepare the target in the
    |1〉 state, an eigenstate of the (uncontrolled) `R1` operation in which Dagonet
    hid his angle. Since each measurement uses phase kickback to affect only the control
    register, this preparation can be done once before playing the game.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表9.21中的`X`操作，我们可以将目标状态准备为|1〉状态，这是（未控制的）`R1`操作的本征态，Dagonet在其中隐藏了他的角度。由于每次测量都使用相位回弹仅影响控制寄存器，这种准备可以在玩游戏之前一次性完成。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Phase estimation is a quantum algorithm that allows for learning the phase applied
    to a register of qubits by a given operation.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相位估计是一种量子算法，它允许通过给定的操作学习施加到量子比特寄存器上的相位。
- en: In Q#, we can declare new user-defined types to label how a given type is meant
    to be used in a quantum program or provide a shorthand for long types.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Q#中，我们可以声明新的用户定义类型来标记给定类型在量子程序中的使用方式，或者为长类型提供缩写。
- en: Quantum programs in Q# can be run on their own or from a host program written
    in Python; this allows for using Q# programs alongside data science tools like
    SciPy.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q#中的量子程序可以独立运行，也可以从用Python编写的宿主程序中运行；这允许使用Q#程序与数据科学工具（如SciPy）一起使用。
- en: When an operation leaves inputs in a given state unmodified other than applying
    a global phase, we say that that input state is an *eigenstate*, and the corresponding
    phase is an *eigenphase*.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个操作除了应用全局相位外，不修改给定状态的其他输入时，我们称该输入状态为*本征态*，相应的相位为*本征相位*。
- en: Using the `Controlled` functor and phase kickback together, we can turn global
    eigenphases into local phases that we can observe and estimate.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Controlled`函子和相位回弹一起，我们可以将全局本征相位转换为我们可以观察和估计的局部相位。
- en: Putting everything together, we can use classical data-fitting techniques to
    learn eigenphases from the measurements returned by running a Q# program that
    performs phase estimation.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们可以使用经典数据拟合技术从运行相位估计Q#程序返回的测量结果中学习本征相位。
- en: 'Part 2: Conclusion'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分：结论
- en: In this part of the book, we’ve had a lot of fun using Q# and quantum computing
    to help the various denizens of Camelot. Using a quantum random number generator
    written in Q#, we were able to help Morgana pull one over on poor Lancelot. At
    the same time, we helped Merlin and Nimue each play their respective roles in
    deciding the fate of kings, learning about the Deutsch–Jozsa algorithm and phase
    kickback all the while. With the land at peace and the fires in Castle Camelot
    burning down for the night, we saw how to use everything we learned to help Lancelot
    play another game, winning this time by guessing a quantum operation hidden by
    Dagonet.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们使用Q#和量子计算帮助卡美洛的各个居民度过了很多乐趣。通过使用用Q#编写的量子随机数生成器，我们帮助莫甘娜欺骗了可怜的兰斯洛特。同时，我们帮助梅林和尼姆乌分别扮演各自的角色，决定国王的命运，在此过程中学习了Deutsch–Jozsa算法和相位回弹。随着土地的和平与卡美洛城堡夜晚的火焰，我们看到了如何使用我们所学的一切来帮助兰斯洛特玩另一场游戏，这次通过猜测Dagonet隐藏的量子操作而获胜。
- en: 'Throughout our Camelot escapades, you picked up quite a few new tricks to help
    you on your way as a quantum developer:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Camelot 逃亡过程中，你学到了不少新技巧，这些技巧将帮助你成为一名量子开发者：
- en: What a quantum algorithm is, and how to implement it with the Quantum Development
    Kit and Q#
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子算法是什么，以及如何使用量子开发工具包和Q#来实现它
- en: How to use Q# from Python and Jupyter Notebook
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从Python和Jupyter Notebook中使用Q#
- en: How to design *oracles* to represent classical functions in quantum programs
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计 *预言机* 来在量子程序中表示经典函数
- en: User-defined types
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义类型
- en: Controlled operations
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制操作
- en: Phase kickback
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相位回弹
- en: Going forward, it’s time to bring what you’ve learned from Camelot back home
    and apply these new techniques to something a bit more practical. In the next
    chapter, you’ll see how quantum computing can help in understanding chemistry
    problems. Don’t worry if you don’t remember the periodic table; you’ll be working
    with some colleagues who know the chemistry side of things and are looking for
    your help in using everything you learned in this part of the book to upgrade
    their workflow with quantum technology.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 向前看，是时候把你在 Camelot 学到的知识带回家，并将这些新技术应用到一些更实用的东西上了。在下一章中，你将看到量子计算如何帮助理解化学问题。如果你不记得元素周期表也不要担心；你将与一些了解化学方面的同事合作，他们希望你能利用这本书的这一部分所学到的所有知识，用量子技术来升级他们的工作流程。
