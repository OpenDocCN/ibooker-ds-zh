- en: 1 What are microservice APIs?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 微服务API是什么？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What microservices are and how they compare with monolithic applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是什么以及它们与单体应用如何比较
- en: What web APIs are and how they help us drive integrations between microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络API是什么以及它们如何帮助我们推动微服务之间的集成
- en: The most important challenges of developing and operating microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和运营微服务面临的最重要挑战
- en: 'This chapter defines the most important concepts in this book: microservices
    and APIs. Microservices are an architectural style in which components of a system
    are designed as independently deployable services, and APIs are the interfaces
    that allow us to interact with those services. We will see the defining features
    of microservices architecture and how they compare with monolithic applications.
    Monolithic applications are structured around a single code base and deployed
    in a single build.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章定义了本书中最重要的一些概念：微服务和API。微服务是一种架构风格，其中系统的组件被设计为独立部署的服务，API是允许我们与这些服务交互的接口。我们将看到微服务架构的定义特征以及它们与单体应用的比较。单体应用围绕单个代码库构建并部署在单个构建中。
- en: We’ll discuss the benefits and the disadvantages of microservices architecture.
    The last part of this chapter talks about the most important challenges that we
    face when designing, implementing, and operating microservices. This discussion
    is not to deter you from embracing microservices, but so that you can make an
    informed decision about whether microservices are the right choice of architecture
    for you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论微服务架构的优点和缺点。本章的最后部分将讨论在设计、实施和运营微服务时面临的最重要挑战。这次讨论不是为了阻止你接受微服务，而是为了让你能够做出明智的决定，判断微服务是否是你架构选择的正确选择。
- en: 1.1 What are microservices?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 微服务是什么？
- en: In this section, we define what microservices architecture is, and we analyze
    how microservices compare with monolithic applications. We’ll look into the benefits
    and challenges of each architectural pattern. Finally, we’ll also take a brief
    look at the historical developments that led to the emergence of modern microservices
    architecture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们定义微服务架构是什么，并分析微服务与单体应用的比较。我们将探讨每种架构模式的优点和挑战。最后，我们还将简要回顾导致现代微服务架构出现的历史发展。
- en: 1.1.1 Defining microservices
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 定义微服务
- en: 'So, what are microservices? Microservices can be defined in different ways,
    and, depending on which aspect of microservices architecture we want to emphasize,
    authors provide slightly different yet related definitions of the term. Sam Newman,
    one of the most influential authors in the field of microservices, provides a
    minimal definition: “Microservices are small, autonomous services that work together.”[¹](#pgfId-1070924)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，微服务是什么？微服务可以以不同的方式定义，并且，根据我们想要强调的微服务架构的哪个方面，作者提供了略微不同但相关的定义。Sam Newman，微服务领域最有影响力的作者之一，提供了一个最小化定义：“微服务是小型、自治的服务，它们协同工作。”[¹](#pgfId-1070924)
- en: This definition emphasizes the fact that microservices are applications that
    run independently of each other yet can collaborate in the performance of their
    tasks. The definition also emphasizes that microservices are “small.” In this
    context, “small” doesn’t refer to the size of the microservices’ code base, but
    to the idea that microservices are applications with a narrow and well-defined
    scope, following the Single Responsibility Principle of doing one thing and doing
    it well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义强调了微服务是独立运行的应用程序，但可以在执行任务时相互协作的事实。定义还强调了微服务是“小型”的。在这种情况下，“小型”并不指微服务的代码库大小，而是指微服务是具有狭窄和明确范围的应用程序，遵循单一责任原则，即做好一件事。
- en: A seminal article written by James Lewis and Martin Fowler provides a more detailed
    definition. They define microservices as an architectural style with “an approach
    to developing a single application as a suite of small services, each running
    in its own process and communicating with lightweight mechanisms, often an HTTP
    resource API” ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)).
    This definition emphasizes the autonomy of the services by stating that they run
    in independent processes. Lewis and Fowler also highlight that microservices have
    a narrow scope of responsibilities by saying that they are “small,” and they explicitly
    describe how microservices communicate through lightweight protocols, such as
    HTTP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: James Lewis 和 Martin Fowler 撰写的一篇开创性文章提供了更详细的定义。他们将微服务定义为一种架构风格，即“将单个应用程序作为一系列小型服务开发的方法，每个服务都在自己的进程中运行，并通过轻量级机制进行通信，通常是
    HTTP 资源 API”([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))。这个定义通过指出它们在独立进程中运行来强调服务的自治性。Lewis
    和 Fowler 还强调微服务具有狭窄的责任范围，他们说它们是“小的”，并明确描述了微服务通过轻量级协议（如 HTTP）进行通信的方式。
- en: DEFINITION A *microservice* is an architectural style in which components of
    a system are designed as independently deployable services. Microservices are
    designed around well-defined business subdomains, and they talk to each other
    using lightweight protocols, such as HTTP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*微服务*是一种架构风格，其中系统的组件被设计为独立部署的服务。微服务围绕定义良好的业务子域设计，并使用轻量级协议（如 HTTP）相互通信。
- en: From the previous definitions, we can see that microservices can be defined
    as an architectural style in which services are components that perform a small
    and clearly defined set of related functions. As you can see in figure 1.1, this
    definition means that a microservice is designed and built around a specific business
    subdomain, for example, processing payments, sending emails, or handling orders
    from a customer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的定义中，我们可以看出微服务可以被定义为一种架构风格，其中服务是执行一组小而明确定义的相关功能的组件。正如你在图 1.1 中所看到的，这个定义意味着微服务是围绕特定的业务子域设计和构建的，例如处理支付、发送电子邮件或处理客户的订单。
- en: '![](../Images/01-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.1](../Images/01-01.png)'
- en: Figure 1.1 In microservices architecture, every service implements a specific
    business subdomain and is deployed as an independent component that runs in its
    own process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 在微服务架构中，每个服务实现特定的业务子域，并作为独立组件部署，在它自己的进程中运行。
- en: Microservices are deployed as independent processes, typically running in independent
    environments, and expose their capabilities through well-defined interfaces. In
    this book, you will learn to design and build microservices that expose their
    capabilities through web APIs, though other types of interfaces are also possible,
    such as messaging queues.[²](#pgfId-1070939)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务作为独立进程部署，通常在独立环境中运行，并通过定义良好的接口公开其功能。在这本书中，你将学习如何设计和构建通过 Web API 公开其功能的微服务，尽管其他类型的接口也是可能的，例如消息队列。[²](#pgfId-1070939)
- en: 1.1.2 Microservices vs. monoliths
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 微服务与单体
- en: 'Now that we know what microservices are, let’s see how they compare with the
    monolithic application pattern. In contrast with microservices, a monolith is
    a system where all functionality is deployed together as a single build and runs
    in the same process. For example, figure 1.2 shows a food delivery application
    with four services: a payments service, an orders service, a delivery service,
    and a customer support service. Since the application is implemented as a monolith,
    all functionality is deployed together. We can run multiple instances of a monolithic
    application and have them run in parallel for redundancy and scalability purposes,
    but it’s still the whole application running in each process.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了什么是微服务，让我们看看它们与单体应用模式的比较。与微服务相反，单体是一个所有功能都作为一个单一构建部署在一起并运行在相同进程中的系统。例如，图
    1.2 展示了一个包含四个服务的食品配送应用程序：支付服务、订单服务、配送服务和客户支持服务。由于应用程序被实现为单体，所有功能都一起部署。我们可以运行多个单体应用程序的实例，并让它们并行运行以提高冗余和可伸缩性，但每个进程仍然运行整个应用程序。
- en: '![](../Images/01-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.2](../Images/01-02.png)'
- en: Figure 1.2 In a monolithic application, all functionality is deployed together
    as a single build to each server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 在单体应用程序中，所有功能都作为一个单一构建部署到每个服务器。
- en: DEFINITION A *monolith* is an architectural pattern in which the whole application
    is deployed as a single build.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一个**单体**是一种架构模式，其中整个应用程序作为一个单一构建部署。'
- en: 'In some situations, the monolith is the right choice of architecture. For example,
    we’d use a monolith when our code base is small and it isn’t expected to grow
    very large.[³](#pgfId-1070953) Monoliths also come with advantages. First, having
    the whole implementation in the same code base makes it easier to access data
    and logic from different subdomains. And because everything runs within the same
    process, it is easy to trace errors through the application: you only need to
    place a few breakpoints in different parts of your code, and you will get a detailed
    picture of what happens when something goes wrong. Besides, because all the code
    falls within the scope of the same project, you can leverage the productivity
    features of your favorite development editor when consuming functionality from
    a different subdomain.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，单体是架构的正确选择。例如，当我们的代码库很小且预期不会变得很大时，我们会使用单体。[³](#pgfId-1070953) 单体也带来了一些优势。首先，整个实现都在同一个代码库中，这使得从不同的子域访问数据和逻辑变得更容易。而且因为所有内容都在同一个进程中运行，所以很容易通过应用程序跟踪错误：你只需要在你代码的不同部分放置几个断点，你就能得到一个详细的错误发生时的画面。此外，因为所有代码都在同一个项目的范围内，当你从不同的子域消费功能时，你可以利用你最喜欢的开发编辑器的生产力功能。
- en: However, as the application grows and becomes more complex, this type of architecture
    shows limitations. This happens when the code base grows to a point where it becomes
    difficult to manage, and when finding your way through the code becomes arduous.
    Additionally, being able to reuse code from other subdomains within the same project
    often leads to tight coupling among components. Tight coupling happens when a
    component depends on the implementation details of another piece of code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着应用程序的增长和复杂化，这种类型的架构显示出局限性。当代码库增长到难以管理的程度，以及当你通过代码找到路径变得困难时，这种情况就会发生。此外，能够在同一项目内部的其他子域中重用代码通常会导致组件之间的紧密耦合。紧密耦合发生在组件依赖于另一段代码的实现细节时。
- en: The bigger the monolith, the longer it takes to test it. Every part of the monolith
    must be tested, and as we add new features to it, the test suite grows larger.
    Consequently, deployments become slower and encourage developers to pile up changes
    within the same release, which makes releases more challenging. Because many changes
    are released together, if a new bug is introduced in the release, it is often
    difficult to spot the specific change that caused the bug and roll it back. And
    because the whole application runs within the same process, when you scale the
    resources for one component, you are scaling for the whole application. Long story
    short, code changes become increasingly risky and deployments become more difficult
    to manage. How can microservices help us address these issues?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单体越大，测试它所需的时间就越长。单体中的每个部分都必须经过测试，并且随着我们向其中添加新功能，测试套件会越来越大。因此，部署变得缓慢，并鼓励开发者在同一个版本中堆积更改，这使得发布变得更加具有挑战性。因为许多更改一起发布，如果在发布中引入了新的错误，通常很难找到导致错误的特定更改并将其回滚。而且因为整个应用程序在同一个进程中运行，当你为某个组件扩展资源时，你实际上是在为整个应用程序扩展资源。简而言之，代码更改变得越来越有风险，部署变得越来越难以管理。微服务如何帮助我们解决这些问题？
- en: Microservices address some of the issues associated with monolithic applications
    by enforcing strict boundaries separating components. When you implement an application
    using microservices, each microservice runs in a different process, often in different
    servers or virtual machines, and can have a completely different deployment model.
    As a matter of fact, they can be written in completely different programming languages
    (that does not mean they should!).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过强制执行严格分离组件的边界来解决了与单体应用程序相关的一些问题。当你使用微服务实现应用程序时，每个微服务都在不同的进程中运行，通常在不同的服务器或虚拟机上，并且可以拥有完全不同的部署模型。实际上，它们可以用完全不同的编程语言编写（这并不意味着它们应该这样做！）。
- en: Because microservices contain smaller code bases than a monolith, and because
    their logic is self-contained and defined within the scope of a specific business
    subdomain, it is easier to test them, and their test suites run faster. Because
    they do not have dependencies with other components of the platform at the code
    level (except perhaps for some shared libraries), their code is clearer, and it
    is easier to refactor them. This means the code can get better over time and become
    more maintainable. Consequently, we can make small changes to the code and release
    more often. Smaller releases are more controllable, and if we spot a bug, the
    releases are easier to roll back. I’d like to emphasize that microservices are
    not a panacea. As we will see in section 1.3, microservices also have limitations
    and bring challenges of their own.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的代码库比单体应用小，并且它们的逻辑是自包含的，并且定义在特定的业务子域范围内，因此测试它们更容易，它们的测试套件运行更快。由于它们在代码级别上没有与其他平台组件的依赖关系（除了可能是一些共享库），它们的代码更清晰，重构它们也更容易。这意味着代码可以随着时间的推移变得更好，并变得更加易于维护。因此，我们可以对代码进行小幅度修改并更频繁地发布。较小的发布更容易控制，如果我们发现了一个错误，发布回滚也更容易。我想强调的是，微服务并不是万能的。正如我们将在第1.3节中看到的，微服务也有其局限性，并带来了一些自己的挑战。
- en: Now that we know what microservices are and how they compare with monolithic
    applications, let’s take a step back and see what developments led to the emergence
    of this type of architecture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了微服务是什么以及它们与单体应用相比如何，让我们退一步看看是什么发展导致了这种类型架构的出现。
- en: 1.1.3 Microservices today and how we got here
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 当前微服务及其发展历程
- en: In many ways, microservices are not new.[⁴](#pgfId-1070965) Companies were implementing
    and deploying components as independent applications well before the concept of
    microservices became popular. They just did not call it microservices. Werner
    Vogels, CTO of Amazon, explains how Amazon started to experiment with this type
    of architecture in the early 2000s. By that time, the code base for the Amazon
    website had grown into a complex system without a clear architectural pattern,
    where making new releases and scaling the system had become serious pain points.
    To combat these issues, they decided to look for independent pieces of logic within
    the code and separate them out into independently deployable components, with
    an API in front of them. As part of this process, they also identified the data
    that belongs to those components and made sure that other parts of the system
    could not access the data except through an API. They called this new type of
    architecture *service-oriented architecture* ([https://vimeo.com/29719577](https://vimeo.com/29719577)).
    Netflix also pioneered this type of architectural style at scale, and they referred
    to it as “fine-grained Service Oriented Architecture.”[⁵](#pgfId-1070970)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，微服务并不是什么新鲜事物。[⁴](#pgfId-1070965) 公司在微服务概念流行之前就已经开始实施和部署独立的应用程序组件。他们只是没有称之为微服务。亚马逊的首席技术官Werner
    Vogels解释了亚马逊是如何在21世纪初开始尝试这种架构的。到那时，亚马逊网站的代码库已经增长成为一个没有明确架构模式的复杂系统，发布新版本和扩展系统已经变成了严重的痛点。为了解决这些问题，他们决定在代码中寻找独立的逻辑片段，并将它们分离出来成为可以独立部署的组件，并在它们前面提供一个API。在这个过程中，他们还确定了属于这些组件的数据，并确保系统的其他部分不能通过API之外的方式访问数据。他们将这种新的架构类型称为*面向服务的架构*([https://vimeo.com/29719577](https://vimeo.com/29719577))。Netflix也在大规模上开创了这种架构风格，并将它称为“细粒度面向服务的架构”。[⁵](#pgfId-1070970)
- en: The term *microservice* grew in popularity in the early 2010s to describe this
    type of architecture. For example, James Lewis used this concept in a presentation
    at the 33rd Degree conference in Krakow in 2012, under the title “Micro-Services—Java,
    the Unix way” ([https://vimeo.com/74452550](https://vimeo.com/74452550)). In 2014
    the concept was consolidated with a paper written by Martin Fowler and James Lewis
    about the architectural features of microservices ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)),
    as well as the publication of Newman’s influential book *Building Microservices*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*微服务*在2010年代初开始流行，用来描述这种类型的架构。例如，James Lewis在2012年克拉科夫第33度会议上使用了这个概念，标题为“Micro-Services—Java,
    the Unix way”([https://vimeo.com/74452550](https://vimeo.com/74452550))。2014年，Martin
    Fowler和James Lewis关于微服务架构特征的论文以及Newman有影响力的书籍《Building Microservices》的出版，使这一概念得到了巩固([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))。
- en: Today, microservices are a widely used architectural style. Most companies in
    which technology plays an important role are already using microservices or moving
    toward its adoption. It is also common for startups to begin implementing their
    platform using a microservices approach. However, microservices are not for everyone,
    and although they bring substantial benefits, as we have shown, they also carry
    considerable challenges, as we will see in section 1.3.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，微服务是一种广泛使用的架构风格。在技术扮演重要角色的公司中，大多数公司已经在使用微服务或正在转向其采用。对于初创公司来说，开始使用微服务方法实现其平台也是常见的。然而，微服务并不适合所有人，尽管它们带来了实质性的好处，正如我们所展示的，它们也带来了相当大的挑战，我们将在第
    1.3 节中看到。
- en: 1.2 What are web APIs?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 什么是 Web API？
- en: In this section, we will explain web APIs. You will learn that a web API is
    a specific instance of the more general concept of an application programming
    interface (API). It is important to understand that an API is just a layer on
    top of an application, and that there are different types of interfaces. For this
    reason, we will begin this section by defining what an API is, and then we will
    move on to explaining how APIs help us drive integrations between microservices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释 Web API。您将了解到 Web API 是更一般的应用程序编程接口（API）概念的特定实例。重要的是要理解 API 只是应用程序之上的一个层，并且存在不同类型的接口。因此，我们将从定义
    API 是什么开始，然后我们将继续解释 API 如何帮助我们驱动微服务之间的集成。
- en: 1.2.1 What is an API?
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 什么是 API？
- en: An API is an interface that allows us to programmatically interact with an application.
    Programmatic interfaces are those we can use from our code or from the terminal,
    as opposed to graphic interfaces, in which we use a user interface to interact
    with the application. There are multiple types of application interfaces, such
    as command-line interfaces (CLIs; interfaces that allow you to use an application
    from a terminal), desktop UI interfaces, web UI interfaces, or web API interfaces.
    As you can see in figure 1.3, an application can have one or more of these interfaces.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: API 是一种接口，允许我们以编程方式与应用程序交互。编程接口是我们可以从代码或终端使用的那种接口，与图形界面相对，在图形界面中，我们使用用户界面与应用程序交互。应用程序接口有多种类型，例如命令行界面（CLI；允许您从终端使用应用程序的接口）、桌面
    UI 接口、Web UI 接口或 Web API 接口。如图 1.3 所示，一个应用程序可以有一个或多个这些接口。
- en: '![](../Images/01-03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3](../Images/01-03.png)'
- en: Figure 1.3 An application can have multiple interfaces, such as a web API, a
    CLI, a web UI, and a desktop UI.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 一个应用程序可以拥有多个接口，例如 Web API、CLI、Web UI 和桌面 UI。
- en: 'To illustrate this idea, think of the popular client URL (cURL). cURL is a
    CLI to the `libcurl` library. `libcurl` implements functionality that allows us
    to interact with URLs, while cURL exposes those capabilities through a CLI. For
    example, we can use cURL to send a GET request to a URL:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，想想流行的客户端 URL（cURL）。cURL 是 `libcurl` 库的 CLI。`libcurl` 实现了允许我们与 URL 交互的功能，而
    cURL 通过 CLI 揭示这些功能。例如，我们可以使用 cURL 向 URL 发送 GET 请求：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also use cURL with the `-O` option in order to download the contents
    of a URL to a file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用带有 `-O` 选项的 cURL 来将 URL 的内容下载到文件中：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `libcurl` library sits behind the cURL CLI, and nothing prevents us from
    accessing it directly through the source code (if you are curious, you can pull
    it from Github: [https://github.com/curl/curl](https://github.com/curl/curl))
    and building additional types of interfaces for this application.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`libcurl` 库位于 cURL CLI 之后，没有任何东西阻止我们通过源代码直接访问它（如果您好奇，您可以从 Github 上获取它：[https://github.com/curl/curl](https://github.com/curl/curl))并为该应用程序构建更多类型的接口。'
- en: 1.2.2 What is a web API?
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 什么是 Web API？
- en: Now that we understand what an API is, we will explain the defining features
    of a web API. A web API is an API that uses the Hypertext Transfer Protocol (HTTP)
    protocol to transport data. HTTP is the communication protocol that underpins
    the internet, and it allows us to exchange different kinds of media types, such
    as text, images, video, and JSON, over a network. HTTP uses the concept of a Uniform
    Resource Locator (i.e., URL) to locate resources on the internet, and it has features
    that can be leveraged by API technologies to enhance the interaction with the
    server, such as request methods (e.g., GET, POST, PUT) and HTTP headers. Web APIs
    are implemented using technologies such as SOAP, REST, GraphQL, gRPC, and others
    that are discussed in more detail in appendix A.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了API是什么，我们将解释Web API的定义特征。Web API是一种使用超文本传输协议（HTTP）传输数据的API。HTTP是支撑互联网的通信协议，它允许我们在网络上交换不同类型的媒体类型，如文本、图像、视频和JSON。HTTP使用统一资源定位符（即URL）的概念来定位互联网上的资源，并且它具有API技术可以利用的功能，以增强与服务器的交互，例如请求方法（例如GET、POST、PUT）和HTTP头。Web
    API使用诸如SOAP、REST、GraphQL、gRPC等技术实现，这些技术将在附录A中更详细地讨论。
- en: 1.2.3 How do APIs help us drive microservices integrations?
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 API如何帮助我们驱动微服务集成？
- en: 'Microservices communicate with each other using APIs, and therefore APIs represent
    the interfaces to our microservices. APIs are documented using standard protocols.
    The API documentation tells us exactly what we need to do to interact with the
    microservice and what kind of responses we can expect from it. The better the
    API documentation, the clearer it is for the API consumer how the API works. In
    that sense, as you can see in figure 1.4, API documentation represents a contract
    between services: as long as both the client and the server follow the API documentation,
    communication will work as expected.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过API相互通信，因此API代表了我们的微服务接口。API使用标准协议进行文档化。API文档告诉我们如何与微服务交互以及我们可以期望从它那里得到什么样的响应。API文档越好，API消费者对API的工作方式就越清晰。从这个意义上说，如图1.4所示，API文档代表了服务之间的合同：只要客户端和服务器都遵循API文档，通信就会按预期进行。
- en: '![](../Images/01-04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4](../Images/01-04.png)'
- en: Figure 1.4 API specifications represent a contract between the API server and
    the API client. As long as both the client and the server follow the specification,
    the API integration will work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 API规范代表了API服务器和API客户端之间的合同。只要客户端和服务器都遵循规范，API集成就会正常工作。
- en: Fowler and Lewis popularized the idea that the best strategy for integrating
    microservices is by exposing *smart endpoints* and communicating through *dumb
    pipes* ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)).
    This idea is inspired by the design principles of Unix systems, which establish
    that
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 弗劳尔和刘易斯普及了这样一个观点：集成微服务的最佳策略是通过暴露*智能端点*并通过*哑管道*进行通信（[https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)）。这个想法受到了Unix系统设计原则的启发，这些原则规定：
- en: A system should be made up of small, independent components that do only one
    thing.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系统应由小型、独立的组件组成，这些组件只做一件事。
- en: The output for every component should be designed in such a way that it can
    easily become the input for another component.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件的输出都应该设计得易于成为另一个组件的输入。
- en: 'Unix programs communicate with each other using pipelines, which are simple
    mechanisms for passing messages from one application to another. To illustrate
    this process, think of the following chain of commands, which you can run from
    the terminal of a Unix-based machine (e.g., a Mac or Linux computer):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unix程序通过管道相互通信，管道是简单地将消息从一个应用程序传递到另一个应用程序的机制。为了说明这个过程，请考虑以下命令链，您可以从基于Unix的机器（例如Mac或Linux计算机）的终端运行：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `history` command shows you the list of all commands you have run using
    your Bash profile. The list of commands can be long, so you may want to paginate
    `history`’s output using the `less` command. To pass data from one command to
    the another, use the pipe character (`|`), which instructs the shell to capture
    the output from the `history` command and pipe it as the input of the `less` command.
    We say that this type of pipe is “dumb” because its only job is passing messages
    from one process to another. As you can see in figure 1.5, web APIs exchange data
    through HTTP. The data transport layer knows nothing about the specific API protocol
    we are using, and therefore it represents our “dumb pipe,” while the API itself
    contains all the necessary logic to process the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`history`命令显示了使用你的Bash配置文件运行的所有命令列表。命令列表可能很长，所以你可能想使用`less`命令分页显示`history`的输出。要从一个命令传递数据到另一个命令，使用管道字符（`|`），这指示shell捕获`history`命令的输出并将其作为`less`命令的输入。我们称这种类型的管道为“哑”管道，因为它的唯一任务是传递消息从一个进程到另一个进程。如图1.5所示，Web
    API通过HTTP交换数据。数据传输层对我们使用的特定API协议一无所知，因此它代表我们的“哑”管道，而API本身包含处理数据的所有必要逻辑。'
- en: '![](../Images/01-05.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5](../Images/01-05.png)'
- en: Figure 1.5 Microservices communicate over APIs using a data transport layer,
    such as HTTP over TCP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 微服务通过数据传输层（如TCP上的HTTP）进行API通信。
- en: 'APIs must be stable, and behind them you can change the internal implementations
    of any service provided they comply with the API documentation. This means that
    the consumer of an API must be able to continue calling the API in the exact way
    as before, and it must get the same responses. This leads to another important
    concept in microservices architecture: *replaceability*.[⁶](#pgfId-1071051) The
    idea is that you should be able to completely replace the code base that lies
    behind an endpoint, yet the endpoint, and therefore communication across services,
    will still work. Now that we understand what APIs are and how they help us drive
    integrations between services, let’s look at the most important challenges posed
    by microservices.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: API必须稳定，并且在其背后，你可以更改任何服务的内部实现，只要它们遵守API文档。这意味着API的消费者必须能够继续以前的方式调用API，并且必须获得相同的响应。这导致微服务架构中的另一个重要概念：*可替换性*。[⁶](#pgfId-1071051)
    理念是，你应该能够完全替换端点背后的代码库，而端点以及因此服务之间的通信仍然可以工作。现在我们了解了API是什么以及它们如何帮助我们驱动服务之间的集成，让我们看看微服务带来的最重要的挑战。
- en: 1.3 Challenges of microservices architecture
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 微服务架构的挑战
- en: 'As we saw in section 1.1.2, microservices bring substantial benefits. However,
    they also come with significant challenges. In this section, we discuss the most
    important challenges that microservices pose, which we classify into five main
    categories:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在1.1.2节中看到的，微服务带来了实质性的好处。然而，它们也带来了重大的挑战。在本节中，我们讨论微服务带来的最重要的挑战，我们将它们分为五个主要类别：
- en: Effective service decomposition
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的服务分解
- en: Microservices integration tests
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务集成测试
- en: Handling service unavailability
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务不可用
- en: Tracing distributed transactions
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪分布式事务
- en: Increased operational complexity and infrastructure overhead
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加的操作复杂性和基础设施开销
- en: All the problems and difficulties that we discuss in this section can be addressed
    with specific patterns and strategies, some of which we detail over the course
    of this book. You’ll also find references to other resources that deal with these
    issues in depth. The idea here is to make you aware that microservices are not
    a magical cure for all the problems that monolithic applications present.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中讨论的所有问题和困难都可以通过特定的模式和策略来解决，其中一些我们在本书的后续内容中详细说明。你还会找到其他深入处理这些问题的资源的引用。这里的理念是让你意识到微服务并不是解决单体应用所呈现的所有问题的神奇疗法。
- en: 1.3.1 Effective service decomposition
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 有效的服务分解
- en: One of the most important challenges when designing microservices is service
    decomposition. We must break down a platform into loosely coupled yet sufficiently
    independent components with clearly defined boundaries. You can tell whether you
    have unreasonable coupling between your services if you find yourself changing
    one service whenever you change another service. In such situations, either the
    contract between services is not resilient, or there are enough dependencies between
    both components to justify merging them. Failing to break down a system into independent
    microservices can result in what Chris Richardson, author of *Microservices Patterns*,
    calls a *distributed monolith*, a situation where you combine all the problems
    of monolithic architectures with all the problems of microservices, without enjoying
    the benefits of any of them. In chapter 3, you’ll learn useful design patterns
    and service decomposition strategies that will help you break down a system into
    microservices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时，最关键的挑战之一是服务分解。我们必须将平台分解成松散耦合但足够独立的组件，并具有明确定义的边界。如果您发现自己每次更改另一个服务时都会更改一个服务，那么您就可以知道您在服务之间有不合理的耦合。在这种情况下，要么服务之间的合同不够弹性，要么两个组件之间有足够的依赖关系，这足以证明它们应该合并。未能将系统分解成独立的微服务可能导致Chris
    Richardson，*微服务模式*一书的作者所说的*分布式单体*，这是一种将单体架构的所有问题与微服务的所有问题结合在一起的情况，而没有享受到任何一种架构的好处。在第3章中，您将学习有用的设计模式和分解策略，这些策略将帮助您将系统分解成微服务。
- en: 1.3.2 Microservices integration tests
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 微服务集成测试
- en: In section 1.1.2, we said that microservices are usually easier to test, and
    that their test suites generally run faster. Microservices integration tests,
    however, can be significantly more difficult to run, especially in cases where
    a single transaction involves collaboration among several microservices. When
    your whole application runs within the same process, it is fairly easy to test
    the integration between different components, and most of it will simply require
    well-written unit tests. In a microservices context, to test the integration among
    multiple services you need to be able to run all of them with a setup similar
    to your production environment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.1.2节中，我们提到微服务通常更容易测试，并且它们的测试套件通常运行得更快。然而，微服务集成测试可能运行起来要困难得多，尤其是在单个事务涉及多个微服务协作的情况下。当您的整个应用程序运行在同一个进程中时，测试不同组件之间的集成相对容易，其中大部分只需要编写良好的单元测试。在微服务环境中，为了测试多个服务之间的集成，您需要能够以类似于您的生产环境的方式进行设置来运行所有这些服务。
- en: You can use different strategies to test microservices integrations. The first
    step is making sure that each service has a well-documented and correctly implemented
    API. You can test the API implementation against the API specification using tools
    like Dredd and Schemathesis, as you’ll learn in chapter 12\. You must also ensure
    that the API client is consuming the API exactly as dictated by the API documentation.
    You can write unit tests for the API client using the API documentation to generate
    mocked responses from the service.[⁷](#pgfId-1071081) Finally, none of these tests
    will be sufficient without a full-blown end-to-end test that runs the actual microservices
    making calls to each other.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用不同的策略来测试微服务集成。第一步是确保每个服务都有一个良好文档化和正确实现的API。您可以使用Dredd和Schemathesis等工具，正如您将在第12章中学到的，来测试API实现是否符合API规范。您还必须确保API客户端按照API文档的要求准确消费API。您可以使用API文档编写针对API客户端的单元测试，以从服务生成模拟响应。[⁷](#pgfId-1071081)
    最后，如果没有一个完整的端到端测试来运行实际的微服务并相互调用，那么上述任何测试都不足以满足要求。
- en: 1.3.3 Handling service unavailability
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 处理服务不可用
- en: 'We have to make sure that our applications are resilient in the face of service
    unavailability, connections and request timeouts, erroring requests, and so on.
    For example, when we place an order through a food delivery application such as
    Uber Eats, Delivery Hero, or Deliveroo, a chain of requests between services unfolds
    to process and deliver the order, and any of those requests can fail at any point.
    Let’s take a high-level view of the process that takes place when a user places
    an order (see figure 1.6 for an illustration of the chain of requests):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们的应用程序在面对服务不可用、连接和请求超时、错误请求等情况时具有弹性。例如，当我们通过像Uber Eats、Delivery Hero或Deliveroo这样的食品配送应用程序下单时，服务之间的一系列请求展开以处理和交付订单，任何这些请求在任何一点都可能失败。让我们从用户下单时发生的过程的宏观角度来审视这个过程（见图1.6以展示请求链的示意图）：
- en: A customer places an order and pays for it. The order is placed using the orders
    service, and to process the payment, the orders service works together with the
    payments service.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户下单并支付。订单是通过订单服务进行的，为了处理支付，订单服务与支付服务协同工作。
- en: If payment is successful, the orders service makes a request to the kitchen
    service to schedule the order for production.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果支付成功，订单服务向厨房服务发出请求以安排订单的生产。
- en: Once the order has been produced, the kitchen service makes a request to the
    delivery service to schedule the delivery.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦订单生产完成，厨房服务向配送服务发出请求以安排配送。
- en: '![](../Images/01-06.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-06.png)'
- en: Figure 1.6 Microservices must be resilient to events such as service unavailability,
    request timeouts, and processing errors from other services and either retry the
    requests or come back to the user with a meaningful response.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 微服务必须能够应对服务不可用、请求超时和其他服务的处理错误等事件，要么重试请求，要么向用户返回有意义的响应。
- en: In this complex chain of requests, if one of the services involved fails to
    respond as expected, it can trigger a cascading error through the platform that
    leaves the order unprocessed or in an inconsistent state. For this reason, it
    is important to design microservices so that they can deal reliably with failing
    endpoints. Our end-to-end tests should consider these scenarios and test the behavior
    of our services in those situations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个复杂的请求链中，如果参与的服务中的任何一个未能按预期响应，它可能会通过平台触发级联错误，导致订单未处理或处于不一致的状态。因此，设计微服务时，它们必须能够可靠地处理失败的端点非常重要。我们的端到端测试应该考虑这些场景，并测试我们在这些情况下的服务行为。
- en: 1.3.4 Tracing distributed transactions
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.4 跟踪分布式事务
- en: 'Collaborating services must sometimes handle distributed transactions. Distributed
    transactions are those that require the collaboration of two or more services.
    For example, in a food delivery application, we want to keep track of the existing
    stock of ingredients so that our catalogue can accurately reflect product availability.
    When a user places an order, we want to update the stock of ingredients to reflect
    the new availability. Specifically, we want to update the stock of ingredients
    once the payment has been successfully processed. As you can see in figure 1.7,
    the successful processing of an order involves the following actions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 协作服务有时必须处理分布式事务。分布式事务是指需要两个或更多服务协作的事务。例如，在一个食品配送应用程序中，我们希望跟踪现有原料的库存，以便我们的目录可以准确地反映产品可用性。当用户下单时，我们希望更新原料库存以反映新的可用性。具体来说，我们希望在支付成功处理之后更新原料库存。正如您在图1.7中看到的，订单成功处理涉及以下操作：
- en: Process the payment.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理支付。
- en: If payment is successful, update the order’s status to indicate that it’s in
    progress.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果支付成功，将订单状态更新为表示其正在处理中。
- en: Interface with the kitchen service to schedule the order for production.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与厨房服务接口，安排订单的生产。
- en: Update the stock of ingredients to reflect their current availability.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新原料库存以反映其当前可用性。
- en: '![](../Images/01-07.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-07.png)'
- en: Figure 1.7 A distributed transaction involves collaboration among multiple services.
    If any of these services fails, we must be able to handle the failure and provide
    a meaningful response to the user.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 分布式事务涉及多个服务之间的协作。如果其中任何服务失败，我们必须能够处理失败并提供对用户有意义的响应。
- en: All of these operations are related, and they must be orchestrated so that they
    either all succeed or fail together. We can’t have an order successfully paid
    without correctly updating its status, and we shouldn’t schedule its production
    if payment fails. We may want to update the availability of the ingredients at
    the time of making the order, and if payment fails later on, we want to make sure
    we rollback the update. If all these actions happen within the same process, managing
    the flow is straightforward, but with microservices we must manage the outcomes
    of various processes. When using microservices, the challenge is ensuring that
    we have a robust communication process among services so that we know exactly
    what kind of error happens when it does, and we take appropriate measures in response
    to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都是相关的，并且它们必须协调一致，要么全部成功，要么全部失败。我们不能在没有正确更新其状态的情况下成功完成订单，如果支付失败，我们也不应该安排其生产。我们可能希望在制作订单时更新原料的可用性，如果支付后来失败，我们想要确保回滚更新。如果所有这些操作都在同一个流程中发生，管理流程就很简单，但使用微服务时，我们必须管理各个流程的结果。当使用微服务时，挑战在于确保我们在服务之间有一个健壮的通信过程，以便我们确切知道当错误发生时是什么类型的错误，并采取适当的措施来应对。
- en: In the case of services that work collaboratively to serve certain requests,
    you also must be able to trace the cycle of the request as it goes across the
    different services to be able to spot errors during the transaction. To gain visibility
    of distributed transactions, you’ll need to set up distributed logging and tracing
    for your microservices. You can learn more about this topic from Jamie Riedesel’s
    *Software Telemetry* (Manning, 2021).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务协同工作以处理某些请求的情况下，你还必须能够跟踪请求在其穿越不同服务时的周期，以便在事务过程中发现错误。为了获得分布式事务的可见性，你需要为你的微服务设置分布式日志和跟踪。你可以从Jamie
    Riedesel的《软件遥测》（Manning，2021年）中了解更多关于这个主题的信息。
- en: 1.3.5 Increased operational complexity and infrastructure overhead
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.5 运营复杂性和基础设施开销增加
- en: Another important challenge that comes with microservices is the increased operational
    complexity and operational overhead they add to your platform. When the whole
    backend of your website runs within a single application build, you only need
    to deploy and monitor one process. When you have a dozen microservices, every
    service must be configured, deployed, and managed. And this includes not only
    the provisioning of servers to deploy the services, but also log aggregation streams,
    monitoring systems, alerts, self-recovery mechanisms, and so on. As you’ll learn
    in chapter 3, every service owns its own database, which means they also require
    multiple database setups with all the features needed to operate at scale. And
    it is not unusual that a new deployment changes the endpoint for a microservice,
    whether it’s the IP, the base URL, or a specific path within a generic URL, which
    means its consumers must be notified of the changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务的引入，另一个重要的挑战是它们给平台带来的增加的运营复杂性和运营开销。当你的整个网站后端运行在单个应用程序构建中时，你只需要部署和监控一个进程。当你有十几个微服务时，每个服务都必须进行配置、部署和管理。这包括不仅为部署服务而提供服务器，还包括日志聚合流、监控系统、警报、自恢复机制等等。正如你将在第3章中学到的，每个服务都有自己的数据库，这意味着它们也需要多个数据库设置，包括所有在规模上运行所需的功能。而且，一个新部署改变微服务的端点并不罕见，无论是IP、基本URL还是通用URL中的特定路径，这意味着其消费者必须被告知这些变化。
- en: When Amazon first started their journey toward a microservices architecture,
    they discovered that development teams would spend about 70% of their time managing
    infrastructure ([https://vimeo.com/29719577](https://vimeo.com/29719577) at 07:53).
    This is a very real risk that you face if you do not adopt best practices for
    infrastructure automation from the beginning. And even if you do, you are likely
    to spend a significant amount of time developing custom tooling to manage your
    services effectively and efficiently.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当亚马逊刚开始向微服务架构转型时，他们发现开发团队大约会花费70%的时间来管理基础设施([https://vimeo.com/29719577](https://vimeo.com/29719577)
    在07:53处)。如果你从一开始就没有采用最佳实践进行基础设施自动化，这将是一个非常真实的风险。即使你采取了这些措施，你也可能需要花费大量时间开发定制工具来有效地管理你的服务。
- en: 1.4 Introducing documentation-driven development
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 介绍文档驱动开发
- en: 'As we explained in section 1.2.3, the success of an API integration depends
    on good API documentation, and in this section, we introduce an API development
    workflow that puts documentation at the forefront of API development. As you can
    see in figure 1.8, documentation-driven development is an approach to building
    APIs that works in three stages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在1.2.3节中解释的，API集成的成功取决于良好的API文档，在本节中，我们介绍了一种将文档置于API开发前沿的API开发工作流程。如图1.8所示，以文档驱动的开发是构建API的一种方法，它分为三个阶段：
- en: You design and document the API.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您设计和记录API。
- en: You build the API client and the API server following the documentation.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照文档说明，您构建API客户端和API服务器。
- en: You test both the API client and the API server against the documentation.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将API客户端和API服务器都针对文档进行测试。
- en: '![](../Images/01-08.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01-08.png)'
- en: 'Figure 1.8 Documentation-driven development works in three stages: design and
    document, implement, and validate.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：以文档驱动的开发分为三个阶段：设计和文档、实施和验证。
- en: Let’s dive into each of these points. The first step involves designing and
    documenting the specification. We build APIs for others to consume, so before
    we build the API, we must produce an API design that meets the needs of our API
    clients. Just as we involve users when we design an application’s user interface
    (UI), we must also engage with our API consumers when we design the API.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些要点。第一步包括设计和记录规范。我们为他人构建API，因此在构建API之前，我们必须创建一个满足API客户端需求的API设计。正如我们在设计应用程序的用户界面（UI）时涉及用户一样，在设计API时也必须与API消费者进行互动。
- en: Good API design delivers good developer experience, while good API documentation
    helps to deliver successful API integrations. What is API documentation? API documentation
    is a description of the API following a standard interface description language
    (IDL), such as OpenAPI for REST APIs and the Schema Definition Language (SDL)
    for GraphQL APIs. Standard IDLs have ecosystems of tools and frameworks that make
    it easier to build, test, and visualize our APIs, and therefore it’s worth investing
    time in studying them. In this book, you’ll learn to document your APIs with OpenAPI
    (chapter 5) and the SDL (chapter 8).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的API设计可以提供良好的开发者体验，而良好的API文档有助于实现成功的API集成。什么是API文档？API文档是根据标准接口描述语言（IDL）对API的描述，例如OpenAPI用于REST
    API和Schema Definition Language（SDL）用于GraphQL API。标准IDL拥有工具和框架的生态系统，这使得构建、测试和可视化我们的API变得更加容易，因此投入时间学习它们是值得的。在这本书中，您将学习如何使用OpenAPI（第5章）和SDL（第8章）来记录您的API。
- en: Once we have produced a documented API design, we move on to the second stage,
    which consists of building the API server and the API client against the API documentation.
    In chapters 2 and 6, you’ll learn to analyze the requirements of an OpenAPI specification
    and to build an API application against them, and in chapter 10, we’ll apply the
    same approach to GraphQL APIs. API client developers can also leverage the API
    documentation to run API mock servers and test their code against them.[⁸](#pgfId-1071148)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了文档化的API设计，我们就进入第二阶段，这一阶段包括根据API文档构建API服务器和API客户端。在第2章和第6章中，您将学习如何分析OpenAPI规范的要求，并根据这些要求构建API应用程序，而在第10章中，我们将应用相同的方法来处理GraphQL
    API。API客户端开发者还可以利用API文档来运行API模拟服务器，并对其代码进行测试。[⁸](#pgfId-1071148)
- en: The final stage involves testing our implementation against the API documentation.
    In chapter 12, you’ll learn to use automated API testing tools such as Dredd and
    Schemathesis, which can generate a solid battery of tests for your API. Running
    Dredd and Schemathesis in combination with your application unit test suite will
    give you confidence that your API implementation works as it should. You should
    run these tests in your continuous integration server to make sure you don’t release
    any code that breaks the contract with the API documentation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的阶段涉及测试我们的实现与API文档的一致性。在第12章中，您将学习如何使用自动化的API测试工具，如Dredd和Schemathesis，这些工具可以为您的API生成一系列可靠的测试。将Dredd和Schemathesis与您的应用程序单元测试套件结合使用，将使您确信您的API实现按预期工作。您应该在持续集成服务器上运行这些测试，以确保不会发布任何违反API文档约定的代码。
- en: 'By putting API documentation at the forefront of the development process, documentation-driven
    development helps you avoid one of the most common problems API developers face:
    disagreements between the client and the server development teams about how the
    API should work. In the absence of robust API documentation, developers often
    need to guess on implementation details of the API. In such cases, the API rarely
    succeeds its first integration test. Although documentation-driven development
    won’t give a 100% guarantee that your API integrations will work, it will significantly
    reduce the risk of API integration failure.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将API文档置于开发过程的前端，文档驱动开发有助于你避免API开发者面临的最常见问题之一：客户端和服务器开发团队在API应该如何工作的问题上存在分歧。在没有健壮的API文档的情况下，开发者经常需要猜测API的实现细节。在这种情况下，API很少在第一次集成测试中成功。尽管文档驱动开发不能保证你的API集成100%成功，但它将显著降低API集成失败的风险。
- en: 1.5 Introducing the CoffeeMesh application
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 介绍CoffeeMesh应用程序
- en: To illustrate the concepts and ideas that we explain throughout this book, we’ll
    build components of an application called CoffeeMesh. CoffeeMesh is a fictitious
    application that allows customers to order coffee in any location, at any time.
    The CoffeeMesh platform consists of a collection of microservices that implement
    different capabilities, such as processing orders and scheduling deliveries. We’ll
    undertake a formal analysis and design of the CoffeeMesh platform in chapter 3\.
    To give you a taste of the kinds of things you’ll learn in this book, we’ll begin
    implementing the API of CoffeeMesh’s orders service in chapter 2\. Before we close
    this chapter, I’d like to dedicate a section to explaining what you’ll learn from
    this book.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明本书中解释的概念和想法，我们将构建一个名为CoffeeMesh的应用程序的部分组件。CoffeeMesh是一个虚构的应用程序，允许客户在任何地点、任何时间订购咖啡。CoffeeMesh平台由一组实现不同功能的微服务组成，例如处理订单和安排配送。我们将在第3章中对CoffeeMesh平台进行正式的分析和设计。为了让你了解这本书中你将学到的东西，我们将在第2章中开始实现CoffeeMesh订单服务的API。在我们结束这一章之前，我想专门用一节来解释你将从这本书中学到什么。
- en: 1.6 Who this book is for and what you will learn
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 这本书面向的对象以及你将学到什么
- en: To make the most out of this book, you should be familiar with the basics of
    web development. The code examples in the book are in Python, so a basic understanding
    of Python is beneficial but not necessary to be able to follow along with them.
    You do not need to have knowledge of web APIs or microservices, as we will explain
    these technologies in depth. It is useful if you are familiar with the model-view-controller
    (MVC) pattern for web development or its variants, such as the model-template-view
    (MTV) pattern implemented by Python’s popular Django framework. We will draw comparisons
    with these patterns from time to time to illustrate certain concepts. Basic familiarity
    with Docker and cloud computing will be useful to get through the chapters about
    deployments, but I’ll do my best to explain every concept in detail.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这本书，你应该熟悉网络开发的基础知识。书中的代码示例使用Python编写，因此对Python的基本理解有益，但不是必须的，以便能够跟随示例。你不需要了解网络API或微服务，因为我们将深入解释这些技术。如果你熟悉网络开发中的模型-视图-控制器（MVC）模式或其变体，例如Python流行的Django框架实现的模型-模板-视图（MTV）模式，这将很有用。我们将不时将这些模式与某些概念进行比较以说明。对Docker和云计算的基本熟悉将有助于通过部署章节，但我会尽最大努力详细解释每个概念。
- en: This book shows you how to develop API-driven microservices with Python through
    a hands-on approach. You will learn
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本书通过实践方法展示了如何使用Python开发API驱动的微服务。你将学习
- en: Service decomposition strategies for designing microservice architectures
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计微服务架构的服务分解策略
- en: How to design REST APIs and how to document them using the OpenAPI specification
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计和使用OpenAPI规范来记录REST API
- en: How to build REST APIs in Python using popular frameworks like FastAPI and Flask
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用FastAPI和Flask等流行框架在Python中构建REST API
- en: How to design and consume GraphQL APIs and how to build them using Python’s
    Ariadne framework
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计和消费GraphQL API，以及如何使用Python的Ariadne框架构建它们
- en: How to test your APIs using property-based testing and API testing frameworks
    such as Dredd and Schemathesis
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基于属性的测试和Dredd、Schemathesis等API测试框架测试你的API
- en: Useful design patterns to achieve loose coupling in your microservices
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的微服务中实现松耦合的有用设计模式
- en: How to add authentication and authorization to your APIs using Open Authorization
    (OAuth) and OpenID Connect (OIDC)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用开放授权（OAuth）和开放ID连接（OIDC）为您的API添加身份验证和授权
- en: How to deploy your microservices using Docker and Kubernetes to AWS
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Docker和Kubernetes将您的微服务部署到AWS
- en: By the end of this book, you will be familiar with the benefits that microservices
    architectures bring for web applications as well as the challenges and difficulties
    that come with them. You will know how to integrate microservices using APIs,
    you will know how to build and document those APIs using standards and best practices,
    and you will be prepared to define the domain of an API with clear application
    boundaries. Finally, you’ll also know how to test, deploy, and secure your microservice
    APIs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书结束时，您将熟悉微服务架构为Web应用程序带来的好处，以及随之而来的挑战和困难。您将了解如何使用API集成微服务，您将了解如何使用标准和最佳实践构建和记录这些API，您将准备好以清晰的应用程序边界定义API的领域。最后，您还将了解如何测试、部署和确保您的微服务API的安全性。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Microservices are an architectural pattern in which components of a system are
    designed and built as independently deployed services. This results in smaller
    and more maintainable code bases and allows services to be optimized and scaled
    independently of each other.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是一种架构模式，其中系统的组件被设计和构建为独立部署的服务。这导致代码库更小、更易于维护，并允许服务独立于彼此进行优化和扩展。
- en: Monoliths are an architectural pattern in which whole applications are deployed
    in a single build and run in the same process. This makes the application easier
    to deploy and monitor, but it also makes deployments more challenging when the
    code base grows large.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构是一种架构模式，其中整个应用程序在一个构建中部署，并在同一进程中运行。这使得应用程序更容易部署和监控，但当代码库变得很大时，部署也更具挑战性。
- en: Applications can have multiple types of interfaces, such as UIs, CLIs, and APIs.
    An API is an interface that allows us to interact with an application programmatically
    from our code or terminal.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以有多种类型的接口，例如UI、CLI和API。API是一种允许我们从代码或终端以编程方式与应用程序交互的接口。
- en: A web API is an API that runs on a web server and uses HTTP for data transport.
    We use web APIs to expose service capabilities through the internet.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API是在Web服务器上运行的API，使用HTTP进行数据传输。我们使用Web API通过互联网公开服务功能。
- en: Microservices talk to each other using smart endpoints and “dumb pipes.” A dumb
    pipe is a pipe that simply transfers data from one component to another. A great
    example of a dumb pipe for microservices is HTTP, which exchanges data between
    the API client and the API server without knowing anything about the API protocol
    being used. Therefore, web APIs are a great technology for driving integrations
    between microservices.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务通过智能端点和“哑管道”相互通信。哑管道是一种简单地将数据从一个组件传输到另一个组件的管道。对于微服务来说，HTTP是一个很好的哑管道示例，它在不了解所使用的API协议的情况下，在API客户端和API服务器之间交换数据。因此，Web
    API是推动微服务之间集成的一种优秀技术。
- en: 'Despite their benefits, microservices also bring the following challenges:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管它们有好处，但微服务也带来了以下挑战：
- en: '*Effective service decomposition*—We must design services with clear boundaries
    around specific subdomains; otherwise, we risk building a “distributed monolith.”'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效的服务分解*——我们必须围绕特定的子域设计服务，以具有清晰的边界；否则，我们可能会构建一个“分布式单体”。'
- en: '*Microservice integration tests*—Running integration tests for all microservices
    is challenging, but we can reduce the risk of integration failures by ensuring
    APIs are correctly implemented.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*微服务集成测试*——对所有微服务进行集成测试具有挑战性，但我们可以通过确保API正确实现来降低集成失败的风险。'
- en: '*Handling service unavailability*—Collaborating services are vulnerable to
    service unavailability, request timeouts, and processing errors, and therefore
    must be able to handle those scenarios.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理服务不可用*——协作服务容易受到服务不可用、请求超时和处理错误的影响，因此必须能够处理这些场景。'
- en: '*Tracing distributed transactions*—Tracing errors across multiple services
    is challenging and requires software telemetry tools that allow you to centralize
    logs, enable API visibility, and trace requests across services.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跟踪分布式事务*——跨多个服务跟踪错误具有挑战性，需要软件遥测工具，这些工具允许您集中日志、启用API可见性并跨服务跟踪请求。'
- en: '*Increased operational complexity and infrastructure overhead*—Each microservice
    requires its own infrastructure provisioning, including servers, monitoring systems,
    and alerts, so you need to invest additional efforts in infrastructure automation.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*增加的操作复杂性和基础设施开销*——每个微服务都需要自己的基础设施配置，包括服务器、监控系统以及警报，因此您需要在基础设施自动化方面投入额外的努力。'
- en: 'Documentation-driven development is an API development workflow that works
    in three stages:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以文档驱动开发是一种API开发工作流程，分为三个阶段：
- en: Design and document the API.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计并记录API。
- en: Build the API against the documentation.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据文档构建API。
- en: Test the API against the documentation.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试API与文档的一致性。
- en: By putting API documentation at the forefront of the development process, documentation-driven
    development helps you avoid many common problems that API developers face and
    therefore reduce the chances of API integration failure.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将API文档置于开发过程的前端，文档驱动开发有助于您避免API开发者面临的一些常见问题，从而降低API集成失败的风险。
- en: '* * *'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ Sam Newman, *Building Microservices* (O’Reilly, 2015), p. 2.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ Sam Newman，*Building Microservices*（O’Reilly，2015年），第2页。
- en: ² For a comprehensive view of the different interfaces that can be used to enable
    communication between microservices, see Chris Richardson, *Microservices Patterns*
    (Manning, 2019).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ² 为了全面了解可用于实现微服务之间通信的不同接口，请参阅Chris Richardson所著的《Microservices Patterns》（Manning，2019年）。
- en: ³ For a thorough analysis of strategic architectural decisions around monoliths
    and microservices, see Vernon, Vaughn and Tomasz Jaskula, *Strategic Monoliths
    and Microservices* (Addison-Wesley, 2021).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 为了对单体架构和微服务架构的战略性架构决策进行彻底分析，请参阅Vernon、Vaughn和Tomasz Jaskula合著的《Strategic Monoliths
    and Microservices》（Addison-Wesley，2021年）。
- en: '⁴ For a more comprehensive analysis of the history of microservices architecture
    and its precursors, see Nicola Dragoni et al, “Microservices: Yesterday, Today,
    and Tomorrow,” *Present and Ulterior Software Engineering* (Springer, 2017), pp.
    195–216.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '⁴ 为了更全面地分析微服务架构及其前身的历史，请参阅Nicola Dragoni等人撰写的“Microservices: Yesterday, Today,
    and Tomorrow”，载于《Present and Ulterior Software Engineering》（Springer，2017年），第195–216页。'
- en: '⁵ Allen Wang and Sudhir Tonse, “Announcing Ribbon: Tying the Netflix Mid-Tier
    Services Together,” *Netflix Technology Blog*, January 18, 2013, [https://netflixtechblog.com/announcing-ribbon-tying-the-netflix-mid-tier-services-together-a89346910a62](https://netflixtechblog.com/announcing-ribbon-tying-the-netflix-mid-tier-services-together-a89346910a62).
    For an excellent discussion of the difference between service-oriented architecture
    (SOA) and microservices architecture, see Richardson, *Microservices Patterns*,
    pp. 13–14.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '⁵ Allen Wang和Sudhir Tonse，"Announcing Ribbon: Tying the Netflix Mid-Tier Services
    Together"，载于《Netflix Technology Blog》，2013年1月18日，[https://netflixtechblog.com/announcing-ribbon-tying-the-netflix-mid-tier-services-together-a89346910a62](https://netflixtechblog.com/announcing-ribbon-tying-the-netflix-mid-tier-services-together-a89346910a62)。关于面向服务架构（SOA）与微服务架构之间差异的精彩讨论，请参阅Richardson所著的《Microservices
    Patterns》，第13–14页。'
- en: ⁶ Newman, *Building Microservices*, pp. 7–8.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ Newman，*Building Microservices*，第7–8页。
- en: ⁷ To learn more about API development workflows and how to use API mock servers
    to build the client, check out my presentation “API Development Workflows for
    Successful Integrations,” Manning API Conference, August 3, 2021, [https://youtu.be/SUKqmEX_uwg](https://youtu.be/SUKqmEX_uwg).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 要了解更多关于API开发工作流程以及如何使用API模拟服务器构建客户端的信息，请查看我的演示文稿“API Development Workflows
    for Successful Integrations”，Manning API会议，2021年8月3日，[https://youtu.be/SUKqmEX_uwg](https://youtu.be/SUKqmEX_uwg)。
- en: ⁸ To learn how API server and client developers can leverage API documentation
    in their software development process, check out my talk “Leveraging API Documentation
    to Deliver Reliable API Integrations,” API Specifications Conference, September
    28–29, 2021, [https://youtu.be/kAWvM-CVcnw](https://youtu.be/kAWvM-CVcnw).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ⁸ 要了解API服务器和客户端开发者如何在软件开发过程中利用API文档，请查看我的演讲“Leveraging API Documentation to
    Deliver Reliable API Integrations”，API规范会议，2021年9月28日至29日，[https://youtu.be/kAWvM-CVcnw](https://youtu.be/kAWvM-CVcnw)。
