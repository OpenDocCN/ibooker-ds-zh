- en: 16 Advanced concurrent programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 高级并发编程
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The Fork/Join API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fork/Join API
- en: Work-stealing algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作窃取算法
- en: Concurrency and functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发与函数式编程
- en: Under the hood with Kotlin coroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin协程背后的原理
- en: Clojure concurrency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure并发
- en: Software transactional memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件事务内存
- en: Agents
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: In this chapter, we will bring together several themes from earlier chapters.
    In particular, we will weave together the functional programming concepts from
    previous chapters with the Java concurrency libraries from chapter 6\. Our non-Java
    languages get included as well, with some novel concurrency aspects of both Kotlin
    and Clojure appearing later in the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将结合前面章节中的几个主题。特别是，我们将把前面章节中的函数式编程概念与第6章中的Java并发库编织在一起。我们的非Java语言也包括在内，Kotlin和Clojure的一些新颖并发特性将在本章后面出现。
- en: Note The concepts in this chapter, such as coroutines and agents (aka actors),
    are also increasingly part of the landscape of Java concurrency.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中的概念，如协程和代理（又称演员），也越来越多地成为Java并发领域的一部分。
- en: 'We’ll kick off with a slight oddity: the Java Fork/Join API. This framework
    allows a certain class of concurrent problems to be handled more efficiently than
    the executors we saw in chapter 6.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个小小的异常开始：Java Fork/Join API。这个框架允许一类并发问题比我们在第6章中看到的executors更有效地处理。
- en: 16.1 The Fork/Join framework
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 Fork/Join框架
- en: As we discussed in chapter 7, processor speeds (or, more properly, transistor
    counts on CPUs) have increased hugely in recent years. I/O performance has not
    had the same remarkable improvement, and so the end result is that waiting for
    I/O is now a common situation. This suggests that we could make better use of
    the processing capabilities inside our computers. The Fork/Join (F/J) framework
    is an attempt to do just that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第7章中讨论的那样，处理器速度（或者更确切地说，CPU上的晶体管数量）在近年来大幅提高。I/O性能并没有相同的显著改进，因此最终结果是等待I/O现在成为一种常见情况。这表明我们可以更好地利用我们计算机内部的处理器能力。Fork/Join（F/J）框架正是为了实现这一点而进行的尝试。
- en: F/J is all about automatic scheduling of tasks on a thread pool that is invisible
    to the user. To do this, the tasks must be able to be broken up in a way that
    the user specifies. In many applications, F/J has a notion of “small” and “large”
    tasks that is very natural for the framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: F/J主要关于在用户不可见的线程池上自动调度任务。为此，任务必须能够以用户指定的方式进行拆分。在许多应用中，F/J有一个关于“小任务”和“大任务”的概念，这对于框架来说是非常自然的。
- en: 'Let’s take a quick look at some of the headline facts and fundamentals related
    to F/J:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下与F/J相关的某些主要事实和基本概念：
- en: The framework introduces a new kind of executor service, called a `ForkJoinPool`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架引入了一种新的执行器服务类型，称为`ForkJoinPool`。
- en: '`ForkJoinPool` handles a unit of concurrency (the `ForkJoinTask`) that is “smaller”
    than a `Thread`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`处理一个比`Thread`“更小”的并发单元（`ForkJoinTask`）。'
- en: '`ForkJoinTask` can be scheduled in a more lightweight manner by the `ForkJoinPool`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`可以通过更轻量级的方式对`ForkJoinTask`进行调度。'
- en: 'F/J makes use of the following two kinds of tasks (both represented as instances
    of `ForkJoinTask`):'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F/J使用以下两种类型的任务（都表示为`ForkJoinTask`的实例）：
- en: “Small” tasks are those that can be performed straightaway without consuming
    too much processor time.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “小任务”是指那些可以立即执行而不会消耗太多处理器时间的任务。
- en: “Large” tasks are those that need to be split up (possibly more than once) before
    they can be directly performed.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: “大任务”是指在直接执行之前需要拆分（可能需要多次拆分）的任务。
- en: The framework provides basic methods to support the splitting up of large tasks.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架提供了基本方法来支持大任务的拆分。
- en: The framework has automatic scheduling and rescheduling.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架具有自动调度和重新调度功能。
- en: One key feature of the framework is that it’s expected that these lightweight
    tasks may well spawn other instances of `ForkJoinTask`, which will be scheduled
    on the same thread pool that executed their parent task. This pattern is sometimes
    called *divide and conquer*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的一个关键特性是，预期这些轻量级任务可能会产生其他`ForkJoinTask`实例，这些实例将在执行其父任务的同一个线程池上进行调度。这种模式有时被称为*分而治之*。
- en: We’ll start with a simple example of using the F/J framework, then briefly touch
    on the features of problems that are well suited to this type of parallel processing
    approach. We will then discuss the feature called “work-stealing” as used in F/J
    and its relevance in a wider context. The best way to get started with F/J is
    with an example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用F/J框架的简单示例开始，然后简要介绍适合这种并行处理方法的问题特征。然后我们将讨论F/J中使用的“工作窃取”功能及其在更广泛环境中的相关性。开始使用F/J的最佳方式是举一个例子。
- en: 16.1.1 A simple F/J example
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.1 一个简单的F/J示例
- en: 'As a simple example of what the F/J framework can do, consider the following
    case: we have a number of transaction objects created at various times. The class
    we’ll use to represent them is `Transaction`, as shown here, which is an evolution
    of the `TransferTask` class we met in chapters 5 and 6:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为F/J框架能做什么的一个简单例子，考虑以下情况：我们在不同时间创建了一系列事务对象。我们将使用`Transaction`类来表示它们，如下所示，这是从第5章和第6章中遇到的`TransferTask`类演变而来的：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We want to obtain a list of transactions, sorted by time. To achieve this, we’ll
    use F/J as a multithreaded sort—in fact a variant of the *MergeSort* algorithm.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望获得一个按时间排序的事务列表。为了实现这一点，我们将使用F/J作为多线程排序——实际上是一种*归并排序*算法的变体。
- en: Our example uses `RecursiveAction`, which is a specialized subclass of `ForkJoinTask`.
    It is simpler than general `ForkJoinTask` because it’s explicit about not having
    any overall result (the transactions will be reordered in place), and it emphasizes
    the recursive nature of the tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子使用了`RecursiveAction`，它是`ForkJoinTask`的一个特殊子类。它比一般的`ForkJoinTask`简单，因为它明确表示没有整体结果（事务将在原地重新排序），并且强调任务的递归性质。
- en: The `TransactionSorter` class provides a way of ordering a list of updates using
    the `compareTo()` method on `Transaction` objects. The `compute()` method (which
    you have to implement because it’s abstract in the `RecursiveAction` superclass)
    basically orders an array of transactions by their creation time, as shown in
    the next listing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionSorter`类提供了一种使用`Transaction`对象的`compareTo()`方法对一系列更新进行排序的方法。`compute()`方法（你必须实现，因为它在`RecursiveAction`超类中是抽象的）基本上是按照创建时间对事务数组进行排序，如下一个列表所示。'
- en: Listing 16.1 Sorting with a `RecursiveAction`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.1 使用`RecursiveAction`进行排序
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ 32 or fewer sorted serially
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 32个或更少的排序序列
- en: ❷ The method defined in RecursiveAction
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在RecursiveAction中定义的方法
- en: 'To use the sorter, you can drive it with some code like that shown next, which
    will generate some transactions and shuffle them, before passing them to the sorter.
    The output is the reordered updates:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用排序器，你可以用一些像下面这样的代码来驱动它，这将生成一些事务并将它们打乱，然后再将它们传递给排序器。输出是重新排序的更新：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The promise of F/J seems tantalizing, but in practice, not every problem is
    easily reduced to as simple a form as the multithreaded `MergeSort` we’ve just
    discussed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: F/J的承诺似乎很有吸引力，但在实践中，并不是每个问题都能像我们刚才讨论的多线程`MergeSort`那样简单地简化。
- en: This is an example of the antipattern *Easy Cases Are Easy*, in which developers
    can be seduced by a simple-seeming technology that allows an easy task to be achieved
    with very little effort but disguises the fact that the technology does not scale
    or generalize well to the less-easy cases. We should say something about the sorts
    of problems that are likely to be tractable by the use of F/J, and those problems
    for which another approach will likely be better.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个反模式“简单情况很简单”的例子，其中开发者可能会被一种看似简单的技术所吸引，这种技术允许通过非常少的努力完成简单的任务，但掩盖了技术无法扩展或很好地推广到不那么简单的情况的事实。我们应该谈谈那些可能通过使用F/J方法容易解决的问题，以及那些可能更适合其他方法的问题。
- en: 16.1.2 Parallelizing problems for F/J
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.2 并行化适合F/J的问题
- en: 'Here are some examples of problems well suited to the F/J approach:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些适合F/J方法的典型问题示例：
- en: Simulating the motion of large numbers of simple objects (e.g., particle effects)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟大量简单物体的运动（例如，粒子效果）
- en: Log file analysis
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件分析
- en: Data operations where a quantity is calculated from aggregated inputs (e.g.,
    map-reduce operations)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据操作，其中从一个聚合输入中计算出一个数量（例如，map-reduce操作）
- en: Another way of looking at this is to say that a good problem for F/J is one
    that can be broken up, as shown in figure 16.1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是说，一个好的F/J问题是可以分解的，如图16.1所示。
- en: '![](../Images/CH16_F01_Evans2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH16_F01_Evans2.png)'
- en: Figure 16.1 Fork and join
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 分支和合并
- en: 'One practical way of determining whether a problem is likely to reduce well
    is to apply the following checklist to the problem and its subtasks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个问题是否可能得到良好解决的一个实用方法是将以下清单应用于该问题和其子任务：
- en: Can the problem’s subtasks work without explicit cooperation or synchronization
    between the subtasks?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题子任务能否在没有子任务之间显式合作或同步的情况下工作？
- en: Do the subtasks calculate some value from their data without altering it (i.e.,
    are they pure functions)?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子任务是否从其数据中计算一些值而不改变它（即，它们是否是纯函数）？
- en: Is divide and conquer natural for the subtasks?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于子任务来说，分而治之是否是自然的？
- en: If the answer to the preceding questions is “Yes!” or “Mostly, but with edge
    cases,” your problem may well be amenable to a F/J approach. If, on the other
    hand, the answer to those questions is “Maybe” or “Not really,” you may well find
    that F/J performs poorly, and a different approach may work better.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对前面问题的答案是“是！”或“大多数情况下是，但有边缘情况”，那么你的问题可能非常适合 F/J 方法。另一方面，如果那些问题的答案是“可能”或“不是真的”，你可能会发现
    F/J 的性能不佳，而另一种方法可能更有效。
- en: Designing good multithreaded algorithms is hard, and F/J doesn’t work in every
    circumstance. It’s very useful within its own domain of applicability, but in
    the end, you have to decide whether your problem fits within the framework. If
    not, you must be prepared to develop your own solution, which probably means building
    on top of the superb toolbox of `java.util.concurrent`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的多线程算法很困难，F/J 并不适用于所有情况。它在自己的适用范围内非常有用，但最终，你必须决定你的问题是否适合该框架。如果不适合，你必须准备好开发自己的解决方案，这可能意味着在
    `java.util.concurrent` 的出色工具箱之上构建。
- en: 16.1.3 Work-stealing algorithms
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.3 工作窃取算法
- en: '`ForkJoinTask` is the superclass of `RecursiveAction`. It’s a generic class
    in the return type of an action (so `RecursiveAction` extends `ForkJoinTask<Void>`).
    This makes `ForkJoinTask` very suitable for map-reduce approaches that boil down
    a dataset and either return a result or act via side effect (as is the case for
    `RecursiveAction`).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinTask` 是 `RecursiveAction` 的超类。它是一个动作返回类型中的泛型类（因此 `RecursiveAction`
    扩展 `ForkJoinTask<Void>`）。这使得 `ForkJoinTask` 非常适合将数据集归结为一种方法，并返回一个结果或通过副作用执行（正如
    `RecursiveAction` 的情况）。'
- en: Objects of type `ForkJoinTask` are scheduled on a `ForkJoinPool`, which is a
    new type of executor service designed specifically for these lightweight tasks.
    The service maintains a list of tasks for each thread, and if one task finishes,
    the service can reassign tasks from a fully loaded thread to an idle one. We can
    see this happening in figure 16.2
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinTask` 类型的对象在 `ForkJoinPool` 上进行调度，这是一种专为这些轻量级任务设计的新的执行服务类型。服务为每个线程维护一个任务列表，如果一个任务完成，服务可以从满载的线程重新分配任务给空闲的线程。我们可以在图16.2中看到这种情况。'
- en: '![](../Images/CH16_F02_Evans2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2](../Images/CH16_F02_Evans2.png)'
- en: 'Figure 16.2 Work-stealing: When the second thread completes its task, the service
    reassigns a task from the still-busy first thread to the second.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 工作窃取：当第二个线程完成其任务时，服务将任务从仍然忙碌的第一个线程重新分配给第二个线程。
- en: Without this *work-stealing algorithm*, scheduling problems could arise related
    to the two sizes of tasks. In general, the two sizes of tasks could take very
    different lengths of time to run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个 *工作窃取算法*，可能会出现与两种任务大小相关的调度问题。一般来说，两种大小的任务可能需要非常不同的运行时间。
- en: For example, one thread may have a run queue consisting of only small tasks,
    whereas another may have only large tasks. If the small tasks run five times faster
    than large tasks, the thread with only small tasks may well find itself idle before
    the large-task thread finishes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个线程可能只有一个由小任务组成的工作队列，而另一个线程可能只有大任务。如果小任务运行速度比大任务快五倍，那么只有小任务的线程很可能在大型任务线程完成之前就空闲了。
- en: warning Work-stealing depends on the assumption that the tasks are independent
    of each other. If this assumption is not valid, the results of calculations could
    be different from run to run.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：工作窃取依赖于任务之间相互独立的假设。如果这个假设不成立，计算结果可能会在不同的运行中有所不同。
- en: 'Work-stealing has been implemented precisely to work around this problem and
    allow all the pool threads to be used throughout the lifecycle of the F/J job.
    It’s completely automatic, and you don’t need to do anything specific to reap
    the benefits of work-stealing. It’s another example of the runtime environment
    doing more to help developers manage concurrency, rather than making it a manual
    task. The documentation also makes it explicit: `ForkJoinPool` may also be appropriate
    for use with event-style tasks that are never joined.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 工作窃取（Work-stealing）被精确实现以解决此问题，并允许在整个 F/J 作业的生命周期中使用所有池线程。这是完全自动的，你不需要做任何具体的事情来获得工作窃取的好处。这是运行时环境为了帮助开发者管理并发而做更多工作的另一个例子。文档也明确指出：`ForkJoinPool`
    也适用于与事件式任务一起使用，这些任务永远不会合并。
- en: Note `ForkJoinPool` is also used in popular Java/JVM libraries, such as the
    Akka system of actor-based concurrency in Scala and Java.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `ForkJoinPool` 也用于流行的 Java/JVM 库中，例如 Scala 和 Java 中的基于演员的并发 Akka 系统。
- en: 'To interact with a `ForkJoinPool`, the class exposes the following primary
    methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `ForkJoinPool` 交互，该类公开以下主要方法：
- en: '`execute()`—Starts an asynchronous execution'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()`—启动异步执行'
- en: '`invoke()`—Starts execution and awaits the result'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke()`—启动执行并等待结果'
- en: '`submit()`—Starts execution and returns a future for the result'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit()`—启动执行并返回结果的 future'
- en: Since Java 8, the runtime has included a common pool, which is accessed via
    `ForkJoinPool.commonPool()`. This is provided primarily for its work-stealing
    capabilities—there is not a lot of expectation that many programs will use it
    for recursive decomposition.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 8 以来，运行时已包含一个公共池，通过 `ForkJoinPool.commonPool()` 访问。这主要提供其工作窃取功能——并不期望许多程序会将其用于递归分解。
- en: The common pool has a number of configurable properties that can be set to control
    things like the parallelism level (i.e.. how many threads to use) and the thread
    factory class used to create new threads for the common pool.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 公共池具有许多可配置的属性，可以设置以控制诸如并行级别（即使用多少线程）和用于为公共池创建新线程的线程工厂类等事项。
- en: 16.2 Concurrency and functional programming
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 并发与函数式编程
- en: In chapter 5, we met the concept of immutable objects and showed that they are
    extremely useful for concurrent programming because they sidestep the problem
    of *shared mutable state*, which is at the heart of so many concurrency problems.
    So, we might guess that functional techniques that utilize immutability are an
    important tool for building concurrent applications. This is true, but a small
    extension to immutability is also relevant to concurrent programming.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，我们遇到了不可变对象的概念，并展示了它们对于并发编程非常有用，因为它们避开了 *共享可变状态* 的问题，这是许多并发问题的核心。因此，我们可能会猜测，利用不可变性的函数技术对于构建并发应用程序是一个重要的工具。这是真的，但不可变性的一个小扩展也与并发编程相关。
- en: 16.2.1 CompletableFuture revisited
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.1 重新审视 CompletableFuture
- en: 'In chapter 6, we met the `CompletableFuture` class. This type is not immutable,
    but it has a very simple state model, described next:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章中，我们遇到了 `CompletableFuture` 类。这种类型不是不可变的，但它有一个非常简单的状态模型，下面将进行描述：
- en: It starts in an uncompleted state.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从未完成状态开始。
- en: Any attempt to `get()` a value from it will block.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何尝试从其中获取 `get()` 值的尝试都将阻塞。
- en: At some later time, a publication event occurs.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个稍后的时间，发生发布事件。
- en: This sets the value and passes it to any threads blocking on `get()`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将设置值并将其传递给任何阻塞在 `get()` 上的线程。
- en: The published value is now immutable.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已发布的价值现在不可更改。
- en: Figure 16.3 shows the future and the publication event.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 展示了未来和发布事件。
- en: '![](../Images/CH16_F03_Evans2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH16_F03_Evans2.png)'
- en: Figure 16.3 Event publication sets the value and passes it to any threads blocking
    on `get()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 事件发布设置值并将其传递给任何阻塞在 `get()` 上的线程。
- en: One big strength of `CompletableFuture` is that it is possible to compose functions
    with the result, and the result will be lazily evaluated, that is, the function
    will not be executed until the value has arrived.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` 的一个重大优势是，可以组合带有结果的功能，并且结果将被延迟评估，也就是说，函数将在值到达之前不会执行。'
- en: 'This function composition can occur either synchronously or asynchronously.
    This is perhaps easiest to see by running a few examples. Let’s reuse the idea
    of the `NumberService` from chapter 6 and use a dummy implementation for it, for
    example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数组合可以同步或异步发生。这也许通过运行几个示例最容易看出。让我们重用第 6 章中提到的 `NumberService` 的想法，并使用一个模拟实现，例如：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This obviously doesn’t actually compute primes, but it is good enough to demonstrate
    the threading behavior, which is our goal. We need a bit of code to drive this,
    as shown next:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然实际上并没有计算素数，但它足以演示线程行为，这是我们想要的目标。我们需要一些代码来驱动它，如下所示：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Supplies the computation to run asynchronously
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供要异步运行的计算
- en: ❷ Supplies the function to apply to the result of the asynchronous computation
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为异步计算的结果提供要应用的功能
- en: ❸ Supplies another function to apply asynchronously to the result
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为结果提供另一个异步应用的功能
- en: 'When we run this code, we get some output like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们会得到一些类似这样的输出：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The future `f2`, which uses `thenApply()`, executes on the same thread as `future`,
    whereas `f3` (which uses `thenApplyAsync()`) executes on a different thread in
    the pool.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`thenApply()`的`f2`未来将在与`future`相同的线程上执行，而`f3`（使用`thenApplyAsync()`）将在池中的不同线程上执行。
- en: You might notice that, by default, execution of `CompletableFuture` code all
    uses the common pool. This pool shows up with the name of `ForkJoinPool.commonPool`,
    as can be seen in the previous output.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，默认情况下，`CompletableFuture`代码的执行都使用公共池。这个池以`ForkJoinPool.commonPool`的名称出现，如前一个输出所示。
- en: Under some circumstances, developers may want to use an alternate thread pool.
    For example, the common pool isn’t configurable in terms of the maximum number
    of threads that can be used, and this may not be acceptable for certain workloads.
    Fortunately, the factory methods of `CompletableFuture`, such as `supplyAsync()`,
    come with overloads that take an explicit `Executor` argument. This allows the
    future to run on a specific threadpool instead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，开发者可能想要使用一个替代的线程池。例如，常见的线程池在可配置的最大线程数方面是不可配置的，这可能不适合某些工作负载。幸运的是，`CompletableFuture`的工厂方法，如`supplyAsync()`，提供了带有显式`Executor`参数的重载。这允许未来在特定的线程池上运行。
- en: As well as the `thenApply()` method, `CompletableFuture` also provides `thenCompose()`.
    Some developers find the difference between the two confusing, so let’s take a
    moment to explain.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`thenApply()`方法外，`CompletableFuture`还提供了`thenCompose()`。一些开发者发现这两个方法之间的区别令人困惑，所以让我们花点时间来解释一下。
- en: Recall that `thenApply()` takes as its argument a `Function` that maps `T ->
    U`. This function is applied synchronously on whichever thread the `CompletableFuture`
    is running on after the original future completes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`thenApply()`接受一个`Function`作为参数，该函数将`T`映射到`U`。这个函数在原始未来完成后的同步方式应用于`CompletableFuture`运行的任何线程上。
- en: 'On the other hand, `thenCompose()` takes a `Function` that maps `T -> CompletableFuture<U>`
    (the actual return type is `CompletionStage<U>` rather than `CompletableFuture<U>`,
    but let’s gloss over that detail for now). This is, effectively, an asynchronous
    function (and it could run on a different thread). Let’s look at a concrete example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`thenCompose()`接受一个将`T`映射到`CompletableFuture<U>`（实际的返回类型是`CompletionStage<U>`而不是`CompletableFuture<U>`，但现在我们先忽略这个细节）的`Function`。这实际上是一个异步函数（它可以在不同的线程上运行）。让我们看一个具体的例子：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We *could* pass this function to `thenApply()`, but the result would be a `CompletableFuture<CompletableFuture<Long>>`.
    Instead, `thenCompose()` flattens the result back to a `CompletableFuture<Long>`.
    This is similar to how the `flatMap()` method works in the Java Streams API—it
    applies a function that returns `Stream<T>` to a stream object, but instead of
    returning a `Stream<Stream<T>>`, the separate streams are flattened and joined
    together into a single stream.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*将这个函数传递给`thenApply()`，但结果将会是一个`CompletableFuture<CompletableFuture<Long>>`。相反，`thenCompose()`会将结果扁平化回一个`CompletableFuture<Long>`。这类似于Java
    Streams API中的`flatMap()`方法——它将返回`Stream<T>`的函数应用到流对象上，但与返回`Stream<Stream<T>>`不同，它将独立的流扁平化并合并成一个单一的流。
- en: '`CompletableFuture` also supports `join()`, which essentially works like a
    thread join but returns a value. It is also possible to “join together” futures
    by having code that is intended to run after either (or both) of them have finished.
    For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`还支持`join()`，它本质上就像一个线程join，但返回一个值。也可以通过让代码在任意（或两个）未来完成之后运行来“连接”未来。例如：'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now want to bring together the discussion of functional programming in the
    previous chapter with the ideas here.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望将上一章中关于函数式编程的讨论与这里的思想结合起来。
- en: 'If the functions that we want to apply to the result of a `CompletableFuture`
    are pure and do not depend upon anything but the input value, the action of applying
    a function to the future is the same as applying the function to the result. Put
    another way: if the future is thought of as a container type, which holds a value,
    then the container is “transparent” to the function that is applied to the value
    once it has arrived.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要应用于 `CompletableFuture` 结果的函数是纯函数且不依赖于任何东西，只依赖于输入值，那么将函数应用于未来的操作与将函数应用于结果的操作相同。换句话说：如果将未来视为一个容器类型，它包含一个值，那么容器对于应用于该值的函数来说是“透明的”，一旦值到达，容器就不再存在。
- en: 'In particular, two of the major benefits of referential transparency (e.g.,
    using pure functions) follow:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，引用透明度（例如，使用纯函数）的两个主要好处如下：
- en: Memoization
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存。
- en: Transportability
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性。
- en: The first means that any pure function call can be replaced by an already-calculated
    value—we don’t have to rerun the function call with the same arguments, because
    we already know what the answer is. Second, of course, if we’re calculating a
    pure function, then it doesn’t matter what thread it takes place on, so whether
    we’ve supplied a function to be applied synchronously or asynchronously won’t
    affect the result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个意思是任何纯函数调用都可以替换为已计算出的值——我们不需要用相同的参数重新运行函数调用，因为我们已经知道答案了。其次，当然，如果我们正在计算一个纯函数，那么它发生在哪个线程上并不重要，所以无论我们是否提供了同步或异步应用函数，都不会影响结果。
- en: Note Java, as already discussed, is quite an impure language, so many of these
    benefits will apply only if the programmer is careful to use pure functions and
    immutable data throughout.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如前所述，Java 是一种相当不纯的语言，因此许多这些好处只有在程序员小心地使用纯函数和不可变数据时才会适用。
- en: While we’re discussing concurrent functional programming, it seems pertinent
    to say something about *parallel streams*, which are an area of the Streams API
    that many developers misunderstand.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在讨论并发函数式编程时，似乎有必要谈谈 *并行流*，这是许多开发者误解的 Streams API 的一个领域。
- en: 16.2.2 Parallel streams
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.2 并行流
- en: 'In chapter 5, we met Amdahl’s law, which is one of the fundamental results
    about concurrency as it pertains to *data parallelism*. This is the approach to
    concurrency that we often want to use when we have a large amount of bulk data
    that is pretty similar and all has to be processed in more or less the same way.
    In general, the data parallelism approach is useful if all of the following are
    true:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我们遇到了阿姆达尔定律，这是关于数据并行性的基本结果之一。这是我们处理大量非常相似且必须以更多或更少相同方式处理的大批量数据时经常想要使用的并发方法。一般来说，如果以下所有条件都成立，数据并行方法是有用的：
- en: You have a lot of data to process in the same (or a very similar) way.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要处理大量以相同（或非常相似）方式处理的数据。
- en: Ordering doesn’t matter.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序不重要。
- en: Items are independent of each other.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项之间相互独立。
- en: You can show a particular processing step is the bottleneck.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以显示特定的处理步骤是瓶颈。
- en: 'Parallel streams are a type of data parallelism that a lot of Java developers
    got quite excited about when they were included in Java 8\. However, as we’ll
    see, the reality has turned out rather differently to the initial hope. The API,
    shown here, seems simple enough:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 并行流是一种数据并行类型，许多 Java 开发者在 Java 8 中将其包含进来时非常兴奋。然而，正如我们将看到的，现实与最初的希望大相径庭。这里显示的
    API 看起来足够简单：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Under the hood, the work is distributed using F/J framework and uses the work-stealing
    algorithm to spread out the computation over multiple cores. The following seems
    too good to be true:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，工作是通过 F/J 框架进行分布式处理的，并使用工作窃取算法将计算分散到多个核心上。以下内容看起来好得令人难以置信：
- en: The work is managed by the framework.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作由框架管理。
- en: API aims to be explicit but unobtrusive.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 旨在明确但又不显眼。
- en: Distributed by data.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按数据分布。
- en: '`parallelStream()` allows the programmer to flip between sequential and parallel.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallelStream()` 允许程序员在顺序和并行之间切换。'
- en: “Free speedup.”
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “免费加速”。
- en: In fact, it *is* too good to be true. The first and most obvious problem is
    Amdahl’s law. To split a sequential task into a set of chunks that can be executed
    in parallel requires work—that is, computation time. The more preparation and
    communication overhead, the less benefit multiple processors provide—this is the
    essence of Amdahl’s law.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这确实好得令人难以置信。第一个且最明显的问题是阿姆达尔定律。要将顺序任务分割成可以并行执行的一组块，需要做工作——即计算时间。准备和通信开销越大，多处理器提供的益处就越少——这就是阿姆达尔定律的本质。
- en: No general way exists to easily and reliably estimate the relative costs of
    splitting versus the linear operation cost. The framework passes the cognitive
    cost of deciding whether parallelism is actually worthwhile back up to the developer.
    This already sounds like “automatic parallelism” is not the nirvana that was promised.
    Instead, the end user must be acutely aware of many details that would ideally
    be abstracted away.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种简单可靠的方法可以轻松地估计拆分与线性操作成本之间的相对成本。框架将决定是否值得并行化的认知成本转回给开发者。这听起来就像“自动并行化”并不是曾经承诺的极乐境界。相反，最终用户必须对许多理想的抽象化细节有敏锐的认识。
- en: 'To take just one example: the splitting and recombining work must take place
    on a thread pool within the JVM. The more threads that the JVM creates, the more
    they compete for CPU time. The Streams API does not, a priori, know how many other
    instances of parallel streams exist within the current process. This leads to
    the following two possible, equally unpalatable strategies:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 仅举一个例子：拆分和重新组合的工作必须在 JVM 内部的线程池中完成。JVM 创建的线程越多，它们对 CPU 时间的竞争就越激烈。Streams API
    并非事先就知道当前进程中存在多少个并行流的实例。这导致了以下两种同样令人不快的策略：
- en: Create a new, dedicated thread pool for each invocation of parallel streams.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为并行流的每次调用创建一个新的、专用的线程池。
- en: Create a single instance of a thread pool (private to the JVM), and make all
    invocations of parallel streams use it.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个线程池的单个实例（私有于 JVM），并使所有并行流的调用都使用它。
- en: 'The first option leads to a potentially unbounded creation of threads, which
    will ultimately starve or crash a JVM. For this reason, in Java 8, there is a
    single shared thread pool underlying parallel streams: `ForkJoinPool.commonPool()`.
    This choice leads to potential contention on a shared resource (which, as we have
    seen in chapter 7, is the real root of a great many performance problems).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择可能导致线程的无界创建，最终会饿死或崩溃 JVM。因此，在 Java 8 中，并行流下面有一个单一的共享线程池：`ForkJoinPool.commonPool()`。这个选择可能导致对共享资源的潜在竞争（正如我们在第
    7 章中看到的，这是许多性能问题的真正根源）。
- en: 'There is a workaround: if you execute a parallel stream as a task on a `ForkJoinPool`,
    it will execute there and not use the common pool, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个解决方案：如果你将并行流作为一个任务在 `ForkJoinPool` 上执行，它将在这里执行，而不是使用公共池，如下所示：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the `forkJoinPool` must be explicitly shut down, or it will persist
    in memory waiting for new tasks and thus leak memory and threads.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`forkJoinPool` 必须显式关闭，否则它将保留在内存中等待新任务，从而泄漏内存和线程。
- en: In general, the best advice that can be given about parallel streams is not
    to apply the parallelism blindly. Instead, actually show you have a use case for
    it. As always, this is done by measuring and by showing that the stream operations
    are indeed the bottleneck first, before attempting to see whether parallel streams
    will help.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关于并行流的最佳建议是不要盲目地应用并行化。相反，实际上展示你有使用它的用例。像往常一样，这是通过测量并展示流操作确实是瓶颈，然后再尝试看并行流是否有所帮助来完成的。
- en: Unfortunately, there is no general class of problem where parallel streams might
    be expected to help. Each case must be examined and tested from first principles.
    Only then can you try to apply parallelism to the stream and prove with data that
    a worthwhile improvement can be achieved.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有一类问题可以预期并行流可能有所帮助。每个案例都必须从基本原则出发进行检验和测试。只有在这种情况下，你才能尝试将并行性应用于流，并通过数据证明可以取得有价值的改进。
- en: 16.3 Under the hood with Kotlin coroutines
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 Kotlin 协程的内部机制
- en: As we introduced in chapter 9, Kotlin provides an alternative to the `Thread`
    model for concurrency with *coroutines*. Coroutines can be thought of as “light-weight
    threads” without the resource penalties of full operating system threads. This
    bears some resemblance to Java’s Fork/Join. How does Kotlin provide this alternate
    means of execution? A deeper understanding of what’s going on under the surface
    is warranted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 9 章中介绍的，Kotlin 为并发提供了一个对 `Thread` 模型的替代方案，即 *协程*。协程可以被视为“轻量级线程”，它们没有完整操作系统线程的资源惩罚。这与
    Java 的 Fork/Join 有一些相似之处。Kotlin 是如何提供这种替代执行方式的？对表面之下发生的事情有更深入的了解是必要的。
- en: 16.3.1 How coroutines work
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.1 协程的工作原理
- en: 'Let’s start from the following modified example of what we saw in chapter 9:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第 9 章中看到的修改后的例子开始：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we use the `GlobalScope.launch` to start a new coroutine. *Scopes* are
    used to express how a coroutine should be run, and we’ll look at them more carefully
    in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用`GlobalScope.launch`来启动一个新的协程。*作用域*用于表达协程应该如何运行，我们将在下一节更仔细地研究它们。
- en: The coroutine we create here will wait for a second using the `delay` function,
    and then call our own function, `sus`. Lastly, we `Thread.sleep` for 2 seconds
    to make sure our coroutine has time to complete before our whole program exits.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的协程将使用`delay`函数等待一秒，然后调用我们的函数`sus`。最后，我们使用`Thread.sleep`等待2秒，以确保在程序完全退出之前协程有足够的时间完成。
- en: Part of how coroutines differ from threads is that their execution may be paused
    at specific points. How does Kotlin know where it can pause? That comes from the
    `suspend` keyword we put on our `sus` function (and also on the library-provided
    `delay` function). The `suspend` function marks off the blocks of code that Kotlin
    treats as the units for execution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 协程与线程的不同之处在于，它们的执行可能在特定的点暂停。Kotlin是如何知道它可以暂停的地方呢？这来自于我们放在`sus`函数上的`suspend`关键字（以及库提供的`delay`函数）。`suspend`函数标记了Kotlin将其视为执行单元的代码块。
- en: With `suspend` functions marking the chunks of code in our coroutine between
    which we can pause, Kotlin can create a *state machine* to manage our coroutine’s
    execution. Progress through that state machine is tracked by our generated code,
    with our `suspend`-defined blocks providing the steps to that machine.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的协程中，`suspend`函数标记了代码块，在这些代码块之间我们可以暂停，Kotlin可以创建一个*状态机*来管理协程的执行。通过我们生成的代码跟踪状态机的进度，我们的`suspend`定义的块提供了到达该机器的步骤。
- en: 'Let’s translate our coroutine into a state machine like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的协程转换成这样的状态机：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The steps in our coroutine follow and are illustrated in figure 16.4:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们协程的步骤如下，并在图16.4中展示：
- en: Create our new coroutine instance by calling `launch`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`launch`创建我们的新协程实例。
- en: Execute through `delay`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`delay`执行。
- en: Control returns to Kotlin, which will wait the requested 1 second.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制权返回到Kotlin，它将等待请求的1秒。
- en: Resume after `delay` and execute through `sus`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`delay`之后恢复，并通过`sus`执行。
- en: Hand control back to Kotlin, without requiring a pause this time.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将控制权交还给Kotlin，这次不需要暂停。
- en: Resume after `sus`, and finish the coroutine.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`sus`之后恢复，并完成协程。
- en: '![](../Images/CH16_F04_Evans2.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH16_F04_Evans2.png)'
- en: Figure 16.4 Coroutine state machine
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 协程状态机
- en: This breakdown into steps clarifies why coroutines are sometimes described as
    “cooperative multitasking.” The code between our calls to `suspend` functions
    is executed synchronously, with the `suspend` points providing the only opportunity
    to pause and execute other coroutine steps. Imagine between `delay` and `sus`
    we entered an infinite loop. That loop would block whatever thread it’s executing
    on forever.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种步骤分解清楚地说明了为什么协程有时被描述为“协作式多任务处理”。在调用`suspend`函数之间的代码是同步执行的，`suspend`点提供了唯一的暂停和执行其他协程步骤的机会。想象一下，在`delay`和`sus`之间我们进入了一个无限循环。这个循环将永远阻塞它正在执行的任何线程。
- en: This state machine isn’t just an idea—Kotlin directly generates code that does
    this, and we can examine it. Let’s look at the output from our previous function
    to see how it gets translated. (Note, some minor details are excluded for length
    and clarity.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态机不仅仅是一个想法——Kotlin直接生成执行此操作的代码，我们可以检查它。让我们看看我们之前函数的输出，看看它是如何被转换的。（注意，为了长度和清晰度，省略了一些细节。）
- en: 'The compilation results from our basic app has more class files than we might
    expect. For example, here’s the resulting output under Gradle’s build directory:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本应用程序的编译结果比我们预期的有更多的类文件。例如，以下是Gradle构建目录下的结果输出：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We encountered the `MainKt.class` in chapter 9\. Kotlin transparently creates
    a holding class for top-level functions, because the JVM doesn’t natively support
    free-floating functions and must place all method code in some class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9章遇到了`MainKt.class`。Kotlin透明地创建了一个用于顶层函数的持有类，因为JVM原生不支持自由浮动的函数，必须将所有方法代码放在某个类中。
- en: 'Alongside that, though, we have a new class: `MainKt$main$1.class`. Disassembling
    that class file reveals that Kotlin has done similar work creating “secret” classes
    for our coroutine, just like it did for our top-level functions. This generated
    class represents a single execution of our coroutine. As we can see next, this
    generated class is a mixture of our code and the plumbing to run what we’ve written
    as a coroutine:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们还有一个新的类：`MainKt$main$1.class`。反汇编这个类文件揭示 Kotlin 为我们的协程创建了类似的“秘密”类，就像它为我们顶级函数所做的那样。这个生成的类代表我们协程的单次执行。正如我们接下来可以看到的，这个生成的类是我们代码和将我们编写的作为协程运行的管道的混合体：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Our generated class gets functionality from Kotlin’s SuspendLambda.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们生成的类从 Kotlin 的 SuspendLambda 获取功能。
- en: ❷ Our generated class implements a specific interface that calling code will
    use to invoke our coroutine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们生成的类实现了调用代码将用来调用我们的协程的特定接口。
- en: 'If we check out the code generated from our `main` function in `MainKt.class`,
    we see Kotlin created an instance of our coroutine and then invoked it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 `MainKt.class` 中从我们的 `main` 函数生成的代码，我们看到 Kotlin 创建了一个我们的协程实例然后调用了它：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Retrieves the GlobalScope instance to use starting our coroutine
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取全局作用域实例以启动我们的协程
- en: ❷ Creates and initializes a new instance of our generated coroutine class
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建并初始化我们生成的协程类的新实例
- en: ❸ Calls the launch method, providing it the scope and our coroutine instance.
    In particular, our coroutine instance is passed as the Function2 parameter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 `launch` 方法，向其提供作用域和我们的协程实例。特别是，我们的协程实例作为 Function2 参数传递。
- en: 'The code in the `launch` method will then start calling methods on our generated
    coroutine instance, running our state machine. Let’s look at the bytecode implementing
    that state machine. First up, the coroutine instance has two separate fields.
    These track the coroutine scope and the current location in our state machine:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `launch` 方法中的代码将开始调用我们生成的协程实例上的方法，运行我们的状态机。让我们看看实现该状态机的字节码。首先，协程实例有两个单独的字段。这些跟踪协程作用域和我们在状态机中的当前位置：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ CoroutineScope for our current execution
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当前执行的协程作用域
- en: ❷ The int value representing our state machine’s current step
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表示我们状态机当前步骤的整数值
- en: When our state machine runs, the heart of it is a method that decides our next
    step based on these fields. Kotlin generates a method called `invokeSuspend` for
    just that purpose. `invokeSuspend` ends up as a mixture of our code and the state
    machine tracking our progress. During the lifetime of our coroutine, Kotlin will
    repeatedly call `invokeSuspend` whenever the coroutine is ready for its next execution
    step.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的状态机运行时，其核心是一个基于这些字段决定我们下一步的方法。Kotlin为此目的生成一个名为 `invokeSuspend` 的方法。`invokeSuspend`
    最终成为我们代码和跟踪我们进度的状态机的混合体。在我们的协程生命周期内，每当协程准备好执行下一个步骤时，Kotlin都会重复调用 `invokeSuspend`。
- en: 'The next code snippet shows us the beginning of `invokeSuspend`, along with
    our first step from the state machine (from the coroutine’s start until we call
    `delay`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段展示了 `invokeSuspend` 的开始，以及从状态机中的第一个步骤（从协程的启动到我们调用 `delay`）：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Determines our next step in the state machine
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确定状态机中的下一步
- en: ❷ The beginning of first step (up to the delay call)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 首个步骤的开始（直到调用延迟）
- en: ❸ The beginning of second step (up to the sus call), which will happen when
    invokeSuspend is called again
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第二个步骤的开始（直到调用 `suspend`），这将在再次调用 `invokeSuspend` 时发生
- en: After gathering information on the current coroutine, byte 5 loads up what step
    we’re executing next from the `label` field. Then at byte 8, it uses an opcode
    we haven’t seen before, `tableswitch`. This opcode looks at the value on the stack
    and jumps based on the values defined. Because this is our first time through
    `invokeSuspend`, our `label` has a value of 0, and we proceed to byte 36\. We
    execute linearly from there. At bytes 55 and 56, we update our state `label` to
    1 and advance to the next step. We call `delay` at byte 59 and then `areturn`
    from `invokeSuspend` at byte 68.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集当前协程的信息后，字节 5 从 `label` 字段加载我们即将执行的步骤。然后在字节 8，它使用我们之前未见过的操作码 `tableswitch`。这个操作码查看栈上的值并根据定义的值跳转。因为这是我们第一次通过
    `invokeSuspend`，我们的 `label` 的值为 0，然后我们继续到字节 36。从这里开始线性执行。在字节 55 和 56，我们更新我们的状态
    `label` 为 1 并前进到下一步。我们在字节 59 调用 `delay`，然后在字节 68 从 `invokeSuspend` 返回。
- en: At this point Kotlin’s code is given control, and it decides when to run the
    coroutine’s next step. When it determines the time is right, it will call `invokeSuspend`
    on the same coroutine instance. Our state `label` will be set to 1, and we jump
    ahead to execute the code for our second step, after `delay` but before our `sus`
    call.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个点上，Kotlin 的代码获得了控制权，并决定何时运行协程的下一步。当它确定时机合适时，它将在相同的协程实例上调用 `invokeSuspend`。我们的状态
    `label` 将被设置为 1，然后我们跳到执行第二个步骤的代码，在 `delay` 之后但在我们的 `sus` 调用之前。
- en: Although it’s not truly necessary to get down to the bytecode level for day-to-day
    use of coroutines, understanding the mechanism is valuable. The well-grounded
    developer also shouldn’t be satisfied when a feature seems too magical. At the
    end of the day, it’s all just code executing one instruction at a time, and we
    have the tools to understand it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在日常使用协程时真正深入到底层字节码级别并非必要，但理解其机制是有价值的。对于那些基础扎实的开发者来说，当某个特性看起来过于神奇时，也不应该感到满足。毕竟，所有这些都是一次执行一条指令的代码，而我们拥有理解它的工具。
- en: This examination also may answer some questions from section 15.3.7 where we
    saw the `yield` function used in defining a Kotlin sequence. We hand-waved a little
    at that point about how our lambda to define the sequence could “pause” its execution.
    This is, in fact, using the same mechanism of a generated state machine based
    on `suspend` functions. Each successive calls to `invokeSuspend` gets the next
    item in the sequence.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次检查也可能回答第 15.3.7 节中的一些问题，在那里我们看到了在定义 Kotlin 序列时使用 `yield` 函数。在那个点上，我们稍微挥了挥手，关于我们的
    lambda 定义序列的函数如何“暂停”其执行。实际上，这是使用基于 `suspend` 函数生成的状态机机制。每次对 `invokeSuspend` 的连续调用都会获取序列中的下一个项目。
- en: 16.3.2 Coroutine scoping and dispatching
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.2 协程作用域和调度
- en: Although coroutines provide a different abstraction to the standard operating
    system threading model, under the surface our code is still executing in a thread
    somewhere. How that work gets distributed and coordinated by Kotlin’s coroutines
    is managed by coroutine scopes and *dispatchers*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管协程为标准操作系统线程模型提供了不同的抽象，但在表面之下，我们的代码仍然在某个线程中执行。Kotlin 协程如何管理和协调这项工作由协程作用域和 *调度器*
    管理。
- en: 'Let’s revise our example to peek at where each step of our coroutine is actually
    executing:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的示例，看看协程的每个步骤实际上在哪里执行：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The results aren’t deterministic but will look something like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不是确定性的，但看起来可能像这样：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our thread name provides two interesting pieces of information: a name for
    a dispatcher (`DefaultDispatcher`) and a number indicating which thread from an
    available pool we’re using. When we asked for a particular scope—in our case,
    the `GlobalScope`, which lasts the entire application lifetime—part of what we’re
    choosing is the dispatcher, which determines how our work is actually scheduled.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们线程的名称提供了两个有趣的信息：一个调度器（`DefaultDispatcher`）的名称和一个数字，表示我们正在使用可用池中的哪个线程。当我们请求特定的作用域时——在我们的例子中，是整个应用程序生命周期的
    `GlobalScope`——我们选择的部分包括调度器，它决定了我们的工作是如何实际调度的。
- en: 'Let’s say that we want greater control over how that work dispatching happens.
    Rather than using `GlobalScope`, we can create our own, separate `CoroutineScope`
    instance, as shown next. Typically, a scope is associated with a different object
    in our system with its own specific lifetime. Our custom scopes require a context
    at construction, and the standard functions factory methods are largely identified
    by how they configured dispatching:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要对工作调度有更大的控制权。我们不是使用 `GlobalScope`，而是可以创建自己的、独立的 `CoroutineScope` 实例，如下所示。通常，一个作用域与我们的系统中不同的对象相关联，具有其特定的生命周期。我们的自定义作用域在构造时需要一个上下文，标准函数工厂方法主要根据它们如何配置调度来识别：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The not terribly surprising output shows we’re executing on an entirely separate
    set of threads than we saw before:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 并非特别令人惊讶的输出显示我们正在执行与之前完全不同的线程集：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note It’s worth paying attention because the `newFixedThreadPoolContext` and
    other related functions are marked as obsolete, but their replacements are not
    available as of this writing. Check out the Kotlin coroutine documentation at
    [https://kotlin.github.io/kotlinx.coroutines](https://kotlin.github.io/kotlinx.coroutines)
    for the most up-to-date practices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：值得注意，因为 `newFixedThreadPoolContext` 和其他相关函数已被标记为过时，但截至本文撰写时，它们的替代品尚不可用。请查看
    Kotlin 协程文档 [https://kotlin.github.io/kotlinx.coroutines](https://kotlin.github.io/kotlinx.coroutines)
    以获取最新的实践方法。
- en: 'Context classes wrap up more than just a dispatcher for coroutines. Examples
    of additional information we can provide are a name for our coroutine (which improves
    the debugging experience in IDEs, particularly when many coroutines share dispatchers)
    and a generalized error handler. Elements are added to an existing context object
    using the `plus` function, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文类不仅封装了协程的调度器，还可以提供额外的信息。我们可以提供的信息示例包括为我们的协程命名（这改善了IDE中的调试体验，尤其是在许多协程共享调度器时）和通用错误处理器。元素可以通过`plus`函数添加到现有的上下文对象中，如下所示：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Alongside automatic cancellation of coroutines when the exception is raised,
    our `CoroutineExceptionHandler` will be run and print “Failed!!!!”. You may wish
    to consider a more thorough error-handling strategy for your production applications,
    but coroutines provide the necessary hooks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在异常抛出时自动取消协程之外，我们的`CoroutineExceptionHandler`将被执行并打印“Failed!!!!”。您可能希望考虑为您的生产应用程序制定更彻底的错误处理策略，但协程提供了必要的钩子。
- en: 'It’s not unusual to want to execute various steps in parallel but then require
    the results from those stages before continuing. Within a coroutine this is supported
    by the `async` function, as shown next, which returns a `Deferred<T>`— effectively
    a coroutine `Job` that also allows for waiting and retrieving the value:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 想要并行执行各种步骤，然后再继续之前需要那些阶段的结果，这种情况并不少见。在协程中，这可以通过`async`函数来实现，如下所示，它返回一个`Deferred<T>`——实际上是一个允许等待和检索值的协程`Job`：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Unsurprisingly, prints Got 10
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 毫不意外，打印出“Got 10”
- en: 'Back in section 9.5, we saw that by default, coroutines will cancel the entire
    coroutine hierarchy on errors as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在9.5节中，我们看到了默认情况下，协程会在错误发生时取消整个协程层次结构，如下所示：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Gives time to finish executing
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 给予时间完成执行
- en: ❷ Prints Cancelled true
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印取消为true
- en: 'When you want it, this behavior is extremely powerful. However, it may not
    always be desirable. If some child coroutines can safely fail, we can wrap them
    with the `supervisorScope` as follows. This behaves like a typical coroutine wrapper,
    but doesn’t percolate up cancellations:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要它时，这种行为非常强大。然而，这并不总是可取的。如果某些子协程可以安全失败，我们可以用`supervisorScope`将它们包装起来，如下所示。这就像一个典型的协程包装器，但不会向上传递取消操作：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Again, needs time to finish
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 再次，需要时间来完成
- en: ❷ Prints Cancelled false, indicating our supervisor allowed the child coroutine
    to fail without cancelling the parent
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印取消为false，表示我们的主管允许子协程失败而不取消父协程
- en: Coroutines provide us with many options for how we handle concurrent execution.
    They are far from the only alternate way of thinking about the world, though.
    Let’s see what Clojure brings to the table.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 协程为我们提供了许多处理并发执行的方式。尽管它们不是思考世界的唯一替代方式，但它们提供了很多选项。让我们看看Clojure能带来什么。
- en: 16.4 Concurrent Clojure
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 并发Clojure
- en: Java’s model of state is based fundamentally around the idea of mutable objects.
    As we saw in chapter 5, this leads directly to problems with safety in concurrent
    code. We need to introduce quite complicated locking strategies to prevent other
    threads from seeing intermediate (aka *inconsistent*) object states while a given
    thread is working on mutating an object’s state. These strategies are hard to
    come up with, hard to debug, and harder to test.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Java的状态模型从根本上基于可变对象的概念。正如我们在第5章中看到的，这直接导致并发代码中的安全问题。我们需要引入相当复杂的锁定策略来防止其他线程在给定线程正在修改对象状态时看到中间状态（即*不一致*的对象状态）。这些策略很难想出来，很难调试，更难测试。
- en: Clojure takes a different view, and its abstractions for concurrency aren’t
    as low-level as Java’s in some respects. For example, the use of thread pools
    that are managed by the Clojure runtime (and over which the developer has little
    or no control) may seem strange. But the power gained stems from allowing the
    platform (in this case, the Clojure runtime) to perform the bookkeeping for you,
    allowing you to free up your mind for much more important tasks, such as overall
    design.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有不同的看法，其并发抽象在某些方面并不像Java那样低级。例如，使用由Clojure运行时（开发者几乎无法控制）管理的线程池可能看起来很奇怪。但获得的力量来自于允许平台（在这种情况下，是Clojure运行时）为你做账本记录，让你有更多精力去处理更重要的任务，比如整体设计。
- en: Overall, the philosophy guiding Clojure is to isolate threads from each other
    by default, which goes a long way to making the language concurrently typesafe
    by default. By assuming a baseline of “nothing needs to be shared” and having
    immutable values, Clojure sidesteps a lot of Java’s issues and instead can focus
    on ways to share state safely for concurrent programming.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Clojure 的哲学是默认将线程彼此隔离，这有助于使语言默认情况下并发类型安全。通过假设基线为“不需要共享任何东西”并使用不可变值，Clojure
    避免了许多 Java 的问题，并且可以专注于安全共享状态以进行并发编程的方法。
- en: Note To help promote safety, Clojure’s runtime provides mechanisms for coordinating
    between threads, and it’s very strongly recommended that you use these mechanisms
    rather than trying to use Java idioms or making your own concurrency constructs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了促进安全性，Clojure 的运行时提供了线程间协调的机制，强烈建议您使用这些机制，而不是尝试使用 Java 习惯用法或创建自己的并发结构。
- en: 'Let’s look at the first of these building blocks: persistent data structures.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些构建块中的第一个：持久化数据结构。
- en: 16.4.1 Persistent data structures
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.1 持久化数据结构
- en: A *persistent data structure* is one that preserves previous versions when it
    is modified. As a result, they are thread safe, because operations on them do
    not mutate the structure as seen by existing readers and instead always yield
    a new updated object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一种 *持久化数据结构* 是在修改时保留先前版本的。因此，它们是线程安全的，因为对它们的操作不会改变现有读者所看到的结构，而是始终产生一个新的更新对象。
- en: All of the Clojure collections are persistent and allow for the efficient creation
    of modified copies, by using *structural sharing*. The collections are inherently
    thread safe and designed to be efficient.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Clojure 集合都是持久的，并允许通过使用 *结构共享* 高效地创建修改后的副本。集合本质上是线程安全的，并且设计得非常高效。
- en: It’s important to note that Clojure’s persistent collections do not permit in-place
    mutation or deletion of elements. They will throw `UnsupportedOperationException`
    if your program calls those methods of the Java Collections interfaces (such as
    `List` or `Map`). Instead, the expectation is that the persistent collections
    will be built up using operations like `(cons)` and `(conj)`, in the Lisp tradition.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Clojure 的持久化集合不允许原地修改或删除元素。如果您的程序调用 Java 集合接口（如 `List` 或 `Map`）的这些方法，它们将抛出
    `UnsupportedOperationException`。相反，预期持久化集合将通过 `(cons)` 和 `(conj)` 等操作构建，遵循 Lisp
    传统。
- en: 'All the collections support the following basic methods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都支持以下基本方法：
- en: '`count` gets the size of the collection.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 获取集合的大小。'
- en: '`cons` and `conj` add to the collection.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cons` 和 `conj` 向集合中添加元素。'
- en: '`seq` gets a sequence that can walk the collection.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seq` 获取一个可以遍历集合的序列。'
- en: 'All of the sequence functions can therefore be used with any collection, via
    the support for `seq`. Let’s look at an example—Clojure’s `PersistentVector`—starting
    with some Java code to show how the vector is build up by repeatedly adding new
    elements with `(cons)`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有序列函数都可以通过 `seq` 的支持与任何集合一起使用。让我们看一个例子——Clojure 的 `PersistentVector`——从一些
    Java 代码开始，展示如何通过重复使用 `(cons)` 添加新元素来构建向量：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will output something like
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出类似以下内容
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: which shows that it is possible to keep each earlier version of the persistent
    vector around, should you need to. This would also mean that it would be possible
    to pass the vector between threads and have each thread modify it without affecting
    the others.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，如果您需要，可以保留持久向量的每个早期版本。这也意味着可以在线程之间传递向量，并且每个线程都可以修改它，而不会影响其他线程。
- en: Let’s take a quick look at how this data structure is implemented. Recall that
    array-backed data structures (such as vectors) in other languages are usually
    implemented in terms of a single continuous chunk of memory. This implementation
    makes indexed operations, such as lookup, fast, but for operations such as making
    a mutated copy of the vector (while retaining the original), we must copy the
    entire backing array.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下这种数据结构的实现方式。回想一下，其他语言中基于数组的结构（如向量）通常是通过一个单一的连续内存块实现的。这种实现使得索引操作，如查找，非常快，但对于像创建向量的修改副本（同时保留原始副本）这样的操作，我们必须复制整个支持数组。
- en: Clojure’s `PersistentVector` is very different. Instead, Clojure stores elements
    for the vector in chunks of 32 elements. The general idea is that if an element
    is added, only the current *tail* of 32 elements needs to be copied. If a vector
    has more than 32 elements added to it, a structure called a *node* is created
    that contains an array of 32 elements, which are themselves references to nodes
    that contain full arrays of 32 elements.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的`PersistentVector`非常不同。相反，Clojure将向量的元素存储在32个元素的块中。一般思路是，如果添加了一个元素，只需要复制当前的32个元素的*尾部*。如果一个向量添加了超过32个元素，就会创建一个称为*节点*的结构，它包含一个32个元素的数组，这些元素本身是包含完整32个元素数组的节点的引用。
- en: Note `PersistentVector` is one of Clojure’s core abstractions, and it is so
    widely used that is actually implemented in Java (not Clojure), because it is
    needed to bootstrap the basic Clojure language runtime.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`PersistentVector`是Clojure的核心抽象之一，它被广泛使用，实际上是在Java（而不是Clojure）中实现的，因为它需要启动Clojure语言运行时。
- en: 'The class definition looks like this (slightly simplified for clarity):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义看起来像这样（为了清晰起见略有简化）：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'with the inner class `PersistentVector.Node` defined as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类`PersistentVector.Node`定义如下：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the `array` field is just an `Object[]`. This is an aspect of Clojure’s
    dynamically typed nature—there are no generics here.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`array`字段只是一个`Object[]`。这是Clojure动态类型特性的一部分——这里没有泛型。
- en: 'In addition, Clojure makes use of public final fields frequently in its core
    and does not always define accessor methods. We can therefore peek inside the
    data structure and see how the nodes work. For example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Clojure在其核心中频繁使用公共最终字段，并不总是定义访问器方法。因此，我们可以查看数据结构内部，看看节点是如何工作的。例如：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'produces output like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 产生如下输出：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After 64 elements have been added, the `tail` is `[32, ... 63]`, and `root.array`
    contains a single `PersistentVector.Node` that contains the elements `[0, ...
    31]` as its array field. So, in pictorial form, for 0–32 elements, the vector
    looks like figure 16.5.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了64个元素之后，`tail`将是`[32, ... 63]`，而`root.array`包含一个单一的`PersistentVector.Node`，其数组字段包含元素`[0,
    ... 31]`。因此，在图示形式上，对于0到32个元素，向量看起来像图16.5。
- en: '![](../Images/CH16_F05_Evans2.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH16_F05_Evans2.png)'
- en: Figure 16.5 A persistent vector with 32 elements
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 一个包含32个元素的持久向量
- en: For a number of elements more than 32 and less than 64, the structure will look
    like figure 16.6.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于超过32个元素但少于64个元素的数目，结构将类似于图16.6。
- en: '![](../Images/CH16_F06_Evans2.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH16_F06_Evans2.png)'
- en: Figure 16.6 A persistent vector with 64 elements
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 一个包含64个元素的持久向量
- en: And for 64 to 96 elements, it will look like it does in figure 16.7 and so on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于64到96个元素，其结构将类似于图16.7，依此类推。
- en: '![](../Images/CH16_F07_Evans2.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH16_F07_Evans2.png)'
- en: Figure 16.7 A persistent vector with 96 elements
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 一个包含96个元素的持久向量
- en: You might, legitimately, ask what happens when all of the node’s array slots
    are full. This occurs when the vector contains 32 + (32 * 32)—or 1,056—elements.
    The reader might be expecting this number to be 1,024, but we also have the *tail*,
    which contains 32 elements—effectively an “off-by-one effect.” A full `PersistentVector`
    with one level of `Node` can be seen in figure 16.8.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会合情合理地问，当所有节点的数组槽位都满了会发生什么。这发生在向量包含32 + (32 * 32)——或1,056——个元素时。读者可能期望这个数字是1,024，但我们还有*尾部*，它包含32个元素——实际上是一个“偏移一个”的效果。一个包含一个`Node`层级的完整`PersistentVector`可以在图16.8中看到。
- en: '![](../Images/CH16_F08_Evans2.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH16_F08_Evans2.png)'
- en: Figure 16.8 A persistent vector with 1,056 elements
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 一个包含1,056个元素的持久向量
- en: If we continue to add elements, the tree structure grows another level, as shown
    in figure 16.9.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续添加元素，树结构将再增加一个层级，如图16.9所示。
- en: '![](../Images/CH16_F09_Evans2.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH16_F09_Evans2.png)'
- en: Figure 16.9 A persistent vector with many elements
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 一个包含许多元素的持久向量
- en: 'To see this in code, we can run some code like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中看到这一点，我们可以运行一些这样的代码：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This produces output like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生如下输出：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice how in this example, the array field of `v0` and `v1` no longer contains
    `Integer` elements but instead now contains `Node` objects. This is why the `array`
    field is typed as `Object[]`, to allow for this sort of dynamic typing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这个例子中，`v0`和`v1`的数组字段不再包含`Integer`元素，而是现在包含`Node`对象。这就是为什么`array`字段被类型化为`Object[]`，以允许这种动态类型。
- en: Note If we continue adding elements, we will build a multilevel structure, and
    this allows `PersistentVector` to handle vectors of any size (albeit at an increasing
    cost of indirection for larger vectors).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果我们继续添加元素，我们将构建一个多层结构，这允许 `PersistentVector` 处理任何大小的向量（尽管对于更大的向量，间接成本会不断增加）。
- en: However, data structures aren’t the only things that Clojure needs to be a successful
    concurrent language. For example, a notion of concurrency models and execution
    is absolutely essential. Fortunately, Clojure has you covered!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据结构并不是Clojure需要成为成功并发语言所需要的一切。例如，并发模型和执行的概念绝对至关重要。幸运的是，Clojure已经为您提供了这些！
- en: 'In fact, Clojure uses several methods to provide different sorts of concurrency
    models: futures and pcalls, refs, and agents. Let’s look at each in turn, starting
    with one of the simplest.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Clojure使用多种方法来提供不同类型的并发模型：futures和pcalls、refs和agents。让我们逐一查看，从最简单的一个开始。
- en: 16.4.2 Futures and pcalls
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.2 Futures和pcalls
- en: We should start by making it clear that you can always start new threads by
    exploiting Clojure’s tight binding to Java. Anything you can do in Java, you can
    also do in Clojure, and you can write concurrent Java code very easily in Clojure.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该明确，您可以通过利用Clojure对Java的紧密绑定来启动新线程。您在Java中能做的事情，在Clojure中也能做，并且您可以在Clojure中非常容易地编写并发Java代码。
- en: However, some of Java’s abstractions have a cleaned-up form within Clojure.
    For example, Clojure provides a very clean approach to the `Future` concept that
    we encountered in Java in chapter 6\. The following listing shows a simple example.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java的一些抽象在Clojure中有一种清理后的形式。例如，Clojure提供了一个非常干净的方法来处理我们在第6章中在Java中遇到的 `Future`
    概念。下面的列表显示了一个简单的示例。
- en: Listing 16.2 Futures in Clojure
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.2 Clojure中的Future
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Starts executing at once
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 立即开始执行
- en: ❷ Blocks when dereferencing
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解引用时的阻塞
- en: In this listing, you set up a Future with `(future)`. As soon as this is created,
    it begins to run on a background thread, which is why you see the printout of
    line 0 (and later line 1) on the Clojure REPL—the code has started to run on another
    thread.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，您使用 `(future)` 设置一个Future。一旦创建，它就会在后台线程上开始运行，这就是为什么您在Clojure REPL上看到第0行（以及后来的第1行）的打印输出——代码已经开始在另一个线程上运行。
- en: You can then test to see whether the code has completed using `(future-done?)`,
    which is a nonblocking call (like `isDone()` in Java). The attempt to dereference
    the future, however, causes the calling thread to block until the function has
    completed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `(future-done?)` 来测试代码是否已完成，这是一个非阻塞调用（类似于Java中的 `isDone()`）。然而，尝试解引用future会导致调用线程阻塞，直到函数完成。
- en: This is effectively a thin Clojure wrapper over a Java Future, with some slightly
    cleaner syntax. Clojure also provides helper forms that can be very useful to
    the concurrent programmer. One simple function is `(pcalls)`, which takes in a
    variable number of zero-argument functions and executes them in parallel.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个简单的Clojure包装器，覆盖了Java Future，并有一些稍微干净的语法。Clojure还提供了对并发程序员非常有用的辅助形式。一个简单的函数是
    `(pcalls)`，它接受一个零参数函数的变量数量，并并行执行它们。
- en: Note `(pcalls)` is somewhat similar to Java’s `ExecutorService.invokeAll()`
    helper method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `(pcalls)` 与Java的 `ExecutorService.invokeAll()` 辅助方法有些类似。
- en: The calls are executed on a runtime-managed threadpool and will return a lazy
    seq of the results. Trying to access any elements of the seq that haven’t yet
    completed will cause the accessing thread to block.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 调用在运行时管理的线程池上执行，并将返回一个惰性序列的结果。尝试访问尚未完成的序列中的任何元素将导致访问线程阻塞。
- en: Listing 16.3 sets up a one-argument function called `(wait-with-for)`. This
    uses a loop form similar to the one introduced in section 10.2.5\. From this,
    you create a number of zero-argument functions—`(wait-1)`, `(wait-2)`, and so
    on—which you can feed to `(pcalls)`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.3 设置一个名为 `(wait-with-for)` 的一参数函数。这使用一个类似于第10.2.5节中引入的循环形式。从这个循环中，您创建了一系列零参数函数——`(wait-1)`、`(wait-2)`
    等等，您可以将它们馈送到 `(pcalls)`。
- en: Listing 16.3 Parallel calls in Clojure
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.3 Clojure中的并行调用
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With a thread sleep value of only 500 ms, the wait functions complete very quickly.
    By playing with the timeout (such as by extending it to 10 seconds), it’s easy
    to verify that the lazy sequence called `wait-seq` that is returned by `(pcalls)`
    has the described blocking behavior.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仅500毫秒的线程睡眠值，等待函数会非常快地完成。通过调整超时（例如，将其扩展到10秒），很容易验证由 `(pcalls)` 返回的名为 `wait-seq`
    的惰性序列具有描述的阻塞行为。
- en: 'This access to simple multithreaded constructs is fine for the case where you
    don’t need to share state, but in many applications, different processing threads
    need to communicate in flight. Clojure has a couple of models for handling this,
    so let’s look at one of these next: the shared state enabled by the `(ref)` form
    that is handled in a transaction.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对简单多线程结构的访问对于不需要共享状态的情况是好的，但在许多应用中，不同的处理线程需要在飞行中通信。Clojure有几个处理这种情况的模型，所以让我们看看下一个：由`(ref)`形式启用的共享状态，该状态在事务中处理。
- en: 16.4.3 Software transactional memory
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.3 软件事务内存
- en: The first, and most obvious, way to share state is not to. In fact, the Clojure
    construct that we’ve been using up until now, the `var`, isn’t really able to
    be shared. If two different threads inherit the same name for a `var` and rebind
    it in-thread, then those rebindings are visible only within those individual threads
    and can never be shared by other threads.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种，也是最明显的方法是不共享状态。事实上，我们到目前为止一直在使用的Clojure构造，即`var`，实际上并不能被共享。如果两个不同的线程继承了同一个`var`的名称并在线程内重新绑定它，那么这些重新绑定只对那些个别线程可见，并且永远不会被其他线程共享。
- en: 'This is by design, and Clojure provides an alternative way of sharing state
    between threads: the *ref*. This concept relies upon a model provided by the runtime
    for state changes that need to be seen by multiple threads. The model effectively
    introduces an additional level of indirection between a symbol and a value—that
    is, a symbol is bound to a reference to a value, rather than directly to a value.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由设计决定的，Clojure提供了一个在线程之间共享状态的替代方法：*ref*。这个概念依赖于运行时提供的模型，该模型用于需要被多个线程看到的状态更改。该模型有效地在符号和值之间引入了一个额外的间接层——也就是说，一个符号绑定到一个值的引用，而不是直接绑定到值。
- en: The system is essentially transactional, and changes to the underlying value
    are coordinated by the Clojure runtime. This is illustrated in figure 16.10.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 系统本质上具有事务性，对底层值的更改由Clojure运行时进行协调。这如图16.10所示。
- en: '![](../Images/CH16_F10_Evans2.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 软件事务内存](../Images/CH16_F10_Evans2.png)'
- en: Figure 16.10 Software transactional memory
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 软件事务内存
- en: This indirection means that before a ref can be altered or updated, it has to
    be placed inside a transaction. When the transaction is completed, either all
    or none of the updates will take effect, and this has an obvious analogy to a
    transaction in a database.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这种间接性意味着在ref可以被更改或更新之前，它必须被放置在一个事务中。当事务完成时，所有的更新要么全部生效，要么全部不生效，这显然与数据库中的事务有明显的类比。
- en: 'This can seem a bit abstract, so let’s return to an earlier example, the `Account`
    classes we discussed in chapters 5 and 6\. Recall that, to avoid concurrency problems
    like lost update, in Java you’re required to protect every sensitive bit of data
    with locks, as shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点抽象，所以让我们回到一个更早的例子，我们在第5章和第6章讨论过的`Account`类。回想一下，为了避免像丢失更新这样的并发问题，在Java中，你必须使用锁来保护每一点敏感数据，如下所示：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let’s see how you could try to write something similar to this in Clojure. However,
    it’s here that we run into something of a conceptual problem.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你如何在Clojure中尝试编写类似的东西。然而，正是在这里，我们遇到了一个概念上的问题。
- en: 'In Java, the default is to use mutable state, and this is the case in the previous
    code. The `withdraw()` method takes in a single parameter, `amount`, and one of
    the following three things happens:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，默认使用可变状态，这在之前的代码中就是这种情况。`withdraw()`方法接受一个参数，`amount`，以下三种情况中的一种会发生：
- en: '`amount` *is less than or equal to zero* —An `IllegalArgumentException` is
    thrown, because this is not a valid withdrawal.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amount` *小于或等于零* —会抛出一个`IllegalArgumentException`异常，因为这不是一个有效的提款操作。'
- en: '*The withdrawal succeeds*—The balance is updated, and `true` is returned.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提款成功*—余额已更新，并返回`true`。'
- en: '*The withdrawal fails (not enough money available)*—The balance is *not* updated,
    and `false` is returned.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提款失败（可用余额不足）*—余额*未*更新，并返回`false`。'
- en: 'Leaving aside the invalid case, two separate aspects are happening here: updating
    mutable state and signaling via the return code whether or not the operation succeeded.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 不考虑无效的情况，这里有两个独立的过程正在发生：更新可变状态和通过返回码信号操作是否成功。
- en: In functional programming, rather than updating mutable state, we would usually
    return a new value that contains the updated state. However, if the withdrawal
    fails, how will the user of the code know whether the balance has been updated?
    We could imagine changing the return code to be a pair of return codes and possibly
    an updated value, but this is somewhat clumsy.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们通常会返回一个包含更新状态的新值，而不是更新可变状态。然而，如果提款失败，代码的使用者将如何知道余额是否已更新？我们可以想象将返回代码更改为一对返回代码和可能的一个更新值，但这有些笨拙。
- en: Instead, let’s start with a slightly different single-threaded version shown
    in the next listing. The semantics here are that the `(debit)` form operates on
    a map (representing an account) and returns a new map if the withdrawal succeeds—and
    throws if it fails.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们从一个稍微不同的单线程版本开始，这个版本将在下一列表中展示。这里的语义是，`(debit)`形式在映射（表示账户）上操作，如果提款成功则返回一个新的映射，如果失败则抛出异常。
- en: Listing 16.4 Simple account model in Clojure
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.4 Clojure中的简单账户模型
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice how compact this code is compared to the Java version. Admittedly, this
    is still single threaded, but it’s a lot less code than was needed for Java. Running
    the code will give you the expected result: you end up with a map with a balance
    of 4000.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与Java版本相比，这段代码是多么紧凑。诚然，这仍然是单线程的，但与Java所需的代码相比要少得多。运行代码将给出预期的结果：你最终会得到一个余额为4000的映射。
- en: Despite the relative simplicity, this is not entirely satisfactory—we are actually
    solving a different problem with different semantics. Let’s see if we can resolve
    some of the problems by generalizing to a concurrent version.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相对简单，但这并不完全令人满意——我们实际上是用不同的语义解决了一个不同的问题。让我们看看是否可以通过推广到并发版本来解决一些问题。
- en: To make this code concurrent, we need to introduce Clojure’s refs. These are
    created with the `(ref)` form and are JVM objects of type `clojure.lang.Ref`.
    Usually they’re set up with a Clojure map to hold the state.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这段代码并发，我们需要引入Clojure的refs。这些是通过`(ref)`形式创建的，是类型为`clojure.lang.Ref`的JVM对象。通常它们与Clojure映射一起设置，以保存状态。
- en: We’ll also need the `(dosync)` form, which sets up a transaction. Within this
    transaction, we’ll also use the `(alter)` form, which can be used to modify a
    ref’s contents. Let’s see how to use refs for this multithreaded approach to our
    account construct, as shown in the following.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`(dosync)`形式，它设置了一个事务。在这个事务中，我们还将使用`(alter)`形式，它可以用来修改refs的内容。让我们看看如何使用refs来实现对账户构造的多线程方法，如下所示。
- en: Listing 16.5 Multithreaded account handling
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.5 多线程账户处理
- en: '[PRE37]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As noted, the `(alter)` form acts on a ref by applying a function with arguments.
    The value acted upon is the local value visible to this thread during the transaction.
    This is called the *in-transaction value*. The value returned is the new value
    of the ref after the alter function returns. This value isn’t visible outside
    the altering thread until you exit the transaction block defined by `(dosync)`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`(alter)`形式通过应用一个带有参数的函数来作用于一个ref。所作用的价值是在事务期间对该线程可见的局部值。这被称为*事务中的值*。返回的值是在alter函数返回后refs的新值。这个值在退出由`(dosync)`定义的事务块之前对更改线程不可见。
- en: Other transactions may be proceeding at the same time as this one. If so, the
    Clojure STM system will keep track of that and will allow a transaction to commit
    only if it’s consistent with other transactions that have committed since it started.
    If it’s inconsistent, it will be rolled back and may be retried with an updated
    view of the world.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 其他交易可能同时进行。如果这样，Clojure STM系统将跟踪这些交易，并且只有在它与自开始以来已提交的其他交易一致的情况下，才会允许事务提交。如果它不一致，它将被回滚，并且可能需要使用更新后的世界视图重新尝试。
- en: This retry behavior can cause problems if the transaction does anything that
    produces side effects (such as a log file or other output). It’s up to you to
    keep the transactional parts as simple and as pure in the functional programming
    sense (meaning as side-effect-free) as possible.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事务执行任何产生副作用（如日志文件或其他输出）的操作，这种重试行为可能会导致问题。你需要尽可能使事务部分简单且在函数式编程意义上纯净（意味着无副作用）。
- en: For some multithreaded approaches, this optimistic transactional behavior can
    seem to be a rather heavyweight approach. Some concurrent applications need to
    communicate between threads only occasionally and in a rather asymmetric fashion.
    Fortunately, Clojure provides another concurrency mechanism that is much more
    fire-and-forget, and it’s the topic of our next section.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些多线程方法，这种乐观的事务行为可能看起来是一种相当重量级的做法。一些并发应用程序只需要偶尔以相当不对称的方式在线程之间进行通信。幸运的是，Clojure
    提供了另一种并发机制，它更加简单直接，这是我们下一节的主题。
- en: 16.4.4 Agents
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4.4 代理
- en: Agents are another of Clojure’s concurrency primitives. Instead of using a shared
    state, a Clojure agent is an asynchronous, message-oriented execution object.
    They are similar to the *actor* concept in other languages (such as Scala and
    Erlang).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是 Clojure 的另一个并发原语。与使用共享状态不同，Clojure 代理是一个异步、面向消息的执行对象。它们与其他语言中的 *actor* 概念（如
    Scala 和 Erlang）类似。
- en: An agent is an execution context that can receive messages (in the form of functions)
    sent to it from another thread (or the same one). New agents are declared with
    the `(agent)` function and messages can be sent to them using `(send)`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是一个可以接收来自另一个线程（或同一个线程）发送给它的消息（以函数的形式）的执行上下文。新的代理通过 `(agent)` 函数声明，可以使用 `(send)`
    向它们发送消息。
- en: “They must go by the carrier,” she thought; “and how funny it’ll seem, sending
    presents to one’s own feet! And how odd the directions will look!”
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: “它们必须通过载体传递，”她心想；“给自己的脚送礼物看起来多么有趣！而且指示看起来多么奇怪！”
- en: —Lewis Carroll
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ——刘易斯·卡罗尔
- en: The agents are not threads themselves but are instead executable objects that
    are “smaller” than a thread. They are scheduled on a threadpool that is managed
    by the Clojure runtime (the threadpool isn’t usually accessible to the programmer
    directly).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 代理本身不是线程，而是比线程“更小”的可执行对象。它们被安排在由 Clojure 运行时管理的线程池中（线程池通常不能直接由程序员访问）。
- en: Note Clojure agents are potentially long-lived, unlike task objects for Java
    threadpools, which typically have bounded lifetimes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与 Java 线程池中的任务对象不同，Clojure 代理可能是长期存在的，因为任务对象通常具有有限的生命周期。
- en: The runtime also ensures that the values of the agent that are seen from outside
    are isolated and atomic. This means that user code will only see the value of
    the agent in its before or after state.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时还确保从外部看到的代理的值是隔离和原子的。这意味着用户代码将只看到代理在其之前或之后的状态。
- en: Note We will meet another example of executable objects smaller than a thread
    in chapter 18.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在第 18 章中遇到另一个小于线程的可执行对象示例。
- en: The following listing shows a simple example of agents, similar to the example
    we used to discuss futures.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了代理的一个简单示例，类似于我们用来讨论未来的示例。
- en: Listing 16.6 Agents in Clojure
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.6 Clojure 中的代理
- en: '[PRE38]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `(send)` call dispatches a `(wait-and-log)` call to the agent, and by using
    the REPL to dereference it, you can see that, as promised, you can never see an
    intermediate state of the agent—only the final state appears (where the `"foo"`
    string has been added twice).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`(send)` 调用会将 `(wait-and-log)` 调用分发给代理，通过使用 REPL 来取消引用它，你可以看到，正如承诺的那样，你永远看不到代理的中间状态——只有最终状态出现（其中
    `"foo"` 字符串被添加了两次）。'
- en: It could seem odd that in the agent approach, we’re sending a message to an
    agent that’s scheduled on a thread in a Clojure-managed threadpool, when both
    threads already share an address space. But one of the themes in concurrency that
    you’ve now encountered several times is that additional abstraction can be a good
    thing if it enables a simpler and clearer usage.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理方法中，我们向一个在 Clojure 管理的线程池中的线程上安排的代理发送消息，当两个线程已经共享地址空间时，这似乎有些奇怪。但你在并发中已经多次遇到的一个主题是，如果它能够使使用更简单、更清晰，那么额外的抽象可能是一件好事。
- en: Nowhere is this synergy clearer than in Clojure’s delegation of many low-level
    aspects of threading and concurrency control to the runtime. This frees the programmer
    to focus on good multithreaded design and higher-level concerns. This is analogous
    to the way in which Java’s garbage collection facilities allow you to free yourself
    from the details of memory management.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 将许多线程和并发控制方面的低级方面委托给运行时的情况下，这种协同效应在 Clojure 中表现得尤为明显。这使程序员能够专注于良好的多线程设计和更高级别的关注点。这与
    Java 的垃圾收集设施允许你从内存管理的细节中解脱出来的方式类似。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Each language has extended the core concepts of execution in their own way.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种语言都以自己的方式扩展了执行的核心概念。
- en: Java has introduced decomposable tasks and work-stealing through the Fork/Join
    library; Kotlin uses advanced compiler tricks to produce a version of coroutines;
    and Clojure builds in a form of the actor model using the agent concept.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java通过Fork/Join库引入了可分解的任务和工作窃取；Kotlin使用高级编译器技巧来生成协程版本；而Clojure通过代理概念构建了一种形式的actor模型。
- en: The treatment of state differs between our three languages and is key to concurrent
    programming
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的三种语言中，对状态的处理不同，这是并发编程的关键
- en: In Java, mutability is the default, with some enhancements such as `CompletableFuture`.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，可变性是默认的，通过`CompletableFuture`等一些增强功能。
- en: Kotlin places a greater emphasis on immutability but is still fundamentally
    drawing from the same worldview of shared, mutable state.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin更加重视不可变性，但仍然从根本上借鉴了共享、可变状态的世界观。
- en: Clojure centers immutability, via software transactional memory, but at the
    cost of a less-familiar programming model and a less-close integration with the
    Java Collections.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure通过软件事务内存中心化不可变性，但代价是编程模型不太熟悉，与Java集合的集成也不太紧密。
