- en: 8 Working with serverless computing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 使用无服务器计算
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining serverless
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义无服务器
- en: Explaining what serverless means for the Jamstack
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释无服务器对 Jamstack 的意义
- en: Describing serverless options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 serverless 选项
- en: Building serverless functions with Netlify
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Netlify 构建 serverless 函数
- en: Building serverless functions with Vercel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vercel 构建 serverless 函数
- en: In the last chapter, we discussed a few different ways you can add dynamic elements
    back into your Jamstack sites. These were done via external services set up specifically
    to serve a need, for example, Google Forms letting you design and accept feedback
    for a form.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了几种不同的方法，可以将动态元素重新添加到你的 Jamstack 网站中。这些是通过为满足特定需求而专门设置的外部服务完成的，例如，Google
    表单让你设计和接受表单的反馈。
- en: While the availability of these services continues to grow in both number and
    variety, there are certain things that simply do not make sense as external services,
    including very particular business logic for your Jamstack site that only you
    know how to develop. This is where serverless computing, and specifically functions
    as a service, come into play.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些服务的可用性在数量和种类上都在持续增长，但有些事情作为外部服务来说根本就不合理，包括只有你知道如何开发的针对你的 Jamstack 网站的非常特定的业务逻辑。这就是无服务器计算，特别是作为服务的函数，发挥作用的地方。
- en: 8.1 What is serverless computing?
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 什么是无服务器计算？
- en: Let’s get this out of the way. There are still servers in serverless computing.
    Just like how we don’t actually build infrastructure in real clouds, serverless
    technology doesn’t magically remove the need for physical hardware. Serverless
    computing is about removing the need to *worry* about the servers. It’s about
    getting all the benefit of what the server provides without the boring work of
    actually maintaining a server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把这个问题讲清楚。在无服务器计算中仍然存在服务器。就像我们在真正的云中实际上并不构建基础设施一样，无服务器技术并不会神奇地消除对物理硬件的需求。无服务器计算是关于消除对服务器的担忧。它是在不维护服务器的枯燥工作中，获得服务器提供的一切好处。
- en: 'There are a wide variety of services that can fall under the serverless definition.
    Here are just a few:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多服务可以归入无服务器定义的范畴。这里只列举一些：
- en: The ability to provision and use a MongoDB database entirely from its website
    ([mongodb.com](https://www.mongodb.com/)) without having to install anything themselves.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够完全从其网站 ([mongodb.com](https://www.mongodb.com/)) 中配置和使用 MongoDB 数据库，而无需自己安装任何东西。
- en: The ability to build complex workflows driven by events at Pipedream ([pipedream.com](https://pipedream.com/)).
    Pipedream lets developers build workflows by piecing together various steps that
    can include custom code.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pipedream ([pipedream.com](https://pipedream.com/)) 中，通过事件驱动的复杂工作流程的能力。Pipedream
    允许开发者通过组合各种步骤来构建工作流程，这些步骤可以包括自定义代码。
- en: And of course, the ability to build nearly anything with the first real enterprise-level
    provider of serverless, Amazon Lambda ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，还有使用无服务器计算的第一家真正的企业级提供商 Amazon Lambda ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/))
    来构建几乎任何东西的能力。
- en: 'While serverless computing has many interpretations and implementations, this
    chapter will focus on probably the most widely known and used example: function
    as a service (FaaS). FaaS lets you focus on the business logic of a particular
    feature and not worry about the hosting or routing. Let’s consider a simple example.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无服务器计算有许多解释和实现，但本章将重点关注最广为人知和使用的例子：函数即服务（FaaS）。FaaS 允许你专注于特定功能的业务逻辑，而不必担心托管或路由。让我们考虑一个简单的例子。
- en: 'Imagine you want to build a service that returns the current time. First, don’t
    do this. Browsers know what time it is. But this gives us a simple requirement
    to build. If I were building this with Node.js, the setup would go something like
    this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想构建一个返回当前时间的服务。首先，不要这样做。浏览器知道时间。但这为我们提供了一个简单的构建要求。如果我用 Node.js 构建，设置可能如下所示：
- en: Provision a Linux VM.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 Linux 虚拟机。
- en: Ensure Node is available.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Node可用。
- en: Write a Node script that will listen for requests on a port and particular path.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 Node 脚本，该脚本将监听端口和特定路径上的请求。
- en: Ensure the VM is set up to respond to that HTTP request.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保虚拟机已设置以响应该 HTTP 请求。
- en: When that happens, perform the business logic (get the current time).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生这种情况时，执行业务逻辑（获取当前时间）。
- en: Creating the same result with FaaS would typically be
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FaaS通常会产生相同的结果
- en: Perform the business logic.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行业务逻辑。
- en: And that’s it. Obviously this is a somewhat contrived example, but the idea
    is that the developer no longer needs to worry about the server, the operating
    system, the network routing, and such, and only needs to worry about the actual
    logic of what they’re building. It’s not always that easy, but you get the idea.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。显然，这是一个有些牵强的例子，但想法是开发者不再需要担心服务器、操作系统、网络路由等问题，而只需关注他们实际构建的逻辑。这并不总是那么容易，但你应该明白了。
- en: 'So how does this impact the Jamstack? While there are multiple services out
    there that provide APIs for various services, sometimes you need very specific
    logic that only you can create. By using serverless computing and functions as
    a service, a developer can write precisely what they need, expose it as an API,
    and then call it with JavaScript from their Jamstack site. Let’s look at one form
    of using this: Netlify functions.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对 Jamstack 有什么影响呢？虽然市面上有多个服务提供各种服务的 API，但有时你需要非常具体的逻辑，而这只有你自己才能创建。通过使用无服务器计算和函数即服务，开发者可以精确地编写他们需要的代码，将其暴露为
    API，然后从他们的 Jamstack 网站使用 JavaScript 调用它。让我们看看使用这种功能的一种形式：Netlify 函数。
- en: 8.2 Building serverless functions with Netlify
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2 使用 Netlify 构建 serverless 函数
- en: We discussed Netlify in an earlier chapter, and one of the features we hinted
    at was the ability to write serverless functions. This feature, called Netlify
    functions ([https://functions.netlify.com/](https://functions.netlify.com/)),
    lets you include functions written in JavaScript or Go. Netlify handles taking
    your code and making it available via HTTP, with no additional work required on
    your part. Netlify supports these functions on their free tier (with caps) and
    has higher tiers for higher cost ([https://www.netlify.com/pricing/#add-ons-functions](https://www.netlify.com/pricing/#add-ons-functions)).
    Netlify functions are built on Amazon Lambda, but you don’t have to know anything
    about that service in order to use them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面一章讨论了 Netlify，我们暗示的一个功能是能够编写无服务器函数。这个功能称为 Netlify 函数 ([https://functions.netlify.com/](https://functions.netlify.com/))，它允许你包含用
    JavaScript 或 Go 编写的函数。Netlify 处理将你的代码通过 HTTP 提供出来，而你无需做任何额外的工作。Netlify 在其免费层（有限制）上支持这些函数，并为更高成本提供更高层级的选项
    ([https://www.netlify.com/pricing/#add-ons-functions](https://www.netlify.com/pricing/#add-ons-functions))。Netlify
    函数建立在 Amazon Lambda 之上，但你无需了解该服务即可使用它们。
- en: Netlify functions support URL and form parameters, which means your client-side
    code can pass arguments in multiple ways when executing calls. Your code can also
    access full details of the request and return data in various forms, although
    typically you’ll return JSON.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 函数支持 URL 和表单参数，这意味着你的客户端代码可以在执行调用时以多种方式传递参数。你的代码还可以访问请求的完整详细信息，并以各种形式返回数据，尽管通常你会返回
    JSON。
- en: 'For our first test, we’re going to make use of the Netlify CLI. While not required,
    it’s going to be useful in this chapter to help us more quickly get started and
    more easily test our code. To install the Netlify CLI, use npm:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一次测试中，我们将使用 Netlify CLI。虽然不是必需的，但在这个章节中，它将有助于我们更快地开始，并更容易测试我们的代码。要安装 Netlify
    CLI，请使用 npm：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After installing the utility, you will then be able to run the netlify function
    from your terminal (figure 8.1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完实用程序后，你将能够从你的终端运行 netlify function（图 8.1）。
- en: '![CH08_F01_Camden2](Images/CH08_F01_Camden2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F01_Camden2](Images/CH08_F01_Camden2.png)'
- en: Figure 8.1 The default output of the Netlify CLI gives basic help for its commands.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 Netlify CLI 的默认输出为其命令提供基本帮助。
- en: After confirming you’ve installed the CLI correctly, run netlify login. This
    will prompt you for your authentication, so if you didn’t create an account with
    them in the deployment chapter, do so now. Once logged in you won’t need to reauthenticate
    in the future.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认你已正确安装 CLI 后，运行 netlify login。这将提示你进行身份验证，所以如果你在部署章节中没有为他们创建账户，现在就创建一个。一旦登录，你将来就不需要再次进行身份验证。
- en: As you can see in figure 8.1, the CLI does quite a bit, but we’re going to touch
    on just a few aspects of it in this chapter. In particular, the CLI can scaffold
    functions for us, including numerous sample apps to help get started.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图 8.1 中所见，CLI 做了很多事情，但我们在本章中只将涉及其中的一些方面。特别是，CLI 可以为我们搭建函数，包括许多示例应用程序以帮助入门。
- en: Your Netlify functions can be stored in any folder you want, but recently Netlify
    started supporting a default location of netlify/functions. Unfortunately, at
    the time this book was written, the CLI doesn’t yet support knowing about this
    default, which means we need to specify it. While this can be done via Netlify’s
    web-based dashboard, we can use yet another new feature of Netlify, *file-based
    configuration*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Netlify 函数存储在任何您想要的文件夹中，但最近 Netlify 开始支持默认位置 netlify/functions。不幸的是，在本书编写时，CLI
    还不支持了解这个默认值，这意味着我们需要指定它。虽然这可以通过 Netlify 的基于 Web 的仪表板完成，但我们还可以使用 Netlify 的另一个新功能，即基于文件的配置。
- en: Netlify lets you specify a netlify.toml file in the root of your project. Pretty
    much every setting possible can be set here (see the documentation at [http://mng
    .bz/XWM6](http://mng.bz/XWM6) for full details), but in our case we’re going to
    specify only the root folder for our Netlify functions. To get started with our
    first test, create a new empty directory and add a blank netlify.toml file (or
    use the chapter8/test1 folder from the GitHub repository). We will assume the
    folder you created is named test1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 允许您在项目的根目录中指定一个 netlify.toml 文件。几乎所有的设置都可以在这里设置（有关完整详情，请参阅[http://mng.bz/XWM6](http://mng.bz/XWM6)上的文档），但在这个案例中，我们将只指定
    Netlify 函数的根文件夹。为了开始我们的第一次测试，创建一个新的空目录并添加一个空的 netlify.toml 文件（或使用 GitHub 仓库中的
    chapter8/test1 文件夹）。我们将假设您创建的文件夹命名为 test1。
- en: Listing 8.1 Configuring netlify.toml (chapter8/test1/netlify.toml)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 配置 netlify.toml（chapter8/test1/netlify.toml）
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The configuration file specifies the functions setting in the build group and
    sets where Netlify should look when preparing to load functions. Again, this value
    is now the default in Netlify but isn’t recognized in the CLI.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件指定了构建组中的函数设置，并设置了 Netlify 在准备加载函数时应查找的位置。同样，这个值现在是 Netlify 的默认值，但在 CLI 中不被识别。
- en: At this point, you can create the functions folder if you wish, but the CLI
    can create it if it needs to. If you decide to create it yourself, you should
    end up with a structure like the one shown in figure 8.2.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果您愿意，可以创建函数文件夹，但 CLI 如果需要也会创建它。如果您决定自己创建，您应该得到一个类似于图 8.2 中所示的架构。
- en: '![CH08_F02_Camden2](Images/CH08_F02_Camden2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F02_Camden2](Images/CH08_F02_Camden2.png)'
- en: Figure 8.2 Folder structure of our functions test project. Note that netlify.toml
    is at the root of test1; it’s a bit unclear in the screenshot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 函数测试项目的文件夹结构。请注意，netlify.toml 位于 test1 的根目录；在截图上可能不太清晰。
- en: Now we can finally test the scaffolding feature of the CLI. To begin, run netlify
    functions:create from the test1 folder. This will open a prompt asking you to
    select an example (figure 8.3).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于可以测试 CLI 的脚手架功能了。首先，从 test1 文件夹中运行 netlify functions:create。这将打开一个提示，要求您选择一个示例（图
    8.3）。
- en: '![CH08_F03_Camden2](Images/CH08_F03_Camden2.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F03_Camden2](Images/CH08_F03_Camden2.png)'
- en: Figure 8.3 Browsing the selection of function examples
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 浏览函数示例选择
- en: The first and default option, hello-world, is the simplest and the best to start
    with, so select that first. Next, you’ll be prompted to name your function; since
    we’re testing, take the default of hello-world. Click Enter, and the CLI will
    report on the newly scaffolded function (figure 8.4).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和默认选项，hello-world，是最简单且最适合开始的，所以先选择它。接下来，您将被提示为您的函数命名；由于我们正在测试，请使用默认的 hello-world。按
    Enter 键，CLI 将报告新搭建的函数（图 8.4）。
- en: '![CH08_F04_Camden2](Images/CH08_F04_Camden2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F04_Camden2](Images/CH08_F04_Camden2.png)'
- en: Figure 8.4 The CLI has finished scaffolding the function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 CLI 已完成函数的脚手架搭建。
- en: We’ll talk more about the general form of Netlify functions later, but for now
    know that this function looks for a name value in the query string, and if it
    doesn’t exist, uses a default value of 'World'. It then returns a JSON object
    with one value message that simply says hello to the name value (again, that is
    either provided in the query string or defaulted).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论 Netlify 函数的一般形式，但到目前为止，请了解这个函数会在查询字符串中查找一个名称值，如果不存在，则使用默认值 'World'。然后它返回一个包含一个值
    message 的 JSON 对象，该对象简单地对该名称值说 hello（再次强调，这可以是查询字符串中提供的，或者默认值）。
- en: Listing 8.2 The hello-world function
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 hello-world 函数
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So how do we test this? Another useful feature of the CLI is the dev command.
    This starts a local web server and lets you test your Jamstack site locally. In
    your terminal, ensure you can run netlify dev, and you should see output, as seen
    in figure 8.5\. Note that you should still be in the same directory as before.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何测试这个？CLI的另一个有用功能是dev命令。这个命令启动一个本地Web服务器，并允许你在本地测试你的Jamstack网站。在你的终端中，确保你可以运行netlify
    dev，你应该会看到如图8.5所示的输出。请注意，你仍然应该在之前的目录中。
- en: '![CH08_F05_Camden2](Images/CH08_F05_Camden2.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F05_Camden2](Images/CH08_F05_Camden2.png)'
- en: Figure 8.5 Running the local development server with the Netlify CLI
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 使用Netlify CLI运行本地开发服务器
- en: 'Along with running a local web server, the CLI may also open a tab in your
    browser. The site currently doesn’t have any HTML files, so you may get a “Not
    Found” message, but we can ignore that for now. To execute Netlify functions,
    you address them at /.netlify/functions/nameOfFunction. Given that figure 8.5
    says our site is running on localhost at port 8888, the full URL to our test function
    will be: http://localhost:8888/.netlify/functions/hello-world. Notice there is
    no “.js” at the end. The URL uses the name of the function but not the extension.
    If you run this, you should get the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行本地Web服务器外，CLI还可能在你的浏览器中打开一个标签页。目前网站还没有任何HTML文件，所以你可能收到“未找到”的消息，但我们可以暂时忽略它。要执行Netlify函数，你可以在/.netlify/functions/nameOfFunction处找到它们。鉴于图8.5表明我们的网站在本地主机8888端口上运行，我们的测试函数的完整URL将是：http://localhost:8888/.netlify/functions/hello-world。注意，结尾没有“.js”。URL使用函数名而不是扩展名。如果你运行这个，你应该得到以下输出：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you remember, we said the function takes a name argument via the URL. You
    can test this by adding ?name=Ray (or your own name) to the URL http://localhost
    :8888/.netlify/functions/hello-world?name=Ray. The output should then update:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们说过该函数通过URL传递一个名称参数。你可以通过在URL http://localhost:8888/.netlify/functions/hello-world?name=Ray（或你自己的名字）中添加?name=Ray来测试这一点。输出应该会更新：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s build something that makes use of this function. Our site now only contains
    the function (and configuration file), so let’s add an index.html file with a
    simple JavaScript example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一些使用这个函数的东西。我们的网站现在只包含函数（和配置文件），所以让我们添加一个index.html文件，包含一个简单的JavaScript示例。
- en: Best practices dictate that we should (normally) separate our HTML and JavaScript;
    for this simple demo, one file is sufficient. Our HTML consists of an input field,
    a button, and an empty div element. The input field will be where users enter
    their name. The button will fire off a request to our function. And finally, the
    empty div will display the result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践规定我们应该（通常）将我们的HTML和JavaScript分开；对于这个简单的演示，一个文件就足够了。我们的HTML由一个输入字段、一个按钮和一个空的div元素组成。输入字段将是用户输入他们的名字的地方。按钮将触发对函数的请求。最后，空的div将显示结果。
- en: The JavaScript sets a listener for when the document is loaded, and when it’s
    ready, listens for click events on the button. This runs the function with the
    somewhat poor name testApi, which uses the fetch API to hit our Netlify function.
    If you remember, the result is a JSON object with the key message. We can take
    the result of that call and write it into our DOM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript设置了一个监听器，当文档加载时，当它准备好时，监听按钮的点击事件。这个函数使用fetch API调用我们的Netlify函数，其名称相当糟糕，名为testApi。如果你记得，结果是包含键message的JSON对象。我们可以将这个调用的结果写入我们的DOM。
- en: Listing 8.3 Using our function from HTML and JavaScript code
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 使用HTML和JavaScript代码中的我们的函数
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The field where a person can enter their name
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个人可以输入他们的名字的字段
- en: ❷ Where we listen for clicks on the button
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们在哪里监听按钮的点击
- en: ❸ The code executed when the button is clicked. Figure 8.6 demonstrates a simple
    example of this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当按钮被点击时执行的代码。图8.6展示了这个简单的例子。
- en: '![CH08_F06_Camden2](Images/CH08_F06_Camden2.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F06_Camden2](Images/CH08_F06_Camden2.png)'
- en: Figure 8.6 A test of our Netlify function from simple JavaScript
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 从简单的JavaScript测试我们的Netlify函数
- en: 'You now have a simple static site that makes use of a serverless function!
    Let’s look at that serverless function again. At the top, we define the function
    using arrow-style functions (you can learn more about this style at [http://mng.bz/Bx7r](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)).
    If this style of defining functions is unfamiliar to you, you can rewrite it like
    so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了一个简单的静态网站，它使用了无服务器函数！让我们再次看看这个无服务器函数。在顶部，我们使用箭头函数风格定义了该函数（你可以在[http://mng.bz/Bx7r](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)了解更多关于这种风格的信息）。如果你对这种定义函数的风格不熟悉，你可以这样重写：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Netlify doesn’t require arrow functions, but the CLI defaults to using that
    format. The event object is one of two arguments sent to every Netlify function.
    The Netlify docs define this as similar to the Amazon AWS API Gateway event, but
    if you’ve never used that before, know that it will contain the following values:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify不要求使用箭头函数，但CLI默认使用该格式。事件对象是发送给每个Netlify函数的两个参数之一。Netlify文档将其定义为类似于Amazon
    AWS API Gateway事件，但如果你之前从未使用过，请了解它将包含以下值：
- en: Path—The path to the function itself
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Path—函数本身的路径
- en: httpMethod—The HTTP method used to call the function, useful for times when
    you care if the function was called with a form post
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: httpMethod—调用函数时使用的HTTP方法，在关心函数是否通过表单提交调用时很有用
- en: headers—All the request headers for this execution
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: headers—本次执行的所有请求头
- en: queryStringParameters—As shown, any values passed along the query string
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: queryStringParameters—如所示，通过查询字符串传递的任何值
- en: body—A JSON string of any request payload
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: body—任何请求负载的JSON字符串
- en: isBase64Encoded—A true/false flag specifying if the body is base64 encoded
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isBase64Encoded—一个true/false标志，指定body是否以base64编码
- en: The second argument passed to Netlify function is a context object. This object
    contains information about the function context itself, for example, things pertaining
    to the AWS Lambda function behind the scenes (Netlify hides all of this for you!).
    The context object isn’t something you need to use (hence it not even being shown
    in the function), so you will rarely make actual use of it in your function. The
    one place it does come into use is with Netlify’s user management system called
    Identity. We aren’t covering that here, but you can find out more about that in
    the docs ([https://docs.netlify.com/visitor-access/identity/](https://docs.netlify.com/visitor-access/identity/)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给Netlify函数的第二个参数是一个上下文对象。该对象包含有关函数上下文本身的信息，例如，与后台的AWS Lambda函数相关的事项（Netlify为你隐藏了所有这些）。上下文对象不是你需要使用的东西（因此甚至没有在函数中显示），所以你很少在函数中实际使用它。它真正被用到的地方是与Netlify的用户管理系统Identity相关。这里我们不涉及该内容，但你可以在文档中了解更多信息（[https://docs.netlify.com/visitor-access/identity/](https://docs.netlify.com/visitor-access/identity/))。
- en: 'The final part of your function is where you return data. As seen in listing
    8.4, an object is returned containing the following parts:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一部分是你返回数据的地方。如列表8.4所示，返回的对象包含以下部分：
- en: statusCode—This should be a valid HTTP status code representing the result status
    of the function. 200 is used to mean a good status, whereas 500 (and others) can
    represent errors and other states. Generally, you will return 200.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: statusCode—这应该是一个有效的HTTP状态码，表示函数的结果状态。200表示良好状态，而500（及其他）可以表示错误和其他状态。通常，你会返回200。
- en: Body—A JSON-string representing your data result. The caller will parse this
    JSON into valid data. You do not need to return a JSON string, but that’s fairly
    typical for serverless functions acting as an API.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Body—表示你的数据结果的JSON字符串。调用者将解析此JSON为有效数据。你不需要返回JSON字符串，但对于作为API的服务器端函数来说，这是相当典型的。
- en: headers and multiValueHeaders—These let you return headers to be sent along
    with your data. The headers value is used for simple key/value headers (header
    so-and-so has value so-and-so), whereas multiValueHeaders are used in cases where
    a header has multiple values. Some APIs will use headers to specify the content
    type or additional data related to things like licensing and other statuses.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: headers和multiValueHeaders—这些允许你返回与数据一起发送的头部。headers值用于简单的键/值头部（某个头部有某个值），而multiValueHeaders用于头部有多个值的情况。一些API将使用头部来指定内容类型或与许可和其他状态相关的其他数据。
- en: isBase64Encoded—Another true/false flag, this time for the result, that specifies
    if the result is base64 encoded.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isBase64Encoded—另一个true/false标志，这次是针对结果，指定结果是否以base64编码。
- en: Most developers will only need to worry about statusCode and body, which is
    what the CLI uses in its default scaffolded function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者只需关注statusCode和body，这正是CLI在默认的函数模板中使用的。
- en: Listing 8.4 The hello-world function
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 hello-world函数
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ This is the function declaration that defines the event object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是定义事件对象的函数声明。
- en: ❷ One of the values available in event is queryStringParameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 事件中可用的值之一是queryStringParameters。
- en: ❸ Serverless functions should return a status and body.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 无服务器函数应返回状态和body。
- en: 'If you want, you can modify your serverless function to log out the entire
    event object to the console: console.log(event);. If you switch to the terminal
    where you’re running the netlify command, you can see the output, but note it
    may be rather large, especially in the request header section, as seen in figure
    8.7.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以修改你的无服务器函数，将其整个事件对象输出到控制台：console.log(event);。如果你切换到你运行netlify命令的终端，你可以看到输出，但请注意，它可能相当大，尤其是在请求头部分，如图8.7所示。
- en: '![CH08_F07_Camden2](Images/CH08_F07_Camden2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F07_Camden2](Images/CH08_F07_Camden2.png)'
- en: Figure 8.7 Debug output from the serverless function
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 服务器端函数的调试输出
- en: 8.2.1 Adding serverless computing to Camden Grounds
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 将无服务器计算添加到Camden Grounds
- en: In chapter 2, you learned about Eleventy and built a simple coffee store called
    Camden Grounds. Let’s look at how we can use Netlify functions to enhance our
    Jamstack site. We’re going to modify the site such that each product page will
    now display a dynamic message if the product is available. We’ll use hardcoded
    logic (everything but tea is available) and client-side JavaScript to display
    the result. An example is shown in figure 8.8.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，你学习了Eleventy并构建了一个名为Camden Grounds的简单咖啡店。让我们看看我们如何使用Netlify函数来增强我们的Jamstack网站。我们将修改网站，使得每个产品页面现在如果产品可用将显示一个动态消息。我们将使用硬编码的逻辑（除了茶之外的所有产品都可用）和客户端JavaScript来显示结果。一个示例如图8.8所示。
- en: '![CH08_F08_Camden2](Images/CH08_F08_Camden2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F08_Camden2](Images/CH08_F08_Camden2.png)'
- en: Figure 8.8 The double espresso product is available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 双倍浓缩咖啡产品可用。
- en: Create a new copy of the site into your chapter 8 folder (or ensure you’ve downloaded
    the final code from the GitHub repository). Add the netlify.toml file that specifys
    the function’s directory. Since the CLI can create this folder, you do not need
    to manually create it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的第8章文件夹中创建网站的新副本（或者确保你已经从GitHub仓库下载了最终代码）。添加netlify.toml文件，指定函数的目录。由于CLI可以创建此文件夹，因此你不需要手动创建它。
- en: 'Once again we can use the Netlify CLI to scaffold an application, but this
    time we’ll save a step by specifying the name of function as an argument: netlify
    functions:create product-availability. This should be run in the new folder you
    created that is the copy of Camden Grounds. You will still be prompted for the
    type of function to create and accept the default (hello-world) again. The result
    will be a folder named product-availability and a file under it named product-availability.js,
    as shown in the following listing.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用Netlify CLI来构建应用程序，但这次我们将通过指定函数名称作为参数来节省一个步骤：netlify functions:create product-availability。这应该在您创建的新文件夹中运行，该文件夹是Camden
    Grounds的副本。您仍然会被提示选择要创建的函数类型，并再次接受默认值（hello-world）。结果将是一个名为product-availability的文件夹，以及其中名为product-availability.js的文件，如下所示。
- en: Listing 8.5 The product-availability function
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 产品可用性函数
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Checking for a product value in the query string
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在查询字符串中检查产品值
- en: ❷ Hardcoded logic that says tea won’t be available
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 硬编码的逻辑表示茶不可用
- en: ❸ Returning the available value
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回可用的值
- en: 'As before, we check the query string for a value, this time product. If the
    product being checked is tea, we return false. Note the result body uses a shorthand
    notation that replaces code that would use the same key and value, so, for example,
    instead of writing { name: name }, we can now write { name } to specify the same
    thing. Basically, a name key and the value is represented by the name variable.
    Netlify doesn’t require this syntax, but it’s there if you want to use it.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，我们检查查询字符串中的值，这次是产品。如果正在检查的产品是茶，我们返回false。注意结果体使用了一种简写符号，用来替换使用相同键和值的代码，因此，例如，我们不再需要写{name:
    name}，现在我们可以写{name}来指定相同的内容。基本上，一个键名和值由name变量表示。Netlify不要求这种语法，但如果你想要使用它，它是存在的。'
- en: To use this, we’re going to modify the products.liquid template file, which
    is used for every product for our site (listing 8.6). Our first change is to add
    an empty paragraph tag to the product template. This is then edited later by the
    JavaScript code. This template is executed once for every product, and you can
    actually see a bit of Liquid in the code itself. While JavaScript code is dynamic
    in the source, when deployed in product, it’s a hardcoded product name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，我们将修改用于我们网站上每个产品的products.liquid模板文件（列表8.6）。我们的第一个更改是在产品模板中添加一个空的段落标签。然后稍后由JavaScript代码进行编辑。此模板为每个产品执行一次，你实际上可以在代码本身中看到一些Liquid。虽然JavaScript代码在源代码中是动态的，但在产品部署时，它是一个硬编码的产品名称。
- en: The JavaScript makes a request to the serverless function, gets the result,
    and then handles updating the DOM with the availability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 向 serverless 函数发送请求，获取结果，然后使用可用性更新 DOM。
- en: Listing 8.6 The new product template (/chapter8/camdengrounds/products.liquid)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 新产品模板 (/chapter8/camdengrounds/products.liquid)
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ A new empty paragraph that will be updated via JavaScript
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将通过 JavaScript 更新的新空段落
- en: ❷ JavaScript code that will be static once the site is deployed
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 网站部署后将是静态的 JavaScript 代码
- en: ❸ Where the actual update happens
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 实际更新发生的地方
- en: You’ve already seen an example of a product being available, but if you go to
    the Tea page (don’t forget to start your site with netlify dev if you haven’t),
    you’ll now see it isn’t available (figure 8.9).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了一个产品可用的示例，但如果您访问茶页（如果您还没有，别忘了用 netlify dev 启动您的站点），您现在会看到它不可用（图 8.9）。
- en: '![CH08_F09_Camden2](Images/CH08_F09_Camden2.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F09_Camden2](Images/CH08_F09_Camden2.png)'
- en: Figure 8.9 No tea for you!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 没有茶可以喝！
- en: This brings up an interesting situation. Our Camden Grounds site now has both
    static and dynamic product data. The static portion is in the _data folder and
    is hardcoded JSON. The dynamic portion is the availability of the product. In
    production, the list of products will be static, but their availability will be
    checked on every visit. This makes sense for Camden Grounds, as they rarely change
    the products they sell but do sometimes run out of a particular product. This
    would not be appropriate for every Jamstack site out there but shows the flexibility
    of Jamstack in general.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个有趣的情况。我们的 Camden Grounds 网站现在既有静态产品数据也有动态产品数据。静态部分位于 _data 文件夹中，是硬编码的
    JSON。动态部分是产品的可用性。在生产环境中，产品列表将是静态的，但它们的可用性将在每次访问时进行检查。这对于 Camden Grounds 来说是合理的，因为他们很少更改他们销售的产品，但有时会缺货。这并不适合所有
    Jamstack 网站，但显示了 Jamstack 的一般灵活性。
- en: 8.2.2 More on Netlify functions
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 更多关于 Netlify 函数的内容
- en: Netlify functions are both simple to use and powerful in their implementation.
    You can peruse examples ([https://functions.netlify.com/examples/](https://functions.netlify.com/examples/))
    for more inspiration and play with some live ones at their playground ([https://functions.netlify.com/playground/](https://functions.netlify.com/playground/)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 函数既易于使用，在实现上又功能强大。您可以浏览示例（[https://functions.netlify.com/examples/](https://functions.netlify.com/examples/)）以获得更多灵感，并在他们的游乐场（[https://functions.netlify.com/playground/](https://functions.netlify.com/playground/)）中尝试一些实时示例。
- en: Recently, Netlify announced support for “Background Functions” ([https://docs.netlify.com/functions/background-functions/](https://docs.netlify.com/functions/background-functions/)).
    This feature is currently in beta and lets you run functions that need a much
    longer execution time to process. When called, they return a 202 status immediately
    and then begin their processing. They would not be used for functions that need
    to return a result to client-side JavaScript but could be useful for things that
    need to happen, as you can probably guess, in the background. Again, this feature
    is currently in beta, so use with caution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Netlify 宣布支持“后台函数”功能（[https://docs.netlify.com/functions/background-functions/](https://docs.netlify.com/functions/background-functions/)）。此功能目前处于测试阶段，允许您运行需要更长时间执行时间的函数。当被调用时，它们会立即返回
    202 状态，然后开始处理。这些函数不会用于需要向客户端 JavaScript 返回结果的函数，但如您所猜，对于需要在后台发生的操作可能很有用。再次提醒，此功能目前处于测试阶段，因此请谨慎使用。
- en: 8.3 Building serverless functions with Vercel
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3 使用 Vercel 构建 serverless 函数
- en: Like Netlify, Vercel supports easily deploying and using serverless functions
    along with your Jamstack site. You can write functions using Node.js, Go, Python,
    and Ruby. For those who want to use Node.js, you can use either JavaScript or
    TypeScript, if you prefer. (TypeScript is possible with Netlify functions as well,
    just not officially supported.) As with Netlify, Vercel has a free tier for their
    functions; details can be found on their pricing page ([https://vercel.com/pricing](https://vercel.com/pricing)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Netlify 一样，Vercel 支持轻松部署和使用与您的 Jamstack 网站一起使用的 serverless 函数。您可以使用 Node.js、Go、Python
    和 Ruby 编写函数。对于想使用 Node.js 的人来说，您可以使用 JavaScript 或 TypeScript，如果您愿意的话。（TypeScript
    也可以与 Netlify 函数一起使用，只是目前不是官方支持。）与 Netlify 一样，Vercel 为其函数提供免费层；详细信息可以在其定价页面上找到（[https://vercel.com/pricing](https://vercel.com/pricing)）。
- en: Vercel’s serverless support is documented ([https://vercel.com/docs/serverless-functions/introduction](https://vercel.com/docs/serverless-functions/introduction)),
    but at the time of writing this chapter, there were some parts of that documentation
    that were a bit misleading. Let’s start with a basic introduction to serverless
    functions with Vercel.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel的无服务器支持在文档中有记录([https://vercel.com/docs/serverless-functions/introduction](https://vercel.com/docs/serverless-functions/introduction))，但在撰写本章时，该文档的一些部分有些误导。让我们从Vercel无服务器函数的基本介绍开始。
- en: To create a Vercel serverless function, you begin by adding an api folder to
    your project. (For developers working with Next.js, you would use pages/api instead.)
    In that folder, you can then create your serverless function. The docs (again,
    at the time of publication) imply that the name of the function (outside of the
    extension) does not matter. This is not the case. The name of your file will impact
    the URL that you use to call the API. Vercel deploys your serverless function
    at the path /api/filenameMinusExtension. For example, if you create a file named
    func1.js, and your host is raymondcamden.com, your serverless function would be
    available at https://raymondcamden.com/ api/func1\. The documentation demonstrates
    a path that does *not* include the filename minus the extension, but that will
    only work if you name your file index.js. In my opinion, it doesn’t make sense
    to use this filename unless you are sure you are going to have only one serverless
    function on your site. Even if you are only planning one now, in the future you
    may need more.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Vercel无服务器函数，您首先需要在您的项目中添加一个api文件夹。（对于使用Next.js的开发者，您将使用pages/api代替。）在那个文件夹中，然后您可以创建您的无服务器函数。文档（再次，在出版时）暗示函数的名称（不包括扩展名）并不重要。这并不正确。您的文件名将影响您用于调用API的URL。Vercel将在路径/api/filenameMinusExtension上部署您的无服务器函数。例如，如果您创建了一个名为func1.js的文件，并且您的域名是raymondcamden.com，您的无服务器函数将可在https://raymondcamden.com/api/func1处访问。文档演示了一个不包括文件名减去扩展名的路径，但这仅当您将文件命名为index.js时才会有效。在我看来，除非您确信您将在网站上只有一个无服务器函数，否则使用此文件名没有意义。即使您现在只计划一个，将来您可能还需要更多。
- en: 'This confusion aside, what does a Vercel serverless function look like? Here
    is the example from its own docs:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略这种混淆，Vercel无服务器函数看起来是什么样子？这里是从其自己的文档中的示例：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once again, an arrow function is being used but is not required. You could
    rewrite this as such:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里使用的是箭头函数，但这不是必需的。您可以将其重写如下：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Use whatever form you are most comfortable with. The function is passed two
    arguments, req and res, which map to Node.js Request and Response objects with
    additional “helpers” provided by Vercel. For example, req.query maps to the query
    string of the request. These helpers are documented ([http://mng.bz/doOv](http://mng.bz/doOv))
    and currently exist only for developers using Node.js for their serverless functions.
    Let’s see this in action.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您最舒适的形式。该函数接收两个参数，req和res，它们映射到Node.js请求和响应对象，并提供了Vercel提供的额外“辅助工具”。例如，req.query映射到请求的查询字符串。这些辅助工具在文档中有记录([http://mng.bz/doOv](http://mng.bz/doOv))，并且目前仅适用于使用Node.js为其无服务器函数的开发者。让我们看看它是如何工作的。
- en: 8.3.1 Your first Vercel serverless function
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 您的第一个Vercel无服务器函数
- en: In chapter 6, you tested the Vercel service by installing its CLI tool. If you
    have not done that yet, please see the instructions in the previous chapter and
    set that up. You will want to both install the CLI and ensure you run the login
    command, so you can properly go forward.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，您通过安装其CLI工具来测试了Vercel服务。如果您还没有这样做，请参阅上一章中的说明并设置它。您需要安装CLI并确保运行登录命令，这样您才能正确地继续前进。
- en: Vercel’s Zero Config feature means it’s rather simple to use most of its features,
    and that includes its serverless support. In a new folder (or use the /chapter8/test2
    folder from the GitHub repository), create an API subdirectory and a new file,
    func1.js.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel的零配置功能意味着使用其大多数功能相当简单，包括其无服务器支持。在新的文件夹中（或使用GitHub仓库中的/chapter8/test2文件夹），创建一个API子目录和一个新文件，func1.js。
- en: Listing 8.7 A Vercel serverless function (/chapter8/test2/api/func1.js)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 Vercel无服务器函数 (/chapter8/test2/api/func1.js)
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function is the same code as the Vercel documentation. When requested,
    it will echo back the request body, query string, and any cookies that were sent.
    To test this, run vercel dev in your terminal, ensuring you are in the folder
    you created, not the api folder, but rather the directory above it. The vercel
    dev command is much like the Netlify version: it lets you run your site locally
    and test your site. The first time you run the command, you’ll be prompted to
    answer questions about the site, and you can take all the defaults (figure 8.10).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与Vercel文档中的代码相同。当请求时，它会回显请求体、查询字符串和发送的任何cookie。为了测试，请在终端中运行vercel dev，确保你位于你创建的文件夹中，而不是api文件夹，而是其上级目录。vercel
    dev命令与Netlify版本类似：它允许你在本地运行你的站点并测试你的站点。第一次运行该命令时，你将需要回答有关站点的问题，你可以接受所有默认设置（图8.10）。
- en: '![CH08_F10_Camden2](Images/CH08_F10_Camden2.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F10_Camden2](Images/CH08_F10_Camden2.png)'
- en: Figure 8.10 Running vercel dev for the first time
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 第一次运行vercel dev
- en: 'Subsequent runs of vercel dev will skip all these questions. To test your function,
    open your browser to http://localhost:3000/api/func1\. The “func1” at the end
    of the URL is our filename minus the extension. The result will be the contents
    of the query string (none in our first test), any cookies your browser sent, and
    nobody, as none was sent in the request. Your cookies may vary, but the output
    of the query value should look like an empty object:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 后续运行vercel dev将跳过所有这些问题。为了测试你的函数，打开你的浏览器到http://localhost:3000/api/func1。URL末尾的“func1”是我们文件名减去扩展名。结果将是查询字符串的内容（在我们的第一次测试中没有），你的浏览器发送的任何cookie，以及没有人，因为在请求中没有发送。你的cookie可能会有所不同，但查询值的输出应该看起来像一个空对象：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you change the URL in your browser to include a query string, for example,
    http://localhost:3000/api/func1?msg=hello&name=world, you will see the query value
    change:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将浏览器中的URL更改为包含查询字符串，例如，http://localhost:3000/api/func1?msg=hello&name=world，你会看到查询值发生变化：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The JSON response you are seeing comes from the serverless function using res.json.
    The argument passed to this is converted to JSON and returned in the result object.
    You do not need to return JSON, but most serverless functions do.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的JSON响应来自使用res.json的服务器端函数。传递给此的参数被转换为JSON并返回在结果对象中。你不需要返回JSON，但大多数无服务器函数都这样做。
- en: Let’s now test Vercel’s serverless functions by replicating what we did in the
    previous section. Earlier in the chapter, you used the scaffolded Netlify function
    in a simple frontend application that passed in a name value. Listing 8.4 demonstrated
    a Netlify function that looks for name in the query string with a default value
    of World. It then returned a JSON object with the key message and a value of "Hello
    Name", where Name is either the value in the query string or the default. The
    new function checks the req.query object for a name value and defaults it to "World".
    Then a string is returned with the message key containing the name. As you can
    see, at least in this example, it’s quite a bit slimmer than the Netlify version.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过复制上一节中做的事情来测试Vercel的无服务器函数。在本章早期，你在一个简单的前端应用程序中使用了Netlify函数的脚手架，传递了一个名称值。列表8.4演示了一个Netlify函数，它在查询字符串中查找名称，默认值为World。然后它返回一个包含键message和值为"Hello
    Name"的JSON对象，其中Name是查询字符串中的值或默认值。新函数检查req.query对象中的名称值，并在不存在时将其默认为"World"。然后返回一个包含消息键的字符串，其中包含名称。正如你所看到的，至少在这个例子中，它比Netlify版本要瘦得多。
- en: Listing 8.8 Hello function with Vercel (/chapter8/test2/api/hello.js)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 使用Vercel的Hello函数 (/chapter8/test2/api/hello.js)
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Check for a name value in the query string and default it if not present.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查查询字符串中的名称值，如果不存在则默认它。
- en: 'If you named this file hello.js, you can then access it at http://localhost:3000/api/
    hello?name=Ray. If you stopped the Vercel development server, remember to run
    it again with the vercel dev command. After clicking the URL, your output should
    be:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此文件命名为hello.js，你可以在http://localhost:3000/api/hello?name=Ray处访问它。如果你停止了Vercel开发服务器，请记住使用vercel
    dev命令再次运行它。点击URL后，你的输出应该是：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we need to build the simple frontend. This version will be the same as
    listing 8.3 with one tiny difference: the URL. You can find this new version in
    the GitHub repo in the file, /chapter8/test2/index.html.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要构建简单的前端。这个版本将与列表8.3相同，只有一个微小的区别：URL。你可以在GitHub仓库中的文件/chapter8/test2/index.html中找到这个新版本。
- en: Listing 8.9 Calling our Vercel serverless function (/chapter8/test2/index.html)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 调用我们的Vercel无服务器函数 (/chapter8/test2/index.html)
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The changed URL
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 修改后的URL
- en: The only thing we changed here is the URL used in the fetch command. Both the
    Netlify and Vercel function returned the same “shape” of their result, which made
    this update easier. Now let’s look at another interesting feature of Vercel’s
    serverless support.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里唯一改变的是 fetch 命令中使用的 URL。Netlify 和 Vercel 函数返回了相同“形状”的结果，这使得这次更新更容易。现在让我们看看
    Vercel 无服务器支持的一个有趣特性。
- en: 8.3.2 Vercel functions with dynamic path support
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 支持动态路径的 Vercel 函数
- en: In the previous examples, you saw a simple Vercel serverless function using
    the query string for input. While this works, you can use a different URL syntax
    that allows for dynamic paths, for example, /api/somefunction/somevalue and /api/somefunction/
    anothervalue. In these examples, we want to run a function, somefunction, and
    the last values (somevalue and anothervalue) are inputs given to the function.
    This makes for slightly simpler URL syntax and could be more desirable than the
    query string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您看到了一个使用查询字符串作为输入的简单 Vercel 无服务器函数。虽然这可行，但您可以使用不同的 URL 语法，允许动态路径，例如，/api/somefunction/somevalue
    和 /api/somefunction/ anothervalue。在这些示例中，我们想要运行一个函数，somefunction，而最后的值（somevalue
    和 anothervalue）是提供给函数的输入。这使得 URL 语法稍微简单一些，可能比查询字符串更受欢迎。
- en: 'To support this, you must do two things. First, create a subdirectory to store
    your function. This will end up as part of the URL path. Given the example, our
    directory is /api/somefunction. Next, you create a file for your serverless function.
    The name of the file must be surrounded in brackets, and the name of the file
    will determine how you access it in code. For example, if I used [value].js, then
    my serverless code would access the path value as req.query.value. Let’s test
    this by creating a new version of our previous serverless function that lets us
    use a path and not the query string. Under the api folder, create a new folder,
    greeter. The name must include the brackets and will then be used by our code
    to get the value. Create a file named [name].js. The contents of this file are
    the same as listing 8.8 and can be found in the GitHub repository at /chapter8/test2/api/greeter/[name].js.
    Once saved, you can access your function at http://localhost:3000/api/greeter/Ray.
    The output will be the same as the previous example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，您必须做两件事。首先，创建一个子目录来存储您的函数。这将最终成为 URL 路径的一部分。根据示例，我们的目录是 /api/somefunction。接下来，您为您的无服务器函数创建一个文件。文件名必须用方括号括起来，文件名将决定您如何在代码中访问它。例如，如果我用
    [value].js，那么我的无服务器代码将把路径 value 作为 req.query.value 访问。让我们通过创建一个新版本的先前无服务器函数来测试这一点，这个函数允许我们使用路径而不是查询字符串。在
    api 文件夹下，创建一个新的文件夹，greeter。名称必须包括方括号，然后将被我们的代码用来获取值。创建一个名为 [name].js 的文件。这个文件的内容与列表
    8.8 相同，可以在 GitHub 仓库的 /chapter8/test2/api/greeter/[name].js 找到。一旦保存，您就可以在 http://localhost:3000/api/greeter/Ray
    访问您的函数。输出将与上一个示例相同：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you change Ray to Lindy (http://localhost:3000/api/greeter/Lindy), you can
    probably guess what you’ll get:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 Ray 改为 Lindy（http://localhost:3000/api/greeter/Lindy），您可能可以猜到您会得到什么：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you want to test this version, the GitHub repository has index2.html, which
    simply repeats the change to index.html in switching where the fetch call makes
    its request.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试这个版本，GitHub 仓库中有 index2.html，它只是简单地重复了在切换 fetch 调用请求位置时对 index.html 的更改。
- en: 8.3.3 Adding serverless functions to Camden Grounds (again)
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 再次将无服务器函数添加到 Camden Grounds
- en: Let’s create another real-world example of serverless functions in the Jamstack
    by making use of Camden Grounds. This time we’re going to add an API to our site.
    This API will return either all the products available in JSON format or a filtered
    list based on a query string value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过利用 Camden Grounds 来创建另一个使用无服务器函数的 Jamstack 的真实世界示例。这次我们将向我们的网站添加一个 API。这个
    API 将返回所有可用的产品，格式为 JSON，或者根据查询字符串值返回一个过滤后的列表。
- en: To begin, copy the Camden Grounds site from your chapter 2 folder, or use the
    chapter8/camdengrounds2 folder from GitHub. If you don’t use the chapter 8 version
    from GitHub, we have to make a few quick changes to our earlier version. First,
    remove the existing package.json file. This came from the template source we used
    and will get in the way with our new version. The easiest way to create a new
    package .json file from scratch is with the command npm init -f. Next, we need
    to add Eleventy as a dependency. One of the features of Vercel is that it can
    determine a lot about your project based on your files. The package.json can help
    tip Vercel off as to how your project works. We’ve got an Eleventy site, so let’s
    set up Eleventy as a dependency by running npm install @11ty/eleventy --save.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从你的第 2 章文件夹中复制 Camden Grounds 网站，或者使用 GitHub 中的 chapter8/camdengrounds2 文件夹。如果你不使用
    GitHub 中的第 8 版本，我们必须对我们的早期版本进行一些快速更改。首先，删除现有的 package.json 文件。这个文件来自我们使用的模板源，会妨碍我们的新版本。从头开始创建新的
    package.json 文件的最简单方法是使用命令 npm init -f。接下来，我们需要添加 Eleventy 作为依赖项。Vercel 的一个特性是它可以根据你的文件确定你项目的大部分信息。package.json
    可以帮助 Vercel 了解你的项目是如何工作的。我们有一个 Eleventy 网站，所以让我们通过运行 npm install @11ty/eleventy
    --save 来设置 Eleventy 作为依赖项。
- en: 'At this point, your package.json file should look like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的 package.json 文件应该看起来像这样：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now you can run vercel dev to start the local server. As before, you’ll be prompted
    a few times, and you should take the defaults. Once the CLI is done, it will run
    Eleventy, and this time you’ll notice something a bit off in the output (figure
    8.11).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行 vercel dev 来启动本地服务器。和之前一样，你会被提示几次，你应该接受默认值。一旦 CLI 完成，它将运行 Eleventy，这次你会在输出中注意到一些不太对劲的地方（图
    8.11）。
- en: '![CH08_F11_Camden2](Images/CH08_F11_Camden2.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F11_Camden2](Images/CH08_F11_Camden2.png)'
- en: Figure 8.11 Error output from the Eleventy CLI
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 Eleventy CLI 的错误输出
- en: 'What you are seeing is an interesting side effect of using Vercel and Eleventy.
    When you ran vercel dev and it completed its initial setup, it created a new folder
    called .vercel with some configuration information. You don’t have to worry about
    that. But it also added a .gitignore file that specified .vercel. The .gitignore
    file is a special file Git repositories use as a way of flagging files and folders
    that should not be committed to your source repository. This action then triggered
    something in Eleventy. By default, Eleventy will ignore the node_modules folder
    used by npm unless you have a .gitignore file. The error message comes from Eleventy
    *not* ignoring the node_modules folder and getting tripped up by a random file
    inside. Luckily the fix is simple: add the node_modules file to your .gitignore
    file.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你所看到的是使用 Vercel 和 Eleventy 的一个有趣的副作用。当你运行 vercel dev 并完成其初始设置时，它创建了一个名为 .vercel
    的新文件夹，其中包含一些配置信息。你不必担心这一点。但它还添加了一个 .gitignore 文件，指定了 .vercel。.gitignore 文件是 Git
    仓库使用的一种特殊文件，作为标记不应提交到源仓库的文件和文件夹的方式。这个动作随后触发了 Eleventy 中的某些操作。默认情况下，Eleventy 会忽略
    npm 使用的 node_modules 文件夹，除非你有 .gitignore 文件。错误信息来自 Eleventy *没有*忽略 node_modules
    文件夹，并被一个随机文件所困扰。幸运的是，修复很简单：将 node_modules 文件添加到你的 .gitignore 文件中。
- en: Listing 8.10 The fixed .gitignore file (/chapter8/camdengrounds2/.gitignore)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 固定的 .gitignore 文件 (/chapter8/camdengrounds2/.gitignore)
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point you can press Ctrl or CMD-C in your terminal to stop vercel dev
    and simply run it again; the error should go away.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以按终端中的 Ctrl 或 CMD-C 来停止 vercel dev 并重新运行它；错误应该会消失。
- en: Now Camden Grounds should be up and running. Let’s add our serverless function.
    Create an api folder and then a file named products.js. The file begins with a
    copy of our product data from the Eleventy _data folder (with some of the text
    trimmed in the code listing to make it a bit shorter). After the list of products,
    the meat of the function begins. First, it looks for a query string value named
    filter. If it exists, this is used to filter the array. Finally, the products
    are returned as JSON.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Camden Grounds 应该已经启动并运行。让我们添加我们的无服务器函数。创建一个 api 文件夹，然后创建一个名为 products.js
    的文件。该文件以从 Eleventy _data 文件夹（代码列表中的一些文本被裁剪以使其更短）中的产品数据副本开始。在产品列表之后，函数的主要内容开始。首先，它查找一个名为
    filter 的查询字符串值。如果存在，则用于过滤数组。最后，产品作为 JSON 返回。
- en: Listing 8.11 The products API (/chapter8/camdengrounds2/api/products.js)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 产品 API (/chapter8/camdengrounds2/api/products.js)
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that while testing, I noticed that the first time I added my serverless
    function, the CLI did not recognize that it had been added. I stopped the Vercel
    CLI and reran, and it picked it up fine. If you encounter this as well, try the
    same.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在测试过程中，我发现第一次添加我的无服务器函数时，CLI 没有识别出它已被添加。我停止了 Vercel CLI 并重新运行，它顺利地识别了它。如果你也遇到这种情况，请尝试同样的方法。
- en: 'With the function saved, access it in your browser at http://localhost:3000/api/products.
    You’ll see all the products. Next, try filtering http://localhost:3000/ api/products?filter=espresso.
    This returns a shorter list:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 函数保存后，你可以在浏览器中通过 http://localhost:3000/api/products 访问它。你会看到所有产品。接下来，尝试过滤 http://localhost:3000/api/products?filter=espresso。这将返回一个更短的列表：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now your "static" Jamstack site has its own API that can be used by other sites!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的 "静态" Jamstack 网站已经有了自己的 API，其他网站可以使用它！
- en: In the next chapter, you’ll get an introduction to powerful, user-friendly CMS
    (content management system) offerings that make Jamstack even easier to use, especially
    for people without a technical background.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解一些强大且用户友好的 CMS（内容管理系统）产品，这些产品使得 Jamstack 更易于使用，特别是对于那些没有技术背景的人来说。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Serverless computing gives you all the power of a server without the boring
    chore of having to set one up. It also relieves you of the worry of maintaining
    that server.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器计算为你提供了服务器的所有功能，而不需要设置服务器的繁琐工作。它还减轻了你维护服务器的担忧。
- en: FaaS is a generic term that describes using serverless computing as a way of
    writing functions that perform some action and then exposing that function via
    a URL. These functions could be site-specific utilities that don’t exist as external
    services. For example, a store that has unusual hours (let’s say weather-dependent)
    could use a serverless function to handle that logic. It could use another serverless
    function to handle checking product availability.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FaaS 是一个通用术语，描述了使用无服务器计算作为编写执行某些操作并随后通过 URL 公开这些函数的方式。这些函数可以是特定于站点的实用工具，而不是外部服务。例如，一个营业时间不寻常（比如说天气相关）的商店可以使用无服务器函数来处理这种逻辑。它还可以使用另一个无服务器函数来处理检查产品可用性。
- en: Netlify provides support for serverless functions and has a CLI that can be
    used to scaffold and test locally. Netlify lets you build multiple functions in
    your Jamstack site and provides a standard URL for accessing them.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify 提供无服务器函数的支持，并有一个 CLI 可以用来本地搭建和测试。Netlify 允许你在 Jamstack 网站中构建多个函数，并为它们提供标准
    URL 以供访问。
- en: Vercel has support for serverless functions and can be tested locally via the
    CLI. Like Netlify, it follows a standard of where to place your code and how to
    access it.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vercel 支持无服务器函数，并且可以通过 CLI 在本地进行测试。与 Netlify 类似，它遵循一个标准，即代码放置的位置以及如何访问代码。
