- en: '13 Remote control: One-to-one and one-to-many'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 远程控制：一对一和一对多
- en: Let’s take a look at the `Invoke-ScriptBlock` command. Notice that it has a
    `-ComputerName` parameter. Hmmm . . . does that mean it can run commands on other
    hosts too? After a bit of experimenting, you’ll discover that’s exactly what it
    does. How many other commands have the ability to connect to remote machines?
    While there is not a way to obtain a concrete number to answer this question,
    there are quite a lot.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `Invoke-ScriptBlock` 命令。注意它有一个 `-ComputerName` 参数。嗯嗯……这难道意味着它也可以在其它主机上运行命令吗？经过一番实验，你会发现这正是它的功能。有多少其他命令有连接到远程机器的能力呢？虽然没有办法获得一个具体的数字来回答这个问题，但确实有很多。
- en: What we’ve realized is that PowerShell’s creators are a bit lazy—and that’s
    a good thing. Because they didn’t want to have to code a `-HostName` parameter
    for every single cmdlet, they created a shell-wide system called *remoting*. This
    system enables you to run any cmdlet on a remote computer. In fact, you can even
    run commands that exist on the remote computer but that don’t exist on your own
    computer—meaning you don’t always have to install every administrative cmdlet
    on your workstation. This remoting system is powerful, and it offers interesting
    administrative capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到的是，PowerShell 的创造者有点懒惰——这其实是个好事。因为他们不想为每个 cmdlet 编写 `-HostName` 参数，所以他们创建了一个跨
    shell 的系统，称为 *远程*。这个系统使你能够在远程计算机上运行任何 cmdlet。实际上，你甚至可以运行存在于远程计算机上但不存在于你自己的计算机上的命令——这意味着你不必总是在你工作站上安装每个管理
    cmdlet。这个远程系统非常强大，并提供了有趣的行政管理能力。
- en: Note Remoting is a huge, complex technology. We introduce you to it in this
    chapter and cover usage scenarios that you’ll deal with 80% to 90% of the time.
    But we can’t cover it all, so in the “Further exploration” section at the end
    of this chapter, we point you to a must-have resource that covers remoting’s configuration
    options.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：远程是一个庞大而复杂的技术。我们在本章中向您介绍它，并涵盖了您将遇到的 80% 到 90% 的使用场景。但我们无法涵盖所有内容，因此在本章末尾的“进一步探索”部分，我们指向了一个必须的资源，该资源涵盖了远程配置选项。
- en: 13.1 The idea behind remote PowerShell
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 远程 PowerShell 的理念
- en: Remote PowerShell works somewhat similarly to Telnet and other age-old remote-control
    technologies. When you run a command, it’s running *on* the remote computer—only
    the results of that command come back to your computer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Remote PowerShell 的工作方式与 Telnet 和其他古老的远程控制技术有些相似。当你运行一个命令时，它是在远程计算机上运行的——只有该命令的结果会返回到你的计算机。
- en: 13.1.1 Remoting on Windows devices
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 Windows 设备上的远程
- en: PowerShell uses a communications protocol called *Web Services for Management*
    (WSMan). WSMan operates entirely over HTTP or HTTPS (HTTP by default), making
    it easy to route through firewalls if necessary (because each of those protocols
    uses a single port to communicate). Microsoft’s implementation of WSMan comes
    in the form of a background service, Windows Remote Management (WinRM). WinRM
    is installed by default on Windows 10 devices and Server 2012 and up. By default,
    these services are disabled but can easily be enabled individually or by group
    policy.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 使用一种名为 *Web 服务管理* (WSMan) 的通信协议。WSMan 完全通过 HTTP 或 HTTPS（默认为 HTTP）运行，如果需要的话，可以轻松地通过防火墙（因为每个协议都使用单个端口进行通信）。Microsoft
    对 WSMan 的实现形式是一个后台服务，Windows 远程管理 (WinRM)。WinRM 默认安装在 Windows 10 设备和 Server 2012
    及以上版本上。默认情况下，这些服务是禁用的，但可以很容易地通过组策略单独或成组启用。
- en: 13.1.2 Remoting on macOS and Linux devices
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 macOS 和 Linux 设备上的远程
- en: As you can guess, WSMan and WinRM are Windows-only services. So in order for
    PowerShell to have remoting capabilities, the team decided that it would be best
    to use the industry standard Secure Shell (SSH). SSH makes it easy to route through
    firewalls if necessary (because that protocol uses a single port to communicate)
    and has been used by Linux professionals for decades. Microsoft has ported OpenSSH
    to Windows, so you can even use this to remote into Windows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，WSMan 和 WinRM 是仅适用于 Windows 的服务。因此，为了让 PowerShell 具有远程功能，团队决定最好使用行业标准的安全外壳
    (SSH)。SSH 如果需要的话可以轻松地通过防火墙（因为该协议使用单个端口进行通信）并且几十年来一直被 Linux 专业人士使用。Microsoft 已经将
    OpenSSH 移植到 Windows 上，因此你甚至可以使用它来远程连接到 Windows。
- en: Setting up PSRP over SSH on Windows
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上通过 SSH 设置 PSRP
- en: 'You may want to set up PowerShell remoting protocol (PSRP) over SSH on any
    Windows machine you have PowerShell Core installed on. We won’t go into the details
    on how to set this up, but the instructions are available in Microsoft’s documentation:
    [http://mng.bz/laPd](http://mng.bz/laPd).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想在安装了PowerShell Core的任何Windows机器上设置PowerShell远程协议（PSRP）通过SSH。我们不会详细介绍如何设置，但Microsoft的文档中有可用的说明：[http://mng.bz/laPd](http://mng.bz/laPd)。
- en: 13.1.3 Cross-platform remoting
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.3 跨平台远程操作
- en: 'You’ve already learned that PowerShell cmdlets all produce objects as their
    output. When you run a remote command, its output objects need to be put into
    a form that can be easily transmitted over a network. XML, it turns out, is an
    excellent way to do that, so PowerShell automatically *serializes* those output
    objects into XML. The XML is transmitted across the network and is then *deserialized*
    on your computer back into objects that you can work with inside PowerShell. Serialization
    and deserialization are really just a form of format conversion: from objects
    to XML (serialization), and from XML to objects (deserialization).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到PowerShell cmdlet的所有输出都是对象。当你运行远程命令时，其输出对象需要被转换成可以在网络上轻松传输的形式。结果证明，XML是完成这一任务的一种极好的方式，因此PowerShell自动将这些输出对象序列化为XML。XML通过网络传输，然后在你的计算机上反序列化，回到PowerShell内部你可以操作的对象。序列化和反序列化实际上只是格式转换的一种形式：从对象到XML（序列化），以及从XML到对象（反序列化）。
- en: Why should you care how this output is returned? Because those serialized-then-deserialized
    objects are only snapshots, of sorts; they don’t update themselves continually.
    For example, if you were to get the objects that represent the processes running
    on a remote computer, what you’d get back would be accurate for only the exact
    point in time at which those objects were generated. Values such as memory usage
    and CPU utilization won’t be updated to reflect subsequent conditions. In addition,
    you can’t tell the deserialized objects to do anything—you can’t instruct one
    to stop itself, for example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么应该关心这种输出是如何返回的？因为这些序列化然后反序列化的对象只是某种形式的快照；它们不会持续更新。例如，如果你要获取表示远程计算机上正在运行的过程的对象，你得到的结果将只准确反映那些对象生成时的确切时间点。像内存使用和CPU利用率这样的值不会更新以反映随后的条件。此外，你不能告诉反序列化的对象做任何事情——你不能指示它们停止自己，例如。
- en: 'Those are basic limitations of remoting, but they don’t stop you from doing
    some amazing stuff. In fact, you can tell a remote process to stop itself, but
    you have to be clever about it. We’ll show you how later in this chapter. To make
    remoting work, you have two basic requirements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是远程操作的基本限制，但它们并不会阻止你做一些令人惊叹的事情。实际上，你可以告诉远程进程停止自己，但你必须足够聪明。我们将在本章后面展示如何做到这一点。为了使远程操作生效，你需要满足两个基本要求：
- en: Both your computer and the one you want to send commands to must be running
    PowerShell v7.1 or later.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要发送命令的计算机和你自己的计算机都必须运行PowerShell v7.1或更高版本。
- en: Ideally, both computers need to be members of the same domain, or of trusted/
    trusting domains. It’s possible to get remoting to work outside a domain, but
    it’s trickier, and we don’t cover it in this chapter. To learn more about that
    scenario, open PowerShell and run `help` `about_remote_troubleshooting`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，两台计算机都需要是同一域的成员，或者信任/被信任的域的成员。在域外使远程操作生效是可能的，但这更复杂，本章中我们不涉及这一点。要了解更多关于这种情况的信息，请打开PowerShell并运行`help`
    `about_remote_troubleshooting`。
- en: Try it Now We hope you’ll be able to follow along with some of the examples
    in this chapter. To participate, you’ll ideally have a second test computer (or
    a virtual machine) that’s in the same Active Directory domain as the test computer
    you’ve been using up to this point. You can run any version of Windows on that
    second computer, provided you have PowerShell v7.1 or later installed. If you
    are using two Windows devices, it will make your life a lot easier if they are
    part of the same domain. If you can’t set up an additional computer or virtual
    machine, use `localhost` to create remoting connections to your current computer.
    You’re still using remoting, but it isn’t as exciting to be “remote controlling”
    the computer at which you’re sitting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 我们希望您能够跟随本章的一些示例。为了参与，理想情况下您将有一个第二台测试计算机（或虚拟机），该计算机与您到目前为止使用的测试计算机位于同一
    Active Directory 域中。只要在该第二台计算机上安装了 PowerShell v7.1 或更高版本，您就可以在该计算机上运行任何版本的 Windows。如果您使用了两台
    Windows 设备，如果它们属于同一域，这将使您的生活变得更加容易。如果您无法设置额外的计算机或虚拟机，请使用 `localhost` 来创建到您当前计算机的远程连接。尽管您仍在使用远程操作，但坐在您面前的计算机进行“远程控制”并不那么令人兴奋。
- en: 13.2 Setting up PSRP over SSH
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 在 SSH 上设置 PSRP
- en: Let’s spend some time getting SSH set up in your environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花些时间在您的环境中设置 SSH。
- en: 13.2.1 macOS and Linux
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 macOS 和 Linux
- en: 'On the computer, make sure that the SSH server and client are installed. On
    Ubuntu, these are the instructions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上，确保已安装 SSH 服务器和客户端。在 Ubuntu 上，这些是相应的说明：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For macOS, the client is installed by default. Here is the command to enable
    the server:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS，客户端默认已安装。以下是启用服务器的命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to install the module that enables PSRP over SSH:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装启用 SSH 上 PSRP 的模块：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, run the command to enable PSRP over SSH:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行命令以启用 SSH 上的 PSRP：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, you need to restart the OpenSSH service. On Ubuntu, this is the command
    to restart the service:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要重新启动 OpenSSH 服务。在 Ubuntu 上，这是重新启动服务的命令：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On macOS, this is the command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，这是相应的命令：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 13.2.2 Setting up SSH on Windows
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 在 Windows 上设置 SSH
- en: SSH can run on Windows desktops and servers as well. In fact, you can disable
    WinRM if you really want to (we don’t suggest you do that). Most likely, if you
    are using SSH for remoting on a Windows device, you are either remoting to or
    from a Linux or macOS device.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 也可以在 Windows 桌面和服务器上运行。实际上，如果您真的想禁用 WinRM，您也可以这样做（我们不建议这样做）。如果您在 Windows
    设备上使用 SSH 进行远程操作，您可能是在 Linux 或 macOS 设备上远程到或从这些设备远程。
- en: 'Install the OpenSSH client and server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 OpenSSH 客户端和服务器：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the initial configuration of the SSH server:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 SSH 服务器的初始配置：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Confirm the firewall rule is configured. It should be created automatically
    by setup:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确认防火墙规则已配置。它应该由设置自动创建：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There should be a firewall rule named `OpenSSH-Server-In-TCP`, which should
    be enabled. Configure and edit the sshd_config file located at `$env:ProgramData\ssh`
    on the target machine *(figure 13.1)*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个名为 `OpenSSH-Server-In-TCP` 的防火墙规则，该规则应该被启用。配置并编辑位于目标机器 `$env:ProgramData\ssh`
    上的 sshd_config 文件 *(图 13.1)*。
- en: '![](Images/CH13_F01_Plunk.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH13_F01_Plunk.png)'
- en: Figure 13.1 This is what the sshd_config file looks like with the PowerShell
    changes added.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 这是添加 PowerShell 变更后的 sshd_config 文件的外观。
- en: 'Verify that password authentication is enabled by removing the `#` sign:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除 `#` 符号来验证密码认证是否已启用：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add the `Subsystem` for PowerShell. You can see that we are using the 8.3 short
    names for the file paths that contain spaces.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 PowerShell 的 `Subsystem`。您可以看到我们正在使用包含空格的文件路径的 8.3 短名称。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The 8.3 short name for the `Program Files` folder in Windows is usually `Progra~1`.
    However, you can use the following command to make sure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中 `Program Files` 文件夹的 8.3 短名称通常是 `Progra~1`。但是，您可以使用以下命令来确保这一点：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An optional enable-key authentication is
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的启用密钥认证是
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Restart the OpenSSH service:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 OpenSSH 服务：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Be sure to secure your SSH server
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确保保护您的 SSH 服务器
- en: 'You should research current standards for securing OpenSSH. At the time of
    writing, the basics are only to enable private-key authentication. Also, be sure
    to secure your private key. Here are links on how to do this for major platforms:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该研究当前用于保护 OpenSSH 的标准。在撰写本文时，基本做法是仅启用私钥认证。此外，请确保保护您的私钥。以下是针对主要平台如何执行此操作的链接：
- en: 'macOS: [http://mng.bz/Bxyw](http://mng.bz/Bxyw)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'macOS: [http://mng.bz/Bxyw](http://mng.bz/Bxyw)'
- en: 'Ubuntu: [http://mng.bz/do9g](http://mng.bz/do9g)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ubuntu: [http://mng.bz/do9g](http://mng.bz/do9g)'
- en: 13.3 PSRP over SSH overview
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 SSH 上 PSRP 概述
- en: Let’s talk about SSH, because you’re going to have to configure it in order
    to use remoting. Once again, you need to configure PSRP over SSH—and PowerShell
    remoting—on only those computers that will *receive* incoming commands. In most
    of the environments we’ve worked in, the administrators have enabled remoting
    on every computer. Doing so gives you the ability to remote into client desktop
    and laptop computers in the background (meaning the users of those computers won’t
    know you’re doing so), which can be tremendously useful.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈 SSH，因为你将需要配置它才能使用远程功能。再一次，你需要配置 PSRP 通过 SSH——以及 PowerShell 远程——只在这些将 *接收*
    传入命令的计算机上。在我们工作过的多数环境中，管理员已经在每台计算机上启用了远程功能。这样做可以让你在后台远程到客户端桌面和笔记本电脑（这意味着那些计算机的用户不会知道你在这样做），这可以非常有用。
- en: SSH allows multiple subsystems to register. This allows different protocols
    to work over the same port. When you enable SSH remoting, PowerShell registers
    as a subsystem, and incoming connections from PSRP are routed to that subsystem.
    Figure 13.2 illustrates how the pieces fit together.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 允许多个子系统注册。这允许不同的协议在同一个端口上工作。当你启用 SSH 远程时，PowerShell 会注册为一个子系统，来自 PSRP 的传入连接会被路由到该子系统。图
    13.2 展示了这些部分是如何组合在一起的。
- en: '![](Images/CH13_F02_Plunk.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH13_F02_Plunk.png)'
- en: Figure 13.2 The relationship between OpenSSH and PowerShell
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 OpenSSH 和 PowerShell 之间的关系
- en: As shown, you can have dozens or even hundreds of `sshd` subsystems on your
    system. Each endpoint can point to a different application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，你可以在系统中拥有数十个甚至数百个 `sshd` 子系统。每个端点可以指向不同的应用程序。
- en: Figure 13.2 also illustrates the `sshd` *listener*. `sshd` acts as a listener
    sitting and waiting for incoming network traffic—kind of like a web server listening
    for incoming requests. A listener “listens” on a specific port and on a specific
    IP address.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 还展示了 `sshd` *监听器*。`sshd` 作为监听器，坐着等待传入的网络流量——有点像网站服务器在等待传入请求。监听器“监听”在特定的端口和特定的
    IP 地址上。
- en: Try it Now Go ahead and enable remoting on your second computer (or on the first
    one, if that’s the only one you have to work with). If you receive an error message
    when you enable remoting, stop and figure it out.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。在你的第二台计算机上（或者如果你只有一台计算机，就在那台计算机上）启用远程功能。如果你在启用远程功能时收到错误消息，请停止并找出原因。
- en: 13.4 WinRM overview
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 WinRM 概述
- en: Let’s talk about WinRM, because you’re going to have to configure it in order
    to use remoting. Once again, you need to configure WinRM—and PowerShell remoting—on
    only those computers that will *receive* incoming commands. In most of the environments
    we’ve worked in, the administrators have enabled remoting on every Windows-based
    computer (keep in mind that PowerShell and remoting are supported all the way
    back to Windows XP). Doing so gives you the ability to remote into client desktop
    and laptop computers in the background (meaning the users of those computers won’t
    know you’re doing so), which can be tremendously useful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈 WinRM，因为你将需要配置它才能使用远程功能。再一次，你需要配置 WinRM——以及 PowerShell 远程——只在这些将 *接收*
    传入命令的计算机上。在我们工作过的多数环境中，管理员已经在基于 Windows 的每台计算机上启用了远程功能（请记住，PowerShell 和远程功能一直支持到
    Windows XP）。这样做可以让你在后台远程到客户端桌面和笔记本电脑（这意味着那些计算机的用户不会知道你在这样做），这可以非常有用。
- en: 'WinRM isn’t unique to PowerShell. Microsoft is starting to use it for more
    and more administrative communications—even things that use other protocols today.
    With that in mind, Microsoft made WinRM capable of routing traffic to multiple
    administrative applications—not only PowerShell. WinRM acts as a dispatcher: when
    traffic comes in, WinRM decides which application needs to deal with that traffic.
    All WinRM traffic is tagged with the name of a recipient application, and those
    applications must register as *endpoints* with WinRM so that WinRM will listen
    for incoming traffic on their behalf. This means you need to not only enable WinRM,
    but also tell PowerShell to register as an endpoint with WinRM. Figure 13.3 illustrates
    how the pieces fit together.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: WinRM 并非 PowerShell 独有。微软开始越来越多地使用它来进行管理通信——甚至包括今天使用其他协议的事情。考虑到这一点，微软使 WinRM
    能够将流量路由到多个管理应用程序——不仅仅是 PowerShell。WinRM 作为调度器：当流量进入时，WinRM 会决定哪个应用程序需要处理该流量。所有
    WinRM 流量都会被标记为接收应用程序的名称，并且这些应用程序必须作为 *端点* 在 WinRM 上注册，以便 WinRM 代表它们监听传入的流量。这意味着你不仅需要启用
    WinRM，还需要告诉 PowerShell 将自己注册为 WinRM 的端点。图 13.3 展示了这些部分是如何组合在一起的。
- en: '![](Images/CH13_F03_Plunk.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH13_F03_Plunk.png)'
- en: Figure 13.3 The relationship between WinRM, WSMan, endpoints, and PowerShell
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 WinRM、WSMan、端点和PowerShell之间的关系
- en: As shown, you can have dozens or even hundreds of WinRM endpoints on your system
    (PowerShell calls them *session configurations*). Each endpoint can point to a
    different application, and you can even have endpoints that point to the same
    application but provide different permissions and functionality. For example,
    you could create a PowerShell endpoint that allows only one or two commands, and
    make it available to specific users in your environment. We don’t dive that deep
    into remoting in this chapter, but we do later in the book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，你可以在系统中拥有数十个甚至数百个WinRM端点（PowerShell称其为*会话配置*）。每个端点可以指向不同的应用程序，你甚至可以拥有指向相同应用程序但提供不同权限和功能的端点。例如，你可以创建一个只允许一个或两个命令的PowerShell端点，并将其提供给环境中特定的用户。我们在这章中不会深入探讨远程操作，但在本书的后续章节中会进行讨论。
- en: Figure 13.3 also illustrates the WinRM *listener*, which in the figure is of
    the HTTP variety. A listener sits and waits for incoming network traffic on behalf
    of WinRM—kind of like a web server listening for incoming requests. A listener
    “listens” on a specific port and on a specific IP address, although the default
    listener created by `Enable-PSRemoting` listens on *all* local IP addresses.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3还说明了WinRM*监听器*，在图中是HTTP类型的。监听器代表WinRM静候传入的网络流量——有点像网站服务器在等待传入请求。监听器“监听”在特定的端口和特定的IP地址上，尽管由`Enable-PSRemoting`创建的默认监听器会在*所有*本地IP地址上监听。
- en: The listener connects to the defined endpoint. One way to create an endpoint
    is to open a copy of PowerShell—making sure that you’re running it as an administrator—and
    run the `Enable-PSRemoting` cmdlet. You might sometimes see references to a different
    cmdlet, called `Set-WSManQuickConfig`. You don’t need to run that one; `Enable-PSRemoting`
    will call it for you, and `Enable-PSRemoting` performs a few extra steps that
    are necessary to get remoting up and running. All told, the cmdlet will start
    the WinRM service, configure it to start automatically, register PowerShell as
    an endpoint, and even set up a Windows Firewall exception to permit incoming WinRM
    traffic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器连接到定义的端点。创建端点的一种方法是在管理员权限下打开PowerShell的一个副本——确保你以管理员身份运行它——并运行`Enable-PSRemoting`命令。你有时可能会看到对另一个名为`Set-WSManQuickConfig`的命令的引用。你不需要运行那个命令；`Enable-PSRemoting`会为你调用它，并且`Enable-PSRemoting`会执行一些额外的步骤，这些步骤对于远程操作能够启动和运行是必要的。总的来说，该命令将启动WinRM服务，将其配置为自动启动，将PowerShell注册为端点，甚至设置Windows防火墙异常以允许传入的WinRM流量。
- en: Try it Now Go ahead and enable remoting on your second computer (or on the first
    one, if that’s the only one you have to work with). Make sure you’re running PowerShell
    as an administrator if you are on a Windows device (the Window’s title bar should
    read Administrator). If you’re not, close the shell, right-click the PowerShell
    icon in the Start menu, and select Run as Administrator from the context menu.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 前往你的第二台计算机（或者如果你只有一台要工作的话，就是第一台）上启用远程操作。如果你在Windows设备上，确保以管理员身份运行PowerShell（窗口标题栏应显示为管理员）。如果不是，关闭外壳，在开始菜单中右键单击PowerShell图标，并从上下文菜单中选择以管理员身份运行。
- en: The most common error you will receive is “WinRM firewall exception will not
    work since one of the network connection types on this machine is set to Public.”
    Any network connection set to `Public` can’t have Windows Firewall exceptions,
    so when `Enable-PSRemoting` tries to create one, it fails. The only solution is
    to go into Windows and modify the network adapter setting so that whatever network
    you’re on is either Work or Home. But don’t do this if you’re connected to a public
    network (e.g., a public wireless hotspot), because you’ll be turning off some
    valuable security protections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你最可能遇到的错误是“由于此机器上的网络连接类型之一设置为公共，WinRM防火墙异常将无法工作。”任何设置为`Public`的网络连接都不能有Windows防火墙异常，所以当`Enable-PSRemoting`尝试创建一个时，它会失败。唯一的解决方案是进入Windows并修改网络适配器设置，将你所在的网络设置为工作或家庭。但如果你连接到公共网络（例如，公共无线热点），请不要这样做，因为你将关闭一些宝贵的安全保护措施。
- en: Note You don’t have to worry about PowerShell remoting and public networks as
    much on server operating systems, because they don’t have the same restrictions
    in the OS.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 你在服务器操作系统上不必过多担心PowerShell远程操作和公共网络，因为它们在操作系统上没有相同的限制。
- en: 'If you’re not excited about having to run around to every computer to enable
    remoting, don’t worry: you can also do it with a Group Policy Object (GPO). The
    necessary GPO settings are built into your domain controllers (you can download
    an ADM template from [www.microsoft.com/en-us/download](https://www.microsoft.com/en-us/download)
    to add these GPO settings to an older domain’s domain controllers). Open a GPO
    and look under Computer Configuration > Administrative Templates > Windows Components.
    Near the bottom of the list, you’ll find both Remote Shell and Windows Remote
    Management. For now, we’ll assume you’ll run `Enable-PSRemoting` on those computers
    that you want to configure, because at this point you’re probably playing around
    with only a virtual machine or two.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对不得不跑遍每台计算机以启用远程操作不感兴趣，请不要担心：您也可以使用组策略对象（GPO）来完成此操作。必要的 GPO 设置已内置到您的域控制器中（您可以从
    [www.microsoft.com/en-us/download](https://www.microsoft.com/en-us/download) 下载
    ADM 模板，以将这些 GPO 设置添加到较旧域的域控制器）。打开一个 GPO，然后在计算机配置 > 管理模板 > Windows 组件下查找。在列表底部附近，您将找到远程外壳和
    Windows 远程管理。现在，我们假设您将在您想要配置的计算机上运行 `Enable-PSRemoting`，因为到目前为止，您可能只是在玩一个或两个虚拟机。
- en: Note PowerShell’s `about_remote_troubleshooting` help topic provides more coverage
    on using GPOs. Look for the “How to enable remoting in an enterprise” and “How
    to enable listeners by using a Group Policy” sections within that help topic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 PowerShell 的 `about_remote_troubleshooting` 帮助主题提供了更多关于使用 GPO 的信息。在该帮助主题中查找“如何在企业中启用远程操作”和“如何使用组策略启用监听器”部分。
- en: 13.5 Using Enter-PSSession and Exit-PSSession for one-to-one remoting
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 使用 Enter-PSSession 和 Exit-PSSession 进行一对一远程操作
- en: PowerShell uses remoting in two distinct ways. The first is one-to-one, or 1:1,
    remoting. The second is one-to-many, or 1:N, remoting (and you’ll see it in the
    next section). With one-to-one remoting, you’re accessing a shell prompt on a
    single remote computer. Any commands you run will run directly on that computer,
    and you’ll see results in the shell window. This is vaguely similar to using SSH
    or Remote Desktop Connection, except you are limited to the command-line environment
    of Windows PowerShell. This kind of remoting also uses a *fraction* of the resources
    that Remote Desktop requires, so it imposes much less overhead on your servers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 以两种不同的方式使用远程操作。第一种是一对一，或 1:1，远程操作。第二种是一对多，或 1:N，远程操作（您将在下一节中看到）。在一对一远程操作中，您正在访问单个远程计算机上的命令提示符。您运行的任何命令都将直接在该计算机上运行，您将在命令窗口中看到结果。这与使用
    SSH 或远程桌面连接有些类似，但您被限制在 Windows PowerShell 的命令行环境中。这种远程操作也只使用远程桌面所需资源的一小部分，因此对您的服务器造成的开销要小得多。
- en: 'Before we can connect to a remote computer, we need you to understand the difference
    between `-hostname` and `-computername` parameters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够连接到远程计算机之前，我们需要您了解 `-hostname` 和 `-computername` 参数之间的区别：
- en: '`-hostname`—Use this to use SSH.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-hostname`—使用此选项使用SSH。'
- en: '`-computername`—Use this to connect via WinRM.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-computername`—使用此选项通过WinRM进行连接。'
- en: 'PowerShell has no way of knowing what protocol you are trying to use, so you
    have to tell it. To establish a one-to-one connection with a remote computer,
    run the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 无法知道您正在尝试使用哪种协议，因此您必须告诉它。要建立与远程计算机的一对一连接，请运行以下命令：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you can use this syntax:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下语法：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: (You need to provide the correct computer name instead of `SRV2` or `Ubuntu1`.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: （您需要提供正确的计算机名，而不是 `SRV2` 或 `Ubuntu1`。）
- en: 'Assuming that you enabled remoting on your remote computer, and you’re all
    in the same domain, and your network is functioning correctly, you should get
    a connection established. PowerShell lets you know that you’ve succeeded by changing
    the shell prompt:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已在远程计算机上启用了远程操作，并且您都在同一个域中，并且您的网络运行正常，您应该能够建立连接。PowerShell 会通过更改命令提示符来通知您已成功连接：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The shell prompt tells you that everything you’re doing is taking place on `Ubunut1`
    (or whichever server you connected to). You can run whatever commands you like.
    You can even import modules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符会告诉您，您正在进行的所有操作都在`Ubunut1`（或您连接到的任何服务器）上。您可以运行您喜欢的任何命令。您甚至可以导入模块。
- en: Try it Now Try to create a remoting connection to your second computer or virtual
    machine. If you haven’t done so, you’ll also need to enable remoting on that computer
    before you try to connect to it. Note that you need to know the hostname or IP
    address.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试：尝试创建到您的第二台计算机或虚拟机的远程连接。如果您还没有这样做，您在尝试连接之前还需要在该计算机上启用远程操作。请注意，您需要知道主机名或
    IP 地址。
- en: Any command you run on the remote computer will run under the credentials you
    use to authenticate, so you’ll be able to do anything you’d normally have permission
    to do. It’s as if you logged into that computer’s console and used its copy of
    PowerShell directly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你在远程计算机上运行的任何命令都将使用你用于认证的凭据执行，所以你将能够做你通常有权限做的事情。这就像你登录到该计算机的控制台并直接使用其 PowerShell
    版本一样。
- en: Even if you have a PowerShell profile script on the remote computer, it won’t
    run when you connect using remoting. We haven’t fully covered profile scripts
    yet (they’re in chapter 26), but suffice it to say, they’re a batch of commands
    that run automatically each time you open the shell. Folks use them to automatically
    load shell extensions and modules and so forth. That doesn’t happen when you remote
    into a computer, so be aware of that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在远程计算机上有一个 PowerShell 配置文件脚本，当你使用远程连接时它也不会运行。我们还没有完全介绍配置文件脚本（它们在第 26 章中），但简单来说，它们是一组在每次打开外壳时自动运行的命令。人们使用它们来自动加载外壳扩展和模块等。当你远程连接到计算机时，这种情况不会发生，所以请注意这一点。
- en: Aside from this fairly minor caveat, you should be good to go. But wait—what
    do you do when you’re finished running commands on the remote computer? Many PowerShell
    cmdlets come in pairs, with one cmdlet doing something and the other doing the
    opposite. In this case, if `Enter-PSSession` gets you *into* the remote computer,
    can you guess what would get you *out* of the remote computer? If you guessed
    `Exit-PSSession`, give yourself a prize. The command doesn’t need any parameters;
    run it and your shell prompt will change back to normal, and the remote connection
    will close automatically.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个相当小的警告之外，你应该没问题。但是等等——当你完成在远程计算机上运行命令后，你该怎么办？许多 PowerShell 命令都是成对的，一个命令执行某个操作，另一个执行相反的操作。在这种情况下，如果
    `Enter-PSSession` 让你 *进入* 远程计算机，你能猜到什么会让你 *离开* 远程计算机吗？如果你猜对了 `Exit-PSSession`，给自己发个奖。该命令不需要任何参数；运行它，你的外壳提示符将恢复正常，远程连接将自动关闭。
- en: Try it Now Exit the remoting session, if you created one. We’re done with it
    for now.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：如果你创建了一个远程会话，请退出它。我们现在暂时完成了它。
- en: What if you forget to run `Exit-PSSession` and instead close the PowerShell
    window? Don’t worry. PowerShell is smart enough to figure out what you did, and
    the remote connection will close all by itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记运行 `Exit-PSSession` 而是关闭 PowerShell 窗口怎么办？别担心。PowerShell 足够智能，能够弄清楚你做了什么，远程连接会自动关闭。
- en: 'We do have one caution to offer: When you’re remoting into a computer, don’t
    run `Enter-PSSession` *from that computer* unless you fully understand what you’re
    doing. Let’s say you work on Computer A, which runs Ubuntu, and you remote into
    SRV2\. Then, at the PowerShell prompt, you run this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实有一个警告要提供：当你远程连接到计算机时，除非你完全理解你在做什么，否则不要从该计算机上运行 `Enter-PSSession`。假设你在运行
    Ubuntu 的计算机 A 上工作，并远程连接到 SRV2。然后，在 PowerShell 提示符下，你运行以下命令：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This causes Ubuntu1 to maintain an open connection to SRV2, which can start
    to create a *remoting chain* that’s hard to keep track of and that imposes unnecessary
    overhead on your servers. At times you may *have* to do this—we’re thinking mainly
    of instances where a computer such as SRV2 sits behind a firewall and you can’t
    access it directly, so you use SRV1 as a middleman to hop over to Server-DC4\.
    But, as a general rule, try to avoid remote chaining. The PowerShell team has
    a great article on making a second hop in PowerShell Remoting at [http://mng.bz/AxXe](http://mng.bz/AxXe).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致 Ubuntu1 维持与 SRV2 的开放连接，这可能会开始创建一个难以追踪的 *远程链*，并且会给你的服务器带来不必要的开销。有时你可能 *必须*这样做——我们主要考虑的是当
    SRV2 这样的计算机位于防火墙后面，你不能直接访问它时，你使用 SRV1 作为中间人跳转到 Server-DC4。但是，作为一般规则，尽量避免远程链。PowerShell
    团队有一篇关于在 PowerShell 远程中实现第二次跳转的优秀文章，请参阅 [http://mng.bz/AxXe](http://mng.bz/AxXe)。
- en: 'Caution Some people refer to remote chaining as *the second hop*, and it’s
    a major PowerShell gotcha. We offer a hint: If the PowerShell prompt is displaying
    a computer name, then you’re finished. You can’t issue any more remote control
    commands until you exit that session and “come back” to your computer.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：有些人将远程链称为 *第二次跳转*，这是 PowerShell 中的一个主要陷阱。我们提供一个提示：如果 PowerShell 提示符显示计算机名，那么你就完成了。在你退出该会话并“回来”到你的计算机之前，你无法发出任何更多的远程控制命令。
- en: When you’re using this one-to-one remoting, you don’t need to worry about objects
    being serialized and deserialized. As far as you’re concerned, you’re typing directly
    on the remote computer’s console. If you retrieve a process and pipe it to `Stop-Process`,
    it’ll stop running, as you’d expect it to.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这种一对一远程时，你不需要担心对象被序列化和反序列化。对你来说，你就像是在远程计算机的控制台上直接输入。如果你检索一个进程并将其管道传输到 `Stop-Process`，它将停止运行，就像你预期的那样。
- en: 13.6 Using Invoke-ScriptBlock for one-to-many remoting
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 使用 Invoke-ScriptBlock 进行一对多远程
- en: 'The next trick—and honestly, this is one of the coolest things in PowerShell—is
    to send a command to *multiple remote computers at the same time*. That’s right,
    full-scale distributed computing. Each computer will independently execute the
    command and send the results back to you. It’s all done with the `Invoke-ScriptBlock`
    cmdlet, and it’s called *one-to-many*, or 1:N, remoting. The command looks like
    this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技巧——坦白说，这是 PowerShell 中最酷的事情之一——是同时向 *多台远程计算机发送命令*。没错，这就是全规模的分布式计算。每台计算机将独立执行命令并将结果发送回您。这一切都是通过
    `Invoke-ScriptBlock` 命令来完成的，这被称为 *一对多*，或 1:N 远程。命令看起来是这样的：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try it Now Run this command. Substitute the name of your remote computer (or
    computers) and username where we put our three server names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。运行这个命令。用你的远程计算机（或计算机）的名称替换我们放置的三台服务器名称，以及用户名。
- en: Everything in those curly braces `{}` gets transmitted to the remote computers—all
    three of them. By default, PowerShell talks to up to 32 computers at once; if
    you specify more than that, it will queue them up, and as one computer completes,
    the next one in line will begin. If you have an awesome network and powerful computers,
    you could raise that number by specifying the `-throttleLimit` parameter of `Invoke-ScriptBlock`.
    Read the command’s help for more information.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那些花括号 `{}` 中的所有内容都会被传输到远程计算机——所有三台。默认情况下，PowerShell 一次最多与 32 台计算机通信；如果你指定了超过这个数量，它将排队等待，一旦一台计算机完成，下一台就会开始。如果你有一个很棒的网络和强大的计算机，你可以通过指定
    `Invoke-ScriptBlock` 的 `-throttleLimit` 参数来提高这个数字。更多信息请阅读命令的帮助。
- en: Be careful about the punctuation
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意标点符号
- en: We need to further consider the syntax for a one-to-many remoting example, because
    in this case PowerShell’s punctuation can get confusing. That confusion can make
    you do the wrong thing when you start constructing these command lines on your
    own.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进一步考虑一对多远程示例的语法，因为在这种情况下 PowerShell 的标点符号可能会让人困惑。这种困惑可能会让你在开始自己构建这些命令行时做错事情。
- en: 'Here’s an example to consider:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子供你考虑：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Two commands in this example use curly braces: `Invoke-ScriptBlock` and `Where-Object`.
    `Where-Object` is entirely nested within the outer set of braces. The outermost
    set of braces encloses everything that’s being sent to the remote computers for
    execution:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有两个命令使用了花括号：`Invoke-ScriptBlock` 和 `Where-Object`。`Where-Object` 完全嵌套在外层花括号中。最外层的一组花括号包含了要发送到远程计算机执行的所有内容：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Following that nesting of commands can be tough, particularly in a book like
    this one, where the physical width of the page makes it necessary to display the
    command across several lines of text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那些命令的嵌套可能会很困难，尤其是在像这本书这样的书中，物理页面宽度使得必须在多行文本中显示命令。
- en: Be sure you can identify the exact command that’s being sent to the remote computer
    and that you understand the use for each matched set of curly braces.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你能识别出发送到远程计算机的确切命令，并且理解每个匹配的花括号组的使用。
- en: If you carefully read the help for `Invoke-ScriptBlock` (see how we’re continuing
    to push those help files?), you’ll also notice a parameter that lets you specify
    a script file, rather than a command. That parameter lets you send an entire script
    from your local computer to the remote computers—meaning you can automate some
    complex tasks and have each computer do its own share of the work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读 `Invoke-ScriptBlock` 的帮助信息（看我们是如何继续推动这些帮助文件的？），你也会注意到一个参数，允许你指定一个脚本文件，而不是命令。这个参数允许你将整个脚本从你的本地计算机发送到远程计算机——这意味着你可以自动化一些复杂的任务，并让每台计算机完成它自己的部分工作。
- en: Try it Now Make sure you can identify the `-ScriptBlock` parameter in the help
    for `Invoke-ScriptBlock` and that you can spot the parameter that would enable
    you to specify a file path and name instead of a script block.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。确保你能识别出 `Invoke-ScriptBlock` 帮助中的 `-ScriptBlock` 参数，并且能找到允许你指定文件路径和名称而不是脚本块的参数。
- en: 'We want to circle back to the `-HostName` parameter we mentioned at the beginning
    of the chapter. When we first used `Invoke-ScriptBlock`, we typed a comma-separated
    list of hostnames, as we did in the previous example. But we work with a lot of
    computers, and we don’t want to have to type them all in every time. We keep text
    files for some of our common computer categories, such as web servers and domain
    controllers. Each text file contains one computer name per line, and that’s it—no
    commas, no quotes, no nothing. PowerShell makes it easy for us to use those files:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想回到本章开头提到的 `-HostName` 参数。当我们第一次使用 `Invoke-ScriptBlock` 时，我们输入了一个以逗号分隔的主机名列表，就像上一个例子中做的那样。但我们处理了很多计算机，我们不想每次都要输入它们。我们为一些常见的计算机类别（如
    Web 服务器和域控制器）保留文本文件。每个文本文件每行包含一个计算机名，仅此而已——没有逗号，没有引号，什么都没有。PowerShell 让我们很容易使用这些文件：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The parentheses here force PowerShell to execute `Get-Content` first—the same
    way parentheses work in math. The results of `Get-ScriptBlock` are then stuck
    into the `-HostName` parameter, which works against each of the computers listed
    in the file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的括号迫使 PowerShell 首先执行 `Get-Content`——就像数学中的括号一样工作。然后，`Get-ScriptBlock` 的结果被固定到
    `-HostName` 参数中，该参数针对文件中列出的每台计算机工作。
- en: 13.7 Differences between remote and local commands
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 远程命令与本地命令之间的差异
- en: 'We want to explain the differences between running commands by using `Invoke-ScriptBlock`
    and running those same commands locally, as well as the differences between remoting
    and other forms of remote connectivity. For this discussion, we’ll use this command
    as our example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过使用 `Invoke-ScriptBlock` 运行命令和本地运行相同命令之间的差异，以及远程连接与其他远程连接形式之间的差异来解释这些差异。为了这次讨论，我们将使用此命令作为我们的示例：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 13.7.1 Deserialized objects
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.7.1 反序列化对象
- en: Another caveat to keep in mind about remoting is that the objects that come
    back to your computer aren’t fully functional. In most cases, they lack methods,
    because they’re no longer “attached” to “live” software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于远程连接，还需要注意的一个注意事项是，返回到你的计算机上的对象并不完全可用。在大多数情况下，它们缺少方法，因为它们不再“附加”到“实时”软件上。
- en: 'For example, run this on your local computer, and you’ll notice that a `System
    .Diagnostics.Process` object has numerous methods associated with it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你的本地计算机上运行此命令，你会注意到一个 `System .Diagnostics.Process` 对象与它关联了许多方法：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now get some of those same objects via remoting:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过远程连接获取一些相同的对象：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The methods—except the universal `ToString``()` and `GetType()` methods common
    to all objects—are gone. This is a read-only copy of the object; you can’t tell
    it to do things like stop, pause, resume, and so forth. So any actions you want
    taken as the result of your command should be included in the script block that’s
    sent to the remote computer; that way, the objects are still live and contain
    all of their methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 方法——除了所有对象都通用的 `ToString()` 和 `GetType()` 方法之外——都不存在了。这是一个只读的对象副本；你不能让它执行停止、暂停、恢复等操作。因此，你想要命令执行的结果应该包含在发送到远程计算机的脚本块中；这样，对象仍然是活跃的，并且包含所有的方法。
- en: 13.7.2 Local vs. remote processing
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.7.2 本地与远程处理
- en: 'We’ll cite our original example again:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次引用我们的原始示例：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s what happens here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是这样的：
- en: The computers are contacted in parallel, meaning the command can complete somewhat
    more quickly.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机是并行接触的，这意味着命令可以更快地完成。
- en: Each computer queries the records and filters them *locally*. The only data
    transmitted across the network is the result of that filtering, meaning that only
    the records we care about are transmitted.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每台计算机都会查询记录并本地过滤它们 *locally*。网络中传输的唯一数据是过滤的结果，这意味着只有我们关心的记录会被传输。
- en: Before transmitting, each computer serializes its output into XML. Our computer
    receives that XML and deserializes it back into something that looks like objects.
    But they aren’t real event log objects, and that might limit what we can do with
    them once they’re on our computer.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传输之前，每台计算机将其输出序列化为 XML。我们的计算机接收那个 XML 并将其反序列化回类似对象的东西。但它们不是真实的事件日志对象，这可能会限制我们在计算机上对它们能做的事情。
- en: 'Now, compare it to this alternative:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，比较一下这个替代方案：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The differences are subtle. Well, we see only one difference: we moved one
    of those curly braces.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 差异是微妙的。嗯，我们只看到一处差异：我们移动了一个大括号。
- en: In the second version, only `Get-Process` is being invoked remotely. All of
    the results generated by `Get-Process` are serialized and sent to our computer,
    where they’re deserialized into objects and then piped to `Where` and filtered.
    The second version of the command is less efficient, because a lot of unnecessary
    data is being transmitted across the network, and our one computer has to filter
    the results from three computers, rather than those three computers filtering
    their own results for us. The second version, then, is a bad idea.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个版本中，只有 `Get-Process` 命令是在远程计算机上执行的。`Get-Process` 生成的所有结果都被序列化并发送到我们的计算机，在那里它们被反序列化为对象，然后通过管道传递给
    `Where` 并进行过滤。第二个版本的命令效率较低，因为大量的不必要数据被传输到网络上，而且我们的计算机需要过滤来自三台计算机的结果，而不是让这三台计算机为我们过滤它们自己的结果。因此，第二个版本不是一个好主意。
- en: 'Let’s look at two versions of another command, starting with the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个命令的两个版本，先从以下内容开始：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now let’s look at the second version:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第二个版本：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once again, the only difference between these two is the placement of a curly
    brace. But in this example, the first version of the command won’t work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这两个版本之间的唯一区别是花括号的位置。但在本例中，第一个版本的命令将无法正常工作。
- en: 'Look carefully: we’re sending `Get-Process` `-name` `pwsh` to the remote computer.
    The remote computer retrieves the specified process, serializes it into XML, and
    sends it to us across the network. Our computer receives that XML, deserializes
    it back into an object, and pipes it to `Stop-Process`. The problem is that the
    deserialized XML doesn’t contain enough information for our computer to realize
    that the process came from a *remote machine*. Instead, our computer will try
    to stop the `pwsh` process *running locally*, which isn’t what we want at all.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看：我们正在向远程计算机发送 `Get-Process` `-name` `pwsh` 命令。远程计算机检索指定的进程，将其序列化为 XML 格式，并通过网络发送给我们。我们的计算机接收那个
    XML，将其反序列化为对象，然后通过管道传递给 `Stop-Process`。问题是反序列化的 XML 没有包含足够的信息让我们的计算机意识到该进程来自一个
    *远程机器*。相反，我们的计算机将尝试停止本地运行的 `pwsh` 进程，而这根本不是我们想要的。
- en: 'The moral of the story is to always complete as much of your processing on
    the remote computer as possible. The only thing you should expect to do with the
    results of `Invoke-ScriptBlock` is to display them or store them as a report,
    or a data file, and so forth. The second version of our command follows that advice:
    what’s being sent to the remote computer is `Get-Process` `-name` `pwsh` `|` `Stop-Process`,
    so the entire command—both getting the process and stopping it—happens on the
    remote computer. Because `Stop-Process` doesn’t normally produce any output, there
    won’t be any objects to serialize and send to us, so we won’t see anything on
    our local console. But the command will do what we want: stop the `pwsh` process
    *on the remote computer*, not on our local machine.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事告诉我们，应该尽可能在远程计算机上完成你的处理工作。你唯一应该期望用 `Invoke-ScriptBlock` 的结果去做的事情是显示它们或将其存储为报告、数据文件等。我们的命令的第二个版本遵循了这一建议：发送到远程计算机的是
    `Get-Process` `-name` `pwsh` `|` `Stop-Process`，因此整个命令——获取进程和停止进程——都在远程计算机上执行。因为
    `Stop-Process` 通常不会产生任何输出，所以不会有对象被序列化并发送给我们，因此我们本地控制台将不会显示任何内容。但命令会完成我们想要的事情：在远程计算机上停止
    `pwsh` 进程，而不是在我们的本地机器上。
- en: Whenever we use `Invoke-ScriptBlock`, we always look at the commands after it.
    If we see commands for formatting, or for exporting data, we’re fine, because
    it’s okay to do those things with the results of `Invoke-ScriptBlock`. But if
    `Invoke-ScriptBlock` is followed by action cmdlets—ones that start, stop, set,
    change, or do something else—then we sit back and try to think about what we’re
    doing. Ideally, we want all of those actions to happen on the remote computer,
    not on our local computer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用 `Invoke-ScriptBlock` 时，我们都会查看其后的命令。如果我们看到用于格式化或导出数据的命令，我们就可以放心，因为用 `Invoke-ScriptBlock`
    的结果来做这些事情是可以的。但如果 `Invoke-ScriptBlock` 后面跟着的是执行命令——那些开始、停止、设置、更改或执行其他操作的命令——那么我们就退后一步，试图思考我们在做什么。理想情况下，我们希望所有这些操作都在远程计算机上执行，而不是在我们的本地计算机上。
- en: 13.8 But wait, there’s more
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.8 但是等等，还有更多
- en: The previous examples have all used ad hoc remoting connections, meaning that
    we specified hostnames. If you’re going to be reconnecting to the same computer
    (or computers) several times within a short period of time, you can create reusable,
    persistent connections to use instead. We cover that technique in chapter 18.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例都使用了临时的远程操作连接，这意味着我们指定了主机名。如果你打算在短时间内多次重新连接到同一台（或几台）计算机，你可以创建可重复使用、持久的连接来代替。我们在第18章中介绍了这种技术。
- en: We should also acknowledge that not every company is going to allow PowerShell
    remoting to be enabled—at least, not right away. Companies with extremely restrictive
    security policies may, for example, have firewalls on all client and server computers,
    which would block the remoting connection. If your company is one of those, see
    whether an exception is in place for SSH or WinRM. We find that’s a common exception,
    because administrators obviously need some remote connectivity to servers. If
    SSH or WinRM is allowed, then you can user PowerShell remoting over SSH.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该承认，并不是每家公司都会允许启用PowerShell远程操作——至少，不是立即允许。例如，具有极其严格的安全策略的公司可能在所有客户端和服务器计算机上都有防火墙，这将阻止远程操作连接。如果你的公司是这类公司之一，看看是否为SSH或WinRM设置了例外。我们发现这是一个常见的例外，因为管理员显然需要一些远程连接到服务器。如果允许SSH或WinRM，那么你可以使用SSH上的PowerShell远程操作。
- en: 13.9 Common points of confusion
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.9 常见混淆点
- en: 'Whenever beginners using remoting, some common problems crop up over the course
    of the day:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者使用远程操作，在一天的过程中可能会出现一些常见问题：
- en: Remoting is designed to be more or less automatically configured. If every computer
    involved is on the same domain, and your username is the same, things will typically
    work great. If not, you need to run `help about_remote_troubleshooting` and dig
    into the details.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程操作设计为基本可以自动配置。如果所有涉及的计算机都在同一个域中，并且你的用户名相同，通常一切都会运行得很好。如果不是这样，你需要运行 `help about_remote_troubleshooting`
    并深入了解细节。
- en: When you invoke a command, you’re asking the remote computer to launch PowerShell,
    run your command, and then close PowerShell. The next command you invoke on that
    same remote computer will be starting from scratch—anything that was run in the
    first invocation will no longer be in effect. If you need to run a whole series
    of related commands, put them all into the same invocation.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你调用一个命令时，你是在要求远程计算机启动PowerShell，运行你的命令，然后关闭PowerShell。你在同一远程计算机上调用的下一个命令将从头开始——第一次调用中运行的任何内容都将不再有效。如果你需要运行一系列相关的命令，请将它们全部放入同一个调用中。
- en: 13.10 Lab
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.10 实验室
- en: Note For this lab, you need a computer running PowerShell v7 or later. Ideally,
    you should have two computers on the same network with remoting enabled.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验室，你需要一台运行PowerShell v7或更高版本的计算机。理想情况下，你应该有两个在同一网络上的计算机，并且启用了远程操作。
- en: 'It’s time to combine some of what you’ve learned about remoting with what you’ve
    learned in previous chapters. See if you can accomplish the following tasks:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将你关于远程操作的知识与你之前章节中学到的知识结合起来。看看你是否能完成以下任务：
- en: Make a one-to-one connection with a remote computer (or with `localhost` if
    you have only one computer). Launch your favorite text editor. What happens?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与远程计算机（或如果你只有一台计算机，则与 `localhost`）建立一对一的连接。启动你喜欢的文本编辑器。会发生什么？
- en: 'Using `Invoke-ScriptBlock`, retrieve a list of processes currently running
    from one or two remote computers (it’s okay to use `localhost` twice if you have
    only one computer). Format the results as a wide list. (Hint: It’s okay to retrieve
    results and have the formatting occur on your computer—don’t include the `Format-`
    cmdlets in the commands that are invoked remotely.)'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Invoke-ScriptBlock` 从一台或两台远程计算机（如果你只有一台计算机，则可以使用 `localhost` 两次）检索当前正在运行的进程列表。将结果格式化为宽列表。（提示：检索结果并在你的计算机上进行格式化是可以的——不要在远程调用的命令中包含
    `Format-` cmdlet。）
- en: Use `Invoke-ScriptBlock` to get a list of the top 10 processes for virtual memory
    (VM) usage. Target one or two remote computers, if you can; if you have only one
    computer, target `localhost` twice.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Invoke-ScriptBlock` 获取虚拟内存（VM）使用量最高的前10个进程列表。如果可能的话，针对一台或两台远程计算机；如果你只有一台计算机，则针对
    `localhost` 两次。
- en: Create a text file that contains three computer names, with one name per line.
    It’s okay to use the same computer name, or `localhost`, three times if you have
    access to only one computer. Then use `Invoke-ScriptBlock` to retrieve the 10
    newest files from the home directory (`~`).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含三个计算机名称的文本文件，每行一个名称。如果你只有一台计算机，可以使用相同的计算机名称或 `localhost` 重复三次。然后使用 `Invoke-ScriptBlock`
    从主目录（`~`）检索最新的10个文件。
- en: 'Using `Invoke-ScriptBlock`, query one or more remote computers to display the
    property `PSVersion` from the `$PSVersionTable` variable. (Hint: This requires
    you to get the property of an item.)'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Invoke-ScriptBlock`，查询一个或多个远程计算机以显示 `$PSVersionTable` 变量中的属性 `PSVersion`。（提示：这需要你获取一个项目的属性。）
- en: 13.11 Lab answers
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.11 实验答案
- en: '`Enter-PSSession Server01`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Enter-PSSession Server01`'
- en: '`[Ubuntu1] /home/tylerl> nano`'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`[Ubuntu1] /home/tylerl> nano`'
- en: The nano process will launch, but there won’t be any interactive process either
    locally or remotely. In fact, run this way, the prompt won’t return until the
    nano process ends—although an alternative command to launch it is `Start-Process
    nano`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nano 进程将启动，但无论是本地还是远程都不会有任何交互式进程。实际上，以这种方式运行，提示符不会返回，直到 nano 进程结束——尽管启动它的替代命令是
    `Start-Process nano`。
- en: '`[SRV2] PS C:\Users\Administrator\Documents> Notepad`'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`[SRV2] PS C:\Users\Administrator\Documents> Notepad`'
- en: The Notepad process will launch, but there won’t be any interactive process
    either locally or remotely. In fact, run this way, the prompt won’t return until
    the Notepad process ends—although an alternative command to launch it is `Start-Process
    Notepad`.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记事本进程将启动，但无论是本地还是远程都不会有任何交互式进程。实际上，以这种方式运行，提示符不会返回，直到记事本进程结束——尽管启动它的替代命令是 `Start-Process
    Notepad`。
- en: '`Invoke-ScriptBlock –scriptblock {Get-Process } -HostName`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-ScriptBlock –scriptblock {Get-Process } -HostName`'
- en: '`➥ Server01,Server02 -UserName yourUser | Format-Wide -Column 4`'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ Server01,Server02 -UserName yourUser | Format-Wide -Column 4`'
- en: '`Invoke-ScriptBlock -scriptblock {get-process | sort VM -Descending |`'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-ScriptBlock -scriptblock {get-process | sort VM -Descending |`'
- en: '`➥ Select-first 10} –HostName Server01,Server02 -UserN`'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ Select-first 10} –HostName Server01,Server02 -UserN`'
- en: '`Invoke-ScriptBlock -scriptblock { Get-ChildItem ~/* | Sort-Object`'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-ScriptBlock -scriptblock { Get-ChildItem ~/* | Sort-Object`'
- en: '`➥ -Property LastWriteTime -Descending | Select-Object -First 10}`'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ -Property LastWriteTime -Descending | Select-Object -First 10}`'
- en: '`➥ -HostName (Get-Content computers.txt) -UserName yourUser`'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ -HostName (Get-Content computers.txt) -UserName yourUser`'
- en: '`Invoke-ScriptBlock –scriptblock $ -Server01,Server02 -UserName yourUser`'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-ScriptBlock –scriptblock $ -Server01,Server02 -UserName yourUser`'
- en: 13.12 Further exploration
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.12 进一步探索
- en: We could cover a lot more about remoting in PowerShell—enough that you’d be
    reading about it for *another* month of lunches. Unfortunately, some of its trickier
    bits aren’t well documented. We suggest heading up to PowerShell.org, and more
    specifically to their e-book resources, where Don and fellow MVP Dr. Tobias Weltner
    have put together a comprehensive (and free!) *Secrets of PowerShell Remoting*
    mini e-book for you (see [https://leanpub.com/secretsofpowershellremoting](https://leanpub.com/secretsofpowershellremoting)).
    The guide rehashes some of the basics you learned in this chapter, but it primarily
    focuses on detailed, step-by-step directions (with color screenshots) that show
    how to configure a variety of remoting scenarios. The guide also digs into some
    of the grittier details of the protocol and troubleshooting, and even has a short
    section on how to talk to information security people about remoting. The guide
    is updated periodically, so check back every few months to make sure you have
    the latest edition.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以关于 PowerShell 的远程处理讲很多——足够让你在午餐时间读上一个月。不幸的是，其中一些比较复杂的部分并没有很好地记录。我们建议访问 PowerShell.org，特别是他们的电子书资源，在那里
    Don 和 MVP 同事 Dr. Tobias Weltner 为你准备了一本全面（且免费！）的 *PowerShell 远程处理秘密* 短小电子书（见 [https://leanpub.com/secretsofpowershellremoting](https://leanpub.com/secretsofpowershellremoting)）。指南重新梳理了你在本章中学到的一些基础知识，但它主要关注详细的、分步的说明（带有彩色截图），展示了如何配置各种远程处理场景。指南还深入探讨了协议和故障排除的一些更粗糙的细节，甚至还有一个简短的关于如何与信息安全人员讨论远程处理的章节。指南会定期更新，所以每隔几个月检查一下，确保你有最新的版本。
