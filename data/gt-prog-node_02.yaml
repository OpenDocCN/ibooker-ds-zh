- en: Unit 2\. Easier web development with Express.js
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元2\. 使用 Express.js 更容易地进行网络开发
- en: '[Unit 1](../Text/kindle_split_014.html#part01) taught you how web servers work
    with Node.js and how to build meaningful content with built-in modules. This unit
    is about taking your application to a more robust and professional level by using
    a web framework and dynamic content. A *web framework* is a predefined application
    structure and a library of development tools designed to make building a web application
    easier and more consistent.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[单元1](../Text/kindle_split_014.html#part01) 教导了你如何使用 Node.js 构建网络服务器以及如何使用内置模块构建有意义的内
    容。本单元是关于通过使用网络框架和动态内容将你的应用程序提升到一个更稳健和专业的水 平。*网络框架* 是一个预定义的应用程序结构和一组开发工具库，旨在使构建网络应用程序更加容易和一致。'
- en: 'In this unit, you learn how to set up an application with Express.js and organize
    your application file structure to optimize communication of data among your pages.
    You’re also introduced to the model-view-controller (MVC) application architecture,
    which organizes your code into three distinct responsibilities:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本单元中，你将学习如何使用 Express.js 设置应用程序并组织你的应用程序文件结构以优化页面之间数据通信。你还将了解模型-视图-控制器（MVC）应用程序架构，它将你的代码组织成三个不同的职责：
- en: Giving structure to your data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的数据构建结构
- en: Displaying that data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示该数据
- en: Handling requests to interact with that data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理请求以与该数据交互
- en: 'With the goals of building on the lessons you learned in [unit 1](../Text/kindle_split_014.html#part01)
    and modifying your code to take full advantage of Express.js, this unit covers
    the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 [单元1](../Text/kindle_split_014.html#part01) 中学习到的课程基础上进行构建，并修改你的代码以充分利用
    Express.js，本单元涵盖了以下主题：
- en: '[Lesson 8](../Text/kindle_split_021.html#ch08) introduces Express.js and shows
    how to configure a new Node.js application. In this lesson, you get an overview
    of how a web framework helps you develop an application.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8课](../Text/kindle_split_021.html#ch08) 介绍了 Express.js 并展示了如何配置新的 Node.js
    应用程序。在本课中，你将了解一个网络框架如何帮助你开发应用程序的概述。'
- en: '[Lesson 9](../Text/kindle_split_022.html#ch09) covers routing with Express.js.
    You’ve already learned about writing routes from scratch. This lesson introduces
    you to the style of routing you’ll use throughout the rest of the book. You also
    learn about MVC and see how routes can behave like controllers in that structure.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9课](../Text/kindle_split_022.html#ch09) 讲解了使用 Express.js 进行路由。你已经学习了从头开始编写路由的方法。本课将向你介绍本书其余部分将使用的路由风格。你还将了解
    MVC 模式，并了解在这种结构中路由如何像控制器一样行为。'
- en: '[Lesson 10](../Text/kindle_split_023.html#ch10) introduces the concepts of
    layouts and dynamically rendered views. So far, you’ve worked only with static
    content, but in this lesson, you use Express.js to feed content to your views
    on every page reload. This lesson also discusses templating in Node.js. In Express.js,
    templating engines are at work to allow you to write placeholders for dynamic
    content into your HTML pages.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第10课](../Text/kindle_split_023.html#ch10) 介绍了布局和动态渲染视图的概念。到目前为止，你只处理了静态内容，但在本课中，你使用
    Express.js 在每次页面刷新时向你的视图提供内容。本课还讨论了 Node.js 中的模板化。在 Express.js 中，模板引擎正在工作，允许你在
    HTML 页面中写入动态内容的占位符。'
- en: '[Lesson 11](../Text/kindle_split_024.html#ch11) builds on the preceding lessons
    to show how to handle application errors and configure a start-up script with
    npm.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11课](../Text/kindle_split_024.html#ch11) 在前面的课程基础上，展示了如何处理应用程序错误并使用 npm 配置启动脚本。'
- en: Finally, [lesson 12](../Text/kindle_split_025.html#ch12) shows how to rebuild
    your project from [unit 1](../Text/kindle_split_014.html#part01) by using Express.js.
    You re-create the three front-facing views for the cooking school’s website and
    add functionality to dynamically fill content from your application server.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，[第12课](../Text/kindle_split_025.html#ch12) 展示了如何使用 Express.js 从 [单元1](../Text/kindle_split_014.html#part01)
    重建你的项目。你重新创建了烹饪学校的网站的前端三个视图，并添加了从你的应用程序服务器动态填充内容的功能。
- en: This unit is your first step into web applications that may feel more familiar.
    Getting comfortable with Express.js and external packages will make you a more
    skilled developer. When your Node.js application is running successfully on Express.js,
    [unit 3](../Text/kindle_split_026.html#part03) talks about how to connect your
    app to a database and save user information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本单元是你进入可能感觉更熟悉的网络应用程序的第一步。熟悉 Express.js 和外部包将使你成为一个更熟练的开发者。当你的 Node.js 应用程序在
    Express.js 上成功运行时，[单元3](../Text/kindle_split_026.html#part03) 将讨论如何将你的应用程序连接到数据库并保存用户信息。
- en: Lesson 8\. Setting up an app with Express.js
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8课\. 使用 Express.js 设置应用程序
- en: Building a web application has become a simpler task with the addition of web
    frameworks. A web framework in Node.js is a module that offers structure to your
    application. Through this structure, you can easily build and customize the way
    your application feels without worrying about building certain features from scratch,
    such as serving individual files. By the end of this lesson, you’ll know where
    to begin with web frameworks and how the one used in this book, Express.js, can
    reduce the time it takes you to get your application running.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web框架的加入，构建Web应用程序已经变得更容易。Node.js中的Web框架是一个模块，为你的应用程序提供结构。通过这个结构，你可以轻松地构建和自定义应用程序的感觉，而无需担心从头开始构建某些功能，例如服务单个文件。在本课结束时，你将了解如何开始使用Web框架，以及本书中使用的Express.js如何减少你使应用程序运行所需的时间。
- en: This lesson covers
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Setting up a Node.js application with Express.js
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express.js设置Node.js应用程序
- en: Navigating a web framework
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航Web框架
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Your static web app from [unit 1](../Text/kindle_split_014.html#part01) is a
    success. The cooking community wants you to add more functionality and serve more
    web pages. You realize that your application isn’t fully prepared to handle more
    routes, let alone handling errors or serving other types of assets. Could there
    be an easier way to start development with some structure already in place?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你从[单元1](../Text/kindle_split_014.html#part01)中的静态Web应用程序已经成功了。烹饪社区希望你添加更多功能并服务更多网页。你意识到你的应用程序还没有完全准备好处理更多的路由，更不用说处理错误或服务其他类型的资源了。有没有一种更简单的方法可以从已有结构开始开发？
- en: Luckily, you can install a web framework with your Node.js application. Express.js,
    the framework you use in this book, handles a lot of the tasks most applications
    need right out of the box, such as error handling and static-asset serving. The
    more familiar you get with this framework’s methods and keywords, the faster you
    can build your applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用Node.js应用程序安装一个Web框架。Express.js，这本书中使用的框架，直接处理了大多数应用程序需要的许多任务，例如错误处理和静态资源服务。你对这个框架的方法和关键字越熟悉，你构建应用程序的速度就越快。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)8.1\. Installing the Express.js package'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)8.1\. 安装Express.js包'
- en: Express.js increases development speed and provides a stable structure on which
    to build applications. Like Node.js, Express.js offers tools that are open-source
    and managed by a large online community.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js提高了开发速度，并为构建应用程序提供了一个稳定的结构。像Node.js一样，Express.js提供了开源的工具，并由一个庞大的在线社区管理。
- en: First, I’ll talk about why Express.js is the web framework you should learn.
    With each passing year, Node.js gains new frameworks, some of which provide convincing
    reasons to switch to its library. Express.js came out in 2010, and since then,
    other reliable frameworks have grown in popularity. [Table 8.1](#ch08table01)
    lays out some other frameworks you can look into.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将讨论为什么Express.js是你应该学习的Web框架。随着每年过去，Node.js获得了新的框架，其中一些提供了令人信服的理由去切换到它的库。Express.js于2010年发布，从那时起，其他可靠的框架也日益流行。[表8.1](#ch08table01)列出了你可以考虑的其他框架。
- en: Table 8.1\. Node.js frameworks to know
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.1\. 你应该了解的Node.js框架
- en: '| Node.js frameworks | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Node.js框架 | 描述 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Koa.js | Designed by developers who built Express.js with a focus on a library
    of methods not offered in Express.js ([http://koajs.com/](http://koajs.com/))
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Koa.js | 由构建Express.js的开发者设计，专注于Express.js中未提供的库方法([http://koajs.com/](http://koajs.com/))
    |'
- en: '| Hapi.js | Designed with a similar architecture to Express.js and a focus
    on writing less code ([https://hapijs.com/](https://hapijs.com/)) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Hapi.js | 设计与Express.js具有相似架构，并专注于编写更少的代码([https://hapijs.com/](https://hapijs.com/))
    |'
- en: '| Sails.js | Built on top of Express.js, offering more structure, as well as
    a larger library and less opportunity for customization ([https://sailsjs.com/](https://sailsjs.com/))
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Sails.js | 建立在Express.js之上，提供了更多的结构，以及更大的库和更少的定制机会([https://sailsjs.com/](https://sailsjs.com/))
    |'
- en: '| Total.js | Built on the core HTTP module and acclaimed for its high-performance
    request handling and responses ([https://www.totaljs.com/](https://www.totaljs.com/))
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Total.js | 建立在核心HTTP模块之上，因其高性能的请求处理和响应而受到赞誉([https://www.totaljs.com/](https://www.totaljs.com/))
    |'
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about Node.js web frameworks, you can view an updated list
    of GitHub repositories at [http://nodeframework.com/](http://nodeframework.com/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Node.js Web框架的更多信息，你可以查看GitHub仓库的更新列表，网址为[http://nodeframework.com/](http://nodeframework.com/)。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Ultimately, a framework is intended to help you overcome some common development
    challenges in building a web application from scratch. Express.js is the most
    used framework in the Node.js community, ensuring that you find the support you
    need compared with the support offered by other, newer frameworks. Although I
    recommend using Total.js for its performance and scalability ratings, it’s not
    necessarily the best framework to start with.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，框架旨在帮助您克服从头开始构建 web 应用程序时的一些常见开发挑战。Express.js 是 Node.js 社区中最常用的框架，确保您与其他较新框架提供的支持相比，能够找到所需的支持。尽管我推荐使用
    Total.js，因为它在性能和可扩展性方面表现良好，但它不一定是最适合开始的框架。
- en: Because you’re working with Node.js to build a web application for the first
    time, you need some tools to help you along the way. A web framework is designed
    to offer some of the common tools used in web development. Express.js provides
    methods and modules to assist with handling requests, serving static and dynamic
    content, connecting databases, and keeping track of user activity, for example.
    You find out more about how Express.js provides this support in later lessons.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您是第一次使用 Node.js 来构建 web 应用程序，您需要一些工具来帮助您在这个过程中。Web 框架旨在提供一些在 web 开发中常用的工具。Express.js
    提供了处理请求、提供静态和动态内容、连接数据库以及跟踪用户活动等方法和模块。您将在后面的课程中了解更多关于 Express.js 如何提供这种支持的信息。
- en: Express.js is used by new and professional Node.js developers alike, so if you
    feel overwhelmed at any time, know that thousands of others can help you overcome
    your development obstacles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 被新的和专业的 Node.js 开发者共同使用，所以如果您在任何时候感到不知所措，请记住，有成千上万的人可以帮助您克服开发障碍。
- en: Now you’re ready to jump into initializing an application with Express.js. To
    begin, you need to initialize your application by creating a new project directory
    called first_express_project, entering that directory within a new terminal window,
    and entering `npm init`. You can follow the prompt to save main.js as the entry
    point and to save all the other default values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好使用 Express.js 初始化应用程序了。首先，您需要通过创建一个名为 first_express_project 的新项目目录，在新的终端窗口中进入该目录，并输入
    `npm init` 来初始化您的应用程序。您可以按照提示将 main.js 保存为主入口点，并保存所有其他默认值。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As discussed in [lesson 1](../Text/kindle_split_012.html#ch01), initializing
    a new project creates a package.json file with which you can define some attributes
    of your application, including the packages you download and depend on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [课程 1](../Text/kindle_split_012.html#ch01) 中所述，初始化新项目会创建一个 package.json 文件，您可以使用它来定义应用程序的一些属性，包括您下载和依赖的包。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Because Express.js is an external package, it doesn’t come preinstalled with
    Node.js. You need to download and install it by running the following command
    within your project directory in terminal: `npm install express --save`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Express.js 是一个外部包，它不会与 Node.js 预先安装。您需要在终端中运行以下命令来下载和安装它：`npm install express
    --save`。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At this writing, the latest version of Express.js is 4.16.3\. To ensure that
    your version of Express.js is consistent with the one used in this book, install
    the package by running `npm install express@4.16.3 --save`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Express.js 的最新版本是 4.16.3。为确保您的 Express.js 版本与本书中使用的版本一致，请运行 `npm install
    express@4.16.3 --save` 来安装该包。
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you try to install Express.js in a specific project before you create package.json,
    you may see an error complaining that there’s no directory or file with which
    the installation can complete.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建 package.json 之前尝试在特定项目中安装 Express.js，您可能会看到一个错误，抱怨没有目录或文件可以完成安装。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Use the `--save` flag so that Express.js is listed as an application dependency.
    In other words, your application depends on Express.js to work, so you need to
    ensure that it’s installed. Open package.json to see this Express.js package installation
    under the `dependencies` listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--save` 标志，以便将 Express.js 列为应用程序依赖项。换句话说，您的应用程序依赖于 Express.js 来工作，因此您需要确保它已安装。打开
    package.json 来查看此 Express.js 包安装位于 `dependencies` 列表中。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to access the Express.js package documentation from your terminal
    window, type `npm docs express`. This command opens your default web browser to
    [http://expressjs.com](http://expressjs.com).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从终端窗口访问 Express.js 包的文档，请输入 `npm docs express`。此命令将打开您的默认网页浏览器，访问 [http://expressjs.com](http://expressjs.com)。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next section, you create your first Express.js application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将创建您的第一个 Express.js 应用程序。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 8.1**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 8.1**'
- en: '**[Q1:](#ch08qa2q0a1)**'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch08qa2q0a1)**'
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you don’t use the `--save` flag when installing Express.js for
    your application?
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你在为你的应用程序安装Express.js时没有使用`--save`标志，会发生什么？
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 8.1 answer**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 8.1 答案**'
- en: '**[1:](#ch08qa1q1)**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch08qa1q1)**'
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Without the `--save` flag, your Express.js installation won’t be marked as an
    application dependency. Your application will still run locally, because Express.js
    will be downloaded to your project’s node_modules folder, but if you upload your
    application code without that folder, there’s no indication in your package.json
    file that the Express.js package is needed to run your application.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有使用`--save`标志，你的Express.js安装不会被标记为应用程序依赖项。你的应用程序仍然可以在本地运行，因为Express.js将被下载到你的项目`node_modules`文件夹中，但如果你不包含该文件夹上传你的应用程序代码，你的`package.json`文件中不会有任何指示表明需要Express.js包来运行你的应用程序。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)8.2\. Building your first Express.js application'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)8.2\. 构建你的第一个Express.js应用程序'
- en: To start using Express.js, you need to create a main application file and require
    the `express` module. Save the code in [listing 8.1](#ch08ex01) to a file called
    main.js within your project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Express.js，你需要创建一个主应用程序文件并引入`express`模块。将代码保存在[列表8.1](#ch08ex01)中，并将其保存为项目中的`main.js`文件。
- en: You require Express.js by referring to the module name `express` and storing
    it as a constant. `express` offers a library of methods and functionality, including
    a class with built-in web server functionality. The `express` webserver application
    is instantiated and stored in a constant to be referred to as `app`. Throughout
    the rest of the project, you’ll use `app` to access most of Express.js’ resources.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过引用模块名`express`并将其存储为一个常量来引入Express.js。`express`提供了一个方法库和功能，包括一个具有内置网络服务器功能的一个类。`express`网络服务器应用程序被实例化并存储在一个常量中，以便引用为`app`。在整个项目的其余部分，你将使用`app`来访问Express.js的大部分资源。
- en: As in the first capstone project, Express.js offers a way to define a `GET`
    route and its callback function without building out an extra module. If a request
    is made to the home page, Express.js catches it and allows you to respond.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个项目一样，Express.js提供了一种定义`GET`路由及其回调函数的方法，而无需构建额外的模块。如果对主页发起请求，Express.js会捕获它并允许你进行响应。
- en: A response in plain text is sent to the browser. Notice the Express.js method
    `send`, which behaves similarly to `write` from the `http` module. Express.js
    also supports `http` module methods. Remember to use `end` to complete your response
    if you use `write`. Finally, you set up the application to listen for requests
    on port 3000 of your local host and ask for a helpful message to be logged to
    your console when the application is running successfully.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以纯文本形式发送响应到浏览器。注意Express.js的`send`方法，它与`http`模块中的`write`方法行为类似。Express.js还支持`http`模块的方法。如果你使用`write`，请记住使用`end`来完成你的响应。最后，你设置应用程序监听本地主机的3000端口上的请求，并在应用程序成功运行时将一条有用的消息记录到你的控制台。
- en: Listing 8.1\. Simple Express.js web application in main.js
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. main.js中的简单Express.js网络应用程序
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Add the express module to your application.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将express模块添加到你的应用程序中。**'
- en: '***2*** **Assign the express application to the app constant.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将express应用程序分配给app常量。**'
- en: '***3*** **Set up a GET route for the home page.**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **为主页设置一个GET路由。**'
- en: '***4*** **Issue a response from the server to the client with res.send.**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用res.send从服务器向客户端发送响应。**'
- en: '***5*** **Set up the application to listen at port 3000.**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **设置应用程序以监听3000端口。**'
- en: Give it a shot. Make sure that you’re in your project directory on your command
    line. Run `node main`, and go to http://localhost:3000\. If you see `Hello, Universe!`
    on the screen, you’ve built your first successful Express.js application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。确保你在命令行中处于你的项目目录。运行`node main`，然后访问http://localhost:3000。如果你在屏幕上看到`Hello,
    Universe!`，那么你已经构建了第一个成功的Express.js应用程序。
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Installing and using nodemon**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装和使用nodemon**'
- en: To see your application server code changes in effect, you need to restart the
    server in terminal. Close your existing server by pressing Command-D (Ctrl-C for
    Windows) and entering `node main.js` again.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的应用程序服务器代码更改的效果，你需要在终端中重新启动服务器。通过按Command-D（Windows上的Ctrl-C）关闭现有服务器，然后再次输入`node
    main.js`。
- en: The more changes you apply to your application, the more tedious this task becomes.
    That’s why I recommend installing the `nodemon` package. You can use this package
    to start your application the first time and automatically restart it when application
    files change.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你对应用程序应用的变化越多，这项任务就越繁琐。这就是我推荐安装 `nodemon` 包的原因。你可以使用这个包来首次启动你的应用程序，并在应用程序文件更改时自动重新启动它。
- en: To install `nodemon` globally, enter `npm i nodemon -g`. You may need to prepend
    that command with `sudo` or run it in terminal as an administrator.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局安装 `nodemon`，请输入 `npm i nodemon -g`。你可能需要在命令前加上 `sudo` 或以管理员身份在终端中运行它。
- en: Alternatively, you can install `nodemon` as a development dependency (`devDependency`)
    or a resource that you use only during development of an application. Run `npm
    i nodemon -- save-dev` or `npm i nodemon -D. nodemon` starts with your `npm start`
    script (discussed in [lesson 11](../Text/kindle_split_024.html#ch11)). The benefit
    of installing as a `devDependency` is that each project has its own `nodemon`
    modules, reflecting the most up-to-date version of the package at the time of
    development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将 `nodemon` 安装为开发依赖项（`devDependency`）或仅在应用程序开发期间使用的资源。运行 `npm i nodemon
    --save-dev` 或 `npm i nodemon -D`。`nodemon` 会与你的 `npm start` 脚本（在 [第 11 课](../Text/kindle_split_024.html#ch11)
    中讨论）一起启动。将 `nodemon` 作为 `devDependency` 安装的好处是，每个项目都有自己的 `nodemon` 模块，反映了开发时包的最新版本。
- en: 'When `nodemon` is installed, it’s simple to use: nodemon picks up on the main
    property in your package.json. Your package.json should also be modified to include
    the npm start script. Add "start": "nodemon main.js", to the scripts section in
    package.json so that you may run your application using nodemon with npm start.
    Go to your project directory in terminal, and enter `nodemon`. This command launches
    your application, and any future changes you make signal `nodemon` to restart
    without your needing to enter another command.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '当安装了 `nodemon` 后，使用起来很简单：`nodemon` 会检测你的 package.json 中的主属性。你的 package.json
    也应该修改为包含 npm start 脚本。在 package.json 的 scripts 部分添加 "start": "nodemon main.js"，这样你就可以使用
    npm start 通过 `nodemon` 运行你的应用程序。在终端中进入你的项目目录，并输入 `nodemon`。这个命令会启动你的应用程序，并且你未来所做的任何更改都会通知
    `nodemon` 重新启动，而无需输入另一个命令。'
- en: You can shut down the server by pressing the same key combination (Command-D
    or Ctrl-C for Windows) in the `nodemon` window in terminal.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在终端中的 `nodemon` 窗口中按下相同的键组合（Windows 上的 Command-D 或 Ctrl-C）来关闭服务器。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `express` constant is still used for some Express.js tools related to configuring
    your application. `app` is used mainly for anything created for the application’s
    movement of data and user interaction.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`express` 常量仍然用于一些与配置应用程序相关的 Express.js 工具。`app` 主要用于创建用于应用程序数据传输和用户交互的任何内容。'
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, I talk about some of the ways that Express.js offers support
    as a web framework.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将讨论 Express.js 作为网络框架提供的一些支持方式。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 8.2**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 8.2**'
- en: '**[Q1:](#ch08qa4q0a1)**'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch08qa4q0a1)**'
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between the `express` and app constants?
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`express` 和 `app` 常量之间的区别是什么？'
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 8.2 answer**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 8.2 答案**'
- en: '**[1:](#ch08qa3q1)**'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch08qa3q1)**'
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`app` represents most of your application, the routes, and access to other
    modules. `express` represents a wider range of methods that aren’t necessarily
    scoped to your application. `express` could offer a method to analyze or parse
    some text on which your application doesn’t necessarily depend.'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`app` 代表了你的应用程序的大部分内容，包括路由和其他模块的访问。`express` 代表了一组更广泛的方法，这些方法不一定局限于你的应用程序。`express`
    可能会提供一种方法来分析或解析某些文本，而你的应用程序可能并不依赖于这些文本。'
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)8.3\. Working your way around a web framework'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)8.3\. 在网络框架中工作'
- en: A web framework is designed to do a lot of the tedious tasks for you and leave
    you with an intuitive structure for customizing your app. Express.js provides
    a way to listen for requests to specific URLs and respond by using a callback
    function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络框架旨在为你完成许多繁琐的任务，并为你提供一个直观的结构来定制你的应用程序。Express.js 提供了一种通过回调函数监听特定 URL 的请求并响应的方法。
- en: A web framework like Express.js operates through functions considered to be
    middleware because they sit between HTTP interaction on the web and the Node.js
    platform. *Middleware* is a general term applied to code that assists in listening
    for, analyzing, filtering, and handling HTTP communication before data interacts
    with application logic.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Express.js 这样的网络框架通过函数作为中间件来操作，因为这些函数位于 Web 上的 HTTP 交互和 Node.js 平台之间。*中间件*是一个通用术语，用于指代在数据与应用逻辑交互之前，帮助监听、分析、过滤和处理
    HTTP 通信的代码。
- en: You can think of middleware as being like a post office. Before your package
    can go into the delivery network, a postal worker needs to inspect the size of
    your box and to ensure that it’s properly paid for and adheres to delivery policies
    (nothing dangerous in your package). See the diagram on middleware in [figure
    8.1](#ch08fig01).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将中间件想象成一个邮局。在您的包裹进入配送网络之前，邮递员需要检查包裹的大小，并确保它已正确付费并符合配送政策（包裹内没有危险物品）。请参阅中间件的图示[图
    8.1](#ch08fig01)。
- en: Figure 8.1\. Express.js stands between the HTTP requests and your application
    code.
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. Express.js 位于 HTTP 请求和您的应用程序代码之间。
- en: '![](../Images/08fig01_alt.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig01_alt.jpg)'
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Middleware can come in smaller packages than Express.js. Some play a security
    role in checking incoming requests before data passes through to the core application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以比 Express.js 更小，一些中间件在数据传递到核心应用之前，扮演着检查传入请求的安全角色。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Because you’re still dealing with HTTP methods, the overall interaction between
    your application and the browser doesn’t change much from your application that
    uses the `http` module in [unit 1](../Text/kindle_split_014.html#part01). You
    get the same request and response objects, containing a lot of rich information
    about the sender and its contents. Express.js offers methods that make it easier
    for you to get that information.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您仍在处理 HTTP 方法，所以您的应用程序与浏览器之间的整体交互与第 1 单元（../Text/kindle_split_014.html#part01）中使用
    `http` 模块的应用程序相比变化不大。您获得相同的请求和响应对象，其中包含有关发送者和其内容的丰富信息。Express.js 提供了使您更容易获取这些信息的方法。
- en: In addition to the `send` method on the response object, Express.js provides
    simpler ways to pull and log data from the request body. Add the code in the next
    listing to your `GET` route handler in main.js.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了响应对象上的 `send` 方法外，Express.js 还提供了从请求体中提取和记录数据的更简单方法。将以下代码添加到 main.js 中的 `GET`
    路由处理程序中。
- en: Listing 8.2\. Request object methods in Express.js in main.js
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. main.js 中的 Express.js 请求对象方法
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Access request parameters.**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **访问请求参数。**'
- en: From the request, you can pull the values in [table 8.2](#ch08table02).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从请求中提取[表 8.2](#ch08table02)中的值。
- en: Table 8.2\. Request object data items
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.2\. 请求对象数据项
- en: '| Request data object | Description |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 请求数据对象 | 描述 |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| params | Allows you to extract IDs and tokens from the URL. When you learn
    about RESTful routes in [unit 4](../Text/kindle_split_031.html#part04), this request
    attribute allows you to identify which items are being requested in an e-commerce
    site or what user profile you should navigate to. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| params | 允许您从 URL 中提取 ID 和令牌。当您学习到第 4 单元中的 RESTful 路由时，这个请求属性允许您识别在电子商务网站上请求的是哪些项目，或者您应该导航到哪个用户配置文件。
    |'
- en: '| body | Contains much of the contents of the request, which often includes
    data coming from a POST request, such as a submitted form. From the request body,
    you can collect information quickly and save it in a database. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| body | 包含请求的大部分内容，通常包括来自 POST 请求的数据，如提交的表单。您可以从请求体中快速收集信息并将其保存到数据库中。 |'
- en: '| url | Provides information about the URL being visited (similar to req.url
    in [unit 1](../Text/kindle_split_014.html#part01)’s basic web server). |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| url | 提供有关访问的 URL 的信息（类似于第 1 单元（../Text/kindle_split_014.html#part01）的基本
    Web 服务器中的 req.url）。 |'
- en: '| query | Like body, lets you pull data being submitted to the application
    server. This data isn’t necessarily from a POST request, however, and is often
    requested in the URL as a query string. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 查询 | 与 body 类似，允许您从提交到应用服务器的数据中提取信息。然而，这些数据不一定来自 POST 请求，通常作为查询字符串在 URL 中请求。
    |'
- en: Upon restarting your application and visiting http://localhost:3000, you see
    these values logged to your server’s terminal window. You explore how to make
    better use of the request body when you learn about Express.js routes in [lesson
    9](../Text/kindle_split_022.html#ch09).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启您的应用程序并访问 http://localhost:3000 后，您会在服务器的终端窗口中看到这些值被记录下来。当您在学习 [第9课](../Text/kindle_split_022.html#ch09)
    中关于 Express.js 路由时，您会探索如何更好地利用请求体。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: '*A query string* is text represented as key/value pairs in the URL following
    a question mark (`?)` after the hostname. http://localhost:3000?name=jon, for
    example, is sending the `name` (key) paired with `jon` (value). This data can
    be extracted and used in the route handler.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询字符串* 是以键/值对形式表示的文本，位于主机名后的问号 (`?`) 之后。例如，http://localhost:3000?name=jon
    正在发送 `name`（键）与 `jon`（值）配对的 数据。这些数据可以在路由处理程序中提取和使用。'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 8.3**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查8.3**'
- en: '**[Q1:](#ch08qa6q0a1)**'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch08qa6q0a1)**'
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do most developers use web frameworks instead of building web applications
    from scratch?
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么大多数开发者使用网络框架而不是从头开始构建网络应用程序？
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 8.3 answer**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 8.3 答案**'
- en: '**[1:](#ch08qa5q1)**'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch08qa5q1)**'
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Web frameworks make development work a lot easier. Web development is fun, and
    the best parts aren’t the tedious tasks that are most subject to errors. With
    web frameworks, developers and businesses alike can focus on the more interesting
    parts of applications.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络框架使开发工作变得容易得多。网络开发很有趣，最好的部分不是那些容易出错且繁琐的任务。有了网络框架，开发者和企业都可以专注于应用程序更有趣的部分。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to initialize an Express.js project and started
    a simple application that said hello in your web browser. You also learned about
    Express.js as a web framework and saw how you’ll benefit from its methods moving
    forward. In [lesson 9](../Text/kindle_split_022.html#ch09), you apply some Express.js
    methods in building a routing system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了如何初始化 Express.js 项目，并启动了一个简单的应用程序，在您的网页浏览器中显示“你好”。您还了解了 Express.js
    作为网络框架，并看到了您将如何从其方法中受益。在 [第9课](../Text/kindle_split_022.html#ch09) 中，您将应用一些 Express.js
    方法来构建路由系统。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Change the `get` method in your `index.js` file to `post`. Restart your application,
    and see how your application behaves differently when you try to access the home
    page at http://localhost:3000\. You should see a default error message from Express,
    telling you that there’s no `GET` route for `/`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 `index.js` 文件中的 `get` 方法更改为 `post`。重启您的应用程序，并尝试在 http://localhost:3000 访问主页时，看看您的应用程序的行为有何不同。您应该会看到
    Express 的默认错误消息，告诉您 `/` 没有对应的 `GET` 路由。
- en: The reason is that you changed the request method you’re listening for. If you
    make a curl `POST` request to the home page, you see your original response content.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是您更改了您正在监听请求的方法。如果您向主页发送 curl `POST` 请求，您会看到您原始的响应内容。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 9\. Routing in Express.js
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9课。Express.js中的路由
- en: In [lesson 8](../Text/kindle_split_021.html#ch08), I introduced Express.js as
    a framework for Node.js web applications. The rest of this unit is dedicated to
    exploring Express.js functionality and using its convenient methods. This lesson
    covers routing and how a few more Express.js methods allow you to send meaningful
    data to the user before building a view. You also walk through the process of
    collecting a request’s query string. The lesson ends by touching on the MVC design
    pattern.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第8课](../Text/kindle_split_021.html#ch08) 中，我介绍了 Express.js 作为 Node.js 网络应用程序的框架。本单元的其余部分致力于探索
    Express.js 的功能并使用其便捷的方法。本课涵盖了路由以及如何在构建视图之前，使用一些额外的 Express.js 方法向用户发送有意义的 数据。您还了解了如何收集请求的查询字符串。课程结束时简要提到了
    MVC 设计模式。
- en: This lesson covers
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Setting up routes for your application
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序设置路由
- en: Responding with data from another module
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个模块返回数据
- en: Collecting request URL parameters
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集请求 URL 参数
- en: Moving route callbacks to controllers
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由回调移动到控制器
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这个**'
- en: You want to build a home-page view for your recipe application that people can
    visit to see an estimated date of completion for your application. With your new,
    clean Express.js setup, you’d like to keep the date variable in a separate file
    that you can easily change without modifying your main.js file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您想为您的食谱应用程序构建一个主页视图，人们可以访问以查看应用程序的预计完成日期。有了您的新、干净的 Express.js 设置，您希望将日期变量放在一个单独的文件中，这样您就可以轻松地更改它，而无需修改
    main.js 文件。
- en: After setting up your routes, you’ll be able to store some data in a separate
    module and respond dynamically with that data. With the separate module, you’ll
    be able to modify that file’s contents without needing to edit your main application
    file. This structure helps prevent you from making mistakes in your code while
    constantly changing values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好路由后，你将能够在单独的模块中存储一些数据，并使用这些数据动态响应。使用单独的模块，你将能够修改该文件的內容，而无需编辑主应用程序文件。这种结构有助于你在不断更改值的同时避免在代码中出错。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)9.1\. Building routes with Express.js'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)9.1\. 使用Express.js构建路由'
- en: 'In [lesson 8](../Text/kindle_split_021.html#ch08), you constructed your first
    Express.js application, consisting of a route handling `GET` requests to your
    home-page URL. Another way to describe this route is as an application endpoint
    that takes an HTTP method and path (URL). Routes in Express.js should look familiar
    to you because you built the same routing structure at the end of [unit 1](../Text/kindle_split_014.html#part01).
    In Express.js, a route definition starts with your `app` object, followed by a
    lowercase HTTP method and its arguments: the route path and callback function.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8课](../Text/kindle_split_021.html#ch08)中，你构建了你的第一个Express.js应用程序，该应用程序处理对主页URL的`GET`请求。另一种描述此路由的方式是将其视为一个应用程序端点，该端点接受HTTP方法和路径（URL）。Express.js中的路由应该对你来说很熟悉，因为你已经在[第1单元](../Text/kindle_split_014.html#part01)的结尾构建了相同的路由结构。在Express.js中，路由定义从你的`app`对象开始，后面跟着小写的HTTP方法及其参数：路由路径和回调函数。
- en: A route handling `POST` requests to the `/contact` path should look like the
    following listing. This example uses the `post` method provided by Express.js.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 处理到`/contact`路径的`POST`请求的路由应该看起来像以下列表。此示例使用Express.js提供的`post`方法。
- en: Listing 9.1\. Express.js `POST` route in main.js
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. main.js中的Express.js `POST`路由
- en: '[PRE2]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Handle requests with the Express.js post method.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用Express.js的post方法处理请求。**'
- en: You can use these HTTP methods on the `app` object because `app` is an instance
    of the main Express.js framework class. By installing this package, you inherited
    routing methods without needing to write any other code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`app`对象上使用这些HTTP方法，因为`app`是主Express.js框架类的实例。通过安装此包，你继承了路由方法，而无需编写任何其他代码。
- en: Express.js lets you write routes with parameters in the path. These parameters
    are a way of sending data through the request. (Another way is with query strings,
    which I talk about at the end of this lesson.) Route parameters have a colon (`:`)
    before the parameter and can exist anywhere in the path. [Listing 9.2](#ch09ex02)
    shows an example of a route with parameters. The route in this listing expects
    a request made to `/items/` plus some vegetable name or number. A request to `"/items/lettuce"`,
    for example, would trigger the route and its callback function. The response sends
    the item from the URL back to the user through the `params` property of the request
    object.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js允许你在路径中编写带有参数的路由。这些参数是通过请求发送数据的一种方式。（另一种方式是查询字符串，我在本课的结尾会提到。）路由参数在参数之前有一个冒号（`:`），并且可以在路径的任何位置存在。[列表9.2](#ch09ex02)显示了带有参数的路由的示例。此列表中的路由期望一个对`/items/`的请求，加上一些蔬菜名称或数字。例如，对`"/items/lettuce"`的请求将触发路由及其回调函数。响应通过请求对象的`params`属性将项目从URL发送回用户。
- en: Listing 9.2\. Using route parameters to indicate vegetable type in main.js
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 在main.js中使用路由参数来指示蔬菜类型
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Respond with path parameters.**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用路径参数进行响应。**'
- en: Initialize a new project called express_routes, install Express.js, and add
    the code to require and instantiate the Express.js module. Then create a route
    with parameters, and respond with that parameter as shown in [listing 9.2](#ch09ex02).
    At this point, your main.js should look like the code in the next listing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个名为express_routes的新项目，安装Express.js，并将代码添加到require和实例化Express.js模块。然后创建一个带有参数的路由，并像[列表9.2](#ch09ex02)中所示那样响应该参数。此时，你的main.js应该看起来像下一个列表中的代码。
- en: Listing 9.3\. Complete Express.js example in main.js
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. main.js中的完整Express.js示例
- en: '[PRE4]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Add a route to get URL parameters.**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个获取URL参数的路由。**'
- en: Route parameters are handy for specifying data objects in your application.
    When you start saving user accounts and course listings in a database, for example,
    you might access a user’s profile or specific course with the `/users/:id` and`/course/:type`
    paths, respectively. This structure is necessary for developing a representational
    state transfer (REST) architecture, as you learn in [unit 4](../Text/kindle_split_031.html#part04).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 路由参数对于在您的应用程序中指定数据对象很有用。例如，当您开始在数据库中保存用户账户和课程列表时，您可以使用 `/users/:id` 和 `/course/:type`
    路径分别访问用户的个人资料或特定课程。这种结构对于开发您在 [单元 4](../Text/kindle_split_031.html#part04) 中学习的表示状态传输
    (REST) 架构是必要的。
- en: 'One last note on Express.js routes: I talked about how Express.js is a type
    of middleware because it adds a layer between a request being received and that
    request being processed. This feature is great, but you may want to add your own
    custom middleware. You may want to log the path of every request made to your
    application for your own records, for example. You can accomplish this task by
    adding a log message to every route or by creating the middleware function in
    [listing 9.4](#ch09ex04). This listing defines a middleware function with an additional
    `next` argument, logs the request’s path to your terminal console, and then calls
    the `next` function to continue the chain in the request-response cycle.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Express.js 路由的最后一句话：我谈到了 Express.js 是一种中间件，因为它在请求被接收和处理之间添加了一个层。这个特性很棒，但您可能想添加自己的自定义中间件。例如，您可能想记录发送到您应用程序的每个请求的路径以供自己记录。您可以通过向每个路由添加日志消息或在
    [列表 9.4](#ch09ex04) 中创建中间件函数来完成此任务。此列表定义了一个带有额外 `next` 参数的中间件函数，将请求的路径记录到您的终端控制台，然后调用
    `next` 函数以继续请求-响应周期中的链。
- en: '`next` is provided as a way of calling the next function in your request-response
    execution flow. From the time a request enters the server, it accesses a series
    of middleware functions. Depending on where you add your own custom middleware
    function, you can use `next` to let Express.js know that your function is complete
    and that you want to continue to whatever function is next in the chain.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 提供了一种在请求-响应执行流程中调用下一个函数的方式。从请求进入服务器的那一刻起，它访问一系列中间件函数。根据您添加自己的自定义中间件函数的位置，您可以使用
    `next` 通知 Express.js 您的函数已完成，并且您希望继续链中的下一个函数。'
- en: 'As with HTTP methods, you can create a route with `app.use` that runs on every
    request. The difference is that you’re adding an additional argument in the callback:
    the `next` function. This middleware function allows you to run custom code on
    the request before its URL path matches with any other routes in your application.
    When your custom code completes, `next` points the request to the next route that
    matches its path.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HTTP 方法一样，您可以使用 `app.use` 创建在每次请求上运行的路由。区别在于您在回调中添加了一个额外的参数：`next` 函数。此中间件函数允许您在请求的
    URL 路径与您的应用程序中的任何其他路由匹配之前运行自定义代码。当您的自定义代码完成后，`next` 将请求指向下一个与路径匹配的路由。
- en: Try adding this middleware function to your `express_routes` application. If
    a request is made to `/items/lettuce`, the request is processed first by your
    middleware function and then by the `app.get("/items/:vegetable")` route you created
    previously.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将此中间件函数添加到您的 `express_routes` 应用程序中。如果请求 `/items/lettuce`，则请求首先由您的中间件函数处理，然后是您之前创建的
    `app.get("/items/:vegetable")` 路由。
- en: Listing 9.4\. Express.js middleware function for logging request path in main.js
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. main.js 中的 Express.js 中间件函数用于记录请求路径
- en: '[PRE5]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Define a middleware function.**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义一个中间件函数。**'
- en: '***2*** **Log the request’s path to console.**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将请求的路径记录到控制台。**'
- en: '***3*** **Call the next function.**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **调用 next 函数。**'
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**警告**'
- en: Calling `next` at the end of your function is necessary to alert Express.js
    that your code has completed. Not doing so leaves your request hanging. Middleware
    runs sequentially, so by not calling `next`, you’re blocking your code from continuing
    until completion.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数末尾调用 `next` 是必要的，以通知 Express.js 您的代码已完成。如果不这样做，您的请求将处于挂起状态。中间件按顺序运行，因此不调用
    `next` 将阻止您的代码继续执行直到完成。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can also specify a path for which you’d like your middleware function to
    run. `app.use("/items", <callback>)`, for example, will run your custom callback
    function for every request made to a path starting with `items`. [Figure 9.1](#ch09fig01)
    shows how middleware functions can interact with a request on the server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定一个您希望中间件函数运行的路径。例如，`app.use("/items", <callback>)` 将为以 `items` 开头的每个请求运行您的自定义回调函数。[图
    9.1](#ch09fig01) 显示了中间件函数如何与服务器上的请求交互。
- en: Figure 9.1\. The role of middleware functions
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 中间件函数的作用
- en: '![](../Images/09fig01_alt.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig01_alt.jpg)'
- en: In the next section, I talk about handling data in your routes and responding
    with that data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将讨论在您的路由中处理数据并使用该数据响应。
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 9.1**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.1**'
- en: '**[Q1:](#ch09qa2q0a1)**'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch09qa2q0a1)**'
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the Express.js `use` method do?
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Express.js 的 `use` 方法做什么？
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.1 answer**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.1 答案**'
- en: '**[1:](#ch09qa1q1)**'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch09qa1q1)**'
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `use` method allows you to define the middleware functions you want to use
    with Express.js.
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`use` 方法允许您定义您想要与 Express.js 一起使用的中间件函数。'
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)9.2\. Analyzing request data'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)9.2\. 分析请求数据'
- en: Preparing fancy and dynamic responses is important in your application, but
    eventually, you’ll need to demonstrate the application’s ability to capture data
    from the user’s request.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中准备花哨和动态的响应很重要，但最终，您将需要证明应用程序能够从用户的请求中捕获数据的能力。
- en: 'You have two main ways to get data from the user:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两种主要方式从用户那里获取数据：
- en: Through the request body in a `POST` request
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `POST` 请求中的请求体
- en: Through the request’s query string in the URL
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 URL 中的请求查询字符串
- en: In the first capstone project, you successfully built a form that submits data
    to a `POST` route (a route that listens for posted data to a specific URL). But
    `http` incoming data is represented as a Buffer stream, which is not human-readable
    and adds an extra step to making that data accessible for processing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个综合项目中，您成功构建了一个将数据提交到 `POST` 路由（监听特定 URL 上提交数据的路由）的表单。但 `http` 进入的数据表示为 Buffer
    流，这不是人类可读的，并且为使该数据可处理添加了一个额外的步骤。
- en: Express.js makes retrieving the request body easy with the `body` attribute.
    To assist in reading the `body` contents (as of Express.js version 4.16.0), you
    add `express.json` and `express.urlencoded` to your `app` instance to analyze
    incoming request bodies. Notice the use of `req.body` to log posted data to the
    console in [listing 9.5](#ch09ex05). Add that code to your project’s main.js.
    With Express.js’ `app.use`, specify that you want to parse incoming requests that
    are URL-encoded (usually, form post and utf-8 content) and in JSON format. Then
    create a new route for posted data. This process is as simple as using the `post`
    method and specifying a URL. Finally, print the contents of a posted form with
    the request object and its `body` attribute.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 使用 `body` 属性使检索请求体变得简单。为了帮助读取 `body` 内容（截至 Express.js 版本 4.16.0），您将
    `express.json` 和 `express.urlencoded` 添加到您的 `app` 实例中，以分析传入的请求体。注意在 [列表 9.5](#ch09ex05)
    中使用 `req.body` 将发布的数据记录到控制台。将此代码添加到您项目的 main.js 中。使用 Express.js 的 `app.use`，指定您想要解析的传入请求是
    URL 编码的（通常是表单 POST 和 utf-8 内容）以及 JSON 格式。然后为发布的数据创建一个新的路由。这个过程就像使用 `post` 方法并指定一个
    URL 一样简单。最后，使用请求对象及其 `body` 属性打印发布表单的内容。
- en: Listing 9.5\. Capturing posted data from the request body in main.js
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 在 main.js 中从请求体捕获发布数据
- en: '[PRE6]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Tell your Express.js application to parse URL-encoded data.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **告诉您的 Express.js 应用程序解析 URL 编码数据。**'
- en: '***2*** **Create a new post route for the home page.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为主页创建一个新的 POST 路由。**'
- en: '***3*** **Log the request’s body.**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **记录请求的体。**'
- en: 'Test this code by submitting a `POST` request to http://localhost:3000, using
    the following `curl` command: `curl --data "first_name=Jon&last_name=Wexler"`
    http://localhost:3000.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下 `curl` 命令向 http://localhost:3000 提交 `POST` 请求来测试此代码：`curl --data "first_name=Jon&last_name=Wexler"`
    http://localhost:3000.
- en: 'You should see the body logged to your server’s console window like so: `{
    first_name: "Jon", last_name:` “`Wexler" }`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '您应该看到如下所示的内容记录到您的服务器控制台窗口：`{ first_name: "Jon", last_name: "Wexler" }`。'
- en: Now when you demo the backend code to your customers, you can show them, through
    a mocked form submission, how data will be collected on the server.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您向客户演示后端代码时，您可以通过模拟表单提交来向他们展示数据如何在服务器上收集。
- en: Another way to collect data is through the URL parameters. Without the need
    for an additional package, Express.js lets you collect values stored at the end
    of your URL’s path, following a question mark (`?`). These values are called *query
    strings*, and they are often used for tracking user activity on a site and storing
    temporary information about a user’s visited pages.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 收集数据的另一种方式是通过 URL 参数。无需额外的包，Express.js 允许您收集存储在 URL 路径末尾的值，后面跟着一个问号 (`?`)。这些值被称为
    *查询字符串*，它们通常用于跟踪网站上的用户活动以及存储有关用户访问页面的临时信息。
- en: 'Examine the following sample URL: http://localhost:3000?cart=3&pagesVisited=4&utmcode=837623\.
    This URL might be passing information about the number of items in a user’s shopping
    cart, the number of pages they’ve visited, and a marketing code to let the site
    owners know how this user found your app in the first place.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下示例 URL：http://localhost:3000?cart=3&pagesVisited=4&utmcode=837623。这个 URL
    可能正在传递有关用户购物车中项目数量的信息，他们访问的页面数量，以及一个营销代码，让网站所有者知道用户最初是如何找到您的应用的。
- en: 'To see these query strings on the server, add `console.log(req.query)`; to
    your middleware function in main.js. Now try visiting the same URL. You should
    see `{ cart: "3", pagesVisited: "4", utmcode: "837623" }` logged to your server’s
    console window.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '要在服务器上查看这些查询字符串，请将 `console.log(req.query)` 添加到 main.js 中的中间件函数。现在尝试访问相同的 URL。你应该看到
    `{ cart: "3", pagesVisited: "4", utmcode: "837623" }` 在您的服务器控制台窗口中记录。'
- en: In the next section, I talk about MVC architecture and how Express.js routes
    fit into that structure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将讨论 MVC 架构以及 Express.js 路由如何融入该结构。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 9.2**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.2**'
- en: '**[Q1:](#ch09qa4q0a1)**'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch09qa4q0a1)**'
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What additional middleware functions are needed to parse incoming data in a
    request body with Express.js?
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要哪些额外的中间件函数来解析使用 Express.js 的请求体中的传入数据？
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 9.2 answer**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.2 答案**'
- en: '**[1:](#ch09qa3q1)**'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch09qa3q1)**'
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The express.json and express.urlencoded for parsing incoming data to the server.
    Other packages, such as `body-parser`, act as middleware and perform similar tasks.
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: express.json 和 express.urlencoded 用于解析传入服务器中的数据。其他包，如 `body-parser`，充当中间件并执行类似任务。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)9.3\. Using MVC'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)9.3\. 使用 MVC'
- en: This lesson is about processing request data within your routes. Express.js
    opens the door to custom modules and code to read, edit, and respond with data
    within the request-response cycle. To organize this growing code base, you’re
    going to follow an application architecture known as MVC.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课是关于在您的路由中处理请求数据。Express.js 打开了自定义模块和代码的大门，以便在请求-响应周期内读取、编辑和响应数据。为了组织这个不断增长的代码库，你将遵循一个名为
    MVC 的应用程序架构。
- en: 'MVC architecture focuses on three main parts of your application’s functionality:
    models, views, and controllers. You used views in past applications to display
    HTML in the response. See the breakdown and definitions in [table 9.1](#ch09table01).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 架构侧重于您应用程序功能的主要三个部分：模型、视图和控制器。您在以前的应用程序中使用了视图来在响应中显示 HTML。请参阅 [表 9.1](#ch09table01)
    中的分解和定义。
- en: Table 9.1\. Model-view-controller parts
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 9.1\. 模型-视图-控制器部分
- en: '| Views | Rendered displays of data from your application. In [unit 3](../Text/kindle_split_026.html#part03),
    you learn about models and even create your own. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 视图 | 从您的应用程序中渲染数据。在 [第 3 单元](../Text/kindle_split_026.html#part03) 中，你学习了模型，甚至创建了您自己的模型。
    |'
- en: '| Models | Classes that represent object-oriented data in your application
    and database. In your recipe application, you might create a model to represent
    a customer order. Within this model, you define what data an order should contain
    and the types of functions you can run on that data. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 模型 | 代表您应用程序和数据库中面向对象数据的类。在您的食谱应用程序中，您可能创建一个模型来表示客户订单。在这个模型中，您定义订单应包含哪些数据以及可以在该数据上运行哪些类型的函数。
    |'
- en: '| Controllers | The glue between views and models. Controllers perform most
    of the logic when a request is received to determine how request body data should
    be processed and how to involve the models and views. This process should sound
    familiar, because in an Express.js application, your route callback functions
    act as controllers. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 控制器 | 视图和模型之间的粘合剂。当接收到请求时，控制器执行大部分逻辑，以确定如何处理请求体数据以及如何涉及模型和视图。这个过程应该听起来很熟悉，因为在
    Express.js 应用程序中，您的路由回调函数充当控制器。 |'
- en: To follow the MVC design pattern, move your callback functions to separate modules
    that reflect the purposes of those functions. Callback functions related to user
    account creation, deletion, or changes, for example, go in a file called usersController.js
    within the controllers folder. Functions for routes that render the home page
    or other informational pages can go in homeController.js by convention. [Figure
    9.2](#ch09fig02) shows the file structure that your application will follow.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循 MVC 设计模式，将你的回调函数移动到反映这些函数目的的独立模块中。例如，与用户账户创建、删除或更改相关的回调函数可以放在 controllers
    文件夹中的 usersController.js 文件中。用于渲染主页或其他信息页面的函数可以按照惯例放在 homeController.js 中。[图 9.2](#ch09fig02)
    显示了你的应用程序将遵循的文件结构。
- en: Figure 9.2\. Express.js MVC file structure
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. Express.js MVC 文件结构
- en: '![](../Images/09fig02_alt.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig02_alt.jpg)'
- en: '[Figure 9.3](#ch09fig03) shows Express.js as a layer over your application
    that handles requests but also feeds your application’s controllers. The callbacks
    decide whether a view should be rendered or some data should be sent back to the
    client.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.3](#ch09fig03) 显示了 Express.js 作为一层覆盖在你的应用程序之上，处理请求但同时也为你的应用程序控制器提供数据。回调函数决定是否渲染视图或向客户端发送某些数据。'
- en: Figure 9.3\. Express.js can follow the MVC structure with routes feeding controllers
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. Express.js 可以遵循 MVC 结构，路由为控制器提供数据
- en: '![](../Images/09fig03_alt.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig03_alt.jpg)'
- en: 'To restructure your express_routes application to adhere to this structure,
    follow these steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 express_routes 应用程序重构为遵循此结构，请按照以下步骤操作：
- en: Create a controllers folder within your project folder.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件夹内创建一个 controllers 文件夹。
- en: Create a homeController.js file within controllers.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 controllers 文件夹内创建一个 homeController.js 文件。
- en: 'Require your home controller file into your application by adding the following
    to the top of main.js:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 main.js 的顶部添加以下内容将你的主控制器文件引入到应用程序中：
- en: '[PRE7]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Move your route callback functions to the home controller, and add them to that
    module’s `exports` object. Your route to respond with a vegetable parameter, for
    example, can move to your home controller to look like [listing 9.6](#ch09ex06).
    In homeController.js, you assign `exports.sendReqParam` to the callback function.
    `sendReqParam` is a variable name, so you can choose your own name that describes
    the function.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的路由回调函数移动到主控制器，并将它们添加到该模块的 `exports` 对象中。例如，响应带有蔬菜参数的路由可以移动到你的主控制器，看起来像 [列表
    9.6](#ch09ex06)。在 homeController.js 中，你将 `exports.sendReqParam` 分配给回调函数。`sendReqParam`
    是一个变量名，所以你可以选择自己的名字来描述该函数。
- en: Listing 9.6\. Moving a callback to homeController.js
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 将回调函数移动到 homeController.js
- en: '[PRE8]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Create a function to handle route-specific requests.**'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个处理特定路由请求的函数。**'
- en: Back in main.js, change the route to look like the next listing. When a request
    is made to this path, the function assigned to `sendReqParam` in the home controller
    is run.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 main.js 中，将路由更改为下一个列表所示的样子。当对这条路径发出请求时，分配给主控制器中 `sendReqParam` 的函数将被执行。
- en: Listing 9.7\. Replacing a callback with a controller function in main.js
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 在 main.js 中用控制器函数替换回调函数
- en: '[PRE9]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Handle GET requests to “/items/:vegetable”.**'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **处理对“/items/:vegetable”的 GET 请求。**'
- en: Apply this structure to the rest of your routes, and continue to use the controller
    modules to store the routes’ callback function. You can move your request-logging
    middleware to a function in the home controller referenced as `logRequestPaths`,
    for example.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此结构应用到其余的路由中，并继续使用控制器模块来存储路由的回调函数。例如，你可以将请求记录中间件移动到主控制器中的一个函数，称为 `logRequestPaths`。
- en: Restart your Node.js application, and see that the routes still work. With this
    setup, your Express.js application is taking on a new form with MVC in mind.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动你的 Node.js 应用程序，并查看路由是否仍然工作。在这种设置下，你的 Express.js 应用程序正在以 MVC 的形式采取新的形式。
- en: In the next lesson, I discuss how to serve views and assets with Express.js.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我将讨论如何使用 Express.js 提供视图和资源。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Installing and using express-generator**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装和使用 express-generator**'
- en: As you continue to evolve your Express.js application, you adhere to a specific
    file structure. You have many ways to construct your application, though, depending
    on its intended use. To jump-start your application in the Express.js framework,
    you can use a package called `express-generator`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续演进你的 Express.js 应用程序，你遵循特定的文件结构。然而，根据其预期用途，你有多种构建应用程序的方法。为了在 Express.js
    框架中快速启动你的应用程序，你可以使用一个名为 `express-generator` 的包。
- en: '`express-generator` provides some boilerplate code for an application. This
    tool offers scaffolding (prebuilt folders, modules, and configurations) that might
    have taken you a few hours to build from scratch. To install this package, use
    the global flag with the `npm install` command. Enter the following command in
    terminal: `npm install express-generator -g`. For UNIX machines, you may need
    to prepend this command with `sudo` or run it as an administrator.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-generator` 为应用程序提供了一些样板代码。这个工具提供了脚手架（预构建的文件夹、模块和配置），这可能需要你花费几个小时从头开始构建。要安装此包，使用
    `npm install` 命令的全局标志。在终端中输入以下命令：`npm install express-generator -g`。对于 UNIX 计算机，你可能需要在命令前添加
    `sudo` 或以管理员身份运行。'
- en: When this package is installed, you can create a new project by entering express
    and the project name in a new terminal window. If your project is called Generation
    Generator, for example, enter `express generation_generator` in terminal. The
    `express` keyword in this context uses `express-generator` in terminal to construct
    the application with some views and routes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个包安装后，你可以在新的终端窗口中输入 express 和项目名称来创建一个新的项目。例如，如果你的项目名为 Generation Generator，请在终端中输入
    `express generation_generator`。在这个上下文中，`express` 关键字使用 `express-generator` 在终端中构建应用程序，其中包含一些视图和路由。
- en: Although this tool is great for constructing applications quickly, I don’t recommend
    using it while running the exercises in this book. You should use a slightly different
    application structure from the one provided by express-generator. For more information
    about this package, visit [https://expressjs.com/en/starter/generator.html](https://expressjs.com/en/starter/generator.html).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个工具对于快速构建应用程序非常出色，但我不建议在本书的练习中使用它。你应该使用与 express-generator 提供的结构略有不同的应用程序结构。有关此包的更多信息，请访问
    [https://expressjs.com/en/starter/generator.html](https://expressjs.com/en/starter/generator.html)。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 9.3**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.3**'
- en: '**[Q1:](#ch09qa6q0a1)**'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch09qa6q0a1)**'
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the role of controllers in MVC?
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 控制器在 MVC 中扮演什么角色？
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.3 answer**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.3 答案**'
- en: '**[1:](#ch09qa5q1)**'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch09qa5q1)**'
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Controllers are responsible for processing data by communicating with models,
    performing code logic, and calling for a view to be rendered in a server’s response.
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 控制器负责通过与模型通信、执行代码逻辑和调用在服务器响应中渲染视图来处理数据。
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to build routes and middleware functions with
    Express.js. Then you used middleware functions to work with Express.js in analyzing
    request body contents. At the end of the lesson, you learned about MVC and saw
    how routes can be rewritten to use controllers in your application. In [lesson
    10](../Text/kindle_split_023.html#ch10), you jump into views and a rich feature
    known as layouts. With these tools, you can build your views faster.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何使用 Express.js 构建路由和中间件函数。然后你使用中间件函数与 Express.js 一起处理请求体内容。在本课结束时，你了解了
    MVC 模式，并看到了如何将路由重写以在应用程序中使用控制器。在[第10课](../Text/kindle_split_023.html#ch10)中，你将进入视图和布局等丰富功能。有了这些工具，你可以更快地构建视图。
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: You have the directory structure set up for an MVC Express.js application. Try
    creating a `POST` route for the `/sign_up` path, using Express.js methods and
    controller functions for the route’s callback.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为 MVC Express.js 应用程序设置了目录结构。尝试为 `/sign_up` 路径创建一个 `POST` 路由，使用 Express.js
    方法和控制器的函数作为路由的回调。
- en: The function’s name in the controller can read something like `userSignUpProcessor`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器中函数的名称可以像 `userSignUpProcessor` 一样。
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 10\. Connecting views with templates
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10课：连接视图与模板
- en: In [lesson 9](../Text/kindle_split_022.html#ch09), you constructed a routing
    system for your Express.js application. In this lesson, you learn about templating
    engines and see how to connect your routes to views. You learn how to work with
    Embedded JavaScript (EJS), a syntax for applying Java-Script functions and variables
    within your views, as well as how to pass data into those views from your controllers.
    You start by setting up EJS with your application and seeing how templating engines
    work. By the end of the lesson, you’ll understand the syntax needed to master
    EJS in your Express.js applications. At the end of the lesson, you install the
    `express-ejs-layouts` package to use dynamic layouts in your application.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9课](../Text/kindle_split_022.html#ch09)中，你为你的Express.js应用程序构建了一个路由系统。在本课中，你将学习关于模板引擎的内容，并了解如何将你的路由连接到视图。你将学习如何使用嵌入式JavaScript
    (EJS)，这是一种在视图内应用JavaScript函数和变量的语法，以及如何从你的控制器中将数据传递到这些视图。你首先设置EJS与你的应用程序，并了解模板引擎是如何工作的。在本课结束时，你将了解在Express.js应用程序中掌握EJS所需的语法。课程结束时，你将安装`express-ejs-layouts`包以在应用程序中使用动态布局。
- en: This lesson covers
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Connecting a templating engine to your application
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模板引擎连接到你的应用程序
- en: Passing data from your controllers to your views
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你的控制器向你的视图传递数据
- en: Setting up Express.js layouts
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Express.js布局
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You have some wireframes laying out how your application pages will look, and
    you notice that many of the pages share components. Your home page and contact
    page both use the same navigation bar. Instead of rewriting the HTML representing
    the navigation bar for each view, you want to write the code once and reuse it
    for each view.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些线框图，展示了你的应用程序页面将如何看起来，并且你注意到许多页面都共享组件。你的主页和联系页面都使用了相同的导航栏。你不想为每个视图重写表示导航栏的HTML代码，你希望编写一次代码并在每个视图中重用它。
- en: With templating in a Node.js application, you can do just that. In fact, you’ll
    be able to render a single layout for all your application pages or share view
    content in code snippets called *partials*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js应用程序中使用模板，你可以做到这一点。实际上，你将能够为所有应用程序页面渲染单个布局，或者将视图内容共享在称为*部分*的代码片段中。
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)10.1\. Connecting a templating engine'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)10.1. 连接模板引擎'
- en: In [lesson 9](../Text/kindle_split_022.html#ch09), you reorganized your routes
    to serve responses with Express.js routing methods and an MVC application structure.
    The next step is using your routes to respond with more than single lines of text.
    As in [unit 1](../Text/kindle_split_014.html#part01), you’ll render separate files,
    but these files aren’t purely HTML, and you won’t explicitly need the `fs` module
    to serve them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9课](../Text/kindle_split_022.html#ch09)中，你重新组织了你的路由，使用Express.js路由方法和MVC应用程序结构来提供响应。下一步是使用你的路由以单行文本以外的内容来响应。与[单元1](../Text/kindle_split_014.html#part01)一样，你将渲染单独的文件，但这些文件不是纯HTML，你也不需要显式地使用`fs`模块来提供它们。
- en: Part of what makes Express.js so popular is its ability to work with other packages
    and tools. One such tool is the templating engine. *Templating* allows you to
    code your views with the ability to insert dynamic data. In this book, you’ll
    be writing your views in HTML with EJS—data in the form of JavaScript objects
    embedded in the page with special syntax. These files have the .ejs extension.
    There are many templating languages like EJS, but this book assumes that you have
    moderate experience with HTML, and EJS proves to be the most effective and simplest
    templating language to learn with that background. If you want to explore other
    templating engines, consider some of the ones listed in [table 10.1](#ch10table01).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js之所以如此受欢迎的部分原因在于它能够与其他包和工具协同工作。其中一个工具就是模板引擎。*模板*允许你用能够插入动态数据的能力来编写视图。在本书中，你将使用HTML编写视图，并使用EJS——页面中嵌入的JavaScript对象以特殊语法形式存在。这些文件具有.ejs扩展名。有许多模板语言，如EJS，但本书假设你有一定的HTML经验，并且EJS证明是在这种背景下最有效且最简单的模板语言之一。如果你想探索其他模板引擎，可以考虑列表中的一些[表10.1](#ch10table01)。
- en: Table 10.1\. Templating engines
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1. 模板引擎
- en: '| Templating engine | Description |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 模板引擎 | 描述 |'
- en: '| --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mustache.js | Without the custom helpers offered by Handlebars.js, this templating
    engine is simple and lightweight, and it compiles for many languages other than
    JavaScript ([https://mustache.github.io/](https://mustache.github.io/)). |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| Mustache.js | 没有Handlebars.js提供的自定义助手，这个模板引擎简单轻量，并且可以编译成除JavaScript以外的许多语言([https://mustache.github.io/](https://mustache.github.io/))。|'
- en: '| Handlebars.js | Functionally similar to EJS, this templating engine focuses
    on the use of curly brackets, or *handlebars*, for inserting dynamic content into
    your views ([http://handlebarsjs.com/](http://handlebarsjs.com/)). |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| Handlebars.js | 功能上类似于EJS，这个模板引擎专注于使用花括号，或*handlebars*，将动态内容插入到您的视图中([http://handlebarsjs.com/](http://handlebarsjs.com/))。
    |'
- en: '| Underscore.js | In addition to other JavaScript functions and libraries,
    this engine offers templating with customizable syntax and symbols ([http://underscorejs.org/](http://underscorejs.org/)).
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| Underscore.js | 除了其他JavaScript函数和库之外，这个引擎还提供了可自定义语法和符号的模板功能([http://underscorejs.org/](http://underscorejs.org/))。
    |'
- en: '| Pug.js | This engine offers syntax similar to Jade in Ruby, abbreviating
    HTML tag names for simplicity, and is indentation-sensitive ([https://pugjs.org](https://pugjs.org)).
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| Pug.js | 这个引擎提供的语法类似于Ruby中的Jade，简化了HTML标签名称，并且对缩进敏感([https://pugjs.org](https://pugjs.org))。
    |'
- en: A *templating engine* is what Express.js uses to process your views and convert
    them to browser-readable HTML pages. Any non-HTML lines are converted to HTML,
    with values rendered where embedded variables once were. See [figure 10.1](#ch10fig01)
    to understand the conversion process.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板引擎*是Express.js用来处理您的视图并将它们转换为浏览器可读的HTML页面的工具。任何非HTML行都会被转换为HTML，其中嵌入变量的值会被渲染出来。参见[图10.1](#ch10fig01)以了解转换过程。'
- en: Figure 10.1\. Converting EJS to HTML
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. 将EJS转换为HTML
- en: '![](../Images/10fig01_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig01_alt.jpg)'
- en: 'In a new application project called express_templates, initialize your application,
    install `express` as a dependency, and create your controllers folder with a home
    controller. In your main.js file, require the normal Express.js module and `app`
    object, homeController.js, and set your server to listen on port 3000\. Next,
    install the `ejs` package with the following terminal command: `npm install ejs
    --save`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为express_templates的新应用程序项目中，初始化您的应用程序，将`express`作为依赖项安装，并创建您的控制器文件夹，包括一个主页控制器。在您的main.js文件中，引入正常的Express.js模块和`app`对象、homeController.js，并将您的服务器设置为监听端口3000。接下来，使用以下终端命令安装`ejs`包：`npm
    install ejs --save`。
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can also install `express` and `ejs` in one line by running `npm install
    express ejs --save`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过运行以下命令在一行内安装`express`和`ejs`：`npm install express ejs --save`。
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The set method**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置方法**'
- en: set is often used to assign values to predefined configuration variables used
    by your application. Those variables, called *application settings properties*,
    are listed at [https://expressjs.com/en/api.html#app.set](https://expressjs.com/en/api.html#app.set).
    Some variables are used by `app` itself to allow your application to function
    on your computer. Assigning variables with set is another way toset the application’s
    configurations.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`通常用于将值分配给应用程序使用的预定义配置变量。这些变量被称为*应用程序设置属性*，在[https://expressjs.com/en/api.html#app.set](https://expressjs.com/en/api.html#app.set)中列出。一些变量由`app`本身使用，以允许应用程序在您的计算机上运行。使用`set`分配变量是设置应用程序配置的另一种方式。'
- en: You’ve been setting the port for your application to 3000\. Although 3000 is
    a conventional port number used in web development, the port number won’t stay
    the same when the application is deployed online.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经将应用程序的端口号设置为3000。虽然3000是网络开发中常用的端口号，但应用程序上线部署时端口号不会保持不变。
- en: '`app.set` lets you assign a value to some key that you plan to reuse in your
    application. The following code will set port to the environment variable `PORT`
    value or `3000` if the former value is undefined. You could use `app.set("port",
    process.env.PORT || 3000)`;, forexample.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.set`允许您将值分配给您计划在应用程序中重用的某些键。以下代码将端口号设置为环境变量`PORT`的值或`3000`，如果前者未定义。例如，您可以使用`app.set("port",
    process.env.PORT || 3000)`；'
- en: To use this set value, you need to replace your hardcoded `3000` at the end
    of the application main.js file with `app.get("port")`. Similarly, you could run
    `app.get("view engine")`. Now you can even replace your `console.log` with a more
    dynamic statement, such as ``console.log(`Server running at http://localhost:${
    app.get("port") }`)``;
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此设置值，您需要将应用程序main.js文件末尾的硬编码`3000`替换为`app.get("port")`。同样，您也可以运行`app.get("view
    engine")`。现在，您甚至可以将您的`console.log`替换为更动态的语句，例如`console.log(`Server running at
    http://localhost:${ app.get("port") }`)`；
- en: Restart this application with the added code to make sure that it still runs
    correctly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用添加的代码重新启动此应用程序，以确保它仍然可以正确运行。
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that the `ejs` package is installed, you need to let your Express.js application
    know that you plan to use it for templating. To do so, add `app.set("view engine",
    "ejs")` below your require lines in main.js. This line tells your Express.js application
    to set its `view engine` as `ejs`. This line is how your application knows to
    expect EJS in your views folder in your main project directory.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ejs` 包已经安装，您需要让您的 Express.js 应用程序知道您计划使用它进行模板化。为此，在 main.js 中的 require 语句下方添加
    `app.set("view engine", "ejs")`。这一行告诉您的 Express.js 应用程序将其 `view engine` 设置为 `ejs`。这一行是您的应用程序知道在主项目目录中的视图文件夹中期望使用
    EJS 的方式。
- en: Now that your application is ready to interpret EJS, create an index.ejs file
    in your views folder with the code in [listing 10.1](#ch10ex01). In this code,
    you use the EJS syntax `<% %>` to define and assign a variable within your view.
    Everything within these characters runs as valid JavaScript. Each line of HTML
    contains an embedded variable. By using `<%= %>`, you’re able to print that variable’s
    value within the HTML tags.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的应用程序已准备好解释 EJS，请在您的视图文件夹中创建一个 index.ejs 文件，并包含 [列表 10.1](#ch10ex01) 中的代码。在这段代码中，您使用
    EJS 语法 `<% %>` 在视图中定义和分配一个变量。这些字符内的所有内容都作为有效的 JavaScript 运行。HTML 的每一行都包含一个嵌入的变量。通过使用
    `<%= %>》，您能够在 HTML 标签内打印该变量的值。
- en: Listing 10.1\. Sample EJS content in your index.ejs view
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. index.ejs 视图中的示例 EJS 内容
- en: '[PRE10]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Define and assign a variable in EJS.**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在 EJS 中定义和分配一个变量。**'
- en: '***2*** **Embed a variable within HTML.**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在HTML中嵌入一个变量。**'
- en: 'Last, create a route in main.js for the `/name` path. You can think of a name
    for the controller function that relates to what the function will do. The following
    example calls the function `respondWithName`: `app.get("/name", homeController.respondWithName)`.
    This route runs when a request is made to the `/name` path; then it calls the
    `respondWithName` function in the home controller.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 main.js 中为 `/name` 路径创建一个路由。您可以想一个与该函数将要执行的操作相关的控制器函数名称。以下示例调用函数 `respondWithName`：`app.get("/name",
    homeController.respondWithName)`。当请求 `/name` 路径时，此路由会运行，然后调用控制器中的 `respondWithName`
    函数。
- en: In homeController.js, add the `respondWithName` function as shown in the next
    listing. You use the `render` method on the response object to respond with a
    view from your views folder.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在 homeController.js 中，添加 `respondWithName` 函数，如下所示。您使用响应对象的 `render` 方法从您的视图文件夹中响应视图。
- en: Listing 10.2\. Rendering a view from a controller action in homeController.js
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 在 homeController.js 中从控制器操作渲染视图
- en: '[PRE11]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Respond with a custom EJS view.**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **响应一个自定义的 EJS 视图。**'
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that you don’t need the .ejs extension for the index.ejs view, and you
    don’t need to specify the folder that this view lives in. Express.js takes care
    of all that for you. As long as you continue to add your views to the views folder
    and use EJS, your application will know what to do.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不需要为 index.ejs 视图添加 .ejs 扩展名，也不需要指定此视图所在的文件夹。Express.js 会为您处理所有这些。只要您继续将视图添加到视图文件夹并使用
    EJS，您的应用程序就会知道该怎么做。
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Restart your application, and visit [http://localhost:3000/name](http://localhost:3000/name)
    in your browser. If you run into any issues, try reinstalling the `ejs` and `express`
    packages, and make sure that your files are in the correct folders.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序，并在浏览器中访问 [http://localhost:3000/name](http://localhost:3000/name)。如果您遇到任何问题，请尝试重新安装
    `ejs` 和 `express` 包，并确保您的文件位于正确的文件夹中。
- en: In the next section, I talk about passing data from the controller to your EJS
    views.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将讨论从控制器传递数据到您的 EJS 视图。
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 10.1**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.1**'
- en: '**[Q1:](#ch10qa2q0a1)**'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch10qa2q0a1)**'
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is a templating engine?
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是模板引擎？
- en: '|  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 10.1 answer**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.1 答案**'
- en: '**[1:](#ch10qa1q1)**'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch10qa1q1)**'
- en: ''
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A templating engine is the tool that Express.js uses in your application to
    process a template view. Because template views contain a mix of HTML and JavaScript
    content, the engine’s job is to convert this information to an HTML file that
    your browser can use.
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模板引擎是 Express.js 在您的应用程序中用于处理模板视图的工具。因为模板视图包含 HTML 和 JavaScript 内容的混合，所以引擎的任务是将这些信息转换为浏览器可以使用的
    HTML 文件。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)10.2\. Passing data from your controllers'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)10.2\. 从控制器传递数据'
- en: Now that your templates are rendering, the best way to use them is to pass data
    from your controllers to your views instead of defining those variables directly
    in the view. To do so, remove the line in index.ejs that defines and assigns the
    `name` variable, but keep the H1 tag and its EJS contents.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的模板正在渲染，最佳做法是从控制器将数据传递到视图，而不是直接在视图中定义这些变量。为此，请从 index.ejs 中删除定义和分配 `name`
    变量的行，但保留 H1 标签及其 EJS 内容。
- en: 'Change your route to take a parameter in its path and then send that parameter
    to the view. Your route should look like the following code: `app.get("/name/:myName",
    home Controller.respondWithName)`. Now the route takes a parameter at the end
    of the `/name` path.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的路由修改为在其路径中接受一个参数，然后将该参数发送到视图。您的路由应类似于以下代码：`app.get("/name/:myName", home
    Controller.respondWithName)`。现在路由在 `/name` 路径的末尾接受一个参数。
- en: To use this parameter, you need to access it from your request params in the
    `home -Controller.respondWithName` function. Then you can pass the name variable
    to your view in a JavaScript object. Your function should look like the code in
    the following listing. In this code block, you set the route parameter to a local
    variable; then you pass the name variable as a value for the `name` key (which
    should match the variable name in your view).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此参数，您需要从 `home -Controller.respondWithName` 函数中的请求参数访问它。然后您可以将名称变量作为JavaScript对象中的
    `name` 键的值传递（该键的名称应与视图中的变量名称匹配）。您的函数应类似于以下列表中的代码。在此代码块中，您将路由参数设置为一个局部变量；然后您将名称变量作为
    `name` 键的值传递（该键的名称应与视图中的变量名称匹配）。
- en: Listing 10.3\. Passing a route parameter to your view in homeController.js
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 在 homeController.js 中将路由参数传递到您的视图
- en: '[PRE12]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Assign a local variable to a request parameter.**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将局部变量分配给请求参数。**'
- en: '***2*** **Pass a local variable to a rendered view.**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将局部变量传递给渲染的视图。**'
- en: Restart your application, and visit [http://localhost:3000/name/jon](http://localhost:3000/name/jon)
    in your browser.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序，并在浏览器中访问 [http://localhost:3000/name/jon](http://localhost:3000/name/jon)。
- en: '|  |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: '`/name/jon` is a different path from `/name/`. If you don’t add a name as a
    route parameter, your application will complain that no route matches your request.
    You must add some text following the second forward slash in the URL.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`/name/jon` 与 `/name/` 是不同的路径。如果您不将名称作为路由参数添加，您的应用程序将抱怨没有路由匹配您的请求。您必须在URL中的第二个正斜杠之后添加一些文本。'
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next section, I talk about layouts and partials, and discuss how they
    allow you to write less code to get the same results in your views.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将讨论布局和部分，并讨论它们如何允许您在视图中编写更少的代码以获得相同的结果。
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 10.2**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.2**'
- en: '**[Q1:](#ch10qa4q0a1)**'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch10qa4q0a1)**'
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the format in which you send data from your controller to a view?
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您从控制器发送数据到视图的格式是什么？
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 10.2 answer**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.2 答案**'
- en: '**[1:](#ch10qa3q1)**'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch10qa3q1)**'
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To send data from your controller, you can pass a variable within a JavaScript
    object. The variable that’s local to your controller’s context follows the key,
    whose name should match the variable name in your view.
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要从您的控制器发送数据，您可以在JavaScript对象中传递一个变量。属于您控制器上下文的局部变量遵循键，其名称应与视图中的变量名称匹配。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)10.3\. Setting up partials and layouts'
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)10.3\. 设置部分和布局'
- en: In the preceding two sections, you introduced dynamic data to your views. In
    this section, you set up your views a little differently so that you can share
    view content across multiple pages.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中，您已经向视图引入了动态数据。在本节中，您将以不同的方式设置视图，以便您可以在多个页面之间共享视图内容。
- en: To start, create an application layout. A *layout* is a shell in which your
    views are rendered. Think of layouts as being the content that doesn’t change
    from page to page when you browse a website. The bottom (footer) of the page or
    navigation bar might stay the same, for example. Instead of re-creating the HTML
    for these components, add them to a layout.ejs file that other views can share.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个应用程序布局。一个 *布局* 是一个外壳，在其中渲染视图。将布局视为在浏览网站时页面之间不改变的内容。例如，页面的底部（页脚）或导航栏可能保持不变。而不是重新创建这些组件的HTML，将这些组件添加到其他视图可以共享的
    layout.ejs 文件中。
- en: To do so, install the `express-ejs-layouts` package, and require it in your
    main.js file by `layouts = require("express-ejs-layouts")`. Then let Express.js
    know to use this package as an additional middleware layer by adding `app.use(layouts)`
    to your `main.js` file.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请安装`express-ejs-layouts`包，并在您的`main.js`文件中通过`layouts = require("express-ejs-layouts")`来引入它。然后，通过在`main.js`文件中添加`app.use(layouts)`，让Express.js知道使用此包作为额外的中间件层。
- en: Next, create a layout.ejs file in your views folder. You can start with some
    simple HTML in the layout file, as shown in the next listing. The `body` keyword
    is used by Express.js and the layout `express-ejs-layouts` to fill your other
    views’ contents in its place.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的视图文件夹中创建一个`layout.ejs`文件。您可以从布局文件中的简单HTML开始，如下一列表所示。`body`关键字由Express.js和布局`express-ejs-layouts`使用，以填充其他视图的内容。
- en: Listing 10.4\. EJS layout file contents in layout.ejs
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. `layout.ejs`中的EJS布局文件内容
- en: '[PRE13]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Wrap body with boilerplate HTML.**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将body包裹在样板HTML中。**'
- en: When you visit a route that renders a view, you’ll notice the navigation and
    footer text with your rendered view in between. This layout will continue to render
    along with your view on every page load. To see, restart your application, and
    visit the `/name/:myName` path in your browser.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问一个渲染视图的路由时，您会注意到在您的渲染视图之间有导航和页脚文本。这个布局将在每次页面加载时与您的视图一起渲染。要查看，请重新启动您的应用程序，并在浏览器中访问`/name/:myName`路径。
- en: 'Partials work similarly to layouts. *Partials* are snippets of view content
    that can be included in other views. In your recipe application, you may want
    to add a notification box on a few of the pages. To do so, create a partial called
    notification.ejs, and add it to select EJS views by using the `include` keyword.
    To create a partial for the navigation element, move your code for that div to
    a new file called navigation.ejs. Place that file in a new folder called partials
    within your views folder. Then include that file within your layout.ejs file by
    using the following code: `<%- include(''partials/navigation'') %>`. With a little
    styling, your view should resemble [figure 10.2](#ch10fig02).'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 部分与布局的工作方式类似。*部分*是可以在其他视图中包含的视图内容片段。在您的食谱应用程序中，您可能想在几个页面上添加一个通知框。为此，创建一个名为`notification.ejs`的部分，并使用`include`关键字将其添加到选定的EJS视图中。为了创建导航元素的片段，将那个div的代码移动到一个名为`navigation.ejs`的新文件中。将该文件放置在视图文件夹中的新文件夹`partials`内。然后在`layout.ejs`文件中使用以下代码包含该文件：`<%-
    include('partials/navigation') %>`。稍加样式，您的视图应该类似于[图10.2](#ch10fig02)。
- en: Figure 10.2\. Example view of name page
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 名称页面的示例视图
- en: '![](../Images/10fig02_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig02_alt.jpg)'
- en: Within the EJS carets, use the `include` keyword followed by a relative path
    to your partial. Because the layout is already in the views folder, it needs to
    look in the partials folder on the same directory level to find the navigation
    partial.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在EJS的箭头中，使用`include`关键字后跟一个相对路径到您的部分。因为布局已经在视图文件夹中，它需要在该目录级别的`partials`文件夹中查找导航部分。
- en: Restart your application, and visit the `/name/:myName` path again. If everything
    was set up correctly, nothing in that view should have changed since the addition
    of a layout file. To prove that the partial is working, try changing the text
    in the navigation partial or adding new tags to see how content changes in your
    browser.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序，并再次访问`/name/:myName`路径。如果一切设置正确，该视图中的内容自添加布局文件以来不应有任何变化。为了证明部分正在工作，尝试更改导航部分中的文本或添加新标签，以查看浏览器中的内容如何变化。
- en: '|  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When making changes in your views, you don’t need to restart your application.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在视图中进行更改时，您不需要重新启动应用程序。
- en: '|  |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now you have an application using an EJS templating engine, a layout, and partials
    that accept dynamic data. In [lesson 11](../Text/kindle_split_024.html#ch11),
    you learn about handling errors and adding some configurations to your package.json
    file.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个使用EJS模板引擎、布局和接受动态数据的部分的应用程序。在[第11课](../Text/kindle_split_024.html#ch11)中，您将学习如何处理错误并向您的`package.json`文件添加一些配置。
- en: '|  |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 10.3**'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查10.3**'
- en: '**[Q1:](#ch10qa6q0a1)**'
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch10qa6q0a1)**'
- en: ''
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What keyword do you use to share partials across multiple views?
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您使用什么关键字在多个视图中共享部分？
- en: '|  |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 10.3 answer**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.3 答案**'
- en: '**[1:](#ch10qa5q1)**'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch10qa5q1)**'
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `include` keyword looks for a partial in the relative path provided and
    renders it in place.
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`include`关键字在提供的相对路径中查找部分，并在其位置渲染它。'
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)总结'
- en: In this lesson, you learned how to use templates in your application with EJS.
    You also learned how to pass data from your controllers to application views.
    At the end of the lesson, you learned how to create a layout with the `express-ejs-layouts`
    package and partials to share content across your views. In [lesson 11](../Text/kindle_split_024.html#ch11),
    you add a configuration to start your application with a different command and
    handle errors with new middleware functions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何在你的应用程序中使用模板与EJS。你还学习了如何从控制器传递数据到应用程序视图。在本节课结束时，你学习了如何使用`express-ejs-layouts`包和部分创建布局，以在视图之间共享内容。在[第11课](../Text/kindle_split_024.html#ch11)中，你添加了一个配置来使用不同的命令启动你的应用程序，并使用新的中间件函数处理错误。
- en: '|  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: Now that you have templates, partials, and a layout in your application, you
    should use them to create multiple views. Try creating a contact page for your
    recipe application that uses your application layout and a partial that renders
    a notification box called `notificationBox.ejs`. Add this partial to your `index.ejs`
    view as well.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在你的应用程序中有了模板、部分和布局，你应该使用它们来创建多个视图。尝试为你的食谱应用程序创建一个使用应用程序布局和名为`notificationBox.ejs`的通知框部分的联系页面。将这个部分添加到你的`index.ejs`视图。
- en: '|  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 11\. Configurations and error handling
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11课\. 配置和错误处理
- en: In [lesson 10](../Text/kindle_split_023.html#ch10), you added Embedded JavaScript
    (EJS) to your application views. In this lesson, you add finishing touches to
    your application by modifying your package.json file to use a start script. This
    script changes the way that you start your application from terminal. Then you
    add error handling middleware functions to log errors and respond with error pages.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10课](../Text/kindle_split_023.html#ch10)中，你向你的应用程序视图添加了嵌入式JavaScript（EJS）。在本节课中，你通过修改你的package.json文件来使用启动脚本，为你的应用程序添加了最后的修饰。这个脚本改变了你从终端启动应用程序的方式。然后，你添加了错误处理中间件函数来记录错误并返回错误页面。
- en: This lesson covers
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课涵盖
- en: Changing your application start script
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改你的应用程序启动脚本
- en: Serving static pages with Express.js
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express.js提供静态页面
- en: Creating middleware functions for error handling
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建错误处理的中间件函数
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: You’re in full swing developing your recipe application. As is common in programming,
    you run into many errors, but you have no clear indication of those errors in
    your browser.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在全力开发你的食谱应用程序。在编程中很常见，你会遇到很多错误，但在你的浏览器中并没有清晰的错误指示。
- en: In this lesson, you explore ways to serve error pages to your browser window
    when appropriate.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你将探索在适当的时候向浏览器窗口提供错误页面的方法。
- en: '|  |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)11.1\. Modifying your start script'
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)11.1\. 修改你的启动脚本'
- en: To start this lesson, you modify a file that you haven’t touched in a while.
    The package .json file is created every time you initialize a new Node.js application,
    but you’ve changed hardly any of its values manually. In [lesson 4](../Text/kindle_split_016.html#ch04),
    I talked about using the `npm start` command to start your application when that
    script is configured in your project’s package.json.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本节课，你需要修改一个你很久没动过的文件。每当初始化一个新的Node.js应用程序时，都会创建一个package.json文件，但你几乎没有手动更改过它的任何值。在[第4课](../Text/kindle_split_016.html#ch04)中，我提到了如何使用`npm
    start`命令来启动你的应用程序，当这个脚本配置在你的项目的package.json中时。
- en: 'Make a copy of your express_templates application folder from [lesson 10](../Text/kindle_split_023.html#ch10).
    In your -package.json file, locate the `scripts` property; you should see a placeholder
    for a test script. Add a comma to the end of that test script, and add `"start":
    "node main.js"`. This script allows you to run `npm start` to start your application
    and abstracts the need to know the name of your main application file. That part
    of your package.json file should look like the next listing. Within the `scripts`
    object, you can use the key—`start`—to start your application by running `npm
    start`, `npm run start`, or `npm run-script start`.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '从[第10课](../Text/kindle_split_023.html#ch10)复制你的express_templates应用程序文件夹。在你的package.json文件中，找到`scripts`属性；你应该看到一个测试脚本的占位符。在该测试脚本末尾添加一个逗号，然后添加`"start":
    "node main.js"`。这个脚本允许你运行`npm start`来启动你的应用程序，并抽象出你需要知道你的主应用程序文件名的需求。你的package.json文件中的这部分应该看起来像下面的列表。在`scripts`对象中，你可以使用键`start`通过运行`npm
    start`、`npm run start`或`npm run-script start`来启动你的应用程序。'
- en: Listing 11.1\. Add the npm start script to your package.json
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. 将npm start脚本添加到你的package.json
- en: '[PRE14]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Add a start script to package.json.**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在package.json中添加一个启动脚本。**'
- en: Save your file, and run your application with `npm start`. Functionally, nothing
    else should change in your application, which should start as usual.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的文件，并使用`npm start`运行您的应用程序。从功能上讲，您的应用程序不应该有任何其他变化，它应该像往常一样启动。
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you experience any issues restarting your application, try reverting to `node
    main` to rule out any accidental changes made in your main.js file.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在重新启动应用程序时遇到任何问题，请尝试将`node main`还原，以排除在main.js文件中意外做出的任何更改。
- en: '|  |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next section, you improve the way that you handle errors in your application.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将改进处理应用程序中错误的方式。
- en: '|  |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 11.1**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查11.1**'
- en: '**[Q1:](#ch11qa2q0a1)**'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch11qa2q0a1)**'
- en: ''
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the purpose of the `scripts` object in your package.json file?
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您的package.json文件中`scripts`对象的作用是什么？
- en: '|  |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 11.1 answer**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 11.1 答案**'
- en: '**[1:](#ch11qa1q1)**'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch11qa1q1)**'
- en: ''
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `scripts` object allows you to define aliases for commands that you want
    to run with npm.
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`scripts`对象允许您为使用npm运行的命令定义别名。'
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)11.2\. Handling errors with Express.js'
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)11.2\. 使用Express.js处理错误'
- en: So far, Express.js has been a great improvement on the development process.
    One perk is that the application doesn’t hang forever when a request is made to
    a path for which no route exists. When you make a request to the home page, however,
    if there’s no route to handle that request, you see an unfriendly `Cannot GET
    /` in your browser.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Express.js对开发过程来说是一个很大的改进。一个好处是，当请求一个不存在路由的路径时，应用程序不会永远挂起。然而，当您请求主页时，如果没有路由来处理该请求，您会在浏览器中看到一个不友好的`Cannot
    GET /`。
- en: You can take a few approaches to error handling with Express.js. The first approach
    is logging to your console whenever an error occurs. You can log errors the same
    way that you logged the requested path in [lesson 10](../Text/kindle_split_023.html#ch10).
    Because I’m dealing with a topic that’s separate from serving normal informational
    pages, I recommend that you create a new controller and install the `http-status-codes`
    package by running `npm install http-status-codes --save` in the project’s terminal
    window.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几种方法来处理Express.js中的错误。第一种方法是在发生错误时将日志记录到控制台。您可以像在[第10课](../Text/kindle_split_023.html#ch10)中记录请求路径一样记录错误。因为我处理的是一个与提供常规信息页面无关的主题，我建议您创建一个新的控制器，并在项目终端窗口中运行`npm
    install http-status-codes --save`来安装`http-status-codes`包。
- en: Create errorController.js in your controllers folder, and add the function shown
    in [listing 11.2](#ch11ex02). This function contains one more argument than the
    normal middleware function. If an error occurs in the request-response cycle,
    it appears as the first argument. As with `console.log`, you can use `console.error`
    to log the `error` object’s `stack` property, which tells you what went wrong.
    As in the previous middleware functions, the `next` argument calls the next function
    or route in the chain, this time passing the error object in case it needs to
    be processed further.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的controllers文件夹中创建errorController.js，并添加[列表11.2](#ch11ex02)中显示的函数。这个函数比正常的中间件函数多一个参数。如果在请求-响应周期中发生错误，它将作为第一个参数出现。与`console.log`一样，您可以使用`console.error`来记录`error`对象的`stack`属性，这会告诉您出了什么问题。与之前的中间件函数一样，`next`参数调用链中的下一个函数或路由，这次传递错误对象，以防需要进一步处理。
- en: '|  |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You need to accept four arguments in this error handler, with the first argument
    always representing the error object. Without all four arguments, the function
    will not be interpreted as error handling middleware, but instead as a normal
    middleware function..
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在这个错误处理程序中接受四个参数，第一个参数始终代表错误对象。如果没有所有四个参数，该函数将不会被解释为错误处理中间件，而是一个正常的中间件函数。
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 11.2\. Adding a function to your error controller, errorController.js
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2\. 向错误控制器添加函数，errorController.js
- en: '[PRE15]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Add middleware to handle errors.**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加中间件来处理错误。**'
- en: '***2*** **Log the error stack.**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **记录错误堆栈。**'
- en: '***3*** **Pass the error to the next middleware function.**'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将错误传递给下一个中间件函数。**'
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using `console.log` is great for general debugging, but as your application
    gets more involved, you’ll want to vary your log messages. Tools such as the Chrome
    browser’s console window can color-coordinate these messages for you to distinguish
    between general log messages and error messages.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`console.log`对于一般的调试来说很好，但随着您的应用程序变得更加复杂，您可能希望更改日志消息。例如，Chrome浏览器控制台窗口的工具可以为您着色这些消息，以便您区分一般日志消息和错误消息。
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Next, you need to tell Express.js to use this middleware function by requiring
    errorController.js and adding `app.use(errorController.logErrors)` to your main.js
    file. You can invoke an error by commenting out the line that defines the `paramsName`
    variable in the `respondWithName` function. Then, when you visit http://localhost:3000/name/jon,
    your `logErrors` function will run. Remember to uncomment that line when you’re
    done.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要告诉 Express.js 使用这个中间件函数，通过引入 errorController.js 并在 main.js 文件中添加 `app.use(errorController.logErrors)`。你可以通过注释掉
    `respondWithName` 函数中定义 `paramsName` 变量的行来引发一个错误。然后，当你访问 http://localhost:3000/name/jon
    时，你的 `logErrors` 函数将会运行。记住，完成之后取消注释那行代码。
- en: '|  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Make sure to add the middleware line in main.js after the rest of your normal
    route definitions.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 main.js 中将中间件行添加到你的正常路由定义之后。
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: By default, Express.js handles any errors at the end of processing a request.
    If you want to respond with a custom message, however, you can add a catch-all
    route at the end of your routes to respond with a `404` status code if the page
    is not found or a `500` status code if your application got an error in the process.
    That code should look like [listing 11.3](#ch11ex03) in errorController.js.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Express.js 在处理请求的末尾处理任何错误。但是，如果你想用自定义消息响应，你可以在你的路由末尾添加一个通配符路由来响应，如果页面未找到，则返回
    `404` 状态码，如果应用程序在处理过程中发生错误，则返回 `500` 状态码。这段代码应该看起来像 errorController.js 中的 [列表
    11.3](#ch11ex03)。
- en: In errorController.js, the first function responds with a message to let the
    user know that the request page wasn’t found in your routes. The second function
    notifies the user of an internal error that prevented the request from being processed.
    Here, you use the `http-status-codes` module in place of the code values themselves.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在 errorController.js 中，第一个函数会向用户发送一条消息，告知请求页面在你的路由中未找到。第二个函数会通知用户请求处理过程中发生的内部错误。在这里，你使用
    `http-status-codes` 模块代替代码值本身。
- en: Listing 11.3\. Handle missing routes and errors with custom messages in errorController.js
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 在 errorController.js 中使用自定义消息处理缺失路由和错误
- en: '[PRE16]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **Respond with a 404 status code.**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以 404 状态码响应。**'
- en: '***2*** **Catch all errors and respond with a 500 status code.**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **捕获所有错误并以 500 状态码响应。**'
- en: In main.js, order matters. `respondNoResourceFound` will catch requests made
    with no matching routes, and `respondInternalError` will catch any requests where
    errors occurred. Add these middleware functions to main.js, as shown in the following
    listing.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main.js 中，顺序很重要。`respondNoResourceFound` 会捕获没有匹配路由的请求，而 `respondInternalError`
    会捕获任何在请求处理过程中发生的错误。将这两个中间件函数添加到 main.js 中，如下面的列表所示。
- en: 'Listing 11.4\. Handle missing routes and errors with custom messages: main.js'
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 使用自定义消息处理缺失路由和错误：main.js
- en: '[PRE17]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Add error-handling middleware to main.js.**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将错误处理中间件添加到 main.js 中。**'
- en: If you want to customize your error pages, you can add a 404.html and a 500.html
    page in your public folder with basic HTML. Then, instead of responding with a
    plain-text message, you can respond with this file. This file won’t use your templating
    engine to process the response. Your `respondNoResourceFound` function in your
    error controller looks like the next listing. In this code, `res.sendFile` allows
    you to specify an absolute path to your error page, which is helpful if your normal
    templating renderer isn’t working.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自定义错误页面，你可以在你的公共文件夹中添加一个 404.html 和一个 500.html 页面，使用基本的 HTML。然后，而不是用纯文本消息响应，你可以用这个文件来响应。这个文件不会使用你的模板引擎来处理响应。你错误控制器中的
    `respondNoResourceFound` 函数看起来像下面的列表。在这段代码中，`res.sendFile` 允许你指定一个指向你的错误页面的绝对路径，如果你的正常模板渲染器不起作用，这会很有帮助。
- en: Listing 11.5\. Handle missing routes and errors with custom messages
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 使用自定义消息处理缺失路由和错误
- en: '[PRE18]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Respond with a custom error page.**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以自定义错误页面响应。**'
- en: '***2*** **Send content in 404.html.**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在 404.html 中发送内容。**'
- en: Now that you have error messages being served to your users and logged to your
    terminal, you should make sure that your application is set up for serving static
    files like your 404.html page.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将错误消息提供给用户并记录到终端，你应该确保你的应用程序已设置好以服务静态文件，如 404.html 页面。
- en: '|  |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 11.2**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 11.2**'
- en: '**[Q1:](#ch11qa4q0a1)**'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch11qa4q0a1)**'
- en: ''
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does your middleware that handles missing routes go after your nor-mal application
    routes?
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么处理缺失路由的中间件在你的正常应用路由之后？
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 11.2 answer**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 11.2 答案**'
- en: '**[1:](#ch11qa3q1)**'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch11qa3q1)**'
- en: ''
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The middleware function that responds with `404` status codes acts like an `else`
    inand `if-else` code block. If no other route paths match the request, this function
    responds with the message to your user.
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 响应`404`状态码的中间件函数在`if-else`代码块中类似于`else`。如果没有其他路由路径与请求匹配，此函数将向用户显示消息。
- en: '|  |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)11.3\. Serving static files'
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)11.3\. 服务器静态文件'
- en: This last section is a short one. In your application from [unit 1](../Text/kindle_split_014.html#part01),
    serving all different types of static files and assets would require hundreds
    of lines of code. With Express.js, these file types are accounted for automatically.
    The only thing you need to do is tell Express.js where to find these static files.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这部分内容较短。在您的应用程序中，从[第1单元](../Text/kindle_split_014.html#part01)开始，提供所有不同类型的静态文件和资源可能需要数百行代码。使用Express.js，这些文件类型会自动处理。您需要做的只是告诉Express.js在哪里可以找到这些静态文件。
- en: '|  |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Static files include your assets and custom error pages, such as 404.html and
    500.html. These HTML pages don’t go through a templating engine because they don’t
    contain any EJS values.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件包括您的资源和自定义错误页面，如404.html和500.html。这些HTML页面不会通过模板引擎，因为它们不包含任何EJS值。
- en: '|  |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To set up this task, you need to use the `static` method from the `express`
    module. This method takes an absolute path to the folder containing your static
    files. Then, as with any other middleware function, you need to tell the Express.js
    `app` instance to use this feature. To enable the serving of static files, add
    `app.use(express.static("public"))` to main.js. This line of code tells your application
    to use the corresponding public folder, at the same level in the project directory
    as main.js, to serve static files.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置此任务，您需要使用`express`模块中的`static`方法。此方法接受包含您的静态文件的文件夹的绝对路径。然后，与任何其他中间件函数一样，您需要告诉Express.js的`app`实例使用此功能。要启用静态文件的提供，请在main.js中添加`app.use(express.static("public"))`。此行代码告诉您的应用程序使用位于项目目录中与main.js同一级别的相应公共文件夹来提供静态文件。
- en: With this code in place, you can visit http://localhost:3000/404.html directly.
    You can also place an image or another static asset in your public folder and
    access it by filename after the main domain in your URL. If you add an image,
    such as cat.jpg, within another subdirectory called images, you can view that
    image alone by visiting http://localhost:3000/images/cat.jpg.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码设置完成后，您可以直接访问http://localhost:3000/404.html。您也可以在公共文件夹中放置一个图像或其他静态资源，并通过URL中的主域名后的文件名来访问它。如果您在名为images的子目录中添加了一个图像，例如cat.jpg，您可以通过访问http://localhost:3000/images/cat.jpg来单独查看该图像。
- en: '|  |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 11.3**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查11.3**'
- en: '**[Q1:](#ch11qa6q0a1)**'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch11qa6q0a1)**'
- en: ''
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What important static files live in your public folder?
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您公共文件夹中存放着哪些重要的静态文件？
- en: '|  |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 11.3 answer**'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 11.3 答案**'
- en: '**[1:](#ch11qa5q1)**'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch11qa5q1)**'
- en: ''
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Your public folder contains static HTML files for your error pages. If some-thing
    goes wrong in your application, these files can be served back to the client.
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您的公共文件夹包含用于错误页面的静态HTML文件。如果您的应用程序出现错误，这些文件可以被发送回客户端。
- en: '|  |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)总结'
- en: In this lesson, you learned how to change your application’s start script. You
    also learned how to log and manage some of the errors that occur in your Express.js
    application. At the end of the lesson, you set up Express.js to serve static assets
    from your public folder. Now you have quite a few tools at your disposal to use
    in building your recipe application. In [lesson 12](../Text/kindle_split_025.html#ch12),
    you put what you’ve learned to the test by restructuring the Confetti Cuisine
    application.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，您学习了如何更改应用程序的启动脚本。您还学习了如何记录和管理Express.js应用程序中发生的一些错误。在本课结束时，您设置了Express.js以从公共文件夹提供静态资源。现在，您有相当多的工具可以使用来构建您的食谱应用程序。在[第12课](../Text/kindle_split_025.html#ch12)中，您通过重构Confetti
    Cuisine应用程序来测试您所学的内容。
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: Now that you have the ability to serve static files, build a creative HTML page
    for 404 and 500 errors in your application. These files don’t use the normal layout
    file that you use for templating, so all your styling must live inside the HTML
    page.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了提供静态文件的能力，为您的应用程序构建一个用于404和500错误的创意HTML页面。这些文件不使用您用于模板的常规布局文件，因此所有样式都必须位于HTML页面内部。
- en: '|  |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lesson 12\. Capstone: Enhancing the Confetti Cuisine site with Express.js'
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12课：综合：使用Express.js增强Confetti Cuisine网站
- en: After some consideration, I decided that it would be easier to rely on a web
    framework to assist me in building a web application for Confetti Cuisine. Building
    custom routes and application logic has become a tedious task, so I’m converting
    my application to use Express.js.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些考虑，我决定依赖一个网络框架来帮助我构建 Confetti Cuisine 的网络应用程序会更简单。构建自定义路由和应用程序逻辑已经变成了一项繁琐的任务，所以我将把我的应用程序转换为使用
    Express.js。
- en: I still want the application to have home, courses, and sign-up pages. I need
    to convert the routes to use keywords and syntax found in Express.js. I need to
    make sure that I serve my static assets out of the public directory and have all
    necessary package.json configurations set up for launching the application locally.
    When I feel ready to make this transformation, I’ll start by initializing the
    project with `npm init`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然希望应用程序拥有主页、课程和注册页面。我需要将路由转换为使用 Express.js 中找到的关键字和语法。我需要确保从公共目录中提供我的静态资源，并且为本地启动应用程序设置了所有必要的
    package.json 配置。当我准备好进行这种转换时，我将首先使用 `npm init` 初始化项目。
- en: '![](../Images/sectionFig.png)12.1\. Initializing the application'
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![初始化应用程序](../Images/sectionFig.png)12.1. 初始化应用程序'
- en: To begin this site redesign, I’m going to create a new project directory called
    confetti_cuisine and enter that folder. Within the project folder in terminal,
    I’ll initialize the application package.json with `npm init`.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个网站的重设计，我将创建一个新的项目目录，命名为 confetti_cuisine 并进入该文件夹。在终端的项目文件夹中，我将使用 `npm
    init` 初始化应用程序的 package.json 文件。
- en: Remembering the configurations that I previously set, I’ll keep the default
    settings for the project name and use entry point main.js.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我之前设置的配置，我将保留项目名称的默认设置，并使用入口点 main.js。
- en: 'Now that my package.json is set up, I’m going to add a start script under `"scripts"`,
    which will allow me to run the application by using `npm start` instead of `node
    <filename>`. I add `"start": "node main.js"` to my list of scripts.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我的 package.json 已经设置好了，我将在 `"scripts"` 下添加一个启动脚本，这样我就可以使用 `npm start` 而不是
    `node <filename>` 来运行应用程序。我在脚本列表中添加了 `"start": "node main.js"`。'
- en: '|  |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t forget to separate multiple script items with a comma.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记用逗号分隔多个脚本项。
- en: '|  |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The last step in the initialization process is adding the main Express.js web
    framework, EJS templating, a layout, and `http-status-codes` packages to this
    project. To do so, I run `npm install express ejs express-ejs-layouts http-status-codes
    --save` in the command line.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化过程的最后一步是向此项目添加主 Express.js 网络框架、EJS 模板、布局和 `http-status-codes` 包。为此，我在命令行中运行
    `npm install express ejs express-ejs-layouts http-status-codes --save`。
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `--save` flag saves the `express` package as a dependency in this project’s
    package.json. This way, any future work on this project will ensure that Express.js
    is installed before anything is able to work.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save` 标志将 `express` 包保存为项目 package.json 中的依赖项。这样，任何未来的项目工作都将确保在能够工作之前安装了
    Express.js。'
- en: '|  |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: My resulting package.json file looks like the following listing.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我生成的 package.json 文件如下所示。
- en: Listing 12.1\. Project configurations in package.json
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1. package.json 中的项目配置
- en: '[PRE19]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **List dependencies installed for this project.**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **列出为此项目安装的依赖项。**'
- en: 'Before I add any new files, I’m going to set up my application’s directory
    structure. The final project structure will look like [listing 12.2](#ch12ex02).
    I’ll add the following:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在我添加任何新文件之前，我将设置我的应用程序的目录结构。最终的项目结构将看起来像 [列表 12.2](#ch12ex02)。我将添加以下内容：
- en: A views folder to hold my HTML pages
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个视图文件夹来存放我的 HTML 页面
- en: A controllers folder to hold any routing functions
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制器文件夹来存放任何路由函数
- en: A public folder with css, js, and images folders within to hold my client-side
    assets
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公共文件夹，其中包含 css、js 和 images 文件夹，用于存放我的客户端资源
- en: Listing 12.2\. Confetti Cuisine project file structure
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2. Confetti Cuisine 项目文件结构
- en: '[PRE20]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **List of project directory from root**'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从根目录列出项目目录**'
- en: Great. Now I’m ready to add application logic.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。现在我已经准备好添加应用程序逻辑。
- en: '![](../Images/sectionFig.png)12.2\. Building the application'
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![构建应用程序](../Images/sectionFig.png)12.2. 构建应用程序'
- en: Now that the application is set up with Express.js installed, I’ll create my
    main.js application file. Although this file will resemble my `http` module version,
    writing it from scratch will eliminate a ton of headaches in converting line by
    line. My main.js will look like the code in [listing 12.3](#ch12ex03).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经设置好，并安装了 Express.js，我将创建我的 main.js 应用程序文件。尽管这个文件将类似于我的 `http` 模块版本，但从头开始编写它将消除在逐行转换时的许多头痛。我的
    main.js 将看起来像 [列表 12.3](#ch12ex03) 中的代码。
- en: The first line of main.js requires the contents of the Express.js package, assigning
    them to a constant called `express`. As with the app constant in the first version
    of this application, I’ll instantiate the `express` object, representing this
    project’s main application framework as another constant called `app`. The `app`
    constant will have the ability to set up a `GET` route, listening for requests
    made to the root URL (/) and responding with the Express.js send function called
    on the response. I can finally set up the server to listen on port 3000 and log
    a message to my console when it’s up and running.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js`的第一行需要Express.js包的内容，并将它们分配给一个名为`express`的常量。与第一个版本中的应用程序中的`app`常量一样，我将实例化`express`对象，将其表示为名为`app`的另一个常量，代表本项目的主要应用程序框架。`app`常量将能够设置一个`GET`路由，监听对根URL（/）的请求，并使用响应上的Express.js
    send函数进行响应。我最终可以设置服务器监听端口3000，并在运行时向我的控制台记录一条消息。'
- en: Listing 12.3\. Setting up the main application logic in main.js
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.3\. 在`main.js`中设置主要应用程序逻辑
- en: '[PRE21]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Require express.**'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入express。**'
- en: '***2*** **Instantiate the express application.**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **实例化Express应用程序。**'
- en: '***3*** **Create a route for the home page.**'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **为主页创建路由。**'
- en: '***4*** **Set the application up to listen on port 3000.**'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将应用程序设置为监听端口3000。**'
- en: With this logic in place, I can start the application by running `npm start`
    in my command line.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个逻辑到位后，我可以通过在命令行中运行`npm start`来启动应用程序。
- en: The json and urlencoded Express.js middleware functions will be used as middleware
    that interpret incoming request bodies for me. In main.js, I’ll add the code in
    the next listing.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用json和urlencoded Express.js中间件函数作为中间件，为我解析传入请求的请求体。在`main.js`中，我将在下一列表中添加代码。
- en: Listing 12.4\. Adding body parsing to the top of main.js
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.4\. 在`main.js`顶部添加body解析
- en: '[PRE22]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Tell the Express.js app to use body-parser for processing URL-encoded
    and JSON parameters.**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **告诉Express.js应用程序使用body-parser处理URL编码和JSON参数。**'
- en: Now my application is ready to analyze data within incoming requests. Next,
    I need to create routes to reach views in my application.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我的应用程序已准备好分析传入请求中的数据。接下来，我需要创建路由以访问应用程序中的视图。
- en: '![](../Images/sectionFig.png)12.3\. Adding more routes'
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)12.3\. 添加更多路由'
- en: Now that my application has a starting point, I’m going to create routes for
    the courses and sign-up pages. Additionally, I’ll add a `POST` route to handle
    submissions made from the form on the sign-up page.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我的应用程序有一个起点，我将为课程和注册页面创建路由。此外，我还会添加一个`POST`路由来处理从注册页面表单提交的请求。
- en: 'First, I create a home controller in my controllers folder, which is where
    I’ll store the functions my routes will use. I need to require this controller
    by adding `const homeController = require("./controllers/homeController")` in
    main.js. I add the code in the next listing to my home controller, below my application’s
    first route. All three of these functions respond with an EJS page reflecting
    the requested route. I need to create the following views: `courses.ejs`, `contact.ejs`,
    and `thanks.ejs`.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我在`controllers`文件夹中创建一个主页控制器，这是我将存储路由将使用的函数的地方。我需要在`main.js`中通过添加`const homeController
    = require("./controllers/homeController")`来引入这个控制器。我在下一列表中添加的代码到主页控制器中，在我的应用程序的第一个路由下方。这三个函数都响应一个反映请求路由的EJS页面。我需要创建以下视图：`courses.ejs`、`contact.ejs`和`thanks.ejs`。
- en: Listing 12.5\. Adding route actions to my home controller in homeController.js
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5\. 在`homeController.js`中添加路由操作
- en: '[PRE23]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Add callback functions for specific routes.**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **为特定路由添加回调函数。**'
- en: In my main.js, I add the following routes and modify my original home-page route
    to use my home controller too, as shown in [listing 12.6](#ch12ex06). The first
    route handles `GET` requests made to view course listings. For the most part,
    this route behaves similarly to the home page. The route for the contact page
    also listens for `GET` requests, as most people will be expecting a sign-up form
    on this page when the `/contact` URL is requested. The last route is for `POST`
    requests targeting the `/contact` URL. The `GET` route is used internally to view
    who submitted a request to get in contact. The `POST` route is used by the sign-up
    form on the contact page.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 main.js 中，我添加了以下路由，并修改了我原始的主页路由以使用我的主页控制器，如[列表 12.6](#ch12ex06)所示。第一个路由处理查看课程列表的
    `GET` 请求。在大多数情况下，此路由的行为与主页相似。联系页面的路由也监听 `GET` 请求，因为当请求 `/contact` URL 时，大多数人都会期望在这个页面上有一个注册表单。最后一个路由是针对
    `/contact` URL 的 `POST` 请求。`GET` 路由用于内部查看谁提交了请求以取得联系。`POST` 路由由联系页面上的注册表单使用。
- en: Listing 12.6\. Adding routes for each page and request type in main.js
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. 在 main.js 中为每个页面和请求类型添加路由
- en: '[PRE24]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **Add routes for the courses page, contact page, and contact form submission.**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **为课程页面、联系页面和联系表单提交添加路由。**'
- en: Now that all the routes are defined, I’m still missing the bulk of the content.
    It’s time to add and render some views.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有路由都已定义，但我仍然缺少大部分内容。是时候添加和渲染一些视图了。
- en: '![](../Images/sectionFig.png)12.4\. Routing to views'
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)12.4\. 路由到视图'
- en: With Express.js, my views are going to be cleaner and easier to render. I need
    to create the views listed in [table 12.1](#ch12table01).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Express.js，我的视图将更干净且更容易渲染。我需要创建[表 12.1](#ch12table01)中列出的视图。
- en: Table 12.1\. Confetti Cuisine views
  id: totrans-597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 12.1\. Confetti Cuisine 视图
- en: '| Filename | Purpose |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 目的 |'
- en: '| --- | --- |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| layout.ejs | Serves as the application’s main styling and navigation foundation
    |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| layout.ejs | 作为应用程序的主要样式和导航基础 |'
- en: '| index.ejs | Produces the home page’s content |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| index.ejs | 生成主页的内容 |'
- en: '| courses.ejs | Displays course content |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| courses.ejs | 显示课程内容 |'
- en: '| contact.ejs | Displays the contact form |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| contact.ejs | 显示联系表单 |'
- en: '| thanks.ejs | Displays a thank-you message upon form submission |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| thanks.ejs | 在表单提交后显示感谢信息 |'
- en: '| error.ejs | Displays an error message when a page isn’t found |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| error.ejs | 当找不到页面时显示错误信息 |'
- en: I’ll start by generating my application’s layout view, which will handle what
    the navigation and general site structure looks like from page to page.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先生成我的应用程序布局视图，它将处理导航和网站结构从页面到页面的样子。
- en: For the layout to work, I need to include it in my main application file, right
    below my initialization of the Express.js module, as shown in [listing 12.7](#ch12ex07).
    First, I require the `express-ejs-layouts` module to allow me to use the layout.ejs
    file. Then, I set the application server to use the `ejs` rendering template.
    Last, I set the application server to use the recently required `layouts` module.
    This way, when a new view is rendered, it goes through the layout.ejs file.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使布局工作，我需要在主应用程序文件中包含它，就在初始化 Express.js 模块之后，如[列表 12.7](#ch12ex07)所示。首先，我需要引入
    `express-ejs-layouts` 模块，以便我可以使用 layout.ejs 文件。然后，我将应用程序服务器设置为使用 `ejs` 渲染模板。最后，我将应用程序服务器设置为使用最近引入的
    `layouts` 模块。这样，当渲染新的视图时，它将通过 layout.ejs 文件。
- en: Listing 12.7\. Enable EJS layout rendering in main.js
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7\. 在 main.js 中启用 EJS 布局渲染
- en: '[PRE25]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Require the express-ejs-layouts module.**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要引入 express-ejs-layouts 模块。**'
- en: '***2*** **Set the application to use ejs.**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将应用程序设置为使用 ejs。**'
- en: '***3*** **Set the application to use the layout module.**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将应用程序设置为使用布局模块。**'
- en: I’ll add this file, called layout.ejs, to my views folder. The key component
    of this file includes `<%- body %>`, which will be replaced by my target route’s
    rendered content.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加一个名为 layout.ejs 的文件到我的视图文件夹中。该文件的关键组件包括 `<%- body %>`，它将被我的目标路由的渲染内容所替换。
- en: Each of the following views will use this layout to provide visual consistency
    (and to avoid repetition of code between files). Within the views folder, I’m
    going to create index.ejs, courses.ejs, contact.ejs, thanks.ejs, and error.ejs
    files. Like the layout file, these views render as Embedded JavaScript, allowing
    me to dynamically feed content to the pages from the server file. After creating
    index.ejs, I change my home-page route (`/`) to render the index page in place
    of sending plain text.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 以下每个视图都将使用此布局来提供视觉一致性（以及避免在文件之间重复代码）。在 views 文件夹中，我将创建 index.ejs、courses.ejs、contact.ejs、thanks.ejs
    和 error.ejs 文件。与布局文件类似，这些视图以嵌入式 JavaScript 的形式渲染，允许我从服务器文件动态地向页面提供内容。在创建 index.ejs
    之后，我将我的主页路由 (`/`) 修改为渲染索引页面，而不是发送纯文本。
- en: The one view I need to focus on is contact.ejs, where I’ll have prospective
    students fill out a form, submitting a `POST` request to my application’s `/sign-up`
    route. That form will look like the HTML in the next listing. Notice that the
    form action is `/contact` and the form method is `POST`. When the form is submitted,
    it will make a `POST` request to the `/contact` route.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要关注的视图是 contact.ejs，在这里我将让潜在的学生填写表单，向我的应用程序的 `/sign-up` 路由提交 `POST` 请求。这个表单将类似于下一条列表中的
    HTML。请注意，表单的 action 是 `/contact`，表单的方法是 `POST`。当表单提交时，它将向 `/contact` 路由发送 `POST`
    请求。
- en: Listing 12.8\. Contact form in contact.ejs
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. contact.ejs 中的联系表单
- en: '[PRE26]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Display example contact form.**'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示示例联系表单。**'
- en: I should be all set. If I named my routes to match and render their corresponding
    views, I should be able to launch my app and see those views rendered within the
    layout I built. The only thing missing is my app’s ability to serve images and
    other static files, which I cover next.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该已经设置好了。如果我将路由命名以匹配并渲染相应的视图，我应该能够启动我的应用并看到那些视图在构建的布局中渲染。唯一缺少的是我的应用提供图片和其他静态文件的能力，这将在下一部分进行介绍。
- en: '|  |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The layout file is rendered on every page I visit. Try adding new HTML content
    above and below the `<%- body %>`marker. Notice that these elements are applied
    to every page.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 布局文件在访问的每个页面上都会被渲染。尝试在 `<%- body %>` 标记的上方和下方添加新的 HTML 内容。请注意，这些元素应用于每个页面。
- en: '|  |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)12.5\. Serving static views'
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)12.5\. 服务器静态视图'
- en: In my first take of this application using `http`, serving static assets became
    a big mess. With every new asset I added to my project directory, I needed to
    create a new route and handle it appropriately. Luckily, Express.js handles this
    task nicely, requiring virtually no effort on my part to handle any and all static
    files I want my application to serve. To enable static assets, I’ll use Express.js’
    `static` function by adding `app.use(express.static` `("public"))` below the initialization
    of Express.js in my application file. This addition allows individual assets in
    the application to be served directly.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在我第一次使用 `http` 开发这个应用程序时，提供静态资源变得一团糟。每当我在项目目录中添加新的资源时，我都需要创建一个新的路由并相应地处理它。幸运的是，Express.js
    很好地处理了这个任务，几乎不需要我做出任何努力来处理我想要应用提供的任何和所有静态文件。为了启用静态资源，我将在应用程序文件中 Express.js 初始化之后添加
    `app.use(express.static("public"))`。这个添加允许直接提供应用程序中的单个资源。
- en: The last major step in converting the app to an Express.js app is using dynamic
    content in the views.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用转换为 Express.js 应用程序的最后一步主要是在视图中使用动态内容。
- en: '![](../Images/sectionFig.png)12.6\. Passing content to the views'
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![章节图](../Images/sectionFig.png)12.6\. 将内容传递到视图中'
- en: Confetti Cuisine often modifies its course listings, so the application is better
    off not showing those courses on a static web page. With Express.js, passing content
    from the server logic to the view is a piece of cake.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: Confetti Cuisine 经常修改其课程列表，因此应用程序最好不在静态网页上显示这些课程。使用 Express.js，从服务器逻辑向视图传递内容易如反掌。
- en: For this app, I need to display an array of course offerings as a JavaScript
    object. Then I can send the object to my rendered view. I add the code in [listing
    12.9](#ch12ex09) to homeController.js. By assigning the `courses` variable to
    an array of JavaScript objects, I can use this list and target specific keys in
    my view. The `res.render` method allows me to pass the `courses` object to the
    view and refer to it as `offeredCourses` on that page.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，我需要将课程列表以 JavaScript 对象的形式显示。然后我可以将这个对象发送到我的渲染视图。我在 [代码列表 12.9](#ch12ex09)
    中添加了代码到 homeController.js 文件。通过将 `courses` 变量赋值给一个 JavaScript 对象数组，我可以使用这个列表并针对视图中的特定键进行操作。`res.render`
    方法允许我将 `courses` 对象传递到视图中，并在该页面上将其引用为 `offeredCourses`。
- en: '|  |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Within the view, I can access this array by using the variable name `offeredCourses`.
    Within the home controller, that array goes by the name `courses`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我可以通过使用变量名 `offeredCourses` 来访问这个数组。在主控制器中，这个数组名为 `courses`。
- en: '|  |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 12.9\. Set up content on server and pass into rendered view in homeController.js
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. 在 homeController.js 中设置内容并在渲染的视图中传递
- en: '[PRE27]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Define an array of courses.**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义课程数组。**'
- en: '***2*** **Pass the courses array to the view.**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将课程数组传递到视图中。**'
- en: To benefit from this feature, I need to add some EJS and HTML to loop through
    the offeredCourses list in courses.ejs and print the relevant content, as shown
    in [listing 12.10](#ch12ex10).
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个功能，我需要在 courses.ejs 中添加一些 EJS 和 HTML 来遍历 offeredCourses 列表并打印相关内容，如[列表
    12.10](#ch12ex10)所示。
- en: Listing 12.10\. Loop through and display dynamic content in view in courses.ejs
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10\. 在 courses.ejs 视图中遍历并显示动态内容
- en: '[PRE28]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** **Loop through the array of courses in the view.**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在视图中遍历课程数组。**'
- en: Now the application is complete. My courses page looks like [figure 12.1](#ch12fig01).
    Instead of modifying my courses.ejs view every time a modification is made to
    the course offerings, I can change the array in my main application file. Running
    the application is the easy part now.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经完成。我的课程页面看起来像[图 12.1](#ch12fig01)。每次课程提供修改时，我无需修改我的 courses.ejs 视图，只需更改主应用程序文件中的数组即可。现在运行应用程序变得简单。
- en: Figure 12.1\. View of courses page
  id: totrans-643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.1\. 课程页面视图
- en: '![](../Images/12fig01_alt.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10\. 12fig01_alt.jpg](../Images/12fig01_alt.jpg)'
- en: I should anticipate that things won’t go exactly as planned, so it’s always
    smart to prepare for certain errors and handle them accordingly. Soon, when this
    array of courses is replaced by contents from a persistent database, I won’t need
    to make any code changes to update the course listing.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该预料到事情不会完全按计划进行，因此总是明智地准备处理某些错误并相应地处理它们。不久，当这个课程数组被持久数据库中的内容替换时，我无需对代码进行任何更改来更新课程列表。
- en: '![](../Images/sectionFig.png)12.7\. Handling the errors'
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图 12.7\. 处理错误](../Images/sectionFig.png)'
- en: An application handling most expected outcomes ensures a fairly consistent and
    good experience for its users. I know that my application may be missing some
    foolproof logic, though, and I prefer to send my own custom error messages to
    my client’s audience when those errors occur.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大多数预期结果的应用程序确保为用户提供相当一致和良好的体验。我知道我的应用程序可能缺少一些万无一失的逻辑，但当我遇到这些错误时，我更喜欢向我的客户端观众发送我自己的自定义错误消息。
- en: For error handling, I’ll create an error controller, errorController.js, to
    store my functions, as shown in [listing 12.11](#ch12ex11). The first function
    handles all requests not previously handled, which fits the category of URLs visited
    without an active route and results in a 404 error, serving error.ejs. The last
    function handles any internal server errors that occur. Instead of necessarily
    crashing and scaring the audience away, I prefer a friendlier message.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误处理，我将创建一个错误控制器，errorController.js，来存储我的函数，如[列表 12.11](#ch12ex11)所示。第一个函数处理所有之前未处理的请求，这符合访问没有活动路由的
    URL 类别，并导致 404 错误，提供 error.ejs。最后一个函数处理发生的任何内部服务器错误。我更喜欢一个友好的消息，而不是必然崩溃并吓跑观众。
- en: Listing 12.11\. Adding error handling routes in errorController.js
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 在 errorController.js 中添加错误处理路由
- en: '[PRE29]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **Handle all requests not previously handled.**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **处理所有之前未处理的请求。**'
- en: '***2*** **Handle any internal server errors.**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **处理任何内部服务器错误。**'
- en: Then I add routes to correspond to these functions. I’ll add the routes in [listing
    12.12](#ch12ex12) to trigger the functions in my error controller if no proceeding
    routes respond to a request.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我为这些函数添加路由。我将在[列表 12.12](#ch12ex12)中添加路由，以触发我的错误控制器中的函数，如果先前的路由没有响应请求。
- en: '|  |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The order of routes matters. These routes must go below any preexisting routes,
    as they act as a catch-all and override any routes below them.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的顺序很重要。这些路由必须放在任何现有路由之下，因为它们充当通配符并覆盖其下任何路由。
- en: '|  |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 12.12\. Adding error handling routes in main.js
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. 在 main.js 中添加错误处理路由
- en: '[PRE30]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Add error handlers as middleware functions.**'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将错误处理程序作为中间件函数添加。**'
- en: I need to require this controller by adding `const errorController = require("./
    controllers/errorController")` to the top of my main.js file. Now my application
    is ready to handle errors and launch. When a URL is visited without a corresponding
    route, users see my cat, Hendrix, relaxing on the error page ([figure 12.2](#ch12fig02)).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要在 main.js 文件的顶部添加 `const errorController = require("./controllers/errorController")`
    来引入这个控制器。现在我的应用程序已经准备好处理错误并启动。当访问没有对应路由的 URL 时，用户会看到我的猫亨德里克斯在错误页面上放松（[图 12.2](#ch12fig02)）。
- en: Figure 12.2\. View of error page
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.2\. 错误页面视图
- en: '![](../Images/12fig02_alt.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12fig02_alt.jpg)'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png) 摘要'
- en: Through this project, I redefined the Node.js project file structure to fit
    a web framework. I used npm to install three external packages. Then I rebuilt
    the main application file, using Express.js syntax. To create a path for specific
    URLs, I set up new routes, using Express.js keywords. For a consistent user interface,
    I used layouts with EJS. Using Express.js’ static library, I set up static assets
    to be served to the client through my public folder. Last, I added content to
    the main project application file and set up that content to be served dynamically
    to one of my views.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个项目，我重新定义了 Node.js 项目文件结构以适应网络框架。我使用 npm 安装了三个外部包。然后我重新构建了主要应用程序文件，使用了 Express.js
    语法。为了为特定的 URL 创建路径，我设置了新的路由，使用了 Express.js 的关键字。为了保持一致的用户界面，我使用了 EJS 的布局。使用 Express.js
    的静态库，我在公共文件夹中设置了静态资源以供客户端服务。最后，我在主要项目应用程序文件中添加了内容，并设置了这些内容以动态地服务于我的某个视图。
- en: With consistent practice of these techniques and proper error handling, I can
    use Express.js to build future applications in a few steps. With new features
    such as layouts and dynamic content, I can try to send content to other views
    in my application or try modifying the layout as it’s used throughout the app.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续练习这些技术和适当的错误处理，我可以用 Express.js 在几个步骤中构建未来的应用程序。有了布局和动态内容等新功能，我可以尝试将内容发送到应用程序中的其他视图，或者尝试在应用程序中使用时修改布局。
- en: In [unit 3](../Text/kindle_split_026.html#part03), I discuss how to organize
    application code around persistent data with Express.js.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [单元 3](../Text/kindle_split_026.html#part03) 中，我讨论了如何使用 Express.js 围绕持久数据组织应用程序代码。
