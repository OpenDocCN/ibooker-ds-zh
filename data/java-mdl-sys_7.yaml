- en: appendix E
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附录 E
- en: Targeting multiple Java versions with multi-release JARs
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用多版本 JAR 针对多个 Java 版本
- en: It’s never easy to decide which Java version to require for your project. On
    the one hand, you want to give users the freedom of choice, so it would be nice
    to support several major versions, not just the newest one. On the other hand,
    you’re dying to use the newest language features and APIs. From Java 9 on, there’s
    a new JVM feature, multi-release JARs (MR-JARs), that helps you reconcile these
    opposing forces—at least, under some circumstances.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 决定你的项目需要哪个 Java 版本从来都不容易。一方面，你希望给用户选择自由，所以支持几个主要版本而不是仅支持最新版本会很好。另一方面，你迫切希望使用最新的语言特性和
    API。从 Java 9 开始，有一个新的 JVM 特性，即多版本 JAR（MR-JARs），它可以帮助你在某些情况下调和这些对立的力量。
- en: MR-JARs allow you to ship bytecode for different Java versions in the same artifact.
    You can then rely on the JVM to load the classes that you compiled for the most
    recent version it supports. Starting with a project that runs successfully on
    your minimally required version, you can selectively improve it on newer JVMs
    by using more resilient and performant APIs—without being forced to raise your
    project’s baseline.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MR-JARs 允许你在同一个工件中打包不同版本的 Java 字节码。然后你可以依赖 JVM 加载你为它支持的最新版本编译的类。从一个在最小要求版本上成功运行的工程开始，你可以通过使用更健壮和性能更高的
    API 来选择性地在新 JVM 上改进它，而无需强制提高你项目的基线。
- en: ESSENTIAL INFO Of course, you’ll only ever need to consider MR-JARs if you don’t
    have full control over the JVM version running your project. This is always the
    case for libraries and frameworks and often for desktop applications or web backends
    that your users host themselves. If, on the other hand, you administer the machines
    that run your application, you can use a newer JVM and forego the complexities
    of MR-JARs.
  id: totrans-4
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**当然，你只有在没有完全控制运行你项目的 JVM 版本的情况下才需要考虑 MR-JARs。对于库和框架来说，这始终是这种情况，对于用户自己托管桌面应用程序或网络后端来说，通常也是如此。另一方面，如果你管理运行你应用程序的机器，你可以使用较新的
    JVM，并放弃 MR-JARs 的复杂性。'
- en: With all of that out of the way, let’s explore this handy new feature. We’ll
    start with creating a simple MR-JAR before looking at how it’s structured internally.
    We’ll end with some recommendations for when and how to use MR-JARs.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在解决所有这些问题之后，让我们来探索这个实用的新特性。我们将从创建一个简单的 MR-JAR 开始，然后再看看它是如何内部结构的。最后，我们将提供一些关于何时以及如何使用
    MR-JARs 的建议。
- en: Creating a multi-release JAR
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个多版本 JAR
- en: Definition
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义
- en: 'Multi-release JARs (MR-JARs) are specially prepared JARs that contain bytecode
    for several major Java versions. How that bytecode is loaded depends on the JVM
    version:'
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多版本 JAR（MR-JARs）是特别准备的 JAR，包含几个主要 Java 版本的字节码。字节码的加载方式取决于 JVM 版本：
- en: Java 8 and earlier load version-unspecific class files.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 及更早版本加载版本无关的类文件。
- en: Java 9 and later load version-specific class files if they exist, or otherwise
    fall back to version-unspecific ones.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9 及以后的版本如果存在版本特定的类文件，则加载这些类文件，否则回退到版本无关的类文件。
- en: To prepare for an MR-JAR, you need to split source files by the Java version
    they target, compile each set of sources for the corresponding version, and place
    the resulting `.class` files into separate folders. When packaging them with `jar`,
    you add the baseline class files as usual (directly or with `-C`; check section
    4.5.1) and use the new option `--release ${release}` for each other bytecode set.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了准备一个 MR-JAR，你需要根据目标 Java 版本分割源文件，为每个版本的源文件集编译相应的版本，并将生成的 `.class` 文件放入单独的文件夹中。当使用
    `jar` 打包时，你通常添加基线类文件（直接或使用 `-C`；请参阅第 4.5.1 节）并为每个其他字节码集使用新的选项 `--release ${release}`。
- en: Let’s look at an example. Say you need to detect the currently running JVM’s
    major version. Java 9 offers a nice API for that, so you no longer have to parse
    a system property. (Section 6.5.1 gives a glimpse of it, but the details aren’t
    important here.) By deploying an MR-JAR, you can use that API if you’re running
    on Java 9 or later.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设你需要检测当前运行的 JVM 的主要版本。Java 9 提供了一个很好的 API 来实现这一点，因此你不再需要解析系统属性。（第
    6.5.1 节提供了一些关于它的信息，但细节在这里并不重要。）通过部署一个 MR-JAR，如果你在 Java 9 或更高版本上运行，你可以使用那个 API。
- en: The hypothetical app has two classes, `Main` and `DetectVersion`; and the goal
    is to have two variants of `DetectVersion`, one for Java 8 and earlier and another
    for Java 9 and later. These two variants need to have the exact same fully qualified
    name (which can make it challenging to work with them in your IDE)—assume you
    place them into two parallel source folders, `src/main/java` and `src/main/java-9`.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设的应用程序有两个类，`Main` 和 `DetectVersion`；目标是拥有两个 `DetectVersion` 的变体，一个用于 Java 8
    及更早版本，另一个用于 Java 9 及以后版本。这两个变体需要具有完全相同的完全限定名（这可能会在 IDE 中使用它们时带来挑战）——假设你将它们放置在两个平行的源文件夹中，`src/main/java`
    和 `src/main/java-9`。
- en: '[Figure E.1](part0035.html#filepos2080621) shows how to organize the sources,
    and [listing E.1](part0035.html#filepos2077220) shows how to compile and package
    them into an MR-JAR. Note the two compilation steps and the separate output folders.
    The end result is shown in [figure E.2](part0035.html#filepos2081957).'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 E.1](part0035.html#filepos2080621) 展示了如何组织源代码，而 [列表 E.1](part0035.html#filepos2077220)
    展示了如何将它们编译和打包成 MR-JAR。注意有两个编译步骤和单独的输出文件夹。最终结果在 [图 E.2](part0035.html#filepos2081957)
    中展示。'
- en: Listing E.1 Compiling and packaging sources for different Java versions into
    a JAR
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 E.1 编译和打包不同 Java 版本的源代码到 JAR 文件
- en: '`javac --release 8` [`①`](part0035.html#filepos2079074) `-d classes src/main/java/org/codefx/detect/*.java`
    `javac --release 9` [`②`](part0035.html#filepos2079453) `-d classes-9 src/main/java-9/module-info.java
    src/main/java-9/org/codefx/detect/DetectVersion.java` `jar --create` [`③`](part0035.html#filepos2079823)`--file
    target/detect.jar` [`③`](part0035.html#filepos2079823)`-C classes .` [`③`](part0035.html#filepos2079823)`--release
    9` [`④`](part0035.html#filepos2080219)`-C classes-9 .` [`④`](part0035.html#filepos2080219)'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`javac --release 8` [`①`](part0035.html#filepos2079074) `-d classes src/main/java/org/codefx/detect/*.java`
    `javac --release 9` [`②`](part0035.html#filepos2079453) `-d classes-9 src/main/java-9/module-info.java
    src/main/java-9/org/codefx/detect/DetectVersion.java` `jar --create` [`③`](part0035.html#filepos2079823)`--file
    target/detect.jar` [`③`](part0035.html#filepos2079823)`-C classes .` [`③`](part0035.html#filepos2079823)`--release
    9` [`④`](part0035.html#filepos2080219)`-C classes-9 .` [`④`](part0035.html#filepos2080219)'
- en: ①
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Compiles the code in src/main/java for Java 8 (or earlier) into classes
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 src/main/java 中的代码编译成 Java 8（或更早版本）的类文件
- en: ②
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Compiles the code in src/main/java-9 for Java 9 into classes-9
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 src/main/java-9 中的代码编译成 Java 9 的 classes-9 类文件
- en: ③
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: When packaging the bytecode into a JAR, packages default bytecode from classes
    as usual.
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当将字节码打包到 JAR 文件中时，包默认将类中的字节码作为通常一样处理。
- en: ④
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Includes classes specifically for Java 9
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含专门针对 Java 9 的类
- en: '![](../images/00040.jpeg)'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: '[Figure E.1](part0035.html#filepos2076354)One possible way to lay out the source
    code for a MR-JAR. The most important detail is that the version-dependent code,
    here `DetectVersion`, has the same fully qualified name in all variants.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 E.1](part0035.html#filepos2076354) 展示了 MR-JAR 的源代码布局方式。最重要的细节是，版本相关的代码，这里为
    `DetectVersion`，在所有变体中都有相同的完全限定名。'
- en: This simple example creates two variants of `DetectVersion`, one for the minimally
    required Java 8 and another for Java 9\. Formalizing that to the general case
    of creating a feature with several classes for several versions is surprisingly
    complex and tedious, so I’ll spare you the formal version. Instead, section E.3
    leaves you with a rule of thumb.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个简单的示例创建了两个 `DetectVersion` 的变体，一个用于最低要求的 Java 8，另一个用于 Java 9。将这正式化到创建具有多个类和多个版本的特性的通用情况是惊人地复杂和繁琐，所以我就不提供正式版本了。相反，E.3
    节为你提供了一个经验法则。
- en: '![](../images/00112.jpeg)'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00112.jpeg)'
- en: '[Figure E.2](part0035.html#filepos2076828)The JAR resulting from [listing E.1](part0035.html#filepos2077220)'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 E.2](part0035.html#filepos2076828) 由 [列表 E.1](part0035.html#filepos2077220)
    生成的 JAR 文件'
- en: Internal workings of MR-JARs
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MR-JAR 的内部工作原理
- en: 'How does an MR-JAR work? It’s pretty straightforward: it stores version-unspecific
    class files in its root (as usual) and version-specific files in `META-INF/versions/${version}`.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MR-JAR 的工作原理是怎样的？它非常直接：它在根目录中存储与版本无关的类文件（如通常一样），并在 `META-INF/versions/${version}`
    中存储特定版本的文件。
- en: ESSENTIAL INFO JVMs of version 8 and earlier don’t know anything about `META-INF/versions`
    and load the classes from the package structure in the JAR’s root. Consequently,
    it’s not possible to distinguish between versions before 9.
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息 JVMs 8 及更早版本对 `META-INF/versions` 一无所知，并从 JAR 根目录中的包结构加载类。因此，在 9 版本之前无法区分版本。
- en: Newer JVMs, however, first look into `META-INF/versions` and, only if they don’t
    find a class there, into the JAR’s root. They search backward from their own version,
    meaning a Java 10 JVM looks for code in `META-INF/versions/10`, then `META-INF/versions/9`,
    and then the root directory. These JVMs thus shadow version-unspecific class files
    with the newest version-specific ones they support.
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，较新的 JVM 首先查看 `META-INF/versions`，只有在那里找不到类时，才会查看 JAR 的根目录。它们从自己的版本开始向后搜索，这意味着
    Java 10 JVM 会寻找 `META-INF/versions/10` 中的代码，然后是 `META-INF/versions/9`，然后是根目录。因此，这些
    JVM 会用它们支持的最新的版本特定的类文件来覆盖版本无关的类文件。
- en: 'In addition to the folders in `META-INF/versions`, an MR-JAR can also be recognized
    by looking at the plaintext file `META-INF/MANIFEST.MF`: in MR-JARs, the manifest
    has an entry `Multi-Release: true`.'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '除了 `META-INF/versions` 中的文件夹外，MR-JAR 还可以通过查看纯文本文件 `META-INF/MANIFEST.MF` 来识别：在
    MR-JARs 中，清单有一个条目 `Multi-Release: true`。'
- en: Usage recommendations
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用建议
- en: 'Now that you know how to create MR-JARs and how they work, I want to give you
    some recommendations for how to make the most out of them. More precisely, I’ll
    give you tips on these topics:'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何创建 MR-JARs 以及它们是如何工作的，我想给您一些建议，如何最大限度地利用它们。更确切地说，我将就以下主题提供一些建议：
- en: How to organize source code
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织源代码
- en: How to organize bytecode
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织字节码
- en: When to use MR-JARs
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用 MR-JARs
- en: ORGANIZING THE SOURCE CODE
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**组织源代码**'
- en: 'ESSENTIAL INFO I propose two guidelines when organizing source code for MR-JARs:'
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息**我建议在组织 MR-JARs 的源代码时遵循以下两个指南：'
- en: 'The code for the oldest supported Java version goes in the project’s default
    root directory: for example, `src/main/java`, not `src/main/java-X`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于支持的最老版本的 Java 代码，放在项目的默认根目录中：例如，`src/main/java`，而不是 `src/main/java-X`。
- en: The code in that source folder is complete, meaning it can be compiled, tested,
    and deployed as is without additional files from version-specific source trees
    like `src/main/java-X`. (Note that if you’re offering a feature that only works
    on a newer Java version, having a class that only throws errors stating `“Operation
    not supported before Java X”` counts as complete. My recommendation is to not
    leave it out, leading to an uninformative `NoClassDefFoundError`.)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该源文件夹中的代码是完整的，这意味着它可以编译、测试和部署，无需从特定版本的源树（如 `src/main/java-X`）中添加额外的文件。（注意，如果您提供仅在较新
    Java 版本上工作的功能，仅抛出错误声明“在 Java X 之前不支持操作”的类也视为完整。我的建议是不要将其排除在外，从而导致不提供信息的 `NoClassDefFoundError`。）
- en: These aren’t technical requirements; nothing stops you from targeting Java 11
    and putting half of the code in `src/main/java` and the other half, or even all
    of it, in `src/main/java-11`. But that will only cause confusion.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些不是技术要求；没有任何东西阻止您针对 Java 11，将一半的代码放在 `src/main/java` 中，另一半，甚至全部，放在 `src/main/java-11`
    中。但这只会造成混淆。
- en: By sticking to the guidelines, you keep the source tree’s layout as simple as
    possible. Any human or tool looking into it sees a fully functioning project that
    targets the required JVM version. Version-dependent source trees then selectively
    enhance that code for newer versions.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过坚持指南，您可以使源树的布局尽可能简单。任何查看它的人类或工具都会看到一个针对所需 JVM 版本完全功能的项目。版本相关的源树随后会针对新版本选择性地增强该代码。
- en: 'How do you verify whether you got it right? As I said earlier, a formal description
    is complex, so here’s that rule of thumb I promised. To determine whether your
    particular layout works, mentally (or actually) undertake the following steps:'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您如何验证是否正确？正如我之前所说，正式描述很复杂，所以这里是您承诺的规则。为了确定您的特定布局是否有效，心理上（或实际上）执行以下步骤：
- en: Compile and test the version-independent source tree on the oldest supported
    Java version.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最老支持的 Java 版本上编译和测试版本无关的源树。
- en: 'For each additional source tree:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个额外的源树：
- en: Move the version-dependent code into the version-independent tree, replacing
    files where they have the same fully qualified name.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将版本相关的代码移动到版本无关的树中，替换具有相同完全限定名称的文件。
- en: Compile and test the tree on the newer version.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在较新版本的树上编译和测试该树。
- en: If that works, you got it right.
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这样做有效，那么您就做对了。
- en: Of course, your tools also have to work with the source layout you choose. Unfortunately,
    at the time of writing, IDEs and most build tools don’t have good support for
    this layout, and you might be forced to compromise. As an alternative solution,
    consider creating separate projects for each Java version.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，您的工具也必须与您选择的源布局协同工作。不幸的是，在撰写本文时，IDE 和大多数构建工具对该布局的支持并不好，您可能被迫做出妥协。作为替代方案，考虑为每个
    Java 版本创建单独的项目。
- en: ORGANIZING THE BYTECODE
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**组织字节码**'
- en: 'ESSENTIAL INFO A straight path leads from that source tree structure to my
    proposal for organizing the bytecode in the JAR:'
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 从那个源树结构到我在 JAR 中组织字节码的建议是一条直路：'
- en: The bytecode for the oldest supported Java version goes into the JAR’s root,
    meaning it’s not added after `--release`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于最老的支持的 Java 版本的字节码放入 JAR 的根目录，这意味着它不会在 `--release` 之后添加。
- en: The bytecode in the JAR’s root is complete, meaning it can be executed as is
    without additional files from `META-INF/versions`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR 根目录中的字节码是完整的，这意味着它可以不添加 `META-INF/versions` 中的额外文件即可执行。
- en: Once again, these aren’t technical requirements, but they guarantee that everybody
    looking into the JAR’s root sees a fully functioning project compiled for the
    required JVM version with selective enhancements for newer JVMs in `META-INF/versions`.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次强调，这些不是技术要求，但它们保证了查看 JAR 根目录的每个人都能看到为所需的 JVM 版本编译的完整项目，并在 `META-INF/versions`
    中对较新的 JVM 进行选择性增强。
- en: WHEN TO USE MR-JARS
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**何时使用 MR-JAR**'
- en: 'How do MR-JARs help you solve the dilemma of picking the required Java version?
    First, and to state the obvious, preparing a MR-JAR adds quite a bit of complexity:'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MR-JAR 如何帮助你解决选择所需 Java 版本的困境？首先，显然地，准备一个 MR-JAR 会增加相当多的复杂性：
- en: Your IDE and build tool must be configured appropriately to allow easy work
    on source files with the same fully qualified name that are compiled against different
    Java versions.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 IDE 和构建工具必须配置得当，以便能够轻松处理针对不同 Java 版本编译的具有相同完全限定名称的源文件。
- en: You need to keep multiple variants of the same source file in sync, so that
    they keep the same public API.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要保持同一源文件的多个变体同步，以确保它们具有相同的公共 API。
- en: Unit testing gets more complicated because you might end up writing tests that
    only run or pass on specific JVM versions.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试变得复杂，因为你可能会编写只能在特定 JVM 版本上运行或通过的测试。
- en: Integration testing gets more cumbersome because you need to consider testing
    the resulting artifact on each Java version for which the MR-JAR contains bytecode.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试变得更加繁琐，因为你需要考虑测试 MR-JAR 包含字节码的每个 Java 版本生成的结果工件。
- en: ESSENTIAL INFO That means you should carefully consider whether you want to
    create MR-JARs. There should be a considerable payoff for going down this road.
    (Maybe you can raise the required Java version after all.)
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 这意味着你应该仔细考虑是否要创建 MR-JAR。走这条路应该有相当大的回报。（也许你最终可以提升所需的 Java 版本。）'
- en: Also, MR-JARs aren’t a good fit for using convenient new language features.
    As you’ve seen, you need two variants of the involved source files, and there’s
    no good argument on the basis of convenience if you have to keep a source file
    with the inconvenient variant. Language features will also quickly pervade a code
    base, leading to a lot of duplicate classes. This isn’t a good idea.
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，MR-JAR 并不适合使用方便的新语言特性。正如你所看到的，你需要涉及源文件的两个变体，如果你必须保留具有不便变体的源文件，那么基于便利性的论据并不充分。语言特性也会迅速渗透到代码库中，导致大量重复的类。这不是一个好主意。
- en: 'APIs, on the other hand, are the sweet spot for MR-JARs. Java 9 introduced
    a number of new APIs that solve existing use cases with more resilience and/or
    better performance:'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，API 是 MR-JAR 的最佳应用场景。Java 9 引入了一系列新的 API，它们以更高的鲁棒性和/或更好的性能解决了现有的用例：
- en: Detecting the JVM version with `Runtime.Version` instead of parsing system properties
    (see section 6.5.1)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Runtime.Version` 而不是解析系统属性来检测 JVM 版本（见第 6.5.1 节）
- en: Analyzing the call stack with the stack-walking API instead of creating a `Throwable`
    (this book doesn’t cover that API, but developers of your logging framework are
    already using it)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆栈跟踪 API 分析调用栈而不是创建 `Throwable`（本书不涵盖该 API，但你的日志框架的开发者已经在使用它）
- en: Replacing reflection with variable handles (see section 12.3.2)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用变量句柄替换反射（见第 12.3.2 节）
- en: 'If you want to use a newer API on a newer Java release, all you need to do
    is encapsulate your direct calls to it in a dedicated wrapper class and then implement
    two variants of it: one using the old API, another using the new one. If you’ve
    accepted the complexities outlined before, then this is straightforward.'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想在新的 Java 版本上使用新的 API，你只需要封装你对它的直接调用到一个专用的包装类中，然后实现它的两个变体：一个使用旧 API，另一个使用新
    API。如果你已经接受了之前概述的复杂性，那么这很简单。
