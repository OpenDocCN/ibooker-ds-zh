- en: 5 Persisting and managing data in the cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 在云中持久化和管理数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding databases in a cloud native system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解云原生系统中的数据库
- en: Implementing data persistence with Spring Data JDBC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Data JDBC实现数据持久性
- en: Testing data persistence with Spring Boot and Testcontainers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot和Testcontainers测试数据持久性
- en: Managing databases in production with Flyway
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flyway在生产中管理数据库
- en: In chapter 1, I distinguished between application services and data services
    in a cloud native system. So far, we have worked with application services, which
    should be stateless to play well in a cloud environment. However, most applications
    are useless if they don’t store any state or data somewhere. For example, the
    Catalog Service application we built in chapter 3 has no persistent storage mechanism,
    so you can’t really use it to manage a catalog of books. Once you shut it down,
    all the books you added to the catalog are gone. As a consequence of being stateful,
    you can’t even scale the application horizontally.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我在云原生系统中区分了应用服务和数据服务。到目前为止，我们已经与应用服务合作，这些服务应该是无状态的，以便在云环境中良好运行。然而，如果应用不存储任何状态或数据，它们大多数都是无用的。例如，我们在第3章中构建的目录服务应用没有持久化存储机制，因此你实际上无法用它来管理书籍目录。一旦你关闭它，你添加到目录中的所有书籍都将消失。由于具有状态，你甚至无法水平扩展应用。
- en: The *state* is everything that should be preserved when you shut down a service
    and spin up a new instance. Data services are the stateful components of a system.
    For example, they can be data stores like PostgreSQL, Cassandra, and Redis, or
    they can be messaging systems like RabbitMQ and Apache Kafka.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态*是你关闭服务并启动新实例时应保留的一切。数据服务是系统的有状态组件。例如，它们可以是像PostgreSQL、Cassandra和Redis这样的数据存储，也可以是像RabbitMQ和Apache
    Kafka这样的消息系统。'
- en: This chapter will introduce databases for cloud native systems and the main
    aspects of persisting data in the cloud. We’ll rely on Docker to run PostgreSQL
    in the local environment, but in production we’re going to replace it with a managed
    service offered by a cloud platform. Then we’ll add a data persistence layer to
    Catalog Service using Spring Data JDBC. Finally, I’ll cover some common concerns
    about managing and evolving databases in production with Flyway.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍云原生系统的数据库以及云中持久化数据的主要方面。我们将依靠Docker在本地环境中运行PostgreSQL，但在生产中我们将用云平台提供的托管服务来替换它。然后我们将使用Spring
    Data JDBC向目录服务添加数据持久化层。最后，我将涵盖一些关于使用Flyway在生产中管理和演进数据库的常见问题。
- en: Note The source code for the examples in this chapter is available in the Chapter05/05-begin,
    Chapter05/05-intermediate, and Chapter05/05-end folders on GitHub, containing
    the initial, intermediate, and final states of the project ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在GitHub上的Chapter05/05-begin、Chapter05/05-intermediate和Chapter05/05-end文件夹中找到，包含项目的初始、中间和最终状态（[https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)）。
- en: 5.1 Databases for cloud native systems
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 云原生系统的数据库
- en: Data can be stored in many ways. Traditionally you would probably use a single
    massive database server to save as much as possible, since getting a new one would
    be expensive and time-consuming. Depending on your organization’s processes, a
    task like that could take from a few days to several months. Not in the cloud.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以以多种方式存储。传统上，你可能倾向于使用单个大型数据库服务器来尽可能多地保存数据，因为获取一个新的服务器既昂贵又耗时。根据你组织的流程，这样的任务可能需要几天到几个月。但在云中不是这样。
- en: The cloud offers elastic, self-service, and on-demand provisioning features—strong
    motivators for migrating your data services there. For each cloud native application
    you design, you should consider the most suitable storage type for the data it
    will produce. Then your cloud platform should let you provision it through an
    API or a graphical user interface. A task that used to be very time-consuming
    now requires only a few minutes. For example, deploying an instance of a PostgreSQL
    database server on Azure is as simple as running the az postgres server create
    command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供了弹性、自助和按需配置功能——这些是迁移你的数据服务到那里的强大动力。对于你设计的每个云原生应用，你应该考虑最适合其生成数据的存储类型。然后你的云平台应该允许你通过API或图形用户界面来配置它。曾经非常耗时的一项任务现在只需要几分钟。例如，在Azure上部署PostgreSQL数据库服务器的实例就像运行az
    postgres server create命令一样简单。
- en: Cloud native applications are designed to be stateless because of the nature
    of the cloud itself. It’s a dynamic infrastructure where the computing nodes can
    spread across different clusters, geographical regions, and clouds. The problem
    of applications storing state is evident. How could the state survive such a distributed
    and dynamic environment? That’s why we want to keep applications stateless.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用的设计是为了无状态，这是云本身的特性。它是一个动态的基础设施，计算节点可以分布在不同的集群、地理区域和云中。应用存储状态的问题很明显。状态在这样的分布式和动态环境中如何生存？这就是我们希望保持应用无状态的原因。
- en: Yet, we need to achieve statefulness in the cloud. This section will present
    the challenges of data services and persistence management in the cloud and describe
    your options, depending on whether you want to manage a data service yourself
    or rely on one of the offerings from a cloud provider. Then I’ll guide you through
    setting up a PostgreSQL database instance as a container for your local environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要在云中实现有状态。本节将介绍云中数据服务和持久性管理的挑战，并描述你的选项，取决于你是否想自己管理数据服务或依赖云提供商的某些服务。然后我将指导你设置一个PostgreSQL数据库实例作为本地环境的容器。
- en: 5.1.1 Data services in the cloud
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 云中的数据服务
- en: Data services are the components of a cloud native architecture designed to
    be stateful. By designing applications to be stateless, you can limit cloud storage
    challenges to those few components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务是云原生架构的组件，旨在有状态。通过设计应用为无状态，你可以将云存储挑战限制在少数几个组件中。
- en: Traditionally, storage was handled by operations engineers and database administrators.
    But the cloud and DevOps practices enable developers to pick the data service
    that best fits the application’s requirements and deploy it with the same approach
    used for cloud native applications. Specialists like database administrators are
    consulted to make the most of the technology that developers have picked, addressing
    aspects like performance, security, and efficiency. However, the goal is to provide
    storage and data services on demand, just like you would for cloud native applications,
    and configure them in a self-service manner.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，存储是由运维工程师和数据库管理员处理的。但云和DevOps实践使开发者能够选择最适合应用需求的数据服务，并以与云原生应用相同的方式部署它。数据库管理员等专家被咨询以充分利用开发者选择的技术，解决性能、安全性和效率等方面的问题。然而，目标是像为云原生应用提供存储和数据服务一样，按需提供，并以自助方式配置。
- en: 'The difference between application and data services can also be visualized
    in terms of the three basic building blocks of cloud infrastructure: compute,
    storage, and network. As shown in figure 5.1, application services use computing
    and networking resources because they are stateless. On the other hand, data services
    are stateful and require storage to persist the state.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用和数据服务之间的区别也可以通过云基础设施的三个基本构建块来可视化：计算、存储和网络。如图5.1所示，应用服务使用计算和网络资源，因为它们是无状态的。另一方面，数据服务是有状态的，需要存储来持久化状态。
- en: '![05-01](../Images/05-01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![05-01](../Images/05-01.png)'
- en: Figure 5.1 Application services (stateless) only use computing and networking
    resources in a cloud infrastructure. Data services (stateful) also need storage.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 应用服务（无状态）在云基础设施中仅使用计算和网络资源。数据服务（有状态）还需要存储。
- en: Let’s look at the challenges of data services in a cloud environment. We’ll
    also explore the main categories of data services, from which you can choose the
    most suitable solution for your applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看云环境中数据服务的挑战。我们还将探讨数据服务的主要类别，从这些类别中你可以为你的应用选择最合适的解决方案。
- en: Challenges with data services
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务的挑战
- en: Data services in a cloud native system are generally off-the-shelf components
    like databases and message brokers. There are a few properties you should consider
    to ensure you choose the most suitable technology.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生系统中，数据服务通常是现成的组件，如数据库和消息代理。在选择最合适的技术时，你应该考虑以下几个属性。
- en: '*Scalability*—Cloud native applications can scale in and out dynamically. Data
    services are no different: they should scale to adapt to increasing or decreasing
    workloads. The new challenge is scaling while ensuring safe access to the data
    storage. The amount of data flying through a system in the cloud is larger than
    ever, and there can be sudden increments, so data services should support the
    likelihood of increasing workloads and be resilient.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可伸缩性*—云原生应用可以动态地扩展和缩减。数据服务也不例外：它们应该能够扩展以适应增加或减少的工作负载。新的挑战是在确保安全访问数据存储的同时进行扩展。在云中通过系统的数据量比以往任何时候都要大，可能会有突然的增加，因此数据服务应该支持增加工作负载的可能性并具有弹性。'
- en: '*Resilience*—Much like cloud native applications, data services should be resilient
    to failures. The new aspect here is that the data persisted using a specific storage
    technology should also be resilient. One of the key strategies for ensuring your
    data is resilient and preventing data loss is duplication. Replicating data across
    different clusters and geographical zones makes it even more resilient, but this
    comes at a cost. Data services like relational databases allow replication while
    ensuring data consistency. Others, like some non-relational databases, provide
    a high level of resilience but can’t always guarantee data consistency (they offer
    what is referred to as *eventual consistency*).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*弹性*—与云原生应用类似，数据服务应该能够抵御故障。这里的新方面是，使用特定存储技术持久化的数据也应该具有弹性。确保您的数据具有弹性和防止数据丢失的关键策略之一是复制。在不同集群和地理区域之间复制数据使其更具弹性，但这需要付出代价。像关系型数据库这样的数据服务允许复制同时确保数据一致性。其他一些非关系型数据库提供高水平的弹性，但并不总能保证数据一致性（它们提供所谓的*最终一致性*）。'
- en: '*Performance*—The way data is duplicated can affect performance, which is also
    limited by the I/O access latency of the specific storage technology and the network
    latency. Where the storage is located compared to the data services relying on
    it becomes important—this is a concern that we haven’t encountered with cloud
    native applications.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能*—数据的复制方式可能会影响性能，这还受到特定存储技术的I/O访问延迟和网络延迟的限制。存储相对于依赖它的数据服务所在的位置变得很重要——这是我们未曾遇到过的云原生应用的担忧。'
- en: '*Compliance*—You might face compliance challenges with data services more than
    with cloud native applications. Persisted data is usually critical for businesses
    and often contains information protected by specific laws, regulations, or customer
    agreements regarding how it’s managed. For example, when dealing with personal
    and sensitive information, it’s vital that you manage data in accordance with
    privacy laws. In Europe, that would mean following the General Data Protection
    Regulation (GDPR). In California, there is the California Consumer Privacy Act
    (CCPA). In other domains, further laws apply. For example, health data in the
    United States should be handled in compliance with the Health Insurance Portability
    and Accountability Act (HIPAA). Both the cloud native storage and cloud provider
    should comply with whatever laws or agreements you are required to respect. Because
    of this challenge, some organizations dealing with very sensitive data, like health
    care providers and banks, prefer to use a type of cloud native storage on their
    premises so they have more control over data management and can ensure compliance
    with the applicable regulations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*合规性*—在与数据服务打交道时，你可能会面临比与云原生应用更多的合规性挑战。持久化数据通常对业务至关重要，并且通常包含受特定法律、法规或客户协议保护的信息，这些协议规定了其管理方式。例如，在处理个人和敏感信息时，按照隐私法管理数据至关重要。在欧洲，这意味着遵守通用数据保护条例（GDPR）。在加利福尼亚，有加利福尼亚消费者隐私法案（CCPA）。在其他领域，还有更多的法律适用。例如，美国的健康数据应按照健康保险可携带性和问责制法案（HIPAA）进行管理。云原生存储和云服务提供商都应遵守您必须遵守的任何法律或协议。由于这一挑战，一些处理非常敏感数据（如医疗保健提供商和银行）的组织更喜欢在其场所使用某种云原生存储，以便他们对数据管理有更多的控制，并确保符合适用的法规。'
- en: Categories of data services
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务类别
- en: 'Data services can be categorized based on who is responsible for them: the
    cloud provider or you. Cloud providers have multiple offerings for data services,
    addressing all the main challenges of cloud native storage.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务可以根据谁负责它们来分类：云提供商还是您。云提供商为数据服务提供多种选择，解决云原生存储的所有主要挑战。
- en: You can find industry-standard services like PostgreSQL, Redis, and MariaDB.
    Some cloud providers even offer enhancements on top of them, optimized for scalability,
    availability, performance, and security. For example, should you need a relational
    database, you could use Amazon Relational Database Service (RDS), Azure Database,
    or Google Cloud SQL.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到行业标准的服务，如PostgreSQL、Redis和MariaDB。一些云提供商甚至在这些服务之上提供增强功能，针对可扩展性、可用性、性能和安全进行了优化。例如，如果您需要关系型数据库，可以使用Amazon
    Relational Database Service (RDS)、Azure Database或Google Cloud SQL。
- en: Cloud providers also offer new types of data services specifically built for
    the cloud and exposing their own unique APIs. For instance, Google BigQuery is
    a serverless data warehouse solution with a particular focus on high scalability.
    Another example is the extremely fast, non-relational database Cosmos DB offered
    by Azure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商还提供专为云构建的新类型数据服务，并公开它们自己独特的API。例如，Google BigQuery是一个无服务器数据仓库解决方案，特别关注高可扩展性。另一个例子是Azure提供的极快、非关系型数据库Cosmos
    DB。
- en: The other option is to manage data services yourself, increasing the complexity
    for you, but giving you more control over the solution. You can choose to use
    a more traditional setup based on virtual machines, or you could use containers
    and take advantage of the lessons you’ve learned managing cloud native applications.
    Using containers will allow you to manage all the services in your system through
    a unified interface, such as Kubernetes, handling both compute and storage resources
    and reducing costs. Figure 5.2 illustrates these categories of data services for
    the cloud.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是自行管理数据服务，这会增加您的复杂性，但同时也让您对解决方案有更多的控制权。您可以选择基于虚拟机的更传统设置，或者使用容器并利用您在管理云原生应用程序中学到的经验。使用容器将允许您通过统一的界面管理系统中所有的服务，例如Kubernetes，处理计算和存储资源，并降低成本。图5.2展示了云数据服务的这些类别。
- en: '![05-02](../Images/05-02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![05-02](../Images/05-02.png)'
- en: Figure 5.2 Data services can be managed by you (as containers or on virtual
    machines) or by the cloud provider. In the first case you can use more traditional
    services, and in the second, you can also access multiple services built specifically
    for the cloud by the provider.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 数据服务可以由您（作为容器或虚拟机）或云提供商管理。在前一种情况下，您可以使用更传统的服务，而在后一种情况下，您还可以访问提供商为云专门构建的多个服务。
- en: Note When choosing to run and manage a data service by yourself (whether a virtual
    machine or a container on Kubernetes), another essential decision is what type
    of storage you’ll use. Local persistence storage? Remote persistence storage?
    The subject of cloud native storage is fascinating, but it’s out of scope for
    this book. If you’d like to learn more, I recommend checking out the Cloud Native
    Storage section in the CNCF Cloud Native Interactive Landscape ([https://landscape.cncf.io](https://landscape.cncf.io)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当选择自行运行和管理数据服务（无论是虚拟机还是Kubernetes上的容器）时，另一个重要的决定是您将使用哪种类型的存储。本地持久化存储？远程持久化存储？云原生存储的主题非常吸引人，但超出了本书的范围。如果您想了解更多信息，我建议您查看CNCF云原生交互式景观中的云原生存储部分（[https://landscape.cncf.io](https://landscape.cncf.io)）。
- en: The following section will focus on relational databases and will guide you
    through setting up a PostgreSQL container for your local environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将专注于关系型数据库，并指导您为本地环境设置PostgreSQL容器。
- en: 5.1.2 Running PostgreSQL as a container
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 将PostgreSQL作为容器运行
- en: For the Catalog Service application, we’ll use a relational database, PostgreSQL,
    to store the data about the books in the catalog ([www.postgresql.org](http://www.postgresql.org)).
    PostgreSQL is a popular open source database with strong reliability, robustness,
    and performance, supporting both relational and non-relational data. Most cloud
    providers offer PostgreSQL as a managed service, freeing you from dealing with
    issues like high availability, resilience, and persistent storage on your own.
    Examples are Azure Database for PostgreSQL, Amazon RDS for PostgreSQL, Google
    Cloud SQL for PostgreSQL, Alibaba Cloud ApsaraDB RDS for PostgreSQL, and DigitalOcean
    PostgreSQL.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目录服务应用程序，我们将使用关系型数据库PostgreSQL来存储目录中书籍的数据（[www.postgresql.org](http://www.postgresql.org)）。PostgreSQL是一个流行的开源数据库，具有强大的可靠性、健壮性和性能，支持关系型和非关系型数据。大多数云提供商都提供PostgreSQL作为托管服务，让您免于处理高可用性、弹性和持久化存储等问题。例如，Azure
    Database for PostgreSQL、Amazon RDS for PostgreSQL、Google Cloud SQL for PostgreSQL、阿里云ApsaraDB
    RDS for PostgreSQL和DigitalOcean PostgreSQL。
- en: Later in the book, we’ll deploy the Polar Bookshop system to a Kubernetes cluster
    managed by a cloud provider, and I’ll show you how to use their offerings for
    managed PostgreSQL. You’ll want to ensure environment parity, as recommended by
    the 15-Factor methodology, so you’ll use PostgreSQL in development as well. Docker
    makes running databases locally easier than ever, so I’ll show you how to run
    PostgreSQL as a container on your local machine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将部署Polar Bookshop系统到由云服务提供商管理的Kubernetes集群，我会向您展示如何使用他们提供的托管PostgreSQL服务。您需要确保环境一致性，正如15-Factor方法所建议的，因此您也会在开发中使用PostgreSQL。Docker使得在本地运行数据库比以往任何时候都要简单，所以我会向您展示如何在您的本地机器上以容器形式运行PostgreSQL。
- en: 'In chapter 2, you gave Docker a first try with the Catalog Service application.
    Running PostgreSQL as a container is no different. Make sure your Docker Engine
    is up and running, open a Terminal window, and execute the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，您使用目录服务应用程序首次尝试了Docker。以容器形式运行PostgreSQL并没有什么不同。请确保您的Docker Engine正在运行，打开一个终端窗口，并执行以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The name of the container
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 容器的名称
- en: ❷ Defines the username for the admin user
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义了管理员用户的用户名
- en: ❸ Defines the password for the admin user
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义了管理员用户的密码
- en: ❹ Defines the name of the database to be created
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义了要创建的数据库的名称
- en: ❺ Exposes the database to port 5432 on your machine
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将数据库暴露到您机器上的5432端口
- en: ❻ The PostgreSQL container image pulled by Docker Hub
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ Docker Hub拉取的PostgreSQL容器镜像
- en: Compared to how you ran the Catalog Service container, you’ll notice a few new
    elements. First, the Docker image from which you run a container (postgres:14.4)
    is not created by you—it’s pulled from the Docker Hub container registry (configured
    by default when you install Docker).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与您运行目录服务容器的方式相比，您会注意到一些新元素。首先，您运行容器的Docker镜像（postgres:14.4）不是由您创建的——它是从Docker
    Hub容器注册库（在安装Docker时默认配置）中拉取的。
- en: The second new thing is passing environment variables as arguments to the container.
    PostgreSQL accepts a few environment variables that are used during the container’s
    creation to configure a database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个新功能是将环境变量作为参数传递给容器。PostgreSQL接受一些环境变量，这些变量在容器创建期间用于配置数据库。
- en: Note In this book, I won’t cover how to configure storage in Docker (*volumes*).
    This means that all the data saved in your local PostgreSQL container will be
    lost once you remove the container. It might seem counterintuitive given the topic
    of this chapter, but any storage-related concern will be handled by the cloud
    provider in production, so you won’t have to deal with it yourself. If you need
    to add persistent storage to your local containers, though, you can read how to
    use volumes in the official Docker documentation ([https://docs.docker.com](https://docs.docker.com)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这本书中，我不会介绍如何在Docker中配置存储（*卷*）。这意味着一旦您删除容器，您在本地PostgreSQL容器中保存的所有数据都将丢失。考虑到本章的主题，这可能会显得有些不合逻辑，但在生产环境中，所有与存储相关的问题将由云服务提供商处理，因此您不需要自己处理。如果您需要向本地容器添加持久存储，您可以在官方Docker文档中阅读如何使用卷（[https://docs.docker.com](https://docs.docker.com)）。
- en: In the next section, you’ll see how to add data persistence to a Spring Boot
    application using Spring Data JDBC and PostgreSQL.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到如何使用Spring Data JDBC和PostgreSQL将数据持久化添加到Spring Boot应用程序中。
- en: Note If you need to, you can stop the container with docker stop polar-postgres
    and start it again with docker start polar-postgres. If you want to start over,
    you can remove the container with docker rm -fv polar-postgres and create it again
    with the previous docker run command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您需要，可以使用`docker stop polar-postgres`停止容器，然后使用`docker start polar-postgres`重新启动它。如果您想从头开始，可以使用`docker
    rm -fv polar-postgres`删除容器，然后使用之前的`docker run`命令重新创建它。
- en: 5.2 Data persistence with Spring Data JDBC
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 使用Spring Data JDBC进行数据持久化
- en: Spring supports a wide variety of data persistence technologies through the
    Spring Data project, which contains specific modules dedicated to relational (JDBC,
    JPA, R2DBC) and non-relational databases (Cassandra, Redis, Neo4J, MongoDB, and
    so on). Spring Data provides common abstractions and patterns, making it straightforward
    to navigate the different modules. This section focuses on relational databases,
    but the key points of the interaction between an application using Spring Data
    and a database (shown in figure 5.3) apply to all of them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 通过 Spring Data 项目支持多种数据持久化技术，该项目包含特定于关系型（JDBC、JPA、R2DBC）和非关系型数据库（Cassandra、Redis、Neo4J、MongoDB
    等）的模块。Spring Data 提供了常见的抽象和模式，使得在不同模块之间导航变得简单。本节重点介绍关系型数据库，但使用 Spring Data 和数据库（如图
    5.3 所示）之间的交互的关键点适用于所有这些。
- en: '![05-03](../Images/05-03.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![05-03](../Images/05-03.png)'
- en: Figure 5.3 A driver configures the connection between the application and the
    database. Entities represent domain objects and can be stored and retrieved through
    a repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 一个驱动程序配置应用程序和数据库之间的连接。实体代表领域对象，可以通过存储库进行存储和检索。
- en: 'The main elements in the interaction shown in figure 5.3 are database drivers,
    entities, and repositories:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 所示交互中的主要元素是数据库驱动程序、实体和存储库：
- en: '*Database drivers*—Components that provide integration with a specific database
    (through *connection factories*). For relational databases, you can use a JDBC
    driver (Java Database Connectivity API) in imperative/blocking applications or
    an R2DBC driver in reactive/non-blocking applications. For non-relational databases,
    each vendor has its own dedicated solution.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库驱动程序*—提供与特定数据库（通过 *连接工厂*）集成的组件。对于关系型数据库，您可以在命令式/阻塞应用程序中使用 JDBC 驱动程序（Java
    数据库连接 API）或在响应式/非阻塞应用程序中使用 R2DBC 驱动程序。对于非关系型数据库，每个供应商都有自己的专用解决方案。'
- en: '*Entities*—Domain objects that are persisted in a database. They must contain
    a field to uniquely identify each instance (a *primary key*) and can use dedicated
    annotations to configure the mapping between Java objects and database entries.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实体*—在数据库中持久化的领域对象。它们必须包含一个字段来唯一标识每个实例（*主键*），并且可以使用专用注解来配置 Java 对象和数据库条目之间的映射。'
- en: '*Repositories*—The abstractions used for data storage and retrieval. Spring
    Data provides basic implementations, which are further extended by each module
    to provide features specific to the database in use.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储库*—用于数据存储和检索的抽象。Spring Data 提供了基本实现，每个模块都进一步扩展以提供特定于所用数据库的功能。'
- en: This section will show you how to use Spring Data JDBC to add data persistence
    to a Spring Boot application like Catalog Service. You’ll configure a connection
    pool to interact with a PostgreSQL database through the JDBC driver, define entities
    to be persisted, use repositories to access data, and work with transactions.
    Figure 5.4 shows how the Polar Bookshop architecture will look by the end of this
    chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何使用 Spring Data JDBC 将数据持久化添加到像目录服务这样的 Spring Boot 应用程序中。您将配置连接池以通过
    JDBC 驱动程序与 PostgreSQL 数据库交互，定义要持久化的实体，使用存储库来访问数据，并处理事务。图 5.4 展示了在本章结束时 Polar Bookshop
    架构将如何看起来。
- en: '![05-04](../Images/05-04.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![05-04](../Images/05-04.png)'
- en: Figure 5.4 The Catalog Service application uses a PostgreSQL database to persist
    book data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 目录服务应用程序使用 PostgreSQL 数据库来持久化书籍数据。
- en: Spring Data JDBC or Spring Data JPA?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JDBC 或 Spring Data JPA？
- en: 'Spring Data offers two main options for integrating applications with a relational
    database over the JDBC driver: Spring Data JDBC and Spring Data JPA. How to choose
    between the two? As always, the answer is that it depends on your requirements
    and specific context.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 提供了两种主要选项来通过 JDBC 驱动程序将应用程序与关系型数据库集成：Spring Data JDBC 和 Spring Data
    JPA。如何在这两者之间选择？像往常一样，答案是这取决于您的需求和具体环境。
- en: Spring Data JPA ([https://spring.io/projects/spring-data-jpa](https://spring.io/projects/spring-data-jpa))
    is the most-used module in the Spring Data project. It’s based on the Java Persistence
    API (JPA), a standard specification included in Jakarta EE (previously known as
    Java EE). Hibernate is the most popular implementation. It’s a robust and battle-tested
    object-relational mapping (ORM) framework for managing data persistence in Java
    applications. Hibernate provides many useful features, but it’s also a complex
    framework. If you’re not aware of aspects like persistence context, lazy loading,
    dirty checking, or sessions, you might face issues that will be hard to debug
    without a sound familiarity with JPA and Hibernate. Once you know the framework
    better, you’ll appreciate how much Spring Data JPA simplifies things and boosts
    your productivity. To learn more about JPA and Hibernate, you can check out *High-Performance
    Java Persistence and SQL* by Vlad Mihalcea ([https://vladmihalcea.com](https://vladmihalcea.com))
    and *Java Persistence with Spring Data and Hibernate* by Ca˘ta˘lin Tudose (Manning,
    2022).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA ([https://spring.io/projects/spring-data-jpa](https://spring.io/projects/spring-data-jpa))
    是 Spring Data 项目中最常用的模块。它基于 Java 持久化 API (JPA)，这是包含在 Jakarta EE（之前称为 Java EE）中的标准规范。Hibernate
    是最受欢迎的实现。它是一个健壮且经过实战考验的对象关系映射（ORM）框架，用于管理 Java 应用程序中的数据持久化。Hibernate 提供了许多有用的功能，但它也是一个复杂的框架。如果你不了解持久化上下文、延迟加载、脏检查或会话等概念，你可能会遇到难以调试的问题，除非你对
    JPA 和 Hibernate 有足够的了解。一旦你更了解这个框架，你就会欣赏 Spring Data JPA 如何简化事情并提高你的生产力。要了解更多关于
    JPA 和 Hibernate 的信息，你可以查看 Vlad Mihalcea 的《高性能 Java 持久化和 SQL》（[https://vladmihalcea.com](https://vladmihalcea.com)）以及
    Ca˘ta˘lin Tudose 的《使用 Spring Data 和 Hibernate 进行 Java 持久化》（Manning, 2022）。
- en: Spring Data JDBC ([https://spring.io/projects/spring-data-jdbc](https://spring.io/projects/spring-data-jdbc))
    is a more recent addition to the Spring Data family. It integrates with relational
    databases following the domain-driven design (DDD) concepts like aggregates, aggregate
    roots, and repositories. It’s lightweight, simpler, and an excellent choice for
    microservices where domains are usually defined as bounded contexts (another DDD
    concept). It gives developers more control over SQL queries and allows the use
    of immutable entities. Being a simpler alternative to Spring Data JPA, it’s not
    a drop-in replacement for every scenario, since it doesn’t provide all the features
    offered by JPA. I recommend learning both, considering your requirements, and
    then deciding which module suits the specific scenario better.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JDBC ([https://spring.io/projects/spring-data-jdbc](https://spring.io/projects/spring-data-jdbc))
    是 Spring Data 家族中较新的成员。它遵循领域驱动设计（DDD）概念，如聚合、聚合根和仓库，与关系数据库集成。它轻量级、简单，是微服务的绝佳选择，在微服务中，领域通常被定义为边界上下文（另一个
    DDD 概念）。它为开发者提供了更多对 SQL 查询的控制，并允许使用不可变实体。作为 Spring Data JPA 的简单替代方案，它并不是每个场景的即插即用替代品，因为它不提供
    JPA 提供的所有功能。我建议根据你的需求学习两者，然后决定哪个模块更适合特定的场景。
- en: I’ve chosen to cover Spring Data JDBC here for its good fit with cloud native
    applications and its simplicity. Thanks to the Spring Data common abstractions
    and patterns, you can easily convert a project from Spring Data JDBC to Spring
    Data JPA. In the following sections, I’ll point out the main differences between
    the two to give you enough information in case you want to try implementing the
    same requirements using Spring Data JPA. In the code repository accompanying the
    book, you’ll also find a JPA version of Catalog Service you can use as a reference
    (Chapter05/05-end/catalog-service-jpa).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在这里介绍 Spring Data JDBC，因为它与云原生应用程序的良好匹配和其简单性。多亏了 Spring Data 的通用抽象和模式，你可以轻松地将项目从
    Spring Data JDBC 转换为 Spring Data JPA。在接下来的章节中，我会指出两者之间的主要区别，以便你在想要尝试使用 Spring
    Data JPA 实现相同要求的情况下有足够的信息。在本书附带的代码库中，你还可以找到一个 JPA 版本的 Catalog Service，你可以将其用作参考（第05章/05-end/catalog-service-jpa）。
- en: 5.2.1 Connecting to a database with JDBC
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 使用 JDBC 连接到数据库
- en: Let’s start implementing the data persistence layer for the Catalog Service
    application. As a minimum, you’ll need to import the Spring Data module for the
    specific database you want to use and, if required, also the database driver.
    Since Spring Data JDBC supports different relational databases, you’ll need to
    explicitly declare a dependency on the specific database driver you want to use.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为 Catalog Service 应用程序实现数据持久化层。至少，你需要导入你想要使用的特定数据库的 Spring Data 模块，如果需要，还可以导入数据库驱动程序。由于
    Spring Data JDBC 支持不同的关系数据库，你需要明确声明对你要使用的特定数据库驱动的依赖。
- en: You can add the two new dependencies to the build.gradle file for the Catalog
    Service project (catalog-service). Remember to refresh or reimport the Gradle
    dependencies after the new addition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将两个新的依赖项添加到目录服务项目（catalog-service）的build.gradle文件中。请记住，在添加新依赖项后刷新或重新导入Gradle依赖项。
- en: Listing 5.1 Adding dependency for Spring Data JDBC in Catalog Service
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 在目录服务中添加Spring Data JDBC依赖项
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These are the main dependencies:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要依赖项：
- en: '*Spring Data JDBC* (org.springframework.boot:spring-boot-starter-data-jdbc)—Provides
    the necessary libraries to persist data in relational databases using Spring Data
    and JDBC.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Data JDBC*（org.springframework.boot:spring-boot-starter-data-jdbc）—提供必要的库，使用Spring
    Data和JDBC在关系型数据库中持久化数据。'
- en: '*PostgreSQL* (org.postgresql:postgresql)—Provides a JDBC driver that allows
    the application to connect to a PostgreSQL database.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PostgreSQL*（org.postgresql:postgresql）—提供JDBC驱动程序，允许应用程序连接到PostgreSQL数据库。'
- en: 'The PostgreSQL database is a backing service to the Catalog Service application.
    As such, it should be handled as an attached resource according to the 15-factor
    methodology. The attachment is done through resource binding, which in the case
    of PostgreSQL, consists of the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL数据库是目录服务应用程序的后端服务。因此，它应根据15个因素方法作为附加资源进行处理。附加是通过资源绑定完成的，在PostgreSQL的情况下，包括以下内容：
- en: A URL to define which driver to use, where to find the database server, and
    which database to connect the application to
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个URL，用于定义要使用的驱动程序、数据库服务器的位置以及将应用程序连接到的数据库
- en: Username and password to establish a connection with the specified database
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于建立与指定数据库连接的用户名和密码
- en: Thanks to Spring Boot, you can provide those values as configuration properties.
    This means you can easily replace the attached database by changing the values
    for the resource binding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Spring Boot，您可以将这些值作为配置属性提供。这意味着您可以通过更改资源绑定的值轻松替换附加的数据库。
- en: Open the application.yml file for the Catalog Service project, and add the properties
    for configuring the connection with PostgreSQL. Those values are the ones you
    defined earlier as environment variables when creating the PostgreSQL container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开目录服务项目的application.yml文件，并添加配置与PostgreSQL连接的属性。这些值是在创建PostgreSQL容器时作为环境变量定义的。
- en: Listing 5.2 Configuring the connection to a database using JDBC
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 使用JDBC配置数据库连接
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The credentials for a user with privileges to access the given database and
    a JDBC URL to identify with which database you want to establish a connection
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 具有访问给定数据库权限的用户凭据以及一个JDBC URL，用于标识您想与之建立连接的数据库
- en: 'Opening and closing database connections are relatively expensive operations,
    so you don’t want to do that every time your application accesses data. The solution
    is *connection pooling*: the application establishes several connections with
    the database and reuses them, rather than creating new ones for each data access
    operation. This is a considerable performance optimization.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 打开和关闭数据库连接是相对昂贵的操作，因此您不希望在每次应用程序访问数据时都这样做。解决方案是*连接池*：应用程序与数据库建立多个连接并重用它们，而不是为每次数据访问操作创建新的连接。这是一个相当的性能优化。
- en: Spring Boot uses HikariCP for connection pooling, and you can configure it from
    the application.yml file. You want to configure at least a connection timeout
    (spring.datasource.hikari.connection-timeout) and a maximum number of connections
    in the pool (spring.datasource.hikari.maximum-pool-size), because these both affect
    application resilience and performance. As you saw for the Tomcat thread pool,
    multiple factors influence which values you should use. As a starting point, you
    can refer to the HikariCP analysis of pool sizing ([https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot使用HikariCP进行连接池管理，您可以从application.yml文件中进行配置。您需要配置至少一个连接超时（spring.datasource.hikari.connection-timeout）和连接池中的最大连接数（spring.datasource.hikari.maximum-pool-size），因为这两个因素都会影响应用程序的弹性和性能。正如您在Tomcat线程池中看到的，多个因素会影响您应该使用哪些值。作为一个起点，您可以参考HikariCP的池大小分析（[https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)）。
- en: Listing 5.3 Configuring the connection pool to interact with the database
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 配置连接池以与数据库交互
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The maximum time (ms) to spend waiting to get a connection from the pool
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从连接池获取连接的最大等待时间（毫秒）
- en: ❷ The maximum number of connections HikariCP will keep in the pool
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ HikariCP将在池中保持的最大连接数
- en: Now that you have connected a Spring Boot application to a PostgreSQL database,
    you can go ahead and define what data you want to persist.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将Spring Boot应用程序连接到了PostgreSQL数据库，您可以继续定义您想要持久化的数据。
- en: 5.2.2 Defining persistent entities with Spring Data
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 使用Spring Data定义持久化实体
- en: In Catalog Service, you already have a Book record representing a domain entity
    for the application. Depending on the business domain and its complexity, you
    might want to distinguish the domain entity from the persistent entity, making
    the domain layer utterly independent of the persistence layer. If you’d like to
    explore how to model that scenario, I recommend referring to domain-driven design
    and hexagonal architecture principles.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录服务中，您已经有了代表应用领域实体的Book记录。根据业务领域及其复杂性，您可能想要区分领域实体和持久化实体，使领域层完全独立于持久化层。如果您想了解如何建模这种情况，我建议参考领域驱动设计和六边形架构原则。
- en: In this case, the business domain is quite simple, so we’ll update the Book
    record to also be a persistent entity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，业务领域相当简单，因此我们将更新Book记录，使其也成为持久化实体。
- en: Making a domain class persistent
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使领域类持久化
- en: Spring Data JDBC encourages working with immutable entities. Using Java records
    to model entities is an excellent choice, since they’re immutable by design and
    expose an all-args constructor that the framework can use to populate objects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JDBC鼓励使用不可变实体。使用Java记录来建模实体是一个很好的选择，因为它们按设计是不可变的，并且暴露了一个所有参数的构造函数，框架可以使用它来填充对象。
- en: A persistent entity must have a field that acts as the identifier for the object,
    which will translate to the primary key in the database. You can mark a field
    as an identifier with the @Id annotation (from the org.springframework.data.annotation
    package). The database is responsible for generating a unique identifier for each
    created object automatically.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化实体必须有一个字段作为对象的标识符，这将在数据库中对应为主键。您可以使用来自org.springframework.data.annotation包的@Id注解将字段标记为标识符。数据库负责为每个创建的对象自动生成一个唯一的标识符。
- en: Note Books are uniquely identified by an ISBN, which we can call a *natural
    key* (or *business key*) for the domain entity. We could decide to use it also
    as the primary key or introduce a *technical key* (or *surrogate key*). There
    are pros and cons to both approaches. I chose to use a technical key to make it
    easier to manage and to decouple domain concerns from persistence implementation
    details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本通过ISBN唯一标识，我们可以将其称为该领域实体的*自然键*（或*业务键*）。我们可以决定使用它作为主键，或者引入一个*技术键*（或*代理键*）。这两种方法各有优缺点。我选择使用技术键，以便更容易管理和将领域关注点与持久化实现细节解耦。
- en: That is enough to create and persist a Book in the database. It’s also OK when
    a single user updates an existing Book object in isolation. But what happens if
    the same entity is updated by multiple users concurrently? Spring Data JDBC supports
    *optimistic locking* to address that concern. Users can read data concurrently.
    When a user attempts an update operation, the application checks if there has
    been any change since the last read. If there was, the operation is not performed,
    and an exception is thrown. The check is based on a numeric field that starts
    counting from 0 and automatically increases at every update operation. You can
    mark such a field with the @Version annotation (from the org.springframework.data.annotation
    package).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够在数据库中创建和持久化一本书了。当单个用户独立更新现有的Book对象时，这也是可以的。但如果多个用户同时更新相同的实体会发生什么呢？Spring
    Data JDBC支持*乐观锁*来解决这个问题。用户可以并发读取数据。当用户尝试执行更新操作时，应用程序会检查自上次读取以来是否发生了任何变化。如果有变化，则不执行操作，并抛出异常。检查基于一个从0开始计数并在每次更新操作时自动增加的数字字段。您可以使用来自org.springframework.data.annotation包的@Version注解标记这样的字段。
- en: When the @Id field is null and the @Version field is 0, Spring Data JDBC assumes
    it’s a new object. Consequently, it relies on the database to generate an identifier
    when inserting the new row in the table. When values are provided, it expects
    to find the object in the database already and to update it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当@Id字段为null且@Version字段为0时，Spring Data JDBC假定它是一个新对象。因此，它依赖于数据库在向表中插入新行时生成标识符。当提供值时，它期望在数据库中找到该对象并更新它。
- en: Let’s go ahead and add two new fields to the Book record for the identifier
    and the version number. Since both fields are populated and handled by Spring
    Data JDBC under the hood, using the all-args constructor might be too verbose
    for situations such as generating test data. For convenience, let’s add a static
    factory method to the Book record for building an object by passing only the business
    fields.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加两个新字段到Book记录中，用于标识符和版本号。由于这两个字段都由Spring Data JDBC在底层填充和处理，使用全参数构造函数在生成测试数据等情况下可能过于冗长。为了方便，让我们在Book记录中添加一个静态工厂方法，通过仅传递业务字段来构建对象。
- en: Listing 5.4 Defining identifier and version for Book objects
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 定义Book对象的标识符和版本
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Identifies the field as the primary key for the entity
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将字段标识为主实体的主键
- en: ❷ The entity version number, which is used for optimistic locking
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 实体版本号，用于乐观锁定
- en: ❸ An entity is considered new when the ID is null and the version is 0.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当ID为null且版本为0时，实体被视为新实体。
- en: Note Spring Data JPA works with mutating objects, so you can’t use Java records.
    JPA entity classes must be marked with the @Entity annotation and expose a no-args
    constructor. JPA identifiers are annotated with @Id and @Version from the javax.persistence
    package instead of org.springframework.data.annotation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Spring Data JPA与可变对象一起工作，因此你不能使用Java记录。JPA实体类必须用@Entity注解标记并公开无参数构造函数。JPA标识符用javax.persistence包中的@Id和@Version注解，而不是org.springframework.data.annotation。
- en: After adding the new fields, we need to update a few classes using the Book
    constructor, which now requires passing values for id and version.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新字段后，我们需要使用Book构造函数更新几个类，现在该构造函数需要传递id和版本值。
- en: The BookService class contains the logic for updating books. Open it and change
    the editBookDetails() method to ensure the book identifiers and versions are correctly
    passed along when calling the data layer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: BookService类包含更新书籍的逻辑。打开它，并将editBookDetails()方法更改为确保在调用数据层时正确传递书籍标识符和版本。
- en: Listing 5.5 Including existing identifier and version on book updates
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 在书籍更新中包含现有的标识符和版本
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Uses the identifier of the existing book
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用现有书籍的标识符
- en: ❷ Uses the version of the existing book, which will be increased automatically
    if the update operation succeeds
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用现有书籍的版本，如果更新操作成功，版本将自动增加。
- en: In BookDataLoader, we can use the new static factory method for building Book
    objects. The framework will take care of handling the id and version fields.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在BookDataLoader中，我们可以使用新的静态工厂方法来构建Book对象。框架将负责处理id和版本字段。
- en: Listing 5.6 Using the static factory method when creating a book
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 在创建书籍时使用静态工厂方法
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The framework takes care of assigning a value for the identifier and the version
    under the hood.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 框架在底层负责为标识符和版本分配值。
- en: I’ll leave it to you to update the autotests similarly. You can also extend
    the tests in the BookJsonTests class to verify the serialization and deserialization
    of the new fields. As a reference, you can check Chapter05/05-intermediate/catalog-service
    in the code repository accompanying this book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我将更新自动测试的任务留给你。你还可以扩展BookJsonTests类中的测试以验证新字段的序列化和反序列化。作为参考，你可以在伴随本书的代码仓库中的Chapter05/05-intermediate/catalog-service中查看。
- en: As a persistent entity, the Book record will be automatically mapped to relational
    resources. Class and field names are transformed into lowercase, and the camel
    case is translated into words joined by underscores. The Book record will result
    in the book table, the title field will result in the title column, the price
    field will result in the price column, and so on. Figure 5.5 shows the mapping
    between the Java object and the relational table.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为持久化实体，Book记录将自动映射到关系资源。类和字段名称被转换为小写，驼峰式命名法被转换为由下划线连接的单词。Book记录将生成book表，title字段将生成title列，price字段将生成price列，等等。图5.5显示了Java对象与关系表之间的映射。
- en: '![05-05](../Images/05-05.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![05-05](../Images/05-05.png)'
- en: Figure 5.5 Java classes marked as persistent entities are automatically mapped
    by Spring Data JDBC to relational resources in the database.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 Java类标记为持久化实体，将由Spring Data JDBC自动映射到数据库中的关系资源。
- en: Creating the database schema
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据库模式
- en: The database must have a table defined (as shown in figure 5.5) for the mapping
    to work. Spring Data offers a feature to initialize a data source at startup time.
    By default, you can use a schema.sql file to create a schema and a data.sql file
    to insert data in the newly created tables. Such files should be placed in the
    src/main/resources folder.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库必须定义一个表（如图 5.5 所示），映射才能工作。Spring Data 提供了一个在启动时初始化数据源的功能。默认情况下，你可以使用 schema.sql
    文件来创建模式，并使用 data.sql 文件在新建的表中插入数据。这些文件应放置在 src/main/resources 文件夹中。
- en: That is a convenient feature, and it’s useful for demos and experiments. However,
    it’s too limited for use in production. As you’ll see later in the chapter, it’s
    better to create and evolve relational resources with a more sophisticated tool,
    like Flyway or Liquibase, which will let you version-control your database. For
    now we’ll use the built-in database initialization mechanism so that we can focus
    on the data layer implementation first.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的功能，对于演示和实验很有用。然而，在生产环境中使用它过于有限。正如你将在本章后面看到的那样，使用更复杂的工具（如 Flyway 或 Liquibase）创建和演进关系型资源会更好，这将允许你进行数据库版本控制。现在我们将使用内置的数据库初始化机制，以便我们首先关注数据层实现。
- en: Note Hibernate, the foundation for Spring Data JPA, offers an interesting feature
    for automatically generating schemas from the entities defined in Java. Once again,
    this is convenient for demos and experiments, but please think twice before using
    it in production.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Hibernate，Spring Data JPA 的基础，提供了一种从 Java 中定义的实体自动生成模式的有意思的功能。这再次方便了演示和实验，但在生产环境中使用之前请三思。
- en: In your Catalog Service project, add a new schema.sql file in the src/main/resources
    folder. Then write the SQL instructions to create the book table, which will be
    mapped to the Book record in Java.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Catalog Service 项目中，在 src/main/resources 文件夹中添加一个新的 schema.sql 文件。然后编写 SQL
    指令以创建书籍表，该表将映射到 Java 中的 Book 记录。
- en: Listing 5.7 Defining the SQL instructions to create the book table
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 定义创建书籍表的 SQL 指令
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Drops the book table if it already exists
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果书籍表已存在，则将其删除
- en: ❷ The primary key for the table. The database will generate it as a sequence
    of numbers (bigserial type).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表的主键。数据库将生成它作为一系列数字（bigserial 类型）。
- en: ❸ The UNIQUE constraint ensures that a particular ISBN is assigned only to one
    book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 唯一约束确保特定的 ISBN 只分配给一本书。
- en: ❹ The NOT NULL constraint ensures the related column is assigned a value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ NOT NULL 约束确保相关列被分配一个值。
- en: ❺ The entity version number, stored as an integer
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 实体版本号，以整数形式存储
- en: By default, Spring Data loads the schema.sql file only when using an embedded,
    in-memory database. Since we’re using PostgreSQL, we need to enable the functionality
    explicitly. In the application.yml file for your Catalog Service project, add
    the following configuration to initialize the database schema from the schema.sql
    file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Data 仅在使用嵌入式内存数据库时加载 schema.sql 文件。由于我们使用的是 PostgreSQL，我们需要显式启用此功能。在
    Catalog Service 项目的 application.yml 文件中，添加以下配置以从 schema.sql 文件初始化数据库模式。
- en: Listing 5.8 Initializing the database schema from an SQL script
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 从 SQL 脚本初始化数据库模式
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At startup, Spring Data will read the file and execute the SQL instructions
    in the PostgreSQL database to create a new book table and make it possible to
    start inserting data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，Spring Data 将读取该文件并在 PostgreSQL 数据库中执行 SQL 指令以创建一个新的书籍表，并使其能够开始插入数据。
- en: In the next section, you’ll make it possible to capture audit events related
    to the persistent entities and keep track of when each row has been inserted into
    the table and modified most recently.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将能够捕获与持久化实体相关的审计事件，并跟踪每一行何时被插入到表中以及最近一次的修改。
- en: 5.2.3 Enabling and configuring JDBC auditing
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 启用和配置 JDBC 审计
- en: When persisting data, it’s useful to know the creation date for each row in
    a table and the date when it was updated last. After securing an application with
    authentication and authorization, you can even register who created each entity
    and recently updated it. All of that is called *database auditing*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久化数据时，知道表中每一行的创建日期以及最后更新的日期很有用。在通过身份验证和授权确保应用程序安全后，你甚至可以记录每个实体是由谁创建的以及最近更新了它。所有这些统称为
    *数据库审计*。
- en: With Spring Data JDBC, you can enable auditing for all the persistent entities
    using the @EnableJdbcAuditing annotation on a configuration class. In the com
    .polarbookshop.catalogservice.config package, add a DataConfig class to gather
    JDBC-related configuration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Data JDBC，您可以通过在配置类上使用`@EnableJdbcAuditing`注解来为所有持久化实体启用审计。在`com.polarbookshop.catalogservice.config`包中，添加一个DataConfig类以收集JDBC相关配置。
- en: Listing 5.9 Enabling JDBC auditing via annotation configuration
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.9 通过注解配置启用JDBC审计
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Indicates a class as a source of Spring configuration
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指示一个类作为Spring配置的来源
- en: ❷ Enables auditing for persistent entities
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为持久化实体启用审计
- en: Note In Spring Data JPA, you would use the @EnableJpaAuditing annotation to
    enable JPA auditing, and you would annotate the entity class with @EntityListeners(AuditingEntityListener.class)
    to make it listen to audit events, which doesn’t happen automatically as in Spring
    Data JDBC.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Spring Data JPA中，您会使用`@EnableJpaAuditing`注解来启用JPA审计，并且您会使用`@EntityListeners(AuditingEntityListener.class)`注解实体类以使其监听审计事件，这与Spring
    Data JDBC中的自动监听不同。
- en: When this feature is enabled, audit events are generated whenever data is created,
    updated, or deleted. Spring Data provides convenient annotations (listed in table
    5.1) that we can use on dedicated fields to capture the information from such
    events (*audit metadata*) and store it in the database as part of the entity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当此功能启用时，每当数据被创建、更新或删除时，都会生成审计事件。Spring Data提供了方便的注解（如表5.1中列出），我们可以在专用字段上使用这些注解来捕获此类事件的信息（*审计元数据*），并将其作为实体的一部分存储在数据库中。
- en: Table 5.1 When database auditing is enabled, these annotations can be used on
    entity fields to capture audit metadata.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 当数据库审计启用时，这些注解可以用于实体字段以捕获审计元数据。
- en: '| Annotation | What it does on an entity field |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 在实体字段上执行的操作 |'
- en: '| @CreatedBy | Identifies the field representing the user that created the
    entity. It’s defined on creation and never changed. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| @CreatedBy | 识别表示创建实体的用户的字段。它在创建时定义，并且永远不会更改。|'
- en: '| @CreatedDate | Identifies the field representing when the entity was created.
    It’s defined on creation and never changed. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| @CreatedDate | 识别表示实体创建时间的字段。它在创建时定义，并且永远不会更改。|'
- en: '| @LastModifiedBy | Identifies the field representing the user that most recently
    modified the entity. It’s updated at every create or update operation. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| @LastModifiedBy | 识别表示最近修改实体的用户的字段。它在每次创建或更新操作时更新。|'
- en: '| @LastModifiedDate | Identifies the field representing when the entity was
    most recently modified. It’s updated at every create or update operation. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| @LastModifiedDate | 识别表示实体最后修改时间的字段。它在每次创建或更新操作时更新。|'
- en: In Catalog Service we can add the createdDate and lastModifiedDate fields to
    the Book record. In chapter 12, after introducing Spring Security, we’ll extend
    this object to also capture who created or updated the entity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录服务中，我们可以向书籍记录添加createdDate和lastModifiedDate字段。在第12章中，在介绍Spring Security之后，我们将扩展此对象以捕获谁创建了或更新了实体。
- en: Open the Book record, add the two new fields, and update the static factory
    method accordingly. They can be null when instantiating a new object because they
    will be populated by Spring Data under the hood.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开书籍记录，添加两个新字段，并相应地更新静态工厂方法。在实例化新对象时，它们可以是null，因为它们将由Spring Data在底层填充。
- en: Listing 5.10 Adding fields to store audit metadata in a persistent entity
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.10 向持久化实体添加存储审计元数据的字段
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ When the entity was created
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 实体创建的时间
- en: ❷ When the entity was last modified
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 实体最后修改的时间
- en: After extending the Book record, the BookService class needs to be updated one
    more time. Open it and change the editBookDetails() method to ensure the audit
    metadata is correctly passed along when calling the data layer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展书籍记录之后，BookService类需要再次更新。打开它，并更改editBookDetails()方法以确保在调用数据层时正确传递审计元数据。
- en: Listing 5.11 Including the existing audit metadata when updating a book
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11 在更新书籍时包含现有的审计元数据
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Uses the creation date of the existing book record
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用现有书籍记录的创建日期
- en: ❷ Uses the last modified date of the existing book record. It will be updated
    automatically by Spring Data if the operation succeeds.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用现有书籍记录的最后修改日期。如果操作成功，它将由Spring Data自动更新。
- en: Next, let’s update the schema.sql file to add the columns for the new fields
    to the book table.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新schema.sql文件，为书籍表添加新字段的列。
- en: Listing 5.12 Adding columns for audit metadata to the book table
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.12 向书籍表添加审计元数据列
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ When the entity was created (stored as a timestamp)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当实体被创建（存储为时间戳）
- en: ❷ When the entity was last modified (stored as a timestamp)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当实体最后被修改（存储为时间戳）
- en: I’ll leave it to you to update the autotests accordingly, when necessary. You
    can also extend the tests in BookJsonTests to verify the serialization and deserialization
    of the new fields. As a reference, you can check Chapter05/05-intermediate/catalog-service
    in the code repository accompanying this book.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把它留给你，在必要时更新自动测试。您还可以扩展BookJsonTests中的测试以验证新字段的序列化和反序列化。作为参考，您可以在伴随本书的代码仓库中检查Chapter05/05-intermediate/catalog-service。
- en: So far, you have got everything in place to map your Java objects to relational
    objects in a database, including audit metadata. You still need a way to access
    data from the database, though. That’s the subject of the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经将所有内容都设置好了，以便将Java对象映射到数据库中的关系对象，包括审计元数据。尽管如此，您仍然需要一种从数据库访问数据的方法。这就是下一节的主题。
- en: 5.2.4 Data repositories with Spring Data
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 使用Spring Data的数据仓库
- en: The *repository* pattern provides an abstraction for accessing data independently
    of its source. The BookRepository interface used by BookService is an example
    of a repository. The domain layer, which contains the business logic, doesn’t
    need to know where the data comes from, as long as it gets access. In chapter
    3, we added an implementation of the repository interface to store data in memory.
    Now that we’re building the persistence layer, we’ll need a different implementation
    to access data from PostgreSQL.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*仓库*模式提供了一种访问数据而不依赖于其来源的抽象。BookService使用的BookRepository接口是一个仓库的例子。包含业务逻辑的领域层不需要知道数据来自哪里，只要它能访问即可。在第3章中，我们添加了一个仓库接口的实现，用于在内存中存储数据。现在，在构建持久化层时，我们需要一个不同的实现来从PostgreSQL访问数据。'
- en: The good news is that we can use Spring Data repositories, a technical solution
    that provides access to data from a data store independently of the specific persistence
    technology used. It’s one of the most valuable features of Spring Data, because
    we can use the same repository abstraction in any persistence scenario, whether
    relational or non-relational.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们可以使用Spring Data仓库，这是一种技术解决方案，它提供了从数据存储中访问数据的功能，而不依赖于所使用的特定持久化技术。这是Spring
    Data最有价值的特性之一，因为我们可以在任何持久化场景中使用相同的仓库抽象，无论是关系型还是非关系型。
- en: Using a data repository
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据仓库
- en: When using Spring Data repositories, your responsibility is limited to defining
    an interface. At startup time, Spring Data will generate an implementation for
    your interface on the fly. In the Catalog Service project (catalog-service), go
    ahead and delete the InMemoryBookRepository class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Spring Data仓库时，您的责任仅限于定义一个接口。在启动时，Spring Data将动态为您生成接口的实现。在Catalog Service项目（catalog-service）中，请继续删除InMemoryBookRepository类。
- en: Let’s now see how we can refactor the BookRepository interface from the Catalog
    Service project. First, it should extend one of the available Repository interfaces
    provided by Spring Data. Most Spring Data modules add Repository implementations
    specific to the data source supported. The Catalog Service application requires
    standard CRUD operations on Book objects, so you can make the BookRepository interface
    extend from CrudRepository.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看我们如何从Catalog Service项目重构BookRepository接口。首先，它应该扩展Spring Data提供的可用仓库接口之一。大多数Spring
    Data模块添加了针对支持的数据源特定的Repository实现。Catalog Service应用程序需要对Book对象执行标准CRUD操作，因此您可以让BookRepository接口扩展自CrudRepository。
- en: CrudRepository provides methods to perform CRUD operations, including save()
    and findAll(), so you can remove their explicit declarations from your interface.
    The default methods defined by CrudRepository for Book objects are based on their
    @Id-annotated fields. Since the application needs to access books based on the
    ISBN, we must explicitly declare those operations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: CrudRepository提供了执行CRUD操作的方法，包括save()和findAll()，因此您可以从接口中删除它们的显式声明。CrudRepository为Book对象定义的默认方法基于它们的@Id注解字段。由于应用程序需要根据ISBN访问书籍，我们必须显式声明这些操作。
- en: Listing 5.13 Repository interface for accessing books
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.13 访问书籍的仓库接口
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Extends a repository providing CRUD operations, specifying the type of managed
    entity (Book) and its primary key type (Long)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 扩展提供CRUD操作的仓库，指定管理实体的类型（Book）及其主键类型（Long）
- en: ❷ Methods implemented by Spring Data at runtime
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Spring Data在运行时实现的方法
- en: ❸ Identifies an operation that will modify the database state
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 识别一个将修改数据库状态的操作
- en: ❹ Declares the query that Spring Data will use to implement the method
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 声明Spring Data将用于实现该方法的查询
- en: 'At startup time, Spring Data will provide an implementation for BookRepository
    with all the most common CRUD operations and the methods you declared in the interface.
    There are two main options for defining custom queries in Spring Data:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，Spring Data将为BookRepository提供一个实现，包括所有最常用的CRUD操作和您在接口中声明的方法。在Spring Data中定义自定义查询有两个主要选项：
- en: Using the @Query annotation to provide an SQL-like statement that will be executed
    by the method.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用@Query注解提供一个将被方法执行的类似SQL的语句。
- en: Defining query methods following a specific naming convention, as described
    in the official documentation ([https://spring.io/projects/spring-data](https://spring.io/projects/spring-data)).
    Generally, you can build a method name by combining multiple pieces, as described
    in table 5.2\. At the time of writing, Spring Data JDBC supports this option only
    for read operations. On the other hand, Spring Data JPA provides full support
    for it.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照官方文档中描述的特定命名约定定义查询方法（[https://spring.io/projects/spring-data](https://spring.io/projects/spring-data)）。通常，您可以通过将多个部分组合起来构建方法名，如表5.2中所述。在撰写本文时，Spring
    Data JDBC仅支持此选项用于读取操作。另一方面，Spring Data JPA提供了对此的全面支持。
- en: Table 5.2 You can add custom queries to a repository and have Spring Data generate
    implementations for you by following a specific naming convention comprising these
    building blocks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 您可以通过遵循特定的命名约定，包括以下构建块，将自定义查询添加到存储库，并让Spring Data为您生成实现。
- en: '| Repository method building block | Examples |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 存储库方法构建块 | 示例 |'
- en: '| Action | find, exists, delete, count |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | find, exists, delete, count |'
- en: '| Limit | One, All, First10 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 限制 | One, All, First10 |'
- en: '| - | By |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| - | 由 |'
- en: '| Property expression | findByIsbn, findByTitleAndAuthor, findByAuthorOrPrice
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 属性表达式 | findByIsbn, findByTitleAndAuthor, findByAuthorOrPrice |'
- en: '| Comparison | findByTitleContaining, findByIsbnEndingWith, findByPriceLessThan
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | findByTitleContaining, findByIsbnEndingWith, findByPriceLessThan |'
- en: '| Ordering operator | orderByTitleAsc, orderByTitleDesc |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 排序运算符 | orderByTitleAsc, orderByTitleDesc |'
- en: Using some of the methods provided by the CrudRepository interface and inherited
    by BookRepository, we can improve the BookDataLoader class so that we start with
    an empty database during development and create books with a single command.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用由CrudRepository接口提供并由BookRepository继承的一些方法，我们可以改进BookDataLoader类，以便在开发时从一个空数据库开始，并通过单个命令创建书籍。
- en: Listing 5.14 Using Spring Data methods to delete and save books
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.14 使用Spring Data方法删除和保存书籍
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Deletes all existing books, if any, to start from an empty database
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果存在，删除所有现有书籍，以便从一个空数据库开始
- en: ❷ Saves multiple objects at once
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一次性保存多个对象
- en: Defining transactional contexts
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 定义事务上下文
- en: The repositories provided by Spring Data come configured with transactional
    contexts for all the operations. For example, all methods in CrudRepository are
    transactional. That means you can safely call the saveAll() method, knowing that
    it will be executed in a transaction.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供的存储库为所有操作配置了事务上下文。例如，CrudRepository中的所有方法都是事务性的。这意味着您可以安全地调用saveAll()方法，知道它将在事务中执行。
- en: When you add your own query methods, as you did for BookRepository, it’s up
    to you to define which ones should be part of a transaction. You can rely on the
    declarative transaction management provided by the Spring Framework and use the
    @Transactional annotation (from the org.springframework.transaction.annotation
    package) on classes or methods to ensure they are executed as part of a single
    *unit of work*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加自己的查询方法时，就像您为BookRepository所做的那样，您需要定义哪些方法应该包含在事务中。您可以使用Spring框架提供的声明性事务管理，并在类或方法上使用@Transactional注解（来自org.springframework.transaction.annotation包）来确保它们作为单个*工作单元*的一部分执行。
- en: Among the custom methods you defined in BookRepository, deleteByIsbn() is a
    good candidate for being transactional, since it modifies the database state.
    You can ensure it runs in a transaction by applying the @Transactional annotation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在BookRepository中定义的自定义方法中，deleteByIsbn()是一个很好的候选事务方法，因为它修改了数据库状态。您可以通过应用@Transactional注解来确保它在事务中运行。
- en: Listing 5.15 Defining transactional operations
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.15 定义事务性操作
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Identifies the method to be executed in a transaction
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别要执行的事务中要执行的方法
- en: Note For more information about the declarative transaction management provided
    by Spring Framework, you can refer to the official documentation ([https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关 Spring 框架提供的声明式事务管理的信息，您可以参考官方文档([https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework))。
- en: Great job! You successfully added data persistence capabilities to the Catalog
    Service application. Let’s verify that it works correctly. First of all, make
    sure the PostgreSQL container is still running. If not, run it as described at
    the beginning of this chapter. Then start the application (./gradlew bootRun),
    send HTTP requests to each REST endpoint, and ensure it works as expected. When
    you’re done, remove the database container (docker rm -fv polar-postgres) and
    stop the application (Ctrl-C).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你成功地为目录服务应用程序添加了数据持久性功能。让我们验证它是否正常工作。首先，确保 PostgreSQL 容器仍在运行。如果不是，按照本章开头描述的方式运行它。然后启动应用程序（./gradlew
    bootRun），向每个 REST 端点发送 HTTP 请求，并确保它按预期工作。完成后，删除数据库容器（docker rm -fv polar-postgres）并停止应用程序（Ctrl-C）。
- en: Tip In the repository accompanying the book, you will find useful commands for
    querying the PostgreSQL database directly and verifying schemas and data generated
    by the application (Chapter05/05-intermediate/catalog-service/README.md).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在本书的配套仓库中，你可以找到用于直接查询 PostgreSQL 数据库以及验证应用程序生成的模式和数据的实用命令（Chapter05/05-intermediate/catalog-service/README.md）。
- en: Manual verification of data persistence is fine, but automated verification
    is better. That’s what the next section is all about.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 手动验证数据持久性是可以的，但自动验证更好。这正是下一节要讨论的内容。
- en: 5.3 Testing data persistence with Spring and Testcontainers
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 使用 Spring 和 Testcontainers 测试数据持久性
- en: In the previous sections, we added data persistence functionality to an application
    by developing against a PostgreSQL database in a container, which is the same
    technology used in production. That was a good step toward the environment parity
    recommended by the 15-Factor methodology. Keeping all environments as similar
    as possible improves the quality of the project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过在一个容器中针对 PostgreSQL 数据库开发，为应用程序添加了数据持久性功能，这是在生产环境中使用的技术。这是朝着 15-Factor
    方法论推荐的环境一致性迈出的良好一步。尽可能保持所有环境相似性，可以提高项目的质量。
- en: Data sources are one of the primary causes of differences across environments.
    It’s common practice to use an in-memory database while developing locally—something
    like H2 or HSQL. But that affects the predictability and robustness of your applications.
    Even if all relational databases speak the SQL language and Spring Data JDBC provides
    generic abstractions, each vendor has its own dialect and unique features that
    make it essential to use the same database in production that you use in development
    and testing. Otherwise, you may not catch errors that might happen only in production.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源是导致环境之间差异的主要原因之一。在本地开发时使用内存数据库是一种常见的做法——比如 H2 或 HSQL。但这会影响你应用程序的可预测性和健壮性。即使所有关系型数据库都使用
    SQL 语言，Spring Data JDBC 也提供了通用抽象，但每个供应商都有自己的方言和独特功能，这使得在生产环境中使用与开发和测试中相同的数据库变得至关重要。否则，你可能无法捕捉到仅在生产中可能发生的错误。
- en: “What about testing?” you might ask. That is an excellent question. Another
    reason for using in-memory databases is to make integration tests more accessible.
    However, integration tests are also supposed to test the integration with your
    application’s external services. Using something like H2 makes those tests less
    reliable. Each commit should be a candidate for release when adopting a continuous
    delivery approach. Suppose the autotests run by the deployment pipeline are not
    using the same backing services used in production. In that case, you’ll need
    to do extra manual testing before deploying the application safely in production
    because you can’t be sure it will work correctly. Therefore, it’s essential to
    reduce the gap between environments.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: “那关于测试呢？”你可能会问。这是一个非常好的问题。使用内存数据库的另一个原因是使集成测试更容易进行。然而，集成测试也应当测试与你的应用程序外部服务的集成。使用类似
    H2 的工具会使这些测试变得不那么可靠。在采用持续交付方法时，每个提交都应当是发布候选。假设部署管道中运行的自动测试没有使用与生产中相同的后端服务。在这种情况下，在安全地将应用程序部署到生产之前，你需要进行额外的手动测试，因为你无法确定它是否能够正确工作。因此，减少环境之间的差距至关重要。
- en: Docker makes it easier to set up and develop applications with an actual database
    locally, as you experienced with PostgreSQL. In a similar way, Testcontainers
    (a Java library for testing) makes it easy to use backing services as containers
    in the context of integration tests.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使您能够更容易地设置和开发使用实际数据库的应用程序，就像您使用 PostgreSQL 时的体验一样。以类似的方式，Testcontainers（一个用于测试的
    Java 库）使您能够在集成测试的上下文中轻松使用支持服务作为容器。
- en: This section will show you how to write slice tests for the data persistence
    layer using the @DataJdbcTest annotation and include a database in integration
    tests using the @SpringBootTest annotation. In both cases, you’ll rely on Testcontainers
    to run the autotests against an actual PostgreSQL database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何使用 @DataJdbcTest 注解编写数据持久层的切片测试，并使用 @SpringBootTest 注解在集成测试中包含数据库。在这两种情况下，您都将依赖
    Testcontainers 来运行针对实际 PostgreSQL 数据库的自动测试。
- en: 5.3.1 Configuring Testcontainers for PostgreSQL
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 为 PostgreSQL 配置 Testcontainers
- en: Testcontainers ([https://testcontainers.org](https://testcontainers.org)) is
    a Java library for testing. It supports JUnit and provides lightweight, throwaway
    containers such as databases, message brokers, and web servers. It’s perfect for
    implementing integration tests with the actual backing services used in production.
    The result is more reliable and stable tests, which lead to higher-quality applications
    and favor continuous delivery practices.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Testcontainers ([https://testcontainers.org](https://testcontainers.org)) 是一个用于测试的
    Java 库。它支持 JUnit，并提供轻量级、一次性容器，如数据库、消息代理和 Web 服务器。它非常适合实现使用生产中实际使用的支持服务的集成测试。结果是更可靠和稳定的测试，这有助于提高应用程序的质量，并有利于持续交付实践。
- en: You can configure a lightweight PostgreSQL container with Testcontainers and
    use it in your autotests involving a data persistence layer. Let’s see how it
    works.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Testcontainers 配置一个轻量级的 PostgreSQL 容器，并在涉及数据持久层的自动测试中使用它。让我们看看它是如何工作的。
- en: First, you need to add a dependency on the Testcontainers module for PostgreSQL
    in the build.gradle file of your Catalog Service project. Remember to refresh
    or reimport the Gradle dependencies after the new addition.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在 Catalog Service 项目的 build.gradle 文件中添加对 Testcontainers PostgreSQL 模块的依赖。记得在添加新依赖后刷新或重新导入
    Gradle 依赖。
- en: Listing 5.16 Adding dependency on Testcontainers in Catalog Service
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 在 Catalog Service 中添加 Testcontainers 依赖
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Defines the Testcontainers version to use
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义要使用的 Testcontainers 版本
- en: ❷ Provides container management features for PostgreSQL databases
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为 PostgreSQL 数据库提供容器管理功能
- en: ❸ BOM (bill of materials) for Testcontainers dependency management
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Testcontainers 依赖管理 BOM（物料清单）
- en: When running tests, we want the application to use a PostgreSQL instance provided
    by Testcontainers rather than the one we configured earlier via the spring.datasource
    .url property. We can overwrite that value in a new application-integration.yml
    file created under src/test/resources. Any property defined in this file will
    take precedence over the main one when the integration profile is enabled. In
    this case, we’ll overwrite the value for spring.datasource.url following a format
    defined by Testcontainers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试时，我们希望应用程序使用 Testcontainers 提供的 PostgreSQL 实例，而不是我们之前通过 spring.datasource.url
    属性配置的那个实例。我们可以在 src/test/resources 下创建一个新的 application-integration.yml 文件中覆盖该值。当集成配置文件启用时，在此文件中定义的任何属性都将优先于主属性。在这种情况下，我们将按照
    Testcontainers 定义的格式覆盖 spring.datasource.url 的值。
- en: Create a new application-integration.yml file in src/test/resources, and add
    the following configuration.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 src/test/resources 中创建一个新的 application-integration.yml 文件，并添加以下配置。
- en: Listing 5.17 Using a PostgreSQL data source provided by Testcontainers
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.17 使用 Testcontainers 提供的 PostgreSQL 数据源
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Identifies the PostgreSQL module in Testcontainers. “14.4” is the version
    of PostgreSQL to use.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Testcontainers 中标识 PostgreSQL 模块。“14.4”是使用的 PostgreSQL 版本。
- en: That’s all we need to configure Testcontainers. When the integration profile
    is enabled, Spring Boot will use the PostgreSQL container instantiated by Testcontainers.
    We’re now ready to write autotests to verify the data persistence layer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要配置 Testcontainers 的所有内容。当集成配置文件启用时，Spring Boot 将使用 Testcontainers 实例化的
    PostgreSQL 容器。我们现在可以编写自动测试来验证数据持久层了。
- en: 5.3.2 Testing data persistence with @DataJdbcTest and Testcontainers
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 使用 @DataJdbcTest 和 Testcontainers 测试数据持久性
- en: As you might recall from chapter 3, Spring Boot allows you to run integration
    tests by loading only the Spring components used by a specific application slice
    (*slice tests*). In Catalog Service, we created tests for the MVC and the JSON
    slices. Now I’ll show you how to write tests for the data slice.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在第 3 章中可能记得的，Spring Boot 允许您通过仅加载特定应用程序切片（*切片测试*）使用的 Spring 组件来运行集成测试。在 Catalog
    Service 中，我们创建了 MVC 和 JSON 切片的测试。现在我将向您展示如何编写数据切片的测试。
- en: Create a BookRepositoryJdbcTests class, and mark it with the @DataJdbcTest annotation.
    That will trigger Spring Boot to include all Spring Data JDBC entities and repositories
    in the application context. It will also auto-configure JdbcAggregateTemplate,
    a lower-level object we can use to set up the context for each test case instead
    of using the repository (the object under testing).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 BookRepositoryJdbcTests 类，并用 @DataJdbcTest 注解标记它。这将触发 Spring Boot 将所有 Spring
    Data JDBC 实体和存储库包含在应用程序上下文中。它还将自动配置 JdbcAggregateTemplate，这是一个我们可以用来为每个测试用例设置上下文的更低级别的对象，而不是使用存储库（被测试的对象）。
- en: Listing 5.18 Integration tests for the Data JDBC slice
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.18 数据 JDBC 切片集成测试
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Identifies a test class that focuses on Spring Data JDBC components
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别一个专注于 Spring Data JDBC 组件的测试类
- en: ❷ Imports the data configuration (needed to enable auditing)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入数据配置（需要启用审计）
- en: ❸ Disables the default behavior of relying on an embedded test database since
    we want to use Testcontainers
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 禁用默认的依赖嵌入式测试数据库的行为，因为我们想使用 Testcontainers
- en: ❹ Enables the “integration” profile to load configuration from application-integration.yml
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 启用“集成”配置文件从 application-integration.yml 加载配置
- en: ❺ A lower-level object to interact with the database
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一个用于与数据库交互的更低级别的对象
- en: ❻ JdbcAggregateTemplate is used to prepare the data targeted by the test.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用 JdbcAggregateTemplate 准备测试目标的数据。
- en: The @DataJdbcTest annotation encapsulates handy features. For example, it makes
    each test method run in a transaction and rolls it back at its end, keeping the
    database clean. After running the test method in listing 5.18, the database will
    not contain the book created in findBookByIsbnWhenExisting() because the transaction
    is rolled back at the end of the method’s execution.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '@DataJdbcTest 注解封装了便捷的功能。例如，它使每个测试方法都在事务中运行，并在方法执行结束时回滚，以保持数据库的清洁。在运行列表 5.18
    中的测试方法后，数据库将不会包含 findBookByIsbnWhenExisting() 中创建的书籍，因为事务在方法执行结束时回滚。'
- en: Let’s verify that the Testcontainers configuration works. First, make sure the
    Docker Engine is running in your local environment. Then open a Terminal window,
    navigate to the root folder of your Catalog Service project, and run the following
    command to ensure the tests are successful. Under the hood, Testcontainers will
    create a PostgreSQL container before the test’s execution and remove it at the
    end.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证 Testcontainers 配置是否正常工作。首先，确保 Docker 引擎在您的本地环境中正在运行。然后打开一个终端窗口，导航到 Catalog
    Service 项目的根目录，并运行以下命令以确保测试成功。在底层，Testcontainers 将在测试执行之前创建一个 PostgreSQL 容器，并在测试结束时将其删除。
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the code repository accompanying the book, you can find more examples of
    unit and integration tests for the Catalog Service project. The following section
    will cover how to run full integration tests with Testcontainers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在与本书配套的代码仓库中，您可以找到更多 Catalog Service 项目的单元和集成测试示例。下一节将介绍如何使用 Testcontainers
    运行完整的集成测试。
- en: 5.3.3 Integration tests with @SpringBootTest and Testcontainers
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 使用 @SpringBootTest 和 Testcontainers 的集成测试
- en: In the Catalog Service application, we already have a CatalogServiceApplicationTests
    class annotated with @SpringBootTest and containing full integration tests. The
    Testcontainers configuration we defined earlier applies to all autotests for which
    the integration profile is enabled, so we need to add the profile configuration
    to the CatalogServiceApplicationTests class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Catalog Service 应用程序中，我们已经有了一个带有 @SpringBootTest 注解的 CatalogServiceApplicationTests
    类，其中包含完整的集成测试。我们之前定义的 Testcontainers 配置适用于所有启用集成配置文件的自动测试，因此我们需要将配置文件添加到 CatalogServiceApplicationTests
    类中。
- en: Listing 5.19 Enabling integration profile for the integration tests
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.19 启用集成配置文件以进行集成测试
- en: '[PRE20]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Enables the “integration” profile to load configuration from application-integration.yml
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 启用“集成”配置文件从 application-integration.yml 加载配置
- en: Open a Terminal window, navigate to the root folder of your Catalog Service
    project, and run the following command to ensure the tests are successful. Under
    the hood, Testcontainers will create a PostgreSQL container before the test’s
    execution and remove it at the end.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到您的 Catalog Service 项目根目录，并运行以下命令以确保测试成功。在底层，Testcontainers 会在测试执行前创建一个
    PostgreSQL 容器，并在测试结束后将其删除。
- en: '[PRE21]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Good job! You have added data persistence to a Spring Boot application and written
    tests while ensuring environment parity. Let’s move on and complete this chapter
    by discussing how to manage schemas and data in production.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已经为 Spring Boot 应用程序添加了数据持久性，并编写了测试，同时确保了环境一致性。让我们继续前进，通过讨论如何在生产中管理模式和数据进行本章的完成。
- en: 5.4 Managing databases in production with Flyway
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 使用 Flyway 在生产中管理数据库
- en: It’s good practice to register any database changes, just like you do for your
    application source code through version control. You’ll need a deterministic and
    automated way to infer the database’s state, whether specific changes have already
    been applied, how to recreate a database from scratch, and how to migrate it in
    a controlled, repeatable, and reliable way. The continuous delivery approach encourages
    automating as much as possible, including database management.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 记录任何数据库变更是一个好习惯，就像您通过版本控制为您的应用程序源代码做的那样。您需要一个确定性和自动化的方式来推断数据库的状态，即是否已经应用了特定的变更，如何从头开始重新创建数据库，以及如何以受控、可重复和可靠的方式进行迁移。持续交付方法鼓励尽可能自动化，包括数据库管理。
- en: In the Java ecosystem, the two most-used tools for tracking, versioning, and
    deploying database changes are Flyway ([https://flywaydb.org](https://flywaydb.org))
    and Liquibase ([https://liquibase.org](https://liquibase.org)). Both of them are
    fully integrated with Spring Boot. This section will show you how to use Flyway.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 生态系统中，用于跟踪、版本控制和部署数据库变更的两个最常用的工具是 Flyway ([https://flywaydb.org](https://flywaydb.org))
    和 Liquibase ([https://liquibase.org](https://liquibase.org))。它们都完全集成到 Spring Boot
    中。本节将向您展示如何使用 Flyway。
- en: '5.4.1 Understanding Flyway: Version control for your database'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 理解 Flyway：数据库的版本控制
- en: Flyway is a tool that provides version control for your database. It offers
    a single source of truth for the version of your database’s state and keeps track
    of any changes incrementally. It automates changes and lets you reproduce or roll
    back the state of a database. Flyway is highly reliable, safe to use in cluster
    environments, and supports several relational databases, including the cloud ones
    like Amazon RDS, Azure Database, and Google Cloud SQL.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway 是一个提供数据库版本控制的工具。它为数据库的状态版本提供了一个单一的事实来源，并按增量跟踪任何变更。它自动化变更，并允许您重现或回滚数据库的状态。Flyway
    非常可靠，在集群环境中安全使用，并支持包括 Amazon RDS、Azure Database 和 Google Cloud SQL 在内的多个关系数据库。
- en: Note In this section, I will introduce some features offered by Flyway, but
    I recommend you check the official documentation to discover all the powerful
    possibilities provided by this tool ([https://flywaydb.org](https://flywaydb.org)).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本节中，我将介绍 Flyway 提供的一些功能，但我建议您查看官方文档以发现该工具提供的所有强大功能（[https://flywaydb.org](https://flywaydb.org)）。
- en: At its core, Flyway manages database changes. Any database change is called
    a *migration*, and migrations can be either *versioned* or *repeatable*. Versioned
    migrations are identified by a unique version number and are applied in order
    exactly once. For each *regular* versioned migration, you can also provide an
    optional *undo* migration to revert its effects (in case something goes wrong).
    They can be used to create, alter, or drop relational objects like schemas, tables,
    columns, and sequences or to correct data. On the other hand, repeatable migrations
    are applied every time their checksum changes. They can be used for creating or
    updating views, procedures, and packages.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway 的核心功能是管理数据库变更。任何数据库变更都被称为 *迁移*，迁移可以是 *版本化的* 或 *可重复的*。版本化迁移通过唯一的版本号进行标识，并且按照顺序恰好应用一次。对于每个
    *常规* 版本化迁移，你还可以提供一个可选的 *撤销* 迁移来撤销其影响（以防出现错误）。它们可以用来创建、修改或删除关系对象，如模式、表、列和序列，或者用于修正数据。另一方面，可重复迁移每次其校验和发生变化时都会应用。它们可以用来创建或更新视图、过程和包。
- en: Both types of migration can be defined in standard SQL scripts (useful for DDL
    changes) or Java classes (useful for DML changes, like data migrations). Flyway
    keeps track of which migrations have already been applied through a flyway_schema_history
    table automatically created in the database the first time it runs. You can picture
    migrations as commits in a Git repository and the schema history table as the
    repository log containing the list of all the commits applied over time (figure
    5.6).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的迁移都可以在标准SQL脚本（用于DDL更改）或Java类（用于DML更改，如数据迁移）中定义。Flyway通过在第一次运行时自动创建在数据库中的flyway_schema_history表来跟踪哪些迁移已经被应用。你可以将迁移想象成Git仓库中的提交，而模式历史表则是包含随时间应用的所有提交列表的仓库日志（图5.6）。
- en: '![05-06](../Images/05-06.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![05-06](../Images/05-06.png)'
- en: Figure 5.6 Flyway migrations represent database changes that can be pictured
    as commits in a Git repository.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 Flyway迁移表示数据库更改，这些更改可以想象成Git仓库中的提交。
- en: Note A prerequisite for using Flyway is that both the database you want to manage
    and a user with the correct access privileges exist. Once you have a database
    and a user, Flyway can manage database changes for you. You shouldn’t use Flyway
    to manage users.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用Flyway的前提是你要管理的数据库以及具有正确访问权限的用户都存在。一旦你有了数据库和用户，Flyway就可以为你管理数据库更改。你不应该使用Flyway来管理用户。
- en: You can use Flyway in standalone mode or embedded in a Java application. Spring
    Boot provides auto-configuration for it, making it very convenient to include
    Flyway in your applications. When integrated with Spring Boot, Flyway will search
    for SQL migrations in the src/main/resources/db/migration folder and Java migrations
    in src/main/java/db/migration.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Flyway的独立模式或将其嵌入到Java应用程序中。Spring Boot为其提供了自动配置，使得在应用程序中包含Flyway变得非常方便。当与Spring
    Boot集成时，Flyway将在src/main/resources/db/migration文件夹中查找SQL迁移，并在src/main/java/db/migration中查找Java迁移。
- en: Running schema and data migrations is one of those administrative processes
    described by the 15-Factor methodology introduced in chapter 2\. In this case,
    the strategy adopted for managing such a process was to embed it in the application
    itself. By default, it’s activated during the application startup phase. Let’s
    see how we can implement it for Catalog Service.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 运行模式和数据迁移是第2章中介绍的15-Factor方法论所描述的行政流程之一。在这种情况下，管理此类流程的策略是将它嵌入到应用程序本身中。默认情况下，它在应用程序启动阶段被激活。让我们看看我们如何为目录服务实现它。
- en: Open your Catalog Service project (catalog-service) and add a dependency on
    Flyway in the build.gradle file. Remember to refresh or reimport the Gradle dependencies
    after the addition.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的目录服务项目（catalog-service），并在build.gradle文件中添加Flyway依赖。记得在添加后刷新或重新导入Gradle依赖。
- en: Listing 5.20 Adding a dependency on Flyway in Catalog Service
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.20 在目录服务中添加Flyway依赖
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the next section, you’ll learn how to create your first migration to initialize
    the database schema.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何创建你的第一个迁移来初始化数据库模式。
- en: 5.4.2 Initializing a database schema with Flyway
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 使用Flyway初始化数据库模式
- en: The first database change you’ll apply is usually to initialize the schema.
    So far we’ve been relying on the built-in data source initialization capabilities
    offered by Spring Boot and providing a schema.sql file with the SQL statements
    to run. Now we can initialize the schema using an SQL Flyway migration.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你将应用的第一项数据库更改通常是初始化模式。到目前为止，我们一直依赖于Spring Boot提供的内置数据源初始化功能，并提供一个包含要运行的SQL语句的schema.sql文件。现在我们可以使用SQL
    Flyway迁移来初始化模式。
- en: First, delete the schema.sql file and remove the spring.sql.init.mode property
    from the application.yml file in your Catalog Service project.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除schema.sql文件，并从你的目录服务项目中的应用.yml文件中移除spring.sql.init.mode属性。
- en: Next, create a src/main/resources/db/migration folder. That’s where Flyway will
    look for SQL migrations by default. Inside the folder, create a V1__Initial_schema.sql
    file, which will contain the SQL statement for initializing the database schema
    required by the Catalog Service application. Ensure you type two underscores after
    the version number.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个src/main/resources/db/migration文件夹。这是Flyway默认查找SQL迁移的地方。在文件夹内，创建一个V1__Initial_schema.sql文件，该文件将包含目录服务应用程序所需的初始化数据库模式的SQL语句。确保在版本号后输入两个下划线。
- en: 'Flyway expects SQL migration files to comply with a specific naming pattern.
    Regular versioned migrations should follow this structure:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway期望SQL迁移文件遵循特定的命名模式。常规版本化迁移应遵循以下结构：
- en: '*Prefix*—V for versioned migrations'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前缀*—V表示版本化迁移'
- en: '*Version*—Version number using dots or underscores to separate it into multiple
    parts (e.g., 2.0.1)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版本*——使用点或下划线分隔的版本号（例如，2.0.1）'
- en: '*Separator*—Two underscores: __'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分隔符*——两个下划线：__'
- en: '*Description*—Words separated by underscores'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*——用下划线分隔的单词'
- en: '*Suffix*—.sql'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后缀*——.sql'
- en: In the V1__Initial_schema.sql migration script, you can include the SQL instructions
    to create a book table that Spring Boot JDBC will map to the Book persistent entity.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 V1__Initial_schema.sql 迁移脚本中，您可以包含创建书籍表的 SQL 指令，该表将由 Spring Boot JDBC 映射到
    Book 持久实体。
- en: Listing 5.21 Flyway migration script for schema initialization
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.21 初始化模式的 Flyway 迁移脚本
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Definition of the book table
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 书籍表的定义
- en: ❷ Declares the id field as the primary key
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 id 字段声明为主键
- en: ❸ Constrains the isbn field to be unique
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 isbn 字段约束为唯一
- en: When you let Flyway manage changes to the database schema, you gain all the
    benefits of version control. You can now start a new PostgreSQL container following
    the instructions provided in section 5.1.2 (if you still have the previous one
    running, remove it with docker rm -fv polar-postgres), run the application (./gradlew
    bootRun), and verify that everything works correctly.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当您让 Flyway 管理数据库模式变更时，您将获得版本控制的所有好处。现在，您可以按照 5.1.2 节中提供的说明启动一个新的 PostgreSQL
    容器（如果之前还在运行，请使用 docker rm -fv polar-postgres 删除它），运行应用程序（./gradlew bootRun），并验证一切是否正常工作。
- en: Note In the repository accompanying the book, you can find useful commands to
    query the PostgreSQL database directly and verify the schemas and data generated
    by Flyway (Chapter05/05-end/catalog-service/README.md).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在伴随书籍的仓库中，您可以找到查询 PostgreSQL 数据库并验证 Flyway 生成的模式和数据的实用命令（Chapter05/05-end/catalog-service/README.md）。
- en: Your autotests will also use Flyway. Go ahead and run them; they should all
    succeed. Once you’re done, push your changes to your remote Git repository, and
    check the commit stage results from GitHub Actions. They should be successful
    as well. Finally, stop the application execution (Ctrl-C) and the PostgreSQL container
    (docker rm -fv polar-postgres).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您的自动测试也将使用 Flyway。继续运行它们；它们都应该成功。完成后，将您的更改推送到远程 Git 仓库，并检查 GitHub Actions 的提交阶段结果。它们也应该成功。最后，停止应用程序执行（Ctrl-C）和
    PostgreSQL 容器（docker rm -fv polar-postgres）。
- en: In the final section, you’ll learn how to use Flyway migrations to evolve a
    database.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，您将学习如何使用 Flyway 迁移来演进数据库。
- en: 5.4.3 Evolving a database with Flyway
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 使用 Flyway 演进数据库
- en: 'Imagine that you completed the Catalog Service application and deployed it
    to production. Employees of the bookshop have started adding books to the catalog
    and gathered feedback about the application. The result is a new requirement for
    the catalog’s functionality: it should provide information about the book publisher.
    How can you do that?'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经完成了 Catalog Service 应用程序并将其部署到生产环境中。书店的员工已经开始向目录中添加书籍并收集关于应用程序的反馈。结果是目录功能的新需求：它应该提供关于书籍出版者的信息。您该如何做到这一点？
- en: Since the application is already in production and some data has already been
    created, you can use Flyway to apply a new database change, altering the book
    table to add a new publisher column. Create a new V2__Add_publisher_column.sql
    file in the src/main/resources/db/migration folder of your Catalog Service project,
    and add the following SQL instruction to add the new column.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序已经在生产中，并且已经创建了一些数据，您可以使用 Flyway 应用新的数据库变更，修改书籍表以添加新的出版者列。在您的 Catalog Service
    项目 src/main/resources/db/migration 文件夹中创建一个新的 V2__Add_publisher_column.sql 文件，并添加以下
    SQL 指令以添加新列。
- en: Listing 5.22 Flyway migration script for updating a table schema
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.22 更新表模式的 Flyway 迁移脚本
- en: '[PRE24]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then update the Book Java record accordingly. The change should take into account
    that, in production, there are already books saved in the database without the
    publisher information, so it must be an optional field or the existing data will
    become invalid. You should also update the static factory method accordingly.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后相应地更新 Java 的 Book 记录。变更应考虑到在生产环境中，数据库中已经保存了一些没有出版信息书籍，因此必须是一个可选字段，否则现有数据将变得无效。您还应该相应地更新静态工厂方法。
- en: Listing 5.23 Adding a new optional field to an existing data entity
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 向现有数据实体添加新的可选字段
- en: '[PRE25]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ A new, optional field
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个新的、可选的字段
- en: Note After making this change, you must update the classes that call the static
    factory method and the Book() constructor to include a value for the publisher
    field. You can use either null (since it’s optional) or a string value like Polarsophia.
    Check the source code (Chapter05/05-end/catalog-service) to see the final result.
    In the end, check that both the autotests and the application run correctly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在做出此更改后，你必须更新调用静态工厂方法和 Book() 构造函数的类，以包含出版社字段的值。你可以使用 null（因为它可选）或像 Polarsophia
    这样的字符串值。检查源代码（Chapter05/05-end/catalog-service）以查看最终结果。最后，检查自动测试和应用程序是否运行正确。
- en: When this new version of Catalog Service is deployed to production, Flyway will
    skip the V1__Initial_schema.sql migration because it’s already been applied, but
    it will execute the change described in V2__Add_publisher_column.sql. At this
    point, bookshop employees can start including the publisher name when adding new
    books to the catalog, and all the existing data will still be valid.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个新版本的目录服务部署到生产环境时，Flyway 将跳过 V1__Initial_schema.sql 迁移，因为它已经被应用，但它将执行 V2__Add_publisher_column.sql
    中描述的更改。此时，书店员工可以在添加新书到目录时开始包含出版社名称，并且所有现有数据仍然有效。
- en: What if you need to make the publisher field mandatory? You can do that in a
    third version of Catalog Service, using an SQL migration to enforce the publisher
    column to be NON NULL and implementing a Java migration that adds a publisher
    to all the existing books in the database that don’t have one already.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使出版社字段成为必填项，你可以在目录服务的第三个版本中这样做，使用 SQL 迁移强制出版社列不能为 NULL，并实现一个 Java 迁移，将出版社添加到数据库中所有尚未包含出版社的现有书籍中。
- en: This two-step approach is very common to ensure backward compatibility during
    an upgrade. As you’ll learn in a later chapter, there are usually multiple instances
    of the same application running. Deploying a new version is generally done through
    a *rolling upgrade* procedure consisting of updating one (or a few) instances
    at a time to ensure zero downtime. There will be both old and new versions of
    the application running during the upgrade, so it’s paramount that the old instances
    can still run correctly even after the database changes introduced in the latest
    version have been applied.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这种两步法在升级期间确保向后兼容性非常常见。正如你将在后面的章节中学到的，通常有多个相同应用实例在运行。部署新版本通常通过 *滚动升级* 程序完成，该程序一次更新一个（或几个）实例，以确保零停机时间。在升级期间，将同时运行旧版本和新版本的应用程序，因此确保旧实例即使在应用了最新版本中引入的数据库更改后仍能正确运行至关重要。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The state is everything that should be preserved when shutting down a service
    and spinning up a new instance.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是关闭服务并启动新实例时应保留的一切。
- en: Data services are the stateful components of a cloud native architecture, requiring
    storage technologies to persist the state.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据服务是云原生架构中的有状态组件，需要存储技术来持久化状态。
- en: Using data services in the cloud is challenging because it’s a dynamic environment.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中使用数据服务具有挑战性，因为它是一个动态的环境。
- en: Some issues to consider when choosing a data service are scalability, resilience,
    performance, and compliance with specific regulations and laws.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择数据服务时需要考虑的一些问题包括可伸缩性、弹性、性能以及符合特定法规和法律。
- en: You can use data services that are offered and managed by your cloud provider
    or manage your own, either relying on virtual machines or containers.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用由你的云提供商提供和管理的服务，或者自己管理，无论是依赖于虚拟机还是容器。
- en: Spring Data provides common abstractions and patterns for accessing data, making
    it straightforward to navigate the different modules dedicated to relational and
    non-relational databases.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data 提供了访问数据的通用抽象和模式，使得导航针对关系型和非关系型数据库的不同模块变得简单直接。
- en: The main elements in Spring Data are database drivers, entities, and repositories.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data 的主要元素包括数据库驱动程序、实体和仓库。
- en: Spring Data JDBC is a framework that supports integrating Spring applications
    with relational databases relying on a JDBC driver.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JDBC 是一个框架，它支持通过 JDBC 驱动程序将 Spring 应用程序与关系型数据库集成。
- en: Entities represent domain objects and can be managed by Spring Data JDBC as
    immutable objects. They must have the field hosting the primary key annotated
    with @Id.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体代表领域对象，并且可以作为不可变对象由 Spring Data JDBC 管理。它们必须有一个字段包含主键，并使用 @Id 注解。
- en: Spring Data lets you capture audit metadata whenever an entity is created or
    updated. You can enable this feature with @EnableJdbcAuditing.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data 允许你在实体创建或更新时捕获审计元数据。你可以通过使用 @EnableJdbcAuditing 来启用此功能。
- en: Data repositories grant access to entities from the database. You need to define
    an interface, and then Spring Data will generate the implementation for you.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据仓库允许从数据库访问实体。你需要定义一个接口，然后 Spring Data 将为你生成实现。
- en: Depending on your requirements, you can extend one of the available Repository
    interfaces provided by Spring Data, such as CrudRepository.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你的需求，你可以扩展 Spring Data 提供的可用 Repository 接口之一，例如 CrudRepository。
- en: In Spring Data JDBC, all mutating custom operations (create, update, delete)
    should run in transactions.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring Data JDBC 中，所有修改自定义操作（创建、更新、删除）都应该在事务中运行。
- en: Use the @Transactional annotation to run operations in a single unit of work.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 @Transactional 注解来运行单个工作单元的操作。
- en: You can run integration tests for the Spring Data JDBC slice using the @DataJdbcTest
    annotation.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 @DataJdbcTest 注解来运行 Spring Data JDBC 切片的集成测试。
- en: Environment parity is essential for the quality and reliability of your tests
    and deployment pipeline.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境一致性对于测试和部署管道的质量和可靠性至关重要。
- en: You can test the integration between your application and backing services defined
    as containers by using the Testcontainers library. It lets you use lightweight,
    throwaway containers in your integration tests.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Testcontainers 库来测试你的应用程序与作为容器定义的后端服务之间的集成。它允许你在集成测试中使用轻量级、可丢弃的容器。
- en: Database schemas are critical for applications. In production, you should use
    a tool like Flyway, which provides version control for your database.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式对于应用程序至关重要。在生产环境中，你应该使用像 Flyway 这样的工具，它为你的数据库提供版本控制。
- en: Flyway should manage any database changes to ensure reproducibility, traceability,
    and reliability.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flyway 应该管理任何数据库更改，以确保可重复性、可追踪性和可靠性。
