- en: 13 Calendar
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 日历
- en: It wasn’t just the Mayans who invented their own calendar. Just about every
    early culture featured some form of classification for the passage of days. The
    Mayans gained notoriety in 2012 because it was the end of one of their great calendrical
    cycles—the long count, or *b’ak’tun*. It wasn’t the end of the world—more like
    turning the page on one of those cheap insurance company calendars. Bummer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅玛雅人发明了自己的日历。几乎每一种早期文化都为日子的流逝提供了一种分类形式。玛雅人在 2012 年获得了知名度，因为那是他们伟大的日历周期之一——长计数，或称
    *b’ak’tun* 的结束。这并不是世界的末日——更像是翻过了一页那种廉价的保险公司日历。真糟糕。
- en: Most cultures start with lunar calendars and eventually switch to solar calendars,
    either fully or reluctantly. Hebrew, Muslim, Eastern Orthodox, and Chinese calendars
    are still used today, with different year values and lunar features. Julius Caesar
    took a stab at updating the Roman calendar system—before the Senate took various
    stabs at him. And Pope Gregory introduced our modern calendar system in the year
    1582.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数文化最初使用阴历，最终转向阳历，要么完全转向，要么不情愿地转向。希伯来、穆斯林、东正教和中国日历至今仍在使用，具有不同的年份值和阴历特征。尤利乌斯·凯撒试图更新罗马日历系统——在参议院多次对他进行攻击之前。教皇格里高利在
    1582 年引入了我们的现代日历系统。
- en: 'Even with calendar utilities handy, coding your own calendar tools helps hone
    your time programming skills in C and more. In this chapter, you learn to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有日历工具在手，编写自己的日历工具也有助于磨练你在 C 语言中的时间编程技能。在本章中，你将学习到：
- en: Appreciate the *cal* program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏 `cal` 程序
- en: Calculate holidays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算假日
- en: Code week, month, and year utilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写周、月和年实用工具的代码
- en: Output color text
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出彩色文本
- en: Color-code important dates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用颜色编码重要日期
- en: Yes, Unix has featured the *cal* program since the steam-powered days. Still,
    understanding date-and-time programming is important for all C coders. By practicing
    on these utilities, you can better code your own, custom date programs. You can
    also use the techniques presented here in any program that relies upon date calculations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Unix 自蒸汽动力时代起就提供了 `cal` 程序。然而，对于所有 C 语言程序员来说，理解日期和时间编程非常重要。通过在这些工具上练习，你可以更好地编写自己的定制日期程序。你还可以将这些技术应用于任何依赖于日期计算的程序。
- en: 13.1 The calendar program
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 日历程序
- en: 'The calendar program developed for AT&T Unix (System V) is called *cal*. Linux
    inherited this fine tool. The default output, with no options specified, displays
    the current month in this format:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为 AT&T Unix（System V）开发的日历程序称为 `cal`。Linux 继承了这个优秀的工具。在不指定任何选项的情况下，默认输出显示当前月份的格式：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The current day is shown inverse, such as the 20th above.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当前日期以反相显示，例如上面的第 20 天。
- en: 'You can follow *cal* with a year argument to obtain the full, 12-month calendar
    for the given year:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `cal` 后面加上年份参数，以获取给定年份的完整 12 个月份日历：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can add a month argument to see the calendar for a specific month in a
    specific year:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加月份参数，以查看特定年份特定月份的日历：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The month can be specified numerically or by name. To see the next three months
    of output, specify the -A2 argument:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 月份可以用数字或名称指定。要查看接下来三个月的输出，请指定 -A2 参数：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like many classic Unix utilities, the *cal* program is burdened with a plethora
    of easily forgettable options and unmemorable switches.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多经典的 Unix 工具一样，`cal` 程序被许多容易忘记的选项和难以记忆的开关所累赘。
- en: 'The program’s output is consistent: the first row is the full month name and
    full year. The next row is the weekday header. The program then outputs six rows
    of text for the calendar. When a month lacks a sixth week, the last row of output
    is blank.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出是一致的：第一行是完整的月份名称和年份。下一行是星期几的标题。然后程序输出六行文本作为日历。当某个月没有第六周时，输出行的最后一行是空的。
- en: 'The only thing the *cal* program doesn’t do is output the calendar sideways.
    This job is handled by the updated version, the *ncal* program:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`cal` 程序唯一不做的就是以横向输出日历。这项工作由更新的版本 `ncal` 程序处理：'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The advantage of the *ncal* program is that it outputs the entire year in a
    grid four months wide, which makes it easier to read on a text screen. The *cal*
    program uses a grid three months wide when it outputs an entire year.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ncal` 程序的优势在于它以四个月宽的网格输出整个年份，这使得在文本屏幕上阅读更加容易。当 `cal` 程序输出整个年份时，它使用三个月宽的网格。'
- en: You could just use these utilities and go right along on your merry Linux adventures,
    but then what do you learn? Further, it’s possible to customize calendar output
    to however you prefer. As with any programming project, the possibilities are
    endless—providing that the caffeine and chips don’t run out.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些实用程序，继续你的Linux冒险之旅，但这样你又能学到什么呢？此外，你可以自定义日历输出，以满足你的偏好。就像任何编程项目一样，可能性是无限的——只要咖啡和薯片不耗尽。
- en: Calendar trivia
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 日历趣闻
- en: When Julius Caesar’s calendar was adopted in 46 BC, the year became 445 days
    long. This change was to align the new calendar with the solar year. It became
    the longest year in history.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尤利乌斯·凯撒在公元前46年采用日历时，这一年变成了445天。这次改变是为了使新历法与太阳年对齐。它成为了历史上最长的一年。
- en: 'English month names are derived from the old Roman calendar: Ianuarius (January),
    Februarius (February), Martius (March), Aprilis (April), Maius (May), Iunius (June),
    Quintilis (July), Sextilis (August), September, October, November, and December.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英文月份名称源自古老的罗马历法：Ianuarius（一月），Februarius（二月），Martius（三月），Aprilis（四月），Maius（五月），Iunius（六月），Quintilis（七月），Sextilis（八月），September，October，November，和December。
- en: Some religious ceremonies continue to be based on Julian calendar dates—specifically,
    in the Eastern Orthodox Church.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些宗教仪式仍然基于儒略历日期——特别是在东正教中。
- en: When Pope Gregory adopted the current, Gregorian calendar in 1582, October 4
    was immediately followed by October 15.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当教皇格列高利在1582年采用当前的格里高利历法时，10月4日紧接着就是10月15日。
- en: The effect of the Gregorian calendar’s adoption by Great Britain is reflected
    in the *cal* program’s output for September 1752\. Type **cal 9 1752** to see
    a shortened month as the old calendar was adjusted to the new.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大不列颠采用格里高利历的影响反映在*cal*程序9月1752年的输出中。输入**cal 9 1752**可以看到缩短的月份，因为旧历法已经调整为新历法。
- en: Even with the improved Gregorian calendar, leap seconds are added to the year
    every so often.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是改进后的格里高利历，每年也会偶尔添加闰秒。
- en: The number of times Friday falls on the 13th in a specific month varies from
    one to three times a year.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定月份中，星期五落在13号的出现次数每年从一次到三次不等。
- en: During nonleap years, February and March share the same date patterns—up until
    March 29, of course.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非闰年中，二月和三月共享相同的日期模式——当然，直到3月29日为止。
- en: A sidereal year is based on the time it takes Planet Earth to make a lap around
    the sun. Its value is 365.256363 days.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个恒星年基于地球绕太阳一周所需的时间。它的值是365.256363天。
- en: A lunar year consists of 12 moon cycles. It’s 354.37 days long.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴历年由12个月亮周期组成。它长354.37天。
- en: Intercalary months are added to lunar calendars every few years to resynchronize
    the moon cycle with the solar calendar.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每过几年，阴历就会增加闰月，以重新同步月亮周期与阳历。
- en: A galactic year is 230,000,000 (solar) years long. It’s the time it takes the
    sun to orbit the Milky Way galaxy—or the time it takes a toddler to find a matching
    pair of socks.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个银河年有230,000,000（太阳）年那么长。这是太阳绕银河系运行的时间——或者是一个学步儿童找到一双匹配的袜子所需的时间。
- en: 13.2 Good dates to know
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 应知的好日期
- en: 'C programmers familiar with the library’s time functions know that date-and-time
    tidbits can easily be extracted from the current timestamp, available from the
    operating system: values are available for the year, month, day of the month,
    and day of the week. These items are all you need to construct a calendar for
    the current week or month. But what about next month? What about July in 1978?
    For these details, your code must work harder.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉库中时间函数的C程序员知道，可以从操作系统的当前时间戳中轻松提取日期和时间信息：有年份、月份、月份中的天数和星期中的天数等值。这些就是你需要构建当前周或月日历的所有信息。但下个月怎么办？1978年的7月怎么办？为了这些细节，你的代码必须更加努力工作。
- en: Making date calculations is difficult because some months have 30 days and some
    have 31\. Once every four years, February decides to grow another day—but even
    this leap day isn’t consistent. To help you properly program dates, you must code
    some tools.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 进行日期计算很困难，因为有些月份有30天，有些有31天。每四年一次，二月决定再增加一天——但即使是这个闰日也不是一致的。为了正确编程日期，你必须编写一些工具。
- en: 13.2.1 Creating constants and enumerating dates
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 创建常量和枚举日期
- en: More than most of my programming, it seems like date programming brings in a
    lot of constants—specifically, string and symbolic constants for weekday and month
    names. For my date programming, I employ both types of constants and try to do
    so consistently for all my date-and-time related functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与我的大多数编程相比，日期编程似乎引入了大量的常量——特别是星期和月份名称的字符串和符号常量。对于我的日期编程，我使用这两种类型的常量，并试图在所有与日期和时间相关的函数中保持一致性。
- en: 'For weekday and month names, I use *const char* pointers—string constants.
    The weekday constants are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于星期和月份名称，我使用 `const char*` 指针——字符串常量。星期常量是：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shorter versions are also used:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用简短版本：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are my favorite month constants:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的最喜欢的月份常量：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each statement creates an array of pointers; storage for each string is allocated
    by the program at runtime. What remains is an array of addresses. Each array is
    in a sequence that matches the tm_wday and tm_mon members of the tm structure
    returned from the *localtime()* function. For example, the tm_mon member for January
    is numbered 0, and the zeroth element of the month[] array is the string for January.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句创建一个指针数组；每个字符串的存储在程序运行时由程序分配。剩下的是一个地址数组。每个数组与从 `localtime()` 函数返回的 `tm_wday`
    和 `tm_mon` 结构体成员的顺序相匹配。例如，一月的 `tm_mon` 成员编号为0，月份数组 `month[]` 的零元素是一月的字符串。
- en: The *const* classifier declares these arrays as immutable, which prevents them
    from being accidentally altered elsewhere in the code. The strings can be passed
    to functions, but don’t change them! Doing so leads to unpredictable behavior,
    but not when they’re classified as constants.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 分类器将这些数组声明为不可变，这防止了它们在代码的其他地方被意外更改。字符串可以传递给函数，但不要更改它们！这样做会导致不可预测的行为，但不是当它们被分类为常量时。'
- en: Pairing with these two arrays, I also use enumerated constants to represent
    the weekday and month values. The C language *enum* keyword makes creating these
    constants easy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与这两个数组配对，我也使用枚举常量来表示星期和月份值。C语言的 `enum` 关键字使得创建这些常量变得容易。
- en: Don’t tell me you’ve avoided the *enum* keyword because it’s weird. I did so
    for too long. Yet *enum* helps you define constants similarly to the way an array
    defines groups of variables with the same data type. For weekday and month names,
    enum provides a helpful tool to create these constants and make your code more
    readable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不要告诉我你因为觉得它奇怪而避免了 `enum` 关键字。我这样做太久了。然而，`enum` 帮助你定义常量，类似于数组以相同的数据类型定义变量组的方式。对于星期和月份名称，`enum`
    提供了一个有用的工具来创建这些常量，并使你的代码更易于阅读。
- en: 'As a review, the *enum* keyword is followed by a set of braces that contain
    the enumerated (numbered) constants. Values are assigned sequentially, starting
    with 0:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，枚举关键字后面跟着一组大括号，其中包含枚举（编号）常量。值是按顺序分配的，从0开始：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, constant FALSE is defined as 0; TRUE, as 1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，常量 `FALSE` 被定义为0；`TRUE` 被定义为1。
- en: 'You can use an assignment operator to alter the number sequencing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用赋值运算符来改变数字顺序：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This statement defines constant ALPHA as 1\. Constant GAMMA is set equal to
    5, with the rest of the constants numbered sequentially: DELTA is 6, EPSILON is
    7, and THETA is 8.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句将常量 `ALPHA` 定义为1。常量 `GAMMA` 被设置为5，其余的常量按顺序编号：`DELTA` 是6，`EPSILON` 是7，`THETA`
    是8。
- en: 'The weekday values reported from the *localtime()* function start with 0 for
    Sunday. Here is the *enum* statement to declare weekday values for use in your
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `localtime()` 函数报告的星期值从0开始，代表星期日。以下是用于在代码中声明星期值使用的 `enum` 语句：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the 12 months, you can split the *enum* statement across multiple lines,
    just as you can split any statement in C:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于12个月份，你可以将 `enum` 语句拆分到多行，就像你可以将任何语句拆分到C语言中的多行一样：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As with weekdays, the *localtime()* function uses 0 to represent January. These
    enumerated constants are ready to use in your code. For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像星期一样，`localtime()` 函数使用0来表示一月。这些枚举常量可以随时在你的代码中使用。例如：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using the month[] array defined earlier in this section, along with enumerated
    constant JANUARY, the previous statement outputs the text January. This construction
    is self-documenting and easier to read than using month[0] or something equally
    vague without reference to what 0 could mean.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本节之前定义的 `month[]` 数组，以及枚举常量 `JANUARY`，前面的语句输出文本“一月”。这种结构是自我文档化的，比使用 `month[0]`
    或其他同样模糊的引用没有说明0可能意味着的内容更容易阅读。
- en: 13.2.2 Finding the day of the week
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 查找星期几
- en: After arriving at the destination, the first thing a time traveler asks is,
    “What year is it?” This question provides a big-picture answer, but it also helps
    the production design team understand how to visually misinterpret various eras
    in history. And it allows the locals to predictably respond, “What are you talking
    about, stranger in the silver pajamas?”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到达目的地后，时间旅行者首先问的问题是，“现在是哪一年？”这个问题提供了一个宏观的答案，但它也帮助制作设计团队了解如何视觉上误解历史上的各个时代。它还允许当地人可预测地回答，“你在说什么，穿着银色睡衣的陌生人？”
- en: For calendar programming, yes, knowing the current year is important. Also necessary
    to plotting out a calendar is knowing month, day, and—vitally—the weekday. The
    day-and-weekday info are key to unlocking the first day of the month. The other
    time tidbits are easily obtained from the data reported by the *time()* and *localtime()*
    functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日历编程来说，知道当前年份很重要。绘制日历还需要知道月份、日期，以及至关重要的星期几。日期和星期几的信息是解锁月份第一天的关键。其他时间片段可以很容易地从
    *time()* 和 *localtime()* 函数报告的数据中获得。
- en: In the next listing, the *time()* function obtains the current epoch value,
    a *time_t* data type. The *localtime()* function uses this value to fill a tm
    structure, date. The month, month day, year, and weekday values are then interpreted
    and output, displaying the current day and date.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，*time()* 函数获取当前的纪元值，一个 *time_t* 数据类型。*localtime()* 函数使用这个值填充一个 tm 结构，date。然后解释并输出月份、月份日、年份和星期几的值，显示当前的日期和星期。
- en: Listing 13.1 Source code for weekday01.c
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.1 weekday01.c 的源代码
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ String constants for the days of the week
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 星期的字符串常量
- en: ❷ String constants for months of the year
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 年份的月份字符串常量
- en: ❸ Variable to store the clock ticks
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 存储时钟滴答的变量
- en: ❹ Variable to store time tidbits
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 存储时间片段的变量
- en: ❺ Obtains the current clock tick value
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取当前时钟滴答值
- en: ❻ Fills the tm date structure with individual time values
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将 tm 日期结构填充为单独的时间值
- en: ❼ Outputs the results
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 输出结果
- en: The string constants declared in weekday01.c are used throughout this chapter.
    Remember to define them as *const char* variables; you don’t want to mess with
    the string’s contents, lest all sorts of mayhem ensue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: weekday01.c 中声明的字符串常量在本章中会被使用。请记住将它们定义为 *const char* 变量；你不想与字符串的内容纠缠，否则可能会引发各种混乱。
- en: 'The program built from the code in listing 13.1 outputs a simple string, reflecting
    the current date and weekday:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表 13.1 中的代码构建的程序输出一个简单的字符串，反映了当前的日期和星期：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can use the date info generated in the program to plot out a calendar—for
    the current month. To figure out how the following July maps out on a calendar,
    you must apply some math. To help you, and avoid all that boring trial-and-error,
    you can steal an algorithm from the internet.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用程序生成的日期信息绘制日历——当前月份的日历。为了了解接下来的七月如何在日历上布局，你必须应用一些数学知识。为了帮助你，并避免所有那些无聊的试错，你可以从互联网上偷取一个算法。
- en: 'Before computers on desktops were a thing, I remember one of my elementary
    school teachers demonstrating an algorithm to find the weekday for any day, month,
    and year. It’s simple enough that you can perform the math in your head without
    exploding. I forget what my teacher wrote on the chalkboard, but here’s the algorithm,
    freshly stolen from the internet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在台式计算机出现之前，我记得我的小学老师演示了一个算法，用于找到任何日期、月份和年份的星期几。这个算法足够简单，以至于你可以在脑海中完成数学运算而不会爆炸。我忘记了老师写在黑板上的内容，但这里是从互联网上新鲜偷来的算法：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Array t[] holds the algorithm’s magic. I’m unsure what the data references,
    though my guess is that it’s probably some sort of month pattern index. The year
    value is reduced by 1 for the months of January and February. Then variable r
    captures the day of the week, with Sunday being 0\. I assume most of the year
    manipulation in the expression is to compensate for leap years. Further, this
    algorithm assumes that the value of January is 1, not 0\. These differences can
    be adjusted as shown in the *dayoftheweek()* function in the following listing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 t[] 包含算法的魔法。我不确定数据引用的是什么，尽管我的猜测是它可能是一种月份模式索引。对于一月份和二月份，年份值减去 1。然后变量 r 捕获星期几，星期日为
    0。我假设表达式中的大部分年份操作都是为了补偿闰年。此外，此算法假定一月份的值为 1，而不是 0。这些差异可以根据以下列表中的 *dayoftheweek()*
    函数进行调整。
- en: Listing 13.2 The *dayoftheweek()* function
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.2 The *dayoftheweek()* 函数
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The month value, m, ranges from 0 through 11 for January through December;
    d is the day of the month, and y is the full year value (tm_year+1900).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 月份值 m 从 0 到 11，对应于从一月到十二月；d 是月份中的日期，y 是完整的年份值（tm_year+1900）。
- en: ❷ The magic array
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 魔法数组
- en: ❸ The m<2 evaluation is either 1 or 0, which is added to the year variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ m<2 的评估结果是 1 或 0，这被添加到年份变量中。
- en: ❹ The rest of the algorithm, with m used without modification as the element
    number
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 算法的其余部分，其中 m 作为元素编号使用，没有修改
- en: 'I updated the *main()* function from weekday01.c to call the *dayoftheweek()*
    function. Specific values are set for month, day, and year variables, which are
    passed to the function. The result is then output. These modifications are found
    in the online repository as source code file weekday02.c. Here is some sample
    output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 weekday01.c 中的 *main()* 函数更新为调用 *dayoftheweek()* 函数。为月份、日期和年份变量设置了特定值，这些值被传递给函数。然后输出结果。这些修改可在在线仓库中找到，作为源代码文件
    weekday02.c。以下是一些示例输出：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The capability to obtain these four date details—year, month, day, and day of
    the week—is key to creating a calendar. The next step is to calculate the first
    day of the month, with the rest of the days flowing after.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这些四个日期细节——年、月、日和星期几——对于创建日历至关重要。下一步是计算月份的第一天，其余日期随后流动。
- en: Exercise 13.1
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 13.1
- en: If you’re like me, you probably played with the source code from weekday02.c,
    typing in your birthday or some other important date out of curiosity. But why
    keep updating the source code?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你可能出于好奇玩过 weekday02.c 的源代码，输入你的生日或其他重要日期。但为什么还要不断更新源代码呢？
- en: 'Your task for this exercise is to modify the source code from weekday02.c so
    that command-line arguments are interpreted as the month, day, and year for which
    you want to find the day of the week. And if your locale doesn’t like the argument
    order—you can change it! Here is a sample run of my solution, which I call *weekday*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的任务是修改 weekday02.c 的源代码，以便将命令行参数解释为要查找星期几的月份、日期和年份。如果你的地区不喜欢这种参数顺序——你可以更改它！以下是我解决方案的示例运行，我称之为
    *weekday*：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: My solution is available in the online repository as weekday03.c.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案可在在线仓库中找到，作为 weekday03.c。
- en: 13.2.3 Calculating the first day of the month
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 计算月份的第一天
- en: Today is the 20th day of the month—any month. It’s a Monday. On which day of
    the week did the first day of the month fall?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 今天是这个月的第 20 天——任何月份。它是一个星期一。这个月的第一天是星期几？
- en: Uh . . .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 噢……
- en: Quick! Use the handy illustration in figure 13.1 to help your calculations.
    If today is Monday the 20th, the first of the month is on a Wednesday, always,
    for any month where Monday is the 20th.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 快点！使用图 13.1 中的便捷插图来帮助你计算。如果今天是 20 日星期一，那么对于任何一个月，如果 20 日是星期一，那么这个月的第一天总是星期三。
- en: '![13-01](Images/13-01.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![13-01](Images/13-01.png)'
- en: Figure 13.1 A month where the 20th is a Monday
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 20 日是星期一的月份
- en: 'When given a day of the month and its weekday, the computer can easily calculate
    upon which day the first of the month falls. Here is the formula I devised to
    determine the weekday for the first of the month when given the current weekday
    and day of the month:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定月份的某一天及其星期几时，计算机可以轻松地计算出这个月的第一天是星期几。以下是我设计的公式，用于在给定当前星期几和月份的日期的情况下确定月份的第一天的星期几：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To work through the formula with figure 13.1, assume that today is the 23rd—which
    it is as I write this text. It’s a Thursday, numeric value 4:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与图 13.1 中的公式一起工作，假设今天是 23 日——正如我写这篇文本的时候。它是一个星期四，数字值为 4：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When a month has the 23rd fall on a Thursday, the first is on a Wednesday (value
    3). Refer to figure 13.1 to confirm.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个月的 23 日落在星期四时，第一天是星期三（值为 3）。请参考图 13.1 以确认。
- en: To put my first-of-the-month algorithm to the test, the next listing shows code
    that obtains the current date. It uses the weekday and day of the month values
    to work the algorithm, outputting on which weekday the first of the month falls.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我的月份第一天算法，下一个列表显示了获取当前日期的代码。它使用星期几和月份的日期值来执行算法，输出月份的第一天是星期几。
- en: Listing 13.3 Source code for thefirst01.c
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.3 first01.c 的源代码
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Obtains the current clock tick value
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取当前时钟滴答值
- en: ❷ Fills the tm structure date
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 填充 tm 结构的日期
- en: ❸ Works the algorithm
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行算法
- en: ❹ Outputs the results
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出结果
- en: 'The source code for thefirst01.c is available in the online repository, but
    don’t get excited about it. If the current weekday value is greater than the weekday
    value for the first of the month, the program works, as it did on my computer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`first01.c` 的源代码可在在线仓库中找到，但不要为此兴奋。如果当前工作日值大于月初的工作日值，程序将正常工作，就像在我的电脑上一样：'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the current weekday value is less than the weekday value of the first of
    the month, the code fails. For example, if today is Tuesday (2) and the first
    is on Friday (5), you see something like this delightful output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前工作日值小于月初的工作日值，代码将失败。例如，如果今天是星期二（2）而月初是星期五（5），你会看到如下令人愉快的输出：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The reason for the core dump is that the value stored in first drops below
    0\. This error can be corrected by testing for a negative value of first:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 核心转储的原因是第一个存储的值低于0。可以通过检查第一个的负值来纠正这个错误：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this update to the code, I use enumerated constant WEDNESDAY as the weekday
    and 12 as the day of the month. The first of the month is on a Saturday. Here
    is the code’s output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次代码更新中，我使用枚举常量 WEDNESDAY 作为工作日，12 作为月份的日期。月初是在星期六。以下是代码的输出：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finding the weekday for the first of the month may seem silly. After all, from
    the preceding section you find code that locates the day of the week for any day
    of the month. The issue is that you’re often not given the first of the month.
    Sure, you could write more code that calls the *dayoftheweek()* function after
    modifying the current day of the month. But I find that using the algorithm works
    best for me.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 找出月初的星期几可能看起来很愚蠢。毕竟，从前面的部分中，你可以找到定位任何月份日期的星期几的代码。问题是，你通常不会给出月初的日期。当然，你可以编写更多的代码，在修改当前月份的日期后调用
    `dayoftheweek()` 函数。但我发现使用算法对我来说效果最好。
- en: Exercise 13.2
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 13.2
- en: 'It’s time to write another function! From the source code file thefirst02.c,
    pull out the algorithm portion of the *main()* function and set it into its own
    function, *thefirst()*. This function is prototyped like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写另一个函数了！从源代码文件 `thefirst02.c` 中提取 `main()` 函数的算法部分，并将其设置为它自己的函数 `thefirst()`。此函数的原型如下：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Variable wday is the day of the week, mday is the day of the month. The value
    returned is the weekday for the first of the month, range 0 through 6.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `wday` 是星期几，`mday` 是月份的日期。返回的值是月初的工作日，范围是0到6。
- en: My solution is available in the online repository as thefirst03.c. I wrote code
    in the *main()* function to report the first of the month when the current day
    is the 25th, a Saturday. Comments in the code explain my approach.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案作为 `thefirst03.c` 可在在线仓库中找到。我在 `main()` 函数中编写了代码来报告当当前天是25号，星期六时的月初。代码中的注释解释了我的方法。
- en: 13.2.4 Identifying leap years
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.4 识别闰年
- en: You can’t discuss date programming without bringing up the squidgy issue of
    leap years. The varying number of days in February is yet another example of the
    universe trying to tell us that nothing would exist if everything were in perfect
    balance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论日期编程时，不可避免地要提到关于闰年的棘手问题。二月天数的不同数量是宇宙试图告诉我们，如果一切都在完美的平衡中，那么什么都不会存在的另一个例子。
- en: 'When I work with days in the month, I typically write an array like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我处理月份中的天数时，我通常会编写一个这样的数组：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This array holds the number of days for January through December. For February,
    the value is 28\. But one out of every four years (on average), February has 29
    days—the extra leap day in a leap year.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组包含从一月到十二月的每月天数。对于二月，值为28。但平均每四年中就有一个二月有29天——这是闰年中的额外闰日。
- en: 'To determine which years are leap years, and adjust the mdays[], you must do
    some math. Here are the leap year rules in order of elimination:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定哪些年份是闰年，并调整 `mdays[]`，你必须做一些数学计算。以下是按消除顺序排列的闰年规则：
- en: If the year is divisible by both 100 and 400, it’s a leap year.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果年份既能被100整除也能被400整除，则它是闰年。
- en: If the year is divisible only by 100, it’s not a leap year.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果年份只能被100整除，则它不是闰年。
- en: If the year is divisible by four, it’s a leap year.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果年份能被4整除，则它是闰年。
- en: 'Normally, the leap year rules are listed in reverse order: If the year is divisible
    by four, it’s a leap year, unless the year is divisible by 100, in which case
    it’s not a leap year, unless the year is also divisible by 400, in which case
    it is a leap year.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，闰年规则是按相反顺序列出的：如果年份能被4整除，则它是闰年，除非年份能被100整除，在这种情况下它不是闰年，除非年份也能被400整除，在这种情况下它是闰年。
- en: Got it?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？
- en: No, it’s easier to list the rules upside down, which also helps to write a leap
    year function, *february()*, shown next. Its purpose is to return the number of
    days in February, a value then set into an array like mdays[] (shown earlier).
    The rules for calculating a leap year appear in the function as a series of *if*
    tests based on the year value passed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不，倒着列出规则更容易，这也有助于编写下一个显示的闰年函数*february()*。它的目的是返回二月的天数，然后将该值设置到一个数组，如mdays[]（前面已显示）。计算闰年的规则以一系列基于传递的年份值的*if*测试的形式出现在函数中。
- en: Listing 13.4 The *february()* function
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.4 *february()*函数
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ If the year is divisible by 400 (which includes 100), it’s a leap year.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果年份能被400（包括100）整除，那么它是一个闰年。
- en: ❷ If the year is divisible by 100, it’s a leap year.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果年份能被100整除，那么它是一个闰年。
- en: ❸ If the year is not a multiple of four, it’s not a leap year.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果年份不是四的倍数，则它不是闰年。
- en: ❹ Otherwise, it’s a leap year.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则，它是一个闰年。
- en: 'I use the *february()* function in the source code file leapyear01.c, available
    in the online repository. In the *main()* function, a loop tests the years 1584
    through 2101, which span the time from when the Gregorian calendar began to when
    the lizard people finally invade. If the year is a leap year, meaning the *february()*
    function returns 29, its value is output. Here is the tail end of a sample run:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我在源代码文件leapyear01.c中使用了*february()*函数，该文件可在在线仓库中找到。在*main()*函数中，一个循环测试了1584年至2101年的年份，这涵盖了从格里高利历开始到蜥蜴人最终入侵的时间。如果年份是闰年，即*february()*函数返回29，则输出其值。以下是样本运行的末尾部分：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code accurately identifies the year 2000 as a leap year.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码准确地识别了2000年是一个闰年。
- en: The *february()* function is used in programs demonstrated later in this chapter
    to update the mdays[] array to reflect the proper number of days in February for
    a given year.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*february()*函数将在本章后面演示的程序中使用，以更新mdays[]数组，以反映给定年份二月应有的天数。'
- en: 13.2.5 Getting the time zone correct
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.5 获取正确的时区
- en: One weirdo issue to consider when dealing with dates is the computer’s time
    zone. This value is set according to the system’s locale. It reflects the local
    time of day, which is what’s accessed when you program dates and time in C.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理日期时，需要考虑的一个奇怪问题是计算机的时区。这个值是根据系统的区域设置设置的。它反映了当地的白天时间，这是在C语言中编程日期和时间时访问的。
- en: Normally, the time zone detail is ignored; what you want to obtain from the
    *time()* function is the current date and time for the computer or other device’s
    location. However, if your code doesn’t account for the difference between GMT,
    or Greenwich Mean Time, and your local time zone, the time calculation you make
    could be inaccurate.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，时区细节会被忽略；你想要从*time()*函数获取的是计算机或其他设备的当前日期和时间。然而，如果你的代码没有考虑到格林威治标准时间（GMT）和你的本地时区之间的差异，你所进行的时间计算可能会不准确。
- en: For example, my time zone is US Pacific. If I’m not careful, the eight-hour
    time difference gives me results that are off by eight hours. Believe it or not,
    this level of chronological accuracy is necessary for a program to spit out an
    accurate calendar.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我的时区是太平洋标准时间。如果不小心，八小时的时间差会导致结果偏差八小时。信不信由你，这种时间准确性对于程序输出准确的日历是必要的。
- en: To drive home this concern, consider the source code in the next listing. It
    initializes a time_t value to 0, which is the dawn of the Unix epoch, or midnight
    January 1, 1970\. This value is output in a *printf()* statement, which uses the
    *ctime()* function to convert a *time_t* value into a human-readable string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这一担忧，考虑以下列表中的源代码。它将一个time_t值初始化为0，这是Unix纪元的黎明，或者说1970年1月1日的午夜。这个值通过一个*printf()*语句输出，该语句使用*ctime()*函数将*time_t*值转换为人类可读的字符串。
- en: Listing 13.5 Source code for timezone01.c
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.5 timezone01.c的源代码
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Presets the *time_t* value to zero, the dawn of the Unix epoch
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将*time_t*值预设为零，Unix纪元的黎明
- en: ❷ Outputs the time string for the epoch
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出纪元的时间字符串
- en: 'When the program is run, I see this text on my computer:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我在我的计算机上看到以下文本：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output shows eight hours before the epoch began (midnight, January 1) because
    my computer’s time zone is set to GMT-8 (Greenwich Mean Time minus eight hours),
    or Pacific Standard Time. The output is accurate: when it was midnight on January
    1 in the UK, it was 4:00 P.M. the day before here on the West Coast of the United
    States.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在纪元开始前八小时（午夜，1月1日），因为我的计算机时区设置为GMT-8（格林威治标准时间减去八小时），或太平洋标准时间。输出是准确的：当英国1月1日午夜时，这里西海岸的美国是前一天下午4:00。
- en: 'In Linux, you can check the computer’s time zone information by examining the
    /etc/localtime symbolic link. Use the **ls -l** (dash-L) command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，您可以通过检查/etc/localtime符号链接来检查计算机的时区信息。使用**ls -l**（连字符-L）命令：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the relevant part of the output I see on my system:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我系统上看到的相关输出部分：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: My time zone is set the same as in Los Angeles, though the people are much nicer
    where I live. The output you see is local to your system, a value set when Linux
    was first configured.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我的时间区域设置与洛杉矶相同，尽管我住的地方人们要友好得多。您看到的输出是您系统的本地时间，这是Linux首次配置时设置的值。
- en: 'Your code need not look up the /etc/localtime symbolic link to determine the
    computer’s time zone or attempt to change this setting. Instead, you can write
    code to temporarily set the TZ (time zone) environment variable to GMT. To make
    this update to the source code for timezone01.c, you must add two functions: *putenv()*
    and *tzset()*.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码无需查找/etc/localtime符号链接来确定计算机的时区或尝试更改此设置。相反，您可以编写代码临时设置TZ（时区）环境变量为GMT。要更新timezone01.c的源代码，您必须添加两个函数：*putenv()*和*tzset()*。
- en: The *putenv()* adds an environment variable to the program’s local environment;
    the change doesn’t affect the shell, so it’s not something you must undo later
    in the code. The *man* page format is
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*putenv()*向程序的本地环境添加一个环境变量；更改不会影响shell，因此您不需要在代码的后续部分撤销它。*man*页面的格式是'
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The string is the environment entry to add. In this case, it’s TZ=GMT for “time
    zone equals Greenwich Mean Time” exactly, the time zone you want. This function
    requires the inclusion of the stdlib.h library.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是要添加的环境条目。在这种情况下，它是TZ=GMT，表示“时区等于格林威治标准时间”，即您想要的时区。此函数需要包含stdlib.h库。
- en: 'The *tzset()* function sets the program’s time zone—but only while it runs.
    The function doesn’t otherwise alter the system. Here is the *man* page format:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*tzset()*函数设置程序的时间区域——但仅在运行期间。该函数不会以其他方式更改系统。以下是*man*页面的格式：'
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The *tzset()* function requires no arguments because it uses the TZ environment
    variable to set the program’s time zone. The time.h header file must be included
    for this function to behave properly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*tzset()*函数不需要任何参数，因为它使用TZ环境变量来设置程序的时间区域。为了使此函数正常工作，必须包含time.h头文件。'
- en: 'To update the code for timezone01.c, add the following two statements before
    the *printf()* statement:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新timezone01.c的代码，请在*printf()*语句之前添加以下两个语句：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And don’t forget to include the stdlib.h header file for the *putenv()* function.
    These changes are found in the online repository in the source code file timezone02.c.
    Here is the program’s output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 并且不要忘记包含stdlib.h头文件，以便于*putenv()*函数。这些更改可以在在线仓库中的源代码文件timezone02.c中找到。以下是程序的输出：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The output now reflects the true Unix epoch as the program’s time zone is changed
    to GMT internally.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出反映了真正的Unix纪元，因为程序内部将时区更改为GMT。
- en: This code is used later in this chapter, when the full year calendar is generated.
    Without making the adjustment, the calendar outputs the incorrect year, before
    or after the desired year based on your local time zone. The time zone adjustment
    ensures that the calendar is properly aligned. You can also use this trick in
    other programs that rely upon precise time-and-date calculations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在本章后面部分使用，当生成完整的年历表时。如果不进行此调整，日历将输出错误年份，根据您的本地时区，可能是在期望年份之前或之后。时区调整确保日历正确对齐。您也可以在其他依赖于精确时间日期计算的程序中使用这个技巧。
- en: 13.3 Calendar utilities
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 日历实用工具
- en: The Linux *cal* program does more than you can imagine. It’s impressive. Given
    its abundance of options and switches, *cal* can output dates in a given range
    for a given locale in a specific format. As with other Linux command-line programs
    I’ve aped, the goal for my calendar programs is to be specific, as opposed to
    writing one program that does everything.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的*cal*程序的功能比你想象的要多。它令人印象深刻。鉴于其丰富的选项和开关，*cal*可以以特定格式输出给定区域给定范围内的日期。与其他我模仿的Linux命令行程序一样，我的日历程序的目标是具体，而不是编写一个可以做所有事情的程序。
- en: I first coded my calendar programs because I wanted to see output for the current
    month in a wider format than what the *cal* program generates. Also, I just wanted
    to see whether I could code a calendar for any given month. The result is my *month*
    program, which I use far more often than *cal*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初编写日历程序是因为我想以比*cal*程序生成的更宽的格式看到当前月份的输出。此外，我只是想看看我是否可以为任何给定的月份编写日历。结果是我的*month*程序，我使用它的频率比*cal*高得多。
- en: One decision to make right away with any calendar utility is whether the week
    starts on Monday or Sunday. The *cal* program (as you may suspect) has options
    to set the week’s starting day. For my series of calendar programs in this chapter,
    it’s assumed that the week starts on Sunday.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何日历工具中，立即需要做出的一个决定是周从星期一还是星期日开始。*cal* 程序（正如你可能猜到的）有设置周开始日的选项。在本章中我的日历程序系列中，假设周从星期日开始。
- en: 13.3.1 Generating a week
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 生成一周
- en: 'I suppose the simplest calendar would output only the current day—something
    like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最简单的日历只会输出当前日期——类似于这样：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Most people want more from a calendar. But rather than start with the current
    month, my first calendar program shows the current week. This code hinges upon
    knowing the current day of the month and weekday. Here is the output I want to
    see for the final program:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人都希望日历能提供更多功能。但我的第一个日历程序并不是从当前月份开始，而是显示当前周。这段代码依赖于知道当前月份的日期和星期几。这是我想要在最终程序中看到的输出：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The current day is December 26\. The month (and year) ends on Friday, with Saturday
    being the first of January and the new year. It’s the 52nd week of the year.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当前日期是12月26日。这个月（和年份）在星期五结束，星期六是1月的第一天，也是新年的开始。这是当年的第52周。
- en: Before coding all that output, I want to start small and output only the current
    week. A loop outputs the days, Sunday through Saturday. No matter which weekday
    it is currently, the output starts on Sunday. Today’s day is highlighted in brackets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出所有这些信息之前，我想从小处着手，只输出当前周。一个循环输出了从星期日到星期六的每一天。无论当前是星期几，输出都从星期日开始。今天的日期用括号突出显示。
- en: 'The *localtime()* function reports details about the current day of the week.
    The formula I use to determine Sunday’s date is:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*localtime()* 函数会报告关于当前星期的详细信息。我用来确定星期日日期的公式是：'
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The day_of_the_month value is found in the tm structure, member tm_mday. Today’s
    weekday value is member tm_wday. As an example, if today is Thursday the 16th,
    the formula reads:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 月份的日期值可以在 tm 结构的 tm_mday 成员中找到。今天的星期值是 tm_wday 成员。例如，如果今天是星期四的16日，公式如下：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The date for Sunday is the 12th, which checks out on the monthly calendar shown
    in figure 13.1, earlier in this chapter. The sunday value is then used in a loop
    to output the seven days of the week:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 星期日的日期是12日，这在第13.1节中提到的月份日历中得到了验证。然后使用这个值在循环中输出一周的七天：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I output the consecutive days in a space four characters wide. This room allows
    for today’s date to be output embraced by square brackets.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我以四个字符宽的空间输出连续的日期。这个空间允许今天的日期被方括号包围输出。
- en: The full code for my week01.c program is shown in the next listing. It reads
    data from the *time()* and *localtime()* functions, outputs the current month
    (but not the year), and outputs dates for the current week. I use variables day,
    month, and weekday as readable shortcuts for their related members of the tm structure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 week01.c 程序中的完整代码将在下一部分列出。它从 *time()* 和 *localtime()* 函数读取数据，输出当前月份（但不包括年份），并输出当前周的日期。我使用变量
    day、month 和 weekday 作为 tm 结构相关成员的可读性简写。
- en: Listing 13.6 Source code for week01.c
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6 week01.c 的源代码
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Obtains the current time in clock ticks
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取当前时间的时钟滴答数
- en: ❷ Converts the time_t value into tm structure members
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 time_t 值转换为 tm 结构成员
- en: ❸ Sets the day, month, and weekday values for convenience and readability
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为方便和可读性设置日期、月份和星期值
- en: ❹ Calculates the date for Sunday
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算星期日的日期
- en: ❺ Outputs the first line, the current month
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出第一行，当前月份
- en: ❻ Outputs the day of the week header row
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出星期表头行
- en: ❼ Loops through days of the week, Sunday through Sunday + 7
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 遍历从星期日到星期日 + 7 的每一天
- en: ❽ For the current day, outputs its value in brackets
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 对于当前日期，在括号中输出其值
- en: ❾ Outputs every other day without brackets
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 输出每隔一天不带括号
- en: 'The source code from listing 13.6 is available in the online repository as
    week01.c. Its core consists of three lines of output, with the third line generated
    by a loop. The loop outputs days of the week, starting at Sunday. The current
    day is highlighted, as shown in the sample output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6 的源代码可以在在线仓库中找到，作为 week01.c。它的核心由三行输出组成，第三行由循环生成。循环从星期日开始输出星期，当前日期突出显示，如示例输出所示：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, this code isn’t perfect. If the first of the month falls on any
    day other than Sunday, you see output like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码并不完美。如果月初不是星期日，你会看到如下输出：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Likewise, at the end of the month, you can see output like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在月底，你可以看到如下输出：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For my first update to the code, I added another decision in the output: In
    the *for* loop, if the value of variable d is less than one, spaces are output
    instead of the day value. Likewise, spaces are output when the day value is greater
    than the number of days in the current month.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我对代码的第一次更新，我在输出中添加了另一个决策：在*for*循环中，如果变量d的值小于1，则输出空格而不是日期值。同样，当日期值大于当前月的天数时，也会输出空格。
- en: Determining the last day of the month requires more code. Specifically, you
    must add the mdays[] array that lists days of each month, and also the *february()*
    function, covered earlier in this chapter. This function is necessary to ensure
    that the proper number of days in February is known for the current year.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 确定月底需要更多的代码。具体来说，你必须添加一个mdays[]数组，该数组列出了每个月的天数，还需要添加*february()*函数，这个函数在本章前面已经介绍过。这个函数是必要的，以确保当前年份二月的天数是正确的。
- en: 'The mdays[] array is added to the code in the variable declaration part of
    the *main()* function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: mdays[]数组被添加到*main()*函数的变量声明部分：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The *february()* function is also added to the source code. After the *localtime()*
    function is called, the *february()* function is called to update the mdays[]
    array, element one:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*february()*函数也被添加到源代码中。在调用*localtime()*函数之后，调用*february()*函数来更新mdays[]数组，元素一：'
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The following code shows the updated *for* loop in the *main()* function. The
    first *if* decision outputs spaces for out-of-range dates. The *else* portion
    consists of the original *if-else* decision from the first version of the code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了*main()*函数中更新的*for*循环。第一个*if*决策输出超出范围的日期的空格。*else*部分由代码的第一个版本的原始*if-else*决策组成。
- en: Listing 13.7 The updated *for* loop found in week02.c
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.7 week02.c中找到的更新后的*for*循环
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ If date d is out of range, less than 1, or greater than the number of days
    in the current month, outputs spaces
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果日期d超出范围，小于1，或大于当前月的天数，则输出空格
- en: ❷ Outputs the current day with brackets
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出带括号的当前日
- en: ❸ Outputs other days without brackets
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出其他天数时不加括号
- en: 'This update to the source code is found in the online repository as week02.c.
    It accurately addresses the date overflow issues, as shown in this sample output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个源代码的更新可以在在线仓库中找到，作为week02.c。它准确地解决了日期溢出问题，如下面的示例输出所示：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'At the end of the month, the output now looks like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 月份结束时，输出现在看起来是这样的：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Delightfully awkward output happens when today is the first and it’s a Saturday:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当今天是星期六且是第一天时，会出现令人愉快的尴尬输出：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'I don’t want this program to show multiple weeks, which would eventually devolve
    it into a month program. No, what would be keen is to output those final days
    from the preceding month, like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我不希望这个程序显示多周，这最终会使其变成一个月程。不，更希望的是输出前一个月的最后几天，如下所示：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Both months are listed in the header because dates from both months appear in
    the output. The current date is highlighted so that an astute user (that’s you)
    can tell that the week is the last one of the previous year, but today’s date
    is New Year’s Day.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个月份的日期都出现在输出中，因此两个月份都列在标题中。当前日期被突出显示，以便精明的用户（也就是你）可以知道这个星期是去年最后一周，但今天的日期是新年第一天。
- en: 'This update to the code from week02.c requires the addition of a new variable,
    pmonth, which holds the value of the previous month. The pmonth calculation takes
    place after the current month’s value is read and stored in variable month:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从week02.c中更新的代码需要添加一个新变量pmonth，它包含上个月的值。pmonth的计算发生在读取并存储当前月值的变量month之后：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The previous month’s value is the current month’s value minus one. If it’s January
    (0), the previous month’s value is negative. The *if* test catches this condition,
    in which case the value of pmonth is set to 11, December.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 上个月的值是当前月值的减一。如果是1月（0），则上个月的值是负数。*if*测试捕获了这个条件，在这种情况下，pmonth的值被设置为11，即12月。
- en: 'Next, a series of tests are performed to determine which month names to output:
    a single month, the current and previous months, or the current and next months.
    These tests are illustrated here.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进行一系列测试以确定要输出哪些月份名称：单个月份、当前和上个月，或者当前和下个月。这些测试在此处展示。
- en: Listing 13.8 Tests to determine which months to output (from week03.c)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.8 确定要输出哪些月份的测试（来自week03.c）
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ When days from the previous month are calculated, shows the previous and current
    months
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当计算上个月的天数时，显示上个月和当前月
- en: ❷ Tests to see whether days from the next month are output
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试是否输出下个月的天数
- en: ❸ For December, outputs December and January directly
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于十二月，直接输出十二月和一月
- en: ❹ For other months, outputs the current and next month names
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于其他月份，输出当前月和下个月的名称
- en: ❺ No previous or next month dates appear in the output.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出中不显示前一个月或下一个月的日期。
- en: To output dates from the previous or next month, the *for* loop in the *main()*
    function must be modified. Again, an *if else-if else* structure is used, shown
    in the next listing. Calculations are made to generate the trailing dates from
    the previous month and the following dates from the next month.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出前一个月或下个月的日期，必须在 *main()* 函数中的 *for* 循环进行修改。再次使用 *if else-if else* 结构，如下一列表所示。进行计算以生成前一个月的尾随日期和下一个月的后续日期。
- en: Listing 13.9 The updated *for* loop (from week03.c)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.9 更新的 *for* 循环（来自 week03.c）
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ The previous month still has days to output.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 上个月仍有要输出的天数。
- en: ❷ Outputs the dates using the previous month’s number of days minus the value
    of variable d
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用上个月的天数减去变量 d 的值来输出日期
- en: ❸ If the value of variable d is greater than the number of days in the current
    month . . .
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果变量 d 的值大于当前月份的天数 . . .
- en: ❹ . . . outputs days from the next month using d minus the number of days in
    the current month
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ . . . 使用 d 减去当前月的天数来输出下个月的天数
- en: ❺ The final *else* block outputs days from the current month as-is.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 最终的 *else* 块以原样输出当前月的天数。
- en: 'These decisions look messy, but they’re required to fill in the proper dates
    for overlapping months. The full source code is available from the online repository
    as week03.c. Here’s a sample run:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策看起来很混乱，但它们是必要的，以填充重叠月份的正确日期。完整的源代码可以从在线仓库中获取，作为 week03.c。以下是一个示例运行：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Above, the next month and first day of the month are output for the current
    week, when today is December 26\. Similar output is shown when days from the previous
    month appear in the week:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，当今天是 12 月 26 日时，输出当前周的下一月和该月的第一天。当上个月的天数出现在该周时，也会显示类似的输出：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The program is pretty much complete at this point. Being a nerd, however, I
    always look for ways to improve upon the code. The only thing I can think to add
    is to output the current week number as well.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，程序已经基本完成。然而，作为一个极客，我总是寻找改进代码的方法。我能想到的唯一要添加的功能是输出当前的周数。
- en: Each year has 52 weeks, though they don’t fall in a regular pattern. After all,
    the first week of the year may have a few lingering days from December. From what
    I gather, when January 1 falls on a Wednesday or earlier in the week, it’s in
    the first week of the year. Otherwise, January 1 is part of week 52 from the previous
    year.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每年有 52 周，尽管它们并不遵循固定的模式。毕竟，新年的第一周可能包含来自十二月的几天。据我所知，当 1 月 1 日在星期三或更早的时候，它就是新年的第一周。否则，1
    月 1 日是上一年的第 52 周。
- en: An exception occurs during leap years when January 1 falls on a Thursday. Though
    it could be week 52 of the preceding year, a leap year can have 53 weeks. The
    next time a year has 53 weeks is in 2032—so hang on to this book!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在闰年中，当 1 月 1 日在星期四时，会发生异常。尽管它可能是前一年的第 52 周，但闰年可以有 53 周。下一个有 53 周的年份是 2032 年——所以请保留这本书！
- en: 'My first attempt to calculate the current week number resulted in this formula:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次尝试计算当前周数的结果是这个公式：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The day_of_the_year value is kept in the tm structure as member tm_yday. The
    weekday value is tm structure member tm_wday, where Sunday is zero. The expression
    is divided by seven, which is rounded as an integer value and stored in variable
    weekno.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 年内天数值存储在 tm 结构的成员 tm_yday 中。星期值是 tm 结构的成员 tm_wday，其中星期天为零。表达式除以 7，四舍五入为整数并存储在变量
    weekno 中。
- en: 'The value of weekno must be tested for the first week of the year—specifically,
    when the first of January falls late in the week. In this configuration, the weekno
    value returned by the equation is 0\. It should be 52, as it’s technically the
    last week of the previous year. Therefore, some adjustment is necessary before
    the value is output:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 必须测试 weekno 的值，以确定新年的第一周——特别是当 1 月 1 日在周中较晚的时候。在这种情况下，由方程返回的 weekno 值为 0。它应该是
    52，因为技术上它是上一年的最后一周。因此，在输出值之前需要进行一些调整：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To complete the code update from week03.c, you must remove all the newlines
    from the *printf()* statement that outputs the current month or pair of months.
    Follow these statements with a new *printf()* statement:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成来自 week03.c 的代码更新，你必须从输出当前月或一对月份的 *printf()* 语句中删除所有换行符。然后跟上一个新的 *printf()*
    语句：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The final program is available in the online repository as week04.c. Here is
    a sample run:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最终程序以week04.c的形式存储在在线仓库中。以下是一个示例运行：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here is the output for January 1 of the same week:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同一周1月1日的输出：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: By the way, you can also use the *strftime()* function to obtain the current
    week number. The placeholder is %W, but it reports the first day of the week as
    Monday. The week number value is set into a string, which must be converted to
    an integer to perform any math. Like the formula I chose to use for my update
    to the code, the *strftime()* function returns 0 for the first week of the year.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你也可以使用*strftime()*函数来获取当前的周数。占位符是%W，但它将周一作为一周的第一天。周数值被设置到一个字符串中，必须将其转换为整数才能进行任何数学运算。就像我选择用于代码更新的公式一样，*strftime()*函数在年初的第一周返回0。
- en: 13.3.2 Showing a month
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 显示月份
- en: 'The month program was the first calendar program I wrote. I used it to help
    with my C programming blog posts ([https://c-for-dummies.com/blog](https://c-for-dummies.com/blog)),
    which I write in advance and schedule for later. Obviously, I could use the *cal*
    program, which outputs the current month as a default:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 月份程序是我写的第一个日历程序。我使用它来帮助我的C编程博客文章（[https://c-for-dummies.com/blog](https://c-for-dummies.com/blog)），我提前写好并安排在以后发布。显然，我可以用*cal*程序，它默认输出当前月份：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Oh, and the *cal* program does lots of other things, too. But I didn’t let
    its flexibility stop me. Here is the output from my program, which I call *month*:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，*cal*程序还能做很多事情。但我没有让它的高度灵活性阻止我。以下是我程序的输出，我称之为*month*：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The output is a bit wider, which I find more readable—even back before I needed
    reading glasses. After all, my goal is to output the current month. The dimensions
    of the *cal* program’s output are designed so that the entire year can be shown
    three months wide by three columns deep. My *month* program could output months
    three wide, but the text won’t fit on an 80-column screen. I touch upon this issue
    later in this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 输出稍微宽一些，我觉得更易读——甚至在我需要阅读眼镜之前。毕竟，我的目标是输出当前月份。*cal*程序输出的尺寸设计得如此之好，以至于整个年份可以以三个月宽、三列深的方式显示。我的*month*程序可以输出三个月份，但文本无法适应80列屏幕。我在本章的后面会提到这个问题。
- en: 'A month of dates is really a grid: rows for weeks and columns for days of the
    week. It’s not a full grid because the starting point occurs at a specific column;
    the first row of output is special. The rest of the days of the month flow through
    the grid until the last day, when output stops.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个月的日期实际上是一个网格：行代表周，列代表星期。它不是一个完整的网格，因为起始点位于特定的列；输出的第一行是特殊的。其余的日期通过网格流动，直到最后一天，输出停止。
- en: 'The following listing shows my test code to ensure that the month program works.
    It outputs the month of December 2021\. The focus is on the nested loop: the *while*
    loop uses the variable day to churn through days of the month. The inner *for*
    loop processes weeks. The first week is special, which outputs blanks for days
    from the previous month.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了我的测试代码，以确保月份程序能够正常工作。它输出了2021年12月。重点是嵌套循环：*while*循环使用变量day遍历月份中的每一天。内层的*for*循环处理周。第一周是特殊的，它为上个月的天数输出空白。
- en: Listing 13.10 Source code for month01.c
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.10 month01.c的源代码
- en: '[PRE67]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ❶ Presets the number of days in the month (for December)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预设本月的天数（例如十二月）
- en: ❷ Sets today as the 27th
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将今天设置为27号
- en: ❸ The first day of the month is on Wednesday.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 本月的第一个星期三。
- en: ❹ Starts with the day counter at 1, the first day of the month
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从1开始，即本月的第一天
- en: ❺ Loops through the days of the month
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 遍历月份中的每一天
- en: ❻ Loops through a week, Sunday (0) through Saturday (6)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 遍历一周，从周日（0）到周六（6）
- en: ❼ Checks for the first week of the month
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 检查月份的第一周
- en: ❽ Outputs blanks-and do not increment the day counter!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 输出空白，并且不增加天数计数器！
- en: ❾ Outputs days, now that the first week/day has passed
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 在第一周/天过去后输出日期
- en: ❿ Highlights today
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 突出显示今天
- en: ⓫ Regular day output
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 正常输出日期
- en: ⓬ Increments the day counter
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 增加天数计数器
- en: ⓭ Exits the loop after the last day of the month
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 在月底的最后一天退出循环
- en: 'From listing 13.10, in the *for* loop you can see that the first week of the
    month is handled differently from the remaining weeks. No output should occur
    before the first day of the month. Variable first holds the weekday value—3 for
    Wednesday—so the *if* test is TRUE for days before the first of the month:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表 13.10 中，在 *for* 循环中可以看到，这个月的第一周与其他周的处理方式不同。在月份的第一天之前不应有任何输出。变量 first 保存的是星期值——3
    代表星期三——因此，在月份第一天之前的 *if* 测试是 TRUE：
- en: '[PRE68]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Variable d tracks days of the week, Sunday through Saturday (0 through 6). Variable
    first holds the day of the week on which the first of the month falls. Variable
    day represents the day of the month.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 d 跟踪一周中的天数，从星期日到星期六（0 到 6）。变量 first 保存的是月份第一天的星期。变量 day 代表月份中的某一天。
- en: When the first of the month is encountered, the *else* portion of the *if* decision
    takes over, outputting the rest of the month grid. Sample output for this version
    of the month program is shown earlier. The source code file month01.c is available
    in the online repository.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到月份的第一天时，*if* 决策的 *else* 部分接管，输出月份网格的其余部分。此版本月份程序的示例输出在前面已展示。源代码文件 month01.c
    可在在线仓库中找到。
- en: I messed with variables mdays, today, and first to ensure that the month program
    output the various month configurations. The next step to improve the code is
    to use the current month’s data. This improvement requires several steps.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我对变量 mdays、today 和 first 进行了调整，以确保月份程序输出各种月份配置。改进代码的下一步是使用当前月份的数据。这一改进需要几个步骤。
- en: First, the code must include the *february()* and *thefirst()* functions, covered
    earlier in this chapter. You need to add the *february()* function to complete
    a proper mdays[] array, which contains days of the month for the current year.
    The other function lets you know upon which weekday the first of the month falls.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码必须包含前面在本章中介绍的 *february()* 和 *thefirst()* 函数。您需要添加 *february()* 函数以完成包含当前年份每月天数的
    mdays[] 数组。另一个函数可以告诉您月份的第一天是星期几。
- en: 'Second, the variable declarations are updated to include the month name constants,
    mdays[] array, and other variables required to report the current month’s dates:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，变量声明被更新，包括月份名称常量、mdays[] 数组和其他报告当前月份日期所需的变量：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Third, the *time()* and *localtime()* functions are called to obtain details
    about the current date:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，调用了 *time()* 和 *localtime()* 函数以获取当前日期的详细信息：
- en: '[PRE70]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Fourth, the current date info is packed into the variables month, today, weekday,
    and year. February’s days are updated with a call to the *february()* function,
    and variable first is set to the day of the week upon which the first of the month
    falls:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，当前日期信息被打包到变量 month、today、weekday 和 year 中。通过调用 *february()* 函数更新了二月份的天数，并将变量
    first 设置为月份第一天的星期：
- en: '[PRE71]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Fifth, the *printf()* statement to output the current month and year is updated:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第五，更新了输出当前月份和年份的 *printf()* 语句：
- en: '[PRE72]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: And finally, the mdays variable in the original source code file must be replaced
    by mdays[month] in the final version.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，原始源代码文件中的 mdays 变量必须替换为最终版本中的 mdays[month]。
- en: This update to the code is titled month02.c, available in the online repository.
    Unlike the original, static program, this version outputs the current month.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这个更新版本被命名为 month02.c，可在在线仓库中找到。与原始的静态程序不同，这个版本会输出当前月份。
- en: Exercise 13.3
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 13.3
- en: 'The *month* program’s output lists the current month and year as the top heading
    but right-justified. Update the code to create a new function, center(). The function’s
    purpose is to output a string of text centered within a certain width. Here is
    the prototype to use:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*month* 程序的输出将当前月份和年份作为顶部标题列出，但右对齐。更新代码以创建一个新的函数，center()。该函数的目的是在特定宽度内输出文本字符串。以下是使用的原型：'
- en: '[PRE73]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The function calculates the length of string text and then does the fancy math
    to center the string within the given width. If the string is longer than the
    width, it’s output and truncated to the width.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数计算字符串 text 的长度，然后进行复杂的数学计算以在给定的宽度内居中字符串。如果字符串比宽度长，则输出并截断到宽度。
- en: Making this update to the month02.c code involves more than just writing the
    *center()* function. Ensure that the function is called with the proper string
    arguments and that the result is output atop the calendar. My solution is titled
    month03.c, and it’s available in the online repository.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对 month02.c 代码的这次更新不仅仅是编写 *center()* 函数。确保以正确的字符串参数调用该函数，并且结果应输出在日历的顶部。我的解决方案被命名为
    month03.c，并且可在在线仓库中找到。
- en: Exercise 13.4
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Exercise 13.4
- en: No, you’re not quite done with the month program. Your final task is to modify
    the *main()* function from month03.c (see the preceding exercise) so that any
    command-line arguments are parsed as a month-and-year value. Both values must
    be present and valid; otherwise, the current month is output. My solution is available
    in the online repository as month04.c.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: No, you’re not quite done with the month program. Your final task is to modify
    the *main()* function from month03.c (see the preceding exercise) so that any
    command-line arguments are parsed as a month-and-year value. Both values must
    be present and valid; otherwise, the current month is output. My solution is available
    in the online repository as month04.c.
- en: 13.3.3 Displaying a full year
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.3 Displaying a full year
- en: The issue with outputting a full year has nothing to do with fancy date coding;
    the math and functions required are already presented so far in this chapter.
    The problem is getting the output correct—rows and columns.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: The issue with outputting a full year has nothing to do with fancy date coding;
    the math and functions required are already presented so far in this chapter.
    The problem is getting the output correct—rows and columns.
- en: Figure 13.2 shows the output from a *year* program that uses the same format
    as the *months* program, shown earlier in this chapter. You see three columns
    by four rows of months. Steam output generates the text, one row at a time. Some
    coordination is required to produce the visual effect you see in the figure. Further,
    the output is far too wide for a typical 80-column text screen. So, while the
    math and functions might be known, fine-tuning the output is the big issue.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 13.2 shows the output from a *year* program that uses the same format
    as the *months* program, shown earlier in this chapter. You see three columns
    by four rows of months. Steam output generates the text, one row at a time. Some
    coordination is required to produce the visual effect you see in the figure. Further,
    the output is far too wide for a typical 80-column text screen. So, while the
    math and functions might be known, fine-tuning the output is the big issue.
- en: '![13-02](Images/13-02.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![13-02](Images/13-02.png)'
- en: Figure 13.2 Output from a *year* program that uses the same format as the *month*
    program
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 13.2 Output from a *year* program that uses the same format as the *month*
    program
- en: Rather than go hog-wild and attempt to code a multicolumn year program all at
    once, I sought to first code a long vertical column for the current year. The
    code, year01.c, is available in the online repository. It uses the existing *center()*
    and *february()* functions.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Rather than go hog-wild and attempt to code a multicolumn year program all at
    once, I sought to first code a long vertical column for the current year. The
    code, year01.c, is available in the online repository. It uses the existing *center()*
    and *february()* functions.
- en: The *main()* function consists of two parts. The first part initializes all
    variables to a specific year. I chose the year 2000\. The code sets the weekday
    for January 1, which starts the entire year. Once established, the second part
    of the *main()* function consists of a loop to output the months.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: The *main()* function consists of two parts. The first part initializes all
    variables to a specific year. I chose the year 2000\. The code sets the weekday
    for January 1, which starts the entire year. Once established, the second part
    of the *main()* function consists of a loop to output the months.
- en: The following listing shows the initialization portion of the *main()* function.
    The code is cobbled together from the *month* series of programs, though the program
    doesn’t scan command-line input.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: The following listing shows the initialization portion of the *main()* function.
    The code is cobbled together from the *month* series of programs, though the program
    doesn’t scan command-line input.
- en: Listing 13.11 Initialization in the *main()* function from year01.c
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13.11 Initialization in the *main()* function from year01.c
- en: '[PRE74]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ Constants and stuff from earlier date code
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Constants and stuff from earlier date code
- en: ❷ Y2K is hardcoded here, minus 1900 for the tm structure.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Y2K is hardcoded here, minus 1900 for the tm structure.
- en: ❸ Remember to set hours, minute, and seconds.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Remember to set hours, minute, and seconds.
- en: ❹ You must set the time zone, or else January 1 may fall in the previous year.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ You must set the time zone, or else January 1 may fall in the previous year.
- en: ❺ Updates the tm date structure, specifically with the weekday value
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ Updates the tm date structure, specifically with the weekday value
- en: ❻ Uses weekday for readability and to save typing molecules
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ Uses weekday for readability and to save typing molecules
- en: ❼ Adjusts the year value
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Adjusts the year value
- en: ❽ Sets the proper number of days in February
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Sets the proper number of days in February
- en: It’s important that the time zone be set to GMT, as shown in listing 13.11\.
    In my original code, I forgot to do this step—even though I warned about doing
    so earlier in this chapter—and the oversight caused lots of grief. As I was testing
    the code late in the evening, the years and dates were off. Only by asserting
    GMT as the time zone does the calendar year properly render, no matter what your
    time zone.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: It’s important that the time zone be set to GMT, as shown in listing 13.11\.
    In my original code, I forgot to do this step—even though I warned about doing
    so earlier in this chapter—and the oversight caused lots of grief. As I was testing
    the code late in the evening, the years and dates were off. Only by asserting
    GMT as the time zone does the calendar year properly render, no matter what your
    time zone.
- en: The *main()* function’s nested loops are shown next. They consist of an outer
    *for* loop to process the months and an inner while loop to process days of the
    month. Variable dow counts weekdays. It’s updated manually as opposed to being
    in a loop because the first weekday of the month isn’t the same for every month.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个展示了 *main()* 函数的嵌套循环。它们由一个外部 *for* 循环处理月份和一个内部 while 循环处理月份中的天数组成。变量 dow
    计算工作日。它是手动更新的，而不是在循环中，因为每个月的第一天工作日并不相同。
- en: Listing 13.12 The output loop from the *main()* function in year01.c
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.12 year01.c 中 *main()* 函数的输出循环
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ❶ The weekday loop variable, day-of-the-week
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 星期几循环变量，星期几
- en: ❷ The outer loop pages through months of the year.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 外部循环遍历年份的月份。
- en: ❸ Outputs the month and year, centered, and the weekday header row
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出居中的月份和年份，以及星期几标题行
- en: ❹ Initializes the day of the month, the first
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 初始化月份的第一天
- en: ❺ Loops through the days of the month
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 遍历月份中的每一天
- en: ❻ The first week is special; variable weekday holds the first weekday of the
    month. Outputs blanks before then.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 第一周是特殊的；变量星期几持有该月的第一天工作日。在此之前的输出为空白。
- en: ❼ Outputs the date
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出日期
- en: ❽ Increments the day of the week, Sunday (0) through Saturday (6)
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 增加星期几的天数，从星期日（0）到星期六（6）
- en: ❾ Checks for weekday overflow
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 检查星期几溢出
- en: ❿ Resets the day of the week back to Sunday (0)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 将星期几重置为星期日（0）
- en: ⓫ Outputs a newline for the next week
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 为下一周输出一个换行符
- en: ⓬ Increments the day of the month counter
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 增加月份的天数计数器
- en: ⓭ Tests for the end of the month
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 测试月份的结束
- en: ⓮ Sets the first day of the month for next month
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ⓮ 设置下一个月的第一天
- en: ⓯ Resets the day of the week back to Sunday for the next month
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ⓯ 将星期几重置为下一个月的星期日
- en: Variable dow works with variable weekday to output the first week of January.
    Afterward, variables weekday and dow are updated so that the following month’s
    start day is properly set.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 dow 与变量 weekday 一起使用，以输出一月份的第一周。之后，变量 weekday 和 dow 被更新，以便正确设置下一个月的开始日。
- en: 'The full code is available in the online repository as year01.c. Here is the
    first part of the output:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可在在线仓库中找到，作为 year01.c。以下是输出的一部分：
- en: '[PRE76]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Each month follows, all down one long page of text. The output is accurate for
    the year 2000, but who wants to relive that?
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 每个月都跟随，全部在一页长的文本中。输出对于 2000 年是准确的，但谁想重温那段时光呢？
- en: Exercise 13.5
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 13.5
- en: Modify the year01.c code so that it accepts a command-line argument for the
    year to output. When a command-line argument isn’t available, the current year
    is output. The changes necessary all take place in the main() function. Remember
    that the year input and the tm_year value differ by 1900.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 year01.c 代码，使其接受一个命令行参数以输出年份。如果没有提供命令行参数，则输出当前年份。所有必要的更改都发生在 main() 函数中。记住，年份输入和
    tm_year 值相差 1900。
- en: My solution is named year02.c and is found in the online repository. Comments
    in the code explain my approach.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案命名为 year02.c，并可在在线仓库中找到。代码中的注释解释了我的方法。
- en: 13.3.4 Putting the full year into a grid
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.4 将整年放入网格中
- en: To output a full year of months in a grid on a text screen requires that it
    be output one row at a time. The approach used in the year01.c code just won’t
    work; stream output doesn’t let you back up or move the cursor on the text screen.
    Each line must be processed one a time, with multiple steps required to output
    different dates for different months. So, I threw out most of the year01.c code
    to start over.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文本屏幕上以网格形式输出整年的月份，需要逐行输出。year01.c 代码中使用的这种方法不起作用；流输出不允许你在文本屏幕上回退或移动光标。每一行必须一次处理，输出不同月份的不同日期需要多个步骤。因此，我丢弃了
    year01.c 代码的大部分内容，从头开始。
- en: 'The calendar still progresses month by month. But the months are organized
    into columns. For each column, individual rows for each month are output. Figure
    13.3 illustrates this approach, with each month output a row at a time: two header
    rows, a special first week of the month row, and then the remaining weeks in the
    month. Each month must output six weeks, even when the month has only five weeks
    of dates.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 日历仍然按月递进。但月份被组织成列。对于每一列，输出每个月的单独行。图 13.3 阐述了这种方法，每个月一次输出一行：两个标题行，一个月的特殊第一周行，然后是该月的剩余周。每个月必须输出六周，即使该月只有五周的日期。
- en: '![13-03](Images/13-03.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![13-03](Images/13-03.png)'
- en: Figure 13.3 The approach to output a multicolumn display
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 输出多列显示的方法
- en: To start working on the code, I copied the *center()* and *february()* functions
    from the existing *year* source code files. The *main()* function retains most
    of the setup required for the year02.c update to read a command-line argument.
    From this base, I built the rest of the code.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写代码，我从现有的 *year* 源代码文件中复制了 *center()* 和 *february()* 函数。*main()* 函数保留了大部分为更新
    year02.c 以读取命令行参数所需的设置。在此基础上，我构建了其余的代码。
- en: 'From the top down, the first change is to add a defined constant, COLUMNS:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下，第一个更改是添加一个定义的常量，COLUMNS：
- en: '[PRE77]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This symbolic constant sets the number of columns wide for the output, but
    it’s not a value the user should change: valid values for COLUMNS are limited
    to factors of 12\. You can change the definition to two, three, four, six, or
    even 12\. But if you use another value, the arrays in the code will overflow.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个符号常量设置了输出列的宽度，但用户不应该更改这个值：COLUMNS 的有效值限于 12 的因子。你可以将其定义为 2、3、4、6 或甚至 12。但如果你使用其他值，代码中的数组将会溢出。
- en: The next update required is to the *center()* function. As used earlier in this
    chapter, the function centers the month and year within a given width but doesn’t
    pad out the rest of the row of text. To line up the months in a grid, the header
    row one must be output at a consistent size. The next listing shows the required
    updates to the *center()* function for row-by-row output. The width argument centers
    the text *and* sets the number of spaces to pad on both sides.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要更新的函数是 *center()*。如本章前面所述，该函数在给定的宽度内居中月份和年份，但不填充文本的其余部分。为了使月份在网格中对齐，标题行一必须以一致的大小输出。下一个列表显示了为逐行输出所需的
    *center()* 函数更新。宽度参数居中文本并设置两侧填充的空格数。
- en: Listing 13.13 The updated *center()* function
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.13 更新的 *center()* 函数
- en: '[PRE78]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ❶ Instead of a *puts()* function, outputs the string one character at a time
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用输出字符串的每个字符代替 *puts()* 函数
- en: ❷ Outputs each character
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出每个字符
- en: ❸ Increments the pointer
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 增加指针
- en: ❹ Tracks variable s to determine the final output width
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 跟踪变量 s 以确定最终输出宽度
- en: ❺ Outputs spaces to match the width value
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出空格以匹配宽度值
- en: 'With the *center()* function updated, my approach is to output only the first
    row by itself—just to see whether it works. The program outputs header row one,
    the month and year. I used this code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新 *center()* 函数后，我的方法是通过单独输出第一行来测试——只是为了看看它是否工作。程序输出了标题行一，月份和年份。我使用了以下代码：
- en: '[PRE79]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ❶ Skips over every COLUMN month to output rows
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跳过每个 COLUMN 月份以输出行
- en: ❷ Three spaces
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 三个空格
- en: 'The *prntf()* statement outputs three spaces to keep each month/year header
    separated in the grid. This program serves as a test to ensure that the grid is
    output in the order I want. Here’s a sample run, minus a few spaces to fit on
    this page:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*prntf()* 语句输出三个空格，以保持每个月/年标题在网格中分开。这个程序作为测试，以确保网格按我想要的顺序输出。以下是一个示例运行，减去一些空格以适应这一页：'
- en: '[PRE80]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Adding the weekday header row is the next step. It requires a second *for*
    loop inside the outer month loop. In fact, each row of output represents a *for*
    loop in the code. These statements are inserted after the putchar(''\n'') statement
    ending the previous *for* loop, which also adds spaces to separate the columns:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 添加星期标题行是下一步。它需要在外部月份循环内部添加第二个 *for* 循环。实际上，输出中的每一行代表代码中的一个 *for* 循环。这些语句插入在结束上一个
    *for* 循环的 putchar('\n') 语句之后，这也为分隔列添加了空格：
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: At this point, I became confident that I could output the year calendar in a
    grid. The key was to use sequential *for* loops, one for each row in the month.
    The last statement in each *for* loop pads spaces to keep the month grids separate
    in each column.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我对自己有信心，可以以网格的形式输出年日历。关键是使用顺序的 *for* 循环，每个月一行。每个 *for* 循环中的最后一个语句填充空格，以保持每个月网格在每列中分开。
- en: 'The most difficult row to output is the first week of the month. As with the
    other calendar programs in this chapter, the first day of the month starts on
    a specific weekday. I could use the *first()* function to determine each month’s
    starting weekday, but instead I created an array in the *main()* function:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最难输出的行是月份的第一周。与其他章节中的其他日历程序一样，月份的第一天从特定的星期几开始。我可以用 *first()* 函数确定每个月的起始星期几，但相反，我在
    *main()* 函数中创建了一个数组：
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The dotm[] (day of the month) array holds the starting day for each month in
    the year. Its values are the same as the weekday variable, 0 through 6\. The weekday
    variable already holds the day of the week for January 1\. It’s stored in element
    0 of the dotm[] array. A *for* loop then fills in values for the remaining months:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: dotm[]（月份的日期）数组保存了每年每个月的起始日。它的值与 weekday 变量相同，0到6。weekday 变量已经保存了1月1日的周几，存储在
    dotm[] 数组的第0个元素中。然后一个 *for* 循环填充剩余月份的值：
- en: '[PRE83]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The statement in the *for* loop totals the values of the number of days in the
    previous month, mdays[month-1], with the starting day of the week for the previous
    month, dotm[month-1]. This total is modulo 7, which yields the starting day of
    the week for the month represented by variable month. When the loop is complete,
    the dotm[] array holds the starting weekday for the first of each month in the
    given year.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*for* 循环中的语句将上个月的天数 mdays[month-1] 与上个月每周的起始日 dotm[month-1] 相加。这个总和模7，得到变量
    month 表示的月份的每周起始日。当循环完成后，dotm[] 数组将保存给定年份每个月第一天的起始周几。'
- en: Listing 13.14 shows the next nested *for* loop that generates the first row
    for each month of the year. The starting value in the dotm[] array determines
    which weekday starts the month. The day of the month, starting with one, is stored
    in variable day.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.14显示了生成每年每个月第一行的下一个嵌套 *for* 循环。dotm[] 数组中的起始值决定了哪一天开始这个月。从1开始，月份的日期存储在变量
    day 中。
- en: Listing 13.14 The third nested *for* loop, outputting the first week of each
    month
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.14 第三层嵌套 *for* 循环，输出每年每个月的第一周
- en: '[PRE84]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ❶ Initializes the day of the month
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化月份的日期
- en: ❷ Loops through days of the week
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历每周的日期
- en: ❸ If the first of the month weekday hasn’t happened, outputs a space
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果月份的第一天周几尚未发生，则输出一个空格
- en: ❹ Otherwise, outputs the day, as was done in the other calendar programs
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则，输出日期，就像在其他日历程序中做的那样
- en: ❺ Increments the day of the month
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 增加月份的日期
- en: ❻ After the month’s week is output, pads two spaces
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在输出月份的周之后，填充两个空格
- en: ❼ Saves the day of the month for output on the next row’s Sunday position
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 保存下个行星期日位置的月份日期
- en: 'Most of the *for* loop shown in listing 13.14 is borrowed from code presented
    earlier in this chapter. What’s different is saving the day of the month for the
    next row’s output: dotm[month+c] = day. This value, available in variable day,
    replaces the starting day of the month in the dotm[] array. It’s used to output
    the next row, to set the day of the month value for the next Sunday.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.14中显示的大多数 *for* 循环是从本章前面展示的代码中借用的。不同的是，保存下一天数的月份输出：dotm[month+c] = day。这个值，可用变量
    day，替换了 dotm[] 数组中的月份起始日。它用于输出下一行，设置下个星期日的月份值。
- en: The final *for* loop is responsible for outputting rows two through six for
    each month. It includes a nested for loop for each day of the week, with the outer
    *for* loop processing each week. The following listing shows the details, which
    again use the dotm[] array to hold the starting day for each subsequent week.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 *for* 循环负责输出每个月的2到6行。它包括一个嵌套的 *for* 循环，用于处理每周的每一天，外部的 *for* 循环处理每一周。以下列表显示了详细信息，它再次使用
    dotm[] 数组来保存每个后续周的起始日。
- en: Listing 13.15 The final *for* loops for the *main()* function
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.15 *main()* 函数的最终 *for* 循环
- en: '[PRE85]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ❶ Six weeks for each month, regardless of whether the month has a sixth week
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个月6周，无论该月是否有第六周
- en: ❷ Output is by column first—each column and then each week (outer loop).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 首先按列输出——每个列然后每个周（外部循环）。
- en: ❸ Updates the day of the month for Sunday output
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新星期日输出的月份日期
- en: ❹ The innermost (fourth-nested) loop outputs weekdays.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 最内层（第四层嵌套）的循环输出工作日。
- en: ❺ For valid days of the current month, outputs the day number
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于当前月份的有效日期，输出日期数字
- en: ❻ Outputs blanks for days beyond the last day of the month
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出超过最后一天日期的空白
- en: ❼ Pads two spaces between weeks
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在周之间填充两个空格
- en: ❽ Updates the day for next week’s Sunday
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 更新下个星期日的日期
- en: ❾ End of the row of weeks
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 行周结束
- en: ❿ End of the month—space between this row of months and the next
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 月份结束——本行月份与下一行月份之间的空格
- en: Because the starting day of the week is saved in the dotm[] array, the triple
    nested loops shown in listing 13.15 have an easy time outputting weeks for each
    row and then each month in the larger grid row.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每周的起始日已经保存在 dotm[] 数组中，所以列表13.15中显示的三层嵌套循环很容易输出每行的周和更大网格行中的每个月的周。
- en: The updated code for the *year* program is available in the online repository
    as year03.c. The output is shown in figure 13.2\. I’ve adjusted the COLUMNS value
    to 2 and then 4, and the code still performs well. It also handles the year as
    a command-line argument. But it’s just too wide!
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*year* 程序的更新代码可在在线仓库中找到，文件名为 year03.c。输出结果如图 13.2 所示。我已经调整了 COLUMNS 值为 2 和
    4，代码仍然表现良好。它还能处理命令行参数中的年份。但它的宽度太宽了！'
- en: Yes, you can adjust the terminal window for your operating system. Still, I
    like a cozy 80-by-24 window, just like grandpa used. Though I could adjust the
    output width for days of the week, making it narrower like the *cal* program,
    a better way to condense things might be to color-code the output.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以调整操作系统的终端窗口。尽管如此，我还是喜欢像爷爷那样舒适的 80 行 x 24 列的窗口。尽管我可以调整星期的输出宽度，使其像 *cal*
    程序一样变窄，但可能更好的方法是通过颜色编码输出。
- en: 13.4 A calendar in color
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 彩色日历
- en: Text mode need not be as boring as it was at the height of its unpopularity
    in the early 1980s. Yes, many people had text-only displays because it was cheaper.
    Early graphics systems, primitive beyond belief by today’s standards, were pricey.
    Early PC monochrome monitors could output text in normal or high intensity (brightness),
    inverse, and underline. Some data terminals output text in color, as did a few
    home computers.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 文本模式不必像在 20 世纪 80 年代初其不受欢迎的高峰期那样无聊。是的，许多人因为便宜而使用纯文本显示。早期的图形系统，按照今天的标准来看，是如此原始，以至于价格昂贵。早期的
    PC 单色显示器可以输出正常或高强度的文本（亮度），反色和下划线。一些数据终端以彩色输出文本，一些家用电脑也是如此。
- en: As costs came down, color text became more common. Early word processors highlighted
    onscreen text in various colors to show different attributes and fonts. Colorful
    text programs, databases, spreadsheets, and such were all the rage—until graphical
    operating systems took over. Then color text took the backseat, where it’s been
    ever since.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 随着成本的降低，彩色文本变得更加常见。早期的文字处理器以各种颜色突出显示屏幕上的文本，以显示不同的属性和字体。彩色文本程序、数据库、电子表格等都非常流行——直到图形操作系统接管。然后彩色文本退居次要位置，一直如此。
- en: Color text can aid in program visibility. It’s easier to identify different
    parts of the screen when the text is colored differently. Add in Unicode fancy
    characters, and the text terminal has a potential for output more interesting
    than just letters and numbers.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色文本可以有助于程序的可视化。当文本以不同颜色显示时，更容易识别屏幕上的不同部分。再加上 Unicode 的花哨字符，文本终端的输出潜力就不仅仅是字母和数字了。
- en: 13.4.1 Understanding terminal colors
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 理解终端颜色
- en: Text output in the terminal windows can be whatever the boring default is, such
    as green on black, but your options aren’t limited to the terminal window’s settings.
    Your programs can generate a variety of colors—eight foreground and eight background
    for up to 64 combinations, many of them annoying or invisible. To make this rainbow
    magic happen, the program outputs ANSI color sequences. As most terminals are
    ANSI-color compatible, all you need to know are the proper ANSI escape sequences.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 终端窗口中的文本输出可以是任何无聊的默认设置，例如绿色背景，但你的选项不仅限于终端窗口的设置。你的程序可以生成各种颜色——最多 64 种组合，包括 8
    种前景色和 8 种背景色，其中许多令人烦恼或看不见。要实现这种彩虹魔法，程序需要输出 ANSI 颜色序列。由于大多数终端都兼容 ANSI 颜色，你只需要知道正确的
    ANSI 转义序列。
- en: An ANSI escape sequence is a series of characters, the first of which is the
    escape character, ASCII 27, hex 1B. This character must be output directly; you
    can’t press the keyboard’s Esc key to pull off this trick. The remainder of the
    characters follow a pattern, which are numerical codes representing various colors.
    The final character is m, which signals the end of the escape sequence, as illustrated
    in figure 13.4.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI 转义序列是一系列字符，第一个是转义字符，ASCII 27，十六进制 1B。这个字符必须直接输出；你不能按键盘的 Esc 键来完成这个技巧。其余的字符遵循一个模式，这些是代表各种颜色的数字代码。最后的字符是
    m，它表示转义序列的结束，如图 13.4 所示。
- en: '![13-04](Images/13-04.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![13-04](Images/13-04.png)'
- en: Figure 13.4 The format for an ANSI color text escape sequence
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 ANSI 颜色文本转义序列的格式
- en: Text output that follows the ANSI sequence appears in the specified attributes
    or colors. To change colors, issue a new escape sequence. To restore terminal
    colors, a reset escape sequence is given.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 ANSI 顺序输出的文本将显示为指定的属性或颜色。要更改颜色，发出一个新的转义序列。要恢复终端颜色，给出一个重置转义序列。
- en: Table 13.1 lists the basic character effects or attributes available with ANSI
    escape sequences. The escape character is listed as hex value \x1b, how it appears
    as a character in C.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 列出了使用 ANSI 转义序列可用的基本字符效果或属性。转义字符列为例值 \x1b，以及它在 C 中的字符表示。
- en: Table 13.1 ANSI text effects
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 ANSI 文本效果
- en: '| Effect | Code | Sequence |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| 效果 | 代码 | 序列 |'
- en: '| Reset | 0 | \x1b[0m |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 重置 | 0 | \x1b[0m |'
- en: '| Bold | 1 | \x1b[1m |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| 粗体 | 1 | \x1b[1m |'
- en: '| Faint | 2 | \x1b[2m |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 细体 | 2 | \x1b[2m |'
- en: '| Underline | 4 | \x1b[4m |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| 下划线 | 4 | \x1b[4m |'
- en: '| Blinking | 5 | \x1b[5m |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 闪烁 | 5 | \x1b[5m |'
- en: '| Inverse | 7 | \x1b[7m |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| 反白显示 | 7 | \x1b[7m |'
- en: Not all attributes shown in table 13.1 are available in every terminal window.
    Just in case, the test program shown in the next listing creates defined constant
    strings for the escape sequences and then outputs each one a line at a time.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 中显示的并非所有属性在所有终端窗口中都可用。为了以防万一，下一个列表中显示的测试程序为转义序列创建定义的常量字符串，然后逐行输出每个字符串。
- en: Listing 13.16 Source code for ansi01.c
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.16 ansi01.c 的源代码
- en: '[PRE86]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Running the program for ansi01.c yielded mixed results on my various computers.
    The Mac Terminal window shows the output the best, including blinking text, which
    is most annoying. Ubuntu Linux in Windows 10/11 shows underlined text well. The
    rest of my computers were a mixed bag. Again, remember that you can obtain another
    terminal program if the one your OS provides shows less than spectacular results.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的各种计算机上运行 ansi01.c 得到了混合的结果。Mac 终端窗口显示的输出最好，包括闪烁的文本，这非常令人烦恼。Windows 10/11
    中的 Ubuntu Linux 很好地显示了下划线文本。其余的计算机则是一个混合体。再次提醒，如果你的操作系统提供的终端程序显示的结果不够出色，你可以获取另一个终端程序。
- en: The ANSI color code sequences are shown in table 13.2\. Codes in the 30s represent
    foreground colors; codes in the 40s are background colors.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI 颜色代码序列显示在第 13.2 表中。30s 代码表示前景颜色；40s 代码表示背景颜色。
- en: Table 13.2 ANSI color-code escape sequences
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.2 ANSI 颜色代码转义序列
- en: '| Color | Foreground Code | Background Code | Foreground Sequence | Background
    Sequence |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 颜色 | 前景代码 | 背景代码 | 前景序列 | 背景序列 |'
- en: '| Black | 30 | 40 | \x1b[30m | \x1b[40m |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 黑色 | 30 | 40 | \x1b[30m | \x1b[40m |'
- en: '| Red | 31 | 41 | \x1b[31m | \x1b[41m |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | 31 | 41 | \x1b[31m | \x1b[41m |'
- en: '| Green | 32 | 42 | \x1b[32m | \x1b[42m |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 绿色 | 32 | 42 | \x1b[32m | \x1b[42m |'
- en: '| Yellow | 33 | 43 | \x1b[33m | \x1b[43m |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 黄色 | 33 | 43 | \x1b[33m | \x1b[43m |'
- en: '| Blue | 34 | 44 | \x1b[34m | \x1b[44m |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 蓝色 | 34 | 44 | \x1b[34m | \x1b[44m |'
- en: '| Magenta | 35 | 45 | \x1b[35m | \x1b[45m |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 品红色 | 35 | 45 | \x1b[35m | \x1b[45m |'
- en: '| Cyan | 36 | 46 | \x1b[36m | \x1b[46m |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 青色 | 36 | 46 | \x1b[36m | \x1b[46m |'
- en: '| White | 37 | 47 | \x1b[37m | \x1b[47m |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| 白色 | 37 | 47 | \x1b[37m | \x1b[47m |'
- en: Codes can be combined in a single sequence, as shown back in figure 13.4\. For
    example, if you want red text on a blue background, you can use the sequence \x1b[31;44m,
    where 31 is the code for red foreground and 44 is the code for blue background.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以组合在一个序列中，如图 13.4 所示。例如，如果你想在蓝色背景上显示红色文本，可以使用序列 \x1b[31;44m，其中 31 是红色前景的代码，44
    是蓝色背景的代码。
- en: The code for ansi02.c in the next code listing cycles through all the permutations
    of foreground and background colors. Run the program to ensure that the terminal
    window is capable of outputting colors, plus to see how nifty it is to do color
    text output in C. (Well, it’s a terminal feature, not really part of the C programming
    language.)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码列表中的 ansi02.c 代码遍历了所有前景和背景颜色的排列组合。运行程序以确保终端窗口能够输出颜色，并查看在 C 中进行颜色文本输出的巧妙之处。（好吧，这是一个终端功能，而不是
    C 编程语言的一部分。）
- en: Listing 13.17 Source code for ansi02.c
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.17 ansi02.c 的源代码
- en: '[PRE87]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ❶ Loops through foreground values
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历前景值
- en: ❷ Loops through background values
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历背景值
- en: ❸ Outputs the escape sequence and the two values
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出转义序列和两个值
- en: ❹ Updates the numbers here
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 更新这里的数字
- en: ❺ Resets and starts a new line
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 重置并开始新的一行
- en: The generated output from ansi02.c—which I won’t show here because this book
    isn’t in color—is a grid of all the color combinations. Output with the same foreground
    and background colors makes the text invisible, but it’s there.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ansi02.c 生成的输出——这里不展示，因为这本书不是彩色的——是一个所有颜色组合的网格。具有相同前景和背景颜色的输出使文本不可见，但它确实存在。
- en: This color output can be used in your text mode programs to spice up the screen
    or to call attention to one part of the output or another. Keep in mind that the
    output is still streaming, one character after another. Also, not all terminals
    properly render the character attributes.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这种颜色输出可以用于你的文本模式程序中，以使屏幕更加生动，或者吸引对输出中某个部分的注意。请记住，输出仍然是流式的，一个字符接一个字符。此外，并非所有终端都能正确渲染字符属性。
- en: 13.4.2 Generating a tight-but-colorful calendar
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 生成紧凑且多彩的日历
- en: It’s possible to squeeze more months on a text screen if you eliminate the space
    between the days. On a plain text screen, such a move would render the month’s
    data output useless to all but the most insane nerd. Yet it’s possible to output
    a month with no spaces between the days—if you change each day’s colors.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除日期之间的空格，可以在文本屏幕上挤入更多月份。在纯文本屏幕上，这样的操作将使月份的数据输出对除了最疯狂的极客之外的所有人都没有用。然而，如果你改变每一天的颜色，你可以输出没有空格的月份。
- en: In figure 13.5, you see single month output from my year program (so far), the
    *cal* program, and then from a version of my year program with no spaces between
    the dates. Which is easiest to read?
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在图13.5中，你可以看到我的年份程序（到目前为止）的单月输出，cal程序，然后是从没有日期间隔的年份程序版本。哪个最容易阅读？
- en: '![13-05](Images/13-05.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![13-05](Images/13-05.png)'
- en: Figure 13.5 Comparing output from various calendar programs
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 比较各种日历程序的输出
- en: I would offer that the calendars shown in figure 13.5 rank, from left to right,
    in order of easiest to read. However, the easier the calendar is to read, the
    more text screen real estate it occupies. You can always adjust the terminal window
    size, but a larger window is often impractical for many of the fun times to be
    had in text mode.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我会提出，图13.5中显示的日历，从左到右，按照阅读难度排序。然而，日历越容易阅读，它占用的文本屏幕空间就越大。你总是可以调整终端窗口的大小，但更大的窗口对于许多在文本模式下的娱乐活动来说往往不切实际。
- en: The year configuration on the right in figure 13.5 allows for more months to
    pack into a typical 80-by-24 character terminal window. In fact, you can march
    four columns of months across the terminal window when using this dense format.
    You can almost see all 12 months as well, though not the complete bottom row.
    The problem is that the numbers all run together—unless you color-code them.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5右边的年份配置允许在典型的80x24字符终端窗口中装入更多月份。实际上，当使用这种密集格式时，你可以在终端窗口中跨越四列月份。你几乎可以看到所有12个月份，尽管看不到完整的最后一行。问题是数字都连在一起——除非你用颜色编码它们。
- en: Figure 13.6 shows a full year’s worth of output with no spaces between dates
    in each month. The dates are color-coded, as are the weekday headers. You can’t
    see the colors in this book, but even in grayscale, it’s far easier to visually
    separate the days in a month.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6显示了没有日期间隔的整个年份输出，月份中的日期和星期几的标题都进行了颜色编码。在这本书中你看不到颜色，但即使在灰度下，也更容易在月份中视觉上区分出每一天。
- en: '![13-06](Images/13-06.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![13-06](Images/13-06.png)'
- en: Figure 13.6 Color-coded days allow the tight calendar to be useful.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 颜色编码的日期使得紧凑的日历变得有用。
- en: To update the *year* series of programs to output a tighter annual calendar,
    start with the year03.c source code. Color output requires no additional headers
    or libraries—just that you add the ANSI escape sequences to output color. These
    updates are found in the source code file year04.c, available in the online repository.
    Follow along as I review each update to the code.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新*年份*系列程序以输出更紧凑的年历，请从year03.c源代码开始。彩色输出不需要额外的头文件或库——只需将ANSI转义序列添加到输出彩色即可。这些更新可以在在线仓库中找到的源代码文件year04.c中找到。随着我逐一审查代码的每个更新，请跟我一起学习。
- en: 'First, I added the following defined constants, which help output colors, foreground
    and background:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我添加了以下定义的常量，这些常量有助于输出颜色、前景和背景：
- en: '[PRE88]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The updated year program uses only the colors listed. Constants FG and BG are
    added to the other values to create the various foreground and background color
    combinations.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的年份程序只使用列出的颜色。将FG和BG常量添加到其他值中，以创建各种前景和背景颜色组合。
- en: Second, to output dates, I added the *color_output()* function, shown in the
    next listing. Its job is to output every other date of the month in a different
    color. The *if* decision alternates between odd and even days, with variable d
    passed as an argument. The defined constants shown earlier are used in the *printf()*
    statement to set color output.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，为了输出日期，我添加了 *color_output()* 函数，如下一列表所示。它的任务是每月以不同颜色输出每隔一天的日期。*if* 条件语句在奇数和偶数日之间交替，变量
    d 作为参数传递。前面定义的常量在 *printf()* 语句中用于设置颜色输出。
- en: Listing 13.18 The *color_output()* function from year04.c
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.18 来自 year04.c 的 *color_output()* 函数
- en: '[PRE89]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ❶ The condition is true for odd-numbered values of d.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当 d 的值为奇数时，条件为真。
- en: ❷ Outputs odd days with a black foreground and white background
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 以黑色前景和白色背景输出奇数日
- en: ❸ Outputs even days with a white foreground and cyan background
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 以白色前景和青色背景输出偶数日
- en: 'Along with the addition of the *color_output()* function, the *printf()* functions
    that output the current day must be replaced. They go from this:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加 *color_output()* 函数外，输出当前日的 *printf()* 函数也必须替换。它们从以下内容变为：
- en: '[PRE90]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'to this:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 到以下内容：
- en: '[PRE91]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'I also changed the length of the month and day strings. The month names are
    shortened to better fit in the tighter layout:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我还改变了月份和日期字符串的长度。月份名称被缩短以更好地适应更紧凑的布局：
- en: '[PRE92]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The weekday headings are reset to two characters long. Like the days of the
    month, the weekday headings must be color-coded. I couldn’t think of a clever
    way to code the weekday header without creating another array, so a series of
    *printf()* statements output the days, alternating bold and normal attributes:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 星期几的标题重置为两个字符长。像月份的日期一样，星期几的标题也必须进行颜色编码。我无法想出一个聪明的办法来编码星期几的标题而不创建另一个数组，因此一系列
    *printf()* 语句输出这些天，交替加粗和正常属性：
- en: '[PRE93]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, the space between months is reduced to two. Various putchar(''\n'')
    statements are replaced by *printf()* statements that also output the ANSI escape
    sequence to reset the colors back to normal. This change avoided color spill at
    the end of each line of output. In fact, color spill is something you must be
    aware of when coding color output: always terminate the color output, resetting
    it when colored text is no longer required. The reset sequence is \x1b[0m;.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，月份之间的空间减少到两个。各种 putchar('\n') 语句被替换为 *printf()* 语句，这些语句还输出 ANSI 转义序列以将颜色重置回正常。此更改避免了输出行末的颜色溢出。实际上，在编码颜色输出时必须注意颜色溢出：始终终止颜色输出，当不再需要彩色文本时重置它。重置序列是
    \x1b[0m;。
- en: Output for the program generated by year04.c appears earlier, in figure 13.6\.
    The BOLD attribute looks faint in the image because of how the terminal window
    sets bold color. Again, color output differs from terminal to terminal.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 由 year04.c 生成的程序输出出现在图 13.6 中。由于终端窗口设置加粗颜色，图像中的 BOLD 属性看起来较淡。再次强调，颜色输出因终端而异。
- en: Exercise 13.6
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 13.6
- en: What is missing from the output for the year04.c code, and missing in figure
    13.6 as well, is a highlight for the current day of the year.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: year04.c 代码的输出中缺少的内容，以及图 13.6 中也缺少的内容，是突出显示当年的当前日。
- en: Your task for this exercise is to modify the source code for year04.c to detect
    the current day of the year and output this one specific day in a special color.
    Obviously, if the calendar isn’t showing the current year, your code won’t highlight
    today’s date. So, your solution must detect whether the current year is shown.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的任务是修改 year04.c 的源代码以检测当年的当前日，并以特殊颜色输出这一天。显然，如果日历没有显示当前年份，你的代码将不会突出显示今天的日期。因此，你的解决方案必须检测当前年份是否显示。
- en: My solution is named year05.c, available in the online repository. Comments
    in the text explain what I did. My chosen colors for the current day of the year
    are red text on a black background.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案命名为 year05.c，可在在线存储库中找到。文本中的注释解释了我所做的工作。我选择的当前年份的颜色是红色文本和黑色背景。
- en: 13.4.3 Coloring holidays
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 突出显示节假日
- en: The final step to the year series of programs, and for both this and the preceding
    chapter, is to generate an annual calendar with highlighted holidays. This program
    requires an update to the year04.c source code but also the inclusion of the *isholiday()*
    function from chapter 12\. The output uses the return value from *isholiday()*
    to color-code holiday dates, making them visible in the output.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 到年份系列程序的最后一步，以及对于本章和前一章，都是生成带有突出显示节假日的年度日历。此程序需要更新 year04.c 源代码，并且包含来自第 12 章的
    *isholiday()* 函数。输出使用 *isholiday()* 的返回值来对节假日日期进行颜色编码，使其在输出中可见。
- en: 'To accomplish this task, three separate files are required:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，需要三个单独的文件：
- en: The new source code file, year05.c, which calls the *isholiday()* function and
    color-codes holiday dates
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的源代码文件 year05.c，它调用 *isholiday()* 函数并对假日日期进行着色编码
- en: A source code file, isholiday.c, containing the *isholiday()* function and its
    support functions
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个源代码文件 isholiday.c，包含 *isholiday()* 函数及其支持函数
- en: 'A header file, holiday_year.h, which contains resources for the final program:
    header files to include, defined constants, the holiday structure definition,
    and the function prototype for *isholiday()*'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个头文件 holiday_year.h，其中包含最终程序所需的资源：要包含的头文件、定义的常量、假日结构定义以及 *isholiday()* 函数的原型
- en: These files are available in the online repository. Review them as I cover the
    changes to the code.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件可在在线存储库中找到。在我介绍代码更改时，请查看它们。
- en: 'To update the year04.c source code to year05.c, several updates are required.
    The first is the addition of the *color_holiday()* function, which outputs a holiday’s
    value with white text on a red background:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 year04.c 源代码更新为 year05.c，需要几个更新。首先是添加 *color_holiday()* 函数，该函数以红色背景上的白色文本输出假日的值：
- en: '[PRE94]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Next, the *for* loop that outputs the first day of the month is updated to scan
    for any holidays. The following listing shows the updates—specifically, how holiday
    structure h is filled to make the *isholiday()* function call. Also note that
    if a holiday falls on today’s date, the color used is for the holiday, not the
    color for today’s date.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新输出月份第一天的 *for* 循环，以扫描任何假日。以下列表显示了更新——特别是如何填充假日结构 h 以使 *isholiday()* 函数调用。注意，如果假日落在今天的日期上，使用的颜色是假日颜色，而不是今天日期的颜色。
- en: Listing 13.19 The updated *for* loop for the first day of the week in year 06.c
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.19 year 06.c 中第一周第一天的更新 *for* 循环
- en: '[PRE95]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ❶ These items are consistent throughout the first week.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些项目在整个第一周中是一致的。
- en: ❷ The month starts on day 1.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 月份从第一天开始
- en: ❸ Loops through the first week, Sunday through Saturday
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在第一周内循环，从周日到周六
- en: ❹ Outputs blanks before the first of the month starts
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在月份开始前输出空白
- en: ❺ Updates holiday structure h with the current day and day of the week
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更新假日结构 h，包含当前日期和星期几
- en: ❻ Tests for holidays
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 测试假日
- en: ❼ Colors the holiday
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 着色假日
- en: ❽ Tests for today’s date and color
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 测试今天的日期和颜色
- en: ❾ Outputs a regular date
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 输出常规日期
- en: ❿ Increments the day counter
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 增加天数计数器
- en: ⓫ Resets the color output
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 重置颜色输出
- en: ⓬ Updates the first day of next week
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 更新下周的第一天
- en: ⓭ Resets the color output
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 重置颜色输出
- en: Changes similar to those shown in listing 13.19 are made in the next *for* loop,
    which outputs the remaining days of the month.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个 *for* 循环中进行的更改类似于列表 13.19 中所示，该循环输出该月的剩余日期。
- en: 'To build the program, you must build both year06.c and isholiday.c into a single
    program. I use the following command, which generates a program file named year.
    Also, don’t forget to link in the math library, shown as the last argument:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建程序，你必须将 year06.c 和 isholiday.c 构建成一个单独的程序。我使用以下命令，生成一个名为 year 的程序文件。另外，别忘了链接数学库，如最后一个参数所示：
- en: '[PRE96]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The program’s output shows the current year—or any year specified at the command
    prompt—highlighting all the holidays and today’s date, providing today isn’t a
    holiday. It’s compact, with nearly the entire year fitting in a standard terminal
    window. This type of output works well only when you color-code the dates.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出显示当前年份——或者通过命令提示符指定的任何年份——突出显示所有假日和今天的日期，前提是今天不是假日。输出紧凑，几乎整个年份都能适应标准终端窗口。这种类型的输出只有在给日期着色编码时才有效。
