- en: Appendix D. Using Terraform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录D. 使用Terraform
- en: Infrastructure as code is not a new concept, but over the years, the tools have
    changed from scripts and images that are on physical hardware your company owns
    to tools built to work in the cloud. Kubernetes and serverless platforms have
    taken the spotlight off of other tools that help build infrastructure within these
    various cloud environments. There are trade-offs and benefits to all different
    types of deployments. In this appendix, examples are provided for one last tool
    to give you a broad overview of the deployment landscape.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码不是一个新概念，但多年来，工具已经从物理硬件上的脚本和镜像转变为在云中工作的工具。Kubernetes和无服务器平台已经将其他工具的聚光灯从构建这些不同云环境中的基础设施的工具上移开。所有不同类型的部署都有其权衡和好处。在本附录中，提供了最后一个工具的示例，以给您提供一个关于部署景观的广泛概述。
- en: D.1 Building the image
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.1 构建镜像
- en: My first job was with the IT department in high school. While working there,
    I was able to assist in unboxing and wiring the computer labs. After all the computers
    were unboxed and plugged in, I would turn them all on, rapidly tapping on keys
    to enable network mode. Within a few minutes, I would see an installer start to
    run, and within the hour, we had 20 identical machines. Every week I would repeat
    this magic with amazement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一份工作是在高中时的IT部门。在那里工作期间，我能够协助拆箱和布线计算机实验室。当所有计算机都拆箱并插上电源后，我会把它们全部打开，快速敲击键盘以启用网络模式。几分钟内，我会看到安装程序开始运行，一个小时后，我们就有了20台完全相同的机器。每周我都会带着惊奇重复这个魔法。
- en: The amazement hasn’t worn off. Today we need to do the same task in the cloud
    with our applications. Instead of unboxing physical servers, we push our images
    to ephemeral ones. When you create a server in the cloud, it is a virtual machine
    on a larger server cluster. It can go down and start right back up on a completely
    different box in a completely different part of the building it’s in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那种惊奇感还没有消失。今天我们需要在云中使用我们的应用程序执行同样的任务。我们不是拆箱物理服务器，而是将我们的镜像推送到临时服务器上。在云中创建服务器时，它是在更大的服务器集群上的一个虚拟机。它可以关闭，然后在建筑物的完全不同的部分，甚至是在完全不同的机器上重新启动。
- en: To build the image, we will use Packer ([https://www.packer.io/](https://www.packer.io/)),
    a tool by HashiCorp that builds server images based on the specifications provided.
    Then we will create a Packer image definition with the code in the following listing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建镜像，我们将使用Packer（[https://www.packer.io/](https://www.packer.io/）），这是HashiCorp的一个工具，它根据提供的规范构建服务器镜像。然后我们将使用以下列表中的代码创建一个Packer镜像定义。
- en: Listing D.1 `hello-api.pkr.hcl`
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 D.1 `hello-api.pkr.hcl`
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Input variables needed for the build
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建所需输入变量
- en: ❷ The base image we will be building from
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将构建的基础镜像
- en: ❸ The name of the image we are going to create
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们将要创建的镜像名称
- en: ❹ Special builder that copies our binary over to the image
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 特殊构建器，用于将我们的二进制文件复制到镜像中
- en: This will build an image with the name of the commit that was merged. Next,
    we need to adjust our account to be able to deploy images. Run the commands in
    the following listing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个以合并的提交名称命名的镜像。接下来，我们需要调整我们的账户以能够部署镜像。运行以下列表中的命令。
- en: Listing D.2 `hello-api.pkr.hcl`
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 D.2 `hello-api.pkr.hcl`
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will allow our GitHub pipeline to use Packer to build the image. Next,
    we will write the server to run the image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们的GitHub管道使用Packer构建镜像。接下来，我们将编写服务器以运行镜像。
- en: D.2 Deploying the image
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.2 部署镜像
- en: To define our infrastructure, we use Terraform ([https://www.terraform.io/](https://www.terraform.io/)),
    another HashiCorp tool. Terraform provides a language to define servers, load
    balancers, databases, and more. It also keeps track of the state of your infrastructure,
    which will be important when you need to change or delete a service. We need to
    install Terraform locally so that we can set up a few necessary pieces. To begin,
    create a directory called `infra` and then a sub-directory called `global`. In
    these, we will add the code in the following listing to a `main.tf` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的基础设施，我们使用Terraform（[https://www.terraform.io/](https://www.terraform.io/）），这是另一个HashiCorp的工具。Terraform提供了一种定义服务器、负载均衡器、数据库等语言。它还跟踪您基础设施的状态，这在您需要更改或删除服务时将非常重要。我们需要在本地安装Terraform，以便我们可以设置一些必要的组件。首先，创建一个名为`infra`的目录，然后创建一个名为`global`的子目录。在这些目录中，我们将以下列表中的代码添加到`main.tf`文件中。
- en: Listing D.3 `main.tf`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 D.3 `main.tf`
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a state bucket to store our current infrastructure values
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个状态桶来存储我们当前的基础设施值
- en: Then run `terraform` `apply` and confirm. This bucket will hold the state of
    our entire system so that we can make changes. If this file were to be stored
    on a laptop, no one else could make changes. If the file were lost, you would
    lose the state of your infrastructure and would need to modify it by hand.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行 `terraform` `apply` 并确认。这个存储桶将保存我们整个系统的状态，以便我们可以进行更改。如果这个文件存储在笔记本电脑上，其他人就无法进行更改。如果文件丢失，你将丢失基础设施的状态，需要手动修改它。
- en: Next, we will define the server and variables needed to deploy. Create a directory
    called `infra/server`, and add the code in the following listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义服务器和部署所需的变量。创建一个名为 `infra/server` 的目录，并添加以下列表中的代码。
- en: Listing D.4 `main.tf`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表D.4 `main.tf`
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Defines the backend we will use and the state file
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义我们将使用的后端和状态文件
- en: ❷ Creates the server instance
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建服务器实例
- en: ❸ Inputs the image name
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输入镜像名称
- en: ❹ The script that runs when the server starts
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 服务器启动时运行的脚本
- en: ❺ Creates a hole in the firewall to access the service
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在防火墙中创建一个洞以访问服务
- en: ❻ Output endpoint to call the API
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出端点以调用API
- en: Now we can create our pipeline.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的管道。
- en: D.3 Creating the pipeline
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.3 创建管道
- en: Our pipeline will compile our binary, package it with Packer, and then create
    a server. Upon any commit, the server will redeploy (see the next listing).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道将编译我们的二进制文件，使用Packer打包，然后创建一个服务器。在任何提交后，服务器将重新部署（见下一列表）。
- en: Listing D.5 `pipeline.yml`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表D.5 `pipeline.yml`
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Infrastructure can get complicated, and this pipeline only shows a simple way
    of creating a continuous deployment. It differs from chapter 10 because this infrastructure
    code is automatically deployed instead of being integrated manually. In the output
    of the pipeline, you find the endpoint you need to call the service.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施可能会变得复杂，而这个管道只展示了创建持续部署的简单方法。它与第10章不同，因为这种基础设施代码是自动部署的，而不是手动集成。在管道的输出中，你可以找到需要调用服务的端点。
