- en: '2 Verticles: The basic processing units of Vert.x'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Verticles：Vert.x的基本处理单元
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What verticles are
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: verticles是什么
- en: How to write, configure, and deploy verticles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写、配置和部署verticles
- en: The Vert.x threading model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x的线程模型
- en: How to mix Vert.x and non-Vert.x threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何混合Vert.x和非Vert.x线程
- en: Put simply, a *verticle* is the fundamental processing unit in Vert.x. The role
    of a verticle is to encapsulate a *technical functional unit* for processing events,
    such as exposing an HTTP API and responding to requests, providing a repository
    interface on top of a database, or issuing requests to a third-party system. Much
    like components in technologies like Enterprise JavaBeans, verticles can be deployed,
    and they have a life cycle.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，*verticle*是Vert.x中的基本处理单元。verticle的作用是封装一个*技术功能单元*以处理事件，例如暴露HTTP API并响应请求，在数据库之上提供存储库接口，或向第三方系统发出请求。与像Enterprise
    JavaBeans这样的技术中的组件类似，verticles可以被部署，并且它们有自己的生命周期。
- en: Asynchronous programming is key to building reactive applications, since they
    have to scale, and verticles are fundamental in Vert.x for structuring (asynchronous)
    event-processing code and business logic.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是构建响应式应用的关键，因为它们需要扩展，而verticles在Vert.x中对于结构（异步）事件处理代码和业务逻辑是基本的。
- en: 2.1 Writing a verticle
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 编写verticle
- en: 'If you’re familiar with the *actor concurrency model*, you will find similarities
    between Vert.x verticles and actors.[1](#pgfId-1011950) Put simply, in the actor
    model, autonomous entities (the actors) exclusively communicate with other entities
    by sending and responding to messages. The similarities between Vert.x verticles
    and actors is no fortuitous coincidence: verticles have private state that may
    be updated when receiving events, they can deploy other verticles, and they can
    communicate via message-passing (more on that in the next chapter). Verticles
    do not necessarily follow the orthodox definition of actors, but it is fair to
    consider Vert.x as being at least inspired by actors.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉*actor并发模型*，您将在Vert.x verticles和actors之间找到相似之处。[1](#pgfId-1011950) 简单来说，在actor模型中，自主实体（actors）通过发送和响应消息专门与其他实体通信。Vert.x
    verticles和actors之间的相似性并非偶然巧合：verticles具有可能在接收事件时更新的私有状态，它们可以部署其他verticles，并且它们可以通过消息传递进行通信（下一章将详细介绍）。verticles不一定遵循actor的正统定义，但公平地说，Vert.x至少受到了actor的启发。
- en: 'Since verticles are a key concept in Vert.x, we will look into how they work.
    Before that, though, we’ll write a small verticle that processes two types of
    events: periodic timers and HTTP requests.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于verticles是Vert.x中的一个关键概念，我们将探讨它们是如何工作的。在此之前，我们将编写一个小型verticle来处理两种类型的事件：周期性计时器和HTTP请求。
- en: 2.1.1 Preparing the project
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 准备项目
- en: We will use a common project for all of the examples in this chapter, making
    use of the Gradle project descriptor in the following listing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个通用的项目来展示本章中的所有示例，并使用以下列表中的Gradle项目描述符。
- en: Listing 2.1 Gradle `build.gradle.kts` for the examples in chapter 2
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 第2章示例的Gradle `build.gradle.kts`
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ This is the Vert.x core library dependency. Replace “VERSION” with a recent
    release number like 3.9.0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是Vert.x核心库依赖。将“VERSION”替换为最近的发布号，如3.9.0。
- en: ❷ The logback-classic dependency provides the SLF4J logger API and the logback
    implementation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ logback-classic依赖提供了SLF4J日志记录器API和logback实现。
- en: ❸ This will allow you to run samples with Gradle from the command line.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这将允许您从命令行运行使用Gradle的示例。
- en: ❹ This ensures that Vert.x itself also uses SLF4J logging.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这确保了Vert.x本身也使用SLF4J日志记录。
- en: The Gradle build is a very simple one for a Java project. Since we will have
    several examples to run, we won’t rely on the Gradle `application` plugin, but
    will define our own custom `run` task, where we can pass the name of the class
    to execute. We’ll also use it to ensure that logging is properly configured and
    unified to SLF4J.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle构建对于Java项目来说非常简单。由于我们将运行多个示例，我们不会依赖于Gradle `application`插件，而是定义自己的自定义`run`任务，其中我们可以传递要执行的类的名称。我们还将使用它来确保日志配置正确且统一到SLF4J。
- en: Listing 2.2 Logback configuration to reduce Netty verbosity
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 Logback配置以减少Netty的冗余
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This defines an appender to send events to the console.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这定义了一个将事件发送到控制台的后缀。
- en: ❷ The pattern defines what the log events look like.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 该模式定义了日志事件的样式。
- en: ❸ We drop Netty log events that are more verbose than warnings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们丢弃比警告更冗余的Netty日志事件。
- en: Tip Vert.x uses Netty, and logging in Netty is quite verbose with the default
    Logback configuration. We can reduce the number of log entries by creating an
    src/main/resources/logback.xml file and adding the configuration as in listing
    2.2\. To make the log samples shorter in this book, I’ve also removed event dates
    and shortened logger class names (`$logger{0}`). Please refer to the Logback documentation
    to learn how to configure it ([https://logback .qos.ch/manual/index.html](https://logback.qos.ch/manual/index.html)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Vert.x 使用 Netty，并且 Netty 的默认 Logback 配置中的日志记录相当详细。我们可以通过创建一个 src/main/resources/logback.xml
    文件并添加配置来减少日志条目数量，如列表 2.2 中所示。为了使本书中的日志样本更短，我还删除了事件日期并缩短了记录器类名（`$logger{0}`）。请参阅
    Logback 文档以了解如何配置它 ([https://logback.qos.ch/manual/index.html](https://logback.qos.ch/manual/index.html))。
- en: 2.1.2 The verticle class
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 组件类
- en: The whole verticle and application fits in the following Java class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 整个组件和应用程序都包含在以下 Java 类中。
- en: Listing 2.3 A sample verticle
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 一个示例组件
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ This defines a periodic task every five seconds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这定义了一个每五秒执行一次的周期性任务。
- en: ❷ The HTTP server calls this handler on every request.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ HTTP 服务器会在每次请求时调用此处理器。
- en: ❸ We need a global Vert.x instance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们需要一个全局的 Vert.x 实例。
- en: ❹ This is the simplest way to deploy a verticle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这是部署组件的最简单方法。
- en: 'This verticle defines two event handlers: one for periodic tasks every five
    seconds, and one for processing HTTP requests in an HTTP server. The `main` method
    instantiates a global Vert.x instance and deploys an instance of the verticle.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件定义了两个事件处理器：一个用于每五秒执行一次的周期性任务，另一个用于处理HTTP服务器中的HTTP请求。`main` 方法实例化一个全局的 Vert.x
    实例并部署一个组件实例。
- en: Defining a verticle in Java is typically done by specializing the `AbstractVerticle`
    class. There is a `Verticle` interface that you could in theory implement, but
    `AbstractVerticle` provides all the event processing, configuration, and execution
    plumbing that Vert.x users need.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中定义组件通常是通过特化 `AbstractVerticle` 类来完成的。理论上您可以实现 `Verticle` 接口，但 `AbstractVerticle`
    提供了 Vert.x 用户所需的所有事件处理、配置和执行管道。
- en: note Since Vert.x is a library and not a framework, you can create a Vert.x
    instance from a `main` method, or from any other class, and then deploy verticles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于 Vert.x 是一个库而不是框架，您可以从 `main` 方法或任何其他类中创建 Vert.x 实例，然后部署组件。
- en: 'The life cycle of a verticle consists of start and stop events. The `AbstractVerticle`
    class provides `start` and `stop` methods that can be overridden:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期由启动和停止事件组成。`AbstractVerticle` 类提供了可以重写的 `start` 和 `stop` 方法：
- en: The `start` method typically contains setup and initialization for handlers,
    like setting a periodic task handler and starting an HTTP server in listing 2.3.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start` 方法通常包含处理器的设置和初始化，如列表 2.3 中设置周期性任务处理器和启动 HTTP 服务器。'
- en: The `stop` method is implemented when housekeeping tasks are required, such
    as closing open database connections.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要执行清理任务时，例如关闭打开的数据库连接，会实现 `stop` 方法。
- en: By default these methods do nothing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些方法不执行任何操作。
- en: 2.1.3 Running and first observations
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 运行和初步观察
- en: 'The application can be launched as a regular Java application by running the
    `main` method either from an IDE or from the command line. To run it on the command
    line using Gradle, you can use the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以作为常规 Java 应用程序启动，通过 IDE 或命令行运行 `main` 方法。要在命令行中使用 Gradle 运行它，可以使用以下命令：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I am again assuming that you will run this from a Unix shell, be it under Linux,
    macOS, or Windows through WSL. If you run the command from a traditional Windows
    terminal, there is a .bat file for Gradle, so you will need to replace `./gradlew`
    with `gradlew.bat`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次假设您将从 Unix shell 中运行此程序，无论是 Linux、macOS 还是通过 WSL 的 Windows。如果您从传统的 Windows
    终端运行命令，有一个 Gradle 的 .bat 文件，因此您需要将 `./gradlew` 替换为 `gradlew.bat`。
- en: Once the application runs, you can perform a few HTTP requests at http://localhost:8080/
    with a web browser, or by using command-line tools such as curl and HTTPie. The
    logs will be similar to the one shown in the following listing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序运行，您可以使用网络浏览器在 http://localhost:8080/ 上执行几个 HTTP 请求，或者通过使用 curl 和 HTTPie
    等命令行工具。日志将类似于以下列表中所示。
- en: Listing 2.4 Sample log output when running `HelloVerticle`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 运行 `HelloVerticle` 时的示例日志输出
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The HTTP server is now ready.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ HTTP 服务器现在已准备就绪。
- en: ❷ A periodic task event log
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 周期性任务事件日志
- en: ❸ An HTTP request event log
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ HTTP 请求事件日志
- en: Tip In some of the remaining examples, I have shortened the class definitions.
    I have especially removed package definitions, imports, and `main` methods that
    are similar to the one in listing 2.3\. To see the full source code, please consult
    the book’s code repository.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在一些剩余的示例中，我已经缩短了类定义。我特别移除了与列表2.3中类似的包定义、导入和`main`方法。要查看完整的源代码，请查阅本书的代码仓库。
- en: 'The Logback configuration that we are using shows the name of the thread associated
    with an event. We can already check an important property of Vert.x verticles
    in log entries: event processing happens on a single event-loop thread. Both the
    periodic tasks and HTTP request processing happen on a thread that appears as
    `vert.x -eventloop-thread-0` in the logs.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的Logback配置显示了与事件相关联的线程名称。我们已经在日志条目中检查了Vert.x垂直结构的一个重要属性：事件处理发生在单个事件循环线程上。周期性任务和HTTP请求处理都发生在日志中显示为`vert.x
    -eventloop-thread-0`的线程上。
- en: An obvious benefit of this design is that a verticle instance always executes
    event processing on the same thread, so there is no need for using thread synchronization
    primitives. In a multithreaded design, updating the `counter` field would require
    either a `synchronized` block or the use of `java.util.concurrent.AtomicLong`.
    There is no such issue here, so a plain `long` field can be safely used.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的明显好处是，垂直实例总是在同一线程上执行事件处理，因此不需要使用线程同步原语。在多线程设计中，更新`counter`字段可能需要`synchronized`块或使用`java.util.concurrent.AtomicLong`。这里没有这样的问题，因此可以安全地使用普通`long`字段。
- en: Preparation methods, such as `createHttpServer` or `setTimer`, may be called
    from a non-Vert.x thread. This may happen when you’re directly using a `Vertx`
    object without a verticle, or when you’re writing unit tests. This is, however,
    not a problem, because the use of the `Vertx` class methods is thread-safe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 准备方法，如`createHttpServer`或`setTimer`，可能从非Vert.x线程中调用。这可能会发生在你直接使用`Vertx`对象而没有垂直结构，或者当你编写单元测试时。然而，这并不是一个问题，因为`Vertx`类方法的使用是线程安全的。
- en: Figure 2.1 shows the (simplified) interactions between the verticle, the handlers,
    Vert.x, and the event sources. Each arrow represents a method call between the
    participants. For instance, `HelloVerticle` creates a periodic task handler by
    calling `setPeriodic` on the `Vertx` object, which in turns creates a periodic
    task using an internal Vert.x timer. In turn, the timer periodically calls back
    the `timerHandler` handler in `HelloVerticle`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1显示了垂直结构、处理器、Vert.x和事件源之间的（简化）交互。每条箭头代表参与者之间的方法调用。例如，`HelloVerticle`通过在`Vertx`对象上调用`setPeriodic`来创建周期性任务处理器，这反过来又使用内部Vert.x计时器创建周期性任务。然后，计时器定期回调`HelloVerticle`中的`timerHandler`处理器。
- en: '![](../Images/CH02_F01_Ponge.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Ponge.png)'
- en: Figure 2.1 Execution of listing 2.3
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 列表2.3的执行
- en: Note that I represented the calls to `requestHandler` and `listen` as being
    to the `Vertx` object as a shortcut; in reality, they are on an object that implements
    the `HttpServer` interface. The actual class is internal to Vert.x, and since
    it doesn’t serve the diagram to add another participant, I merged it into `Vertx`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我将`requestHandler`和`listen`的调用表示为对`Vertx`对象的调用，这是一个快捷方式；实际上，它们是在实现`HttpServer`接口的对象上。实际类是Vert.x内部的，并且由于它不服务于添加另一个参与者，我将其合并到`Vertx`中。
- en: 2.2 More on verticles
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 关于垂直结构更多内容
- en: 'There are more things to know about writing and deploying verticles:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写和部署垂直结构，还有更多需要了解的内容：
- en: What happens when the event loop is being blocked?
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件循环被阻塞时会发生什么？
- en: How can you defer notification of life-cycle completion in the presence of asynchronous
    initialization work?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存在异步初始化工作的情况下，你如何延迟生命周期完成的通告？
- en: How can you deploy and undeploy verticles?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何部署和卸载垂直结构？
- en: How can you pass configuration data?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何传递配置数据？
- en: We’ll cover each of these topics using very simple yet focused examples.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用非常简单但专注的示例来涵盖这些主题。
- en: 2.2.1 Blocking and the event loop
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 阻塞和事件循环
- en: Handler callbacks are run from event-loop threads. It is important that code
    running on an event loop takes as little time as possible, so that the event-loop
    thread can have a higher throughput in the number of processed events. This is
    why no long-running or blocking I/O operations should happen on the event loop.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器回调是在事件循环线程上运行的。代码在事件循环上运行时，应尽可能少地占用时间，以便事件循环线程可以处理更多的事件。这就是为什么不应该在事件循环上发生长时间运行或阻塞I/O操作。
- en: That being said, it may not always be easy to spot blocking code, especially
    when using third-party libraries. Vert.x provides a checker that detects when
    an event loop is being blocked for too long.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在第三方库中使用时，可能并不总是容易发现阻塞代码。Vert.x 提供了一个检查器，用于检测事件循环被阻塞的时间过长。
- en: To illustrate that, let’s see what happens when we introduce an infinite loop
    in an event-handler callback.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看当我们在一个事件处理程序回调中引入无限循环时会发生什么。
- en: Listing 2.5 An example where the event loop is being blocked
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 一个事件循环被阻塞的示例
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Infinite loop!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 无限循环！
- en: The code in listing 2.5 defines a one-second timer, and the handler callback
    enters into an infinite loop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 中的代码定义了一个一秒定时器，并且处理程序回调进入了一个无限循环。
- en: Listing 2.6 Log output when running listing 2.5
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 运行列表 2.5 时的日志输出
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The thread checker is not happy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 线程检查器不开心了。
- en: Listing 2.6 shows a typical log output when running the code from listing 2.5\.
    As you can see, warnings start to appear while the event-loop thread is running
    the infinite loop and hence is not available for processing other events. After
    some iterations (five seconds by default), the warning is enriched with stack
    trace dumps, so you can clearly identify the culprit in your code. Note that this
    is only a warning. The event-loop thread checker cannot kill the handler that
    is taking too long to complete its task.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 显示了运行列表 2.5 代码时的典型日志输出。如您所见，当事件循环线程运行无限循环时，开始出现警告，因此它无法处理其他事件。经过一些迭代（默认为五秒），警告中包含了堆栈跟踪转储，因此您可以清楚地识别出代码中的问题。请注意，这只是一个警告。事件循环线程检查器不能杀死执行时间过长的处理程序。
- en: Of course, you sometimes will need to use blocking or long-running code, and
    Vert.x offers solutions to run such code without blocking the event loop. This
    is the subject of section 2.3.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时您可能需要使用阻塞或长时间运行的代码，而 Vert.x 提供了解决方案来运行这样的代码而不阻塞事件循环。这是第 2.3 节的主题。
- en: Configuring the Vert.x blocked thread checker
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Vert.x 阻塞线程检查器
- en: The time limit before the blocked thread checker complains is two seconds by
    default, but it can be configured to a different value. There are environments,
    such as embedded devices, where processing power is slower, and it is normal to
    increase the thread-checker threshold for them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在阻塞的线程检查器抱怨之前的时间限制是两秒，但可以配置为不同的值。在一些环境，例如嵌入式设备中，处理能力较慢，因此对于它们来说增加线程检查器的阈值是正常的。
- en: 'You can use system properties to change the settings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用系统属性来更改设置：
- en: '`-Dvertx.options.blockedThreadCheckInterval=5000` changes the interval to five
    seconds.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Dvertx.options.blockedThreadCheckInterval=5000` 将间隔更改为五秒。'
- en: '`-Dvertx.threadChecks=false` disables the thread checker.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Dvertx.threadChecks=false` 禁用了线程检查器。'
- en: Note that this configuration is global and cannot be fine-tuned on a per-verticle
    basis.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个配置是全局的，并且不能根据每个 verticle 进行微调。
- en: 2.2.2 Asynchronous notification of life-cycle events
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 生命周期事件的异步通知
- en: So far we have looked at examples with `start()` life-cycle methods. The contract
    in these methods is that a verticle has successfully completed its `start` life-cycle
    event processing unless the method throws an exception. The same applies for `stop()`
    methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了一些使用 `start()` 生命周期方法的示例。这些方法中的约定是，一个 verticle 成功完成了其 `start` 生命周期事件处理，除非方法抛出异常。`stop()`
    方法也是如此。
- en: 'There is, however, a problem: some of the operations in a `start` or a `stop`
    method may be asynchronous, so they may complete after a call to `start()` or
    `stop()` has returned.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个问题：`start` 或 `stop` 方法中的某些操作可能是异步的，因此它们可能在调用 `start()` 或 `stop()` 返回之后完成。
- en: Let’s see how to properly notify the caller of deferred success or failure.
    A good example is starting a HTTP server, which is a non-blocking operation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何正确通知延迟成功或失败的调用者。一个很好的例子是启动 HTTP 服务器，这是一个非阻塞操作。
- en: Listing 2.7 Example of an asynchronous start life-cycle method
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 异步启动生命周期方法的示例
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The Promise is of type void because Vert.x is only interested in the deployment
    completion, and there is no value to carry along.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Promise 是 void 类型，因为 Vert.x 只对部署完成感兴趣，没有值需要携带。
- en: ❷ The listen variant that supports an asynchronous result indicates whether
    the operation failed or not.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 支持异步结果的 listen 变体指示操作是否失败。
- en: ❸ complete() is used to mark the Promise as completed (when the Promise is not
    of type void, a value can be passed).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 `complete()` 来标记 Promise 为完成状态（当 Promise 不是 void 类型时，可以传递一个值）。
- en: ❹ If the listen operation fails, we mark the Promise as failed and propagate
    the error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果监听操作失败，我们将Promise标记为失败并传播错误。
- en: Listing 2.7 shows an example where the verticle reports an asynchronous notification
    when it starts. This is important because starting a HTTP server *can* fail. Indeed,
    the TCP port may be used by another process, in which case the HTTP server cannot
    start, and hence the verticle has not successfully deployed. To report the asynchronous
    notification, we use a variant of the `listen` method with callback called when
    the operation completes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7展示了当verticle启动时报告异步通知的示例。这很重要，因为启动HTTP服务器*可能*会失败。确实，TCP端口可能被另一个进程使用，在这种情况下，HTTP服务器无法启动，因此verticle没有成功部署。为了报告异步通知，我们使用`listen`方法的变体，当操作完成时调用回调。
- en: The `start` and `stop` methods in `AbstractVerticle` support variants with an
    argument of type `io.vertx.core.Promise`. As the name suggests, a Vert.x `Promise`
    is an adaptation of the *futures and promises* model for processing asynchronous
    results.[2](#pgfId-1014865) A *promise* is used to *write* an asynchronous result,
    whereas a *future* is used to *view* an asynchronous result. Given a `Promise`
    object, you can call the `future()` method to obtain a future of type `io.vertx.core.Future`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractVerticle`中的`start`和`stop`方法支持具有`io.vertx.core.Promise`类型参数的变体。正如其名所示，Vert.x的`Promise`是对*future和promise*模型进行异步结果处理的改编。[2](#pgfId-1014865)
    一个*promise*用于*写入*异步结果，而一个*future*用于*查看*异步结果。给定一个`Promise`对象，您可以调用`future()`方法来获取类型为`io.vertx.core.Future`的future。'
- en: In listing 2.7, the `Promise` object is set to be completed when the verticle
    has successfully completed its `start` or `stop` life cycle. If an error arises,
    the `Promise` object is failed with an exception describing the error, and the
    verticle deployment is failed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表2.7中，`Promise`对象被设置为在verticle成功完成其`start`或`stop`生命周期时完成。如果出现错误，`Promise`对象将因异常描述错误而失败，verticle部署也会失败。
- en: '![](../Images/CH02_F02_Ponge.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F02_Ponge.png)'
- en: Figure 2.2 Sequence diagram of starting an HTTP server with a promise and a
    `listen` handler
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 使用Promise和`listen`处理器的HTTP服务器启动序列图
- en: To better understand what happens here, figure 2.2 illustrates the interactions
    between the verticle, the Vert.x object, and the internal Vert.x deployer object
    responsible for calling the `start` method. We can check that the deployer waits
    for the promise completion to know if the deployment was a success or not, even
    after the call to the `start` method has returned. In contrast, figure 2.3 shows
    the interactions when not using the variant of `start` that accepts a `Promise`
    object. There is no way the deployer can be notified of an error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这里发生的情况，图2.2说明了verticle、Vert.x对象和负责调用`start`方法的内部Vert.x部署器对象之间的交互。我们可以检查部署器等待Promise完成以确定部署是否成功，即使在调用`start`方法返回之后也是如此。相比之下，图2.3显示了不使用接受`Promise`对象变体的`start`时的交互。部署器无法通知错误。
- en: '![](../Images/CH02_F03_Ponge.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F03_Ponge.png)'
- en: Figure 2.3 Sequence diagram of starting an HTTP server without a promise and
    a `listen` handler
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 无Promise和`listen`处理器的HTTP服务器启动序列图
- en: Tip It is a good robustness practice to use the asynchronous method variants
    that accept a callback to notify of errors, like the `listen` method in listing
    2.7\. I will not always do this in the remainder of this book if it allows me
    to reduce the verbosity of code samples.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用异步方法变体，如列表2.7中的`listen`方法，来通知错误是一种良好的健壮性实践。如果这允许我减少代码示例的冗长性，我将在本书的其余部分不总是这样做。
- en: 2.2.3 Deploying verticles
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 部署verticles
- en: So far we have been deploying verticles from a `main` method embedded in a single
    verticle class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是从单个verticle类中嵌入的`main`方法部署verticles。
- en: 'Verticles are always deployed (and undeployed) through the `Vertx` object.
    You can do so from any method, but the typical way to deploy an application composed
    of verticles is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Verticles总是通过`Vertx`对象部署（和取消部署）。您可以从任何方法中这样做，但部署由verticles组成的应用的典型方式如下：
- en: Deploy a `main` verticle.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署`main` verticle。
- en: The `main` verticle deploys other verticles.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` verticle部署其他verticles。'
- en: The deployed verticles may in turn deploy further verticles.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署的verticles可以进一步部署其他verticles。
- en: Note that while this sounds hierarchical, Vert.x has no formal notion of parent/child
    verticles.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然这听起来像是分层结构，但Vert.x没有正式的父/子verticles概念。
- en: To illustrate that, let’s define some verticles.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们定义一些verticles。
- en: Listing 2.8 A sample verticle to deploy
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 一个用于部署的示例垂直结构
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ We log when the verticle starts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们记录垂直结构启动时的情况。
- en: Listing 2.8 defines a simple verticle. It does not do anything interesting except
    logging when it starts and stops.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 定义了一个简单的垂直结构。它除了在启动和停止时记录日志外，没有做任何有趣的事情。
- en: Listing 2.9 A verticle that deploys and undeploys other verticles
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 一个部署和卸载其他垂直结构的垂直结构
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ We deploy a new instance of EmptyVerticle every second.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们每秒部署一个新的EmptyVerticle实例。
- en: ❷ Deploying a verticle is an asynchronous operation, and there is a variant
    of the deploy method that supports an asynchronous result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 部署垂直结构是一个异步操作，deploy方法有一个支持异步结果的变体。
- en: ❸ We will undeploy a verticle after five seconds.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 五秒后我们将卸载一个垂直结构。
- en: ❹ Undeploying is very similar to deploying.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 卸载与部署非常相似。
- en: Listing 2.9 defines a verticle that deploys 50 instances of the `EmptyVerticle`
    class from 2.8\. The use of a timer allows us to separate each deployment by one
    second. The `deploy` method uses another timer for undeploying a verticle five
    seconds after it has been deployed. Deployment assigns a unique identifier string
    to a verticle, which can later be used for undeploying.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 定义了一个垂直结构，它从2.8部署了`EmptyVerticle`类的50个实例。定时器的使用使我们能够将每个部署分开一秒。`deploy`方法使用另一个定时器在垂直结构部署五秒后卸载。部署为垂直结构分配一个唯一的标识符字符串，以后可以用于卸载。
- en: Listing 2.10 Main class to deploy the `Deployer` verticle
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 用于部署`Deployer`垂直结构的主体类
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Last but not least, the `Deployer` verticle itself can be deployed from a `main`
    method and class, as shown in listing 2.10\. Running this example yields log entries
    like those in the following listing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`Deployer`垂直结构本身可以从`main`方法和类中部署，如列表2.10所示。运行此示例会产生如下列表中的日志条目。
- en: Listing 2.11 Log excerpts of running the code in listing 2.10
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 运行列表2.10中代码的日志摘录
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ A verticle has been deployed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 已部署一个垂直结构。
- en: ❷ A verticle has been undeployed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 已卸载一个垂直结构。
- en: You can see the log entries from the `vert.x-eventloop-thread-0` thread; they
    correspond to the `Deployer` verticle. You can then see life-cycle log events
    from `EmptyVerticle` instances; they use other event-loop threads.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`vert.x-eventloop-thread-0`线程中看到日志条目；它们对应于`Deployer`垂直结构。然后您可以看到来自`EmptyVerticle`实例的生命周期日志事件；它们使用其他事件循环线程。
- en: Interestingly, we are deploying 50 verticles from `Deployer`, yet there are
    likely fewer threads than verticles appearing in the logs. By default, Vert.x
    creates twice the number of event-loop threads as CPU cores. If you have 8 cores,
    then a Vert.x application has 16 event loops. The assignment of verticles to event
    loops is done in a round-robin fashion.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们从`Deployer`部署了50个垂直结构，但日志中出现的垂直结构可能比线程少。默认情况下，Vert.x创建的事件循环线程数是CPU核心数的两倍。如果您有8个核心，那么Vert.x应用程序有16个事件循环。垂直结构到事件循环的分配是循环分配的。
- en: 'This teaches us an interesting lesson: while a verticle always uses the same
    event-loop thread, the event-loop threads are being shared by multiple verticles.
    This design results in a predictable number of threads for running an application.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个有趣的教训：虽然垂直结构始终使用相同的事件循环线程，但事件循环线程被多个垂直结构共享。这种设计导致运行应用程序的线程数量可预测。
- en: Tip It is possible to tweak how many event loops should be available, but it
    is not possible to manually allocate a given verticle to a specific event loop.
    This should never be a problem in practice, but in the worst case you can always
    plan the deployment order of verticles.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：可以调整应有多少个事件循环可用，但无法手动将给定的垂直结构分配到特定的事件循环。在实际情况中，这不应该成为问题，但最坏的情况下，您总是可以计划垂直结构的部署顺序。
- en: 2.2.4 Passing configuration data
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.4 传递配置数据
- en: 'Application code often needs configuration data. A good example is code that
    connects to a database server: it typically needs a host name, a TCP port, a login,
    and a password. Since the values change from one deployment configuration to another,
    such configuration needs to be accessed from a *configuration* API.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码通常需要配置数据。一个很好的例子是连接到数据库服务器的代码：它通常需要一个主机名、TCP端口、登录名和密码。由于这些值从一个部署配置到另一个部署配置会有所不同，因此这种配置需要从*配置*API中访问。
- en: Vert.x verticles can be passed such configuration data when they are deployed.
    You will see later in this book that some more advanced forms of configuration
    can be used, but the Vert.x core API already provides a generic API that is very
    useful.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Vert.x 节点被部署时，可以传递此类配置数据。你将在本书的后面看到，可以使用一些更高级的配置形式，但 Vert.x 核心API已经提供了一种非常有用的通用API。
- en: Configuration needs to be passed as JSON data, using the Vert.x JSON API materialized
    by the `JsonObject` and `JsonArray` classes in the `io.vertx.core.json` package.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 配置需要以 JSON 数据的形式传递，使用 `io.vertx.core.json` 包中的 `JsonObject` 和 `JsonArray` 类实现的
    Vert.x JSON API。
- en: Listing 2.12 Passing configuration data to a verticle
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 将配置数据传递给节点
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ config() returns the JsonObject configuration instance, and the accessor method
    supports optional default values. Here, if there is no “n” key in the JSON object,
    -1 is returned.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `config()` 返回 JsonObject 配置实例，访问器方法支持可选的默认值。在这里，如果 JSON 对象中没有“n”键，则返回 -1。
- en: ❷ We create a JSON object and put an integer value for key “n.”
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们创建一个 JSON 对象，并为“n”键放入一个整数值。
- en: ❸ The DeploymentOption allows more control on a verticle, including passing
    configuration data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 部署选项允许对节点有更多的控制，包括传递配置数据。
- en: ❹ We can deploy multiple instances at once.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们可以一次性部署多个实例。
- en: ❺ Since we deploy multiple instances, we need to point to the verticle using
    its fully qualified class name (FQCN) rather than using the new operator. For
    deploying just one instance, you can elect either an instance created with new
    or using a FQCN.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 由于我们部署了多个实例，我们需要使用节点的完全限定类名（FQCN）来指向节点，而不是使用 new 操作符。对于仅部署一个实例，你可以选择使用 new
    创建的实例或使用 FQCN。
- en: Listing 2.12 shows an example of deploying many verticles and passing configuration
    data. Running the example gives the output in listing 2.13, and you can check
    the different values of the configuration data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 展示了部署多个节点并传递配置数据的示例。运行示例会给出列表 2.13 中的输出，你可以检查配置数据的不同值。
- en: Listing 2.13 Sample execution output when running the code in listing 2.12
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.13 当在列表 2.12 中运行代码时的示例执行输出
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 2.3 When code needs to block
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 当代码需要阻塞时
- en: The basic rule when running code on an event loop is that it should not block,
    and it should run “fast enough.” You saw earlier that, by default, Vert.x detects
    and warns when an event loop is being blocked for too long.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件循环上运行代码的基本规则是，它不应该阻塞，并且应该运行“足够快”。你之前已经看到，默认情况下，Vert.x 会检测并警告事件循环被阻塞得太久。
- en: 'There are inevitably cases where you will have a hard time avoiding blocking
    code. It may happen because you are using a third-party library with another threading
    model, such as drivers for some networked services. Vert.x provides two options
    for dealing with such cases: worker verticles and the `executeBlocking` operation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 必然会有一些情况，你很难避免阻塞代码。这可能是因为你正在使用具有另一种线程模型的第三方库，例如某些网络服务的驱动程序。Vert.x 提供了两种处理此类情况的方法：工作节点和
    `executeBlocking` 操作。
- en: 2.3.1 Worker verticles
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 工作节点
- en: Worker verticles are a special form of verticles that do not execute on an event
    loop. Instead, they execute on *worker threads*, that is, threads taken from special
    worker pools. You can define your own worker thread pools and deploy worker verticles
    to them, but in most cases you will be just fine using the default Vert.x worker
    pool.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点（Worker Verticles）是一种特殊的节点形式，它们不在事件循环上执行。相反，它们在*工作线程*上执行，即从特殊的工作线程池中取出的线程。你可以定义自己的工作线程池并将工作节点部署到它们中，但在大多数情况下，使用默认的
    Vert.x 工作线程池就足够了。
- en: 'A worker verticle processes events just like an event-loop verticle, except
    that it can take an arbitrarily long time to do so. It is important to understand
    two things:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点处理事件的方式与事件循环节点相同，只不过它可能需要任意长的时间来完成。理解以下两点很重要：
- en: A worker verticle is not tied to a single worker thread, so unlike an event-loop
    verticle, successive events may not execute on the same thread.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作节点不绑定到单个工作线程，因此与事件循环节点不同，连续的事件可能不会在同一个线程上执行。
- en: Worker verticles may only be accessed by a single worker thread at a given time.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作节点在同一时间只能由单个工作线程访问。
- en: To put it simply, like event-loop verticles, worker verticles are single-threaded,
    but unlike event-loop verticles, the thread may not always be the same.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，就像事件循环节点一样，工作节点是单线程的，但与事件循环节点不同的是，线程可能并不总是相同的。
- en: Listing 2.14 A sample worker verticle
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.14 一个示例工作节点
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ We can block and get no warning!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以阻塞而不会收到警告！
- en: ❷ Making a worker verticle is a deployment options flag.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个工作垂直是一个部署选项标志。
- en: Listing 2.14 shows an example where a worker verticle is being deployed with
    two instances. Every 10 seconds, the code blocks for 8 seconds. Running this example
    produces output similar to that of listing 2.15\. As you can see, different worker
    threads are being used for successive events.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14展示了这样一个例子：一个工作垂直部署了两个实例。每隔10秒，代码会阻塞8秒。运行此示例会产生类似于列表2.15的输出。正如您所看到的，不同的工作线程被用于连续的事件。
- en: Listing 2.15 Sample output of running listing 2.14
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 运行列表2.14的示例输出
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Warning When deploying a verticle, there is an option for enabling multithreading
    for worker verticles, which allows multiple events to be processed concurrently
    by a verticle, breaking the single-threaded processing assumption. This was always
    considered fairly advanced usage, and many users ended up using it the wrong way
    and catching concurrency bugs. The feature is no longer publicly documented and
    may even disappear in future Vert.x releases. Users are encouraged to simply adjust
    worker pool sizes to match the workload, rather than enabling worker multi-threading.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 当部署垂直时，有一个选项可以启用工作垂直的多线程，这允许垂直同时处理多个事件，打破了单线程处理的假设。这始终被认为是一种相当高级的使用方式，许多用户最终以错误的方式使用它并捕获并发错误。该功能不再公开文档化，甚至可能在未来的Vert.x版本中消失。鼓励用户简单地调整工作池大小以匹配工作负载，而不是启用工作多线程。
- en: 2.3.2 The executeBlocking operation
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 `executeBlocking`操作
- en: Worker verticles are a sensible option for running blocking tasks, but it may
    not always make sense to extract blocking code into worker verticles. Doing so
    can lead to an explosion in the number of worker verticle classes performing small
    duties, and each class may not form a sensible standalone functional unit.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 工作垂直是运行阻塞任务的一个合理选项，但并不总是有意义将阻塞代码提取到工作垂直中。这样做可能会导致执行小任务的工人垂直类数量激增，而且每个类可能不是一个合理的独立功能单元。
- en: The other option for running blocking code is to use the `executeBlocking` method
    from the `Vertx` class. This method takes some blocking code to execute, offloads
    it to a worker thread, and sends the result back to the event loop as a new event,
    as illustrated in figure 2.4.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行阻塞代码的另一种选项是使用`Vertx`类的`executeBlocking`方法。此方法接受一些要执行的阻塞代码，将其卸载到工作线程，并将结果作为新事件发送回事件循环，如图2.4所示。
- en: '![](../Images/CH02_F04_Ponge.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F04_Ponge.png)'
- en: Figure 2.4 Interactions in an `executeBlocking` call
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 `executeBlocking`调用中的交互
- en: The following listing shows a sample usage.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了其示例用法。
- en: Listing 2.16 Using `executeBlocking`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 使用`executeBlocking`
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '❶ executeBlocking takes two parameters: the code to run and a callback for
    when it has run.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `executeBlocking`接受两个参数：要运行的代码和运行后的回调。
- en: ❷ The blocking code takes a Promise object of any type. It is used to eventually
    pass the result.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 阻塞代码接受任何类型的Promise对象。它最终用于传递结果。
- en: ❸ The Promise object needs to either complete or fail, marking the end of the
    blocking code execution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Promise对象需要完成或失败，以标记阻塞代码执行的结束。
- en: ❹ Processing the result on the event loop is just another asynchronous result.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在事件循环上处理结果只是另一个异步结果。
- en: The following listing shows some sample output from running the code in listing
    2.16\. As you can see, the execution is offloaded to worker threads, but the result
    processing still happens on the event loop.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了运行列表2.16中代码的一些示例输出。正如您所看到的，执行被卸载到工作线程，但结果处理仍然发生在事件循环上。
- en: Listing 2.17 Sample output when running listing 2.16
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17 运行列表2.16时的示例输出
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip By default, successive `executeBlocking` operations have their results processed
    in the same order as the calls to `executeBlocking`. There is a variant of `executeBlocking`
    with an additional `boolean` parameter, and when it’s set to `false`, results
    are made available as event-loop events as soon as they are available, regardless
    of the order of the `executeBlocking` calls.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 默认情况下，连续的`executeBlocking`操作的结果会按照`executeBlocking`调用的顺序进行处理。`executeBlocking`有一个带有额外`boolean`参数的变体，当它设置为`false`时，结果一旦可用就会作为事件循环事件提供，而不考虑`executeBlocking`调用的顺序。
- en: 2.4 So what is really in a verticle?
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 那么，垂直中到底有什么？
- en: So far you’ve seen how to write verticles, how to deploy and configure them,
    and how to deal with blocking code. By using informative logs in the examples,
    you have seen the elements of the Vert.x threading model.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何编写垂直，如何部署和配置它们，以及如何处理阻塞代码。通过在示例中使用信息日志，你已经看到了 Vert.x 线程模型中的元素。
- en: Now is a good time to step back and dissect what is inside a verticle, and make
    sure you leave this chapter with a comprehensive understanding of how verticles
    work and how you can properly use them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个很好的时机来回顾一下垂直内部的结构，并确保你在离开这一章时对垂直的工作原理和如何正确使用它们有一个全面的理解。
- en: 2.4.1 Verticles and their environment
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 垂直和它们的环境
- en: Figure 2.5 gives an overview of the relationships between a verticle and its
    environment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 给出了垂直及其环境之间关系的一个概述。
- en: 'A verticle object is essentially the combination of two objects:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直对象本质上是由两个对象的组合：
- en: The Vert.x instance the verticle belongs to
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直所属的 Vert.x 实例
- en: A dedicated context instance that allows events to be dispatched to handlers
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个专门上下文实例，允许事件被调度到处理器
- en: '![](../Images/CH02_F05_Ponge.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F05_Ponge.png)'
- en: Figure 2.5 An event-loop verticle and its environment
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 事件循环垂直及其环境
- en: The Vert.x instance exposes the core APIs for declaring event handlers. We have
    used it already in the previous code samples with methods such as `setTimer`,
    `setPeriodic`, `createHttpServer`, `deployVerticle`, and so on. The Vert.x instance
    is being shared by multiple verticles, and there is generally only one instance
    of `Vertx` per JVM process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 实例公开了声明事件处理器的核心 API。我们已经在之前的代码示例中使用了它，例如 `setTimer`、`setPeriodic`、`createHttpServer`、`deployVerticle`
    等方法。Vert.x 实例被多个垂直共享，并且通常每个 JVM 进程只有一个 `Vertx` 实例。
- en: The context instance holds the access to the thread for executing handlers.
    Events may originate from various sources such as timers, database drivers, HTTP
    servers, and more. As such, they are more often than not being triggered from
    other threads, such as Netty accepting threads or timer threads.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文实例持有执行处理器的线程访问权限。事件可能来自各种来源，如计时器、数据库驱动程序、HTTP 服务器等。因此，它们通常是从其他线程触发的，例如 Netty
    接受线程或计时器线程。
- en: Event handling in user-defined callbacks happens through the context. The context
    instance allows us to call the handler back on the verticle event-loop thread,
    hence respecting the Vert.x threading model.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义回调中的事件处理通过上下文进行。上下文实例允许我们在垂直事件循环线程上调用处理器，从而尊重 Vert.x 线程模型。
- en: The case of worker verticles is not much different, except that handlers are
    executed using one worker thread in a worker thread pool, as illustrated in figure
    2.6\. They are still verticles, just like their event-loop counterparts, and the
    code can assume single-threaded access. There is just no stability in which a
    worker thread is going to be used for processing a worker verticle’s events.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 工作垂直的情况并没有太大的不同，除了处理器是在工作线程池中的一个工作线程上执行的，如图 2.6 所示。它们仍然是垂直，就像它们的事件循环对应物一样，代码可以假设单线程访问。只是没有稳定性来决定哪个工作线程将被用于处理工作垂直的事件。
- en: '![](../Images/CH02_F06_Ponge.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F06_Ponge.png)'
- en: Figure 2.6 A worker verticle and its environment
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 一个工作垂直和它的环境
- en: 2.4.2 More on contexts
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 更多关于上下文的内容
- en: Context objects can be accessed using the `getOrCreateContext()` method from
    the `Vertx` class. While a context is almost always associated with a verticle,
    it is possible to create event-loop contexts outside of a verticle. As the name
    of the method suggests
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Vertx` 类中的 `getOrCreateContext()` 方法访问上下文对象。虽然上下文几乎总是与垂直相关联，但可以在垂直之外创建事件循环上下文。正如方法名所暗示的
- en: Calling `getOrCreateContext()` from a context thread like that of a verticle
    returns the context.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类似于垂直的上下文线程中调用 `getOrCreateContext()` 返回上下文。
- en: Calling `getOrCreateContext()` from a non-context thread creates a new context.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从非上下文线程中调用 `getOrCreateContext()` 会创建一个新的上下文。
- en: Listing 2.18 shows an example where a global `Vertx` instance is being created,
    and two calls to `getOrCreateContext` are being made on the JVM process main thread.
    Each call is followed by a call to `runOnContext`, which allows us to run a block
    of code on the context thread.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.18 展示了一个示例，其中创建了一个全局的 `Vertx` 实例，并在 JVM 进程的主线程上对 `getOrCreateContext` 进行了两次调用。每次调用之后都跟着一个对
    `runOnContext` 的调用，这允许我们在上下文线程上运行一段代码块。
- en: Listing 2.18 Creating contexts without a verticle
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.18 创建无垂直方向的上下文
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❷ The lambda is executed on a Vert.x context thread.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Lambda 在 Vert.x 上下文线程上执行。
- en: As you can see in the next listing, each context gets assigned to an event loop.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下一个列表中可以看到的，每个上下文都被分配到一个事件循环。
- en: Listing 2.19 Sample output of running listing 2.18
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.19 运行列表 2.18 的示例输出
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Context objects support more operations, such as holding context-wide arbitrary
    key/value data and declaring exception handlers. The following listing shows an
    example where a `foo` key holds string `bar`, and an exception handler is declared
    to catch and process exceptions while a handler is executed on the event-loop
    thread.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文对象支持更多操作，例如持有上下文范围内的任意键/值数据并声明异常处理程序。以下列表展示了这样一个示例，其中 `foo` 键持有字符串 `bar`，并声明了一个异常处理程序来捕获和处理在事件循环线程上执行处理程序时的异常。
- en: Listing 2.20 Using context data and exception handling
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.20 使用上下文数据和异常处理
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Context data may be useful when event processing is spread across multiple classes.
    It is otherwise much simpler (and faster!) to use class fields.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件处理分散在多个类中时，上下文数据可能很有用。否则，使用类字段会更简单（并且更快！）。
- en: Exception handlers are important when event processing may throw exceptions.
    By default, exceptions are simply logged by Vert.x, but overriding a context exception
    handler is useful when performing custom actions to deal with errors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件处理可能抛出异常时，异常处理程序很重要。默认情况下，异常只是由 Vert.x 记录，但在执行自定义操作以处理错误时，覆盖上下文异常处理程序是有用的。
- en: Listing 2.21 Sample output of running listing 2.20
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.21 运行列表 2.20 的示例输出
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the code in listing 2.20 produces output similar to that of listing
    2.21\.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表 2.20 中的代码会产生与列表 2.21 相似的输出。
- en: 2.4.3 Bridging Vert.x and non-Vert.x threading models
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 桥接 Vert.x 和非-Vert.x 线程模型
- en: 'You will probably not have to deal with Vert.x contexts when writing Vert.x
    applications. Still, there is one case where it makes the most sense: when you
    have to use third-party code that has its own threading model, and you want to
    make it work properly with Vert.x.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Vert.x 应用程序时，你可能不需要处理 Vert.x 上下文。然而，有一种情况是最有意义的：当你必须使用具有自己线程模型的第三方代码，并且你想让它与
    Vert.x 正确工作。
- en: The code in the next listing shows an example where a non-Vert.x thread is being
    created. By passing a context obtained from a verticle, we are able to execute
    some code back on the event loop from some code running on a non-Vert.x thread.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的代码示例展示了如何创建一个非-Vert.x 线程。通过传递从垂直结构中获取的上下文，我们能够从运行在非-Vert.x 线程上的代码中执行一些代码回到事件循环。
- en: Listing 2.22 Mixing different threading models
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.22 混合不同的线程模型
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ We get the context of the verticle because start is running on an event-loop
    thread.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们获取垂直结构的上下文，因为 `start` 是在事件循环线程上运行的。
- en: ❷ We start a plain Java thread.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们启动了一个普通的 Java 线程。
- en: ❸ runOnContext ensures we run some code back on the verticle event-loop thread.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `runOnContext` 确保我们在垂直结构事件循环线程上运行一些代码。
- en: The logs in the following listing show that.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的日志显示了这一点。
- en: Listing 2.23 Sample output when running listing 2.22
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.23 运行列表 2.22 的示例输出
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can use the technique of having a verticle context and issuing calls to
    `runOnContext` whenever you need to integrate non-Vert.x threading models into
    your applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将非-Vert.x 线程模型集成到你的应用程序中时，可以使用具有垂直结构上下文并发出 `runOnContext` 调用的技术。
- en: 'Tip This example shows another important property of contexts: they are propagated
    when defining handlers. Indeed, the block of code run with `runOnContext` sets
    a timer handler after one second. You can see that the handler is executed with
    the same context as the one that was used to define it.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：此示例展示了上下文的另一个重要属性：在定义处理程序时它们会被传播。确实，使用 `runOnContext` 运行的代码块在 1 秒后设置了一个定时器处理程序。你可以看到，处理程序是使用定义它的同一个上下文执行的。
- en: The next chapter discusses the event bus, the privileged way verticles can communicate
    with each other and articulate event processing in a Vert.x application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论事件总线，这是垂直结构之间相互通信的特权方式，并在 Vert.x 应用程序中阐述事件处理。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Verticles are the core component for asynchronous event processing in Vert.x
    applications.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直结构是 Vert.x 应用程序中异步事件处理的核心组件。
- en: Event-loop verticles process asynchronous I/O events and should be free of blocking
    and long-running operations.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环垂直结构处理异步 I/O 事件，应该避免阻塞和长时间运行的操作。
- en: Worker verticles can be used to process blocking I/O and long-running operations.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作垂直结构可以用来处理阻塞 I/O 和长时间运行的操作。
- en: It is possible to mix code with both Vert.x and non-Vert.x threads by using
    event-loop contexts.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用事件循环上下文，可以混合使用 Vert.x 和非-Vert.x 线程的代码。
- en: '* * *'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '1.For more on the actor concurrency model, see the 1973 article by Carl Hewitt,
    Peter Bishop, and Richard Steiger that introduced the model: “A universal modular
    ACTOR formalism for artificial intelligence,” in Proceedings of the 3rd international
    joint conference on Artificial intelligence (IJCAI’73), p. 235-245 (Morgan Kaufmann,
    1973).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 关于演员并发模型，更多内容请参阅 Carl Hewitt、Peter Bishop 和 Richard Steiger 在 1973 年发表的文章，该文章介绍了该模型：“用于人工智能的通用模块化
    ACTOR 形式化”，载于第 3 届国际人工智能联合会议（IJCAI’73）论文集，第 235-245 页（Morgan Kaufmann，1973 年）。
- en: '2.The paper that introduced the concept of promises and futures was B. Liskov
    and L. Shrira, “Promises: linguistic support for efficient asynchronous procedure
    calls in distributed systems,” in R.L. Wexelblat, ed., Proceedings of the ACM
    SIGPLAN 1988 conference on Programming language design and implementation (PLDI’88),
    p. 260-267 (ACM, 1988).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 介绍了承诺和未来概念的文章是 B. Liskov 和 L. Shrira 的“Promises：在分布式系统中对高效异步过程调用的语言支持”，载于
    R.L. Wexelblat 编著的 ACM SIGPLAN 1988 年程序设计语言设计和实现会议（PLDI’88）论文集，第 260-267 页（ACM，1988
    年）。
