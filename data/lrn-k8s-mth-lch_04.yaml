- en: 3 Connecting Pods over the network with Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 通过服务在网络中连接Pod
- en: Pods are the basic building blocks of an application running in Kubernetes.
    Most applications are distributed across multiple components, and you model those
    in Kubernetes using a Pod for each component. For example, you may have a website
    Pod and an API Pod, or you may have dozens of Pods in a microservice architecture.
    They all need to communicate, and Kubernetes supports the standard networking
    protocols, TCP and UDP. Both protocols use IP addresses to route traffic, but
    IP addresses change when Pods are replaced, so Kubernetes provides a network address
    discovery mechanism with *Services*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Pods是运行在Kubernetes中的应用程序的基本构建块。大多数应用程序都分布在多个组件上，你可以在Kubernetes中使用每个组件的Pod来模拟这些组件。例如，你可能有一个网站Pod和一个API
    Pod，或者你可能在一个微服务架构中有数十个Pod。它们都需要进行通信，Kubernetes支持标准的网络协议，TCP和UDP。这两个协议都使用IP地址来路由流量，但是当Pod被替换时，IP地址会发生变化，因此Kubernetes提供了一个带有*服务*的网络地址发现机制。
- en: Services are flexible resources that support routing traffic between Pods, into
    Pods from the world outside the cluster, and from Pods to external systems. In
    this chapter, you’ll learn all the different Service configurations Kubernetes
    provides to glue systems together, and you’ll understand how they work transparently
    for your apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是灵活的资源，支持在Pod之间、从集群外部到Pod以及从Pod到外部系统之间路由流量。在本章中，你将了解Kubernetes提供的所有不同服务配置，以粘合系统，并了解它们是如何为你的应用程序透明工作的。
- en: 3.1 How Kubernetes routes network traffic
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 Kubernetes如何路由网络流量
- en: 'You learned two important things about Pods in the previous chapter: a Pod
    is a virtual environment that has an IP address assigned by Kubernetes, and Pods
    are disposable resources whose lifetime is controlled by another resource. If
    one Pod wants to communicate with another, it can use the IP address. That’s problematic
    for two reasons, however: first, the IP address changes if the Pod is replaced,
    and second, there’s no easy way to find a Pod’s IP address—it can be discovered
    only using the Kubernetes API.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你了解了关于Pod的两个重要事情：Pod是一个由Kubernetes分配IP地址的虚拟环境，Pod是可丢弃的资源，其生命周期由另一个资源控制。如果一个Pod想要与另一个Pod通信，它可以使用IP地址。然而，这有两个问题：首先，如果Pod被替换，IP地址会发生变化，其次，没有简单的方法可以找到Pod的IP地址——它只能通过Kubernetes
    API来发现。
- en: Try it now If you deploy two Pods, you can ping one Pod from the other, but
    you first need to find its IP address.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 如果你部署了两个Pod，你可以从另一个Podping它，但首先你需要找到它的IP地址。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: My output appears in figure 3.1\. The ping inside the container works fine,
    and the first Pod is able to successfully reach the second Pod, but I had to find
    the IP address using kubectl and pass it into the `ping` command.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出显示在图3.1中。容器内的ping操作正常，第一个Pod能够成功到达第二个Pod，但我不得不使用kubectl找到IP地址并将其传递给`ping`命令。
- en: '![](../Images/3-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-1.jpg)'
- en: Figure 3.1 Pod networking with IP addresses—you can discover an address only
    from the Kubernetes API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 使用IP地址的Pod网络——你只能从Kubernetes API中找到地址。
- en: The virtual network in Kubernetes spans the whole cluster, so Pods can communicate
    via IP address even if they’re running on different nodes. This example works
    in the same way on a single-node K3s cluster and a 100-node AKS cluster. It’s
    a useful exercise to help you see that Kubernetes doesn’t do any special networking
    magic; it just uses the standard protocols your apps already use. You wouldn’t
    normally do this, because the IP address is specific to one Pod, and when the
    Pod is replaced, the replacement will have a new IP address.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的虚拟网络跨越整个集群，因此即使Pod在不同的节点上运行，它们也可以通过IP地址进行通信。这个例子在单个节点的K3s集群和100个节点的AKS集群上以相同的方式工作。这是一个有用的练习，可以帮助你看到Kubernetes不做任何特殊的网络魔法；它只是使用了你的应用程序已经使用的标准协议。你通常不会这样做，因为IP地址是特定于一个Pod的，当Pod被替换时，替换的Pod将有一个新的IP地址。
- en: Try it now These Pods are managed by Deployment controllers. If you delete the
    second Pod, its controller will start a replacement with a new IP address.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 这些Pod由Deployment控制器管理。如果你删除了第二个Pod，其控制器将启动一个新的IP地址的替换Pod。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In figure 3.2, my output shows that the replacement Pod has a different IP address,
    and if I tried to ping the old address, the command would fail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2中，我的输出显示替换后的Pod有一个不同的IP地址，如果我尝试ping旧地址，命令会失败。
- en: '![](../Images/3-2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-2.jpg)'
- en: Figure 3.2 The Pod IP address is not part of its specification; a replacement
    Pod has a new address.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 Pod的IP地址不是其规范的一部分；替换后的Pod有一个新的地址。
- en: The problem of needing a permanent address for resources that can change is
    an old one—the internet solved it using DNS (the Domain Name System), mapping
    friendly names to IP addresses, and Kubernetes uses the same system. A Kubernetes
    cluster has a DNS server built in, which maps Service names to IP addresses. Figure
    3.3 shows how a domain name lookup works for Pod-to-Pod communication.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要为可能变化的资源提供永久地址的问题是一个老问题——互联网使用 DNS（域名系统）解决了这个问题，将友好名称映射到 IP 地址，Kubernetes
    也使用了相同的系统。Kubernetes 集群内置了一个 DNS 服务器，它将服务名称映射到 IP 地址。图 3.3 展示了 Pod 到 Pod 通信的域名查找过程。
- en: '![](../Images/3-3.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-3.jpg)'
- en: Figure 3.3 Services allow Pods to communicate using a fixed domain name.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 显示服务允许 Pod 使用固定域名进行通信。
- en: This type of Service is an abstraction over a Pod and its network address, just
    like a Deployment is an abstraction over a Pod and its container. The Service
    has its own IP address, which is static. When consumers make a network request
    to that address, Kubernetes routes it to the actual IP address of the Pod. The
    link between the Service and its Pods is set up with a label selector, just like
    the link between Deployments and Pods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的服务是对 Pod 及其网络地址的抽象，就像 Deployment 是对 Pod 及其容器的抽象一样。服务有自己的 IP 地址，它是静态的。当消费者向该地址发起网络请求时，Kubernetes
    将其路由到 Pod 的实际 IP 地址。服务与其 Pod 之间的连接是通过标签选择器设置的，就像 Deployment 与 Pod 之间的连接一样。
- en: Listing 3.1 shows the minimal YAML specification for a Service, using the app
    label to identify the Pod which is the ultimate target of the network traffic.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 展示了服务的最小 YAML 规范，使用 app 标签来识别网络流量的最终目标 Pod。
- en: Listing 3.1 sleep2-service.yaml, the simplest Service definition
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 sleep2-service.yaml，最简单的服务定义
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This Service definition works with one of the Deployments we have running from
    the previous exercise. When you deploy it, Kubernetes creates a DNS entry called
    sleep-2, which routes traffic into the Pod created by the sleep-2 Deployment.
    Other Pods can send traffic to that Pod using the Service name as the domain name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务定义与之前练习中运行的一个 Deployment 兼容。当您部署它时，Kubernetes 创建一个名为 sleep-2 的 DNS 条目，将流量路由到由
    sleep-2 Deployment 创建的 Pod。其他 Pod 可以使用服务名称作为域名向该 Pod 发送流量。
- en: Try it now You deploy a Service using a YAML file and the usual kubectl `apply`
    command. Deploy the Service, and verify the network traffic is routed to the Pod.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。您可以使用 YAML 文件和常规的 kubectl `apply` 命令部署一个服务。部署服务后，验证网络流量是否被路由到 Pod。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: My output is shown in figure 3.4, where you can see that the name resolution
    worked correctly, although the `ping` command didn’t work as expected because
    ping uses a network protocol that isn’t supported in Kubernetes Services.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出显示在图 3.4 中，您可以看到名称解析工作正常，尽管 `ping` 命令没有按预期工作，因为 ping 使用的是 Kubernetes 服务不支持的网络协议。
- en: '![](../Images/3-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-4.jpg)'
- en: Figure 3.4 Deploying a Service creates a DNS entry, giving the Service name
    a fixed IP address.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 部署服务创建了一个 DNS 条目，为服务名称提供了一个固定的 IP 地址。
- en: 'That’s the basic concept behind Service discovery in Kubernetes: deploy a Service
    resource and use the name of the Service as the domain name for components to
    communicate.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Kubernetes 中服务发现背后的基本概念：部署一个服务资源，并使用服务的名称作为组件通信的域名。
- en: Different types of Service support different networking patterns, but you work
    with them all in the same way. Next, we’ll look more closely at Pod-to-Pod networking,
    with a working example of a simple distributed app.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的服务类型支持不同的网络模式，但您以相同的方式与它们一起工作。接下来，我们将更详细地研究 Pod 到 Pod 的网络，通过一个简单分布式应用的示例来展示。
- en: 3.2 Routing traffic between Pods
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 在 Pod 之间路由流量
- en: The default type of Service in Kubernetes is called ClusterIP. It creates a
    clusterwide IP address that Pods on any node can access. The IP address works
    only within the cluster, so ClusterIP Services are useful only for communicating
    between Pods. That’s exactly what you want for a distributed system where some
    components are internal and shouldn’t be accessible outside of the cluster. We’ll
    use a simple website that uses an internal API component to demonstrate that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中服务的默认类型称为 ClusterIP。它创建一个集群范围内的 IP 地址，任何节点上的 Pod 都可以访问。该 IP 地址仅在集群内部有效，因此
    ClusterIP 服务仅适用于 Pod 之间的通信。这正是分布式系统所需要的，其中某些组件是内部的，不应该在集群外部访问。我们将使用一个简单的网站来演示这一点，该网站使用内部
    API 组件。
- en: Try it now Run two Deployments, one for the web application and one for the
    API. This app has no Services yet, and it won’t work correctly because the website
    can’t find the API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行两个Deployment，一个用于Web应用，一个用于API。此应用尚未定义任何服务，并且它将无法正常工作，因为网站找不到API。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see from my output shown in figure 3.5 that the app fails with a message
    stating the API is unavailable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从我在图3.5中显示的输出中看到，应用失败，显示API不可用的消息。
- en: '![](../Images/3-5.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-5.jpg)'
- en: Figure 3.5 The web app runs but doesn’t function correctly because the network
    call to the API fails.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 Web应用运行但无法正常工作，因为对API的网络调用失败。
- en: The error page also shows the domain name where the site is expecting to find
    the API—http://numbers-api. That’s not a fully qualified domain name (like [blog.sixeyed
    .com](http://blog.sixeyed.com)); it’s an address that should be resolved by the
    local network, but the DNS server in Kubernetes doesn’t resolve it because there
    is no Service with the name `numbers-api`. The specification in listing 3.2 shows
    a Service with the correct name and a label selector that matches the API Pod.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 错误页面还显示了网站期望找到API的域名——http://numbers-api。这并不是一个完全限定的域名（如[blog.sixeyed.com](http://blog.sixeyed.com)）；这是一个应由本地网络解析的地址，但Kubernetes中的DNS服务器无法解析它，因为没有名为`numbers-api`的服务。列表3.2中的规范显示了一个具有正确名称的Service和一个匹配API
    Pod的标签选择器。
- en: Listing 3.2 api-service.yaml, a Service for the random-number API
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 api-service.yaml，随机数API的服务
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This Service is similar to that in listing 3.1, except that the names have changed
    and the Service type of ClusterIP is explicitly stated. That can be omitted because
    it’s the default Service type, but I think it makes the spec clearer if you include
    it. Deploying the Service will route the traffic between the web Pod and the API
    Pod, fixing the app without any changes to the Deployments or Pods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务与列表3.1中的类似，只是名称已更改，并且明确指出了ClusterIP服务类型。这可以省略，因为它是默认的服务类型，但我认为包含它可以使规范更清晰。部署服务将路由Web
    Pod和API Pod之间的流量，修复应用而无需更改部署或Pod。
- en: Try it now Create a Service for the API so the domain lookup works and traffic
    is sent from the web Pod to the API Pod.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 为API创建一个服务，以便域名查找工作，并将流量从Web Pod发送到API Pod。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: My output, shown in figure 3.6, shows the app working correctly, with the website
    displaying a random-number generated by the API.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图3.6中显示的输出显示了应用正常工作，网站显示由API生成的随机数。
- en: '![](../Images/3-6.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-6.jpg)'
- en: Figure 3.6 Deploying a Service fixes the broken link between the web app and
    the API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 部署服务修复了Web应用和API之间的断链。
- en: The important lesson here, beyond Services, Deployments, and Pods, is that your
    YAML specifications describe your whole application in Kubernetes—that’s all the
    components and the networking between them. Kubernetes doesn’t make assumptions
    about your application architecture; you need to specify it in the YAML. This
    simple web app needs three Kubernetes resources defined for it to work in its
    current state—two Deployments and a Service—but the advantage of having all these
    moving parts is increased resilience.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务、部署和Pod之外，这里的重要教训是您的YAML规范描述了您的整个应用程序在Kubernetes中——那就是所有组件及其之间的网络。Kubernetes不会对您的应用程序架构做出假设；您需要在YAML中指定它。这个简单的Web应用需要定义三个Kubernetes资源才能在当前状态下工作——两个Deployment和一个Service，但所有这些移动部件的优势是提高了弹性。
- en: Try it now The API Pod is managed by a Deployment controller, so you can delete
    the Pod and a replacement will be created. The replacement is also a match for
    the label selector in the API Service, so traffic is routed to the new Pod, and
    the app keeps working.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 API Pod 由Deployment控制器管理，因此您可以删除Pod，并将创建一个替换品。替换品也符合API Service中的标签选择器，因此流量被路由到新的Pod，应用继续工作。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Figure 3.7 shows that a replacement Pod is created by the Deployment controller.
    It’s the same API Pod spec but running in a new Pod with a new IP address. The
    IP address of the API Service hasn’t changed, though, and the web Pod can reach
    the new API Pod at the same network address.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7显示Deployment控制器创建了一个替换Pod。它是相同的API Pod规范，但在一个新的Pod中运行，具有新的IP地址。不过，API服务的IP地址没有改变，Web
    Pod可以在相同的网络地址上到达新的API Pod。
- en: '![](../Images/3-7.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-7.jpg)'
- en: Figure 3.7 The Service isolates the web Pod from the API Pod, so it doesn’t
    matter whether the API Pod changes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 服务将Web Pod与API Pod隔离开来，因此API Pod是否更改无关紧要。
- en: We’re manually deleting Pods in these exercises to trigger the controller to
    create a replacement, but in the normal life cycle of a Kubernetes application,
    Pod replacement happens all the time. Anytime you update a component of your app—to
    add features, fix bugs, or release an update to a dependency—you’re replacing
    Pods. Any time a node goes down, its Pods are replaced on other nodes. The Service
    abstraction keeps apps communicating through these replacements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些练习中，我们手动删除Pods以触发控制器创建替换，但在Kubernetes应用程序的正常生命周期中，Pod替换一直在发生。每次你更新应用程序的任何组件——添加功能、修复错误或发布依赖项的更新——你都在替换Pods。任何节点宕机时，其Pods都会在其他节点上替换。服务抽象层保持应用程序通过这些替换进行通信。
- en: This demo app isn’t complete yet because it doesn’t have anything configured
    to receive traffic from outside the cluster and send it in to the web Pod. We’ve
    used port forwarding so far, but that’s really a trick for debugging. The real
    solution is to deploy a Service for the web Pod, too.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示应用程序还不完整，因为它还没有配置好以接收来自集群外部的流量并将其发送到Web Pod。我们到目前为止已经使用了端口转发，但这实际上是一种调试技巧。真正的解决方案是为Web
    Pod也部署一个服务。
- en: 3.3 Routing external traffic to Pods
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 将外部流量路由到Pods
- en: You have several options to configure Kubernetes to listen for traffic coming
    into the cluster and forward it to a Pod. We’ll start with a simple and flexible
    approach, which is fine for everything from local development to production. It’s
    a type of a Service called LoadBalancer, which solves the problem of getting traffic
    to a Pod that might be running on a different node from the one that received
    the traffic; figure 3.8 shows how it looks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方法可以配置Kubernetes以监听进入集群的流量并将其转发到Pod。我们将从一种简单灵活的方法开始，这对于从本地开发到生产的一切都适用。这是一种称为LoadBalancer的服务类型，它解决了将流量引导到可能运行在不同节点上的Pod的问题；图3.8显示了其外观。
- en: '![](../Images/3-8.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8](../Images/3-8.jpg)'
- en: Figure 3.8 LoadBalancer Services route external traffic from any node into a
    matching Pod.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 LoadBalancer服务将来自任何节点的外部流量路由到匹配的Pod。
- en: It looks like a tricky problem, especially because you might have many Pods
    that match the label selector for the Service, so the cluster needs to choose
    a node to send the traffic to and then choose a Pod on that node. All that trickiness
    is taken care of by Kubernetes—that’s world-class orchestration for you—so all
    you need to do is deploy a LoadBalancer Service. Listing 3.3 shows the Service
    specification for the web application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个棘手的问题，特别是因为你可能有多个匹配服务标签选择器的Pod，因此集群需要选择一个节点来发送流量，然后在该节点上选择一个Pod。所有这些复杂性都由Kubernetes处理——这就是世界级的编排——所以你只需要部署一个LoadBalancer服务。列表3.3显示了Web应用程序的服务规范。
- en: Listing 3.3 web-service.yaml, a LoadBalancer Service for external traffic
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 web-service.yaml，一个用于外部流量的LoadBalancer服务
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This Service listens on port 8080 and sends traffic to the web Pod on port 80\.
    When you deploy it, you’ll be able to use the web app without setting up a port
    forward in kubectl, but the exact details of how you reach the app will depend
    on how you’re running Kubernetes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务监听8080端口并将流量发送到端口80的Web Pod。当你部署它时，你将能够使用Web应用程序而无需在kubectl中设置端口转发，但如何到达应用程序的确切细节将取决于你如何运行Kubernetes。
- en: Try it now Deploy the Service, and then use kubectl to find the address of the
    Service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 部署服务，然后使用kubectl找到服务的地址。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 3.9 shows my output from running the exercise on my Docker Desktop Kubernetes
    cluster, where I can browse to the website at the address http://localhost:8080.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9显示了我在Docker Desktop Kubernetes集群上运行练习的输出，我可以浏览到地址为http://localhost:8080的网站。
- en: '![](../Images/3-9.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9](../Images/3-9.jpg)'
- en: Figure 3.9 Kubernetes requests an IP address for LoadBalancer Services from
    the platform on which it’s running.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 Kubernetes从其运行的平台上请求LoadBalancer服务的IP地址。
- en: The output is different using K3s or a managed Kubernetes cluster in the cloud,
    where the Service deployment creates a dedicated external IP address for the load
    balancer. Figure 3.10 shows the output of the same exercise (using the same YAML
    specifications) using the K3s cluster on my Linux VM-here the website is at http://
    172.28.132.127:8080.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用K3s或云中的托管Kubernetes集群时，输出会有所不同，其中服务部署为负载均衡器创建一个专用的外部IP地址。图3.10显示了使用同一YAML规范在Linux
    VM上的K3s集群执行相同练习的输出（这里网站位于http://172.28.132.127:8080）。
- en: '![](../Images/3-10.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10](../Images/3-10.jpg)'
- en: Figure 3.10 Different Kubernetes platforms use different addresses for LoadBalancer
    Services.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 不同Kubernetes平台为LoadBalancer服务使用不同的地址。
- en: How can the results be different with the same application manifests? I said
    in chapter 1 that you can deploy Kubernetes in different ways and *it’s all the
    same Kubernetes* (my emphasis), but that’s not strictly true. Kubernetes contains
    a lot of extension points, and distributions have flexibility in how they implement
    certain features. LoadBalancer Services represent a good example of where implementations
    differ, suited to the goals of the distribution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的应用清单为什么结果会不同呢？我在第一章提到过，你可以以不同的方式部署 Kubernetes，*它们都是相同的 Kubernetes*（我的强调），但这并不完全正确。Kubernetes
    包含了许多扩展点，各个发行版在实现某些功能时都有一定的灵活性。LoadBalancer 服务就是一个很好的例子，其实现方式因发行版的目标而异。
- en: Docker Desktop is a local development environment. It runs on a single machine
    and integrates with the network stack so LoadBalancer Services are available at
    the localhost address. Every LoadBalancer Service publishes to localhost, so you’ll
    need to use different ports if you deploy many load balancers.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop 是一个本地开发环境。它运行在单个机器上，并与网络栈集成，因此 LoadBalancer 服务在 localhost 地址上可用。每个
    LoadBalancer 服务都会发布到 localhost，因此如果你部署了多个负载均衡器，你需要使用不同的端口。
- en: K3s supports LoadBalancer Services with a custom component that sets up routing
    tables on your machine. Every LoadBalancer Service publishes to the IP address
    of your machine (or VM), so you can access Services with localhost or from a remote
    machine on your network. Like Docker Desktop, you’ll need to use different ports
    for each load balancer.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K3s 支持使用自定义组件设置路由表，从而支持 LoadBalancer 服务。每个 LoadBalancer 服务都会发布到你的机器（或虚拟机）的 IP
    地址，因此你可以通过 localhost 或网络上的远程机器访问服务。与 Docker Desktop 类似，你需要为每个负载均衡器使用不同的端口。
- en: Cloud Kubernetes platforms like AKS and EKS are highly available multinode clusters.
    Deploying a Kubernetes LoadBalancer Service creates an actual load balancer in
    your cloud, which spans all the nodes in your cluster—the cloud load balancer
    sends incoming traffic to one of the nodes and then Kubernetes routes it to a
    Pod. You’ll get a different IP address for each LoadBalancer Service, and it will
    be a public address, accessible from the internet.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 AKS 和 EKS 这样的云 Kubernetes 平台是高度可用的多节点集群。部署 Kubernetes LoadBalancer 服务会在你的云中创建一个实际的负载均衡器，它覆盖了集群中的所有节点——云负载均衡器将传入的流量发送到集群中的一个节点，然后
    Kubernetes 将其路由到 Pod。每个 LoadBalancer 服务都会分配一个不同的 IP 地址，并且它是一个公网地址，可以从互联网访问。
- en: This is a pattern we’ll see again in other Kubernetes features where distributions
    have different resources available and different aims. Ultimately, the YAML manifests
    are the same and the end results are consistent, but Kubernetes allows distributions
    to diverge in how they get there.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他 Kubernetes 功能中，我们还会看到这种模式，即各个发行版提供了不同的资源，有不同的目标。最终，YAML 清单是相同的，最终结果也是一致的，但
    Kubernetes 允许发行版在实现过程中有所差异。
- en: Back in the world of standard Kubernetes, there’s another Service type you can
    use that listens for network traffic coming into the cluster and directs it to
    a Pod—the NodePort. NodePort Services don’t require an external load balancer—every
    node in the cluster listens on the port specified in the Service and sends traffic
    to the target port on the Pod. Figure 3.11 shows how it works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 Kubernetes 的世界中，你还可以使用另一种 Service 类型来监听进入集群的网络流量并将其导向 Pod——即 NodePort。NodePort
    服务不需要外部负载均衡器——集群中的每个节点都会监听服务中指定的端口，并将流量发送到 Pod 的目标端口。图 3.11 展示了其工作原理。
- en: '![](../Images/3-11.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11](../Images/3-11.jpg)'
- en: Figure 3.11 NodePort Services also route external traffic to Pods, but they
    don’t require a load balancer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 NodePort 服务也会将外部流量路由到 Pod，但它们不需要负载均衡器。
- en: NodePort Services don’t have the flexibility of LoadBalancer Services because
    you need a different port for each Service, your nodes need to be publicly accessible,
    and you don’t achieve load-balancing across a multinode cluster. NodePort Services
    also have different levels of support in the distributions, so they work as expected
    in K3s and Docker Desktop but not so well in Kind. Listing 3.4 shows a NodePort
    spec for reference.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: NodePort 服务没有 LoadBalancer 服务的灵活性，因为每个服务都需要不同的端口，你的节点需要是公开可访问的，而且你无法在多节点集群中实现负载均衡。NodePort
    服务在各个发行版中的支持级别也不同，因此在 K3s 和 Docker Desktop 中可以按预期工作，但在 Kind 中则不太理想。列表 3.4 展示了一个
    NodePort 规范以供参考。
- en: Listing 3.4 web-service-nodePort.yaml, a NodePort Service specification
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 web-service-nodePort.yaml，一个 NodePort 服务规范
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There isn’t an exercise to deploy this NodePort Service (although the YAML file
    is in the chapter’s folder if you want to try it out). This is partly because
    it doesn’t work in the same way on every distribution, so this section would end
    with lots of if branches that you’d need to try to make sense of. But there’s
    a more important reason—you don’t typically use NodePorts in production, and it’s
    good to keep your manifests as consistent as possible across different environments.
    Sticking with LoadBalancer Services means you have the same specs from development
    up to production, which means fewer YAML files to maintain and keep in sync.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有部署此 NodePort 服务的练习（尽管 YAML 文件在章节文件夹中，如果您想尝试的话）。这部分原因是因为它不是在每种发行版上以相同的方式工作，所以这一节将结束于许多需要尝试才能理解的
    if 分支。但更重要的是——您通常不会在生产环境中使用 NodePort，并且最好让您的配置文件在不同环境中尽可能一致。坚持使用 LoadBalancer
    服务意味着您从开发到生产都有相同的规范，这意味着需要维护和同步的 YAML 文件更少。
- en: We’ll finish this chapter by digging into how Services work under the hood,
    but before that, we’ll look at one more way you can use Services, which is to
    communicate from Pods to components outside of the cluster.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过深入了解服务在底层是如何工作的来结束本章，但在那之前，我们将探讨您可以使用服务的一种更多方式，即从 Pod 与集群外部的组件进行通信。
- en: 3.4 Routing traffic outside Kubernetes
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 在 Kubernetes 外部路由流量
- en: You can run almost any server software in Kubernetes, but that doesn’t mean
    you should. Storage components like databases are typical candidates for running
    outside of Kubernetes, especially if you’re deploying to the cloud and you can
    use a managed database service instead. Or you may be running in the datacenter
    and need to integrate with existing systems that won’t be migrating to Kubernetes.
    Whatever architecture you’re using, you can still use Kubernetes Services for
    domain name resolution to components outside the cluster.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎可以在 Kubernetes 中运行任何服务器软件，但这并不意味着您应该这样做。例如，数据库等存储组件通常是运行在 Kubernetes 外部的典型候选者，尤其是如果您正在云中部署，并且可以使用托管数据库服务。或者，您可能正在数据中心运行，需要与不会迁移到
    Kubernetes 的现有系统集成。无论您使用什么架构，您仍然可以使用 Kubernetes 服务进行域名解析，以访问集群外部的组件。
- en: The first option for that is to use an ExternalName Service, which is like an
    alias from one domain to another. ExternalName Services let you use local names
    in your application Pods, and the DNS server in Kubernetes resolves the local
    name to a fully qualified external name when the Pod makes a lookup request. Figure
    3.12 shows how that works, with a Pod using a local name that resolves to an external
    system address.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的第一种方法是使用 ExternalName 服务，它就像一个从一个域名到另一个域名的别名。ExternalName 服务允许您在应用程序 Pod
    中使用本地名称，当 Pod 进行查找请求时，Kubernetes 中的 DNS 服务器将本地名称解析为完全限定的外部名称。图 3.12 展示了它是如何工作的，一个
    Pod 使用本地名称，该名称解析为外部系统地址。
- en: '![](../Images/3-12.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-12.jpg)'
- en: Figure 3.12 Using an ExternalName Service lets you use local cluster addresses
    for remote components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 使用 ExternalName 服务允许您使用本地集群地址访问远程组件。
- en: The demo app for this chapter expects to use a local API to generate random
    numbers, but it can be switched to read a static number from a text file on GitHub
    just by deploying an ExternalName Service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的演示应用程序预期使用本地 API 生成随机数，但只需部署一个 ExternalName 服务，就可以切换到从 GitHub 上的文本文件中读取静态数字。
- en: Try it now You can’t switch a Service from one type to another in every version
    of Kubernetes, so you’ll need to delete the original ClusterIP Service for the
    API before you can deploy the ExternalName Service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：您不能在 Kubernetes 的每个版本中都将服务从一种类型切换到另一种类型，因此您在部署 ExternalName 服务之前需要删除
    API 的原始 ClusterIP 服务。
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: My output is shown in figure 3.13\. You can see the app works in the same way,
    and it’s using the same URL for the API. If you refresh the page, however, you’ll
    find that it always returns the same number because it’s not using the random-number
    API anymore.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我的结果如图 3.13 所示。您可以看到应用程序以相同的方式工作，并且它使用相同的 API URL。但是，如果您刷新页面，您会发现它总是返回相同的数字，因为它不再使用随机数
    API。
- en: '![](../Images/3-13.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-13.jpg)'
- en: Figure 3.13 ExternalName Services can be used as a redirect to send requests
    outside of the cluster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 ExternalName 服务可以用作重定向，将请求发送到集群外部。
- en: ExternalName Services can be a useful way to deal with differences between environments
    that you can’t work around in your app configuration. Maybe you have an app component
    that uses a hardcoded string for the name of the database server. In development
    environments, you could create a ClusterIP Service with the expected domain name,
    which resolves to a test database running in a Pod; in production environments,
    you can use an ExternalName Service that resolves to the real domain name of the
    database server. Listing 3.5 shows the YAML spec for the API external name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalName服务可以是一种有用的方式来处理你无法在应用配置中绕过的环境差异。也许你有一个应用组件，它使用硬编码的字符串作为数据库服务器的名称。在开发环境中，你可以创建一个带有预期域名的ClusterIP服务，该服务解析到在Pod中运行的测试数据库；在生产环境中，你可以使用一个解析到数据库服务器真实域名的ExternalName服务。列表3.5显示了API外部名称的YAML规范。
- en: Listing 3.5 api-service-externalName.yaml, an ExternalName Service
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 api-service-externalName.yaml，一个ExternalName服务
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Kubernetes implements ExternalName Services using a standard feature of DNS—canonical
    names (CNAMEs). When the web Pod makes a DNS lookup for the `numbers-api` domain
    name, the Kubernetes DNS server returns with the CNAME, which is raw.githubusercontent.com.
    Then the DNS resolution continues using the DNS server configured on the node,
    so it will reach out to the internet to find the IP address of the GitHub servers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用DNS的一个标准功能——规范名称（CNAMEs）来实现ExternalName服务。当Web Pod对`numbers-api`域名进行DNS查找时，Kubernetes
    DNS服务器返回CNAME，即raw.githubusercontent.com。然后DNS解析继续使用节点上配置的DNS服务器，因此它会连接到互联网以找到GitHub服务器的IP地址。
- en: Try it now Services are part of the clusterwide Kubernetes Pod network, so any
    Pod can use a Service. The sleep Pods from the first exercise in this chapter
    have a `DNS` `lookup` command in the container image, which you can use to check
    the resolution of the API Service.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下，服务是集群范围内的Kubernetes Pod网络的一部分，所以任何Pod都可以使用服务。本章第一个练习中的sleep Pods在容器镜像中有一个`DNS`
    `lookup`命令，你可以使用它来检查API服务的解析。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you try this, you may get scrambled results that look like errors, because
    the Nslookup tool returns a lot of information and it’s not in the same order
    every time you run it. The data you want is in there, though. I repeated the command
    a few times to get the fit-for-print output you see in figure 3.14.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试这样做时，你可能会得到一些看起来像错误的混乱结果，因为Nslookup工具返回了大量的信息，并且每次运行时顺序都不相同。不过，你想要的数据确实在里面。我重复执行了几次命令，以获得图3.14中看到的适合打印的输出。
- en: '![](../Images/3-14.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14](../Images/3-14.jpg)'
- en: Figure 3.14 Apps aren’t isolated by default in Kubernetes, so any Pod can do
    a lookup for any Service.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 在Kubernetes中，应用默认不是隔离的，所以任何Pod都可以为任何服务进行查找。
- en: 'There’s one important thing to understand about ExternalName Services, which
    you can see from this exercise: they ultimately just give your app an address
    to use, but they don’t actually change the requests your application makes. That’s
    fine for components like databases, which communicate over TCP, but it’s not so
    simple for HTTP services. HTTP requests include the target host name in a header
    field, and that won’t match the actual domain from the ExternalName response,
    so the client call will probably fail. The random-number app in this chapter has
    some hacky code to get around this issue, manually setting the host header, but
    this approach is best for non-HTTP services.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ExternalName服务，有一件重要的事情需要理解，你可以从这个练习中看到：它们最终只是给你的应用提供一个地址来使用，但它们实际上并没有改变应用发出的请求。这对于像数据库这样的组件来说是可以的，因为它们通过TCP进行通信，但对于HTTP服务来说就不那么简单了。HTTP请求在头字段中包含目标主机名，这不会与ExternalName响应的实际域名匹配，所以客户端调用可能会失败。本章中的随机数应用有一些绕过这个问题的代码，手动设置主机头，但这种方法最适合非HTTP服务。
- en: There’s one other option for routing local domain names in the cluster to external
    systems. It doesn’t fix the HTTP header issue, but it does let you use a similar
    approach to ExternalName Services when you want to route to an IP address rather
    than a domain name. These are *headless Services*, which are defined as a ClusterIP
    Service type but without a label selector so they will never match any Pods. Instead,
    the service is deployed with an *endpoint* resource that explicitly lists the
    IP addresses the Service should resolve.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中路由本地域名到外部系统还有一个其他选项。它不能修复HTTP头问题，但当你想要将流量路由到IP地址而不是域名时，它允许你使用与ExternalName服务类似的方法。这些是*无头服务*，定义为ClusterIP服务类型，但没有标签选择器，因此它们永远不会匹配任何Pod。相反，服务通过一个*端点*资源来部署，该资源明确列出服务应解析的IP地址。
- en: Listing 3.6 shows a headless Service with a single IP address in the endpoint.
    It also shows a new use of YAML, with multiple resources defined, separated by
    three dashes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6显示了一个端点具有单个IP地址的无头服务。它还展示了YAML的新用法，通过三个短横线分隔定义了多个资源。
- en: Listing 3.6 api-service-headless.yaml, a Service with explicit addresses
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 api-service-headless.yaml，一个具有显式地址的服务
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The IP address in that endpoint specification is a fake one, but Kubernetes
    doesn’t validate that the address is reachable, so this code will deploy without
    errors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该端点规范中的IP地址是一个假的，但Kubernetes不会验证该地址是否可达，因此这段代码将无错误地部署。
- en: Try it now Replace the ExternalName Service with this headless Service. It will
    cause the app to fail because the API domain name now resolves to an inaccessible
    IP address.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 替换外部名称服务为这个无头服务。这将导致应用失败，因为API域名现在解析到一个不可访问的IP地址。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: My output, shown in figure 3.15, confirms that Kubernetes will happily let you
    deploy a Service change that breaks your application. The domain name resolves
    the internal cluster IP address, but any network calls to that address fail because
    they are routed to the actual IP address in the endpoint that doesn’t exist.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图3.15中显示的输出确认了Kubernetes会愉快地让你部署一个会破坏你应用的服务变更。域名解析了内部集群IP地址，但任何对该地址的网络调用都会失败，因为它们被路由到端点中实际存在的IP地址。
- en: '![](../Images/3-15.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-15.jpg)'
- en: Figure 3.15 A misconfiguration in a Service can break your apps, even without
    deploying an app change.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 服务配置错误可能会破坏你的应用，即使没有部署应用变更。
- en: 'The output from that exercise raises a couple of interesting questions: How
    come the DNS lookup returns the cluster IP address instead of the endpoint address?
    Why does the domain name end with .default.svc.cluster.local? You don’t need a
    background in network engineering to work with Kubernetes Services, but it will
    help you track down issues if you understand how Service resolution actually works—and
    that’s how we’ll finish the chapter.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该练习的输出引发了一些有趣的问题：为什么DNS查找返回的是集群IP地址而不是端点地址？为什么域名以.default.svc.cluster.local结尾？你不需要网络工程背景就可以使用Kubernetes服务，但如果你理解服务解析的实际工作方式，这将有助于你追踪问题——这正是我们结束本章的方式。
- en: 3.5 Understanding Kubernetes Service resolution
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 理解Kubernetes服务解析
- en: Kubernetes supports all the network configurations your app is likely to need
    using Services, which build on established networking technologies. Application
    components run in Pods and communicate with other Pods using standard transfer
    protocols and DNS names for discovery. You don’t need any special code or libraries;
    your apps work in the same way in Kubernetes as if you deployed them on physical
    servers or VMs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes通过使用服务（Services），这些服务建立在成熟的网络技术之上，支持所有应用可能需要的网络配置。应用组件在Pod中运行，并使用标准传输协议和DNS名称进行发现来与其他Pod进行通信。你不需要任何特殊的代码或库；你的应用在Kubernetes中的工作方式与你在物理服务器或虚拟机上部署它们时相同。
- en: We’ve covered all the Service types and their typical use cases in this chapter,
    so now you have a good understanding of the patterns you can use. If you’re feeling
    that there’s an awful lot of detail here, be assured that the majority of times
    you’ll be deploying ClusterIP Services, which require little configuration. They
    mostly work seamlessly, but it is useful to go one level deeper to understand
    the stack. Figure 3.16 shows that next level of detail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了所有服务类型及其典型用例，因此现在你对可以使用的设计模式有了很好的理解。如果你觉得这里有很多细节，请放心，大多数时候你将部署集群IP服务，这需要很少的配置。它们大多无缝工作，但深入理解堆栈是有用的。图3.16显示了下一级别的细节。
- en: '![](../Images/3-16.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-16.jpg)'
- en: Figure 3.16 Kubernetes runs a DNS server and a proxy and uses them with standard
    network tools.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16显示Kubernetes运行DNS服务器和代理，并使用标准网络工具。
- en: The key takeaway is that the ClusterIP is a virtual IP address that doesn’t
    exist on the network. Pods access the network through the kube-proxy running on
    the node, and that uses packet filtering to send the virtual IP to the real endpoint.
    Kubernetes Services keep their IP addresses as long as they exist, and Services
    can exist independently of any other parts of your app. Services have a controller
    that keeps the endpoint list updated whenever there are changes to Pods, so clients
    always use the static virtual IP address and the kube-proxy always has the up-to-date
    endpoint list.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是ClusterIP是一个虚拟IP地址，它不在网络上存在。Pod通过节点上运行的kube-proxy访问网络，它使用数据包过滤将虚拟IP发送到实际端点。Kubernetes服务只要存在就保持它们的IP地址，服务可以独立于应用程序的任何其他部分存在。服务有一个控制器，每当Pod发生变化时都会更新端点列表，因此客户端始终使用静态虚拟IP地址，kube-proxy始终有最新的端点列表。
- en: Try it now You can see how Kubernetes keeps the endpoint list immediately updated
    when Pods change by listing the endpoints for a Service between Pod changes. Endpoints
    use the same name as Services, and you can view endpoint details using kubectl.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 您可以看到当Pod发生变化时，通过列出Pod变化之间的服务端点，Kubernetes如何立即更新端点列表。端点使用与服务相同的名称，您可以使用kubectl查看端点详情。
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see my output in figure 3.17, and it’s the answer to the first question—Kubernetes
    DNS returns the cluster IP address and not the endpoint, because endpoint addresses
    change.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图3.17中看到我的输出，这是对第一个问题的回答——Kubernetes DNS返回集群IP地址而不是端点，因为端点地址会变化。
- en: '![](../Images/3-17.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图3-17](../Images/3-17.jpg)'
- en: Figure 3.17 The cluster IP address for a Service doesn’t change, but the endpoint
    list is always being updated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 服务的集群IP地址不会改变，但端点列表始终在更新。
- en: Using a static virtual IP means clients can cache the DNS lookup response indefinitely
    (which many apps do as misguided performance-saving), and that IP address will
    continue to work no matter how many Pod replacements occur over time. The second
    question—about the domain name suffix—needs to be answered with a sideways step
    to look at Kubernetes *namespaces*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态虚拟IP意味着客户端可以无限期地缓存DNS查找响应（许多应用程序错误地将其作为性能节省），并且无论随着时间的推移发生多少Pod替换，该IP地址都将继续工作。关于域名后缀的第二个问题需要通过侧向思考来回答，即查看Kubernetes的*命名空间*。
- en: Every Kubernetes resource lives inside a namespace, which is a resource you
    can use to group other resources. Namespaces are a way to logically partition
    a Kubernetes cluster—you could have one namespace per product, one per team, or
    a single shared namespace. We won’t use namespaces for a while yet, but I’m introducing
    them here because they have a part to play in DNS resolution. Figure 3.18 shows
    where the namespace comes into the Service name.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Kubernetes资源都存在于一个命名空间内，这是一个您可以使用它来分组其他资源的资源。命名空间是逻辑上划分Kubernetes集群的一种方式——您可以为每个产品创建一个命名空间，为每个团队创建一个，或者使用一个共享的命名空间。我们暂时不会使用命名空间，但我在这里介绍它们，因为它们在DNS解析中扮演着一定的角色。图3.18显示了命名空间如何进入服务名称。
- en: '![](../Images/3-18.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图3-18](../Images/3-18.jpg)'
- en: Figure 3.18 Namespaces logically partition a cluster, but Services are accessible
    across namespaces.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 命名空间逻辑上划分了一个集群，但服务可以在命名空间之间访问。
- en: You already have several namespaces in your cluster—all the resources we’ve
    deployed so far have been created in the `default` namespace (which is the default;
    that’s why we haven’t needed to specify a namespace in our YAML files). Internal
    Kubernetes components like the DNS server and the Kubernetes API also run in Pods
    in the `kube-system` namespace.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您的集群中已经有了几个命名空间——我们迄今为止部署的所有资源都已在`default`命名空间中创建（这是默认的；这就是为什么我们不需要在我们的YAML文件中指定命名空间）。内部Kubernetes组件，如DNS服务器和Kubernetes
    API，也在`kube-system`命名空间中的Pod中运行。
- en: Try it now Kubectl is namespace-aware—you can use the namespace flag to work
    with resources outside of the default namespace.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 Kubectl具有命名空间感知能力——您可以使用命名空间标志来处理默认命名空间之外的资源。
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: My output, shown in figure 3.19, answers the second question—the local domain
    name for a Service is just the Service name, but that’s an alias for the fully
    qualified domain name that includes the Kubernetes namespace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图3.19中展示的输出回答了第二个问题——服务的本地域名只是服务名称，但这是对包括Kubernetes命名空间在内的完全限定域名的一个别名。
- en: '![](../Images/3-19.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图3-19](../Images/3-19.jpg)'
- en: Figure 3.19 You can use the same kubectl commands to view resources in different
    namespaces.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 您可以使用相同的kubectl命令查看不同命名空间中的资源。
- en: It’s important to know about namespaces early in your Kubernetes journey, if
    only because it helps you see that core Kubernetes features run as Kubernetes
    applications too, but you don’t see them in kubectl unless you explicitly set
    the namespace. Namespaces are a powerful way to subdivide your cluster to increase
    utilization without compromising security, and we’ll return to them in chapter
    11.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Kubernetes之旅早期了解命名空间很重要，仅因为这样可以帮助您看到核心Kubernetes功能也是作为Kubernetes应用程序运行的，但除非您明确设置命名空间，否则您在kubectl中看不到它们。命名空间是一种强大的方式，可以将您的集群细分以增加利用率，同时不牺牲安全性，我们将在第11章中再次讨论它们。
- en: For now we’re done with namespaces and Services. In this chapter, you’ve learned
    that every Pod has its own IP address, and Pod communication ultimately uses that
    address with standard TCP and UDP protocols. You never use the Pod IP address
    directly, though—you always create a Service resource, which Kubernetes uses to
    provide Service discovery with DNS. Services support multiple networking patterns,
    with different Service types configuring network traffic between Pods, into Pods
    from the outside world, and from Pods to the world outside. You also learned that
    Services have their own life cycle, independent of Pods and Deployments, so the
    last thing to do is clean up before we move on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们已经完成了命名空间和服务的操作。在本章中，您了解到每个Pod都有自己的IP地址，Pod通信最终使用该地址通过标准的TCP和UDP协议。尽管如此，您永远不会直接使用Pod
    IP地址——您总是创建一个服务资源，Kubernetes使用该资源通过DNS提供服务发现。服务支持多种网络模式，不同的服务类型配置Pod之间的网络流量、从外部世界进入Pod的网络流量以及从Pod到外部世界的网络流量。您还了解到服务有自己的生命周期，独立于Pod和部署，因此在继续之前，我们最后要做的就是清理。
- en: Try it now Deleting a Deployment also deletes all its Pods, but there’s no cascading
    delete for Services. They’re independent objects that need to be removed separately.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 删除部署也会删除其所有Pod，但服务没有级联删除。它们是独立的对象，需要单独删除。
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now your cluster is clear again, although, as you can see in figure 3.20, you
    need to be careful with some of these kubectl commands.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的集群又清空了，尽管如此，如图3.20所示，您在使用一些kubectl命令时需要小心。
- en: '![](../Images/3-20.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图3-20](../Images/3-20.jpg)'
- en: Figure 3.20 You need to explicitly delete any Services you create, but watch
    out with the `all` parameter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 您需要明确删除您创建的任何服务，但要注意`all`参数。
- en: 3.6 Lab
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 实验室
- en: 'This lab is going to give you some practice creating Services, but it’s also
    going to get you thinking about labels and selectors, which are powerful features
    of Kubernetes. The goal is to deploy Services for an updated version of the random-number
    app, which has had a UI makeover. Here are your hints:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验将让您练习创建服务，但也会让您思考标签和选择器，这些都是Kubernetes的强大功能。目标是部署随机数字应用程序的更新版本的服务，该版本已经进行了用户界面改造。以下是您的提示：
- en: The lab folder for this chapter has a `deployments.yaml` file. Use that to deploy
    the app with kubectl.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的实验文件夹中有一个`deployments.yaml`文件。使用该文件通过kubectl部署应用程序。
- en: Check the Pods—there are two versions of the web application running.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查Pods——有运行着两个版本的Web应用程序。
- en: Write a Service that will make the API available to other Pods at the domain
    name `numbers-api`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个服务，使API可以通过域名`numbers-api`供其他Pod使用。
- en: Write a Service that will make version 2 of the website available externally,
    on port 8088.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个服务，使网站的第2版可以在外部端口8088上使用。
- en: You’ll need to look closely at the Pod labels to get the correct result.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要仔细查看Pod标签才能得到正确的结果。
- en: 'This lab is an extension of the exercises in the chapter, and if you want to
    check my solution, it’s up on GitHub in the repository for the book: [https://github.com/sixeyed/kiamol/blob/master/ch03/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch03/lab/README.md).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验是本章练习的扩展，如果您想检查我的解决方案，可以在GitHub上找到该书的存储库：[https://github.com/sixeyed/kiamol/blob/master/ch03/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch03/lab/README.md)。
