- en: Chapter 4\. Selected classes from the Java API and arrays
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章。Java API中的选定类和数组
- en: '| Exam objectives covered in this chapter | What you need to know |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 本章涵盖的考试目标 | 你需要了解的内容 |'
- en: '| --- | --- |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **[9.2]** Creating and manipulating Strings | How to initialize String variables
    using = (assignment) and new operators. Use of the operators =, +=, !=, and ==
    with String objects. Pooling of string literal values. Literal value for class
    String. Use of methods from class String. Immutable String values. All the String
    methods manipulate and return a new String object. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| **[9.2]** 创建和操作字符串 | 如何使用`=`（赋值）和`new`运算符初始化String变量。使用运算符`=`, `+=`, `!=`,
    和`==`与String对象。字符串字面量的池化。String类的字面量值。使用String类的方法。不可变的String值。所有String方法都操作并返回一个新的String对象。|'
- en: '| **[3.2]** Test equality between Strings and other objects using == and equals().
    | How to determine the equality of two String objects. Differences between using
    operator == and method equals() to determine equality of String objects. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **[3.2]** 使用`==`和`equals()`测试字符串与其他对象之间的相等性。 | 如何确定两个String对象之间的相等性。使用操作符`==`和方法`equals()`确定String对象相等性的区别。|'
- en: '| **[9.1]** Manipulate data using the StringBuilder class and its methods.
    | How to create StringBuilder classes and how to use their commonly used methods.
    Difference between StringBuilder and String classes. Difference between methods
    with similar names defined in both of these classes. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| **[9.1]** 使用StringBuilder类及其方法操作数据。 | 如何创建StringBuilder类以及如何使用它们常用的方法。StringBuilder类和String类的区别。这两个类中定义的具有相似名称的方法的区别。|'
- en: '| **[4.1]** Declare, instantiate, initialize, and use a one-dimensional array.
    | How to declare, instantiate, and initialize one-dimensional arrays using single
    and multiple steps. The do’s and don’ts of each of these steps. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| **[4.1]** 声明、实例化、初始化和使用一维数组。 | 如何使用单步和多步声明、实例化和初始化一维数组，以及每个步骤的注意事项。|'
- en: '| **[4.2]** Declare, instantiate, initialize, and use a multidimensional array.
    | How to declare, instantiate, and initialize multidimensional arrays using single
    and multiple steps, with do’s and don’ts for each of these steps. Accessing elements
    in asymmetric multidimensional arrays. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| **[4.2]** 声明、实例化、初始化和使用多维数组。 | 如何使用单步和多步声明、实例化和初始化多维数组，以及每个步骤的注意事项。访问非对称多维数组中的元素。|'
- en: '| **[9.4]** Declare and use an ArrayList of a given type. | How to declare,
    create, and use an ArrayList. Advantages of using an ArrayList over arrays. Use
    of methods that add, modify, and delete elements of an ArrayList. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| **[9.4]** 声明并使用给定类型的ArrayList。 | 如何声明、创建和使用ArrayList。使用ArrayList而不是数组的优势。使用添加、修改和删除ArrayList元素的方法。|'
- en: '| **[9.3]** Create and manipulate calendar data using classes from java.time.LocalDateTime,
    java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter,
    java.time.Period. | How to store dates and times using classes LocalDate, LocalTime,
    and LocalDateTime. Identify the factory methods to instantiate date and time objects.
    Use instance methods of date and time classes. Use Period to add or subtract duration
    (days, months, or years) to and from date objects. Use DateTimeFormatter to format
    or parse date and time objects. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **[9.3]** 使用`java.time.LocalDateTime`、`java.time.LocalDate`、`java.time.LocalTime`、`java.time.format.DateTimeFormatter`、`java.time.Period`类创建和操作日历数据。
    | 如何使用LocalDate、LocalTime和LocalDateTime类存储日期和时间。识别实例化日期和时间对象的工厂方法。使用日期和时间类的实例方法。使用Period向日期对象添加或减去持续时间（天数、月份或年）。使用DateTimeFormatter格式化或解析日期和时间对象。|'
- en: In the OCA Java SE 8 Programmer I exam, you’ll be asked many questions about
    how to create, modify, and delete `String` objects, `StringBuilder` objects, arrays,
    `ArrayList` objects, and date/time objects. To prepare you for such questions,
    in this chapter I’ll provide insight into the variables you’ll use to store these
    objects’ values, along with definitions for some of their methods. This information
    should help you apply all the methods correctly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCA Java SE 8程序员I考试中，你将需要回答许多关于如何创建、修改和删除`String`对象、`StringBuilder`对象、数组、`ArrayList`对象和日期/时间对象的问题。为了准备这些问题，在本章中，我将提供有关您将使用的变量以存储这些对象值的见解，以及一些方法定义。这些信息应该有助于您正确应用所有方法。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating and manipulating `String` and `StringBuilder` objects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作`String`和`StringBuilder`对象
- en: Using common methods from classes `String` and `StringBuilder`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`String`和`StringBuilder`类中的常用方法
- en: Creating and using one-dimensional and multidimensional arrays in single and
    multiple steps
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单步和多个步骤中创建和使用一维和二维数组
- en: Accessing elements in asymmetric multidimensional arrays
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问非对称多维数组中的元素
- en: Declaring, creating, and using an `ArrayList` and understanding the advantages
    of an `ArrayList` over arrays
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明、创建和使用 `ArrayList` 以及理解 `ArrayList` 相对于数组的优势
- en: Using methods that add, modify, and delete elements of an `ArrayList`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用添加、修改和删除 `ArrayList` 元素的方法
- en: Creating date and time objects using the classes `LocalDate, LocalTime`, and
    `LocalDateTime`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LocalDate`、`LocalTime` 和 `LocalDateTime` 类创建日期和时间对象
- en: Manipulating date objects using the class `Period`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Period` 类操作日期对象
- en: Formatting and parsing date and time objects using `DateTimeFormatter`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DateTimeFormatter` 格式化和解析日期和时间对象
- en: Let’s get started with the class `String`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `String` 类开始。
- en: 4.1\. Welcome to the world of the String class
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 欢迎来到字符串类世界
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[9.2] Create and manipulate strings'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.2] 创建和操作字符串'
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[3.2](kindle_split_014.html#ch03lev1sec2)] Test equality between Strings and
    other objects using == and equals()'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3.2](kindle_split_014.html#ch03lev1sec2)] 使用 `==` 和 `equals()` 测试字符串与其他对象的相等性'
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, we’ll cover the class `String` defined in the Java API in the
    `java.lang` package. The `String` class represents character strings. We’ll create
    objects of the class `String` and work with its commonly used methods, including
    `indexOf()`, `substring()`, `replace()`, `charAt()`, and others. You’ll also learn
    how to determine the equality of two `String` objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 `java.lang` 包中定义的 `String` 类。`String` 类表示字符字符串。我们将创建 `String` 类型的对象，并使用其常用方法，包括
    `indexOf()`、`substring()`、`replace()`、`charAt()` 等。您还将学习如何确定两个 `String` 对象的相等性。
- en: The `String` class is perhaps the most-used class in the Java API. You’ll find
    instances of this class being used by every other class in the Java API. How many
    times do you think you’ve used the class `String`? Don’t answer that question—it’s
    like trying to count your hair.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类可能是 Java API 中使用最频繁的类。您会发现 Java API 中的每个其他类都使用了这个类的实例。您认为您使用了 `String`
    类多少次？不要回答这个问题——这就像试图数你的头发一样。'
- en: Although many developers find the `String` class to be one of the simplest to
    work with, this perception can be deceptive. For example, in the `String` value
    `"Shreya"`, at which index do you think `r` is stored—second or third? The correct
    answer is second because the first letter of a `String` is stored at index 0 and
    not index 1\. You’ll learn many other facts about the `String` class in this section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多开发者认为 `String` 类是其中最容易处理的之一，但这种看法可能会误导。例如，在 `String` 值 `"Shreya"` 中，您认为
    `r` 存储在哪个索引——第二个还是第三个？正确答案是第二个，因为字符串的第一个字母存储在索引 0 而不是索引 1。在本节中，您还将了解关于 `String`
    类的许多其他事实。
- en: Let’s start by creating new objects of this class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建这个类的新对象。
- en: 4.1.1\. Creating String objects
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 创建字符串对象
- en: You can create objects of the class `String` by using the `new` operator or
    by using `String` literal values (values within double quotes). You can assign
    a `String` literal value to a `String` reference variable by using the assignment
    operator (`=`). But you may have noticed a *big* difference in how these objects
    are stored and referred to by Java.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `new` 操作符或使用 `String` 文字值（双引号内的值）来创建 `String` 类型的对象。您可以使用赋值操作符（`=`）将
    `String` 文字值赋给 `String` 引用变量。但您可能已经注意到，Java 在存储和引用这些对象方面存在很大的差异。
- en: 'Let’s create two `String` objects with the value `"Paul"` using the operator
    `new`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用操作符 `new` 创建两个值为 `"Paul"` 的 `String` 对象：
- en: '![](223fig01_alt.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](223fig01_alt.jpg)'
- en: '[Figure 4.1](#ch04fig01) illustrates the previous code.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.1](#ch04fig01) 展示了之前的代码。'
- en: Figure 4.1\. `String` objects created using the operator `new` always refer
    to separate objects, even if they store the same sequence of characters.
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 使用操作符 `new` 创建的 `String` 对象始终引用单独的对象，即使它们存储相同的字符序列。
- en: '![](04fig01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01.jpg)'
- en: In the previous code, a comparison of the `String` reference variables `str1`
    and `str2` prints `false`. The operator `==` compares the addresses of the objects
    referred to by the variables `str1` and `str2`. Even though these `String` objects
    store the same sequence of characters, they refer to separate objects stored at
    separate locations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，比较 `String` 引用变量 `str1` 和 `str2` 输出 `false`。操作符 `==` 比较由变量 `str1` 和
    `str2` 指向的对象的地址。尽管这些 `String` 对象存储相同的字符序列，但它们引用的是存储在不同位置上的单独对象。
- en: Let’s initialize two `String` variables with the value `"Harry"` using the assignment
    operator (`=`). [Figure 4.2](#ch04fig02) illustrates the variables `str3` and
    `str4` and the objects referred to by these variables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用赋值运算符（`=`）初始化两个 `String` 变量，值为 `"Harry"`。[图 4.2](#ch04fig02) 展示了变量 `str3`
    和 `str4` 以及这些变量所引用的对象。
- en: Figure 4.2\. `String` objects created using the assignment operator (=) may
    refer to the same object if they store the same sequence of characters.
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 使用赋值运算符（=）创建的 `String` 对象可能指向同一个对象，如果它们存储相同的字符序列。
- en: '![](04fig02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig02.jpg)'
- en: '![](224fig01_alt.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](224fig01_alt.jpg)'
- en: 'In the preceding example, the variables `str1` and `str2` referred to different
    `String` objects, even if they were created using the same sequence of characters.
    In the case of variables `str3` and `str4`, the objects are created and stored
    in a *pool* of `String` objects. Before creating a new object in the pool, Java
    searches for an object with similar contents. When the following line of code
    executes, no `String` object with the value `"Harry"` is found in the pool of
    `String` objects:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，即使使用相同的字符序列创建，变量 `str1` 和 `str2` 也指向不同的 `String` 对象。在变量 `str3` 和 `str4`
    的情况下，对象是在 `String` 对象池中创建和存储的。在池中创建新对象之前，Java 会搜索具有相似内容的对象。当执行以下代码行时，在 `String`
    对象池中没有找到具有值 `"Harry"` 的 `String` 对象：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a result, Java creates a `String` object with the value `"Harry"` in the
    pool of `String` objects referred to by the variable `str3`. This action is depicted
    in [figure 4.3](#ch04fig03).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java 在变量 `str3` 指向的 `String` 对象池中创建了一个具有值 `"Harry"` 的 `String` 对象。这一动作如图
    4.3 所示。
- en: Figure 4.3\. The sequence of steps that executes when Java is unable to locate
    a `String` in a pool of `String` objects
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 当 Java 无法在 `String` 对象池中找到 `String` 时执行的步骤序列
- en: '![](04fig03_alt.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig03_alt.jpg)'
- en: 'When the following line of code executes, Java is able to find a `String` object
    with the value `"Harry"` in the pool of `String` objects:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行以下代码行时，Java 能够在 `String` 对象池中找到具有值 `"Harry"` 的 `String` 对象：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Java doesn’t create a new `String` object in this case, and the variable `str4`
    refers to the existing `String` object `"Harry"`. As shown in [figure 4.4](#ch04fig04),
    both variables `str3` and `str4` refer to the same `String` object in the pool
    of `String` objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Java 不会创建一个新的 `String` 对象，变量 `str4` 指向现有的 `String` 对象 `"Harry"`。如图 4.4
    所示，变量 `str3` 和 `str4` 都指向对象池中的同一个 `String` 对象。
- en: Figure 4.4\. The sequence of actions that executes when Java locates a *`String`*
    in the pool of *`String`* objects
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 当 Java 在 *`String`* 对象池中找到 *`String`* 时执行的动作序列
- en: '![](04fig04_alt.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig04_alt.jpg)'
- en: 'You can also create a `String` object by enclosing a value within double quotes
    (`"`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在双引号（`"`）内包围一个值来创建 `String` 对象：
- en: '![](225fig01_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](225fig01_alt.jpg)'
- en: 'These values are reused from the `String` constant pool if a matching value
    is found. If a matching value isn’t found, the JVM creates a `String` object with
    the specified value and places it in the `String` constant pool:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到匹配的值，这些值将从 `String` 常量池中重用。如果没有找到匹配的值，JVM 将创建一个具有指定值的 `String` 对象并将其放置在
    `String` 常量池中：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compare the preceding example with the following example, which creates a `String`
    object using the operator `new` and (only) double quotes and then compares their
    references:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的例子与以下例子进行比较，该例子使用 `new` 运算符和（仅）双引号创建 `String` 对象，然后比较它们的引用：
- en: '![](225fig02_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](225fig02_alt.jpg)'
- en: The preceding code shows that object references of `String` objects that exist
    in the `String` constant pool and object references of `String` objects that don’t
    exist in the `String` constant pool don’t refer to the same `String` object, even
    if they define the same `String` value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表明，存在于 `String` 常量池中的 `String` 对象的引用和不存在于 `String` 常量池中的 `String` 对象的引用不指向同一个
    `String` 对象，即使它们定义了相同的 `String` 值。
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The terms *`String` constant pool* and *`String` pool* are used interchangeably
    and refer to the same pool of `String` objects. Because `String` objects are immutable,
    the pool of `String` objects is also called the *`String` constant pool*. You
    may see either of these terms on the exam.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *`String` 常量池* 和 *`String` 池* 可以互换使用，并指代同一个 `String` 对象池。因为 `String` 对象是不可变的，所以
    `String` 对象池也被称为 *`String` 常量池*。您可能在考试中看到这两个术语中的任何一个。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can also invoke other overloaded constructors of the class `String` to
    create its objects by using the operator `new`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以调用 `String` 类的其他重载构造函数，通过使用 `new` 运算符来创建其对象：
- en: '![](226fig01_alt.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](226fig01_alt.jpg)'
- en: 'You can also create objects of `String` using the classes `StringBuilder` and
    `StringBuffer`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `StringBuilder` 和 `StringBuffer` 类来创建 `String` 对象：
- en: '![](226fig02_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](226fig02_alt.jpg)'
- en: 'Because `String` is a class, you can assign `null` to it, as shown in the next
    example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `String` 是一个类，你可以将它赋值为 `null`，如下例所示：
- en: '![](226fig03_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](226fig03_alt.jpg)'
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The default value for `String` is `null`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 的默认值是 `null`。'
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Counting String objects
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算 `String` 对象
- en: 'To test your understanding of the various ways in which a `String` object can
    be created, the exam may question you on the total number of `String` objects
    created in a given piece of code. Count the total number of `String` objects created
    in the following code, assuming that the `String` constant pool doesn’t define
    any matching `String` values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你对创建 `String` 对象的各种方式的了解，考试可能会询问你在一块给定的代码中创建了多少个 `String` 对象。计算以下代码中创建的
    `String` 对象的总数，假设 `String` 常量池没有定义任何匹配的 `String` 值：
- en: '![](226fig04_alt.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](226fig04_alt.jpg)'
- en: 'I’ll walk through the code with you step by step to calculate the total number
    of `String` objects created:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我会一步一步地带你分析代码，计算创建的 `String` 对象的总数：
- en: The code at ![](num-1.jpg) creates a new `String` object with the value `"Summer"`.
    This object is not placed in the `String` constant pool.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](num-1.jpg) 的代码中创建了一个值为 `"Summer"` 的新 `String` 对象。此对象没有被放入 `String` 常量池中。
- en: The code at ![](num-2.jpg) creates a new `String` object with the value `"Summer"`
    and places it in the `String` constant pool.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](num-2.jpg) 的代码中创建了一个值为 `"Summer"` 的新 `String` 对象并将其放入 `String` 常量池中。
- en: The code at ![](num-3.jpg) doesn’t need to create any new `String` object. It
    reuses the `String` object with the value `"Summer"` that already existed in the
    `String` constant pool.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](num-3.jpg) 的代码中不需要创建任何新的 `String` 对象。它重用了 `String` 常量池中已经存在的值为 `"Summer"`
    的 `String` 对象。
- en: The code at ![](num-4.jpg) creates a new `String` object with the value `"autumn"`
    and places it in the `String` constant pool.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](num-4.jpg) 的代码中创建了一个值为 `"autumn"` 的新 `String` 对象并将其放入 `String` 常量池中。
- en: The code at ![](num-5.jpg) reuses the `String` value `"autumn"` from the `String`
    constant pool. It creates a `String` object with the value `"summer"` in the `String`
    constant pool (note the difference in the case of letters—Java is case-sensitive
    and `"Summer"` is not the same as `"summer"`).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](num-5.jpg) 的代码中，重用了 `String` 常量池中的 `"autumn"` 值。它在 `String` 常量池中创建了一个值为
    `"summer"` 的 `String` 对象（注意字母的大小写差异——Java 是大小写敏感的，`"Summer"` 和 `"summer"` 不相同）。
- en: The code at ![](num-6.jpg) creates a new `String` object with the value `"Summer"`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ![](num-6.jpg) 的代码中创建了一个值为 `"Summer"` 的新 `String` 对象。
- en: The previous code creates a total of five `String` objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码总共创建了五个 `String` 对象。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: If a `String` object is created using the keyword `new`, it always results in
    the creation of a new `String` object. `String` objects created this way are never
    pooled. When a variable is assigned a `String` literal using the assignment operator,
    a new `String` object is created only if a `String` object with the same value
    isn’t found in the `String` constant pool.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用关键字 `new` 创建 `String` 对象，它总是导致创建一个新的 `String` 对象。以这种方式创建的 `String` 对象永远不会被池化。当使用赋值运算符将
    `String` 文字赋给变量时，只有当 `String` 常量池中没有找到具有相同值的 `String` 对象时，才会创建一个新的 `String` 对象。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.1.2\. The class String is immutable
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. `String` 类是不可变的
- en: The concept that the class `String` is immutable is an important point to remember.
    Once created, the contents of an object of the class `String` can never be modified.
    The immutability of `String` objects helps the JVM reuse `String` objects, reducing
    memory overhead and increasing performance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `String` 类不可变的概念是一个重要的要点。一旦创建，`String` 类对象的内部内容就永远不能被修改。`String` 对象的不可变性有助于
    JVM 重复使用 `String` 对象，减少内存开销并提高性能。
- en: As shown previously in [figure 4.4](#ch04fig04), the JVM creates a pool of `String`
    objects that can be referenced by multiple variables across the JVM. The JVM can
    make this optimization only because `String` is immutable. `String` objects can
    be shared across multiple reference variables without any fear of changes in their
    values. If the reference variables `str1` and `str2` refer to the same `String`
    object value `"Java"`, `str1` need not worry for its lifetime that the value `"Java"`
    might be changed through the variable `str2`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，[图 4.4](#ch04fig04) 所示，JVM 创建了一个 `String` 对象池，这些对象可以在 JVM 中被多个变量引用。JVM
    只能进行这种优化，因为 `String` 是不可变的。`String` 对象可以在多个引用变量之间共享，而不用担心它们值的变化。如果引用变量 `str1`
    和 `str2` 指向同一个 `String` 对象值 `"Java"`，则 `str1` 不必担心在其生命周期内，值 `"Java"` 可能会通过变量 `str2`
    被更改。
- en: 'Let’s take a quick look at how the immutability of the class `String` is implemented
    by the authors of this class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下这个类的作者是如何实现 `String` 类不可变性的：
- en: The class `String` stores its values in a `private` variable of the type `char`
    array (`char value[]`). Arrays are fixed in size and don’t grow once initialized.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 `String` 将其值存储在一个 `private` 类型的字符数组变量中（`char value[]`）。数组的大小固定，一旦初始化就不会增长。
- en: This `value` variable is marked as `final` in the class `String`. Note that
    `final` is a nonaccess modifier, and a `final` variable can be initialized only
    once.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 `value` 变量在 `String` 类中被标记为 `final`。请注意，`final` 是一个非访问修饰符，`final` 变量只能初始化一次。
- en: None of the methods defined in the class `String` manipulate the individual
    elements of the array `value`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 `String` 中定义的任何方法都不会操作数组 `value` 的单个元素。
- en: I’ll discuss each of these points in detail in the following sections.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的章节中详细讨论这些点。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Code from Java API classes**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java API 类的代码**'
- en: To give you a better understanding of how the classes `String`, `StringBuilder`,
    and `ArrayList` work, I’ll explain the variables used to store these objects’
    values, along with definitions for some of their methods. My purpose is not to
    overwhelm you but to prepare you. The exam won’t question you on this subject,
    but these details will help you retain relevant information for the exam and implement
    similar requirements in code for practical projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更好地理解 `String`、`StringBuilder` 和 `ArrayList` 类的工作方式，我将解释用于存储这些对象值的变量，以及它们的一些方法定义。我的目的不是让您感到不知所措，而是为了做好准备。考试不会就这个主题提问您，但这些细节将帮助您保留与考试相关的信息，并在实际项目中实现类似的要求。
- en: The source code of the classes defined in the Java API is shipped with the Java
    Development Kit (JDK). You can access it by unzipping the src.zip archive from
    your JDK’s installation folder.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java API 中定义的类的源代码包含在 Java 开发工具包（JDK）中。您可以通过解压缩 JDK 安装文件夹中的 src.zip 存档来访问它。
- en: The rest of this section discusses how the authors of the Java API have implemented
    immutability in the class `String`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分将讨论 Java API 的作者如何在 `String` 类中实现不可变性。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: String uses a char array to store its value
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: String 使用字符数组来存储其值
- en: 'Here’s a partial definition of the class `String` from the Java source code
    file (String.java) that includes the array used to store the characters of a `String`
    value (the relevant code is in bold):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Java 源代码文件（String.java）中 `String` 类的部分定义，包括用于存储 `String` 值字符的数组（相关代码用粗体表示）：
- en: '![](228fig01_alt.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](228fig01_alt.jpg)'
- en: The arrays are fixed in size—they can’t grow once they’re initialized.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小是固定的——一旦初始化就不能增长。
- en: 'Let’s create a variable `name` of type `String` and see how it’s stored internally:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类型为 `String` 的变量 `name` 并看看它是如何内部存储的：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 4.5](#ch04fig05) shows a UML representation (class diagram on the left
    and object diagram on the right) of the class `String` and its object `name`,
    with only one relevant variable, `value`, which is an array of the type `char`
    and is used to store the sequence of characters assigned to a `String`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.5](#ch04fig05) 展示了类 `String` 及其对象 `name` 的 UML 表示（左边的类图和右边的对象图），其中只有一个相关变量，`value`，它是一个
    `char` 类型的数组，用于存储分配给 `String` 的字符序列。'
- en: Figure 4.5\. UML representations of the class `String` and a `String` object
    with `String`’s instance attribute `value`
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5\. `String` 类和具有 `String` 实例属性 `value` 的 `String` 对象的 UML 表示
- en: '![](04fig05.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig05.jpg)'
- en: As you can see in [figure 4.5](#ch04fig05), the `String` value `Selvan` is stored
    in an array of type `char`. In this chapter, I’ll cover arrays in detail, as well
    as how an array stores its first value at position 0.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图4.5](#ch04fig05)所示，`String`值`Selvan`存储在一个类型为`char`的数组中。在本章中，我将详细介绍数组以及数组如何将其第一个值存储在位置0。
- en: '[Figure 4.6](#ch04fig06) shows how `Selvan` is stored as a `char` array.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.6](#ch04fig06) 展示了`Selvan`如何存储为一个`char`数组。'
- en: Figure 4.6\. Mapping characters stored by a `String` with the positions at which
    they’re stored
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6. `String`存储的字符与它们存储的位置的映射
- en: '![](04fig06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig06.jpg)'
- en: What do you think you’ll get when you request that this `String` return the
    character at position 4? If you said `a` and not `v`, you got the right answer
    (as in [figure 4.6](#ch04fig06)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您请求这个`String`返回位置4的字符时，你认为你会得到什么？如果你说是`a`而不是`v`，你就得到了正确答案（如[图4.6](#ch04fig06)所示）。
- en: String uses final variable to store its value
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: String使用final变量来存储其值
- en: 'The variable `value`, which is used to store the value of a `String` object,
    is marked as `final`. Review the following code snippet from the class `String.java`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储`String`对象值的变量`value`被标记为`final`。请回顾一下来自`String.java`类的以下代码片段：
- en: '![](229fig01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](229fig01.jpg)'
- en: The basic characteristic of a `final` variable is that it can initialize a value
    only once. By marking the variable `value` as `final`, the class `String` makes
    sure that it can’t be reassigned a value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`变量的基本特征是它只能初始化一次值。通过将变量`value`标记为`final`，`String`类确保它不能被重新赋值。'
- en: Methods of String don’t modify the char array
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`String`类的方法不会修改字符数组'
- en: Although we can’t reassign a value to a `final char` array (as mentioned in
    the previous section), we can reassign its individual characters. Wow—does this
    mean that the statement “`Strings` are immutable” isn’t completely true?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们无法像前一个章节中提到的将值重新赋给`final char`数组，但我们可以重新赋值其单个字符。哇——这难道意味着“字符串是不可变的”这个说法并不完全正确吗？
- en: No, that statement is still true. The `char` array used by the class `String`
    is marked `private`, which means that it isn’t accessible outside the class for
    modification. The class `String` itself doesn’t modify the value of this variable
    either.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这个说法仍然是正确的。`String`类使用的`char`数组被标记为`private`，这意味着它不能被类外修改。`String`类本身也不会修改这个变量的值。
- en: All the methods defined in the class `String`, such as `substring`, `concat`,
    `toLower-Case`, `toUpperCase`, `trim`, and so on, which *seem* to modify the contents
    of the `String` object on which they’re called, create and return a new `String`
    object rather than modify the existing value. [Figure 4.7](#ch04fig07) illustrates
    the partial definition of `String`’s `replace` method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`String`类中定义的所有方法，如`substring`、`concat`、`toLower-Case`、`toUpperCase`、`trim`等，*看似*会修改它们被调用的`String`对象的内容，实际上创建并返回一个新的`String`对象，而不是修改现有值。[图4.7](#ch04fig07)说明了`String`的`replace`方法的局部定义。
- en: Figure 4.7\. The partial definition of the method `replace` from the class `String`
    shows that this method creates and returns a new `String` object rather than modifies
    the value of the `String` object on which it’s called.
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.7. `String`类中`replace`方法的局部定义显示了该方法创建并返回一个新的`String`对象，而不是修改它所调用的`String`对象的值。
- en: '![](04fig07_alt.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig07_alt.jpg)'
- en: I reiterate that the previous code from the class `String` will help you relate
    the theory to the code and understand how and why a particular concept works.
    If you understand a particular concept well in terms of how and why it works,
    you’ll be able to retain that information longer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次强调，来自`String`类的先前代码将帮助您将理论与代码联系起来，并理解特定概念是如何以及为什么工作的。如果您对某个概念在如何以及为什么工作方面理解得很好，您将能够更长时间地保留这些信息。
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Strings are immutable. Once initialized, a `String` value can’t be modified.
    All the `String` methods that return a modified `String` value return a new `String`
    object with the modified value. The original `String` value always remains the
    same.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的。一旦初始化，`String`值就不能修改。所有返回修改后的`String`值的`String`方法都返回一个新的带有修改值的`String`对象。原始的`String`值始终保持不变。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.1.3\. Methods of the class String
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3. `String`类的方法
- en: '[Figure 4.8](#ch04fig08) categorizes the methods that are on the exam into
    groups: ones that query the positions of characters, ones that seem to modify
    `String`, and others.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.8](#ch04fig08) 将考试中的方法分为几类：查询字符位置的方法、似乎修改`String`的方法以及其他方法。'
- en: Figure 4.8\. Categorization of the `String` methods
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.8. `String`方法的分类
- en: '![](04fig08_alt.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig08_alt.jpg)'
- en: Categorizing the methods in this way will help you better understand these methods.
    For example, the methods `charAt()`, `indexOf()`, and `substring()` query the
    position of individual characters in a `String`. The methods `substring()`, `trim()`,
    and `replace()` seem to be modifying the value of a `String`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式对方法进行分类将有助于您更好地理解这些方法。例如，`charAt()`、`indexOf()` 和 `substring()` 方法查询 `String`
    中单个字符的位置。`substring()`、`trim()` 和 `replace()` 方法似乎在修改 `String` 的值。
- en: charAt()
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: charAt()
- en: 'You can use the method `charAt(int index)` to retrieve a character at a specified
    index of a `String`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `charAt(int index)` 方法来检索 `String` 中指定索引处的字符：
- en: '![](230fig01_alt.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](230fig01_alt.jpg)'
- en: '[Figure 4.9](#ch04fig09) illustrates the previous string, `Paul`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.9](#ch04fig09) 展示了前面的字符串，`Paul`。'
- en: Figure 4.9\. The sequence of characters of `"Paul"` stored by `String` and the
    corresponding array index positions
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9。`String` 中存储的 `"Paul"` 字符序列及其对应的数组索引位置
- en: '![](04fig09.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig09.jpg)'
- en: 'Because the last character is placed at index 3, the following code will throw
    an exception at runtime:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后一个字符放置在索引 3 处，以下代码将在运行时抛出异常：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As a quick introduction, a *runtime exception* is a programming error determined
    by the Java Runtime Environment (JRE) during the execution of code. These errors
    occur because of the inappropriate use of another piece of code (exceptions are
    covered in detail in [chapter 7](kindle_split_021.html#ch07)). The previous code
    tries to access a nonexistent index position, so it causes an exception.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速介绍，*运行时异常* 是在代码执行过程中由 Java 运行时环境 (JRE) 确定的编程错误。这些错误是由于不恰当地使用其他代码片段（异常将在第
    7 章中详细讨论）而发生的。前面的代码尝试访问一个不存在的索引位置，因此引发了异常。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: indexOf()
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: indexOf()
- en: 'You can search a `String` for the occurrence of a `char` or a `String`. If
    the specified `char` or `String` is found in the target `String`, this method
    returns the first matching position; otherwise, it returns `-1`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `String` 中搜索 `char` 或 `String` 的出现。如果指定的 `char` 或 `String` 在目标 `String`
    中找到，则此方法返回第一个匹配的位置；否则，返回 `-1`：
- en: '![](231fig01_alt.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](231fig01_alt.jpg)'
- en: '[Figure 4.10](#ch04fig10) illustrates the previous string `ABCAB`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.10](#ch04fig10) 展示了前面的字符串 `ABCAB`。'
- en: Figure 4.10\. The characters `"ABCAB"` stored by `String`
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10。存储在 `String` 中的 `"ABCAB"` 字符
- en: '![](04fig10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig10.jpg)'
- en: 'By default, the `indexOf()` method starts its search from the first `char`
    of the target `String`. If you wish, you can also set the starting position, as
    in the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`indexOf()` 方法从目标 `String` 的第一个 `char` 开始搜索。如果您愿意，也可以设置起始位置，如下例所示：
- en: '![](231fig02_alt.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](231fig02_alt.jpg)'
- en: substring()
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: substring()
- en: 'The `substring()` method is shipped in two flavors. The first returns a substring
    of a `String` from the position you specify to the end of the `String`, as in
    the following example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring()` 方法有两种形式。第一种返回从您指定的位置到 `String` 结尾的子字符串，如下例所示：'
- en: '![](231fig03_alt.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](231fig03_alt.jpg)'
- en: '[Figure 4.11](#ch04fig11) illustrates the previous example.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.11](#ch04fig11) 展示了前面的示例。'
- en: Figure 4.11\. The `String "Oracle"`
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.11。`String "Oracle"`
- en: '![](04fig11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig11.jpg)'
- en: 'You can also specify the end position with this method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用此方法指定结束位置：
- en: '![](232fig01_alt.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](232fig01_alt.jpg)'
- en: '[Figure 4.12](#ch04fig12) illustrates the `String` value `"Oracle"`, including
    both a start point and an end point for the method `substring`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.12](#ch04fig12) 展示了 `String` 值 `"Oracle"`，包括 `substring` 方法的起始点和结束点。'
- en: Figure 4.12\. How the method `substring` looks for the specified characters
    from the start until the end position
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.12。`substring` 方法如何从起始位置查找直到结束位置的指定字符
- en: '![](04fig12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig12.jpg)'
- en: 'An interesting point is that the `substring` method doesn’t include the character
    at the end position. In the previous example, `result` is assigned the value `ac`
    (characters at positions 2 and 3), not the value `acl` (characters at positions
    2, 3, and 4). Here’s a simple way to remember this rule:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观点是，`substring` 方法不包含结束位置处的字符。在上面的示例中，`result` 被分配了 `ac` 的值（位置 2 和 3 的字符），而不是
    `acl`（位置 2、3 和 4 的字符）。这里有一个简单的方法来记住这个规则：
- en: Length of `String` returned by substring() = end - start
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring()` 方法返回的 `String` 长度 = 结束索引 - 开始索引'
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: The `substring` method doesn’t include the character at the end position in
    its return value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring` 方法不包含结束位置处的字符在其返回值中。'
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: trim()
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: trim()
- en: The `trim()` method returns a new `String` by removing all the leading and trailing
    *white space* in a `String`. White spaces are blanks (new lines, spaces, or tabs).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim()`方法通过移除`String`中所有前导和尾随的空白来返回一个新的`String`。空白是空白字符（换行符、空格或制表符）。'
- en: Let’s define and print a `String` with leading and trailing white space. (The
    colons printed before and after the `String` determine the start and end of the
    `String`.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义并打印一个带有前导和尾随空白的`String`。 (在`String`前后打印的冒号确定了`String`的开始和结束。)
- en: '![](232fig02_alt.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](232fig02_alt.jpg)'
- en: 'Here’s another example that trims the leading and trailing white space:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个示例，展示了如何去除前导和尾随空白：
- en: '![](232fig03_alt.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](232fig03_alt.jpg)'
- en: Note that this method doesn’t remove the space *within* a `String`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法不会移除`String`内部的空格。
- en: replace()
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: replace()
- en: 'This method will return a new `String` by replacing all the occurrences of
    a `char` with another `char`. Instead of specifying a `char` to be replaced by
    another `char`, you can also specify a sequence of characters—a `String` to be
    replaced by another `String`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将通过用另一个`char`替换所有出现的`char`来返回一个新的`String`。除了指定要替换的`char`外，你还可以指定一个字符序列——一个要替换的`String`：
- en: '![](233fig01_alt.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig01_alt.jpg)'
- en: 'Notice the type of the method parameters passed on this method: either `char`
    or `String`. You can’t mix these parameter types, as the following code shows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在此方法中传递的方法参数的类型：要么是`char`，要么是`String`。你不能混合这些参数类型，如下面的代码所示：
- en: '![](233fig02_alt.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig02_alt.jpg)'
- en: 'Again, notice that this method doesn’t—or can’t—change the value of the variable
    `letters`. Examine the following line of code and its output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，此方法不会——或者不能——更改变量`letters`的值。检查以下代码行及其输出：
- en: '![](233fig03_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig03_alt.jpg)'
- en: length()
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: length()
- en: 'You can use the `length()` method to retrieve the length of a `String`. Here’s
    an example showing its use:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`length()`方法来检索`String`的长度。以下是一个展示其使用方法的示例：
- en: '![](233fig04_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig04_alt.jpg)'
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The length of a `String` is one number greater than the position that stores
    its last character. The length of `String "Shreya"` is 6, but its last character,
    `a`, is stored at position 5 because the positions start at 0, not 1.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`的长度比存储其最后一个字符的位置多一个数字。`String "Shreya"`的长度是6，但它的最后一个字符`a`存储在位置5，因为位置从0开始，而不是1。'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: startsWith() and endsWith()
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: startsWith() 和 endsWith()
- en: 'The method `startsWith()` determines whether a `String` starts with a specified
    prefix, specified as a `String`. You can also specify whether you wish to search
    from the start of a `String` or from a particular position. This method returns
    `true` if a match is found and `false` otherwise:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`startsWith()`确定一个`String`是否以指定的前缀开始，该前缀指定为`String`。你也可以指定是否要从`String`的开始位置或从特定位置开始搜索。如果找到匹配项，则此方法返回`true`，否则返回`false`：
- en: '![](233fig05_alt.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig05_alt.jpg)'
- en: 'The method `endsWith()` tests whether a `String` ends with a particular suffix.
    It returns `true` for a matching value and `false` otherwise:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`endsWith()`测试一个`String`是否以特定的后缀结束。如果匹配则返回`true`，否则返回`false`：
- en: '![](234fig01_alt.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](234fig01_alt.jpg)'
- en: Method chaining
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法链式调用
- en: 'It’s common practice to use multiple `String` methods in a single line of code,
    as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行代码中使用多个`String`方法是一种常见的做法，如下所示：
- en: '![](234fig02_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](234fig02_alt.jpg)'
- en: The methods are evaluated from left to right. The first method to execute in
    this example is `replace`, not `concat`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是从左到右评估的。在这个例子中，首先执行的方法是`replace`，而不是`concat`。
- en: Method chaining is one of the favorite topics of the exam authors. You’re sure
    to encounter a question on method chaining in the OCA Java SE 8 Programmer I exam.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链式调用是考试作者最喜欢的主题之一。你肯定会在OCA Java SE 8程序员I考试中遇到关于方法链式调用的一个问题。
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When chained, the methods are evaluated from left to right.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当链式调用时，方法是从左到右评估的。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Note that there’s a difference between calling a chain of methods on a `String`
    object versus doing the same and then reassigning the return value to the same
    variable:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`String`对象上调用方法链与将相同的操作应用于然后重新分配返回值到同一变量之间有一个区别：
- en: '![](234fig03_alt.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](234fig03_alt.jpg)'
- en: Because `String` objects are immutable, their values won’t change if you execute
    methods on them. You can, of course, reassign a value to a reference variable
    of type `String`. Watch out for related questions in the exam.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`String`对象是不可变的，因此如果你在它们上执行方法，它们的值不会改变。当然，你可以将值重新分配给类型为`String`的引用变量。注意考试中的相关问题。
- en: Although the next Twist in the Tale exercise may seem simple, with only two
    lines of code, appearances can be deceptive (answers in the appendix).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然下一个故事转折练习可能看起来很简单，只有两行代码，但外表可能具有欺骗性（答案见附录）。
- en: Twist in the Tale 4.1
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 4.1
- en: Let’s modify some of the code used in the previous section. Execute this code
    on your system. Which answer correctly shows its output?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一节中使用的一些代码。在您的系统上执行此代码。哪个答案正确显示了其输出？
- en: '[PRE5]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`true`'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`true`'
- en: '`false`'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`AB`'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AB`'
- en: '`ABC`'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ABC`'
- en: Compilation error
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: 4.1.4\. String objects and operators
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4\. 字符串对象和运算符
- en: 'Of all the operators that are on this exam, you can use just a handful with
    the `String` objects:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个考试的所有运算符中，您只能使用少数几个与`String`对象一起使用：
- en: 'Concatenation: `+` and `+=`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接：`+`和`+=`
- en: 'Equality: `==` and `!=`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于：`==`和`!=`
- en: In this section, we’ll cover the concatenation operators. We’ll cover the equality
    operators in the next section (4.1.5).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍连接运算符。我们将在下一节（4.1.5）介绍相等运算符。
- en: Concatenation operators (`+` and `+=`) have a special meaning for `String`s.
    The Java language has additional functionality defined for these operators for
    `String`. You can use the operators `+` and `+=` to concatenate two `String` values.
    Behind the scenes, string concatenation is implemented by using the `StringBuilder`
    (covered in the next section) or `StringBuffer` (similar to `StringBuilder`) classes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 连接运算符（`+`和`+=`）对`String`有特殊含义。Java语言为这些运算符定义了针对`String`的附加功能。您可以使用运算符`+`和`+=`来连接两个`String`值。在幕后，字符串连接是通过使用`StringBuilder`（下一节介绍）或`StringBuffer`（类似于`StringBuilder`）类来实现的。
- en: 'But remember that a `String` is immutable. You can’t modify the value of any
    existing object of `String`. The `+` operator enables you to create a new object
    of the class `String` with a value equal to the concatenated values of multiple
    `Strings`. Examine the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，`String`是不可变的。您不能修改任何现有`String`对象的价值。`+`运算符使您能够创建一个新的`String`类对象，其值等于多个`String`连接的值。检查以下代码：
- en: '![](235fig01_alt.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](235fig01_alt.jpg)'
- en: 'Here’s another example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：
- en: '![](235fig02_alt.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](235fig02_alt.jpg)'
- en: 'Why do you think the value of the variable `anotherStr` is `22OCJA` and not
    `1012OCJA`? The `+` operator can be used with the primitive values, and the expression
    `num + val + aStr` is evaluated from left to right. Here’s the sequence of steps
    executed by Java to evaluate the expression:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为变量`anotherStr`的值为什么是`22OCJA`而不是`1012OCJA`？`+`运算符可以与原始值一起使用，并且表达式`num + val
    + aStr`是从左到右评估的。以下是Java评估该表达式的步骤序列：
- en: Add operands `num` and `val` to get `22`.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作数`num`和`val`相加得到`22`。
- en: Concatenate `22` with `OCJA` to get `22OCJA`.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`22`与`OCJA`连接以得到`22OCJA`。
- en: 'If you wish to treat the numbers stored in variables `num` and `val` as `String`
    values, modify the expression as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将存储在变量`num`和`val`中的数字视为`String`值，请按以下方式修改表达式：
- en: '![](235fig03_alt.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](235fig03_alt.jpg)'
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A practical tip on String concatenation**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串连接的实用技巧**'
- en: During my preparation for my Java Programmer certification, I learned how the
    output changes in String concatenation when the order of values being concatenated
    is changed. At work, it helped me to quickly debug a Java application that was
    logging incorrect values to a log file. It didn’t take me long to discover that
    the offending line of code was `logToFile("Shipped:" + numReceived() + inTransit());`.
    The methods were returning correct values individually, but the return values
    of these methods were not being added. They were being *concatenated* as `String`
    values, resulting in the unexpected output.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我为Java程序员认证做准备的过程中，我学习了在字符串连接中，当连接的值的顺序改变时，输出如何变化。在工作中，这帮助我快速调试了一个将错误值记录到日志文件中的Java应用程序。我没有花很长时间就发现，有问题的代码行是`logToFile("Shipped:"
    + numReceived() + inTransit());`。这些方法单独返回正确的值，但这些方法的返回值没有被相加。它们被作为`String`值*连接*，导致出现意外的输出。
- en: One solution is to enclose the `int` addition within parentheses, as in `logToFile("Shipped:"+
    (numReceived() + inTransit()));`. This code will log the text `"Shipped"` with
    the sum of the numeric values returned by the methods `num-Received()` and `inTransit()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是将`int`加法放在括号内，例如`logToFile("Shipped:"+ (numReceived() + inTransit()));`。此代码将记录文本`"Shipped"`与`num-Received()`和`inTransit()`方法返回的数值总和。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When you use `+=` to concatenate `String` values, ensure that the variable
    you’re using has been initialized (and doesn’t contain `null`). Look at the following
    code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `+=` 连接 `String` 值时，请确保您使用的变量已经初始化（并且不包含 `null`）。看看以下代码：
- en: '![](236fig01_alt.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![236fig01_alt.jpg](236fig01_alt.jpg)'
- en: 4.1.5\. Determining equality of Strings
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.5\. 确定 `String` 的相等性
- en: The correct way to compare two `String` values for equality is to use the `equals`
    method defined in the `String` class. This method returns a `true` value if the
    object being compared to it isn’t `null`, is a `String` object, and represents
    the same sequence of characters as the object to which it’s being compared.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个 `String` 值的正确方法是使用 `String` 类中定义的 `equals` 方法。如果与之比较的对象不是 `null`，是一个 `String`
    对象，并且表示与它比较的对象相同的字符序列，则此方法返回 `true` 值。
- en: equals method
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`equals` 方法'
- en: The following listing shows the method definitions of the `equals` method defined
    in class `String` in the Java API.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了 Java API 中类 `String` 中定义的 `equals` 方法的定义方法。
- en: Listing 4.1\. Method definition of the `equals` method from the class `String`
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 类 `String` 中 `equals` 方法的定义
- en: '![](236fig02_alt.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![236fig02_alt.jpg](236fig02_alt.jpg)'
- en: 'In [listing 4.1](#ch04lis01), the `equals` method accepts a method parameter
    of type `Object` and returns a `boolean` value. Let’s walk through the `equals`
    method defined by the class `String`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.1](#ch04lis01) 中，`equals` 方法接受一个类型为 `Object` 的方法参数，并返回一个 `boolean` 值。让我们回顾一下由类
    `String` 定义的 `equals` 方法：
- en: '![](num-1.jpg) compares the object reference variables. If the reference variables
    are the same, they refer to the same object.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![num-1.jpg](num-1.jpg) 比较对象引用变量。如果引用变量相同，它们引用同一个对象。'
- en: '![](num-2.jpg) compares the type of the method parameter to this object. If
    the method parameter passed to this method is not of type `String`, ![](num-6.jpg)
    returns `false`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![num-2.jpg](num-2.jpg) 比较方法参数的类型与该对象。如果传递给此方法的方法参数不是 `String` 类型，![num-6.jpg](num-6.jpg)
    返回 `false`。'
- en: '![](num-3.jpg) checks whether the lengths of the `String` values being compared
    are equal.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![num-3.jpg](num-3.jpg) 检查正在比较的 `String` 值的长度是否相等。'
- en: '![](num-4.jpg) compares the individual characters of the `String` values. It
    returns `false` if a mismatch is found at any position. If no mismatch is found,
    ![](num-5.jpg) returns `true`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![num-4.jpg](num-4.jpg) 比较了 `String` 值的各个字符。如果在任何位置找到不匹配，则返回 `false`。如果没有找到不匹配，![num-5.jpg](num-5.jpg)
    返回 `true`。'
- en: Comparing reference variables to instance values
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较引用变量与实例值
- en: 'Examine the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下代码：
- en: '![](237fig01_alt.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![237fig01_alt.jpg](237fig01_alt.jpg)'
- en: 'The operator `==` compares the reference variables, that is, whether the variables
    refer to the same object. Hence, `var1 == var2` in the previous code prints `false`.
    Now examine the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `==` 比较引用变量，即变量是否引用同一个对象。因此，在之前的代码中 `var1 == var2` 打印 `false`。现在检查以下代码：
- en: '![](237fig02_alt.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![237fig02_alt.jpg](237fig02_alt.jpg)'
- en: Even though comparing `var3` and `var4` using the operator `==` prints `true`,
    you should *never* use this operator for comparing `String` values. The variables
    `var3` and `var4` refer to the same `String` object created and shared in the
    pool of `String` objects. (We discussed the pool of `String` objects in [section
    4.1.1](#ch04lev2sec1) earlier in this chapter.) The `==` operator won’t always
    return the value `true`, even if the two objects store the same `String` values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用运算符 `==` 比较 `var3` 和 `var4` 打印 `true`，您也 *永远不要* 使用此运算符来比较 `String` 值。变量
    `var3` 和 `var4` 引用同一个在 `String` 对象池中创建和共享的 `String` 对象。（我们已经在本章的 [4.1.1 节](#ch04lev2sec1)
    中讨论了 `String` 对象池。）即使两个对象存储相同的 `String` 值，运算符 `==` 也不总是会返回 `true`。
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The operator `==` compares whether the reference variables refer to the same
    objects, and the method `equals` compares the `String` values for equality. Always
    use the `equals` method to compare two `String`s for equality. Never use the `==`
    operator for this purpose.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 `==` 比较引用变量是否引用同一个对象，而方法 `equals` 比较字符串值是否相等。始终使用 `equals` 方法来比较两个 `String`
    的相等性。永远不要使用运算符 `==` 来完成此目的。
- en: '|  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can use the operator `!=` to compare the inequality of objects referred
    to by `String` variables. It’s the inverse of the operator `==`. Let’s compare
    the usage of the operator `!=` with the operator `==` and the method `equals()`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用运算符 `!=` 来比较由 `String` 变量引用的对象的不等性。它是运算符 `==` 的逆运算。让我们比较运算符 `!=` 与运算符 `==`
    和方法 `equals()` 的用法：
- en: '![](238fig01_alt.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![238fig01_alt.jpg](238fig01_alt.jpg)'
- en: 'The following example uses the operators `!=` and `==` and the method `equals`
    to compare `String` variables that refer to the same object in the `String` constant
    pool:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `!=` 和 `==` 操作符以及 `equals` 方法来比较指向 `String` 常量池中相同对象的 `String` 变量：
- en: '![](238fig02_alt.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![238fig02_alt.jpg](238fig02_alt.jpg)'
- en: As you can see, in both of the previous examples the operator `!=` returns the
    inverse of the value returned by the operator `==`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在先前的两个示例中，`!=` 操作符返回的是 `==` 操作符返回值的相反。
- en: Equality of values returned by String methods
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`String` 方法返回值的相等性'
- en: 'Do you think the `String` values returned by methods are stored in the `String`
    pool? Will they return `true` when their variable references are compared using
    the `==` operator? Let’s find out:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为方法返回的 `String` 值是否存储在 `String` 池中？当使用 `==` 操作符比较它们的变量引用时，它们会返回 `true` 吗？让我们来看看：
- en: '![](238fig03_alt.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![238fig03_alt.jpg](238fig03_alt.jpg)'
- en: In the preceding code, the call to `lang1.substring()` and `lang2.subtring()`
    will return `"Ja"`. But these string values aren’t stored in the `String` pool.
    This is because these substrings are created using the `new` operator in `String`’s
    method `substring` (and other `String` methods). This is confirmed by comparing
    their reference variables using the `==` operator, which returns `false`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，对 `lang1.substring()` 和 `lang2.subtring()` 的调用将返回 `"Ja"`。但这些字符串值并没有存储在
    `String` 池中。这是因为这些子字符串是使用 `String` 类的 `substring` 方法（以及其他 `String` 方法）中的 `new`
    操作符创建的。这可以通过使用 `==` 操作符比较它们的引用变量来确认，它返回 `false`。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for the exam questions that test you on using the `==` operator with
    `String` values returned by methods of the class `String`. Because these values
    are created using the `new` operator, they aren’t placed in the `String` pool.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意考试中测试您使用 `==` 操作符与 `String` 类方法返回的 `String` 值的问题。因为这些值是使用 `new` 操作符创建的，所以它们不会被放置在
    `String` 池中。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Because `String`s are immutable, we also need a mutable sequence of characters
    that can be manipulated. Let’s work with the other type of string on the OCA Java
    SE 8 Programmer I exam: `StringBuilder`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `String` 是不可变的，所以我们还需要一个可变的字符序列，可以对其进行操作。让我们来看看 OCA Java SE 8 程序员 I 考试中的另一种字符串类型：`StringBuilder`。
- en: '4.2\. Mutable strings: StringBuilder'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 可变字符串：`StringBuilder`
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[9.1] Manipulate data using the StringBuilder class and its methods'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.1] 使用 `StringBuilder` 类及其方法操作数据'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The class `StringBuilder` is defined in the package `java.lang`, and it has
    a mutable sequence of characters. You should use the class `StringBuilder` when
    you’re dealing with larger strings or modifying the contents of a string often.
    Doing so will improve the performance of your code. Unlike `StringBuilder`, the
    `String` class has an immutable sequence of characters. Every time you modify
    a string that’s represented by the `String` class, your code creates new `String`
    objects instead of modifying the existing one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder` 类定义在 `java.lang` 包中，它有一个可变的字符序列。当您处理较大的字符串或经常修改字符串内容时，应使用 `StringBuilder`
    类。这样做将提高您代码的性能。与 `StringBuilder` 不同，`String` 类有一个不可变的字符序列。每次您修改由 `String` 类表示的字符串时，您的代码都会创建新的
    `String` 对象，而不是修改现有的对象。'
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You can expect questions on the need for the `StringBuilder` class and its comparison
    with the `String` class.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以预期会有关于 `StringBuilder` 类的需求及其与 `String` 类的比较的问题。
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s work with the methods of the class `StringBuilder`. Because `StringBuilder`
    represents a mutable sequence of characters, the main operations on `StringBuilder`
    are related to the modification of its value by adding another value at the end
    or at a particular position, deleting characters, or changing characters at a
    particular position.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起学习 `StringBuilder` 类的方法。因为 `StringBuilder` 代表一个可变的字符序列，所以对 `StringBuilder`
    的主要操作与通过在末尾或特定位置添加另一个值、删除字符或更改特定位置的字符来修改其值有关。
- en: 4.2.1\. The StringBuilder class is mutable
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. `StringBuilder` 类是可变的
- en: 'In contrast to the class `String`, the class `StringBuilder` uses a non–`final
    char` array to store its value. Following is a partial definition of the class
    `AbstractStringBuilder` (the superclass of the class `StringBuilder`). It includes
    the declaration of the variables `value` and `count`, which are used to store
    the value of `StringBuilder` and its `length`, respectively (the relevant code
    is in bold):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `String` 类相比，`StringBuilder` 类使用非 `final char` 数组来存储其值。以下是对类 `AbstractStringBuilder`（`StringBuilder`
    类的超类）的部分定义。它包括变量 `value` 和 `count` 的声明，分别用于存储 `StringBuilder` 的值及其长度（相关代码以粗体显示）：
- en: '[PRE6]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This information will come in handy when we discuss the methods of class `StringBuilder`
    in the following sections.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中讨论 `StringBuilder` 类的方法时，这些信息将很有用。
- en: 4.2.2\. Creating StringBuilder objects
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 创建 StringBuilder 对象
- en: 'You can create objects of the class `StringBuilder` using multiple overloaded
    constructors, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用多个重载构造函数创建 `StringBuilder` 类的对象，如下所示：
- en: '![](240fig01_alt.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](240fig01_alt.jpg)'
- en: '![](num-1.jpg) constructs a `StringBuilder` object with no characters in it
    and an initial capacity of 16 characters. ![](num-2.jpg) constructs a `StringBuilder`
    object that contains the same set of characters as contained by the `StringBuilder`
    object passed to it. ![](num-3.jpg) constructs a `StringBuilder` object with no
    characters and an initial capacity of 50 characters. ![](num-4.jpg) constructs
    a `StringBuilder` object with an initial value as contained by the `String` object.
    [Figure 4.13](#ch04fig13) illustrates `StringBuilder` object `sb4` with the value
    `Shreya Gupta`.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 构造了一个没有任何字符且初始容量为 16 个字符的 `StringBuilder` 对象。![](num-2.jpg)
    构造了一个包含与传递给它的 `StringBuilder` 对象相同字符集的 `StringBuilder` 对象。![](num-3.jpg) 构造了一个没有任何字符且初始容量为
    50 个字符的 `StringBuilder` 对象。![](num-4.jpg) 构造了一个初始值与 `String` 对象相同的 `StringBuilder`
    对象。[图 4.13](#ch04fig13) 展示了具有值 `Shreya Gupta` 的 `StringBuilder` 对象 `sb4`。'
- en: Figure 4.13\. The `StringBuilder` object with character values and their corresponding
    storage positions
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.13\. `StringBuilder` 对象及其对应的存储位置字符值
- en: '![](04fig13_alt.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig13_alt.jpg)'
- en: 'When you create a `StringBuilder` object using its default constructor, the
    following code executes behind the scenes to initialize the array `value` defined
    in the class `StringBuilder` itself:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用其默认构造函数创建 `StringBuilder` 对象时，以下代码在幕后执行以初始化在 `StringBuilder` 类本身中定义的数组 `value`：
- en: '![](240fig02.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](240fig02.jpg)'
- en: 'When you create a `StringBuilder` object by passing it a `String`, the following
    code executes behind the scenes to initialize the array value:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过传递一个 `String` 来创建 `StringBuilder` 对象时，以下代码在幕后执行以初始化数组值：
- en: '![](240fig03_alt.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](240fig03_alt.jpg)'
- en: 'The creation of objects for the class `StringBuilder` is the basis for the
    next Twist in the Tale exercise. Your task in this exercise is to look up the
    Java API documentation or the Java source code to answer the question. You can
    access the Java API documentation in a couple of ways:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder` 类对象的创建是下一个 Twist in the Tale 练习的基础。在这个练习中，您的任务是查找 Java API
    文档或 Java 源代码来回答问题。您可以通过以下几种方式访问 Java API 文档：'
- en: View it online at [http://docs.oracle.com/javase/8/docs/api/](http://docs.oracle.com/javase/8/docs/api/).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线查看[http://docs.oracle.com/javase/8/docs/api/](http://docs.oracle.com/javase/8/docs/api/).
- en: Download it to your system from [http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html](http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html).
    Accept the license agreement and click the link for jdk-8u66-docs-all.zip to download
    it. (These links may change eventually as Oracle updates its website.)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 [http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html](http://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html)
    下载到您的系统。接受许可协议并点击 jdk-8u66-docs-all.zip 链接进行下载。（这些链接可能会随着 Oracle 更新其网站而最终更改。）
- en: The answer to the following Twist in the Tale exercise is given in the appendix.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Twist in the Tale 练习的答案是附录中给出的。
- en: Twist in the Tale 4.2
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Twist in the Tale 4.2
- en: 'Take a look at the Java API documentation or the Java source code files and
    answer the following question:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Java API 文档或 Java 源代码文件，并回答以下问题：
- en: Which of the following options (there’s just one correct answer) correctly creates
    an object of the class `StringBuilder` with a default capacity of 16 characters?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个选项（只有一个正确答案）正确地创建了一个具有默认容量为 16 个字符的 `StringBuilder` 类对象？
- en: '`StringBuilder name = StringBuilder.getInstance();`'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StringBuilder name = StringBuilder.getInstance();`'
- en: '`StringBuilder name = StringBuilder.createInstance();`'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StringBuilder name = StringBuilder.createInstance();`'
- en: '`StringBuilder name = StringBuilder.buildInstance();`'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StringBuilder name = StringBuilder.buildInstance();`'
- en: None of the above
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上均不正确
- en: 4.2.3\. Methods of class StringBuilder
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. `StringBuilder` 类的方法
- en: 'You’ll be pleased to learn that many of the methods defined in the class `StringBuilder`
    work exactly like the versions in the class `String`—for example, methods such
    as `charAt`, `indexOf`, `substring`, and `length`. We won’t discuss these again
    for the class `StringBuilder`. In this section, we’ll discuss the other main methods
    of the class `StringBuilder`: `append`, `insert`, and `delete`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很高兴地了解到，在 `StringBuilder` 类中定义的许多方法与 `String` 类中的版本工作方式完全相同——例如，`charAt`、`indexOf`、`substring`
    和 `length` 等方法。我们不会再次讨论 `StringBuilder` 类中的这些方法。在本节中，我们将讨论 `StringBuilder` 类的其他主要方法：`append`、`insert`
    和 `delete`。
- en: '[Figure 4.14](#ch04fig14) shows the categorization of this class’s methods.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.14](#ch04fig14) 展示了此类方法的分类。'
- en: Figure 4.14\. Categorization of `StringBuilder` methods
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.14\. `StringBuilder` 方法的分类
- en: '![](04fig14_alt.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig14_alt.jpg)'
- en: append()
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: append()
- en: The `append` method adds the specified value at the end of the existing value
    of a `StringBuilder` object. Because you may want to add data from multiple data
    types to a `StringBuilder` object, this method has been overloaded so that it
    can accept data of any type.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 方法将指定的值添加到 `StringBuilder` 对象的现有值末尾。因为你可能想要将来自多个数据类型的数据添加到 `StringBuilder`
    对象中，所以该方法被重载，以便它可以接受任何类型的数据。'
- en: 'This method accepts all the primitives, `String`, `char` array, and `Object`,
    as method parameters, as shown in the following example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受所有原始类型、`String`、`char` 数组以及 `Object` 作为方法参数，如下例所示：
- en: '![](242fig01_alt.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](242fig01_alt.jpg)'
- en: 'You can append a complete `char` array, `StringBuilder`, or `String` or its
    subset as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按以下方式附加完整的 `char` 数组、`StringBuilder`、`String` 或其子集：
- en: '![](242fig02_alt.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](242fig02_alt.jpg)'
- en: 'Because the method `append` also accepts a method parameter of type `Object`,
    you can pass it any object from the Java API or your own user-defined object:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 因为方法 `append` 也接受类型为 `Object` 的方法参数，所以你可以传递来自 Java API 或你自定义的任何对象：
- en: '![](242fig03_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](242fig03_alt.jpg)'
- en: The output of the previous code is
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出是
- en: '[PRE7]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this output, the hex value (`126b249`) that follows the `@` sign may differ
    on your system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，跟随 `@` 符号的十六进制值（`126b249`）可能因系统而异。
- en: When you append an object’s value to a `StringBuilder`, the method `append`
    calls the static `String.valueOf()` method. The version taking an `Object` parameter
    returns the four-letter string “null” if the parameter is `null`; otherwise, it
    calls its `toString` method. If the `toString` method has been overridden by the
    class, then the method `append` adds the `String` value returned by it to the
    target `StringBuilder` object. In the absence of the overridden `toString` method,
    the `toString` method defined in the class `Object` executes. For your information,
    the default implementation of the method `toString` in the class `Object` returns
    the name of the class followed by the `@` char and unsigned hexadecimal representation
    of the hash code of the object (the value returned by the object’s `hashCode`
    method).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将对象的值附加到 `StringBuilder` 时，`append` 方法会调用静态的 `String.valueOf()` 方法。接受 `Object`
    参数的版本，如果参数为 `null`，则返回四字母字符串“null”；否则，它调用其 `toString` 方法。如果 `toString` 方法已被类覆盖，则
    `append` 方法会将它返回的 `String` 值添加到目标 `StringBuilder` 对象中。如果没有覆盖 `toString` 方法，则执行类
    `Object` 中定义的 `toString` 方法。为了你的信息，类 `Object` 中 `toString` 方法的默认实现返回类的名称，后跟 `@`
    字符和对象的哈希码的无符号十六进制表示（由对象的 `hashCode` 方法返回的值）。
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: For classes that haven’t overridden the `toString` method, the `append` method
    results in appending the output from the default implementation of method `toString`
    defined in the class `Object` (if the parameter isn’t `null`).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有覆盖 `toString` 方法的类，`append` 方法会导致将类 `Object` 中定义的方法 `toString` 的默认实现输出附加到（如果参数不是
    `null`）。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'It’s interesting to take a quick look at how the `append` method works for
    the class `StringBuilder`. Following is a partial code listing of the method `append`
    that accepts a `boolean` parameter (as explained in the comments):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看 `StringBuilder` 类的 `append` 方法的工作方式很有趣。以下是对接受 `boolean` 参数的 `append` 方法的部分代码列表（如注释中所述）：
- en: '![](243fig01_alt.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](243fig01_alt.jpg)'
- en: '![](num-1.jpg) and ![](num-2.jpg) determine whether the array `value` can accommodate
    four additional characters corresponding to the `boolean` literal value `true`.
    At ![](num-2.jpg), the call to `expand-Capacity()` increases the capacity of the
    array `value` (used to store the characters of a `StringBuilder` object) if it
    isn’t big enough. ![](num-3.jpg) adds individual characters of the `boolean` value
    `true` to the array `value`.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![num-1.jpg](num-1.jpg) 和 ![num-2.jpg](num-2.jpg) 确定数组 `value` 是否可以容纳与布尔字面值
    `true` 对应的四个额外字符。在 ![num-2.jpg](num-2.jpg) 中，对 `expand-Capacity()` 的调用会增加数组 `value`（用于存储
    `StringBuilder` 对象的字符）的容量（如果它不够大）。![num-3.jpg](num-3.jpg) 将布尔值 `true` 的单个字符添加到数组
    `value` 中。'
- en: insert()
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`insert()`'
- en: 'The `insert` method is as powerful as the `append` method. It also exists in
    multiple flavors (read: overloaded methods) that accept any data type. The main
    difference between the `append` and `insert` methods is that the `insert` method
    enables you to insert the requested data at a particular position, but the `append`
    method allows you to add the requested data only at the end of the `StringBuilder`
    object:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 方法与 `append` 方法一样强大。它也存在多种变体（即：重载方法），可以接受任何数据类型。`append` 和 `insert`
    方法之间的主要区别在于，`insert` 方法允许您在特定位置插入所需数据，而 `append` 方法只允许您在 `StringBuilder` 对象的末尾添加所需数据：'
- en: '![](244fig01_alt.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![244fig01_alt.jpg](244fig01_alt.jpg)'
- en: '[Figure 4.15](#ch04fig15) illustrates the previous code.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.15](#ch04fig15) 展示了前面的代码。'
- en: Figure 4.15\. Inserting a `char` using the method `insert` in `StringBuilder`
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.15\. 在 `StringBuilder` 中使用 `insert` 方法插入 `char`
- en: '![](04fig15.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![04fig15.jpg](04fig15.jpg)'
- en: 'As with `String` objects, the first character of `StringBuilder` is stored
    at position 0\. Hence, the previous code inserts the letter `r` at position 2,
    which is occupied by the letter `n`. You can also insert a complete `char` array,
    `StringBuffer`, or `String` or its subset, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `String` 对象一样，`StringBuilder` 的第一个字符存储在位置 0。因此，前面的代码在位置 2 插入了字母 `r`，该位置被字母
    `n` 占据。您也可以插入完整的 `char` 数组、`StringBuffer`、`String` 或其子集，如下所示：
- en: '![](244fig02_alt.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![244fig02_alt.jpg](244fig02_alt.jpg)'
- en: '[Figure 4.16](#ch04fig16) illustrates the previous code.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4.16](#ch04fig16) 展示了前面的代码。'
- en: Figure 4.16\. Inserting a substring of `String` in `StringBuilder`
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.16\. 在 `StringBuilder` 中插入 `String` 的子字符串
- en: '![](04fig16_alt.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![04fig16_alt.jpg](04fig16_alt.jpg)'
- en: '|  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Take note of the start and end positions when inserting a value in a `StringBuilder`.
    Multiple flavors of the `insert` method defined in `StringBuilder` may confuse
    you because they can be used to insert either single or multiple characters.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StringBuilder` 中插入值时，请注意起始和结束位置。`StringBuilder` 中定义的 `insert` 方法的多种变体可能会让您感到困惑，因为它们可以用来插入单个或多个字符。
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: delete() and deleteCharAt()
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`delete()` 和 `deleteCharAt()`'
- en: 'The method `delete` removes the characters in a substring of the specified
    `StringBuilder`. The method `deleteCharAt` removes the `char` at the specified
    position. Here’s an example showing the method `delete`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 方法删除指定 `StringBuilder` 的子字符串中的字符。`deleteCharAt` 方法删除指定位置的 `char`。以下是一个显示
    `delete` 方法的示例：'
- en: '![](245fig01_alt.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![245fig01_alt.jpg](245fig01_alt.jpg)'
- en: '![](num-1.jpg) removes characters at positions 2 and 3\. The `delete` method
    doesn’t remove the letter at position 4\. [Figure 4.17](#ch04fig17) illustrates
    the previous code.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![num-1.jpg](num-1.jpg) 删除位置 2 和 3 的字符。`delete` 方法不会删除位置 4 的字母。[图 4.17](#ch04fig17)
    展示了前面的代码。'
- en: Figure 4.17\. The method `delete(2,4)` doesn’t delete the character at position
    4.
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.17\. 方法 `delete(2,4)` 不会删除位置 4 的字符。
- en: '![](04fig17_alt.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![04fig17_alt.jpg](04fig17_alt.jpg)'
- en: 'The method `deleteCharAt` is simple. It removes a single character, as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `deleteCharAt` 很简单。它删除单个字符，如下所示：
- en: '![](245fig02_alt.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![245fig02_alt.jpg](245fig02_alt.jpg)'
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Combinations of the `deleteCharAt` and `insert` methods can be quite confusing.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteCharAt` 和 `insert` 方法的组合可能会相当令人困惑。'
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: trim()
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`trim()`'
- en: Unlike the class `String`, the class `StringBuilder` doesn’t define the method
    `trim`. An attempt to use it with this class will prevent your code from compiling.
    The only reason I’m describing a nonexistent method here is to ward off any confusion.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `String` 类不同，`StringBuilder` 类没有定义 `trim` 方法。尝试使用此类使用它将阻止您的代码编译。我在这里描述一个不存在的方法的唯一原因是为了避免任何混淆。
- en: reverse()
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`reverse()`'
- en: 'As the name suggests, the `reverse` method reverses the sequence of characters
    of a `StringBuilder`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`reverse` 方法反转 `StringBuilder` 中字符的顺序：
- en: '![](246fig01_alt.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![246fig01_alt.jpg](246fig01_alt.jpg)'
- en: '|  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: You can’t use the method `reverse` to reverse a substring of `String-Builder`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能使用 `reverse` 方法来反转 `StringBuilder` 的子字符串。
- en: '|  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: replace()
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`replace()`'
- en: 'Unlike the `replace` method defined in the class `String`, the `replace` method
    in the class `StringBuilder` replaces a sequence of characters, identified by
    their positions, with another `String`, as in the following example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 与在类String中定义的`replace`方法不同，类StringBuilder中的`replace`方法通过指定位置来替换一系列字符，如下例所示：
- en: '![](246fig02_alt.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图片](246fig02_alt.jpg)'
- en: '[Figure 4.18](#ch04fig18) shows a comparison of the `replace` methods defined
    in the classes `String` and `StringBuilder`.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.18](#ch04fig18)显示了在类`String`和`StringBuilder`中定义的`replace`方法的比较。'
- en: Figure 4.18\. Comparing the `replace` methods in `String` (left) and `StringBuilder`
    (right). The method `replace` in `String` accepts the characters to be replaced.
    The method `replace` in `StringBuilder` accepts a position to be replaced.
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.18\. 比较`String`（左）和`StringBuilder`（右）中的`replace`方法。`String`中的`replace`方法接受要替换的字符。`StringBuilder`中的`replace`方法接受要替换的位置。
- en: '![](04fig18_alt.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig18_alt.jpg)'
- en: subSequence()
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: subSequence()
- en: 'Apart from using the method `substring`, you can also use the method `subSequence`
    to retrieve a subsequence of a `StringBuilder` object. This method returns objects
    of type `CharSequence`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`substring`方法外，您还可以使用`subSequence`方法来检索`StringBuilder`对象的子序列。此方法返回`CharSequence`类型的对象：
- en: '![](247fig01_alt.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图片](247fig01_alt.jpg)'
- en: The method `subsequence` doesn’t modify the existing value of a `StringBuilder`
    object.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`subsequence`方法不会修改`StringBuilder`对象的现有值。'
- en: 4.2.4\. A quick note on the class StringBuffer
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. 关于类StringBuffer的简要说明
- en: Although the OCA Java SE 8 Programmer I exam objectives don’t mention the class
    `StringBuffer`, you may see it in the list of (incorrect) answers in the OCA exam.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然OCA Java SE 8程序员I考试目标没有提到类`StringBuffer`，但你可能在OCA考试的错误答案列表中看到它。
- en: 'The classes `StringBuffer` and `StringBuilder` offer the same functionality,
    with one difference: the methods of the class `StringBuffer` are synchronized
    where necessary, whereas the methods of the class `StringBuilder` aren’t. What
    does this mean? When you work with the class `StringBuffer`, only one thread out
    of multiple threads can execute your method. This arrangement prevents any inconsistencies
    in the values of the instance variables that are modified by these (synchronized)
    methods. But it introduces additional overhead, so working with synchronized methods
    and the `StringBuffer` class affects the performance of your code.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 类`StringBuffer`和`StringBuilder`提供相同的功能，但有一个区别：`StringBuffer`类的方法在必要时是同步的，而`StringBuilder`类的方法不是。这意味着什么？当您使用`StringBuffer`类时，只有多个线程中的一个可以执行您的该方法。这种安排可以防止这些（同步）方法修改的实例变量值出现不一致。但这也引入了额外的开销，因此使用同步方法和`StringBuffer`类会影响您代码的性能。
- en: The class `StringBuilder` offers the same functionality as offered by `StringBuffer`,
    minus the additional feature of synchronized methods. Often your code won’t be
    accessed by multiple threads, so it won’t need the overhead of thread synchronization.
    If you need to access your code from multiple threads, use `StringBuffer`; otherwise
    use `StringBuilder`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 类`StringBuilder`提供与`StringBuffer`相同的功能，但没有额外的同步方法功能。通常您的代码不会被多个线程访问，因此不需要线程同步的开销。如果您需要从多个线程访问您的代码，请使用`StringBuffer`；否则请使用`StringBuilder`。
- en: 4.3\. Arrays
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 数组
- en: '|  |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[4.1](#ch04lev1sec1)] Declare, instantiate, initialize, and use a one-dimensional
    array'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[[4.1](#ch04lev1sec1)] 声明、实例化、初始化和使用一维数组'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[4.2](#ch04lev1sec2)] Declare, instantiate, initialize, and use a multidimensional
    array'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[[4.2](#ch04lev1sec2)] 声明、实例化、初始化和使用多维数组'
- en: '|  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, I’ll cover declaration, allocation, and initialization of one-dimensional
    and multidimensional arrays. You’ll learn about the differences between arrays
    of primitive data types and arrays of objects.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍一维数组和多维数组的声明、分配和初始化。您将了解原始数据类型数组和对象数组之间的区别。
- en: 4.3.1\. What is an array?
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 什么是数组？
- en: 'An array is an object that stores a collection of values. The fact that an
    array itself is an object is often overlooked. I’ll reiterate: an array is an
    object itself; it stores references to the data it stores. Arrays can store two
    types of data:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个存储值集合的对象。数组本身是对象这一事实往往被忽视。我将重申：数组本身就是一个对象；它存储它所存储数据的引用。数组可以存储两种类型的数据：
- en: A collection of primitive data types
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据类型的集合
- en: A collection of objects
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组对象集合
- en: An array of primitives stores a collection of values that constitute the primitive
    values themselves. (With primitives, there are no objects to reference.) An array
    of objects stores a collection of values, which are in fact heap-memory addresses
    or pointers. The addresses point to (reference) the object instances that your
    array is said to store, which means that object arrays store references (to objects)
    and primitive arrays store primitive values.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据数组存储构成原始值的值集合。（对于原始数据，没有要引用的对象。）对象数组存储值集合，实际上是指向堆内存地址或指针。这些地址指向（引用）数组所存储的对象实例，这意味着对象数组存储引用（到对象），而原始数组存储原始值。
- en: The members of an array are defined in contiguous (continuous) memory locations
    and hence offer improved access speed. (You should be able to quickly access all
    the students of a class if they all can be found next to each other.)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的成员定义在连续（连续）的内存位置中，因此提供了改进的访问速度。（如果您能快速访问所有相邻的学生，您应该能够快速访问一个班级的所有学生。）
- en: 'The following code creates an array of primitive data and an array of objects:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个原始数据数组和对象数组：
- en: '![](248fig01_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图片](248fig01_alt.jpg)'
- en: I’ll discuss the details of creating arrays shortly. The previous example shows
    one of the ways to create arrays. [Figure 4.19](#ch04fig19) illustrates the arrays
    `intArray` and `objArray`. Unlike `intArray`, `objArray` stores references to
    `String` objects.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在稍后讨论创建数组的细节。上一个示例展示了创建数组的一种方法。[图4.19](#ch04fig19)展示了`intArray`和`objArray`数组。与`intArray`不同，`objArray`存储了对`String`对象的引用。
- en: Figure 4.19\. An array of `int` primitive data type and another of `String`
    objects
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.19\. `int`原始数据类型数组和`String`对象数组
- en: '![](04fig19.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig19.jpg)'
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Arrays are objects and refer to a collection of primitive data types or other
    objects.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是对象，指向原始数据类型或其他对象的集合。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In Java, you can define one-dimensional and multidimensional arrays. A *one-dimensional
    array* is an object that refers to a collection of scalar values. A two-dimensional
    (or more) array is referred to as a *multidimensional array*. A two-dimensional
    array refers to a collection of objects in which each of the objects is a one-dimensional
    array. Similarly, a three-dimensional array refers to a collection of two-dimensional
    arrays, and so on. [Figure 4.20](#ch04fig20) depicts a one-dimensional array and
    multidimensional arrays (two-dimensional and three-dimensional).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，您可以定义一维和多维数组。*一维数组*是一个指向标量值集合的对象。二维（或更多）数组称为*多维数组*。二维数组是指一个集合中的对象，其中每个对象都是一维数组。同样，三维数组是指二维数组的集合，依此类推。[图4.20](#ch04fig20)描述了一维数组和多维数组（二维和三维）。
- en: Figure 4.20\. One-dimensional and multidimensional (two- and three-dimensional)
    arrays
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.20\. 一维和多维（二维和三维）数组
- en: '![](04fig20_alt.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig20_alt.jpg)'
- en: Note that multidimensional arrays may or may not contain the same number of
    elements in each row or column, as shown in the two-dimensional array in [figure
    4.20](#ch04fig20).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，多维数组可能或可能不包含每行或每列相同数量的元素，如图4.20中的二维数组所示。
- en: 'Creating an array involves three steps, as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组涉及三个步骤，如下所示：
- en: Declaring the array
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明数组
- en: Allocating the array
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配数组
- en: Initializing the array elements
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化数组元素
- en: 'You can create an array by executing the previous steps using separate lines
    of code or you can combine these steps on the same line of code. Let’s start with
    the first approach: completing each step on a separate line of code.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用单独的代码行执行前面的步骤或将这些步骤组合在同一行代码中创建数组。让我们从第一种方法开始：在单独的代码行上完成每个步骤。
- en: 4.3.2\. Array declaration
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 数组声明
- en: An array declaration includes the array *type* and array *variable*, as shown
    in [figure 4.21](#ch04fig21). The type of objects that an array can store depends
    on its type. An array type is followed by one or more empty pairs of square brackets
    `[]`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明包括数组*类型*和数组*变量*，如图4.21所示。数组可以存储的对象类型取决于其类型。数组类型后面跟着一个或多个空方括号对`[]`。
- en: Figure 4.21\. Array declaration includes the array type and array variable
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.21\. 数组声明包括数组类型和数组变量
- en: '![](04fig21.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig21.jpg)'
- en: 'To declare an array, specify its type, followed by the name of the array variable.
    Here’s an example of declaring arrays of `int` and `String` values:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个数组，指定其类型，然后是数组变量的名称。以下是一个声明`int`和`String`值数组的示例：
- en: '![](249fig01_alt.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](249fig01_alt.jpg)'
- en: The number of bracket pairs indicates the depth of array nesting. Java doesn’t
    impose any theoretical limit on the level of array nesting. The square brackets
    can follow the array type or its name, as shown in [figure 4.22](#ch04fig22).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号对的数量表示数组嵌套的深度。Java不对数组嵌套的级别设置任何理论上的限制。方括号可以跟在数组类型或其名称之后，如图4.22所示。
- en: Figure 4.22\. Square brackets can follow either the variable name or its type.
    In the case of multidimensional arrays, it can follow both of them.
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.22\. 方括号可以跟在变量名称或其类型之后。在多维数组的情况下，它可以跟在两者之后。
- en: '![](04fig22_alt.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig22_alt.jpg)'
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In an array declaration, placing the square brackets next to the type (as in
    `int[]` or `int[][]`) is preferred because it makes the code easier to read by
    showing the array types in use.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组声明中，将方括号放在类型旁边（如`int[]`或`int[][]`）是首选的，因为它通过显示正在使用的数组类型使代码更容易阅读。
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The array declaration only creates a variable that refers to `null`, as shown
    in [figure 4.23](#ch04fig23).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明仅创建一个引用`null`的变量，如图4.23所示。
- en: Figure 4.23\. Array declaration creates a variable that refers to `null`.
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.23\. 数组声明创建一个引用`null`的变量。
- en: '![](04fig23.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig23.jpg)'
- en: 'Because no elements of an array are created when it’s declared, it’s invalid
    to define the size of an array with its declaration. The following code won’t
    compile:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在声明数组时没有创建数组元素，所以使用声明定义数组的大小是不合法的。以下代码无法编译：
- en: '![](250fig01_alt.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](250fig01_alt.jpg)'
- en: 'An array type can be any of the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型可以是以下任何一种：
- en: Primitive data type
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: Interface
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Abstract class
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类
- en: Concrete class
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体类
- en: We declared an array of an `int` primitive type and a concrete class `String`
    previously. I’ll discuss some complex examples with abstract classes and interfaces
    in [section 4.3.7](#ch04lev2sec16).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前声明了一个`int`原始数据类型的数组和一个具体的类`String`。我将在[4.3.7节](#ch04lev2sec16)中讨论一些使用抽象类和接口的复杂示例。
- en: '|  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Arrays can be of any data type other than `null`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以是除了`null`之外任何数据类型。
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.3.3\. Array allocation
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3\. 数组分配
- en: 'As the name suggests, array allocation will allocate memory for the elements
    of an array. When you allocate memory for an array, you should specify its dimensions,
    such as the number of elements the array should store. Note that the size of an
    array can’t expand or reduce once it is allocated. Here are a few examples:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，数组分配将为数组的元素分配内存。当你为数组分配内存时，你应该指定其维度，例如数组应存储的元素数量。请注意，一旦分配，数组的尺寸就不能扩展或缩小。以下是一些示例：
- en: '![](251fig01_alt.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](251fig01_alt.jpg)'
- en: 'Because an array is an object, it’s allocated using the keyword `new`, followed
    by the type of value that it stores, and then its size. The code won’t compile
    if you don’t specify the size of the array or if you place the array size on the
    left of the `=` sign, as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组是一个对象，所以使用关键字`new`进行分配，后面跟它存储的值的类型，然后是其尺寸。如果你没有指定数组的尺寸，或者将数组尺寸放在`=`符号的左侧，代码将无法编译，如下所示：
- en: '![](251fig02_alt.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](251fig02_alt.jpg)'
- en: 'The size of the array must evaluate to an `int` value. You can’t create an
    array with its size specified as a floating-point number. The following line of
    code won’t compile:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的尺寸必须评估为一个`int`类型的值。你不能创建一个其尺寸指定为浮点数的数组。以下代码行无法编译：
- en: '![](251fig03_alt.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](251fig03_alt.jpg)'
- en: 'Java accepts an expression to specify the size of an array, as long as it evaluates
    to an `int` value. The following are valid array allocations:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Java接受一个表达式来指定数组的尺寸，只要它评估为一个`int`类型的值。以下都是有效的数组分配：
- en: '![](251fig04_alt.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![](251fig04_alt.jpg)'
- en: 'Let’s allocate the multidimensional array `multiArr`, as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式分配多维数组`multiArr`：
- en: '![](251fig05_alt.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](251fig05_alt.jpg)'
- en: 'You can also allocate the multidimensional array `multiArr` by defining size
    in only the first square brackets:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过只定义第一个方括号中的尺寸来分配多维数组`multiArr`：
- en: '![](251fig06_alt.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![](251fig06_alt.jpg)'
- en: It’s interesting to note the difference between what happens when the multidimensional
    array `multiArr` is allocated by defining sizes for a single dimension or for
    both of its dimensions. This difference is shown in [figure 4.24](#ch04fig24).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是要注意，当通过定义单维或两个维度的尺寸来分配多维数组`multiArr`时，所发生的情况之间的差异。这种差异如图4.24所示。
- en: Figure 4.24\. The difference in array allocation of a two-dimensional array
    when it’s allocated using values for only one of its dimensions and for both of
    its dimensions
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.24\. 当使用仅为其一个维度提供值和为其两个维度都提供值来分配二维数组时，数组分配的差异
- en: '![](04fig24_alt.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig24_alt.jpg)'
- en: 'You can’t allocate a multidimensional array as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能如下分配一个多维数组：
- en: '![](252fig01_alt.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](252fig01_alt.jpg)'
- en: '![](num-1.jpg) won’t compile because there’s a mismatch in the number of square
    brackets on both sides of the assignment operator (`=`). The compiler required
    `[][]` on the right side of the assignment operator, but it finds only `[]`. ![](num-2.jpg)
    won’t compile because you can’t allocate a multidimensional array without including
    a size in the first square bracket and defining a size in the second square bracket.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 无法编译，因为在赋值运算符（`=`）两侧的方括号数量不匹配。编译器要求赋值运算符右侧使用`[][]`，但它只找到了`[]`。![](num-2.jpg)
    无法编译，因为你不能在不包括第一个方括号中的大小并在第二个方括号中定义大小的情况下分配多维数组。'
- en: Once allocated, the array elements store their default values. For arrays that
    store objects, all the allocated array elements store `null`. For arrays that
    store primitive values, the default values depend on the exact data types stored
    by them.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配，数组元素将存储它们的默认值。对于存储对象的数组，所有分配的数组元素都存储 `null`。对于存储原始值的数组，默认值取决于它们存储的确切数据类型。
- en: '|  |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Once allocated, all the array elements store their default values. Elements
    in an array that store objects default to `null`. Elements of an array that store
    primitive data types store `0` for integer types (`byte`, `short`, `int`, `long`);
    `0.0` for decimal types (`float` and `double`); `false` for `boolean;` or `\u0000`
    for `char` data.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配，所有数组元素将存储它们的默认值。存储对象的数组元素默认为 `null`。存储原始数据类型的数组元素存储 `0`（对于整数类型 `byte`、`short`、`int`、`long`）；`0.0`（对于十进制类型
    `float` 和 `double`）；`false`（对于 `boolean`）；或 `\u0000`（对于 `char` 数据类型）。
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.3.4\. Array initialization
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.4\. 数组初始化
- en: 'You can initialize an array as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样初始化一个数组：
- en: '![](252fig02_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](252fig02_alt.jpg)'
- en: In the preceding code, ![](num-1.jpg) uses a `for` loop to initialize the array
    `intArray` with the required values. ![](num-2.jpg) initializes the individual
    array elements without using a `for` loop. Note that all array objects use their
    public immutable field `length` to access their array size.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，![](num-1.jpg) 使用 `for` 循环初始化 `intArray` 数组，使其包含所需的值。![](num-2.jpg)
    在不使用 `for` 循环的情况下初始化单个数组元素。请注意，所有数组对象都使用它们的公共不可变字段 `length` 来访问它们的数组大小。
- en: 'Similarly, a `String` array can be declared, allocated, and initialized as
    follows:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以如下声明、分配和初始化一个 `String` 数组：
- en: '![](253fig01_alt.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![](253fig01_alt.jpg)'
- en: 'When you initialize a two-dimensional array, you can use nested `for` loops
    to initialize its array elements. Also notice that to access an element in a two-dimensional
    array, you should use two array position values, as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化一个二维数组时，你可以使用嵌套的 `for` 循环来初始化其数组元素。同时请注意，要访问二维数组中的元素，你应该使用两个数组位置值，如下所示：
- en: '![](253fig02_alt.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](253fig02_alt.jpg)'
- en: 'What happens when you try to access a nonexistent array index position? The
    following code creates an array of size 2 but tries to access its array element
    at index 3:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试访问一个不存在的数组索引位置时会发生什么？以下代码创建了一个大小为2的数组，但试图在索引3处访问其数组元素：
- en: '![](253fig03_alt.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![](253fig03_alt.jpg)'
- en: The previous code will throw a runtime exception, `ArrayIndexOutOfBounds-Exception`.
    For an array of size 2, the only valid index positions are 0 and 1\. All the rest
    of the array index positions will throw the exception `ArrayIndexOutOfBoundsException`
    at runtime.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将抛出运行时异常，`ArrayIndexOutOfBounds-Exception`。对于大小为2的数组，唯一有效的索引位置是0和1。其余的所有数组索引位置将在运行时抛出
    `ArrayIndexOutOfBoundsException` 异常。
- en: '|  |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry if you can’t immediately absorb all the information related to exceptions
    here. Exceptions are covered in detail in [chapter 7](kindle_split_021.html#ch07).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能立即吸收与异常相关的所有信息，请不要担心。异常将在第7章中详细讲解。[章节7](kindle_split_021.html#ch07)。
- en: '|  |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The Java compiler doesn’t check the range of the index positions at which you
    try to access an array element. You may be surprised to learn that the following
    line of code will compile successfully even though it uses a negative array index
    value:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器不会检查你尝试访问数组元素时的索引位置范围。你可能惊讶地发现，以下代码行将成功编译，尽管它使用了负数组索引值：
- en: '![](254fig01_alt.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](254fig01_alt.jpg)'
- en: 'Although the previous code compiles successfully, it will throw the exception
    `Array-IndexOutOfBoundsException` at runtime. Code to access an array element
    will fail to compile if you don’t pass it a `char`, `byte`, `short`, or `int`
    data type (wrapper classes are not on this exam, and I don’t include them in this
    discussion):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的代码可以成功编译，但在运行时将抛出`Array-IndexOutOfBoundsException`异常。如果你不传递`char`、`byte`、`short`或`int`数据类型（包装类不在此考试范围内，我也没有包括在内），访问数组元素的代码将无法编译：
- en: '![](254fig02_alt.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](254fig02_alt.jpg)'
- en: '|  |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Code to access an array index will throw a runtime exception if you pass it
    an invalid array index value. Code to access an array index will fail to compile
    if you don’t use a `char`, `byte`, `short`, or `int`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组索引的代码如果传递了无效的数组索引值，将会抛出运行时异常。访问数组索引的代码如果没有使用`char`、`byte`、`short`或`int`，将无法编译。
- en: '|  |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Also, you can’t remove array positions. For an array of objects, you can set
    a position to the value `null`, but it doesn’t remove the array position:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你不能删除数组位置。对于对象数组，你可以将位置设置为`null`值，但这不会删除数组位置：
- en: '![](254fig03_alt.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![](254fig03_alt.jpg)'
- en: '![](num-1.jpg) creates an array of `String` and initializes it with four `String`
    values. ![](num-2.jpg) sets the value at array index 2 to `null`. ![](num-3.jpg)
    iterates over all the array elements. As shown in the following output, four (not
    three) values are printed:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 创建了一个`String`类型的数组，并使用四个`String`值进行初始化。![](num-2.jpg) 将数组索引2的值设置为`null`。![](num-3.jpg)
    遍历所有数组元素。如下面的输出所示，打印了四个（而不是三个）值：'
- en: '[PRE8]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 4.3.5\. Combining array declaration, allocation, and initialization
  id: totrans-500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.5\. 结合数组声明、分配和初始化
- en: 'You can combine all the previously mentioned steps of array declaration, allocation,
    and initialization into one step, as follows:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将之前提到的所有数组声明、分配和初始化步骤合并为一步，如下所示：
- en: '[PRE9]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the previous code
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前面的代码
- en: Doesn’t use the keyword `new` to initialize an array
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用关键字`new`来初始化数组
- en: Doesn’t specify the size of the array
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不指定数组的大小
- en: Uses a single pair of braces to define values for a one-dimensional array and
    multiple pairs of braces to define a multidimensional array
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一对花括号定义一维数组的值，并使用多对花括号定义多维数组的值
- en: 'All the previous steps of array declaration, allocation, and initialization
    can be combined in the following way, as well:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明、分配和初始化的所有先前步骤也可以以下这种方式结合：
- en: '[PRE10]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unlike the first approach, the preceding code uses the keyword `new` to initialize
    an array.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一种方法不同，前面的代码使用关键字`new`来初始化数组。
- en: 'If you try to specify the size of an array with the preceding approach, the
    code won’t compile. Here are a few examples:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用前面提到的方法指定数组的大小，代码将无法编译。以下是一些示例：
- en: '[PRE11]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When you combine an array declaration, allocation, and initialization in a single
    step, you can’t specify the size of the array. The size of the array is calculated
    by the number of values that are assigned to the array.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在单一步骤中结合数组声明、分配和初始化时，你不能指定数组的大小。数组的大小通过分配给数组值的数量来计算。
- en: '|  |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Another important point to note is that if you declare and initialize an array
    using two separate lines of code, you’ll use the keyword `new` to initialize the
    values. The following lines of code are correct:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要点是，如果你使用两行代码分别声明和初始化数组，你将使用关键字`new`来初始化值。以下代码行是正确的：
- en: '[PRE12]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But you can’t miss the keyword `new` and initialize your array as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不能错过关键字`new`，并按以下方式初始化你的数组：
- en: '[PRE13]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 4.3.6\. Asymmetrical multidimensional arrays
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.6\. 非对称多维数组
- en: At the beginning of this section, I mentioned that a multidimensional array
    can be asymmetrical. An array can define a different number of columns for each
    of its rows.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我提到多维数组可以是非对称的。数组可以为每一行定义不同数量的列。
- en: 'The following example is an asymmetrical two-dimensional array:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是一个非对称的二维数组：
- en: '[PRE14]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 4.25](#ch04fig25) shows this asymmetrical array.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.25](#ch04fig25)显示了此非对称数组。'
- en: Figure 4.25\. An asymmetrical array
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.25\. 非对称数组
- en: '![](04fig25.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig25.jpg)'
- en: As you might have noticed, `multiStrArr[1]` refers to a `null` value. An attempt
    to access any element of this array, such as `multiStrArr[1][0],` will throw an
    exception. This brings us to the next Twist in the Tale exercise (answers are
    in the appendix).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经注意到的，`multiStrArr[1]`引用了一个`null`值。尝试访问此数组的任何元素，例如`multiStrArr[1][0]`，将抛出异常。这把我们带到了下一个“故事转折”练习（答案在附录中）。
- en: Twist in the Tale 4.3
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折4.3
- en: 'Modify some of the code used in the previous example as follows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 修改前一个例子中使用的部分代码如下：
- en: '[PRE15]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Which of the following individual options are true for the previous code?
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个选项对于前面的代码是正确的？
- en: Code on line 4 is the same as `{"Jan", "Feb", null, null},`.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第4行的代码与`{"Jan", "Feb", null, null},`相同。
- en: No value is stored at `multiStrArr[2][2]`.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`multiStrArr[2][2]`处没有存储值。
- en: No value is stored at `multiStrArr[1][1]`.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`multiStrArr[1][1]`处没有存储值。
- en: Array `multiStrArr` is asymmetric.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组`multiStrArr`是不对称的。
- en: 4.3.7\. Arrays of type interface, abstract class, and class Object
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.7\. 接口、抽象类和`Object`类的数组
- en: In the section on array declaration, I mentioned that the type of an array can
    also be an interface or an abstract class. What values do elements of these arrays
    store? Let’s look at some examples.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组声明部分，我提到数组的类型也可以是接口或抽象类。这些数组的元素存储什么值？让我们看看一些例子。
- en: interface type
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接口类型
- en: 'If the type of an array is an interface, its elements are either `null` or
    objects that implement the relevant interface type. For example, for the interface
    `MyInterface`, the array `interfaceArray` can store references to objects of either
    the class `MyClass1` or `MyClass2`:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组类型是接口，其元素可以是`null`或者实现了相关接口类型的对象。例如，对于接口`MyInterface`，数组`interfaceArray`可以存储`MyClass1`或`MyClass2`类的对象引用：
- en: '[PRE16]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: abstract class type
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象类类型
- en: 'If the type of an array is an `abstract` class, its elements are either `null`
    or objects of concrete classes that extend the relevant `abstract` class:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组的类型是`abstract`类，其元素可以是`null`或者扩展相关`abstract`类的具体类的对象：
- en: '![](257fig01_alt.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图片](257fig01_alt.jpg)'
- en: Next, I’ll discuss a special case in which the type of an array is `Object`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将讨论一个特殊情况，即数组的类型是`Object`。
- en: Object
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Object
- en: 'Because all classes extend the class `java.lang.Object`, elements of an array
    whose type is `java.lang.Object` can refer to any object. Here’s an example:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有类都扩展了`java.lang.Object`类，所以类型为`java.lang.Object`的数组的元素可以引用任何对象。以下是一个例子：
- en: '![](257fig02_alt.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![图片](257fig02_alt.jpg)'
- en: '![](num-1.jpg) is valid code. Because an array is an object, the element of
    the array of `java.lang.Object` can refer to another array. [Figure 4.26](#ch04fig26)
    illustrates the previously created array, `objArray`.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](num-1.jpg)是有效的代码。因为数组是一个对象，`java.lang.Object`数组中的元素可以引用另一个数组。[图4.26](#ch04fig26)说明了之前创建的数组`objArray`。'
- en: Figure 4.26\. An array of class `Object`
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.26\. `Object`类的数组
- en: '![](04fig26.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig26.jpg)'
- en: 4.3.8\. Members of an array
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.8\. 数组的成员
- en: 'Array objects have the following `public` members:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象有以下`public`成员：
- en: '`length`—The public variable `length` stores the number of elements of the
    array.'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`—公共变量`length`存储数组的元素数量。'
- en: '`clone()`—This method overrides the method `clone` defined in the class `Object`
    but doesn’t throw checked exceptions. The return type of this method is the same
    as the array’s type. For example, for an array of type `Type[]`, this method returns
    `Type[]`.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone()`—此方法覆盖了在`Object`类中定义的`clone`方法，但不抛出检查异常。此方法的返回类型与数组的类型相同。例如，对于类型为`Type[]`的数组，此方法返回`Type[]`。'
- en: '***Inherited methods—*** Methods inherited from the class `Object`, except
    the method `clone`.'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***继承的方法—*** 从`Object`类继承的方法，除了`clone`方法。'
- en: 'As mentioned in the earlier section on the `String` class, a `String` uses
    the method `length()` to retrieve its length. With an array, you can use the array’s
    variable `length` to determine the number of the array’s elements. In the exam,
    you may be tricked by code that tries to access the *length* of a `String` using
    the variable `length`. Note the correct combination of class and member used to
    access its length:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`String`类使用`length()`方法来获取其长度。对于数组，你可以使用数组的变量`length`来确定数组元素的个数。在考试中，你可能会被试图使用变量`length`访问`String`的`length`的代码所迷惑。注意访问其长度时使用的正确类和成员组合：
- en: '`String`—Retrieve length using the method `length()`'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`—使用`length()`方法获取长度'
- en: '***Array—*** Determine element count using the variable `length`'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数组—*** 使用`length`变量确定元素数量'
- en: I have an interesting way to remember this rule. As opposed to an array, you’ll
    invoke a *lot* of methods on `String` objects. So you use the *method* `length()`
    to retrieve the length of `String` and the *variable* `length` to retrieve the
    length of an array.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个记住这个规则很有趣的方法。与数组不同，你会在`String`对象上调用很多方法。所以你使用`length()`方法来获取`String`的长度，使用`length`变量来获取数组的长度。
- en: 4.4\. ArrayList
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. `ArrayList`
- en: '|  |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[9.4] Declare and use an ArrayList of a given type'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.4] 声明和使用指定类型的ArrayList'
- en: '|  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, I’ll cover how to use `ArrayList`, its commonly used methods,
    and the advantages it offers over an array.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍如何使用`ArrayList`，其常用方法和它相对于数组提供的优势。
- en: 'The OCA Java SE 8 Programmer I exam covers only one class from the Java Collection
    API: `ArrayList`. The rest of the classes from the Java Collection API are covered
    in the OCP Java SE 8 Programmer II exam (exam number 1Z0-809). One of the reasons
    to include this class in the Java Associate exam could be how frequently this
    class is used by all Java programmers.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8程序员I考试仅涵盖Java集合API中的一个类：`ArrayList`。Java集合API中的其余类在OCP Java SE
    8程序员II考试（考试编号1Z0-809）中涵盖。将此类包含在Java Associate考试中的一个原因可能是所有Java程序员使用此类的频率。
- en: '`ArrayList` is one of the most widely used classes from the Collections framework.
    It offers the best combination of features offered by an *array* and the *List*
    data structure. The most commonly used operations with a list are *add items to
    a list*, *modify items in a list*, *delete items from a list*, and *iterate over
    the items*.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`是集合框架中最广泛使用的类之一。它提供了由*数组*和*列表*数据结构提供的最佳功能组合。列表中最常用的操作是*向列表添加项目*、*修改列表中的项目*、*从列表中删除项目*和*遍历项目*。'
- en: One frequently asked question by Java developers is, “Why should I bother with
    an `ArrayList` when I can already store objects of the same type in an array?”
    The answer lies in the ease of use of an `ArrayList`. This is an important question,
    and this exam contains explicit questions on the practical reasons for using an
    `ArrayList`.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发者经常问的一个问题是，“为什么我要费心使用`ArrayList`，当我已经在数组中存储了相同类型的对象时？”答案在于`ArrayList`的使用简便性。这是一个重要的问题，本考试包含关于使用`ArrayList`的实际原因的明确问题。
- en: You can compare an `ArrayList` with a resizable array. As you know, once it’s
    created, you can’t increase or decrease the size of an array. On the other hand,
    an `ArrayList` automatically increases and decreases in size as elements are added
    to or removed from it. Also, unlike arrays, you don’t need to specify an initial
    size to create an `ArrayList`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`ArrayList`与可变数组进行比较。正如你所知，一旦创建，你无法增加或减少数组的大小。另一方面，`ArrayList`在元素添加到或从其中删除时会自动增加或减少大小。此外，与数组不同，你不需要指定初始大小来创建`ArrayList`。
- en: Let’s compare an `ArrayList` and an array with real-world objects. Just as a
    balloon can increase and decrease in size when it’s inflated or deflated, an `ArrayList`
    can increase or decrease in size as values are added to it or removed from it.
    One comparison is a cricket ball, because it has a predefined size. Once created,
    like an array, it can’t increase or decrease in size.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用现实世界中的对象比较`ArrayList`和数组。就像气球在充气或放气时可以增加或减少大小一样，`ArrayList`在添加或从其中删除值时也可以增加或减少大小。一个比较是板球，因为它有一个预定义的大小。一旦创建，就像数组一样，它的大小不能增加或减少。
- en: 'Here are a few more important properties of an `ArrayList`:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`ArrayList`的一些其他重要属性：
- en: It implements the interface `List`.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了`List`接口。
- en: It allows `null` values to be added to it.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许添加`null`值。
- en: It implements all list operations (add, modify, and delete values).
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了所有列表操作（添加、修改和删除值）。
- en: It allows duplicate values to be added to it.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许添加重复值。
- en: It maintains its insertion order.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它维护其插入顺序。
- en: You can use either `Iterator` or `ListIterator` to iterate over the items of
    an `ArrayList`.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`Iterator`或`ListIterator`遍历`ArrayList`中的项目。
- en: It supports generics, making it type safe. (You have to declare the type of
    the elements that should be added to an `ArrayList` with its declaration.)
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持泛型，使其类型安全。（你必须使用其声明来声明应添加到`ArrayList`中的元素类型。）
- en: 4.4.1\. Creating an ArrayList
  id: totrans-578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 创建一个ArrayList
- en: 'The following example shows you how to create an `ArrayList`:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何创建`ArrayList`：
- en: '![](259fig01_alt.jpg)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![](259fig01_alt.jpg)'
- en: 'Package `java.util` isn’t implicitly imported into your class, which means
    that ![](num-1.jpg) imports the class `ArrayList` in the class `CreateArrayList`
    defined previously. To create an `ArrayList`, you need to inform Java about the
    type of the objects that you want to store in this collection of objects. ![](num-2.jpg)
    declares an `ArrayList` called `myArrList`, which can store `String` objects specified
    by the name of the class `String` between the angle brackets (`<>`). Note that
    the name `String` appears twice in the code at ![](num-2.jpg), once on the left
    side of the equal sign and once on the right. Do you think the second one seems
    redundant? Congratulations, Oracle agrees with you. Starting with Java version
    7, you can omit the object type on the right side of the equal sign and create
    an `ArrayList` as follows:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 包`java.util`没有隐式导入到你的类中，这意味着![num-1.jpg](num-1.jpg)导入的是之前定义在`CreateArrayList`类中的`ArrayList`类。要创建一个`ArrayList`，你需要通知Java你想要存储在这个对象集合中的对象类型。![num-2.jpg](num-2.jpg)声明了一个名为`myArrList`的`ArrayList`，它可以存储由类名`String`指定的`String`对象。注意，在![num-2.jpg](num-2.jpg)的代码中，`String`出现了两次，一次在等号左边，一次在右边。你认为第二个看起来重复吗？恭喜你，Oracle也同意你的看法。从Java版本7开始，你可以在等号右边省略对象类型，并按如下方式创建一个`ArrayList`：
- en: '![](260fig01_alt.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![260fig01_alt.jpg](260fig01_alt.jpg)'
- en: Many developers still work with Java SE versions prior to version 7, so you’re
    likely to see some developers still using the older way of creating an `ArrayList`.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者仍在使用Java SE版本7之前的版本，所以你很可能会看到一些开发者仍在使用创建`ArrayList`的较老方式。
- en: 'Take a look at what happens behind the scenes (in the Java source code) when
    you execute the previous statement to create an `ArrayList`. Because you didn’t
    pass any arguments to the constructor of class `ArrayList`, its no-argument constructor
    will execute. Examine the definition of the following no-argument constructor
    defined in the class `ArrayList.java`:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当你执行前面的语句来创建一个`ArrayList`时幕后发生了什么（在Java源代码中）。因为你没有向`ArrayList`类的构造函数传递任何参数，所以它的无参构造函数将被执行。检查以下在`ArrayList.java`类中定义的无参构造函数的定义：
- en: '[PRE17]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because you can use an `ArrayList` to store any type of `Object`, `ArrayList`
    defines an instance variable `elementData` of type `Object[]` to store all its
    individual elements. Following is a partial code listing from class `ArrayList`:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以使用`ArrayList`来存储任何类型的`Object`，所以`ArrayList`定义了一个类型为`Object[]`的实例变量`elementData`来存储所有单个元素。以下是`ArrayList`类的一个部分代码列表：
- en: '[PRE18]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Figure 4.27](#ch04fig27) illustrates the variable `elementData` shown within
    an object of `ArrayList`.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27](#ch04fig27)说明了在`ArrayList`对象中显示的`elementData`变量。'
- en: Figure 4.27\. Variable `elementData` shown within an object of `ArrayList`
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.27\. `ArrayList`对象中显示的`elementData`变量
- en: '![](04fig27.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![04fig27.jpg](04fig27.jpg)'
- en: 'Here’s the definition of the constructor from the class `ArrayList` (`ArrayList.java`),
    which initializes the previously defined instance variable, `elementData`:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`ArrayList`类（`ArrayList.java`）中构造函数的定义，它初始化之前定义的实例变量`elementData`：
- en: '[PRE19]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Wait a minute. Did you notice that an `ArrayList` uses an array to store its
    individual elements? Does that make you wonder why on earth you would need another
    class if it uses a type (array, to be precise) that you already know how to work
    with? The simple answer is that you wouldn’t want to reinvent the wheel.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。你注意到`ArrayList`使用数组来存储其单个元素吗？这让你想知道为什么你需要另一个类，因为它使用了一个你已知如何操作的类型（确切地说，是数组）？简单的答案是，你不想重新发明轮子。
- en: 'For an example, answer this question: to decode an image, which of the following
    options would you prefer?'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回答以下问题：解码图像时，你更倾向于以下哪个选项？
- en: Creating your own class using characters to decode the image
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符创建自己的类来解码图像
- en: Using an existing class that offers the same functionality
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提供相同功能的现有类
- en: Obviously, it makes sense to go with the second option. If you use an existing
    class that offers the same functionality, you get more benefits with less work.
    The same logic applies to `ArrayList`. It offers you all the benefits of using
    an array with none of the disadvantages. It looks and behaves like an expandable
    array that’s modifiable.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，选择第二个选项是有意义的。如果你使用一个提供相同功能的现有类，你将获得更多的好处，而工作量更少。同样的逻辑也适用于`ArrayList`。它提供了使用数组的所有好处，而没有使用数组的任何缺点。它看起来和表现就像一个可扩展的、可修改的数组。
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An `ArrayList` uses an array to store its elements. It provides you with the
    functionality of a dynamic array.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`使用数组来存储其元素。它为你提供了动态数组的函数。'
- en: '|  |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I’ll cover how to add, modify, delete, and access the elements of an `ArrayList`
    in the following sections. Let’s start with adding elements to an `ArrayList`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将介绍如何添加、修改、删除和访问 `ArrayList` 的元素。让我们从向 `ArrayList` 添加元素开始。
- en: 4.4.2\. Adding elements to an ArrayList
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 向 ArrayList 添加元素
- en: 'Let’s begin by adding `String` objects to an `ArrayList`, as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过以下方式向 `ArrayList` 添加 `String` 对象：
- en: '![](261fig01_alt.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_IMG
  zh: '![](261fig01_alt.jpg)'
- en: You can add a value to an `ArrayList` either at its end or at a specified position.
    ![](num-1.jpg) adds elements at the end of `list`. ![](num-2.jpg) adds an element
    to `list` at position 2\. Please note that the first element of an `ArrayList`
    is stored at position 0\. Hence, at ![](num-2.jpg) the `String` literal value
    `"three"` will be inserted at position 2, which was occupied by the literal value
    `"four"`. When a value is added to a place that’s already occupied by another
    element, the values shift by a place to accommodate the newly added value. In
    this case, the literal value `"four"` shifted to position 3 to make way for the
    literal value `"three"` (see [figure 4.28](#ch04fig28)).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `ArrayList` 的末尾或指定位置添加一个值。![](num-1.jpg) 将元素添加到 `list` 的末尾。![](num-2.jpg)
    将一个元素添加到 `list` 的位置 2。请注意，`ArrayList` 的第一个元素存储在位置 0。因此，在 ![](num-2.jpg) 处，`String`
    文字值 `"three"` 将被插入到位置 2，该位置原本由文字值 `"four"` 占据。当一个值被添加到已经被另一个元素占据的位置时，值会移动一个位置以容纳新添加的值。在这种情况下，文字值
    `"four"` 移动到位置 3，为文字值 `"three"` 让出空间（参见 [图 4.28](#ch04fig28)）。
- en: Figure 4.28\. Code that adds elements to the end of an `ArrayList` and at a
    specified position
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.28\. 向 `ArrayList` 添加元素到末尾和指定位置的代码
- en: '![](04fig28_alt.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig28_alt.jpg)'
- en: 'Let’s see what happens behind the scenes in an `ArrayList` when you add an
    element to it. Here’s the definition of the method `add` from the class `ArrayList`:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你向 `ArrayList` 添加一个元素时，幕后发生了什么。以下是 `ArrayList` 类中 `add` 方法的定义：
- en: '[PRE20]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you add an element to the end of the list, the `ArrayList` first checks
    whether its instance variable `elementData` has an empty slot at the end. If there’s
    an empty slot at its end, it stores the element at the first available empty slot.
    If no empty slots exist, the method `ensureCapacity` creates another array with
    a higher capacity and copies the existing values to this newly created array.
    It then copies the newly added value at the first available empty slot in the
    array.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个元素添加到列表的末尾时，`ArrayList` 首先检查其实例变量 `elementData` 是否在末尾有一个空槽。如果末尾有空槽，它将元素存储在第一个可用的空槽中。如果没有空槽，方法
    `ensureCapacity` 会创建一个具有更高容量的新数组，并将现有值复制到这个新创建的数组中。然后，它将新添加的值复制到数组中第一个可用的空槽。
- en: When you add an element at a particular position, an `ArrayList` creates a new
    array (only if there’s not enough room left) and inserts all its elements at positions
    other than the position you specified. If there are any subsequent elements to
    the right of the position that you specified, it shifts them by one position.
    Then it adds the new element at the requested position.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在特定位置添加一个元素时，`ArrayList` 会创建一个新的数组（只有当剩余空间不足时），并将所有其他元素插入到你指定的位置之外。如果你指定的位置右侧有任何后续元素，它们会向右移动一个位置。然后，它将新元素添加到请求的位置。
- en: '|  |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Practical Tip
  id: totrans-614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实用技巧
- en: Understanding how and why a class works in a particular manner will take you
    a long way in regard to both the certification exam and your career. This understanding
    should help you retain the information for a longer time and help you answer questions
    in the certification exam that are designed to verify your practical knowledge
    of using this class. Finally, the internal workings of a class will enable you
    to make informed decisions on using a particular class at your workplace and writing
    efficient code.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一个类以特定方式工作的原因和方法，在认证考试和你的职业生涯中都会大有裨益。这种理解应该有助于你更长时间地保留信息，并帮助你回答认证考试中旨在验证你使用此类实际知识的问题。最后，类的内部工作原理将使你能够在工作场所使用特定类时做出明智的决定，并编写高效的代码。
- en: '|  |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.4.3\. Accessing elements of an ArrayList
  id: totrans-617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 访问 ArrayList 的元素
- en: Before we modify or delete the elements of an `ArrayList`, let’s see how to
    access them. To access the elements of an `ArrayList`, you can use `get()`, an
    enhanced `for` loop, `Iterator`, or `ListIterator`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改或删除 `ArrayList` 的元素之前，让我们看看如何访问它们。要访问 `ArrayList` 的元素，你可以使用 `get()`、增强型
    `for` 循环、`Iterator` 或 `ListIterator`。
- en: 'The following code accesses and prints all the elements of an `ArrayList` using
    the enhanced `for` loop (code to access elements is in bold):'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用增强型`for`循环（访问元素的代码用粗体表示）访问并打印`ArrayList`中的所有元素：
- en: '![](263fig01_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](263fig01_alt.jpg)'
- en: 'The output of the previous code is as follows:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '[PRE21]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](num-1.jpg) defines the enhanced `for` loop to access all the elements of
    the `myArrList`.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 定义了增强型`for`循环来访问`myArrList`中的所有元素。'
- en: 'Let’s look at how to use a `ListIterator` to loop through all the values of
    an `ArrayList`:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`ListIterator`遍历`ArrayList`中的所有值：
- en: '![](264fig01_alt.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
  zh: '![](264fig01_alt.jpg)'
- en: '![](num-1.jpg) gets the iterator associated with `ArrayList myArrList`. ![](num-2.jpg)
    calls the method `has-Next` on `iterator` to check whether more elements of `myArrList`
    exist. The method `hasNext` returns a `boolean true` value if more of its elements
    exist and `false` otherwise. ![](num-3.jpg) calls the method `next` on `iterator`
    to get the next item from `myArrList`.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 获取与`ArrayList myArrList`关联的迭代器。![](num-2.jpg) 在迭代器上调用`hasNext`方法来检查`myArrList`中是否存在更多元素。如果其元素存在更多，`hasNext`方法返回`boolean
    true`值，否则返回`false`。![](num-3.jpg) 在迭代器上调用`next`方法从`myArrList`获取下一个项目。'
- en: The previous code prints out the same results as the code that preceded it,
    the code that used an enhanced `for` loop to access `ArrayList`’s elements. A
    `ListIterator` doesn’t contain any reference to the *current* element of an `ArrayList`.
    `ListIterator` provides you with a method (`hasNext`) to check whether more elements
    exist for an `ArrayList`. If `true`, you can extract its *next* element using
    the method `next()`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码打印出与之前代码相同的结果，即使用增强型`for`循环访问`ArrayList`元素的代码。`ListIterator`不包含对`ArrayList`中**当前**元素的引用。`ListIterator`为您提供了一个方法（`hasNext`）来检查是否还有更多元素存在于`ArrayList`中。如果为`true`，您可以使用`next()`方法提取其**下一个**元素。
- en: Note that an `ArrayList` preserves the insertion order of its elements. `ListIterator`
    and the enhanced `for` loop will return to you the elements in the order in which
    you added them.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ArrayList`保留了其元素的插入顺序。`ListIterator`和增强型`for`循环将按您添加它们的顺序返回元素。
- en: '|  |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: An `ArrayList` preserves the order of insertion of its elements. `Iterator`,
    `ListIterator`, and the enhanced `for` loop will return the elements in the order
    in which they were added to the `ArrayList`. An iterator (`Iterator` or `ListIterator`)
    lets you remove elements as you iterate an `ArrayList`. It’s not possible to remove
    elements from an `ArrayList` while iterating it using a `for` loop.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`保留了其元素的插入顺序。`Iterator`、`ListIterator`和增强型`for`循环将按它们被添加到`ArrayList`中的顺序返回元素。迭代器（`Iterator`或`ListIterator`）允许您在迭代`ArrayList`时删除元素。在迭代`ArrayList`时使用`for`循环无法删除元素。'
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.4.4\. Modifying the elements of an ArrayList
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4\. 修改ArrayList的元素
- en: 'You can modify an `ArrayList` by either replacing an existing element in the
    `ArrayList` or modifying all of its existing values. The following code uses the
    `set` method to replace an element in an `ArrayList`:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过替换`ArrayList`中的现有元素或修改其所有现有值来修改`ArrayList`。以下代码使用`set`方法替换`ArrayList`中的元素：
- en: '![](265fig01_alt.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![](265fig01_alt.jpg)'
- en: 'The output of the previous code is as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '[PRE22]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also modify the existing values of an `ArrayList` by accessing its
    individual elements. Because `String`s are immutable, let’s try this with `StringBuilder`.
    Here’s the code:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过访问其单个元素来修改`ArrayList`中现有的值。由于`String`是不可变的，让我们用`StringBuilder`来尝试一下。以下是代码：
- en: '![](265fig02_alt.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![](265fig02_alt.jpg)'
- en: 'The output of this code is as follows:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE23]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](num-1.jpg) accesses all the elements of `myArrList` and modifies the element
    value by appending its length to it. The modified value is printed by accessing
    `myArrList` elements again.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 访问`myArrList`中的所有元素，并通过将其长度追加到它上来修改元素值。通过再次访问`myArrList`元素来打印修改后的值。'
- en: 4.4.5\. Deleting the elements of an ArrayList
  id: totrans-643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.5\. 删除ArrayList的元素
- en: '`ArrayList` defines two methods to remove its elements, as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`定义了两个方法来删除其元素，如下所示：'
- en: '`remove(int index)`—This method removes the element at the specified position
    in this list.'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(int index)`—此方法从列表中删除指定位置的元素。'
- en: '`remove(Object o)`—This method removes the first occurrence of the specified
    element from this list, if it’s present.'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(Object o)`—此方法从列表中删除指定元素的第一种出现，如果存在的话。'
- en: 'Let’s take a look at some code that uses these removal methods:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用这些删除方法的代码示例：
- en: '![](266fig01_alt.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![](266fig01_alt.jpg)'
- en: 'The output of the previous code is as follows:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE24]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](num-1.jpg) tries to remove the `StringBuilder` with the value `"Four"`
    from `myArrList`. The removal of the specified element fails because of the manner
    in which the object references are compared for equality. Objects are compared
    for equality using their `equals()` method, which isn’t overridden by the class
    `StringBuilder`. So two `StringBuilder` objects are equal if their object references
    (the variables that store them) point to the same object. You can always override
    the `equals` method in your own class to change this default behavior. The following
    is an example using the class `MyPerson`:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg)尝试从`myArrList`中移除具有值`"Four"`的`StringBuilder`。由于对象引用比较的方式，指定元素的移除失败。对象是通过它们的`equals()`方法进行比较的，而`StringBuilder`类没有重写这个方法。因此，如果两个`StringBuilder`对象的引用（存储它们的变量）指向同一个对象，则这两个`StringBuilder`对象是相等的。您始终可以在自己的类中重写`equals`方法来改变这种默认行为。以下是一个使用`MyPerson`类的示例：'
- en: '![](266fig02_alt.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
  zh: '![](266fig02_alt.jpg)'
- en: At ![](num-1.jpg), the method `equals` in the class `MyPerson` overrides the
    method `equals` in the class `Object`. It returns `false` if a `null` value is
    passed to this method. It returns `true` if an object of `MyPerson` is passed
    to it with a matching value for its instance variable `name`.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在![](num-1.jpg)处，`MyPerson`类中的`equals`方法重写了`Object`类中的`equals`方法。如果传递给此方法的参数是`null`值，则返回`false`。如果传递给它的对象是具有匹配实例变量`name`值的`MyPerson`对象，则返回`true`。
- en: At ![](num-2.jpg), the method `remove` removes the element with the name `Paul`
    from `myArr-List`. As mentioned earlier, the method `remove` compares the objects
    for equality before removing it from `ArrayList` by calling the method `equals`.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在![](num-2.jpg)处，方法`remove`通过调用方法`equals`比较对象以确定相等性，从而从`myArr-List`中移除名为`Paul`的元素。如前所述，方法`remove`在从`ArrayList`中移除元素之前会调用`equals`方法进行比较。
- en: When elements of an `ArrayList` are removed, the remaining elements are rearranged
    at their correct positions. This change is required to retrieve all the remaining
    elements at their correct new positions.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 当从`ArrayList`中移除元素时，剩余的元素会重新排列到它们正确的位置。这种变化是必要的，以便检索所有剩余元素在其正确的新位置。
- en: 4.4.6\. Other methods of ArrayList
  id: totrans-656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.6. ArrayList的其他方法
- en: Let’s briefly discuss the other important methods defined in `ArrayList`.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下在`ArrayList`中定义的其他重要方法。
- en: Adding multiple elements to an ArrayList
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向ArrayList添加多个元素
- en: 'You can add multiple elements to an `ArrayList` from another `ArrayList` or
    any other class that’s a subclass of `Collection` by using the following overloaded
    versions of method `addAll`:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下重载的`addAll`方法，将多个元素从一个`ArrayList`或任何其他是`Collection`子类的类中添加到另一个`ArrayList`中：
- en: '`addAll(Collection<? extends E> c)`'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAll(Collection<? extends E> c)`'
- en: '`addAll(int index, Collection<? extends E> c)`'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAll(int index, Collection<? extends E> c)`'
- en: The method `addAll(Collection<? extends E> c)` appends all the elements in the
    specified collection to the end of this list in the order in which they’re returned
    by the specified collection’s `Iterator`. If you aren’t familiar with generics,
    and the parameters of this method look scary to you, don’t worry—other classes
    from the Collection API aren’t on this exam.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`addAll(Collection<? extends E> c)`将指定集合中的所有元素按指定集合的`Iterator`返回的顺序追加到该列表的末尾。如果您不熟悉泛型，并且这个方法的参数看起来令您感到害怕，请不要担心——集合API中的其他类不在这个考试范围内。
- en: Method `addAll(int index, Collection<? extends E> c)` inserts all the elements
    in the specified collection into this list, starting at the specified position.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`addAll(int index, Collection<? extends E> c)`将指定集合中的所有元素插入到该列表的指定位置。
- en: 'In the following code example, all elements of `ArrayList yourArrList` are
    inserted into `ArrayList myArrList`, starting at position 1:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，`ArrayList yourArrList`的所有元素从位置1开始插入到`ArrayList myArrList`中：
- en: '![](268fig01_alt.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![](268fig01_alt.jpg)'
- en: 'The output of the previous code is as follows:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE25]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The elements of `yourArrList` aren’t removed from it. The objects that are stored
    in `yourArrList` can now be referred to from `myArrList`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '`yourArrList`中的元素不会被移除。现在可以通过`myArrList`引用存储在`yourArrList`中的对象。'
- en: 'What happens if you modify the *common* object references in these lists, `myArrList`
    and `yourArrList`? We have two cases here: in the first one, you *reassign* the
    object reference using either of the lists. In this case, the value in the second
    list will remain unchanged. In the second case, you *modify* the internals of
    any of the common list elements—in this case, the change will be reflected in
    both of the lists.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改这些列表中**公共**的对象引用，`myArrList`和`yourArrList`，会发生什么？这里有两种情况：在第一种情况下，你使用任一列表**重新分配**对象引用。在这种情况下，第二个列表中的值将保持不变。在第二种情况下，你**修改**任何公共列表元素的内部结构——在这种情况下，更改将在两个列表中反映出来。
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: This is also one of the favorite topics of the exam authors. In the exam, you’re
    likely to encounter a question that adds the same object reference to multiple
    lists and then tests you on your understanding of the state of the same object
    and reference variable in all the lists. If you have any questions on this issue,
    please refer to the section on reference variables ([section 2.3](kindle_split_013.html#ch02lev1sec3)).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是考试出题者最喜欢的主题之一。在考试中，你可能会遇到一个将相同对象引用添加到多个列表中，然后测试你对所有列表中相同对象和引用变量状态理解的问题。如果你对此问题有任何疑问，请参阅关于引用变量的部分（[第2.3节](kindle_split_013.html#ch02lev1sec3)）。
- en: '|  |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It’s time for our next Twist in the Tale exercise. Let’s modify some of the
    code that we’ve used in our previous examples and see how it affects the output
    (answers in the appendix).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行我们的下一个故事转折练习了。让我们修改一下我们在之前的例子中使用的一些代码，看看它如何影响输出（答案见附录）。
- en: Twist in the Tale 4.4
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 4.4
- en: What is the output of the following code?
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE26]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`One:Two:One:Two:`'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`One:Two:One:Two:`'
- en: '`Bne:Two:Bne:Two:`'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Bne:Two:Bne:Two:`'
- en: '`One:Two:Bne:Two:`'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`One:Two:Bne:Two:`'
- en: '`Bne:Two:One:Two:`'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Bne:Two:One:Two:`'
- en: Clearing ArrayList elements
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清除ArrayList元素
- en: 'You can remove all the `ArrayList` elements by calling `clear` on it. Here’s
    an example:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`clear`来移除`ArrayList`中的所有元素。以下是一个示例：
- en: '[PRE27]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The previous code won’t print out anything because there are no more elements
    in `myArrList`.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码不会打印任何内容，因为`myArrList`中没有更多元素。
- en: Accessing individual ArrayList elements
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 访问单个ArrayList元素
- en: 'In this section, we’ll cover the following methods for accessing elements of
    an `ArrayList`:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下用于访问`ArrayList`元素的`ArrayList`方法：
- en: '`get(int index)`—This method returns the element at the specified position
    in this list.'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(int index)`—此方法返回此列表中指定位置的元素。'
- en: '`size()`—This method returns the number of elements in this list.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`—此方法返回此列表中的元素数量。'
- en: '`contains(Object o)`—This method returns `true` if this list contains the specified
    element.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains(Object o)`—如果此列表包含指定的元素，则此方法返回`true`。'
- en: '`indexOf(Object o)`—This method returns the index of the first occurrence of
    the specified element in this list, or `–1` if this list doesn’t contain the element.'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(Object o)`—此方法返回此列表中指定元素首次出现的索引，如果此列表不包含该元素，则返回`–1`。'
- en: '`lastIndexOf(Object o)`—This method returns the index of the last occurrence
    of the specified element in this list, or `–1` if this list doesn’t contain the
    element.'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOf(Object o)`—此方法返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回`–1`。'
- en: 'You can retrieve an object at a particular position in `ArrayList` and determine
    its size as follows:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式检索`ArrayList`中特定位置的元素并确定其大小：
- en: '![](270fig01_alt.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![](270fig01_alt.jpg)'
- en: Behind the scenes, the method `get` will check whether the requested position
    exists in the `ArrayList` by comparing it with the array’s size. If the requested
    element isn’t within the range, the `get` method throws a `java.lang.IndexOutOfBoundsException`
    error at runtime.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`get`方法将通过与数组大小进行比较来检查请求的位置是否存在于`ArrayList`中。如果请求的元素不在范围内，`get`方法将在运行时抛出`java.lang.IndexOutOfBoundsException`错误。
- en: All the remaining three methods—`contains`, `indexOf`, and `lastIndexOf`—require
    you to have an unambiguous and strong understanding of how to determine the equality
    of objects. `ArrayList` stores objects, and these three methods will compare the
    values that you pass to these methods with all the elements of the `ArrayList`.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的所有三个方法—`contains`、`indexOf`和`lastIndexOf`—要求你对如何确定对象相等性有一个明确且深入的理解。`ArrayList`存储对象，这三个方法将比较你传递给这些方法的值与`ArrayList`中所有元素的值。
- en: By default, objects are considered equal if they are referred to by the same
    variable (the `String` class is an exception with its pool of `String` objects).
    If you want to compare objects by their state (values of the instance variable),
    override the `equals` method in that class. I’ve already demonstrated the difference
    in how equality of objects of a class is determined, when the class overrides
    its `equals` method and when it doesn’t, in [section 4.4.5](#ch04lev2sec22) with
    an overridden `equals` method in the class `MyPerson`.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果对象被相同的变量引用（`String` 类是一个例外，它有自己的 `String` 对象池），则认为这些对象是相等的。如果您想根据对象的状态（实例变量的值）来比较对象，请在该类中重写
    `equals` 方法。我已经在 [4.4.5 节](#ch04lev2sec22) 中通过在 `MyPerson` 类中重写 `equals` 方法，展示了如何确定一个类中对象的相等性，以及当类重写了它的
    `equals` 方法时和没有重写时的情况。
- en: 'Let’s see the usage of all these methods:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看所有这些方法的用法：
- en: '![](270fig02_alt.jpg)'
  id: totrans-699
  prefs: []
  type: TYPE_IMG
  zh: '![](270fig02_alt.jpg)'
- en: 'The output of the previous code is as follows:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '[PRE28]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Take a look at the output of the same code using a list of `MyPerson` objects
    that has overridden the `equals` method. First, here’s the definition of the class
    `MyPerson`:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 查看使用重写了 `equals` 方法的 `MyPerson` 对象列表的相同代码的输出。首先，这是类 `MyPerson` 的定义：
- en: '![](271fig01_alt.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![](271fig01_alt.jpg)'
- en: 'The definition of the class `MiscMethodsArrayList4` follows:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `MiscMethodsArrayList4` 的定义如下：
- en: '![](271fig02_alt.jpg)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
  zh: '![](271fig02_alt.jpg)'
- en: As you can see from the output of the preceding code, equality of the objects
    of the class `MyPerson` is determined by the rules defined in its `equals` method.
    Two objects of the class `MyPerson` with the same value for its instance variable
    `name` are considered to be equal. `myArrList` stores objects of the class `MyPerson`.
    To find a target object, `myArrList` will rely on the output given by the `equals`
    method of the class `MyPerson`; it won’t compare the object references of the
    stored and target objects.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码的输出所示，`MyPerson` 类中对象的相等性是由其 `equals` 方法中定义的规则确定的。具有相同 `name` 实例变量值的两个
    `MyPerson` 类对象被认为是相等的。`myArrList` 存储了 `MyPerson` 类的对象。为了找到目标对象，`myArrList` 将依赖于
    `MyPerson` 类的 `equals` 方法给出的输出；它不会比较存储对象和目标对象的引用。
- en: '|  |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: An `ArrayList` can store duplicate object values.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList` 可以存储重复的对象值。'
- en: '|  |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Cloning an ArrayList
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 克隆 ArrayList
- en: The method `clone` defined in the class `ArrayList` returns a *shallow copy*
    of this `ArrayList` instance. “Shallow copy” means that this method creates a
    new instance of the `ArrayList` object to be cloned. Its element references are
    copied, but the objects themselves are not.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `ArrayList` 中定义的 `clone` 方法返回这个 `ArrayList` 实例的 *浅拷贝*。“浅拷贝”意味着此方法创建了一个要克隆的
    `ArrayList` 对象的新实例。它的元素引用被复制，但对象本身并没有被复制。
- en: 'Here’s an example:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![](272fig01_alt.jpg)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
  zh: '![](272fig01_alt.jpg)'
- en: 'Let’s go through the previous code:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前的代码：
- en: '![](num-1.jpg) assigns the object referred to by `myArrList` to `assignedArrList`.
    The variables `myArrList` and `assignedArrList` now refer to the same object.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 将 `myArrList` 引用的对象赋值给 `assignedArrList`。现在变量 `myArrList` 和
    `assignedArrList` 引用了相同的对象。'
- en: '![](num-2.jpg) assigns a *copy* of the object referred to by `myArrList` to
    `clonedArrList`. The variables `myArrList` and `clonedArrList` refer to different
    objects. Because the method `clone` returns a value of the type `Object`, it’s
    cast to `ArrayList<String-Builder>` to assign it to `clonedArrList` (don’t worry
    if you can’t follow this line—casting is covered in [chapter 6](kindle_split_019.html#ch06)).'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](num-2.jpg) 将 `myArrList` 引用的对象的副本赋值给 `clonedArrList`。变量 `myArrList` 和 `clonedArrList`
    引用了不同的对象。因为 `clone` 方法返回的是 `Object` 类型的值，所以它被转换为 `ArrayList<String-Builder>` 类型以赋值给
    `clonedArrList`（如果您不理解这一行，不要担心——类型转换将在 [第 6 章](kindle_split_019.html#ch06) 中介绍）。'
- en: '![](num-3.jpg) prints `true` because `myArrList` and `assignedArrList` refer
    to the same object.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](num-3.jpg) 输出 `true`，因为 `myArrList` 和 `assignedArrList` 引用了相同的对象。'
- en: '![](num-4.jpg) prints `false` because `myArrList` and `clonedArrList` refer
    to separate objects, because the method `clone` creates and returns a new object
    of `ArrayList` (but with the same list members).'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](num-4.jpg) 输出 `false`，因为 `myArrList` 和 `clonedArrList` 引用了不同的对象，因为 `clone`
    方法创建并返回一个新的 `ArrayList` 对象（但具有相同的列表成员）。'
- en: '![](num-5.jpg) proves that the method `clone` didn’t copy the elements of `myArrList`.
    All the variable references `myArrVal, AssignedArrVal`, and `clonedArrVal` refer
    to the same objects.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](num-5.jpg) 证明了 `clone` 方法没有复制 `myArrList` 的元素。所有变量引用 `myArrVal`、`AssignedArrVal`
    和 `clonedArrVal` 都指向相同的对象。'
- en: Hence, both ![](num-6.jpg) and ![](num-7.jpg) print `true`.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，![](num-6.jpg) 和 ![](num-7.jpg) 都会打印 `true`。
- en: Creating an array from an ArrayList
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从ArrayList创建数组
- en: You can use the method `toArray` to return an array containing all the elements
    in an `ArrayList` in sequence from the first to the last element. As mentioned
    earlier in this chapter (refer to [figure 4.27](#ch04fig27) in [section 4.4.1](#ch04lev2sec18)),
    an `ArrayList` uses a private variable, `elementData` (an array), to store its
    own values. Method `toArray` doesn’t return a reference to this array. It creates
    a new array, copies the elements of the `ArrayList` to it, and then returns it.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `toArray` 方法返回一个包含 `ArrayList` 中所有元素的数组，从第一个元素到最后一个元素。如本章前面所述（参见图 4.27[#ch04fig27]
    在 [4.4.1 节](#ch04lev2sec18)中），`ArrayList` 使用一个私有变量 `elementData`（一个数组）来存储其自己的值。`toArray`
    方法不返回对这个数组的引用。它创建一个新的数组，将 `ArrayList` 的元素复制到其中，然后返回它。
- en: Now comes the tricky part. No references to the returned array, which is itself
    an object, are maintained by the `ArrayList`. But the references to the individual
    `ArrayList` elements are copied to the returned array and are still referred to
    by the `ArrayList`.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是棘手的部分。`ArrayList` 不保留对返回数组的引用，该数组本身也是一个对象。但是，对`ArrayList`中各个元素的引用被复制到返回数组中，并且仍然由`ArrayList`引用。
- en: This implies that if you modify the returned array by, say, swapping the position
    of its elements or by assigning new objects to its elements, the elements of `ArrayList`
    won’t be affected. But if you modify the state of (mutable) elements of the returned
    array, then the modified state of elements will be reflected in the `ArrayList`.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果您通过交换元素位置或为其元素分配新对象等方式修改返回数组，`ArrayList` 的元素将不会受到影响。但是，如果您修改返回数组（可变）元素的状态，则修改后的元素状态将在
    `ArrayList` 中反映出来。
- en: 4.5\. Comparing objects for equality
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5. 比较对象是否相等
- en: '|  |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[3.2](kindle_split_014.html#ch03lev1sec2)] Test equality between Strings and
    other objects using == and equals()'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3.2](kindle_split_014.html#ch03lev1sec2)] 使用 == 和 equals() 测试字符串和其他对象之间的相等性'
- en: '|  |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In [section 4.1](kindle_split_015.html#ch04lev1sec1), you saw how the class
    `String` defined a set of rules to determine whether two `String` values are equal
    and how these rules were coded in the method `equals`. Similarly, any Java class
    can define a set of rules to determine whether its two objects should be considered
    equal. This comparison is accomplished using the method `equals`, which is described
    in the next section.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [4.1 节](kindle_split_015.html#ch04lev1sec1) 中，您看到了类 `String` 如何定义一组规则来确定两个
    `String` 值是否相等，以及这些规则如何在 `equals` 方法中编码。同样，任何Java类都可以定义一组规则来确定其两个对象是否应该被视为相等。这种比较是通过
    `equals` 方法完成的，该方法将在下一节中描述。
- en: 4.5.1\. The method equals in the class java.lang.Object
  id: totrans-731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1. 类 java.lang.Object 中的 equals 方法
- en: The method `equals` is defined in class `java.lang.Object`. All the Java classes
    directly or indirectly inherit this class. [Listing 4.2](#ch04lis02) contains
    the default implementation of the method `equals` from the class `java.lang.Object`.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `equals` 定义在类 `java.lang.Object` 中。所有Java类都直接或间接继承了这个类。[列表 4.2](#ch04lis02)
    包含了类 `java.lang.Object` 中方法 `equals` 的默认实现。
- en: Listing 4.2\. Implementation of `equals` method from class `java.lang.Object`
  id: totrans-733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2. 类 `java.lang.Object` 中 `equals` 方法的实现
- en: '[PRE29]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the default implementation of the `equals` method only compares
    whether two object variables refer to the same object. Because instance variables
    are used to store the state of an object, it’s common to compare the values of
    the instance variables to determine whether two objects should be considered equal.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`equals` 方法的默认实现仅比较两个对象变量是否引用了同一个对象。因为实例变量用于存储对象的状态，所以通常比较实例变量的值来确定两个对象是否应该被视为相等。
- en: 4.5.2\. Comparing objects of a user-defined class
  id: totrans-736
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2. 比较用户定义类的对象
- en: 'Let’s work with an example of the class `BankAccount`, which defines two instance
    variables: `acctNumber` of type `String`, and `acctType` of type `int`. The `equals`
    method compares the values of these instance variables to determine the equality
    of two objects of the class `BankAccount`.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以类 `BankAccount` 的一个示例来工作，该类定义了两个实例变量：`acctNumber` 类型为 `String`，`acctType`
    类型为 `int`。`equals` 方法比较这些实例变量的值以确定 `BankAccount` 类的两个对象是否相等。
- en: 'Here’s the relevant code:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相关的代码：
- en: '![](274fig01_alt.jpg)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![](274fig01_alt.jpg)'
- en: 'Let’s verify the working of this `equals` method in the following code:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下代码中验证这个 `equals` 方法的功能：
- en: '![](274fig02_alt.jpg)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
  zh: '![](274fig02_alt.jpg)'
- en: '![](num-1.jpg) prints `false` because the value of the reference variables
    `b1` and `b2` don’t match. ![](num-2.jpg) prints `true` because the values of
    the reference variables `b2` and `b3` match each other. ![](num-3.jpg) passes
    an object of type `String` to the method `equals` defined in the class `Bank-Account`.
    This method returns `false` if the method parameter passed to it is not of type
    `BankAccount`. Hence, ![](num-3.jpg) prints `false`.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 输出 `false`，因为引用变量 `b1` 和 `b2` 的值不匹配。![](num-2.jpg) 输出 `true`，因为引用变量
    `b2` 和 `b3` 的值彼此匹配。![](num-3.jpg) 将 `String` 类型的对象传递给在 `Bank-Account` 类中定义的 `equals`
    方法。如果传递给它的方法参数不是 `BankAccount` 类型，该方法返回 `false`。因此，![](num-3.jpg) 输出 `false`。'
- en: 'Even though the following implementation is unacceptable for classes used in
    the real world, it’s still correct syntactically:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 即使以下实现对于实际使用的类来说不可接受，它仍然是语法正确的：
- en: '[PRE30]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous definition of the `equals` method will return `true` for any object
    that’s compared to an object of the class `BankAccount` because it doesn’t compare
    any values. Let’s see what happens when you compare an object of the class `String`
    with an object of class `BankAccount` and vice versa using `equals()`:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的 `equals` 方法对于与 `BankAccount` 类的对象进行比较的任何对象都会返回 `true`，因为它不比较任何值。让我们看看当您使用
    `equals()` 方法比较 `String` 类型的对象与 `BankAccount` 类型的对象以及反之亦然时会发生什么：
- en: '![](275fig01_alt.jpg)'
  id: totrans-746
  prefs: []
  type: TYPE_IMG
  zh: '![](275fig01_alt.jpg)'
- en: In the preceding code, ![](num-1.jpg) prints `true`, but ![](num-2.jpg) prints
    `false`. The `equals` method in the class `String` returns `true` only if the
    object that’s being compared to is a `String` with the same sequence of characters.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，![](num-1.jpg) 输出 `true`，但 ![](num-2.jpg) 输出 `false`。`String` 类中的 `equals`
    方法仅在比较的对象是一个具有相同字符序列的 `String` 时返回 `true`。
- en: '|  |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: In the exam, watch out for questions about the correct implementation of the
    `equals` method (refer to [section 4.5.4](#ch04lev2sec27)) to compare two objects
    versus questions about the `equals` methods that simply compile correctly. If
    you’d been asked whether `equals()` in the previous example code would compile
    correctly, the correct answer would be yes.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，请注意关于正确实现 `equals` 方法的题目（参考[第4.5.4节](#ch04lev2sec27)），以比较两个对象，而不是关于简单编译正确的
    `equals` 方法的题目。如果您被问及之前示例代码中的 `equals()` 是否可以正确编译，正确答案应该是可以。
- en: '|  |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.5.3\. Incorrect method signature of the equals method
  id: totrans-752
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.3\. `equals` 方法的错误方法签名
- en: 'It’s a common mistake to write an `equals` method that accepts an instance
    of the class itself. In the following code, the class `BankAccount` doesn’t override
    `equals()`; it overloads it:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 编写接受自身类实例的 `equals` 方法是一个常见的错误。在下面的代码中，`BankAccount` 类没有重写 `equals()`，而是重载了它：
- en: '![](275fig02_alt.jpg)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![](275fig02_alt.jpg)'
- en: Although the previous definition of `equals()` may seem to be flawless, what
    happens when you try to add and retrieve an object of the class `BankAccount`
    (as shown in the preceding code) from an `ArrayList`? The method `contains` defined
    in the class `ArrayList` compares two objects by calling the object’s `equals`
    method. It does not compare object references.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前的 `equals()` 定义看起来似乎是完美的，但当您尝试将 `BankAccount` 类型的对象（如前述代码所示）添加到 `ArrayList`
    并检索时会发生什么？`ArrayList` 类中定义的 `contains` 方法通过调用对象的 `equals` 方法来比较两个对象。它不比较对象引用。
- en: 'In the following code, see what happens when you add an object of the class
    `Bank-Account` to an `ArrayList` and then try to verify whether the list contains
    a `BankAccount` object with the same instance variable’s values for `acctNumber`
    and `acctType` as the object being searched for:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，看看当您将 `Bank-Account` 类型的对象添加到 `ArrayList` 中，然后尝试验证列表是否包含与正在搜索的对象具有相同
    `acctNumber` 和 `acctType` 实例变量值的 `BankAccount` 对象时会发生什么：
- en: '![](276fig01_alt.jpg)'
  id: totrans-757
  prefs: []
  type: TYPE_IMG
  zh: '![](276fig01_alt.jpg)'
- en: '![](num-1.jpg) and ![](num-3.jpg) define objects `b1` and `b2` of the class
    `BankAccount` with the same state. ![](num-2.jpg) adds `b1` to the list. ![](num-4.jpg)
    compares the object `b2` with the objects added to the list.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '![](num-1.jpg) 和 ![](num-3.jpg) 定义了具有相同状态的 `BankAccount` 类的 `b1` 和 `b2` 对象。![](num-2.jpg)
    将 `b1` 添加到列表中。![](num-4.jpg) 将对象 `b2` 与列表中添加的对象进行比较。'
- en: An `ArrayList` uses the method `equals` to compare two objects. Because the
    class `BankAccount` didn’t follow the rules for correctly defining (overriding)
    the method `equals`, `ArrayList` uses the method `equals` from the base class
    `Object`, which compares object references. Because the code didn’t add `b2` to
    `list`, it prints `false`.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ArrayList`使用`equals`方法来比较两个对象。因为`BankAccount`类没有遵循正确定义（重写）`equals`方法的规则，所以`ArrayList`使用基类`Object`中的`equals`方法，该方法比较对象引用。因为代码没有将`b2`添加到`list`中，所以它打印出`false`。
- en: What do you think will be the output of the previous code if you change the
    definition of the method `equals` in the class `BankAccount` so that it accepts
    a method parameter of type `Object`? Try it for yourself!
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为如果改变`BankAccount`类中`equals`方法的定义，使其接受类型为`Object`的方法参数，之前的代码会输出什么？自己试一试！
- en: '|  |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The method `equals` defines a method parameter of type `Object`, and its return
    type is `boolean`. Don’t change the name of the method, its return type, or the
    type of method parameter when you define (*override*) this method in your class
    to compare two objects.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`方法定义了一个类型为`Object`的方法参数，其返回类型为`boolean`。当你定义（重写）此方法以比较两个对象时，不要更改方法名、返回类型或方法参数的类型。'
- en: '|  |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.5.4\. Contract of the equals method
  id: totrans-765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.4\. `equals`方法的约定
- en: The Java API defines a *contract* for the `equals` method, which should be taken
    care of when you implement it in any of your classes. I’ve pulled the following
    contract explanation directly from the Java API documentation:^([[1](#ch04fn01)])
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: Java API定义了`equals`方法的*约定*，当你在任何类中实现它时应该注意。以下合同说明直接来自Java API文档：^([[1](#ch04fn01)])
- en: ¹
  id: totrans-767
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The Java API documentation for `equals` can be found on the Oracle site: [http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)).'
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java API文档中关于`equals`方法的说明可以在Oracle网站上找到：[http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)).
- en: 'The `equals` method implements an equivalence relation on non-`null` object
    references:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`方法在非`null`对象引用上实现了一个等价关系：'
- en: '*It is reflexive: for any non-`null` reference value `x`, `x.equals(x)` should
    return `true`.*'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是自反的：对于任何非`null`引用值`x`，`x.equals(x)`应该返回`true`。*'
- en: '*It is symmetric: for any non-`null` reference values `x` and `y`, `x.equals(y)`
    should return `true` if and only if `y.equals(x)` returns `true`.*'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是对称的：对于任何非`null`引用值`x`和`y`，如果`y.equals(x)`返回`true`，则`x.equals(y)`也应该返回`true`。*'
- en: '*It is transitive: for any non-`null` reference values `x`, `y`, and `z`, if
    `x.equals(y)` returns `true` and `y.equals(z)` returns `true`, then `x.equals(z)`
    should return `true`.*'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是传递的：对于任何非`null`引用值`x`、`y`和`z`，如果`x.equals(y)`返回`true`且`y.equals(z)`返回`true`，则`x.equals(z)`应该返回`true`。*'
- en: '*It is consistent: for any non-`null` reference values `x` and `y`, multiple
    invocations of `x.equals(y)` consistently return `true` or consistently return
    `false`, provided no information used in `equals()` comparisons on the objects
    is modified.*'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是一致的：对于任何非`null`引用值`x`和`y`，多次调用`x.equals(y)`应始终返回`true`或始终返回`false`，前提是在对象上用于`equals()`比较的信息没有被修改。*'
- en: '*For any non-`null` reference value `x`, `x.equals(null)` should return `false`.*'
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对于任何非`null`引用值`x`，`x.equals(null)`应该返回`false`。*'
- en: 'As per the contract, the definition of the `equals` method that we defined
    for the class `BankAccount` in an earlier example violates the contract for the
    `equals` method. Take a look at the definition again:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 根据约定，我们在前面的示例中为`BankAccount`类定义的`equals`方法的定义违反了`equals`方法的约定。再次查看定义：
- en: '[PRE31]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code returns `true`, even for `null` values passed to this method. According
    to the contract of the method `equals`, if a `null` value is passed to the `equals`
    method, the method should return `false`.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 即使将`null`值传递给此方法，此代码也会返回`true`。根据`equals`方法的约定，如果将`null`值传递给`equals`方法，则该方法应返回`false`。
- en: '|  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You may get to answer explicit questions on the contract of the `equals` method.
    An `equals` method that returns `true` for a `null` object passed to it will violate
    the contract. Also, if the `equals` method modifies the value of any of the instance
    variables of the method parameter passed to it, or of the object on which it is
    called, it will violate the `equals` contract.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会回答关于 `equals` 方法契约的明确问题。如果一个 `equals` 方法对其传入的 `null` 对象返回 `true`，则违反了契约。此外，如果
    `equals` 方法修改了传递给它的方法参数的任何实例变量的值，或者修改了它被调用的对象上的值，它将违反 `equals` 契约。
- en: '|  |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The hashCode() method**'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '**hashCode() 方法**'
- en: A lot of programmers are confused about the role of the method `hashCode` in
    determining the equality of objects. The method `hashCode` is *not* called by
    the `equals` method to determine the equality of two objects. Because the `hashCode`
    method is not on the exam, I’ll discuss it quickly here to ward off any confusion
    about this method.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员对方法 `hashCode` 在确定对象相等性中的作用感到困惑。`hashCode` 方法不是由 `equals` 方法调用来确定两个对象的相等性的。因为
    `hashCode` 方法不在考试范围内，所以我将在这里简要讨论它，以消除对这种方法的任何混淆。
- en: The method `hashCode` is used by the collection classes (such as `HashMap`)
    that store *key*-*value* pairs, where a *key* is an object. These collection classes
    use the `hashCode` of a *key* to search efficiently for the corresponding *value*.
    The `hashCode` of the *key* (an object) is used to specify a *bucket* number,
    which should store its corresponding *value*. The `hashCode` values of two *distinct*
    objects can be the same. When these collection classes find the right bucket,
    they call the `equals` method to select the correct *value* object (that shares
    the same *key* values). The `equals` method is called even if a *bucket* contains
    only one object. After all, it might be the same hash but a different `equals`,
    and there is no match to get!
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashCode` 方法由存储 *键*-*值* 对的集合类（如 `HashMap`）使用，其中 *键* 是一个对象。这些集合类使用 *键* 的 `hashCode`
    来高效地搜索相应的 *值*。*键*（一个对象）的 `hashCode` 用于指定一个 *桶* 号，该 *桶* 应该存储其相应的 *值*。两个 *不同* 对象的
    `hashCode` 值可以相同。当这些集合类找到正确的 *桶* 时，它们将调用 `equals` 方法来选择正确的 *值* 对象（具有相同的 *键* 值）。即使
    *桶* 中只有一个对象，也会调用 `equals` 方法。毕竟，可能会有相同的哈希值但不同的 `equals`，而且没有匹配项可以获取！'
- en: According to the Java documentation, when you override the `equals` method in
    your class, you should also override the `hashCode` method. If you don’t, objects
    of your classes won’t behave as required if they’re used as *keys* by collection
    classes that store *key*-*value* pairs. This method is not discussed in detail
    in this chapter because it isn’t on the exam. But don’t forget to override it
    with the method `equals` in your real-world projects.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Java文档，当你在你自己的类中重写 `equals` 方法时，你也应该重写 `hashCode` 方法。如果你不这样做，如果你的类作为存储 *键*-*值*
    对的集合类（如 `HashMap`）的 *键* 使用，它们的行为将不会如预期。这个方法在本章中没有详细讨论，因为它不在考试范围内。但在你的实际项目中，不要忘记使用
    `equals` 方法重写它。
- en: '|  |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.6\. Working with calendar data
  id: totrans-789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 处理日历数据
- en: '|  |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[9.3] Create and manipulate calendar data using classes from java.time.LocalDateTime,
    java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter,
    java.time.Period3'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.3] 使用 `java.time.LocalDateTime`、`java.time.LocalDate`、`java.time.LocalTime`、`java.time.format.DateTimeFormatter`、`java.time.Period`
    类创建和操作日历数据'
- en: '|  |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The new Date and Time API in Java 8 simplifies working with date and time objects.
    It includes classes and interfaces with simple and informative method names. As
    you work with the classes `LocalDate`, `LocalTime`, `LocalDateTime`, `Period`,
    and `DateTimeFormatter` in this section, you’ll notice that these classes define
    methods with similar names (which have similar purposes). [Table 4.1](#ch04table01)
    lists the method prefix, its type, and its use (from Oracle Java documentation).
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 中的新日期和时间 API 简化了日期和时间对象的处理。它包括具有简单和有信息性的方法名称的类和接口。当你在本节中使用 `LocalDate`、`LocalTime`、`LocalDateTime`、`Period`
    和 `DateTimeFormatter` 类时，你会注意到这些类定义了具有相似名称（具有相似目的）的方法。[表 4.1](#ch04table01) 列出了方法前缀、其类型及其用途（来自
    Oracle Java 文档）。
- en: Table 4.1\. Method prefixes, types, and their uses in the Date and Time API
    in Java 8
  id: totrans-794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. Java 8 日期和时间 API 中的方法前缀、类型及其用途
- en: '| Prefix | Method type | Use |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 方法类型 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-796
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| of | static | Creates an instance where the factory is primarily validating
    the input parameters, not converting them. |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '| of | static | 创建一个实例，其中工厂主要验证输入参数，而不是转换它们。|'
- en: '| from | static | Converts the input parameters to an instance of the target
    class, which may involve losing information from the input. |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| from | static | 将输入参数转换为目标类的实例，这可能涉及从输入中丢失信息。|'
- en: '| parse | static | Parses the input string to produce an instance of the target
    class. |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '| parse | static | 将输入字符串解析为目标类的实例。|'
- en: '| format | instance | Uses the specified formatter to format the values in
    the temporal object to produce a string. |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '| format | instance | 使用指定的格式化程序将时间对象中的值格式化为字符串。|'
- en: '| get | instance | Returns a part of the state of the target object. |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '| get | instance | 返回目标对象状态的一部分。|'
- en: '| is | instance | Queries the state of the target object. |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| is | instance | 查询目标对象的状态。|'
- en: '| with | instance | Returns a copy of the target object with one element changed;
    this is the immutable equivalent to a set method on a JavaBean. |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| with | instance | 返回一个副本的目标对象，其中一个元素已更改；这是JavaBean上set方法的不可变等效。|'
- en: '| plus | instance | Returns a copy of the target object with an amount of time
    added. |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
  zh: '| plus | instance | 返回添加了时间量的目标对象的一个副本。|'
- en: '| minus | instance | Returns a copy of the target object with an amount of
    time subtracted. |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '| minus | instance | 返回从目标对象中减去时间量后的副本。|'
- en: '| to | instance | Converts this object to another type. |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '| to | instance | 将此对象转换为另一种类型。|'
- en: '| at | instance | Combines this object with another. |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '| at | instance | 将此对象与另一个对象组合。|'
- en: '|  |'
  id: totrans-808
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-809
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding table might not *seem* to add a lot of value at this point. But
    as you go through the following sections, you’ll realize the similarity in the
    names of the methods that are defined in the date and time classes.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格可能在此点看起来没有增加太多价值。但随着您进入以下部分，您将意识到在日期和时间类中定义的方法名称的相似性。
- en: '|  |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s get started with the class `LocalDate`.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`LocalDate`类开始。
- en: 4.6.1\. LocalDate
  id: totrans-813
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.1\. LocalDate
- en: To store dates like a birthday or anniversary, visiting a place, or starting
    a job, school, or college, you don’t need to store the time. `LocalDate` will
    work perfectly in this case.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储像生日或周年纪念日、参观某个地方或开始工作、学校或大学这样的日期，您不需要存储时间。在这种情况下，`LocalDate`将完美工作。
- en: '`LocalDate` can be used to store dates like 2015-12-27 without time or time
    zones. `LocalDate` instances are immutable and hence safe to be used in a multithreaded
    environment.'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate`可以用来存储没有时间或时区的日期，如2015-12-27。`LocalDate`实例是不可变的，因此在多线程环境中使用是安全的。'
- en: Creating LocalDate
  id: totrans-816
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建`LocalDate`
- en: 'The `LocalDate` constructor is marked private, so you must use one of the factory
    methods to instantiate it. The static method `of()` accepts year, month, and day
    of month:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate`构造函数被标记为私有，因此您必须使用其中一个工厂方法来实例化它。静态方法`of()`接受年、月和月份：'
- en: '![](279fig01_alt.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![](279fig01_alt.jpg)'
- en: '|  |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the new Date and Time API, introduced with Java 8, January is represented
    by `int` value `1` and not `0`. The old Calendar-based API hasn’t changed in Java
    8 and still uses 0-based month numbering.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中引入的新日期和时间API中，1月由`int`类型的值`1`表示，而不是`0`。基于旧日历的API在Java 8中没有改变，仍然使用基于0的月份编号。
- en: '|  |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To get the current date from the system clock, use the static method `now()`:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 要从系统时钟获取当前日期，请使用静态方法`now()`：
- en: '[PRE32]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also parse a string in the format 2016-02-27 to instantiate `LocalDate`.
    Here’s an example:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以解析格式为2016-02-27的字符串来实例化`LocalDate`。以下是一个示例：
- en: '[PRE33]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: If you pass invalid values to `parse()` or `of()`, you’ll get `DateTimeParseException`.
    The format of the string passed to `parse()` must be exactly of the format 9999-99-99\.
    The month and date values passed to `parse()` must be of two digits; a single
    digit is considered an invalid value. For days and months with values 1–9, pass
    01–09.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向`parse()`或`of()`传递无效值，您将得到`DateTimeParseException`。传递给`parse()`的字符串格式必须正好是9999-99-99的格式。传递给`parse()`的月份和日期值必须是两位数字；单个数字被视为无效值。对于值为1-9的天和月，传递01-09。
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Querying LocalDate
  id: totrans-831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询`LocalDate`
- en: 'You can use instance methods like `get`*`XX`*`()` to query `LocalDate` on its
    year, month, and date values. The date can be queried as day-of-month, day-of-week,
    and day-of-year. The month value can be retrieved as the enum constant `Month`
    or as an `int` value:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用实例方法如`get`*`XX`*`()`来查询`LocalDate`的年、月和日期值。日期可以查询为月份中的日、周中的日和年中的日。月份值可以检索为枚举常量`Month`或`int`值：
- en: '[PRE34]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the preceding code looks like this:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下所示：
- en: '[PRE35]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can use the instance methods `isAfter()` or `isBefore()` to determine whether
    a date is chronologically before or after another date:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用实例方法 `isAfter()` 或 `isBefore()` 来确定一个日期是否在时间上早于或晚于另一个日期：
- en: '![](280fig01_alt.jpg)'
  id: totrans-837
  prefs: []
  type: TYPE_IMG
  zh: '![](280fig01_alt.jpg)'
- en: Manipulating LocalDate
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作 LocalDate
- en: 'The `LocalDate` class defines methods with the names `minus`*`XX`*`()`, `plus`*`XX`*`()`,
    and `with`*`XX`*`()` to manipulate the date values. The API architects have used
    the names that make their purpose explicit. Because `LocalDate` is an immutable
    class, all the methods create and return a copy. The `minus`*`XX`*`()` methods
    return a copy of the date with the specified days, months, or years subtracted
    from it:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate` 类定义了名为 `minus`*`XX`*`()`、`plus`*`XX`*`()` 和 `with`*`XX`*`()` 的方法来操作日期值。API
    架构师使用了使它们的目的明确化的名称。因为 `LocalDate` 是一个不可变类，所以所有的方法都会创建并返回一个副本。`minus`*`XX`*`()`
    方法返回一个副本的日期，从其中减去指定的天数、月份或年份：'
- en: '[PRE36]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面代码的输出：
- en: '[PRE37]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|  |'
  id: totrans-843
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: '`LocalDate` is immutable. All the methods that seem to manipulate its value
    return a copy of the `LocalDate` instance on which it’s called.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate` 是不可变的。所有看似操作其值的方法都会返回它被调用的 `LocalDate` 实例的副本。'
- en: '|  |'
  id: totrans-846
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The `plus`*`XX`*`()` methods return a copy of the date instance after adding
    the specified days, months, or years to it:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '`plus`*`XX`*`()` 方法在向日期实例添加指定的天数、月份或年份后返回日期实例的副本：'
- en: '[PRE38]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面代码的输出：
- en: '[PRE39]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|  |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: All additions, subtractions, or replacements to `LocalDate` consider leap years.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对 `LocalDate` 的添加、减法或替换都考虑闰年。
- en: '|  |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The `with`*`XX`*`()` methods return a copy of the date instance replacing the
    specified day, month, or year in it:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`*`XX`*`()` 方法返回日期实例的副本，替换其中的指定日、月或年：'
- en: '[PRE40]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the preceding code looks like this:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下所示：
- en: '[PRE41]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Converting to another type
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换为其他类型
- en: The `LocalDate` class defines methods to convert it to `LocalDateTime` and `long`
    (representing the epoch date).
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate` 类定义了将其转换为 `LocalDateTime` 和 `long`（表示纪元日期）的方法。'
- en: 'The `LocalDate` class defines overloaded `atTime()` instance methods. These
    methods combine `LocalDate` with time to create and return `LocalDateTime`, which
    stores both the date and time (the `LocalDateTime` class is covered in the next
    section):'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate` 类定义了重载的 `atTime()` 实例方法。这些方法将 `LocalDate` 与时间结合，创建并返回 `LocalDateTime`，它存储日期和时间（`LocalDateTime`
    类将在下一节中介绍）：'
- en: '[PRE42]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面代码的输出：
- en: '[PRE43]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: If you pass any invalid hours, minutes, or seconds value to the method `atTime`,
    it will throw a `DateTimeException` at runtime.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将任何无效的小时、分钟或秒值传递给 `atTime` 方法，它将在运行时抛出 `DateTimeException`。
- en: '|  |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can use the method `toEpochDay()` to convert `LocalDate` to the *epoch
    date*—the count of days from January 1, 1970:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `toEpochDay()` 方法将 `LocalDate` 转换为 *纪元日期*——从1970年1月1日起的天数计数：
- en: '[PRE44]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面代码的输出：
- en: '[PRE45]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In standard date and time, the *epoch date* refers to January 1, 1970, 00:00:00
    GMT.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准日期和时间中，*纪元日期*指的是1970年1月1日 00:00:00 GMT。
- en: '|  |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.6.2\. LocalTime
  id: totrans-877
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.2\. LocalTime
- en: To store times like breakfast, conference talk start time, or in-store sale
    end time, you can use `LocalTime`. It stores time in the format hours-minutes-seconds
    (without a time zone) and to nanosecond precision. So you’re sure to see methods
    that accept nanoseconds as method arguments or methods that return this value.
    Like `LocalDate`, `LocalTime` is also immutable and hence safe to be used in a
    multithreaded environment.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储像早餐、会议演讲开始时间或在店销售结束时间这样的时间，您可以使用 `LocalTime`。它以小时-分钟-秒（不带时区）的格式存储时间，并精确到纳秒。因此，您肯定会看到接受纳秒作为方法参数的方法或返回此值的方法。像
    `LocalDate` 一样，`LocalTime` 也是不可变的，因此在多线程环境中使用是安全的。
- en: Creating LocalTime
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建 LocalTime
- en: 'The `LocalTime` constructor is private, so you must use one of the factory
    methods to instantiate it. The static method `of()` accepts hours, minutes, seconds,
    and nanoseconds:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime` 构造函数是私有的，因此您必须使用其中一个工厂方法来实例化它。静态方法 `of()` 接受小时、分钟、秒和纳秒：'
- en: '![](282fig01_alt.jpg)'
  id: totrans-881
  prefs: []
  type: TYPE_IMG
  zh: '![](282fig01_alt.jpg)'
- en: 'The `of()` method uses a 24-hour clock to specify the hour value. What happens
    if you pass out-of-range values for hours, minutes, or seconds to `of()`? In this
    case, you’ll get a runtime exception, `DateTimeException`. You’ll get a compiler
    error if the range of values passed to a method doesn’t comply with the method’s
    argument type. Here’s an example:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`of()`方法使用24小时制来指定小时值。如果您向`of()`传递超出范围的小时、分钟或秒值，会发生什么？在这种情况下，您将得到一个运行时异常，`DateTimeException`。如果传递给方法的值范围不符合方法的参数类型，您将得到编译错误。以下是一个示例：'
- en: '![](282fig02_alt.jpg)'
  id: totrans-883
  prefs: []
  type: TYPE_IMG
  zh: '![](282fig02_alt.jpg)'
- en: '|  |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: '`LocalTime` doesn’t define a method to pass a.m. or p.m. Use values 0–23 to
    define hours. If you pass out-of-range values to either hours, minutes, or seconds,
    you’ll get a runtime exception.'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime`没有定义用于传递上午或下午的方法。使用0–23的值来定义小时。如果您向小时、分钟或秒传递超出范围的值，您将得到一个运行时异常。'
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To get the current time from the system clock, use the static method `now()`:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 要从系统时钟获取当前时间，请使用静态方法`now()`：
- en: '[PRE46]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can parse a string to instantiate `LocalTime` by using its static method
    `parse()`. You can either pass a string in the format 15:08:23 (hours:minutes:seconds)
    or parse any text using `DateTimeFormatter` (covered in the next section):'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`LocalTime`的静态方法`parse()`将字符串解析为`LocalTime`实例。您可以选择传递格式为15:08:23（小时:分钟:秒）的字符串，或者使用`DateTimeFormatter`（下一节介绍）解析任何文本：
- en: '[PRE47]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: If you pass invalid string values to `parse()`, the code will compile but will
    throw a runtime exception. If you don’t pass a `DateTimeFormatter`, the format
    of the string passed to `parse()` must be exactly of the format 99:99:99\. The
    hours and minutes values passed to `parse()` must be two digits; a single digit
    is considered an invalid value. For hours and minutes with the value 0–9, pass
    00–09.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向`parse()`传递无效的字符串值，代码将编译但会抛出运行时异常。如果您没有传递`DateTimeFormatter`，传递给`parse()`的字符串格式必须正好是99:99:99的格式。传递给`parse()`的小时和分钟值必须是两位数字；单个数字被视为无效值。对于值为0–9的小时和分钟，传递00–09。
- en: '|  |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using LocalTime constants
  id: totrans-896
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用本地时间常量
- en: 'You can use constants from the `LocalTime` class to work with predefined times:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`LocalTime`类中的常量来处理预定义的时间：
- en: '`LocalTime.MIN`—Minimum supported time, that is, 00:00'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.MIN`—支持的最小时间，即00:00'
- en: '`LocalTime.MAX`—Maximum supported time, that is, 23:59:59.999999999'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.MAX`—支持的最大时间，即23:59:59.999999999'
- en: '`LocalTime.MIDNIGHT`—Time when the day starts, that is, 00:00'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.MIDNIGHT`—一天开始的时间，即00:00'
- en: '`LocalTime.NOON`—Noontime, that is, 12:00'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.NOON`—中午时间，即12:00'
- en: 'Does that make you wonder whether the minimum and midnight times are equal?
    See for yourself; the following code outputs `true`:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否让你想知道最小时间和午夜时间是否相等？亲自看看吧；以下代码输出`true`：
- en: '![](283fig01_alt.jpg)'
  id: totrans-903
  prefs: []
  type: TYPE_IMG
  zh: '![](283fig01_alt.jpg)'
- en: Querying LocalTime
  id: totrans-904
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询本地时间
- en: 'You can use instance methods like `get`*`XX`*`()` to query `LocalTime` on its
    hour, minutes, seconds, and nanoseconds. All these methods return an `int` value:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似`get`*`XX`*`()`的实例方法查询`LocalTime`的小时、分钟、秒和纳秒。所有这些方法都返回一个`int`值：
- en: '[PRE48]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s the output:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE49]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The correct method names for querying `LocalTime` are `get-Hour()`, `getMinute()`,
    `getSecond()`, and `getNano()`. Watch out for exam questions that use invalid
    method names like *getHours()*, *getMinutes()*, *getSeconds(),* or *getNanoSeconds()*.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 查询`LocalTime`的正确方法名是`get-Hour()`、`getMinute()`、`getSecond()`和`getNano()`。注意考试中可能会使用无效的方法名，如*getHours()*,
    *getMinutes()*, *getSeconds(),* 或 *getNanoSeconds()*。
- en: '|  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can use the instance methods `isAfter()` and `isBefore()` to check whether
    a time is after or before the specified time. The following code outputs `true`:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用实例方法`isAfter()`和`isBefore()`来检查时间是否在指定时间之后或之前。以下代码输出`true`：
- en: '![](284fig01_alt.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![](284fig01_alt.jpg)'
- en: Manipulating LocalTime
  id: totrans-915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作本地时间
- en: 'You can use the instance methods `minusHours()`, `minusMinutes()`, `minusSeconds()`,
    and `minusNanos()` to create and return a copy of `LocalTime` instances with the
    specified period subtracted. The method names are self-explanatory. For example,
    `minus-Hours(int)` returns a copy of a `LocalTime` instance with the specified
    period in hours subtracted. The following example calculates and outputs the time
    when Shreya should leave from her office to watch a movie, given that the movie
    starts at 21:00 hours and it takes 35 minutes to commute to the movie theater:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用实例方法`minusHours()`、`minusMinutes()`、`minusSeconds()`和`minusNanos()`来创建并返回具有指定时间段减去的`LocalTime`实例的副本。方法名称是自解释的。例如，`minus-Hours(int)`返回一个在指定时间段内减去小时的`LocalTime`实例的副本。以下示例计算并输出Shreya应该离开办公室去看电影的时间，假设电影在21:00小时开始，通勤到电影院需要35分钟：
- en: '[PRE50]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '[PRE51]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: 'Unlike the `get`*`XXX`*`()` methods, `minus`*`XXX`*`()` methods use the plural
    form: `getHour()` versus `minusHours()`, `getMinute()` versus `minusMinutes()`,
    `getSecond()` versus `minusSeconds()`, and `getNano()` versus `minusNanos()`.'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 与`get`*`XXX`*`()`方法不同，`minus`*`XXX`*`()`方法使用复数形式：`getHour()`与`minusHours()`，`getMinute()`与`minusMinutes()`，`getSecond()`与`minusSeconds()`，以及`getNano()`与`minusNanos()`。
- en: '|  |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `plusHours()`, `plusMinutes()`, `plusSeconds()`, and `plusNanos()` methods
    accept `long` values and add the specified hours, minutes, seconds, or nanoseconds
    to time, returning its copy as `LocalTime`. The following example uses the `addSeconds()`
    and `isAfter()` methods to add seconds to a time and compares it with another
    time:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '`plusHours()`、`plusMinutes()`、`plusSeconds()`和`plusNanos()`方法接受`long`值，并将指定的小时、分钟、秒或纳秒添加到时间中，返回其副本作为`LocalTime`。以下示例使用`addSeconds()`和`isAfter()`方法向时间添加秒，并将其与另一个时间进行比较：'
- en: '[PRE52]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output of the preceding code looks like this:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出如下：
- en: '[PRE53]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|  |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-929
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: '`LocalTime` is immutable. Calling any method on its instance won’t modify its
    value.'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime`是不可变的。对其实例调用任何方法都不会修改其值。'
- en: '|  |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `withHour()`, `withMinute()`, `withSecond()`, and `withNano()` methods
    accept an `int` value and return a copy of `LocalTime` with the specified value
    altered. In the following example, a new `LocalTime` instance with the minute
    value `00` is created:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '`withHour()`、`withMinute()`、`withSecond()`和`withNano()`方法接受一个`int`值，并返回一个具有指定值更改的`LocalTime`副本。以下示例创建了一个新的`LocalTime`实例，其分钟值为`00`：'
- en: '[PRE54]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here’s the output:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE55]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Combining with another type
  id: totrans-936
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与其他类型的组合
- en: 'The `LocalTime` class defines the `atDate()` method to combine a `LocalDate`
    with itself to create `LocalDateTime`:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime`类定义了`atDate()`方法，用于将`LocalDate`与自身结合以创建`LocalDateTime`：'
- en: '[PRE56]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here’s the output:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE57]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-942
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The class `LocalTime` defines the method `atDate()`, which can be passed a `LocalDate`
    instance to create a `LocalDateTime` instance.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime`类定义了`atDate()`方法，该方法可以传入一个`LocalDate`实例来创建一个`LocalDateTime`实例。'
- en: '|  |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.6.3\. LocalDateTime
  id: totrans-945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.3\. LocalDateTime
- en: If you want to store both date and time (without the time zone), use the class
    `LocalDateTime`. It stores a value like `2050-06-18T14:20:30:908765` (year-month-day**T**hours:minutes:seconds:nanoseconds).
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想存储日期和时间（不含时区），请使用`LocalDateTime`类。它存储的值类似于`2050-06-18T14:20:30:908765`（年-月-日**T**小时:分钟:秒:纳秒）。
- en: '|  |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `LocalDateTime` class uses the letter *T* to separate date and time values
    in its printed value.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDateTime`类使用字母*T*在其打印值中分隔日期和时间值。'
- en: '|  |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can consider this class to offer the functionality of both the `LocalDate`
    and `Local-Time` classes. This class defines similar methods as those defined
    by the `LocalDate` and `LocalTime` classes. So instead of discussing individual
    methods of this class, here’s an example that covers the important methods of
    this class:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此类视为`LocalDate`和`Local-Time`类功能的结合。此类定义了与`LocalDate`和`LocalTime`类中定义的类似方法。因此，而不是讨论此类中单个方法，以下是一个涵盖此类重要方法的示例：
- en: '![](286fig01_alt.jpg)'
  id: totrans-952
  prefs: []
  type: TYPE_IMG
  zh: '![](286fig01_alt.jpg)'
- en: In the next section, you’ll discover how you can perform calculations with date
    and time using the `Period` class.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解如何使用`Period`类进行日期和时间的计算。
- en: 4.6.4\. Period
  id: totrans-954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.4\. Period
- en: People often talk about periods of years, months, or days. With the Java 8 Date
    API, you can use the `Period` class to do so. The `Period` class represents a
    date-based amount in years, months, and days, like 2 years, 5 months, and 10 days.
    To work with a time-based amount in seconds and nanoseconds, you can use the `Duration`
    class.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常谈论年、月或日的周期。使用 Java 8 Date API，你可以使用 `Period` 类来这样做。`Period` 类表示基于日期的年、月和日的时间量，如
    2 年、5 个月和 10 天。要处理基于秒和纳秒的时间量，你可以使用 `Duration` 类。
- en: '|  |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `Duration` class can be used to store amounts of time like 1 hour, 36 minutes,
    or 29.4 seconds. But this class isn’t explicitly covered in this exam (and this
    book). It’s covered in the OCP Java SE 8 Programmer II exam.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duration` 类可以用来存储像 1 小时、36 分钟或 29.4 秒这样的时间量。但这个类在本考试（和本书）中并没有明确介绍。它包含在 OCP
    Java SE 8 Programmer II 考试中。'
- en: '|  |'
  id: totrans-959
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can add or subtract `Period` instances from the `LocalDate` and `LocalDateTime`
    classes. `Period` is also an immutable class and hence safe to use in a multithreaded
    environment. Let’s get started by instantiating `Period`.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 `LocalDate` 和 `LocalDateTime` 类中添加或减去 `Period` 实例。`Period` 也是一个不可变类，因此在多线程环境中使用是安全的。让我们通过实例化
    `Period` 开始吧。
- en: Instantiating Period
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实例化 Period
- en: 'With a private constructor, the `Period` class defines multiple factory methods
    to create its instances. The static methods `of()`, `ofYears()`, `ofMonths()`,
    `ofWeeks()`, and `ofDays()` accept `int` values to create periods of years, months,
    weeks, or days:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有构造函数，`Period` 类定义了多个工厂方法来创建其实例。静态方法 `of()`、`ofYears()`、`ofMonths()`、`ofWeeks()`
    和 `ofDays()` 接受 `int` 值来创建年、月、周或日的周期：
- en: '![](286fig02_alt.jpg)'
  id: totrans-963
  prefs: []
  type: TYPE_IMG
  zh: '![](286fig02_alt.jpg)'
- en: '|  |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-965
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: A period of 35 days is not stored as 1 month and 5 days. Its individual elements,
    that is, days, months, and years, are stored the way it is initialized.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 35 天的周期不是存储为 1 个月和 5 天。它的各个元素，即日、月和年，是以初始化的方式存储的。
- en: '|  |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can also define negative periods by passing negative integer values to
    all the preceding methods. Here’s a quick example:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过向所有前面的方法传递负整数来定义负数周期。以下是一个快速示例：
- en: '![](287fig01_alt.jpg)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
  zh: '![](287fig01_alt.jpg)'
- en: '|  |'
  id: totrans-970
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-971
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: You can define positive or negative periods of time. For example, you can define
    `Period` instances representing 15 or -15 days.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义正数或负数的时间周期。例如，你可以定义代表 15 或 -15 天的 `Period` 实例。
- en: '|  |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can also parse a string to instantiate `Period` by using its static method
    `parse`. This method parses string values of the format *PnYnMnD* or *PnW*, where
    *n* represents a number and the letters (*P*, *Y*, *M*, *D*, and *W*) represent
    parse, year, month, day, and week. These letters can exist in lower- or uppercase.
    Each string must start with the letter *p* or *P* and must include at least one
    of the four sections, that is, year, month, week, or day. For the string format
    PnW, the count of weeks is multiplied by 7 to get the number of days. You can
    also define negative periods using `parse()`. If you precede the complete string
    value passed to `parse()` with a negative sign (-), it’s applied to all values.
    If you place a negative sign just before an individual number, it applies only
    to that section. Here are some examples to instantiate a period of five years
    (notice the use of uppercase and lowercase letters and + and – signs):'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用其静态方法 `parse` 通过解析字符串来实例化 `Period`。此方法解析格式为 *PnYnMnD* 或 *PnW* 的字符串值，其中
    *n* 代表一个数字，而字母 (*P*, *Y*, *M*, *D*, 和 *W*) 分别代表解析、年、月、日和周。这些字母可以是大写或小写。每个字符串必须以字母
    *p* 或 *P* 开头，并且必须包含至少四个部分之一，即年、月、周或日。对于字符串格式 PnW，周的数量乘以 7 以得到天数。你还可以使用 `parse()`
    定义负数周期。如果你在传递给 `parse()` 的完整字符串值之前加上负号 (-)，则它应用于所有值。如果你在单个数字之前放置一个负号，则它仅应用于该部分。以下是一些实例化五年周期的示例（注意大小写字母和
    + 和 – 符号的使用）：
- en: '![](287fig02_alt.jpg)'
  id: totrans-975
  prefs: []
  type: TYPE_IMG
  zh: '![](287fig02_alt.jpg)'
- en: 'The following examples define periods of separate durations:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了不同持续时间的周期：
- en: '[PRE58]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When passed to `System.out.println()`, the variables in the preceding code
    will result in the following output:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递给 `System.out.println()` 时，前面代码中的变量将产生以下输出：
- en: '[PRE59]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|  |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: If you pass invalid string values to `parse()`, the code will compile but will
    throw a runtime exception.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 `parse()` 传递无效的字符串值，代码将编译但会抛出运行时异常。
- en: '|  |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can also use the static method `between(LocalDate dateInclusive, LocalDate
    dateExclusive)` to instantiate `Period`:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用静态方法 `between(LocalDate dateInclusive, LocalDate dateExclusive)` 来实例化
    `Period`：
- en: '![](288fig01_alt.jpg)'
  id: totrans-985
  prefs: []
  type: TYPE_IMG
  zh: '![](288fig01_alt.jpg)'
- en: '|  |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: 'The static method `between` accepts two `LocalDate` instances and returns a
    `Period` instance representing the number of years, days, and months between the
    two dates. The first date is included, but the second date is excluded in the
    returned `Period`. Here’s a quick way to remember it: period = end date – start
    date.'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`between`接受两个`LocalDate`实例，并返回一个表示两个日期之间年、日和月数的`Period`实例。返回的`Period`中包含第一个日期，但不包含第二个日期。这里有一个快速记住它的方法：周期
    = 结束日期 - 开始日期。
- en: '|  |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Manipulating LocalDate and LocalDateTime using Period
  id: totrans-990
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用周期操作`LocalDate`和`LocalDateTime`
- en: 'In everyday life, it’s common to add or subtract periods of days, months, or
    years from a date. The `Period` class implements the interface `TemporalAmount`,
    so it can be used with the methods `plus()` and `minus()` defined in the classes
    `LocalDateTime` and `LocalDate`. The following example adds a period of a day
    to a `LocalDate` instance:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常生活中，从日期中添加或减去天数、月数或年数是很常见的。`Period`类实现了`TemporalAmount`接口，因此可以使用`LocalDateTime`和`LocalDate`类中定义的`plus()`和`minus()`方法。以下示例向`LocalDate`实例添加一个周期：
- en: '[PRE60]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '[PRE61]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'What happens when you add a period of a month to January 31 of any year? Do
    you get the last day of February or the first day of March? The following example
    adds a period of a month to a `LocalDateTime` instance:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向任何年份的1月31日添加一个周期时会发生什么？您会得到2月的最后一天还是3月的第一天？以下示例向`LocalDateTime`实例添加一个周期：
- en: '[PRE62]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output of the preceding code looks like this:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '[PRE63]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|  |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Because `Period` instances can represent positive or negative periods (like
    15 days or -15 days), you can subtract days from a `LocalDate` or `LocalDateTime`
    by calling the method `plus`.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Period`实例可以表示正数或负数周期（如15天或-15天），所以您可以通过调用`plus`方法从`LocalDate`或`LocalDateTime`中减去天数。
- en: '|  |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Similarly, you can use the method `minus()` with the classes `LocalDate` and
    `LocalDateTime` to subtract a period of years, months, weeks, or days:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以使用`minus()`方法与`LocalDate`和`LocalDateTime`类一起使用，以减去年、月、周或天数：
- en: '[PRE64]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here’s the output:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE65]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Querying Period instances
  id: totrans-1007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询周期实例
- en: 'You can use the instance methods `getYears()`, `getMonths()`, and `getDays()`
    to query a `Period` instance on its years, months, and days. All these methods
    return an `int` value:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用实例方法`getYears()`、`getMonths()`和`getDays()`来查询`Period`实例的年、月和日。所有这些方法都返回一个`int`值：
- en: '[PRE66]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The preceding code outputs the following:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出以下内容：
- en: '[PRE67]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|  |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When you initialize a `Period` instance with days more than 31 or months more
    than 12, it doesn’t recalculate its years, months, or days components-.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用超过31天的天数或超过12个月的月份初始化`Period`实例时，它不会重新计算其年、月或日组件-。
- en: '|  |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can query whether any of three units of a `Period` is negative using the
    methods `isNegative` and `isZero`. A `Period` instance is zero if all three units
    are zero. The `isNegative` method returns `true` if at least one of its three
    components is strictly negative (<0):'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`isNegative`和`isZero`方法查询一个`Period`周期的三个单位中是否有任何一个为负。如果三个单位都为零，则`Period`实例为零。`isNegative`方法如果其三个组件中至少有一个是严格负数（<0）则返回`true`：
- en: '![](289fig01_alt.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![](289fig01_alt.jpg)'
- en: Manipulating Period
  id: totrans-1018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作周期
- en: 'You can use the instance methods `minus(TemporalAmount)`, `minusDays(long)`,
    `minus-Weeks(long)`, `minusMonths(long)`, `minusYears(long)`, and `multipliedBy(int)`
    to create and return a copy of `Period` instances with the specified period subtracted
    or modified. The method names are self-explanatory. For an example, `minusDays(long)`
    returns a copy of a `Period` instance with the specified days subtracted. You
    can use the following example to send out reminders to your friends (limited to
    printing a message) for an event, say a birthday celebration, if it’s due in 10
    days:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用实例方法`minus(TemporalAmount)`、`minusDays(long)`、`minusWeeks(long)`、`minusMonths(long)`、`minusYears(long)`和`multipliedBy(int)`来创建并返回具有指定周期减去或修改的`Period`实例的副本。方法名称是自解释的。例如，`minusDays(long)`返回一个从指定天数减去的`Period`实例的副本。您可以使用以下示例在10天后向您的朋友发送提醒（限于打印消息）以提醒一个事件，比如生日庆祝活动：
- en: '[PRE68]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|  |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: 'In the class `Period`, both the `get`*`XXX`*`()` methods and `minus`*`XXX`*`()`
    methods use the plural form: `getYears()`, `minusHours()`.'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Period`类中，`get`*`XXX`*`()`方法和`minus`*`XXX`*`()`方法都使用复数形式：`getYears()`、`minusHours()`。
- en: '|  |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'What happens when you subtract a `Period` representing one month (`P1M`) from
    a `Period` representing 10 days (`P10D`)? Would you get a `Period` representing
    20 days or a `Period` representing -1 month and 10 days? Let’s find out using
    the following code, which also includes quick sample code on the usage of all
    the `minus`*`XXX`* methods:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个代表一个月的 `Period`（`P1M`）减去一个代表 10 天的 `Period`（`P10D`）时会发生什么？你会得到一个代表 20 天的
    `Period` 或一个代表 -1 个月和 10 天的 `Period`？让我们通过以下代码来找出答案，该代码还包括所有 `minus`*`XXX`* 方法的快速示例代码：
- en: '[PRE69]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here’s the output:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE70]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|  |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When you subtract `Period` instances using the `minus`*`XXX`*`()` methods, the
    individual elements are subtracted. Subtracting `P10D` from `P1M` returns `P1M-10D`
    and not `P20D`.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `minus`*`XXX`*`()` 方法减去 `Period` 实例时，将分别减去各个元素。从 `P1M` 减去 `P10D` 返回 `P1M-10D`，而不是
    `P20D`。
- en: '|  |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `Period` class defines `multipliedBy(int)`, which multiplies each element
    in the period by the integer value:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period` 类定义了 `multipliedBy(int)` 方法，该方法将周期中的每个元素乘以整数值：'
- en: '![](290fig01_alt.jpg)'
  id: totrans-1034
  prefs: []
  type: TYPE_IMG
  zh: '![](290fig01_alt.jpg)'
- en: '|  |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-1036
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The method `multipliedBy(int)` in the class `Period` is used to modify all elements
    of a `Period` instance. `Period` doesn’t define a “divideBy()” method. Both the
    `get`*`XXX`*`()` methods and `minus`*`XXX`*`()` methods use the plural form `getYears()`,
    `minusHours()`.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period` 类中的 `multipliedBy(int)` 方法用于修改 `Period` 实例的所有元素。`Period` 没有定义 “divideBy()”
    方法。`get`*`XXX`*`()` 方法和 `minus`*`XXX`*`()` 方法都使用复数形式 `getYears()`、`minusHours()`。'
- en: '|  |'
  id: totrans-1038
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `plus(TemporalAmount)`, `plusDays(long)`, `plusWeeks(long)`, `plusMonths(long)`,
    and `plusYears(long)` methods add to `Period` instances and return the modified
    value as a `Period`. Like the `minus`*`XXX`*`()` methods, all the `plus`*`XXX`*`()`
    methods add individual elements:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '`plus(TemporalAmount)`、`plusDays(long)`、`plusWeeks(long)`、`plusMonths(long)`
    和 `plusYears(long)` 方法将 `Period` 实例添加到 `Period` 实例中，并返回修改后的值作为 `Period`。与 `minus`*`XXX`*`()`
    方法一样，所有 `plus`*`XXX`*`()` 方法都添加单个元素：'
- en: '[PRE71]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE72]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|  |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-1044
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Adding a `Period` of 10 months to a `Period` of 5 months gives 15 months, not
    1 year and 3 months.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 将 10 个月的 `Period` 加到 5 个月的 `Period` 上得到 15 个月，而不是 1 年和 3 个月。
- en: '|  |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `withDays()`, `withMonths()`, and `withYears()` methods accept an `int`
    value and return a copy of `Period` with the specified value altered.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '`withDays()`、`withMonths()` 和 `withYears()` 方法接受一个 `int` 值，并返回一个具有指定值更改的 `Period`
    的副本。'
- en: Converting to another type
  id: totrans-1048
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换到其他类型
- en: 'The method `toTotalMonths()` returns the total number of months in the period
    by multiplying the number of years by 12 and adding the number of months:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '`toTotalMonths()` 方法通过将年数乘以 12 并加上月数来返回周期中的总月数：'
- en: '![](291fig01_alt.jpg)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
  zh: '![](291fig01_alt.jpg)'
- en: A `Period` can be used as an argument to the `LocalDate` one-parameter `plus()`
    and `minus()` methods. What happens when you want to add 3 months and 10 days
    to a given date? The number of months per year is constant but the number of days
    per month isn’t. A glimpse at the `plus()` and `minus()` methods in the `LocalDate`
    source code shows that years are converted to months and months are always handled
    before days.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period` 可以作为 `LocalDate` 单参数 `plus()` 和 `minus()` 方法的参数。当你想要给一个特定的日期加上 3 个月和
    10 天时会发生什么？每年月份数量是固定的，但每月天数不是。查看 `LocalDate` 源代码中的 `plus()` 和 `minus()` 方法可以看到，年份被转换为月份，并且总是先处理月份再处理天数。'
- en: In the next section, you’ll work with the class `DateTimeFormatter`.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将使用 `DateTimeFormatter` 类。
- en: 4.6.5\. DateTimeFormatter
  id: totrans-1053
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.5\. DateTimeFormatter
- en: Defined in the package `java.time.format`, the class `DateTimeFormatter` can
    be used to format and parse date and time objects. In this section, you’ll use
    this class to format or parse date and time objects using predefined constants
    (like `ISO_LOCAL_DATE`), using patterns (like yyyy-MM-dd) or localized styles
    like *long* or *short*.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在 `java.time.format` 包中的 `DateTimeFormatter` 类可以用来格式化和解析日期和时间对象。在本节中，你将使用此类使用预定义的常量（如
    `ISO_LOCAL_DATE`）、使用模式（如 yyyy-MM-dd）或本地化样式（如 *long* 或 *short*）来格式化或解析日期和时间对象。
- en: The first step to format or parse a date or time object is to access a `DateTime-Formatter`
    and then call `format` or `parse` methods on either date or time objects or `DateTimeFormatter`.
    Let’s work in detail with these steps, starting with multiple ways to instantiate
    or access a `DateTimeFormatter` object.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化或解析日期或时间对象的第一步是访问 `DateTime-Formatter`，然后对日期或时间对象或 `DateTimeFormatter` 调用
    `format` 或 `parse` 方法。让我们详细探讨这些步骤，从多种方式实例化或访问 `DateTimeFormatter` 对象开始。
- en: Instantiate or access DateTimeFormatter
  id: totrans-1056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实例化或访问 DateTimeFormatter
- en: 'You can instantiate or access a `DateTimeFormatter` object in multiple ways:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式实例化或访问 `DateTimeFormatter` 对象：
- en: By calling a static `of`*`XXX`* method, passing it a `FormatStyle` value
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用静态 `of`*`XXX`* 方法，并传递一个 `FormatStyle` 值
- en: By access public static fields of `DateTimeFormatter`
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过访问 `DateTimeFormatter` 的公共静态字段
- en: By using the static method `ofPattern` and passing it a string value
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用静态方法 `ofPattern` 并传递一个字符串值
- en: 'Starting with the first option, you can instantiate a `DateTimeFormatter` to
    work with date, time, or date/time objects by calling its `of`*`XXX`* static method
    and passing it a `FormatStyle` value (`FormatStyle.FULL`, `FormatStyle.LONG`,
    `FormatStyle.MEDIUM`, or `FormatStyle.SHORT`):'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个选项开始，你可以通过调用其 `of`*`XXX`* 静态方法并传递一个 `FormatStyle` 值（`FormatStyle.FULL`、`FormatStyle.LONG`、`FormatStyle.MEDIUM`
    或 `FormatStyle.SHORT`）来实例化一个 `DateTimeFormatter` 以处理日期、时间或日期/时间对象：
- en: '[PRE73]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|  |'
  id: totrans-1063
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The methods `ofLocalizedDate`, `ofLocalizedTime`, and `ofLocalizedDateTime`
    format date and time objects according to the locale (language, region, or country)
    of the system on which your code executes. So the output might vary slightly across
    systems.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '`ofLocalizedDate`、`ofLocalizedTime` 和 `ofLocalizedDateTime` 方法根据代码执行的系统上的区域设置（语言、区域或国家）来格式化日期和时间对象。因此，输出可能会在不同系统之间略有差异。'
- en: '|  |'
  id: totrans-1066
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Table 4.2](#ch04table02) shows how a date or time object will be formatted
    by using the different `Format-Style` values.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4.2](#ch04table02) 展示了使用不同的 `Format-Style` 值如何格式化日期或时间对象。'
- en: Table 4.2\. Examples of how `FormatStyle` affects formatting of a date (say,
    August 11, 2057) or time (say, 14 hours, 30 minutes, and 15 seconds) object
  id: totrans-1068
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.2\. `FormatStyle` 对日期（例如，2057年8月11日）或时间（例如，14小时30分钟和15秒）对象格式化影响的示例
- en: '| FormatStyle | Example |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle | 示例 |'
- en: '| --- | --- |'
  id: totrans-1070
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| FormatStyle.FULL | Saturday, August 11, 2057 |'
  id: totrans-1071
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.FULL | Saturday, August 11, 2057 |'
- en: '| FormatStyle.LONG | August 11, 2057 |'
  id: totrans-1072
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.LONG | August 11, 2057 |'
- en: '| FormatStyle.MEDIUM | Aug 11, 2057 |'
  id: totrans-1073
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.MEDIUM | Aug 11, 2057 |'
- en: '| FormatStyle.SHORT | 8/11/57 |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.SHORT | 8/11/57 |'
- en: '| FormatStyle.FULL |   |'
  id: totrans-1075
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.FULL |   |'
- en: '| FormatStyle.LONG |   |'
  id: totrans-1076
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.LONG |   |'
- en: '| FormatStyle.MEDIUM | 2:30:15 PM |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.MEDIUM | 2:30:15 PM |'
- en: '| FormatStyle.SHORT | 2:30 PM |'
  id: totrans-1078
  prefs: []
  type: TYPE_TB
  zh: '| FormatStyle.SHORT | 2:30 PM |'
- en: 'You can access a `DateTimeFormatter` object by using the public and static
    fields of this class:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用该类的公共和静态字段来访问 `DateTimeFormatter` 对象：
- en: '[PRE74]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[Table 4.3](#ch04table03) lists a few predefined formatters that are relevant
    for this exam.'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4.3](#ch04table03) 列出了与本次考试相关的几个预定义格式化工具。'
- en: Table 4.3\. Predefined formatters in the class `DateTimeFormatter` and an example
    of how they format a date (say, August 11, 2057) or time (say, 14 hours 30 minutes,
    and 15 seconds) object
  id: totrans-1082
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.3\. `DateTimeFormatter` 类中的预定义格式化工具及其如何格式化日期（例如，2057年8月11日）或时间（例如，14小时30分钟和15秒）对象的示例
- en: '| Predefined formatter | Example |'
  id: totrans-1083
  prefs: []
  type: TYPE_TB
  zh: '| 预定义格式化工具 | 示例 |'
- en: '| --- | --- |'
  id: totrans-1084
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| BASIC_ISO_DATE | 20570811 |'
  id: totrans-1085
  prefs: []
  type: TYPE_TB
  zh: '| BASIC_ISO_DATE | 20570811 |'
- en: '| ISO_DATE/ISO_LOCAL_DATE | 2057-08-11 |'
  id: totrans-1086
  prefs: []
  type: TYPE_TB
  zh: '| ISO_DATE/ISO_LOCAL_DATE | 2057-08-11 |'
- en: '| ISO_TIME/ISO_LOCAL_TIME | 14:30:15.312 |'
  id: totrans-1087
  prefs: []
  type: TYPE_TB
  zh: '| ISO_TIME/ISO_LOCAL_TIME | 14:30:15.312 |'
- en: '| ISO_DATE_TIME/ISO_LOCAL_DATE_TIME | 2057-08-11T14:30:15.312 |'
  id: totrans-1088
  prefs: []
  type: TYPE_TB
  zh: '| ISO_DATE_TIME/ISO_LOCAL_DATE_TIME | 2057-08-11T14:30:15.312 |'
- en: 'You can instantiate a `DateTimeFormatter` using a pattern (of letters and symbols)
    by using the static method `ofPattern` and passing it a string value:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用静态方法 `ofPattern` 并传递一个字符串值来使用模式（字母和符号）实例化一个 `DateTimeFormatter`：
- en: '[PRE75]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can use the preceding code to format a date, say August 11, 2057, as 2057
    08 11\. [Table 4.4](#ch04table04) lists the letters that can be used to define
    such patterns.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用前面的代码将日期格式化为2057 08 11。表4.4（[Table 4.4](#ch04table04)）列出了可以用来定义此类模式的字母。
- en: Table 4.4\. Letters used to define patterns for `DateTimeFormatter` and examples
    of how they would format a date (say, August 11, 2057) or time (say, 14 hours,
    30 minutes, and 15 seconds) object
  id: totrans-1092
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.4\. 用于定义 `DateTimeFormatter` 模式的字母及其如何格式化日期（例如，2057年8月11日）或时间（例如，14小时30分钟和15秒）对象的示例
- en: '| Symbol | Meaning | Example |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-1094
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| y, Y | year | 2057; 57 |'
  id: totrans-1095
  prefs: []
  type: TYPE_TB
  zh: '| y, Y | 年 | 2057; 57 |'
- en: '| M | month of year | 8; 08; Aug; August |'
  id: totrans-1096
  prefs: []
  type: TYPE_TB
  zh: '| M | 年中的月份 | 8; 08; Aug; August |'
- en: '| D | day of year | 223 |'
  id: totrans-1097
  prefs: []
  type: TYPE_TB
  zh: '| D | 年内天数 | 223 |'
- en: '| d | day of month | 11 |'
  id: totrans-1098
  prefs: []
  type: TYPE_TB
  zh: '| d | 月份中的天数 | 11 |'
- en: '| E | day of week | Sat |'
  id: totrans-1099
  prefs: []
  type: TYPE_TB
  zh: '| E | 星期几 | Sat |'
- en: '| e | localized day of week | 7; Sat |'
  id: totrans-1100
  prefs: []
  type: TYPE_TB
  zh: '| e | 本地化星期几 | 7; Sat |'
- en: '| a | a.m. or p.m. of day | pm |'
  id: totrans-1101
  prefs: []
  type: TYPE_TB
  zh: '| a | 一天中的上午或下午 | pm |'
- en: '| h | clock hour of a.m./p.m. | 03 |'
  id: totrans-1102
  prefs: []
  type: TYPE_TB
  zh: '| h | 上午或下午的时钟小时数 | 03 |'
- en: '| H | hour of day | 14 |'
  id: totrans-1103
  prefs: []
  type: TYPE_TB
  zh: '| H | 一天中的小时数 | 14 |'
- en: '| m | minute of hour | 30 |'
  id: totrans-1104
  prefs: []
  type: TYPE_TB
  zh: '| m | 小时中的分钟数 | 30 |'
- en: '| s | second of minute | 15 |'
  id: totrans-1105
  prefs: []
  type: TYPE_TB
  zh: '| s | 分钟的秒数 | 15 |'
- en: '| '' | escape for text |   |'
  id: totrans-1106
  prefs: []
  type: TYPE_TB
  zh: '| '' | 文本转义 |   |'
- en: '|  |'
  id: totrans-1107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A `DateTimeFormatter` can define rules to format or parse a date object, time
    object, or both.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter` 可以定义规则来格式化或解析日期对象、时间对象或两者。'
- en: '|  |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Format date or time objects using DateTimeFormatter
  id: totrans-1111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 DateTimeFormatter 格式化日期或时间对象
- en: To format a date or time object, you can use either the instance `format` method
    in date/time objects or the instance `format` method in the `DateTimeFormatter`
    class. Behind the scenes, the `format` method in date and time objects simply
    calls the `format` method in `DateTimeFormatter`. [Table 4.5](#ch04table05) lists
    the available `format` methods.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 要格式化日期或时间对象，您可以使用日期/时间对象的实例 `format` 方法或 `DateTimeFormatter` 类的实例 `format` 方法。在幕后，日期和时间对象的
    `format` 方法只是调用 `DateTimeFormatter` 的 `format` 方法。[表 4.5](#ch04table05) 列出了可用的
    `format` 方法。
- en: '|  |'
  id: totrans-1113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`TemporalAccessor` is an interface, implemented by the classes `LocalDate`,
    `LocalTime`, and `LocalDateTime`. You won’t get explicit questions on this interface
    on the exam.'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemporalAccessor` 是一个接口，由 `LocalDate`、`LocalTime` 和 `LocalDateTime` 类实现。在考试中不会明确考察这个接口。'
- en: '|  |'
  id: totrans-1116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Table 4.5\. `format` methods in the classes `LocalDate`, `LocalTime`, `LocalDateTime`,
    and `Date-TimeFormatter`
  id: totrans-1117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.5\. `LocalDate`、`LocalTime`、`LocalDateTime` 和 `DateTimeFormatter` 类中的 `format`
    方法
- en: '| Defined in | Return type | Method signature and description |'
  id: totrans-1118
  prefs: []
  type: TYPE_TB
  zh: '| 定义于 | 返回类型 | 方法签名和描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LocalDate | String | format(DateTimeFormatter) Formats this date object using
    the specified DateTimeFormatter |'
  id: totrans-1120
  prefs: []
  type: TYPE_TB
  zh: '| LocalDate | String | format(DateTimeFormatter) 使用指定的 DateTimeFormatter 格式化此日期对象
    |'
- en: '| LocalTime | String | format(DateTimeFormatter) Formats this time object using
    the specified DateTimeFormatter |'
  id: totrans-1121
  prefs: []
  type: TYPE_TB
  zh: '| LocalTime | String | format(DateTimeFormatter) 使用指定的 DateTimeFormatter 格式化此时间对象
    |'
- en: '| LocalDateTime | String | format(DateTimeFormatter) Formats this date/time
    object using the specified DateTimeFormatter |'
  id: totrans-1122
  prefs: []
  type: TYPE_TB
  zh: '| LocalDateTime | String | format(DateTimeFormatter) 使用指定的 DateTimeFormatter
    格式化此日期/时间对象 |'
- en: '| DateTimeFormatter | String | format(TemporalAccessor) Formats a date/time
    object using this formatter |'
  id: totrans-1123
  prefs: []
  type: TYPE_TB
  zh: '| DateTimeFormatter | String | format(TemporalAccessor) 使用此格式化器格式化日期/时间对象 |'
- en: '|  |'
  id: totrans-1124
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for the count and type of arguments passed to the instance method
    `format`. When calling `format` on a `LocalDate`, `LocalTime`, or `LocalDateTime`
    instance, pass a `DateTimeFormatter` instance as a method parameter. When calling
    `format` on `DateTimeFormatter`, pass a `LocalDate`, `LocalTime`, or `LocalDateTime`
    instance as a method argument.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意传入实例方法 `format` 的参数数量和类型。当在 `LocalDate`、`LocalTime` 或 `LocalDateTime` 实例上调用
    `format` 时，将 `DateTimeFormatter` 实例作为方法参数传递。当在 `DateTimeFormatter` 上调用 `format`
    时，将 `LocalDate`、`LocalTime` 或 `LocalDateTime` 实例作为方法参数传递。
- en: '|  |'
  id: totrans-1127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The method `format` in `DateTimeFormatter` formats a date or time object to
    a `String` using the rules of the formatter. The following example formats a `LocalDate`
    object using the style `FormatStyle` (styles are listed in [table 4.2](#ch04table02)):'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter` 中的 `format` 方法使用格式器的规则将日期或时间对象格式化为 `String`。以下示例使用 `FormatStyle`
    风格（风格在 [表 4.2](#ch04table02) 中列出）格式化 `LocalDate` 对象：'
- en: '![](294fig01_alt.jpg)'
  id: totrans-1129
  prefs: []
  type: TYPE_IMG
  zh: '![](294fig01_alt.jpg)'
- en: What happens if you pass a time object (`LocalTime`) instead of a date object
    (`LocalDate`) in the preceding code? Will it compile or execute successfully (changes
    are shown in bold)?
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在前面代码中将时间对象（`LocalTime`）而不是日期对象（`LocalDate`）传递给 `format` 方法，会发生什么？它能否编译或成功执行（更改以粗体显示）？
- en: '![](295fig01_alt.jpg)'
  id: totrans-1131
  prefs: []
  type: TYPE_IMG
  zh: '![](295fig01_alt.jpg)'
- en: The preceding code will compile successfully but won’t execute. It will throw
    a runtime exception because the `formatter` defines rules to format a date object
    (created using `ofLocalizedDate()`), but its `format()` is passed a time object.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以成功编译，但不会执行。它将抛出一个运行时异常，因为 `formatter` 定义了格式化日期对象的规则（使用 `ofLocalizedDate()`
    创建），但其 `format()` 方法接收了一个时间对象。
- en: '|  |'
  id: totrans-1133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: If you pass a date object to the method `format` on a `DateTimeFormatter` instance
    that defines rules to format a time object, it will throw a runtime exception.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将日期对象传递给定义了格式化时间对象规则的 `DateTimeFormatter` 实例上的 `format` 方法，它将抛出一个运行时异常。
- en: '|  |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Formatting date and time objects using `DateTimeFormatter`, which are created
    using string patterns, is interesting (and confusing). Take note of the case of
    the letters used in the patterns. *M* and *m* or *D* and *d* are not the same.
    Also, using a pattern letter doesn’t specify the count of digits or texts. For
    an example, using *Y* or *YYYY* to format a date object returns the same results.
    Following are examples that use different patterns:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DateTimeFormatter` 格式化日期和时间对象（这些对象是通过字符串模式创建的）很有趣（但也令人困惑）。注意在模式中使用的字母的大小写。*M*
    和 *m* 或 *D* 和 *d* 是不同的。此外，使用模式字母并不指定数字或文本的数量。例如，使用 *Y* 或 *YYYY* 格式化日期对象会返回相同的结果。以下是一些使用不同模式的示例：
- en: '[PRE76]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE77]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '|  |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: If you're confused between *M*, *m*, *D*, and *d*, remember that an uppercase
    letter represents a bigger duration period. So *M* is for month and *m* is for
    minutes. Similarly, *D* represents day of year; *d* represents day of month.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分不清 *M*，*m*，*D* 和 *d*，请记住大写字母代表更长的持续时间。所以 *M* 代表月份，*m* 代表分钟。同样，*D* 代表一年中的某一天；*d*
    代表一个月中的某一天。
- en: '|  |'
  id: totrans-1144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can also format date and time objects by calling the `format` method in
    date or time objects and passing it a `DateTimeFormatter` instance.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在日期或时间对象上调用 `format` 方法并将 `DateTimeFormatter` 实例传递给它来格式化日期和时间对象。
- en: '|  |'
  id: totrans-1146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: If you access Java’s source code, you’ll notice that the `format` and `parse`
    methods in date and time classes simply call the `format` and `parse` methods
    on a `DateTimeFormatter` instance.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 Java 的源代码，你会注意到日期和时间类中的 `format` 和 `parse` 方法只是简单地调用 `DateTimeFormatter`
    实例上的 `format` 和 `parse` 方法。
- en: '|  |'
  id: totrans-1149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Parse date or time objects using DateTimeFormatter
  id: totrans-1150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 DateTimeFormatter 解析日期或时间对象
- en: To parse a date or time object, you can use either the static `parse` method
    in date/time objects or the instance `parse` method in the `DateTimeFormatter`
    class. Behind the scenes, the `parse` method in date/time objects simply calls
    the `parse` method in `DateTimeFormatter`. [Table 4.6](#ch04table06) lists the
    available parse methods.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析日期或时间对象，你可以使用日期/时间对象中的静态 `parse` 方法或 `DateTimeFormatter` 类中的实例 `parse` 方法。在幕后，日期/时间对象中的
    `parse` 方法只是调用 `DateTimeFormatter` 中的 `parse` 方法。[表 4.6](#ch04table06) 列出了可用的解析方法。
- en: '|  |'
  id: totrans-1152
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The parse methods are defined as static methods in the classes `LocalDate`,
    `LocalTime`, and `LocalDateTime`. The class `DateTimeFormatter` defines the `parse`
    method as an instance method.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 解析方法在 `LocalDate`，`LocalTime` 和 `LocalDateTime` 类中定义为静态方法。`DateTimeFormatter`
    类将 `parse` 方法定义为实例方法。
- en: '|  |'
  id: totrans-1155
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Table 4.6\. `parse` methods in the classes `LocalDate`, `LocalTime`, `LocalDateTime`,
    and `Date-TimeFormatter`
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.6\. `LocalDate`，`LocalTime`，`LocalDateTime` 和 `DateTimeFormatter` 类中的 `parse`
    方法
- en: '| Defined in | Return type | Method signature and description |'
  id: totrans-1157
  prefs: []
  type: TYPE_TB
  zh: '| 定义在 | 返回类型 | 方法签名和描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LocalDate | LocalDate | parse(CharSequence) Creates a LocalDate instance
    using a text string such as 2057-08-11, parsed using DateTimeFormatter.ISO_LOCAL_DATE
    |'
  id: totrans-1159
  prefs: []
  type: TYPE_TB
  zh: '| LocalDate | LocalDate | parse(CharSequence) 使用文本字符串（如 2057-08-11）创建 LocalDate
    实例，使用 DateTimeFormatter.ISO_LOCAL_DATE 解析 |'
- en: '| LocalDate | LocalDate | parse(CharSequence, DateTimeFormatter) Creates a
    LocalDate instance, parsing text using the specified formatter |'
  id: totrans-1160
  prefs: []
  type: TYPE_TB
  zh: '| LocalDate | LocalDate | parse(CharSequence, DateTimeFormatter) 使用指定的格式器解析文本创建
    LocalDate 实例 |'
- en: '| LocalTime | LocalTime | parse(CharSequence) Creates a LocalTime instance
    using a text string such as 14:40, parsed using Date-TimeFormatter.ISO_LOCAL_TIME
    |'
  id: totrans-1161
  prefs: []
  type: TYPE_TB
  zh: '| LocalTime | LocalTime | parse(CharSequence) 使用文本字符串（如 14:40）创建 LocalTime
    实例，使用 Date-TimeFormatter.ISO_LOCAL_TIME 解析 |'
- en: '| LocalTime | LocalTime | parse(CharSequence, DateTimeFormatter) Creates a
    LocalTime instance, parsing text using the specified formatter |'
  id: totrans-1162
  prefs: []
  type: TYPE_TB
  zh: '| LocalTime | LocalTime | parse(CharSequence, DateTimeFormatter) 使用指定的格式器解析文本创建
    LocalTime 实例 |'
- en: '| LocalDateTime | LocalDateTime | parse(CharSequence) Creates a LocalDateTime
    instance using a text string such as 2057-08-11T14:40, parsed using DateTimeFormatter.ISO_LOCAL_DATE_TIME
    |'
  id: totrans-1163
  prefs: []
  type: TYPE_TB
  zh: '| LocalDateTime | LocalDateTime | parse(CharSequence) 使用文本字符串（如 2057-08-11T14:40）创建
    LocalDateTime 实例，使用 DateTimeFormatter.ISO_LOCAL_DATE_TIME 解析 |'
- en: '| LocalDateTime | LocalDateTime | parse(CharSequence, DateTimeFormatter) Creates
    a LocalDateTime instance, parsing text using the specified formatter |'
  id: totrans-1164
  prefs: []
  type: TYPE_TB
  zh: '| LocalDateTime | LocalDateTime | parse(CharSequence, DateTimeFormatter) 使用指定的格式器解析文本创建
    LocalDateTime 实例 |'
- en: '| DateTimeFormatter | TemporalAccessor | parse(CharSequence) Parses text using
    the rules of DateTime-Formatter, returning a temporal object |'
  id: totrans-1165
  prefs: []
  type: TYPE_TB
  zh: '| DateTimeFormatter | TemporalAccessor | parse(CharSequence) 使用 DateTimeFormatter
    的规则解析文本，返回一个时间对象 |'
- en: '|  |'
  id: totrans-1166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When calling `parse` on `LocalDate`, `LocalTime`, or `LocalDateTime` instances,
    you might not specify a formatter. In this case `DateTimeFormatter.ISO_LOCAL_DATE`,
    `DateTimeFormatter.ISO_LOCAL_TIME`, and `DateTimeFormatter.ISO_LOCAL_DATE_TIME`
    are used to parse text, respectively.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `LocalDate`、`LocalTime` 或 `LocalDateTime` 实例上调用 `parse` 方法时，你可能没有指定格式化程序。在这种情况下，分别使用
    `DateTimeFormatter.ISO_LOCAL_DATE`、`DateTimeFormatter.ISO_LOCAL_TIME` 和 `DateTimeFormatter.ISO_LOCAL_DATE_TIME`
    来解析文本。
- en: '|  |'
  id: totrans-1169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s work with the method `parse` of `LocalDate`, `LocalTime`, or `LocalDateTime`
    to parse a string value using a `DateTimeFormatter`, producing a date or time
    object:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `LocalDate`、`LocalTime` 或 `LocalDateTime` 的 `parse` 方法，通过使用 `DateTimeFormatter`
    解析字符串值，生成日期或时间对象：
- en: '[PRE78]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following line throws a `DateTimeParseException` because this mechanism
    works *only if* all components are present. For example, the pattern yyyy-MM-dd
    with “2057-01-29” works fine. The component order doesn’t matter; hence, using
    dd-yyyy-MM to parse “29-2057-01” works too and yields January 29, 2057 as well:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行抛出 `DateTimeParseException`，因为此机制仅在所有组件都存在的情况下才有效。例如，使用“2057-01-29”的 yyyy-MM-dd
    模式运行良好。组件顺序无关紧要；因此，使用 dd-yyyy-MM 来解析“29-2057-01”也有效，并得到 2057 年 1 月 29 日：
- en: '[PRE79]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Similarly, you can call the `parse` method to create instances of `LocalTime`
    and `LocalDateTime`.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以调用 `parse` 方法来创建 `LocalTime` 和 `LocalDateTime` 的实例。
- en: 4.7\. Summary
  id: totrans-1175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7\. 摘要
- en: In this chapter, you learned about the `String` class, its properties, and its
    methods. Because this is one of the most frequently used classes in Java, I’ll
    reiterate that a good understanding of this class in terms of why its methods
    behave in a particular manner will go a long way toward helping you successfully
    complete the OCA Java SE 8 Programmer I exam.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 `String` 类、其属性和方法。由于这是 Java 中使用最频繁的类之一，我将重申，对这一类在特定方法行为原因的理解将大大有助于你成功完成
    OCA Java SE 8 程序员 I 考试。
- en: You learned how to initialize `String` variables using the operator `new` and
    the assignment operator (`=`) with `String` literals. You also learned the differences
    between how `String` objects are stored using these two approaches. If you use
    the assignment operator to initialize your `String` variables, they’re stored
    in a common pool of `String` objects (also known as the `String` constant pool)
    that can be used by others. This storage is possible because `String` objects
    are immutable—that is, their values can’t be changed.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用操作符 `new` 和赋值操作符（`=`）以及 `String` 文字来初始化 `String` 变量。你还学习了使用这两种方法存储 `String`
    对象之间的区别。如果你使用赋值操作符来初始化你的 `String` 变量，它们将存储在一个公共的 `String` 对象池中（也称为 `String` 常量池），可以被其他人使用。这种存储是可能的，因为
    `String` 对象是不可变的——也就是说，它们的值不能被更改。
- en: You learned how a `char` array is used to store the value of a `String` object.
    This helps explain why the methods `charAt()`, `indexOf()`, and `substring()`
    search for the first character of a `String` at position 0, not position 1\. We
    also reviewed the methods `replace()`, `trim()`, and `substring()`, which seem
    to modify the value of a `String` but will never be able to do so because `String`
    objects are immutable. You also learned the methods `length()`, `startsWith()`,
    and `endsWith()`.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了 `char` 数组如何用于存储 `String` 对象的值。这有助于解释为什么 `charAt()`、`indexOf()` 和 `substring()`
    方法在位置 0 而不是位置 1 处搜索 `String` 的第一个字符。我们还回顾了 `replace()`、`trim()` 和 `substring()`
    方法，这些方法似乎会修改 `String` 的值，但永远不会这样做，因为 `String` 对象是不可变的。你还学习了 `length()`、`startsWith()`
    和 `endsWith()` 方法。
- en: 'Because not all operators can be used with `String`s, you learned about the
    ones that can be used with `String`: `+`, `+=`, `==`, and `!=`. You also learned
    that the equality of `String`s can be determined using the method `equals`. By
    using the operator `==`, you can only determine whether both of the variables
    are referring to the same object; it doesn’t compare the values stored by `String`s.
    As with all the other object types, you can assign `null` to a `String` variable.'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有操作符都可以与 `String` 一起使用，你学习了可以与 `String` 一起使用的操作符：`+`、`+=`、`==` 和 `!=`。你还学习了
    `String` 的相等性可以使用 `equals` 方法确定。通过使用操作符 `==`，你只能确定两个变量是否都指向同一个对象；它不比较 `String`
    存储的值。与其他所有对象类型一样，你可以将 `null` 赋值给 `String` 变量。
- en: You worked with the class `StringBuilder`, which is defined in the package `java.lang`
    and is used to store a mutable sequence of characters. The class `StringBuilder`
    is usually used to store a sequence of characters that needs to be modified often—such
    as when you’re building a query for database applications. Like the `String` class,
    `StringBuilder` also uses a `char` array to store its characters. Many of the
    methods defined in the class `StringBuilder` work exactly as defined by the class
    `String`, such as the methods `charAt`, `indexOf`, `substring`, and `length`.
    The `append` method is used to add characters to the end of a `StringBuilder`
    object. The `insert` method is another important `StringBuilder` method that’s
    used to insert either single or multiple characters at a specified position in
    a `StringBuilder` object. The class `StringBuilder` offers the same functionality
    as offered by the class `StringBuffer`, minus the additional feature of methods
    that are synchronized where needed.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 您曾使用过`StringBuilder`类，该类定义在`java.lang`包中，用于存储可变字符序列。`StringBuilder`类通常用于存储需要经常修改的字符序列——例如，当您在为数据库应用程序构建查询时。与`String`类一样，`StringBuilder`也使用`char`数组来存储其字符。`StringBuilder`类中定义的许多方法与`String`类中定义的方法完全相同，例如`charAt`、`indexOf`、`substring`和`length`方法。`append`方法用于向`StringBuilder`对象的末尾添加字符。`insert`方法是另一个重要的`StringBuilder`方法，用于在`StringBuilder`对象中指定位置插入单个或多个字符。`StringBuilder`类提供了与`StringBuffer`类相同的功能，但不需要同步的方法提供了额外的特性。
- en: An array is an object that stores a collection of values. An array can store
    a collection of primitive data types or a collection of objects. You can define
    one-dimensional and multidimensional arrays. A one-dimensional array is an object
    that refers to a collection of scalar values. A two-dimensional (or more) array
    is referred to as a multidimensional array. A two-dimensional array refers to
    a collection of objects, where each of the objects is a one-dimensional array.
    Similarly, a three-dimensional array refers to a collection of two-dimensional
    arrays, and so on. Arrays can be declared, allocated, and initialized in a single
    step or in multiple steps. A two-dimensional array doesn’t need to be symmetrical,
    and each of its rows can define different numbers of members. You can define arrays
    of primitives, interfaces, abstract classes, and concrete classes. All arrays
    are objects and can access the variable `length` and methods inherited from the
    class `java.lang.Object`.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个存储值集合的对象。数组可以存储原始数据类型的集合或对象的集合。您可以定义一维和多维数组。一维数组是一个指向标量值集合的对象。二维（或更多）数组被称为多维数组。二维数组指的是一个对象集合，其中每个对象都是一个一维数组。同样，三维数组指的是二维数组的集合，依此类推。数组可以一次性或分步声明、分配和初始化。二维数组不需要对称，并且它的每一行可以定义不同数量的成员。您可以定义原始数据类型、接口、抽象类和具体类的数组。所有数组都是对象，并且可以访问从`java.lang.Object`类继承的变量`length`和方法。
- en: '`ArrayList` is a resizable array that offers the best combination of features
    offered by an array and the List data structure. You can add objects to an `ArrayList`
    using the method `add`. You can access the objects of an `ArrayList` by using
    an enhanced `for` loop or by using the `get()` method or an iterator. An `ArrayList`
    preserves the order of insertion of its elements. `ListIterator`, `Iterator`,
    and the enhanced `for` loop will return the elements in the order in which they
    were added to the `ArrayList`. You can modify the elements of an `ArrayList` using
    the method `set`. You can remove the elements of an `ArrayList` by using the method
    `remove`, which accepts the element position or an object. You can also add multiple
    elements to an `ArrayList` by using the method `addAll`. The method `clone` defined
    in the class `ArrayList` returns a shallow copy of this `ArrayList` instance.
    *Shallow copy* means that the method creates a new instance of the `ArrayList`
    to be cloned, but the `ArrayList` elements aren’t copied.'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList` 是一个可调整大小的数组，它提供了数组和 List 数据结构提供的最佳功能组合。您可以使用 `add` 方法向 `ArrayList`
    中添加对象。您可以通过使用增强型 `for` 循环或使用 `get()` 方法或迭代器来访问 `ArrayList` 中的对象。`ArrayList` 保留其元素的插入顺序。`ListIterator`、`Iterator`
    和增强型 `for` 循环将按它们被添加到 `ArrayList` 中的顺序返回元素。您可以使用 `set` 方法修改 `ArrayList` 的元素。您可以通过使用
    `remove` 方法移除 `ArrayList` 的元素，该方法接受元素位置或对象。您还可以使用 `addAll` 方法向 `ArrayList` 中添加多个元素。`ArrayList`
    类中定义的 `clone` 方法返回此 `ArrayList` 实例的浅拷贝。"浅拷贝"意味着该方法创建了一个新的 `ArrayList` 实例以进行克隆，但
    `ArrayList` 元素没有被复制。'
- en: You can compare the objects of your class by overriding the `equals` method.
    The `equals` method is defined in the class `java.lang.Object`, which is the base
    class of all classes in Java. The default implementation of the method `equals`
    only compares the object references for equality. Because instance variables are
    used to store the state of an object, it’s common to compare the values of these
    variables to determine whether two objects should be considered equal in the `equals`
    method. The Java API documentation defines a contract for the `equals` method.
    In the exam, for a given definition of the method `equals`, it is important to
    note the differences between an `equals` method that compiles successfully, one
    that fails compilation, and one that doesn’t follow the contract.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重写 `equals` 方法来比较您类中的对象。`equals` 方法在 `java.lang.Object` 类中定义，这是 Java 中所有类的基类。`equals`
    方法的默认实现仅比较对象引用是否相等。因为实例变量用于存储对象的状态，所以在 `equals` 方法中比较这些变量的值以确定两个对象是否应该被视为相等是很常见的。Java
    API 文档为 `equals` 方法定义了一个契约。在考试中，对于 `equals` 方法的给定定义，重要的是要注意编译成功、编译失败以及不遵循契约的 `equals`
    方法的区别。
- en: The Date and Time API in Java 8 simplifies how you work with the date and time
    classes. You worked with `LocalDate`, which is used to store only dates of the
    format 2016-08-14\. `LocalTime` stores time in the format 14:09:65:23 (hours:minutes:seconds:nanoseconds).
    The class `LocalDateTime` stores both date and time. The class `Period` is used
    to work with a duration of, say, a period of 4 months or 4 days. The class `DateTimeFormatter`
    is used to format date and time using a predefined or custom format.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 的日期和时间 API 简化了您与日期和时间类的工作方式。您使用了 `LocalDate`，它用于存储仅日期的格式 2016-08-14\.
    `LocalTime` 以 14:09:65:23（小时:分钟:秒:纳秒）的格式存储时间。`LocalDateTime` 类存储日期和时间。`Period`
    类用于处理，例如，4 个月或 4 天的持续时间。`DateTimeFormatter` 类用于使用预定义或自定义格式格式化日期和时间。
- en: 4.8\. Review notes
  id: totrans-1185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8. 复习笔记
- en: This section lists the main points covered in this chapter.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了本章涵盖的主要要点。
- en: 'The class `String`:'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类：'
- en: The class `String` represents an immutable sequence of characters.
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String` 类表示一个不可变的字符序列。'
- en: A `String` variable can be initialized by using the operator `new` or by using
    the assignment operator with `String` literal values.
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `new` 运算符或使用 `String` 文字值与赋值运算符来初始化 `String` 变量。
- en: '`String` objects created using a `String` literal without the `new` operator
    are placed in a *pool* of `String` objects. Whenever the JRE receives a new request
    to initialize a `String` variable using the assignment operator, it checks whether
    a `String` object with the same value already exists in the pool. If one is found,
    it returns the object reference for the existing `String` object from the pool.'
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不带 `new` 运算符的 `String` 文字创建的 `String` 对象被放置在一个 `String` 对象的 *池* 中。每当 JRE 收到使用赋值运算符初始化
    `String` 变量的新请求时，它会检查是否已存在具有相同值的 `String` 对象。如果找到了，它将从池中返回现有 `String` 对象的引用。
- en: '`String` objects created using the operator `new` are never placed in the pool
    of `String` objects.'
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `new` 运算符创建的 `String` 对象永远不会放置在 `String` 对象的池中。
- en: The comparison operator (`==`) compares `String` references, whereas the `equals`
    method compares the `String` values.
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符 (`==`) 比较的是 `String` 引用，而 `equals` 方法比较的是 `String` 值。
- en: None of the methods defined in the class `String` can modify its value.
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 `String` 中定义的任何方法都不能修改其值。
- en: The method `charAt(int index)` retrieves a character at a specified index of
    a `String`.
  id: totrans-1194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charAt(int index)` 方法可以检索 `String` 中指定索引处的字符。'
- en: The method `indexOf` can be used to search a `String` for the occurrence of
    a `char` or a `String`, starting from the first position or a specified position.
  id: totrans-1195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf` 方法可以用来在 `String` 中搜索一个 `char` 或 `String` 的出现，从第一个位置或指定的位置开始搜索。'
- en: The method `substring` can be used to retrieve a portion of a `String` object.
    The `substring` method doesn’t include the character at the end position.
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substring` 方法可以用来检索 `String` 对象的一部分。`substring` 方法不包括结束位置处的字符。'
- en: The `trim` method will return a new `String` by removing all the leading and
    trailing white spaces from a `String`. This method doesn’t remove any white space
    *within* a `String`.
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim` 方法将返回一个新的 `String`，通过从 `String` 中移除所有前导和尾随空白字符来实现。此方法不会移除 `String` 中的任何空白字符。'
- en: You can use the method `length` to retrieve the length of a `String`.
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `length` 方法来获取 `String` 的长度。
- en: The method `startsWith` determines whether a `String` starts with a specified
    `String`.
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startsWith` 方法确定一个 `String` 是否以指定的 `String` 开头。'
- en: The method `endsWith` determines whether a `String` ends with a specified `String`.
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endsWith` 方法确定一个 `String` 是否以指定的 `String` 结尾。'
- en: It’s a common practice to use multiple `String` methods in a single line of
    code. When chained, the methods are evaluated from left to right.
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单行代码中使用多个 `String` 方法是一种常见的做法。当方法链式调用时，方法是从左到右评估的。
- en: You can use the concatenation operators `+` and `+=` and comparison operators
    `!=` and `==` with `String` objects.
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用连接运算符 `+` 和 `+=` 以及比较运算符 `!=` 和 `==` 与 `String` 对象一起使用。
- en: The Java language provides special support for concatenating `String` objects
    by using the operators `+` and `+=`.
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 语言通过使用运算符 `+` 和 `+=` 提供了对连接 `String` 对象的特殊支持。
- en: The right technique for comparing two `String` values for equality is to use
    the method `equals` defined in the `String` class. This method returns a `true`
    value if the object being compared isn’t `null` and is a `String` object that
    represents the same sequence of characters as the object to which it’s being compared.
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较两个 `String` 值是否相等的方法是使用在 `String` 类中定义的 `equals` 方法。如果被比较的对象不是 `null`，并且是一个表示与被比较对象相同字符序列的
    `String` 对象，则此方法返回 `true` 值。
- en: The comparison operator `==` determines whether both of the reference variables
    are referring to the same `String` objects. Hence, it’s not the right operator
    for comparing `String` values.
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符 `==` 判断两个引用变量是否都指向同一个 `String` 对象。因此，它不是比较 `String` 值的正确运算符。
- en: 'The class `StringBuilder`:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `StringBuilder`：
- en: The class `StringBuilder` is defined in the package `java.lang` and represents
    a mutable sequence of characters.
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 `StringBuilder` 定义在包 `java.lang` 中，表示一个可变的字符序列。
- en: The `StringBuilder` class is very efficient when a user needs to modify a sequence
    of characters often. Because it’s mutable, the value of a `StringBuilder` object
    can be modified without the need to create a new `StringBuilder` object.
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户需要经常修改字符序列时，`StringBuilder` 类非常高效。因为它可变，所以不需要创建一个新的 `StringBuilder` 对象就可以修改
    `StringBuilder` 对象的值。
- en: A `StringBuilder` object can be created using its constructors, which can accept
    either a `String` object, another `StringBuilder` object, an `int` value to specify
    the capacity of `StringBuilder`, or nothing.
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用其构造函数创建一个 `StringBuilder` 对象，该构造函数可以接受一个 `String` 对象、另一个 `StringBuilder`
    对象、一个 `int` 值来指定 `StringBuilder` 的容量，或者不接受任何参数。
- en: The methods `charAt`, `indexOf`, `substring,` and `length` defined in the class
    `StringBuilder` work in the same way as methods with the same names defined in
    the class `String`.
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`StringBuilder`类中定义的`charAt`、`indexOf`、`substring`和`length`方法与在`String`类中定义的同名方法工作方式相同。
- en: The `append` method adds the specified value at the end of the existing value
    of a `StringBuilder` object.
  id: totrans-1211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append`方法将指定的值添加到`StringBuilder`对象现有值的末尾。'
- en: The `insert` method enables you to insert characters at a specified position
    in a `StringBuilder` object. The main difference between the `append` and `insert`
    methods is that the `insert` method enables you to insert the requested data at
    a particular position, whereas the `append` method allows you to add the requested
    data only at the end of the `StringBuilder` object.
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert`方法允许您在`StringBuilder`对象的指定位置插入字符。`append`和`insert`方法之间的主要区别在于，`insert`方法允许您在特定位置插入所需数据，而`append`方法只允许您在`StringBuilder`对象的末尾添加所需数据。'
- en: The method `delete` removes the characters in a substring of the specified `StringBuilder`.
    The method `deleteCharAt` removes the `char` at the specified position.
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`方法从指定的`StringBuilder`的子字符串中删除字符。`deleteCharAt`方法删除指定位置的`char`。'
- en: Unlike the class `String`, the class `StringBuilder` doesn’t define the method
    `trim`.
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`String`类不同，`StringBuilder`类没有定义`trim`方法。
- en: The method `reverse` reverses the sequence of characters of a `StringBuilder`.
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse`方法反转`StringBuilder`中字符的顺序。'
- en: The `replace` method in the class `StringBuilder` replaces a sequence of characters,
    identified by their position, with another `String`.
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuilder`类中的`replace`方法通过字符的位置替换一个由其位置确定的字符序列，用另一个`String`替换。'
- en: In addition to using the method `substring`, you can also use the method `subSequence`
    to retrieve a subsequence of a `StringBuilder` object.
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了使用`substring`方法外，您还可以使用`subSequence`方法检索`StringBuilder`对象的子序列。
- en: 'Arrays:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 数组：
- en: An array is an object that stores a collection of values.
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是一个存储值集合的对象。
- en: An array itself is an object.
  id: totrans-1220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组本身是一个对象。
- en: An array can store two types of data—a collection of primitive data types and
    a collection of objects.
  id: totrans-1221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以存储两种类型的数据——原始数据类型的集合和对象的集合。
- en: You can define one-dimensional and multidimensional arrays.
  id: totrans-1222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以定义一维和多维数组。
- en: A one-dimensional array is an object that refers to a collection of scalar values.
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一维数组是一个引用集合标量值的对象。
- en: A two-dimensional (or more) array is referred to as a multidimensional array.
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二维（或更多）数组被称为多维数组。
- en: A two-dimensional array refers to a collection of objects, in which each of
    the objects is a one-dimensional array.
  id: totrans-1225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二维数组指的是一个对象集合，其中每个对象都是一个一维数组。
- en: Similarly, a three-dimensional array refers to a collection of two-dimensional
    arrays, and so on.
  id: totrans-1226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，三维数组指的是二维数组的集合，依此类推。
- en: Multidimensional arrays may or may not contain the same number of elements in
    each row or column.
  id: totrans-1227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组可能或可能不包含每行或每列相同数量的元素。
- en: 'The creation of an array involves three steps: declaration of an array, allocation
    of an array, and initialization of array elements.'
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数组涉及三个步骤：数组的声明、数组的分配和数组元素的初始化。
- en: An array declaration is composed of an array type, a variable name, and one
    or more occurrences of `[]`.
  id: totrans-1229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组声明由数组类型、变量名和一个或多个`[]`的出现组成。
- en: Square brackets can follow either the variable name or its type. In the case
    of multidimensional arrays, it can follow both of them.
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号可以跟在变量名或其类型之后。在多维数组的情况下，它可以跟在两者之后。
- en: An array declaration creates a variable that refers to `null`.
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组声明创建了一个引用`null`的变量。
- en: Because no elements of an array are created when it’s declared, it’s invalid
    to define the size of an array with its declaration.
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在声明数组时没有创建数组元素，因此不能在声明中定义数组的大小。
- en: Array allocation allocates memory for the elements of an array. When you allocate
    memory for an array, you must specify its dimensions, such as the number of elements
    the array should store.
  id: totrans-1233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组分配为数组的元素分配内存。当你为数组分配内存时，你必须指定其维度，例如数组应存储的元素数量。
- en: Because an array is an object, it’s allocated using the keyword `new`, followed
    by the type of value that it stores, and then its size.
  id: totrans-1234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为数组是一个对象，所以它使用`new`关键字分配，后面跟存储值的类型，然后是其大小。
- en: Once allocated, all the array elements store their default values. Elements
    of an array that store objects refer to `null`. Elements of an array that store
    primitive data types store `0` for integer types (`byte`, `short`, `int`, `long`),
    `0.0` for decimal types (`float` and `double`), `false` for `boolean`, or `/u0000`
    for `char` data.
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦分配，所有数组元素都存储其默认值。存储对象的数组元素引用 `null`。存储原始数据类型的数组元素存储 `0`（对于整型 `byte`、`short`、`int`、`long`），`0.0`（对于十进制类型
    `float` 和 `double`），`false`（对于 `boolean`），或 `/u0000`（对于 `char` 数据）。
- en: To access an element in a two-dimensional array, use two array position values.
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问二维数组中的元素，使用两个数组位置值。
- en: You can combine all the steps of array declaration, allocation, and initialization
    into a single step.
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将数组声明、分配和初始化的所有步骤合并为单步操作。
- en: When you combine array declaration, allocation, and initialization in a single
    step, you can’t specify the size of the array. The size of the array is calculated
    by the number of values that are assigned to the array.
  id: totrans-1238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在单步中组合数组声明、分配和初始化时，你不能指定数组的大小。数组的大小通过分配给数组的值的数量来计算。
- en: You can declare and allocate an array but choose not to initialize its elements
    (for example, `int[] a = new int[5];`).
  id: totrans-1239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以声明和分配一个数组，但可以选择不初始化其元素（例如，`int[] a = new int[5];`）。
- en: The Java compiler doesn’t check the range of the index positions at which you
    try to access an array element. The code throws an `ArrayIndexOutOfBounds-Exception`
    exception if the requested index position doesn’t fall in the valid range at runtime.
  id: totrans-1240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 编译器不会检查你尝试访问数组元素时索引位置的范围。如果请求的索引位置在运行时不属于有效范围，代码将抛出 `ArrayIndexOutOfBounds-Exception`
    异常。
- en: A multidimensional array can be asymmetrical; it may or may not define the same
    number of columns for each of its rows.
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多维数组可以是非对称的；它可能或可能不为每一行定义相同数量的列。
- en: The type of an array can also be an `interface` or `abstract` class. Such an
    array can be used to store objects of classes that inherit from the `interface`
    type or the `abstract` class type.
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的类型也可以是 `interface` 或 `abstract` 类。这样的数组可以用来存储从 `interface` 类型或 `abstract`
    类类型继承的类的对象。
- en: The type of an array can also be `java.lang.Object`. Because all classes extend
    the `java.lang.Object` class, elements of this array can refer to any object.
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的类型也可以是 `java.lang.Object`。因为所有类都扩展了 `java.lang.Object` 类，所以这个数组的元素可以引用任何对象。
- en: All the arrays are objects and can access the variable `length`, which specifies
    the number or components stored by the array.
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有数组都是对象，并且可以访问变量 `length`，该变量指定数组存储的组件数量。
- en: Because all arrays are objects, they inherit and can access all methods from
    the class `Object`.
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为所有数组都是对象，所以它们继承并可以访问 `Object` 类的所有方法。
- en: '`ArrayList`:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`：'
- en: '`ArrayList` is one of the most widely used classes from the Collections framework.
    It offers the best combination of features offered by an array and the List data
    structure.'
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList` 是集合框架中最广泛使用的类之一。它提供了数组和列表数据结构提供的最佳功能组合。'
- en: An `ArrayList` is like a resizable array.
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList` 类似于可调整大小的数组。'
- en: Unlike arrays, you may not specify an initial size to create an `ArrayList`.
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组不同，你无法指定初始大小来创建 `ArrayList`。
- en: '`ArrayList` implements the interface `List` and allows `null` values to be
    added to it.'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList` 实现了 `List` 接口，并允许添加 `null` 值。'
- en: '`ArrayList` implements all list operations (`add`, `modify`, and `delete` values).'
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList` 实现了所有列表操作（`add`、`modify` 和 `delete` 值）。'
- en: '`ArrayList` allows duplicate values to be added to it and maintains its insertion
    order.'
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList` 允许添加重复值，并保持其插入顺序。'
- en: You can use either `Iterator` or `ListIterator` or an enhanced `for` loop to
    iterate over the items of an `ArrayList`.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Iterator`、`ListIterator` 或增强型 `for` 循环来遍历 `ArrayList` 的项目。
- en: '`ArrayList` supports generics, making it type safe.'
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList` 支持泛型，使其类型安全。'
- en: Internally, an array of type `java.lang.Object` is used to store the data in
    an `ArrayList`.
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，`java.lang.Object` 类型的数组用于在 `ArrayList` 中存储数据。
- en: You can add a value to an `ArrayList` either at its end or at a specified position
    by using the method `add`.
  id: totrans-1256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 `add` 方法在 `ArrayList` 的末尾或指定位置添加一个值。
- en: An iterator (`Iterator` or `ListIterator`) lets you remove elements as you iterate
    through an `ArrayList`. It’s not possible to remove elements from an `ArrayList`
    while iterating through it using a `for` loop.
  id: totrans-1257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迭代器（`Iterator` 或 `ListIterator`）允许你在遍历 `ArrayList` 时移除元素。使用 `for` 循环遍历 `ArrayList`
    时无法移除元素。
- en: An `ArrayList` preserves the order of insertion of its elements. `ListIterator`
    and the enhanced `for` loop will return the elements in the order in which they
    were added to the `ArrayList`.
  id: totrans-1258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList`保留其元素的插入顺序。`ListIterator`和增强型`for`循环将按元素添加到`ArrayList`中的顺序返回元素。'
- en: You can use the method `set` to modify an `ArrayList` by either replacing an
    existing element in `ArrayList` or modifying its existing values.
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`set`方法通过替换`ArrayList`中的现有元素或修改其现有值来修改`ArrayList`。
- en: '`remove(int)` removes the element at the specified position in the list.'
  id: totrans-1260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(int)`从列表中移除指定位置的元素。'
- en: '`remove(Object o)` removes the first occurrence of the specified element from
    the list, if it’s present.'
  id: totrans-1261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(Object o)`从列表中移除指定的元素的第一种出现，如果存在的话。'
- en: You can add multiple elements to an `ArrayList` from another `ArrayList` or
    any other class that’s a subclass of `Collection` by using the method `addAll`.
  id: totrans-1262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`addAll`方法从另一个`ArrayList`或任何其他是`Collection`子类的类中添加多个元素到`ArrayList`。
- en: You can remove all the `ArrayList` elements by calling the method `clear` on
    it.
  id: totrans-1263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过调用`clear`方法来移除所有的`ArrayList`元素。
- en: '`get(int index)` returns the element at the specified position in the list.'
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(int index)`返回列表中指定位置的元素。'
- en: '`size()` returns the number of elements in the list.'
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`返回列表中的元素数量。'
- en: '`contains(Object o)` returns `true` if the list contains the specified element.'
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains(Object o)`如果列表包含指定的元素，则返回`true`。'
- en: '`indexOf(Object o)` returns the index of the first occurrence of the specified
    element in the list, or `–1` if the list doesn’t contain the element.'
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(Object o)`返回列表中指定元素第一次出现的索引，如果列表不包含该元素则返回`-1`。'
- en: '`lastIndexOf(Object o)` returns the index of the last occurrence of the specified
    element in the list, or `–1` if the list doesn’t contain the element.'
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOf(Object o)`返回列表中指定元素最后一次出现的索引，如果列表不包含该元素则返回`-1`。'
- en: The method `clone` defined in the class `ArrayList` returns a shallow copy of
    this `ArrayList` instance. *Shallow copy* means that the method creates a new
    instance of the `ArrayList` to be cloned, but the `ArrayList` elements aren’t
    copied.
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList`类中定义的`clone`方法返回此`ArrayList`实例的浅拷贝。*浅拷贝*意味着该方法创建了一个新的`ArrayList`实例以进行克隆，但`ArrayList`元素没有被复制。'
- en: You can use the method `toArray` to return an array containing all the elements
    in `ArrayList` in sequence from the first to the last element.
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`toArray`方法返回一个包含`ArrayList`中所有元素的数组，从第一个元素到最后一个元素按顺序排列。
- en: 'Comparing objects for equality:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 比较对象以确定相等性：
- en: Any Java class can define a set of rules to determine whether two objects should
    be considered equal.
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Java类都可以定义一组规则来确定两个对象是否应该被视为相等。
- en: The method `equals` is defined in the class `java.lang.Object`. All the Java
    classes directly or indirectly inherit this class.
  id: totrans-1273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals`方法定义在`java.lang.Object`类中。所有Java类直接或间接继承了这个类。'
- en: The default implementation of the `equals` method only checks whether two object
    variables refer to the same object.
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals`方法的默认实现仅检查两个对象变量是否引用同一个对象。'
- en: Because instance variables are used to store the state of an object, it’s common
    to compare the values of the instance variables to determine whether two objects
    should be considered equal.
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为实例变量用于存储对象的状态，所以通常比较实例变量的值来确定两个对象是否应该被视为相等。
- en: When you override the `equals` method in your class, make sure that you use
    the correct method signature for the `equals` method.
  id: totrans-1276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您在类中重写`equals`方法时，请确保您使用正确的`equals`方法签名。
- en: The Java API defines a contract for the `equals` method, which should be taken
    care of when you implement the method in any of your classes.
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java API为`equals`方法定义了一个约定，您在实现任何类中的方法时都应该注意。
- en: According to the contract of the method `equals`, if a `null` value is passed
    to it, the method `equals` should return `false`.
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据方法`equals`的约定，如果向它传递了一个`null`值，则方法`equals`应该返回`false`。
- en: If the `equals` method modifies the value of any of the instance variables of
    the method parameter passed to it, or of the object on which it is called, it
    will violate the contract.
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`equals`方法修改了传递给它的方法参数的任何实例变量的值，或者修改了它所调用的对象上的值，它将违反约定。
- en: '`LocalDate`:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDate`:'
- en: '`LocalDate` can be used to store dates like 2015-12-27 without time or time
    zones.'
  id: totrans-1281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate`可用于存储没有时间或时区的日期，如2015-12-27。'
- en: '`LocalDate` instances are immutable.'
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate`实例是不可变的。'
- en: The `LocalDate` constructor is marked private.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate`构造函数被标记为私有。'
- en: 'Use `LocalDate`’s overloaded static method `of()` to instantiate it:'
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LocalDate` 的重载静态方法 `of()` 来实例化它：
- en: '`public static LocalDate of(int year, int month, int dayOfMonth)`'
  id: totrans-1285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static LocalDate of(int year, int month, int dayOfMonth)`'
- en: '`public static LocalDate of(int year, Month month, int dayOfMonth)`'
  id: totrans-1286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static LocalDate of(int year, Month month, int dayOfMonth)`'
- en: The `of()` methods will throw a `DateTimeException` when values passed to it
    are out of range.
  id: totrans-1287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递给 `of()` 方法的值超出范围时，`of()` 方法将抛出 `DateTimeException`。
- en: In date classes released with Java 8, the January month is represented by `int`
    value `1` and not `0`. The date classes defined with or prior to Java 7 represent
    January using `0`.
  id: totrans-1288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 8 中发布的日期类中，1月用 `int` 值 `1` 表示，而不是 `0`。Java 7 或之前定义的日期类使用 `0` 来表示1月。
- en: '`LocalDate`’s static method `now()` returns the current date from the system
    clock as a `LocalDate` instance.'
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate` 的静态方法 `now()` 返回系统时钟的当前日期，作为一个 `LocalDate` 实例。'
- en: Use `LocalDate`’s static method `parse()` to parse a string in the format 2016-02-27
    to instantiate `LocalDate`.
  id: totrans-1290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LocalDate` 的静态方法 `parse()` 解析格式为 2016-02-27 的字符串以实例化 `LocalDate`。
- en: If you pass invalid values to `parse()` or `of()`, you’ll get a `DateTimeParse-Exception`.
    The format of the string passed to `parse()` must be exactly of the format 9999-99-99\.
    The month and date values passed to `parse()` must be of two digits; a single
    digit is considered an invalid value. For days and months with a value 1–9, pass
    01–09.
  id: totrans-1291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将无效值传递给 `parse()` 或 `of()`，您将得到 `DateTimeParseException`。传递给 `parse()` 的字符串格式必须正好是
    9999-99-99 的格式。传递给 `parse()` 的月份和日期值必须是两位数字；单个数字被视为无效值。对于值为 1–9 的日和月，传递 01–09。
- en: 'You can use `LocalDate`’s instance methods like `get`*`XX`*`()` to query `LocalDate`
    on its year, month, and date values:'
  id: totrans-1292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `LocalDate` 的实例方法 `get`*`XX`*`()` 来查询 `LocalDate` 的年、月和日期值：
- en: '`getDayOfMonth()`'
  id: totrans-1293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDayOfMonth()`'
- en: '`getDayOfWeek()`'
  id: totrans-1294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDayOfWeek()`'
- en: '`getDayOfYear()`'
  id: totrans-1295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDayOfYear()`'
- en: '`getMonth()`'
  id: totrans-1296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMonth()`'
- en: '`getMonthValue()`'
  id: totrans-1297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMonthValue()`'
- en: '`getYear()`'
  id: totrans-1298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getYear()`'
- en: '`LocalDate`’s instance `minus`*`XX`*`()` methods return a copy of its value
    after subtracting the specified days, months, weeks, or years from it:'
  id: totrans-1299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate` 的实例 `minus`*`XX`*`()` 方法返回从其值中减去指定天数、月份、周或年份后的副本：'
- en: '`minusDays()`'
  id: totrans-1300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minusDays()`'
- en: '`minusMonths()`'
  id: totrans-1301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minusMonths()`'
- en: '`minusWeeks()`'
  id: totrans-1302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minusWeeks()`'
- en: '`minusYears()`'
  id: totrans-1303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minusYears()`'
- en: '`LocalDate` is immutable. All the methods that seem to manipulate its value
    return a copy of the `LocalDate` instance on which it’s called.'
  id: totrans-1304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate` 是不可变的。所有看似操纵其值的方法都返回调用它的 `LocalDate` 实例的副本。'
- en: 'The `plus`*`XX`*`()` methods return a copy of `LocalDate`’s value after adding
    the specified days, months, or year to it:'
  id: totrans-1305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plus`*`XX`*`()` 方法返回在它上添加了指定天数、月份或年份后的 `LocalDate` 值的副本：'
- en: '`plusDays()`'
  id: totrans-1306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plusDays()`'
- en: '`plusMonths()`'
  id: totrans-1307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plusMonths()`'
- en: '`plusWeeks()`'
  id: totrans-1308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plusWeeks()`'
- en: '`plusYears()`'
  id: totrans-1309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plusYears()`'
- en: 'The `with`*`XX`*`()` methods return a copy of `LocalDate`’s value replacing
    the specified day, month, or year in it:'
  id: totrans-1310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`*`XX`*`()` 方法返回 `LocalDate` 值的副本，其中替换了指定的日、月或年：'
- en: '`withDayOfMonth()`'
  id: totrans-1311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withDayOfMonth()`'
- en: '`withDayOfYear()`'
  id: totrans-1312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withDayOfYear()`'
- en: '`withMonth()`'
  id: totrans-1313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withMonth()`'
- en: '`withYear()`'
  id: totrans-1314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withYear()`'
- en: All additions, subtractions, or replacements to `LocalDate` consider leap years.
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对 `LocalDate` 的添加、减去或替换都考虑闰年。
- en: Despite the verbs used in the previous methods (*add*, *subtract*, *replace*),
    none of them actually modifies an existing `LocalDate`—all of them return a new
    instance with the requested changes applied.
  id: totrans-1316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管前述方法（*添加*、*减去*、*替换*）使用了动词，但它们实际上并没有修改现有的 `LocalDate`——所有这些方法都返回一个应用了请求更改的新实例。
- en: The `LocalDate` class defines overloaded `atTime()` instance methods. These
    methods combine `LocalDate` with time to create and return `LocalDateTime`, which
    stores both the date and time.
  id: totrans-1317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate` 类定义了重载的 `atTime()` 实例方法。这些方法将 `LocalDate` 与时间结合，创建并返回 `LocalDateTime`，它存储日期和时间。'
- en: Use the method `toEpochDay()` to convert `LocalDate` to the epoch date—the count
    of days from January 1, 1970.
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `toEpochDay()` 方法将 `LocalDate` 转换为纪元日期——从1970年1月1日起的天数计数。
- en: '`LocalTime`:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalTime`:'
- en: It stores time in the format hours-minutes-seconds (without a time zone).
  id: totrans-1320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以小时-分钟-秒（不带时区）的格式存储时间。
- en: It stores time to nanosecond precision.
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以纳秒精度存储时间。
- en: '`LocalTime` is immutable.'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime` 是不可变的。'
- en: You can instantiate `LocalTime` using `LocalTime`’s static method `of()` that
    accepts hours, minutes, seconds, and nanoseconds.
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `LocalTime` 的静态方法 `of()` 来实例化 `LocalTime`，该方法接受小时、分钟、秒和纳秒。
- en: The `of()` method uses a 24-hour clock to specify the hour value.
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of()` 方法使用24小时制来指定小时值。'
- en: The `of()` method will throw a runtime exception, `DateTimeException`, if you
    pass an invalid range of values to it.
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您向 `of()` 方法传递无效的范围值，它将抛出一个运行时异常，`DateTimeException`。
- en: '`LocalTime` doesn’t define a method to pass a.m. or p.m. Use values 0–23 to
    define hours. If you pass out-of-range values to either hours, minutes, or seconds,
    you’ll get a runtime exception.'
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime` 没有定义传递上午或下午的方法。使用 0–23 的值来定义小时。如果您传递超出范围的值给小时、分钟或秒，您将得到一个运行时异常。'
- en: To get the current time from the system clock, use the static method `now()`.
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从系统时钟获取当前时间，请使用静态方法 `now()`。
- en: You can parse a string to instantiate `LocalTime` by using its static method
    `parse()`. You can either pass a string in the format 15:08:23 (hours:minutes:seconds)
    or parse any text using `DateTimeFormatter`.
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用其静态方法 `parse()` 将字符串解析为 `LocalTime` 实例。您可以选择传递格式为 15:08:23（小时:分钟:秒）的字符串，或者使用
    `DateTimeFormatter` 解析任何文本。
- en: If you pass invalid string values to `parse()`, the code will compile but will
    throw a runtime exception. If you don’t pass a `DateTimeFormatter`, the format
    of the string passed to `parse()` must be exactly of the format 99:99:99\. The
    hours and minutes values passed to `parse()` must be of two digits; a single digit
    is considered an invalid value. For hours and minutes with a value 0–9, pass 00–09.
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您向 `parse()` 传递无效的字符串值，代码将编译但会抛出一个运行时异常。如果您没有传递 `DateTimeFormatter`，传递给 `parse()`
    的字符串的格式必须正好是 99:99:99 的格式。传递给 `parse()` 的小时和分钟值必须是两位数；单个数字被视为无效值。对于值为 0–9 的小时和分钟，传递
    00–09。
- en: 'You can use constants from the `LocalTime` class to work with predefined times:'
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `LocalTime` 类的常量来处理预定义的时间：
- en: '`LocalTime.MIN`—Minimum supported time, that is, 00:00'
  id: totrans-1331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.MIN`—支持的最小时间，即 00:00'
- en: '`LocalTime.MAX`—Maximum supported time, that is, 23:59:59.999999999'
  id: totrans-1332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.MAX`—支持的最大时间，即 23:59:59.999999999'
- en: '`LocalTime.MIDNIGHT`—Time when day starts, that is, 00:00'
  id: totrans-1333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.MIDNIGHT`—一天开始的时间，即 00:00'
- en: '`LocalTime.NOON`—Noontime, that is, 12:00'
  id: totrans-1334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime.NOON`—中午时间，即 12:00'
- en: You can use instance methods like `get`*`XX`*`()` to query `LocalTime` on its
    hour, minutes, seconds, and nanoseconds. All these methods return an `int` value.
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用类似 `get`*`XX`*`()` 的实例方法来查询 `LocalTime` 的时、分、秒和纳秒。所有这些方法都返回一个 `int` 值。
- en: The correct method names to query `LocalTime` are `getHour()`, `getMinute()`,
    `getSecond()`, and `getNano()`. Watch out for exam questions that use invalid
    method names like `getHours()`, `getMinutes()`, `getSeconds()`, or `getNanoSeconds()`.
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 `LocalTime` 的正确方法名是 `getHour()`、`getMinute()`、`getSecond()` 和 `getNano()`。注意考试中可能使用无效方法名的情况，如
    `getHours()`、`getMinutes()`、`getSeconds()` 或 `getNanoSeconds()`。
- en: You can use the instance methods `isAfter()` and `isBefore()` to check whether
    a time is after or before the specified time.
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用实例方法 `isAfter()` 和 `isBefore()` 来检查时间是否在指定时间之后或之前。
- en: You can use the instance methods `minusHours()`, `minusMinutes()`, `minusSeconds()`,
    and `minusNanos()` to create and return a copy of `LocalTime` instances with the
    specified period subtracted.
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用实例方法 `minusHours()`、`minusMinutes()`、`minusSeconds()` 和 `minusNanos()`
    来创建并返回具有指定时间段减去的 `LocalTime` 实例的副本。
- en: 'Unlike the `get`*`XXX`*`()` methods, the `minus`*`XXX`*`()` methods use the
    plural form: `getHour()` versus `minusHours()`, `getMinute()` versus `minusMinutes()`,
    `getSecond()` versus `minusSeconds(),` and `getNano()` versus `minusNanos()`.'
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `get`*`XXX`*`()` 方法不同，`minus`*`XXX`*`()` 方法使用复数形式：`getHour()` 对比 `minusHours()`、`getMinute()`
    对比 `minusMinutes()`、`getSecond()` 对比 `minusSeconds()`、`getNano()` 对比 `minusNanos()`。
- en: The `plusHours()`, `plusMinutes()`, `plusSeconds()`, and `plusNanos()` methods
    accept long values and add the specified hours, minutes, seconds, or nanoseconds
    to time, returning its copy as `LocalTime`.
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plusHours()`、`plusMinutes()`、`plusSeconds()` 和 `plusNanos()` 方法接受长整型值，并将指定的小时、分钟、秒或纳秒添加到时间中，返回其副本作为
    `LocalTime`。'
- en: '`LocalTime` is immutable. Calling any method on an instance won’t modify its
    value.'
  id: totrans-1341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime` 是不可变的。对实例调用任何方法都不会修改其值。'
- en: The `withHour()`, `withMinute()`, `withSecond()`, and `withNano()` methods accept
    an `int` value and return a copy of `LocalTime` with the specified value altered.
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withHour()`、`withMinute()`、`withSecond()` 和 `withNano()` 方法接受一个 `int` 值，并返回一个具有指定值更改的
    `LocalTime` 副本。'
- en: The class `LocalTime` defines the method `atDate()`, which can be passed a `Local-Date`
    instance to create a `LocalDateTime` instance.
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 `LocalTime` 定义了 `atDate()` 方法，该方法可以传入一个 `Local-Date` 实例来创建一个 `LocalDateTime`
    实例。
- en: '`LocalDateTime`:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalDateTime`:'
- en: '`LocalDateTime` stores a value like 2050-06-18T14:20:30:908765 (year-month-dayThours:minutes:seconds:nanoseconds).'
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDateTime` 存储一个值，如 2050-06-18T14:20:30:908765（年-月-日Th时:分:秒:纳秒）。'
- en: The `LocalDateTime` class uses the letter *T* to separate date and time values
    in its printed value.
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDateTime` 类在其打印值中使用字母 *T* 来分隔日期和时间值。'
- en: You can consider this class to offer the functionality of both the `LocalDate`
    and `LocalTime` classes. This class defines similar methods as those defined by
    the `LocalDate` and `LocalTime` classes.
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将此类视为提供 `LocalDate` 和 `LocalTime` 类的功能。此类定义了与 `LocalDate` 和 `LocalTime` 类中定义的方法类似的方法。
- en: '`Period`:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '`Period`：'
- en: The `Period` class represents a date-based amount in years, months, and days,
    like 2 years, 5 months, and 10 days. To work with time-based amounts in seconds
    and nanoseconds, you can use the `Duration` class.
  id: totrans-1349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Period` 类表示基于日期的年、月和日的时间量，例如 2 年、5 个月和 10 天。要处理基于秒和纳秒的时间量，你可以使用 `Duration`
    类。'
- en: You can add or subtract `Period` instances from `LocalDate` and `LocalDateTime`
    classes.
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从 `LocalDate` 和 `LocalDateTime` 类中添加或减去 `Period` 实例。
- en: '`Period` is an immutable class.'
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Period` 是一个不可变类。'
- en: The `Period` class defines multiple factory methods to create its instances.
    The static methods `of()`, `ofYears()`, `ofMonths()`, `ofWeeks()`, and `ofDays()`
    accept `int` values to create periods of years, months, weeks, or days.
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Period` 类定义了多个工厂方法来创建其实例。静态方法 `of()`、`ofYears()`、`ofMonths()`、`ofWeeks()`
    和 `ofDays()` 接受 `int` 值来创建年、月、周或日的时间周期。'
- en: A `Period` of 35 days is not stored as 1 month and 5 days. Its individual elements,
    that is, days, months, and years, are stored the way it is initialized.
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 35 天的 `Period` 不是存储为 1 个月和 5 天。它的各个元素，即天数、月份和年份，是以其初始化的方式存储的。
- en: You can define positive or negative periods of time. You can define `Period`
    instances representing 15 or -15 days.
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以定义正数或负数的时间周期。你可以定义表示 15 或 -15 天的 `Period` 实例。
- en: You can also parse a string to instantiate `Period` by using its static method
    `parse`. This method parses string values of the format PnYnMnD or PnW, where
    *n* represents a number and the letters (*P*, *Y*, *M*, *D*, and *W*) represent
    parse, year, month, day, and week. These letters can exist in lower- or uppercase.
    Each string must start with the letter *p* or *P* and must include at least one
    of the four sections, that is, year, month, week, or day.
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用其静态方法 `parse` 通过解析字符串来实例化 `Period`。此方法解析格式为 PnYnMnD 或 PnW 的字符串值，其中 *n*
    代表一个数字，而字母 (*P*, *Y*, *M*, *D*, 和 *W*) 分别代表解析、年、月、日和周。这些字母可以是小写或大写。每个字符串必须以字母
    *p* 或 *P* 开头，并且必须包含至少四个部分之一，即年、月、周或日。
- en: If you pass invalid string values to `parse()`, the code will compile but will
    throw a runtime exception.
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你向 `parse()` 方法传递无效的字符串值，代码将编译但会抛出运行时异常。
- en: You can also use the static method `between(LocalDate dateInclusive, LocalDate
    dateExclusive)` to instantiate `Period`.
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用静态方法 `between(LocalDate dateInclusive, LocalDate dateExclusive)` 来实例化
    `Period`。
- en: The static method `between` accepts two `LocalDate` instances and returns a
    `Period` instance representing number of years, days, and months between the two
    dates. The first date is included, but the second date is excluded in the returned
    `Period`.
  id: totrans-1358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法 `between` 接受两个 `LocalDate` 实例，并返回一个表示两个日期之间年、日和月数的 `Period` 实例。第一个日期包含在内，但第二个日期在返回的
    `Period` 中被排除。
- en: The `Period` class implements the interface `TemporalAmount`, so it can be used
    with the methods `plus()` and `minus()` defined in the classes `LocalDateTime`
    and `LocalDate`.
  id: totrans-1359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Period` 类实现了 `TemporalAmount` 接口，因此它可以与 `LocalDateTime` 和 `LocalDate` 类中定义的
    `plus()` 和 `minus()` 方法一起使用。'
- en: Because `Period` instances can represent positive or negative periods (like
    15 days or -15 days), you can subtract days from a `LocalDate` or `LocalDateTime`
    by calling the method `plus`.
  id: totrans-1360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `Period` 实例可以表示正数或负数周期（例如 15 天或 -15 天），你可以通过调用 `plus` 方法从 `LocalDate` 或 `LocalDateTime`
    中减去天数。
- en: Similarly, you can use the method `minus()` with classes `LocalDate` and `LocalDateTime`
    to subtract a period of years, months, weeks, or days.
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，你可以使用 `minus()` 方法与 `LocalDate` 和 `LocalDateTime` 类一起使用，以减去年、月、周或日的时间周期。
- en: You can use the instance methods `getYears()`, `getMonths()`, and `getDays()`
    to query a `Period` instance on its years, months, and days. All these methods
    return an `int` value.
  id: totrans-1362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用实例方法 `getYears()`、`getMonths()` 和 `getDays()` 来查询 `Period` 实例的年、月和日。所有这些方法都返回一个
    `int` 值。
- en: When you initialize a `Period` instance with days more than 31 or months more
    than 12, it doesn’t recalculate its years, months, or days components.
  id: totrans-1363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用超过 31 天或超过 12 个月的日期初始化 `Period` 实例时，它不会重新计算其年、月或日组件。
- en: You can query whether any of three units of a `Period` is negative using the
    methods `isNegative` and `isZero`. A `Period` instance is negative if all three
    of its units are zero.
  id: totrans-1364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `isNegative` 和 `isZero` 方法查询 `Period` 的三个单位中是否有任何一个为负。如果 `Period` 的所有三个单位都是零，则
    `Period` 实例为负。
- en: You can use instance methods `minus(TemporalAmount)`, `minusDays(long)`, `minus-Months(long)`,
    `minusYears(long)`, and `multipliedBy(int)` to create and return a copy of `Period`
    instances with the specified period subtracted or modified.
  id: totrans-1365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用实例方法 `minus(TemporalAmount)`，`minusDays(long)`，`minus-Months(long)`，`minusYears(long)`
    和 `multipliedBy(int)` 来创建并返回具有指定周期减去或修改的 `Period` 实例的副本。
- en: 'In the class `Period`, both the `get`*`XXX`*`()` methods and `minus`*`XXX`*`()`
    methods use the plural form: `getYears()`, `minusHours()`.'
  id: totrans-1366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Period` 类中，`get`*`XXX`*`()` 方法和 `minus`*`XXX`*`()` 方法都使用复数形式：`getYears()`，`minusHours()`。
- en: When you subtract a `Period` instance using the `minus`*`XXX`*`()` methods,
    its individual elements are subtracted. Subtracting P10D from P1M returns P1M-10D
    and not P20D.
  id: totrans-1367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `minus`*`XXX`*`()` 方法减去 `Period` 实例时，其各个元素会被减去。从 P1M 减去 P10D 返回 P1M-10D，而不是
    P20D。
- en: The method `multipliedBy(int)` in the class `Period` is used to modify all elements
    of a `Period` instance. `Period` doesn’t define *divideBy*.
  id: totrans-1368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Period` 类中的 `multipliedBy(int)` 方法用于修改 `Period` 实例的所有元素。`Period` 没有定义 *divideBy*。'
- en: Adding a `Period` of 10 months to a `Period` of 5 months gives 15 months, not
    1 year and 3 months.
  id: totrans-1369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 10 个月的 `Period` 加到 5 个月的 `Period` 上得到 15 个月，而不是 1 年和 3 个月。
- en: The method `toTotalMonths()` returns the total number of months in the period
    by multiplying the number of years by 12 and adding the number of months.
  id: totrans-1370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toTotalMonths()` 方法通过将年数乘以 12 并加上月数来返回周期中的总月数。'
- en: '`DateTimeFormatter`'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter`'
- en: Defined in the package `java.time.format`, the class `DateTimeFormatter` can
    be used to format and parse date and time objects.
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义在 `java.time.format` 包中，`DateTimeFormatter` 类可以用来格式化和解析日期和时间对象。
- en: A `DateTimeFormatter` can define rules to format or parse a date object, time
    object, or both.
  id: totrans-1373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter` 可以定义规则来格式化或解析日期对象、时间对象或两者。'
- en: 'You can instantiate or access a `DateTimeFormatter` object in multiple ways:'
  id: totrans-1374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过多种方式实例化或访问 `DateTimeFormatter` 对象：
- en: By calling a static `of`*`XXX`* method, passing it a `FormatStyle` value
  id: totrans-1375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用静态 `of`*`XXX`* 方法，传递一个 `FormatStyle` 值
- en: By accessing public static fields of `DateTimeFormatter`
  id: totrans-1376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过访问 `DateTimeFormatter` 的公共静态字段
- en: By using a static method `ofPattern` and passing it a string value
  id: totrans-1377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用静态方法 `ofPattern` 并传递一个字符串值
- en: To instantiate a `DateTimeFormatter` using `of`*`XXX`* methods, pass it a `FormatStyle`
    value (`FormatStyle.FULL`, `FormatStyle.LONG`, `FormatStyle.MEDIUM`, or `FormatStyle.SHORT`).
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `of`*`XXX`* 方法实例化 `DateTimeFormatter` 时，传递一个 `FormatStyle` 值（`FormatStyle.FULL`，`FormatStyle.LONG`，`FormatStyle.MEDIUM`
    或 `FormatStyle.SHORT`）。
- en: 'You can access a `DateTimeFormatter` object by using the public and static
    fields of this class: `BASIC_ISO_DATE`, `ISO_DATE`, `ISO_TIME`, and `ISO_DATE_TIME`.'
  id: totrans-1379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用这个类的公共和静态字段来访问 `DateTimeFormatter` 对象：`BASIC_ISO_DATE`，`ISO_DATE`，`ISO_TIME`
    和 `ISO_DATE_TIME`。
- en: The method `format` in `DateTimeFormatter` formats a date or time object to
    a `String` using the rules of the formatter.
  id: totrans-1380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter` 中的 `format` 方法使用格式器的规则将日期或时间对象格式化为 `String`。'
- en: To parse a date or time object, you can use either the `parse` method in date/time
    objects or the `parse` method in the `DateTimeFormatter` class.
  id: totrans-1381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要解析日期或时间对象，你可以使用日期/时间对象中的 `parse` 方法或 `DateTimeFormatter` 类中的 `parse` 方法。
- en: 4.9\. Sample exam questions
  id: totrans-1382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9\. 样本考试问题
- en: '**[Q4-1.](#ch04qa2q0a1)**'
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-1.](#ch04qa2q0a1)**'
- en: ''
  id: totrans-1384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-1387
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ''
  id: totrans-1388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`4c010`'
  id: totrans-1389
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4c010`'
- en: '`4c10`'
  id: totrans-1390
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4c10`'
- en: '`113`'
  id: totrans-1391
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`113`'
- en: '`103`'
  id: totrans-1392
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`103`'
- en: Compilation error
  id: totrans-1393
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**[Q4-2.](#ch04qa2q0a2)**'
  id: totrans-1394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-2.](#ch04qa2q0a2)**'
- en: ''
  id: totrans-1395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-1398
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ''
  id: totrans-1399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0:0`'
  id: totrans-1400
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:0`'
- en: '`a:b`'
  id: totrans-1401
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a:b`'
- en: '`0:b`'
  id: totrans-1402
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:b`'
- en: '`a:0`'
  id: totrans-1403
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a:0`'
- en: Compilation error
  id: totrans-1404
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**[Q4-3.](#ch04qa2q0a3)**'
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-3.](#ch04qa2q0a3)**'
- en: ''
  id: totrans-1406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following are valid lines of code to define a multidimensional
    `int` array?
  id: totrans-1407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些是定义多维 `int` 数组的有效代码行？
- en: ''
  id: totrans-1408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`int[][] array1 = {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`'
  id: totrans-1409
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int[][] array1 = {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`'
- en: '`int[][] array2 = new array() {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`'
  id: totrans-1410
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int[][] array2 = new array() {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`'
- en: '`int[][] array3 = {1, 2, 3}, {0}, {1, 2,3, 4, 5};`'
  id: totrans-1411
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int[][] array3 = {1, 2, 3}, {0}, {1, 2,3, 4, 5};`'
- en: '`int[][] array4 = new int[2][];`'
  id: totrans-1412
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int[][] array4 = new int[2][];`'
- en: '**[Q4-4.](#ch04qa2q0a4)**'
  id: totrans-1413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-4.](#ch04qa2q0a4)**'
- en: ''
  id: totrans-1414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are correct?
  id: totrans-1415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些陈述是正确的？
- en: ''
  id: totrans-1416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code executes without an error or exception:'
  id: totrans-1417
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码执行没有错误或异常：
- en: ''
  id: totrans-1418
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-1419
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: ''
  id: totrans-1420
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1421
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Because `ArrayList` stores only objects, you can’t pass an element of an `ArrayList`
    to a `switch` construct.
  id: totrans-1422
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`ArrayList`只存储对象，所以你不能将`ArrayList`的元素传递给`switch`构造。
- en: Calling `clear()` or `remove()` on an `ArrayList` will remove all its elements.
  id: totrans-1423
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ArrayList`上调用`clear()`或`remove()`将移除其所有元素。
- en: If you frequently add elements to an `ArrayList`, specifying a larger capacity
    will improve the code efficiency.
  id: totrans-1424
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你经常向`ArrayList`添加元素，指定更大的容量将提高代码效率。
- en: Calling the method `clone()` on an `ArrayList` creates its shallow copy; that
    is, it doesn’t clone the individual list elements.
  id: totrans-1425
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ArrayList`上调用方法`clone()`创建其浅拷贝；也就是说，它不会克隆单个列表元素。
- en: '**[Q4-5.](#ch04qa2q0a5)**'
  id: totrans-1426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-5.](#ch04qa2q0a5)**'
- en: ''
  id: totrans-1427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are correct?
  id: totrans-1428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: ''
  id: totrans-1429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An `ArrayList` offers a resizable array, which is easily managed using the methods
    it provides. You can add and remove elements from an `ArrayList`.
  id: totrans-1430
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayList`提供了一个可调整大小的数组，你可以通过它提供的方法轻松管理。你可以从`ArrayList`中添加和删除元素。'
- en: Values stored by an `ArrayList` can be modified.
  id: totrans-1431
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayList`存储的值可以被修改。'
- en: You can iterate through elements of an `ArrayList` using a `for` loop, `Iterator`,
    or `ListIterator`.
  id: totrans-1432
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`for`循环、`Iterator`或`ListIterator`遍历`ArrayList`的元素。
- en: An `ArrayList` requires you to specify the total number of elements before you
    can store any elements in it.
  id: totrans-1433
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你可以在`ArrayList`中存储任何元素之前，`ArrayList`要求你指定元素的总数。
- en: An `ArrayList` can store any type of object.
  id: totrans-1434
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayList`可以存储任何类型的对象。'
- en: '**[Q4-6.](#ch04qa2q0a6)**'
  id: totrans-1435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-6.](#ch04qa2q0a6)**'
- en: ''
  id: totrans-1436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-1439
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ''
  id: totrans-1440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Line 7 prints `true`.
  id: totrans-1441
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第7行打印`true`。
- en: Line 7 prints `false`.
  id: totrans-1442
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第7行打印`false`。
- en: Line 8 prints `-1`.
  id: totrans-1443
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第8行打印`-1`。
- en: Line 8 prints `1`.
  id: totrans-1444
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第8行打印`1`。
- en: Line 9 removes all elements of the list `ejg`.
  id: totrans-1445
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第9行移除列表`ejg`的所有元素。
- en: Line 9 sets the list `ejg` to `null`.
  id: totrans-1446
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第9行将列表`ejg`设置为`null`。
- en: Line 10 prints `null`.
  id: totrans-1447
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第10行打印`null`。
- en: Line 10 prints `[]`.
  id: totrans-1448
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第10行打印`[]`。
- en: Line 10 prints a value similar to `ArrayList@16356`.
  id: totrans-1449
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第10行打印一个类似于`ArrayList@16356`的值。
- en: Line 11 throws an exception.
  id: totrans-1450
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第11行抛出异常。
- en: Line 11 prints `null`.
  id: totrans-1451
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第11行打印`null`。
- en: '**[Q4-7.](#ch04qa2q0a7)**'
  id: totrans-1452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-7.](#ch04qa2q0a7)**'
- en: ''
  id: totrans-1453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-1456
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ''
  id: totrans-1457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`true` printed once'
  id: totrans-1458
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一次`true`
- en: '`false` printed once'
  id: totrans-1459
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一次`false`
- en: '`true` printed in an infinite loop'
  id: totrans-1460
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无限循环中打印`true`
- en: '`false` printed in an infinite loop'
  id: totrans-1461
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无限循环中打印`false`
- en: '**[Q4-8.](#ch04qa2q0a8)**'
  id: totrans-1462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-8.](#ch04qa2q0a8)**'
- en: ''
  id: totrans-1463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-1466
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ''
  id: totrans-1467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`gZmeAZ`'
  id: totrans-1468
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZmeAZ`'
- en: '`gZmeAa`'
  id: totrans-1469
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZmeAa`'
- en: '`gZm`'
  id: totrans-1470
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZm`'
- en: '`gZ`'
  id: totrans-1471
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZ`'
- en: '`game`'
  id: totrans-1472
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`game`'
- en: '**[Q4-9.](#ch04qa2q0a9)**'
  id: totrans-1473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-9.](#ch04qa2q0a9)**'
- en: ''
  id: totrans-1474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-1477
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ''
  id: totrans-1478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`gZmeAZ`'
  id: totrans-1479
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZmeAZ`'
- en: '`gZmeAa`'
  id: totrans-1480
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZmeAa`'
- en: '`gZm`'
  id: totrans-1481
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZm`'
- en: '`gZ`'
  id: totrans-1482
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZ`'
- en: '`game`'
  id: totrans-1483
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`game`'
- en: '**[Q4-10.](#ch04qa2q0a10)**'
  id: totrans-1484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-10.](#ch04qa2q0a10)**'
- en: ''
  id: totrans-1485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-1488
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ''
  id: totrans-1489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`12S512S5`'
  id: totrans-1490
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`12S512S5`'
- en: '`12S12S`'
  id: totrans-1491
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`12S12S`'
- en: '`1025102S`'
  id: totrans-1492
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1025102S`'
- en: Runtime exception
  id: totrans-1493
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '**[Q4-11.](#ch04qa2q0a11)**'
  id: totrans-1494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-11.](#ch04qa2q0a11)**'
- en: ''
  id: totrans-1495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-1498
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ''
  id: totrans-1499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`521`'
  id: totrans-1500
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`521`'
- en: Runtime exception
  id: totrans-1501
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '`65321`'
  id: totrans-1502
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`65321`'
- en: '`65431`'
  id: totrans-1503
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`65431`'
- en: '**[Q4-12.](#ch04qa2q0a12)**'
  id: totrans-1504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-12.](#ch04qa2q0a12)**'
- en: ''
  id: totrans-1505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-1508
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ''
  id: totrans-1509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`August 11, 2057T00:00`'
  id: totrans-1510
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`August 11, 2057T00:00`'
- en: '`Saturday Aug 11,2057T00:00`'
  id: totrans-1511
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Saturday Aug 11,2057T00:00`'
- en: '`08-11-2057T00:00:00`'
  id: totrans-1512
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`08-11-2057T00:00:00`'
- en: Compilation error
  id: totrans-1513
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-1514
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: 4.10\. Answers to sample exam questions
  id: totrans-1515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10\. 样本考试题目的答案
- en: '**[Q4-1.](#ch04qa1q1)**'
  id: totrans-1516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-1.](#ch04qa1q1)**'
- en: ''
  id: totrans-1517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-1520
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE90]'
- en: ''
  id: totrans-1521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`4c010`'
  id: totrans-1522
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4c010`'
- en: '`4c10`'
  id: totrans-1523
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`4c10`'
- en: '`113`'
  id: totrans-1524
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`113`'
- en: '`103`'
  id: totrans-1525
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`103`'
- en: '**Compilation error**'
  id: totrans-1526
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译错误**'
- en: ''
  id: totrans-1527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: e'
  id: totrans-1528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：e
- en: ''
  id: totrans-1529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The code in this question won’t compile due to'
  id: totrans-1530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：这个问题中的代码不会编译，因为
- en: ''
  id: totrans-1531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1532
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ''
  id: totrans-1533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The preceding line of code tries to assign a value of type `long` to a variable
    of type `int`. Because Java doesn’t support implicit narrowing conversions (for
    example, `long` to `int` in this case), the assignment fails. Also, this code
    tries to trick you regarding your understanding of the following:'
  id: totrans-1534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上一行代码尝试将类型为`long`的值赋给类型为`int`的变量。因为Java不支持隐式缩窄转换（例如，在这个例子中，`long`到`int`），赋值失败。此外，此代码试图欺骗你对以下内容的理解：
- en: ''
  id: totrans-1535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assigning a `char` value to an `int` array element (`arr[1] = c`)
  id: totrans-1536
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`char`值赋给`int`数组元素（`arr[1] = c`）
- en: Adding a `byte` value to an `int` array element (`arr[0] = b`)
  id: totrans-1537
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`byte`值添加到`int`数组元素（`arr[0] = b`）
- en: Whether an unassigned `int` array element is assigned a default value `(arr[2])`
  id: totrans-1538
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未分配的`int`数组元素是否分配了默认值（`arr[2]`）
- en: Whether `arr[0] + arr[1] + arr[2] + arr[3]` prints the sum of all these values
    or a concatenated value
  id: totrans-1539
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arr[0] + arr[1] + arr[2] + arr[3]`打印所有这些值的总和还是连接后的值'
- en: ''
  id: totrans-1540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When answering questions in the OCA Java SE 8 Java Programmer I exam, be careful
    about such tactics. If any of the answers lists a compilation error or a runtime
    exception as an option, look for obvious lines of code that could result in it.
    In this example, `arr[3] = longVar` will result in a compilation error.
  id: totrans-1541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在回答 OCA Java SE 8 Java 程序员 I 考试中的问题时，请注意这些策略。如果任何答案选项列出了编译错误或运行时异常，寻找可能导致这些错误的明显代码行。在这个例子中，`arr[3]
    = longVar` 将导致编译错误。
- en: '**[Q4-2.](#ch04qa1q2)**'
  id: totrans-1542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-2.](#ch04qa1q2)**'
- en: ''
  id: totrans-1543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1546
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE92]'
- en: ''
  id: totrans-1547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0:0`'
  id: totrans-1548
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:0`'
- en: '`a:b`'
  id: totrans-1549
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a:b`'
- en: '`0:b`'
  id: totrans-1550
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0:b`'
- en: '`a:0`'
  id: totrans-1551
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a:0`'
- en: '**Compilation error**'
  id: totrans-1552
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译错误**'
- en: ''
  id: totrans-1553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: e'
  id: totrans-1554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：e
- en: ''
  id: totrans-1555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Because a `char` value can be assigned to an `int` value, you
    might assume that a `char` array can be assigned to an `int` array. But we’re
    talking about arrays of `int` and `char` primitives, which aren’t the same as
    a primitive `int` or `char`. Arrays themselves are reference variables, which
    refer to a collection of objects of similar type.'
  id: totrans-1556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：因为 `char` 值可以赋给 `int` 值，你可能会认为 `char` 数组可以赋给 `int` 数组。但我们谈论的是 `int` 和 `char`
    原始数组的数组，它们与原始的 `int` 或 `char` 不同。数组本身是引用变量，它指向类似类型的对象集合。
- en: '**[Q4-3.](#ch04qa1q3)**'
  id: totrans-1557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-3.](#ch04qa1q3)**'
- en: ''
  id: totrans-1558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following are valid lines of code to define a multidimensional
    `int` array?
  id: totrans-1559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些是定义多维 `int` 数组的有效代码行？
- en: ''
  id: totrans-1560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`int[][] array1 = {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`**'
  id: totrans-1561
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`int[][] array1 = {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`**'
- en: '`int[][] array2 = new array() {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`'
  id: totrans-1562
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int[][] array2 = new array() {{1, 2, 3}, {}, {1, 2,3, 4, 5}};`'
- en: '`int[][] array3 = {1, 2, 3}, {0}, {1, 2,3, 4, 5};`'
  id: totrans-1563
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int[][] array3 = {1, 2, 3}, {0}, {1, 2,3, 4, 5};`'
- en: '**`int[][] array4 = new int[2][];`**'
  id: totrans-1564
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`int[][] array4 = new int[2][];`**'
- en: ''
  id: totrans-1565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, d'
  id: totrans-1566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, d
- en: ''
  id: totrans-1567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (b) is incorrect. This line of code won’t compile because
    `new array()` isn’t valid code. Unlike objects of other classes, an array isn’t
    initialized using the keyword `new` followed by the word `array`. When the keyword
    `new` is used to initialize an array, it’s followed by the type of the array,
    not the word `array`.'
  id: totrans-1568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项 (b) 是错误的。此行代码无法编译，因为 `new array()` 不是一个有效的代码。与其它类的对象不同，数组不是使用 `new` 关键字后跟
    `array` 单词来初始化的。当使用 `new` 关键字初始化数组时，它后面跟的是数组的类型，而不是 `array` 单词。
- en: ''
  id: totrans-1569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is incorrect. To initialize a two-dimensional array, all of these
    values must be enclosed within another pair of curly braces, as shown in the code
    in option (a).
  id: totrans-1570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (c) 是错误的。要初始化一个二维数组，所有这些值必须包含在另一对花括号内，如选项 (a) 中的代码所示。
- en: '**[Q4-4.](#ch04qa1q4)**'
  id: totrans-1571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-4.](#ch04qa1q4)**'
- en: ''
  id: totrans-1572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are correct?
  id: totrans-1573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些陈述是正确的？
- en: ''
  id: totrans-1574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code executes without an error or exception:'
  id: totrans-1575
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码执行时没有错误或异常：
- en: ''
  id: totrans-1576
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-1577
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ''
  id: totrans-1578
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1579
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Because `ArrayList` stores only objects, you can’t pass element of an `ArrayList`
    to a `switch` construct.
  id: totrans-1580
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `ArrayList` 只存储对象，所以你不能将 `ArrayList` 的元素传递给 `switch` 结构。
- en: Calling `clear()` or `remove()` on an `ArrayList` will remove all its elements.
  id: totrans-1581
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ArrayList` 上调用 `clear()` 或 `remove()` 将移除其所有元素。
- en: '**If you frequently add elements to an `ArrayList`, specifying a larger capacity
    will improve the code efficiency.**'
  id: totrans-1582
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你经常向 `ArrayList` 添加元素，指定更大的容量将提高代码效率。**'
- en: '**Calling the method `clone()` on an `ArrayList` creates its shallow copy;
    that is, it doesn’t clone the individual list elements.**'
  id: totrans-1583
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 `ArrayList` 上调用 `clone()` 方法会创建其浅拷贝；也就是说，它不会克隆单个列表元素。**'
- en: ''
  id: totrans-1584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d, e'
  id: totrans-1585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d, e
- en: ''
  id: totrans-1586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is incorrect. The default type of a non-floating numeric
    literal value is `int`. You can’t add an `int` to an `ArrayList` of type `Long`.
    You can pass values of type `Long` or `long` to its `add` method.'
  id: totrans-1587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项 (a) 是错误的。非浮点数值字面量的默认类型是 `int`。你不能将 `int` 添加到 `Long` 类型的 `ArrayList` 中。你可以传递
    `Long` 或 `long` 类型的值到其 `add` 方法。
- en: ''
  id: totrans-1588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is incorrect. Starting with Java 7, `switch` also accepts variables
    of type `String`. Because a `String` can be stored in an `ArrayList`, you can
    use elements of an `ArrayList` in a `switch` construct.
  id: totrans-1589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 是错误的。从 Java 7 开始，`switch` 也接受 `String` 类型的变量。因为 `String` 可以存储在 `ArrayList`
    中，所以可以在 `switch` 结构中使用 `ArrayList` 的元素。
- en: ''
  id: totrans-1590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is incorrect. Only `clear()` will remove all elements of an `ArrayList`.
  id: totrans-1591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (c) 是错误的。只有 `clear()` 会移除 `ArrayList` 的所有元素。
- en: ''
  id: totrans-1592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is correct. An `ArrayList` internally uses an array to store all
    its elements. Whenever you add an element to an `ArrayList`, it checks whether
    the array can accommodate the new value. If it can’t, `ArrayList` creates a larger
    array, copies all the existing values to the new array, and then adds the new
    value at the end of the array. If you frequently add elements to an `ArrayList`,
    it makes sense to create an `ArrayList` with a bigger capacity because the previous
    process isn’t repeated for each `Array-List` insertion.
  id: totrans-1593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项(d)是正确的。`ArrayList`内部使用数组来存储所有元素。每次你向`ArrayList`添加元素时，它都会检查数组是否可以容纳新值。如果不能，`ArrayList`将创建一个更大的数组，将所有现有值复制到新数组中，然后将新值添加到数组的末尾。如果你经常向`ArrayList`添加元素，那么创建一个具有更大容量的`ArrayList`是有意义的，因为之前的步骤不会为每个`ArrayList`插入重复执行。
- en: ''
  id: totrans-1594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (e) is correct. Calling `clone()` on an `ArrayList` will create a separate
    reference variable that stores the same number of elements as the `ArrayList`
    to be cloned. But each individual `ArrayList` element will refer to the same object;
    that is, the individual `ArrayList` elements aren’t cloned.
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项(e)是正确的。在`ArrayList`上调用`clone()`将创建一个单独的引用变量，该变量存储与要克隆的`ArrayList`相同数量的元素。但每个单独的`ArrayList`元素都将引用相同的对象；也就是说，单独的`ArrayList`元素没有被克隆。
- en: '**[Q4-5.](#ch04qa1q5)**'
  id: totrans-1596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-5.](#ch04qa1q5)**'
- en: ''
  id: totrans-1597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are correct?
  id: totrans-1598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些陈述是正确的？
- en: ''
  id: totrans-1599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**An `ArrayList` offers a resizable array, which is easily managed using the
    methods it provides. You can add and remove elements from an `ArrayList`.**'
  id: totrans-1600
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ArrayList`提供了一个可调整大小的数组，可以使用它提供的方法轻松管理。你可以从`ArrayList`中添加和删除元素**。'
- en: '**Values stored by an `ArrayList` can be modified.**'
  id: totrans-1601
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**由`ArrayList`存储的值可以被修改**。'
- en: '**You can iterate through elements of an `ArrayList` using a `for` loop, `Iterator`,
    or `ListIterator`.**'
  id: totrans-1602
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你可以使用`for`循环、`Iterator`或`ListIterator`遍历`ArrayList`中的元素**。'
- en: An `ArrayList` requires you to specify the total elements before you can store
    any elements in it.
  id: totrans-1603
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayList`要求你在存储任何元素之前指定总元素数。'
- en: '**An `ArrayList` can store any type of object.**'
  id: totrans-1604
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ArrayList`可以存储任何类型的对象**。'
- en: ''
  id: totrans-1605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, b, c, e'
  id: totrans-1606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, b, c, e
- en: ''
  id: totrans-1607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is correct. A developer may prefer using an `ArrayList`
    over an array because it offers all the benefits of an array and a list. For example,
    you can easily add or remove elements from an `ArrayList`.'
  id: totrans-1608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项(a)是正确的。开发者可能更喜欢使用`ArrayList`而不是数组，因为它提供了数组和列表的所有好处。例如，你可以轻松地向`ArrayList`中添加或删除元素。
- en: ''
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is correct.
  id: totrans-1610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项(b)是正确的。
- en: ''
  id: totrans-1611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is correct. An `ArrayList` can be easily searched, sorted, and have
    its values compared using the methods provided by the Collection framework classes.
  id: totrans-1612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项(c)是正确的。`ArrayList`可以很容易地通过集合框架类提供的方法进行搜索、排序，并比较其值。
- en: ''
  id: totrans-1613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is incorrect. An array requires you to specify the total number of
    elements before you can add any element to it. But you don’t need to specify the
    total number of elements that you may add to an `ArrayList` at any time in your
    code.
  id: totrans-1614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项(d)是不正确的。数组要求你在添加任何元素之前指定总元素数。但你不需要在代码中的任何时间指定你可能会添加到`ArrayList`中的总元素数。
- en: ''
  id: totrans-1615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (e) is correct.
  id: totrans-1616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项(e)是正确的。
- en: '**[Q4-6.](#ch04qa1q6)**'
  id: totrans-1617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-6.](#ch04qa1q6)**'
- en: ''
  id: totrans-1618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-1621
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE94]'
- en: ''
  id: totrans-1622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Line 7 prints `true`**.'
  id: totrans-1623
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第7行打印`true`**。'
- en: Line 7 prints `false`.
  id: totrans-1624
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第7行打印`false`。
- en: Line 8 prints `-1`.
  id: totrans-1625
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第8行打印`-1`。
- en: '**Line 8 prints `1`**.'
  id: totrans-1626
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第8行打印`1`**。'
- en: '**Line 9 removes all elements of the list `ejg`**.'
  id: totrans-1627
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第9行移除了列表`ejg`的所有元素**。'
- en: Line 9 sets `ejg` to `null`.
  id: totrans-1628
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第9行将`ejg`设置为`null`。
- en: Line 10 prints `null`.
  id: totrans-1629
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第10行打印`null`。
- en: '**Line 10 prints `[]`**.'
  id: totrans-1630
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第10行打印`[]`**。'
- en: Line 10 prints a value similar to `ArrayList@16356`.
  id: totrans-1631
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第10行打印类似于`ArrayList@16356`的值。
- en: '**Line 11 throws an exception.**'
  id: totrans-1632
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**第11行抛出异常**。'
- en: Line 11 prints `null`.
  id: totrans-1633
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第11行打印`null`。
- en: ''
  id: totrans-1634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, d, e, h, j'
  id: totrans-1635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, d, e, h, j
- en: ''
  id: totrans-1636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Line 7: The method `contains` accepts an object and compares it
    with the values stored in the list. It returns `true` if the method finds a match
    and `false` otherwise. This method uses the `equals` method defined by the object
    stored in the list. In the example, the `ArrayList` stores objects of class `String`,
    which has overridden the `equals` method. The `equals` method of the `String`
    class compares the values stored by it. This is why line 7 returns the value `true`.'
  id: totrans-1637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：第7行：`contains`方法接受一个对象并将其与列表中存储的值进行比较。如果方法找到匹配项，则返回`true`，否则返回`false`。此方法使用列表中存储的对象定义的`equals`方法。在示例中，`ArrayList`存储了`String`类的对象，该类已重写`equals`方法。`String`类的`equals`方法比较它存储的值。这就是为什么第7行返回值`true`。
- en: ''
  id: totrans-1638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Line 8: `indexOf` returns the index position of an element if a match is found;
    otherwise, it returns `-1`. This method also uses the `equals` method behind the
    scenes to compare the values in an `ArrayList`. Because the `equals` method in
    the class `String` compares its values and not the reference variables, the `indexOf`
    method finds a match in position 1.'
  id: totrans-1639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 8 行：`indexOf` 方法在找到匹配项时返回元素的索引位置；如果没有找到匹配项，则返回 `-1`。此方法还使用 `equals` 方法在后台比较
    `ArrayList` 中的值。因为 `String` 类中的 `equals` 方法比较其值而不是引用变量，所以 `indexOf` 方法在位置 1 找到匹配项。
- en: ''
  id: totrans-1640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Line 9: The `clear` method removes all the individual elements of an `ArrayList`
    such that an attempt to access any of the earlier `ArrayList` elements will throw
    a runtime exception. It doesn’t set the `ArrayList` reference variable to `null`.'
  id: totrans-1641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 9 行：`clear` 方法移除 `ArrayList` 的所有单个元素，因此尝试访问任何早期的 `ArrayList` 元素将抛出运行时异常。它不会将
    `ArrayList` 引用变量设置为 `null`。
- en: ''
  id: totrans-1642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Line 10: `ArrayList` has overridden the `toString` method such that it returns
    a list of all its elements enclosed within square brackets. To print each element,
    the `toString` method is called to retrieve its `String` representation.'
  id: totrans-1643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 10 行：`ArrayList` 已覆盖 `toString` 方法，使其返回一个包含所有元素的列表，这些元素被括号括起来。为了打印每个元素，调用
    `toString` 方法以获取其 `String` 表示形式。
- en: ''
  id: totrans-1644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Line 11: The `clear` method removes all the elements of an `ArrayList`. An
    attempt to access the (nonexistent) `ArrayList` element throws a runtime `IndexOutOfBounds-Exception`
    exception.'
  id: totrans-1645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 11 行：`clear` 方法移除 `ArrayList` 的所有元素。尝试访问（不存在的）`ArrayList` 元素会抛出运行时 `IndexOutOfBounds-Exception`
    异常。
- en: ''
  id: totrans-1646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This question tests your understanding of `ArrayList` and determining the equality
    of `String` objects.
  id: totrans-1647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个问题测试你对 `ArrayList` 和确定 `String` 对象相等性的理解。
- en: '**[Q4-7.](#ch04qa1q7)**'
  id: totrans-1648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-7.](#ch04qa1q7)**'
- en: ''
  id: totrans-1649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-1652
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ''
  id: totrans-1653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`true` printed once'
  id: totrans-1654
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`true` 打印一次'
- en: '`false` printed once'
  id: totrans-1655
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`false` 打印一次'
- en: '**`true` printed in an infinite loop**'
  id: totrans-1656
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`true` 在无限循环中打印**'
- en: '`false` printed in an infinite loop'
  id: totrans-1657
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`false` 在无限循环中打印'
- en: ''
  id: totrans-1658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: `String` objects that are created without using the `new` operator
    are placed in a pool of `String`s. Hence, the `String` object referred to by the
    variable `ejg3` is placed in a pool of `String`s. The variable `ejg4` is also
    defined without using the `new` operator. Before Java creates another `String`
    object in the `String` pool for the variable `ejg4`, it looks for a `String` object
    with the same value in the pool. Because this value already exists in the pool,
    it makes the variable `ejg4` refer to the same `String` object. This, in turn,
    makes the variables `ejg3` and `ejg4` refer to the same `String` objects. Hence,
    both of the following comparisons will return `true`:'
  id: totrans-1661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：未使用 `new` 操作符创建的 `String` 对象被放置在一个 `String` 对象池中。因此，变量 `ejg3` 所引用的 `String`
    对象被放置在一个 `String` 对象池中。变量 `ejg4` 也是未使用 `new` 操作符定义的。在 Java 为变量 `ejg4` 在 `String`
    池中创建另一个 `String` 对象之前，它会查找池中具有相同值的 `String` 对象。因为这个值已经在池中存在，所以它使变量 `ejg4` 指向同一个
    `String` 对象。这反过来又使得变量 `ejg3` 和 `ejg4` 指向同一个 `String` 对象。因此，以下两个比较都将返回 `true`：
- en: ''
  id: totrans-1662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ejg3 == ejg4` (compare the object references)'
  id: totrans-1663
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ejg3 == ejg4`（比较对象引用）'
- en: '`ejg3.equals(ejg4)` (compare the object values)'
  id: totrans-1664
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ejg3.equals(ejg4)`（比较对象值）'
- en: ''
  id: totrans-1665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even though the variables `ejg1` and `ejg2` refer to different `String` objects,
    they define the same values. So `ejg1.equals(ejg2)` also returns `true`. Because
    the loop condition `(ejg3==ejg4)` always returns `true`, the code prints `true`
    in an infinite loop.
  id: totrans-1666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使变量 `ejg1` 和 `ejg2` 指向不同的 `String` 对象，但它们定义了相同的值。所以 `ejg1.equals(ejg2)` 也返回
    `true`。因为循环条件 `(ejg3==ejg4)` 总是返回 `true`，所以代码在无限循环中打印 `true`。
- en: '**[Q4-8.](#ch04qa1q8)**'
  id: totrans-1667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-8.](#ch04qa1q8)**'
- en: ''
  id: totrans-1668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-1671
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE96]'
- en: ''
  id: totrans-1672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`gZmeAZ`'
  id: totrans-1673
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZmeAZ`'
- en: '**`gZmeAa`**'
  id: totrans-1674
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`gZmeAa`**'
- en: '`gZm`'
  id: totrans-1675
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZm`'
- en: '`gZ`'
  id: totrans-1676
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZ`'
- en: '`game`'
  id: totrans-1677
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`game`'
- en: ''
  id: totrans-1678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-1679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b
- en: ''
  id: totrans-1680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: When chained, methods are evaluated from left to right. The first
    method to execute is `replace`, not `concat`. `String`s are immutable. Calling
    the method `substring` on the reference variable `ejg` doesn’t change the contents
    of the variable `ejg`. It returns a `String` object that isn’t referred to by
    any other variable in the code. In fact, none of the methods defined in the `String`
    class modify the object’s own value. They all create and return new `String` objects.'
  id: totrans-1681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：当链式调用时，方法从左到右进行评估。首先执行的是 `replace` 方法，而不是 `concat`。`String` 对象是不可变的。在引用变量
    `ejg` 上调用 `substring` 方法不会改变变量的内容。它返回一个 `String` 对象，该对象不被代码中的任何其他变量引用。实际上，`String`
    类中定义的任何方法都不会修改对象的自身值。它们都创建并返回新的 `String` 对象。
- en: '**[Q4-9.](#ch04qa1q9)**'
  id: totrans-1682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-9.](#ch04qa1q9)**'
- en: ''
  id: totrans-1683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1686
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE97]'
- en: ''
  id: totrans-1687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`gZmeAZ`'
  id: totrans-1688
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZmeAZ`'
- en: '`gZmeAa`'
  id: totrans-1689
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZmeAa`'
- en: '`gZm`'
  id: totrans-1690
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZm`'
- en: '`gZ`'
  id: totrans-1691
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gZ`'
- en: '**`game`**'
  id: totrans-1692
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`game`**'
- en: ''
  id: totrans-1693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: e'
  id: totrans-1694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：e
- en: ''
  id: totrans-1695
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: `String` objects are immutable. It doesn’t matter how many methods
    you execute on a `String` object; its value won’t change. Variable `ejg` is initialized
    with the `String` value `"game"`. This value won’t change, and the code prints
    `game`.'
  id: totrans-1696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：`String`对象是不可变的。无论你在`String`对象上执行多少方法，其值都不会改变。变量`ejg`被初始化为`String`值`"game"`。这个值不会改变，并且代码打印`game`。
- en: '**[Q4-10.](#ch04qa1q10)**'
  id: totrans-1697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-10.](#ch04qa1q10)**'
- en: ''
  id: totrans-1698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1701
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE98]'
- en: ''
  id: totrans-1702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`12S512S5`**'
  id: totrans-1703
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`12S512S5`**'
- en: '`12S12S`'
  id: totrans-1704
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`12S12S`'
- en: '`1025102S`'
  id: totrans-1705
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1025102S`'
- en: Runtime exception
  id: totrans-1706
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: ''
  id: totrans-1707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-1708
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a
- en: ''
  id: totrans-1709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: This question tests your understanding of operators, `String`,
    and `StringBuilder`. The following line of code returns `12SUN45`:'
  id: totrans-1710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：这个问题测试你对运算符、`String`和`StringBuilder`的理解。以下代码行返回`12SUN45`：
- en: ''
  id: totrans-1711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-1712
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE99]'
- en: ''
  id: totrans-1713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `+` operator adds two numbers but concatenates the last two numbers. When
    the `+` operator encounters a `String` object, it treats all the remaining operands
    as `String` objects.
  id: totrans-1714
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`+`运算符将两个数字相加，但连接最后两个数字。当`+`运算符遇到`String`对象时，它将所有剩余的操作数视为`String`对象。'
- en: ''
  id: totrans-1715
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unlike the `String` objects, `StringBuilder` objects are mutable. The `append`
    and `delete` methods defined in this class change its value. `ejg.delete(3, 6)`
    modifies the existing value of the `StringBuilder` to `12S5`. It then appends
    the same value to itself when calling `ejg.append()`, resulting in the value `12S512S5.`
  id: totrans-1716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与`String`对象不同，`StringBuilder`对象是可变的。这个类中定义的`append`和`delete`方法会改变它的值。`ejg.delete(3,
    6)`修改了`StringBuilder`的现有值为`12S5`。然后，在调用`ejg.append()`时，它将相同的值追加到自身，结果值为`12S512S5`。
- en: '**[Q4-11.](#ch04qa1q11)**'
  id: totrans-1717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-11.](#ch04qa1q11)**'
- en: ''
  id: totrans-1718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-1721
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE100]'
- en: ''
  id: totrans-1722
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`521`'
  id: totrans-1723
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`521`'
- en: Runtime exception
  id: totrans-1724
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '**`65321`**'
  id: totrans-1725
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`65321`**'
- en: '`65431`'
  id: totrans-1726
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`65431`'
- en: ''
  id: totrans-1727
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Like the method `substring`, the method `subSequence` doesn’t
    modify the contents of a `StringBuilder`. Hence, the value of the variable `sb1`
    remains `123456`, even after the execution of the following line of code:'
  id: totrans-1730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：与`substring`方法一样，`subSequence`方法不会修改`StringBuilder`的内容。因此，变量`sb1`的值仍然是`123456`，即使在执行以下代码行之后：
- en: ''
  id: totrans-1731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-1732
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE101]'
- en: ''
  id: totrans-1733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The method `deleteCharAt` deletes a `char` value at position 3\. Because the
    positions are zero-based, the digit 4 is deleted from the value `123456`, resulting
    in `12356`. The method `reverse` modifies the value of a `StringBuilder` by assigning
    to it the reverse representation of its value. The reverse of `12356` is `65321`.
  id: totrans-1734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`deleteCharAt`方法删除位置3处的`char`值。因为位置是从0开始的，所以数字4被从值`123456`中删除，结果为`12356`。`reverse`方法通过将其值赋给其值的反转表示来修改`StringBuilder`的值。`12356`的反转是`65321`。'
- en: '**[Q4-12.](#ch04qa1q12)**'
  id: totrans-1735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4-12.](#ch04qa1q12)**'
- en: ''
  id: totrans-1736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-1739
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE102]'
- en: ''
  id: totrans-1740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`August 11, 2057T00:00`'
  id: totrans-1741
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`August 11, 2057T00:00`'
- en: '`Saturday Aug 11,2057T00:00`'
  id: totrans-1742
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Saturday Aug 11,2057T00:00`'
- en: '`08-11-2057T00:00:00`'
  id: totrans-1743
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`08-11-2057T00:00:00`'
- en: Compilation error
  id: totrans-1744
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**Runtime exception**'
  id: totrans-1745
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时异常**'
- en: ''
  id: totrans-1746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: e'
  id: totrans-1747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：e
- en: ''
  id: totrans-1748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The example code in this question calls `LocalDate.parse()`, passing
    it a string value but no `DateTimeFormatter` instance. In this case, the text
    2057-08-11 is parsed using `DateTimeFormatter.ISO_LOCAL_DATE`. `LocalDate.parse()`
    returns a `LocalDate` instance.'
  id: totrans-1749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：这个问题中的示例代码调用了`LocalDate.parse()`，传递了一个字符串值但没有`DateTimeFormatter`实例。在这种情况下，文本`2057-08-11`使用`DateTimeFormatter.ISO_LOCAL_DATE`进行解析。`LocalDate.parse()`返回一个`LocalDate`实例。
- en: ''
  id: totrans-1750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The example code then calls the `format` method on a `LocalDate` instance, using
    `DateTimeFormatter.ISO_DATE_TIME`. The code compiles successfully because the
    `format` method accepts a `DateTimeFormatter` instance. But `format()` throws
    an exception at runtime because it tries to format a `LocalDate` instance using
    a formatter (`ISO_DATE_TIME`) that defines rules for a date/time object. When
    no matching time values are found in a `LocalDate` object, an exception is thrown.
  id: totrans-1751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 示例代码接着在一个`LocalDate`实例上调用`format`方法，使用`DateTimeFormatter.ISO_DATE_TIME`。代码编译成功，因为`format`方法接受一个`DateTimeFormatter`实例。但是，在运行时抛出异常，因为它试图使用定义日期/时间对象规则的格式化器（`ISO_DATE_TIME`）来格式化`LocalDate`实例。当在`LocalDate`对象中找不到匹配的时间值时，会抛出异常。
- en: ''
  id: totrans-1752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exam Tip
  id: totrans-1753
  prefs:
  - PREF_BQ
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: ''
  id: totrans-1754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `parse` method is defined as a static method in classes `LocalDate`, `LocalTime`,
    and `LocalDateTime`. The class `DateTimeFormatter` defines the method `parse`
    as an instance method. But `format()` is defined as an instance method by all.
    The example code wouldn’t have compiled if the order of calling `parse()` and
    `format()` was reversed:'
  id: totrans-1755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`parse` 方法在 `LocalDate`、`LocalTime` 和 `LocalDateTime` 类中被定义为静态方法。`DateTimeFormatter`
    类将 `parse` 方法定义为实例方法。但 `format()` 方法则被所有类定义为实例方法。如果调用 `parse()` 和 `format()` 的顺序颠倒，示例代码将无法编译：'
- en: ''
  id: totrans-1756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-1757
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE103]'
- en: ''
  id: totrans-1758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-1759
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  |'
