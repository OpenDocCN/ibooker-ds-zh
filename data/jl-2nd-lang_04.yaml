- en: 3 Control flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 控制流
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using Boolean values in conditions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在条件中使用布尔值
- en: Running the same code multiple times using while and for loops
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用while和for循环多次运行相同的代码
- en: Deciding what code to run with an if statement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用if语句决定运行什么代码
- en: Looping over ranges of numbers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数字范围
- en: Defining functions spanning multiple lines of code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义跨越多行代码的函数
- en: Implementing control flow using recursion or iteration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归或迭代实现控制流
- en: Control flow is what separates a computer from a mere calculator. Calculators
    are for computing single expressions. Computers, on the other hand, have the ability
    to repeat the same calculations with different inputs numerous times without human
    intervention. Computers can choose to perform one calculation over another based
    on whether or not a condition holds true.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流是区分计算机和普通计算器的地方。计算器用于计算单个表达式。另一方面，计算机具有在无需人工干预的情况下多次使用不同输入重复相同计算的能力。计算机可以根据条件是否为真来选择执行一个计算而不是另一个计算。
- en: In this chapter you will explore code examples oriented around producing mathematical
    tables. You will learn about tables for trigonometric functions, as such tables
    are well known and of historical importance. Later you will explore conditional
    execution to help track the growth of rabbits using a method developed by Italian
    mathematician Fibonacci 800 years ago.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将探索围绕生成数学表的代码示例。您将了解三角函数表，因为这些表广为人知，并且具有历史重要性。稍后，您将探索条件执行，以帮助跟踪使用800年前意大利数学家斐波那契开发的方法繁殖的兔子的增长。
- en: 3.1 Navigation and trigonometry
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 航海与三角学
- en: In the age of sail the use of mathematical tables became more widespread, and
    a need to develop ways to automate the calculation of these tables developed (navigation
    is based on the calculation of angles and the sides of triangles; figure 3.1).
    This meant calculating trigonometric functions such as sine, cosine, and tangent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在帆船时代，数学表的使用变得更加普遍，并且需要开发自动化计算这些表的方法（航海基于计算角度和三角形的边；图3.1）。这意味着计算正弦、余弦和正切等三角函数。
- en: '![03-01](../Images/03-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![03-01](../Images/03-01.png)'
- en: Figure 3.1 A captain on a ship could use a sextant to measure angle θ between
    the horizon and top of a lighthouse.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 一艘船上的船长可以使用六分仪来测量地平线和灯塔顶部之间的角度θ。
- en: Nautical maps contain heights of different lighthouses. Thus if you want to
    know your position at sea while close to shore, you could measure the angle between
    the horizon and the top of a lighthouse of known height. This would give you the
    distance to that lighthouse. However all of these calculations require calculating
    trigonometric functions such as sine and cosine, and sea captains of the 1700s
    did not have pocket calculators (table 3.1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 海图包含不同灯塔的高度。因此，如果您想在靠近海岸的海域知道自己的位置，您可以测量地平线和已知高度的灯塔顶部之间的角度。这将给出您到该灯塔的距离。然而，所有这些计算都需要计算正弦和余弦等三角函数，而18世纪的船长们没有携带计算器（表3.1）。
- en: Table 3.1 A simple trigonometric table
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 一个简单的三角函数表
- en: '| angle | 0° | 30° | 45° | 60° | 90° |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 角度 | 0° | 30° | 45° | 60° | 90° |'
- en: '| sin | 0.000 | 0.500 | 0.707 | 0.866 | 1.000 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| sin | 0.000 | 0.500 | 0.707 | 0.866 | 1.000 |'
- en: Instead they used mathematical tables. Large, printed tables detailing the value
    of sine, cosine, and tangent for different angles were common tools for navigators
    of the time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 他们使用的是数学表。当时，大型、印刷的表格，详细列出不同角度的正弦、余弦和正切值，是航海家们常用的工具。
- en: 'Let me just refresh you on your high-school math if you have not used trigonometric
    functions in a while. Looking at the triangle in figure 3.2, sine, cosine, and
    tangent are defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一段时间没有使用三角函数，让我来帮您回顾一下高中数学。观察图3.2中的三角形，正弦、余弦和正切的定义如下：
- en: '![03-01-Equation](../Images/03-01-Equation.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![03-01-Equation](../Images/03-01-Equation.png)'
- en: '![03-02](../Images/03-02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![03-02](../Images/03-02.png)'
- en: Figure 3.2 A right triangle with sides of length a, b, and h. The longest side
    h is called the hypotenuse and has an angle θ.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 一条边长为a、b和h的直角三角形。最长的边h称为斜边，有一个角度θ。
- en: 'So for example, the sine of an angle is equal to the length of the opposing
    side divided by the longest side (the hypothenuse) in a right triangle (one angle
    is 90°). Today you use a calculator to calculate these trigonometric functions.
    But what if you lived before 1972^([1](#pgfId-1012155))? How would you do these
    calculations by hand? There is, in fact, no canonical way of calculating sine
    and cosine. Instead there are various methods of *approximation*. A popular method
    of calculating sine is called the *Taylor series*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个角的正弦值等于直角三角形中对立边的长度除以最长边（斜边）的长度（一个角是90°）。今天你使用计算器来计算这些三角函数。但如果你生活在1972年之前^([1](#pgfId-1012155))，你会如何手动进行这些计算？实际上，没有计算正弦和余弦的标准方法。相反，有各种近似方法。计算正弦的一个流行方法是称为
    *泰勒级数*：
- en: '![03-02-Equation_3-4](../Images/03-02-Equation_3-4.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![03-02-Equation_3-4](../Images/03-02-Equation_3-4.png)'
- en: You can write this in a more compact and generalized form as
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其写成更紧凑和通用的形式为
- en: '![03-02-Equation_3-5](../Images/03-02-Equation_3-5.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![03-02-Equation_3-5](../Images/03-02-Equation_3-5.png)'
- en: But mathematical tables are not limited to trigonometric functions. Tables are
    useful for many other functions to reduce the amount of hand calculations required.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但数学表不仅限于三角函数。表格对于许多其他函数都很有用，可以减少所需的手动计算量。
- en: This spurred Charles Babbage to begin the construction of a massive mechanical
    calculating machine called the Difference Engine in 1819 (figure 3.3). It could
    calculate multiple values for tables by repeating the same calculation many times
    over. In modern programming terms it was creating the tables using loops. Loops
    are based on evaluating (running) the same code multiple times as long as a given
    condition holds true. In all programming languages Boolean expressions are used
    to define conditions. You will follow in Babbage’s footsteps by creating such
    loops in Julia.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这促使查尔斯·巴贝奇在1819年开始构建一台名为差分机的巨大机械计算器（图3.3）。它可以通过重复相同的计算多次来计算表格中的多个值。用现代编程术语来说，它是在循环中创建表格。循环基于评估（运行）相同的代码，只要给定条件保持为真。在所有编程语言中，布尔表达式都用于定义条件。你将跟随巴贝奇的脚步，在Julia中创建这样的循环。
- en: '![03-03](../Images/03-03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![03-03](../Images/03-03.png)'
- en: Figure 3.3 A part of Charles Babbage’s Difference Engine, which was a precursor
    to the Analytical Engine—the first mechanical general-purpose computer
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 查尔斯·巴贝奇的差分机的一部分，它是分析机——第一台机械通用计算机的先驱
- en: Your goal is implementing trigonometric functions in Julia using the Taylor
    series. Before that is possible you need to develop your understanding of Boolean
    expressions, which make it possible to understand while loops, for loops, and
    if statements. You will develop this understanding through a number of smaller
    code examples, printing out numbers, adding numbers, and converting from degrees
    to radians.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是使用泰勒级数在Julia中实现三角函数。在此之前，你需要理解布尔表达式，这些表达式使得理解while循环、for循环和if语句成为可能。你将通过一系列较小的代码示例来发展这种理解，打印数字、加数字和将角度转换为弧度。
- en: 3.2 Boolean expressions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 布尔表达式
- en: 'One of the first things you learn about in elementary school is Boolean expressions.
    Ironically, most students never practice using them for anything. Nobody tells
    you they are one of the most important parts of any programming language. You
    have already looked at numerical expressions, such as *3 + 5*; these evaluate
    to a number. Boolean expressions, in contrast, evaluate to true or false. They
    are easier to grasp with some practical examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在小学阶段，你首先学到的是布尔表达式。讽刺的是，大多数学生从未练习过它们。没有人告诉你它们是任何编程语言最重要的部分之一。你已经看过数值表达式，例如 *3
    + 5*；这些表达式评估为数字。相比之下，布尔表达式评估为真或假。通过一些实际例子，它们更容易理解：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Is 3 larger than 5?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 3是否大于5？
- en: ❷ Is 8 larger than 3?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 8是否大于3？
- en: ❸ Check if values are equal. This is not an assignment operator.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查值是否相等。这不是一个赋值操作符。
- en: ❹ Less than or equal
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 小于等于
- en: 'In the example you use a Unicode version of the *less than or equal* operator.
    Several Boolean operators have Unicode variants. The following table shows you
    how to write some of them in the Julia REPL:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用了 *小于等于* 操作符的Unicode版本。有几个布尔操作符有Unicode变体。以下表格显示了如何在Julia的REPL中编写它们：
- en: '| Character | Tab Completion | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | Tab 完成提示 | 描述 |'
- en: '| ≤ | \leq | less than or equal <= |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| ≤ | \leq | 小于等于 <= |'
- en: '| ≥ | \geq | greater than or equal >= |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| ≥ | \geq | 大于等于 >= |'
- en: '| ≠ | \ne | not equal != |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| ≠ | \ne | 不等于 != |'
- en: '| ≈ | \approx | isapprox(x, y) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| ≈ | \approx | isapprox(x, y) |'
- en: 'Boolean expressions return Boolean values, of which there are only two: true
    and false. Remember how I said everything is numbers inside a computer? Boolean
    values are no different:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式返回布尔值，其中只有两个：true 和 false。记得我说过在计算机内部一切都是数字吗？布尔值也不例外：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Boolean expressions give values of type Bool.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 布尔表达式给出类型为 Bool 的值。
- en: ❷ The false value is stored as a 0.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 假值存储为 0。
- en: ❸ true is stored as a 1.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ true 存储为 1。
- en: 'Unlike many other programming languages, Julia actually allows you to perform
    arithmetic on Boolean values. In arithmetic, Boolean values are treated as 0 or
    1:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他编程语言不同，Julia 实际上允许你对布尔值执行算术运算。在算术中，布尔值被视为 0 或 1：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For clarity it is best to avoid using Boolean values as numbers. However there
    are cases when this is very useful. Julia developers frequently use it to count
    how many things are true. In chapter 4 you will see an example of this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，最好避免将布尔值用作数字。然而，在某些情况下，这非常有用。Julia 开发者经常用它来计算有多少个东西是真的。在第 4 章中，你将看到这个例子。
- en: 3.2.1 Compound statements
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 复合语句
- en: 'Boolean expressions can be combined with the || and && operators. These perform
    what are called logical *OR* and logical *AND* operations. Thus given a variable
    x, I could ask, for example, if it is smaller than 4 *or* larger than 10:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式可以用 || 和 && 运算符组合。这些执行所谓的逻辑 *OR* 和逻辑 *AND* 操作。因此，给定一个变量 x，例如，我可以询问它是否小于
    4 *或*大于 10：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you could ask if x is larger than 4 *and* smaller than 10:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以询问 x 是否大于 4 并且小于 10：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next you will use Boolean expressions to define conditions for repeating the
    same code multiple times.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用布尔表达式来定义重复执行相同代码的条件。
- en: 3.3 Looping
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 循环
- en: The simplest looping construct in any programming language is the while loop.
    It allows you to repeat the same code over and over again as long as a Boolean
    condition is true, as shown in the following listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中最简单的循环结构是 while 循环。它允许你在布尔条件为真时重复执行相同的代码，如下面的列表所示。
- en: Listing 3.1 A simple while loop
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 一个简单的 while 循环
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All the code between the keywords while and end gets repeated over and over
    again as long as the condition i < 5 is true. You could copy and paste this code
    into your Julia REPL, but you would not see any output. Why? Because while end
    is an expression that evaluates to nothing. That may sound a bit abstract, so
    let me give an example: 3 + 4 is an expression that evaluates to 7\. You could
    store the value of an expression in variables like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键字 while 和 end 之间的所有代码只要条件 i < 5 为真就会重复执行。你可以将这段代码复制粘贴到你的 Julia REPL 中，但你不会看到任何输出。为什么？因为
    while end 是一个求值为空的表达式。这可能听起来有点抽象，所以让我举一个例子：3 + 4 是一个求值为 7 的表达式。你可以将表达式的值存储在变量中，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Pointless while loop that terminates immediately
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 无意义的 while 循环，立即终止
- en: ❷ The Julia REPL does not print nothing values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Julia REPL 不打印 nothing 值。
- en: The while loop example illustrates a couple of different things. The loop itself
    evaluates to a value, just like *3 + 4*. You store this value in variable y. However
    you cannot see the value in the REPL because it is of type Nothing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环的例子说明了几个不同的事情。循环本身求出一个值，就像 *3 + 4* 一样。你将这个值存储在变量 y 中。然而，你无法在 REPL 中看到这个值，因为它属于类型
    Nothing。
- en: 'Also notice that it is perfectly possible to place a while loop on a single
    line. Whitespace is not significant in Julia like it is in Python; in Python you
    must remember to indent statements belonging to a loop. But whitespace does play
    a role in Julia. Consider these three assignments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，将 while 循环放在单行上是完全可能的。在 Julia 中，空白不像在 Python 中那样重要；在 Python 中，你必须记住缩进属于循环的语句。但在
    Julia 中，空白确实扮演着角色。考虑以下三个赋值：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want them on a single line you need to separate them with a semicolon:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要它们在单行上，你需要用分号来分隔它们：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You might wonder why I stored the value of the while expression in a variable.
    I did that purely for teaching purposes, to make you aware of the fact that nearly
    everything in Julia is an expression that evaluates to a value. Even an assignment
    evaluates to a value (see listing 3.2). While this may sound like a theoretical
    curiosity of no interest to you, it does have many practical consequences. It
    makes the REPL show what value you gave a variable in an assignment statement.
    You will also see the benefit of treating everything as an expression later in
    the chapter when if statements are discussed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我将 while 表达式的值存储在一个变量中。我这样做纯粹是为了教学目的，让你意识到在 Julia 中几乎所有东西都是一个表达式，它评估为值。甚至赋值也会评估为值（参见列表
    3.2）。虽然这可能听起来像是一个对你没有兴趣的理论上的好奇心，但它确实有许多实际的影响。它使得 REPL 显示你在赋值语句中给变量赋予的值。你也会在讨论
    if 语句时看到将一切视为表达式的优点。
- en: Listing 3.2 The assignment evaluates to a value
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 赋值的结果是一个值
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note Calling an assignment a statement is technically wrong because everything
    in Julia is an expression. However I will use the word *statement* about many
    expressions in this book. The reason is that it makes it easier to distinguish
    between assignments and control flow, such as if statements and while-loops, and
    more mathematical expressions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将赋值称为语句在技术上是不正确的，因为在 Julia 中一切都是表达式。然而，我将在本书中关于许多表达式中使用“语句”这个词。原因是这有助于区分赋值和控制流，例如
    if 语句和 while 循环，以及更多的数学表达式。
- en: 'The REPL will always show the value of the outer expression and not the inner
    expression. For instance if you evaluate 1 + (3+2), you will never see 5 printed
    because that is the value of subexpression 3+2. Likewise you will not see i =
    i + 1 inside a loop. To *see* the value of i for every iteration, you need to
    explicitly tell Julia to print the value to the console. This is done with the
    print and println functions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 总是显示外部表达式的值，而不是内部表达式的值。例如，如果你评估 1 + (3+2)，你永远不会看到 5 打印出来，因为那是子表达式 3+2 的值。同样，你也不会在循环中看到
    i = i + 1。要*看到*每次迭代的 i 的值，你需要明确告诉 Julia 将值打印到控制台。这是通过 print 和 println 函数完成的：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From these examples you can probably tell the difference. println is short
    for *print line*. It prints a variable on a separate line. You can use print and
    println to explicitly print values outside of loops, but that is rarely needed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中，你可能可以分辨出差异。println 是 *print line* 的缩写。它在单独的一行上打印一个变量。你可以使用 print 和 println
    在循环之外显式地打印值，但这很少需要：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 3.3.1 Flowchart
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 流程图
- en: Text doesn’t visualize the control flow of a program very well. You have to
    know the semantics. Because of this, flowchart diagrams, which depict the flow
    of programs using boxes and arrows, used to be very popular (figure 3.4).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文本不能很好地可视化程序的控制流。你必须知道语义。正因为如此，使用方框和箭头描绘程序流程的流程图曾经非常流行（图 3.4）。
- en: '![03-04](../Images/03-04.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![03-04](../Images/03-04.png)'
- en: Figure 3.4 Standard flowchart boxes
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 标准流程图框
- en: In the past, students would be taught to design their programs as flowcharts
    and then write the code. The popularity of object-oriented programming caused
    flowcharts to fall out of use, as they cannot model object relations. However,
    flowchart diagrams are still very useful in teaching control flow in a program.
    If you are not familiar with loops, flowcharts can help you develop an intuition
    for how they work (figure 3.5).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，学生会学习将程序设计成流程图，然后编写代码。面向对象编程的流行导致流程图不再使用，因为它们无法模拟对象关系。然而，流程图在教授程序中的控制流方面仍然非常有用。如果你不熟悉循环，流程图可以帮助你发展对它们如何工作的直觉（图
    3.5）。
- en: '![03-05](../Images/03-05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![03-05](../Images/03-05.png)'
- en: Figure 3.5 Visualization of the control flow in a while loop
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 while 循环中的控制流可视化
- en: The square boxes represent actions performed, while the diamond-shaped boxes
    represent decisions where the flow of control branches into different directions.
    If the condition is i < 5 ? is true, then the flow will follow the arrow marked
    with yes. Otherwise control flow would follow the no arrow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方形框表示执行的操作，而菱形框表示决策，控制流会分支到不同的方向。如果条件 i < 5 ? 为真，则流程将遵循标记为 yes 的箭头。否则，控制流将遵循
    no 箭头。
- en: 3.3.2 Making a mathematical table for the sine function
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 为正弦函数制作数学表
- en: 'You now have all the basic building blocks to repeat what Charles Babbage’s
    Difference Engine did: calculating mathematical tables. To keep things simple
    let’s begin by printing out angles, as follows.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了所有基本构建块来重复查尔斯·巴贝奇差分机的功能：计算数学表。为了保持简单，让我们先打印出角度，如下所示。
- en: Listing 3.3 A loop printing out angles in increments of 15
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 以 15 为增量打印角度的循环
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You could copy and paste this code into your Julia REPL, and you would get
    this result printed out:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此代码复制并粘贴到你的 Julia REPL 中，然后你会得到以下打印结果：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before calculating the sine of these angles you need to convert them to radians,
    as sine, cosine, and tangent functions generally don’t work with degrees from
    0° to 360° but rather radians from 0 to 2π. The illustrations in figure 3.6 show
    how 1 radian is defined. If you have a circle with radius *r* and draw an arch
    *s* of length *r* along the perimeter of the circle, then the pie slice has an
    angle equal to 1 radian.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算这些角度的正弦之前，你需要将它们转换为弧度，因为正弦、余弦和正切函数通常不使用 0° 到 360° 的度数，而是使用 0 到 2π 的弧度。图 3.6
    中的插图显示了 1 弧度的定义。如果你有一个半径为 *r* 的圆，并在圆周上画一个长度为 *r* 的弧 *s*，那么这个饼形部分的角度等于 1 弧度。
- en: '![03-06](../Images/03-06.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![03-06](../Images/03-06.png)'
- en: Figure 3.6 The relationship between a radian and the radius of a circle
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 弧度与圆半径的关系
- en: 'The circumference *C* and arc length *s* of a circle are defined as the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 圆的周长 *C* 和弧长 *s* 定义如下：
- en: '![03-06-Equation](../Images/03-06-Equation.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![03-06-Equation](../Images/03-06-Equation.png)'
- en: From this you can derive a function deg2rad to convert from degrees to radians.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里你可以推导出一个函数 deg2rad，用于将度转换为弧度。
- en: Listing 3.4 Converting degrees to radians
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 将度转换为弧度
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In fact you don’t have to write this function because Julia already comes with
    it in its standard library. With this function you can modify the code in listing
    3.3 and create a small program that produces a table of sine values, as follows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不必编写这个函数，因为 Julia 已经在其标准库中提供了它。使用这个函数，你可以修改列表 3.3 中的代码，创建一个生成正弦值表的程序，如下所示。
- en: Listing 3.5 Loop printing out a sine table
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 循环打印正弦表
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you run this you will get the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会得到以下输出：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 3.3.3 Range objects
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 范围对象
- en: 'When reading normal Julia code you will find that looping based on conditions
    is, in fact, not the normal approach. Instead loops tend to be defined using range
    objects; ranges are constructed with the : operator. You can do a number of things
    with ranges, such as checking whether a particular value is within the given range.
    In this example you will get the first and last part of a range, before querying
    whether a particular number is within a given range:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '当阅读正常的 Julia 代码时，你会发现基于条件的循环实际上不是正常的方法。相反，循环往往使用范围对象来定义；范围是用 : 运算符构建的。你可以对范围做很多事情，比如检查特定值是否在给定范围内。在这个例子中，你将获取范围的第一部分和最后一部分，在查询特定数字是否在给定范围内之前：'
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Construct a range object, and store it in variable r. Or more correctly, bind
    the label r to the range object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建一个范围对象，并将其存储在变量 r 中。或者更准确地说，将标签 r 绑定到范围对象上。
- en: ❷ Get the start of the range.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取范围的起始点。
- en: ❸ Get the end of the range.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取范围的末尾。
- en: ❹ Check if 1 is within the range 2 to 4\. Since 1 is outside of the range this
    expression will evaluate to false.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查 1 是否在 2 到 4 的范围内。由于 1 不在范围内，这个表达式将评估为假。
- en: ❺ Check if 3 is within the range. It is.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查 3 是否在范围内。是的。
- en: ❻ Normally, you can only use Unicode symbols in infix form, but in is an exception.
    3 in r is equivalent to in(3, r).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通常，你只能使用中缀形式的 Unicode 符号，但 in 是一个例外。r 中的 3 等同于 in(3, r)。
- en: 3.3.4 For loops
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 For 循环
- en: Range objects are commonly used in for loops, but before showing a for loop
    example let me just show you how you might use it in a while loop. The loop is
    repeated as long as the i in 0:4 condition remains true, as follows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 范围对象在 for 循环中常用，但在展示 for 循环示例之前，让我先展示你如何在 while 循环中使用它。当 i 在 0:4 条件保持为真时，循环会重复，如下所示。
- en: Listing 3.6 While loop using a range
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 使用范围对象的 while 循环
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is such a common and useful idiom that for loops are made to remove a lot
    of the boilerplate. The following code is equivalent in behavior.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如此常见且有用的习语，以至于 for 循环被用来移除很多样板代码。以下代码在行为上是等效的。
- en: Listing 3.7 For loop over a range
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 对范围进行 for 循环
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What about cases when you don’t want to increment by 1 on each iteration? When
    you calculated angles you did it in increments of 15\. Is that possible to do
    with a for loop? No problem; ranges allow you to define a step size, as in the
    following listing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不想在每次迭代中递增1时怎么办？当你计算角度时，你是以15度的增量进行的。这是否可以用for循环做到？没问题；范围允许你定义步长，如下面的列表所示。
- en: Listing 3.8 For loop with stepped range
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 带步长范围的for循环
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run this code you get the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此代码时，你会得到以下输出：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Objects you can use in a for loop, such as range objects, are referred to as
    *iterable*. There are many different iterable objects in Julia, which we will
    explore in later chapters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在for循环中使用的对象，如range对象，被称为*可迭代对象*。Julia中有许多不同的可迭代对象，我们将在后面的章节中探讨。
- en: 3.4 Multiline functions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 多行函数
- en: The functions you have used up until now have been defined on a single line.
    That is quite limiting. More complex problems require multiple lines of code.
    How do you do that? You need a way to mark the beginning and end of the code that
    should be included in the function. The for loop and while loop may already give
    you a hint at how you to do that. A multiline function starts with the keyword
    function and ends with the keyword end. In the following example code you use
    a loop to print out the sine value for all angles from 0 to max_angle with an
    angle increment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止所使用的函数都是定义在一行上的。这相当有限。更复杂的问题需要多行代码。你该如何做到这一点？你需要一种方式来标记应该包含在函数中的代码的开始和结束。for循环和while循环可能已经给你一些提示，告诉你如何做到这一点。一个多行函数以关键字function开始，以关键字end结束。在下面的示例代码中，你使用循环来打印出从0到max_angle的所有角度的正弦值，角度递增。
- en: Listing 3.9 Code for creating a sine table stored in a function
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 创建存储在函数中的正弦表的代码
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how listing 3.9 modifies previous code listing 3.5 to use function arguments
    increment and max_angle instead of hard coding 15- and 90-degree angles. Thus
    users can easily change the table they produce. For example, users can produce
    sine values with 1-degree increments, with print_sin_table(1, 90).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表3.9是如何修改之前的代码列表3.5，使用函数参数increment和max_angle而不是硬编码15度和90度角度。因此，用户可以轻松地更改他们生成的表格。例如，用户可以使用print_sin_table(1,
    90)生成以1度递增的正弦值。
- en: So how does this relate to the Difference Engine made by Charles Babbage? Babbage’s
    equivalent of println would not have written numbers on a computer screen but
    to a sort of printer. The Difference Engine was meant to be attached to a machine
    that would imprint numbers on metal plates. These could then be used for printing
    number tables in books. You could also send the numbers you produce to other devices,
    but this will be covered in later chapters on input and output.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这与查尔斯·巴贝奇制造的差分机有什么关系？巴贝奇的println等价物不会在计算机屏幕上写数字，而是写入一种打印机。差分机旨在连接到一种机器，该机器会在金属板上印制数字。然后，这些数字可以用于在书中打印数字表。你还可以将你生成的数字发送到其他设备，但这将在后面的章节中介绍。
- en: 3.4.1 Implementing the sine trigonometric function
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 实现正弦三角函数
- en: 'Now that you have learned to use loops and multiline functions, you actually
    have all the building blocks necessary to build your own sin function, meaning
    you can replicate what a calculator does. Review the Taylor series used to calculate
    the *sin(x)* function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了使用循环和多行函数，实际上你已经拥有了构建自己的sin函数所需的所有构建块，这意味着你可以复制计算器的功能。回顾用于计算*sin(x)*函数的泰勒级数：
- en: '![03-02-Equation_3-4](../Images/03-02-Equation_3-4.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![03-02-Equation_3-4](../Images/03-02-Equation_3-4.png)'
- en: 'This function can be written as a summation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以写成求和的形式：
- en: '![03-06-Equation_3-9](../Images/03-06-Equation_3-9.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![03-06-Equation_3-9](../Images/03-06-Equation_3-9.png)'
- en: I will not prove mathematically how to arrive at this definition; your interest
    here is demonstrating how computers can be used to solve such problems. Computing
    by hand became a real problem in the 1800s, as the importance of mathematics and
    science expanded.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会从数学上证明如何得到这个定义；你在这里的兴趣是展示计算机如何被用来解决这样的问题。在19世纪，随着数学和科学的重要性增加，手工计算成为一个真正的问题。
- en: 'If you are unfamiliar with mathematical notation, let me demonstrate in code
    how the Σ operator works. Let’s start with a simple case:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对数学符号不熟悉，让我用代码演示Σ运算符的工作原理。让我们从一个简单的例子开始：
- en: '![03-06Equation_3-10](../Images/03-06Equation_3-10.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![03-06Equation_3-10](../Images/03-06Equation_3-10.png)'
- en: The bottom and top half of the Σ symbol basically define a range. You are stating
    that you will iterate over the variable *x* from 1 to *n*. You can think of the
    Σ operator as performing a loop; it iterates across a range and adds up values
    of the expression it iterates over. You can mimic this behavior with a for loop,
    as follows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Σ 符号的底部和上半部分基本上定义了一个范围。您正在声明您将迭代变量 *x* 从 1 到 *n*。您可以将 Σ 运算符视为执行循环；它遍历一个范围，并累加它遍历的表达式的值。您可以使用如下
    for 循环来模拟这种行为。
- en: Listing 3.10 How the sum operator works
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 如何工作求和运算符
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ For storing the total sum
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于存储总和
- en: ❷ A shorthand for total = total + 2x + 1
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ total = total + 2x + 1 的简写
- en: ❸ Return value
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回值
- en: A function evaluates to the value of its last expression. In many other languages
    this is called the *return value*, and the last expression would have been written
    as
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的值等于其最后一个表达式的值。在许多其他语言中，这被称为 *返回值*，最后一个表达式将被写成
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is also valid in Julia, but it is only used when you need to exit a function
    early. Otherwise return is usually omitted in Julia functions. The following listing
    should help you understand how you can use the Taylor series to implement a sine
    function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Julia 中也有效，但只有在您需要提前退出函数时才会使用。否则，在 Julia 函数中通常省略 return。以下列表应有助于您了解如何使用泰勒级数来实现正弦函数。
- en: Listing 3.11 Sine implemented using the Taylor series
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 使用泰勒级数实现的正弦函数
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Placing this function in a separate file (e.g., trig.jl) along with other trigonometric
    functions you implement is a good exercise for the reader. Implement cosine and
    tangent as well; you can perform an internet search to find their Taylor series
    definition. You can then load this file into Julia and compare with the built-in
    sin function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数放在单独的文件中（例如，trig.jl），其中包含您实现的其他三角函数，对读者来说是一个很好的练习。也实现余弦和正切函数；您可以通过网络搜索找到它们的泰勒级数定义。然后您可以将此文件加载到
    Julia 中，并与内置的 sin 函数进行比较：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see that the results are quite similar despite the fact that you only
    iterate up to n = 5. The accurate definition implies that n = ∞, which is impractical
    to implement in code. Try with different values of n to see if you can get as
    accurate result as the built-in sin function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，尽管您只迭代到 n = 5，但结果相当相似。准确定义意味着 n = ∞，这在代码中实现是不切实际的。尝试使用不同的 n 值，看看您是否能得到与内置
    sin 函数一样准确的结果。
- en: 3.5 Implementing factorial
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 实现阶乘
- en: 'Your custom sine function uses the built-in factorial function. The factorial
    of a number *n* means multiplying every number from 1 up to *n*. So the factorial
    of five would be 5 × 4 × 3 × 2 × 1\. How would you implement this yourself? There
    are many approaches. We will look at some of them in this section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您自定义的正弦函数使用了内置的阶乘函数。一个数字 *n* 的阶乘意味着将 1 到 *n* 之间的每个数字相乘。所以五的阶乘将是 5 × 4 × 3 ×
    2 × 1。您会如何自己实现它呢？有好多方法。在本节中，我们将探讨其中的一些：
- en: Using the built-in prod function.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的 prod 函数。
- en: Using a while loop to perform multiple multiplications.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 while 循环执行多次乘法。
- en: Multiplying repeatedly by combining recursion with an if statement.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过结合递归和 if 语句重复乘法。
- en: 'The prod function is able to multiply all the numbers in a range:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: prod 函数能够乘以一个范围内的所有数字：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Define your own factorial function named fac, implemented with prod.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义自己的名为 fac 的阶乘函数，使用 prod 实现。
- en: ❷ Check that fac and factorial give the same result.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查 fac 和 factorial 是否给出相同的结果。
- en: Experiment with both of these functions to make sure you get the same result.
    You could do this by using a loop as before.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这两个函数，以确保您得到相同的结果。您可以通过使用循环来实现这一点。
- en: Listing 3.12 Factorial implemented using a loop
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 使用循环实现的阶乘
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On each iteration in the loop you decrease the value of n by 1 until the condition
    n >= 1 no longer holds true and exit with the product^([2](#pgfId-1016953)) of
    all numbers in the range n to 1\.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，您将 n 的值减去 1，直到条件 n >= 1 不再成立，然后退出，并带上 n 到 1 范围内所有数字的乘积^([2](#pgfId-1016953))。
- en: 3.6 Factorial with recursion
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 递归阶乘
- en: There is another way you can achieve looping without using the while and for
    loops, called *recursion*. Check out the following code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不使用 while 和 for 循环实现循环的方法称为 *递归*。查看以下代码。
- en: Listing 3.13 Broken factorial function implemented using recursion
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 使用递归实现的错误阶乘函数
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Try running this. It doesn’t quite work. You get the following error message:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行此代码。它并不完全工作。您会得到以下错误信息：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is because the fac function keeps calling fac indefinitely. Or more specifically,
    it calls fac 79,984 times in my example, until it blows up by running out of memory.
    This produces a *stackoverflow* error message. This is because you keep calling
    fac, even when the n argument has become less than 1\. Somehow you need to check
    whether n has become less than 1 and exit. You are lucky because Julia’s if statement
    can help you do that.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 fac 函数不断地调用 fac，直到无限循环。或者更具体地说，在我的例子中，它调用了 79,984 次 fac，直到因为内存耗尽而崩溃。这产生了
    *stack overflow* 错误信息。这是因为你甚至在 n 参数小于 1 时仍然调用 fac。某种方式你需要检查 n 是否已经小于 1 并退出。你很幸运，因为
    Julia 的 if 语句可以帮助你做到这一点。
- en: 3.7 If statements
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 If 语句
- en: Now rewrite your recursive fac function using an if statement. The following
    code is the first attempt. You will expand on this code until the factorial function
    handles all edge cases, such as fac(0).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 if 语句重写你的递归 fac 函数。以下代码是第一次尝试。你将在此基础上扩展代码，直到阶乘函数处理所有边缘情况，例如 fac(0)。
- en: Listing 3.14 Almost-working factorial function implemented using recursion
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 几乎可以工作的使用递归实现的阶乘函数
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ You exit the fac function using the return statement if the n argument is
    less than or equal to 2\. You explicitly call return here to do an early return,
    rather than waiting until you get to the last expression in the function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 n 参数小于或等于 2，你将使用 return 语句退出 fac 函数。你在这里显式调用 return 以进行早期返回，而不是等待到达函数中的最后一个表达式。
- en: ❷ Call fac again but with n-1, and multiply the returned result with n. Remember
    the last expression in a Julia function does an implicit return.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 再次调用 fac，但这次是 n-1，并将返回的结果与 n 相乘。记住 Julia 函数中的最后一个表达式会进行隐式返回。
- en: 3.7.1 If-else statements
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.1 If-else 语句
- en: Instead of using the return statement to exit the function early, you can choose
    between two different blocks of code to execute by adding an else clause, as in
    the following listing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 return 语句提前退出函数，你可以通过添加一个 else 子句来选择执行两个不同的代码块之一，如下面的列表所示。
- en: Listing 3.15 If-else statement
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 If-else 语句
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the n <= 2 condition is not true, you will evaluate the code between the
    else-end block. The whole if-else statement, like all other statements in Julia,
    is an expression that evaluates to a value. The statement evaluates to the value
    of the code block that was evaluated. You can try this out in the Julia REPL yourself.
    Experiment with different values for x, and see how the value of y changes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 n <= 2 的条件不成立，你将评估 else-end 块之间的代码。整个 if-else 语句，就像 Julia 中的所有其他语句一样，是一个返回值的表达式。该语句返回被评估的代码块中的值。你可以在
    Julia REPL 中亲自尝试。通过改变 x 的不同值，看看 y 的值是如何变化的：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However your fac function doesn’t actually work correctly yet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的 fac 函数实际上还没有正确工作：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: fac(0) returns 0, but it should return 1\. Also, fac(n) with n < 0 should not
    even be allowed. Thus you need to handle the case in which n == 0 and n < 0 differently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: fac(0) 返回 0，但它应该返回 1。此外，n < 0 的 fac(n) 甚至不应该被允许。因此，你需要以不同的方式处理 n == 0 和 n <
    0 的情况。
- en: 3.7.2 Elseif clause
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7.2 ElseIf 子句
- en: In this scenario the elseif clause comes to the rescue. You can add several
    of these clauses to any if statement. You have done just that in the following
    listing to handle all the unique cases. Go ahead and test in the REPL whether
    fac(0) and fac(-1) behave correctly with this update.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，elseif 子句起到了救星的作用。你可以在任何 if 语句中添加多个这样的子句。你已经在下面的列表中这样做，以处理所有独特的情况。现在请在
    REPL 中测试 fac(0) 和 fac(-1) 是否能正确地处理这个更新。
- en: Listing 3.16 If-else statement
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 If-else 语句
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Return 1 if n is zero.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 n 是零，则返回 1。
- en: ❷ Create an exception object. These are used to store information about an error
    that occurred.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个异常对象。这些用于存储关于发生的错误的信息。
- en: ❸ Report an error indicating that n is not allowed to be negative.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 报告一个错误，指出 n 不允许为负数。
- en: Each elseif clause adds another condition check. First check if n > 2, then
    check if it is n > 0. Continue performing every elseif check, until you hit a
    condition that evaluates to true. If no condition is true, evaluate the else clause
    that reports an error (figure 3.7).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 elseif 子句都会添加另一个条件检查。首先检查 n > 2，然后检查它是否是 n > 0。继续执行每个 elseif 检查，直到遇到一个评估为真的条件。如果没有条件为真，则评估
    else 子句，该子句报告错误（图 3.7）。
- en: '![03-07](../Images/03-07.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![03-07](../Images/03-07.png)'
- en: Figure 3.7 If statement with elseif and else
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 包含 elseif 和 else 的 if 语句
- en: 'Before discussing error handling further, I will conclude by clarifying the
    rules for writing an if statement:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论错误处理之前，我将通过澄清编写 if 语句的规则来结束讨论：
- en: There must be exactly one if keyword used, and it has to be at the start.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须恰好使用一个 if 关键字，并且它必须位于开头。
- en: else is optional, but it can only be used once and only at the very end.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: else 是可选的，但它只能使用一次，并且只能放在非常末尾。
- en: You can write any number of elseif clauses, but they have to come after the
    if clause.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以写任意数量的 elseif 子句，但它们必须跟在 if 子句之后。
- en: 3.8 Throwing exceptions to handle errors
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 抛出异常以处理错误
- en: In programming speak, functions return values but throw exceptions. In Julia
    this is used to handle programmer mistakes. As a programmer you should not provide
    negative numbers to fac. However, mistakes happen, and have to be dealt with.
    The idea is to report a problem as early as possible—as soon as you have discovered
    it. This makes it easier to diagnose problems when you are developing and testing
    your software.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，函数返回值但抛出异常。在 Julia 中，这用于处理程序员的错误。作为一个程序员，你不应该向 fac 提供负数。然而，错误是会发生的，必须得到处理。想法是尽可能早地报告问题——一旦你发现了它。这使你在开发和测试软件时诊断问题变得更加容易。
- en: How is throwing an exception different from returning a value? Let me explain
    with an example (figure 3.8).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常与返回值有什么不同？让我用一个例子（图 3.8）来解释。
- en: '![03-08](../Images/03-08.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![03-08](../Images/03-08.png)'
- en: Figure 3.8 Difference between regular returns and throwing exceptions
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 正常返回与抛出异常的区别
- en: If function alpha calls beta which calls gamma, then you get what is called
    a *call stack*. The call stack is a place in memory storing the location of function
    calls. This is necessary because when your CPU finishes processing instructions
    in gamma, it needs to get back to the location in beta where gamma was called
    initially. This location is stored in memory. You call it the *return address*.
    Likewise you need to remember how to return to alpha from beta. These nested function
    calls create a stack of return addresses. This is the *call stack*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数 alpha 调用 beta，而 beta 又调用 gamma，那么你得到的就是所谓的 *调用栈*。调用栈是内存中存储函数调用位置的地方。这是必要的，因为当你的
    CPU 完成对 gamma 中指令的处理后，它需要回到 beta 中 gamma 被最初调用的位置。这个位置被存储在内存中。你称之为 *返回地址*。同样，你需要记住如何从
    beta 返回到 alpha。这些嵌套的函数调用创建了一个返回地址的栈。这就是 *调用栈*。
- en: 'As figure 3.8 shows, return carries you back the same way you came. throw is
    different; it allows you to skip many steps in the call stack. throw skips every
    function called until it reaches a point where there is a catch defined:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 3.8 所示，return 会带你回到来的地方。throw 是不同的；它允许你跳过调用栈中的许多步骤。throw 跳过所有被调用的函数，直到它到达一个有
    catch 定义的点：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Defines a block of code, where somewhere in the callstack an exception may
    occur
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个代码块，其中在调用栈的某个地方可能会发生异常
- en: ❷ If an exception does occur it will be caught, and this block of code is meant
    to clean up or handle the exception.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果发生异常，它将被捕获，并且此代码块旨在清理或处理异常。
- en: 'Information about the error is stored in an exception object, which was passed
    to the throw function. The variable e gets set to this object; thus the catch
    block is able to access information about the error that occurred. At this point
    we cannot discuss exceptions in great detail, as this requires a firmer understanding
    of the Julia type system. You can, however, experiment with this in the REPL yourself
    to get a feel for how exceptions break the normal flow of control:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息存储在异常对象中，该对象被传递给了 throw 函数。变量 e 被设置为这个对象；因此 catch 块能够访问到发生的错误信息。在此阶段，我们无法详细讨论异常，因为这需要更深入地理解
    Julia 的类型系统。然而，你可以在 REPL 中自己尝试这个操作，以了解异常如何打断正常的控制流：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember, almost everything in Julia is an expression, including try-catch blocks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Julia 中几乎一切都是表达式，包括 try-catch 块。
- en: 3.9 Control flow vs. data flow
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 控制流与数据流的比较
- en: 'Now that you have looked at different forms of control flow, we’ll discuss
    the meaning of *control flow* in greater depth. Comparing control flow with data
    flow may help you better grasp the concept. Consider this simple code snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了不同的控制流形式，我们将更深入地讨论 *控制流* 的含义。将控制流与数据流进行比较可能有助于你更好地掌握这个概念。考虑以下简单的代码片段：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are two different perspectives when looking at this code: a message stored
    in bob flows *into* the encrypt function, and a cipher text object flows *out*
    of the function (figure 3.9).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此代码时，有两种不同的视角：存储在 bob 中的消息流向 encrypt 函数，而密文对象从函数中流出（图 3.9）。
- en: '![03-09](../Images/03-09.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![03-09](../Images/03-09.png)'
- en: Figure 3.9 Contrasting data flow and control flow
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 对比数据流和控制流
- en: With data flow, data is flowing along the arrow between the boxes. In figure
    3.9 the light boxes are sources and sinks, and the dark box is a filter. It transforms
    incoming data into another type of data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据流中，数据沿着盒子之间的箭头流动。在图3.9中，亮色的盒子是源和汇，而深色的盒子是一个过滤器。它将传入的数据转换成另一种类型的数据。
- en: 'In a control flow diagram (e.g., a flowchart), arrows don’t represent movement
    of data, but transition of control. Control flow is about how control flows from
    one box to the other and how that flow can be altered and redirected:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制流图中（例如，流程图），箭头不表示数据的移动，而是控制的转换。控制流是关于控制如何从一个盒子流向另一个盒子，以及这种流动如何被改变和重新导向：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this example, you can think of how control is passed from the alpha function
    to the beta function and finally to the gamma function: there is a flow of control.
    From a data flow perspective, we think of data flowing into alpha, out of it,
    and then into beta.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以思考控制是如何从alpha函数传递到beta函数，最终传递到gamma函数的：存在控制流。从数据流的角度来看，我们认为数据流入alpha，流出它，然后流入beta。
- en: When analyzing complex code, sketching out a data flow diagram can be useful.
    By labeling arrows with the type of data going in and out of functions (filters)
    you can get a better overview of complex data flows through your code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析复杂的代码时，绘制数据流图可能会有所帮助。通过在箭头上标注函数（过滤器）输入和输出的数据类型，你可以更好地了解代码中复杂的数据流。
- en: 3.10 Counting rabbits
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.10 计算兔子数量
- en: 'In many programming books you will find an implementation of the fib function,
    which is short for *Fibonacci*. Why is this function so popular in programming?
    And why should you care? Consider the following reasons:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程书籍中，你会找到fib函数的实现，这个名字是**斐波那契**的缩写。为什么这个函数在编程中如此流行？你为什么应该关心？考虑以下原因：
- en: It is a simple way of demonstrating transformation of a mathematical definition
    into code.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一种简单的方法，可以展示数学定义如何转化为代码。
- en: Implementing it allows you to contrast solving problems through *recursion*
    and *iteration* (loops).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现它允许你对比通过**递归**和**迭代**（循环）解决问题。
- en: 'Fibonacci numbers pop up in all sorts of real-life circumstances: in the number
    of flower petals, spirals on a sunflower or nautilus shell, and fractions that
    appear in phyllotaxis.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 斐波那契数出现在各种现实生活中的情况中：在花瓣的数量、向日葵或乌贼壳上的螺旋，以及出现在叶序中的分数。
- en: It is a simple demonstration of how you build models of real-world phenomena.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个简单演示如何构建现实世界现象的模型。
- en: 'This is what the number sequence looks like. The sequence goes on towards infinity:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数字序列的看起来。序列一直延伸到无穷大：
- en: '![03-09-Equation_3-11](../Images/03-09-Equation_3-11.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![03-09-方程式_3-11](../Images/03-09-方程式_3-11.png)'
- en: 'Each of the numbers in this sequence is called a *Fibonacci number*. Mathematicians
    like to refer to each of these numbers using the letter *F*. The first number
    in the sequence is *F*[0], the second is *F*[1] and so on. In other words, the
    indexing starts at 0\. Mathematically, Fibonacci numbers are defined as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列中的每一个数都被称为**斐波那契数**。数学家们喜欢用字母**F**来指代这些数中的每一个。序列中的第一个数是**F**[0]，第二个是**F**[1]，以此类推。换句话说，索引从0开始。从数学的角度来看，斐波那契数被定义为如下：
- en: '![03-09-Equation_3-12](../Images/03-09-Equation_3-12.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![03-09-方程式_3-12](../Images/03-09-方程式_3-12.png)'
- en: 'This may seem as enlightening as a Wikipedia page (i.e., not very), so I’ll
    try to provide some intuition behind this mathematical definition with a concrete
    example: the growth of a rabbit population. In fact, this is how Fibonacci numbers
    were discovered. Leonardo of Pisa, also known as Fibonacci, was wondering some
    800 years ago how a rabbit population would grow each month. He asked the following
    hypothetical question:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来就像维基百科页面一样启发人心（即，不是非常），所以我会尝试用一个具体的例子来提供这个数学定义背后的直觉：兔子的种群增长。事实上，这就是斐波那契数是如何被发现的。比萨的莱昂纳多，也就是斐波那契，大约800年前在思考兔子种群每个月会如何增长。他提出了以下假设性问题：
- en: If we have one pair of rabbits at the start of the year, how many will there
    be at the end of the year?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在年初有一对兔子，那么一年结束时会有多少只？
- en: To answer this question, you need to build models of reality. When building
    models, try to extract the most important features of the specific traits you
    are trying to model. For instance, you don’t care about how the rabbits spread
    out, what they look like, what they eat, or how they obtain food. Your model is
    only concerned with how their population grows. All models are built for a particular
    purpose; if you want to check how well a new cellphone will fit in somebody’s
    pocket, then the model doesn’t need to be anything more advanced than a block
    of wood. The only thing you need to mimic is the physical dimensions of the phone,
    not the color of the exterior or crispness of the screen.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，你需要构建现实的模型。在构建模型时，尝试提取你试图模拟的具体特征的最重要的特征。例如，你不需要关心兔子如何扩散，它们看起来像什么，它们吃什么，或者它们如何获取食物。你的模型只关心它们的种群增长。所有模型都是为了特定目的而构建的；如果你想检查一部新手机是否适合某人的口袋，那么模型不需要比一块木头更复杂。你需要模拟的只是手机的物理尺寸，而不是外部的颜色或屏幕的清晰度。
- en: Models, thus, always involve major *simplifications* of reality. In Fibonacci’s
    model of rabbit growth, you deal with immortal rabbits. They never actually die.
    They are born, and a month after birth they start reproducing. You always model
    them as pairs. One pair of rabbits produces another pair of rabbits every month
    as soon as they reach reproductive age (figure 3.10).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模型总是涉及对现实的重大 *简化*。在斐波那契的兔子增长模型中，你处理的是不朽的兔子。它们实际上从未死去。它们出生，出生后一个月就开始繁殖。你总是将它们建模为对。一对兔子在达到繁殖年龄后，每个月都会产生另一对兔子（如图
    3.10）。
- en: '![03-10](../Images/03-10.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![03-10](../Images/03-10.png)'
- en: Figure 3.10 Rabbit population growth each month, as illustrated by Mathigon
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 Mathigon 展示的每月兔子种群增长
- en: 'Mathigon ([https://mathigon.org/course/sequences/fibonacci](https://mathigon.org/course/sequences/fibonacci))
    is an excellent online source demonstrating interactively how rabbit populations
    grow according to the Fibonacci number sequence. The hexagons in the screenshot
    show how many rabbit pairs exist for a given month. In the first month you only
    have 1 pair, while in the sixth month you have 8 pairs. When you implement the
    fib function (listing 3.17) to calculate Fibonacci numbers, it works like this:
    fib(1) is the same as *F*[1]; fib(n) corresponds to *F*[n].'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Mathigon ([https://mathigon.org/course/sequences/fibonacci](https://mathigon.org/course/sequences/fibonacci))
    是一个优秀的在线资源，通过交互式演示如何根据斐波那契数列来展示兔子种群的增长。截图中的六边形显示了给定月份的兔子对数。在第一个月你只有一对兔子，而在第六个月你则有8对。当你实现
    fib 函数（列表 3.17）来计算斐波那契数时，它的工作方式是这样的：fib(1) 与 *F*[1] 相同；fib(n) 对应于 *F*[n]。
- en: Listing 3.17 Calculating a Fibonacci number
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 计算斐波那契数
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ The mathematical definition says F[0] = 0, F[1] = 1, which is expressed here.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数学定义说 F[0] = 0，F[1] = 1，这在这里得到了表达。
- en: ❷ For all other values of n, they are equal to the two preceding Fibonacci numbers.
    This expresses a recursion. The fib function is calling itself with another argument.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于所有其他 n 的值，它们等于前两个斐波那契数。这表达了递归。fib 函数用另一个参数调用自己。
- en: 'Let’s try to walk through how this function works in practice. What happens
    when you try to evaluate fib(3)? This sets n = 3. Whenever n > 1 the following
    line is evaluated:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试分析这个函数在实际中的工作方式。当你尝试评估 fib(3) 时会发生什么？这设置了 n = 3。每当 n > 1 时，以下行会被评估：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will get evaluated over and over again, but the argument n is reduced
    by 1 and 2 each time, meaning sooner or later the first conditions of the fib
    function becomes true. The result then bubbles back up, completing earlier requests.
    Thus you have a sort of double recursion in this case. These REPL examples provide
    a sense of how the Fibonacci function works:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会被反复评估，但每次参数 n 都会减少 1 和 2，这意味着迟早 fib 函数的第一个条件会成立。然后结果会冒泡回传，完成之前的请求。因此，在这种情况下，你有一种双重递归。这些
    REPL 示例提供了斐波那契函数工作方式的感觉：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 3.10.1 Base case
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.1 基础情况
- en: To avoid the recursion running until you consume all your stack memory, you
    need to define the *base case*. This is the if statement that lets you exit the
    recursion at some point.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免递归运行到消耗完所有栈内存，你需要定义 *基础情况*。这是让你在某个点上退出递归的 if 语句。
- en: Listing 3.18 Calculating a Fibonacci number
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 计算斐波那契数
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Check if n is within the range of 0 to 1\. Is it equal to or greater than
    zero as well as smaller or equal to one?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查 n 是否在 0 到 1 的范围内。它是否等于或大于零，同时也小于或等于一？
- en: The 0 <= n <= 1 condition defines the base condition or exist point. You need
    something similar for every recursive function. A recursive function is a function
    that calls itself.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 0 <= n <= 1 条件定义了基本条件或存在点。每个递归函数都需要类似的东西。递归函数是调用自身的函数。
- en: 3.10.2 Iteration vs. recursion
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.2 迭代与递归
- en: 'Earlier you demonstrated that recursion is just one of many ways of solving
    a problem; it is never a requirement. A recursion can always be replaced by an
    iteration. By iteration I mean looping (e.g., using a for loop or while loop).
    For example, with the following code you are *iterating* over the range 0 to 4:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 之前你演示了递归只是解决问题多种方式中的一种；它从来不是必需的。递归总是可以被迭代替换。通过迭代，我指的是循环（例如，使用 for 循环或 while
    循环）。例如，使用以下代码，你正在 *迭代* 从 0 到 4 的范围：
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you can solve the same problem with iteration, then why use recursion? Let’s
    look at the iteration solution to discuss its pros and cons.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以用迭代解决相同的问题，那么为什么还要使用递归？让我们看看迭代解决方案来讨论其优缺点。
- en: Listing 3.19 Calculating a Fibonacci number using iteration
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 使用迭代计算斐波那契数
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Early exit; to avoid deep nesting you use the return keyword to exit the function
    immediately with the value n.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提前退出；为了避免深层嵌套，你使用 return 关键字立即以值 n 退出函数。
- en: ❷ prev is used to represent fib(n-2).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ prev 用于表示 fib(n-2)。
- en: ❸ To hold the final result fib(n)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 要保存最终结果 fib(n)
- en: ❹ This is shorthand for x = x + prev, which is equivalent to the fib(n-1) +
    fib(n-2) calculation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这是对 x = x + prev 的简写，它等同于 fib(n-1) + fib(n-2) 的计算。
- en: While this code may be easier conceptually, you may notice that iteration makes
    everything a lot messier. You get a lot more bookkeeping, meaning we have more
    variables to maintain and update properly. I spent markedly longer time creating
    this example code, while making several mistakes in the initial version. The recursive
    variant, in contrast, I wrote correctly on my first attempt.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码在概念上可能更容易理解，但你可能会注意到迭代使一切变得混乱。你需要做更多的记录，这意味着我们有更多的变量需要正确维护和更新。我花费了明显更长的时间来创建这个示例代码，并且在初始版本中犯了几次错误。相比之下，递归版本我在第一次尝试时就写对了。
- en: Thus while recursion may take some time getting accustomed to, it frequently
    makes your code much simpler. One downside is that recursion is often slower.
    Thus, often you will implement your solution through recursion first, and if it
    turns out to be too slow, you rewrite it using iteration.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然递归可能需要一些时间来习惯，但它通常会使得你的代码更加简单。一个缺点是递归通常较慢。因此，通常你首先通过递归实现你的解决方案，如果它变得太慢，你将重新编写它使用迭代。
- en: 3.10.3 To return or not return
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10.3 返回或不返回
- en: The last example used a return statement to perform an early exit from the function.
    This is also optional, but as you can see, writing the code without return can
    make it harder to read. This is because you can end up with deep nesting of control-flow
    statements, as seen in the following listing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子使用了返回语句来从函数中提前退出。这是可选的，但正如你所见，不写返回语句可能会使代码更难阅读。这是因为你可能会遇到控制流语句的深层嵌套，如下面的列表所示。
- en: Listing 3.20 Calculating a Fibonacci number without early return
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 不使用早期返回计算斐波那契数
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There are no hard rules here. You will just have to use common sense and rely
    on your own sense of good taste. As a rule of thumb, I try to avoid nesting deeper
    than three levels; however, avoid creating strict rules. An obsession with rules
    carved in stone has always plagued the software industry. It is better to be flexible
    and use common sense. Julia itself is a language that tries to be pragmatic.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有硬性规则。你只需使用常识并依靠你自己的审美观。作为一个经验法则，我尽量不嵌套超过三个层次；然而，避免制定严格的规则。对刻在石头上的规则的执着一直是软件行业的困扰。更灵活地使用常识会更好。Julia
    本身就是一种试图实用的语言。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Control-flow statements use conditions composed using Boolean expressions. Loops
    repeat as long as condition remains true.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流语句使用由布尔表达式组成的条件。循环会一直重复，直到条件保持为真。
- en: Even control-flow statements are expressions in Julia, meaning they evaluate
    to a value. In Julia, even nothing is a value.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使控制流语句在 Julia 中也是表达式，意味着它们会返回一个值。在 Julia 中，甚至 nothing 也是一个值。
- en: Computers’ ability to repeat similar calculations a large number of times makes
    them suited for computations that are hard to do by hand, such as calculating
    trigonometric functions.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机能够重复进行大量类似的计算，这使得它们适合于手工难以完成的计算，例如计算三角函数。
- en: A recursive function is a function that calls itself. Recursive functions must
    have a *base case*, or they will never terminate execution.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数是调用自身的函数。递归函数必须有一个*基准情况*，否则它们将永远不会终止执行。
- en: Recursion and iteration can solve the same problems. Recursion often makes the
    code easier to write, while iteration usually provides better performance.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归和迭代可以解决相同的问题。递归通常使代码更容易编写，而迭代通常提供更好的性能。
- en: '* * *'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^(1.)In 1972 Hewlett-Packard released HP-35, the first calculator with sine
    and cosine functions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: (1.)1972年，惠普公司发布了HP-35，这是第一个具有正弦和余弦函数的计算器。
- en: ^(2.)Product is the result of multiplying numbers, in contrast to sum which
    is the result of addition.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: (2.)乘积是乘法的结果，与加法的结果之和相对。
