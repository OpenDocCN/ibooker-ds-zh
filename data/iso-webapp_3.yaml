- en: Part 4\. Applying isomorphic architecture with other tools
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4部分\. 使用其他工具应用同构架构
- en: React is a great choice for many types of front-end applications, but it’s not
    the only choice. The skills taught in this book so far are a subset of what’s
    out there to learn on your way to being a great front-end or full-stack developer.
    This last part covers additional technologies such as Angular and Ember and suggests
    how you can use them to build an isomorphic application. It also includes a brief
    chapter focused on additional skills and areas of expertise you should explore
    that will complement what you’ve learned in this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React是许多类型的前端应用程序的一个很好的选择，但它不是唯一的选择。本书迄今为止教授的技能是学习成为优秀的前端或全栈开发者的技能子集的一部分。最后一部分涵盖了额外的技术，如Angular和Ember，并建议您如何使用它们来构建同构应用程序。它还包括一个简要的章节，专注于您应该探索的额外技能和专业知识领域，这将补充您在本书中学到的内容。
- en: 'Chapter 12\. Other frameworks: implementing isomorphic without React'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章\. 其他框架：不使用React实现同构
- en: '*This chapter covers*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using Ember’s convention-over-configuration implementation to quickly implement
    a universal application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ember的约定优于配置实现快速实现通用应用程序
- en: Implementing the isomorphic parts of an Angular application with TypeScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TypeScript在Angular应用程序中实现同构部分
- en: Running an isomorphic app with Next.js, which gives you an out-of-the-box React
    implementation with server rendering built in
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Next.js运行同构应用程序，它为您提供了内置服务器渲染的现成React实现
- en: 'Each section in this chapter covers a framework that lets you get up and running
    with isomorphic rendering. This chapter doesn’t teach you these other technologies,
    although it does provide links to resources if you want to dive deeper. Instead,
    each section highlights the key parts of each framework:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的每个部分都涵盖了一个框架，该框架允许您使用同构渲染开始使用。本章不会教授您这些其他技术，尽管它确实提供了链接到资源的链接，如果您想深入了解。相反，每个部分都突出了每个框架的关键部分：
- en: Setting up and implementing server-side rendering in each framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个框架中设置和实现服务器端渲染
- en: Enabling hydration of the DOM with the server state in each framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个框架中启用具有服务器状态的DOM的水合
- en: Understanding the pros and cons to each approach
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每种方法的优缺点
- en: 12.1\. Blog example project
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. 博客示例项目
- en: In each section of this chapter, you’ll be working on the same sample application.
    [Figure 12.1](kindle_split_025_split_001.xhtml#ch12fig01) shows the homepage view
    of the blog. It’s a basic homepage with a header and a list of blog posts. Each
    blog post links to a Post Detail page, which shows the post body in full and a
    list of comments.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的每个部分中，您将使用相同的示例应用程序。![图12.1](Images/12fig01_alt.jpg)显示了博客的主页视图。这是一个带有页眉和博客帖子列表的基本主页。每个博客帖子都链接到一个帖子详情页面，该页面显示了完整的帖子正文和评论列表。
- en: Figure 12.1\. The homepage of the app that shows all the posts
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1\. 显示所有帖子的应用程序主页
- en: '![](Images/12fig01_alt.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig01_alt.jpg)'
- en: 'All code for this chapter is in its own GitHub repo at [https://github.com/isomorphic-dev-js/chapter12-frameworks](https://github.com/isomorphic-dev-js/chapter12-frameworks),
    which you can clone (`git clone https://github.com/isomorphic-dev-js/chapter12-frameworks`).
    There’s a top-level folder for each section of this chapter and a folder for the
    data server that provides the stubbed APIs for all three apps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都在其自己的GitHub仓库中，网址为[https://github.com/isomorphic-dev-js/chapter12-frameworks](https://github.com/isomorphic-dev-js/chapter12-frameworks)，您可以克隆（`git
    clone https://github.com/isomorphic-dev-js/chapter12-frameworks`）。每个部分都有一个顶级文件夹，还有一个为所有三个应用程序提供模拟API的数据服务器文件夹：
- en: '***angular2*—** Code for [section 12.2](kindle_split_025_split_002.xhtml#ch12lev1sec2).
    This is a complete Angular app.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***angular2*—** [第12.2节](kindle_split_025_split_002.xhtml#ch12lev1sec2)的代码。这是一个完整的Angular应用程序。'
- en: '***ember-universal*—** Code for [section 12.3](kindle_split_025_split_003.xhtml#ch12lev1sec3).
    This is a complete Ember app.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***ember-universal*—** [第12.3节](kindle_split_025_split_003.xhtml#ch12lev1sec3)的代码。这是一个完整的Ember应用程序。'
- en: '***nextjs*—** Code for [section 12.4](kindle_split_025_split_004.xhtml#ch12lev1sec4).
    This is a complete isomorphic React app built with the Next.js framework.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***nextjs*—** [第12.4节](kindle_split_025_split_004.xhtml#ch12lev1sec4)的代码。这是一个使用Next.js框架构建的完整的同构React应用程序。'
- en: '***server*—** The code in this folder runs a simple data API.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***server*—** 此文件夹中的代码运行一个简单的数据API。'
- en: 12.1.1\. UI and component breakdown
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1\. UI 和组件分解
- en: 'Before we get into the various isomorphic implementations, let’s review how
    the blog works. It’s made up of two routes: a home route (/) and a post detail
    route (/post). [Figure 12.1](kindle_split_025_split_001.xhtml#ch12fig01) shows
    the homepage.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入各种同构实现之前，让我们回顾一下博客是如何工作的。它由两个路由组成：主页路由 (/) 和帖子详情路由 (/post)。[图 12.1](kindle_split_025_split_001.xhtml#ch12fig01)
    展示了主页。
- en: Figure 12.2\. The Post Detail page with the corresponding comments
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.2\. 带有相应评论的帖子详情页面
- en: '![](Images/12fig02_alt.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig02_alt.jpg)'
- en: As you can see, the homepage is straightforward. A simple header has the Posts
    link that takes you back to the homepage. The list of posts is directly below
    the header. When you click any of the posts on the homepage, the app loads the
    corresponding Post Detail page. [Figure 12.2](kindle_split_025_split_001.xhtml#ch12fig02)
    shows what this page looks like.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主页很简单。一个简单的页眉包含“帖子”链接，点击后会带您回到主页。帖子列表直接位于页眉下方。当您点击主页上的任何帖子时，应用会加载相应的帖子详情页面。[图
    12.2](kindle_split_025_split_001.xhtml#ch12fig02) 展示了该页面的样子。
- en: Now that you’ve seen what the app looks like, we’ll go over the mock data server
    that provides the posts and comments data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了应用的样子，我们将介绍提供帖子评论数据的模拟数据服务器。
- en: 12.1.2\. Shared stubbed data API
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2\. 共享模拟数据 API
- en: 'The repo includes a server that serves mock data for each of the sample apps.
    There are two data types in the blog app: posts and comments. To run the server
    (which needs to be running in order for the other apps to work), you should change
    into the server directory, run `npm install`, and then run the server:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该仓库包含一个服务器，为每个示例应用提供模拟数据。博客应用中有两种数据类型：帖子评论。要运行服务器（其他应用需要服务器运行），您应该切换到服务器目录，运行
    `npm install`，然后运行服务器：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you’ve done that, you can fetch the mock data on the various endpoints
    provided:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，您可以在提供的各种端点上获取模拟数据：
- en: http://localhost:3535/posts
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://localhost:3535/posts
- en: http://localhost:3535/post/eu-eu-aute-dolore
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://localhost:3535/post/eu-eu-aute-dolore
- en: http://localhost:3535/post/1/comments
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://localhost:3535/post/1/comments
- en: The mock data for these endpoints is provided by two JSON files that I’ve already
    provided in the repo. The following listing shows what an individual post looks
    like in posts.json.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点的模拟数据由我已在仓库中提供的两个 JSON 文件提供。以下列表显示了 posts.json 中单个帖子的样子。
- en: Listing 12.1\. Posts mock data—server/data/posts.json
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. 帖子模拟数据—server/data/posts.json
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* ID of post**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 帖子的 ID**'
- en: '***2* Image for post**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 帖子的图片**'
- en: '***3* Title of post**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 帖子标题**'
- en: '***4* URL slug of post (title with dashes—posts can be looked up by urlSlug)**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 帖子的 URL 段落（带有短划线的标题—可以通过 urlSlug 查找帖子）**'
- en: '***5* Body of post**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 帖子的正文**'
- en: To fetch all posts, you use the /posts endpoint. This is used on the homepage
    to display all the posts. The server can also get individual posts by fetching
    them with `urlSlug`, which allows the URLs to be readable. Individual posts are
    fetched on the Post Detail page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有帖子，您使用 /posts 端点。这在主页上用于显示所有帖子。服务器还可以通过 `urlSlug` 获取单个帖子，这使得 URL 可读。单个帖子在帖子详情页面上获取。
- en: In addition, you can fetch comments. The following listing shows the JSON for
    an individual comment. This code is already provided in the repo.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以获取评论。以下列表显示了单个评论的 JSON 格式。此代码已在仓库中提供。
- en: Listing 12.2\. Comments mock data—server/data/comments.json
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 注释模拟数据—server/data/comments.json
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Main message body of comment**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 评论的主要信息体**'
- en: '***2* Image of user who wrote comment**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 写评论的用户图片**'
- en: '***3* User’s name**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 用户名**'
- en: '***4* ID for post that comment is associated with**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 与评论关联的帖子 ID**'
- en: '***5* ID of comment**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 评论的 ID**'
- en: To fetch all the comments for a post, you use the post/:id/comments endpoint.
    This is used on the Post Detail page to display the blog post comments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取帖子的所有评论，您使用 post/:id/comments 端点。这在帖子详情页面上用于显示博客帖子评论。
- en: Now that you’ve seen how the app works and learned how to use the mock data
    server, let’s build the first version.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了应用的工作方式并学习了如何使用模拟数据服务器，让我们构建第一个版本。
- en: 12.2\. Server rendering with Ember FastBoot
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 使用 Ember FastBoot 进行服务器端渲染
- en: '*Ember* is a popular convention-based web framework. Using Ember with its isomorphic
    implementation (called FastBoot) is straightforward. The implementation is well
    documented and nearly identical to what you do in a single-page application (SPA)
    with Ember. A couple of key differences exist:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ember* 是一个流行的基于约定的网络框架。使用 Ember 及其同构实现（称为 FastBoot）非常简单。实现方式有很好的文档记录，并且几乎与你在
    Ember 单页应用程序（SPA）中执行的操作相同。存在一些关键差异：'
- en: Install additional libraries such as ember-cli-fastboot to add support for server
    rendering.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装额外的库，如 ember-cli-fastboot，以添加对服务器渲染的支持。
- en: Use Ember Fetch to get data instead of Ember Data. If you’re used to the automatic
    data handling provided by Ember Data, this requires a shift in thinking.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ember Fetch 获取数据而不是 Ember Data。如果你习惯了 Ember Data 提供的自动数据处理，这需要思维上的转变。
- en: '[Figure 12.3](kindle_split_025_split_002.xhtml#ch12fig03) shows the isomorphic
    application diagram you’ve seen in previous chapters. Let’s review it again so
    you can see the detail on using Ember’s isomorphic implementation.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12.3](kindle_split_025_split_002.xhtml#ch12fig03) 展示了你在前几章中看到的同构应用程序图。让我们再次回顾它，以便你可以看到使用
    Ember 同构实现的具体细节。'
- en: Figure 12.3\. Isomorphic app flow with Ember—Ember specifics are highlighted
    in bold.
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.3\. 使用 Ember 的同构实现的应用程序流程——Ember 的特定内容以粗体突出显示。
- en: '![](Images/12fig03_alt.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig03_alt.jpg)'
- en: 'To follow along, check out the ember-starter branch in the GitHub repo (`git
    checkout ember-starter`). To run the app, you need to switch to the Ember directory
    (ember-universal), install the npm packages, and run the app with the Ember CLI.
    [Figure 12.4](kindle_split_025_split_002.xhtml#ch12fig04) shows the output of
    running Ember:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟上进度，请查看 GitHub 仓库中的 ember-starter 分支（`git checkout ember-starter`）。要运行应用程序，你需要切换到
    Ember 目录（ember-universal），安装 npm 包，并使用 Ember CLI 运行应用程序。[图 12.4](kindle_split_025_split_002.xhtml#ch12fig04)
    展示了运行 Ember 的输出：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Figure 12.4\. Run `ember serve` to start the app.
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行 `ember serve` 来启动应用程序。
- en: '![](Images/12fig04_alt.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig04_alt.jpg)'
- en: Ember has a tool called the Ember CLI that lets you get up and running quickly
    (I’ve already included it for you). You use the Ember CLI to run the app by calling
    `ember serve`. You can also use it to generate most of the types of files you
    use in an Ember app.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 有一个名为 Ember CLI 的工具，它让你可以快速开始（我已经为你包括了它）。你通过调用 `ember serve` 使用 Ember
    CLI 运行应用程序。你还可以使用它来生成 Ember 应用程序中使用的绝大多数类型的文件。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Ember resources**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ember 资源**'
- en: 'If you’d like to learn more about building web apps with Ember, here are some
    resources to help you get started:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于使用 Ember 构建网络应用程序的信息，以下是一些帮助你入门的资源：
- en: The Ember documentation site provides a getting started tutorial at [https://guides.emberjs.com/v2.14.0/tutorial/ember-cli/](https://guides.emberjs.com/v2.14.0/tutorial/ember-cli/).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember 文档网站提供了一个入门教程，链接为 [https://guides.emberjs.com/v2.14.0/tutorial/ember-cli/](https://guides.emberjs.com/v2.14.0/tutorial/ember-cli/)。
- en: You can also check out the Quick Start guide at [https://guides.emberjs.com/v2.14.0/getting-started/quick-start/](https://guides.emberjs.com/v2.14.0/getting-started/quick-start/).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以查看快速入门指南，链接为 [https://guides.emberjs.com/v2.14.0/getting-started/quick-start/](https://guides.emberjs.com/v2.14.0/getting-started/quick-start/)。
- en: You’ll find several other Ember tutorials at [http://emberwatch.com/tutorials.html](http://emberwatch.com/tutorials.html).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [http://emberwatch.com/tutorials.html](http://emberwatch.com/tutorials.html)
    找到其他几个 Ember 教程。
- en: The guide to server-rendered Ember is at [https://ember-fastboot.com/quickstart](https://ember-fastboot.com/quickstart).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器渲染的 Ember 指南位于 [https://ember-fastboot.com/quickstart](https://ember-fastboot.com/quickstart)。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The app will run at http://localhost:4200/. Remember to start the data server
    in the server folder as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将在 http://localhost:4200/ 上运行。请记住，同时也要在服务器文件夹中启动数据服务器。
- en: Next, we’ll review the structure of the Ember app.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾 Ember 应用的结构。
- en: 12.2.1\. Ember app structure
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1. Ember 应用程序结构
- en: 'Ember apps use convention instead of configuration. To add a new file, you
    add it in the correct directory type. For example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 应用程序使用约定而不是配置。要添加新文件，你需要在正确的目录类型中添加它。例如：
- en: When making a new component, you add it to the components folder.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建一个新的组件时，你将其添加到 components 文件夹中。
- en: If you need to add a model, you add it in the models directory.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要添加一个模型，你可以在 models 目录中添加它。
- en: '[Figure 12.5](kindle_split_025_split_002.xhtml#ch12fig05) shows the app directory
    for the Ember app. Additional folders and files are in the ember-universal directory,
    but the ones in [figure 12.5](kindle_split_025_split_002.xhtml#ch12fig05) are
    what you need to know about to get started.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12.5](kindle_split_025_split_002.xhtml#ch12fig05) 显示了 Ember 应用的应用程序目录。ember-universal
    目录中还有其他文件夹和文件，但您需要了解的是 [图 12.5](kindle_split_025_split_002.xhtml#ch12fig05) 中的内容，以开始学习。'
- en: Figure 12.5\. The app directory and files that are used in this Ember app
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.5\. Ember 应用程序中使用的应用程序目录和文件
- en: '![](Images/12fig05_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig05_alt.jpg)'
- en: I’ve already set up the main part of the app so you can focus on the isomorphic
    parts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经设置了应用程序的主要部分，这样您就可以专注于同构部分。
- en: Next, we’ll review the routes and components so you understand what you’re working
    with.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾路由和组件，以便您了解您正在处理的内容。
- en: 12.2.2\. Routes in Ember
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2\. Ember 中的路由
- en: First let’s look at the two top-level routes the app has. One is the root, or
    homepage route, and the other is the post detail route (/post/[post.urlSlug]).
    The routes will also be where all the data fetching happens. The following listing
    shows the routes file provided in the repo.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看应用程序拥有的两个顶级路由。一个是根路由或主页路由，另一个是帖子详情路由 (/post/[post.urlSlug])。所有数据获取也将发生在路由上。以下列表显示了存储库中提供的路由文件。
- en: Listing 12.3\. Routes—ember-universal/app/router.js
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 路由—ember-universal/app/router.js
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Import the app config.**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入应用程序配置。**'
- en: '***2* Initialize the router with rootUrl and location type based on config
    (here, these are the same as the defaults set up by ember-cli).**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根据配置（这里与 ember-cli 设置的默认值相同）初始化路由器，包含根 URL 和位置类型。**'
- en: '***3* Add a second route for the Post Detail page—takes name and URL path.**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为帖子详情页面添加第二个路由——包含名称和 URL 路径。**'
- en: In addition to the router, the app needs to provide the index (home) route.
    The following listing shows the code from index.js.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路由器，应用程序还需要提供索引（主页）路由。以下列表显示了 index.js 中的代码。
- en: Listing 12.4\. Index Route (Home)—ember-universal/app/routes/index.js
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4\. 索引路由（主页）—ember-universal/app/routes/index.js
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Import Ember.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Ember。**'
- en: '***2* Extend Route object on Ember.**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 Ember 中扩展路由对象。**'
- en: As long as you follow Ember naming conventions and put the file in the right
    folder, you don’t have to do anything else to get an initial route working. The
    post detail route also looks like this. You can check it out at ember-universal/app/routes/post-detail.js.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您遵循 Ember 命名约定并将文件放在正确的文件夹中，您就不需要做任何事情来使初始路由工作。帖子详情路由也看起来像这样。您可以在 ember-universal/app/routes/post-detail.js
    中查看它。
- en: Next, let’s look at the components that make up this app.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看构成此应用程序的组件。
- en: 12.2.3\. Components
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.3\. 组件
- en: 'Ember components consist of two files: a JavaScript file with a component class
    and a Handlebars template file that provides the view part of the component.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 组件由两个文件组成：一个包含组件类的 JavaScript 文件和一个提供组件视图部分的 Handlebars 模板文件。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Info
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 信息
- en: Handlebars is a JavaScript template language. You can learn more about it at
    [http://handlebarsjs.com](http://handlebarsjs.com).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 是一种 JavaScript 模板语言。您可以在 [http://handlebarsjs.com](http://handlebarsjs.com)
    上了解更多信息。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the blog app, the JavaScript classes don’t have to do much. [Listing 12.5](kindle_split_025_split_002.xhtml#ch12ex05)
    shows what the post controller looks like. The other component classes look just
    like this in their own files (comment-component, header-component, post-list).
    All this code is already provided in the repo.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在博客应用程序中，JavaScript 类不需要做太多。[列表 12.5](kindle_split_025_split_002.xhtml#ch12ex05)
    显示了帖子控制器的外观。其他组件类在其自己的文件（comment-component、header-component、post-list）中看起来也像这样。所有这些代码都已经存储在存储库中。
- en: Listing 12.5\. Post component—ember-universal/app/components/post-component.js
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.5\. 帖子组件—ember-universal/app/components/post-component.js
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Import Ember.**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Ember。**'
- en: '***2* Extend component to make your Post component class.**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 扩展组件以创建您的帖子组件类。**'
- en: 'All the components are already created in the application for you. If you want
    to add your own components, rather than add components by hand you generate them
    with the CLI:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件都已经为您在应用程序中创建好了。如果您想添加自己的组件，而不是手动添加组件，您可以使用 CLI 生成它们：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each component also has its Handlebars template file. The following listing
    shows the Handlebars template file for the post component. You can find all the
    template files for the app inside the /templates directory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都有自己的 Handlebars 模板文件。以下列表显示了帖子组件的 Handlebars 模板文件。您可以在 /templates 目录内找到应用程序的所有模板文件。
- en: Listing 12.6\. Post component Handlebars template—ember-universal/app/templates/components/post-component.hbs
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.6\. 文章组件Handlebars模板—ember-universal/app/templates/components/post-component.hbs
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Places post image in template.**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在模板中放置文章图片。**'
- en: '***2* Places post title in template**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在模板中放置文章标题**'
- en: '***3* Passes body of post to helper function, which truncates text based on
    the limit value (also passed in).**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将文章的正文传递给辅助函数，该函数根据限制值（也传递了）截断文本。**'
- en: The Post component is used on both routes in the application. It’s used on the
    homepage to show the blog snippet and on the Post Detail page in full. The `truncate`
    helper function in the Handlebars template in [listing 12.6](kindle_split_025_split_002.xhtml#ch12ex06)
    makes the component reusable in multiple cases. [Listing 12.7](kindle_split_025_split_002.xhtml#ch12ex07)
    shows the template for the post detail route. Using Handlebars template notation,
    place the Post component on the route. Data is fed to each route via the model,
    so you can access it off the model. You’ll set up the data fetching in the next
    section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文章组件在应用程序的两个路由中使用。它在主页上显示博客片段，在文章详情页上完整显示。在[列表12.6](kindle_split_025_split_002.xhtml#ch12ex06)中的Handlebars模板中的`truncate`辅助函数使得组件可以在多个情况下重复使用。[列表12.7](kindle_split_025_split_002.xhtml#ch12ex07)显示了文章详情路由的模板。使用Handlebars模板语法，在路由上放置文章组件。数据通过模型传递给每个路由，因此您可以从模型中访问它。您将在下一节中设置数据获取。
- en: Listing 12.7\. Post detail route template—ember-universal/app/templates/post-detail.hbs
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.7\. 文章详情路由模板—ember-universal/app/templates/post-detail.hbs
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Pass post data into the component**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将文章数据传递到组件中**'
- en: '***2* Render a dividing header for post comments.**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为文章评论渲染一个分隔标题。**'
- en: '***3* Use Handlebars helper each to loop over every comment (comments such
    as post data are stored on the model).**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用Handlebars辅助函数each遍历每个评论（例如，文章数据存储在模型上）。**'
- en: '***4* Render a comment component for each comment returned on the model.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为模型上返回的每个评论渲染一个评论组件。**'
- en: '***5* Close the each helper.**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 关闭each辅助函数。**'
- en: 'All the routes are loaded into the root template: application. This template
    renders the header and a placeholder for where the routes will be dynamically
    rendered. The following listing shows the template file for application.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有路由都加载到根模板：application。此模板渲染标题和动态渲染路由的占位符。以下列表显示了应用程序的模板文件。
- en: Listing 12.8\. Application template—ember-universal/app/templates/application.hbs
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.8\. 应用程序模板—ember-universal/app/templates/application.hbs
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Place header component into the root template, this will render on every
    page.**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将标题组件放入根模板中，这将显示在每一页上。**'
- en: '***2* Special placeholder router knows to pass components down to children,
    handled automatically.**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 特殊的占位符路由知道将组件传递给子组件，自动处理。**'
- en: By now, you should have a good understanding of the blog app’s code. Next, we’ll
    make the Ember app isomorphic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该对博客应用的代码有了很好的理解。接下来，我们将使Ember应用同构。
- en: 12.2.4\. Implement isomorphic Ember
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.4\. 实现同构Ember
- en: Now let’s set up the two parts of this app that will make it isomorphic. [Figure
    12.6](kindle_split_025_split_002.xhtml#ch12fig06) shows what you should see at
    the end of this section when JavaScript is disabled in the browser.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置这个应用的两个部分，这将使其成为同构的。[图12.6](kindle_split_025_split_002.xhtml#ch12fig06)显示了当浏览器中禁用JavaScript时，本节结束时您应该看到的内容。
- en: Figure 12.6\. The server-rendered app after you’ve added all of the isomorphic
    pieces
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.6\. 添加所有同构组件后的服务器渲染应用
- en: '![](Images/12fig06_alt.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig06_alt.jpg)'
- en: 'Step 1: Ember FastBoot'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第1步：Ember FastBoot
- en: 'First, install the Ember CLI FastBoot library. Run the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装Ember CLI FastBoot库。运行以下命令：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now if you run the server and disable JavaScript in the browser, you’ll see
    the header rendered. To disable JavaScript, open the Options menu in the upper-right
    corner of the Chrome DevTools window and click Settings. Under Debugger, select
    the Disable JavaScript check box. [Figure 12.7](kindle_split_025_split_002.xhtml#ch12fig07)
    shows this in action.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您运行服务器并在浏览器中禁用JavaScript，您将看到渲染的标题。要禁用JavaScript，请打开Chrome DevTools窗口右上角的选项菜单并点击设置。在调试器下，选择禁用JavaScript复选框。[图12.7](kindle_split_025_split_002.xhtml#ch12fig07)显示了这一操作。
- en: Figure 12.7\. The header now renders on the server.
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.7\. 现在标题已在服务器上渲染。
- en: '![](Images/12fig07_alt.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig07_alt.jpg)'
- en: Next we’ll go over how to fetch data in the app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何在应用中获取数据。
- en: 'Step 2: Isomorphic data fetching'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2步：同构数据获取
- en: 'To ensure that you can fetch the data for the app on the server and in the
    browser, you’ll need to use an implementation of fetch that works in both environments.
    Ember has a library you can install, called ember-fetch. Go ahead and install
    it now:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你可以在服务器和浏览器中获取应用的数据，你需要使用在两个环境中都工作的 fetch 实现。Ember 有一个你可以安装的库，称为 ember-fetch。现在就安装它吧：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After this is installed, you can add a fetch call to the main route. The following
    listing shows the code to add to routes/index.js.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以在主路由中添加一个 fetch 调用。以下列表显示了要添加到 routes/index.js 中的代码。
- en: Listing 12.9\. Index route (home)—ember-universal/app/routes/index.js
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. 索引路由（主页）—ember-universal/app/routes/index.js
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Include Ajax module from ember-fetch.**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 ember-fetch 的 Ajax 模块。**'
- en: '***2* Fetch posts from posts endpoint.**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 posts 端点获取帖子。**'
- en: '***3* Return response as is—JSON response in an array (view expects data in
    this format).**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 直接返回响应——数组中的 JSON 响应（视图期望数据以这种格式）。**'
- en: Navigate to the homepage and you’ll see the list of blog posts. To also get
    the data working for the Post Detail page, add the code in the following listing
    to the post detail route.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到主页，你会看到博客文章的列表。为了同时让帖子详情页的数据工作，将以下列表中的代码添加到帖子详情路由中。
- en: Listing 12.10\. Post detail route—ember-universal/app/routes/post-detail.js
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10\. 帖子详情路由—ember-universal/app/routes/post-detail.js
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* If route will have params, these get passed into the model function.**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果路由将有参数，这些参数将被传递到模型函数中。**'
- en: '***2* Call individual post endpoint with ID from URL (URL slug).**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 URL（URL slug）中的 ID 调用单个帖子端点。**'
- en: '***3* After post has returned, get associated comments based on ID.**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 帖子返回后，根据 ID 获取相关评论。**'
- en: '***4* Send both post and array of comments to the view.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将帖子和评论数组发送到视图。**'
- en: That’s all there is to getting the Ember app converted to an isomorphic app!
    (If you’d like to see the complete code, it’s in the ember-complete branch.) [Figure
    12.8](kindle_split_025_split_002.xhtml#ch12fig08) shows what happened in the DOM
    during the Ember isomorphic render.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Ember 应用转换为同构应用就这么简单！（如果你想看到完整的代码，它位于 ember-complete 分支。）[图 12.8](kindle_split_025_split_002.xhtml#ch12fig08)
    展示了 Ember 同构渲染期间 DOM 中发生的情况。
- en: Figure 12.8\. Ember replaces the DOM completely, but it’s imperceptible to the
    user.
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.8\. Ember 完全替换了 DOM，但对用户来说却不可察觉。
- en: '![](Images/12fig08_alt.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig08_alt.jpg)'
- en: Finally, let’s review the benefits and costs associated with using Ember for
    isomorphic rendering.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回顾一下使用 Ember 进行同构渲染相关的优势和成本。
- en: 12.2.5\. Pros and cons of isomorphic Ember
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.5\. 同构 Ember 的优缺点
- en: As you’ve seen in this section, setting up an Ember app to server render is
    almost as simple as setting up an Ember app. That means getting up and running
    with isomorphic Ember is relatively fast. An added bonus is that the Ember CLI
    lets you autogenerate the basics of the app. The following list evaluates the
    pros and cons of using Ember to build your isomorphic app.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中看到的，设置 Ember 应用进行服务器渲染几乎和设置 Ember 应用一样简单。这意味着使用同构 Ember 启动和运行相对较快。一个额外的优点是
    Ember CLI 允许你自动生成应用的基本部分。以下列表评估了使用 Ember 构建同构应用的优势和劣势。
- en: '**Pros**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**'
- en: It’s easy to set up isomorphic parts of the app. Install two extra libraries
    (ember-cli-fastboot and ember-fetch).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置应用的同构部分非常简单。安装两个额外的库（ember-cli-fastboot 和 ember-fetch）。
- en: The Ember CLI (along with FastBoot) makes the time between installation and
    a working app extremely short.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember CLI（连同 FastBoot）使得从安装到运行应用之间的时间非常短。
- en: Convention over configuration makes it easy to wire things together and can
    be beneficial for teams of all sizes.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约定优于配置使得连接事物变得容易，并且对各个规模大小的团队都有益。
- en: Ember FastBoot already supports the majority of isomorphic use cases, including
    cookies in different environments and dynamic metatags based on routes. The overall
    documentation and user guide is good ([https://ember-fastboot.com/docs/user-guide](https://ember-fastboot.com/docs/user-guide)).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember FastBoot 已经支持了大多数同构用例，包括不同环境中的 cookies 和基于路由的动态元标签。整体文档和用户指南做得很好（[https://ember-fastboot.com/docs/user-guide](https://ember-fastboot.com/docs/user-guide)）。
- en: '**Cons**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**'
- en: Replacing the DOM rather than calculating that a DOM update isn’t needed on
    the first render adds additional cost to the initial render.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在首次渲染时替换 DOM 而不是计算是否需要 DOM 更新，这会给初始渲染增加额外的成本。
- en: Ember’s focus on convention isn’t for everyone and may not fit your needs.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember 对约定的关注并不适合每个人，可能不符合你的需求。
- en: It takes time to master Ember. Many things can appear magical for developers
    who are new to the framework.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Ember 需要花费时间。对于刚接触这个框架的开发者来说，许多事情都可能显得神奇。
- en: The current best practice around FastBoot doesn’t have an Ember Data integration,
    which means you lose out on one of the powerful features of the Ember framework.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前关于 FastBoot 的最佳实践没有 Ember Data 集成，这意味着你将失去 Ember 框架的一个强大功能。
- en: 12.3\. Universal Angular
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 通用角动量
- en: Angular has gone through quite an evolution over the last few years. Although
    most of the core concepts from Angular.js (Angular 1) have survived, it has evolved
    to incorporate concepts that have become popular in other libraries and frameworks.
    Luckily, this includes support for server-side rendering. The Angular community
    has decided to label their implementation as *universal* instead of isomorphic.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，Angular 经历了相当大的演变。尽管 Angular.js（Angular 1）的大部分核心概念都得以保留，但它已经演变，吸收了在其他库和框架中变得流行的概念。幸运的是，这包括对服务器端渲染的支持。Angular
    社区决定将他们的实现称为 *通用* 而不是同构。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Officially, Angular now refers to Angular 1 as *Angular.js* and the newer iterations
    as *Angular*. This allows for major version updates to be smoother and continuous
    without your having to remember whether you should be using Angular 2 or Angular
    4\. The code in the repo uses Angular version 4.0.0.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，Angular 现在将 Angular 1 称为 *Angular.js*，将更新的版本称为 *Angular*。这使得主要版本更新更加平滑和连续，你无需记住是否应该使用
    Angular 2 或 Angular 4。仓库中的代码使用 Angular 版本 4.0.0。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, I’m going to walk you through setting up a universal Angular
    app. If you’re new to Angular, I highly recommend getting up to speed on Angular
    basics first. The Angular documentation site has a high-quality tutorial at [https://angular.io/tutorial](https://angular.io/tutorial).
    If you want to go in depth with Angular, I recommend checking out *Angular in
    Action* by Jeremy Wilken (Manning, 2018). Finally, if you want to learn more about
    the Angular CLI tool, you can check out its GitHub repo at [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将带你通过设置通用 Angular 应用程序。如果你是 Angular 新手，我强烈建议你首先熟悉 Angular 基础知识。Angular
    文档网站有一个高质量的教程，网址为 [https://angular.io/tutorial](https://angular.io/tutorial)。如果你想深入了解
    Angular，我推荐阅读 Jeremy Wilken（Manning，2018）的《Angular in Action》。最后，如果你想了解更多关于 Angular
    CLI 工具的信息，你可以查看其 GitHub 仓库 [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Best of friends: TypeScript and Angular**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳拍档：TypeScript 和 Angular**'
- en: Angular is written with TypeScript, a superset of JavaScript that introduces
    the ability to enforce typing information. It can be used with any version of
    JavaScript, so you can use it with anything ES3 (that’s not a typo) or newer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用 TypeScript 编写，它是 JavaScript 的超集，引入了强制类型信息的能力。它可以与任何版本的 JavaScript
    一起使用，因此你可以用它与任何 ES3（这不是一个打字错误）或更新的版本一起使用。
- en: 'The basic value of TypeScript is to enforce that variables are restricted to
    a specific type of value, such as: a variable may hold only a number or an array
    of strings. JavaScript has types (don’t let anyone tell you otherwise!), but variables
    aren’t typed, so you can store any type of value on any variable. This also gave
    birth to the many types of comparison operators, such as `==` for loose equality
    or `===` for strict equality.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的基本价值在于强制变量限制在特定类型的值，例如：一个变量可能只能持有数字或字符串数组。JavaScript 有类型（不要让任何人告诉你不是这样！），但变量没有类型，所以你可以在任何变量上存储任何类型的值。这也催生了多种比较运算符，如
    `==` 用于松散相等或 `===` 用于严格相等。
- en: 'TypeScript can help catch many simple syntax errors before they affect your
    application. Sometimes you can write valid JavaScript, but the real world shows
    that valid syntax doesn’t always mean valid behavior. Take this example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可以帮助在它们影响你的应用程序之前捕获许多简单的语法错误。有时你可以编写有效的 JavaScript，但现实世界表明，有效的语法并不总是意味着有效的行为。以下是一个例子：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This snippet shows a simple tip calculator example: you take the value from
    an input element and add it to the bill to get the total payment amount. But the
    problem here is that the `tip` variable is a string (because it’s a text input).
    Adding a number and a string together is perhaps one of the most common pitfalls
    for new JavaScript developers, but it still can happen to anyone! If you used
    TypeScript to enforce types, this code could be written to alert about this common
    error:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了简单的小费计算器示例：你从输入元素中获取值，并将其添加到账单中，以获取总付款金额。但这里的问题是`tip`变量是一个字符串（因为它是一个文本输入）。将数字和字符串相加可能是新JavaScript开发者最常见的陷阱之一，但这种情况仍然可能发生在任何人身上！如果你使用TypeScript来强制类型检查，这段代码可以编写为在出现这种常见错误时发出警告：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here you’re using TypeScript to declare that all these variables must each hold
    a number value by using `number`. This is a simple syntax that sits inside JavaScript
    to tell TypeScript the type of value the variable should hold. The tip value will
    error because it’s being assigned a string, and then the total value will error
    because it attempts to add a number and string type, which results in a string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用TypeScript声明所有这些变量都必须各自持有数字值，通过使用`number`。这是一个简单的语法，位于JavaScript内部，用于告诉TypeScript变量应该持有的值类型。小费值将出错，因为它被分配了一个字符串，然后总金额将出错，因为它尝试将数字和字符串类型相加，这导致了一个字符串。
- en: This may seem like an obvious error to a seasoned JavaScript developer, but
    how often do you have new developers work on your code base? How often do you
    refactor your code? Can you still ensure that your application is passing around
    the same value types as you continue to maintain the application? Without TypeScript,
    you’re responsible for doing a strict comparator check of every value before it’s
    used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经验丰富的JavaScript开发者来说，这看起来可能是一个明显的错误，但你有多少次让新开发者参与你的代码库的开发？你有多少次重构你的代码？你能确保在继续维护应用程序时，你的应用程序仍在传递相同的值类型吗？没有TypeScript，你在使用每个值之前都必须进行严格的比较检查。
- en: 'Many developers wonder why they should bother learning and using TypeScript.
    Here are the primary reasons to use TypeScript, in my humble opinion:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者想知道为什么他们应该费心学习和使用TypeScript。以下是我认为使用TypeScript的主要理由：
- en: '***It adds clarity to your code*—** Variables that have types are easier to
    understand, because other developers (or yourself in six months) don’t have to
    think very hard about what the variable should be.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它使你的代码更清晰***—** 具有类型的变量更容易理解，因为其他开发者（或六个月后的你自己）不需要非常认真地思考变量应该是什么。'
- en: '***It enables a smarter editor*—** When you use TypeScript with a supported
    editor, you’ll get automatic IntelliSense support for your code. As you write,
    the editor can suggest known variables or functions and tell you the type of value
    it expects.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它使编辑器更智能***—** 当你在支持TypeScript的编辑器中使用TypeScript时，你的代码将获得自动的IntelliSense支持。随着你编写代码，编辑器可以建议已知的变量或函数，并告诉你它期望的值类型。'
- en: '***It catches errors before you run code*—** TypeScript will catch syntax errors
    before you run the code in the browser, helping to reduce the feedback loop when
    you write invalid code.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它在运行代码之前捕获错误***—** TypeScript会在你在浏览器中运行代码之前捕获语法错误，这有助于减少你编写无效代码时的反馈循环。'
- en: '***It’s entirely optional*—** You can use types when you want and optionally
    leave it out where it doesn’t matter.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它是完全可选的***—** 当你需要时可以使用类型，并在不需要的地方选择性地省略它。'
- en: Hopefully you’re sold on the value of TypeScript. If not, don’t worry—I won’t
    judge. But this book will use it in examples because it’ll help provide more clarity
    and will also help further demonstrate the power of TypeScript. I’ll try to provide
    additional insight into TypeScript features and functionality as we use features
    in the examples, but you can always learn all there is to know at [www.typescriptlang.org/docs/tutorial.html](http://www.typescriptlang.org/docs/tutorial.html).
    Even if you choose not to use TypeScript for type enforcement in your application,
    you can use TypeScript to compile your application. Because the Angular CLI already
    uses TypeScript internally, you may be using it without even knowing. If you decide
    to build your own build tooling, TypeScript is still a worthwhile compiler option.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经认可了TypeScript的价值。如果不认可，请不要担心——我不会评判。但本书将在示例中使用它，因为它将有助于提供更多的清晰度，并进一步展示TypeScript的强大功能。随着我们在示例中使用功能，我将尝试提供对TypeScript功能和功能的额外见解。但您始终可以在[www.typescriptlang.org/docs/tutorial.html](http://www.typescriptlang.org/docs/tutorial.html)上学习所有需要知道的内容。即使您选择不使用TypeScript在您的应用程序中进行类型检查，您也可以使用TypeScript来编译您的应用程序。因为Angular
    CLI已经内部使用TypeScript，您可能在使用它时甚至都不知道。如果您决定构建自己的构建工具，TypeScript仍然是一个值得考虑的编译器选项。
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 12.9](kindle_split_025_split_003.xhtml#ch12fig09) shows the isomorphic
    application diagram you’ve seen in previous chapters. I’ve called out all the
    pieces you must implement yourself when using Angular to build an isomorphic app.
    Angular handles some parts of the flow for you. For example, the data fetching
    will work out of the box if you handle your server initialization correctly, but
    you still need to configure a browser entry point and a server entry point.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.9](kindle_split_025_split_003.xhtml#ch12fig09)显示了您在之前章节中看到的同构应用程序图。我已经指出了当使用Angular构建同构应用程序时必须自己实现的各个部分。Angular为您处理流程的一些部分。例如，如果您正确处理服务器初始化，数据获取将自动工作，但您仍然需要配置浏览器入口点和服务器入口点。'
- en: Figure 12.9\. The universal flow in Angular
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.9。Angular中的通用流程
- en: '![](Images/12fig09_alt.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig09_alt.jpg)'
- en: '12.3.1\. Building blocks: components'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1. 构建块：组件
- en: I’ve already set up most of the app structure for you, so you can focus on learning
    how to enable Angular to be universal. In this section, I’ll briefly walk you
    through the structure of this code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为您设置了应用程序结构的大部分，因此您可以专注于学习如何使Angular成为通用。在本节中，我将简要地为您介绍此代码的结构。
- en: The code for this section can be found in the branch angular-starter, and you
    can switch to it by running `git checkout angular-starter`. You also need to switch
    to the angular2 folder and run `npm install`. Note that at this point, this is
    a single-page application (SPA). You can run it by executing the `npm start` command
    in your terminal. The app will run on http://localhost:4100.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码可以在angular-starter分支中找到，您可以通过运行`git checkout angular-starter`来切换到它。您还需要切换到angular2文件夹并运行`npm
    install`。请注意，此时这是一个单页应用程序（SPA）。您可以通过在终端中执行`npm start`命令来运行它。应用程序将在http://localhost:4100上运行。
- en: First let’s review the structure of the files already in the app. [Figure 12.10](kindle_split_025_split_003.xhtml#ch12fig10)
    shows the main folders and files.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下app中已有的文件结构。[图12.10](kindle_split_025_split_003.xhtml#ch12fig10)显示了主要文件夹和文件。
- en: Figure 12.10\. The app folder and files that make up the SPA. It also includes
    the helper modules for universal state transfer and data fetching.
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.10。构成SPA的应用文件夹和文件。它还包括用于通用状态传输和数据获取的辅助模块。
- en: '![](Images/12fig10_alt.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig10_alt.jpg)'
- en: 'Each component is made up of three files: the TypeScript file with the component
    definition, a component CSS file, and the HTML file that provides the component
    template. The app component has app.component.ts, app.component.css, and app.component.html.
    All the components in the Angular app mirror the components in the Ember app but
    are implanted with Angular patterns instead.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件由三个文件组成：包含组件定义的TypeScript文件、组件CSS文件以及提供组件模板的HTML文件。应用程序组件包含app.component.ts、app.component.css和app.component.html。Angular应用程序中的所有组件都反映了Ember应用程序中的组件，但它们被植入Angular模式。
- en: 'Currently, the app flow works like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，应用程序流程是这样的：
- en: '**1**.  The user navigates to the page, and index.html loads the webpack-bundled
    files. This executes the code from the app entry point (main.ts), which bootstraps
    the application.'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 用户导航到页面，index.html加载webpack捆绑的文件。这执行了从应用程序入口点（main.ts）的代码，该代码启动应用程序。'
- en: '**2**.  This app has one module (AppModule) that’s loaded when the app bootstraps.'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  此应用有一个模块（AppModule），当应用启动时加载。'
- en: '**3**.  AppModule includes all the component dependencies. These are now loaded,
    and the current route is rendered.'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  AppModule 包含所有组件依赖项。这些依赖项现在已加载，并且当前路由正在渲染。'
- en: Next you want to add the server-rendering libraries and logic.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要添加服务器渲染库和逻辑。
- en: '12.3.2\. Converting to universal: dependencies'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 转换为通用：依赖项
- en: 'To get server-side rendering working, first you need to install dependencies.
    The first thing you need to add are libraries:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要使服务器端渲染工作，首先你需要安装依赖项。首先需要添加的是库：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To run universal Angular, you also need to provide a state transfer module,
    as this isn’t provided for you. You also need to provide an HTTP implementation
    that’s compatible with this state transfer module. Some packages can help with
    this, but the current best implementation that I’ve found comes from a universal
    example repo: [https://github.com/FrozenPandaz/ng-universal-demo](https://github.com/FrozenPandaz/ng-universal-demo).
    The code can be found in the angular2/src/modules folder, as it’s already included
    in the repo.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行通用Angular，你还需要提供一个状态传输模块，因为这个模块没有为你提供。你还需要提供一个与这个状态传输模块兼容的HTTP实现。一些包可以帮助你完成这项工作，但当前我发现最好的实现来自一个通用示例仓库：[https://github.com/FrozenPandaz/ng-universal-demo](https://github.com/FrozenPandaz/ng-universal-demo)。代码可以在angular2/src/modules文件夹中找到，因为它已经包含在仓库中。
- en: 'The code is made up of two modules: transfer-state and transfer-http. Transfer
    State is a module that handles serializing and deserializing the JSON. Transfer
    HTTP is a module that has logic to look up the app state from the Transfer State
    module before trying to fetch the requested data. It automatically uses keys extrapolated
    from your requests, so you use the Transfer HTTP module just like the regular
    Angular HTTP module.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 代码由两个模块组成：transfer-state和transfer-http。Transfer State是一个处理序列化和反序列化JSON的模块。Transfer
    HTTP是一个在尝试获取请求的数据之前从Transfer State模块中查找应用状态的模块。它自动使用从你的请求中推断出的键，所以你可以像使用常规Angular
    HTTP模块一样使用Transfer HTTP模块。
- en: '12.3.3\. Converting to universal: server and browser code'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3\. 转换为通用：服务器和浏览器代码
- en: The next step in converting the app to universal is to create two entry points
    instead of the one currently implemented with AppModule. First, you should create
    the browser entry point. The following listing shows the code to put in the browser.module.ts
    file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用转换为通用应用的下一步是创建两个入口点，而不是当前通过AppModule实现的单个入口点。首先，你应该创建浏览器入口点。以下列表显示了需要在browser.module.ts文件中放入的代码。
- en: Listing 12.11\. Browser module—angular2/src/browser.module.ts
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 浏览器模块—angular2/src/browser.module.ts
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Import Angular dependencies.**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入Angular依赖项。**'
- en: '***2* Import app component, the root component that gets passed into bootstrap
    array.**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入app组件，这是传递给bootstrap数组的根组件。**'
- en: '***3* Import AppModule so dependencies get set up properly for dependency injection.**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入AppModule以确保依赖项正确设置以进行依赖注入。**'
- en: '***4* Import browser transfer state helper module.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导入browser transfer state helper模块。**'
- en: '***5* Initialize browserModule with server transition.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用服务器转换初始化browserModule。**'
- en: When you initialize the `browserModule`, make sure the `appId` property matches
    what’s in the server module (you’ll add this in [listing 12.13](kindle_split_025_split_003.xhtml#ch12ex13)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化`browserModule`时，确保`appId`属性与服务器模块中的内容匹配（你将在[列表 12.13](kindle_split_025_split_003.xhtml#ch12ex13)中添加此内容）。
- en: Now you need to load the browser entry in main.ts, which bootstraps the application.
    This is just a change of the module that’s currently imported (AppModule). The
    following listing shows the code to replace.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要在main.ts中加载浏览器入口，这将启动应用。这只是一个更改当前导入的模块（AppModule）。以下列表显示了需要替换的代码。
- en: Listing 12.12\. Update the main.ts file—angular2/src/main.ts
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. 更新main.ts文件—angular2/src/main.ts
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Import browser module instead of app.module.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入browser模块而不是app.module。**'
- en: '***2* Use AppBrowserModule to bootstrap app.**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用AppBrowserModule启动应用。**'
- en: Next, you need to create a server entry module. This will be similar to your
    browser module but will set up injecting the server state. The following listing
    shows what to add with an app.server.module.ts file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个服务器入口模块。这将与你的浏览器模块类似，但会设置注入服务器状态。以下列表显示了使用app.server.module.ts文件需要添加的内容。
- en: Listing 12.13\. Server entry module—angular2/src/app.server.module.ts
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. 服务器入口模块—angular2/src/app.server.module.ts
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Import Angular and supporting dependencies.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入Angular和相关依赖项。**'
- en: '***2* Include ServerTransferState-Module, which implements the server version
    of app state.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含 ServerTransferState-Module，它实现了应用程序状态的服务器版本。**'
- en: '***3* Include TransferState module so you can inject the state into it after
    the app is bootstrapped.**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含 TransferState 模块，这样你就可以在应用程序启动后将其注入到其中。**'
- en: '***4* Server module needs to import the root AppModule and component.**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 服务器模块需要导入根 AppModule 和组件。**'
- en: '***5* Set up server transition appId to match the one you added in browser
    module file.**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 设置服务器过渡 appId 以匹配你在浏览器模块文件中添加的 appId。**'
- en: Finally, you need to add a server configuration file that will handle incoming
    routes and then load Angular and render it. The following listing shows the code
    you need to add to the main.server.ts file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要添加一个服务器配置文件，该文件将处理传入的路由，然后加载 Angular 并渲染它。以下列表显示了需要添加到 main.server.ts
    文件中的代码。
- en: Listing 12.14\. Node.js server—main.server.ts
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.14\. Node.js 服务器—main.server.ts
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Module factory is passed to the render function so Angular can properly
    handle routes.**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 模块工厂传递给渲染函数，以便 Angular 可以正确处理路由。**'
- en: '***2* Set up HTML rendering engine.**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置 HTML 渲染引擎。**'
- en: '***3* Make sure view engine points at HTML.**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 确保视图引擎指向 HTML。**'
- en: '***4* When route is received, call res.render.**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当接收到路由时，调用 res.render。**'
- en: 'At this point, you can successfully run the code. You use a different server
    command than for the SPA version. This command builds and starts both the server
    and the browser code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以成功运行代码。你使用与 SPA 版本不同的服务器命令。此命令构建并启动服务器和浏览器代码：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At this point, the app is set up but doesn’t have data. The server will load,
    and you’ll see the app header but no content. The next section covers data fetching,
    which is needed to load the full content.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序已设置但尚未有数据。服务器将加载，你将看到应用程序标题但没有内容。下一节将介绍数据获取，这是加载完整内容所需的。
- en: 12.3.4\. Fetching data in universal
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.4\. 在通用模式下获取数据
- en: To successfully fetch data and pass it down to the browser, you also need to
    use the Transfer HTTP library in the services that fetch the data. The following
    listing shows how to import the module into the App module.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功获取数据并将其传递到浏览器，你还需要在获取数据的服务的中使用 Transfer HTTP 库。以下列表显示了如何将模块导入到 AppModule
    中。
- en: Listing 12.15\. App module with Transfer HTTP—angular2/src/app/app.module.ts
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.15\. 带有 Transfer HTTP 的 AppModule—angular2/src/app/app.module.ts
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Import module and add it to Angular imports—make sure to take out old
    HTTP module and Browser module.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入模块并将其添加到 Angular 导入中——确保移除旧的 HTTP 模块和 Browser 模块。**'
- en: Now that you’ve included the module into the App module, you can import the
    TransferHttp library into your services. The following listing shows how to update
    the Posts service.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将模块包含到 AppModule 中，你可以在服务中导入 TransferHttp 库。以下列表显示了如何更新帖子服务。
- en: Listing 12.16\. Update Posts service—angular2/src/app/services/posts.service.ts
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.16\. 更新帖子服务—angular2/src/app/services/posts.service.ts
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Change Http import to TransferHttp import, then use in constructor instead
    of Http.**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Http 导入更改为 TransferHttp 导入，然后在构造函数中使用它而不是 Http。**'
- en: You also need to make this same update in the comments service. The following
    listing shows what to change in the comments service file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在评论服务中进行相同的更新。以下列表显示了在评论服务文件中需要更改的内容。
- en: Listing 12.17\. Update Comments service—angular2/src/app/services/comments.service.ts
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.17\. 更新评论服务—angular2/src/app/services/comments.service.ts
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Change Http import to TransferHttp import, then use in constructor instead
    of Http.**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Http 导入更改为 TransferHttp 导入，然后在构造函数中使用它而不是 Http。**'
- en: 'At this point, the full universal flow is working. You can go through the same
    exercise you did with Ember: disable JavaScript in the browser via Chrome DevTools
    and observe the HTML that’s loaded. You can also get the full code in the angular-complete
    branch.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，完整的通用流程正在运行。你可以通过相同的练习进行 Ember：通过 Chrome DevTools 禁用浏览器中的 JavaScript 并观察加载的
    HTML。你还可以在 angular-complete 分支中获取完整的代码。
- en: 12.3.5\. Pros and cons of universal Angular
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.5\. 通用 Angular 的优缺点
- en: 'Using universal Angular has the following pros and cons:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用 Angular 有以下优缺点：
- en: '**Pros**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**'
- en: Uses dependency injection, which allows you to swap out dependencies as needed
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖注入，这允许你根据需要交换依赖项
- en: Access to Angular CLI, which lets you generate components
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Angular CLI，它允许你生成组件
- en: Less magic—you have control over the server and the data hydration
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更少的魔法——你可以控制服务器和数据活化
- en: '**Cons**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**'
- en: Requires implementation of state transfer logic
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要实现状态转移逻辑
- en: Requires setting up your own server
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要设置自己的服务器
- en: Requires setting up your own browser and server entry points
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要设置自己的浏览器和服务器入口点
- en: '12.4\. Next.js: React isomorphic framework'
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4\. Next.js：React同构框架
- en: If you’re looking for an all-in-one solution that uses React, Next.js is a strong
    option. Isomorphic by default, Next.js uses a convention-driven approach to building
    a React app. Even if you decide not to use Next.js in production, you may find
    it a good tool for building isomorphic prototypes or proofs of concept (*pocs*).
    It could aid you in selling the idea of isomorphic to your team or boss.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找一个使用React的全栈式解决方案，Next.js是一个强大的选择。默认情况下，Next.js使用一种约定驱动的构建React应用的方法。即使您决定在生产环境中不使用Next.js，您也可能发现它是一个构建同构原型或概念验证（*pocs*）的好工具。它可以帮助您向团队或老板推销同构的想法。
- en: 'To run the Next.js example, check out the master branch (`git checkout master`).
    Change into the nextjs directory, install the Node.js packages, and then run the
    webpack dev server:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Next.js示例，查看主分支（`git checkout master`）。切换到nextjs目录，安装Node.js包，然后运行webpack开发服务器：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Figure 12.11](kindle_split_025_split_004.xhtml#ch12fig11) walks through the
    isomorphic flow as implemented by Next.js. Next.js is server rendered by default,
    so you don’t have to configure anything!'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.11](kindle_split_025_split_004.xhtml#ch12fig11)展示了Next.js实现的同构流程。Next.js默认是服务器渲染的，所以您不需要进行任何配置！'
- en: Figure 12.11\. The isomorphic flow with Next.js
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.11\. Next.js的同构流程
- en: '![](Images/12fig11_alt.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig11_alt.jpg)'
- en: Now let’s walk through the Next.js app. We’ll review the parts that make it
    isomorphic out of the box.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来浏览Next.js应用。我们将回顾使其开箱即用同构的部分。
- en: 12.4.1\. Next.js structure
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1\. Next.js结构
- en: Next.js uses an opinionated React implementation that comes with many standard
    features out of the box (code splitting, built-in router, server rendering, Webpack
    Dev Server, and more). Next.js also provides a set of scripts for building and
    serving your application in production.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js使用了一种有偏见的React实现，它自带了许多标准功能（代码拆分、内置路由、服务器渲染、Webpack开发服务器等）。Next.js还提供了一套用于在生产环境中构建和提供应用的脚本。
- en: Next.js projects are made up of components and pages. *Pages* are container
    components that fetch data and compose child components. You could easily add
    components such as Redux. One major difference between standard React apps and
    Next.js is that in Next.js they’ve implemented their own router. [Figure 12.12](kindle_split_025_split_004.xhtml#ch12fig12)
    shows the folder structure of this simple application.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js项目由组件和页面组成。*页面*是获取数据和组合子组件的容器组件。您可以轻松添加如Redux之类的组件。标准React应用和Next.js之间的一大区别是，在Next.js中，他们实现了自己的路由器。[图12.12](kindle_split_025_split_004.xhtml#ch12fig12)显示了此简单应用的文件夹结构。
- en: Figure 12.12\. The folders and files that make up a basic Next.js app
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.12\. 构成基本Next.js应用的文件夹和文件
- en: '![](Images/12fig12.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig12.jpg)'
- en: Notice that to add a route to the app, you create a new React component in the
    pages directory. Whatever the name of the file is will become the route. There’s
    also a post detail route in this app that uses a query parameter to indicate the
    blog post URL slug.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了向应用添加路由，您需要在pages目录中创建一个新的React组件。文件名将成为路由。此应用中还有一个使用查询参数来指示博客文章URL别名的详细页面路由。
- en: Next.js doesn’t support dynamic routes out of the box. To add dynamic routes,
    you have to add your own server file. That’s straightforward but does require
    extra work. I’m not going to demonstrate this here, but you can find the docs
    for it at [https://github.com/zeit/next.js/#custom-server-and-routing](https://github.com/zeit/next.js/#custom-server-and-routing).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js默认不支持动态路由。要添加动态路由，您必须添加自己的服务器文件。这很简单，但确实需要额外的工作。这里我不会演示这个，但您可以在[https://github.com/zeit/next.js/#custom-server-and-routing](https://github.com/zeit/next.js/#custom-server-and-routing)找到相关文档。
- en: 12.4.2\. Next.js initial props
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2\. Next.js初始属性
- en: For the most part, Next.js is a standard React app, but it provides an asynchronous
    helper called `getInitialProps` that will fetch the component’s data for you.
    The great thing about this method is that the Next.js framework automatically
    takes care of prefetching on the server, knows to not run it again on the browser,
    and will run it for routes that are navigated to in the single-application flow.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，Next.js是一个标准的React应用，但它提供了一个异步助手`getInitialProps`，它会为您获取组件的数据。这个方法的优点是Next.js框架会自动在服务器上处理预取，知道在浏览器上不会再次运行它，并且会在单应用流程中导航到的路由上运行它。
- en: The following listing shows the `getInitialProps` in the index route of the
    app. The Next.js app is entirely built out for you—you don’t need to add this
    code.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了应用程序索引路由中的`getInitialProps`。Next.js应用程序完全为你构建——你不需要添加此代码。
- en: Listing 12.18\. Index route data fetching—nextjs/pages/index.js
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.18\. 索引路由数据获取—nextjs/pages/index.js
- en: '[PRE27]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Define function as async function—Next.js Babel presets are already configured
    to use ES7 features.**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将函数定义为异步函数——Next.js Babel预设已经配置为使用ES7功能。**'
- en: '***2* Add await function to fetch list of posts.**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加等待函数以获取帖子列表。**'
- en: '***3* Add await function to get JSON response.**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加等待函数以获取JSON响应。**'
- en: '***4* If there’s an error, log it—async await doesn’t support promise error
    catching, so use a try/catch block.**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果有错误，记录它——async await不支持promise错误捕获，因此使用try/catch块。**'
- en: '***5* Return posts results.**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回帖子结果。**'
- en: 12.4.3\. Pros and cons of Next.js
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3\. Next.js的优缺点
- en: Overall, Next.js provides a great solution if you want to try something quickly
    or if you have a simple app with just a few pages. For complex apps with dynamic
    routing, Next.js requires more time investment to get up and running.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，如果你想要快速尝试或有一个只有几个页面的简单应用程序，Next.js提供了一个很好的解决方案。对于具有动态路由的复杂应用程序，Next.js需要更多的时间投资才能启动。
- en: '**Pros**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**'
- en: Works out of the box as long as you don’t need dynamic routes.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不需要动态路由，则开箱即用。
- en: Provides all dev build scripts and support for production builds.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供所有开发构建脚本和对生产构建的支持。
- en: Convention-based routing system.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于约定的路由系统。
- en: Isomorphic data-fetching implementation supplied for you. You just add your
    code for fetching the data from your back ends.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了同构数据获取实现。你只需添加从后端获取数据的代码。
- en: '**Cons**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**'
- en: More-complex apps require doing additional work to set up Redux and dynamic
    routing.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的应用程序需要额外的设置工作来设置Redux和动态路由。
- en: Some parts of the framework are custom, such as the router, meaning you have
    to learn yet another router.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的一些部分是自定义的，例如路由器，这意味着你不得不学习另一个路由器。
- en: Originally built with smaller static sites in mind.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初是为较小的静态网站构建的。
- en: 12.5\. Comparing the options
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. 比较选项
- en: You’ve seen several ways to build isomorphic apps with popular JavaScript frameworks.
    [Table 12.1](kindle_split_025_split_005.xhtml#ch12table01) compares the three
    frameworks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了使用流行的JavaScript框架构建同构应用程序的几种方法。[表12.1](kindle_split_025_split_005.xhtml#ch12table01)比较了这三个框架。
- en: Table 12.1\. Comparison of Ember, Angular, and Next.js
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.1\. Ember、Angular和Next.js的比较
- en: '|   | Ember | Angular | Next.js |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|   | Ember | Angular | Next.js |'
- en: '| --- | --- | --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Learning curve for framework | Medium: Get started quickly, but steep learning
    curve for advanced knowledge. | Medium: Requires solid grasp of Angular’s MVC
    implementation. | Easy (if you know React): Requires ramp-up on framework conventions.
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 框架的学习曲线 | 中等：快速入门，但高级知识的学习曲线陡峭。 | 中等：需要牢固掌握Angular的MVC实现。 | 如果你知道React，则简单：需要熟悉框架约定。
    |'
- en: '| Easy to get into production? | Yes | More steps required than other two options
    | Yes |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 容易进入生产环境吗？ | 是 | 比其他两种选项需要更多步骤 | 是 |'
- en: '| Isomorphic code works by default? | Yes, but requires nonstandard Ember data
    fetching | Requires added code module to override default HTTP behavior | Yes
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 默认情况下是否支持同构代码？ | 是的，但需要非标准的Ember数据获取 | 需要添加代码模块来覆盖默认的HTTP行为 | 是 |'
- en: '| Size of app? | Any | Any | Ideal for small or static apps |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序大小？ | 任何 | 任何 | 适用于小型或静态应用程序 |'
- en: '| Approach to initial load of the browser app (handoff between server and browser)
    | Full replace | Calculated replace | Virtual DOM with React, no replacement or
    DOM updates |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器应用程序的初始加载方法（服务器和浏览器之间的交接） | 完全替换 | 计算替换 | 使用React的虚拟DOM，无替换或DOM更新 |'
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided an overview of three ways to get up and running with isomorphic
    (or universal) apps. You learned about Ember FastBoot, universal Angular, and
    Next.js. Each provides a good implementation that may work for your situation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了三种实现同构（或通用）应用程序的方法。你学习了Ember FastBoot、通用Angular和Next.js。每个都提供了适用于你情况的良好实现。
- en: Build a convention-driven app using Ember and Ember FastBoot. Ember provides
    most of the implementation for you, so getting an app running is fast.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ember和Ember FastBoot构建基于约定的应用程序。Ember为你提供了大部分的实现，因此快速启动应用程序。
- en: Use Angular to server-render your app. Angular requires more code to get the
    state transfer working properly between the server and the browser.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular进行应用程序的服务端渲染。Angular需要更多的代码来正确地在服务器和浏览器之间进行状态传输。
- en: Next.js is a React framework that’s isomorphic out of the box, for an app without
    dynamic pages.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js是一个React框架，它默认支持同构，适用于没有动态页面的应用程序。
- en: Chapter 13\. Where to go from here
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章\. 从哪里开始
- en: '*This chapter covers*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Additional isomorphic tools and frameworks
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的同构工具和框架
- en: The skills that you’ll want to acquire to become an expert at building isomorphic
    applications
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要获得的技能，以便成为构建同构应用程序的专家
- en: Where to learn more about related areas of focus such as GraphQL, search engine
    optimization (SEO), and performance
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪里了解更多关于相关重点领域，如GraphQL、搜索引擎优化（SEO）和性能
- en: 'Throughout this book, you’ve learned about many tools, libraries, and frameworks.
    You’ve been exposed to best practices in building isomorphic apps. Most important,
    you’re comfortable thinking isomorphically: you can navigate the server/browser
    handoff and are familiar with the technology that makes this possible. You’ve
    also been exposed to how other technologies such as Ember and Angular implement
    server rendering. And you’ve seen an all-in-one isomorphic framework (Next.js).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你学习了关于许多工具、库和框架的知识。你接触到了构建同构应用程序的最佳实践。最重要的是，你习惯于以同构的方式思考：你可以导航服务器/浏览器交接，并且熟悉使这成为可能的技术。你还接触到了其他技术，如Ember和Angular如何实现服务器端渲染。你还看到了一个全功能的同构框架（Next.js）。
- en: Now it’s time to go over some resources for learning more about isomorphic apps,
    the various technologies presented in this book, and even related topics that
    you may need in order to build practical, real-world apps.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回顾一些资源，以了解更多关于同构应用程序、本书中介绍的各种技术，以及你可能需要构建实用、真实世界应用程序的相关主题。
- en: 13.1\. Additional tools and frameworks
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. 额外的工具和框架
- en: This book has covered many of the most popular libraries used in web development
    today. But if you’ve spent even a month as a web developer, you know that the
    JavaScript community is always evolving ideas, and there are far more useful topics
    than can be covered in a single book. This section provides an overview of Webpack
    Dev Server, suggests where to learn more about implementing it, and goes over
    additional isomorphic frameworks. Webpack Dev Server is a tool that makes your
    development environment easier to work with when building webpack-configured applications.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书涵盖了今天在Web开发中使用的许多最受欢迎的库。但如果你作为一名Web开发者已经工作了甚至一个月，你就会知道JavaScript社区总是在不断演变想法，而且有用的主题远远超过一本书所能涵盖的范围。本节提供了Webpack
    Dev Server的概述，建议你到哪里去了解更多关于实现它的信息，并介绍了额外的同构框架。Webpack Dev Server是一个工具，它使得构建webpack配置的应用程序的开发环境更容易使用。
- en: 13.1.1\. Webpack Dev Server
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. Webpack Dev Server
- en: 'Webpack Dev Server is the development environment provided by webpack. It enables
    Hot Module Replacement, which takes an updated build and automatically replaces
    the parts of your running application that have changed. Here’s a walk-through
    of how it works:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack Dev Server是webpack提供的发展环境。它启用了热模块替换，它接受更新的构建并自动替换运行中的应用程序中已更改的部分。以下是它的工作原理的概述：
- en: '**1**.  Start the first build and output the initial file, served from the
    dev server.'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  启动第一个构建并输出初始文件，由开发服务器提供。'
- en: '**2**.  Enable a watcher.'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  启用监视器。'
- en: '**3**.  A build is triggered by the watcher output, which outputs a new version
    on the dev server.'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  监视器输出触发构建，在开发服务器上输出新版本。'
- en: '**4**.  Use Hot Module Replacement to update the code running in the browser.'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  使用热模块替换来更新浏览器中运行的代码。'
- en: This becomes extremely helpful in a development environment and significantly
    speeds up your ability to compile and see changes. I highly recommend setting
    it up for all your webpack projects.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这在开发环境中变得非常有帮助，并且显著加快了你的编译和查看更改的能力。我强烈建议为你的所有webpack项目设置它。
- en: 'To learn about Webpack Dev Server, you can visit webpack’s documentation: [https://webpack.js.org/guides/hot-module-replacement/](https://webpack.js.org/guides/hot-module-replacement/).
    You have to set up some things specifically for React. The URL for the Hot Module
    Replacement guide includes links (see the Other Code and Frameworks section of
    the documentation site at [https://webpack.js.org/guides/hot-module-replacement/#other-code-and-frameworks](https://webpack.js.org/guides/hot-module-replacement/#other-code-and-frameworks)).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Webpack Dev Server，你可以访问 Webpack 的文档：[https://webpack.js.org/guides/hot-module-replacement/](https://webpack.js.org/guides/hot-module-replacement/)。你必须为
    React 设置一些特定的事情。热模块替换指南的 URL 包含链接（参见文档网站 [https://webpack.js.org/guides/hot-module-replacement/#other-code-and-frameworks](https://webpack.js.org/guides/hot-module-replacement/#other-code-and-frameworks)
    的其他代码和框架部分）。
- en: 'Implementing this in an isomorphic environment isn’t trivial—especially when
    using a Node.js server with a webpack bundle on the front end (as opposed to also
    using webpack to build your Node.js server, which I don’t recommend). Webpack
    Isomorphic Tools can help you get going with this: [https://github.com/halt-hammerzeit/webpack-isomorphic-tools](https://github.com/halt-hammerzeit/webpack-isomorphic-tools).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在同构环境中实现这一点并不简单——尤其是在使用前端 Node.js 服务器和 webpack 打包（而不是也使用 webpack 构建你的 Node.js
    服务器，我不推荐这样做）的情况下。Webpack Isomorphic Tools 可以帮助你开始这个过程：[https://github.com/halt-hammerzeit/webpack-isomorphic-tools](https://github.com/halt-hammerzeit/webpack-isomorphic-tools)。
- en: 13.1.2\. Isomorphic frameworks
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2. 同构框架
- en: 'Besides Next.js, at least two other isomorphic React frameworks are worth looking
    into (if you want to use a prebuilt option instead of building up your own):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Next.js，至少还有两个同构 React 框架值得一看（如果你想要使用预构建选项而不是自己构建）：
- en: Walmart Labs Electrode ([www.electrode.io](http://www.electrode.io))
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Walmart Labs Electrode ([www.electrode.io](http://www.electrode.io))
- en: React Server from Redfin ([https://react-server.io](https://react-server.io))
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redfin 的 React 服务器 ([https://react-server.io](https://react-server.io))
- en: Almost every new JavaScript framework provides the ability to do server rendering.
    Whether you want to try Vue.js ([https://vuejs.org](https://vuejs.org)), Aurelia
    ([https://github.com/AureliaUniversal/universal](https://github.com/AureliaUniversal/universal)),
    or something else, it probably supports isomorphic rendering.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个新的 JavaScript 框架都提供了服务器端渲染的能力。无论你想尝试 Vue.js ([https://vuejs.org](https://vuejs.org))、Aurelia
    ([https://github.com/AureliaUniversal/universal](https://github.com/AureliaUniversal/universal))
    还是其他什么，它们很可能支持同构渲染。
- en: '13.2\. Up your game: building on isomorphic skills'
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2. 上线：基于同构技能构建
- en: This book gives you a solid foundation in several areas, including React architecture
    and server rendering with Node.js. Although you have a good start on these skills,
    this section tells you where you can find more resources to continue improving
    these skills.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书为你提供了在多个领域的坚实基础，包括 React 架构和 Node.js 的服务器端渲染。尽管你在这些技能上已经有一个良好的开端，但这一节会告诉你如何找到更多资源来继续提高这些技能。
- en: 13.2.1\. React best practices
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1. React 最佳实践
- en: 'If you’re going to build isomorphic React apps in production, becoming an expert
    at React architecture is an area where you’ll want to improve your knowledge.
    Luckily for you, React has a strong community and many resources:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在生产环境中构建同构 React 应用，成为 React 架构方面的专家是你想要提高知识的一个领域。幸运的是，React 拥有一个强大的社区和许多资源：
- en: GitHub repo with links to various blogs and resources about React ([http://mng.bz/XEXE](http://mng.bz/XEXE))
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 仓库，包含关于 React 的各种博客和资源链接 ([http://mng.bz/XEXE](http://mng.bz/XEXE))
- en: 'Egghead.io courses—some are free, and others require a subscription ([https://egghead.io/technologies/react](https://egghead.io/technologies/react)).
    I’m a big fan of the way Egghead splits its courses into tiny consumable concepts:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Egghead.io 课程——有些是免费的，有些则需要订阅 ([https://egghead.io/technologies/react](https://egghead.io/technologies/react))。我是
    Egghead 将课程拆分成微小可消费概念的忠实粉丝：
- en: React/Redux cheat sheets ([https://egghead.io/react-redux-cheatsheets](https://egghead.io/react-redux-cheatsheets))
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: React/Redux 技巧表 ([https://egghead.io/react-redux-cheatsheets](https://egghead.io/react-redux-cheatsheets))
- en: Learn React Router v4 ([http://mng.bz/YHFN](http://mng.bz/YHFN))
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 React Router v4 ([http://mng.bz/YHFN](http://mng.bz/YHFN))
- en: Add internationalization to a React app ([http://mng.bz/g5On](http://mng.bz/g5On))
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 React 应用添加国际化 ([http://mng.bz/g5On](http://mng.bz/g5On))
- en: 'Additional React books:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 React 书籍：
- en: '*React in Action* by Mark T. Thomas (Manning, 2017)'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Mark T. Thomas 著的 *React in Action* (Manning, 2017)
- en: '*React Quickly* by Azat Mardan (Manning, 2017)'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Azat Mardan 著的 *React Quickly* (Manning, 2017)
- en: '*Redux in Action* by Marc Garreau and Will Faurot (Manning, 2018)'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Marc Garreau 和 Will Faurot 著的 *Redux in Action* (Manning, 2018)
- en: 13.2.2\. Up your Node.js game
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2. 提升你的 Node.js 水平
- en: 'If you don’t have much experience with Node.js, I suggest improving your Node.js
    skills by doing the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有太多 Node.js 的经验，我建议通过以下方式提高你的 Node.js 技能：
- en: Learning about Node.js’s I/O model ([https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)
    and [http://mng.bz/NR1f](http://mng.bz/NR1f))
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Node.js 的 I/O 模型 ([https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)
    和 [http://mng.bz/NR1f](http://mng.bz/NR1f))
- en: 'Building a simple REST API with Node.js:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js 构建简单的 REST API：
- en: Loopback framework ([https://loopback.io/doc/en/lb3/Tutorials-and-examples.html](https://loopback.io/doc/en/lb3/Tutorials-and-examples.html))
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loopback 框架 ([https://loopback.io/doc/en/lb3/Tutorials-and-examples.html](https://loopback.io/doc/en/lb3/Tutorials-and-examples.html))
- en: Tutorial with Node.js, Express, MongoDB, Mongoose, and Postman ([http://mng.bz/1qSO](http://mng.bz/1qSO))
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js、Express、MongoDB、Mongoose 和 Postman 的教程 ([http://mng.bz/1qSO](http://mng.bz/1qSO))
- en: 'Learning how to harden Node.js to make a more secure server:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何强化 Node.js 以创建更安全的服务器：
- en: Blog post on hardening Node.js ([https://blog.risingstack.com/node-js-security-checklist/](https://blog.risingstack.com/node-js-security-checklist/))
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于强化 Node.js 的博客文章 ([https://blog.risingstack.com/node-js-security-checklist/](https://blog.risingstack.com/node-js-security-checklist/))
- en: Express documentation on security ([https://expressjs.com/en/advanced/best-practice-security.html](https://expressjs.com/en/advanced/best-practice-security.html))
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express 关于安全性的文档 ([https://expressjs.com/en/advanced/best-practice-security.html](https://expressjs.com/en/advanced/best-practice-security.html))
- en: To practice, I suggest building a CRUD app of some kind. Building some of the
    examples in this book would work well—a recipes app that allows users to upload
    a recipe would be a good practice app. Building a chat app is another good way
    to practice because it covers several important topics (REST API, WebSocket, security
    because it requires accounts, and so forth).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，我建议构建一种类型的 CRUD 应用。构建这本书中的某些示例会很好——一个允许用户上传菜谱的应用程序将是一个很好的练习应用。构建一个聊天应用也是练习的另一种好方法，因为它涵盖了几个重要主题（REST
    API、WebSocket、安全性，因为它需要账户，等等）。
- en: 13.2.3\. Infrastructure
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3. 基础设施
- en: 'Because an isomorphic app will always have a server component, acquiring proficiency
    in build tools and server management will help you when running production apps.
    Additionally, understanding CDNs and being able to use them is an important skill
    in any web developer’s tool belt. This blog post is a good place to get started
    deploying React apps using Docker with Amazon Web Services (AWS): [http://mng.bz/9Na2](http://mng.bz/9Na2).'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同构应用程序始终会有一个服务器组件，因此熟练掌握构建工具和服务器管理将有助于你在运行生产应用程序时。此外，了解 CDN 并能够使用它们是任何网络开发者工具箱中的重要技能。这篇博客文章是一个很好的起点，介绍如何使用
    Docker 和亚马逊网络服务（AWS）部署 React 应用程序：[http://mng.bz/9Na2](http://mng.bz/9Na2)。
- en: 'Here’s a list of general skills you’ll need to get started:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一份你需要开始的一般技能列表：
- en: 'Containers: Docker ([https://docs.docker.com/get-started/](https://docs.docker.com/get-started/))'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器：Docker ([https://docs.docker.com/get-started/](https://docs.docker.com/get-started/))
- en: 'CI tool: CircleCI ([https://circleci.com](https://circleci.com)) or TravisCI
    ([https://travis-ci.org](https://travis-ci.org)) are good starting places'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI 工具：CircleCI ([https://circleci.com](https://circleci.com)) 或 TravisCI ([https://travis-ci.org](https://travis-ci.org))
    是一个好的起点
- en: 'Cloud hosting: AWS, Google, Heroku, Digital Ocean, and more'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云托管：AWS、Google、Heroku、Digital Ocean 以及更多
- en: A good explanation of CDNs ([http://mng.bz/k6qG](http://mng.bz/k6qG))
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDN 的良好解释 ([http://mng.bz/k6qG](http://mng.bz/k6qG))
- en: 'There are many CDN providers you can check out: Amazon Cloud Front, CloudFlare,
    Fastly, Akamai'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多 CDN 提供商你可以查看：Amazon Cloud Front、CloudFlare、Fastly、Akamai
- en: SSL/TLS ([https://blog.talpor.com/2015/07/ssltls-certificates-beginners-tutorial/](https://blog.talpor.com/2015/07/ssltls-certificates-beginners-tutorial/))
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL/TLS ([https://blog.talpor.com/2015/07/ssltls-certificates-beginners-tutorial/](https://blog.talpor.com/2015/07/ssltls-certificates-beginners-tutorial/))
- en: CORS ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS))
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CORS ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS))
- en: One of the best ways you can practice these skills is to deploy a personal website
    or practice app with AWS. That will force you to go through the process of using
    several of the tools listed here (for example, you could build an app with Docker
    and deploy it to Elastic Beanstalk in AWS).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以练习这些技能的最好方法之一是在 AWS 上部署一个个人网站或练习应用。这将迫使你通过使用这里列出的几个工具的过程（例如，你可以使用 Docker
    构建一个应用程序并将其部署到 AWS 的 Elastic Beanstalk 上）。
- en: '13.3\. All the things: data, SEO, and performance'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 所有事情：数据、SEO和性能
- en: This book focuses on a narrow slice of web development. But adding deep knowledge
    in at least one of the following areas will improve your ability to execute real-world
    apps (and make you more hirable!).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于网络开发的狭小领域。但在以下至少一个领域添加深入知识将提高你执行实际应用的能力（并使你更具可雇佣性！）。
- en: '13.3.1\. Data: accessing services with GraphQL'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 数据：使用GraphQL访问服务
- en: As app ecosystems have evolved and microservice architecture has become more
    popular, many engineering organizations have come to realize the limits of REST
    architecture. (I recommend the Netflix technical video at [https://netflix.github.io/falcor/starter/why-falcor.html](https://netflix.github.io/falcor/starter/why-falcor.html)
    if you want to understand more about the problem).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用生态系统的演变和微服务架构的普及，许多工程组织开始意识到REST架构的局限性。（如果你想了解更多关于这个问题的信息，我推荐观看Netflix的技术视频[https://netflix.github.io/falcor/starter/why-falcor.html](https://netflix.github.io/falcor/starter/why-falcor.html)）。
- en: In response, both Netflix and Facebook have proposed solutions. You can think
    of their implementations—Falcor ([https://netflix.github.io/falcor/](https://netflix.github.io/falcor/))
    and GraphQL ([http://graphql.org/](http://graphql.org/))—as front-end services
    for all your back-end services. Both allow the client application to request the
    data required for a view without knowing the underlying implementations.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，Netflix和Facebook都提出了解决方案。你可以将他们的实现——Falcor ([https://netflix.github.io/falcor/](https://netflix.github.io/falcor/))
    和 GraphQL ([http://graphql.org/](http://graphql.org/))——视为所有后端服务的客户端服务。两者都允许客户端应用请求视图所需的数据，而无需了解底层实现。
- en: For example, say I have a chat application. While chatting, the app needs to
    fetch chat data and user data, which will likely live on different services or
    endpoints in a REST application. These frameworks allow you to request all the
    data you need in a single request. They contain the business logic indicating
    where to fetch the data from so the client apps don’t have to.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我有一个聊天应用。在聊天过程中，该应用需要获取聊天数据和用户数据，这些数据可能位于REST应用的不同服务或端点上。这些框架允许你通过单个请求获取所有所需的数据。它们包含业务逻辑，指示从哪里获取数据，这样客户端应用就不需要这样做。
- en: 13.3.2\. Search engine optimization
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. 搜索引擎优化
- en: One of the main reasons you’d want to build an isomorphic application is to
    server-render your application’s pages for searchbots. If this is a reason relevant
    to your situation, learning more about what makes good SEO strategy and how to
    perform the technical implementations of SEO is a requirement.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 想要构建同构应用的一个主要原因是服务器端渲染你的应用页面以供搜索引擎爬虫使用。如果这是与你情况相关的理由，那么了解良好的SEO策略以及如何执行SEO的技术实现是必要的。
- en: Understanding SEO best practices
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解SEO最佳实践
- en: 'Whole books and websites have been devoted to SEO strategy. If you’re new to
    SEO or want to up your game, a variety of tools and resources can help you get
    started:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书和网站都致力于SEO策略。如果你是SEO的新手或想提高你的技能，各种工具和资源可以帮助你开始：
- en: SEO 101 from Moz ([https://moz.com/beginners-guide-to-seo](https://moz.com/beginners-guide-to-seo))
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moz的SEO 101指南 ([https://moz.com/beginners-guide-to-seo](https://moz.com/beginners-guide-to-seo))
- en: Moz, an SEO tracking tool, subscription ([https://moz.com](https://moz.com))
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moz，一个SEO跟踪工具，订阅 ([https://moz.com](https://moz.com))
- en: Moz Blog ([https://moz.com/blog](https://moz.com/blog))
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moz Blog ([https://moz.com/blog](https://moz.com/blog))
- en: Google Webmasters Blog ([https://webmasters.googleblog.com](https://webmasters.googleblog.com))
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Webmasters Blog ([https://webmasters.googleblog.com](https://webmasters.googleblog.com))
- en: Google Trends ([https://trends.google.com/trends/](https://trends.google.com/trends/))
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google趋势 ([https://trends.google.com/trends/](https://trends.google.com/trends/))
- en: SERPs Keyword Search Tool, subscription ([https://serps.com/tools/keyword-research/](https://serps.com/tools/keyword-research/))
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SERPs关键词搜索工具，订阅 ([https://serps.com/tools/keyword-research/](https://serps.com/tools/keyword-research/))
- en: Technical implementation of SEO
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SEO的技术实现
- en: 'The more technical side of SEO involves implementing best practices and using
    Google’s tracking tools to monitor and improve SEO. Things like building sitemaps
    also fall in this category:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: SEO的更多技术方面涉及实施最佳实践和使用Google的跟踪工具来监控和改进SEO。例如，构建网站地图也属于这一类别：
- en: Google Search Console ([www.google.com/webmasters/tools/home](http://www.google.com/webmasters/tools/home))—you
    have to verify your web properties before getting started
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Search Console ([www.google.com/webmasters/tools/home](http://www.google.com/webmasters/tools/home))——在开始之前你必须验证你的网站属性。
- en: Schema.org ([http://schema.org/docs/schemas.html](http://schema.org/docs/schemas.html)
    and [https://moz.com/learn/seo/schema-structured-data](https://moz.com/learn/seo/schema-structured-data))
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Schema.org([http://schema.org/docs/schemas.html](http://schema.org/docs/schemas.html)
    和 [https://moz.com/learn/seo/schema-structured-data](https://moz.com/learn/seo/schema-structured-data))
- en: Use good header practices ([www.hobo-web.co.uk/headers/](http://www.hobo-web.co.uk/headers/))
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用良好的标题实践([www.hobo-web.co.uk/headers/](http://www.hobo-web.co.uk/headers/))
- en: Internal linking ([https://moz.com/learn/seo/internal-link](https://moz.com/learn/seo/internal-link))
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部链接([https://moz.com/learn/seo/internal-link](https://moz.com/learn/seo/internal-link))
- en: Sitemaps ([https://moz.com/blog/xml-sitemaps](https://moz.com/blog/xml-sitemaps))
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站地图([https://moz.com/blog/xml-sitemaps](https://moz.com/blog/xml-sitemaps))
- en: 13.3.3\. Web performance
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.3. Web性能
- en: One of the other reasons for building isomorphic apps is to have good perceived
    performance for your users. But you still want to adhere to best practices around
    web performance. There are many things to learn in this area.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 构建同构应用的其他原因之一是为用户提供良好的感知性能。但你仍然需要遵循关于Web性能的最佳实践。在这个领域有许多东西要学习。
- en: The best way to get started learning about performance is to take an app you
    have in production and make performance improvements. Before you start, make sure
    you have a way to measure your web app’s performance (many third-party tools are
    available for this—you can try Pingdom or New Relic).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 了解性能的最佳方式是选择一个正在生产的应用并对其进行性能优化。在开始之前，确保你有方法来衡量你的Web应用性能（许多第三方工具可供选择——你可以尝试Pingdom或New
    Relic）。
- en: 'Here are some resources on how to improve web performance:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于如何提高Web性能的资源：
- en: Google’s Lighthouse tools ([https://developers.google.com/web/tools/lighthouse/](https://developers.google.com/web/tools/lighthouse/))
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google的Lighthouse工具([https://developers.google.com/web/tools/lighthouse/](https://developers.google.com/web/tools/lighthouse/))
- en: Web performance best practices ([www.manning.com/books/web-performance-in-action](http://www.manning.com/books/web-performance-in-action))
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web性能最佳实践([www.manning.com/books/web-performance-in-action](http://www.manning.com/books/web-performance-in-action))
- en: HTTP2 ([https://http2.github.io/0](https://http2.github.io/0))
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP2([https://http2.github.io/0](https://http2.github.io/0))
- en: Service workers ([http://mng.bz/tLwh](http://mng.bz/tLwh))
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者([http://mng.bz/tLwh](http://mng.bz/tLwh))
- en: React performance case study ([http://mng.bz/sNeU](http://mng.bz/sNeU))
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React性能案例研究([http://mng.bz/sNeU](http://mng.bz/sNeU))
- en: You might also consider looking into Preact ([https://github.com/developit/preact](https://github.com/developit/preact)).
    This library provides a “React lite” implementation with the same virtual DOM
    concepts you’ve learned in React. If you’re looking for performance gains, this
    is worth exploring.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以考虑研究Preact([https://github.com/developit/preact](https://github.com/developit/preact))。这个库提供了一个“React轻量级”实现，具有与你在React中学到的相同的虚拟DOM概念。如果你在寻找性能提升，这值得探索。
- en: Summary
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we reviewed several topics that will help you continue to
    improve your web app skills and contribute to your ability to build isomorphic
    apps in production environments:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了几个有助于你继续提高Web应用技能并有助于你在生产环境中构建同构应用的专题：
- en: Where to go to find information that builds on the topics in this book, including
    webpack and more isomorphic frameworks.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去哪里寻找有关本书中主题的信息，包括webpack和更多同构框架。
- en: Resources for improving your Node.js and React skills.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高你的Node.js和React技能的资源。
- en: Topics you may want to learn in the future if you build isomorphic web apps.
    These include data services such as GraphQL, SEO, and infrastructure skills.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你构建同构Web应用，你可能希望在将来学习以下主题。这些包括数据服务，如GraphQL、SEO和基础设施技能。
