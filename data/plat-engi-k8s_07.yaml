- en: '7 Platform capabilities I: Shared application concerns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 平台功能I：共享应用程序关注点
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Learning requirements of 95% of cloud-native applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 95%的云原生应用程序的学习需求
- en: Reducing friction between application and infrastructure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少应用程序与基础设施之间的摩擦
- en: Addressing shared concerns with standard APIs and components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准API和组件解决共同关注的问题
- en: In chapter 5 we created abstractions such as databases and message brokers to
    provision and configure all the components required by our application’s services.
    In chapter 6, we extended these mechanisms to build our platform walking skeleton.This
    platform enables teams to request new development environments that not only create
    isolated environments but also install an instance of the Conference application
    (and all the components required by the application) so teams can do their work.
    By going through the process of building a platform, we defined the responsibilities
    of a platform team and where each tool belongs and why. We ended chapter 6 with
    clear guidelines for where tools like Crossplane, Argo CD, and Tekton would run
    to manage and enable different environments with capabilities that teams will
    need to deliver more software in front of customers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我们创建了数据库和消息代理等抽象，以配置和配置应用程序服务所需的所有组件。在第6章中，我们扩展了这些机制来构建我们的平台步行骨架。这个平台使团队能够请求新的开发环境，这些环境不仅创建隔离的环境，还安装了会议应用程序（以及应用程序所需的所有组件），以便团队能够开展工作。通过构建平台的过程，我们定义了平台团队的责任以及每个工具所属的位置及其原因。在第6章结束时，我们提供了关于像Crossplane、Argo
    CD和Tekton这样的工具在哪里运行以及如何管理并启用具有团队交付更多软件所需功能的不同的环境的明确指南。
- en: 'So far, we have given developers Kubernetes clusters with an instance of their
    application running. This chapter looks at mechanisms to provide developers with
    capabilities closer to their application needs. Most of these capabilities will
    be accessed by APIs that abstract away the application’s infrastructure needs,
    allowing the platform team to evolve (update, reconfigure, change) infrastructural
    components without updating any application code. At the same time, developers
    will interact with these platform capabilities without knowing how they are implemented
    and without bloating their applications with a load of dependencies. This chapter
    is divided into three sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为开发者提供了运行应用程序实例的Kubernetes集群。本章探讨了提供更接近应用程序需求的功能的机制。这些功能中的大多数将通过抽象应用程序基础设施需求的API来访问，允许平台团队在不更新任何应用程序代码的情况下演变（更新、重新配置、更改）基础设施组件。同时，开发者将与这些平台功能交互，而无需了解它们的实现方式，也不会因为大量依赖而使应用程序膨胀。本章分为三个部分：
- en: What are most applications doing 95% of the time?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数应用程序95%的时间在做什么？
- en: Standard APIs and abstractions to separate application code from infrastructure.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准API和抽象，用于将应用程序代码与基础设施分离。
- en: Updating our Conference application with Dapr (Distributed Application Runtime),
    a CNCF and open-source project created to provide solutions to distributed application
    challenges.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dapr（分布式应用运行时）更新我们的会议应用程序，Dapr是一个由CNCF和开源项目创建的，旨在为分布式应用挑战提供解决方案的项目。
- en: Let’s start by analyzing what most applications are doing. Don’t worry; we will
    also cover edge cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先分析一下大多数应用程序在做什么。不用担心；我们也会涵盖边缘情况。
- en: 7.1 What are most applications doing 95% of the time?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 大多数应用程序95%的时间在做什么？
- en: 'We have worked with our walking skeleton Conference applications for seven
    chapters. We have learned how to run it on top of Kubernetes and how to connect
    the services to databases, key-value stores, and message brokers. There was a
    good reason to go over those steps and include those behaviors in the walking
    skeleton. Most applications, like the Conference application, will need the following
    functionality:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经与我们的步行骨架会议应用程序合作了七个章节。我们学习了如何在Kubernetes上运行它，以及如何将服务连接到数据库、键值存储和消息代理。回顾这些步骤并在步行骨架中包含这些行为是有充分理由的。大多数应用程序，如会议应用程序，将需要以下功能：
- en: '*Call other services to send or receive information:* Application services
    don’t exist on their own. They need to call and be called by other services. Services
    can be local or remote, and you can use different protocols, most commonly HTTP
    and GRPC. We use HTTP calls between services for the conference application walking
    skeleton.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用其他服务发送或接收信息:* 应用程序服务并不是孤立的。它们需要调用其他服务，并被其他服务调用。服务可以是本地的或远程的，你可以使用不同的协议，最常见的是HTTP和GRPC。我们在会议应用程序的行走骨架中使用服务之间的HTTP调用。'
- en: '*Store and read data from persistent storage:* This can be a database, a key-value
    store, a blob store like S3 buckets, or even writing and reading from files. For
    the conference application, we are using Redis and PostgreSQL.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储和读取持久化存储中的数据:* 这可以是数据库、键值存储、类似S3存储桶的blob存储，甚至是从文件中写入和读取。对于会议应用程序，我们使用Redis和PostgreSQL。'
- en: '*Emit and consume events or messages asynchronously:* Using asynchronous messaging
    for communicating systems implementing an event-driven architecture is a common
    practice in distributed systems. Using tools like Kafka, RabbitMQ, or even cloud-provider
    messaging systems is common. Each service in the Conference application is emitting
    or consuming events using Kafka.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步发射和消费事件或消息:* 在分布式系统中，使用异步消息进行通信系统实现事件驱动架构是一种常见做法。使用像Kafka、RabbitMQ甚至云提供商的消息系统是常见的。会议应用程序中的每个服务都在使用Kafka发射或消费事件。'
- en: '*Accessing credentials to connect to services:* When connecting to an application’s
    infrastructure components, whether local or remote, most services will need credentials
    to authenticate to other systems. In this book I’ve only mentioned tools like
    external-secrets ([https://github.com/external-secrets/external-secrets](https://github.com/external-secrets/external-secrets))
    or HashiCorp’s Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/)),
    but we haven’t dug deeper into it.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问凭证以连接到服务:* 当连接到应用程序的基础设施组件，无论是本地还是远程时，大多数服务都需要凭证来对其他系统进行身份验证。在这本书中，我只提到了像外部密钥（[https://github.com/external-secrets/external-secrets](https://github.com/external-secrets/external-secrets)）或HashiCorp的Vault（[https://www.vaultproject.io/](https://www.vaultproject.io/)）这样的工具，但我们还没有深入探讨。'
- en: Whether we are building business applications or machine learning tools, most
    applications will benefit from having these capabilities easily available to consume.
    And while complex applications require much more than that, there is always a
    way to separate the complex part from the generic parts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在构建商业应用程序还是机器学习工具，大多数应用程序都将从这些能力易于消费中受益。虽然复杂的应用程序需要更多，但总有办法将复杂部分与通用部分分离。
- en: Figure 7.1 shows several example service interactions with each other and available
    infrastructure. Service A is calling Service B using HTTP (for this topic, GRPC
    would fit similarly). Service B stores and reads data from a database and will
    need the right credentials to connect. Service A also connects to a message broker
    and places messages into it. Service C can pick messages from the message broker
    and, using some credentials, connect to a Bucket to store some calculations based
    on the messages it receives.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1展示了几个服务之间以及与可用基础设施的交互示例。服务A通过HTTP调用服务B（对于这个主题，GRPC同样适用）。服务B存储并从数据库读取数据，并需要正确的凭证来连接。服务A还连接到消息代理并将消息放入其中。服务C可以从消息代理中提取消息，并使用一些凭证连接到存储桶，以存储基于接收到的消息的一些计算。
- en: '![](../../OEBPS/Images/07-01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-01.png)'
- en: Figure 7.1 Common communication patterns in distributed applications
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 分布式应用程序中的常见通信模式
- en: No matter what logic these services are implementing, we can extract some constant
    behaviors and enable development teams to consume without the hassle of dealing
    with the low-level details or pushing them to make decisions around cross-cutting
    concerns that can be solved at the platform level.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这些服务实现什么逻辑，我们都可以提取一些常量行为，并使开发团队能够消费，而无需处理低级细节，或推动他们做出关于可以在平台级别解决的问题的决策。
- en: To understand how this can work, we must look closely at what is happening inside
    these services. As you might know already, the devil is in the details. While
    from a high-level perspective, we are used to dealing with services doing what
    is described in figure 7.1, if we want to unlock an increased velocity in our
    software delivery pipelines, we need to go one level down to understand the intricate
    relationships between the components of our applications. Let’s take a quick look
    at the challenges the application teams face when trying to change different services
    and infrastructure that our services require.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，我们必须仔细观察这些服务内部发生的事情。正如你可能已经知道的，魔鬼藏在细节中。从高层次的角度来看，我们习惯于处理如图7.1所示的服务执行其描述的操作，但如果我们想要在软件交付管道中实现更高的速度，我们需要再深入一层，了解我们应用程序组件之间的复杂关系。让我们快速看一下应用程序团队在尝试更改不同的服务和所需的基础设施时面临的挑战。
- en: 7.1.1 The challenges of coupling application and infrastructure
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 应用与基础设施耦合的挑战
- en: Fortunately, this is not a programming language competition, independent of
    your programming language of choice. If you want to connect to a database or message
    broker, you must add some dependencies to your application code. While this is
    a common practice in the software development industry, it is also one of the
    reasons why delivery speed is slower than it should be.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这并不是编程语言竞赛，与你的选择无关。如果你想连接到数据库或消息代理，你必须向你的应用程序代码中添加一些依赖项。虽然这在软件开发行业中是一种常见做法，但它也是交付速度比预期慢的原因之一。
- en: Coordination between different teams is the reason behind most blockers when
    releasing software. We have created architectures and adopted Kubernetes because
    we want to go faster. By using containers, we have adopted an easier and more
    standard way to run our applications. No matter in which language the application
    is written or which tech stack is used, if you give me a container with the application
    inside, I can run it. We have removed the application dependencies on the operating
    system and the software that we need to have installed in a machine (or virtual
    machine) to run your application, which is now encapsulated inside a container.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不同团队之间的协调是发布软件时大多数阻塞问题的原因。我们创建了架构并采用了Kubernetes，因为我们希望更快地发展。通过使用容器，我们采用了更简单、更标准的方式来运行我们的应用程序。无论应用程序是用哪种语言编写的，或者使用了哪种技术栈，如果你给我一个包含应用程序的容器，我就可以运行它。我们已经消除了应用程序对操作系统的依赖，以及我们需要在机器（或虚拟机）上安装的软件，以便运行你的应用程序，现在这些软件都封装在容器中。
- en: Unfortunately, we haven’t tackled the relationships and integration points between
    containers (our application’s services). We also haven’t solved how these containers
    will interact with application infrastructure components that can be local (self-hosted)
    or managed by a cloud provider.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们还没有解决容器（我们应用程序的服务）之间的关系和集成点。我们也没有解决这些容器将如何与本地（自托管）或由云服务提供商管理的应用程序基础设施组件交互的问题。
- en: Let’s take a closer look at where these applications heavily rely on other services
    and can block teams from making changes, pushing them for complicated coordination
    that can end up causing downtime to our users. We will start by splitting up the
    previous example into the specifics of each interaction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些应用程序在哪些方面严重依赖其他服务，并且可能阻碍团队进行更改，推动他们进行复杂的协调，这可能导致我们的用户出现停机。我们将从将之前的示例分解为每个交互的具体情况开始。
- en: 7.1.2 Service-to-service interaction challenges
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 服务间交互挑战
- en: To send data from one service to another, you must know where the other service
    is running and which protocol it uses to receive information. Because we are dealing
    with distributed systems, we also need to ensure that the requests between services
    arrive at the other service and have mechanisms to deal with unexpected network
    problems or situations where the other services might fail. In other words, we
    need to build resilience in our services. We cannot always trust the network or
    other services to behave as expected.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据从一个服务发送到另一个服务，你必须知道另一个服务运行的位置以及它使用哪种协议来接收信息。因为我们处理的是分布式系统，我们还需要确保服务间的请求能够到达另一个服务，并具备处理意外网络问题或另一个服务可能失败的情况的机制。换句话说，我们需要在我们的服务中构建弹性。我们并不能总是信任网络或其他服务按预期行为。
- en: Let’s use Service A and Service B as examples to go deeper into the details.
    In figure 7.2, Service A needs to send a request to Service B.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以服务A和服务B为例，深入探讨细节。在图7.2中，服务A需要向服务B发送一个请求。
- en: '![](../../OEBPS/Images/07-02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-02.png)'
- en: Figure 7.2 Service-to-service interaction challenges
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 服务间交互挑战
- en: But let’s dig deeper into the mechanisms services can use internally. Suppose
    we leave the fact that Service A depends on the Service B contract (API) to be
    stable and not change for this to work on the side. What else can go wrong here?
    As mentioned, development teams should add a resiliency layer inside their services
    to ensure that Service A requests reach Service B. One way to do this is to use
    a framework to retry the request if it fails automatically. Frameworks implementing
    this functionality are available for all programming languages. Tools like `go-retryablehttp`
    ([https://github.com/hashicorp/go-retryablehttp](https://github.com/hashicorp/go-retryablehttp))
    or Spring Retry for Spring Boot ([https://github.com/spring-projects/spring-retry](https://github.com/spring-projects/spring-retry))
    add resiliency to your service-to-service interactions. Some of these mechanisms
    also include exponential backoff functionality to avoid overloading services and
    the network when things are going wrong.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们更深入地探讨服务内部可以使用的机制。假设我们暂时不考虑服务A依赖于服务B的合同（API）需要稳定且不改变的事实，以便于理解这个机制。还有什么可能出错？正如提到的，开发团队应该在他们的服务内部添加一个弹性层，以确保服务A的请求能够到达服务B。实现这一功能的一种方法是通过框架在请求失败时自动重试。所有编程语言都有实现这一功能的框架。像`go-retryablehttp`（[https://github.com/hashicorp/go-retryablehttp](https://github.com/hashicorp/go-retryablehttp)）或Spring
    Boot的Spring Retry（[https://github.com/spring-projects/spring-retry](https://github.com/spring-projects/spring-retry)）这样的工具可以为你的服务间交互添加弹性。其中一些机制还包括指数退避功能，以避免在出现问题时过载服务和网络。
- en: Unfortunately, there is no standard library shared across tech stacks that can
    provide the same behavior and functionality for all your applications, so even
    if you configure both Spring Retry and `go-retryablehttp` with similar parameters,
    it is quite hard to guarantee that they will behave in the same way when services
    start failing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有跨技术堆栈共享的标准库可以为所有应用程序提供相同的行为和功能，所以即使你使用相似的参数配置Spring Retry和`go-retryablehttp`，也很难保证它们在服务开始失败时会有相同的行为。
- en: '![](../../OEBPS/Images/07-03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-03.png)'
- en: Figure 7.3 Service-to-service interactions retry mechanisms
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 服务间交互重试机制
- en: Figure 7.3 shows Service A written in Java using the Spring Retry library to
    retry three times with a wait time of 3 seconds between each request when the
    request fails to be acknowledged by Service B. Service C, written in Go using
    the `go-retryablehttp` library, is configured to retry five times but using an
    exponential backoff (the retry period between requests is not fixed; this can
    provide time for the other service to recover and not be flooded with retries)
    mechanism when things go wrong.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3展示了使用Spring Retry库在Java中编写的服务A，当请求未能被服务B确认时，它将重试三次，每次请求之间的等待时间为3秒。使用`go-retryablehttp`库编写的服务C，用Go语言编写，配置为重试五次，但在出现问题时使用指数退避机制（请求之间的重试周期不是固定的；这可以为其他服务的恢复提供时间，并避免被重试请求淹没）。
- en: Even if the applications are written in the same language and using the same
    frameworks, both services (A and B) must have compatible versions of their dependencies
    and configurations. If we push both Service A and Service B to have the versions
    of the frameworks, we are coupling them together, meaning we will need to coordinate
    the update of the other service whenever any of these internal dependency versions
    change. This can cause even more slowdowns and increase the complexity of coordination
    efforts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用程序是用相同的语言编写的并使用相同的框架，两个服务（A和B）也必须具有兼容的依赖项和配置版本。如果我们将服务A和服务B都推向使用框架的版本，这意味着我们将它们耦合在一起，这意味着每当这些内部依赖项版本中的任何一个发生变化时，我们都需要协调另一个服务的更新。这可能会导致更多的延迟并增加协调工作的复杂性。
- en: Note In this section, I’ve used retrying mechanisms as an example, but think
    about other cross-cutting concerns that you might want to include for these service-to-service
    interactions, like circuit breakers (also for resiliency) rate limiting and observability.
    Consider the frameworks and libraries you will need to add to instrument your
    application code to get metrics from it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本节中，我使用了重试机制作为示例，但请考虑您可能希望包括在这些服务间交互中的其他横切关注点，例如断路器（也用于弹性）、速率限制和可观察性。考虑您将需要添加到您的应用程序代码中以便从中获取指标的框架和库。
- en: On the other hand, using different frameworks (and versions) for each service
    will complicate troubleshooting these services for our operations teams. Wouldn’t
    it be great to have a way to add resiliency to our applications without modifying
    them? Before answering this question, what else can go wrong?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为每个服务使用不同的框架（和版本）将使我们的操作团队对这些服务的故障排除变得复杂。如果有一种方法可以在不修改应用程序的情况下为我们的应用程序添加弹性，那岂不是很好？在回答这个问题之前，还有其他什么可能出错？
- en: Something that developers often overlook relates to the security aspect of these
    communications. Service A and Service B don’t live in a vacuum, meaning other
    services surround them. If any of these services is compromised by a bad actor,
    having a free-for-all service-to-service invocation between all the services makes
    our entire system insecure. This is where having service identity and the right
    security mechanisms to ensure that, for this example, Service A can only call
    Service B is extremely important, as shown in figure 7.4.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常忽视的一些事情与这些通信的安全性方面有关。服务A和服务B并不孤立存在，这意味着其他服务围绕着它们。如果这些服务中的任何一个被恶意行为者攻破，所有服务之间的自由服务间调用会使我们的整个系统不安全。这就是为什么拥有服务身份和正确的安全机制来确保，例如，服务A只能调用服务B，对于图7.4所示的情况，极为重要。
- en: '![](../../OEBPS/Images/07-04.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-04.png)'
- en: Figure 7.4 If a service is compromised, it can affect the entire system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 如果一个服务被攻破，它可能会影响整个系统。
- en: Having a mechanism that allows us to define our service’s identity, we can define
    which service-to-service invocations are allowed and which protocols and ports
    are allowed for the communications to happen. Figure 7.5 shows how we can reduce
    the blast radius (how many services are affected if a security breach happens)
    by defining rules that enforce which services are allowed in our system and how
    they are supposed to interact.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有了允许我们定义我们的服务身份的机制，我们可以定义哪些服务间调用是被允许的，以及允许哪些协议和端口进行通信。图7.5展示了我们如何通过定义规则来减少影响范围（如果发生安全漏洞，受影响的服务的数量），这些规则强制规定哪些服务允许在我们的系统中，以及它们应该如何交互。
- en: '![](../../OEBPS/Images/07-05.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-05.png)'
- en: Figure 7.5 Reducing the blast radius by defining system-level rules
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 通过定义系统级规则来减少影响范围
- en: Having the right mechanisms to define and validate these rules cannot be easily
    built inside each service. Hence developers tend to assume that an external mechanism
    will be in charge of performing these checks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和验证这些规则的正确机制不能轻易地构建在每个服务内部。因此，开发者倾向于假设将有一个外部机制负责执行这些检查。
- en: As we will see in the following sections, service identity is something that
    we need across the board and not only for service-to-service interactions. Wouldn’t
    it be great to have a simple way to add service identity to our system without
    changing our application’s services?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在以下章节中看到的，服务身份是我们需要跨领域的东西，而不仅仅是对于服务间交互。如果有一种简单的方法可以将服务身份添加到我们的系统中而不改变我们的应用程序服务，那岂不是很好？
- en: Before answering this question, let’s look at other challenges teams face when
    architecting distributed applications. Let’s talk about storing and reading state,
    which most applications do.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，让我们看看团队在架构分布式应用程序时面临的其他挑战。让我们谈谈存储和读取状态，这是大多数应用程序都会做的。
- en: 7.1.3 Storing/reading state challenges
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 存储/读取状态挑战
- en: Our application needs to store or read state from persistent storage. That is
    quite a common requirement, right? You need data to do some calculations, then
    store the results somewhere so they don’t get lost if your application goes down.
    In our example, figure 7.6, Service B needed to connect to a database or persistent
    storage to read and write data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要从持久存储中存储或读取状态。这是一个相当常见的需求，对吧？你需要数据来进行一些计算，然后将结果存储在某个地方，以防应用程序崩溃时丢失。在我们的示例中，图7.6，服务B需要连接到数据库或持久存储来读取和写入数据。
- en: '![](../../OEBPS/Images/07-06.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-06.png)'
- en: Figure 7.6 Storing/reading state challenges
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 存储/读取状态挑战
- en: 'What can go wrong here? Developers are used to connecting to different kinds
    of databases (relational, NoSQL, files, buckets) and interacting with them. But
    two main friction points slow teams from moving their services forward: dependencies
    and credentials.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会出什么问题？开发者习惯于连接到不同类型的数据库（关系型、NoSQL、文件、桶）并与它们交互。但是，有两个主要的摩擦点会减缓团队推进服务的步伐：依赖项和凭证。
- en: Let’s start by looking at dependencies. What kind of dependencies does Service
    B need to connect to a database? Figure 7.7 shows Service B connecting to both
    a relational database and a NoSQL database. To achieve these connections, Service
    B needs to include a driver and a client library, plus the configuration needed
    to fine-tune how the application will connect to these two databases. These configurations
    define the size of the connection pool (how many application threads can connect
    concurrently to the database), buffers, health checks, and other important details
    that can change how the application behaves.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看依赖项开始。服务B需要什么类型的依赖项才能连接到数据库？图7.7显示了服务B连接到关系型数据库和NoSQL数据库。为了实现这些连接，服务B需要包含一个驱动程序和客户端库，以及用于微调应用程序如何连接到这两个数据库的配置。这些配置定义了连接池的大小（多少个应用程序线程可以同时连接到数据库）、缓冲区、健康检查以及其他可能改变应用程序行为的重要细节。
- en: '![](../../OEBPS/Images/07-07.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-07.png)'
- en: Figure 7.7 Databases dependencies and client versions
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 数据库依赖项和客户端版本
- en: Besides the configuration of the driver and the client, their versions need
    to be compatible with the version of the databases we are running, and this is
    where the challenges begin.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了驱动程序和客户端的配置之外，它们的版本需要与我们所运行的数据库版本兼容，这正是挑战开始的地方。
- en: Note It is important to notice that each driver/client is specific to the database
    (relational or NoSQL) that you are connecting to. This section assumes you used
    a specific database because it meets your application’s requirements. Each database
    vendor has unique features optimized for different use cases. In this chapter,
    we are more interested in 95% of the cases that do not use vendor-specific features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请注意，每个驱动程序/客户端都是针对您连接到的数据库（关系型或NoSQL）特定的。本节假设您使用了特定的数据库，因为它符合您应用程序的需求。每个数据库供应商都有针对不同用例优化的独特功能。在本章中，我们更感兴趣的是不使用供应商特定功能的95%的情况。
- en: Once the application’s service is connected to the database using the client
    APIs, it should be fairly easy to interact with it. Whether by sending SQL queries
    or commands to fetch data or using a key-value API to read keys and values from
    the database instance, developers should know the basics to start reading and
    writing data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序的服务通过客户端API连接到数据库，与它交互应该相当简单。无论是通过发送SQL查询或命令来获取数据，还是使用键值API从数据库实例中读取键和值，开发者应该了解基础知识以开始读取和写入数据。
- en: Do you have more than one service interacting with the same database instance?
    Are they both using the same library and the same version? Are these services
    written using the same programming language and frameworks? Even if you manage
    to control all these dependencies, there is still a coupling that will slow you
    down. Whenever the operations teams decide to upgrade the database version, each
    service connecting to this instance might or might not need to upgrade its dependencies
    and configuration parameters. Would you upgrade the database first or the dependencies?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否拥有多个服务与同一数据库实例交互？它们是否都使用相同的库和版本？这些服务是否使用相同的编程语言和框架编写？即使您设法控制所有这些依赖项，仍然存在一种耦合关系，这将减慢您的速度。每当运维团队决定升级数据库版本时，连接到此实例的每个服务可能需要也可能不需要升级其依赖项和配置参数。您是先升级数据库还是依赖项？
- en: For credentials, we face a similar problem. It is quite common to consume credentials
    from a credential store like HashiCorp’s Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/)).
    If not provided by the platform and not managed in Kubernetes, application services
    can include a dependency to consume credentials from their application’s code
    easily. Figure 7.8 shows Service B connecting to a credential store, using a specific
    client library, to get a token to connect to a database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于凭据，我们面临类似的问题。从像HashiCorp的Vault（[https://www.vaultproject.io/](https://www.vaultproject.io/)）这样的凭据存储中消费凭据相当普遍。如果没有由平台提供并且不在Kubernetes中管理，应用程序服务可以轻松地从应用程序代码中包含一个依赖来消费凭据。图7.8显示了服务B通过特定的客户端库连接到凭据存储，以获取连接到数据库的令牌。
- en: '![](../../OEBPS/Images/07-08.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-08.png)'
- en: Figure 7.8 Credentials store dependencies
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 凭据存储依赖
- en: In chapters 2 and 5, we connected the Conference services to different components
    using Kubernetes Secrets. By using Kubernetes Secrets, we were removing the need
    for application developers to worry about where to get these credentials from.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章和第5章中，我们使用Kubernetes Secrets将会议服务连接到不同的组件。通过使用Kubernetes Secrets，我们消除了应用程序开发者担心从哪里获取这些凭据的需求。
- en: Otherwise, if your service connects to other services or components that might
    require dependencies in this way, the service will need to be upgraded for any
    change in any of the components. This coupling between the service code and dependencies
    creates the need for complex coordination between application development teams,
    the platform team, and the operations teams in charge of keeping these components
    up and running.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果你的服务连接到其他服务或组件，这些服务或组件可能以这种方式需要依赖，那么服务将需要升级以适应任何组件的任何变化。这种服务代码和依赖之间的耦合创造了在应用程序开发团队、平台团队以及负责保持这些组件运行的操作团队之间进行复杂协调的需求。
- en: Can we get rid of some of these dependencies? Can we push some of these concerns
    down to the platform team, so we remove the hassle of keeping them updated from
    developers? If we decouple these services with a clean interface, then the infrastructure
    and applications can be updated independently.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否消除一些这些依赖？能否将这些担忧推给平台团队，从而减少开发者更新它们的麻烦？如果我们通过一个干净的接口解耦这些服务，那么基础设施和应用可以独立更新。
- en: Before jumping into the next topic, I wanted to briefly talk about why having
    service identity at this level can also help reduce security problems when interacting
    with application infrastructure components. Figure 7.9 shows how similar service
    identity rules can be applied to validate who can interact with infrastructure
    components. Once again, the system will limit the blast radius if a service is
    compromised.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一个主题之前，我想简要谈谈为什么在这一级别拥有服务身份也可以帮助减少与应用程序基础设施组件交互时的安全问题。图7.9展示了如何应用类似的服务身份规则来验证谁可以与基础设施组件交互。一旦服务被攻破，系统将再次限制影响范围。
- en: '![](../../OEBPS/Images/07-09.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-09.png)'
- en: Figure 7.9 Enforcing rules based on service identity
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 基于服务身份执行规则
- en: But what about asynchronous interactions? Let’s look at how these challenges
    relate to asynchronous messaging before jumping into the solutions space.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但异步交互怎么办？在深入解决方案空间之前，让我们看看这些挑战如何与异步消息传递相关联。
- en: 7.1.4 Asynchronous messaging challenges
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 异步消息传递挑战
- en: With asynchronous messaging, you want to decouple the producer from the consumer.
    When using HTTP or GRPC, Service A needs to know about Service B, and both services
    need to be up to exchange information. When using asynchronous messaging, Service
    A doesn’t know anything about Service C. You can take it even further, where Service
    C might not even be running when Service A places a message into the message broker.
    Figure 7.10 shows Service A placing a message into the message broker; at a later
    point in time, Service C can connect to the message broker and fetch messages
    from it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用异步消息传递时，你希望解耦生产者和消费者。当使用HTTP或GRPC时，服务A需要了解服务B，并且两个服务都需要运行以交换信息。当使用异步消息传递时，服务A对服务C一无所知。你可以更进一步，服务C可能在服务A将消息放入消息代理时甚至没有运行。图7.10展示了服务A将消息放入消息代理；在稍后的某个时间点，服务C可以连接到消息代理并从中获取消息。
- en: '![](../../OEBPS/Images/07-10.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-10.png)'
- en: Figure 7.10 Asynchronous messaging interactions
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 异步消息传递交互
- en: Similar to HTTP/GRPC service-to-service interactions, when using a message broker,
    we need to know where the message broker is to send messages to or to subscribe
    to get messages from. Message brokers also provide isolation to enable applications
    to group messages together using the concept of topics. Services can be connected
    to the same message broker instance but send and consume messages from different
    topics.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP/GRPC服务之间的交互类似，当使用消息代理时，我们需要知道消息代理的位置，以便发送消息或订阅以接收消息。消息代理还提供隔离性，使应用程序能够使用主题的概念将消息分组在一起。服务可以连接到同一个消息代理实例，但可以从不同的主题发送和消费消息。
- en: When using message brokers, we face the same problems described with databases.
    We need to add a dependency to our applications depending on which message broker
    we decide to use, its version, and the programming language that we have chosen.
    Message brokers will use different protocols to receive and send information.
    A standard increasingly adopted in this space is the CloudEvent specification
    ([https://cloudevents.io/](https://cloudevents.io/)) from the CNCF. While CloudEvents
    is a great step forward, it doesn’t save your application developers from adding
    dependencies to connect and interact with your message brokers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用消息代理时，我们面临与数据库描述的相同问题。我们需要根据我们决定使用的消息代理、其版本以及我们选择的编程语言，向我们的应用程序添加依赖项。消息代理将使用不同的协议来接收和发送信息。在这个领域越来越被采用的标准是CNCF的CloudEvent规范([https://cloudevents.io/](https://cloudevents.io/))。虽然CloudEvents是一个巨大的进步，但它并不能免除你的应用程序开发者添加依赖项以连接和与你的消息代理交互。
- en: Figure 7.11 shows Service A, which includes the Kafka client library to connect
    to Kafka and send messages. Besides the URL, port, and credentials to connect
    to the Kafka instance, the Kafka client also receives configurations on how the
    client will behave when connecting to the broker, similar to databases. Service
    C uses the same client, but with different versions, to connect to the same broker.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11展示了服务A，它包括用于连接到Kafka并发送消息的Kafka客户端库。除了连接到Kafka实例的URL、端口和凭证外，Kafka客户端还会接收有关客户端在连接到代理时的行为配置，类似于数据库。服务C使用相同的客户端，但使用不同的版本，以连接到相同的代理。
- en: '![](../../OEBPS/Images/07-11.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11](../../OEBPS/Images/07-11.png)'
- en: Figure 7.11 Dependencies and API challenges
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 依赖项和API挑战
- en: Message brokers face the same problem as with databases and persistent storage.
    But unfortunately, with message brokers, developers will need to learn specific
    APIs that might not be that easy initially. Sending and consuming messages using
    different programming languages present more challenges and cognitive load on
    teams without experience with the specifics of the message broker at hand.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理面临与数据库和持久化存储相同的问题。但不幸的是，在使用消息代理时，开发者需要学习特定的API，这些API可能一开始并不容易。使用不同的编程语言发送和消费消息，对于没有具体消息代理经验的团队来说，会带来更多的挑战和认知负荷。
- en: 'Same as with databases, if you have chosen Kafka, for example, it means that
    Kafka fits your application requirements. You might want to use advanced Kafka
    features that other message brokers don’t provide. However, let me repeat it here:
    we are interested in 95% of the cases where application services want to exchange
    messages to externalize the state and let other interested parties know. For those
    cases, we want to remove the cognitive load from our application teams and let
    them emit and consume messages without the hassle of learning all the specifics
    of the selected message broker. By reducing the cognitive load required on developers
    to learn specific technologies, you can onboard less experienced developers and
    let experts take care of the details. Similar to databases, we can use service
    identity to control which services can connect, read, and write messages from
    a message broker. The same principles apply.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库类似，如果你选择了Kafka，例如，这意味着Kafka符合你的应用程序需求。你可能会想使用其他消息代理不提供的Kafka高级功能。然而，让我在这里重申：我们对95%的情况感兴趣，在这些情况下，应用程序服务想要交换消息以外部化状态并让其他感兴趣的各方知道。对于这些情况，我们希望从我们的应用程序团队中移除认知负荷，让他们能够轻松地发送和消费消息，而无需学习所选消息代理的所有具体细节。通过减少开发者学习特定技术所需的认知负荷，你可以让经验较少的开发者加入，并让专家处理细节。与数据库类似，我们可以使用服务身份来控制哪些服务可以连接、读取和从消息代理中写入消息。同样的原则适用。
- en: 7.1.5 Dealing with edge cases (the remaining 5%)
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.5 处理边缘情况（剩余的5%）
- en: There is always more than one good reason to add libraries to your application’s
    services. Sometimes these libraries will give you the ultimate control over how
    to connect to vendor-specific components and functionalities. Other times, we
    add libraries because it is the easiest way to get started or because we are instructed
    to do so. Someone in the organization decided to use PostgreSQL, and the fastest
    way to connect and use it is to add the PostgreSQL driver to our application code.
    We usually don’t realize that we are coupling our application to that specific
    PostgreSQL version. For edge cases, or to be more specific, scenarios where you
    need to use some vendor-specific functionality, consider wrapping up that specific
    functionality as a separate unit from all the generic functionality you might
    consume from a database or message broker.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有不止一个很好的理由将库添加到你的应用程序服务中。有时这些库会给你控制如何连接到供应商特定组件和功能的最终权力。其他时候，我们添加库是因为这是开始的最简单方式，或者因为我们被指示这样做。组织中的某个人决定使用PostgreSQL，最快的方法是将PostgreSQL驱动程序添加到我们的应用程序代码中。我们通常没有意识到我们正在将应用程序耦合到特定的PostgreSQL版本。对于边缘情况，或者更具体地说，需要使用某些供应商特定功能的情况，考虑将那个特定功能作为一个单独的单元封装起来，从你可能会从数据库或消息代理中消耗的所有通用功能中分离出来。
- en: '![](../../OEBPS/Images/07-12.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-12.png)'
- en: Figure 7.12 Common vs. edge cases encapsulation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 常见与边缘情况封装对比
- en: I’ve chosen to use async messaging as an example in figure 7.12, but the same
    applies to databases and credential stores. If we can decouple 95% of our services
    to use generic capabilities to do their work and encapsulate edge cases as separate
    units, we reduce the coupling and the cognitive load on new team members tasked
    to modify these services. Service A in figure 7.12 is consuming a message API
    provided by the platform team to consume and emit messages asynchronously. We
    will look deeper into this approach in the next section. But more importantly,
    the edge cases, where we need to use some Kafka-specific features, for example,
    are extracted into a separate service that Service A can still interact with using
    HTTP or GRPC. Notice that the messaging API also uses Kafka to move information
    around. Still, for Service A, that is no longer relevant, because a simplified
    API is exposed as a platform capability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在图7.12中使用异步消息作为示例，但同样的情况也适用于数据库和凭证存储。如果我们能将95%的服务解耦，使用通用能力来完成工作，并将边缘情况作为单独的单元封装，我们就能减少耦合和新团队成员对这些服务进行修改时的认知负荷。图7.12中的服务A正在使用平台团队提供的消息API异步地消费和发布消息。我们将在下一节更深入地探讨这种方法。但更重要的是，那些需要使用一些特定于Kafka的功能的边缘情况，例如，被提取到一个单独的服务中，服务A仍然可以通过HTTP或GRPC与之交互。请注意，消息API也使用Kafka来移动信息。然而，对于服务A来说，这已经不再相关，因为一个简化的API作为平台能力被暴露出来。
- en: When we need to change these services, 95% of the time, we don’t need team members
    to worry about Kafka. The messaging API removes that concern from our application
    development teams. For modifying Service Y, you will need Kafka experts, and the
    Service Y code will need to be upgraded if Kafka is upgraded because it directly
    depends on the Kafka client. For this book, platform engineering teams should
    focus on trying to reduce the cognitive load on teams for the most common cases
    while at the same time allowing teams to choose the appropriate tool for edge
    cases and specific scenarios that don’t fit the common solutions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要更改这些服务时，95%的情况下，我们不需要团队成员担心Kafka。消息API从我们的应用程序开发团队中移除了这种担忧。对于修改服务Y，你需要Kafka专家，如果Kafka被升级，服务Y的代码也需要升级，因为它直接依赖于Kafka客户端。对于这本书，平台工程团队应该专注于尝试减少团队在常见情况下的认知负荷，同时允许团队为边缘情况和特定场景选择合适的工具，这些场景不适合常见解决方案。
- en: The following section will look at some approaches to address some of the challenges
    we have been discussing. However, keep in mind that these are generic solutions,
    and further steps may be required within your own specific context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将探讨一些方法来解决我们一直在讨论的一些挑战。然而，请记住，这些都是通用解决方案，在你的特定环境中可能还需要进一步的步骤。
- en: 7.2 Standard APIs to separate applications from infrastructure
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 将应用程序与基础设施分离的标准API
- en: What about if we encapsulate all these common functionalities (storing and reading
    data, messaging, credential stores, resiliency policies) into APIs that developers
    can use from within their applications to solve common challenges while, at the
    same time, enabling the platform team to wire infrastructure in a way that doesn’t
    require the application’s code to change? In figure 7.13 we can see the same services,
    but instead of adding dependencies to interact with infrastructure, they use HTTP/GRPC
    requests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些常用功能（存储和读取数据、消息传递、凭证存储、弹性策略）封装成开发者可以在其应用程序中使用以解决常见挑战的API，同时，又使平台团队能够以不要求应用程序代码更改的方式连接基础设施，那会怎样呢？在图7.13中，我们可以看到相同的服务，但它们不是通过添加与基础设施交互的依赖项，而是使用HTTP/GRPC请求。
- en: '![](../../OEBPS/Images/07-13.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13](../../OEBPS/Images/07-13.png)'
- en: Figure 7.13 Platform capabilities as APIs
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 作为API的平台能力
- en: Suppose we expose a set of HTTP/GRPC APIs that our applications services can
    consume. In that case, we can remove vendor-specific dependencies from our application
    code and consume these services using standard HTTP or GRPC calls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们公开了一组HTTP/GRPC API，我们的应用程序服务可以消费这些API。在这种情况下，我们可以从应用程序代码中移除供应商特定的依赖，并使用标准的HTTP或GRPC调用消费这些服务。
- en: This separation between application services and platform capabilities enables
    separate teams to handle different responsibilities. The platform can evolve independently
    from applications, and application code will now only depend on the platform capabilities
    interfaces but not the version of the components running under the hood. Figure
    7.14 shows the separation between application code (our three services) managed
    by application development teams and platform capabilities that are managed by
    the platform team.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务和平台能力之间的这种分离使得不同的团队能够处理不同的责任。平台可以独立于应用程序进行演变，并且应用程序代码现在将仅依赖于平台能力接口，而不是底层的组件版本。图7.14显示了由应用开发团队管理的应用程序代码（我们的三个服务）与由平台团队管理的平台能力之间的分离。
- en: '![](../../OEBPS/Images/07-14.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14](../../OEBPS/Images/07-14.png)'
- en: Figure 7.14 Decoupling responsibilities from app dev teams and platform capabilities
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 将应用开发团队和平台能力之间的责任解耦
- en: When using an approach like the one suggested here, the platform team can expand
    the platform capabilities, introducing new services for application development
    teams. More importantly, they can do so without affecting the existing applications
    or forcing them to release new versions. This enables teams to decide when to
    release new versions of their services based on their features and the capabilities
    that they want to consume.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这里建议的方法时，平台团队能够扩展平台功能，为应用开发团队引入新的服务。更重要的是，他们可以这样做而不影响现有的应用程序或强迫它们发布新版本。这使得团队可以根据其功能和希望消费的能力来决定何时发布其服务的新版本。
- en: By following this approach, the platform team can make new capabilities available
    for services to use and promote best practices. Because these platform capabilities
    are accessible to all services, they can promote standardization and implement
    best practices behind the covers. Each team can decide which capabilities are
    needed to solve their specific problems based on the available ones. If capabilities
    are correctly versioned, teams can decide how and when to upgrade to the latest
    version, allowing teams to move at their own pace without the platform pushing
    every team to upgrade whenever a new version is available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这种方法，平台团队能够为服务提供新的功能，并推广最佳实践。因为这些平台功能对所有服务都是可访问的，它们可以促进标准化，并在幕后实施最佳实践。每个团队可以根据可用的功能决定需要哪些能力来解决他们特定的难题。如果功能版本正确，团队可以决定如何以及何时升级到最新版本，允许团队根据自己的节奏进行迁移，而无需平台在每次有新版本可用时推动每个团队升级。
- en: For the sake of argument, imagine that the platform team decides to expose a
    consistent feature flagging capability to all the services. Using this capability,
    all services can consistently define and use feature flags without adding anything
    to their code except the feature flag conditional checks. Teams then can manage,
    visualize, and toggle on and off all their flags consistently. A capability like
    feature flags introduced and managed by the platform team directly affects developers’
    performance, because they don’t need to worry about defining how feature flags
    will be handled under the hood (persistence, refresh, consistency, etc.), and
    they know for sure that they are doing things aligned with other services.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了论证，假设平台团队决定向所有服务公开一致的功能标志能力。使用这项能力，所有服务都可以一致地定义和使用功能标志，而无需在它们的代码中添加任何东西，除了功能标志的条件检查。然后，团队可以一致地管理、可视化以及打开和关闭所有标志。平台团队引入并管理的能力，如功能标志，直接影响到开发者的性能，因为他们不需要担心在底层如何处理功能标志（持久性、刷新、一致性等），并且他们确信他们正在做的事情与其他服务保持一致。
- en: Figure 7.15 shows how the platform team can add extra capabilities, like, for
    example, feature flags, directly enabling teams to use this new capability uniformly
    in all the services. No new dependencies are needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15展示了平台团队如何添加额外功能，例如，例如，功能标志，直接使团队能够在所有服务中统一使用这项新功能。不需要新的依赖项。
- en: '![](../../OEBPS/Images/07-15.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-15.png)'
- en: Figure 7.15 Enabling teams by providing consistent and unified capabilities
    such as feature flags
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 通过提供一致和统一的能力，如功能标志，来启用团队
- en: Before moving forward, here’s a word of caution. Let’s look at some challenges
    that you will face when externalizing capabilities like APIs, as suggested in
    the previous figure.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，这里有一个警告。让我们看看当你像前一个图所示的那样外部化能力（如API）时，你将面临的一些挑战。
- en: 7.2.1 Exposing platform capabilities challenges
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 公开平台能力面临的挑战
- en: Externalizing APIs for teams to use will require, first of all, stable (and
    versioned) contracts that application teams can trust. When these APIs change,
    all applications consuming those APIs will break and must be updated. Platform
    teams can adopt a non-breaking changes policy that guarantees backward compatibility
    to teams and their applications. Adopting such policies makes your platform easier
    to consume, because the platform APIs and contracts are reliable for teams to
    use.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为团队使用外部化API将需要首先稳定（且版本化）的合同，应用程序团队可以信任。当这些API发生变化时，所有使用这些API的应用程序都会崩溃，并且必须进行更新。平台团队可以采用非破坏性更改策略，确保对团队及其应用程序的向后兼容性。采用此类策略使你的平台更容易被消费，因为平台API和合同对团队来说是可靠的。
- en: One of the main advantages of adding dependencies to your application code and,
    for example, using containers is that for local development, you can always start
    a PostgreSQL instance using Docker or Docker Compose and connect your application
    locally to it. If you move toward platform-provided capabilities, you must ensure
    that you can provide a local development experience for your teams unless your
    organization is mature enough to always work against remote services.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖项添加到你的应用程序代码中，例如使用容器的一个主要优势是，对于本地开发，你始终可以使用Docker或Docker Compose启动一个PostgreSQL实例，并将你的应用程序本地连接到它。如果你转向平台提供的功能，你必须确保可以为你的团队提供本地开发体验，除非你的组织足够成熟，始终可以针对远程服务进行工作。
- en: Another big difference is that the connection between your services and the
    platform provided APIs will introduce latency and require security by default.
    Before, calling the PostgreSQL driver APIs was a local call in the same process
    as your application. HTTPS, or a secure protocol, established the connection to
    the database itself, but setting that secure channel between your application
    and the database was the responsibility of the operations team.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重大区别是，你的服务和平台提供的API之间的连接将引入延迟并默认需要安全性。在此之前，调用PostgreSQL驱动API是在与你的应用程序相同的进程中进行的本地调用。HTTPS或安全协议建立了与数据库本身的连接，但设置应用程序和数据库之间的安全通道是运维团队的责任。
- en: It is also essential to recognize all the edge cases we can find when applying
    this approach to real-life projects. If you want to build these platform capabilities
    and push for your teams to consume them, you need to make sure that there is always
    a door open for edge cases so that teams (or even the platform team) aren’t forced
    to make common cases more complex to account for an obscure feature that will
    be used only 1% of the time. Figure 7.16 shows Services A, B, and C using the
    capabilities exposed by the platform via the capabilities APIs. Service Y, on
    the other hand, has very specific requirements for how to connect to the database,
    and the team maintaining the service has decided to bypass the platform capabilities
    APIs to connect directly to the database using the database client.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这种方法应用于实际项目时，识别我们能够找到的所有边缘情况也是至关重要的。如果您想构建这些平台功能并推动您的团队使用它们，您需要确保始终为边缘情况留有通道，这样团队（甚至平台团队）就不会被迫使常见情况更加复杂，以适应仅会使用1%时间的晦涩功能。图7.16显示了服务A、B和C通过平台能力API使用平台提供的功能。另一方面，服务Y对如何连接数据库有非常具体的要求，维护该服务的团队已决定绕过平台能力API，直接使用数据库客户端连接到数据库。
- en: Treating edge cases separately allows Services A, B, and C to evolve separately
    from the platform components (database, message brokers, credential stores), while
    Service Y is now heavily dependent on the database that is connecting to and requires
    a specific version of the client. While this sounds bad, in practice, it is acceptable
    and should be considered a platform feature. Teams that cannot solve their business
    problems with the exposed APIs will hate the platform and silently find workarounds.
    Good platforms (and platform teams) will promote APIs that cover a wide range
    of use cases, solving and facilitating the implementation of common functionality
    for application developers. If these APIs are not enough for all teams, documenting
    and deeply understanding the edge cases leads to new APIs and platform features
    that the platform team can implement in future versions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将边缘情况单独处理，允许服务A、B和C独立于平台组件（数据库、消息代理、凭证存储）发展，而服务Y现在严重依赖于连接到的数据库，并需要客户端的特定版本。虽然这听起来很糟糕，但在实践中，这是可以接受的，应该被视为平台功能。那些无法使用公开API解决其业务问题的团队将讨厌这个平台，并默默地寻找解决方案。好的平台（和平台团队）将推广覆盖广泛用例的API，解决并促进应用开发者常见功能的实现。如果这些API对所有团队来说都不够用，那么记录和深入理解边缘情况将导致新的API和平台功能，平台团队可以在未来的版本中实现。
- en: '![](../../OEBPS/Images/07-16.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-16.png)'
- en: Figure 7.16 Handling edge cases; do not ignore them
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 处理边缘情况；不要忽略它们
- en: The following section will examine a couple of CNCF initiatives that took these
    ideas forward and helped us implement the platform capabilities that most of our
    applications require.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将探讨几个CNCF倡议，这些倡议将这些想法向前推进，并帮助我们实现了大多数应用程序所需的平台功能。
- en: 7.3 Providing application-level platform capabilities
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 提供应用级平台功能
- en: In this section, we will look at two projects that can save development teams
    time in standardizing these generic APIs that most of our applications will need.
    We will start by looking at the Dapr project ([https://dapr.io/](https://dapr.io/)),
    what it is, how it works, and what it can do for our development and platform
    teams. Then we will look into OpenFeature ([https://openfeature.dev/](https://openfeature.dev/)),
    a CNCF initiative that provides our applications with the right abstractions to
    define and use feature flags without being tied to a specific feature flag provider.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两个项目，这些项目可以帮助开发团队在标准化这些通用API方面节省时间，这些API是我们大多数应用程序所需的。我们将首先了解Dapr项目([https://dapr.io/](https://dapr.io/))，它是什么，如何工作，以及它能为我们的开发和平台团队带来什么。然后我们将探讨OpenFeature([https://openfeature.dev/](https://openfeature.dev/))，这是一个CNCF倡议，为我们的应用程序提供适当的抽象，以便定义和使用功能标志，而无需绑定到特定的功能标志提供者。
- en: Once we get a bit of an understanding of how these two projects work and complement
    each other by helping us to provide application-level platform capabilities, we
    will look into how these projects can be applied to our Conference application,
    what changes are needed, the advantages of following this approach, and some examples
    showing edge cases. Let’s start with Dapr, our Distributed Application Runtime.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对这两个项目的工作原理以及它们如何通过提供应用级平台能力来相互补充有了基本的了解，我们将探讨这些项目如何应用于我们的会议应用程序，需要做出哪些改变，采用这种方法的优势，以及一些展示边缘情况的示例。让我们从
    Dapr，我们的分布式应用程序运行时开始。
- en: 7.3.1 Dapr in action
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 Dapr 在行动
- en: Dapr provides a set of consistent APIs to solve common and recurrent distributed
    application challenges. The Dapr project has spent the last four years implementing
    a set of APIs (called Building Block APIs) to abstract away common challenges
    and best practices that distributed applications will need 95% of the time. Created
    by Microsoft in 2019 and donated to the CNCF in 2021, the Dapr project has a large
    community contributing with extensions and improvements to the project APIs, making
    it the 10th fastest-growing project in the CNCF of 2023.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr 提供了一套一致的 API 来解决常见的和反复出现的分布式应用程序挑战。Dapr 项目在过去四年中实施了一套 API（称为构建块 API），以抽象出分布式应用程序在
    95% 的时间里需要面对的常见挑战和最佳实践。由微软于 2019 年创建并于 2021 年捐赠给 CNCF，Dapr 项目拥有一个庞大的社区，他们通过扩展和改进项目
    API 为项目做出贡献，使其成为 2023 年 CNCF 中增长最快的第 10 个项目。
- en: Dapr defines a set of building blocks that provide concrete APIs to solve distributed
    application challenges and swappable implementations that the platform team can
    configure. If you visit the [https://dapr.io](https://dapr.io) website, you will
    see the list of Building Block APIs, including Service Invocation, State Management,
    Publish & Subscribe, Secrets Store, Input/Output Bindings, Actors, Configurations
    Management, and, more recently Workflows. Figure 7.17 shows the Dapr official
    website describing the current Dapr Building Block APIs that teams can use to
    build their distributed applications. Check the Dapr Overview page at [https://docs.dapr.io/concepts/overview/](https://docs.dapr.io/concepts/overview/)
    for more information about the Dapr project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr 定义了一系列构建块，它们提供具体的 API 来解决分布式应用程序的挑战，以及平台团队可以配置的可互换实现。如果你访问 [https://dapr.io](https://dapr.io)
    网站，你会看到构建块 API 的列表，包括服务调用、状态管理、发布/订阅、密钥存储、输入/输出绑定、演员、配置管理，以及最近的工作流。图 7.17 展示了
    Dapr 官方网站描述的当前 Dapr 构建块 API，这些 API 可以供团队用来构建他们的分布式应用程序。更多信息请查看 [https://docs.dapr.io/concepts/overview/](https://docs.dapr.io/concepts/overview/)
    上的 Dapr 概述页面。
- en: '![](../../OEBPS/Images/07-17.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-17.png)'
- en: Figure 7.17 Dapr components for building distributed applications
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 用于构建分布式应用程序的 Dapr 组件
- en: While Dapr does much more than just expose APIs, in this chapter, I wanted to
    focus on the APIs provided by the project and the mechanisms used by the project
    to enable applications/services to consume these APIs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Dapr 执行的任务远不止暴露 API，但在本章中，我想要专注于项目提供的 API 以及项目用来使应用程序/服务能够消费这些 API 的机制。
- en: Because this is a Kubernetes book, we will look at Dapr in the context of Kubernetes,
    but the project can also be used outside of Kubernetes clusters, making Dapr a
    generic tool to build distributed applications no matter where you are running
    them. As a side note, Dapr is currently part of Azure Container Apps service ([https://azure.microsoft.com/en-us/products/container-apps](https://azure.microsoft.com/en-us/products/container-apps)),
    where it is configured with another CNCF project KEDA ([https://keda.sh/](https://keda.sh/))
    for autoscaling your distributed applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一本关于 Kubernetes 的书，所以我们将从 Kubernetes 的角度来探讨 Dapr，但该项目也可以在 Kubernetes 集群之外使用，这使得
    Dapr 成为一个通用的工具，无论你在哪里运行它们，都可以用来构建分布式应用程序。作为旁注，Dapr 目前是 Azure 容器应用服务的一部分（[https://azure.microsoft.com/en-us/products/container-apps](https://azure.microsoft.com/en-us/products/container-apps)），在那里它与另一个
    CNCF 项目 KEDA ([https://keda.sh/](https://keda.sh/)) 配置在一起，用于自动扩展你的分布式应用程序。
- en: 7.3.2 Dapr in Kubernetes
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 Dapr 在 Kubernetes 中
- en: 'Dapr works as a Kubernetes extension or add-on. You must install a set of Dapr
    controllers (a Dapr control plane) on your Kubernetes clusters. Figure 7.15 shows
    Service A deployed in a Kubernetes cluster with Dapr installed. Service A needs
    to be annotated with two annotations: `dapr.io/enabled: "true"` for the Dapr control
    plane to be aware of the application and `dapr.io/appid: "service-a"` to use Dapr
    service identity features.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'Dapr 作为 Kubernetes 扩展或附加组件运行。您必须在您的 Kubernetes 集群上安装一组 Dapr 控制器（Dapr 控制平面）。图
    7.15 显示了在安装了 Dapr 的 Kubernetes 集群中部署的服务 A。服务 A 需要添加两个注解：`dapr.io/enabled: "true"`
    以让 Dapr 控制平面了解应用程序，以及 `dapr.io/appid: "service-a"` 以使用 Dapr 服务身份功能。'
- en: Once Dapr is installed in your clusters, your applications deployed in the cluster
    can start using the Dapr APIs by adding a set of annotations to your deployments.
    This enables the Dapr control plane services to understand that your application
    wants to use the Dapr APIs, as shown in figure 7.18.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在您的集群中安装了 Dapr，您在集群中部署的应用程序可以通过向您的部署添加一组注解来开始使用 Dapr API。这使 Dapr 控制平面服务能够理解您的应用程序想要使用
    Dapr API，如图 7.18 所示。
- en: '![](../../OEBPS/Images/07-18.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-18.png)'
- en: Figure 7.18 The Dapr control plane monitor for applications with Dapr annotations
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 带有 Dapr 注解的应用程序的 Dapr 控制平面监控器
- en: By default, Dapr will make all the Dapr APIs available to your applications/services
    as a sidecar (`daprd` is the container that will run beside your applications/services)
    that runs beside your application’s containers. Using the sidecar pattern, we
    enable our application to interact with a co-located (localhost) API that runs
    very close to the application’s container and avoids network round trips. Figure
    7.19 shows how the Dapr control plane injects the `daprd` sidecar into the application
    annotated with the Dapr annotations. This enables the application to access the
    configured Dapr components.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Dapr 将所有 Dapr API 作为侧边车（`daprd` 是将运行在您的应用程序/服务容器旁边的容器）提供给您的应用程序/服务。使用侧边车模式，我们使我们的应用程序能够与位于应用程序容器附近的本地
    API（localhost）交互，从而避免网络往返。图 7.19 显示了 Dapr 控制平面如何将 `daprd` 侧边车注入带有 Dapr 注解的应用程序。这使得应用程序能够访问配置的
    Dapr 组件。
- en: '![](../../OEBPS/Images/07-19.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-19.png)'
- en: Figure 7.19 Dapr sidecars (daprd) give your applications local access to Dapr
    components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 Dapr 侧边车（daprd）使您的应用程序能够本地访问 Dapr 组件。
- en: Once the Dapr sidecar is running beside your applications/service container,
    it can use the Dapr APIs by sending requests (using HTTP or GRPC) to `localhost`,
    because the `daprd` sidecar runs inside the same pod as the application, sharing
    the same networking space.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Dapr 侧边车在您的应用程序/服务容器旁边运行，它就可以通过向 `localhost` 发送请求（使用 HTTP 或 GRPC）来使用 Dapr
    API，因为 `daprd` 侧边车与应用程序位于同一个 pod 中，共享相同的网络空间。
- en: Now for the Dapr APIs to be of some use, the platform team needs to configure
    the implementation (or backing mechanisms named Dapr components) for these APIs
    to work. For example, if you want to use the Statestore Dapr APIs ([https://docs.dapr.io/operations/components/setup-state-store/](https://docs.dapr.io/operations/components/setup-state-store/))
    from your applications/services, you must define and configure a Statestore component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让 Dapr API 有所作为，平台团队需要配置这些 API 的实现（或称为 Dapr 组件的后备机制）以使其工作。例如，如果您想从您的应用程序/服务中使用
    Statestore Dapr API ([https://docs.dapr.io/operations/components/setup-state-store/](https://docs.dapr.io/operations/components/setup-state-store/))，您必须定义并配置一个
    Statestore 组件。
- en: When working with Dapr on Kubernetes, you configure a Dapr component specification
    using a Kubernetes resource. For example, you can configure a Statestore Dapr
    component to use Redis. See listing 7.1 for an example Dapr component resource
    definition.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Kubernetes 上使用 Dapr 时，您可以使用 Kubernetes 资源配置 Dapr 组件规范。例如，您可以配置一个用于 Redis
    的 Statestore Dapr 组件。请参阅列表 7.1 以获取 Dapr 组件资源定义的示例。
- en: Listing 7.1 Dapr Statestore component definition
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 Dapr Statestore 组件定义
- en: '[PRE0]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① The Statestore component APIs support different implementations that you can
    find at [https://docs.dapr.io/reference/components-reference/supported-state-stores/](https://docs.dapr.io/reference/components-reference/supported-state-stores/).
    For this example, we are setting up the state.redis implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ① Statestore 组件 API 支持不同的实现，您可以在 [https://docs.dapr.io/reference/components-reference/supported-state-stores/](https://docs.dapr.io/reference/components-reference/supported-state-stores/)
    找到它们。在此示例中，我们正在设置 state.redis 实现。
- en: ② By setting the redisHost, the platform team can define where the Redis instance
    is located. There is no need for this instance to be inside the Kubernetes cluster;
    it can be any accessible Redis instance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ② 通过设置redisHost，平台团队可以定义Redis实例的位置。此实例无需位于Kubernetes集群内部；它可以是任何可访问的Redis实例。
- en: ③ The redisPassword property (required by the state.redis implementation) can
    use, as shown in this example, a Kubernetes Secret reference to fetch the password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ③ redisPassword属性（由state.redis实现所需）可以使用，如本例所示，通过Kubernetes Secret引用来获取密码。
- en: If the component resource is available in the Kubernetes cluster, the `daprd`
    sidecar can read its configurations and connect to the Redis instance for this
    example. From the application perspective, there is no need to know if Redis is
    being used or if any other implementation for the Statestore component. Figure
    7.20 shows how Dapr components are wired so Service A can use the Statestore component
    APIs. For this example, by calling a local API, Service A will be able to store
    and read data from the Redis instance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件资源在Kubernetes集群中可用，`daprd`边车可以读取其配置并连接到本例中的Redis实例。从应用的角度来看，无需知道是否使用了Redis或Statestore组件的任何其他实现。图7.20显示了Dapr组件是如何连接的，以便服务A可以使用Statestore组件API。在本例中，通过调用本地API，服务A将能够从Redis实例存储和读取数据。
- en: '![](../../OEBPS/Images/07-20.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20](../../OEBPS/Images/07-20.png)'
- en: Figure 7.20 Dapr sidecars use component configurations to connect to the component’s
    infrastructure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 Dapr边车使用组件配置来连接到组件的基础设施。
- en: Dapr makes it easy to build your application using a local/self-hosted Redis
    instance but then move it to the cloud where a managed Redis service can be used.
    No code or dependencies changes are needed, just a different Dapr component configuration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Dapr使得使用本地/自托管Redis实例构建应用变得容易，但随后可以将其迁移到云中，在那里可以使用托管的Redis服务。无需更改代码或依赖项，只需不同的Dapr组件配置。
- en: Do you want to emit and consume messages between different applications? You
    just need to configure a Dapr PubSub component ([https://docs.dapr.io/operations/components/setup-pubsub/](https://docs.dapr.io/operations/components/setup-pubsub/))
    and its implementation. Now your service can use a local API to emit asynchronous
    messages. Do you want to make all service interactions (including infrastructure)
    calls resilient? You can use Dapr resiliency policies ([https://docs.dapr.io/operations/resiliency/policies/](https://docs.dapr.io/operations/resiliency/policies/))
    to avoid writing custom logic inside your application code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在不同的应用之间发出和消费消息吗？您只需配置Dapr PubSub组件([https://docs.dapr.io/operations/components/setup-pubsub/](https://docs.dapr.io/operations/components/setup-pubsub/))及其实现。现在，您的服务可以使用本地API发出异步消息。您想使所有服务交互（包括基础设施）调用都具有弹性吗？您可以使用Dapr弹性策略([https://docs.dapr.io/operations/resiliency/policies/](https://docs.dapr.io/operations/resiliency/policies/))来避免在应用代码中编写自定义逻辑。
- en: Figure 7.21 shows how Service A and Service B can send requests to each other
    using the Service Invocation APIs, in contrast to calling the other service directly.
    Using these APIs (that send traffic through the `daprd` sidecar) enables the platform
    team to configure resiliency policies at the platform level, uniformly without
    adding any dependencies or changing the application code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21显示了服务A和服务B如何使用服务调用API相互发送请求，而不是直接调用其他服务。使用这些API（通过`daprd`边车发送流量）使平台团队能够在平台级别配置弹性策略，统一配置，无需添加任何依赖或更改应用代码。
- en: '![](../../OEBPS/Images/07-21.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图7.21](../../OEBPS/Images/07-21.png)'
- en: Figure 7.21 Dapr-enabled services can use service-to-service communications
    and resiliency policies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 Dapr启用服务可以使用服务间通信和弹性策略。
- en: OK, so the Dapr control plane will inject the Dapr sidecars (`daprd`) to the
    applications that are interested in using Dapr components. But how does this look
    from the application point of view?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以Dapr控制平面将注入Dapr边车(`daprd`)到感兴趣使用Dapr组件的应用程序中。但从应用的角度来看，这看起来是怎样的呢？
- en: 7.3.3 Dapr and your applications
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 Dapr与您的应用
- en: If we go back to the example introduced in the previous section where Service
    A wants to use the Statestore component to store/read some data from persistent
    storage like Redis, the application code is straightforward. No matter which programming
    language you use, as soon as you know how to create HTTP or GRPC requests, you
    have all you need to work with Dapr.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到上一节中介绍的示例，其中服务 A 想要使用 Statestore 组件从持久化存储（如 Redis）中存储/读取一些数据，应用程序代码很简单。无论你使用哪种编程语言，只要你知道如何创建
    HTTP 或 GRPC 请求，你就拥有了与 Dapr 一起工作的所有所需。
- en: 'For example, to store data using the Statestore APIs your application code
    needs to send an HTTP/GRPC request to the following endpoint:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用 Statestore API 存储数据，你的应用程序代码需要向以下端点发送 HTTP/GRPC 请求：
- en: '[PRE1]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using `curl`, the request will look like this, where `-d` shows the data we
    want to persist and `3500` is the default `DAPR_HTTP_PORT` and our Statestore
    component is called `statestore`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `curl`，请求看起来是这样的，其中 `-d` 显示我们想要持久化的数据，`3500` 是默认的 `DAPR_HTTP_PORT`，我们的 Statestore
    组件名为 `statestore`：
- en: '[PRE2]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To read the data that we have persisted, instead of sending a POST request,
    we just write a GET request. With `curl`, it would look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取我们已持久化的数据，我们只需发送一个 GET 请求，而不是发送 POST 请求。使用 `curl`，它看起来是这样的：
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Usually, you will not be using `curl` from inside your applications. You will
    use your programming language tools to write these requests. So, if you use Python,
    Go, Java, .NET, or JavaScript, you can find tutorials online on using popular
    libraries or built-in mechanisms to write these requests.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会在应用程序内部使用 `curl`。你会使用你的编程语言工具来编写这些请求。所以，如果你使用 Python、Go、Java、.NET 或 JavaScript，你可以在网上找到使用流行库或内置机制编写这些请求的教程。
- en: Another option is to use one of the Dapr SDKs (Software Development Kits) available
    for different programming languages. Adding the Dapr SDK to your application as
    a dependency allows you to make your developers’ lives easier, so they don’t need
    to craft HTTP or GRCP requests manually. It is crucial to notice that while you
    are now adding a new dependency to your application, this dependency is optional
    and only used as a helper to speed things up, because this dependency is not tied
    to any of the infrastructural components that the Dapr APIs are interacting with.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用适用于不同编程语言的 Dapr SDK（软件开发工具包）。将 Dapr SDK 添加到你的应用程序作为依赖项，可以使开发者的生活更轻松，他们不需要手动构建
    HTTP 或 GRPC 请求。重要的是要注意，虽然你现在正在向应用程序添加一个新的依赖项，但这个依赖项是可选的，并且仅用作辅助工具以加快速度，因为这个依赖项与
    Dapr API 交互的任何基础设施组件都没有关联。
- en: Check the Dapr website for examples of how your code will look if you use the
    Dapr SDK. For example, for a multi-programming language example on how to use
    the Statestore component using the SDKs, you can visit [https://docs.dapr.io/getting-started/quickstarts/statemanagement-quickstart/](https://docs.dapr.io/getting-started/quickstarts/statemanagement-quickstart/).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Dapr 网站，了解如果你使用 Dapr SDK，你的代码将如何看起来。例如，对于使用 SDKs 的多编程语言示例，了解如何使用 Statestore
    组件，你可以访问 [https://docs.dapr.io/getting-started/quickstarts/statemanagement-quickstart/](https://docs.dapr.io/getting-started/quickstarts/statemanagement-quickstart/)。
- en: While I decided to focus on Dapr for API abstractions, Dapr offers much more.
    By allowing platform teams to swap Dapr components implementations, applications
    can be moved across cloud providers without needing to change any application
    code. By default, the entire system is observable ([https://docs.dapr.io/operations/observability/](https://docs.dapr.io/operations/observability/)),
    secure ([https://docs.dapr.io/operations/security/](https://docs.dapr.io/operations/security/)),
    and resilient ([https://docs.dapr.io/operations/resiliency/](https://docs.dapr.io/operations/resiliency/)),
    as Dapr sidecars will enforce service identity and the rules specified by the
    platform team, while at the same time extracting metrics from all the Dapr-enabled
    applications and components. I recommend platform teams familiarize themselves
    with the Dapr Project, as the project was built to solve common challenges that
    teams will face when working with distributed applications. Check section 7.3.5
    of this chapter to see how we can make our Conference application Dapr-enabled.
    Now let’s talk a bit about feature flags.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我决定专注于 Dapr 进行 API 抽象时，Dapr 提供了更多功能。通过允许平台团队交换 Dapr 组件的实现，应用程序可以在不更改任何应用程序代码的情况下跨云提供商迁移。默认情况下，整个系统是可观察的
    ([https://docs.dapr.io/operations/observability/](https://docs.dapr.io/operations/observability/))，安全的
    ([https://docs.dapr.io/operations/security/](https://docs.dapr.io/operations/security/))，并且具有弹性
    ([https://docs.dapr.io/operations/resiliency/](https://docs.dapr.io/operations/resiliency/))，因为
    Dapr 侧车将强制执行服务身份和平台团队指定的规则，同时从所有启用了 Dapr 的应用程序和组件中提取指标。我建议平台团队熟悉 Dapr 项目，因为这个项目是为了解决团队在处理分布式应用程序时将面临的一些常见挑战而构建的。查看本章
    7.3.5 节，了解我们如何使我们的会议应用程序启用 Dapr。现在让我们谈谈功能标志。
- en: 7.3.4 Feature flags in action
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 功能标志的实际应用
- en: Feature flags enable teams to release software that includes new features without
    making those features available immediately. New features can be hidden behind
    feature flags that can be enabled later. In other words, feature flags allow teams
    to keep deploying new versions of their services or applications, and once these
    applications are running, features can be turned on or off based on the company’s
    needs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志使团队能够发布包含新功能的软件，同时不立即使这些功能可用。新功能可以隐藏在可以稍后启用的功能标志后面。换句话说，功能标志允许团队持续部署其服务或应用程序的新版本，一旦这些应用程序运行，可以根据公司的需求开启或关闭功能。
- en: Compared to application-level APIs, which directly enabled developers with out-of-the-box
    behaviors to implement complex features, feature flags can enable other teams
    that make business-related decisions on when features should be enabled to customers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接为开发者提供开箱即用行为的 API 相比，功能标志可以启用其他团队，这些团队在何时启用功能方面做出业务相关决策，并将这些决策传达给客户。
- en: While most companies might build mechanisms to implement feature flags, it is
    a well-recognized pattern to be encapsulated into a specialized service or library.
    In the Kubernetes world, you can consider using `ConfigMaps` as the simplest way
    to parameterize your containers. As soon as your container can read environment
    variables to turn on and off features, you are ready to go. We used this approach
    in chapter 2 with the `FEATURE_DEBUG_ENABLED=true` environment variable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数公司可能会构建机制来实现功能标志，但将其封装到专用服务或库中是一个公认的通用模式。在 Kubernetes 世界中，你可以考虑使用 `ConfigMaps`
    作为参数化容器的最简单方法。一旦你的容器能够读取环境变量来开启和关闭功能，你就可以开始了。我们在第 2 章中使用了这种方法，通过 `FEATURE_DEBUG_ENABLED=true`
    环境变量。
- en: Unfortunately, this approach is too simplistic and doesn’t work for real-world
    scenarios. First, one of the main reasons is that your containers will need to
    be restarted to reread the content of the ConfigMap if it changes. Second, you
    might need many flags for your different services, so you might need multiple
    ConfigMaps to manage your feature flags. Third, if you use environment variables,
    you will need to develop a convention to define each flag’s status, default values,
    and type, because you cannot get away with just defining variables as plain strings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法过于简单，不适用于现实世界的场景。首先，一个主要原因是如果 ConfigMap 发生变化，你的容器将需要重新启动以重新读取其内容。其次，你可能需要为不同的服务设置许多标志，因此你可能需要多个
    ConfigMaps 来管理你的功能标志。第三，如果你使用环境变量，你需要制定一个约定来定义每个标志的状态、默认值和类型，因为你不能仅仅通过定义变量作为普通字符串来解决问题。
- en: Because this is a well-understood problem, several companies have come up with
    tools and managed services like LaunchDarkly ([https://launchdarkly.com/](https://launchdarkly.com/))
    and Split ([https://www.split.io/product/feature-flags/](https://www.split.io/product/feature-flags/)),
    among others, which enable teams to host their feature flags in a remote service
    that offers simplified access to view and modify feature flags without the need
    for technical knowledge. For each of these services, to fetch and evaluate complex
    feature flags, you will need to download and add a dependency to your applications.
    As each feature flag provider will offer different functionalities, switching
    between providers would require many changes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个众所周知的问题，一些公司已经推出了工具和管理服务，如LaunchDarkly ([https://launchdarkly.com/](https://launchdarkly.com/))
    和Split ([https://www.split.io/product/feature-flags/](https://www.split.io/product/feature-flags/))
    等，这些服务使团队能够在提供简化访问以查看和修改功能标志的远程服务中托管其功能标志，而无需技术知识。对于这些服务中的每一个，要获取和评估复杂的功能标志，您需要下载并将依赖项添加到您的应用程序中。由于每个功能标志提供者将提供不同的功能，因此在不同提供者之间切换将需要许多更改。
- en: OpenFeature ([https://openfeature.dev/](https://openfeature.dev/)) is a CNCF
    initiative to unify how feature flags can be consumed and evaluated in cloud-native
    applications. In the same way that Dapr is abstracting how to interact with Statestores
    (storing and reading state) or PubSub (async message brokers) components, OpenFeature
    provides a consistent API to consume and evaluate feature flags no matter which
    features flag provider we use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFeature ([https://openfeature.dev/](https://openfeature.dev/)) 是一个CNCF倡议，旨在统一在云原生应用程序中消费和评估功能标志的方式。与Dapr抽象化与Statestores（存储和读取状态）或PubSub（异步消息代理）组件交互的方式相同，OpenFeature提供了一个一致的API，无论我们使用哪个功能标志提供者，都可以消费和评估功能标志。
- en: In this short section, we will look at a simple example using a ConfigMap to
    hold a set of feature flag definitions. We will also be using the `flagd` implementation
    provided by OpenFeature, but the beauty of this approach is that you can then
    swap the provider where the feature flags are stored without changing any single
    line of code in your application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个简单示例查看使用ConfigMap来保存一组功能标志定义的情况。我们还将使用OpenFeature提供的`flagd`实现，但这种方法的美妙之处在于，您可以在不更改应用程序中任何一行代码的情况下，轻松地更换存储功能标志的提供者。
- en: Figure 7.22 shows a simple application including the OpenFeature SDK that is
    configured to connect to an OpenFeature provider—in this case, `flagd`, which
    is in charge of hosting our feature flag definitions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22展示了包含配置为连接到OpenFeature提供者的OpenFeature SDK的简单应用实例——在这种情况下，`flagd`负责托管我们的功能标志定义。
- en: '![](../../OEBPS/Images/07-22.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-22.png)'
- en: Figure 7.22 Consuming and evaluating feature flags from our application services
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 从我们的应用程序服务消费和评估功能标志
- en: For this simple example, our app is written in Go and uses the OpenFeature Go
    SDK to fetch feature flags from the `flagd` service. The `flagd` service for this
    example is configured to watch a Kubernetes `ConfigMap` that contains some complex
    feature flags definitions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们的应用程序是用Go编写的，并使用OpenFeature Go SDK从`flagd`服务获取功能标志。本例中的`flagd`服务配置为监视包含一些复杂功能标志定义的Kubernetes
    `ConfigMap`。
- en: While this is a simple example, it allows us to see how a service like `flagd`
    can allow us to abstract away all the complexities of the storage and implementation
    of the mechanisms needed to provide a feature flag capability as part of our platform.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的示例，但它使我们能够看到像`flagd`这样的服务如何使我们能够抽象出作为我们平台一部分提供功能标志能力所需的所有存储和实现机制的复杂性。
- en: In contrast with Dapr, the OpenFeature SDK is needed because we are not only
    fetching the feature flag definitions but also performing evaluations that can
    involve complex feature flags.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与Dapr相比，OpenFeature SDK是必需的，因为我们不仅获取功能标志定义，还执行可能涉及复杂功能标志的评估。
- en: You can hook every service in your application to connect to an OpenFeature
    provider to perform feature flag evaluations. An important difference with just
    using plain ConfigMaps is that by using OpenFeature, containers don’t need to
    be restarted to fetch values if they change; that is now the responsibility of
    the OpenFeature flag provider.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将应用程序中的每个服务连接到OpenFeature提供者以执行功能标志评估。与仅使用纯ConfigMap相比，一个重要的区别是，通过使用OpenFeature，如果容器中的值发生变化，则不需要重新启动容器来获取值；现在这是OpenFeature标志提供者的责任。
- en: In the next section, we look at how to apply both Dapr and OpenFeature to the
    Conference application walking skeleton.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将 Dapr 和 OpenFeature 应用于会议应用程序的原型。
- en: 7.3.5 Updating our Conference application to consume application-level platform
    capabilities
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.5 更新我们的会议应用程序以使用应用程序级平台功能
- en: Conceptually and from a platform perspective, it will be great to consume all
    these capabilities without the platform leaking which tools are used to implement
    different behaviors. This would enable the platform team to change/swap implementations
    and reduce the cognitive load from teams using these capabilities. But as we discussed
    with Kubernetes, understanding how these tools work, their behaviors, and how
    their functionalities were designed influences how we architect our applications
    and services. In this last section of the chapter, I wanted to show how tools
    like Dapr and OpenFeature can influence your application architecture and, at
    the same time, show how these tools offer building blocks to create higher-level
    abstractions to reduce consumers’ cognitive load.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上和平台角度来看，在不泄露实现不同行为所使用的工具的情况下，使用所有这些功能将非常棒。这将使平台团队能够更改/交换实现，并减少使用这些功能的团队的认知负荷。但正如我们与
    Kubernetes 讨论的那样，了解这些工具的工作原理、它们的行为以及它们的功能是如何设计的，会影响我们构建应用程序和服务的方式。在本章的最后部分，我想展示像
    Dapr 和 OpenFeature 这样的工具如何影响你的应用程序架构，同时展示这些工具如何提供构建块来创建更高级的抽象，以减少消费者的认知负荷。
- en: 'For our Conference application, we can use the following Dapr components, so
    let’s focus on these:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的会议应用程序，我们可以使用以下 Dapr 组件，因此让我们关注这些：
- en: '*Dapr Statestore component:* Using the Statestore component APIs enables us
    to remove the Redis dependency from the Agenda service included in the Conference
    application. If, for some reason, we want to swap Redis for another persistent
    store, we will be able to do so without changing any of the application code.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dapr 状态存储组件*：使用状态存储组件 API 可以使我们从会议应用程序中包含的议程服务中移除 Redis 依赖。如果出于某种原因，我们想用另一个持久存储替换
    Redis，我们将能够做到这一点，而无需更改任何应用程序代码。'
- en: '*Dapr PubSub component:* For emitting events, we can replace the Kafka client
    from all the services to use the PubSub component APIs, allowing us to test different
    implementations, such as RabbitMQ or a cloud provider service to exchange asynchronous
    messages between applications.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dapr PubSub 组件*：对于发出事件，我们可以用 PubSub 组件 API 替换所有服务中的 Kafka 客户端，使我们能够测试不同的实现，例如
    RabbitMQ 或云提供商服务，以在应用程序之间交换异步消息。'
- en: '*Dapr service-to-service invocations and Dapr resiliency policies:* If we use
    the service-to-service invocation APIs, we can configure resiliency policies between
    the services without adding a library or custom code to our services code. By
    default, all services have resiliency policies defined if no custom configuration
    is provided.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dapr 服务间调用和 Dapr 弹性策略*：如果我们使用服务间调用 API，我们可以在不向我们的服务代码添加库或自定义代码的情况下配置服务之间的弹性策略。默认情况下，如果没有提供自定义配置，所有服务都有弹性策略定义。'
- en: While we can choose to use the Statestore component APIs also to remove the
    PostgreSQL dependency in our Call for Proposals service, I have chosen not to
    do so to support the use of SQL and PostgreSQL features that the team needed for
    this service. When adopting Dapr, you must avoid pushing for an “all or nothing”
    approach.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以选择使用状态存储组件 API 也从我们的提案征集服务中移除 PostgreSQL 依赖，但我选择不这样做，以支持团队为该服务所需的 SQL
    和 PostgreSQL 功能。在采用 Dapr 时，你必须避免采取“全有或全无”的方法。
- en: Let’s look at how the application will change if we decide to use Dapr. Figure
    7.23 shows the application services using Dapr components, because all the services
    are annotated to use Dapr, and the `daprd` sidecar has been injected all services.
    Once the PubSub and Statestore components have been configured, they can be accessed
    by the Call for Proposals service, Agenda service, and Notifications service.
    Finally, a Dapr Subscription pushes events to the Frontend application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们决定使用 Dapr，应用程序将如何改变。图 7.23 显示了使用 Dapr 组件的应用程序服务，因为所有服务都被注释为使用 Dapr，并且
    `daprd` 伴随容器已经注入到所有服务中。一旦配置了 PubSub 和状态存储组件，它们就可以被提案征集服务、议程服务和通知服务访问。最后，Dapr 订阅将事件推送到前端应用程序。
- en: '![](../../OEBPS/Images/07-23.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23](../../OEBPS/Images/07-23.png)'
- en: Figure 7.23 Using Dapr components for our walking skeleton / Conference application
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 使用 Dapr 组件构建我们的原型/会议应用程序
- en: Resiliency policies can also be configured and defined for the Call for Proposals
    service to interact with the agenda and notifications services, as shown in figure
    7.24.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为“提案征集”服务配置和定义弹性策略，以与议程和通知服务交互，如图 7.24 所示。
- en: '![](../../OEBPS/Images/07-24.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.24](../../OEBPS/Images/07-24.png)'
- en: Figure 7.24 Service-to-service interactions can be handled by the `daprd` sidecar,
    allowing platform teams to define different resiliency policies.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 显示了服务到服务的交互可以通过 `daprd` 侧边车来处理，允许平台团队能够定义不同的弹性策略。
- en: Dapr applies default resiliency policies if we don’t configure any. These resiliency
    policies also apply to, for our example, contacting the `statestore` and `pubsub`
    components. This means that not only our service-to-service invocations are resilient,
    but every time our application code wants to interact with infrastructure components
    such as databases, caches and message brokers, the resiliency policies will kick
    in.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不进行配置，Dapr 将应用默认的弹性策略。这些弹性策略也适用于我们的示例，例如，联系 `statestore` 和 `pubsub` 组件。这意味着不仅我们的服务到服务的调用是弹性的，而且每次我们的应用程序代码想要与数据库、缓存和消息代理等基础设施组件交互时，弹性策略都会启动。
- en: The application code needs to change slightly, because when services want to
    talk to each other, they need to use the Dapr API to use resiliency policies.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码需要稍作修改，因为当服务想要相互通信时，它们需要使用 Dapr API 来使用弹性策略。
- en: Finally, because we wanted to enable all the services to use feature flags,
    each service now includes the OpenFeature SDK, which allows the platform team
    to define which feature flag implementation all services will use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们希望所有服务都能使用功能标志，所以每个服务现在都包含了 OpenFeature SDK，这使得平台团队能够定义所有服务将使用哪种功能标志实现。
- en: In figure 7.25 each service has included the OpenFeature SDK library and is
    configured to point to the `flagd` service that enables the platform team to configure
    the mechanism used to store, fetch, and manage all the feature flags used by all
    the services.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.25 中，每个服务都包含了 OpenFeature SDK 库，并配置为指向 `flagd` 服务，这使得平台团队能够配置用于存储、检索和管理所有服务使用的所有功能标志的机制。
- en: '![](../../OEBPS/Images/07-25.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.25](../../OEBPS/Images/07-25.png)'
- en: Figure 7.25 Services using the `flagd` feature flag provider.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25 显示了使用 `flagd` 功能标志提供者的服务。
- en: Using the OpenFeature SDK, we can change the feature flag provider without changing
    our application code. The OpenFeature SDK now standardizes all the feature flag
    consumption and evaluation of our service code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenFeature SDK，我们可以更改功能标志提供者，而无需更改我们的应用程序代码。OpenFeature SDK 现在标准化了我们服务代码的所有功能标志消费和评估。
- en: While in Dapr, using the SDK is optional (because you can always craft your
    HTTP or GRPC requests by hand), in OpenFeature, the scenario is a bit more complicated.
    because the SDKs provide some of the evaluation logic to understand which type
    each flag is and if it is on or off.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Dapr 中使用 SDK 是可选的（因为你可以手动制作 HTTP 或 GRPC 请求），但在 OpenFeature 中，情况要复杂一些。因为 SDKs
    提供了一些评估逻辑，以了解每个标志的类型以及它是开启还是关闭。
- en: The step-by-step tutorial ([https://github.com/salaboy/platforms-on-k8s/tree/v2.0.0/chapter-7](https://github.com/salaboy/platforms-on-k8s/tree/v2.0.0/chapter-7))
    deploys version v2.0.0 of the conference application that uses Dapr and OpenFeature
    flags to enable application teams to keep evolving the application services. Version
    v2.0.0 of the application services doesn’t include the Kafka or Redis client to
    interact with infrastructure. These services can be deployed in different environments
    (including cloud providers) and wired against different implementations of these
    standard APIs. Figure 7.26 shows the dependencies that we managed to remove for
    version v2.0.0 of the application using the Dapr component APIs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步教程([https://github.com/salaboy/platforms-on-k8s/tree/v2.0.0/chapter-7](https://github.com/salaboy/platforms-on-k8s/tree/v2.0.0/chapter-7))部署了使用
    Dapr 和 OpenFeature 标志的会议应用程序的 v2.0.0 版本，以便应用程序团队能够不断演进应用程序服务。应用程序服务的 v2.0.0 版本不包括
    Kafka 或 Redis 客户端以与基础设施交互。这些服务可以在不同的环境中（包括云提供商）部署，并针对这些标准 API 的不同实现进行连接。图 7.26
    显示了我们使用 Dapr 组件 API 为应用程序的 v2.0.0 版本管理的依赖关系。
- en: '![](../../OEBPS/Images/07-26.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.26](../../OEBPS/Images/07-26.png)'
- en: Figure 7.26 Kafka and Redis client removed from services’ dependencies.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26 显示了从服务的依赖中移除了 Kafka 和 Redis 客户端。
- en: From a platform perspective, three Kubernetes resources are defined by the Dapr
    Statestore component, the Dapr PubSub component, and the Dapr Subscription.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从平台的角度来看，Dapr Statestore 组件、Dapr PubSub 组件和 Dapr 订阅定义了三个 Kubernetes 资源。
- en: We’ve already seen in section 7.3.1 how a Dapr Statestore component is defined.
    In listing 7.2, we can see how a PubSub component is defined, in this case selecting
    the type to be `pubsub.kafka`, which uses the Kafka instance installed using Helm.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 7.3.1 节中看到如何定义 Dapr Statestore 组件。在列表 7.2 中，我们可以看到如何定义 PubSub 组件，在这种情况下选择类型为
    `pubsub.kafka`，它使用通过 Helm 安装的 Kafka 实例。
- en: Listing 7.2 Dapr PubSub component definition
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 Dapr PubSub 组件定义
- en: '[PRE4]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① We need to specify the Kafka brokers available for the PubSub component to
    connect to.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们需要指定 PubSub 组件可连接到的 Kafka 代理。
- en: ② By default, the Kafka Helm Chart provided by Bitnami doesn’t require authentication.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ② 默认情况下，Bitnami 提供的 Kafka Helm 图表不需要身份验证。
- en: You can find all the supported PubSub implementations on the official Dapr website
    ([https://docs.dapr.io/reference/components-reference/supported-pubsub/](https://docs.dapr.io/reference/components-reference/supported-pubsub/)).
    Finally, the Dapr Subscription resources allow us to declaratively configure subscriptions
    to PubSub components and route events to the application’s endpoints, as shown
    in listing 7.3.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方 Dapr 网站上找到所有支持的 PubSub 实现（[https://docs.dapr.io/reference/components-reference/supported-pubsub/](https://docs.dapr.io/reference/components-reference/supported-pubsub/)）。最后，Dapr
    订阅资源允许我们声明性地配置对 PubSub 组件的订阅并将事件路由到应用程序的端点，如列表 7.3 所示。
- en: Listing 7.3 Dapr Subscription definition
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 Dapr 订阅定义
- en: '[PRE5]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① The PubSub component where we want to register the subscription
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们想要注册订阅的 PubSub 组件
- en: ② The topic inside the PubSub component that the subscription will listen to
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ② 订阅将监听的 PubSub 组件内的主题
- en: ③ The route where the events received in the topic will be forwarded to by Dapr
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ③ Dapr 将事件转发到的路由
- en: ④ scopes allows us to define which Dapr applications are allowed to receive
    events from this subscription. In this case the only consumer is the frontend
    application. Scopes heavily relies on service identity to block messages from
    being forwarded to unauthorized services.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 范围允许我们定义哪些 Dapr 应用程序被允许接收此订阅的事件。在这种情况下，唯一的消费者是前端应用程序。范围严重依赖于服务身份来阻止消息转发到未经授权的服务。
- en: From an application developer perspective, the changes in v2.0.0 use the Dapr
    Go SDK to call the Dapr components API. For example, to read the state from the
    Statestore component, the Agenda service performs the call shown in listing 7.4.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序开发人员的角度来看，v2.0.0 版本中的更改使用 Dapr Go SDK 调用 Dapr 组件 API。例如，要从 Statestore 组件读取状态，Agenda
    服务执行列表 7.4 中所示的调用。
- en: Listing 7.4 Getting state from a Statestore using the Dapr SDK
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 使用 Dapr SDK 从 Statestore 获取状态
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① To store state, you only need to provide the Statestore component name configured
    in Dapr.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ① 要存储状态，您只需提供在 Dapr 中配置的 Statestore 组件名称。
- en: ② You also need to provide the key that you want to retrieve from the Statestore.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ② 您还需要提供您想要从 Statestore 中检索的密钥。
- en: The APIClient instance here is just a Dapr client that provides helpers to interact
    with the DAPR HTTP and GRPC APIs. Similarly, to store state, you can use the `SaveState`
    method; see listing 7.5.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的 APIClient 实例只是一个提供与 DAPR HTTP 和 GRPC API 交互的辅助器的 Dapr 客户端。同样，要存储状态，您可以使用
    `SaveState` 方法；请参阅列表 7.5。
- en: Listing 7.5 Saving state from a Statestore using the Dapr SDK
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 使用 Dapr SDK 从 Statestore 保存状态
- en: '[PRE7]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Same as before, we need to provide the Statestore component name. Notice that
    applications can have access to multiple Statestore components for different purposes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ① 与之前相同，我们需要提供 Statestore 组件名称。请注意，应用程序可以访问多个 Statestore 组件，用于不同的目的。
- en: ② The KEY will be used to store the payload, so it can then be retrieved by
    calling GetState method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ② KEY 将用于存储有效负载，然后可以通过调用 GetState 方法检索。
- en: ③ The state is sent to the APIs as a JSON payload.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 状态作为 JSON 有效负载发送到 API。
- en: Finally, and following exactly the same approach, applications can publish events
    to the PubSub component by using the API shown in listing 7.6.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，采用完全相同的方法，应用程序可以通过使用列表 7.6 中所示的 API 将事件发布到 PubSub 组件。
- en: Listing 7.6 Publishing an event using the Dapr SDK
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 使用 Dapr SDK 发布事件
- en: '[PRE8]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① To publish an event, we need to specify the Dapr PubSub component that we
    want to use as well as the topic.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ① 要发布事件，我们需要指定我们想要使用的 Dapr PubSub 组件以及主题。
- en: ② The topic allows us to divide the PubSub component into different logical
    buckets that the application can use to exchange events and messages.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ② 该主题使我们能够将 PubSub 组件划分为不同的逻辑桶，应用程序可以使用这些桶来交换事件和消息。
- en: ③ The event payload is expressed as JSON.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 事件有效负载以 JSON 格式表示。
- en: On the OpenFeature side, the feature flag configurations are defined inside
    a ConfigMap ([https://github.com/salaboy/platforms-on-k8s/blob/v2.0.0/conference-application/helm/conference-app/templates/openfeature.yaml#L49](https://github.com/salaboy/platforms-on-k8s/blob/v2.0.0/conference-application/helm/conference-app/templates/openfeature.yaml#L49)).
    The tutorial shows three different feature flags added to the Conference application
    to control frontend and backend features. By modifying the ConfigMap that contains
    the flag definitions, we can change the application behavior without the need
    to restart any container. The `eventsEnabled` feature flag in listing 7.7 shows
    a feature flag of type Object that contains properties for each of the services.
    By defining different variants, we can codify profiles, allowing us to define
    complex scenarios.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenFeature 方面，功能标志配置定义在一个 ConfigMap 中 ([https://github.com/salaboy/platforms-on-k8s/blob/v2.0.0/conference-application/helm/conference-app/templates/openfeature.yaml#L49](https://github.com/salaboy/platforms-on-k8s/blob/v2.0.0/conference-application/helm/conference-app/templates/openfeature.yaml#L49))。教程展示了添加到会议应用程序中的三个不同功能标志，以控制前端和后端功能。通过修改包含标志定义的
    ConfigMap，我们可以更改应用程序行为，而无需重新启动任何容器。列表 7.7 中的 `eventsEnabled` 功能标志显示了一个包含每个服务属性的
    Object 类型功能标志。通过定义不同的变体，我们可以将配置文件编码化，从而允许我们定义复杂的场景。
- en: Listing 7.7 Feature flag definitions, including variants
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 功能标志定义，包括变体
- en: '[PRE9]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7.7 shows an Object feature flag that defines three variants: `all`,
    `decisions-only`, and `none`. By changing the `defaultVariant` property, we can
    change which profile is selected, in this case to enable and disable which services
    will emit events. Inside the Agenda service source code, we use the OpenFeature
    GO SDK to fetch and evaluate the flag, as shown in the following listing.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 展示了一个对象功能标志，它定义了三个变体：`all`、`decisions-only` 和 `none`。通过更改 `defaultVariant`
    属性，我们可以更改所选的配置文件，在这种情况下是启用和禁用哪些服务将发出事件。在议程服务源代码内部，我们使用 OpenFeature GO SDK 来获取和评估标志，如下所示。
- en: Listing 7.8 Feature flag evaluation using OpenFeature SDK
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 使用 OpenFeature SDK 进行功能标志评估
- en: '[PRE10]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 7.8 shows using the OpenFeature client to fetch the `eventsEnabled`
    feature. The `EventsEnabled{}` struct is the default value that should return
    in case there is a problem fetching the feature flag. Finally, the `EvaluationContext`
    struct allows you to add extra parameters for OpenFeature to evaluate the flag
    for more complex scenarios.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 展示了使用 OpenFeature 客户端获取 `eventsEnabled` 功能标志。`EventsEnabled{}` 结构是当获取功能标志出现问题时应该返回的默认值。最后，`EvaluationContext`
    结构允许你为 OpenFeature 添加额外的参数，以便在更复杂的场景中评估标志。
- en: You can find the differences between `v1.0.0` and `v2.0.0` by comparing the
    `main` branch and the `v2.0.0` branch in the application repository at [https://github.com/salaboy/platforms-on-k8s/compare/v2.0.0](https://github.com/salaboy/platforms-on-k8s/compare/v2.0.0).
    At the same time, the platform team is free to configure and wire up application
    infrastructure and define all the backing mechanisms and implementations for feature
    flags, storage, messaging, configuration, managing credentials, resiliency, and
    other common challenges they don’t want to expose directly to developers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过比较应用程序存储库中的 `main` 分支和 `v2.0.0` 分支来找到 `v1.0.0` 和 `v2.0.0` 之间的差异。[https://github.com/salaboy/platforms-on-k8s/compare/v2.0.0](https://github.com/salaboy/platforms-on-k8s/compare/v2.0.0)。同时，平台团队可以自由配置和连接应用程序基础设施，并定义所有支持机制和功能标志、存储、消息传递、配置、管理凭证、弹性和其他他们不想直接向开发者暴露的常见挑战的实现。
- en: 7.4 Linking back to platform engineering
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 返回到平台工程
- en: In this chapter, we have seen how to enable teams with platform-wide capabilities
    in the form of APIs. We aim to speed up their process of writing and delivering
    complex software by providing teams with common and standard APIs to solve everyday
    challenges when creating distributed applications and mechanisms such as feature
    flags.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何以 API 的形式为具有平台级能力的团队启用功能。我们旨在通过为团队提供解决日常挑战的通用和标准 API 来加速他们编写和交付复杂软件的过程，这些挑战包括创建分布式应用程序和机制，如功能标志。
- en: By separating application infrastructure from the application’s code, we not
    only remove dependencies from our services, but we also enable the platform team
    to decide how to configure application infrastructure components and how the services
    will connect to them. If different environments require different implementations,
    the platform team can work behind the APIs to provide different configurations
    for different scenarios.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将应用基础设施与应用代码分离，我们不仅从我们的服务中移除了依赖，还使平台团队能够决定如何配置应用基础设施组件以及服务如何连接到它们。如果不同的环境需要不同的实现，平台团队能够在API背后工作，为不同的场景提供不同的配置。
- en: Figure 7.27 shows how we can reduce friction and dependencies related to the
    application infrastructure. This allows our application’s services to work in
    various environments the platform team can control. Using projects like Dapr,
    you also gain portability of your applications across cloud providers, consistent
    APIs that can be used from any programming language, and you enable teams to bring
    their applications from a local development environment to production environments,
    allowing the platform team to wire up the infrastructure that your application
    needs to work. With feature flags, we enable developers to keep releasing software
    by masking features behind feature flags that can be turned on and off, enabling
    other teams closer to customers (like product teams) to decide when these features
    should be exposed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27展示了我们如何减少与应用基础设施相关的摩擦和依赖。这允许我们的应用服务在各种平台团队能够控制的环境中工作。使用像Dapr这样的项目，你还可以获得跨云提供商的应用可移植性，一致的API，这些API可以从任何编程语言中使用，并使团队能够将他们的应用从本地开发环境带到生产环境，允许平台团队能够连接起应用运行所需的基础设施。通过功能标志，我们使开发者能够通过隐藏在可开关的功能标志背后的功能来持续发布软件，从而让更接近客户的团队（如产品团队）决定何时应该公开这些功能。
- en: '![](../../OEBPS/Images/07-27.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-27.png)'
- en: Figure 7.27 Consistent capabilities across environments enable smoother paths
    to production.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27 在环境中提供一致的能力，使通往生产的路径更加顺畅。
- en: By providing consistent capabilities across environments, we enable easier paths
    to production, because we can control which features are exposed to customers
    after releasing the new version to production. Developers can keep building features
    relying on platform-provided application-level APIs without knowing where the
    available infrastructure is or which versions of databases and message brokers
    are used in the production environment.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在环境中提供一致的能力，我们使通往生产的路径更加容易，因为我们可以在将新版本发布到生产后控制向客户公开哪些功能。开发者可以继续构建功能，依赖于平台提供的应用级API，而无需知道可用的基础设施在哪里，或者生产环境中使用了哪些数据库和消息代理的版本。
- en: For the sake of space, topics such as observability, metrics, and logs, service
    meshes haven’t been covered in these sections, because these capabilities are
    currently more mature and more operations-focused. I’ve decided to focus on capabilities
    that build on top of the operation and infrastructure teams to speed up development
    teams and solve everyday challenges. Platform teams will define which observability
    stack they will use across environments early and how this data can be available
    to developers troubleshooting problems. Service meshes and certificate rotation
    tools for mutual TLS (encryption between services) are often discussed in these
    conversations because these are topics that development teams will not want to
    spend time on and should be provided at the platform level. Figure 7.28 shows
    how our platform is responsible for defining, fetching, and aggregating data from
    the tools available inside each environment. Our platform should provide a single
    entry point to understand what is happening in different environments and provide
    teams with enough information to troubleshoot problems and access the tools the
    organization needs to deliver software to customers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，关于可观察性、指标和日志，以及服务网格等主题在这些部分中没有涉及，因为这些功能目前更加成熟，更侧重于运营。我决定专注于建立在运营和基础设施团队之上的功能，以加快开发团队的进度并解决日常挑战。平台团队将提前定义他们将在各个环境中使用的可观察性堆栈，以及这些数据如何可供开发者在解决问题时使用。在讨论中经常提到的服务网格和用于相互TLS（服务之间的加密）的证书轮换工具，因为这些是开发团队不希望花费时间的话题，并且应该在平台级别提供。图
    7.28 展示了我们的平台如何负责定义、检索和聚合每个环境中可用的工具数据。我们的平台应提供一个单一的入口点来了解不同环境中正在发生的事情，并为团队提供足够的信息来解决问题并访问组织交付软件给客户所需的工具。
- en: '![](../../OEBPS/Images/07-28.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.28](../../OEBPS/Images/07-28.png)'
- en: Figure 7.28 The platform that we build needs to define, manage, and monitor
    the tools available in each environment.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.28 我们构建的平台需要定义、管理和监控每个环境中可用的工具。
- en: The next chapter will explore tools to enable teams to experiment while releasing
    software. Along the same lines of using feature flags, we will dig deeper into
    how to use different release strategies to catch problems earlier in the release
    process and enable stakeholders to try different approaches simultaneously.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨使团队能够在发布软件时进行实验的工具。沿着使用功能标志的相同思路，我们将更深入地探讨如何使用不同的发布策略来在发布过程中更早地发现问题，并使利益相关者能够同时尝试不同的方法。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Moving dependencies to application infrastructure enables application code to
    stay agnostic to platform-wide upgrades. Separating the lifecycle of the applications
    and the infrastructure enables teams to rely on stable APIs instead of dealing
    with provider-specific clients and drivers for everyday use cases.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖项移动到应用程序基础设施中，使应用程序代码能够保持对平台级升级的无感知。将应用程序和基础设施的生命周期分开，使团队能够依赖稳定的API，而不是在日常用例中处理特定供应商的客户端和驱动程序。
- en: Treating edge cases separately allows experts to make more conscious cases based
    on their application requirements. This also allows common scenarios to be handled
    by less experienced team members, who don’t need to understand the specifics of
    tools like vendor-specific database features or low-level message broker configurations
    when they only want to store or read data or emit events from their application’s
    code.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将边缘情况单独处理，使专家能够根据其应用需求做出更自觉的案例。这也允许经验较少的团队成员处理常见场景，当他们只想从应用程序代码中存储或读取数据或发出事件时，他们不需要了解工具的具体细节，例如供应商特定的数据库功能或低级消息代理配置。
- en: Dapr solves common and shared concerns when building distributed applications.
    Developers that can write HTTP/GRPC requests can interact with infrastructure
    that the platform team will wire up.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dapr在构建分布式应用程序时解决常见和共享的担忧。能够编写HTTP/GRPC请求的开发者可以与平台团队将连接的基础设施进行交互。
- en: Feature flags enable developers to keep releasing software by masking new features
    behind feature flags that can be turned on and off.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能标志使开发者能够通过隐藏在可以开启和关闭的功能标志后面的新功能来持续发布软件。
- en: OpenFeature standardizes the way applications consume and evaluate feature flags.
    Relying on OpenFeature abstractions allows platform teams to decide where feature
    flags are stored and how they are managed. Different providers can offer non-technical
    people dashboards where they can see and manipulate flags.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenFeature 标准化了应用程序消费和评估功能标志的方式。依赖 OpenFeature 抽象允许平台团队决定功能标志的存储位置以及如何管理它们。不同的提供商可以为非技术人员提供仪表板，让他们可以查看和操作标志。
- en: If you followed the step-by-step tutorial, you gained hands-on experience in
    using tools like Dapr and OpenFeature in the context of a cloud-native application
    composed of four services that interact with SQL and NoSQL databases and a message
    broker like Kafka. You also modified feature flags on a running application to
    change its behavior without restarting any of its components.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你遵循了逐步教程，你将在云原生应用程序的上下文中获得使用工具如 Dapr 和 OpenFeature 的实践经验，该应用程序由四个服务组成，这些服务与
    SQL 和 NoSQL 数据库以及像 Kafka 这样的消息代理进行交互。你还修改了运行中的应用程序上的功能标志，以改变其行为而无需重新启动其任何组件。
