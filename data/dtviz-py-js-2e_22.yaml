- en: Chapter 16\. Building a Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 16 章\. 构建可视化
- en: In [Chapter 15](ch15.xhtml#chapter_imagining), we used the results of our pandas
    exploration of the Nobel Prize dataset (see [Chapter 11](ch11.xhtml#chapter_pandas_exploring))
    to imagine a visualization. [Figure 16-1](#d3build_target) shows the visualization
    we imagined, and in this chapter we’ll see how to go about building it, leveraging
    the power of JavaScript and D3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 15 章](ch15.xhtml#chapter_imagining)中，我们利用了我们对诺贝尔奖数据集的pandas探索的结果（参见[第 11
    章](ch11.xhtml#chapter_pandas_exploring)），来想象一个可视化效果。[图 16-1](#d3build_target)展示了我们想象的可视化效果，在本章中，我们将看到如何构建它，利用JavaScript和D3的强大功能。
- en: '![dpj2 1601](assets/dpj2_1601.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 1601](assets/dpj2_1601.png)'
- en: Figure 16-1\. Our target, a Nobel Prize visualization
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-1\. 我们的目标，诺贝尔奖可视化
- en: I’ll show how the visual elements we conceived combine to transform our freshly
    cleaned and processed Nobel dataset into an interactive web visualization, deployable
    to billions of devices at the flick of a switch. But before going into the details,
    let’s have a look at the core components of a modern web visualization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示我们构想的视觉元素如何结合，将我们新鲜清理和处理的诺贝尔数据集转换为交互式网络可视化，可以轻松部署到数十亿设备上。但在深入细节之前，让我们先看看现代网络可视化的核心组件。
- en: Preliminaries
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before beginning to build the Nobel visualization, let’s consider the core components
    that will be used and how we will organize our files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建诺贝尔奖可视化之前，让我们考虑将使用的核心组件以及如何组织我们的文件。
- en: Core Components
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心组件
- en: 'As we saw in [“A Basic Page with Placeholders”](ch04.xhtml#webdev101_basic_page),
    building a modern web visualization requires four key components:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[“一个基本页面带有占位符”](ch04.xhtml#webdev101_basic_page)中所看到的，构建现代网络可视化需要四个关键组件：
- en: An HTML skeleton upon which to hang our JavaScripted creation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HTML框架，用于支撑我们的JavaScript创建
- en: One or more CSS files to govern the look and feel of the dataviz
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个CSS文件来控制数据可视化的外观和感觉
- en: The JavaScript files themselves, including any third-party libraries you might
    need (D3 being our biggest dependency)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 文件本身，包括可能需要的任何第三方库（D3 是我们最大的依赖项）
- en: And last but not least, the data to be transformed, ideally in the JSON or CSV
    (if wholly static data) format
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，将要转换的数据，理想情况下是JSON或CSV格式（如果是完全静态数据）
- en: Before we start looking at our dataviz components, let’s get the file structure
    for our Nobel Prize visualization (Nobel-viz) project in place and establish how
    we’re going to feed data to our visualization.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看数据可视化组件之前，让我们先为我们的诺贝尔奖可视化（Nobel-viz）项目准备好文件结构，并确定如何向可视化提供数据。
- en: Organizing Your Files
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织您的文件
- en: '[Example 16-1](#nviz_files) shows the structure of our project directory. By
    convention we have an *index.xhtml* file in the root directory with a *static*
    directory containing all the libraries and assets (images and data) used for our
    visualization.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-1](#nviz_files)展示了我们项目目录的结构。按照惯例，我们在根目录下有一个*index.xhtml*文件，其中包含所有用于可视化的库和资产（图像和数据）的*static*目录。'
- en: Example 16-1\. Our Nobel-viz project’s file structure
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-1\. 我们的诺贝尔奖可视化项目的文件结构
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO1-1)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO1-1)'
- en: The static data files we’ll be using, including a TopoJSON world map (see [Chapter 19](ch19.xhtml#chapter_d3_maps))
    and the country data we grabbed from the web (see [“Getting Country Data for the
    Nobel Dataviz”](ch05.xhtml#country_data)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的静态数据文件，包括TopoJSON世界地图（详见[第 19 章](ch19.xhtml#chapter_d3_maps)）和从网络上抓取的国家数据（详见[“获取诺贝尔数据可视化的国家数据”](ch05.xhtml#country_data)）。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO1-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO1-2)'
- en: The Nobel Prize winners’ photos we scraped using Scrapy in [“Scraping Text and
    Images with a Pipeline”](ch06.xhtml#scraping_bio).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Scrapy爬取的诺贝尔奖获奖者的照片，详见[“使用管道进行文本和图像爬取”](ch06.xhtml#scraping_bio)。
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO1-3)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_building_a_visualization_CO1-3)'
- en: The *js* subdirectory contains our Nobel-viz JavaScript module files (*.mjs*),
    separated into core elements and starting with *nbviz_*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*js*子目录包含我们的Nobel-viz JavaScript模块文件（*.mjs*），分为核心元素，并以*nbviz_*开头。'
- en: Serving the Data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供数据
- en: The full Nobel dataset with the mini-biographies that we scraped in [Chapter 6](ch06.xhtml#chapter_heavy_scraping)
    amounts to around three megabytes of data, considerably less when compressed for
    web transport. By the standards of modern web pages, that’s not a huge amount
    of data. In fact, average web page size is somewhere around 2MB to 3MB.^([1](ch16.xhtml#idm45607751186112))
    Nevertheless it’s approaching a point where we might consider breaking it into
    smaller chunks that could be loaded on a need-to-use basis. We could also serve
    the data dynamically from a web server (see [Chapter 13](ch13.xhtml#chapter_delivery_restful))
    with a database like SQLite. As it is, the small inconvenience of an initial wait
    time is compensated by speedy performance thereafter, as all the data is cached
    by the browser. It also makes things a lot simpler having just one initial fetching
    of data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 6 章](ch06.xhtml#chapter_heavy_scraping)中抓取的包含小传的完整诺贝尔数据集大约有三兆字节的数据，在网络传输时经过压缩后则显著减少。按照现代网页的标准，这并不算是一大量的数据。实际上，平均网页大小大约在
    2MB 到 3MB 之间^([1](ch16.xhtml#idm45607751186112))。尽管如此，它接近一个我们可能需要考虑将其分成更小的块以便根据需要加载的点。我们也可以使用像
    SQLite 这样的数据库从 web 服务器动态提供数据（参见[第 13 章](ch13.xhtml#chapter_delivery_restful)）。正如现在这样，初始等待时间的小不便被浏览器缓存所有数据后的高速性能所补偿。而且只需最初获取一次数据使事情变得简单多了。
- en: 'For our Nobel visualization we’ll serve all the data from a data directory
    (see [Example 16-1](#nviz_files), #2), fetched as the app is initialized.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的诺贝尔可视化，我们将从数据目录中提供所有数据（见[示例 16-1](#nviz_files)，＃2），在应用程序初始化时获取。
- en: The HTML Skeleton
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML 骨架
- en: Although our Nobel visualization has a number of dynamic components, the HTML
    skeleton required is surprisingly simple. This demonstrates a core theme of the
    book—that you need very little conventional web development to set the stage for
    programming data visualizations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的诺贝尔可视化有许多动态组件，但所需的 HTML 骨架却令人惊讶地简单。这展示了本书的一个核心主题——为了编程数据可视化，你并不需要非常传统的
    web 开发技能。
- en: 'The *index.xhtml* file, which creates the visualization on loading, is shown
    in [Example 16-2](#d3build_index). The three components are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.xhtml* 文件，在加载时创建可视化，在 [示例 16-2](#d3build_index) 中展示。三个组成部分是：'
- en: A CSS stylesheet *style.css*, setting fonts, content-block positions, and the
    like, is imported.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入了 CSS 样式表 *style.css*，设置字体、内容块位置等。
- en: HTML placeholders for our visual elements with IDs of the form `nobel-[foo]`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML 占位符用 ID 形式为 `nobel-[foo]` 的视觉元素。
- en: The JavaScript; first third-party libraries, then our original scripts.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript; 首先是第三方库，然后是我们的原始脚本。
- en: 'We’ll cover the individual HTML sections in detail in the coming chapters,
    but I wanted you to see what is essentially the entire nonprogrammatic element
    of the Nobel Prize visualization. With this skeleton in place, you can then turn
    to the job of creative programming, something D3 encourages and excels at. As
    you get used to defining your content blocks in HTML, and fixing dimensions and
    positioning with CSS, you’ll find you spend more and more time doing what you
    love best: manipulating data with code.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节详细介绍各个 HTML 部分，但我希望你能看到这个诺贝尔奖可视化的整体非编程元素。有了这个基本框架，你可以转向创意编程的工作，这正是
    D3 鼓励和擅长的。当你习惯于在 HTML 中定义内容块，并使用 CSS 固定尺寸和定位时，你会发现你越来越多地花时间做你最喜欢的事情：用代码操纵数据。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: I find it helpful to treat the identified placeholders, such as the map holder
    `<div id="nobel-map"></div>`, as panels *owned* by their respective elements.
    We set the dimension and relative positioning of these frames in the main CSS
    or JS^([2](ch16.xhtml#idm45607751164464)) file and the elements, such as our dynamic
    map, adapt themselves to the size of their frame. This allows a nonprogramming
    designer to change the look and feel of the visualization through CSS styling.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现将识别的占位符，如地图容器 `<div id="nobel-map"></div>`，视为其各自元素的*所有权* 是很有帮助的。我们在主 CSS
    或 JS^([2](ch16.xhtml#idm45607751164464)) 文件中设置这些框架的维度和相对定位，而动态地图等元素则根据其框架的大小自适应。这允许非编程设计师通过
    CSS 样式更改可视化的外观和感觉。
- en: Example 16-2\. The index.xhtml access file to our single-page visualization
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-2\. 我们的单页可视化访问文件 `index.xhtml`。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The HTML skeleton ([Example 16-2](#d3build_index)) defines the hierarchical
    structure of our Nobel-viz components, but their visual sizing and positioning
    are set in the *style.css* file. In the next section, we’ll see how this is done
    and look at the general styling of our visualization.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 框架（[示例 16-2](#d3build_index)）定义了我们 Nobel-viz 组件的层次结构，但它们的视觉大小和定位是在 *style.css*
    文件中设置的。在接下来的部分中，我们将看到这是如何完成的，并查看我们可视化的一般样式。
- en: CSS Styling
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS 样式
- en: We’ll deal with the styling of the individual chart components of our chart
    ([Figure 16-1](#d3build_target)) in their respective chapters. This section will
    cover the remaining nonspecific CSS, most importantly the sizing and positioning
    of our elements’ content blocks (*panels*).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在各自的章节中处理我们图表中各个图表组件的样式（[图 16-1](#d3build_target)）。本节将涵盖其余的非特定 CSS，最重要的是我们元素内容块（*面板*）的大小和定位。
- en: The size of a visualization can be a tricky choice. There are many more device
    formats out there these days, with smartphones, tablets, mobile devices, etc.
    having a variety of different resolutions, such as “retina,”^([3](ch16.xhtml#idm45607750526128))
    and full HD (1,920×1,080). So pixel sizes are much more varied than they used
    to be, and pixel density becomes a more meaningful metric. Most devices perform
    pixel scaling to compensate for this, which is why you can still read the text
    on a smartphone even though it has as many pixels as a large desktop monitor.
    Also, most handheld devices have pinch-and-zoom and pan, allowing the user to
    easily focus on regions of a larger dataviz. For our Nobel dataviz we’ll choose
    a compromise resolution of 1,280×800 pixels, which should look OK on most desktop
    monitors and be usable in landscape mode on a mobile device, including our 50-pixel-high
    top-most user controls.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化的大小是一个棘手的选择。现在有许多不同的设备格式，如智能手机、平板电脑、移动设备等，具有多种不同的分辨率，如“视网膜”^([3](ch16.xhtml#idm45607750526128))
    和全高清（1,920×1,080）。因此，像素尺寸比以前更加多样化，像素密度变得更具有意义。大多数设备执行像素缩放来进行补偿，这就是为什么您可以在智能手机上仍然阅读文字，即使它具有与大型桌面显示器相同数量的像素。此外，大多数手持设备具有捏缩放和平移功能，允许用户轻松关注较大数据可视化的区域。对于我们的
    Nobel 数据可视化，我们将选择一个折衷的分辨率 1,280×800 像素，这在大多数桌面监视器上看起来应该还行，并且在移动设备的横向模式下可用，包括我们
    50 像素高的顶部用户控件。
- en: 'First, we set some general styles we want applied to the whole document using
    the `body` selector; a sans-serif font, an off-white background, and some link
    detailing are specified. We also set the width of the visualization and its margins:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `body` 选择器设置了一些通用的样式，应用于整个文档；一个无衬线字体，浅白色背景和一些链接细节被指定。我们还设置了可视化的宽度和其边距：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO2-1)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO2-1)'
- en: This color is just off full-white (`#ffffff`) and should help to make the page
    slightly less bright and easier on the eyes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种颜色略偏白色（`#ffffff`），应有助于使页面稍微不那么亮，更易于眼睛。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO2-2)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO2-2)'
- en: The default underlined hyperlinks look a bit fussy in my opinion, so we remove
    decoration.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为默认的下划线超链接看起来有点繁琐，因此我们去掉了装饰。
- en: 'There are three main div content blocks to our Nobel-viz, which we position
    absolutely within the `#chart` div (their relative parent). These are the main
    title (`#title`) , some information on the visualization (`#info`), and the main
    container (`#nbviz`). The title and info are placed by eye and the main container
    is placed 90 pixels from the page top to allow them room, and given a width of
    100% to make it expand to the available space. The following CSS achieves this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 Nobel-viz 有三个主要的 div 内容块，它们绝对定位在 `#chart` div 内（它们的相对父元素）。这些是主标题（`#title`）、可视化信息（`#info`）和主容器（`#nbviz`）。标题和信息是凭眼观察放置的，而主容器距页面顶部90像素，以便为它们留出空间，并且宽度设置为100%以便扩展到可用空间。以下
    CSS 实现了这一点：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `chart-holder` is given a height of 750 px, a width of 100% its parent,
    and a `position` property of `relative`, meaning the absolute positioning of its
    child panels will be relative to its top-left corner. The bottom of our charts
    is padded by 20 pixels:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`chart-holder` 的高度设置为 750 像素，宽度设置为其父元素的 100%，并具有 `relative` 的 `position` 属性，这意味着其子面板的绝对定位将相对于其左上角。我们的图表底部填充了
    20 像素：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO3-1)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO3-1)'
- en: We want the SVG contexts for our components to expand to fit their containers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们组件的 SVG 上下文能够扩展以适应它们的容器。
- en: Allowing for the Nobel-viz’s height constraint of 750 pixels, the width/height
    ratio of two for our equirectangular map,^([4](ch16.xhtml#idm45607750213296))
    and the need to fit over 100 years’ worth of Nobel Prize circular indicators into
    our time chart, playing with the dimensions suggests [Figure 16-2](#d3build_dimensions)
    as a good compromise for the size of our visual elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Nobel-viz 的高度约束为 750 像素，我们的等经纬度地图的宽高比为二，^([4](ch16.xhtml#idm45607750213296))
    并且需要将 100 年以上的诺贝尔奖圆形指示器适应到我们的时间图表中，根据尺寸进行调整建议将 [图 16-2](#d3build_dimensions) 作为我们可视化元素大小的一个良好折衷。
- en: '![dpj2 1602](assets/dpj2_1602.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 1602](assets/dpj2_1602.png)'
- en: Figure 16-2\. The Nobel-viz’s dimensions
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-2\. Nobel-viz 的尺寸
- en: 'This CSS positions and sizes the components as shown in [Figure 16-2](#d3build_dimensions):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此 CSS 样式按照 [图 16-2](#d3build_dimensions) 所示的位置和大小组件。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO4-1)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO4-1)'
- en: We want absolute, manually adjusted positioning, relative to the `chart-holder`
    parent container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望绝对的手动调整位置，相对于 `chart-holder` 父容器。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO4-2)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO4-2)'
- en: The timeline runs the full width of the visualization.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴占据了可视化的整个宽度。
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO4-3)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_building_a_visualization_CO4-3)'
- en: You can use padding to let the components “breathe.”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用填充使组件有“呼吸空间”。
- en: The other CSS styles are specific to the individual components and will be covered
    in their respective chapters. With the preceding CSS, we have an HTML skeleton
    on which to flesh out our visualization with JavaScript.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 CSS 样式特定于各个组件，并将在各自的章节中进行介绍。通过前面的 CSS，我们在 HTML 骨架上使用 JavaScript 来丰富我们的可视化。
- en: The JavaScript Engine
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 引擎
- en: With a visualization of any size, it’s good to start imposing some modularity
    early on. Many of the D3 examples on the web^([5](ch16.xhtml#idm45607749985552))
    are one-page solutions, combining HTML, CSS, JS, and even data on one page. Though
    this is great for teaching by example, as the codebase increases, things will
    degenerate fast, making changes a slog and increasing the chance of namespace
    collisions and the like.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何尺寸的可视化中，早期实施一些模块化是很好的。网上许多 D3 的例子^([5](ch16.xhtml#idm45607749985552)) 都是单页面解决方案，将
    HTML、CSS、JS 甚至数据都结合在一个页面上。虽然这对通过示例教学很好，但随着代码库的增长，情况将迅速恶化，使得修改变得困难，并增加了命名空间冲突等问题的可能性。
- en: Importing the Scripts
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入脚本
- en: 'We include the JavaScript files for our visualization using `<script>` tags
    placed at the bottom of the `<body>` tag in our entry *index.xhtml* file, as shown
    in [Example 16-2](#d3build_index):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `<script>` 标签将 JavaScript 文件包含在我们入口的 *index.xhtml* 文件的 `<body>` 标签底部，如
    [示例 16-2](#d3build_index) 所示：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO5-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO5-1)'
- en: We use local copies of the third-party libraries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用第三方库的本地副本。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO5-2)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO5-2)'
- en: The main entry point for our Nobel app, where it requests its first datasets
    and sets the display ball rolling. This module imports all the others used by
    the visualization.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们诺贝尔应用的主入口点，它请求其第一个数据集并启动显示。该模块导入了可视化中使用的所有其他模块。
- en: Modular JS with Imports
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化的 JS 与导入
- en: 'In the first edition of this book, a common but rather hacky pattern was used
    to establish an `nbviz` namespace within which to place functions, variables,
    constants, etc. used by the various components of the Nobel dataviz. Here’s an
    example, as you may well run into similar patterns in the wild:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，为建立 `nbviz` 命名空间，以便在诺贝尔数据可视化的各个组件中放置函数、变量、常量等，采用了一种常见但相当巧妙的模式。这里是一个示例，因为您可能会在现实中遇到类似的模式：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO6-1)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO6-1)'
- en: Defining variables as global will prevent them triggering [JSLint errors](https://www.jslint.com).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量定义为全局变量将防止它们触发[JSLint 错误](https://www.jslint.com)。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO6-2)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO6-2)'
- en: Exposes this function to other scripts as part of shared `nbviz` namespace.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数作为共享 `nbviz` 命名空间的一部分暴露给其他脚本。
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO6-3)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_building_a_visualization_CO6-3)'
- en: Uses the `nbviz` object if available, and creates it otherwise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用，则使用 `nbviz` 对象，并在没有时创建它。
- en: Each JS script was encapsulated with this pattern and all required scripts were
    included with a `<script>` tag in the main *index.xhtml* entry point. With the
    arrival of cross-browser support for JS modules, we have a much cleaner, modern
    way of including our JavaScript with modular imports familiar to any Pythonista
    (see [“JavaScript Modules”](ch02.xhtml#sect_js_modules)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JS脚本都用这种模式封装，所有必需的脚本都包含在主 *index.xhtml* 的 `<script>` 标签中。随着跨浏览器支持JS模块的到来，我们有了一种更清洁、现代的方式来包含我们的JavaScript，这对于任何Pythonista都是熟悉的（参见
    [“JavaScript Modules”](ch02.xhtml#sect_js_modules)）。
- en: 'We now have only to include our main JS module in *index.xhtml*, and that will
    import all the other modules required:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需在 *index.xhtml* 中包含我们的主JS模块，这将导入所有其他所需的模块：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO7-1)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO7-1)'
- en: These are imported to initialize their update callbacks. We’ll see how that
    works later in the chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被导入以初始化它们的更新回调。我们将在本章后面看到这是如何工作的。
- en: In the coming chapters, the JavaScript/D3 used to produce the visualization’s
    elements will be explained in detail. First, we’ll deal with the flow of data
    through the Nobel-viz, from the (data) server to the client browser and within
    the client, driven by user interaction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将详细解释用于生成可视化元素的JavaScript/D3。首先，我们将处理数据从（数据）服务器流向客户端浏览器，并在客户端内部由用户交互驱动的Nobel-viz数据流。
- en: Basic Data Flow
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本数据流
- en: There are many ways to deal with data in a project of any complexity. For interactive
    apps, and particularly data visualizations, I find the most robust pattern is
    to have a central data object to cache current data. In addition to the cached
    data, we also have some active reflections or subsets of this dataset, stored
    in the main data object. For example, in our Nobel-viz a user can select a number
    of subsets of the data (e.g., only those winners in the Physics category).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 处理任何复杂项目中的数据有许多方法。对于交互式应用程序，特别是数据可视化，我发现最健壮的模式是拥有一个中央数据对象来缓存当前数据。除了缓存的数据外，我们还有一些主数据对象中存储的活动反映或子集。例如，在我们的Nobel-viz中，用户可以选择数据的多个子集（例如，只有物理类别的获奖者）。
- en: If a different data reflection is triggered by the user, such as by choosing
    the per capita prize metric, a flag^([6](ch16.xhtml#idm45607749683584)) is set
    (in this case, `valuePerCapita` is set to `0` or `1`). We then update all the
    visual components, and those that depend on `valuePerCapita` adapt accordingly.
    The size of the map indicators changes and the bar chart reorganizes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户触发了不同的数据反映，比如选择每人均奖金指标，一个标志^([6](ch16.xhtml#idm45607749683584))就会被设置（在这种情况下，`valuePerCapita`
    被设置为 `0` 或 `1`）。然后我们更新所有的视觉组件，依赖于 `valuePerCapita` 的那些组件会相应地适应。地图指示器的大小会改变，柱状图会重新组织。
- en: The key idea is to make sure the visual elements are synchronized to any user-driven
    data changes. A reliable way to do this is to have a single update method (here
    called `onDataChange`) that is called whenever a user does something to change
    the data. This method alerts all the active visual elements to the changed data
    and they respond accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是确保视觉元素与用户驱动的数据变化同步。做到这一点的一种可靠方法是拥有一个单一的更新方法（这里称为 `onDataChange`），每当用户执行某些操作以更改数据时就调用此方法。该方法通知所有活动的视觉元素数据已更改，它们会相应地做出响应。
- en: Let’s now see how the app’s code fits together, starting with the shared core
    utilities.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看应用程序的代码如何配合，从共享的核心工具开始。
- en: The Core Code
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心代码
- en: The first JavaScript file loaded is *nbviz_core.js*. This script contains any
    code we might want to share among the other scripts. For example, we have a `categoryFill`
    method that returns a specific color for each category. This is used by both the
    timeline component and as a border in the biography box. This core code includes
    functions we might want to isolate for testing, or simply to make other modules
    less cluttered.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个加载的JavaScript文件是 *nbviz_core.js*。该脚本包含了我们可能希望在其他脚本中共享的任何代码。例如，我们有一个 `categoryFill`
    方法，为每个类别返回特定的颜色。这被时间线组件使用，并作为传记框中的边框。这个核心代码包括我们可能想要隔离以进行测试的函数，或者只是为了使其他模块更清晰。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Often in programming we use string constants as dictionary keys and comparatives,
    and in generated labels. It’s easy to slip into the bad habit of typing these
    strings when required, but a much better way is to define a constant variable
    instead. For example, rather than `'if option === "All Categories"'`, we use `'if
    option === nbviz.ALL_CATS'`. In the former option, mistyping `'All Categories'`
    will not flag an error, an accident waiting to happen. Having a `const` also means
    only one edit is needed to change all occurrences of the string. JavaScript has
    a newish `const` keyword that makes enforcing constancy a bit easier, though it
    only prevents variables from being reassigned. See the [Mozilla documentation](https://oreil.ly/AlEbm)
    for some examples and a breakdown of `const` limitations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中经常使用字符串常量作为字典键、比较项和生成的标签。在需要时输入这些字符串很容易养成坏习惯，但更好的方法是定义一个常量变量。例如，不使用`'if
    option === "All Categories"'`，而是使用`'if option === nbviz.ALL_CATS'`。在前者中，误输`'All
    Categories'`不会引发错误，这是一场意外。拥有`const`还意味着只需编辑一次即可更改所有字符串的出现。JavaScript有一个新的`const`关键字，使得强制常量变得更容易，尽管它仅阻止变量被重新赋值。参见[Mozilla文档](https://oreil.ly/AlEbm)获取一些示例和`const`限制的详细说明。
- en: '[Example 16-3](#build_core) shows the code shared between the other modules.
    Anything intended to be used by other modules is attached to the shared `nbviz`
    namespace.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-3](#build_core)展示了在其他模块之间共享的代码。任何打算供其他模块使用的内容都附加在共享的`nbviz`命名空间上。'
- en: Example 16-3\. Shared codebase in nbviz_core.js
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-3\. 在 nbviz_core.js 中的共享代码库
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO8-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO8-1)'
- en: We use one of D3’s built-in color schemes to provide our prize category colors.
    `schemeCategory10` is an array of 10 color hex codes (`['#1f77b4', '#ff7f0e',...]`),
    which we access using the category indices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 D3 的内置颜色方案来提供奖项类别颜色。`schemeCategory10`是一个包含 10 个颜色十六进制码的数组（`['#1f77b4',
    '#ff7f0e',...]`），我们通过类别索引来访问。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO8-2)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO8-2)'
- en: This and the following empty methods will be explained in detail in the following
    chapters in a use context.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此处和以下的空方法将在接下来的章节中根据使用情境进行详细解释。
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO8-3)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_building_a_visualization_CO8-3)'
- en: This function is called when the dataset changes (after initialization of the
    app, this is user-driven) to update the Nobel-viz elements. Update callbacks set
    by the component modules and stored in the `callbacks` array are called in turn,
    triggering any necessary visual changes. See [“Basic Data Flow”](#d3build_sect_components)
    for details.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据集更改时（在应用程序初始化后，这是用户驱动的），调用此函数更新诺贝尔可视化元素。按顺序调用由组件模块设置并存储在`callbacks`数组中的更新回调，触发任何必要的视觉变化。详见[“基本数据流”](#d3build_sect_components)了解详细信息。
- en: '[![4](assets/4.png)](#co_building_a_visualization_CO8-4)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_building_a_visualization_CO8-4)'
- en: The `nbviz` object, with utility functions, constants, and variables, is the
    default export for this module, imported by other modules, thus `import nbviz
    from ​./⁠nbviz_core`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`nbviz`对象具有实用函数、常量和变量，是该模块的默认导出项，由其他模块导入，因此使用`import nbviz from ​./⁠nbviz_core`。'
- en: With the core code at hand, let’s see how our app is initialized by fetching
    static resources using D3’s utility methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有了核心代码，让我们看看如何使用 D3 的实用方法初始化我们的应用程序来获取静态资源。
- en: Initializing the Nobel Prize Visualization
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化诺贝尔奖可视化
- en: 'In order to start the app, we need some data. We use D3’s `json` and `csv`
    helper functions to load the data and convert it to JavaScript objects and arrays.
    The `Promise.all`^([7](ch16.xhtml#idm45607749511824)) method is used to fire off
    these data fetches simultaneously, wait for all four to be resolved, and then
    deliver the data to a specified handler function, in this case `ready`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动应用程序，我们需要一些数据。我们使用 D3 的`json`和`csv`辅助函数加载数据并将其转换为 JavaScript 对象和数组。使用`Promise.all`^([7](ch16.xhtml#idm45607749511824))方法同时发起这些数据获取请求，等待所有四个请求都完成，然后将数据传递给指定的处理函数，在本例中为`ready`：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO9-1)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO9-1)'
- en: Fire off simultaneous requests for the four data files. The static files consist
    of a world map (110m resolution) and some country data we’ll be using in the visualization.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同时发起对四个数据文件的请求。这些静态文件包括一个世界地图（110m 分辨率）和一些我们将在可视化中使用的国家数据。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO9-2)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO9-2)'
- en: The array returned to `ready` uses [JavaScript destructuring](https://oreil.ly/RZzXm)
    to assign the sequential data to its respective variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给`ready`的数组使用[JavaScript解构](https://oreil.ly/RZzXm)将顺序数据分配给相应的变量。
- en: If our data requests are successful, the `ready` function receives the requested
    data and we’re ready to start sending data to the visual elements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据请求成功，`ready`函数将接收所请求的数据，并准备好向可视元素发送数据。
- en: Ready to Go
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: After the deferred requests for data made by the `Promise.all` method are resolved,
    it calls the specified `ready` function, passing the datasets as arguments in
    the order in which they were added.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在由`Promise.all`方法发起的延迟数据请求解决后，它调用指定的`ready`函数，并按添加顺序将数据集作为参数传递。
- en: The `ready` function is shown in [Example 16-4](#build_ready). If the data has
    downloaded without error, we use the winners’ data to create the active filter
    (courtesy of the Crossfilter library) we will use to allow the user to select
    subsets of the Nobel winners based on category, gender, and country. We then call
    some initializer methods, and finally use the `onDataChange` method to trigger
    a drawing of the visual elements of dataviz, updating bar chart, map, timeline,
    and so on. The schematic in [Figure 16-3](#d3build_work_flow) shows the way in
    which data changes propagate.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ready`函数在[示例 16-4](#build_ready)中展示。如果数据下载没有错误，我们将使用获奖者数据创建一个活动过滤器（由Crossfilter库提供），用于允许用户根据类别、性别和国家选择诺贝尔获奖者的子集。然后调用一些初始化方法，最后使用`onDataChange`方法触发数据可视化元素的绘制，更新条形图、地图、时间线等。[图 16-3](#d3build_work_flow)中的示意图展示了数据变化传播的方式。'
- en: Example 16-4\. The `ready` function is called when the initial data requests
    have resolved
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-4\. 当初始数据请求已解决时调用`ready`函数
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO10-1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO10-1)'
- en: This method uses the freshly loaded Nobel Prize dataset to create the filter
    we will use to allow the user to select subsets of the data to visualize. See
    [“Filtering Data with Crossfilter”](#crossfilter) for details.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法利用新加载的诺贝尔奖数据集创建我们将用于允许用户选择要可视化的数据子集的过滤器。详见“Filtering Data with Crossfilter”章节。
- en: We’ll see how the `makeFilterAndDimensions` method ([Example 16-4](#build_ready),
    ![1](assets/1.png)) works when we cover the Crossfilter library in [“Filtering
    Data with Crossfilter”](#crossfilter). For now, we’ll assume we have a means of
    getting the data currently selected by the user via some menu selectors (e.g.,
    selecting all female winners).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在介绍Crossfilter库中的“Filtering Data with Crossfilter”章节时看到`makeFilterAndDimensions`方法（[示例 16-4](#build_ready)，![1](assets/1.png)）的工作原理。暂时假设我们有一种方法通过一些菜单选择器（例如选择所有女性获奖者）获取用户当前选择的数据。
- en: '![dpj2 1603](assets/dpj2_1603.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 1603](assets/dpj2_1603.png)'
- en: Figure 16-3\. The app’s main data flow
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-3\. 应用程序的主要数据流
- en: Data-Driven Updates
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据驱动更新
- en: 'After the menu and map have been initialized in the `ready` function (we’ll
    see how that works in their respective chapters: [Chapter 19](ch19.xhtml#chapter_d3_maps)
    for the map and [Chapter 21](ch21.xhtml#chapter_d3_ui) for the menu), we trigger
    an update of the visual elements with the `onDataChange` method defined in *nbviz_core.js*.
    `onDataChange` (see [Example 16-5](#src_ondatachange)) is a shared function that
    is called whenever the set of displayed data changes in response to user interaction,
    or when the user chooses a different country prize metric (e.g., measuring per
    capita rather than absolute numbers).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ready`函数中初始化菜单和地图（我们将在各自的章节中详细讨论其工作原理：[第19章](ch19.xhtml#chapter_d3_maps)讨论地图，[第21章](ch21.xhtml#chapter_d3_ui)讨论菜单）后，我们使用*nbviz_core.js*中定义的`onDataChange`方法触发可视元素的更新。`onDataChange`（参见[示例 16-5](#src_ondatachange)）是一个共享函数，当显示的数据集因用户交互而改变，或者用户选择不同的国家奖励度量（例如按人均测量而不是绝对数字）时调用。
- en: Example 16-5\. Function called to update the visual elements when selected data
    is changed
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-5\. 当选定数据更改时调用的函数以更新可视元素
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO11-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO11-1)'
- en: Each component module that needs updating appends its callback to this array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更新的每个组件模块都将其回调追加到此数组中。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO11-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO11-2)'
- en: On data change the component callbacks are called in turn, triggering any visual
    changes necessary to reflect the new data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据变化时，依次调用组件回调函数，触发任何必要的视觉变化以反映新数据。
- en: 'When the modules are first imported, they add their callbacks to the `callbacks`
    array in the core module. Here’s the bar chart, for example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块首次导入时，它们将它们的回调添加到核心模块中的`callbacks`数组中。例如，这是条形图：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO12-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO12-1)'
- en: When the main core update function calls this callback function, the country
    data is used by the local update function to change the bar chart.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当主要的核心更新函数调用此回调函数时，国家数据由本地更新函数使用以更改条形图。
- en: The main dataset, consumed by the timeline, map, and bar chart, is produced
    by the `getCountryData` method, which groups the prize winners by country and
    adds some national information, namely population size and international alphacode.
    [Example 16-6](#build_getCountryData) breaks this method down.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 主要数据集由`getCountryData`方法生成，该方法通过国家将获奖者分组，并添加一些国家信息，即人口大小和国际字母代码。[示例 16-6](#build_getCountryData)详细介绍了此方法。
- en: Example 16-6\. Creating the main country dataset
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-6。创建主要的国家数据集
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO13-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO13-1)'
- en: '`countryDim` is one of our Crossfilter dimensions (see [“Filtering Data with
    Crossfilter”](#crossfilter)), here providing group key, value counts (e.g., `{key:Argentina,
    value:5}`).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`countryDim`是我们Crossfilter维度之一（见[“使用Crossfilter进行数据过滤”](#crossfilter)），在这里提供组键、值计数（例如，`{key:Argentina,
    value:5}`）。'
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO13-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO13-2)'
- en: We use the array’s `map` method to create a new array with added components
    from our country dataset.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数组的`map`方法来创建一个新数组，并从我们的国家数据集中添加组件。
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO13-3)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_building_a_visualization_CO13-3)'
- en: Fetches country data using our group key (e.g., Australia).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的组键（例如，澳大利亚）获取国家数据。
- en: '[![4](assets/4.png)](#co_building_a_visualization_CO13-4)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_building_a_visualization_CO13-4)'
- en: If the `valuePerCapita` radio-switch is on then we divide the number of prizes
    by the size of the country’s population, giving a *fairer*, relative prize tally.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`valuePerCapita`单选开关打开，则我们将奖项数量除以该国家的人口数量，从而得到一个*更公平*的相对奖项计数。
- en: '[![5](assets/5.png)](#co_building_a_visualization_CO13-5)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_building_a_visualization_CO13-5)'
- en: Uses `Array`’s `sort` method to make the array descending by value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Array`的`sort`方法使数组按值降序排列。
- en: The update methods of our Nobel-viz elements all make use of data filtered by
    the Crossfilter library. Let’s see how that’s done now.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Nobel-viz元素的更新方法都利用Crossfilter库过滤的数据。现在让我们看看如何做到这一点。
- en: Filtering Data with Crossfilter
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Crossfilter进行数据过滤
- en: Developed by D3’s creators, Mike Bostock and Jason Davies, Crossfilter^([8](ch16.xhtml#idm45607748719440))
    is a highly optimized library for exploring large, multivariate datasets using
    JavaScript. It’s very fast and can easily handle datasets far larger than our
    Nobel Prize dataset. We’ll be using it to filter our dataset of winners by the
    dimensions of category, gender, and country.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Crossfilter是由D3的创作者Mike Bostock和Jason Davies开发的一个高度优化的库，用于使用JavaScript探索大型、多变量数据集。它非常快速，并且可以轻松处理远比我们的诺贝尔奖数据集大得多的数据集。我们将使用它来根据类别、性别和国家的维度来过滤我们的获奖者数据集。
- en: The choice of Crossfilter is slightly ambitious, but I wanted to show it in
    action as I’ve found it to be so useful personally. It’s also the basis of [*dc.js*](https://dc-js.github.io/dc.js),
    the very popular D3 charting library, which testifies to its usefulness. Although
    Crossfilter can be a little difficult to grasp, especially when we start intersecting
    dimensional filters, most use cases follow a basic pattern that is quickly absorbed.
    If you ever find yourself trying to cut and slice large datasets, Crossfilter’s
    optimizations will prove a boon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Crossfilter有些雄心勃勃，但我想展示它的实际效果，因为我个人发现它非常有用。它也是[*dc.js*](https://dc-js.github.io/dc.js)，这个非常流行的D3图表库的基础，这证明了它的实用性。虽然Crossfilter在开始交叉维度过滤时可能有些难以理解，但大多数用例遵循一个基本模式，很快就能掌握。如果你发现自己试图切割和分析大型数据集，Crossfilter的优化将会是一大帮助。
- en: Creating the filter
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建过滤器
- en: On initializing the Nobel-viz, the `makeFilterAndDimensions` method defined
    in *nbviz_core.js* is called from the `ready` method in *nbviz_main.js* (see [“Ready
    to Go”](#sect_ready)). `makeFilterAndDimensions` uses the freshly loaded Nobel
    Prize dataset to create a Crossfilter filter and some dimensions (e.g., prize
    category) based on it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 Nobel-viz 时，*nbviz_core.js* 中定义的 `makeFilterAndDimensions` 方法被从 *nbviz_main.js*
    中的 `ready` 方法中调用（参见[“Ready to Go”](#sect_ready)）。`makeFilterAndDimensions` 使用刚刚加载的诺贝尔奖数据集创建一个
    Crossfilter 过滤器和一些基于它的维度（例如，奖项类别）。
- en: 'We first create our filter using the dataset of Nobel Prize winners fetched
    on initialization. Let’s remind ourselves what that looks like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用初始化时获取的诺贝尔奖获得者数据集创建我们的过滤器。让我们再次看看那是什么样子：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create our filter, call the `crossfilter` function with the array of winner
    objects:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的过滤器，请使用获奖者对象的数组调用 `crossfilter` 函数：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Crossfilter works by allowing you to create dimensional filters on your data.
    You do so by applying a function to the objects. At its simplest, this creates
    a dimension based on a single category—for example, by gender. Here we create
    the gender dimension we’ll use to filter Nobel Prizes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Crossfilter 的工作原理是允许您在数据上创建维度过滤器。您可以通过将函数应用于对象来这样做。在最简单的情况下，这将创建一个基于单一类别的维度，例如按性别划分。在这里，我们创建了将用于过滤诺贝尔奖的性别维度：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This dimension now has an efficient ordering of our dataset by the gender field.
    We can use it like this, to return all objects with gender female:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个维度现在通过性别字段对我们的数据集进行了高效的排序。我们可以像这样使用它，来返回所有性别为女性的对象：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO14-1)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO14-1)'
- en: '`filter` takes a single value or, where appropriate, a range (e.g., [5, 21]—all
    values between 5 and 21). It can also take a Boolean function of the values.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 接受一个单一值或者在适当情况下，一个范围（例如，[5, 21]—所有在5和21之间的值）。它也可以接受值的布尔函数。'
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO14-2)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO14-2)'
- en: Once the filter is applied, `top` returns the specified number of ordered objects.
    Specifying `Infinity`^([9](ch16.xhtml#idm45607748487088)) returns all the filtered
    data objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了过滤器，`top` 就会返回指定数量的排序对象。指定 `Infinity`^([9](ch16.xhtml#idm45607748487088))
    将返回所有过滤后的数据对象。
- en: Crossfilter really comes into its own when we start applying multiple dimensional
    filters, allowing us to slice and dice the data into any subsets we require, all
    achieved with impressive speed.^([10](ch16.xhtml#idm45607748484816))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始应用多维度过滤器时，Crossfilter 真正发挥了作用，使我们能够将数据切片并分割成我们需要的任何子集，所有这些都以令人印象深刻的速度实现。^([10](ch16.xhtml#idm45607748484816))
- en: 'Let’s clear the gender dimension and add a new one, filtering by prize-winning
    category. To reset a dimension,^([11](ch16.xhtml#idm45607748454160)) apply the
    `filter` method without arguments:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清除性别维度并添加一个新的维度，通过获奖类别进行过滤。要重置维度，^([11](ch16.xhtml#idm45607748454160)) 不带参数地应用
    `filter` 方法：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We’ll now create a new prize category dimension:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个新的奖项类别维度：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now filter the gender and category dimensions in sequence, allowing
    us to find, for example, all female Physics prize winners:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按顺序过滤性别和类别维度，从而找到例如所有女性物理学奖获得者：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that we can turn the filters on and off selectively. So, for example,
    we can remove the Physics category filter, meaning the gender dimension now contains
    all the female Nobel Prize winners:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以有选择地打开和关闭过滤器。因此，例如，我们可以移除物理类别过滤器，这意味着性别维度现在包含所有女性诺贝尔奖获得者：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In our Nobel-viz, these filter operations will be driven by the user making
    selections from the topmost menu bar.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的诺贝尔可视化中，这些过滤操作将由用户从最顶部的菜单栏进行选择驱动。
- en: 'As well as returning the filtered subsets, Crossfilter can perform grouping
    operations on the data. We use this to get the national prize aggregates for the
    bar chart and map indicators:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回过滤后的子集，Crossfilter 还可以对数据执行分组操作。我们使用这个来获取柱状图和地图指示器的国家奖聚合数据：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO15-1)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO15-1)'
- en: Group takes an optional function as an argument, but the default is generally
    what you want.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Group 接受一个可选的函数作为参数，但默认通常是您想要的。
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO15-2)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_building_a_visualization_CO15-2)'
- en: Returns all groups by key and value. Do not modify the returned array.^([12](ch16.xhtml#idm45607748238000))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有按键和值分组的组。不要修改返回的数组。^([12](ch16.xhtml#idm45607748238000))
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO15-3)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_building_a_visualization_CO15-3)'
- en: '`value` is the total number of Nobel Prize winners for Argentina.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 是阿根廷诺贝尔奖获得者的总数。'
- en: To create our Crossfilter filter and dimensions, we use the `makeFilterAndDimensions`
    method, defined in *nbviz_core.js*. [Example 16-7](#makeFilterAndDims) shows the
    whole method. Note that the order in which the filters are created isn’t important—their
    intersection will still be the same.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的 Crossfilter 过滤器和维度，我们使用在 *nbviz_core.js* 中定义的 `makeFilterAndDimensions`
    方法。[Example 16-7](#makeFilterAndDims) 显示了整个方法。请注意，创建过滤器的顺序并不重要——它们的交集仍然相同。
- en: Example 16-7\. Making our Crossfilter filter and dimensions
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 16-7\. 制作我们的 Crossfilter 过滤器和维度
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO16-1)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_building_a_visualization_CO16-1)'
- en: 'We’re using the full JavaScript functions for teaching clarity, but these days
    the shortened form would likely be used: `o => o.country`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用完整的 JavaScript 函数来进行教学，但现在可能会使用缩短的形式：`o => o.country`。
- en: Running the Nobel Prize Visualization App
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行诺贝尔奖可视化应用程序
- en: 'To run the Nobel visualization we need a web server that can access the root
    *index.xhtml* file. For development purposes we can make use of Python’s built-in
    `http` module to kick off the required server. In the root directory containing
    our index file, run:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行诺贝尔奖可视化，我们需要一个能够访问根 *index.xhtml* 文件的 Web 服务器。为了开发目的，我们可以利用 Python 内置的 `http`
    模块来启动所需的服务器。在包含我们的索引文件的根目录中，运行：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now open up a browser window and go to *http:localhost:8080* and you should
    see [Figure 16-4](#d3build_nobelviz).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开浏览器窗口，转到 *http:localhost:8080*，您应该会看到[图 16-4](#d3build_nobelviz)。
- en: '![dpj2 1604](assets/dpj2_1604.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![dpj2 1604](assets/dpj2_1604.png)'
- en: Figure 16-4\. The finished Nobel-viz app
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-4\. 完成的 Nobel-viz 应用程序
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we sketched out how to implement the visualization we imagined
    in [Chapter 15](ch15.xhtml#chapter_imagining). The backbone was assembled from
    HTML, CSS, and JavaScript building blocks, and the data feed to the app and data
    flow within it described. In the following chapters, we’ll see how the individual
    components of our Nobel-viz use the data sent to them to create our interactive
    visualization. We’ll start with a big chapter, which will introduce the fundamentals
    of D3 while showing how to build the bar chart component of our app. This should
    set you up for the subsequent D3-focused chapters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了如何在[第 15 章](ch15.xhtml#chapter_imagining)中想象的可视化中实现。主干由 HTML、CSS 和
    JavaScript 构建块组装而成，并描述了应用程序中的数据馈送和数据流。在接下来的章节中，我们将看到我们的 Nobel-viz 的各个组件如何使用发送到它们的数据来创建我们的交互式可视化。我们将从一个大的章节开始，介绍
    D3 的基础知识，同时展示如何构建我们应用程序的条形图组件。这应该为你后续的 D3 焦点章节做好准备。
- en: ^([1](ch16.xhtml#idm45607751186112-marker)) See these [SpeedCurve](https://oreil.ly/ngdOJ)
    and [Web Almanac](https://oreil.ly/qIvox) posts for some analysis of average web
    page size.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch16.xhtml#idm45607751186112-marker)) 请查看这些 [SpeedCurve](https://oreil.ly/ngdOJ)
    和 [Web Almanac](https://oreil.ly/qIvox) 的帖子，了解平均网页大小的一些分析。
- en: ^([2](ch16.xhtml#idm45607751164464-marker)) I would advise saving JavaScripted
    styling for special occasions, doing as much as possible with vanilla CSS.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch16.xhtml#idm45607751164464-marker)) 我建议将 JavaScript 样式保存给特殊场合，尽可能地使用纯
    CSS。
- en: ^([3](ch16.xhtml#idm45607750526128-marker)) Currently around 2,560×1,600 pixels.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch16.xhtml#idm45607750526128-marker)) 目前约为 2,560×1,600 像素。
- en: ^([4](ch16.xhtml#idm45607750213296-marker)) See [“Projections”](ch19.xhtml#sect_projections)
    for a comparison of the different geometric projections. Given the constraint
    of showing all Nobel Prize–winning countries, the equirectangular projection proved
    most effective.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch16.xhtml#idm45607750213296-marker)) 请参阅[“投影”](ch19.xhtml#sect_projections)以比较不同的几何投影。考虑到展示所有获得诺贝尔奖的国家的约束条件，等经纬投影效果最好。
- en: ^([5](ch16.xhtml#idm45607749985552-marker)) See the collection at [D3’s GitHub](https://oreil.ly/khvac).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch16.xhtml#idm45607749985552-marker)) 请查看[D3 的 GitHub 上的集合](https://oreil.ly/khvac)。
- en: ^([6](ch16.xhtml#idm45607749683584-marker)) In our app, I’m keeping things as
    simple as possible; as the number of UI options increases, it’s sensible to store
    flags, ranges, etc. in a dedicated object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch16.xhtml#idm45607749683584-marker)) 在我们的应用程序中，我尽可能地保持简单；随着 UI 选项数量的增加，将标志、范围等存储在专用对象中是明智的选择。
- en: ^([7](ch16.xhtml#idm45607749511824-marker)) You can read more about `Promise.all`
    in the [Mozilla documentation](https://oreil.ly/67Odo).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch16.xhtml#idm45607749511824-marker)) 您可以在[Mozilla 文档](https://oreil.ly/67Odo)中了解更多关于
    `Promise.all` 的信息。
- en: ^([8](ch16.xhtml#idm45607748719440-marker)) See this [Square page](https://square.github.io/crossfilter)
    for an impressive example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch16.xhtml#idm45607748719440-marker)) 请参阅这个[Square 页面](https://square.github.io/crossfilter)，这是一个令人印象深刻的示例。
- en: ^([9](ch16.xhtml#idm45607748487088-marker)) JavaScript’s [`Infinity`](https://oreil.ly/Ll5xV)
    is a numeric value representing infinity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch16.xhtml#idm45607748487088-marker)) JavaScript 的 [`Infinity`](https://oreil.ly/Ll5xV)
    是表示无穷大的数值。
- en: ^([10](ch16.xhtml#idm45607748484816-marker)) Crossfilter was designed to update
    millions of records in real time, in response to user input.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch16.xhtml#idm45607748484816-marker)) Crossfilter 被设计用于实时更新数百万条记录，以响应用户输入。
- en: ^([11](ch16.xhtml#idm45607748454160-marker)) This will clear all the filters
    on this dimension.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch16.xhtml#idm45607748454160-marker)) 这将清除此维度上的所有过滤器。
- en: ^([12](ch16.xhtml#idm45607748238000-marker)) See the [Crossfilter GitHub page](https://oreil.ly/saEpG).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch16.xhtml#idm45607748238000-marker)) 请参阅 [Crossfilter GitHub 页面](https://oreil.ly/saEpG)。
