- en: 2 Thinking in functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 以函数思维
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Functions in math and in programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学与编程中的函数
- en: Representing functions in C#
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中表示函数
- en: Leveraging higher-order functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用高阶函数
- en: In chapter 1, you saw how treating functions as first-class values is one of
    the tenets of FP. This allows the programmer to up the ante and write functions
    that are parameterized by or create other functions. These are called *higher-order
    functions* (HOFs); they really raise the level of abstraction in our programs,
    allowing us to do more with less code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，你看到了将函数视为一等值是函数式编程（FP）的一个原则。这允许程序员提高标准，编写由其他函数参数化或创建的函数。这些被称为*高阶函数*（HOFs）；它们确实提高了我们程序中的抽象级别，使我们能够用更少的代码做更多的事情。
- en: 'But before we delve into HOFs, let’s take a step back and see what we mean
    by functions: what they are both in the mathematical and programming jargon. We’ll
    then look at the various constructs that C# offers to represent functions.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入探讨高阶函数（HOFs）之前，让我们退一步，看看我们所说的函数是什么意思：在数学和编程术语中它们是什么。然后我们将查看C#提供的各种结构来表示函数。
- en: 2.1 What’s a function, anyway?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 函数究竟是什么？
- en: In this section, I’ll clarify what I mean by *function*. I’ll start with the
    mathematical use of the word and then move on to the various language constructs
    that C# offers to represent functions. This will give you some basic conceptual
    and practical tools so you can start to code functionally.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将阐明我所说的*函数*的意思。我将从数学上对这个词的使用开始，然后转向C#提供的各种表示函数的语言结构。这将为你提供一些基本的概念性和实用性工具，以便你可以开始以函数式的方式编码。
- en: 2.1.1 Functions as maps
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 函数作为映射
- en: In mathematics, a function is a map between two sets, respectively called the
    *domain* and *codomain*. That is, given an element from its domain, a function
    yields an element from its codomain. That’s all there is to that. It doesn’t matter
    whether the mapping is based on some formula or is completely arbitrary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，函数是两个集合之间的映射，分别称为*定义域*和*值域*。也就是说，给定定义域中的一个元素，函数会从值域中产生一个元素。这就是全部。无论映射是基于某种公式还是完全任意，都没有关系。
- en: In this sense, a function is a completely abstract mathematical object, and
    the value that a function yields is determined *exclusively* by its input. You’ll
    see that this isn’t always the case with functions in programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，函数是一个完全抽象的数学对象，函数产生的值完全由其输入决定。你会发现，在编程中的函数并不总是这样。
- en: For example, imagine a function mapping lowercase letters to their uppercase
    counterparts as in figure 2.1\. In this case, the domain is the set {*a, b, c,
    ...*}, and the codomain is the set {*A, B, C, ...*}. (Naturally, there are functions
    for which the domain and codomain are the same set; can you think of an example?)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个函数将小写字母映射到它们的大写对应字母，如图2.1所示。在这种情况下，定义域是集合{*a, b, c, ...*}，值域是集合{*A, B,
    C, ...*}。（当然，也存在定义域和值域是同一集合的函数；你能想到一个例子吗？）
- en: '![](Images/CH02_F01_Buonanno2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F01_Buonanno2.png)'
- en: Figure 2.1 A mathematical function is simply a mapping. It maps elements from
    one set (the domain) to elements of another set (the codomain).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 数学函数简单来说就是一个映射。它将一个集合（定义域）的元素映射到另一个集合（值域）的元素。
- en: How does this relate to programming functions? In statically-typed languages
    like C#, *types* represent the sets (domain and codomain). For example, if you
    code the function in figure 2.1, you could use `char` to represent both the domain
    and the codomain. The type of your function could then be written as
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这与编程函数有何关联？在静态类型语言如C#中，*类型*代表集合（定义域和值域）。例如，如果你在图2.1中编写函数，你可以使用`char`来表示定义域和值域。那么你的函数类型可以写成
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function maps `char`s to `char`s or, equivalently, given a `char`, it yields
    a `char`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将`char`映射到`char`，或者等价地，给定一个`char`，它产生一个`char`。
- en: 'The types for the domain and codomain constitute a function’s *interface*,
    also called its *type* or *signature*. You can think of this as a contract: a
    function signature declares that, given an element from the domain, it will yield
    an element from the codomain.[¹](#pgfId-1107578) This may sound pretty obvious,
    but you’ll see in chapter 4 that, in reality, violations of the signature contract
    abound.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义域和值域的类型构成了函数的*接口*，也称为其*类型*或*签名*。你可以将其视为一份合同：函数签名声明，给定定义域中的一个元素，它将产生值域中的一个元素。[¹](#pgfId-1107578)
    这听起来可能非常明显，但你将在第四章中看到，在现实中，违反签名合同的例子比比皆是。
- en: Next, let’s look at the C# language features that enable us to represent functions.
    By this I mean, not just mathematical functions, but what we refer to as functions
    in everyday programming talk.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 C# 语言特性，这些特性使我们能够表示函数。这里的意思是，不仅限于数学函数，还包括我们在日常编程中提到的函数。
- en: 2.1.2 Representing functions in C#
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 在 C# 中表示函数
- en: 'There are several language constructs in C# that you can use to represent functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中有几个语言结构可以用来表示函数：
- en: Methods (including local functions)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法（包括局部方法）
- en: Delegates
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Lambda expressions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Dictionaries
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: If you’re well versed in these, skip to section 2.2; otherwise, here’s a quick
    refresher.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这些内容非常熟悉，请跳到第 2.2 节；否则，这里有一个快速回顾。
- en: Methods
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方法
- en: Methods are the most common and idiomatic representation for functions in C#.
    For example, the `System.Math` class includes methods that represent many common
    mathematical functions. When programming functionally, we tend to overwhelmingly
    use static methods that only rely on their input arguments—they don’t refer to
    any fields or properties in the enclosing static class, and therefore, you can
    think of them in isolation, like you would do with mathematical functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是 C# 中函数最常见和惯用的表示形式。例如，`System.Math` 类包含表示许多常见数学函数的方法。当以函数式编程时，我们倾向于几乎只使用仅依赖于其输入参数的静态方法——它们不引用封装的静态类中的任何字段或属性，因此，您可以将其视为独立存在，就像处理数学函数一样。
- en: We discussed local functions in section 1.2.2\. They’re really methods declared
    inside a method. If you have a function that performs a specific task and you
    only need to call it in one place, it could be a candidate for a local function.
    The constructs that really enable you to program in a functional style are delegates
    and lambda expressions, so let’s move on to those.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 1.2.2 节中讨论了局部函数。它们实际上是方法内部声明的方法。如果您有一个执行特定任务的功能，并且您只需要在一个地方调用它，它可能是一个局部函数的候选。真正使您能够以函数式风格编程的结构是代理和
    lambda 表达式，所以让我们继续讨论这些。
- en: Delegates
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代理
- en: Delegates are type-safe function pointers. *Type-safe* here means that a delegate
    is strongly typed. The types of the input and output values of the function are
    known at compile time, and consistency is enforced by the compiler.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是类型安全的函数指针。这里的 `类型安全` 意味着代理是强类型的。函数的输入和输出值的类型在编译时已知，并且一致性由编译器强制执行。
- en: 'Creating a delegate is a two-step process: you first declare the delegate type
    and then provide an implementation. (This is analogous to writing an `interface`
    and then instantiating a `class` implementing that interface.)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建代理是一个两步过程：首先声明代理类型，然后提供实现。（这与编写 `interface` 然后实例化实现该接口的 `class` 类似。）
- en: The first step is done by using the `delegate` keyword and providing the signature
    for the delegate. For example, the following listing shows the definition of the
    `Comparison<T>` delegate, which is included in the .NET Base Class Library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过使用 `delegate` 关键字并提供代理的签名来完成的。例如，以下列表显示了包含在 .NET 基类库中的 `Comparison<T>`
    代理的定义。
- en: Listing 2.1 Declaring a delegate
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 声明代理
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, a `Comparison<T>` takes two `T`’s. It then yields an `int`,
    indicating which is greater.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Comparison<T>` 接收两个 `T`。然后它产生一个 `int`，表示哪个更大。
- en: Once you have a delegate type, you can instantiate it by providing an implementation.
    The following listing shows this approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了代理类型，您可以通过提供实现来实例化它。以下列表显示了这种方法。
- en: Listing 2.2 Instantiating and using a delegate
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 实例化和使用代理
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Provides an implementation of `Comparison`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供 `Comparison` 的实现
- en: ❷ Uses the `Comparison` delegate as an argument to `Sort`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 `Comparison` 代理作为 `Sort` 的参数使用
- en: As you can see, a delegate is just an *object* (in the technical sense) that
    represents an operation; in this case, a comparison. Like any other object, you
    can use a delegate as an argument for another method as in listing 2.2\. Delegates
    are the language feature that makes functions first-class values in C#.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代理只是一个 *对象*（在技术意义上）表示一个操作；在这种情况下，是一个比较操作。像任何其他对象一样，您可以将代理用作另一个方法的参数，如列表
    2.2 所示。代理是使函数在 C# 中成为一等值的语言特性。
- en: The Func and Action delegates
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Func 和 Action 代理
- en: '.NET includes a couple of delegate families that can represent pretty much
    any function type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 包含几个可以表示几乎所有函数类型的代理家族：
- en: '`Func<R>`—Represents a function that takes no arguments and returns a result
    of type `R`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func<R>`——表示一个不接受任何参数并返回类型为 `R` 的结果的函数'
- en: '`Func<T1,` `R>`—Represents a function that takes an argument of type `T1` and
    returns a result of type `R`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func<T1, R>`—表示一个接受类型为 `T1` 的参数并返回类型为 `R` 的结果的函数'
- en: '`Func<T1,` `T2,` `R>`—Represents a function that takes a `T1` and a `T2` and
    returns an `R`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func<T1, T2, R>`—表示一个接受 `T1` 和 `T2` 并返回 `R` 的函数'
- en: And so on. These delegates represent functions of various *arities* (see the
    sidebar on “Function arity”).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。这些委托代表各种 *arity*（参见“函数arity”侧边栏）的函数。
- en: Since the introduction of `Func`, it has become rare to use custom delegates.
    For example, instead of declaring a custom delegate like this
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 自从引入 `Func` 以来，使用自定义委托的情况变得很少。例如，而不是这样声明一个自定义委托
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: you can simply use
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The type of `Greeter` as defined in this example is equivalent to or compatible
    with `Func<Person,` `Greeting>`. In both cases, it’s a function that takes a `Person`
    and returns a `Greeting`. In practice, this means you can define a `Greeter` and
    pass it to a method that expects a `Func<Person,` `Greeting>` and vice versa,
    without any complaints from the compiler.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中定义的 `Greeter` 类型与 `Func<Person, Greeting>` 相当或兼容。在两种情况下，它都是一个接受 `Person`
    并返回 `Greeting` 的函数。在实践中，这意味着你可以定义一个 `Greeter` 并将其传递给期望 `Func<Person, Greeting>`
    的方法，反之亦然，而编译器不会有任何抱怨。
- en: 'There’s a similar delegate family to represent *actions*, functions that have
    no return value, such as `void` methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个类似的委托家族来表示 *actions*，即没有返回值的函数，例如 `void` 方法：
- en: '`Action`—Represents an action with no input arguments'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action`—表示没有输入参数的操作'
- en: '`Action<T1>`—Represents an action with an input argument of type `T1`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action<T1>`—表示具有类型为 `T1` 的输入参数的操作'
- en: '`Action<T1,` `T2>` and so on—Represent an action with several input arguments'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action<T1, T2>` 等等—表示具有多个输入参数的操作'
- en: The evolution of .NET has been away from custom delegates in favor of the more
    general `Func` and `Action` delegates. For instance, take the representation of
    a predicate:[²](#pgfId-1107662)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的发展趋势是远离自定义委托，转而使用更通用的 `Func` 和 `Action` 委托。例如，考虑谓词的表示方式：[²](#pgfId-1107662)
- en: In .NET 2, a `Predicate<T>` delegate was introduced. For example, the `FindAll`
    method used to filter a `List<T>` expects a `Predicate<T>`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 .NET 2 中，引入了 `Predicate<T>` 委托。例如，`FindAll` 方法用于过滤 `List<T>`，期望一个 `Predicate<T>`。
- en: In .NET 3, the `Where` method, also used for filtering but defined for the more
    general `IEnumerable<T>`, doesn’t take a `Predicate<T>` but simply a `Func<T,`
    `bool>`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 .NET 3 中，`Where` 方法，也用于过滤，但定义为更通用的 `IEnumerable<T>`，不接收 `Predicate<T>`，而只接收
    `Func<T, bool>`。
- en: Both function types are equivalent. Using `Func` is recommended to avoid a proliferation
    of delegate types that represent the same function signature, but there’s still
    something to be said in favor of the expressiveness of custom delegates. `Predicate<T>`,
    in my view, conveys intent more clearly than `Func<T,` `bool>` and is closer to
    the spoken language.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种函数类型是等效的。推荐使用 `Func` 以避免出现代表相同函数签名的委托类型过多的情况，但仍然可以说自定义委托的表达能力更强。在我看来，`Predicate<T>`
    比起 `Func<T, bool>` 更能传达意图，并且更接近于口语。
- en: Function arity
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 函数arity
- en: '*Arity* is a funny word that refers to the number of arguments that a function
    accepts. For instance'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arity* 是一个有趣的词，指的是一个函数接受的参数数量。例如'
- en: A *nullary* function takes no arguments.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *零元* 函数不接受任何参数。
- en: A *unary* function takes one argument.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *一元* 函数接受一个参数。
- en: A *binary* function takes two arguments.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *二进制* 函数接受两个参数。
- en: A *ternary* function takes three arguments.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *三元* 函数接受三个参数。
- en: And so on. In reality, all functions can be viewed as being unary because passing
    *n* arguments is equivalent to passing an *n* tuple as the only argument. For
    example, addition (like any other binary arithmetic operation) is a function whose
    domain is the set of all pairs of numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。实际上，所有函数都可以被视为一元函数，因为传递 *n* 个参数相当于传递一个 *n* 元组作为唯一的参数。例如，加法（就像任何其他二元算术运算）是一个其定义域为所有数字对的函数。
- en: Lambda expressions
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Lambda expressions, called *lambdas* for short, are used to declare a function
    inline. The following listing demonstrates using a lambda to sort a list of numbers
    alphabetically.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式，简称 *lambdas*，用于声明内联函数。以下列表演示了使用lambda对数字列表进行字母排序。
- en: Listing 2.3 Declaring a function inline with a lambda
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 使用 lambda 表达式声明内联函数
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If your function is short, and you don’t need to reuse it elsewhere, lambdas
    offer the most attractive notation. Also notice that in listing 2.3, the compiler
    not only infers `l` and `r` to be of type `int`, it also converts the lambda to
    the delegate type `Comparison<int>` expected by the `Sort` method, given that
    the provided lambda is compatible with this type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数很短，并且你不需要在其他地方重用它，lambda 表达式提供了最吸引人的表示法。此外，请注意，在列表 2.3 中，编译器不仅推断 `l` 和
    `r` 为 `int` 类型，而且还根据提供的 lambda 与 `Sort` 方法期望的 `Comparison<int>` 委托类型兼容，将 lambda
    转换为该类型。
- en: Like methods, delegates and lambdas have access to the variables in the scope
    in which they’re declared. This is particularly useful when leveraging *closures*,
    as in the following listing.[³](#pgfId-1107700)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与方法一样，委托和 lambda 表达式可以访问它们声明的范围内的变量。这在利用 *闭包* 时尤其有用，如下面的列表所示。[³](#pgfId-1107700)
- en: Listing 2.4 A lambda accessing a variable from the enclosing scope
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 一个访问封装作用域中变量的 lambda 表达式
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ References the `s` variable from within the lambda, thus capturing it in a
    closure
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 lambda 中引用 `s` 变量，从而将其捕获在闭包中
- en: In this example, `Where` expects a function that takes a `DayOfWeek` and returns
    a `bool`. In reality, the function expressed by the lambda expression also uses
    the value of `pattern`, which is captured in a closure to calculate its result.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Where` 期望一个函数，该函数接受一个 `DayOfWeek` 并返回一个 `bool`。实际上，由 lambda 表达式表示的函数也使用了
    `pattern` 的值，该值通过闭包捕获来计算其结果。
- en: 'This is interesting. If you were to look at the function expressed by the lambda
    with a more mathematical eye, you might say that it’s actually a binary function
    that takes a `DayOfWeek` *and* a `string` (the pattern) as inputs and yields a
    `bool`. As programmers, however, we’re usually mostly concerned about the function
    signature, so you might be more likely to look at it as a unary function from
    `DayOfWeek` to `bool`. Both perspectives are valid: the function must conform
    to its unary signature, but it depends on two values to do its work.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣。如果你用更数学的眼光看待 lambda 表达式表示的函数，你可能会说它实际上是一个二元函数，它接受一个 `DayOfWeek` *和* 一个
    `string`（模式）作为输入，并产生一个 `bool`。然而，作为程序员，我们通常主要关注函数签名，所以你可能会更倾向于将其视为一个从 `DayOfWeek`
    到 `bool` 的单参数函数。两种观点都是有效的：函数必须符合其单参数签名，但它依赖于两个值来完成其工作。
- en: Anonymous methods
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法
- en: 'For the sake of completeness, I should mention that C# 2 introduced a feature
    called *anonymous methods*. These allow you to create a delegate like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我应该提到，C# 2 引入了一个名为 *匿名方法* 的功能。这允许你创建一个类似于这样的委托：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Anonymous methods were superseded in C# 3 when lambda expressions provided a
    more concise syntax for doing the same, as you saw in listing 2.2\. Anonymous
    methods survive as a vestigial feature of the language, but their use is discouraged.
    In the context of C# features, the term *anonymous functions* refers both to anonymous
    methods and to lambda expressions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当 lambda 表达式提供了更简洁的语法来执行相同操作时，C# 3 取代了匿名方法。匿名方法作为语言的遗迹特征幸存下来，但它们的用法是不被鼓励的。在
    C# 功能的上下文中，术语 *匿名函数* 既指匿名方法也指 lambda 表达式。
- en: Dictionaries
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 字典
- en: Dictionaries are fittingly also called maps (or hash tables). They’re data structures
    that provide a direct representation of a function. They literally contain the
    association of *keys* (elements from the domain) to *values* (the corresponding
    elements from the codomain).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也适当地被称为映射（或哈希表）。它们是提供函数直接表示的数据结构。它们实际上包含了对 *键*（来自定义域的元素）到 *值*（对应于值域的元素）的关联。
- en: We normally think of dictionaries as data, so it’s enriching to change perspectives
    for a moment and consider them as functions. Dictionaries are appropriate for
    representing functions that are completely arbitrary, where the mappings can’t
    be computed but *must* be stored exhaustively. For example, the following listing
    shows how you could map Boolean values to their names in French.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将字典视为数据，所以改变一下视角，将它们视为函数是有益的。字典适合表示完全任意的函数，其中映射无法计算但 *必须* 完全存储。例如，以下列表显示了如何将布尔值映射到法语中的名称。
- en: Listing 2.5 A dictionary exhaustively representing a function
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 完全表示函数的字典
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Function application is performed with a lookup.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数应用是通过查找来执行的。
- en: The fact that functions can be represented with dictionaries also makes it possible
    to optimize computationally expensive functions by storing their computed results
    in a dictionary instead of recomputing them every time. This technique is called
    *memoization*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以用字典表示的事实也使得通过在字典中存储计算结果而不是每次都重新计算来优化计算密集型函数成为可能。这种技术称为 *记忆化*。
- en: For convenience, in the rest of the book, I’ll use the term *function* to indicate
    one of the C# representations of a function. Keep in mind that this doesn’t quite
    match the mathematical definition of the term. You’ll learn more about the differences
    between mathematical and programming functions in chapter 3\.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，在本书的其余部分，我将使用术语 *函数* 来指代函数的 C# 表示之一。请记住，这并不完全符合该术语的数学定义。你将在第 3 章中了解更多关于数学函数和编程函数之间差异的信息。
- en: 2.2 Higher-order functions (HOFs)
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 高阶函数（HOFs）
- en: Now that you have an understanding of what FP is and we’ve reviewed the functional
    features of the language, it’s time to start exploring some concrete functional
    techniques. We’ll begin with the most important benefit of functions as first-class
    values—they give you the ability to define higher-order functions (HOFs).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了什么是 FP，我们也回顾了该语言的函数特性，是时候开始探索一些具体的函数技术了。我们将从函数作为一等值的最重要好处开始——它们让你能够定义高阶函数（HOFs）。
- en: HOFs are functions that take other functions as inputs or return a function
    as output or both. I’ll assume that you’ve already used HOFs to some extent, as
    with LINQ, for example. We’ll use HOFs *a lot* in this book, so this section should
    act as a refresher and will possibly introduce some use cases for HOFs that you
    may be less familiar with.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: HOFs 是接受其他函数作为输入或返回函数作为输出或两者都有的函数。我将假设你已经在使用 HOFs 方面有所了解，例如使用 LINQ。在这本书中，我们将大量使用
    HOFs，所以本节应该作为一个复习，并可能介绍一些你可能不太熟悉的 HOFs 用例。
- en: HOFs are fun, and most of the examples in this section can be run in the REPL.
    Make sure you try a few variations of your own along the way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数（HOFs）很有趣，本节中的大多数示例都可以在 REPL 中运行。确保你在这个过程中尝试一些自己的变体。
- en: 2.2.1 Functions that depend on other functions
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 依赖于其他函数的函数
- en: Some HOFs take other functions as arguments and invoke them in order to do their
    work, somewhat like the way a company may subcontract some of its work to another
    company. You’ve seen some examples of such HOFs earlier in this chapter, including
    `Sort` (an instance method on `List`) and `Where` (an extension method on `IEnumerable`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 HOFs 将其他函数作为参数并按顺序调用它们以完成工作，这有点像一家公司可能将一些工作分包给另一家公司。你已经在本章前面看到了一些这样的 HOFs
    的例子，包括 `Sort`（`List` 上的一个实例方法）和 `Where`（`IEnumerable` 上的一个扩展方法）。
- en: '`List.Sort` when called with a `Comparison` delegate is a method that says,
    “OK, I’ll sort myself, as long as you tell me how to compare any two elements
    that I contain.” `Sort` does the job of sorting, but the caller can decide what
    logic to use for comparing.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Comparison` 委托调用 `List.Sort` 时，这是一个表示“好吧，我会自己排序，只要你告诉我如何比较我所包含的任意两个元素”的方法。`Sort`
    执行排序任务，但调用者可以决定使用什么逻辑进行比较。
- en: Similarly, `Where` does the job of filtering, and the caller decides what logic
    determines whether an element should be included. You can represent the type of
    `Where` graphically as shown in figure 2.2.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Where` 执行过滤任务，调用者决定什么逻辑决定一个元素是否应该被包含。你可以将 `Where` 的类型用如图 2.2 所示的图形表示。
- en: '![](Images/CH02_F02_Buonanno2.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F02_Buonanno2.png)'
- en: Figure 2.2 `Where` is a HOF that takes a predicate function as input. It uses
    the predicate to decide which elements to include in the returned list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 `Where` 是一个接受谓词函数作为输入的高阶函数。它使用谓词来决定哪些元素应包含在返回的列表中。
- en: The following listing shows an idealized implementation of `Where`.[⁴](#pgfId-1107773)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `Where` 的理想化实现。[⁴](#pgfId-1107773)
- en: Listing 2.6 `Where`, a HOF that iteratively applies the given predicate
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 `Where`，一个迭代应用给定谓词的高阶函数
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Iterating over the list is an implementation detail of `Where`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历列表是 `Where` 的一个实现细节。
- en: ❷ The criterion determining which items are included is decided by the caller.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 决定哪些项目被包含的标准由调用者决定。
- en: The `Where` method is responsible for the filtering logic. The caller provides
    the *predicate*, which is the criterion based on which the `IEnumerable` should
    be filtered.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where` 方法负责过滤逻辑。调用者提供 *谓词*，这是基于该谓词对 `IEnumerable` 进行过滤的标准。'
- en: As you can see, HOFs can help with the separation of concerns in cases where
    logic can’t otherwise be easily separated. `Where` and `Sort` are examples of
    an *iterated application*—the HOF applies the given function repeatedly for every
    element in the collection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，HOFs可以帮助在逻辑难以轻易分离的情况下分离关注点。`Where`和`Sort`是迭代应用的例子——HOF对集合中的每个元素重复应用给定的函数。
- en: One crude way of looking at this is that you’re passing as the argument a function
    whose code will ultimately execute inside the body of a loop within the HOF. This
    is something you couldn’t do by only passing static data. The general scheme is
    shown in figure 2.3.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地看，这可以理解为您传递了一个函数作为参数，其代码最终将在HOF体内的循环体中执行。这是您仅通过传递静态数据无法做到的。一般方案如图2.3所示。
- en: '![](Images/CH02_F03_Buonanno2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F03_Buonanno2.png)'
- en: Figure 2.3 A HOF that iteratively applies the function given as an argument
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 重复应用作为参数提供的函数的HOF
- en: Optional execution is another good candidate for HOFs. This is useful when you
    want to invoke a given function only in certain conditions, as figure 2.4 illustrates.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可选执行是HOF的另一个很好的候选。这在您只想在特定条件下调用给定的函数时很有用，如图2.4所示。
- en: '![](Images/CH02_F04_Buonanno2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F04_Buonanno2.png)'
- en: Figure 2.4 A HOF that conditionally applies the function given as an argument
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 条件应用作为参数提供的函数的HOF
- en: For example, imagine a method that looks up an element from the cache. A delegate
    can be provided and can be invoked in case of a cache miss. The following listing
    shows how this is done.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一种从缓存中查找元素的方法。可以提供一个委托，并在缓存未命中时调用它。以下列表显示了如何实现这一点。
- en: Listing 2.7 A HOF that optionally invokes the given function
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 可选调用的HOF
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The logic in `onMiss` could involve an expensive operation, such as a database
    call. You wouldn’t want this to be executed unnecessarily.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMiss`中的逻辑可能涉及昂贵的操作，如数据库调用。您不希望这种操作被不必要地执行。'
- en: The preceding examples illustrate HOFs that take a function as input and use
    it to perform a task or to compute a value. This is perhaps the most common pattern
    for HOFs, and it’s sometimes referred to as *inversion of control*, where the
    caller of the HOF decides *what* to do by supplying a function, and the function
    decides *when* to do it by invoking the given function. Let’s look at some other
    scenarios in which HOFs come in handy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子说明了接受函数作为输入并使用它来执行任务或计算值的HOF。这可能是最常见的HOF模式，有时也被称为*控制反转*，其中HOF的调用者通过提供函数来决定*做什么*，而函数通过调用给定的函数来决定*何时做*。让我们看看HOF在其他哪些场景中很有用。
- en: 2.2.2 Adapter functions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 适配器函数
- en: 'Some HOFs don’t *apply* the given function at all, but rather return a new
    function that’s somehow related to the function given as an argument. For example,
    say you have a function that performs integer division:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些HOF根本不*应用*给定的函数，而是返回一个与作为参数提供的函数以某种方式相关的新的函数。例如，假设您有一个执行整数除法的函数：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You want to change the order of the arguments so that the divisor comes first.
    This could be seen as a particular case of a more general problem: changing the
    order of the arguments. You can write a generic HOF that modifies any binary function
    by swapping the order of its arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你想改变参数的顺序，使除数排在第一位。这可以看作是一个更一般问题的特例：改变参数的顺序。你可以编写一个通用的HOF，通过交换其参数的顺序来修改任何二元函数：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Technically, it would be more correct to say that `SwapArgs` returns a new
    function, which invokes the given function with the arguments in the reverse order.
    But on an intuitive level, I find it easier to think that I’m getting back a modified
    version of the original function. You can now modify the original division function
    by applying `SwapArgs`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，更准确的说法是`SwapArgs`返回一个新的函数，该函数以相反的顺序调用给定的函数。但在直观层面上，我发现认为我得到了原始函数的修改版本更容易。现在你可以通过应用`SwapArgs`来修改原始的除法函数：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Playing with this sort of HOF leads to the interesting idea that functions
    aren’t set in stone: if you don’t like the interface of a function, you can call
    it via another function that provides an interface that better suits your needs.
    That’s why I call these *adapter functions*.[⁵](#pgfId-1107838)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 玩这种类型的HOF会导致一个有趣的想法，即函数不是一成不变的：如果您不喜欢函数的接口，您可以通过另一个提供更适合您需求的接口的函数来调用它。这就是为什么我称这些为*适配器函数*。[⁵](#pgfId-1107838)
- en: 2.2.3 Functions that create other functions
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 创建其他函数的函数
- en: 'Sometimes you’ll write functions whose primary purpose is to create other functions.
    You can think of them as *function factories*. The following example uses a lambda
    to filter a sequence of numbers, keeping only those divisible by 2:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会编写主要目的是创建其他函数的函数。你可以把它们看作 *函数工厂*。以下示例使用 lambda 过滤一个数字序列，只保留能被 2 整除的数字：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What if you wanted something more general, like being able to filter for numbers
    divisible by any number *n*? You could define a function that takes *n* and yields
    a suitable predicate that evaluates whether any given number is divisible by *n*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更通用的东西，比如能够过滤出能被任何数字 *n* 整除的数字，你可以定义一个函数，它接受 *n* 并生成一个合适的谓词，用于评估任何给定的数字是否可以被
    *n* 整除：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We haven’t looked at a HOF like this before. It takes some static data and
    returns a function. Let’s see how you can use it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前还没有看过这样的 HOF。它接受一些静态数据并返回一个函数。让我们看看如何使用它：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how you’ve gained not only in generality but also in readability! In
    this example, you’re using the `isMod` HOF to produce a function, and then you’re
    feeding it as input to another HOF, `Where`, as figure 2.5 shows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不仅获得了通用性，还提高了可读性！在这个例子中，你使用 `isMod` HOF 生成一个函数，然后将它作为输入传递给另一个 HOF，`Where`，如图
    2.5 所示。
- en: '![](Images/CH02_F05_Buonanno2.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F05_Buonanno2.png)'
- en: Figure 2.5 Here we define `IsMod` as a HOF that returns a function telling us
    whether a number is divisible by some given value. We then take the resulting
    predicate and use it as input to `Where`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 在这里，我们将 `IsMod` 定义为一个 HOF，它返回一个函数，告诉我们一个数字是否可以被某个给定的值整除。然后我们使用生成的谓词作为
    `Where` 的输入。
- en: You’ll see many more uses of HOFs in this book. Eventually, you’ll look at them
    as regular functions, forgetting that they’re higher order. Let’s now look at
    how these can be used in a scenario closer to everyday development.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中看到更多关于 HOF 的用法。最终，你会把它们当作普通函数来看待，忘记它们是高阶的。现在让我们看看这些如何在更接近日常开发的场景中使用。
- en: 2.3 Using HOFs to avoid duplication
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用 HOF 避免重复
- en: Another common use case for HOFs is to encapsulate setup and teardown operations.
    For example, interacting with a database requires some setup to acquire and open
    a connection and some cleaning up after the interaction to close the connection
    and return it to the underlying connection pool. The following listing shows what
    this looks like in code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: HOF 的另一个常见用途是封装设置和清理操作。例如，与数据库交互需要一些设置来获取和打开连接，并在交互后进行清理以关闭连接并将其返回到底层连接池。以下列表展示了这在代码中的样子。
- en: Listing 2.8 Connecting to a DB with some setup and teardown
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 带有设置和清理的数据库连接
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '❶ Setup: acquire and open a connection'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置：获取并打开连接
- en: '❷ Teardown: close and release the connection'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 清理：关闭并释放连接
- en: 'The setup and teardown are always identical, regardless of whether you’re reading
    or writing to the database, or performing one or many actions. The preceding code
    is usually written with a `using` block like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和清理总是相同的，无论你是读取还是写入数据库，或者执行一个或多个操作。前面的代码通常使用如下 `using` 块编写：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is both shorter and better, but it’s still essentially the same.[⁶](#pgfId-1107902)
    Consider the following listing, showing a simple `DbLogger` class with a couple
    of methods that interact with the database. `Log` inserts a given log message,
    and `GetLogs` retrieves all logs since a given date.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这既简短又好，但本质上仍然是相同的。[⁶](#pgfId-1107902) 考虑以下列表，展示了一个简单的 `DbLogger` 类，它包含一些与数据库交互的方法。`Log`
    方法插入给定的日志消息，而 `GetLogs` 方法检索自给定日期以来的所有日志。
- en: Listing 2.9 Duplication of setup/teardown logic
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 设置/清理逻辑的重复
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Exposes `Execute` and `Query` as extension methods on the connection
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 `Execute` 和 `Query` 作为扩展方法暴露在连接上
- en: ❷ Assume this is set in the constructor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 假设这是在构造函数中设置的。
- en: ❸ Setup
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置
- en: ❹ Persists the `LogMessage` to the database
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 `LogMessage` 持久化到数据库
- en: ❺ Performs teardown as part of `Dispose`
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 作为 `Dispose` 部分执行清理
- en: ❻ Setup
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 设置
- en: ❼ Queries the database and deserializes the results
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 查询数据库并反序列化结果
- en: ❽ Teardown
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 清理
- en: 'It’s not essential that you understand the code in detail. The code uses Dapper
    ([https://github.com/StackExchange/dapper-dot-net](https://github.com/StackExchange/dapper-dot-net)),
    a thin layer on top of ADO.NET, allowing you to interact with the database through
    a simple API:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 详细理解代码不是必需的。该代码使用 Dapper ([https://github.com/StackExchange/dapper-dot-net](https://github.com/StackExchange/dapper-dot-net))，这是
    ADO.NET 之上的一个薄层，允许您通过简单的 API 与数据库交互：
- en: '`Query`—Queries the database and returns the deserialized `LogMessage`s'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query`——查询数据库并返回反序列化的 `LogMessage`s'
- en: '`Execute`—Runs the stored procedure and returns the number of affected rows,
    which we’re disregarding'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Execute`——运行存储过程并返回受影响的行数，我们忽略它'
- en: The important thing to notice is that the two methods have some duplication;
    namely, the setup and teardown logic. Can we get rid of the duplication?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这两种方法有一些重复；即设置和拆除逻辑。我们能消除这种重复吗？
- en: NOTE In a real-world scenario, I’d recommend you always perform I/O operations
    asynchronously. In this example, `GetLogs` should really call `QueryAsync` and
    return a `Task<IEnumerable<LogMessage>>`). But asynchrony adds a level of complexity
    that’s not helpful while you’re trying to learn the already challenging ideas
    of FP. For pedagogical purposes, I’ll wait until chapter 16 to discuss asynchrony.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在实际场景中，我建议你始终异步执行 I/O 操作。在这个例子中，`GetLogs` 应该真正调用 `QueryAsync` 并返回 `Task<IEnumerable<LogMessage>>`)。但是异步增加了复杂性，这在尝试学习
    FP 的挑战性概念时并不 helpful。出于教学目的，我将在第 16 章讨论异步。
- en: As you can see, `Dapper` exposes a pleasant API, and it even opens the connection
    if necessary. But you’re still required to create the connection, and you should
    dispose it as soon as possible once you’re done with it. As a result, the “meat”
    of your database calls ends up sandwiched between identical pieces of code that
    perform setup and teardown. Let’s look at how you can avoid this duplication by
    extracting the setup and teardown logic into a HOF.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Dapper` 提供了一个令人愉悦的 API，它甚至会在必要时打开连接。但你仍然需要创建连接，一旦完成，你应该尽快将其释放。因此，数据库调用的“肉”最终被设置和拆除的相同代码片段所包围。让我们看看如何通过将设置和拆除逻辑提取到
    HOF 中来避免这种重复。
- en: You’re looking to write a function that performs setup and teardown and that’s
    parameterized on what to do in between. This is a perfect scenario for a HOF because
    you can represent the logic in between with a function.[⁷](#pgfId-1107954) Graphically,
    it looks like figure 2.6.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在编写一个执行设置和拆除的函数，并且参数化中间要执行的操作。这是一个完美的 HOF 场景，因为你可以用一个函数来表示中间的逻辑。[⁷](#pgfId-1107954)
    从图形上看，它看起来像图 2.6。
- en: '![](Images/CH02_F06_Buonanno2.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F06_Buonanno2.png)'
- en: Figure 2.6 A HOF that wraps a given function between setup and teardown logic
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 一个封装在设置和拆除逻辑之间的给定函数的 HOF
- en: Because connection setup and teardown are much more general than `DbLogger`,
    they can be extracted to a new `ConnectionHelper` class. The following listing
    provides an example of this.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为连接设置和拆除比 `DbLogger` 更通用，所以它们可以被提取到一个新的 `ConnectionHelper` 类中。下面的列表提供了一个例子。
- en: Listing 2.10 Encapsulating setup and teardown of the DB connection into a HOF
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 将数据库连接的设置和拆除封装到 HOF 中
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Setup
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置
- en: ❷ What happens in between is now parameterized.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 中间发生的事情现在是参数化的。
- en: ❸ Teardown
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 拆除
- en: The `Connect` function performs the setup and teardown, and it’s parameterized
    by what it should do in between. The signature of the body is interesting; it
    takes an `IDbConnection` (through which it will interact with the database) and
    returns a generic object `R`. In the use cases we’ve seen, `R` will be `IEnumerable<LogMessage>`
    in the case of the query and `int` in the case of the insert.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connect` 函数执行设置和拆除，并且它通过中间要执行的操作进行参数化。函数体的签名很有趣；它接受一个 `IDbConnection`（通过它将与数据库交互）并返回一个泛型对象
    `R`。在我们看到的用例中，`R` 在查询的情况下将是 `IEnumerable<LogMessage>`，在插入的情况下将是 `int`。'
- en: 'You can now use the `Connect` function in `DbLogger` as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在 `DbLogger` 中使用 `Connect` 函数，如下所示：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You got rid of the duplication in `DbLogger`, so `DbLogger` no longer needs
    to know the details about creating, opening, or disposing of the connection. By
    now, I hope you agree that HOFs are powerful tools, although overuse can make
    it difficult to understand what the code is doing. Use HOFs when appropriate but
    be mindful of readability: use short lambdas, clear naming, and meaningful indentation.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经消除了 `DbLogger` 中的重复，因此 `DbLogger` 就不再需要知道创建、打开或释放连接的细节。到现在为止，我希望你同意 HOF 是强大的工具，尽管过度使用可能会使代码难以理解。在适当的时候使用
    HOF，但要注意可读性：使用短的 lambda 表达式、清晰的命名和有意义的缩进。
- en: Exercises
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'I recommend you take the time to do the exercises and come up with a few of
    your own along the way. The code samples repository on GitHub ([http://mng.bz/10Pj](http://mng.bz/10Pj))
    includes placeholders so that you can write, compile, and run your code with minimal
    setup effort. It also includes solutions that you can check your results against:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你花时间做练习，并在过程中想出一些自己的。GitHub 上的代码示例存储库（[http://mng.bz/10Pj](http://mng.bz/10Pj)）包括占位符，这样你就可以用最少的设置工作编写、编译和运行你的代码。它还包括你可以对照检查结果的解决方案：
- en: Browse the methods of `System.Linq.Enumerable` ([http://mng.bz/PX6n](http://mng.bz/PX6n)).
    Which are HOFs? Which do you think imply iterated application of the given function?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览 `System.Linq.Enumerable` 的方法（[http://mng.bz/PX6n](http://mng.bz/PX6n)）。哪些是高阶函数（HOFs）？你认为哪些暗示了给定函数的迭代应用？
- en: 'Write a function that negates a given predicate: when the given predicate evaluates
    to `true`, the resulting function evaluates to `false` and vice versa.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个否定给定谓词的函数：当给定的谓词评估为 `true` 时，结果函数评估为 `false`，反之亦然。
- en: Write a method that uses quicksort to sort a `List<int>`, returning a new list
    rather than sorting it in place.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用快速排序对 `List<int>` 进行排序的方法，返回一个新的列表而不是就地排序。
- en: Generalize the previous implementation to take a `List<T>` and a `Comparison<T>`
    delegate.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前的实现泛化以接受 `List<T>` 和 `Comparison<T>` 委托。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Mathematical functions simply define a mapping between two sets.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学函数简单地定义了两个集合之间的映射。
- en: You can represent functions in C# using methods, delegates, lambdas, and dictionaries.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用方法、委托、lambda 表达式和字典在 C# 中表示函数。
- en: FP leverages higher-order functions (HOFs), which are functions that take other
    functions as input or output); hence, the necessity for the language to have functions
    as first-class values.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程（FP）利用高阶函数（HOFs），这些函数接受其他函数作为输入或输出；因此，语言需要将函数作为一等值。
- en: '* * *'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ Interfaces in the OO sense are an extension of this idea: a set of functions
    with their respective input and output types or, more precisely, methods (which
    are essentially functions) that take `this` (the current instance) as an implicit
    argument.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 在面向对象（OO）的层面上，接口是这一想法的扩展：一组具有相应输入和输出类型或更精确地说，方法（本质上就是函数）的方法，这些方法将 `this`（当前实例）作为隐式参数。
- en: ² A *predicate* is a function that, given a value (say, an integer), tells you
    whether it satisfies some condition (say, whether it’s even).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ² 一个 *谓词* 是一个函数，给定一个值（比如说，一个整数），告诉你它是否满足某些条件（比如说，它是否是偶数）。
- en: ³ A *closure* is the combination of the lambda expression itself along with
    the context in which that lambda is declared (all the variables available in the
    scope where the lambda appears).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 一个 *闭包* 是 lambda 表达式本身及其声明的上下文的组合（lambda 出现的作用域中所有可用的变量）。
- en: ⁴ This implementation is functionally correct, but it lacks the error checking
    and optimizations in the LINQ implementation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 此实现功能上是正确的，但它缺少 LINQ 实现中的错误检查和优化。
- en: ⁵ The well-known adapter pattern in OOP can be seen as applying the idea of
    adapter functions to an object’s interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 在面向对象（OOP）中，著名的适配器模式可以看作是将适配函数的思想应用于对象的接口。
- en: ⁶ It’s shorter because `Dispose` is called as you exit the `using` block, which
    will, in turn, call `Close`. It’s better because the interaction is then wrapped
    in a `try/finally` block, so the connection is disposed even if an exception is
    thrown in the body of the `using` block.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ 它更短，因为 `Dispose` 在退出 `using` 块时被调用，这将反过来调用 `Close`。它更好，因为交互被包裹在一个 `try/finally`
    块中，所以即使在 `using` 块的主体中抛出异常，连接也会被释放。
- en: ⁷ For this reason, you may hear this pattern inelegantly called a “hole in the
    middle.”
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 因此，你可能会听到这种模式被不优雅地称为“中间的洞”。
