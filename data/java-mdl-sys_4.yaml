- en: appendix B
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附录B
- en: High-level introduction to the reflection API
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 反射API的高级介绍
- en: 'Reflection allows code to inspect types, methods, fields, annotations, and
    so forth at run time and to defer the decision about how to use them from compile
    time to run time. Toward that end, Java’s reflection API offers types like `Class`,
    `Field`, `Constructor`, `Method`, `Annotation`, and others. With them, it’s possible
    to interact with types that weren’t known at compile time: for example, to create
    instances of an unknown class and call methods on them.'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 反射允许代码在运行时检查类型、方法、字段、注解等，并将如何使用它们的决策从编译时推迟到运行时。为此，Java的反射API提供了`Class`、`Field`、`Constructor`、`Method`、`Annotation`等类型。有了它们，就可以与编译时未知类型进行交互：例如，创建未知类的实例并在其上调用方法。
- en: Reflection and its use cases can quickly become complex, and I’m not going to
    explain it in detail. Instead, this appendix is intended to give you a high-level
    understanding of what reflection is, what it looks like in Java, and what you
    or your dependencies can use it for.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 反射及其用例可能会迅速变得复杂，我不会对其进行详细解释。相反，本附录旨在让你对反射是什么、在Java中看起来如何以及你可以或你的依赖项用它做什么有一个高级的理解。
- en: Afterward, you’ll be ready to get started using it or work through longer tutorials,
    such as Oracle’s The Reflection API trail at [https://docs.oracle.com/javase/tutorial/reflect](https://docs.oracle.com/javase/tutorial/reflect).
    More important, though, you’ll be prepared to understand the changes the module
    system makes with regard to reflection, which section 7.1.4 and particularly chapter
    12 explore.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 之后，你将准备好开始使用它或学习更长的教程，例如Oracle的《反射API教程》[https://docs.oracle.com/javase/tutorial/reflect](https://docs.oracle.com/javase/tutorial/reflect)。更重要的是，你将准备好理解模块系统对反射所做的更改，第7.1.4节和第12章特别探讨了这一点。
- en: 'Instead of building from the ground up, let’s start with a simple example.
    The following snippet creates a URL, converts it to a string, and then prints
    that. Before resorting to reflection, I used plain Java code:'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而不是从头开始构建，让我们从一个简单的例子开始。下面的代码片段创建了一个URL，将其转换为字符串，然后打印出来。在求助于反射之前，我使用了普通的Java代码：
- en: '`URL url = new URL("http://codefx.org"); String urlString = url.toExternalForm();
    System.out.println(urlString);`'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`URL url = new URL("http://codefx.org"); String urlString = url.toExternalForm();
    System.out.println(urlString);`'
- en: 'I decided at compile time (meaning, when I was writing the code) that I wanted
    to create a `URL` object and call a method in it. Even though that’s not the most
    natural way to do it, you can split the first two lines into five steps:'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在编译时（即，当我编写代码时）决定我想创建一个`URL`对象并在其中调用一个方法。尽管这不是最自然的方法，但你可以将前两行分成五个步骤：
- en: Reference the URL class.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引用URL类。
- en: Locate the constructor taking a single string parameter.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位接受单个字符串参数的构造函数。
- en: Call it with `http://codefx.org`.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`http://codefx.org`调用它。
- en: Locate the method `toExternalForm`.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位`toExternalForm`方法。
- en: Call it on the `url` instance.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`url`实例上调用它。
- en: The following listing shows how to implement those five steps with Java’s reflection
    API.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用Java的反射API实现这五个步骤。
- en: Listing B.1 Reflectively creating a `URL` and calling `toExternalForm` on it
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表B.1 使用反射创建`URL`并在其上调用`toExternalForm`
- en: '`Class<?> urlClass = Class.forName("java.net.URL");` [`①`](part0032.html#filepos1986162)
    `Constructor<?> urlConstructor` `= urlClass.getConstructor(String.class);` [`②`](part0032.html#filepos1986546)
    `Object url =` `urlConstructor.newInstance("http://codefx.org");` [`③`](part0032.html#filepos1986906)
    `Method toExternalFormMethod =` `urlClass.getMethod("toExternalForm");` [`④`](part0032.html#filepos1987283)
    `Object methodCallResult =` `toExternalFormMethod.invoke(url);` [`⑤`](part0032.html#filepos1987624)'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Class<?> urlClass = Class.forName("java.net.URL");` [`①`](part0032.html#filepos1986162)
    `Constructor<?> urlConstructor = urlClass.getConstructor(String.class);` [`②`](part0032.html#filepos1986546)
    `Object url = urlConstructor.newInstance("http://codefx.org");` [`③`](part0032.html#filepos1986906)
    `Method toExternalFormMethod = urlClass.getMethod("toExternalForm");` [`④`](part0032.html#filepos1987283)
    `Object methodCallResult = toExternalFormMethod.invoke(url);` [`⑤`](part0032.html#filepos1987624)'
- en: ①
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: The Class instance for the class to operate on is the gateway to reflection.
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要操作类的Class实例是反射的入口。
- en: ②
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Fetches the constructor that takes a String argument
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取接受String参数的构造函数
- en: ③
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Uses it to create a new instance with the given string as a parameter
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用它以给定的字符串作为参数创建一个新的实例
- en: ④
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Fetches the toExternalForm method
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取`toExternalForm`方法
- en: ⑤
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: Invokes the method in the instance that was created earlier
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调用之前创建的实例中的方法
- en: Using the reflection API is, of course, more cumbersome than writing the code
    directly. But this way, details that used to be baked into the code (like using
    `URL`, or which method is called) become a string parameter. As a consequence,
    instead of having to settle on `URL` and `toExternalForm` at compile time, you
    could decide which type and method to pick later, when the program is already
    running.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用反射 API 比直接编写代码要繁琐。但这种方式，以前通常嵌入到代码中的细节（如使用 `URL` 或调用哪个方法）变成了字符串参数。因此，你不必在编译时决定使用
    `URL` 和 `toExternalForm`，而可以在程序运行时决定选择哪种类型和方法。
- en: Most use cases for this occur in “frameworky” environments. Think about JUnit,
    for example, which wants to execute all methods that are annotated with `@Test`.
    Once it finds them, it uses `getMethod` and `invoke` to call them. Spring and
    other web frameworks act similarly when looking for controllers and request mappings.
    Extensible applications that want to load user-provided plugins at run time are
    another use case.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种用法的大多数情况都发生在“框架化”环境中。以 JUnit 为例，它希望执行所有被 `@Test` 注解的方法。一旦找到它们，它就使用 `getMethod`
    和 `invoke` 来调用它们。Spring 和其他 Web 框架在查找控制器和请求映射时也以类似的方式操作。希望在运行时加载用户提供的插件的可扩展应用程序是另一个用例。
- en: Fundamental types and methods
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基本类型和方法
- en: The gateway into the reflection API is `Class::forName`. In its simple form,
    this static method takes a fully qualified class name and returns a `Class` instance
    for it. You can use that instance to get fields, methods, constructors, and more.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 反射 API 的入口是 `Class::forName`。在其简单形式中，这个静态方法接受一个完全限定的类名，并返回一个对应的 `Class` 实例。你可以使用这个实例来获取字段、方法、构造函数等。
- en: To get a specific constructor, call the `getConstructor` method with the types
    of the constructor arguments, as I did earlier. Similarly, a specific method can
    be accessed by calling `getMethod` and passing its name as well as the parameter
    types.
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要获取特定的构造函数，使用构造函数参数的类型调用 `getConstructor` 方法，就像我之前做的那样。同样，可以通过调用 `getMethod`
    并传递其名称以及参数类型来访问特定的方法。
- en: 'The call to `getMethod("toExternalForm")` didn’t specify any types because
    the method has no arguments. Here’s `URL.openConnection(Proxy)`, which takes a
    `Proxy` as a parameter:'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调用 `getMethod("toExternalForm")` 没有指定任何类型，因为该方法没有参数。这是 `URL.openConnection(Proxy)`，它接受一个
    `Proxy` 参数：
- en: '`Class<?> urlClass = Class.forName("java.net.URL"); Method openConnectionMethod
    = urlClass .getMethod("openConnection", Proxy.class);`'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Class<?> urlClass = Class.forName("java.net.URL"); Method openConnectionMethod
    = urlClass.getMethod("openConnection", Proxy.class);`'
- en: The instances returned by calls to `getConstructor` and `getMethod` are of type
    `Constructor` and `Method`, respectively. To call the underlying member, they
    offer methods like `Constructor::newInstance` and `Method::invoke`. An interesting
    detail of the latter is that you need to pass the instance on which the method
    is to be called as the first argument. The other arguments will be passed on to
    the called method.
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`getConstructor` 和 `getMethod` 调用返回的实例分别是 `Constructor` 和 `Method` 类型。要调用底层成员，它们提供了如
    `Constructor::newInstance` 和 `Method::invoke` 这样的方法。后者一个有趣的细节是，你需要将方法要调用的实例作为第一个参数传递。其他参数将被传递给被调用的方法。'
- en: 'Continuing the `openConnection` example:'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 继续使用 `openConnection` 示例：
- en: '`openConnectionMethod.invoke(url, someProxy);`'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`openConnectionMethod.invoke(url, someProxy);`'
- en: If you want to call a static method, the instance argument is ignored and can
    be `null`.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想调用一个静态方法，实例参数将被忽略，可以是 `null`。
- en: In addition to `Class`, `Constructor`, and `Method`, there is also `Field`,
    which allows read and write access to instance fields. Calling `get` with an instance
    retrieves the value that field has in that instance—the `set` method sets the
    specified value in the specified instance.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了 `Class`、`Constructor` 和 `Method` 之外，还有一个 `Field`，它允许对实例字段进行读写访问。使用实例调用 `get`
    方法可以检索该字段在实例中的值——`set` 方法在指定的实例中设置指定的值。
- en: 'The `URL` class has an instance field `protocol` of type `String`; for the
    URL [http://codefx.org](http://codefx.org), it would contain `"http"`. Because
    it’s private, code like this won’t compile:'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`URL` 类有一个实例字段 `protocol`，其类型为 `String`；对于 URL [http://codefx.org](http://codefx.org)，它将包含
    `"http"`。因为它私有，所以像这样的代码无法编译：'
- en: '`URL url = new URL("http://codefx.org"); // no access to a private field ~>
    compile error url.protocol = "https";`'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`URL url = new URL("http://codefx.org"); // 无法访问私有字段 ~> 编译错误 url.protocol =
    "https";`'
- en: 'Here’s how to do the same thing with reflection:'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是使用反射来完成相同任务的方法：
- en: '``// `Class<?> urlClass` and `Object url` are like before Field protocolField
    = urlClass.getDeclaredField("protocol"); Object oldProtocol = protocolField.get(url);
    protocolField.set(url, "https");``'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '``// `Class<?> urlClass` 和 `Object url` 与之前相同 Field protocolField = urlClass.getDeclaredField("protocol");
    Object oldProtocol = protocolField.get(url); protocolField.set(url, "https");``'
- en: Although this compiles, it still leads to an `IllegalAccessException` on the
    `get` call, because the `protocol` field is private. But that doesn’t have to
    stop you.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这可以编译，但它仍然会在 `get` 调用中导致 `IllegalAccessException`，因为 `protocol` 字段是私有的。但这并不意味着你不能继续。
- en: Breaking into APIs with setAccessible
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `setAccessible` 突破 API
- en: One important use case for reflection has always been to break into APIs by
    accessing nonpublic types, methods, and fields. This is called deep reflection.
    Developers use it to access data that an API doesn’t make accessible, to work
    around bugs in their dependencies by twiddling with the internal state, and to
    dynamically populate instances with the correct values—Hibernate does this, for
    example.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 反射的一个重要用例一直是通过访问非公共类型、方法和字段来突破 API。这被称为深度反射。开发者使用它来访问 API 不提供访问权限的数据，通过调整内部状态来解决依赖项中的错误，以及动态填充实例以正确的值——例如，Hibernate
    就这样做。
- en: 'For deep reflection, you need to do nothing more that call `setAccessible(true)`
    on a `Method`, `Constructor`, or `Field` instance before using it:'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于深度反射，你需要在使用之前对 `Method`、`Constructor` 或 `Field` 实例调用 `setAccessible(true)`：
- en: '``// `Class<?> urlClass` and `Object url` are like before Field protocolField
    = urlClass.getDeclaredField("protocol"); protocolField.setAccessible(true); Object
    oldProtocol = field.get(url); protocolField.set(instance, "https");``'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '``// `Class<?> urlClass` 和 `Object url` 与之前相同 Field protocolField = urlClass.getDeclaredField("protocol");
    protocolField.setAccessible(true); Object oldProtocol = field.get(url); protocolField.set(instance,
    "https");``'
- en: One challenge when migrating to the module system is that it takes away reflection’s
    superpowers, meaning calls to `setAccessible` are much more likely to fail. For
    more on that and how to remedy it, check chapter 12.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当迁移到模块系统时，一个挑战是它剥夺了反射的超级能力，这意味着对 `setAccessible` 的调用更有可能失败。关于这一点以及如何补救，请参阅第
    12 章。
- en: Annotations mark code for reflection
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注解标记代码以供反射
- en: Annotations are an important part of reflection. In fact, annotations are geared
    toward reflection. They’re meant to provide metainformation that can be accessed
    at run time and is then used to shape the program’s behavior. JUnit’s `@Test`
    and Spring’s `@Controller` and `@RequestMapping` are prime examples.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注解是反射的重要组成部分。实际上，注解是为反射设计的。它们的目的是提供在运行时可以访问并在之后用于塑造程序行为的元信息。JUnit 的 `@Test`
    和 Spring 的 `@Controller` 以及 `@RequestMapping` 是主要的例子。
- en: 'All important reflection-related types like `Class`, `Field`, `Constructor`,
    `Method`, and `Parameter` implement the `AnnotatedElement` interface. Its Javadoc
    contains a thorough explanation of how annotations can relate to these elements
    (directly present, indirectly present, or associated), but its simplest form is
    this: the `getAnnotations` method returns the annotations present on that element
    in form of an array of `Annotation` instances, whose members can then be accessed.'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有重要的反射相关类型，如 `Class`、`Field`、`Constructor`、`Method` 和 `Parameter` 都实现了 `AnnotatedElement`
    接口。它的 Javadoc 包含了关于注解如何与这些元素相关联的详细解释（直接存在、间接存在或关联），但它的最简单形式是这样的：`getAnnotations`
    方法返回一个 `Annotation` 实例数组，该数组的成员可以被访问。
- en: But in the context of the module system, how you or the frameworks you depend
    on process annotations is less important than the underlying fact that they only
    work with reflection. That means any class you see that has some annotations on
    it will at some point be reflected over—and if that class is in a module, that
    won’t necessarily work out of the box.
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但在模块系统的背景下，你或你依赖的框架如何处理注解，这比它们仅通过反射来工作的基本事实要次要。这意味着任何带有注解的类在某个时刻都会被反射——如果这个类在模块中，这不一定能直接工作。
