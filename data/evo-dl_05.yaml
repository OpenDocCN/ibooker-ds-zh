- en: 4 More evolutionary computation with DEAP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 使用DEAP进行更多进化计算
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Developing regression solvers with genetic programming in DEAP
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DEAP中使用遗传编程开发回归求解器
- en: Applying particle swarm optimization to solve for unknowns in complex functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将粒子群优化应用于求解复杂函数中的未知数
- en: Breaking a problem into components and coevolving a solution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题分解成组件并协同进化解决方案
- en: Understanding and applying evolutionary strategies to approximating solutions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和应用进化策略来近似解
- en: Approximating continuous and discontinuous solutions with differentiable evolution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可微分的进化近似连续和离散解
- en: In chapter 3, we just started to scratch the surface of what evolutionary computation
    looks like by introducing GAs. Starting with GA helps us set several foundations
    we continue to develop in this chapter. We also continue our progression from
    GA by exploring other evolutionary search methods for solving more specialized
    and complex problems. In this chapter, we look at other forms of the evolutionary
    search for solving a wider variety of problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们通过介绍GA开始探索进化计算的外观，只是触及了表面。从GA开始帮助我们建立几个在本章中继续发展的基础。我们还通过探索其他用于解决更专业和复杂问题的进化搜索方法来继续我们的GA探索。在本章中，我们考察了其他形式的进化搜索来解决更广泛的问题。
- en: There are a wide variety and forms of evolutionary algorithms, each with different
    strengths and weaknesses. Understanding other available options strengthens our
    understanding of where to apply which algorithm. As seen in this chapter, there
    is more than one way to peel an orange.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种各样和形式的进化算法，每种算法都有其不同的优势和劣势。了解其他可用的选项可以加强我们对在哪里应用哪种算法的理解。正如本章所看到的，剥橙子的方法不止一种。
- en: 4.1 Genetic programming with DEAP
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 使用DEAP进行遗传编程
- en: We have already used DEAP extensively for developing GA solutions to a variety
    of problems. In the following notebook, we continue to use DEAP to explore a subset
    of EC/GA called *genetic programming* (GP). GP follows the same principles of
    GA and employs many of the same genetic operators. The key difference between
    GA and GP is the structure of the `gene` or `chromosome` and how `fitness` is
    evaluated. Genetic programming and gene expression programming (GEP) can be used
    to solve a diverse set of automation and control problems, as discussed later
    in this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经广泛使用DEAP开发GA解决方案来解决各种问题。在下面的笔记本中，我们继续使用DEAP来探索EC/GA的一个子集，称为*遗传编程*（GP）。GP遵循与GA相同的原理，并采用许多相同的遗传算子。GA和GP之间的关键区别在于`基因`或`染色体`的结构以及如何评估`适应度`。遗传编程和基因表达编程（GEP）可以用于解决各种自动化和控制问题，如本书后面所讨论的。
- en: The notebook we develop in this section demonstrates one application of genetic
    programming for solving regression. GEP could also be applied to a variety of
    other problems, from optimization to search. Demonstrating regression, however,
    is the most relevant for our purposes, since it is comparable to how we can solve
    the same problem with DL.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中开发的笔记本展示了遗传编程在解决回归问题中的一个应用。GEP也可以应用于各种其他问题，从优化到搜索。然而，展示回归对于我们的目的来说最为相关，因为它与我们如何使用深度学习（DL）解决相同问题的方法相似。
- en: In this notebook, we are solving a problem of multivariable regression, using
    GEP to derive a solution equation. The goal is that this equation successfully
    regresses or predicts an output value, given several input values. This example
    only uses random inputs pre-fed into a target equation to validate the results.
    However, this method can and has been used to perform regression, in a similar
    manner that we would use in DL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个笔记本中，我们通过使用GEP推导出一个解方程来解决多元回归问题。目标是这个方程能够成功回归或预测给定几个输入值的一个输出值。这个例子只使用预先输入到目标方程中的随机输入来验证结果。然而，这种方法可以并且已经被用来执行回归，类似于我们在深度学习（DL）中使用的样子。
- en: 4.1.1 Solving regression with genetic programming
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 使用遗传编程解决回归问题
- en: You can start the exercise by opening the EDL_4_1_GP_Regression.ipynb notebook
    in Google Colab. If you need assistance opening the file, consult the appendix.
    This exercise may feel similar to the DEAP exercises in chapter 3\. For ease of
    use, go ahead and run all the cells in the notebook using the menu Runtime > Run
    All.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Google Colab中打开EDL_4_1_GP_Regression.ipynb笔记本开始练习。如果您需要打开文件的帮助，请参阅附录。这个练习可能感觉与第3章中的DEAP练习相似。为了方便使用，请使用菜单“运行”>“运行所有单元格”来运行笔记本中的所有单元格。
- en: 'We can skip the first few code cells that do setup and imports to focus on
    the first piece of new code shown in listing 4.1\. This code essentially defines
    a special set of `genes` we can represent in an `individual`. In this code, we
    can see the definition of three distinct types of `genes`: the operator, constant,
    and input or argument. To understand this code, let’s take a step back and look
    at how GP works.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以跳过前几个设置和导入的代码单元，专注于列表 4.1 中显示的第一个新代码片段。这段代码本质上定义了我们可以在 `个体` 中表示的特殊 `基因`
    集合。在这段代码中，我们可以看到三种不同类型 `基因` 的定义：运算符、常量和输入或参数。为了理解这段代码，让我们退一步看看 GP 是如何工作的。
- en: 'Listing 4.1 EDL_4_1_GP_Regression.ipynb: Setting up the expression'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 EDL_4_1_GP_Regression.ipynb：设置表达式
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Starts by creating and naming the primitive set
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先创建并命名原始集合
- en: ❷ Adds the operators to the set
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将运算符添加到集合中
- en: ❸ Adds ephemeral constants to the set
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向集合中添加临时常量
- en: ❹ Adds the variable inputs
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 添加变量输入
- en: Genetic programming (GP) allows us to be more specialized in the type of problems
    we solve and how we solve them. With GP, we don’t just search for novel solutions
    but, rather, develop mathematical functions or programmatic code that can be used
    to derive such solutions. The benefit here is that these functions can be reused
    or investigated for a better understanding of specific problems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传编程（GP）使我们能够更专注于我们解决的问题类型以及解决方式。使用 GP，我们不仅寻找新的解决方案，而且开发出可以用来推导这些解决方案的数学函数或程序代码。这里的优势在于，这些函数可以被重用或研究，以更好地理解特定问题。
- en: In GEP, each `gene` represents either an operator, constant, or input, and the
    entire `chromosome` or `gene` sequence represents an expression tree, where an
    operator could represent something as simple as addition or subtraction or as
    complex as programmatic functions. Constants and inputs/arguments, then, represent
    single scalar values or more complex arrays and tensors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GEP 中，每个 `基因` 代表一个运算符、常量或输入，整个 `染色体` 或 `基因` 序列代表一个表达式树，其中运算符可以代表像加法或减法这样简单的操作，或者像程序函数这样复杂的操作。常量和输入/参数，然后，代表单个标量值或更复杂的数组和张量。
- en: Figure 4.1 demonstrates the `gene` sequence of an `individual` that may be consumed
    by GP. In the diagram, you can see how the order of operators and inputs/constants
    forms an expression tree that can be evaluated as an equation, which can then
    be evaluated using mathematical rules. The output of this equation can then be
    compared against some target value to determine the amount of error or `fitness`
    of the `individual`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 展示了 GP 可能消费的 `个体` 的 `基因` 序列。在图中，你可以看到运算符和输入/常量的顺序如何形成一个可以评估为方程的表达式树，然后可以使用数学规则进行评估。该方程的输出可以与某个目标值进行比较，以确定
    `个体` 的错误量或 `适应度`。
- en: '![](../Images/CH04_F01_Lanham.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F01_Lanham.png)'
- en: Figure 4.1 Example GP `individual` to expression tree to equation to `fitness`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 示例 GP `个体` 到表达式树到方程到 `适应度`
- en: The `gene` sequence pictured in figure 4.1 shows how the order of the operators,
    inputs/arguments, and constants form an uneven leaf node expression tree. Looking
    at the `gene` sequence, we can see the first operator is *, which maps to the
    root of the tree. From those, the next two `genes` extend to first-level nodes,
    represented by the + and √ operators. The next two `genes` in the sequence map
    to the + node. Following that, the – operator is attached to the √ node, and finally,
    the last `genes` map to the bottom nodes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 中所示的 `基因` 序列展示了运算符、输入/参数和常量的顺序如何形成一个不均匀的叶节点表达式树。查看 `基因` 序列，我们可以看到第一个运算符是
    *，它映射到树的根。从这些运算符中，接下来的两个 `基因` 扩展到第一级节点，由 + 和 √ 运算符表示。序列中的下一个两个 `基因` 映射到 + 节点。随后，–
    运算符附加到 √ 节点，最后，最后的 `基因` 映射到底部节点。
- en: The number of subnodes formed of each node depends on the order of the operator.
    Where the order of an operator could be unary, binary, ternary or *n*-nary in
    scope. For simplicity, in this example, we use binary operators *, –, and + and
    the unary operator √. Inputs and constants do not have an order and always represent
    leaf nodes in an expression tree.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点形成的子节点数量取决于运算符的顺序。运算符的顺序可以是单目、双目、三目或 *n*-目。为了简化，在这个例子中，我们使用双目运算符 *, – 和
    + 以及单目运算符 √。输入和常量没有顺序，并且始终表示表达式树中的叶节点。
- en: From the expression tree, an equation can be evaluated with a result representing
    some target output. This targeted output is compared to the expected value in
    a form of supervised learning, with the difference representing the error or,
    in this case, `fitness`. The goal in this problem is to reduce the `fitness` or
    error to a minimum value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从表达式树中，可以通过一个表示某些目标输出的结果来评估一个方程。这个目标输出与监督学习中的预期值进行比较，差异表示错误或，在这种情况下，`fitness`。在这个问题中的目标是减少`fitness`或错误到最小值。
- en: We can scroll down from the last code block we looked at in the notebook and
    past the cells that create the `creator` to the start of the `toolbox` setup.
    After the `toolbox` is created, the next line sets up the expression tree evaluator.
    In this example, shown in the following listing, we use an out-of-the-box expression
    tree generator called `genHalfandHalf`, which has a 50% probability of using either
    of its two different forms of tree.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从笔记本中查看的最后一段代码块向下滚动，跳过创建`creator`的单元格，直到`toolbox`设置的开始。在创建`toolbox`之后，下一行设置了表达式树评估器。在下面的列表中，我们使用了一个现成的表达式树生成器`genHalfandHalf`，它有50%的概率使用其两种不同形式的树之一。
- en: 'Listing 4.2 EDL_4_1_GP_Regression.ipynb: Setting up the `toolbox`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 EDL_4_1_GP_Regression.ipynb：设置`toolbox`
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Defines the type of expression generation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义表达式生成的类型
- en: ❷ Creates a compile function using the primitive set definition
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用原始集定义创建编译函数
- en: In expression tree generation, we can assume trees are generated using two basic
    rules. One rule assumes all leaf nodes in a tree are at the same level, or even.
    The other rule assumes leaf nodes can be uneven. The example shown in figure 4.1
    is an example of an uneven leaf node expression tree. The code in listing 4.2
    uses the `genHalfAndHalf` function to allow for the generation of both forms of
    tree.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式树生成中，我们可以假设树是通过两个基本规则生成的。一个规则假设树中所有叶节点处于同一级别，或者说是偶数级别。另一个规则假设叶节点可以是奇数级别。图4.1中所示的是一种奇数级别叶节点的表达式树示例。列表4.2中的代码使用`genHalfAndHalf`函数允许生成两种形式的树。
- en: Next, we look at how the sample input values are randomly generated using a
    couple of lines of code with the help of NumPy, as shown in the following listing.
    The `x` inputs are generated using NumPy’s random `rand` function with a shape
    of `4, 10000`, representing 4 inputs over 10,000 rows. Then, we calculate target
    `y` values using an ad hoc equation our solution should replicate later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看如何使用NumPy的几行代码随机生成样本输入值，如以下列表所示。`x`输入是通过NumPy的随机`rand`函数生成的，形状为`4, 10000`，表示在10,000行中有4个输入。然后，我们使用一个临时的方程来计算目标`y`值，我们的解决方案稍后应该复制这个方程。
- en: 'Listing 4.3 EDL_4_1_GP_Regression.ipynb: Generating data'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 EDL_4_1_GP_Regression.ipynb：生成数据
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates a random tensor of 4, 10000
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个4, 10000的随机张量
- en: ❷ Evaluates target values using the defined equation
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用定义的方程评估目标值
- en: The goal of our GP evolution is to recreate the equation we use in listing 4.3
    to calculate the target values. We are using randomized data in this example,
    but you could certainly apply the same principles to structured data defined by
    input features *x* and target output *y* for solving other forms of regression
    problems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们GP进化的目标是重新创建我们在列表4.3中使用的方程来计算目标值。在这个例子中，我们使用随机数据，但你当然可以将相同的原理应用于由输入特征*x*和目标输出*y*定义的结构化数据，以解决其他形式的回归问题。
- en: Before we move on, let’s jump back to one of the earlier code cells, as shown
    in listing 4.4\. We can see the definition of a function, `protected_div`, which
    replaces the division operator we normally use. We need to do this to avoid division
    by zero errors we may encounter using NumPy. Refer to listing 4.1 to see how this
    function is used to define the division operator for the expression `primitive`
    set.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们回到前面代码中的一个早期代码单元格，如列表4.4所示。我们可以看到函数`protected_div`的定义，该函数替换了我们通常使用的除法运算符。我们需要这样做以避免使用NumPy可能遇到的除以零错误。参考列表4.1以了解该函数是如何用来定义表达式`primitive`集的除法运算符的。
- en: 'Listing 4.4 EDL_4_1_GP_Regression.ipynb: The `protected_div` function'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 EDL_4_1_GP_Regression.ipynb：`protected_div`函数
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A wrapper to protect against division by zero
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 防止除以零的包装器
- en: From here, we move on to reviewing the `fitness` function, called `evalSymbReg`
    in this example, for evaluating the amount of difference in error between the
    compiled expression and the values by passing in each of the inputs. Notice in
    the following listing how NumPy allows us to process all 10,000 sample rows of
    data in one pass to output the total error or difference.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们继续审查用于评估编译表达式与值之间差异量的`fitness`函数，在这个例子中称为`evalSymbReg`。通过传递每个输入来评估差异量。注意以下列表中NumPy如何允许我们一次性处理所有10,000个样本行数据，以输出总误差或差异。
- en: 'Listing 4.5 EDL_4_1_GP_Regression.ipynb: Evaluating the `fitness`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 EDL_4_1_GP_Regression.ipynb：评估`fitness`
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Compiles the expression into a tree
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将表达式编译成树
- en: ❷ Evaluates the difference from compiled expression func from the values and
    square
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 评估编译表达式与值和平方之间的差异
- en: ❸ Returns the difference or error as the individual fitness
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将差异或误差作为个体`fitness`返回
- en: The remainder of the code is quite like the previous chapter exercises, so we
    won’t need to review it here. Figure 4.2 shows the output expression tree for
    an evolution that found a minimum amount of error or `fitness` below one. This
    expression tree graph is created with `network`, as defined in the `plot_expression`
    function shown in listing 4.6\. When this expression tree is evaluated, we can
    see the produced equation and resulting code matches the original function to
    calculate `y`, as shown in listing 4.3\. You may also notice that the expression
    tree introduced another protected division operator, which just resulted in the
    last term being flipped from the actual equation. Mathematically, the solved output
    expression tree matches the original equation used to produce `y`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分与上一章的练习相当，所以我们在这里不需要回顾它。图4.2显示了找到一个最小错误量或`fitness`低于一的进化输出表达式树。这个表达式树图是用`network`创建的，正如在列表4.6中显示的`plot_expression`函数定义的那样。当这个表达式树被评估时，我们可以看到产生的方程和结果代码与计算`y`的原始函数相匹配，如列表4.3所示。你也许还会注意到，表达式树引入了另一个受保护的除法运算符，这导致最后一个项从实际方程中翻转。从数学上讲，求解后的输出表达式树与用于生成`y`的原始方程相匹配。
- en: '![](../Images/CH04_F02_Lanham.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_Lanham.png)'
- en: Figure 4.2 Solved expression tree graph as it evaluates to equations and code
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 求解的表达式树图，它评估为方程和代码
- en: Listing 4.6 shows how the expression tree is plotted using the `plot_expression`
    function. As in the exercises in chapter 3, we continue to output the top or best
    `individual` by `fitness`. In this case, we want the `fitness` to minimize or
    approach a value of zero. The expression trees drawn with the `plot_expression`
    function uses a Fruchterman-Reingold force-directed algorithm to position the
    nodes. Networkx provides a variety of position algorithms or layouts, but spring
    works for most cases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6显示了如何使用`plot_expression`函数绘制表达式树。与第3章的练习一样，我们继续按`fitness`输出顶部或最佳`individual`。在这种情况下，我们希望`fitness`最小化或接近零的值。使用`plot_expression`函数绘制的表达式树使用Fruchterman-Reingold力导向算法定位节点。Networkx提供了各种位置算法或布局，但弹簧布局适用于大多数情况。
- en: 'Listing 4.6 EDL_4_1_GP_Regression.ipynb: Plotting the expression tree'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 EDL_4_1_GP_Regression.ipynb：绘制表达式树
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ networkx is a node graph plotting library.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ networkx是一个节点图绘图库。
- en: ❷ Uses a spring layout to represent the nodes
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用弹簧布局表示节点
- en: ❸ Renders the nodes, edges, and labels for the plot
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 渲染图表的节点、边和标签
- en: In this example, we used randomized data to evolve a regression function that
    can generate our original equation. It is entirely possible to modify this example
    to consume CSV-structured data to produce regression equations that solve real-world
    problems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了随机数据来进化一个回归函数，该函数可以生成我们的原始方程。完全可以修改这个例子以消费CSV结构化数据，从而生成解决现实世界问题的回归方程。
- en: GP provides the ability to generate equations or actual programmatic code using
    the same concept of expression tree generation. This is because, fundamentally,
    all programming code can be represented as an expression tree, where something
    like an `if` statement is a Boolean operator that takes binary inputs or complex
    functions, represented as *n*-nary operators with a single return value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GP提供了使用表达式树生成相同概念来生成方程或实际程序代码的能力。这是因为，从根本上讲，所有编程代码都可以表示为一个表达式树，其中像`if`语句这样的布尔运算符是接受二进制输入或复杂函数的单个返回值的*n*-元运算符。
- en: Gene expression programming
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基因表达式编程
- en: The form of genetic programming we use in this example is known more specifically
    as gene expression programming (GEP). GEP was developed in 2002 by Candida Ferreira,
    who is currently the director of Gepsoft, an AI/ML tools software organization
    that produces a tool called Gene Expression Programming Tools. This tool can be
    used to perform GEP over structured data that produces a variety of forms of output,
    from equations to actual programmatic code across several languages. If you want
    to explore using GEP for structured data, then you should certainly visit the
    Gepsoft website and download a trial version of the software ([www.gepsoft.com](https://www.gepsoft.com/)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中我们使用的遗传编程形式更具体地称为基因表达编程（GEP）。GEP由Candida Ferreira于2002年开发，她目前是Gepsoft的负责人，Gepsoft是一家生产名为Gene
    Expression Programming Tools的工具的AI/ML工具软件组织。这个工具可以用来在结构化数据上执行GEP，产生从方程到跨多种语言的实际程序代码的各种形式输出。如果你想探索使用GEP处理结构化数据，那么你绝对应该访问Gepsoft网站并下载软件的试用版（[www.gepsoft.com](https://www.gepsoft.com/)）。
- en: The benefit of GEP is the generation of actual mathematical functions or programming
    code that can later be optimized and reused. However, GEP can also generate overly
    complex functions or code that may make the solution unusable. If you go back
    and run the last exercise with greater than four inputs, you can verify the increased
    complexity of the expression trees generated during evolution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GEP的好处是生成实际的数学函数或编程代码，这些代码可以稍后进行优化和重用。然而，GEP也可能生成过于复杂的函数或代码，这可能会使解决方案不可用。如果你回过头去运行最后一个练习，输入超过四个时，你可以验证在进化过程中生成的表达式树的复杂性增加。
- en: 4.1.2 Learning exercises
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 学习练习
- en: 'Please complete the following exercises to help improve your knowledge of the
    concepts:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请完成以下练习，以帮助提高你对概念的理解：
- en: Change the target function in listing 4.3 and then rerun the notebook. What
    happens if you make the equation more complex?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表4.3中的目标函数，然后重新运行笔记本。如果你使方程更复杂会发生什么？
- en: Remove or comment on some of the operators in listing 4.1, and then rerun. What
    happens when there are fewer operators to evolve. Is it what you expect?
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或注释列表4.1中的某些算子，然后重新运行。当进化算子较少时会发生什么。这是你所期望的吗？
- en: Alter the genetic operators and/or `crossover`, `selection`, or `mutation` parameters
    and then rerun.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改遗传算子以及/或`交叉`、`选择`或`变异`参数，然后重新运行。
- en: After using evolution to construct gene sequences, we now want to move on to
    a more tangible implementation of survival of the fittest. In the next section,
    we go back to the roots of our life simulations in chapter 2 and introduce particle
    swarm optimization.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用进化构建基因序列之后，我们现在想转向更具体的适者生存实现。在下一节中，我们回到第2章中生命模拟的根源，并介绍粒子群优化。
- en: 4.2 Particle swarm optimization with DEAP
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 使用DEAP的粒子群优化
- en: Particle swarm optimization (PSO) is another EC method that borrows the concepts
    of survival of the fittest and swarming behaviors. In the next notebook, we use
    PSO to approximate the optimum parameters needed to solve a function using DEAP.
    This is a simple example that demonstrates the power of PSO for solving inputs
    to parametric functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子群优化（PSO）是另一种受适者生存和集群行为概念启发的进化计算方法。在下一笔记本中，我们使用PSO来近似使用DEAP解决函数所需的最佳参数。这是一个简单的例子，展示了PSO在解决参数函数输入方面的强大能力。
- en: A common use case for PSO is solving the required input parameters in a known
    equation or function. For example, if we wanted to shoot a cannon ball a specified
    distance, we would consider the equation from the physics shown in figure 4.3.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PSO的一个常见用例是解决已知方程或函数中的所需输入参数。例如，如果我们想将炮弹射到指定的距离，我们会考虑图4.3中显示的物理方程。
- en: '![](../Images/CH04_F03_Lanham.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F03_Lanham.png)'
- en: Figure 4.3 Calculating distance of a cannon shot
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 计算炮弹射击距离
- en: 4.2.1 Solving equations with PSO
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 使用PSO求解方程
- en: We could attempt to solve the equation in figure 4.3 using several mathematical
    and optimization methods. Of course, we are not going to do that but, instead,
    use PSO to find the desired optimum initial velocity of the shot and the angle
    at which it is shot. Open EDL_4_2_PSO.ipynb in Google Colab and start the following
    exercise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用几种数学和优化方法来解决图4.3中的方程。当然，我们不会这么做，而是使用PSO来找到所需的初始速度和射击角度。在Google Colab中打开EDL_4_2_PSO.ipynb并开始以下练习。
- en: The code in this exercise uses DEAP, so most of it should be familiar. Here,
    we focus on a few key cells of code that uniquely define PSO. Start by scrolling
    to the where the `toolbox` is set up, as shown in the following listing. The `toolbox`
    registers several key functions for generating, updating, and evaluating `particles`.
    It can be helpful to think of these as `particle` operators, making sure not to
    call them genetic operators.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习中使用的代码是DEAP，所以其中大部分应该都很熟悉。在这里，我们关注几个独特的代码关键部分，这些部分定义了PSO。首先，滚动到设置`toolbox`的位置，如下所示。`toolbox`注册了几个关键函数，用于生成、更新和评估`粒子`。可以将其视为`粒子`操作符，确保不要将它们称为遗传操作符。
- en: 'Listing 4.7 EDL_4_2_PSO.ipynb: Setting up the `toolbox`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 EDL_4_2_PSO.ipynb：设置`toolbox`
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Registers the generate function to create a new particle
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注册`generate`函数以创建一个新的粒子
- en: ❷ Registers the particle as individuals in the population
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将粒子作为种群中的个体进行注册
- en: ❸ Registers the updateParticle function to update particles
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注册`updateParticle`函数以更新粒子
- en: ❹ Registers the function to evaluate the fitness of individuals
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注册函数以评估个体的适应性
- en: We first look at the `generate` operator and the function of the same name.
    The `generate` function shown in listing 4.8 creates an array of `particles` with
    starting positions set by `pmin` and `pmax`. During a swarm optimization, each
    `particle` has a set speed or distance it can cover in an update. During an update,
    the `particles` are moved or swarmed to position using the evaluation of `fitness`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看`generate`操作符和同名的函数。图4.8中显示的`generate`函数创建了一个由`粒子`组成的数组，其起始位置由`pmin`和`pmax`设置。在群集优化过程中，每个`粒子`都有一个固定的速度或距离，它可以在更新中使用。在更新过程中，`粒子`通过评估`fitness`被移动或群集到位置。
- en: 'Listing 4.8 EDL_4_2_PSO.ipynb: Generating a `particle`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 EDL_4_2_PSO.ipynb：生成`粒子`
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates an array of particles
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个粒子数组
- en: ❷ Creates a random speed vector
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个随机速度向量
- en: Next, we look at the update operator function called `updateParticle`, shown
    in the following listing. This function is responsible for updating the position
    of the `particle` during each iteration of the swarm optimization. In PSO, the
    idea is to continually swarm the `particles` around the fittest `particles`. Within
    the update function, `particles` are swarmed by altering their speed and position.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看更新操作符函数`updateParticle`，如下所示。这个函数负责在群集优化的每次迭代中更新`粒子`的位置。在PSO中，想法是不断群集`粒子`围绕最适应的`粒子`。在更新函数中，通过改变速度和位置来群集`粒子`。
- en: 'Listing 4.9 EDL_4_2_PSO.ipynb: Updating the `particle`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 EDL_4_2_PSO.ipynb：更新`粒子`
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Offsets the particle by some random amount
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过一些随机量偏移粒子
- en: ❷ Calculates the speed offset in two dimensions
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算二维速度偏移
- en: ❸ Enumerates through speeds and then adjusts
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历速度并调整
- en: Figure 4.4 demonstrates how PSO swarms the various `particles` around the target
    area of optimization. If we were to plot the angle and velocity on a graph, then
    we could think of each `particle` or point as a guess or attempt at shooting the
    cannon. The goal of PSO, therefore, is to find the optimum parameters (velocity
    and angle) that shoot the cannon ball to a target distance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4展示了PSO如何将各种`粒子`围绕优化目标区域进行群集。如果我们把角度和速度画在图上，那么我们可以把每个`粒子`或点看作是射击大炮的猜测或尝试。因此，PSO的目标是找到最优参数（速度和角度），使大炮弹射到目标距离。
- en: '![](../Images/CH04_F04_Lanham.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F04_Lanham.png)'
- en: Figure 4.4 Particle swarm optimization
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 粒子群优化
- en: We look at the evaluation function `evaluate` registered to the `toolbox` in
    listing 4.7 next. At the start of this block of code, we define the target distance,
    exposing it as a notebook slider input. Since the velocity term is squared in
    the equation from figure 4.3, we only want to allow positive values. This is the
    reason we guard against negative values. Similarly, we assume the angle is in
    degrees and then convert it into radians for use in the equation. Lastly, we use
    the equation to calculate the distance and subtract it from target distance. Then
    we return the squared value to return the sum of the squares’ error term as a
    tuple from the function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看列表4.7中注册到`toolbox`的评估函数`evaluate`。在这段代码的开始，我们定义了目标距离，将其作为笔记本滑块输入暴露出来。由于图4.3中的方程中速度项是平方的，我们只想允许正值。这就是我们防止负值的原因。同样，我们假设角度是以度为单位，然后将其转换为弧度用于方程。最后，我们使用方程计算距离，并从目标距离中减去。然后我们返回平方值，作为函数返回的元组，以返回平方误差项的总和。
- en: 'Listing 4.10 EDL_4_2_PSO.ipynb: Evaluating the `particle`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 EDL_4_2_PSO.ipynb：评估粒子
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Allows the input distance to be exposed as a slider form control
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许输入距离以滑动条表单控件的形式暴露
- en: ❷ Makes sure velocity is a positive value
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保速度是一个正值
- en: ❸ Converts the angle from degrees to radians
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将角度从度转换为弧度
- en: ❹ Returns the squared error from the distance to the calculated value
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从距离到计算值的平方误差返回
- en: With the basic operations set up, we can move on to the swarming code. This
    block of code, shown in listing 4.11, is significantly simpler than our other
    GA or GP examples. Unlike GA or GP, in PSO, `particles` live for the entire simulation.
    Since the `particles` have long lives, we can track the best `fitness` value for
    each. Tracking the best `fitness` on each `particle` allows the current best `particle`,
    denoted by `best` in the code listing, to be swapped. The `toolbox.update` call
    on the last line is where the `particles` in the swarm are repositioned, based
    on the position of the best `particle`, using the `updateParticle` function from
    listing 4.9.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好基本操作后，我们可以继续到群聚代码。这个代码块，如图 4.11 所示，比我们之前的 GA 或 GP 示例简单得多。与 GA 或 GP 不同，在
    PSO 中，粒子在整个模拟过程中都存在。由于粒子的寿命较长，我们可以跟踪每个粒子的最佳 `fitness` 值。跟踪每个粒子的最佳 `fitness` 值允许当前最佳粒子（在代码列表中以
    `best` 表示）进行交换。最后一行上的 `toolbox.update` 调用是群中粒子根据最佳粒子的位置重新定位的地方，使用列表 4.9 中的 `updateParticle`
    函数。
- en: 'Listing 4.11 EDL_4_2_PSO.ipynb: Swarming'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 EDL_4_2_PSO.ipynb：群聚
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Sets the number of swarming generations
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置群聚代数数量
- en: ❷ Cycles through particles in the population
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在种群中循环粒子
- en: ❸ Checks for the best fitness for the particle
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查粒子的最佳适应度
- en: ❹ Checks if it is better than the best particle
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查它是否比最佳粒子更好
- en: ❺ Loops through the population and updates the toolbox
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 遍历种群并更新工具箱
- en: As the simulation runs, you will see how the `particles` begin to converge to
    the best or multiple best solutions, shown in figure 4.5\. Notice there are two
    correct solutions for the angle and velocity in this problem. Also notice that
    the `particles` are still spread some distance across the solution. This is due
    to the selection of the hyperparameters `pmin`, `pmax`, `smin`, `smax`, `phi1`,
    and `phi2`, and you can change the amount of `particle` spread by adjusting those
    values. If you want to see a smaller spread of `particles`, adjust those hyperparameters
    to smaller values, and then run the notebook again.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着模拟的进行，你会看到粒子如何开始收敛到最佳或多个最佳解，如图 4.5 所示。注意，在这个问题中角度和速度有两个正确解。同时注意，粒子在解的某些距离上仍然分布较广。这是由于超参数
    `pmin`、`pmax`、`smin`、`smax`、`phi1` 和 `phi2` 的选择，你可以通过调整这些值来改变粒子的分布量。如果你想看到更小的粒子分布，将那些超参数调整到更小的值，然后再次运行笔记本。
- en: '![](../Images/CH04_F05_Lanham.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F05_Lanham.png)'
- en: Figure 4.5 Particle swarm scatter by iteration
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 粒子群迭代散点图
- en: Finally, the last block of code in the notebook allows us to evaluate the best
    `particle`’s prescribed solution. Keep in mind, though, that since the problem
    has two solutions, there is a possibility we could evaluate multiple best solutions.
    From the output value, you can see that PSO can do a relatively quick approximation
    of the solution to firing a cannon a certain distance, as shown in the following
    listing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，笔记本中的最后一块代码允许我们评估最佳粒子的指定解。然而，由于问题有两个解，我们可能会评估多个最佳解。从输出值中，你可以看到 PSO 可以相对快速地近似射击一定距离的解，如下面的列表所示。
- en: 'Listing 4.12 EDL_4_2_PSO.ipynb: Outputting the best'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 EDL_4_2_PSO.ipynb：输出最佳结果
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Pulls out the velocity and angle from best
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从最佳解中提取速度和角度
- en: ❷ Converts the angle from degrees to radians
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将角度从度转换为弧度
- en: ❸ Calculates the distance of the shot
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算射击的距离
- en: PSO can be applied to a variety of other problems with various effectiveness.
    Swarming optimization is a lightweight method to find unknown parameters. As seen
    in chapter 5, PSO can provide simple optimization of hyperparameters to DL systems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PSO 可以应用于各种其他问题，并具有不同的有效性。群聚优化是一种轻量级方法，用于寻找未知参数。如第 5 章所示，PSO 可以提供对深度学习系统超参数的简单优化。
- en: 4.2.2 Learning exercises
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 学习练习
- en: 'Improve your knowledge by exploring some or all the following exercises:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索以下练习中的某些或全部内容来提高你的知识：
- en: Alter the target distance in listing 4.10\. What effect does this have on the
    PSO solution?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表 4.10 中的目标距离。这会对 PSO 解有什么影响？
- en: Modify the `pmin`, `pmax`, `smin`, and `smax` inputs in listing 4.7 and then
    rerun.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表4.7中的`pmin`、`pmax`、`smin`和`smax`输入，然后重新运行。
- en: Modify the `phi1` and `phi2` parameters in listing 4.7 and then rerun. What
    effect does this have on finding the solution?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表4.7中的`phi1`和`phi2`参数，然后重新运行。这会对找到解决方案有什么影响？
- en: Now that we have covered optimizing `particles`, we move on in the next section
    to exploring more complex evolutionary processes, such as codependent or coevolving
    solutions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了优化`particles`，在下一节中，我们将探讨更复杂的进化过程，例如相互依赖或协同进化的解决方案。
- en: 4.3 Coevolving solutions with DEAP
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用DEAP协同进化解决方案
- en: Life on our planet exists in a symbiotic relationship, with millions of species
    dependent on one another for survival. Some terms to describe this relationship
    are *coevolution* and *codependent* *evolution*. We can, likewise, simulate coevolution
    using evolutionary methods when attempting to solve more complex problems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们星球上的生命存在于一种共生关系中，数百万物种相互依赖以生存。描述这种关系的术语有*协同进化*和*相互依赖的进化*。当我们试图解决更复杂的问题时，我们同样可以使用进化方法来模拟协同进化。
- en: In the next notebook, we revisit the regression problem we addressed with GP
    in the first example of this chapter. This time we move from a toy problem to
    something of a more real-world example, using a sample structured dataset called
    the Boston housing (BH) market.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个笔记本中，我们回顾了本章第一个例子中使用GP解决的回归问题。这次我们从玩具问题转向一个更接近现实世界的例子，使用一个名为波士顿住房（BH）市场的样本结构化数据集。
- en: The BH dataset encompasses 13 feature columns to help predict the value of a
    house in the Boston market. We could, of course, use GP alone to try to derive
    an equation, but the result would be overly complicated. Instead, in the following
    example, we look at pairing GP with GA using coevolution, in hopes of deriving
    a much simpler output.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: BH数据集包含13个特征列，有助于预测波士顿市场的房价。当然，我们可以单独使用GP来尝试推导出一个方程，但结果会过于复杂。相反，在下面的例子中，我们考虑使用协同进化将GP与GA配对，希望得到一个更简单的输出。
- en: 4.3.1 Coevolving genetic programming with genetic algorithms
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 使用遗传算法与遗传编程协同进化
- en: This exercise alternates between two notebooks. The first is an upgrade from
    our earlier GP example to EDL_4_GP_Regression.ipynb, which replaces the toy problem
    with the BH dataset. The second notebook, EDL_4_3_CoEV_Regression.ipynb, demonstrates
    using coevolution to solve the same problem—this time using both GP and GA.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习在两个笔记本之间交替进行。第一个是从我们早期的GP例子升级到EDL_4_GP_Regression.ipynb，用BH数据集替换了玩具问题。第二个笔记本，EDL_4_3_CoEV_Regression.ipynb，展示了使用协同进化来解决相同的问题——这次使用GP和GA。
- en: Open the EDL_4_GP_Regression.ipynb notebook, and then run all cells with Runtime
    > Run All from the menu. The key difference between this notebook and EDL_4_3_COEV_Regression.ipynb
    is the use of the BH dataset that we can import, as shown in listing 4.13\. The
    BH dataset is loaded from the `sklearn.datasets`, and we return the features,
    `x`, plus targets, `y`. Then the axes are swapped to accommodate the row, feature
    format, and number of inputs extracted. The number of inputs defines the number
    of arguments in the derived equation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 打开EDL_4_GP_Regression.ipynb笔记本，然后从菜单中选择运行 > 运行所有单元格。这个笔记本与EDL_4_3_COEV_Regression.ipynb之间的关键区别是使用了我们可以导入的BH数据集，如列表4.13所示。BH数据集从`sklearn.datasets`加载，我们返回特征`x`和目标`y`。然后交换轴以适应行、特征格式和提取的输入数量。输入数量定义了导出方程中的参数数量。
- en: 'Listing 4.13 EDL_4_3_COEV_Regression.ipynb: Setting up data'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 EDL_4_3_COEV_Regression.ipynb：设置数据
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Imports from sklearn.datasets module
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从sklearn.datasets模块导入
- en: ❷ Loads the data and then returns y, target values
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载数据然后返回目标值y
- en: ❸ Swaps the axes to match the notebook
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 交换轴以匹配笔记本
- en: ❹ Pulls out the number of inputs, arguments
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 提取输入数量、参数
- en: Figure 4.6 shows the results of evolving the equation to a minimum `fitness`
    score less than 135, a value selected to simplify a solution. The resulting equation
    shows that not all the features are used in the derived equation, with only ARG5,
    ARG7, ARG10, ARG11, and ARG12 being relevant. This also means the GP solution
    is automatically performing feature selection by ignoring less-relevant features.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6显示了将方程进化到小于135的最小`fitness`分数的结果，这是一个用于简化解决方案的值。得到的方程表明，并非所有特征都在导出的方程中使用，只有ARG5、ARG7、ARG10、ARG11和ARG12是相关的。这也意味着GP解决方案自动通过忽略不那么相关的特征来执行特征选择。
- en: '![](../Images/CH04_F06_Lanham.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F06_Lanham.png)'
- en: Figure 4.6 Output of GP_Regression notebook
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 GP_Regression笔记本的输出
- en: Next, open the EDL_4_3_COEV_Regression.ipynb notebook in Colab, and then run
    all the cells. There is a lot of code in this notebook, but we have seen all of
    it before in various other examples. The primary difference in this example is
    we are simultaneously using both GP and GA methods to fine-tune a derived equation.
    That means there is double the code, but most of it we have seen before. The first
    thing to notice, as shown in the following listing, is that we construct two `toolboxes`—one
    for the GA `population` and the other for GP.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 Colab 中打开 EDL_4_3_COEV_Regression.ipynb 笔记本，然后运行所有单元格。这个笔记本中有大量的代码，但我们之前在各种其他示例中都见过。这个例子中的主要区别在于我们同时使用
    GP 和 GA 方法来精细调整一个派生的方程。这意味着代码量加倍，但其中大部分我们都见过。首先要注意的是，如下所示，我们构建了两个 `toolboxes`——一个用于
    GA `population`，另一个用于 GP。
- en: 'Listing 4.14 EDL_4_3_COEV_Regression.ipynb: `Toolbox` registration'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 EDL_4_3_COEV_Regression.ipynb：`Toolbox` 注册
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Creates a toolbox for the GA population
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为 GA 种群创建工具箱
- en: ❷ Each gene is defined by a single float, from -1 to +1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个基因由一个介于 -1 到 +1 之间的单个浮点数定义。
- en: ❸ The size of a gene sequence is defined by the number of inputs (13 for BH).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 基因序列的大小由输入数量定义（对于 BH 为 13）。
- en: ❹ Creates a toolbox for the GP population
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为 GP 种群创建工具箱
- en: In this example, the GP solver is working to build a derived equation. The GA
    solver is, in tandem, coevolving a sequence of scaler `genes` with a size equal
    to the number of inputs/features. For the BH dataset, the number of inputs equals
    13\. Each GA scaler `gene` value is used to scale the features being input into
    the equations. We can see how this is applied in the evaluation function called
    `evalSymbReg`, shown in the following listing. When this function is used to evaluate
    `fitness`, we pass two `individuals`. The `individual` input represents a GP `individual`,
    and the `points` input represents a GA `individual`. Each evaluation of this function
    is done with two `individuals` from both the GA and GP `populations`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，GP 求解器正在努力构建一个派生方程。GA 求解器同时与一个大小等于输入/特征数量的缩放器 `genes` 序列协同进化。对于 BH 数据集，输入的数量等于
    13。每个 GA 缩放器 `gene` 值用于缩放输入到方程中的特征。我们可以在下面的列表中看到的 `evalSymbReg` 评估函数中看到这一点。当此函数用于评估
    `fitness` 时，我们传递两个 `individuals`。`individual` 输入代表一个 GP `individual`，而 `points`
    输入代表一个 GA `individual`。这个函数的每次评估都是使用来自 GA 和 GP `populations` 的两个 `individuals`。
- en: 'Listing 4.15 EDL_4_3_COEV_Regression.ipynb: The `fitness` evaluation'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 EDL_4_3_COEV_Regression.ipynb：`fitness` 评估
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Compiles the function from the toolbox
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从工具箱编译函数
- en: ❷ Converts the GA point array from (13,) to (13,1)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 GA 点数组从 (13,) 转换为 (13,1)
- en: ❸ Scales input data by points array
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过点数组缩放输入数据
- en: ❹ Calculates the fitness of the derived equation
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算派生方程的 `fitness`
- en: Often, in coevolution scenarios, you won’t want both methods to evolve at the
    same rate. In this example, we, for instance, allow the GA `population`, the scalers,
    to evolve much more quickly than the GP `population`. This allows the GA method
    to fine-tune the scale or weight of parameters being used in the derived GP equation.
    Essentially, this allows the GA method to fine-tune the equation for a better
    fit. For this notebook, we set an evolution rate between the GA to GP at 10 to
    1\. These hyperparameters are set in the following code listing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在协同进化场景中，你不会希望两种方法以相同的速率进化。在这个例子中，例如，我们允许 GA `population`（种群），缩放器，比 GP `population`（种群）进化得更快。这允许
    GA 方法精细调整在派生 GP 方程中使用的参数的缩放或权重。本质上，这允许 GA 方法对方程进行精细调整以获得更好的拟合。对于这个笔记本，我们在 GA 到
    GP 之间设置了一个进化的比率，为 10 到 1。这些超参数在下面的代码列表中设置。
- en: 'Listing 4.16 EDL_4_3_COEV_Regression.ipynb: Controlling the evolution step'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 EDL_4_3_COEV_Regression.ipynb：控制进化步骤
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Controls generation frequency hyperparameters
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 控制生成频率的超参数
- en: ❷ Adjusts the population start by generation frequency
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过生成频率调整种群起始点
- en: In the evolution code, we control how frequently each `population` evolves with
    the code from the following listing. This block of code shows the evolution for
    the GA `population`, but the same process is applied for GP as well. The hyperparameter
    `GA_GEN` controls the frequency of evolution.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在进化代码中，我们通过以下列表中的代码控制每个 `population` 进化的频率。此代码块显示了 GA `population` 的进化，但对于 GP
    也应用了相同的过程。超参数 `GA_GEN` 控制进化的频率。
- en: 'Listing 4.17 EDL_4_3_COEV_Regression.ipynb: Evolving the `population`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 EDL_4_3_COEV_Regression.ipynb：进化 `population`
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ If this is the evolution step, then evolve.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果这是进化步骤，则进行进化。
- en: ❷ Crossover
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 交叉
- en: ❸ Mutation
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 突变
- en: ❹ Assigns offspring to replace the population
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将后代分配以替换种群
- en: Remember that when we evaluate `fitness`, the function requires `individuals`
    from both `populations`—GA and GP. That means the code for evaluating `individuals`
    is tied to each `population`. Notice that when we evaluate `fitness` for the GA
    or GP `populations`, we use the alternate `population`’s best performer. This
    simplification approximates the top `fitness` for each `population`. An alternative
    method would be to loop through both `populations` and test each combination.
    This method would be computationally expensive, so we revert to the simplification
    shown in the following listing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们评估`适应度`时，该函数需要来自两个`种群`——GA和GP的`个体`。这意味着评估`个体`的代码与每个`种群`相关联。注意，当我们为GA或GP`种群`评估`适应度`时，我们使用另一个`种群`的最佳表现者。这种简化近似了每个`种群`的最高`适应度`。另一种方法是循环遍历两个`种群`并测试每种组合。这种方法将是计算上昂贵的，所以我们退回到以下列表中显示的简化。
- en: 'Listing 4.18 EDL_4_3_COEV_Regression.ipynb: Evaluating the `population` `fitness`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.18 EDL_4_3_COEV_Regression.ipynb：评估`种群``适应度`
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Evaluates GP fitness using the best of the GA pop
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用GA种群中的最佳者评估GP适应度
- en: ❷ Evaluates GA fitness using the best of the GP pop
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用GP种群中的最佳者评估GA适应度
- en: Figure 4.7 shows the final output of running this example to a solution, again
    assuming a `fitness` below 135\. As you can see, the derived equation has been
    significantly simplified. The best GA `individual` assigns the scaler used to
    modify the equation inputs. In figure 4.7, you can see how the final equation
    applies the input scaling.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7显示了运行此示例到解决方案的最终输出，再次假设`适应度`低于135。如图所示，推导出的方程已被显著简化。最佳遗传算法（GA）`个体`分配用于修改方程输入的缩放因子。在图4.7中，你可以看到最终方程如何应用输入缩放。
- en: '![](../Images/CH04_F07_Lanham.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F07_Lanham.png)'
- en: Figure 4.7 The best coevolved solution
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 最佳协同进化解决方案
- en: The final derived equation shows a potential solution for predicting a BH market
    value. If we look at the resulting equation and consult the BH features, as displayed
    in the notebooks, we can see ARG5 is NOX (nitrous oxide concentration) and ARG12
    is LSTAT (percentage of lower status `population`) are identified as the primary
    features used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最终推导出的方程显示了预测BH市场价值的潜在解决方案。如果我们查看结果方程并参考笔记本中显示的BH特征，我们可以看到ARG5被识别为NOX（氧化亚氮浓度），ARG12被识别为LSTAT（低阶层`人口`百分比），它们被确定为使用的主要特征。
- en: If you consult the GP regression notebook solved equation shown in figure 4.6,
    you will also notice that ARG5 and ARG12 are considered important features along
    with ARG7, ARG10, and ARG11\. The coevolved solution was able to further reduce
    features weighting by the inputs passed into the equation. This resulted in a
    possibly oversimplified equation, but with it, we can identify a key correlation
    between the NOX and LSTAT features in the BH dataset.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考图4.6中显示的GP回归笔记本中解决的方程，你也会注意到ARG5和ARG12被认为与ARG7、ARG10和ARG11一样是重要特征。协同进化解决方案能够进一步通过传递到方程中的输入减少特征权重。这导致了一个可能过于简化的方程，但有了它，我们可以在BH数据集中识别NOX和LSTAT特征之间的关键相关性。
- en: GP regression results
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: GP回归结果
- en: As GP evolves, it often creates more complex or overly complex equations. Long-running
    evolutions may even break from the size of the expression tree. Introducing GA
    with GP allows equations to be fine-tuned. However, this may result in oversimplifications
    of problems. The size of the dataset can also be especially problematic, given
    the BH set is only 500+ rows. You will get better results with more data, in most
    cases.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随着遗传规划的进化，它通常会创建更复杂或过于复杂的方程。长时间运行的进化甚至可能超出表达式树的大小。将遗传算法（GA）引入遗传规划允许方程进行微调。然而，这可能会导致问题的过度简化。数据集的大小也可能特别有问题，因为BH集只有500多行。在大多数情况下，你将得到更多数据时的更好结果。
- en: Now, the coevolved solution we just evaluated is not without fault. It certainly
    addresses the complexity problem often found in GP. Obviously, though, the final
    answer may be too simple and missing other key features to infer good enough accuracy.
    Yet it is also simple enough to calculate with a basic calculator and on the fly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们刚刚评估的协同进化解决方案并非完美无缺。它确实解决了在遗传规划（GP）中经常遇到的复杂性问题。然而，显然最终的答案可能过于简单，缺少其他关键特征，无法推断出足够的准确性。但这也足够简单，可以用基本的计算器即时计算。
- en: We move on to using other coevolved solutions in later chapters to balance multiple
    forms of EC being applied to DL. As we have seen in the previous exercise, coevolution
    can bound multiple forms of EC to solve a common complex solution. Balancing coevolution
    is something we spend time mastering as we progress through later examples.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中使用其他协同进化的解决方案来平衡应用于 DL 的多种形式的 EC。正如我们在前面的练习中看到的，协同进化可以将多种形式的 EC 绑定在一起来解决一个共同的复杂问题。在后续的例子中，我们花费时间掌握平衡协同进化的方法。
- en: 4.4 Evolutionary strategies with DEAP
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用 DEAP 的进化策略
- en: Evolutionary strategies are an expansion of evolutionary and genetic methods
    that add controlling subgenes or phenotypes, called *strategies*. These strategies
    are nothing more than an additional vector that controls or influences the `mutation`
    operator. This provides ES for more efficient solving of various complex problems,
    including function approximation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 进化策略是进化方法和遗传方法的扩展，它添加了控制子基因或表型，称为 *策略*。这些策略只不过是一个额外的向量，它控制或影响 `mutation` 操作符。这为
    ES 提供了更有效地解决各种复杂问题的能力，包括函数逼近。
- en: In the next notebook, we explore a function approximation problem we revisit
    later when we look at evolution with DL. To keep things simple, we look at approximating
    function parameters of a known continuous polynomial solution here. Then, we move
    on to more complex discontinuous solutions and see how well ES performs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个笔记本中，我们探索一个函数逼近问题，我们稍后将在查看使用深度学习（DL）的进化时再次回顾这个问题。为了保持简单，我们在这里查看逼近已知连续多项式解的函数参数。然后，我们转向更复杂的不连续解，并观察
    ES 的表现如何。
- en: 4.4.1 Applying evolutionary strategies to function approximation
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 将进化策略应用于函数逼近
- en: ES differs from “vanilla” GAs in that an `individual` carries an additional
    `gene` sequence or vector, called a strategy. Over the course of the evolution,
    this strategy vector learns to adjust and apply better, fine-tuned `mutation`
    to `individual` evolution.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ES 与“vanilla” GAs 的不同之处在于一个 `individual` 携带一个额外的 `gene` 序列或向量，称为策略。在进化的过程中，这个策略向量学会调整和应用更好的、微调的
    `mutation` 来优化 `individual` 的进化。
- en: As we discovered in chapter 3, `mutation` and `mutation` rate are like the learning
    rate in DL. The `mutation` controls the variability of the `population` during
    evolution. The higher the `mutation` rate is, the more variable and diverse the
    `population` will be. The ability to control and learn this `mutation` rate over
    iterations allows us to determine solutions more efficiently.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 3 章中发现的，`mutation` 和 `mutation` 率类似于 DL 中的学习率。`mutation` 控制进化过程中 `population`
    的变异性。`mutation` 率越高，`population` 的变异性就越大，多样性也越高。能够控制并在迭代中学习这个 `mutation` 率使我们能够更有效地确定解决方案。
- en: In the following notebook, we set up an ES algorithm to approximate to known
    solutions. We also discuss how learning to optimize the `mutation` over time allows
    a `population` to better converge and approximate solutions. Let’s start by opening
    notebook EDL_4_4_ES.ipynb in Google Colab and running the whole notebook.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的笔记本中，我们设置了一个 ES 算法来逼近已知解。我们还讨论了如何学习在时间上优化 `mutation`，这允许 `population` 更好地收敛并逼近解。让我们首先打开
    Google Colab 中的笔记本 EDL_4_4_ES.ipynb 并运行整个笔记本。
- en: Evolutionary strategies are an extension of GA, and as such, much of the code
    we need to use DEAP for is similar to what we have seen before. We look over the
    key differences here, focusing on how ES is implemented, starting with the hyperparameter
    definitions. The `IND_SIZE` value controls the dimensionality of the solved polynomial
    function or, effectively, the `gene` size. The `MAX_TIME` hyperparameter is for
    controlling the total amount of time to run the evolution. This is an effective
    way to control how long an evolution runs, instead of relying on number of `generations`.
    Lastly, the strategy allocation hyperparameters `MIN_VALUE``, MAX_VALUE``, MIN_STRATEGY`,
    and `MAX_STRATEGY` control the `mutation` vector and are examined further in the
    following listing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 进化策略是 GA 的扩展，因此我们使用 DEAP 需要的大部分代码与我们之前看到的类似。我们在这里回顾关键差异，重点关注 ES 的实现，从超参数定义开始。`IND_SIZE`
    值控制解决的多项式函数的维度或，实际上是 `gene` 的大小。`MAX_TIME` 超参数用于控制进化的总时间。这是一种有效控制进化运行时间的方法，而不是依赖于
    `generations` 的数量。最后，策略分配超参数 `MIN_VALUE`、`MAX_VALUE`、`MIN_STRATEGY` 和 `MAX_STRATEGY`
    控制突变向量，并在以下列表中进一步讨论。
- en: 'Listing 4.19 EDL_4_4_ES.ipynb: Examining hyperparameters'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 EDL_4_4_ES.ipynb：检查超参数
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Dimensionality of the solved polynomial
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解决的多项式维度
- en: ❷ The number maximum evolution generations
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 最大进化代数数量
- en: ❸ Values for controlling strategy allocation
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 控制策略分配的值
- en: ❹ Crossover and mutation rates
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 交叉和变异率
- en: ❺ The number of generations to produce output
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 产生输出的代数数量
- en: ❻ The maximum time evolution will run for
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 进化运行的最大时间
- en: 'Continuing to the next cell, we can see how the initial target dataset is constructed.
    In this exercise, shown in listing 4.20, we provide three options or equations
    to evaluate against: a 5th-degree polynomial continuous function and two discontinuous
    functions, abs and step. The data is processed using the range parameters to generate
    the `X` and `Y` values, which are zipped into a list called `data`. At the bottom
    of the cell, we plot a scatter plot of the data to visualize the target function.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到下一个单元格，我们可以看到如何构建初始的目标数据集。在这个练习中，如列表 4.20 所示，我们提供了三个选项或方程进行评估：一个五次多项式连续函数和两个不连续函数，abs
    和 step。数据通过范围参数进行处理，生成 `X` 和 `Y` 值，这些值被压缩到一个名为 `data` 的列表中。在单元格底部，我们绘制了数据的散点图以可视化目标函数。
- en: 'Listing 4.20 EDL_4_4_ES.ipynb: Prepping data'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 EDL_4_4_ES.ipynb：准备数据
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Exposes three options for target equations
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供三个目标方程的选项
- en: ❷ The dataset range values for x
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ x 的数据集范围值
- en: ❸ The function to evaluate target equation
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 评估目标方程的函数
- en: ❹ Builds input X values
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 构建输入 X 值
- en: ❺ Runs the equation and then generates Ys
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 运行方程然后生成 Y 值
- en: ❻ Plots the function in a scatterplot
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在散点图中绘制函数
- en: Figure 4.8 shows the plot of the 5th-degree polynomial function along with the
    step and absolute functions. Let’s start by targeting the continuous polynomial
    function to see how efficiently ES can approximate a solution. The other two functions
    represent discontinuous functions that are not differentiable and, thus, not typically
    solvable by DL networks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 展示了五次多项式函数的图像，以及步进和绝对函数。让我们首先针对连续的多项式函数进行目标定位，看看ES如何有效地逼近一个解。其他两个函数代表的是不连续的函数，它们不可导，因此通常不能通过DL网络求解。
- en: '![](../Images/CH04_F08_Lanham.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F08_Lanham.png)'
- en: Figure 4.8 Function approximation options
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 函数逼近选项
- en: Next, we look at the `creator` block of code, shown in listing 4.21, to understand
    how ES differs from typical GA. We can see `FitnessMin` and `Individual` being
    registered, as is normal with one difference. When the `individual` is registered,
    we add another attribute called `Strategy`, set to `None`. The `Strategy` is registered
    last with type double `d` array.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看代码块中的 `creator` 部分，如列表 4.21 所示，以了解ES与典型GA的不同之处。我们可以看到 `FitnessMin` 和
    `Individual` 正常注册，但有一个区别。当 `individual` 被注册时，我们添加了一个名为 `Strategy` 的属性，设置为 `None`。`Strategy`
    最后注册，类型为 double `d` 数组。
- en: 'Listing 4.21 EDL_4_4_ES.ipynb: Creating `Individual` and `Strategy`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21 EDL_4_4_ES.ipynb：创建 `Individual` 和 `Strategy`
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Creates an individual of type array with strategy
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个具有策略的数组类型的个体
- en: ❷ Creates a strategy of type array
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个数组类型的策略
- en: We now skip down to the cell that sets up the `toolbox`, as shown in listing
    4.22\. The first thing we notice is the `generatES` function being used to initialize
    an `individual` with inputs `creator.Individual`, `creator.Strategy`, `IND_SIZE`,
    `MIN_VALUE`, `MAX_VALUE, MIN_STRATEGY`, and `MAX_STRATEGY`. The `crossover` or
    `mate` operation uses a special ES blend operator for combining the parents, instead
    of a replacement operator found in normal `crossover`. Likewise, the `mutate`
    operator is using an ES log normal operation to control the `mutation` with the
    strategy. Then at the bottom of the code block, we can see a decorator being applied
    to the `mate` or `mutate` operators. Decorators provide a filter mechanism to
    the inputs, and in this case, we use the `checkStrategy` function shown shortly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在跳到设置 `toolbox` 的单元格，如列表 4.22 所示。我们首先注意到使用 `generatES` 函数初始化一个 `individual`，输入为
    `creator.Individual`、`creator.Strategy`、`IND_SIZE`、`MIN_VALUE`、`MAX_VALUE`、`MIN_STRATEGY`
    和 `MAX_STRATEGY`。`交叉` 或 `mate` 操作使用特殊的ES混合算子来组合父代，而不是在正常 `交叉` 中找到的替换算子。同样，`变异`
    操作使用ES对数正态操作来控制策略的变异。然后在代码块的底部，我们可以看到一个装饰器被应用于 `mate` 或 `mutate` 操作符。装饰器为输入提供了一个过滤机制，在这种情况下，我们使用了稍后展示的
    `checkStrategy` 函数。
- en: 'Listing 4.22 EDL_4_4_ES.ipynb: Setting up the `toolbox`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.22 EDL_4_4_ES.ipynb：设置 `toolbox`
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Registers the individual with a function that generates taking inputs
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用生成输入的功能注册个人
- en: ❷ The mate/crossover operator is cxESBlend.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 矩阵/交叉算子是 cxESBlend。
- en: ❸ The mutate operator is mutESLogNormal.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 变异算子是 mutESLogNormal。
- en: ❹ Decorates mate/mutate with checkStrategy
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 `checkStrategy` 装饰 `mate/mutate`
- en: Jumping up a cell, we can see the definitions of the `generateES` and `checkStrategy`
    functions, as shown in listing 4.23\. The first function creates the `individual`
    using the inputs passed into the function, where input `icls` represents the class
    used to construct an `individual` and `scls` represents the class to build a strategy.
    The second function checks the strategy using a decorator pattern to make sure
    the vector stays above some minimum. With the initialized `individual` setting,
    each random value in the `gene` sequence is set between the minimum and maximum
    values. Likewise, the initialization of the strategy follows the same pattern
    using different min/max values. This produces an `individual` with two vectors
    of size `IND_SIZE` or `NDIM`—one to define the primary `gene` sequence and the
    other as a learned `mutation` and blend rate applied to each `gene` during the
    `mate` and `mutate` operators.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到上一个单元，我们可以看到 `generateES` 和 `checkStrategy` 函数的定义，如列表 4.23 所示。第一个函数使用传递给函数的输入创建
    `individual`，其中输入 `icls` 代表用于构建 `individual` 的类，而 `scls` 代表用于构建策略的类。第二个函数使用装饰器模式检查策略，以确保向量保持在某个最小值之上。使用初始化的
    `individual` 设置，`gene` 序列中的每个随机值都设置在最小值和最大值之间。同样，策略的初始化遵循相同的模式，使用不同的最小/最大值。这产生了一个具有两个大小为
    `IND_SIZE` 或 `NDIM` 的向量 `individual`——一个用于定义主要的 `gene` 序列，另一个作为在 `mate` 和 `mutate`
    操作符期间应用于每个 `gene` 的学习 `mutation` 和混合率。
- en: 'Listing 4.23 EDL_4_4_ES.ipynb: Core functions'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.23 EDL_4_4_ES.ipynb：核心函数
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Creates the individual, based on input parameters
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据输入参数创建个体
- en: ❷ The decorator to make sure the strategy stays within the bounds
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保策略保持在边界内的装饰器
- en: The last `toolbox` registration we need to add is for evaluating `fitness`.
    Inside this block, shown in listing 4.24, there are two functions. The first,
    `pred`, is used to derive a value by looping through the `individual genes` and
    multiplying them by `x` to the factor `i`. The other, `fitness`, loops over the
    values `x,y` in `data` using the `pred` function to determine the mean squared
    error, where the final value returned is the average MSE. Notice in this example
    how we pass the dataset to the `evaluate` function by using it as a parameter
    in the `register` function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的最后 `toolbox` 注册是用于评估 `fitness`。在这个块中，如列表 4.24 所示，有两个函数。第一个函数 `pred` 用于通过遍历
    `individual genes` 并将它们乘以 `x` 的因子 `i` 来推导一个值。另一个函数 `fitness` 使用 `pred` 函数遍历 `data`
    中的 `x,y` 值，以确定均方误差，返回的最终值是平均 MSE。注意在这个例子中，我们如何通过在 `register` 函数中将它作为参数传递给 `evaluate`
    函数来将数据集传递给 `evaluate` 函数。
- en: 'Listing 4.24 EDL_4_4_ES.ipynb: Evaluating `fitness`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.24 EDL_4_4_ES.ipynb：评估 `fitness`
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Generates prediction from the individual and x
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从个体和 x 生成预测
- en: ❷ Calculates the polynomial factor i
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算多项式因子 i
- en: ❸ The function to calculate fitness
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算适应度的函数
- en: ❹ Evaluates the total mean squared error
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 评估总均方误差
- en: As usual, the evolution code is in the last block, shown in listing 4.25, and
    should look familiar. We start by defining two hyperparameters, `MU` and `LAMBDA`,
    that represent the `population` of parents and the number of derived offspring.
    This means in `selection`, we take MU parents to generate LAMBDA offspring using
    the DEAP algorithm `eaMuCommaLambda`. For this exercise, we are not just limiting
    by `generations` total but also elapsed time. If the elapsed time, in seconds,
    passes the threshold `MAX_TIME`, then the evolution stops. Tracking elapsed time
    allows us to evaluate comparative EC methods, as we see in the next exercise.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，进化代码位于最后一个块中，如列表 4.25 所示，应该看起来很熟悉。我们首先定义了两个超参数，`MU` 和 `LAMBDA`，它们分别代表父母的
    `population` 和衍生后代的数量。这意味着在 `selection` 中，我们使用 DEAP 算法 `eaMuCommaLambda` 从 MU
    个父母生成 LAMBDA 个后代。对于这个练习，我们不仅通过总 `generations` 限制，还通过已过时间来限制。如果已过时间（以秒为单位）超过阈值
    `MAX_TIME`，则进化停止。跟踪已过时间使我们能够评估比较 EC 方法，正如我们在下一个练习中所看到的。
- en: 'Listing 4.25 DL_4_4_ES.ipynb: Evolution'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.25 DL_4_4_ES.ipynb：进化
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Defines the population start and offspring
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义种群起始和后代
- en: ❷ Tracks the time evolution starts
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跟踪进化开始的时间
- en: ❸ Uses eaMuCommaLambda in a single generation
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在单一代中使用 `eaMuCommaLambda`
- en: ❹ A control to limit the output by the number of generations
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过代数数量限制输出
- en: ❺ Checks whether simulation time is up
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查模拟时间是否已到
- en: Figure 4.9 shows an example of the final output after running the evolution
    to a max time of 5 seconds, which is good. However, if we were to plot the input
    data into Excel, we could just as quickly generate an accurate function approximation
    using the Trendline feature, in shorter time. Excel is currently limited to 6-degree
    polynomial function, which is something we could quickly surpass using this example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 显示了运行进化到最大 5 秒后的最终输出示例，这是很好的。然而，如果我们把输入数据绘制到 Excel 中，我们同样可以快速地使用趋势线功能生成准确的功能逼近，而且时间更短。目前
    Excel 限制为 6 次多项式函数，而我们可以通过这个例子快速超越这一点。
- en: '![](../Images/CH04_F09_Lanham.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F09_Lanham.png)'
- en: Figure 4.9 Example output from ES function approximation
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 ES 函数逼近的示例输出
- en: At this point, you can go back and alter the amount of time the evolution runs
    to see if you get better results or try the other functions `abs` and `step`.
    You will likely find that ES is not as effective at discontinuous solutions. The
    reason for this is mostly to do with the way the algorithm approximates the function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以返回并调整进化的运行时间，看看是否可以得到更好的结果，或者尝试其他函数 `abs` 和 `step`。你可能会发现，ES 在处理不连续解方面并不那么有效。这主要是因为算法近似函数的方式。
- en: However, if we were to compare ES to our previous exercises in chapter 3, we
    would see a quicker convergence for continuous problems. This is because ES manages
    the `population` diversity through learned `mutation` and `mating` strategies.
    You can see this if you compare the output histogram in figure 4.9 to previous
    example exercises.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把 ES 与第 3 章中的先前练习进行比较，我们会看到连续问题有更快的收敛速度。这是因为 ES 通过学习到的 `变异` 和 `交配` 策略来管理
    `种群` 的多样性。如果你将图 4.9 中的输出直方图与之前的示例练习进行比较，就可以看到这一点。
- en: 4.4.2 Revisiting the EvoLisa
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 回顾 EvoLisa
- en: 'Function approximation is a good baseline problem, but to see the full power
    of ES, in this section, we revisit one of our most complex previous problems:
    the EvoLisa. Here we revise the problem, employing ES as our solution strategy.
    This is a very quick example that makes a useful comparison between ES and regular
    GA.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 函数逼近是一个很好的基线问题，但要看到 ES 的全部威力，在本节中，我们重新审视了我们之前最复杂的问题之一：EvoLisa。在这里，我们修改了问题，采用
    ES 作为我们的解决方案策略。这是一个非常快速的例子，它对 ES 和常规 GA 之间的比较非常有用。
- en: Open notebook EDL_4_4_EvoLisa.ipynb in Colab. If you need assistance, see the
    appendix. Go ahead and run all the cells of the notebook (Runtime > Run All from
    the menu).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Colab 中打开笔记本 EDL_4_4_EvoLisa.ipynb。如果你需要帮助，请参阅附录。然后运行笔记本中的所有单元格（从菜单中选择“运行”>“运行所有”）。
- en: We have already covered the main code elements in notebooks EDL_3_5_EvoLisa.ipynb
    and EDL_4_4_ES.ipynb. This notebook shows how a GA notebook may be upgraded to
    employ ES.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了笔记本 EDL_3_5_EvoLisa.ipynb 和 EDL_4_4_ES.ipynb 中的主要代码元素。这个笔记本展示了如何将 GA
    笔记本升级以使用 ES。
- en: Let the notebook run for a few thousand `generations` to see the remarkable
    improvement shown in figure 4.10\. Also shown in the figure is a comparison of
    the results generated with “vanilla” GA over double the number of `generations`—7,000
    versus 3,000.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让笔记本运行几千个 `世代`，以查看图 4.10 所示的显著改进。图中还显示了使用“vanilla” GA 在双倍 `世代` 数——7,000 比 3,000
    产生的结果比较。
- en: '![](../Images/CH04_F10_Lanham.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F10_Lanham.png)'
- en: Figure 4.10 EvoLisa output employing ES compared to the previous GA solution
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 使用 ES 与之前的 GA 解决方案相比的 EvoLisa 输出
- en: 4.4.3 Learning exercises
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 学习练习
- en: 'The following exercises can help you further understand the concept of evolutionary
    strategy:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习可以帮助你进一步理解进化策略的概念：
- en: Alter the target function in listing 4.20 and then rerun to see what effect
    this has.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表 4.20 中的目标函数，然后重新运行以查看这会产生什么影响。
- en: Modify several of the parameters in listing 4.19 to see what effect each change
    has on the resulting evolution. Try this with both the function approximation
    and EvoLisa notebook versions.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表 4.19 中的几个参数，看看每个变化对结果进化的影响。尝试使用函数逼近和 EvoLisa 笔记本版本都进行这一操作。
- en: Compare results from this version of the EvoLisa to the GA example we covered
    in chapter 3\. How much better does the `mutation` enhancement guided by ES improve
    the output?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个版本的 EvoLisa 的结果与我们在第 3 章中介绍的 GA 示例进行比较。ES 引导的 `变异` 增强对输出有多大的改进？
- en: Evolve the best facsimile of the Mona Lisa you can. You’re encouraged to contact
    the author with your results.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进化出你能做到的最佳蒙娜丽莎复制品。鼓励你将你的结果与作者联系。
- en: Now, your takeaway from this last notebook may be to upgrade all our solutions
    to using ES. While ES is an excellent advancement we can keep in our toolkit,
    it still lacks the ability to converge discontinuous solutions quickly and efficiently.
    To do that, we need to understand what difficulty regular GA and modified ES have
    in solving more complex functions. This is something we explore further in the
    next exercise.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能从这个最后的笔记本中得到的启示是将我们所有的解决方案升级到使用ES（进化策略）。虽然ES是一个非常好的进步，我们可以将其保留在我们的工具箱中，但它仍然缺乏快速有效地收敛不连续解的能力。要做到这一点，我们需要了解常规GA和修改后的ES在解决更复杂函数时遇到的困难。这是我们将在下一个练习中进一步探讨的内容。
- en: 4.5 Differential evolution with DEAP
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 使用DEAP的差分进化
- en: DL systems are often described simply as good function or convex approximators.
    By no means is function approximation limited to DL, but it currently ranks as
    the top favorite for most solutions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习系统通常被简单地描述为好的函数或凸逼近器。函数逼近绝对不仅限于深度学习，但目前在大多数解决方案中排名第一。
- en: Fortunately, EC encompasses several methods. It is not limited to continuous
    solutions but can solve discontinuous solutions as well. One such method focused
    on function approximation for continuous and discontinuous solutions is *differential
    evolution* (DE). DE is not calculus-based but, instead, relies on reducing the
    difference in optimized solutions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，进化计算（EC）包括几种方法。它不仅限于连续解，也可以解决不连续解。一种专注于连续和不连续解的函数逼近方法是*差分进化*（DE）。DE不是基于微积分的，而是依赖于减少优化解之间的差异。
- en: In our next notebook, we employ DE to approximate a known continuous polynomial
    solution from our last exercise as well as basic examples of discontinuous and
    complex functions. This gives us another tool in our EC toolbelt when we look
    at building combined solutions with DL later.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个笔记本中，我们使用差分进化来逼近我们上一个练习中已知的一个连续多项式解以及基本的不连续和复杂函数的例子。这为我们提供了另一个工具，当我们考虑在以后构建与DL结合的解决方案时。
- en: 4.5.1 Approximating complex and discontinuous functions with DE
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 使用DE逼近复杂和不连续函数
- en: Differential evolution has more in common with PSO than GAs or programming.
    In DE, we maintain a `population` of agents, each of some equal vector size. Like
    PSO, agents are long-running and don’t produce offspring, but their component
    vector is modified using difference comparisons from other random agents to produce
    new and better agents.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 差分进化（Differential evolution）与PSO（粒子群优化）比GAs（遗传算法）或编程有更多的共同点。在差分进化中，我们维护一个`种群`的代理，每个代理的大小都是一些相等的向量大小。像PSO一样，代理是长期运行的，并且不产生后代，但它们的分量向量通过与其他随机代理的差异比较来修改，以产生新的更好的代理。
- en: Figure 4.11 shows the basic workflow for DE. At the start of this figure, three
    agents are randomly selected from a larger pool of agents. These three agents
    are then used to modify a target `Y` for each index value in the agent by taking
    the first agent, `a`, and adding its value to a scaled difference between agents
    `b` and `c`. The resulting `Y` agent is evaluated for `fitness`, and if that value
    is better, then that agent is replaced with the new agent `Y`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11显示了DE的基本工作流程。在这个图的开头，从更大的代理池中随机选择了三个代理。然后，这三个代理被用来通过取第一个代理`a`并将其值加到代理`b`和`c`之间的缩放差异上来修改每个索引值的目标`Y`。结果`Y`代理被评估为`fitness`，如果这个值更好，那么就用新的代理`Y`替换它。
- en: '![](../Images/CH04_F11_Lanham.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F11_Lanham.png)'
- en: Figure 4.11 The DE workflow for producing new agents
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 产生新代理的DE工作流程
- en: The subtle enhancement in this method and why it works so effectively on discontinuous
    functions is the calculation of `individual` dimension difference. Unlike normal
    optimization functions, which often need to blend results, as in DL, or generalize
    results, as in genetic evolution, DE does a component-wise differentiation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法微妙地增强了其功能，以及为什么它对不连续函数如此有效的原因，在于计算`个体`维度差异。与通常需要混合结果（如深度学习中的DL）或泛化结果（如遗传进化）的正常优化函数不同，差分进化进行的是分量级的微分。
- en: In DL, the gradient optimization method we use to backpropagate errors or differences
    during training is a global optimization problem. DE extracts the optimization
    into a component-wise differentiation of values and is, therefore, not limited
    by global methods. This means DE can be used to approximate discontinuous or difficult
    functions, as we will see.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度学习（DL）中，我们用于在训练期间反向传播错误或差异的梯度优化方法是一个全局优化问题。DE将优化提取为值的分量级微分，因此不受全局方法的限制。这意味着DE可以用来逼近不连续或困难的函数，正如我们将看到的。
- en: 'For the next scenario, open notebook EDL_4_5_DE.ipynb in Colab and run all
    the cells. This example works on the same problem set from the last exercise.
    As such, we have three problems we can run this sample against: a polynomial,
    the absolute, and step functions. For comparison, we begin by running the example
    of the same polynomial function approximation problem we just looked at.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个场景，在 Colab 中打开笔记本 EDL_4_5_DE.ipynb 并运行所有单元格。此示例与上一个练习中的相同问题集工作。因此，我们有三个问题可以对此示例进行测试：一个多项式、绝对值和步进函数。为了比较，我们首先运行我们刚刚看过的相同的多项式函数逼近示例。
- en: Running the whole example for a `MAX_TIME` of 5 seconds outputs a good, but
    not great, function approximation, compared to the ES example we just looked at.
    After doing that, we want to run this example on the absolute or step functions
    by changing the function type in the prepping data, shown in listing 4.20, using
    the Colab form dropdown to step a discontinuous function.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 5 秒的 `MAX_TIME` 运行整个示例，与刚刚看到的 ES 示例相比，输出的是一个不错但并不出色的函数逼近。完成之后，我们想要通过更改准备数据中的函数类型（如列表
    4.20 所示）来运行绝对值或步进函数示例，使用 Colab 表单下拉菜单来选择一个不连续的函数。
- en: Before rerunning the notebook, we want to modify the max time hyperparameter,
    as shown in the following listing. Change the `MAX_TIME` value from 5 seconds
    to a value like 100\. The absolute and step functions, being more complex, require
    more time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新运行笔记本之前，我们想要修改最大时间超参数，如下所示列表所示。将 `MAX_TIME` 值从 5 秒更改为类似 100 的值。绝对值和步进函数由于更复杂，需要更多时间。
- en: 'Listing 4.26 EDL_4_5_DE.ipynb: The hyperparameters'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.26 EDL_4_5_DE.ipynb：超参数
- en: '[PRE25]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ The number of dimensions in an agent
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 代理中的维度数量
- en: ❷ Akin to crossover rate in genetic operations
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 类似于遗传操作中的交叉率
- en: ❸ The difference scaling factor [0.0, 2.0]
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 差分缩放因子 [0.0, 2.0]
- en: ❹ MU, or number of agents
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ MU，或代理数量
- en: ❺ The time to limit simulation for
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 限制模拟时间的时长
- en: After setting the function, reset the notebook’s runtime from the menu, using
    Runtime > Factory Reset Runtime. Then, rerun all cells in the notebook with Runtime
    > Run All from the menu.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数后，使用菜单中的“运行时”>“工厂重置运行时”重置笔记本的运行时。然后，使用菜单中的“运行时”>“运行所有”重新运行笔记本中的所有单元格。
- en: To get a good comparison, jump back to the EDL_4_ES.ipynb, and then change the
    `MAX_TIME` to 100 seconds, set the target function to step, restart the runtime,
    and rerun all the cells. Figure 4.12 shows the difference between running the
    DE and ES against the step function. It is interesting to note that the DE method
    performed more than 10 times better than ES, which has to do with the differential
    method. On the flip side, note how the ES histogram is normally distributed, whereas
    the DE chart distribution resembles a narrow Pareto or Cauchy distribution.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得良好的比较，回到 EDL_4_ES.ipynb，然后将 `MAX_TIME` 更改为 100 秒，将目标函数设置为步进，重新启动运行时，并重新运行所有单元格。图
    4.12 显示了 DE 和 ES 对步进函数的运行差异。值得注意的是，DE 方法比 ES 方法表现好了 10 多倍，这与微分方法有关。另一方面，注意 ES
    直方图是正态分布的，而 DE 图表分布类似于狭窄的帕累托或柯西分布。
- en: '![](../Images/CH04_F12_Lanham.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F12_Lanham.png)'
- en: Figure 4.12 Comparison of DE and ES on a step function
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 DE 和 ES 在步进函数上的比较
- en: Next, we can look at both the `creator` and `toolbox` setup in a combined code
    listing. For the `toolbox`, we register an attribute of type `float` with initial
    values of `-3` to `+3` that is similar to a `gene` in genetic evolution. Then,
    we define the `individual` or agent of type `float` and of size `NDIM`, or number
    of dimensions. At the end of the following code listing, we can see a select function
    registered that uses and random method that picks three elements. Recall this
    from figure 4.11, where we select three agents (`a`, `b`, `c`) to apply the differentiation
    algorithm against.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以查看合并代码列表中的 `creator` 和 `toolbox` 设置。对于 `toolbox`，我们注册一个类型为 `float` 的属性，初始值为
    `-3` 到 `+3`，类似于遗传进化中的 `gene`。然后，我们定义类型为 `float` 且大小为 `NDIM` 或维度数量的 `individual`
    或代理。在以下代码列表的末尾，我们可以看到一个已注册的选择函数，它使用随机方法选择三个元素。回想一下图 4.11，其中我们选择三个代理（`a`、`b`、`c`）来应用微分算法。
- en: 'Listing 4.27 EDL_4_5_DE.ipynb: The `creator` and `toolbox`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.27 EDL_4_5_DE.ipynb：`creator` 和 `toolbox`
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Each dimension or attribute is initiated to -3 to +3.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个维度或属性初始化为 -3 到 +3。
- en: ❷ The individual/agent defined by a float of size NDIM
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由大小为 NDIM 的浮点数定义的个体/代理
- en: ❸ The selection method uses random and chooses k=3.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择方法使用随机并选择 k=3。
- en: Much of the code in this example is shared with the previous ES exercise, since
    we are solving the same problem. Review the key differences between the two samples
    to understand what elements comprise each method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中的大部分代码与之前的ES练习共享，因为我们正在解决相同的问题。回顾这两个样本之间的关键差异，以了解每个方法由哪些元素组成。
- en: Our simulation training code is at the bottom of the notebook, but we only need
    to focus on the section that makes DE unique, as shown in listing 4.28\. There
    are two `for` loops in the code—the first iterates over the number of `generations`,
    and the second iterates through each agent. In the inner loop, we first sample
    three agents (`a, b, c`) and then clone the agent to be the target `y`. Then,
    we sample a random index into the agent’s vector and use that with the `CR` value
    to determine whether a possible difference is calculated, as shown in figure 4.10\.
    Finally, we check whether the new agent evaluates a better `fitness`, and if it
    does, we swap out the new agent with the old one.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟训练代码位于笔记本的底部，但我们只需要关注使DE独特的部分，如列表4.28所示。代码中有两个`for`循环——第一个循环遍历`代数`的数量，第二个循环遍历每个代理。在内循环中，我们首先采样三个代理（`a,
    b, c`），然后将代理克隆为目标`y`。然后，我们从一个代理的向量中选择一个随机索引，并使用该索引与`CR`值来确定是否计算可能的差异，如图4.10所示。最后，我们检查新代理的`fitness`是否更好，如果是，我们就用新代理替换旧代理。
- en: 'Listing 4.28 EDL_4_5_DE.ipynb: Agent differentiable simulation'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.28 EDL_4_5_DE.ipynb：代理可微分模拟
- en: '[PRE27]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Enumerates each agent in the population
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 枚举种群中的每个代理
- en: ❷ Randomly selects three agents from the population
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从种群中随机选择三个代理
- en: ❸ Clones an agent into y
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将代理克隆到y
- en: ❹ Selects a random index into the agent’s vector
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从代理的向量中选择一个随机索引
- en: ❺ Matches the vector index and checks for crossover CR
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 匹配向量索引并检查交叉CR
- en: ❻ Evaluates y fitness, and if it is better, it swaps out the current agent
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 评估y的适应度，如果它更好，则替换当前代理
- en: Feel free to go back and try a comparison of the absolute function between the
    ES and DE methods. You can also try tweaking the hyperparameters to see what effect
    they have for approximating a function with both ES and DE.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 随意返回并尝试比较ES和DE方法之间的绝对函数。你还可以尝试调整超参数，看看它们对使用ES和DE逼近函数有什么影响。
- en: 4.5.2 Learning exercises
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 学习练习
- en: 'Continue your exploration of the last notebook by completing the following
    exercises:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成以下练习，继续探索最后一个笔记本：
- en: Alter various hyperparameters in listing 4.26, and then rerun. Are you able
    to improve the performance of discontinuous function approximation?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改列表4.26中的各种超参数，然后重新运行。你是否能够提高不连续函数逼近的性能？
- en: Compare the function approximation results from ES and DE for various functions.
    Which appears to perform better and worse for which types of functions?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较ES和DE对各种函数的函数逼近结果。对于哪些类型的函数，哪种方法看起来表现更好或更差？
- en: Both DE and ES provide excellent function approximators for continuous problems.
    For discontinuous problems, it is generally better to apply DE, since it is not
    limited to gradual approximations across global space. As we discuss in later
    chapters, having both tools available makes our job easier when applying EDL.
    In this chapter, we extended our knowledge of EC and looked at more diverse and
    specialized methods that can address novel or difficult-to-solve problems.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: DE 和 ES 都为连续问题提供了优秀的函数逼近器。对于不连续问题，通常应用 DE 更好，因为它不受限于全局空间中的渐进逼近。正如我们在后面的章节中讨论的，当应用
    EDL 时，拥有这两种工具可以使我们的工作更容易。在本章中，我们扩展了我们对 EC 的知识，并探讨了更多样化和专业的方法，这些方法可以解决新颖或难以解决的问题。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Genetic programming is the use of genetic sequences to define a process or program
    of steps.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗传编程是使用遗传序列定义一个过程或步骤的程序。
- en: DEAP employs a genetic programming extension that makes it easy to convert a
    problem from GA to GP. One application of GP is to derive an equation for a known
    or unknown problem.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEAP采用了一种遗传编程扩展，使得将问题从GA转换为GP变得容易。GP的一个应用是推导出已知或未知问题的方程。
- en: DEAP also provides visualization tools that allow for the interpretation of
    an `individual` `gene` sequence as a `gene` expression tree and how it evaluates
    to a function.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEAP还提供了可视化工具，允许将个体基因序列解释为基因表达树，并评估其如何对应于一个函数。
- en: 'DEAP provides several secondary evolutionary algorithms. One such example is
    particle swarm optimization:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEAP提供了几个二级进化算法。其中一个例子是粒子群优化：
- en: Particle swarm optimization uses a `population` of `individuals` to swarm over
    a solution space.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子群优化使用一个`个体`的`种群`在解空间中游动。
- en: As the `particles` swarm, fitter `individuals` guide the swarm to focus on better
    solutions.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`粒子`群游动时，更适应的`个体`引导群体关注更好的解决方案。
- en: PSO can be used for finding solution parameters to functions or more-complex
    problems.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSO可以用于寻找函数或更复杂问题的解参数。
- en: DEAP supports coevolution scenarios. This is when two or more `populations`
    of `individuals` are identified to tackle unique tasks for specific problems.
    Coevolution can be used to find complex solutions by minimizing and scaling features
    in a derived equation.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEAP支持协同进化场景。这是指在特定问题时，识别出两个或更多`个体`的`种群`来处理独特的任务。协同进化可以通过在导出的方程中最小化和缩放特征来找到复杂解。
- en: Evolutionary strategy is an extension of GAs that places emphasis on strategically
    updating the `mutation` function. This method works well for solving or guiding
    solutions that require `individuals` with large or complex genetic structures
    or sequences.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进化策略是遗传算法的扩展，它强调战略性地更新`变异`函数。这种方法对于解决或引导需要具有大或复杂遗传结构或序列的`个体`的解决方案非常有效。
- en: Differential evolution is similar to PSO but only uses three agents to triangulate
    and narrow a solution-search space. DE works well on complex problems that use
    shorter genetic sequences. Employ differential evolution to solve continuous and
    discontinuous function approximation problems in DEAP.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差分进化与PSO类似，但仅使用三个代理来三角化和缩小解决方案搜索空间。DE在复杂问题中表现良好，这些问题使用较短的遗传序列。在DEAP中使用差分进化来解决连续和断续函数逼近问题。
