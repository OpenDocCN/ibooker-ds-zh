- en: 7 MultiIndex DataFrames
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 MultiIndex DataFrames
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Creating a `MultiIndex`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `MultiIndex`
- en: Selecting rows and columns from a `MultiIndex` `DataFrame`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `MultiIndex DataFrame` 中选择行和列
- en: Extracting a cross-section from a `MultiIndex DataFrame`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `MultiIndex DataFrame` 中提取横截面
- en: Swapping `MultiIndex` levels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换 `MultiIndex` 级别
- en: 'So far on our pandas journey, we’ve explored the one-dimensional `Series` and
    the two-dimensional `DataFrame`. The number of dimensions is the number of reference
    points we need to extract a value from a data structure. We need only one label
    or one index position to locate a value in a `Series`. We need two reference points
    to locate a value in a `DataFrame`: a label/index for the rows and a label/index
    for the columns. Can we expand beyond two dimensions? Absolutely! Pandas supports
    data sets with any number of dimensions through the use of a `MultiIndex`.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的 pandas 之旅中，我们已经探索了一维的 `Series` 和二维的 `DataFrame`。维数的数量是我们从数据结构中提取值所需的参考点数量。在
    `Series` 中定位一个值只需要一个标签或一个索引位置。在 `DataFrame` 中定位一个值需要两个参考点：行和列的标签/索引。我们能否超越二维？绝对可以！Pandas
    通过使用 `MultiIndex` 支持任何数量的维度的数据集。
- en: A `MultiIndex` is an index object that holds multiple levels. Each level stores
    a value for the row. It is optimal to use a `MultiIndex` when a combination of
    values provides the best identifier for a row of data. Consider the data set in
    figure 7.1, which stores stock prices across multiple dates.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiIndex` 是一个包含多个级别的索引对象。每个级别存储行的值。当值的组合为数据行提供最佳标识符时，使用 `MultiIndex` 是最理想的。考虑图
    7.1 中的数据集，它存储了多个日期的股票价格。'
- en: '![](../Images/CH07_F01_Paskhaver.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F01_Paskhaver.png)'
- en: Figure 7.1 Sample data set with Stock, Date, and Price columns
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 示例数据集，包含股票、日期和价格列
- en: Suppose that we want to find a unique identifier for each price. Neither a stock’s
    name nor its date is sufficient by itself, but the combination of both values
    is a good fit. The stock `"MSFT"` appears twice, the date `"02/08/2021"` appears
    twice, but the combination of `"MSFT"` and `"02/08/2021"` appears only once. A
    `MultiIndex` storing the values of the Stock and Date columns would suit this
    data set well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为每个价格找到一个唯一标识符。仅股票名称或日期本身都不足以作为标识，但两者的组合则是一个很好的选择。股票 `"MSFT"` 出现了两次，日期
    `"02/08/2021"` 也出现了两次，但 `"MSFT"` 和 `"02/08/2021"` 的组合只出现了一次。存储股票和日期列值的 `MultiIndex`
    对这个数据集非常适合。
- en: A `MultiIndex` is also ideal for hierarchical data—data in which one column’s
    values are a subcategory of another column’s values. Consider the data set in
    figure 7.2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiIndex` 也非常适合层次数据——其中一列的值是另一列值的子类别的数据。考虑图 7.2 中的数据集。'
- en: '![](../Images/CH07_F02_Paskhaver.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F02_Paskhaver.png)'
- en: Figure 7.2 Sample data set with Group, Item, and Calories columns
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 示例数据集，包含组、项目和卡路里列
- en: The Item column’s values are subcategories of the Group column’s values. An
    Apple is a type of Fruit, and Broccoli is a type of Vegetable. Thus, the Group
    and Item columns could serve as a `MultiIndex` combo.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 项目列的值是组列值的子类别。苹果是一种水果，西兰花是一种蔬菜。因此，组和项目列可以作为 `MultiIndex` 组合。
- en: The `MultiIndex` is an obscure feature in pandas but one that’s worth taking
    the time to learn. The introduction of multiple index levels adds a lot of versatility
    to how we slice and dice data sets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiIndex` 是 pandas 中一个不太为人所知的功能，但值得花时间去学习。引入多个索引级别为我们如何切片和切块数据集增加了许多灵活性。'
- en: 7.1 The MultiIndex object
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 MultiIndex 对象
- en: 'Let’s open a new Jupyter Notebook, import the pandas library, and assign it
    the alias `pd`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个新的 Jupyter Notebook，导入 pandas 库，并将其分配别名 `pd`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To keep things simple, we’ll start by creating a `MultiIndex` object from scratch.
    In section 7.2, we’ll practice these concepts on an imported data set.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将从零开始创建一个 `MultiIndex` 对象。在第 7.2 节中，我们将在导入的数据集上练习这些概念。
- en: Do you recall Python’s built-in tuple object? The tuple is an immutable data
    structure that holds a sequence of values in order. A tuple is effectively a list
    that cannot be modified after creation. For a deeper dive into this data structure,
    see appendix B.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 Python 的内置元组对象吗？元组是一个不可变的数据结构，它按顺序存储一系列值。元组实际上是一个在创建后不能修改的列表。要深入了解这个数据结构，请参阅附录
    B。
- en: 'Let’s say we want to model a street address. An address typically includes
    a street name, city, town, and zip code. We could store these four elements in
    a tuple:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要模拟一个街道地址。地址通常包括街道名称、城市、镇和邮政编码。我们可以将这些四个元素存储在一个元组中：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Series` and `DataFrame` indices can hold various data types: strings, numbers,
    datetimes, and more. But all these objects can store only one value per index
    position, one label per row. A tuple doesn’t have that limitation.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`和`DataFrame`的索引可以存储各种数据类型：字符串、数字、日期和时间等。但所有这些对象在每个索引位置只能存储一个值，每行一个标签。元组没有这个限制。'
- en: 'What if we gathered multiple tuples in a list? The list would look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个列表中收集多个元组呢？列表看起来会是这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now imagine these tuples serving as a `DataFrame`’s index labels. I hope that
    the idea is not too confusing. All operations remain the same. We would still
    be able to reference a row by its index label, but each index label would be a
    container holding multiple elements. That’s a good way to start thinking about
    the `MultiIndex` object—as an index in which each label can store multiple pieces
    of data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象这些元组作为`DataFrame`的索引标签。我希望这个想法不会太令人困惑。所有操作都保持不变。我们仍然可以通过索引标签来引用一行，但每个索引标签都是一个包含多个元素的容器。这是一个很好的方式来开始思考`MultiIndex`对象——作为一个每个标签可以存储多个数据的索引。
- en: 'We can create a `MultiIndex` object independently of a `Series` or `DataFrame`.
    The `MultiIndex` class is available as a top-level attribute on the pandas library.
    It includes a `from_tuples` class method that instantiates a `MultiIndex` from
    a list of tuples. A *class method* is a method we invoke on a class rather than
    an instance. The next example invokes the `from_tuples` class method and passes
    it the `addresses` list:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以独立于`Series`或`DataFrame`创建`MultiIndex`对象。`MultiIndex`类作为pandas库的一个顶级属性可用。它包括一个`from_tuples`类方法，可以从元组列表中实例化一个`MultiIndex`。*类方法*是我们对一个类而不是一个实例调用的方法。下一个例子调用了`from_tuples`类方法，并传递了`addresses`列表：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have our first `MultiIndex`, which stores three tuples of four elements
    each. There is a consistent pattern to each tuple’s elements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了第一个`MultiIndex`，它存储了三个包含四个元素的元组。每个元组的元素都有一个一致的规律：
- en: The first value is the address.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值是地址。
- en: The second value is the city.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值是城市。
- en: The third value is the state.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个值是州。
- en: The fourth value is the zip code.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个值是邮政编码。
- en: In pandas terminology, the collection of tuple values at the same position forms
    a `level` of the `MultiIndex`. In the previous example, the first `MultiIndex`
    level consists of the values `"8809 Flair Square"`, `"9901 Austin Street"`, and
    `"905 Hogan Quarter"`. Similarly, the second `MultiIndex` level consists of `"Toddside"`,
    `"Toddside"`, and `"Franklin"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas术语中，相同位置上的元组值的集合形成`MultiIndex`的一个`level`。在之前的例子中，第一个`MultiIndex`级别由值`"8809
    Flair Square"`、`"9901 Austin Street"`和`"905 Hogan Quarter"`组成。同样，第二个`MultiIndex`级别由`"Toddside"`、`"Toddside"`和`"Franklin"`组成。
- en: 'We can assign each `MultiIndex` level a name by passing a list to the `from_tuples`
    method’s `names` parameter. Here, we assign the names "`Street"`, `"City"`, `"State"`,
    and `"Zip"`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递一个列表给`from_tuples`方法的`names`参数来给每个`MultiIndex`级别分配一个名称。在这里，我们分配了名称"`Street"`、`"City"`、`"State"`和`"Zip"`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To summarize, a `MultiIndex` is a storage container in which each label holds
    multiple values. A level consists of the values at the same position across the
    labels.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`MultiIndex`是一个存储容器，其中每个标签包含多个值。一个级别由标签中相同位置的值组成。
- en: 'Now that we have a `MultiIndex`, let’s attach it to a `DataFrame`. The easiest
    way is to use the `DataFrame` constructor’s `index` parameter. We passed this
    parameter a list of strings in earlier chapters, but it also accepts any valid
    index object. Let’s pass it the `MultiIndex` we assigned to the `row_index` variable.
    Because our `MultiIndex` has three tuples (or, equivalently, three labels), we’ll
    need to provide three rows of data:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`MultiIndex`，让我们将其附加到一个`DataFrame`上。最简单的方法是使用`DataFrame`构造函数的`index`参数。我们在前面的章节中传递了这个参数一个字符串列表，但它也接受任何有效的索引对象。让我们传递给它分配给`row_index`变量的`MultiIndex`。因为我们的`MultiIndex`有三个元组（或者说，相当于三个标签），我们需要提供三行数据：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have a `DataFrame` with a `MultiIndex` on its row axis. Each row’s label
    holds four values: a street, a city, a state, and a zip code.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个在行轴上有`MultiIndex`的`DataFrame`。每一行的标签包含四个值：街道、城市、州和邮政编码。
- en: 'Let’s turn our focus to the column axis. Pandas stores a `DataFrame`’s column
    headers in an index object as well. We can access that index via the `columns`
    attribute:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向列轴。Pandas将`DataFrame`的列标题存储在一个索引对象中。我们可以通过`columns`属性访问该索引：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pandas currently stores the two column names in a single-level `Index` object.
    Let’s create a second `MultiIndex` and attach it to the column axis. The next
    example invokes the `from_tuples` class method again, passing it a list of four
    tuples. Each tuple holds two strings:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas目前将两个列名存储在单级`Index`对象中。让我们创建第二个`MultiIndex`并将其附加到列轴。下一个示例再次调用`from_tuples`类方法，传递一个包含四个元组的列表。每个元组包含两个字符串：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s attach both of our `MultiIndexes` to a `DataFrame`. The `MultiIndex`
    for the row axis (`row_index`) requires the data set to hold three rows. The `MultiIndex`
    for the column axis (`column_index`) requires the data set to hold four columns.
    Therefore, our data set must have a 3 x 4 shape. Let’s create that sample data.
    The next example declares a list of three lists. Each nested list stores four
    strings:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将两个`MultiIndex`都附加到一个`DataFrame`上。行轴的`MultiIndex`（`row_index`）要求数据集包含三行。列轴的`MultiIndex`（`column_index`）要求数据集包含四列。因此，我们的数据集必须具有3
    x 4的形状。让我们创建这个样本数据。下一个示例声明了一个包含三个列表的列表。每个嵌套列表存储四个字符串：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’re ready to put the pieces together and create a `DataFrame` with a `MultiIndex`
    on both the row and column axes. In the `DataFrame` constructor, let’s pass our
    respective `MultiIndex` variables to the `index` and `columns` parameters:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将各个部分组合起来，创建一个在行和列轴上都有`MultiIndex`的`DataFrame`。在`DataFrame`构造函数中，我们将各自的`MultiIndex`变量传递给`index`和`columns`参数：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hooray! We’ve successfully created a `DataFrame` with a four-level row `MultiIndex`
    and a two-level column `MultiIndex`. A `MultiIndex` is an index that can store
    multiple levels, multiple tiers. Each index label is made of multiple components.
    That’s all there is to it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！我们已经成功创建了一个具有四级行`MultiIndex`和二级列`MultiIndex`的`DataFrame`。`MultiIndex`是一个可以存储多个级别、多个层级的索引。每个索引标签由多个组件组成。这就是全部内容。
- en: 7.2 MultiIndex DataFrames
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 多级索引DataFrame
- en: 'Let’s scale things up a bit. The neighborhoods.csv data set is similar to the
    one we created in section 7.1; it’s a listing of ~250 fictional addresses in cities
    across the United States. Each address is graded on four characteristics of livability:
    Restaurants, Museums, Police, and Schools. The four grades are grouped in two
    parent categories: Culture and Services.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微扩大一下范围。neighborhoods.csv数据集与我们第7.1节中创建的数据集类似；它列出了美国各地约250个虚构地址。每个地址根据四个宜居特性进行评级：餐馆、博物馆、警察局和学校。这四个评级分为两个父类别：文化和服务。
- en: 'Here’s a preview of the first couple of rows of the raw CSV file. In a CSV,
    a comma separates every two subsequent values in a row of data. Thus, the presence
    of sequential commas with nothing between them indicates missing values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始CSV文件前几行的预览。在CSV中，逗号分隔数据行中的每两个后续值。因此，连续逗号之间没有内容表示缺失值：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'How will pandas import this CSV file’s data? Let’s find out with the `read_csv`
    function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas如何导入这个CSV文件的数据？让我们用`read_csv`函数来找出答案：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Something is off here! First, we have three Unnamed columns, each one ending
    in a different number. When importing a CSV, pandas assumes that the file’s first
    row holds the column names, also known as the headers. If a header slot does not
    have a value, pandas assigns a title of `"Unnamed"` to the column. Simultaneously,
    the library tries to avoid duplicate column names. To distinguish between multiple
    missing headers, the library adds a numerical index to each. Thus, we have three
    Unnamed columns: Unnamed: 0, Unnamed: 1, and Unnamed: 2.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有些不对劲！首先，我们有三个未命名的列，每个列都以不同的数字结尾。当导入CSV时，pandas假设文件的第一行包含列名，也称为标题。如果一个标题槽没有值，pandas会将其分配一个标题为“未命名”的列名。同时，库试图避免重复的列名。为了区分多个缺失的标题，库会给每个标题添加一个数字索引。因此，我们有三个未命名的列：未命名：0、未命名：1和未命名：2。
- en: The four columns to the right have the same naming issue. Notice that pandas
    assigns a title of Culture to the column at index 3 and Culture 1 to the one after
    it. The CSV file has the same value of `"Culture"` for two header cells in a row,
    followed by the same value of `"Services"` for two header cells in a row.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的四列也存在相同的命名问题。注意，pandas将标题为“文化”的列分配给索引3，并将其后的列命名为“文化1”。CSV文件在行中有两个标题单元格具有相同的“文化”值，然后是两行标题单元格具有相同的“服务”值。
- en: Unfortunately, that’s not the end of our problems. In row 0, each of the first
    three columns holds a `NaN` value. In row 1, we have `NaN` values present in the
    last four columns. The issue is that the CSV is trying to model a multilevel row
    index and a multilevel column index, but the default arguments to the `read_csv`
    function’s parameters don’t recognize it. Luckily, we can solve this problem by
    altering the arguments to a couple of `read_csv` parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这还不是我们的问题的终点。在行 0 中，前三个列都包含一个 `NaN` 值。在行 1 中，最后四个列都存在 `NaN` 值。问题是 CSV 正在尝试模拟一个多级行索引和多级列索引，但
    `read_csv` 函数参数的默认值不识别它。幸运的是，我们可以通过更改 `read_csv` 参数的值来解决这个问题。
- en: 'First, we have to tell pandas that the three leftmost columns should serve
    as the index of the `DataFrame`. We can do this by passing the `index_col` parameter
    a list of numbers, each one representing the index (or numeric position) of a
    column that should be in the `DataFrame`’s index. The index starts counting from
    0\. Thus, the first three columns (the Unnamed ones) will have index positions
    0, 1, and 2\. When we pass `index_col` a list with multiple values, pandas automatically
    creates a `MultiIndex` for the `DataFrame`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须告诉 pandas，前三个列应该作为 `DataFrame` 的索引。我们可以通过将一个包含数字的列表传递给 `index_col` 参数来实现，每个数字代表一个列的索引（或数字位置），该列应包含在
    `DataFrame` 的索引中。索引从 0 开始计数。因此，前三个列（未命名的列）将具有索引位置 0、1 和 2。当我们传递一个包含多个值的 `index_col`
    列表时，pandas 会自动为 `DataFrame` 创建一个 `MultiIndex`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We’re halfway there. Next, we need to tell pandas which data set rows we’d
    like to use for our `DataFrame`’s headers. The `read_csv` function assumes that
    only the first row will hold the headers. In this data set, the first two rows
    will hold the headers. We can customize the `DataFrame` headers with the `read_csv`
    function’s `header` parameter, which accepts a list of integers representing the
    `rows` that pandas should set as column headers. If we provide a list with more
    than one element, pandas will assign a `MultiIndex` to the columns. The next example
    sets the first two rows (indexes 0 and 1) as column headers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了一半。接下来，我们需要告诉 pandas 我们想要用于 `DataFrame` 标题的数据集行。`read_csv` 函数假设只有第一行将包含标题。在这个数据集中，前两行将包含标题。我们可以使用
    `read_csv` 函数的 `header` 参数自定义 `DataFrame` 的标题，该参数接受一个整数列表，表示 pandas 应将其设置为列标题的
    `rows`。如果我们提供一个包含多个元素的列表，pandas 将将一个 `MultiIndex` 分配给列。下一个示例将前两行（索引 0 和 1）设置为列标题：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have something we can work with!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些可以操作的东西！
- en: As mentioned earlier, the data set groups four characteristics of livability
    (Restaurants, Museums, Police, and Schools) in two categories (Culture and Services).
    When we have a parent category encompassing smaller child categories, creating
    a `MultiIndex` is an optimal way to enable quick slicing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据集将四个可居住性特征（餐馆、博物馆、警察和学校）分为两类（文化和服务）。当我们有一个包含较小子类别的父类别时，创建一个 `MultiIndex`
    是实现快速切片的最佳方式。
- en: 'Let’s invoke some familiar methods to observe how the output changes with a
    `MultiIndex` `DataFrame`. The `info` method is a good place to start:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用一些熟悉的方法来观察 `MultiIndex` `DataFrame` 的输出如何变化。`info` 方法是一个很好的起点：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that pandas prints each column’s name as a two-element tuple, such as
    `(Culture`, `Restaurants)`. Similarly, the library stores each row’s label as
    a three-element tuple, such as `('MO',` `'Fisherborough',` `'244` `Tracy` `View')`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，pandas 将每个列名打印为一个包含两个元素的元组，例如 `(Culture, Restaurants)`。同样，库将每行的标签存储为一个包含三个元素的元组，例如
    `('MO', 'Fisherborough', '244 Tracy View')`。
- en: 'We can access the rows’ `MultiIndex` object with the familiar `index` attribute.
    The output allows us to see the tuples that hold each row’s values:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过熟悉的 `index` 属性访问行的 `MultiIndex` 对象。输出使我们能够看到包含每行值的元组：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can access the columns’ `MultiIndex` object with the `columns` attribute,
    which also uses tuples to store the nested column labels:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `columns` 属性访问列的 `MultiIndex` 对象，该属性也使用元组来存储嵌套的列标签：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Under its hood, pandas composes a `MultiIndex` from multiple `Index` objects.
    When importing the data set, the library assigned a name to each `Index` from
    a CSV header. We can access the list of index names with the `names` attribute
    on the `MultiIndex` object. State, City, and Street are the names of the three
    CSV columns that became our index:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在其内部，pandas 从多个 `Index` 对象中组合一个 `MultiIndex`。在导入数据集时，库为每个 `Index` 从 CSV 标题分配了一个名称。我们可以通过
    `MultiIndex` 对象上的 `names` 属性访问索引名称列表。州、市和街道是成为我们索引的三个 CSV 列的名称：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Pandas assigns an order to each nested level within the `MultiIndex`. In our
    current neighborhoods `DataFrame`,
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 为 `MultiIndex` 中的每个嵌套层级分配一个顺序。在我们的当前 `neighborhoods` `DataFrame` 中，
- en: The State level has an index position of 0.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 州层级有一个索引位置为 0。
- en: The City level has an index position of 1.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市层级有一个索引位置为 1。
- en: The Street level has an index position of 2.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 街道层级有一个索引位置为 2。
- en: 'The `get_level_values` method extracts the `Index` object at a given level
    of the `MultiIndex`. We can pass either the level’s index position or the level’s
    name to the method’s first and only parameter, `level`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_level_values` 方法从 `MultiIndex` 的给定层级中提取 `Index` 对象。我们可以传递层级的索引位置或层级的名称给方法的第一个也是唯一的参数
    `level`：'
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The columns’ `MultiIndex` levels do not have any names because the CSV did
    not provide any:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列的 `MultiIndex` 层级没有名称，因为 CSV 没有提供任何：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s fix this problem. We can access the columns’ `MultiIndex` with the `columns`
    attribute. Then we can assign a new list of column names to the `names` attribute
    of the `MultiIndex` object. The names `"Category"` and `"Subcategory"` seem to
    be fitting here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决这个问题。我们可以使用 `columns` 属性访问列的 `MultiIndex`。然后我们可以将新的列名列表分配给 `MultiIndex`
    对象的 `names` 属性。名称 `"Category"` 和 `"Subcategory"` 似乎很适合这里：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The level names will appear to the left of the column headers in the output.
    Let’s invoke the `head` method to see the difference:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 层级名称将出现在输出中的列标题左侧。让我们调用 `head` 方法来看看区别：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we’ve assigned names to the levels, we can use the `get_level_values`
    method to retrieve any `Index` from the columns’ `MultiIndex`. Remember that we
    can pass either the column’s index position or its name to the method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为层级分配了名称，我们可以使用 `get_level_values` 方法从列的 `MultiIndex` 中检索任何 `Index`。记住，我们可以传递列的索引位置或列的名称给该方法：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A `MultiIndex` will carry over to new objects derived from a data set. The
    index can switch axes depending on the operation. Consider a `DataFrame`’s `nunique`
    method, which returns a `Series` with a count of unique values per column. If
    we invoke `nunique` on `neighborhoods`, the `DataFrame`’s column `MultiIndex`
    will swap axes and serve as the row’s `MultiIndex` in the resulting `Series`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiIndex` 将延续到从数据集派生的新对象。索引可以根据操作切换轴。考虑 `DataFrame` 的 `nunique` 方法，它返回一个
    `Series`，其中包含每列唯一值的计数。如果我们对 `neighborhoods` 调用 `nunique`，`DataFrame` 的列 `MultiIndex`
    将交换轴，并在结果 `Series` 中作为行的 `MultiIndex`：'
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `MultiIndex` `Series` tells us how many unique values pandas found in each
    of the four columns. The values are equal in this case because all four columns
    hold the 13 possible grades (A+ to F).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiIndex` `Series` 告诉我们 Pandas 在每个四个列中找到了多少唯一值。在这种情况下，值是相等的，因为所有四个列都包含了
    13 种可能的等级（A+ 到 F）。'
- en: 7.3 Sorting a MultiIndex
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 对 MultiIndex 排序
- en: Pandas can find a value in an ordered collection much quicker than in a jumbled
    one. A good analogous example is searching for a word in a dictionary. It’s easier
    to locate a word when words are in alphabetical order rather than a random sequence.
    Thus, it’s optimal to sort an index before selecting any rows and columns from
    a `DataFrame`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 在有序集合中查找值比在杂乱无章的集合中快得多。一个很好的类似例子是在字典中查找单词。当单词按字母顺序排列时，比随机序列更容易找到单词。因此，在从
    `DataFrame` 中选择任何行和列之前对索引进行排序是最佳的。
- en: 'Chapter 4 introduced the `sort_index` method for sorting a `DataFrame`. When
    we invoke the method on a `MultiIndex` `DataFrame`, pandas sorts all levels in
    ascending order and proceeds from the outside in. In the next example, pandas
    sorts the State-level values first, then the City-level values, and finally the
    Street-level values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 章介绍了用于对 `DataFrame` 排序的 `sort_index` 方法。当我们对 `MultiIndex` `DataFrame` 调用该方法时，pandas
    按升序对所有层级进行排序，并从外部开始进行。在下一个示例中，pandas 首先对州级值进行排序，然后对城市级值进行排序，最后对街道级值进行排序：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s make sure that we understand the output. First, pandas targets the State
    level and sorts the value `"AK"` before `"AL"`. Then, within the state of `"AK"`,
    pandas sorts the city of `"Rowlandchester"` before `"Scottstad"`. It applies the
    same logic to the final level, Street.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们理解输出。首先，pandas 针对州层级，在 `"AK"` 和 `"AL"` 之间对值 `"AK"` 进行排序。然后，在 `"AK"` 州内，pandas
    在 `"Rowlandchester"` 和 `"Scottstad"` 之间对城市进行排序。它将相同的逻辑应用于最终层级，街道。
- en: 'The `sort_values` method includes an `ascending` parameter. We can pass the
    parameter a Boolean to apply a consistent sort order to all `MultiIndex` levels.
    The next example provides an argument of `False`. Pandas sorts the State values
    in reverse alphabetical order, then the City values in reverse alphabetical order,
    and finally the Street values in reverse alphabetical order:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_values` 方法包含一个 `ascending` 参数。我们可以传递一个布尔值给该参数，以对所有 `MultiIndex` 层次应用一致的排序顺序。下一个示例提供了一个
    `False` 参数。Pandas 将州值按逆字母顺序排序，然后是城市值按逆字母顺序排序，最后是街道值按逆字母顺序排序：'
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Suppose that we want to vary the sort order for different levels. We can pass
    the `ascending` parameter a list of Booleans. Each Boolean sets the sort order
    for the next `MultiIndex` level, starting with the outermost one and proceeding
    inward. An argument of `[True, False, True]`, for example, will sort the State
    level in ascending order, the City level in descending order, and the Street level
    in ascending order:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为不同的层次改变排序顺序。我们可以将布尔值列表传递给 `ascending` 参数。每个布尔值设置下一个 `MultiIndex` 层次的排序顺序，从最外层开始，向内进行。例如，`[True,
    False, True]` 参数将按升序对州层次进行排序，按降序对城市层次进行排序，按升序对街道层次进行排序：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also sort a `MultiIndex` level by itself. Let’s say we want to sort
    the rows by the values in the second `MultiIndex` level, City. We can pass the
    level’s index position or its name to the `level` parameter of the `sort_index`
    method. Pandas will ignore the remaining levels when sorting:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以单独对 `MultiIndex` 层次进行排序。假设我们想要按第二个 `MultiIndex` 层次，即城市中的值对行进行排序。我们可以将层次索引位置或其名称传递给
    `sort_index` 方法的 `level` 参数。Pandas 在排序时会忽略剩余的层次：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `level` parameter also accepts a list of levels. The next example sorts
    the City level’s values first, followed by the Street level’s values. The State
    level’s values do not influence the sort at all:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`level` 参数也接受一个层次列表。下一个示例首先按城市层次排序，然后按街道层次排序。州层次的值对排序没有任何影响：'
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also combine the `ascending` and `level` parameters. Notice in the preceding
    example that pandas sorted the two Street values for the city of Amyburgh `("163
    Heather Neck"` and `"941 Brian Expressway"`) in alphabetical/ascending order.
    The next example sorts the City level in ascending order and the Street level
    in descending order, thus swapping the positions of the two Amyburgh Street values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合 `ascending` 和 `level` 参数。注意在前面的示例中，pandas 按字母/升序对艾姆伯赫市（"163 Heather
    Neck" 和 "941 Brian Expressway"）的两个街道值进行了排序。下一个示例按升序对城市层次进行排序，按降序对街道层次进行排序，从而交换了两个艾姆伯赫街道值的位置：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can sort the columns’ `MultiIndex` as well by supplying an `axis` parameter
    to the `sort_index` method. The parameter’s default argument is `0`, which represents
    the row index. To sort the columns, we can pass either the number `1` or the string
    `"columns"`. In the next example, pandas sorts the Category level first and the
    Subcategory level second. The value Culture comes before Services. Within the
    Culture level, the value Museums comes before Restaurants. Within Services, the
    value Police comes before Schools:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过向 `sort_index` 方法提供 `axis` 参数来对列的 `MultiIndex` 进行排序。参数的默认值是 `0`，代表行索引。要排序列，我们可以传递数字
    `1` 或字符串 `"columns"`。在下一个示例中，pandas 首先按类别层次排序，然后按子类别层次排序。文化值在服务之前。在文化层次内，博物馆值在餐馆之前。在服务中，警察值在学校之前：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can combine the `level` and `ascending` parameters with the `axis` parameter
    to further customize the columns’ sort orders. The next example sorts the Subcategory
    level values in descending order. Pandas ignores the values in the Category level.
    The reverse alphabetical order of the subcategories (`"Schools"`, `"Restaurants"`,
    `"Police"`, and `"Museums"`) forces a visual breakup of the Category group. Thus,
    the output prints the Services and Culture column headers multiple times:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `level` 和 `ascending` 参数与 `axis` 参数结合使用，以进一步自定义列的排序顺序。下一个示例按降序对子类别层次值进行排序。Pandas
    忽略类别层次中的值。子类别（"Schools"、"Restaurants"、"Police" 和 "Museums"）的逆字母顺序强制视觉上分割类别组。因此，输出会多次打印服务和文化列标题：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In section 7.4, we’ll learn how to extract rows and columns from a `MultiIndex`
    `DataFrame` with familiar accessor attributes such as `loc` and `iloc`. As mentioned
    earlier, it’s optimal to sort our index before we look up any row. Let’s sort
    the `MultiIndex` levels in ascending order and overwrite our `neighborhoods` `DataFrame`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7.4 节中，我们将学习如何使用熟悉的访问器属性（如 `loc` 和 `iloc`）从 `MultiIndex` `DataFrame` 中提取行和列。如前所述，在我们查找任何行之前对索引进行排序是最佳做法。让我们按升序排序
    `MultiIndex` 级别，并覆盖我们的 `neighborhoods` `DataFrame`：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s the result:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Looks good. We’ve sorted each level in the `MultiIndex` and are clear to proceed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。我们已经对 `MultiIndex` 中的每个级别进行了排序，可以继续进行。
- en: 7.4 Selecting with a MultiIndex
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 使用多级索引进行选择
- en: Extracting `DataFrame` rows and columns gets tricky when multiple levels are
    involved. The key question to ask before writing any code is what we want to pull
    out.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及多个级别时，从 `DataFrame` 中提取行和列会变得复杂。在编写任何代码之前，我们需要问的关键问题是我们要提取什么。
- en: 'Chapter 4 introduced the square-bracket syntax for selecting a column from
    a `DataFrame`. Here’s a quick reminder. The following code creates a `DataFrame`
    with two rows and two columns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章介绍了从 `DataFrame` 中选择列的方括号语法。这里有一个快速提醒。以下代码创建了一个包含两行两列的 `DataFrame`：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The square-bracket syntax extracts a column from the `DataFrame` as a `Series`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号语法从 `DataFrame` 中提取一列作为 `Series`：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Suppose that we want to pull out a column from neighborhoods. Each of the four
    columns in the `DataFrame` requires a combination of two identifiers: a Category
    and a Subcategory. What happens if we pass only one?'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想从 `neighborhoods` 中提取一列。`DataFrame` 中的四个列都需要两个标识符的组合：一个类别和一个子类别。如果我们只传递一个标识符会发生什么？
- en: 7.4.1 Extracting one or more columns
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 提取一个或多个列
- en: 'If we pass a single value in square brackets, pandas will look for it in the
    outermost level of the columns’ `MultiIndex`. The following example searches for
    `"Services"`, which is a valid value in the Category level:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在方括号中传递单个值，pandas 将在列的 `MultiIndex` 的最外层级别中查找它。以下示例搜索 `"Services"`，这是类别级别中的一个有效值：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice that the new `DataFrame` does not have a Category level. It has a plain
    `Index` with two values: `"Police"` and `"Schools"`. There is no longer a need
    for a `MultiIndex`; the two columns in this `DataFrame` are the subcategories
    that fall under the Services value. The Category level no longer has any variation
    that merits listing.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，新的 `DataFrame` 没有类别级别。它有一个简单的 `Index`，包含两个值："Police" 和 "Schools"。不再需要 `MultiIndex`；在这个
    `DataFrame` 中的两列是隶属于服务值的子类别。类别级别不再有任何值得列出的变化。
- en: 'Pandas will raise a `KeyError` exception if the value does not exist in the
    outermost level of the columns’ `MultiIndex`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值不存在于列的 `MultiIndex` 的最外层级别，Pandas 将引发 `KeyError` 异常：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'What if we want to target a specific Category and then a Subcategory within
    it? To specify values across multiple levels in the column’s `MultiIndex`, we
    can pass them inside a tuple. The next example targets the column with a value
    of `"Services"` in the Category level and a value of `"Schools"` in the Subcategory
    level:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想针对特定的类别，然后在该类别中针对子类别，我们应该怎么办？为了在列的 `MultiIndex` 的多个级别中指定值，我们可以将它们放在一个元组中。下一个示例针对类别级别中的值为
    `"Services"` 和子类别级别中的值为 `"Schools"` 的列：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method returns a `Series` without a column index! Once again, when we provide
    a value for a `MultiIndex` level, we remove the need for that level to exist.
    We explicitly told pandas what values to target in the Category and Subcategory
    levels, so the library removed the two levels from the column index. Because the
    `("Services", "Schools")` combination yielded a single column of data, pandas
    returned a `Series` object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个不带列索引的 `Series`！再次强调，当我们为 `MultiIndex` 级别提供一个值时，我们消除了该级别存在的必要性。我们明确告诉
    pandas 在类别和子类别级别中要针对哪些值，因此库从列索引中删除了这两个级别。因为 `("Services", "Schools")` 组合产生了一个数据列，所以
    pandas 返回了一个 `Series` 对象。
- en: 'To extract multiple `DataFrame` columns, we need to pass the square brackets
    a list of tuples. Each tuple should specify the level values for one column. The
    order of tuples within the list sets the order of columns in the resulting `DataFrame`.
    The next example pulls out two columns from neighborhoods:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取多个 `DataFrame` 列，我们需要向方括号传递一个元组列表。列表中的每个元组应指定一个列的级别值。列表中元组的顺序设置了结果 `DataFrame`
    中列的顺序。下一个示例从 `neighborhoods` 中提取两列：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Syntax tends to become confusing and error-prone when it involves multiple
    parentheses and brackets. We can simplify the preceding code by assigning the
    list to a variable and breaking its tuples across several lines:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'Syntax tends to become confusing and error-prone when it involves multiple
    parentheses and brackets. We can simplify the preceding code by assigning the
    list to a variable and breaking its tuples across several lines:'
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous two examples accomplish the same result, but this code is significantly
    easier to read; its syntax clearly identifies where each tuple begins and ends.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: The previous two examples accomplish the same result, but this code is significantly
    easier to read; its syntax clearly identifies where each tuple begins and ends.
- en: 7.4.2 Extracting one or more rows with loc
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 提取一个或多个行使用 loc
- en: 'Chapter 4 introduced the `loc` and `iloc` accessors for selecting rows and
    columns from a `DataFrame`. The `loc` accessor extracts by index label, and the
    `iloc` accessor extracts by index position. Here’s a quick review, using the `df`
    `DataFrame` we declared in section 7.4.1:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'Chapter 4 introduced the `loc` and `iloc` accessors for selecting rows and
    columns from a `DataFrame`. The `loc` accessor extracts by index label, and the
    `iloc` accessor extracts by index position. Here’s a quick review, using the `df`
    `DataFrame` we declared in section 7.4.1:'
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next example uses `loc` to select the row with an index label of `"A"`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'The next example uses `loc` to select the row with an index label of `"A"`:'
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next example uses `iloc` to select the row at index position 1:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例使用 `iloc` 来选择索引位置为 1 的行：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can use the `loc` and `iloc` accessors to pull rows from a `MultiIndex` `DataFrame`.
    Let’s start slow and work our way up.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: We can use the `loc` and `iloc` accessors to pull rows from a `MultiIndex` `DataFrame`.
    Let’s start slow and work our way up.
- en: 'The neighborhoods `DataFrame`’s `MultiIndex` has three levels: State, City,
    and Address. If we know the values to target in each level, we can pass them in
    a tuple within the square brackets. When we provide a value for a level, we remove
    the need for the level to exist in the result. The next example provides `"TX"`
    for the State level, `"Kingchester"` for the City level, and `"534 Gordon Falls"`
    for the Address level. Pandas returns a `Series` object with an index constructed
    from the column headers in neighborhoods:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'The neighborhoods `DataFrame`’s `MultiIndex` has three levels: State, City,
    and Address. If we know the values to target in each level, we can pass them in
    a tuple within the square brackets. When we provide a value for a level, we remove
    the need for the level to exist in the result. The next example provides `"TX"`
    for the State level, `"Kingchester"` for the City level, and `"534 Gordon Falls"`
    for the Address level. Pandas returns a `Series` object with an index constructed
    from the column headers in neighborhoods:'
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we pass a single label in the square brackets, pandas looks for it in the
    outermost `MultiIndex` level. The next example selects the rows with a State value
    of `"CA"`. State is the first level of the rows’ `MultiIndex`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'If we pass a single label in the square brackets, pandas looks for it in the
    outermost `MultiIndex` level. The next example selects the rows with a State value
    of `"CA"`. State is the first level of the rows’ `MultiIndex`:'
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pandas returns a `DataFrame` with a two-level `MultiIndex`. Notice that the
    State level is not present. There is no longer a need for it because all three
    rows belong to that level; there is no longer any variation to display.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas returns a `DataFrame` with a two-level `MultiIndex`. Notice that the
    State level is not present. There is no longer a need for it because all three
    rows belong to that level; there is no longer any variation to display.
- en: 'Usually, the second argument to the square brackets denotes the column(s) we’d
    like to extract, but we can also provide the value to look for in the next `MultiIndex`
    level. The next example targets rows with a State value of `"CA"` and a City value
    of `"Dustinmouth"`. Once again, pandas returns a `DataFrame` with one fewer level.
    Because only one level is left, pandas falls back to a plain `Index` object to
    store the row labels from the Street level:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'Usually, the second argument to the square brackets denotes the column(s) we’d
    like to extract, but we can also provide the value to look for in the next `MultiIndex`
    level. The next example targets rows with a State value of `"CA"` and a City value
    of `"Dustinmouth"`. Once again, pandas returns a `DataFrame` with one fewer level.
    Because only one level is left, pandas falls back to a plain `Index` object to
    store the row labels from the Street level:'
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can still use the second argument to `loc` to declare the column(s) to extract.
    The next example extracts rows with a State value of `"CA"` in the row `MultiIndex`
    and a Category value of `"Culture"` in the column `MultiIndex`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can still use the second argument to `loc` to declare the column(s) to extract.
    The next example extracts rows with a State value of `"CA"` in the row `MultiIndex`
    and a Category value of `"Culture"` in the column `MultiIndex`:'
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The syntax in the previous two examples is not ideal because of its ambiguity.
    The second argument to `loc` can represent either a value from the second level
    of the rows’ `MultiIndex` or a value from the first level of the columns’ `MultiIndex`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'The syntax in the previous two examples is not ideal because of its ambiguity.
    The second argument to `loc` can represent either a value from the second level
    of the rows’ `MultiIndex` or a value from the第一级 of the columns’ `MultiIndex`:'
- en: 'The pandas documentation [¹](#pgfId-1091446) recommends the following indexing
    strategy to avoid uncertainty. Use the first argument to `loc` for row index labels
    and the second argument for column index labels. Wrap all arguments for a given
    index inside a tuple. Following this standard, we should place our row levels’
    values inside a tuple and our column levels’ values inside a tuple as well. The
    recommended way to access rows with a State value of `"CA"` and a City value of
    `"Dustinmouth"` looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 文档 [¹](#pgfId-1091446) 建议以下索引策略以避免不确定性。使用 `loc` 的第一个参数作为行索引标签，第二个参数作为列索引标签。将给定索引的所有参数都包裹在一个元组中。按照这个标准，我们应该将我们的行级别值放在一个元组中，同样，我们的列级别值也应该放在一个元组中。访问具有
    `"CA"` 状态值和 `"Dustinmouth"` 市值的行的推荐方式如下：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This syntax is more straightforward and more consistent; it allows `loc`’s
    second argument to always represent the columns’ index labels to target. The next
    example pulls out the Services columns for the same state of `"CA"` and city of
    `"Dustinmouth"`. We pass `"Services"` inside a tuple. A one-element tuple requires
    a comma for Python to recognize it as a tuple:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法更直接、更一致；它允许 `loc` 的第二个参数始终代表列的索引标签以进行定位。下一个示例提取了相同州 `"CA"` 和市 `"Dustinmouth"`
    的服务列。我们在元组内传递 `"Services"`。一个元素的元组需要一个逗号，以便 Python 能够将其识别为元组：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here’s another helpful hint: pandas distinguishes between list and tuple arguments
    to accessors. Use a list to store multiple keys. Use a tuple to store the components
    of one multilevel key.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个有用的提示：pandas 区分列表和元组参数以访问器。使用列表来存储多个键。使用元组来存储一个多级键的组成部分。
- en: We can pass a tuple as the second argument to `loc` to provide values for levels
    in the columns’ `MultiIndex`. The next example targets
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将元组作为 `loc` 的第二个参数传递，为列的 `MultiIndex` 级别提供值。下一个示例针对
- en: '`"CA"` and `"Dustinmouth"` in the rows’ `MultiIndex` levels'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '行的 `MultiIndex` 级别中的 `"CA"` 和 `"Dustinmouth"` '
- en: '`"Services"` and `"Schools"` in the columns’ `MultiIndex` levels'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '列的 `MultiIndex` 级别中的 `"Services"` 和 `"Schools"` '
- en: 'The placement of `"Services"` and `"Schools"` in a single tuple tells pandas
    to view them as components that make up a single label. `"Services"` is the value
    for the Category level, and `"Schools"` is the value for the Subcategory level:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `"Services"` 和 `"Schools"` 放在一个元组中，告诉 pandas 将它们视为构成单个标签的组成部分。`"Services"`
    是类别级别的值，而 `"Schools"` 是子类别级别的值：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'What about selecting sequential rows? We can use Python’s list-slicing syntax.
    We place a colon between our starting point and our ending point. The next code
    sample pulls all consecutive rows with a State value between `"NE"` and `"NH".`
    In pandas slicing, the endpoint (the value after the colon) is inclusive:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于选择连续行怎么办？我们可以使用 Python 的列表切片语法。我们在起点和终点之间放置一个冒号。下一个代码示例提取了所有在 `"NE"` 和 `"NH"`
    之间的连续行。在 pandas 切片中，终点（冒号后的值）是包含的：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can combine list-slicing syntax with tuple arguments. The next example extracts
    all rows that
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将列表切片语法与元组参数结合使用。下一个示例提取所有行，这些行
- en: Start from a value of `"NE"` in the State level and `"Shawnchester"` in the
    City level
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从州级别 `"NE"` 和市级别 `"Shawnchester"` 的值开始
- en: End with a value of `"NH"` in the State level and `"North Latoya"` in the City
    level
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在州级别以 `"NH"` 结尾，在市级别以 `"North Latoya"` 结尾
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Be careful with this syntax; a single missing parenthesis or comma can raise
    an exception. We can simplify the code by assigning the tuples to descriptive
    variables and breaking the extraction into smaller pieces. The next example returns
    the same result set but is significantly easier to read:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个语法；单个缺失的括号或逗号都可能引发异常。我们可以通过将元组分配给描述性变量并将提取分解成更小的部分来简化代码。下一个示例返回相同的结果集，但更容易阅读：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We do not have to provide each tuple values for each level. The next example
    does not include a City-level value for the second tuple:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必为每个级别提供每个元组的值。下一个示例没有为第二个元组包含市级别的值：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Pandas pulls rows starting from `("NE", "Shawnchester")` until it reaches the
    end of all rows with a State value of `"NH"`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 从 `("NE", "Shawnchester")` 开始提取行，直到遇到所有具有 `"NH"` 状态值的行末尾。
- en: 7.4.3 Extracting one or more rows with iloc
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 使用 iloc 提取一个或多个行
- en: 'The `iloc` accessor extracts rows and columns by index position. The following
    examples should be a refresher on concepts covered in chapter 4\. We can pass
    an index position to `iloc` to extract a single row:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`iloc` 访问器通过索引位置提取行和列。以下示例应该会帮助你回顾第4章中介绍的概念。我们可以向 `iloc` 传递一个索引位置来提取单行：'
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can pass two arguments to `iloc` to represent the row and column indices.
    The next example targets the row with index position 25 and the column with index
    position 2:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 `iloc` 传递两个参数来表示行和列索引。下一个示例针对索引位置为 25 的行和索引位置为 2 的列：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can pull out multiple rows by wrapping their index positions in a list:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将它们的索引位置包裹在列表中来提取多行：
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There’s a big difference between `loc` and `iloc` when it comes to slicing.
    When we’re index slicing with `iloc`, the endpoint is exclusive. In the preceding
    example, the record with a street of `"910` `Sandy` `Ramp"` has index position
    30\. When we provide 30 as the `iloc` endpoint in the next example, pandas pulls
    up to that index but does not include it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片方面，`loc` 和 `iloc` 之间有很大的区别。当我们使用 `iloc` 进行索引切片时，终点是排他的。在前面的例子中，街道为 `"910
    Sandy Ramp"` 的记录的索引位置是 30。当我们提供 30 作为下一个示例中 `iloc` 终点的值时，pandas 提取到该索引，但不包括它：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Column slicing follows the same principles. The next example pulls the columns
    from index positions 1 to 3 (exclusive):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列切片遵循相同的原理。下一个示例从索引位置 1 到 3（不包括）提取列：
- en: '[PRE59]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Pandas also permits negative slices. The next example pulls rows starting from
    the fourth-to-last row and the columns starting from the second-to-last column:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 还允许使用负切片。下一个示例从倒数第四行开始提取行，从倒数第二列开始提取列：
- en: '[PRE60]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Pandas assigns each `DataFrame` row an index position, not each value in a given
    index level. Thus, we cannot index across consecutive `MultiIndex` levels with
    `iloc`. This limitation is an intentional design decision by the pandas development
    team. As developer Jeff Reback states, `iloc` serves as a “strict positional indexer”
    that “does not regard the structure [of the `DataFrame`] at all.” [²](#pgfId-1091618)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 为每个 `DataFrame` 行分配一个索引位置，而不是给定索引级别中的每个值。因此，我们无法使用 `iloc` 在连续的 `MultiIndex`
    级别之间进行索引。这种限制是 pandas 开发团队有意设计的一个决策。正如开发者 Jeff Reback 所说，`iloc` 作为“严格的位置索引器”，“根本不考虑
    `DataFrame` 的结构。” [²](#pgfId-1091618)
- en: 7.5 Cross-sections
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 横截面
- en: 'The `xs` method allows us to extract rows by providing a value for one `MultiIndex`
    level. We pass the method a `key` parameter with the value to look for. We pass
    the `level` parameter either the numeric position or the name of the index level
    in which to look for the value. For example, let’s say we wanted to find all addresses
    in a city of Lake Nicole, regardless of the state or street. City is the second
    level in the `MultiIndex;` it has an index position of 1 in the level hierarchy:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`xs` 方法允许我们通过提供一个 `MultiIndex` 级别的值来提取行。我们向该方法传递一个带有要查找的值的 `key` 参数。我们传递 `level`
    参数为要查找值的数字位置或索引级别的名称。例如，假设我们想要找到湖妮可市的所有地址，无论州或街道。城市是 `MultiIndex` 的第二级；它在级别层次结构中的索引位置为
    1：'
- en: '[PRE61]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There are three addresses in a city of `"Lake` `Nicole"` across two states.
    Notice that pandas removes the City level from the new `DataFrame`’s `MultiIndex`.
    The `City` value is fixed (`"Lake Nicole"`), so there is no need for pandas to
    include it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个州中，湖妮可市有三个地址。注意，pandas 从新的 `DataFrame` 的 `MultiIndex` 中移除了城市级别。`City` 值是固定的（`"Lake
    Nicole"`），因此 pandas 没有必要包含它。
- en: 'We can apply the same extraction techniques to columns by passing the `axis`
    parameter an argument of `"columns"`. The next example selects the columns with
    a key of `"Museums"` in the Subcategory level of the column `MultiIndex`. Only
    one column fits that description:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `axis` 参数的参数设置为 `"columns"` 来将相同的提取技术应用于列。下一个示例选择具有 `Subcategory` 级别中
    `"Museums"` 键的列 `MultiIndex`。只有一个列符合这个描述：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice that the Subcategory level is not present in the returned `DataFrame`,
    but the Category level is still present. Pandas includes it because there is still
    potential for variation (such as multiple values) in the Category level. When
    we pull out values from an intermediate level, they can belong to multiple top-level
    labels.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，子类别级别在返回的 `DataFrame` 中不存在，但类别级别仍然存在。Pandas 包含它是因为类别级别仍然存在变化的可能性（如多个值）。当我们从中间级别提取值时，它们可能属于多个顶级标签。
- en: 'We can also provide the `xs` method with keys across nonconsecutive `MultiIndex`
    levels. We pass them in a tuple. Suppose that we want the rows with a Street value
    of `"238` `Andrew` `Rue"` and a State of `"AK"`, irrespective of the City value.
    That’s not a problem with `xs`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向 `xs` 方法提供跨越非连续 `MultiIndex` 级别的键。我们将它们作为一个元组传递。假设我们想要找到具有 `"238 Andrew
    Rue"` 街道值和 `"AK"` 州值的行，无论城市值如何。这对 `xs` 来说不是问题：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The ability to target values in only one level is a powerful feature of `MultiIndex`es.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 能够仅针对一个级别的值进行操作是 `MultiIndex` 的一个强大功能。
- en: 7.6 Manipulating the Index
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 索引操作
- en: At the start of the chapter, we contorted our neighborhoods data set into its
    current shape by altering the parameters to the `read_csv` function. Pandas also
    allows us to manipulate the index on an existing `DataFrame`. Let’s take a look.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们通过改变 `read_csv` 函数的参数，将我们的邻里数据集扭曲成当前的形状。Pandas 也允许我们操作现有的 `DataFrame`
    上的索引。让我们看一下。
- en: 7.6.1 Resetting the index
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 重置索引
- en: 'The neighborhoods `DataFrame` currently has State as its outermost `MultiIndex`
    level, followed by City and Street:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 邻里 `DataFrame` 当前具有 State 作为其最外层的 `MultiIndex` 级别，后面跟着 City 和 Street：
- en: '[PRE64]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `reorder_levels` method arranges the `MultiIndex` levels in a specified
    order. We pass its `order` parameter a list of levels in a desired order. The
    next example swaps the positions of the City and State levels:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`reorder_levels` 方法按照指定的顺序排列 `MultiIndex` 级别。我们向其 `order` 参数传递一个所需顺序的级别列表。下一个示例交换了
    City 和 State 级别的位置：'
- en: '[PRE65]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can also pass the `order` parameter a list of integers. The numbers must
    represent the current index positions of the `MultiIndex` levels. If we want State
    to be the first level in the new `MultiIndex`, for example, we have to start the
    list with 1—the State level’s index position in the current `MultiIndex`. The
    next code sample returns the same result as the preceding one:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以向 `order` 参数传递一个整数列表。这些数字必须代表 `MultiIndex` 级别的当前索引位置。如果我们想 State 成为新的 `MultiIndex`
    中的第一个级别，例如，我们必须以 1 开始列表——这是 State 级别在当前 `MultiIndex` 中的索引位置。下一个代码示例返回与上一个相同的结果：
- en: '[PRE66]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'What if we want to get rid of the index? Perhaps we want to set a different
    combination of columns as the index labels. The `reset_index` method returns a
    new `DataFrame` that integrates the former `MultiIndex` levels as columns. Pandas
    replaces the former `MultiIndex` with its standard numeric one:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想去除索引呢？也许我们想设置不同组合的列作为索引标签。`reset_index` 方法返回一个新的 `DataFrame`，它将之前的 `MultiIndex`
    级别作为列整合。Pandas 将之前的 `MultiIndex` 替换为其标准的数值索引：
- en: '[PRE67]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice that the three new columns (State, City, and Street) become values in
    Category, the outermost level of the columns’ `MultiIndex`. To ensure consistency
    among columns (making each one a tuple of two values), pandas assigns the three
    new columns a Subcategory value of an empty string.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，三个新列（State、City 和 Street）成为列的 `MultiIndex` 的最外层级别 Category 的值。为了确保列之间的一致性（使每一列都成为两个值的元组），pandas
    将三个新列分配一个空字符串的子类别值。
- en: 'We can add the three columns to an alternate `MultiIndex` level. Pass the desired
    level’s index position or name to the `reset_index` method’s `col_level` parameter.
    The next example integrates the State, City, and Street columns into the Subcategory
    level of the columns’ `MultiIndex`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将三个列添加到另一个 `MultiIndex` 级别。将所需级别的索引位置或名称传递给 `reset_index` 方法的 `col_level`
    参数。下一个示例将 State、City 和 Street 列整合到列的 `MultiIndex` 的子类别级别：
- en: '[PRE68]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now pandas will default to an empty string for Category, the parent level that
    holds the Subcategory level under which State, City, and Street fall. We can replace
    the empty string with a value of our choice by passing an argument to the `col_fill`
    parameter. In the next example, we group the three new columns under an Address
    parent level. Now the outer Category level holds the three distinct values Address,
    Culture, and Services:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 pandas 将默认为空字符串用于类别，这是包含 State、City 和 Street 的子类别级别的父级别。我们可以通过传递一个参数到 `col_fill`
    参数来用我们选择的价值替换空字符串。在下一个示例中，我们在地址父级别下对三个新列进行分组。现在外部的类别级别包含三个不同的值：地址、文化和服务：
- en: '[PRE69]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The standard invocation of `reset_index` transforms all index levels into regular
    columns. We can also move a single index level by passing its name to the `levels`
    parameter. The next example moves the Street level from the `MultiIndex` to a
    regular `DataFrame` column:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset_index` 的标准调用将所有索引级别转换为常规列。我们也可以通过传递其名称到 `levels` 参数来移动单个索引级别。下一个示例将
    `Street` 级别从 `MultiIndex` 移动到常规 `DataFrame` 列：'
- en: '[PRE70]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can move multiple index levels by passing them in a list:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递一个列表来移动多个索引级别：
- en: '[PRE71]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'What about removing a level from the `MultiIndex`? If we pass the `reset_index`
    method’s `drop` parameter a value of `True`, pandas will delete the specified
    level instead of adding it to the columns. The next `reset_index` example removes
    the Street level:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要从 `MultiIndex` 中移除一个级别怎么办？如果我们向 `reset_index` 方法的 `drop` 参数传递一个值为 `True`，pandas
    将删除指定的级别而不是将其添加到列中。下一个 `reset_index` 示例移除了 Street 级别：
- en: '[PRE72]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To set ourselves up for section 7.6.2, let’s make our index reset permanent
    by overwriting the `neighborhoods` variable with the new `DataFrame`. This operation
    moves all three index levels to columns in the `DataFrame`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为7.6.2节做准备，让我们通过用新的`DataFrame`覆盖`neighborhoods`变量来使索引重置永久化。此操作将所有三个索引级别移动到`DataFrame`的列中：
- en: '[PRE73]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now we have seven columns in neighborhoods with a `MultiIndex` on only the column
    axis.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有七个列在社区中，只有列轴上的`MultiIndex`。
- en: 7.6.2 Setting the index
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 设置索引
- en: 'Let’s check in on our `DataFrame` to jog our memory:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的`DataFrame`以唤醒我们的记忆：
- en: '[PRE74]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `set_index` method sets one or more `DataFrame` columns as the new index.
    We can pass the column(s) to use to its `keys` parameter:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_index`方法将一个或多个`DataFrame`列设置为新的索引。我们可以将列传递给其`keys`参数：'
- en: '[PRE75]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'What if we want one of the last four columns to serve as the index?. The next
    example passes the `keys` parameter a tuple with the values to target at each
    `MultiIndex` level:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让最后四个列中的一个作为索引怎么办？下一个示例通过将包含要针对每个`MultiIndex`级别值的元组传递给`keys`参数：
- en: '[PRE76]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To create a `MultiIndex` on the row axis, we can pass a list with multiple
    columns to the `keys` parameter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要在行轴上创建`MultiIndex`，我们可以将包含多个列的列表传递给`keys`参数：
- en: '[PRE77]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As we’ve seen frequently in pandas, there are many permutations and combinations
    for shaping a data set for analysis. When defining a `DataFrame`’s indices, ask
    yourself which values matter most to your current problem. What is the key piece
    of information? Are several pieces of data intrinsically tied together? Which
    data points would you like to store as rows versus columns? Do rows or columns
    comprise a group or category? For many of these problems, a `MultiIndex` can provide
    an effective solution for storing your data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在pandas中经常看到的那样，有许多排列和组合可以用于分析数据集。在定义`DataFrame`的索引时，问问自己当前问题中最重要的是哪些值。关键信息是什么？几份数据是否本质上相互关联？你希望将哪些数据点存储为行或列？行或列是否构成一个组或类别？对于许多这些问题，`MultiIndex`可以提供有效的解决方案来存储你的数据。
- en: 7.7 Coding challenge
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 编码挑战
- en: Here’s your chance to practice the concepts introduced in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是练习本章引入的概念的机会。
- en: 7.7.1 Problems
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 问题
- en: 'The investments.csv data set holds more than 27,000 records of startup investments
    gathered from the website Crunchbase. Each startup has a Name, a Market, a Status,
    a State of operation, and a number of Funding Rounds:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: investments.csv数据集包含来自网站Crunchbase的超过27,000条创业投资记录。每个初创公司都有一个名称、一个市场、一个状态、一个运营状态和一个融资轮次数量：
- en: '[PRE78]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s add a `MultiIndex` to this `DataFrame`. We can begin by identifying the
    number of unique values in each column with the `nunique` method. Columns with
    a small number of unique items usually represent categorical data and are good
    candidates for index levels:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`DataFrame`上添加一个`MultiIndex`。我们可以通过使用`nunique`方法来识别每个列中唯一值的数量。具有少量唯一项的列通常表示分类数据，并且是索引级别的良好候选者：
- en: '[PRE79]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let’s create a three-level `MultiIndex` with the Status, Funding Rounds, and
    State columns. We’ll order the columns so that the ones with the smallest number
    of values come first. The fewer unique values in a level, the quicker pandas can
    extract its rows. We’ll also sort the `DataFrame` index to accelerate lookup time:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含状态、融资轮次和状态列的三级`MultiIndex`。我们将按列中值数量最少的原则排序列。级别中的唯一值越少，pandas提取其行就越快。我们还将对`DataFrame`索引进行排序以加速查找时间：
- en: '[PRE80]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here’s what investments currently looks like:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是投资目前的样子：
- en: '[PRE81]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here are the challenges for this section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是该节的一些挑战：
- en: Extract all rows with a Status of `"Closed"`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取所有状态为`"Closed"`的行。
- en: Extract all rows with a Status of `"Acquired"` and 10 funding rounds.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取所有状态为`"Acquired"`并且有十个融资轮次的行。
- en: Extract all rows with a Status of `"Operating"`, six funding rounds, and a State
    of `"NJ"`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取所有状态为`"Operating"`、六个融资轮次和状态为`"NJ"`的行。
- en: Extract all rows with a Status of `"Closed"` and eight funding rounds. Pull
    out only the Name column.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取所有状态为`"Closed"`并且有八个融资轮次的行，只提取名称列。
- en: Extract all rows with a State of `"NJ"`, irrespective of the values in the Status
    and Funding Rounds levels.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取所有状态为`"NJ"`的行，无论状态和融资轮次级别的值如何。
- en: Reincorporate the `MultiIndex` levels back into the `DataFrame` as columns.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MultiIndex`级别重新整合回`DataFrame`作为列。
- en: 7.7.2 Solutions
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.2 解决方案
- en: 'Let’s tackle the problems one by one:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一解决这些问题：
- en: 'To extract all rows with a Status of `"Closed"`, we can use the `loc` accessor.
    We’ll pass a tuple with a single value of `"Closed"`. Remember that a one-element
    tuple requires a comma:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取所有状态为 `"Closed"` 的行，我们可以使用 `loc` 访问器。我们将传递一个包含单个值 `"Closed"` 的元组。请记住，单元素元组需要逗号：
- en: '[PRE82]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, we need to pull out rows that fit two conditions: a Status value of `"Acquired"`
    and a Funding Rounds value of 10\. These are sequential levels in the `MultiIndex`.
    We can pass a tuple with the proper values to the `loc` accessor:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要提取符合两个条件的行：状态值为 `"Acquired"` 和融资轮次值为 10。这些是 `MultiIndex` 中的连续级别。我们可以将包含正确值的元组传递给
    `loc` 访问器：
- en: '[PRE83]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can use the same solution that we used for the preceding two problems. This
    time around, we need to provide a tuple of three values, one for each `MultiIndex`
    level:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用之前两个问题中使用的相同解决方案。这次，我们需要提供一个包含三个值的元组，每个值对应于 `MultiIndex` 的一个级别：
- en: '[PRE84]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To extract `DataFrame` columns, we can pass a second argument to the `loc`
    accessor. For this problem, we’ll pass a one-element tuple with the Name column.
    The first argument still holds the values for the Status and Funding Rounds levels:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取 `DataFrame` 列，我们可以向 `loc` 访问器传递第二个参数。对于这个问题，我们将传递一个包含名称列的单元素元组。第一个参数仍然包含状态和融资轮次级别的值：
- en: '[PRE85]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The next challenge asks us to extract rows with a value of `"NJ"` in the State
    level. We can use the `xs` method, passing either the level’s index position or
    the level’s name to the `level` parameter:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个挑战要求我们提取在州级别具有 `"NJ"` 值的行。我们可以使用 `xs` 方法，将级别索引位置或级别名称传递给 `level` 参数：
- en: '[PRE86]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we want to add the `MultiIndex` levels back to the `DataFrame` as
    columns. We’ll invoke the `reset_index` method to reincorporate the index levels
    and overwrite the `investments` `DataFrame` to make the change permanent:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望将 `MultiIndex` 级别作为列添加回 `DataFrame`。我们将调用 `reset_index` 方法来重新整合索引级别，并覆盖
    `investments` `DataFrame` 以使更改永久：
- en: '[PRE87]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Congratulations on completing the coding challenge!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成编码挑战！
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A `MultiIndex` is an index made of multiple levels.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiIndex` 是由多个级别组成的索引。'
- en: A `MultiIndex` uses tuples of values to store its labels.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiIndex` 使用值的元组来存储其标签。'
- en: A `DataFrame` can store a `MultiIndex` on both its row and column axis.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame` 可以在其行和列轴上存储 `MultiIndex`。'
- en: The `sort_index` method sorts `MultiIndex` levels. Pandas can sort index levels
    individually or as a group.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_index` 方法对 `MultiIndex` 级别进行排序。Pandas 可以单独或作为一组对索引级别进行排序。'
- en: The label-based `loc` and the position-based `iloc` accessors require additional
    arguments to extract the proper combination of rows and columns.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于标签的 `loc` 和基于位置的 `iloc` 访问器需要额外的参数来提取正确的行和列组合。
- en: Pass tuples to the `loc` and `iloc` accessors to avoid ambiguity.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `loc` 和 `iloc` 访问器传递元组以避免歧义。
- en: The `reset_index` method integrates index levels as `DataFrame` columns.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset_index` 方法将索引级别作为 `DataFrame` 列整合。'
- en: Pass the `set_index` method a list of columns to build a `MultiIndex` from existing
    `DataFrame` columns.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `set_index` 方法传递列的列表，以从现有的 `DataFrame` 列构建 `MultiIndex`。
- en: '* * *'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ See “Advanced indexing with hierarchical index,” [http://mng.bz/5WJO](http://mng.bz/5WJO).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 请参阅“使用分层索引的高级索引”，[http://mng.bz/5WJO](http://mng.bz/5WJO)。
- en: ² See Jeff Reback, “Inconsistent behavior of loc and iloc for MultiIndex,” [https://github.com/pandas-dev/pandas/issues/15228](https://github.com/pandas-dev/pandas/issues/15228).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ² 请参阅 Jeff Reback 的“loc 和 iloc 在 MultiIndex 中的不一致行为”，[https://github.com/pandas-dev/pandas/issues/15228](https://github.com/pandas-dev/pandas/issues/15228)。
