- en: Unit 1\. Variables and strings
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1单元\. 变量和字符串
- en: One of the most familiar statements in JavaScript is the `var` statement. But
    the addition of `let` and `const` means that `var` will soon be used much less.
    The `var` statement isn’t going away, and can still be used, but most programmers
    will soon opt to use `const` to declare variables anytime they don’t need to be
    reassigned and `let` anytime they do. In the first two lessons in this unit, you’ll
    discover why that is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中最熟悉的语句之一是`var`语句。但`let`和`const`的加入意味着`var`将很快被使用得越来越少。`var`语句并不会消失，仍然可以使用，但大多数程序员将很快选择在不需要重新赋值时使用`const`来声明变量，而在需要时使用`let`。在本单元的前两课中，你将发现这是为什么。
- en: The following two lessons will cover new string methods and a new type of string
    called a *template*. Templates are handy and will make the old, tedious task of
    concatenating large strings at author-time (at the time the code is being written)
    a thing of the past. Templates also have a less-known feature called *tagged templates*,
    which allows for custom processing and opens the door for creating domain-specific
    languages. You’ll wrap up this unit by creating a couple of your own domain-specific
    languages using tagged templates.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两课将介绍新的字符串方法和一种称为*模板*的新字符串类型。模板很方便，将使在编写代码时（代码编写时）拼接大型字符串的繁琐任务成为过去式。模板还有一个不太为人所知的特性，称为*标签模板*，它允许自定义处理，并为创建特定领域的语言打开了大门。你将通过使用标签模板创建几个自己的特定领域语言来结束本单元。
- en: Lesson 4\. Declaring variables with let
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4课\. 使用let声明变量
- en: After reading [lesson 4](kindle_split_013_split_000.xhtml#ch04), you will
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读第4课[课后](kindle_split_013_split_000.xhtml#ch04)后，你将
- en: Understand how scope works with `let` and how it differs from `var`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`let`的作用域以及它与`var`的区别
- en: Understand the difference between block scope and function scope
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解块作用域和函数作用域之间的区别
- en: Understand how `let` variables are hoisted
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`let`变量的提升方式
- en: 'In the history of JavaScript, variables have always been declared using the
    keyword `var`.^([[1](kindle_split_013_split_000.xhtml#ch04fn01)]) ES6 introduces
    two new ways to declare variables, with the `let` and `const` keywords.^([[2](kindle_split_013_split_000.xhtml#ch04fn02)])
    Both of these work slightly differently than variables declared with `var`. There
    are two primary differences with `let`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的历史中，变量总是使用关键字`var`来声明。^([[1](kindle_split_013_split_000.xhtml#ch04fn01)])
    ES6引入了两种新的声明变量的方式，即使用`let`和`const`关键字。^([[2](kindle_split_013_split_000.xhtml#ch04fn02)])
    这两种方式与使用`var`声明的变量略有不同。与`let`相关的有两个主要区别：
- en: ¹
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Actually, in non-strict mode, it was possible to create a new variable while
    completely omitting the `var` declaration altogether. This, however, created a
    global, usually unbeknownst to the author, leading to some pretty fun bugs. This
    is why `var` is required in strict mode.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，在非严格模式下，可以在完全不使用`var`声明的情况下创建一个新变量。然而，这却创建了一个全局变量，通常作者并不知道，导致了一些相当有趣的错误。这就是为什么在严格模式下需要`var`的原因。
- en: ²
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Technically `const`s are not variables but constants.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 技术上`const`不是变量，而是常量。
- en: '`let` variables have different scoping rules.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let`变量的作用域规则不同。'
- en: '`let` variables behave differently when hoisted.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let`变量在提升时的行为不同。'
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Consider the following two `for` statements. The only difference is that one
    is using an iterator declared with `var` and the other with `let`. But the resulted
    outcome is much different. What do you think will happen when each one runs?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个`for`语句。它们之间的唯一区别是其中一个使用`var`声明的迭代器，而另一个使用`let`。但结果却大相径庭。你认为当每个语句运行时会发生什么？
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.1\. How scope works with let
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. let的作用域如何工作
- en: 'Variables declared with `let` have *block scope*, meaning they can only be
    accessed within the block (or sub-blocks) they are declared in:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`声明的变量具有*块作用域*，这意味着它们只能在它们声明的块（或子块）内访问：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* An error is thrown because foo does not exist outside the block it was
    declared in.**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由于foo在其声明块之外不存在，因此会抛出错误。**'
- en: 'This makes variables much more predictable and won’t lead to bugs being introduced
    because the variable leaks outside of the block it is used within. A *block* is
    the body of a statement or function. It is the area between the opening and closing
    curly braces, `{` and `}`. You can even use curly braces to create a free-standing
    block that isn’t tied to a statement:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得变量更加可预测，并且不会因为变量从其使用的块中泄漏而导致引入错误。一个 *块* 是语句或函数的主体。它是大括号 `{` 和 `}` 之间的区域。你甚至可以使用大括号来创建一个不与语句相关的独立块：
- en: Listing 4.1\. Using a free-standing block to keep a variable private
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 使用独立块来保持变量私有
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Opening a free-standing block**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打开一个独立块**'
- en: '***2* data is effectively a private variable.**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `data` 事实上是一个私有变量。**'
- en: '***3* Closing a free-standing block**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 关闭一个独立块**'
- en: '***4* “Welcome to ES6!”**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* “欢迎来到 ES6！”**'
- en: '***5* Referencing data outside of the block results in an error.**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在块外引用数据会导致错误。**'
- en: In this example, `read` and `write` are declared outside the block, but their
    values are assigned inside the block that `data` is declared in. This gives them
    access to the `data` variable. But `data` isn’t accessible outside of the block
    and so becomes a private variable that `write` and `read` can use to store their
    internal data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`read` 和 `write` 在块外声明，但它们的值在 `data` 声明的块内赋值。这使得它们可以访问 `data` 变量。但是 `data`
    在块外不可访问，因此成为一个私有变量，`write` 和 `read` 可以使用它来存储它们内部的数据。
- en: 'Normally for a variable declared with `let` to be scoped to a specific block,
    the variable has to be declared within that block. There is one exception to that
    rule, though: in a `for` loop, a variable declared with a `let` inside the `for`
    loop’s clause will be in the scope of the `for` loop’s block:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于使用 `let` 声明的变量要作用域到特定的块，变量必须在那个块内声明。然而，有一个例外：在 `for` 循环中，在 `for` 循环的子句内使用
    `let` 声明的变量将作用域在 `for` 循环的块内：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* i is declared in the clause of the for statement.**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `i` 在 `for` 语句的子句中声明。**'
- en: '***2* i is in the scope of the for loop’s block.**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `i` 在 `for` 循环的块作用域内。**'
- en: '***3* i cannot be referenced outside the for loop and an error is thrown.**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `i` 不能在 `for` 循环外部引用，并且会抛出错误。**'
- en: 4.1.1\. Why the block scope of let is preferred
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 为什么 `let` 的块作用域更受欢迎
- en: 'Variables declared with `var` have *function scope*, meaning they can be accessed
    anywhere in their containing function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 声明的变量有 *函数作用域*，这意味着它们可以在其包含函数的任何地方访问：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* foo is being referenced outside of the if statement it was declared in.**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `foo` 在其声明的 `if` 语句外部被引用。**'
- en: 'This has historically confused developers and led to bugs due to false assumptions.
    Let’s take a look at a classic example in the next listing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这在历史上让开发者感到困惑，并由于错误的假设而导致错误。让我们在下一个列表中看看一个经典示例：
- en: Listing 4.2\. There is a scope problem here, but what is it?
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 这里有一个作用域问题，但问题是什么？
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* document.querySelectorAll is a standard web API method that allows selecting
    all the DOM nodes that match a specified query.**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `document.querySelectorAll` 是一个标准的 Web API 方法，允许选择所有匹配指定查询的 DOM 节点。**'
- en: '***2* addEventListener is a method on DOM nodes that allows attaching an event
    listener.**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `addEventListener` 是 DOM 节点上的一个方法，允许附加事件监听器。**'
- en: This code looks like it’s attaching an event listener to each list item so that
    when it’s clicked, its text and index will be alerted. In other words, if the
    first list item is clicked, the expectation is that one:0 is alerted. The reality
    is that no matter which list item is clicked, the alerted value will always be
    the same, five:5\. That is because this code has a bug in it, a bug that has bitten
    many developers due to function level scoping.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来像是在每个列表项上附加了一个事件监听器，以便当点击时，它的文本和索引将被提示。换句话说，如果点击第一个列表项，期望提示的是 one:0。但现实是，无论点击哪个列表项，提示的值总是相同的，即
    five:5。这是因为这段代码中有一个错误，这个错误由于函数级作用域而导致许多开发者遇到了问题。
- en: 'Did you spot the bug? Since the variables aren’t scoped to the `for` statement,
    each iteration is using the same variables. Here’s the breakdown of what’s going
    on:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现了错误吗？由于变量没有作用域到 `for` 语句，每个迭代都在使用相同的变量。以下是正在发生的事情的分解：
- en: The variable `i` is declared as 0.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `i` 被声明为 0。
- en: The first iteration of the `for` loop runs.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环的第一次迭代执行。'
- en: '`i` is 0 and `li` is the first list item.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 的值为 0，`li` 是第一个列表项。'
- en: The second iteration of the `for` loop runs.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环的第二次迭代执行。'
- en: '`i` is 1 and `li` is the second list item.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 的值为 1，`li` 是第二个列表项。'
- en: The third iteration of the `for` loop runs.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环的第三次迭代运行。'
- en: '`i` is 2 and `li` is the third list item.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 的值为 2，`li` 是第三个列表项。'
- en: The fourth iteration of the `for` loop runs.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环的第四次迭代运行。'
- en: '`i` is 3 and `li` is the fourth list item.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 的值为 3，`li` 是第四个列表项。'
- en: The fifth iteration of the `for` loop runs.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环的第五次迭代运行。'
- en: '`i` is 4 and `li` is the fifth list item.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 的值为 4，`li` 是第五个列表项。'
- en: '`i` increments to 5 and the `for` loop stops.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 增加到 5，`for` 循环停止。'
- en: This means after the `for` loop completes, `i` and `li` are set to 5 and the
    fifth list item, respectively. If the `for` loop alerted the text immediately,
    no bug would be observed; however, the alert statements are set to be alerted
    in an event listener which won’t be triggered until after the `for` loop completes.
    So by the time any of the events trigger and alert `i` and `li.textContent`, you
    get 5 and five.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 `for` 循环完成后，`i` 和 `li` 分别被设置为 5 和第五个列表项。如果 `for` 循环立即发出警报，则不会观察到任何错误；然而，警报语句被设置为在事件监听器中发出，该监听器将在
    `for` 循环完成后才会触发。因此，在触发任何事件并发出 `i` 和 `li.textContent` 的警报时，你会得到 5 和五个。
- en: 'Previously you used a free-standing block to create a scope around some code
    to keep a variable private. Typically a scope like this is created by using an
    *immediately invoked function expression (IIFE)* like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之前你使用一个独立的代码块来创建一个作用域，以保持变量私有。通常，这样的作用域是通过使用一个立即执行的函数表达式（IIFE）来创建的，如下所示：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you rewrite [listing 4.1](kindle_split_013_split_001.xhtml#ch04ex01) using
    an immediately invoked function expression, it will look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用立即执行的函数表达式重写 [列表 4.1](kindle_split_013_split_001.xhtml#ch04ex01)，它将看起来像这样：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* “Back in ES5 land.”**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “回到 ES5 世界。”**'
- en: '***2* data is out of scope so an error is thrown.**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 数据超出作用域，因此抛出错误。**'
- en: This code is much more complex looking and harder to understand at a glance
    because it’s creating and invoking a function for the purpose of creating a scope.
    Using a function merely as a means to create a scope is a bit of overkill, but
    before ES6, that was the only option. With block scope, this is no longer the
    case and IIFEs can be replaced with free-standing blocks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来更复杂，一眼看去更难理解，因为它是为了创建作用域而创建和调用函数。仅仅为了创建作用域而使用函数是一种过度设计，但在 ES6 之前，这是唯一的选择。有了块作用域，这种情况就不再存在了，IIFE
    可以被独立的代码块所取代。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 4.1**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 4.1**'
- en: '**[Q1:](kindle_split_013_split_001.xhtml#ch04qa2q0a1)**'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_013_split_001.xhtml#ch04qa2q0a1)**'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code, what will be logged to the console?
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，控制台将输出什么？
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 4.1 answer**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 4.1 答案**'
- en: '**[A1:](kindle_split_013_split_001.xhtml#ch04qa1q1)**'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_013_split_001.xhtml#ch04qa1q1)**'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This would cause the first word *function* to be processed but not the second
    word *scope*, because by the time the inner loop finishes, i is equal to 7, causing
    the outer loop to stop before processing the second word.
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这会导致处理第一个单词 *function*，但不会处理第二个单词 *scope*，因为当内循环完成后，`i` 的值等于 7，导致外循环在处理第二个单词之前停止。
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Technically this problem could be solved by declaring both `i` variables with
    `let` instead of `var`. But this is called *variable shadowing*,^([[3](kindle_split_013_split_001.xhtml#ch04fn03)])
    and is generally considered a bad practice so I would still advise using a different
    variable name for the inner variable.
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从技术上讲，这个问题可以通过用 `let` 而不是 `var` 声明两个 `i` 变量来解决。但这种情况被称为 *变量遮蔽*，^([[3](kindle_split_013_split_001.xhtml#ch04fn03)])，通常被认为是一种不好的做法，所以我仍然建议为内部变量使用不同的变量名。
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ³
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [https://en.wikipedia.org/wiki/Variable_shadowing](https://en.wikipedia.org/wiki/Variable_shadowing)
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [https://en.wikipedia.org/wiki/Variable_shadowing](https://en.wikipedia.org/wiki/Variable_shadowing)
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.2\. How hoisting works with let
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. `let` 的提升工作原理
- en: 'Variables declared with `let` and `var` both have a behavior called *hoisting*.
    This means that within the entire scope of where the variable is declared, whether
    the entire block for `let` or the entire function for `var`, the variable consumes
    the entire scope. This happens no matter where in the scope the variable is declared:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let` 和 `var` 声明的变量都具有称为 *提升* 的行为。这意味着在变量声明的整个作用域内，无论是 `let` 的整个块还是 `var`
    的整个函数，变量都会消耗整个作用域。无论变量在作用域中的哪个位置声明，都会发生这种情况：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This means that in this section of code, the variable is in scope and can be
    accessed even before it is declared! This is true and somewhat counterintuitive
    if another variable by the same name exists just outside the scope. Consider this
    example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在这个代码段中，变量在作用域内，即使在其声明之前也可以被访问！如果存在另一个同名的变量，只是作用域稍微大一点，这种情况是真实且有些反直觉的。考虑以下示例：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are actually two `myData` variables here: one that’s in scope only in
    the `if` statement, and another that’s in the containing scope. This gets tricky
    because intuitively, you might think the outer-scoped `myData` with the default
    value is being passed to the `doSomePrework` function because the inner variable
    hasn’t been declared yet. But that isn’t the case. Because the inner variable
    consumes the entire scope, it’s the variable that is passed to the `doSomePrework`
    function. It’s hoisted and used before it’s even declared.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这里有两个`myData`变量：一个只在`if`语句的作用域内，另一个在包含的作用域内。这很棘手，因为直观上，你可能认为具有默认值的更外层作用域的`myData`被传递给了`doSomePrework`函数，因为内部变量尚未声明。但这并不是事实。因为内部变量消耗了整个作用域，所以它是传递给`doSomePrework`函数的变量。它被提升并在声明之前使用。
- en: This concept of variables being in scope before they are declared, called hoisting,
    isn’t actually new. `let` hoists to the top of the block, and `var` hoists to
    the top of the function. There is, however, a more important distinction here,
    namely what happens when a variable declared with `let` is accessed before it’s
    declared, in contrast to `var`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在声明之前就在作用域内，这种称为提升的概念实际上并不新鲜。`let`提升到块的顶部，而`var`提升到函数的顶部。然而，这里有一个更重要的区别，即当使用`let`声明的变量在声明之前被访问时会发生什么，与`var`相比。
- en: 'When a `let` variable is accessed in scope before it is declared, it throws
    a reference error. This is unlike `var`, which allows the use but the value will
    always be undefined. This area or *zone*, in which the `let` variable can be accessed
    at a time before it is declared but will throw an error if it actually is, is
    called a *temporal dead zone*. More specifically, a temporal dead zone refers
    to the area in which the variable is in scope before it’s declared. Any references
    to variables in a temporal dead zone will throw a reference error:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`let`变量在声明之前在作用域内被访问时，它会抛出一个引用错误。这与`var`不同，`var`允许使用，但值始终是未定义的。这个区域或*区域*，在这个区域中`let`变量可以在声明之前被访问，但如果实际访问则会抛出错误，被称为*时间死区*。更具体地说，时间死区是指变量在声明之前的作用域内的区域。对时间死区内的变量的任何引用都会抛出引用错误：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Error thrown, as foo is not declared yet**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 抛出错误，因为foo尚未声明**'
- en: Take a moment to look over this code. What do you think will be logged when
    executed?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间看看这段代码。你认为执行时将输出什么？
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you think the answer is `10`, you’re correct. But there’s something else
    going on here that’s easy to miss. By modifying the example ever so slightly,
    you can see what’s going on:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为答案是`10`，你是正确的。但这里还有其他一些容易忽略的事情发生。通过稍微修改示例，你可以看到正在发生什么：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What would you expect to be logged now? If you answer `1`, you’re incorrect.
    Why is this?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在期望输出什么？如果你回答`1`，你是错误的。为什么？
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* num is 0 so the if statement runs.**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* num是0，所以if语句执行。**'
- en: '***2* You’re declaring a new let variable with the value 1.**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你正在声明一个新的`let`变量，其值为1。**'
- en: '***3* Oops, when you declared a new variable as 1, it was scoped only to the
    if statement so this variable still remains 0.**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 哎呀，当你声明一个新的变量为1时，它只限于if语句的作用域，所以这个变量仍然保持为0。**'
- en: 'To fix this, remove the `let` when setting num to 1:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在将num设置为1时移除`let`：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 4.2**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 4.2**'
- en: '**[Q1:](kindle_split_013_split_002.xhtml#ch04qa4q0a1)**'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_013_split_002.xhtml#ch04qa4q0a1)**'
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code, what will be logged to the console?
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，控制台将输出什么？
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 4.2 answer**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 4.2 答案**'
- en: '**[A1:](kindle_split_013_split_002.xhtml#ch04qa3q1)**'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_013_split_002.xhtml#ch04qa3q1)**'
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nothing would be logged, as the first `console.log` statement will throw an
    error because it attempts to access the variable before it’s declared.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不会输出任何内容，因为第一个`console.log`语句会抛出错误，因为它试图在声明之前访问变量。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.3\. Should I use let instead of var from now on?
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. 我应该从现在开始使用`let`而不是`var`吗？
- en: This is a controversial question. Some developers believe yes, and some think
    no. I happen to be in the former camp.^([[4](kindle_split_013_split_003.xhtml#ch04fn04)])
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有争议的问题。一些开发者认为是的，而另一些则认为不是。我恰好属于前者。[^4](kindle_split_013_split_003.xhtml#ch04fn04)
- en: ⁴
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the case of `var`, however, as we’ll see in the next lesson, `const` is often
    preferred to `let`.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，对于 `var` 来说，正如我们将在下一课中看到的，`const` 通常比 `let` 更受欢迎。
- en: The argument for using `var` is that if a variable is declared at the root of
    a function, a `var` should be used to express that this variable is scoped to
    the entire function. I disagree with this argument. I think this is due to developers
    wanting to continue to think in function scope, and needing to embrace block scope.
    A function is just another block as far as a `let` is concerned, and you certainly
    don’t need a different kind of declaration if the `let` is declared inside of
    an `if` versus a `for`, or a `while` or any other block-level statement, so why
    should a function be special?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 的论点是，如果一个变量在函数的根处声明，应该使用 `var` 来表达这个变量的作用域是整个函数。我不同意这个论点。我认为这是由于开发者想要继续在函数作用域内思考，并且需要接受块作用域。对于
    `let` 来说，函数只是另一个块，你当然不需要在 `if`、`for`、`while` 或任何其他块级语句内部声明 `let` 时使用不同类型的声明，那么为什么函数应该是特殊的呢？
- en: A `let` declared at the beginning of a function is scoped the same way as a
    `var`, but it hoists differently. A `var` will be `undefined` if it’s accessed
    before it’s declared; a `let` throws an exception. I think the exception is the
    better behavior because using a variable before it’s declared leads to tricky
    bugs. I have also never come across a compelling reason why that is ever a good
    idea. This is another reason why I’m in favor of no longer using `var`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数开始处声明的 `let` 与 `var` 的作用域相同，但它提升的方式不同。如果在使用之前访问 `var`，它将是 `undefined`；而 `let`
    会抛出异常。我认为异常是更好的行为，因为在使用声明之前使用变量会导致棘手的错误。我也从未遇到过任何令人信服的理由说明为什么那是一个好主意。这也是我赞成不再使用
    `var` 的另一个原因。
- en: But as I’m making the argument to completely replace `var` with `let`, be wary
    of doing a find and replace of `var`s to `let`s in existing code. Making a blanket
    change to an existing code base can lead to errors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我提出完全用 `let` 替换 `var` 的观点时，请警惕在现有代码中将 `var` 替换为 `let`。对现有代码库进行全面的更改可能会导致错误。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, you learned how to declare variables with `let` and how that
    differs from variables declared with `var`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何使用 `let` 声明变量以及这与使用 `var` 声明变量的区别：
- en: Variables declared with `let` use block scope.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `let` 声明的变量使用块作用域。
- en: Block scope means the variable is only in scope within its containing block.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块作用域意味着变量仅在其包含块中的作用域内。
- en: Variables declared with `var` use function scope.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `var` 声明的变量使用函数作用域。
- en: Function scope means the variable is in scope within its entire containing function.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作用域意味着变量在其整个包含函数中的作用域内。
- en: Unlike `var` variables, `let` variables can’t be referenced before they are
    declared.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `var` 变量不同，`let` 变量在声明之前不能被引用。
- en: 'Let’s see if you got this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否理解了：
- en: '**[Q4.1](kindle_split_050_split_001.xhtml#app01qa1q0a1)**'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q4.1](kindle_split_050_split_001.xhtml#app01qa1q0a1)**'
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code creates a function that generates an array containing a
    range of values. It uses `var` and several IIFEs to prevent access to variables
    outside of the context in which they are used:'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码创建了一个函数，该函数生成一个包含一系列值的数组。它使用 `var` 和几个 IIFE 来防止在它们被使用的上下文之外访问变量：
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An all-encompassing IIFE hides `DEFAULT_START` and `DEFAULT_STEP`.
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全面的 IIFE 隐藏 `DEFAULT_START` 和 `DEFAULT_STEP`。
- en: An IIFE prevents `tmp` from escaping the `if` statement it is used in.
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 IIFE 防止 `tmp` 从它被使用的 `if` 语句中逃逸。
- en: Another IIFE prevents `i` from being accessed outside the `for` loop.
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个 IIFE 防止 `i` 在 `for` 循环外部被访问。
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rewrite this code to use `let` and remove the need for any of the IIFEs:'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将此代码重写为使用 `let` 并消除对任何 IIFEs 的需求：
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Lesson 5\. Declaring constants with const
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5课：使用 `const` 声明常量
- en: After reading [lesson 5](kindle_split_014_split_000.xhtml#ch05), you will
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第5课](kindle_split_014_split_000.xhtml#ch05) 之后，你将
- en: Understand what constants are and how they work.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解常量的概念以及它们是如何工作的。
- en: Know when to use constants.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道何时使用常量。
- en: The keyword `const` stands for *constant*, as in *never changing*. Many programs
    have values that never change, whether by intention or by happenstance. Values
    declared with `const`, referred to as *constants*, have the same characteristics
    as those declared with `let,` which you learned about in the previous chapter,
    with the additional feature of reassignment being forbidden.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `const` 代表 *常量*，即 *永不改变*。许多程序都有永远不会改变的价值，无论是出于故意还是偶然。使用 `const` 声明的值，称为
    *常量*，具有与上一章中你了解的 `let` 声明相同的特征，但额外的一个特性是禁止重新赋值。
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Consider the following `switch` statement, which uses flags to determine what
    type of action is being performed. The uppercasing of `ADD_ITEM` and `DEL_ITEM`
    indicates that these are values that are never expected to change,^([[a](kindle_split_014_split_000.xhtml#ch05sfn01)])
    but what would happen if they did change? How would that affect the behavior of
    the program? How could you author the application to protect from that?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`switch`语句，它使用标志来确定正在执行哪种类型的操作。`ADD_ITEM`和`DEL_ITEM`的上标表示这些值永远不会改变，^([[a](kindle_split_014_split_000.xhtml#ch05sfn01)])但如果它们真的改变了，会发生什么？这会如何影响程序的行为？您如何编写应用程序以防止这种情况？
- en: ^a
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This uppercasing is purely by convention and not a required syntax.
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种大写完全是出于惯例，并不是必需的语法。
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.1\. How constants work
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 常量是如何工作的
- en: 'Constants cannot be reassigned. This means that once you assign the value of
    a constant, any attempt to assign a new value will result in an error:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 常量不能重新赋值。这意味着一旦您为常量赋值，任何尝试赋新值的尝试都将导致错误：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Error**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误**'
- en: Because of the inability to reassign constants with new values, they quickly
    became confused with being immutable. Constants are not immutable. So what’s the
    difference between not being able to be reassigned and being immutable? Assignment
    has to do with variable bindings, binding a name to a piece of data. Immutability
    or mutability is a property that belongs to the actual data that the binding contains.
    All primitives (strings, numbers, and so on) are immutable, whereas objects are
    mutable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法重新赋值常量以获得新值，它们很快就被误解为不可变的。常量不是不可变的。那么，无法重新赋值和不可变之间有什么区别？赋值与变量绑定有关，即将一个名称绑定到数据片段上。不可变或可变是绑定所包含实际数据的属性。所有原始数据（字符串、数字等）都是不可变的，而对象是可变的。
- en: 'Let’s take a look at an example where you assign a mutable object to a constant
    and are free to mutate it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，您将可变对象赋给常量，并且可以自由地修改它：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* When you set foo to bar you’re modifying (mutating) the existing object.**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当您将foo设置为bar时，您正在修改（修改）现有对象。**'
- en: '***2* When you set foo to baz you’re modifying (mutating) the existing object.**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当您将foo设置为baz时，您正在修改（修改）现有对象。**'
- en: '***3* You’re trying to set foo to baz by assigning an entirely new object,
    which is forbidden.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 您试图通过分配一个全新的对象来设置foo为baz，这是不允许的。**'
- en: Figure 5.1\. Mutating the value
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. 修改值
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: Because you created a constant and assigned a mutable value to it, you were
    able to mutate that value. But you could not assign a new value to the constant;
    the only way you were able to change the value was by modifying the value itself,
    as shown in [figure 5.1](kindle_split_014_split_001.xhtml#ch05fig01).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您创建了一个常量并将其赋值为可变值，所以您能够修改该值。但是您不能将新值赋给常量；您能够改变值的唯一方法是通过修改该值本身，如[图 5.1](kindle_split_014_split_001.xhtml#ch05fig01)所示。
- en: If you assign an immutable value like a number to a constant, then the constant
    becomes immutable because it contains a value that can’t be modified and the constant
    can’t be reassigned, so they become frozen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将不可变值（如数字）赋给常量，那么常量就变得不可变，因为它包含一个无法修改的值，并且常量不能重新赋值，因此它们变得固定。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 5.1**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 5.1**'
- en: '**[Q1:](kindle_split_014_split_001.xhtml#ch05qa2q0a1)**'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_014_split_001.xhtml#ch05qa2q0a1)**'
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will happen when the following code is executed?
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当执行以下代码时会发生什么？
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 5.1 answer**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 5.1 答案**'
- en: '**[A1:](kindle_split_014_split_001.xhtml#ch05qa1q1)**'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_014_split_001.xhtml#ch05qa1q1)**'
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because the increment operator assigns a new value to the variable it operates
    on, this code will throw an error because constants cannot be reassigned.
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为增量运算符会为它操作的变量分配新值，所以这段代码会抛出错误，因为常量不能重新赋值。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The claim that primitives, like strings and numbers, are immutable may be a
    tough pill to swallow if you aren’t already familiar with it. You may be thinking
    something like “I use primitives and change their value all the time!” The fact
    is that with the ability to reassign variables with new values, primitives are
    harder to spot. Consider this code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对原始数据（如字符串和数字）是不可变的这一说法不熟悉，可能会觉得难以接受。您可能会想：“我经常使用原始数据并改变它们的值！”事实是，由于能够重新分配变量以获得新值，原始数据更难被发现。考虑以下代码：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Hello**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Hello**'
- en: '***2* Hello, World!**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Hello, World!**'
- en: In this example it appears that you’re changing the string contained in variable
    `b`, but in fact you’re creating a new string and reassigning that new string
    to `b`. You can confirm this because, before updating `b`, it contains the same
    value as `a`, but afterwards `a` remains unchanged. This is because `a` is still
    pointing to the same string but `b` was reassigned a new string. This is why you
    can’t use the `+=` operator with constants. See [figure 5.2](kindle_split_014_split_001.xhtml#ch05fig02).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，看起来你正在更改变量 `b` 中包含的字符串，但实际上你正在创建一个新的字符串并将这个新字符串重新赋值给 `b`。你可以通过确认，在更新
    `b` 之前，它包含与 `a` 相同的值，但之后 `a` 保持不变。这是因为 `a` 仍然指向同一个字符串，但 `b` 被重新赋值了一个新的字符串。这就是为什么你不能使用
    `+=` 运算符与常量一起使用。参见[图 5.2](kindle_split_014_split_001.xhtml#ch05fig02)。
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 5.2**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 5.2**'
- en: '**[Q1:](kindle_split_014_split_001.xhtml#ch05qa4q0a1)**'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_014_split_001.xhtml#ch05qa4q0a1)**'
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will happen when executing the following code?
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下代码会发生什么？
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 5.2 answer**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 5.2 答案**'
- en: '**[A1:](kindle_split_014_split_001.xhtml#ch05qa3q1)**'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_014_split_001.xhtml#ch05qa3q1)**'
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You may think that `a.concat` will throw an error when `a` is a constant, but
    remember the `concat` method on strings does’t modify the existing string or reassign
    the variable containing it: it simply returns a new string. Because of this, the
    statement is valid and `b` becomes the string “Hello, World!”'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会认为当 `a` 是一个常量时，`a.concat` 会抛出错误，但记住字符串上的 `concat` 方法不会修改现有的字符串或重新赋值包含它的变量：它只是返回一个新的字符串。正因为如此，这个语句是有效的，`b`
    变成了字符串“Hello, World!”
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 5.2\. Demonstrating that primitives are immutable
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 展示原始数据不可变
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: 5.2\. When to use constants
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 何时使用常量
- en: 'The obvious place to use constants is when creating flags that are more about
    a unique identifier than the actual value they contain. Like this priming exercise,
    for example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量的明显地方是在创建比包含的实际值更关注唯一标识符的标志时。例如，像这样的预热练习：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This ensures that the action flags `ADD_ITEM` and `DEL_ITEM` can never be accidentally
    changed. You may stop there, but if you think about it, should the `items` array
    ever be reassigned? Probably not, so you can make that a const as well:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了操作标志 `ADD_ITEM` 和 `DEL_ITEM` 永远不会被意外更改。你可以在那里停止，但如果你想一下，`items` 数组是否应该被重新赋值？可能不会，所以你也可以将其设置为常量：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But what if you later decide that you need an action to empty the list? Your
    instinct may be to reassign items to a new empty array, but that can’t be done
    using a constant:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你后来决定你需要一个清空列表的操作，你的直觉可能是将 `items` 赋值给一个新的空数组，但使用常量是无法做到这一点的：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Error**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误**'
- en: 'You can still empty the array, though; you just need to figure out a way to
    modify the actual value without assigning a new value. In this case you can again
    use `splice` for such a task:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你仍然可以清空数组；你只需要找出一种方法来修改实际值而不需要重新赋值。在这种情况下，你还可以再次使用 `splice` 来完成这项任务：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OK, so your complete code now looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你的完整代码看起来是这样的：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how you declared every single value with a `const`? This won’t be an
    unusual circumstance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何使用 `const` 声明每个值？这种情况不会很罕见。
- en: Protecting a binding from reassignment isn’t the only reason to use a constant.
    Because constants are never reassigned, certain optimizations can be made by the
    JavaScript engine to improve performance. Because of this, it makes sense to use
    `const` anytime a variable never needs to be reassigned, and fall back to `let`
    when they do.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 保护绑定不被重新赋值不是使用常量的唯一原因。因为常量不会被重新赋值，JavaScript 引擎可以做出某些优化来提高性能。正因为如此，在变量不需要重新赋值时使用
    `const`，而在需要时回退到 `let` 是有意义的。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 5.3**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 5.3**'
- en: '**[Q1:](kindle_split_014_split_002.xhtml#ch05qa6q0a1)**'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_014_split_002.xhtml#ch05qa6q0a1)**'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will happen when executing the following code?
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行以下代码会发生什么？
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 5.3 answer**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 5.3 答案**'
- en: '**[A1:](kindle_split_014_split_002.xhtml#ch05qa5q1)**'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_014_split_002.xhtml#ch05qa5q1)**'
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may think that because the value is originally stored in a constant before
    being returned from the function, it would give errors when reassigned outside
    of the function. But remember that constants have to do with value bindings, not
    the values inside those bindings. The function merely returns the value, not the
    binding. So the new `let` binding is safe to reassign.
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会认为，因为值最初是在函数返回之前存储在常量中，所以在函数外部重新分配时会出错。但请记住，常量与值绑定有关，而不是这些绑定内的值。函数只是返回值，而不是绑定。所以新的`let`绑定是安全重新分配的。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, you learned how to declare variables with `const` and how that
    differs from variables declared with `var` or `let`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何使用`const`声明变量以及它与使用`var`或`let`声明的变量有何不同。
- en: Constants are variables that can’t be reassigned.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量是不能重新分配的变量。
- en: Constants are not immutable.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量不是不可变的。
- en: Constants have the same scoping rules as `let`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量与`let`具有相同的作用域规则。
- en: 'Let’s see if you got this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个：
- en: '**[Q5.1](kindle_split_050_split_002.xhtml#app01qa2q0a1)**'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q5.1](kindle_split_050_split_002.xhtml#app01qa2q0a1)**'
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify your answer from the [lesson 4](kindle_split_013_split_000.xhtml#ch04)
    exercise to use `const` where possible.
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将你在[第4课](kindle_split_013_split_000.xhtml#ch04)练习中的答案修改为尽可能使用`const`。
- en: Lesson 6\. New string methods
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6课。新的字符串方法
- en: After reading [lesson 6](kindle_split_015_split_000.xhtml#ch06), you will
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第6课](kindle_split_015_split_000.xhtml#ch06)之后，你将
- en: Know how to use `String.prototype.startsWith`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用`String.prototype.startsWith`
- en: Know how to use `String.prototype.endsWith`
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用`String.prototype.endsWith`
- en: Know how to use `String.prototype.includes`
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用`String.prototype.includes`
- en: Know how to use `String.prototype.repeat`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用`String.prototype.repeat`
- en: Know how to use `String.prototype.padStart`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用`String.prototype.padStart`
- en: Know how to use `String.prototype.padEnd`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何使用`String.prototype.padEnd`
- en: None of these methods would be extremely difficult to implement, but they are
    tasks that are used enough to warrant inclusion in the standard library.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中没有一个特别难实现，但它们是足够常用的任务，值得包含在标准库中。
- en: '|  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: 'Let’s say you’re writing a function that tells the current time. Using an instance
    of the `Date` object, you can get the current hour and minutes with the `getHours`
    and `getMinutes` methods, respectively:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个函数，用来显示当前时间。使用`Date`对象的实例，你可以分别通过`getHours`和`getMinutes`方法获取当前的小时和分钟：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But if the current time were 5:06 a.m., this function would return the string
    `5:6`. How can you fix the function so that the minutes side is always two digits?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果当前时间是早上5:06，这个函数将返回字符串`5:6`。你如何修改这个函数，使得分钟部分总是两位数？
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1\. Searching strings
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1. 搜索字符串
- en: 'Imagine you’re loading products from a database. The product data comes from
    several different manufacturers and isn’t normalized. Because of this, some of
    the prices are in the format 499.99 without a leading $, whereas others are in
    the format $37.95 with a leading $. When you display the price on the web page,
    you can’t simply prefix all prices with a $ because that would make some have
    a double dollar sign like this: $$37.95.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在从数据库中加载产品。产品数据来自几个不同的制造商，并且没有规范化。因此，一些价格以没有前导$的499.99的格式出现，而其他价格以带有前导$的37.95的格式出现。当你需要在网页上显示价格时，你不能简单地在所有价格前加上$，因为这会使一些价格出现双美元符号，如下所示：$$37.95。
- en: 'You could easily tell if the first character is a $ like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地判断第一个字符是否是一个$，如下所示：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But what if you need to check the first three characters? Imagine you’re showing
    a list of phone numbers. They all have the format `XXX-XXX-XXXX` and you need
    to determine which ones are in the current user’s area code. You may do something
    like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你需要检查前三个字符呢？想象一下你正在显示一个电话号码列表。它们都有`XXX-XXX-XXXX`的格式，你需要确定哪些是在当前用户的区号中。你可能做如下操作：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Both of these are doing the same thing, aren’t they—checking if a given string
    starts with a given value? So why do they go about it in different ways? The answer
    is because, in the former scenario, you were checking against a single character,
    and in the latter, against a range of characters. Neither of these are doing a
    great job of making it easy to understand what you’re checking; hence the need
    for a comment explaining what each does. With ES6, you can now solve both these
    problems in the same *self documenting* way:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是做同样的事情，不是吗——检查给定的字符串是否以给定的值开头？那么为什么它们采取不同的方式呢？答案是，在前一种情况下，你是在检查单个字符，而在后一种情况下，是在检查字符范围。这两种方法都没有很好地使你容易理解你在检查什么；因此需要注释来解释每个方法的作用。使用
    ES6，你现在可以以相同的方式 *自文档化* 解决这两个问题：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Not only are these now more consistent, but isn’t it much easier to understand
    exactly what they’re doing at a glance?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这些现在更一致，而且不是一眼就能清楚地理解它们在做什么吗？
- en: 'With the addition of the `includes`, `startsWith`, and `endsWith` methods,
    searching for strings within strings has gotten much simpler. `startsWith` checks
    if a string starts with a specified value, and `endsWith` checks if the string
    ends with the value. `includes` checks the entire string to see if it contains
    the specified value:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `includes`、`startsWith` 和 `endsWith` 方法，在字符串中搜索字符串变得更加简单。`startsWith` 检查字符串是否以指定的值开头，而
    `endsWith` 检查字符串是否以该值结尾。`includes` 检查整个字符串以查看是否包含指定的值：
- en: '[PRE34]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* true**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正确**'
- en: '***2* false**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 错误**'
- en: '***3* false**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 错误**'
- en: '***4* true**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 正确**'
- en: '***5* true**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 正确**'
- en: 'All of these methods are case-sensitive. You can always lowercase the string
    before performing the search, though:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都是大小写敏感的。在进行搜索之前，你总是可以将字符串转换为小写：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* false**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误**'
- en: '***2* false**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 错误**'
- en: '***3* true**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 正确**'
- en: 'All of these methods also accept a second parameter to specify the position
    in the string to start searching:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法也接受第二个参数来指定字符串中开始搜索的位置：
- en: '[PRE36]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* true**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正确**'
- en: '***2* true**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 正确**'
- en: '***3* true**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 正确**'
- en: '***4* false**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 错误**'
- en: If your needs are more complex than what’s achievable with these methods, you
    can still fall back to using regular expressions for more custom string searching.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的需求比这些方法能实现的更复杂，你仍然可以回退到使用正则表达式进行更自定义的字符串搜索。
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.1**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查6.1**'
- en: '**[Q1:](kindle_split_015_split_001.xhtml#ch06qa2q0a1)**'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_015_split_001.xhtml#ch06qa2q0a1)**'
- en: ''
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume you have an array of objects representing weather data. Each object has
    an `icon` property that specifies the name of an icon that represents the weather
    condition. The icon name ends with night if the icon being used is the nighttime
    version of the icon. Write a filter that grabs all of the objects with nighttime
    icons using one of the three methods we covered.
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你有一个表示天气数据的对象的数组。每个对象都有一个 `icon` 属性，该属性指定了代表天气条件的图标名称。如果使用的图标是图标的夜间版本，则图标名称以
    night 结尾。编写一个过滤器，使用我们介绍的三种方法之一，获取所有具有夜间图标的对象。
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.1 answer**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.1 答案**'
- en: '**[A1:](kindle_split_015_split_001.xhtml#ch06qa1q1)**'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_015_split_001.xhtml#ch06qa1q1)**'
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.2\. Padding strings
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2. 字符串填充
- en: Padding a string means specifying how long you want the string to be, and filling
    the string with a *pad* character until it is that length. For example, in the
    priming exercise, you wanted the minutes to always be two characters long. Sometimes
    it was (such as 36) but other times it wasn’t (such as 5). By padding the string
    to a length of 2 with the pad character being `0`, 36 would be unchanged because
    it is already two chars while 5 would become either 05 or 50 depending on whether
    you were padding left or right.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串填充意味着指定你想要字符串有多长，然后用填充字符填充字符串直到达到该长度。例如，在预训练练习中，你希望分钟数总是两个字符长。有时它是（例如36），但有时不是（例如5）。通过使用填充字符
    `0` 将字符串填充到长度为2，36将保持不变，因为它已经是两个字符，而5将变成05或50，具体取决于你是向左还是向右填充。
- en: 'Let’s say you needed a function that could take an IP address written in decimal
    (base 10) and convert it to binary (base 2). You may end up writing a function
    that looks like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个函数，可以将以十进制（基数10）写成的IP地址转换为二进制（基数2）。你可能最终会编写一个看起来像这样的函数：
- en: '[PRE38]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: But this function wouldn’t work for any number less than 128 because its binary
    representation would be less than eight digits.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个函数对小于128的任何数字都不会起作用，因为它的二进制表示将少于八位数字。
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* “11000000.10101000.10.1”**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “11000000.10101000.10.1”**'
- en: To fix this, you need to pad each octet with zeros until each one is eight digits,
    as shown in the example at the top of the next page. To accomplish this, you can
    use a new feature introduced in ES2015, `String.prototype.repeat`. We could also
    use `padStart`, but that’s a bit more flexible as you’ll see in a minute, and
    `repeat` is also useful to know.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要将每个八位字节用零填充，直到每个字节都是八位，如下一页顶部的示例所示。为了实现这一点，你可以使用 ES2015 中引入的新特性，`String.prototype.repeat`。我们也可以使用
    `padStart`，但它更加灵活，你将在下一分钟看到，而且 `repeat` 也是值得了解的。
- en: '[PRE40]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* “11000000.10101000.00000010.00000001”**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “11000000.10101000.00000010.00000001”**'
- en: 'This works because the `repeat` function repeats the function it’s invoked
    for the number of times specified in the argument:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `repeat` 函数重复调用的函数，其重复次数由参数中指定的次数决定：
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* XXXX (X is repeated 4 times)**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* XXXX (X 重复 4 次)**'
- en: 'If the number specified isn’t a whole number, it will first be floored (rounded
    down, not rounded up):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的数字不是一个整数，它将首先被向下取整（向下舍入，而不是向上舍入）：
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* XXXX**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* XXXX**'
- en: 'This works on strings of any length as well:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这对任何长度的字符串都适用：
- en: '[PRE43]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* foofoofoo**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* foofoofoo**'
- en: Using `String.prototype.repeat` works for our binary example. But what if you
    wanted to pad with a string that’s more than one character? That would be trickier
    to achieve with just the `repeat` function, but you can easily achieve it with
    `String.prototype.padStart` and `String.prototype.padEnd`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `String.prototype.repeat` 对我们的二进制示例有效。但如果你想要用超过一个字符的字符串进行填充，仅使用 `repeat`
    函数将会更难实现，但你可以很容易地使用 `String.prototype.padStart` 和 `String.prototype.padEnd` 来实现。
- en: 'The `padStart` and `padEnd` methods take two arguments: the max length of the
    returned string, and the filler string, as shown in [figure 6.1](kindle_split_015_split_002.xhtml#ch06fig01).
    The filler string defaults to a space `" "` character:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`padStart` 和 `padEnd` 方法接受两个参数：返回字符串的最大长度和填充字符串，如图 6.1 所示 [figure 6.1](kindle_split_015_split_002.xhtml#ch06fig01)。填充字符串默认为空格
    `" "` 字符：'
- en: '[PRE44]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* “ abc”**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “ abc”**'
- en: '***2* “abc ”**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “abc ”**'
- en: '***3* “xxxabc”**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* “xxxabc”**'
- en: '***4* “abcxxx”**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* “abcxxx”**'
- en: '***5* “xyzabc”**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* “xyzabc”**'
- en: '***6* “abcxyz”**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* “abcxyz”**'
- en: Figure 6.1\. Dissecting the padStart function
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 拆解 padStart 函数
- en: '![](Images/06fig01.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig01.jpg)'
- en: 'The max length property specifies the maximum length of the string after the
    filler has been repeated. If the filler is multiple chars and can’t evenly be
    added, it will be truncated:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最大长度属性指定了填充重复后的字符串的最大长度。如果填充是多个字符并且不能均匀添加，它将被截断：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* “12312abc”**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “12312abc”**'
- en: '***2* “12abc”**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “12abc”**'
- en: 'If the max length is less than the original string’s length, the original string
    won’t be truncated but will be returned without any padding applied:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最大长度小于原始字符串的长度，原始字符串不会被截断，而是返回没有任何填充应用的原字符串：
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* “abcdef”**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “abcdef”**'
- en: 'Using this, your `binaryIP` function could then be rewritten like so:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，你的 `binaryIP` 函数可以重写如下：
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* “11000000.10101000.00000010.00000001”**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “11000000.10101000.00000010.00000001”**'
- en: That’s a pretty concise implementation that’s easy to read and understand. Using
    pure ES5 code would have been much more verbose to achieve the same thing. Of
    course, you could have used a third-party string pad function or written your
    own, but `String.prototype.padStart` and `String.prototype.padEnd` eliminated
    that need.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当简洁的实现，易于阅读和理解。使用纯 ES5 代码来实现相同的功能将会非常冗长。当然，你也可以使用第三方字符串填充函数或自己编写一个，但 `String.prototype.padStart`
    和 `String.prototype.padEnd` 消除了这种需求。
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.2**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.2**'
- en: '**[Q1:](kindle_split_015_split_002.xhtml#ch06qa4q0a1)**'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_015_split_002.xhtml#ch06qa4q0a1)**'
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function using `repeat` that will repeat any string to exactly 50 chars,
    truncating any excess.
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个使用 `repeat` 的函数，将任何字符串重复到正好 50 个字符，截断任何多余的字符。
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.2 answer**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.2 答案**'
- en: '**[A1:](kindle_split_015_split_002.xhtml#ch06qa3q1)**'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_015_split_002.xhtml#ch06qa3q1)**'
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, the object was to teach you the most useful new methods being
    added to strings.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，目的是教给你即将添加到字符串中的最有用的新方法。
- en: '`String.prototype.startsWith` checks if a string starts with a value.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.startsWith` 检查一个字符串是否以一个值开头。'
- en: '`String.prototype.endsWith` checks if a string ends with a value.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.endsWith` 检查一个字符串是否以一个值结尾。'
- en: '`String.prototype.includes` checks if a string includes a value.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.includes` 检查一个字符串是否包含一个值。'
- en: '`String.prototype.repeat` repeats a string a given number of times.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.repeat` 重复一个字符串指定次数。'
- en: '`String.prototype.padStart` pads the start of a string.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.padStart` 填充字符串的开始部分。'
- en: '`String.prototype.padEnd` pads the end of a string.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.padEnd` 用于填充字符串的末尾。'
- en: 'Let’s see if you got this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q6.1](kindle_split_050_split_003.xhtml#app01qa3q0a1)**'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6.1](kindle_split_050_split_003.xhtml#app01qa3q0a1)**'
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function that will take an email address and mask all of the characters
    up to the **@**. For example, the email address christina@example.com would be
    masked to *********@example.com.
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数将接受一个电子邮件地址并屏蔽所有直到**@**的字符。例如，电子邮件地址christina@example.com将被屏蔽为*********@example.com。
- en: Lesson 7\. Template literals
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7课\. 模板字符串
- en: After reading [lesson 7](kindle_split_016_split_000.xhtml#ch07), you will
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第7课](kindle_split_016_split_000.xhtml#ch07)之后，你将
- en: Know how to achieve string interpolation with template literals
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用模板字符串实现字符串插值
- en: Understand how to use multiline strings with template literals
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用模板字符串的多行字符串
- en: Know how to make reusable templates with template literals
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用模板字符串创建可重用的模板
- en: Understand how tagged template literals can add custom processing to template
    literals
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用标签化模板字符串为模板字符串添加自定义处理
- en: 'In JavaScript, one of my biggest annoyances has always been the lack of support
    for multiline strings. Having to break each line into a separate string and glue
    them all together is a tedious process. With the addition of template literals,
    that pain is gone, along with some others. *Template literals* introduce multiline
    strings to JavaScript, as well as interpolation and tagging. Don’t worry if you’re
    unsure what these terms mean: I’ll explain each one.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我最大的烦恼之一就是缺乏对多行字符串的支持。必须将每一行拆分为单独的字符串并将它们全部粘合在一起是一个繁琐的过程。随着模板字符串的添加，这种痛苦消失了，还有一些其他的好处。*模板字符串*将多行字符串引入JavaScript，以及插值和标签化。如果你不确定这些术语的含义，不要担心：我会解释每一个。
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: Study the following function, which takes a product object and returns the appropriate
    HTML to represent the product. Currently it’s only displaying a photo and description
    of the product, and it’s already difficult to deduce what’s going on due to the
    many strings being glued together to make up for the lack of support for multi-line
    strings and interpolation. A real product would probably need to show a title,
    a price, and other details, making it even harder to deduce. As the HTML requirements
    for the product become more and more complex, what steps would you take to keep
    the code readable?
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 研究以下函数，该函数接受一个产品对象并返回表示产品的适当HTML。目前它只显示产品的照片和描述，由于许多字符串被粘合在一起以弥补对多行字符串和插值的支持不足，因此很难理解正在发生的事情。一个真实的产品可能需要显示标题、价格和其他细节，这使得理解更加困难。随着产品HTML要求的日益复杂，你会采取哪些步骤来保持代码的可读性？
- en: '[PRE49]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.1\. What are template literals?
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 模板字符串是什么？
- en: 'A template literal is a new literal syntax for creating strings. It uses back-ticks
    (**`**) for demarcation instead of quotes (**’** or **”**) like string literals
    do, and supports new features and functionality. But template literals evaluate
    to a string just like string literals do:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串是创建字符串的新字面量语法。它使用反引号（**`**）作为分隔符，而不是像字符串字面量那样使用引号（**’**或**”**），并支持新的特性和功能。但模板字符串的评估结果与字符串字面量一样是字符串：
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Creating a string using a template literal**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用模板字符串创建字符串**'
- en: '***2* true**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 真实**'
- en: 'The difference is that template literals support three new features that regular
    string literals do not: *interpolation*, *multiline*, and *tagging*. Let’s define
    each of those terms.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于模板字符串支持三个常规字符串字面量不支持的新特性：*插值*、*多行*和*标签化*。让我们定义这些术语。
- en: '*String interpolation*—This is the concept of placing a dynamic value into
    the creation of a string. Many other languages support this, but up until now,
    JavaScript could only put dynamic values into larger strings by concatenation:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串插值*—这是将动态值放入字符串创建过程中的概念。许多其他语言支持这一功能，但到目前为止，JavaScript只能通过连接将动态值放入较长的字符串中：'
- en: '[PRE51]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Multiline strings*—This is not the concept of creating a string that is multiline.
    JavaScript has always been able to do that (for example, `"Line One\nLine Two"`).
    This is the concept of the literal itself spanning multiple lines. Regular strings
    in JavaScript must be defined in a single line, meaning the opening quote and
    the ending quote must be on the same line. With template literals, this is not
    the case:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*多行字符串*——这并不是创建多行字符串的概念。JavaScript 一直能够做到这一点（例如，`"Line One\nLine Two"`）。这是指字面量本身跨越多行。JavaScript
    中的常规字符串必须在单行中定义，这意味着开引号和结束引号必须在同一行上。使用模板字面量，情况并非如此：'
- en: '[PRE52]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Tagging template literals*—This is a much more advanced use. Remember how
    template literals can have values interpolated into them? A tagged template literal
    is a template literal that’s *tagged* with a function. The function is given all
    the raw string parts as well as the interpolated values separately so it can do
    custom preprocessing of the string. It can return an entirely different string
    or a custom value that isn’t even a string. This is especially useful if you want
    to do some sort of preprocessing on the interpolated values before merging them
    into the final value. For example, you could have a tagging function that converts
    the template literal into DOM nodes but escapes the interpolated values to protect
    from HTML injection. You could also prevent SQL injection by treating the string
    parts as safe and the interpolated values as potentially dangerous:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*标记模板字面量*——这是一个更高级的使用。记得模板字面量可以插入值吗？标记模板字面量是一个带有函数标记的模板字面量。该函数会获得所有原始字符串部分以及单独的插值值，以便它可以对字符串进行自定义预处理。它可以返回一个完全不同的字符串或一个甚至不是字符串的定制值。如果你想在合并到最终值之前对插值值进行某种预处理，这特别有用。例如，你可以有一个将模板字面量转换为
    DOM 节点的标记函数，同时转义插值值以防止 HTML 注入。你也可以通过将字符串部分视为安全内容，将插值值视为潜在危险内容来防止 SQL 注入：'
- en: '[PRE53]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So now we have an overview; let’s look at each of these in more detail, starting
    with interpolation.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个概述；让我们更详细地看看这些内容，从插值开始。
- en: 7.1.1\. String interpolation with template literals
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 使用模板字面量的字符串插值
- en: 'The syntax for interpolating value into template literals is to wrap the value
    to be interpolated with curly braces `{` and `}` and to prefix the opening curly
    brace with the dollar sign `$`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 将值插值到模板字面量的语法是将要插值的值用大括号 `{` 和 `}` 括起来，并在开大括号前加上美元符号 `$`：
- en: '[PRE54]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* “fa-check-square fa”**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “fa-check-square fa”**'
- en: This takes the value from the `icon` variable and injects it into the template
    string. You can visualize what’s happening in [figure 7.1](kindle_split_016_split_001.xhtml#ch07fig01).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从 `icon` 变量中获取值并将其注入到模板字符串中。你可以在[图 7.1](kindle_split_016_split_001.xhtml#ch07fig01)中可视化这个过程。
- en: Figure 7.1\. The value of the icon variable is interpolated into the string
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 图标变量的值被插值到字符串中
- en: '![](Images/07fig01.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01.jpg)'
- en: This function generates the Font Awesome ([http://fontawesome.io/icon/check-square/](http://fontawesome.io/icon/check-square/))
    CSS class needed for a given icon. The more interpolation required, the more obvious
    it becomes how nice a feature this is, as shown in the code examples on the following
    page.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数生成给定图标所需的 Font Awesome ([http://fontawesome.io/icon/check-square/](http://fontawesome.io/icon/check-square/))
    CSS 类。所需的插值越多，这种功能的好处就越明显，如下页的代码示例所示。
- en: '[PRE55]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* “The quick brown fox jumps”**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “The quick brown fox jumps”**'
- en: In each example, both these functions are equivalent in functionality. I don’t
    think anyone would make the argument in either case, though, that variant B is
    preferred.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个示例中，这两个函数在功能上是等效的。不过，我认为在两种情况下，没有人会认为变体 B 更受欢迎。
- en: 'Note that you can escape the interpolation using the normal escape character:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以使用正常的转义字符来转义插值：
- en: '[PRE56]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* “My eyes are hazel”**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “My eyes are hazel”**'
- en: '***2* “My eyes are ${color}”**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “My eyes are ${color}”**'
- en: 'But if you are just adding a dollar sign that isn’t followed by an opening
    brace then there’s no need to escape anything:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你只是添加一个没有后跟开括号的美元符号，那么就没有必要转义任何内容：
- en: '[PRE57]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* “Only $5.00”**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “Only $5.00”**'
- en: 'Any value you interpolate that isn’t already a string will be converted to
    a string, and its string representation will be used:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你插值的值如果不是字符串，都会被转换为字符串，并使用其字符串表示形式：
- en: '[PRE58]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* “foo: [object Object]”**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “foo: [object Object]”**'
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 7.1**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 7.1**'
- en: '**[Q1:](kindle_split_016_split_001.xhtml#ch07qa2q0a1)**'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_016_split_001.xhtml#ch07qa2q0a1)**'
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the template literal assigned to the phrase variable evaluate to?
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分配给短语变量的模板字面量会评估成什么？
- en: ''
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 7.1 answer**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.1 答案**'
- en: '**[A1:](kindle_split_016_split_001.xhtml#ch07qa1q1)**'
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_016_split_001.xhtml#ch07qa1q1)**'
- en: ''
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a template literal is interpolated into another template literal, the inner
    literal will be evaluated to a string and then its string value will be interpolated
    into the outer template literal. So the final value here would be `the big yellow
    banana`.
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果模板字面量被插值到另一个模板字面量中，则内部字面量将被评估为字符串，然后其字符串值将被插值到外部模板字面量中。因此，这里的最终值将是`the big
    yellow banana`。
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.1.2\. Multiline strings with template literals
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 使用模板字面量的多行字符串
- en: 'Unlike string literals, an unterminated template literal will continue to the
    following line until terminated:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串字面量不同，未终止的模板字面量将继续到下一行，直到终止：
- en: '[PRE60]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* “Hello,\nWorld”**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “Hello,\nWorld”**'
- en: 'One thing to definitely keep in mind is that multiline template literals preserve
    all of their white space characters:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要记住的一件事是，多行模板字面量保留所有空白字符：
- en: '[PRE61]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* “Welcome back, JD.\n You have 0 items in your cart.”**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “Welcome back, JD.\n You have 0 items in your cart.”**'
- en: 'You can now use a template literal to solve the priming exercise:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用模板字面量来解决这个前导练习：
- en: '[PRE62]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|  |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 7.2**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查7.2**'
- en: '**[Q1:](kindle_split_016_split_001.xhtml#ch07qa4q0a1)**'
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_016_split_001.xhtml#ch07qa4q0a1)**'
- en: ''
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are the following two functions equivalent?
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下两个函数是否等价？
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 7.2 answer**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.2 答案**'
- en: '**[A1:](kindle_split_016_split_001.xhtml#ch07qa3q1)**'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_016_split_001.xhtml#ch07qa3q1)**'
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No, they’re close, but because the template literal preserves white space, it
    will include the new lines and spaces, which might slightly affect the layout
    when rendered to the page.
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不，它们很接近，但由于模板字面量保留了空白字符，它将包括换行符和空格，这可能会在渲染到页面时稍微影响布局。
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.2\. Template literals are not reusable templates
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 模板字面量不是可重用模板
- en: 'I think the name *template literal* is a bit misleading because it creates
    strings, not templates. When developers think of templates, they usually think
    of something that’s reusable. Template literals aren’t reusable templates, but
    rather one-time templates that get evaluated and turned into a string all at once,
    so there’s no reusability to them. If you aren’t familiar with using other JavaScript
    templates, like those from Underscore, Lodash, Handlebars, or several others,
    then you may not be too confused. If you are, on the other hand, coming from a
    template library like one of the ones I listed, let’s explore the difference:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为“模板字面量”这个名字有点误导，因为它创建的是字符串，而不是模板。当开发者想到模板时，他们通常想到的是可重用的东西。模板字面量不是可重用模板，而是一次性模板，它们会一次性评估并转换为字符串，因此没有可重用性。如果您不熟悉使用其他JavaScript模板，如Underscore、Lodash、Handlebars或几个其他模板，那么您可能不会太困惑。如果您是从我列出的模板库之一开始使用的，那么让我们来探讨一下差异：
- en: '[PRE64]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Hello, Talan**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Hello, Talan**'
- en: '***2* Hello, Jonathon**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Hello, Jonathon**'
- en: '***3* Hello, Talan**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Hello, Talan**'
- en: '***4* Uncaught TypeError: greetB is not a function**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 未捕获的类型错误：greetB不是一个函数**'
- en: When you create a template from a library like Underscore, you specify placeholders
    for values and you get back a function that you can invoke multiple times with
    different values to be interpolated. A template literal, on the other hand, interpolates
    the values at the time it’s created, so there’s no re-evaluating it with new values.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Underscore等库创建模板时，您指定值占位符，并返回一个函数，您可以多次调用该函数，用不同的值进行插值。另一方面，模板字面量在创建时插值值，因此不会用新值重新评估它。
- en: 'You can, however, create a reusable template by wrapping the template literal
    in a function:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以通过将模板字面量包裹在一个函数中来创建一个可重用模板：
- en: '[PRE65]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 7.3**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查7.3**'
- en: '**[Q1:](kindle_split_016_split_002.xhtml#ch07qa6q0a1)**'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_016_split_002.xhtml#ch07qa6q0a1)**'
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following code, what would be logged to the console?
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码中，会在控制台输出什么？
- en: ''
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 7.3 answer**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.3 答案**'
- en: '**[A1:](kindle_split_016_split_002.xhtml#ch07qa5q1)**'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_016_split_002.xhtml#ch07qa5q1)**'
- en: ''
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hello, JD
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Hello, JD
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3\. Custom processing with tagged template literals
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 使用标记模板字面量进行自定义处理
- en: Imagine you’re in charge of a growing ecommerce website. Originally all your
    users were English speakers but now you need to support multiple languages. Wouldn’t
    it be nice if there were a way to mark certain strings that needed to be internationalized?
    What if you could mark a string by prefixing it with i18n^([[1](kindle_split_016_split_003.xhtml#ch07fn01)])
    and have it automatically translated for a user’s locale?
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你负责一个不断增长的电子商务网站。最初，所有用户都是英语使用者，但现在你需要支持多种语言。如果有一种方法可以标记需要国际化的字符串，那岂不是很好？如果你可以在字符串前加上
    i18n^([[1](kindle_split_016_split_003.xhtml#ch07fn01)]) 并自动为用户的区域设置翻译，那岂不是更好？
- en: ¹
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: i18n is a common shortening of *internationalization*, meaning i + 18 letters
    + n.
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: i18n 是 *国际化* 的常见缩写，意味着 i + 18 个字母 + n。
- en: '[PRE67]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A tagged template literal is a template literal that’s tagged with a function
    by prefixing the template literal with the name of that function. The basic syntax
    is as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 标记模板字面量是一个带有函数标记的模板字面量，通过在模板字面量前加上该函数的名称来实现。其基本语法如下：
- en: '[PRE68]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: By doing this, you’re tagging `my string` with the function `myTag`. The `myTag`
    function will be invoked and given the template as arguments. If the template
    has any interpolated values, they’re passed as separate arguments. The function
    is then responsible for performing some type of processing of the template and
    returning a new value.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你正在用函数 `myTag` 给 `my string` 打上标签。`myTag` 函数将被调用，并作为参数传递模板。如果模板有任何插值值，它们将作为单独的参数传递。然后该函数负责对模板进行某种类型的处理，并返回一个新值。
- en: 'There is currently only one built-in tagging function, `String.raw`, which
    processes a template without interpreting special characters:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只有一个内置的标记函数，`String.raw`，它处理模板而不解释特殊字符：
- en: '[PRE69]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* “my string”**'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “my string”**'
- en: '***2* “my\tstring”**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “my\tstring”**'
- en: This may be the only built-in tagging function, but you can use ones by library
    authors, or write your own!
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能只是内置的标记函数，但你也可以使用库作者提供的，或者自己编写！
- en: 'When the template literal is tagged with a function, it will be broken apart
    into the string parts and the interpolated values. The tagged function will be
    given these values as separate arguments. The first argument will be an array
    of all the string parts; then for every interpolated value, it will be given as
    an additional argument to the function:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板字面量被标记为函数时，它将被分解为字符串部分和插值值。标记函数将把这些值作为单独的参数传递。第一个参数将是一个包含所有字符串部分的数组；然后对于每个插值值，它将作为函数的附加参数传递：
- en: '[PRE70]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Fortunately, you don’t ever need to write these arguments out explicitly.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你永远不需要明确写出这些参数。
- en: 'To get a better understanding of how these pieces are broken apart and passed,
    write a function that simply logs the parts:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些部分是如何分解和传递的，编写一个简单的函数来记录这些部分：
- en: '[PRE71]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* Gather all the arguments after the first as an array.**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将第一个参数之后的所有参数收集为一个数组。**'
- en: '***2* Strings: [“1”, “3”, “”, “”] Values: [2, 4, 5]**'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 字符串：[“1”, “3”, “”, “”] 值：[2, 4, 5]**'
- en: Here you use JavaScript’s `arguments` object to parse out your string parts
    and interpolated values. You use `arguments[0]` to get the first parameter, which
    is an array of the string parts, and you use `[].slice.call(arguments, 1)` to
    get an array of all the parameters after the first. This array will contain all
    the interpolated values.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 JavaScript 的 `arguments` 对象来解析字符串部分和插值值。你使用 `arguments[0]` 来获取第一个参数，它是一个字符串部分的数组，而你使用
    `[].slice.call(arguments, 1)` 来获取第一个参数之后的所有参数的数组。这个数组将包含所有的插值值。
- en: 'You should have expected the strings `1` and `3`, but why are there two additional
    empty strings? If values being interpolated are next to each other without any
    string parts in between, such as the `4` and the `5`, there will be an implicit
    empty string between them. This is the same for the start and end of the string
    as well. You can visualize how this gets computed with the following graph:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该期望得到字符串 `1` 和 `3`，但为什么会有两个额外的空字符串？如果被插值的值相邻且之间没有字符串部分，例如 `4` 和 `5`，它们之间将隐含一个空字符串。对于字符串的开始和结束也是如此。你可以通过以下图表来可视化它是如何计算的：
- en: '| Strings | “1” |   | “3” |   | “” |   | “” |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | “1” |   | “3” |   | “” |   | “” |'
- en: '| Values |   | 2 |   | 4 |   | 5 |   |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| 值 |   | 2 |   | 4 |   | 5 |   |'
- en: 'Because of this, the first piece and last piece will always be strings and
    the values will be what glues those strings together. This also means you can
    easily process these values with a simple `reduce` function:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，第一部分和最后一部分始终是字符串，值将是将这些字符串粘合在一起的内容。这也意味着你可以很容易地使用简单的`reduce`函数处理这些值：
- en: '[PRE72]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* The .shift() function removes and returns the first value of an array.**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `.shift()`函数移除并返回数组的第一个值。**'
- en: '***2* “12345”**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “12345”**'
- en: 'In this function, you processed the template literal the same as if it had
    not been tagged. But the point is to allow custom processing. This feature will
    most likely be implemented by library authors, but you can still use it to create
    some custom processing. Write a function that strips the whitespace between your
    markup:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你处理模板字符串的方式与它没有被标记时一样。但重点是允许自定义处理。这个特性很可能会由库的作者实现，但你仍然可以使用它来创建一些自定义处理。编写一个函数，用于去除你的标记之间的空白：
- en: '[PRE73]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We’ve only scratched the surface of what you can do with template literals.
    Because they allow for preprocessing of the interpolated values separately from
    the string parts of the literal and can return any data type, they’re perfect
    for creating abstractions known as DSLs (domain-specific languages), which you’ll
    be diving into next in your first capstone project.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了你可以用模板字符串做什么的表面。因为它们允许将插值值与字面量的字符串部分分开进行预处理，并且可以返回任何数据类型，所以它们非常适合创建称为领域特定语言（DSL）的抽象，你将在第一个综合项目中深入了解。
- en: '|  |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 7.4**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查7.4**'
- en: '**[Q1:](kindle_split_016_split_003.xhtml#ch07qa8q0a1)**'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_016_split_003.xhtml#ch07qa8q0a1)**'
- en: ''
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following snippet there are three lines of code. Which is the correct
    syntax for using a function to tag a template literal?
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在下面的代码片段中有三行代码。使用函数标记模板字符串的正确语法是哪一个？
- en: ''
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 7.4 answer**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.4 答案**'
- en: '**[A1:](kindle_split_016_split_003.xhtml#ch07qa7q1)**'
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_016_split_003.xhtml#ch07qa7q1)**'
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The last one: `` myTag`my templat` ``.'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一个是：`` myTag`my templat` ``。
- en: '|  |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, you learned the basics of template literals.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了模板字符串的基础知识。
- en: Template literals are a new literal syntax for creating strings using the back
    tick **`** character.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串是使用反引号**`**字符创建字符串的新字面量语法。
- en: Template literals can interpolate values with `${}`.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串可以使用`${}`进行值插值。
- en: Template literals can span multiple lines.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串可以跨越多行。
- en: Template literals will open the door for domain-specific languages with tagged
    templates.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板字符串将为具有标记模板的领域特定语言打开大门。
- en: 'Let’s see if you got this:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q7.1](kindle_split_050_split_004.xhtml#app01qa4q0a1)**'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7.1](kindle_split_050_split_004.xhtml#app01qa4q0a1)**'
- en: ''
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function you can use to tag template literals that checks whether each
    value is an object, and if so, converts the object into a string of key/value
    pairs before interpolation.
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个函数，你可以用它来标记模板字符串，该函数检查每个值是否是对象，如果是，则在插值之前将对象转换为键/值对的字符串。
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example if you call the function like so
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，如果你这样调用函数
- en: ''
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ''
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: you would get back
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会得到
- en: ''
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Lesson 8\. Capstone: Building a domain-specific language'
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8课：综合：构建领域特定语言
- en: In this project, you will
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将
- en: Learn what a domain-specific language *(DSL)* is
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习领域特定语言 *(DSL)* 是什么
- en: Create a simple DSL for handling user input from an HTML formatter
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为处理来自HTML格式化器的用户输入创建一个简单的领域特定语言
- en: Create a simple DSL for repeating or looping templates around an array
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在数组周围重复或循环模板创建一个简单的领域特定语言
- en: 'Before you build a DSL, let’s first define what one is. A *domain-specific
    language* uses a programming language’s features and syntax in a clever way to
    make solving a particular task appear as if it has first-class support by the
    programming language itself. For example, a common type of DSL seen in JavaScript
    is used by unit test libraries:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在你构建领域特定语言之前，让我们首先定义一下它是什么。*领域特定语言*以一种巧妙的方式使用编程语言的功能和语法，使得解决特定任务看起来就像编程语言本身提供了第一类支持。例如，JavaScript中常见的一种领域特定语言是由单元测试库使用的：
- en: '[PRE77]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is a DSL because it looks like you’re using natural language to state
    that you are describing push, and then giving the actual description: *it should
    add new values to the end of an array*. In reality, the `describe` and `it` parts
    of the sentences are functions, and the rest of the sentences are parameters to
    those functions.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种领域特定语言，因为它看起来你正在使用自然语言来声明你正在描述推送，然后给出实际的描述：*它应该将新值添加到数组的末尾*。实际上，句子中的`describe`和`it`部分是函数，其余部分是这些函数的参数。
- en: 'Other languages such as Ruby have a lot of DSLs. Ruby in particular is so malleable
    and has so much syntactic sugar that it makes creating DSLs extremely easy. JavaScript,
    on the other hand, has not historically lent itself to easy DSL creation. But
    with tagged templates, that may change. For example, a clever programmer might
    be able to utilize tagged templates to change the preceding unit-testing DSL into
    this syntax:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言，如Ruby，有很多领域特定语言（DSL）。特别是Ruby非常灵活，有大量的语法糖，这使得创建领域特定语言变得极其容易。另一方面，JavaScript在历史上并没有容易创建领域特定语言。但是，有了标签模板，这可能有所改变。例如，一个聪明的程序员可能能够利用标签模板将前面的单元测试领域特定语言转换为以下语法：
- en: '[PRE78]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You aren’t going to implement this DSL, but you are going to create a couple
    of your own. In the following sections you will
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会实现这个领域特定语言（DSL），但你将创建一些自己的。在接下来的章节中，你将
- en: Create some helper functions for string processing
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一些字符串处理的辅助函数
- en: Create an HTML-escaping DSL
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个HTML转义领域特定语言（DSL）
- en: Create a DSL for converting arrays into HTML
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将数组转换为HTML的领域特定语言（DSL）
- en: 8.1\. Creating some helper functions
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 创建一些辅助函数
- en: 'Before we begin, you’ll create a couple helper functions. In the last lesson,
    when creating a template tagging function, you started the function with some
    code that resembled the following:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你需要创建一些辅助函数。在上一个课程中，当创建模板标记函数时，你开始编写一些类似于以下代码的代码：
- en: '[PRE79]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These first two lines are for the purpose of getting the string values and the
    interpolated values of the template literal. They are a bit obscure, though, and
    detract from the rest of the logic. You’ll soon discover much better ways of collecting
    these values, but for now you’ll abstract this step away in a layer that hides
    this part from the rest of your logic. How? You’ll create a separate function
    to do this and then pass the collected values to your tag function.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这前两行是为了获取模板字面量的字符串值和插值值。虽然它们有点晦涩，但会分散其他逻辑的注意力。你很快会发现收集这些值更好的方法，但现在你将在这个步骤中抽象出这一层，使其隐藏在其他逻辑之外。如何做到？你将创建一个单独的函数来完成这个任务，然后将收集到的值传递给你的标签函数。
- en: Listing 8.1\. Abstracting the process of collecting interpolated values
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. 抽象收集插值值的过程
- en: '[PRE80]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now when you create a tagging function, you can do this, which is far neater:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你创建一个标记函数时，你可以这样做，这要干净得多：
- en: '[PRE81]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Another redundant step was when you had to use `reduce` to interlace the given
    strings and interpolated values. You can abstract that step away as well.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个冗余步骤是在你必须使用`reduce`来交织给定的字符串和插值值时。你也可以抽象出这个步骤。
- en: Listing 8.2\. Abstracting of interlacing strings and interpolated values
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. 抽象字符串和插值值的交织
- en: '[PRE82]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* This line is duplicating the array, a good practice before invoking methods
    that mutate the array in place like shift.**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这一行是复制数组，在调用像`shift`这样的原地修改数组的函数之前是一个好的实践。**'
- en: You can now use the combination of `createTag` and `interlace` to process a
    template literal in the standard implementation, as shown in the next listing.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用`createTag`和`interlace`的组合来处理模板字面量，如下一列表所示的标准实现。
- en: Listing 8.3\. Processing a template literal
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 处理模板字面量
- en: '[PRE83]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* <a>Click Me</a>**'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* <a>点击我</a>**'
- en: Now that you have these parts abstracted away, you can write a tagging function
    that focuses on the business at hand—escaping an HTML string.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经抽象出了这些部分，你可以编写一个专注于当前业务的标记函数——转义HTML字符串。
- en: 8.2\. Create an HTML-escaping DSL
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 创建一个HTML转义领域特定语言（DSL）
- en: Let’s consider the business logic behind getting a template literal and some
    values to HTML escape and interpolate. Your first tag is going to HTML escape
    your interpolated values. What you want to do is convert any occurrence of `<`
    and `>` with `<` and `>` respectively. You’ll use this to HTML escape user input
    to prevent injecting unintended HTML into your document. Start by writing a function
    that will do this for a given string, as shown in the next listing.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将模板字面量和一些值转换为HTML转义和插值的业务逻辑。你的第一个标签将转义你的插值值。你想要做的是将任何`<`和`>`的出现分别转换为`&lt;`和`&gt;`。你将使用这个方法来转义用户输入，以防止在文档中注入意外的HTML。首先编写一个函数，如下一列表所示，来完成这个任务。
- en: Listing 8.4\. A simple HTML-escaping function
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 一个简单的HTML转义函数
- en: '[PRE84]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This function uses regular expressions to replace the `<` and `>` characters
    with `<` and `>` respectively. Now that you have this, writing your tagging function
    is going to be super simple.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用正则表达式将`<`和`>`字符分别替换为`&lt;`和`&gt;`。现在你有了这个，编写你的标记函数将会非常简单。
- en: Listing 8.5\. Your tagging function, `htmlSafe`
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. 你的标记函数，`htmlSafe`
- en: '[PRE85]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Calls htmlEscape on only the values to be interpolated**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅对要插值的值调用htmlEscape***'
- en: The reason why this is beneficial as a tagging function as opposed to just using
    the `htmlEscape` function directly is because it allows you to target only the
    interpolated values for escaping, as seen in [listing 8.6](kindle_split_017_split_002.xhtml#ch08ex06).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以作为一个标记函数比直接使用`htmlEscape`函数更有益，是因为它允许你仅针对要转义的插值值进行转义，如[列表8.6](kindle_split_017_split_002.xhtml#ch08ex06)中所示。
- en: Listing 8.6\. Basic HTML-escaping DSL in action
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. 基本HTML转义DSL的实际应用
- en: '[PRE86]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* &lt;strong&gt;I &lt;3 ES6!&lt;/strong&gt;**'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* &lt;strong&gt;I &lt;3 ES6!&lt;/strong&gt;**'
- en: '***2* <strong>I &lt;3 ES6!</strong>**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* <strong>I &lt;3 ES6!</strong>**'
- en: Notice how the string `a` has all of the HTML pieces escaped but the string
    `b` correctly only escaped the `<3`.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串`a`中所有的HTML片段都被转义了，但字符串`b`正确地只转义了`<3>`。
- en: 8.3\. Create a DSL for converting arrays into HTML
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 创建一个将数组转换为HTML的DSL
- en: Take a look at the following code. What would you expect the value `list` to
    be?
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码。你期望`list`的值是什么？
- en: '[PRE87]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Wouldn’t it be great to have a utility that could expand the template by repeating
    it around the array of values to produce the following HTML?
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个实用工具可以重复模板，围绕值数组扩展模板，生成以下HTML，那岂不是很好？
- en: '[PRE88]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Let’s see how to build it! It’s actually simple. You just need to
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何构建它！实际上很简单。你只需要
- en: Grab the first and last part of the template
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取模板的第一部分和最后一部分
- en: Grab the interpolated array
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取插值的数组
- en: Map over the items in the array, wrapping each item with the parts of the template
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组中的每个项目进行映射，将每个项目包裹在模板的部分中
- en: 'All of which translates to the following code:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以转化为以下代码：
- en: '[PRE89]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now let’s see it in action.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看它的实际应用。
- en: Listing 8.7\. DSL interpolatating an array of values, not just one
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7\. DSL插值一个值数组，而不仅仅是单个值
- en: '[PRE90]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `html` variable now looks like so:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`html`变量现在看起来是这样的：'
- en: '[PRE91]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Currently the output looks like HTML but is still merely a string. You could
    take this even further by modifying `expand` or making another template tag that
    converts the string to actual DOM nodes.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 目前输出看起来像是HTML，但仍然只是一个字符串。你可以通过修改`expand`或创建另一个模板标记来进一步改进，将字符串转换为实际的DOM节点。
- en: Summary
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this capstone project you made use of both `let` and `const` for defining
    your variables, and you used template literals and tagged template literals to
    build DSLs. This is just scratching the surface of what you can do with the new
    string capabilities of ES6\. In the next unit we’re going to explore the new additions
    to objects and arrays.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合项目中，你使用了`let`和`const`来定义你的变量，并使用了模板字面量和标签模板字面量来构建领域特定语言（DSL）。这仅仅是ES6新字符串功能所能做到的一小部分。在下一个单元中，我们将探索对象和数组的新增功能。
