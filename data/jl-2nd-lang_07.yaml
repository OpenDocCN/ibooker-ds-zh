- en: 6 Storing data in dictionaries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 在字典中存储数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Storing values on keys in dictionaries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字典中通过键存储值
- en: Working with pair objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与成对对象一起工作
- en: Using tuples to create dictionaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组创建字典
- en: Comparing dictionaries and arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较字典和数组
- en: Comparing named tuples and dictionaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较命名元组和字典
- en: 'This chapter introduces a new data type called a *dictionary*. In some other
    languages this datatype is also referred to as a *map*. In dictionaries, values
    are looked up by keys, as opposed to being looked up exclusively using integer
    indices, like in an array. The code example illustrates the difference. Each line
    performs the following operations:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种新的数据类型，称为*字典*。在其他一些语言中，这种数据类型也被称为*映射*。在字典中，通过键查找值，而不是像数组那样仅使用整数索引进行查找。代码示例说明了这种差异。每一行执行以下操作：
- en: Looking up the 42nd value x in array xs. Values in arrays are ordered. However,
    xs could have been a dictionary as well, since dictionary keys can be anything,
    including integers.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数组xs中查找第42个值x。数组中的值是有序的。然而，xs也可以是一个字典，因为字典的键可以是任何东西，包括整数。
- en: Looking up a value y in dictionary ys with the key "foo".
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字典ys中通过键"foo"查找值y。
- en: Using a character 'D' rather than a string as the key in the dictionary zs to
    lookup value z.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字典zs中使用字符'D'而不是字符串作为键来查找值z。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will discover the utility of dictionaries by working through a code example
    involving the conversion of Roman numerals to decimal values and back. A dictionary
    will be used to keep track of what value a letter such as I, V, or X corresponds
    to in the decimal system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个涉及将罗马数字转换为十进制值以及反向转换的代码示例，你会发现字典的实用性。字典将用于跟踪字母I、V或X在十进制系统中的对应值。
- en: 6.1 Parsing Roman numerals
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 解析罗马数字
- en: While Roman numerals are not very practical to use today, they are useful to
    learn about for understanding number systems. In particular, when programming,
    you will encounter various number systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然罗马数字在当今不太实用，但了解它们对于理解数字系统是有用的。特别是，在编程时，你会遇到各种数字系统。
- en: Both Roman numerals and binary—the system used by computers—may seem very cumbersome
    to use. However it often appears that way because you don’t use the numbers as
    they were intended.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字和二进制——计算机使用的系统——可能看起来非常繁琐。然而，它们往往看起来是这样，因为你没有按照它们本来的意图使用这些数字。
- en: It is hard to make calculations using Roman numerals with pen and paper compared
    to Arabic numerals (which is what you typically use for numerals). However, the
    Romans did not use pen and paper to perform calculations. Rather they performed
    their calculations using a Roman abacus (figure 6.1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与阿拉伯数字（通常用于数字）相比，使用罗马数字用笔和纸进行计算比较困难。然而，罗马人并不是用笔和纸进行计算的。相反，他们使用罗马算盘（图6.1）进行计算。
- en: '![06-01](../Images/06-01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![06-01](../Images/06-01.png)'
- en: Figure 6.1 A Roman abacus with pebbles representing different values. The column
    decides how much value each pebble is given.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 一个带有代表不同值的鹅卵石的罗马算盘。列决定了每个鹅卵石赋予的价值。
- en: 'It is divided into multiple columns. Going from right to left, you can see
    columns of pebbles marked as I, X, and C; they each contain four pebbles. Each
    of these pebbles represents a different value, depending on what column they are
    in:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它被分为多个列。从右到左，你可以看到标记为I、X和C的鹅卵石列；它们各自包含四个鹅卵石。每个鹅卵石代表不同的值，具体取决于它们所在的列：
- en: In the I column every pebble represents 1.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在I列中，每个鹅卵石代表1。
- en: In the X column, every pebble represents 10.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在X列中，每个鹅卵石代表10。
- en: In the C column, every pebble represents 100.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C列中，每个鹅卵石代表100。
- en: These columns contain a single pebble each. They are called V, L, and D and
    represent the values 5, 50, and 500\. (On a Roman abacus you cannot actually see
    the VLD letters.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列中每个都包含一个鹅卵石。它们被称为V、L和D，分别代表5、50和500。（在罗马算盘上实际上看不到VLD字母。）
- en: NOTE The beauty of the Roman system is that you can quickly write down exactly
    what the pebbles on the abacus say. Likewise, it is quick to arrange pebbles on
    a Roman abacus to match a Roman numeral you have read. For this reason Roman numerals
    were used all the way into the 1500s in Europe, long after Arabic numerals had
    been introduced.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：罗马数字系统的美在于你可以快速写下算盘上鹅卵石所表示的确切数值。同样，将鹅卵石排列在罗马算盘上以匹配你读到的罗马数字也很迅速。因此，在欧洲，罗马数字一直被使用到1500年，尽管阿拉伯数字已经引入。
- en: Let’s look at how you can use this knowledge to parse Roman numerals and turn
    them into Arabic numerals. Put the following code into a text file, and save it.
    Don’t worry about the new syntax; we will cover that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些知识来解析罗马数字并将它们转换为阿拉伯数字。将以下代码放入文本文件中，并保存。不用担心新的语法；我们将在后面介绍。
- en: Listing 6.1 Parsing and converting Roman numerals to decimal numbers
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 解析并将罗马数字转换为十进制数字
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Load this file into the Julia REPL environment to test it out. This is an example
    of using parse_roman with different Roman numerals as input:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件加载到 Julia REPL 环境中以进行测试。这是使用不同罗马数字作为输入的 parse_roman 的一个示例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s go through how the code works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码是如何工作的。
- en: 6.2 Using the Dict type
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 使用 Dict 类型
- en: 'You map or translate the Roman letters I, V, X, and so on to numbers using
    what is called a *dictionary*. A dictionary is made up of multiple pairs; pairs
    are constructed using the arrow operator, =>. You cannot use the equals operator,
    =, because it is used for assignment. x = y assigns the value of y to variable
    x, while x => y creates a pair of the values in x and y:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用所谓的 *字典* 将罗马字母 I、V、X 等映射或转换为数字。字典由多个对组成；对是通过箭头操作符 => 构建的。您不能使用等号操作符 =，因为它用于赋值。x
    = y 将 y 的值赋给变量 x，而 x => y 则在 x 和 y 中创建一个值对：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A pair of the letter X and the number 10
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 字母 X 和数字 10 的一个对
- en: ❷ Pairs can be stored in a variable and examined later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对可以存储在变量中并在以后进行检查。
- en: ❸ dump allows you to look at the fields of any value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ dump 允许您查看任何值的字段。
- en: ❹ Extracting the first value in the pair
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 提取对中的第一个值
- en: 'Pairs are composite objects with the fields first and second. These fields
    allow you to access both values given when the pair was constructed. However,
    you should consider that an implementation detail and access the fields of pairs
    with first and last accessor functions. This behavior makes pairs very similar
    to range objects covered in chapter 3 and tuples covered in chapter 4:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对是复合对象，具有 first 和 second 字段。这些字段允许您访问在构建对时给出的两个值。然而，您应该将其视为实现细节，并使用 first 和
    last 访问器函数访问对的字段。这种行为使对与第 3 章中介绍的 range 对象和第 4 章中介绍的元组非常相似：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code example I accessed several values in one line by separating them
    with a comma. That produced a tuple with three values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我通过在行中用逗号分隔来访问多个值。这产生了一个包含三个值的元组。
- en: It may seem confusing that the second field of a pair is accessed with the function
    last. The reason is that last element also exists for arrays and tuples. Hence
    last generalizes better across multiple collection types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来可能有些困惑，因为对中的第二个字段是通过函数 last 访问的。原因是数组也有最后一个元素。因此，last 在多个集合类型中具有更好的泛化能力。
- en: Note Out of curiosity you may try to use the dump function on a dictionary object.
    It has fields such as slots, idxfloor, maxprobe, and so on, which likely won’t
    make much sense. That is because dump exposes implementation details. As a user
    of a datatype, you should not need to know what fields it has, only which function
    you can use to operate on it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 出于好奇，您可能会尝试在字典对象上使用 dump 函数。它具有 slots、idxfloor、maxprobe 等字段，这些字段可能不会很有意义。这是因为
    dump 揭示了实现细节。作为数据类型的使用者，您不需要知道它有哪些字段，只需要知道您可以使用哪些函数来操作它。
- en: You provide a list of these pairs to create a dictionary. The following code
    shows how to create a dictionary to map letters used by Roman numerals to their
    corresponding decimal value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您提供这些对的一个列表来创建一个字典。以下代码显示了如何创建一个字典，将罗马数字使用的字母映射到它们对应的十进制值。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When used in a dictionary, you refer to the first values in each pair as the
    *keys* in the dictionary. The second values in each pair form the *values* of
    the dictionary. So I, X, and C are keys, while 1, 10, and 100 are values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中使用时，您将每个对中的第一个值称为字典中的 *键*。每个对中的第二个值形成字典的 *值*。因此，I、X 和 C 是键，而 1、10 和 100
    是值。
- en: 'You can ask a dictionary for the value corresponding to a key. This takes a
    Roman letter and returns the corresponding value:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向字典询问与键对应的值。这需要一个罗马字母并返回相应的值：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 6.3 Looping over characters
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 遍历字符
- en: 'You can use this dictionary to help you convert Roman letters to corresponding
    values. At line 8 in the parse_roman function, you do this conversion with what
    is called an *array comprehension*. You iterate over every character, ch, in the
    string, s. On each iteration, you evaluate roman_numerals[ch], and all of these
    values get collected into an array:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这个字典来帮助您将罗马字母转换为相应的数值。在`parse_roman`函数的第8行，您使用所谓的*数组推导式*进行这种转换。您遍历字符串`s`中的每个字符`ch`。在每次迭代中，您评估`roman_numerals[ch]`，所有这些值都被收集到一个数组中：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A comprehension is like a for-loop, where a value is evaluated on each iteration
    and added to a collection. You can create a comprehension for any collection,
    including dictionaries:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式就像一个for循环，其中每个迭代都会评估一个值并将其添加到集合中。您可以为任何集合创建推导式，包括字典：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But in the Roman-numeral code the comprehension for loop is used to build an
    array. To better understand how an *array comprehension* works let’s look at a
    regular for loop doing the exact same thing. In this example, you start with Roman
    numerals "XIV", which you want to convert:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但在罗马数字代码中，推导式循环用于构建一个数组。为了更好地理解*数组推导式*的工作原理，让我们看看一个执行完全相同任务的常规for循环。在这个例子中，您从罗马数字“XIV”开始，您想要将其转换：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '"XIV" is turned into the array of values [10, 1, 5], named vals. However, the
    job is not quite done. Later, you need to combine these values into one number.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “XIV”被转换成值数组[10, 1, 5]，命名为`vals`。然而，工作还没有完成。稍后，您需要将这些值组合成一个数字。
- en: Before converting input strings, the code sets every letter in uppercase. "xiv"
    would not get processed correctly because all the keys to the dictionary are uppercase.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换输入字符串之前，代码将每个字母都转换为大写。例如，“xiv”将无法正确处理，因为字典的所有键都是大写的。
- en: 'I will walk you through the mechanics of the process and save the explanation
    for why you perform these steps for last. Reverse the order of the letters, so
    you can process numerals conveniently from right to left in a loop:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您介绍这个过程的工作原理，并将解释为什么执行这些步骤的原因留到最后。反转字母的顺序，这样您就可以在循环中从右到左方便地处理数字：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 6.4 Enumerating values and indices
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 枚举值和索引
- en: 'When processing a value, val, in the loop, you want to be able to compare with
    the preceding value. You could have accomplished that with a variable, say prev,
    store value from the previous iteration. Instead, you will use the enumerate function
    to get the index, i, of each value, val, being processed. The value preceding
    val is then simply vals[i-1]:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中处理值`val`时，您希望能够与前面的值进行比较。您可以使用一个变量，比如`prev`，来存储前一次迭代的值。相反，您将使用`enumerate`函数来获取每个值`val`处理的索引`i`。那么，`val`前面的值就是`vals[i-1]`：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To better understand how enumerate works, let’s use some examples focused exclusively
    on enumerate:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`enumerate`的工作原理，让我们使用一些专注于`enumerate`的示例：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That output wasn’t very useful at all. The reason is that enumerate is *lazy*.
    You don’t get any values out because this expression doesn’t actually need any
    values to be evaluated. But you can use the collect function to collect all the
    values enumerate would have produced into an array. The following is a simple
    example of collecting a range:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那个输出毫无用处。原因是`enumerate`是*惰性的*。您不会得到任何值，因为此表达式实际上不需要评估任何值。但您可以使用`collect`函数收集`enumerate`本应产生的所有值到一个数组中。以下是一个收集范围的简单示例：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'More interesting is how you collect values from an enumeration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是如何从枚举中收集值：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The collect function will simulate looping over something, just like a for
    loop, except it will *collect* all the values encountered into an array, which
    it returns. So you can see with enumerate you get a pair of values upon each iteration:
    an integer index and the value at that index.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect`函数将模拟循环操作，就像for循环一样，但它会将遇到的全部值收集到一个数组中，然后返回。因此，您可以看到，使用`enumerate`，您在每次迭代时都会得到一对值：一个整数索引和该索引处的值。'
- en: 6.5 Explaining the conversion process
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 解释转换过程
- en: 'You cannot simply add up the individual Roman letters converted to their corresponding
    values. Consider the Roman number XVI. It turns into [10, 5, 1]. You could add
    up the elements and get the correct result: 16\. However, XIV is supposed to mean
    14 because when a smaller Roman numeral is in front of a larger one, such as in
    *IV*, you subtract the smaller value from the larger.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能简单地将转换成相应数值的罗马字母相加。以罗马数字XVI为例。它变成了[10, 5, 1]。您可以相加这些元素并得到正确的结果：16。然而，XIV应该表示14，因为在*IV*这样的情况下，较小的罗马数字位于较大的数字之前，您需要从较大的数字中减去较小的值。
- en: 'You cannot just sum up the corresponding array [10, 1, 5]. Instead, you reverse
    it to work your way backwards through the values. At every index you ask if the
    current value is lower than the previous one. If it is, you subtract from the
    result; otherwise you add the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能只是将相应的数组 [10, 1, 5] 相加。相反，你需要反转它，以便通过值向后工作。在每一个索引处，你都会询问当前值是否低于前一个值。如果是，则从结果中减去；否则，加上下一个值：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That is what val < vals[i - 1] does. It compares the current value, val, to
    the previous value, vals[i -1]. result is used to accumulate the value of all
    the individual Roman letters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 val < vals[i - 1] 的作用。它将当前值 val 与前一个值 vals[i - 1] 进行比较。result 用于累积所有单个罗马字母的值。
- en: 6.6 Using dictionaries
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 使用字典
- en: Now that you have looked at a practical code example utilizing the dictionary
    type Dict in Julia, let’s explore some more ways of interacting with a dictionary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经查看了一个使用 Julia 中的字典类型 Dict 的实际代码示例，让我们探索更多与字典交互的方法。
- en: 6.6.1 Creating dictionaries
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 创建字典
- en: 'There are a multitude of ways to create a dictionary. In this section, I’ll
    discuss some examples, starting with multiple arguments, where each argument is
    a pair object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字典有多种方法。在本节中，我将讨论一些示例，从多个参数开始，其中每个参数都是一个对对象：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Pass an array of pairs to the dictionary constructor (a function named the
    same as the type it makes instances of):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个对数组传递给字典构造函数（一个与它创建的实例类型同名的函数）：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Pass an array of tuples to the dictionary constructor. Unlike pairs, tuples
    may contain more than two values. For dictionaries they must only contain a key
    and a value though:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个元组数组传递给字典构造函数。与对相比，元组可以包含超过两个值。对于字典，它们必须只包含一个键和一个值：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'How do you know which variant to use? That depends on the problem you are trying
    to solve. For instance, when you read pizza data in chapter 5, you got an array
    of tuples back:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道使用哪个变体？这取决于你试图解决的问题。例如，当你阅读第 5 章中的披萨数据时，你得到了一个元组的数组：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You might want to put this data into a dictionary to quickly look up the price
    for a given pizza:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想将此数据放入字典中，以便快速查找给定披萨的价格：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, if keeping pizza data in order is not important, you could define
    this dictionary directly instead:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不介意保持披萨数据的顺序，你可以直接定义这个字典：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sometimes you need an empty dictionary, which you later fill up. One example
    would be loading from file straight into a dictionary. Instead of appending values
    to the end of an array, you could insert them into a dictionary:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要一个空字典，稍后将其填充。一个例子就是从文件直接加载到字典中。你不必将值追加到数组的末尾，而是可以将它们插入到字典中：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice the {Any, Any} part. This describes what Julia has inferred is the type
    of key and value in the dictionary. However, when you created your pizza dictionary,
    you would have noticed that Julia described it as having the Dict{String, Float64}
    type. String refers to the type of keys in the dictionary, and Float64 refers
    to the type of values. You can, however, specify the types of keys and values
    for an empty dictionary as well:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 {Any, Any} 部分。这描述了 Julia 推断的字典中键和值的类型。然而，当你创建你的披萨字典时，你会注意到 Julia 将其描述为 Dict{String,
    Float64} 类型。String 指的是字典中键的类型，而 Float64 指的是值的类型。然而，你仍然可以为空字典指定键和值的类型：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The benefit of specifying the type of the key and value is that it is easier
    to catch wrong usage of the dictionary at runtime. If you try to use values of
    the wrong type for key and value, Julia will throw an exception to indicate an
    error (chapter 6 covers different types in greater depth). In this case you are
    trying to use an integer 5 as a key when a text string key is expected:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 指定键和值的类型的好处是，在运行时更容易捕捉到字典的错误使用。如果你尝试为键和值使用错误类型的值，Julia 将抛出一个异常来指示错误（第 6 章将更深入地介绍不同类型）。在这种情况下，你试图使用一个整数
    5 作为键，而预期的是一个文本字符串键：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Sometimes you get keys and values in separate arrays. However you can still
    combine them into pairs to create dictionaries using the zip function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会得到单独的键和值数组。然而，你仍然可以使用 zip 函数将它们组合成对来创建字典：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 6.6.2 Element access
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 元素访问
- en: You have already looked at one way of getting and setting dictionary elements.
    But what happens if you try to retrieve a value for a key that does not exist,
    such as "seven"?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一种获取和设置字典元素的方法。但是，如果你尝试检索一个不存在的键的值，比如 "seven"，会发生什么？
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You get an error. You can, of course, simply add it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个错误。当然，你可以简单地添加它：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But how do you avoid producing an error when you are not sure a key exists?
    One solution is the get() function. If the key does not exist, a sentinel value
    is returned instead. The sentinel can be anything.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你不确定键是否存在时，如何避免产生错误？一种解决方案是使用get()函数。如果键不存在，则返回一个哨兵值。哨兵可以是任何值。
- en: Note In computer programming, a *sentinel value* (also referred to as a *flag
    value*, a *trip value*, a *rogue value*, a *signal value*, or dummy data) is a
    special value in the context of an algorithm that uses its presence as a condition
    of termination, typically in a loop or recursive algorithm.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在计算机编程中，*哨兵值*（也称为*标志值*、*触发值*、*异常值*、*信号值*或占位数据）是在使用其存在作为终止条件的情况下使用的特殊值，通常在循环或递归算法中使用。
- en: 'This is a strategy used in many programming languages when working with dictionaries.
    The following example uses -1 as a sentinel value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在许多编程语言中处理字典时使用的一种策略。以下示例使用-1作为哨兵值：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or you could simply ask the dictionary if it has the key:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以简单地询问字典是否具有该键：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 6.7 Why use a dictionary?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 为什么使用字典？
- en: In principle, you could use an array to do the conversion of Roman numerals
    to decimal numbers. Here is an example of how you could do that.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，你可以使用数组将罗马数字转换为十进制数字。以下是如何做到这一点的示例。
- en: Listing 6.2 Look up a value by key in an array of key-value pairs
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 在键值对数组中通过键查找值
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Pull out the key k and value v of each pair in the array.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数组中的每个键值对中提取键k和值v。
- en: ❷ It found a matching key, so return the corresponding value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 找到了匹配的键，因此返回相应的值。
- en: ❸ If iterating over all the pairs didn’t find a matching key, then you are unable
    to return anything and must throw an exception instead. The KeyError exception
    is the convention to use in Julia in cases where keys are missing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果遍历所有键值对没有找到匹配的键，那么你无法返回任何内容，必须抛出异常。在Julia中，当键缺失时，使用KeyError异常是惯例。
- en: 'You could define the lookup table as an array of pairs instead of a dictionary:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将查找表定义为键值对的数组，而不是字典：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this you could do lookup of values based on keys in a similar fashion to
    a dictionary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以根据键进行查找，类似于字典。
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ A demonstration of looking up a key that doesn’t exist, producing an exception
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查找不存在的键，产生异常的演示
- en: Avoid arrays when doing key-based lookup because the time to perform a lookup
    grows linearly with the size of the array. Looking up an element among 30 entries
    takes, on average, three times as long as looking up an entry among 10 elements.
    It is not hard to see how this does not scale well with large arrays. Looking
    for one element among 1 million elements will take 1,000 times longer than locating
    it among 1,000 elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行基于键的查找时避免使用数组，因为查找所需的时间会随着数组大小的线性增长而增长。在30个条目中查找一个元素，平均需要的时间是10个元素中查找一个条目的三倍。不难看出，这种方法在大数组中扩展性不好。在100万个元素中查找一个元素所需的时间将是1000个元素中查找该元素所需时间的1000倍。
- en: Dictionaries, in contrast, are made so that the lookup time is *independent*
    of how many elements the dictionary contains. Looking up 1 element among 100 is
    similar to doing it among 1 million.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，字典被设计成查找时间与字典包含的元素数量无关。在100个元素中查找1个元素与在100万个元素中查找相似。
- en: Why are dictionary lookups so fast?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么字典查找如此快速？
- en: Why dictionaries allow fast lookup of a value given a key is outside the scope
    of this book. Books about data structures and algorithms usually cover this topic
    in detail, and a dictionary refers more to the interface to the data than the
    actual data structure used to achieve fast lookups. In Julia, *hash tables* are
    used to allow fast lookups, but it is also possible to implement a dictionary
    using a *binary search tree* data structure.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么字典允许根据键快速查找值，这超出了本书的范围。关于数据结构和算法的书籍通常会详细讨论这个主题，而字典更多地指的是数据结构的接口，而不是用于实现快速查找的实际数据结构。在Julia中，使用*哈希表*来实现快速查找，但也可以使用*二叉搜索树*数据结构来实现字典。
- en: But don’t discount arrays. Short arrays are very fast to search—faster than
    a dictionary of comparable size. Thus, while the number of elements is less than
    100, arrays are still a viable choice. In fact, the Roman-numeral code example
    used a dictionary because dictionaries are convenient to work with when dealing
    with key-based lookup, and you never have to worry about performance taking a
    nosedive because you added too many elements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要低估数组。短数组搜索非常快——比同等大小的字典快。因此，当元素数量少于 100 时，数组仍然是一个可行的选择。实际上，罗马数字代码示例使用了字典，因为当处理基于键的查找时，字典使用起来很方便，而且你永远不必担心因为添加了太多元素而导致性能大幅下降。
- en: However, there are special cases in which using an array can work really well
    (e.g., if you never modify the array). If elements are never added or removed
    you can simply keep the array sorted. A sorted array can be searched very quickly
    using Julia’s searchsortedfirst function. In fact, the Roman numeral code example
    is well suited for this approach, since the mapping between numerals and decimal
    values is fixed. You can do this by keeping the keys and values in separate arrays
    sorted by the key values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些特殊情况下，使用数组可以非常有效（例如，如果你永远不会修改数组）。如果元素永远不会被添加或删除，你可以简单地保持数组排序。使用 Julia
    的 searchsortedfirst 函数可以非常快速地搜索排序后的数组。实际上，罗马数字代码示例非常适合这种方法，因为数字和十进制值之间的映射是固定的。你可以通过保持键和值分别排序的数组来实现这一点。
- en: Listing 6.3 Array of sorted keys with a matching array of values
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 带有匹配值数组的排序键数组
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With searchsortedfirst you can find the index of a particular key.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 searchsortedfirst，你可以找到特定键的索引。
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make sure the value for key I is located at the same index i in the vals array:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 确保键 I 的值位于 vals 数组中的相同索引 i：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s another example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 6.8 Using named tuples as dictionaries
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 使用命名元组作为字典
- en: Before rounding off this chapter, I want to show you another neat trick that
    allows you to write more-readable code with better performance. You have already
    seen tuples where you can access elements by index. What you have not seen is
    accessing tuple values by key, just like a dictionary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想向你展示另一个很酷的技巧，它允许你用更好的性能编写更易读的代码。你已经看到了可以通过索引访问元素的元组。但你还没有看到通过键访问元组值，就像字典一样。
- en: 'Remember you created a pizza tuple like this: ("hawaiian", ''S'', 10.5). It
    is possible to give names to each value; the names you give will not be text strings
    but Julia *symbols* (built-in Julia type to represent identifiers). In chapter
    5, you used symbols such as :cyan, :green, and :red to specify color of printed
    text. Similarly, you can access individual values in the pizza tuple using symbols
    such as :name and :price:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你创建了一个像这样的 pizza 元组：("hawaiian", 'S', 10.5)。你可以给每个值命名；你给出的名称将不是文本字符串，而是 Julia
    *符号*（内置 Julia 类型，用于表示标识符）。在第 5 章中，你使用了 :cyan、:green 和 :red 这样的符号来指定打印文本的颜色。同样，你可以使用符号如
    :name 和 :price 访问 pizza 元组中的单个值：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how you use a shortcut in the last two expressions; pizza[:price] is
    equivalent to writing pizza.price. This way of working with data will look familiar
    to JavaScript developers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你在最后两个表达式中使用的快捷方式；pizza[:price] 等同于写作 pizza.price。这种方式处理数据的方式对于 JavaScript
    开发者来说很熟悉。
- en: 'Keep in mind that symbols are a lot more limited in functionality than strings.
    In most cases they are treated as atomic values. You cannot access individual
    characters in a symbol or combine and manipulate them like strings. Fortunately,
    it is easy to convert back and forth between keys and strings:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，符号在功能上比字符串有限得多。在大多数情况下，它们被视为原子值。你不能访问符号中的单个字符，也不能像字符串那样组合和操作它们。幸运的是，很容易在键和字符串之间进行转换：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Create a symbol from a string.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从字符串创建一个符号。
- en: ❷ Create a string from a symbol.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从符号创建一个字符串。
- en: With this knowledge you can rewrite your parse_roman function from listing 6.1
    to use a named tuple instead of a dictionary. Observe that you have to change
    the lookup roman_numerals[ch] to roman_numerals[Symbol(ch)] because roman_numerals
    no longer have characters as keys but symbols.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些知识，你可以将列表 6.1 中的 parse_roman 函数重写为使用命名元组而不是字典。观察你会发现，你必须将查找 roman_numerals[ch]
    改为 roman_numerals[Symbol(ch)]，因为 roman_numerals 的键不再是字符，而是符号。
- en: Listing 6.4 Parsing Roman numerals using named tuples
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 使用命名元组解析罗马数字
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Changed from dictionary to named tuple
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从字典更改为命名元组
- en: ❷ Lookup with Symbol(ch) instead of ch
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Symbol(ch) 而不是 ch 进行查找
- en: 6.8.1 When do you use a named tuple?
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.1 何时使用命名元组？
- en: Named tuples look very similar to dictionaries, so what is the point of having
    them? All types of tuples are immutable, meaning you cannot change them. You cannot
    add values to a tuple after you have created it, nor can you modify existing values.
    In contrast, both arrays and dictionaries allow you to add values. Dictionaries
    give you a wider selection of types which can by used as keys. A named tuple only
    allows you to use symbols as keys.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组看起来与字典非常相似，那么拥有它们的目的是什么呢？所有类型的元组都是不可变的，这意味着你不能改变它们。一旦创建了元组，就不能向其中添加值，也不能修改现有值。相比之下，数组和字典都允许你添加值。字典为你提供了更广泛的类型选择，可以用作键。命名元组只允许你使用符号作为键。
- en: The benefit of any tuple type over an array or a dictionary is that the Julia
    JIT compiler will know exactly which elements will be in the tuple at any given
    time, which allows for more aggressive optimizations. Thus you can assume a tuple
    will generally give you equal or better performance compared to an array or a
    dictionary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 任何元组类型相对于数组或字典的优势在于，Julia JIT 编译器将确切知道在任何给定时间元组中会有哪些元素，这允许进行更激进的优化。因此，你可以假设元组通常会比数组或字典提供相等或更好的性能。
- en: While only using symbols as keys is a limitation, it also allows named tuples
    to offer more convenient syntax for accessing values. For example, pizza.name
    is easier to write and read than pizza[:name].
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然只使用符号作为键是一种限制，但它也允许命名元组提供更方便的语法来访问值。例如，pizza.name 比pizza[:name] 更容易编写和阅读。
- en: 6.8.2 Tying it all together
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.2 将所有内容结合起来
- en: This chapter has covered all the key types any programmer should know. With
    numbers, ranges, strings, arrays, tuples, and dictionaries you can do almost anything.
    However, I have not yet said much about *what* a type actually is or how you can
    make your own custom types. This is crucial for facilitating the construction
    of larger, more feature-rich applications. That will be the focus of the next
    two chapters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了任何程序员都应该了解的所有关键类型。有了数字、范围、字符串、数组、元组和字典，你可以做几乎所有的事情。然而，我还没有详细说明类型实际上是什么，或者你如何创建自己的自定义类型。这对于促进构建更大、功能更丰富的应用程序至关重要。这将是下一章的重点。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Dictionaries hold key-value pairs, where the key has to be unique.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典持有键值对，其中键必须是唯一的。
- en: Key-value pairs can quickly be looked up, added, or removed from a dictionary.
    This differs from large arrays, which may require time-consuming searches.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字典中，键值对可以快速查找、添加或删除。这与可能需要耗时搜索的大数组不同。
- en: Arrays offer better performance when the number of elements is small or when
    you can do index-based rather than key-based accessing of elements.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元素数量较少或你可以进行基于索引而不是基于键的元素访问时，数组提供了更好的性能。
- en: In Julia, keys and values are typed. Hence, Julia is able to catch the usage
    of keys of the wrong type as well as attempts at inserting values of the wrong
    type.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，键和值是有类型的。因此，Julia 能够捕获错误类型键的使用，以及尝试插入错误类型值的尝试。
- en: Named tuples work like an immutable version of dictionaries. You can look up
    values, but you cannot modify them or add new entries.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名元组类似于不可变版本的字典。你可以查找值，但不能修改它们或添加新条目。
