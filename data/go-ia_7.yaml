- en: Chapter 8\. Standard library
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章\. 标准库
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章*'
- en: Writing output and logging information
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写输出和日志信息
- en: Decoding and encoding JSON
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码和编码 JSON
- en: Working with IO and streams of data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 IO 和数据流一起工作
- en: Interoperability between packages in the standard library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库中包之间的互操作性
- en: 'What is the *Go standard library* and why is it important? The Go standard
    library is a set of core packages that enhance and extend the language. These
    packages add to the number of different types of programs you can write without
    the need to build your own packages or download packages others have published.
    Since these packages are tied to the language, they come with some special guarantees:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 *Go 标准库* 以及为什么它很重要？Go 标准库是一组核心包，它增强并扩展了语言的功能。这些包增加了你可以编写的不同类型程序的数量，而无需构建自己的包或下载他人发布的包。由于这些包与语言绑定，它们提供了一些特殊的保证：
- en: They will always exist for each minor release of the language.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将始终存在于语言的每个小版本中。
- en: They will honor the backward-compatibility promise.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们将遵守向后兼容性的承诺。
- en: They are part of the dev, build, and release process for Go.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是 Go 的开发、构建和发布过程的一部分。
- en: They are maintained and reviewed by Go contributors.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们由 Go 贡献者维护和审查。
- en: They are tested and benchmarked with each new release of the language.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会随着语言每个新版本的发布进行测试和基准测试。
- en: These guarantees make the standard library special and something you want to
    leverage as much as possible. By using packages from the standard library, you
    make it easier to manage your code and ensure that it’s reliable. This is because
    you don’t have to worry if your program is going to break between release cycles,
    nor do you have to manage third-party dependencies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些保证使标准库变得特殊，并且你希望尽可能多地利用它。通过使用标准库中的包，你可以更容易地管理你的代码，并确保其可靠性。这是因为你不必担心程序在发布周期之间是否会崩溃，也不必管理第三方依赖。
- en: All these benefits would be useless if the standard library didn’t contain all
    the great packages that it does. Go developers in the community depend on these
    packages more so than in other languages. This is because they are well designed
    and provide more functionality than is normally found in traditional standard
    libraries. In the end, the Go community relies on the standard library for lots
    of things that developers in other languages do not, such as networking, HTTP,
    image processing, and cryptology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准库不包含所有这些优秀的包，所有这些好处都将毫无意义。社区中的 Go 开发者比其他语言更依赖这些包。这是因为它们设计得很好，并且提供了比传统标准库中通常找到的功能更多。最终，Go
    社区依赖于标准库来完成许多其他语言中的开发者不做的事情，例如网络、HTTP、图像处理和密码学。
- en: 'In this chapter we’ll take a high-level look at the current set of packages
    that are a part of the standard library. Then we’ll explore in greater detail
    three packages that come in handy for many different programs: `log`, `json`,
    and `io`. These packages also show off some of the great things that Go has to
    offer.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从高层次的角度审视当前属于标准库的包集。然后我们将更详细地探讨三个对许多不同程序都很有用的包：`log`、`json` 和 `io`。这些包也展示了
    Go 提供的一些优秀功能。
- en: 8.1\. Documentation and source code
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 文档和源代码
- en: The standard library is filled with so many packages that it would be impossible
    to cover them all in the scope of one chapter. Currently there are well over 100
    packages organized within 38 categories.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中包含的包如此之多，以至于在一章的范围内不可能全部涵盖。目前，有超过 100 个包组织在 38 个类别中。
- en: Listing 8.1\. Set of top-level folders and packages in the standard library
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. 标准库中的顶级文件夹和包集
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Many of the categories in [listing 8.1](#ch08ex01) are also packages themselves.
    For a detailed description and a look at all the available packages, the Go team
    maintains documentation on the Go website at [http://golang.org/pkg/](http://golang.org/pkg/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.1](#ch08ex01) 中的许多类别本身也是包。要获取详细描述和查看所有可用的包，Go 团队在 Go 网站上维护了文档，网址为 [http://golang.org/pkg/](http://golang.org/pkg/)。'
- en: The `pkg` section of the `golang` website provides the `godoc` documentation
    for each package. [Figure 8.1](#ch08fig01) shows an example of the package documentation
    on the `golang` website for the `io` package.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang` 网站的 `pkg` 部分提供了每个包的 `godoc` 文档。[图 8.1](#ch08fig01) 展示了 `golang` 网站上
    `io` 包的包文档示例。'
- en: Figure 8.1\. golang.org/pkg/io/#Writer
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. golang.org/pkg/io/#Writer
- en: '![](08fig01_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig01_alt.jpg)'
- en: If you want documentation that you can interact with, Sourcegraph has indexed
    all the code for the standard library and many of the public repositories that
    contain Go code. [Figure 8.2](#ch08fig02) shows an example of the package documentation
    on the Sourcegraph website ([https://sourcegraph.com/](https://sourcegraph.com/))for
    the `io` package.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要可以交互的文档，Sourcegraph已经索引了标准库以及包含Go代码的许多公共仓库的所有代码。[图8.2](#ch08fig02)展示了在Sourcegraph网站上(`https://sourcegraph.com/`)的`io`包的包文档示例。
- en: Figure 8.2\. sourcegraph.com/code.google.com/p/go/.GoPackage/io/.def/Writer
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. sourcegraph.com/code.google.com/p/go/.GoPackage/io/.def/Writer
- en: '![](08fig02_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig02_alt.jpg)'
- en: No matter how you installed Go, all the source code for the standard library
    can be found on your development machine in the $GOROOT/src/pkg folder. Having
    the source code for the standard library is important for the Go tooling to work.
    Tools like `godoc`, `gocode`, and even `go build` read this source code to perform
    their functions. If this source code is not on your machine and accessible through
    the `$GOROOT` variable, you’ll get errors when trying to build your programs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何安装Go，标准库的所有源代码都可以在您的开发机器上的$GOROOT/src/pkg文件夹中找到。拥有标准库的源代码对于Go工具的正常工作非常重要。像`godoc`、`gocode`甚至`go
    build`这样的工具会读取这些源代码以执行其功能。如果这些源代码不在您的机器上，并且无法通过`$GOROOT`变量访问，那么在尝试构建您的程序时您将遇到错误。
- en: The source code for the standard library is precompiled as part of your Go distribution
    package. These precompiled files, called *archive files*, can be found in the
    `$GOROOT`/pkg folder for each target platform and operating system you have installed.
    In [figure 8.3](#ch08fig03) you can see files with an .a extension, which are
    the archive files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的源代码作为Go发行版包的一部分预先编译。这些预先编译的文件，称为*归档文件*，可以在您安装的每个目标平台和操作系统的$GOROOT/pkg文件夹中找到。在[图8.3](#ch08fig03)中，您可以看到具有.a扩展名的文件，这些就是归档文件。
- en: Figure 8.3\. View of the archive files inside the pkg folder
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. pkg文件夹内归档文件视图
- en: '![](08fig03_alt.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig03_alt.jpg)'
- en: These files are special static Go libraries that the Go build tools create and
    use when compiling and linking your final programs together. This helps the build
    process to be fast. But there’s no way to specify these files when performing
    a build, so you can’t share them. The Go tooling knows when it can use an existing
    .a file and when it needs to rebuild one from the source code on your machine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是特殊的静态Go库，Go构建工具在编译和链接您的最终程序时创建和使用它们。这有助于构建过程更快。但在执行构建时无法指定这些文件，因此您无法共享它们。Go工具知道何时可以使用现有的.a文件，何时需要从您机器上的源代码重新构建一个。
- en: With this background in place, let’s take a look at a few of the packages in
    the standard library and see how you can consume them in your own programs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立这样的背景知识之后，让我们来看看标准库中的几个包，并看看您如何在您的程序中消费它们。
- en: 8.2\. Logging
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 记录日志
- en: Your programs have bugs, even if they haven’t shown themselves yet. That’s the
    nature of software development. Logging is a way to find those bugs and learn
    more about how your program is functioning. Logs can be your eyes and ears, providing
    code tracing, profiling, and analytics. With this in mind, the standard library
    provides a log package that can be used with some basic configuration. You can
    also create custom loggers to implement your own specific logging needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序有错误，即使它们还没有表现出来。这就是软件开发的本性。记录日志是一种找到这些错误并了解更多关于您的程序如何运行的方法。日志可以是您的眼睛和耳朵，提供代码跟踪、分析和性能分析。考虑到这一点，标准库提供了一个日志包，它可以与一些基本配置一起使用。您还可以创建自定义日志记录器以实现您自己的特定日志需求。
- en: Logging has a long history in UNIX, and this has carried over into the `log`
    package. Traditional CLI (command-line interface) programs write their output
    to the `stdout` device. This device exists on all operating systems and is the
    default destination for standard text output. Terminals are configured by default
    to display text written to this device. Using this single destination works great
    until you have a program that needs to write both output and details about how
    the program is functioning. When you want to write logging information, you want
    to write that to a different destination so your output and logging won’t be mixed
    together.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录在UNIX中有着悠久的历史，这一点也延续到了`log`包中。传统的CLI（命令行界面）程序将它们的输出写入`stdout`设备。这个设备存在于所有操作系统上，是标准文本输出的默认目的地。默认情况下，终端被配置为显示写入此设备的内容。使用这个单一目的地工作得很好，直到你有一个需要同时写入输出和程序功能细节的程序。当你想要写入日志信息时，你希望将其写入不同的目的地，这样你的输出和日志就不会混合在一起。
- en: To solve this problem, UNIX architects added a device called `stderr`. This
    device was created to be the default destination for logging. It allows developers
    to separate their programs’ output from their logging. For a user to see both
    the output and the logging when running a program, terminal consoles are configured
    to display what’s written to both `stdout` and `stderr`. But if your program only
    writes logs, then it’s common practice to write general logging information to
    `stdout` and errors or warnings to `stderr`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，UNIX架构师添加了一个名为`stderr`的设备。这个设备被创建为日志的默认目的地。它允许开发者将程序的输出与日志分离。为了用户在运行程序时能够看到输出和日志，终端控制台被配置为显示写入`stdout`和`stderr`的内容。但是，如果你的程序只写入日志，那么将一般日志信息写入`stdout`，错误或警告写入`stderr`是常见的做法。
- en: 8.2.1\. Log package
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1. 日志包
- en: Let’s start with the base functionality provided by the `log` package before
    you learn how to create your own custom loggers. The purpose of logging is to
    get a trace of what the program is doing, where it’s happening, and when. This
    is some of the information that you can write on every log line with some configuration.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学习如何创建自己的自定义日志记录器之前，让我们先看看`log`包提供的基功能。日志记录的目的是获取程序正在做什么、在哪里发生以及何时发生的跟踪信息。这是你可以通过一些配置写入每条日志行的一些信息。
- en: Listing 8.2\. Sample trace line
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2. 样本跟踪行
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In [listing 8.2](#ch08ex02) you see a log entry produced by the `log` package.
    This log entry contains a prefix, a datetime stamp, the full path to the source
    code writing to the log, the line of code performing the write, and finally the
    message. Let’s look at a program that allows you to configure the `log` package
    to write such a line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表8.2](#ch08ex02)中，你可以看到一个由`log`包生成的日志条目。这个日志条目包含一个前缀、一个日期时间戳、写入日志的源代码的完整路径、执行写入操作的代码行，以及最后的信息。让我们看看一个允许你配置`log`包以写入此类行的程序。
- en: Listing 8.3\. listing03.go
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3. listing03.go
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run the program from [listing 8.3](#ch08ex03), you should get something
    close to the same output from [listing 8.2](#ch08ex02). Let’s break down the code
    and see how it works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从[列表8.3](#ch08ex03)运行程序，你应该会得到与[列表8.2](#ch08ex02)相似的输出。让我们分解代码，看看它是如何工作的。
- en: 'Listing 8.4\. listing03.go: lines 08–11'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表8.4. listing03.go: 第08-11行'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On lines 08 through 11, we have a function called `init()`. This function is
    executed before `main()` as part of the program initialization. It’s common to
    set the log configuration inside of `init()` so the `log` package can be used
    immediately when the program starts. In our program on line 09, we set the string
    to be used as a prefix for each line. This should be a string that allows you
    to identify a log line over normal program output. Traditionally this string is
    written in capital letters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第08至11行，我们有一个名为`init()`的函数。这个函数作为程序初始化的一部分在`main()`之前执行。在`init()`中设置日志配置是常见的做法，这样程序启动时就可以立即使用`log`包。在我们的程序中，第09行设置了用作每行前缀的字符串。这个字符串应该是一个可以让你识别出日志行而不是普通程序输出的字符串。传统上，这个字符串是用大写字母书写的。
- en: There are several flags associated with the `log` package that control other
    information that can be written on each log line. The following listing shows
    the flags that currently exist.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与`log`包相关联有几个标志，它们控制可以写入每行日志的其他信息。以下列表显示了当前存在的标志。
- en: Listing 8.5\. golang.org/src/log/log.go
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5. golang.org/src/log/log.go
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Listing 8.5](#ch08ex05) comes right out of the source code for the `log` package.
    These flags are declared as constants, and the first constant in this block is
    called `Ldate`, which is declared with special syntax.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.5](#ch08ex05) 直接来自 `log` 包的源代码。这些标志被声明为常量，并且在这个块中的第一个常量被称作 `Ldate`，它使用特殊的语法声明。'
- en: Listing 8.6\. Declaration of the `Ldate` constant
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. `Ldate` 常量的声明
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `iota` keyword has a special purpose when it comes to declaring a block
    of constants. It instructs the compiler to duplicate the expression for every
    constant until the block ends or an assignment statement is found. Another function
    of the `iota` keyword is that the value of `iota` for each preceding constant
    gets incremented by 1, with an initial value of 0\. Let’s look at this more closely.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到声明一组常量时，`iota` 关键字具有特殊用途。它指示编译器对每个常量重复表达式，直到块结束或找到赋值语句。`iota` 关键字的另一个功能是，每个先前常量的
    `iota` 值会增加 1，初始值为 0。让我们更仔细地看看这一点。
- en: Listing 8.7\. Use of the keyword `iota`
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 关键字 `iota` 的使用
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Listing 8.7](#ch08ex07) shows what’s happening behind the scenes with the
    constant declarations. The `<<` operator performs a left bitwise shift of the
    bits represented by the value on the left side of the operator. In each case the
    bit pattern for the value of 1 is shifted to the left `iota` position. This has
    the effect of giving each constant its own unique bit position, which you’ll see
    is perfect when working with flags.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.7](#ch08ex07) 展示了常量声明背后的操作。`<<` 操作符执行操作符左侧值表示的位的左移位操作。在每种情况下，值为 1 的位模式都被移位到
    `iota` 位置。这起到了为每个常量赋予其独特位位置的作用，这在处理标志时是完美的。'
- en: The `LstdFlags` constant shows the purpose behind giving each constant its own
    unique bit position.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`LstdFlags` 常量显示了为什么每个常量都有其独特的位位置背后的目的。'
- en: Listing 8.8\. Declaration of the `LstdFlags` constant
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. `LstdFlags` 常量的声明
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In [listing 8.8](#ch08ex08) you see the `LstdFlags` constant break the `iota`
    chain because of the use of the assignment operator. The `LstdFlags` constant
    is assigned the value of `3`, thanks to the fact that the pipe operator (`|`)
    is used to `or` bits together. `Or`’ing bits is equivalent to joining bits so
    each individually set bit is then represented in the final value. When bits 1
    and 2 are `or`ed together, they form the value of `3`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.8](#ch08ex08) 中，你可以看到 `LstdFlags` 常量由于使用了赋值运算符而中断了 `iota` 链。`LstdFlags`
    常量被赋予了值 `3`，这得益于管道操作符 (`|`) 用于进行位或操作。位或操作相当于将位连接起来，因此每个单独设置的位在最终值中都有所表示。当位 1 和
    2 进行或操作时，它们形成值 `3`。
- en: Let’s look again at how we set the log flags we wanted applied.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们如何设置我们想要应用的日志标志。
- en: 'Listing 8.9\. listing03.go: lines 08–11'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.9\. listing03.go: 行 08–11'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we piped the `Ldate`, `Lmicroseconds`, and `Llongfile` flags together and
    passed the value of that operation to the `SetFlags` function. These flags, when
    piped together, represent the value `13` and bits 4, 3, and 1 (00001101). Since
    each constant represents an individual bit, flags can be joined together using
    the pipe operator to create a value that represents all the log options we want
    applied. The `log` package then takes that integer value we passed and inspects
    which bits are set to apply the correct attributes we requested.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `Ldate`、`Lmicroseconds` 和 `Llongfile` 标志一起管道化，并将该操作的值传递给 `SetFlags`
    函数。这些标志一起管道化时，代表值 `13` 和位 4、3 和 1（00001101）。由于每个常量代表一个单独的位，因此可以使用管道操作符将标志连接起来，以创建一个表示我们想要应用的所有日志选项的值。然后，`log`
    包会检查我们传递的整数值，以确定哪些位被设置，从而应用我们请求的正确属性。
- en: With the `log` package initialized, you can look at `main()` and see how to
    write messages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 `log` 包之后，你可以查看 `main()` 函数，了解如何写入消息。
- en: 'Listing 8.10\. listing03.go: lines 13–22'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.10\. listing03.go: 行 13–22'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Listing 8.10](#ch08ex10) shows how to write log messages using three different
    functions: `Println`, `Fatalln`, and `Panicln`. These functions have a format
    version, as well, that end with the letter `f` instead of the letters `ln`. The
    `Fatal` family of functions is used to write a log message and then terminate
    the program using the `os.Exit(1)` function call. The `Panic` family of functions
    is used to write a log message and then issue a panic, which unless recovered,
    will cause the program to terminate and stack trace. The `Print` family of functions
    is the standard way to write log messages.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.10](#ch08ex10) 展示了如何使用三个不同的函数：`Println`、`Fatalln` 和 `Panicln` 来写入日志消息。这些函数也有一个格式版本，以字母
    `f` 结尾而不是 `ln`。`Fatal` 函数族用于写入日志消息并使用 `os.Exit(1)` 函数调用终止程序。`Panic` 函数族用于写入日志消息并引发恐慌，除非恢复，否则将导致程序终止并显示堆栈跟踪。`Print`
    函数族是写入日志消息的标准方式。'
- en: One nice thing about the `log` package is that loggers are multigoroutine-safe.
    This means that multiple goroutines can call these functions from the same logger
    value at the same time without the writes colliding with each other. The standard
    logger and any customized logger you may create will have this attribute.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 包的一个优点是日志记录器是多goroutine安全的。这意味着多个goroutine可以同时从同一个日志记录器值调用这些函数，而不会相互冲突。标准日志记录器和您可能创建的任何自定义日志记录器都将具有此属性。'
- en: Now that you know how to use the `log` package and configure it, let’s explore
    how to create customized loggers so you can have different logging levels that
    can write logs to different destinations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何使用 `log` 包并对其进行配置，让我们探索如何创建自定义日志记录器，这样您就可以拥有不同日志级别，并将日志写入不同的目的地。
- en: 8.2.2\. Customized loggers
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 自定义日志记录器
- en: Creating customized loggers require that you create your own `Logger` type values.
    Each logger you create can be configured for a unique destination and set with
    its own prefix and flags. Let’s look at an example program that creates different
    `Logger` type pointer variables to support different logging levels.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义日志记录器需要您创建自己的 `Logger` 类型值。您创建的每个日志记录器都可以配置为独特的目的地，并设置其自己的前缀和标志。让我们看看一个示例程序，该程序创建不同的
    `Logger` 类型指针变量以支持不同的日志级别。
- en: Listing 8.11\. listing11.go
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. listing11.go
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Listing 8.11](#ch08ex11) shows a complete program that creates four different
    `Logger` type pointer variables. They’re named `Trace`, `Info`, `Warning`, and
    `Error`. Each variable is configured differently because of the importance each
    represents. Let’s break down the code so you can learn how all this works.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.11](#ch08ex11) 展示了一个完整的程序，该程序创建了四个不同的 `Logger` 类型指针变量。它们的名称分别是 `Trace`、`Info`、`Warning`
    和 `Error`。每个变量都根据其重要性进行了不同的配置。让我们分解代码，以便您可以了解这一切是如何工作的。'
- en: On lines 11 through 16 we declare the four `Logger` type pointer variables for
    our different logging levels.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 11 至 16 行，我们声明了四个 `Logger` 类型指针变量，用于我们的不同日志级别。
- en: 'Listing 8.12\. listing11.go: lines 11–16'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.12\. listing11.go: 行 11–16'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [listing 8.12](#ch08ex12) you see the declaration of the `Logger` type pointer
    variables. We’ve given each logger a short but descriptive variable name. Next,
    let’s look at the code in `init()` that creates and assigns the address of each
    `Logger` type value to each variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.12](#ch08ex12) 中，您可以看到 `Logger` 类型指针变量的声明。我们为每个日志记录器分配了一个简短但描述性的变量名。接下来，让我们看看
    `init()` 函数中的代码，该代码创建并分配每个 `Logger` 类型值的地址给每个变量。
- en: 'Listing 8.13\. listing11.go: lines 25–39'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.13\. listing11.go: 行 25–39'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To create each logger, we use the `New` function from the `log` package, which
    creates a properly initialized `Logger` type value. The `New` function returns
    the address to the newly created value. Before the `New` function can create a
    value, we need to pass it some parameters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建每个日志记录器，我们使用来自 `log` 包的 `New` 函数，该函数创建一个正确初始化的 `Logger` 类型值。`New` 函数返回新创建值的地址。在
    `New` 函数可以创建值之前，我们需要传递一些参数。
- en: Listing 8.14\. golang.org/src/log/log.go
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. golang.org/src/log/log.go
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Listing 8.14](#ch08ex14) shows the declaration of the `New` function from
    the source code for the `log` package. The first parameter is the destination
    we want the logger to write to. This is provided as a value that implements the
    `io.Writer` interface. The second parameter is the prefix that you saw before,
    and log flags comprise the final parameter.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.14](#ch08ex14) 展示了来自 `log` 包源代码的 `New` 函数的声明。第一个参数是我们希望日志记录器写入的目的地。这是一个实现了
    `io.Writer` 接口的价值。第二个参数是您之前看到的那个前缀，日志标志是最后一个参数。'
- en: In our program, the `Trace` logger uses the `Discard` variable from the `ioutil`
    package as the destination to write to.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，`Trace` 记录器使用 `ioutil` 包中的 `Discard` 变量作为写入目标。
- en: 'Listing 8.15\. listing11.go: lines 25–27'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.15\. listing11.go: 行 25–27'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Discard` variable has some very interesting properties.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Discard` 变量有一些非常有趣的属性。'
- en: Listing 8.16\. golang.org/src/io/ioutil/ioutil.go
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. golang.org/src/io/ioutil/ioutil.go
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Listing 8.16](#ch08ex16) shows the declaration of the `Discard` variable and
    the implementation surrounding it. The `Discard` variable is declared to be of
    interface type `io.Writer` and is given a value of `0` of type `devNull`. Anything
    written to this variable is discarded based on the implementation of the `Write`
    method for the `devNull` type. Using the `Discard` variable is a technique you
    can use to disable a logging level when the output for that level is not required.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.16](#ch08ex16) 展示了 `Discard` 变量的声明及其周围的实现。`Discard` 变量被声明为接口类型 `io.Writer`，并赋予了一个类型为
    `devNull` 的 `0` 值。任何写入此变量的内容都将根据 `devNull` 类型的 `Write` 方法实现被丢弃。使用 `Discard` 变量是一种技术，可以在不需要该级别的输出时禁用日志级别。'
- en: The `Info` and `Warning` loggers both use the `stdout` destination.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Info` 和 `Warning` 记录器都使用 `stdout` 目标。'
- en: 'Listing 8.17\. listing11.go: lines 29–35'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.17\. listing11.go: 行 29–35'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The declaration of the `Stdout` variable is also interesting.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stdout` 变量的声明也很有趣。'
- en: Listing 8.18\. golang.org/src/os/file.go
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. golang.org/src/os/file.go
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In [listing 8.18](#ch08ex18) you can see the declaration for the three variables
    that represent the standard destinations that exist on all operating systems:
    `Stdin`, `Stdout`, and `Stderr`. All these variables are declared to be pointers
    of type `File`, which implements the `io.Writer` interface. This leads us to the
    final logger, `Error`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.18](#ch08ex18) 中，你可以看到代表所有操作系统上存在的标准目标的三变量声明：`Stdin`、`Stdout` 和 `Stderr`。所有这些变量都被声明为
    `File` 类型的指针，该类型实现了 `io.Writer` 接口。这使我们来到了最终的记录器，`Error`。
- en: 'Listing 8.19\. listing11.go: lines 37–39'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.19\. listing11.go: 行 37–39'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In [listing 8.19](#ch08ex19) you can see that the first parameter to the `New`
    function comes from a special function called `MultiWriter` from the `io` package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.19](#ch08ex19) 中，你可以看到 `New` 函数的第一个参数来自 `io` 包中的一个特殊函数，称为 `MultiWriter`。
- en: Listing 8.20\. Declaration of the `MultiWriter` function in the `io` package
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.20\. `io` 包中 `MultiWriter` 函数的声明
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Listing 8.20](#ch08ex20) isolates the call to the `MultiWriter` function,
    which returns an interface type value of `io.Writer` that contains both the file
    that we opened and the `stderr` destination. The `MultiWriter` function is a variadic
    function that accepts any number of values that implement the `io.Writer` interface.
    The function returns a single `io.Writer` value that bundles all of the `io.Writer`
    values that are passed in. This allows functions like `log.New` to accept multiple
    writers within a single writer. Now when we write a log using the `Error` logger,
    the output will be written to both the file and `stderr`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.20](#ch08ex20) 将对 `MultiWriter` 函数的调用隔离出来，该函数返回一个包含我们打开的文件和 `stderr`
    目标的 `io.Writer` 接口类型值。`MultiWriter` 函数是一个可变参数函数，接受任何实现 `io.Writer` 接口值的数量。该函数返回一个单一的
    `io.Writer` 值，它捆绑了所有传入的 `io.Writer` 值。这允许像 `log.New` 这样的函数在单个写入器中接受多个写入器。现在当我们使用
    `Error` 记录器写入日志时，输出将被写入文件和 `stderr`。'
- en: Now that you know how to create custom loggers, let’s look at how you can use
    them to write messages.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建自定义记录器，让我们看看如何使用它们来写入消息。
- en: 'Listing 8.21\. listing11.go: lines 42–47'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.21\. listing11.go: 行 42–47'
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Listing 8.21](#ch08ex21) shows the `main()` function from [listing 8.11](#ch08ex11).
    On lines 43 through 46 we write a single message for each logger that we created.
    Each logger variable contains a set of methods that are identical to the set of
    functions that are implemented by the `log` package.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.21](#ch08ex21) 展示了 [列表 8.11](#ch08ex11) 中的 `main()` 函数。在第 43 到 46 行，我们为每个创建的记录器写入一条消息。每个记录器变量都包含一组与
    `log` 包实现的功能相同的函数。'
- en: Listing 8.22\. Declarations of the different logging methods
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.22\. 不同记录方法的声明
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Listing 8.22](#ch08ex22) shows all the methods that have been implemented
    for the `Logger` type.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.22](#ch08ex22) 展示了为 `Logger` 类型实现的所有方法。'
- en: 8.2.3\. Conclusion
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 结论
- en: The `log` package has been implemented with the long history and understanding
    of the purpose of logging and how it has been applied in practice. Writing output
    to `stdout` and logging to `stderr` has long been the tradition of many CLI-based
    programs. But when your program is only outputting logs, then using `stdout`,
    `stderr`, and files is perfectly acceptable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 包是基于对日志目的的长期历史理解和实际应用而实现的。将输出写入 `stdout` 和将日志记录到 `stderr` 已成为许多基于 CLI
    的程序的传统。但当你的程序只输出日志时，使用 `stdout`、`stderr` 和文件是完全可接受的。'
- en: The `log` package from the standard library has everything you need for logging
    and its use is recommended. You can trust the implementation not only because
    it’s part of the standard library, but because it’s used widely by the community.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 `log` 包提供了你进行日志记录所需的一切，并且推荐使用。你可以信任其实现，不仅因为它属于标准库，而且还因为它被社区广泛使用。
- en: 8.3\. Encoding/Decoding
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 编码/解码
- en: Many applications, whether they’re using databases, making web calls, or working
    within a distributed system, need to consume and publish data. If your application
    is working with either XML or JSON, the standard library has packages called `xml`
    and `json` that make working with these data formats trivial. If you have your
    own data formats that need to be encoded and decoded, the implementation of these
    packages is a great road map of how to implement your own packages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序，无论它们是使用数据库、进行网络调用还是在分布式系统中工作，都需要消费和发布数据。如果你的应用程序正在处理 XML 或 JSON，标准库中有名为
    `xml` 和 `json` 的包，这些包使得处理这些数据格式变得非常简单。如果你有自己的数据格式需要编码和解码，这些包的实现是实施你自己的包的一个很好的路线图。
- en: Working with and using JSON is more common nowadays than working with XML. This
    is primarily because using JSON requires less markup than working with XML. This
    means less data per message needs to be sent over the network, which helps with
    the overall performance of the system. Also, JSON can be transformed into BSON
    (Binary JavaScript Object Notation), which reduces the size of each message even
    further. In view of this, we’ll explore how to consume and publish JSON in Go
    applications. But working with XML is very similar.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在处理和使用 JSON 比处理 XML 更常见。这主要是因为使用 JSON 比使用 XML 需要更少的标记。这意味着每条消息需要发送的数据更少，这有助于系统的整体性能。此外，JSON
    可以转换为 BSON（Binary JavaScript Object Notation），这进一步减少了每条消息的大小。鉴于这一点，我们将探讨如何在 Go
    应用程序中消费和发布 JSON。但处理 XML 非常相似。
- en: 8.3.1\. Decoding JSON
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 解码 JSON
- en: The first aspect of working with JSON we’ll explore is using the `NewDecoder`
    function and `Decode` method from the `json` package. If you’re consuming JSON
    from a web response or a file, this is the function and method you want to use.
    Let’s look at an example that works with the `http` package to perform a `Get`
    request against the Google search API that returns results in JSON. The next listing
    shows what the response looks like.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索的第一个与 JSON 一起工作的方面是使用 `json` 包中的 `NewDecoder` 函数和 `Decode` 方法。如果你正在从网络响应或文件中消费
    JSON，这就是你想要使用的函数和方法。让我们看看一个使用 `http` 包执行针对返回 JSON 结果的 Google 搜索 API 的 `Get` 请求的示例。下一个列表显示了响应的外观。
- en: Listing 8.23\. Google search API sample JSON response
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.23\. Google 搜索 API 示例 JSON 响应
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here’s the example that retrieves and decodes the response into a struct type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，它检索并解码响应到一个结构体类型。
- en: Listing 8.24\. listing24.go
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.24\. listing24.go
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code on line 37 in [listing 8.24](#ch08ex24) shows a program that makes
    an HTTP `Get` call that retrieves a JSON document from Google. Then, using the
    `NewDecoder` function and `Decode` method on line 46, the JSON document from the
    response is decoded into a variable of the struct type that’s declared on line
    26\. On line 52 the value of the variable is written to `stdout`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [listing 8.24](#ch08ex24) 中的第 37 行的代码显示了一个程序，该程序执行 HTTP `Get` 调用以从 Google
    获取 JSON 文档。然后，在第 46 行使用 `NewDecoder` 函数和 `Decode` 方法，将响应中的 JSON 文档解码到第 26 行声明的结构体类型的变量中。在第
    52 行，变量的值被写入 `stdout`。
- en: If you look at the type declarations for `gResponse` and `gResult` on lines
    26 and 14, you’ll notice strings declared at the end of each field. These are
    called *tags*, and they’re the mechanism to provide metadata about the field mapping
    between the JSON document and the struct type. If tags are not present, the decoding
    and encoding process will attempt to match against the field names directly in
    a case-insensitive way. When a mapping can’t be made, the field in the struct
    value will contain its zero value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看第 26 行和第 14 行的 `gResponse` 和 `gResult` 的类型声明，你会注意到每个字段末尾都声明了字符串。这些被称为 *标签*，它们是提供
    JSON 文档和结构体类型之间字段映射元数据的机制。如果没有标签，解码和编码过程将尝试以不区分大小写的方式直接匹配字段名称。当无法进行映射时，结构体值中的字段将包含其零值。
- en: Thanks to the standard library, all of the technical aspects of performing HTTP
    `Get` calls and decoding JSON into struct types are taken care of. Let’s look
    at the declaration of both the `NewDecoder` function and `Decode` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢标准库，执行 HTTP `Get` 调用和将 JSON 解码为结构体类型的所有技术细节都由它处理。让我们看看 `NewDecoder` 函数和 `Decode`
    方法的声明。
- en: Listing 8.25\. golang.org/src/encoding/json/stream.go
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.25\. golang.org/src/encoding/json/stream.go
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In [listing 8.25](#ch08ex25) you can see that the `NewDecoder` function accepts
    any value whose type implements the `io.Reader` interface. In the next section
    you’ll learn more about the `io.Reader` and `io.Writer` interfaces. For now, understand
    that many different types from within the standard library implement these interfaces,
    including types from the `http` package. When types implement these particular
    interfaces, you get a lot of support and functionality for free.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.25](#ch08ex25) 中，你可以看到 `NewDecoder` 函数接受任何实现了 `io.Reader` 接口类型的值。在下一节中，你将了解更多关于
    `io.Reader` 和 `io.Writer` 接口的内容。现在，理解标准库中的许多不同类型实现了这些接口，包括来自 `http` 包的类型。当类型实现这些特定接口时，你将获得许多免费的支持和功能。
- en: The `NewDecoder` function returns a pointer value of type `Decoder`. Since Go
    supports compound statement calls, the return value from the `NewDecoder` function
    can be used to call the `Decode` method immediately without the need to declare
    a variable first. In [listing 8.25](#ch08ex25) you can see that the `Decode` method
    accepts a value of type `interface{}` and returns an error.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewDecoder` 函数返回一个类型为 `Decoder` 的指针值。由于 Go 支持复合语句调用，`NewDecoder` 函数的返回值可以直接用来调用
    `Decode` 方法，而不需要先声明一个变量。在 [列表 8.25](#ch08ex25) 中，你可以看到 `Decode` 方法接受一个类型为 `interface{}`
    的值，并返回一个错误。'
- en: As described in [chapter 5](kindle_split_013.html#ch05), the empty interface
    is an interface implemented by every type. This means the `Decode` method can
    accept values of any type. Through the use of reflection, the `Decode` method
    will inspect the type information about the value you pass in. Then as it reads
    the JSON response, it will decode the response into a value of that type. This
    means you don’t need to create values yourself; `Decode` can do this for you.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 5 章](kindle_split_013.html#ch05) 所述，空接口是每个类型都实现的接口。这意味着 `Decode` 方法可以接受任何类型的值。通过使用反射，`Decode`
    方法将检查你传递的值的类型信息。然后，当它读取 JSON 响应时，它将解码响应到该类型的值。这意味着你不需要自己创建值；`Decode` 可以为你完成这项工作。
- en: Listing 8.26\. Use of the `Decode` method
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.26\. `Decode` 方法的使用
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In [listing 8.26](#ch08ex26) we pass the address of a pointer variable of type
    `gResponse`, with the value of `nil`, to the `Decode` method. After the method
    call, the value of the pointer variable will be assigned to a value of type `gResponse`
    and initialized based on the JSON document being decoded.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.26](#ch08ex26) 中，我们将类型为 `gResponse` 的指针变量的地址（值为 `nil`）传递给 `Decode` 方法。方法调用后，指针变量的值将被分配一个类型为
    `gResponse` 的值，并根据正在解码的 JSON 文档进行初始化。
- en: Sometimes the JSON documents you’re working with come to you as a `string` value.
    In these cases, you need to convert the `string` into a `byte` slice (`[]byte`)
    and use the `Unmarshal` function from the `json` package.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你正在处理的 JSON 文档以 `string` 值的形式出现。在这些情况下，你需要将 `string` 转换为 `byte` 切片 (`[]byte`)，并使用
    `json` 包中的 `Unmarshal` 函数。
- en: Listing 8.27\. listing27.go
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.27\. listing27.go
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In [listing 8.27](#ch08ex27) we have an example that takes a JSON document inside
    of a `string` variable and uses the `Unmarshal` function to decode the JSON into
    a struct type value. If you run the program, you’ll get the following output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.27](#ch08ex27) 中，我们有一个示例，它将一个 JSON 文档放在一个 `string` 变量中，并使用 `Unmarshal`
    函数将 JSON 解码为结构体类型的值。如果你运行程序，你会得到以下输出。
- en: Listing 8.28\. Output for listing27.go
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.28\. listing27.go 的输出
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sometimes it’s not possible to declare a struct type and you need more flexibility
    to work with the JSON document. In these cases you can decode or unmarshal the
    JSON document into a `map` variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时无法声明一个结构体类型，你需要更多的灵活性来处理 JSON 文档。在这些情况下，你可以将 JSON 文档解码或反序列化为 `map` 变量。
- en: Listing 8.29\. listing29.go
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.29\. listing29.go
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In [listing 8.29](#ch08ex29) we’ve changed the program from [listing 8.27](#ch08ex27)
    to use a `map` variable instead of our struct type variable. The `map` variable
    is declared as a map with a key of type `string` and a value of type `interface{}`.
    This means the `map` can store any type of value for any given key. Though this
    gives you great flexibility when working with JSON documents, it has one minor
    drawback. Look at the syntax required to access the `home` field from the `contact`
    subdocument.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.29](#ch08ex29) 中，我们将程序从 [列表 8.27](#ch08ex27) 更改为使用 `map` 变量而不是我们的结构体类型变量。`map`
    变量被声明为一个具有 `string` 类型键和 `interface{}` 类型值的映射。这意味着 `map` 可以为任何给定的键存储任何类型的值。虽然这在你处理
    JSON 文档时提供了很大的灵活性，但它有一个小的缺点。看看访问 `contact` 子文档中的 `home` 字段的语法要求。
- en: Listing 8.30\. Syntax for accessing a field from an unmarshaled map
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.30\. 从反序列化映射中访问字段的语法
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because the value for each key is of type `interface{}`, you need to convert
    the value to the proper native type in order to work with the value. [Listing
    8.30](#ch08ex30) shows how you need to convert the value of the `contact` key
    to another map with a key of type `string` and a value of type `interface{}`.
    This can make using maps that contain JSON documents sometimes unfriendly to work
    with. But if you never need to dig into the JSON documents you’re working with
    or you plan to do very little manipulation, using a `map` can be fast, and then
    there’s no need to declare new types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个键的值都是 `interface{}` 类型，你需要将值转换为适当的原生类型才能与该值一起工作。[列表 8.30](#ch08ex30) 展示了你需要如何将
    `contact` 键的值转换为另一个具有 `string` 类型键和 `interface{}` 类型值的映射。这可能会使得使用包含 JSON 文档的映射变得不友好。但是，如果你从未需要深入挖掘你正在处理的
    JSON 文档，或者你计划进行很少的修改，使用 `map` 可以更快，而且不需要声明新的类型。
- en: 8.3.2\. Encoding JSON
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 编码 JSON
- en: The second aspect of working with JSON we’ll explore is using the `MarshalIndent`
    function from the `json` package. This comes in handy when you want to publish
    a pretty-printed JSON document from a Go `map` or `struct` type value. *Marshaling*
    is the process of transforming data into a JSON string. Here’s an example that
    converts a `map` type into a JSON string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的与 JSON 一起工作的第二个方面是使用 `json` 包中的 `MarshalIndent` 函数。当你想从 Go `map` 或 `struct`
    类型值发布格式化的 JSON 文档时，这非常有用。*序列化*是将数据转换为 JSON 字符串的过程。以下是一个将 `map` 类型转换为 JSON 字符串的示例。
- en: Listing 8.31\. listing31.go
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.31\. listing31.go
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Listing 8.31](#ch08ex31) shows how to use the `MarshalIndent` function from
    the `json` package to convert a `map` to a `JSON` string. The `MarshalIndent`
    function returns a byte slice that represents the JSON string and an error value.
    Here’s a look at the declaration of the `MarshalIndent` function from the `json`
    package.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.31](#ch08ex31) 展示了如何使用 `json` 包中的 `MarshalIndent` 函数将 `map` 转换为 `JSON`
    字符串。`MarshalIndent` 函数返回一个表示 JSON 字符串的字节切片和一个错误值。以下是对 `json` 包中 `MarshalIndent`
    函数声明的查看。'
- en: Listing 8.32\. golang.org/src/encoding/json/encode.go
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.32\. golang.org/src/encoding/json/encode.go
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see the use of the empty interface type again as the parameter to the
    `MarshalIndent` function. The `MarshalIndent` function uses reflection to determine
    how to transform the `map` type into a JSON string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `MarshalIndent` 函数的参数中再次看到空接口类型的使用。`MarshalIndent` 函数使用反射来确定如何将 `map` 类型转换为
    JSON 字符串。
- en: If you don’t need the pretty-print formatting for your JSON encoding, the `json`
    package also provides a function called `Marshal`. This function is good for producing
    JSON that could be returned in a network response, like a web API. The `Marshal`
    function works the same as the `MarshalIndent` function, but without the parameters
    for `prefix` and `indent`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要为你的 JSON 编码使用漂亮的打印格式，`json` 包还提供了一个名为 `Marshal` 的函数。这个函数非常适合生成可以返回在网络响应中，如
    Web API 的 JSON。`Marshal` 函数的工作方式与 `MarshalIndent` 函数相同，但没有 `prefix` 和 `indent`
    参数。
- en: 8.3.3\. Conclusion
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 结论
- en: If you’re working with JSON or even XML, all the support you need to decode,
    unmarshal, and marshal data in these formats is provided to you already by the
    standard library. With each new release of Go, these packages get faster and faster,
    making working with JSON and XML a great choice. Thanks to the reflection package
    and the support for tags, it’s easy to declare `struct` types and map those fields
    to the document fields you need to consume and publish. Since the `json` and `xml`
    packages provide support for the `io.Reader` and `io.Writer` interfaces, it doesn’t
    matter where your JSON and XML documents are coming from. Everything is supported
    to make working with JSON and XML painless.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理 JSON 或甚至 XML，标准库已经为你提供了解码、反序列化和序列化这些格式数据的所有支持。随着 Go 的每个新版本发布，这些包变得越来越快，使得使用
    JSON 和 XML 成为一种很好的选择。多亏了反射包和标签支持，声明 `struct` 类型并将这些字段映射到你需要消费和发布的文档字段变得非常容易。由于
    `json` 和 `xml` 包为 `io.Reader` 和 `io.Writer` 接口提供了支持，所以你的 JSON 和 XML 文档来自哪里并不重要。所有支持都已提供，使得处理
    JSON 和 XML 变得轻松愉快。
- en: 8.4\. Input and output
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4. 输入和输出
- en: One of the things that makes the UNIX-based operating systems so great is the
    idea that the output of one program can be the input for another. This philosophy
    has created a suite of simple programs that do only one thing and do it really
    well. Then, by composing programs together, scripts can be created to do some
    amazing things. In this world the `stdout` and `stdin` devices serve as the conduits
    to move data between processes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 基础操作系统之所以如此出色，其中一个原因就是程序输出可以作为另一个程序的输入。这种理念创造了一系列只做一件事并且做得非常好的简单程序。然后，通过组合程序，可以创建脚本来完成一些惊人的事情。在这个世界中，`stdout`
    和 `stdin` 设备作为在进程之间移动数据的通道。
- en: This same idea has been extended to the `io` package, and the functionality
    that it provides is amazing. The package supports working with streams of data
    very efficiently, regardless of what the data is, where it’s coming from, or where
    it’s going. Instead of `stdout` and `stdin`, you have two interfaces called `io.Writer`
    and `io.Reader`. Values from types that implement these interfaces can be used
    against all the functionality provided by the `io` package or any function and
    method in any other package that also accepts values of these interface types.
    That’s the real beauty of creating functionality and APIs from interfaces types.
    Developers can compose on top of existing functionality, take advantage of what
    exists, and focus on the business problems they’re trying to solve.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个同样的想法也被扩展到了 `io` 包中，它提供的功能非常出色。无论数据是什么，来自哪里，还是去向何方，该包都支持非常高效地处理数据流。你不再有 `stdout`
    和 `stdin`，而是有两个接口，称为 `io.Writer` 和 `io.Reader`。实现这些接口的类型值可以用于 `io` 包提供的所有功能，或者任何其他包中接受这些接口类型值的函数和方法。这就是从接口类型创建功能和
    API 的真正美妙之处。开发者可以在现有功能之上进行组合，利用现有功能，并专注于他们试图解决的商业问题。
- en: With this in mind, let’s start by looking at the declaration for the `io.Writer`
    and `io.Reader` interfaces and then examine code examples that showcase some of
    the amazing functionality of the `io` package.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，让我们首先看看 `io.Writer` 和 `io.Reader` 接口的声明，然后检查一些展示 `io` 包惊人功能的代码示例。
- en: 8.4.1\. Writer and Reader interfaces
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1. 写入器和读取器接口
- en: The `io` package is built around working with values from types that implement
    the `io.Writer` and `io.Reader` interfaces. The functions and methods that make
    up the `io` package have no understanding about the type of data nor how that
    data is physically read and written. This is thanks to the abstraction that the
    `io.Writer` and `io.Reader` interfaces provide. Let’s start by looking at the
    declaration of the `io.Writer` interface.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`io` 包的设计是围绕处理实现 `io.Writer` 和 `io.Reader` 接口类型的值。组成 `io` 包的函数和方法对数据的类型以及数据是如何物理上读取和写入的没有任何理解。这得益于
    `io.Writer` 和 `io.Reader` 接口提供的抽象。让我们首先看看 `io.Writer` 接口的声明。'
- en: Listing 8.33\. Declaration of the `io.Writer` interface
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.33. `io.Writer` 接口的声明
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Listing 8.33](#ch08ex33) shows the declaration of the `io.Writer` interface.
    The interface declares a single method called `Write` that accepts a `byte` slice
    and returns two values. The first value is the number of bytes written, and the
    second value is an `error`. The rules for implementing this method are as follows.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8.33](#ch08ex33)展示了`io.Writer`接口的声明。该接口声明了一个名为`Write`的单个方法，它接受一个`byte`切片并返回两个值。第一个值是写入的字节数，第二个值是一个`error`。实现此方法的规则如下。'
- en: Listing 8.34\. Documentation for the `io.Writer` interface
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.34\. `io.Writer`接口的文档
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The rules in [listing 8.34](#ch08ex34) come from the standard library. They
    mean that the implementation of the `Write` method should attempt to write the
    entire length of the `byte` slice that’s passed in. But if that isn’t possible,
    then the method must return an error. The number of bytes reported as written
    can be less than the length of the `byte` slice, but never more. Finally, the
    `byte` slice must never be modified in any way.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8.34](#ch08ex34)中的规则来自标准库。这意味着`Write`方法的实现应该尝试写入传入的`byte`切片的整个长度。如果不可能，则该方法必须返回一个错误。报告为写入的字节数可以小于`byte`切片的长度，但不能更多。最后，`byte`切片在任何情况下都不能被修改。'
- en: Let’s look at the declaration of the `Reader` interface.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Reader`接口的声明。
- en: Listing 8.35\. Declaration of the `io.Reader` interface
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.35\. `io.Reader`接口的声明
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `io.Reader` interface in [listing 8.35](#ch08ex35) declares a single method,
    `Read`, that accepts a `byte` slice and returns two values. The first value is
    the number of bytes read and the second value is an `error`. The rules for implementing
    this method are as follows.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8.35](#ch08ex35)中的`io.Reader`接口声明了一个名为`Read`的单个方法，它接受一个`byte`切片并返回两个值。第一个值是读取的字节数，第二个值是一个`error`。实现此方法的规则如下。'
- en: Listing 8.36\. Documentation for the `io.Reader` interface
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.36\. `io.Reader`接口的文档
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are four rules listed in the standard library about implementing the `Read`
    method. The first rule states that the implementation should attempt to read the
    entire length of the `byte` slice that’s passed in. It’s okay to read less than
    the entire length, and it shouldn’t wait to read the entire length if that much
    data isn’t available at the time of the call.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中列出了关于实现`Read`方法的四个规则。第一条规则指出，实现应该尝试读取传入的`byte`切片的整个长度。读取少于整个长度是可以的，如果调用时没有那么多数据，则不需要等待读取整个长度。
- en: The second rule provides guidance about end of file (EOF) read conditions. When
    the last byte is read, two options are available. `Read` either returns the final
    bytes with the proper count and `EOF` for the error value, or returns the final
    bytes with the proper count and `nil` for the error value. In the latter case,
    the next read must return no bytes with the count of 0 and `EOF` for the error
    value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则提供了关于文件结束（EOF）读取条件的指导。当读取最后一个字节时，有两种选择。`Read`方法要么返回带有正确计数的最终字节和`EOF`作为错误值，要么返回带有正确计数的最终字节和`nil`作为错误值。在后一种情况下，下一次读取必须返回没有字节的计数为0和`EOF`作为错误值。
- en: The third rule is a suggestion for those who make the `Read` call. Any time
    the `Read` method returns bytes, those bytes should be processed first before
    checking the error value for an EOF or other error value. Finally, the fourth
    rule requests that implementations of the `Read` method never return a 0 byte
    read count with an error value of `nil`. Reads that result in no bytes read should
    always return an error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条规则是为那些发起`Read`调用的人提供的建议。每次`Read`方法返回字节时，应该首先处理这些字节，然后再检查EOF或其他错误值。最后，第四条规则要求`Read`方法的实现永远不要返回0字节读取计数和`nil`错误值。没有读取的字节应该始终返回一个错误。
- en: Now that you know what the `io.Writer` and `io.Reader` interfaces look like
    and how they’re expected to behave, let’s look at some examples of how you can
    use these interfaces and the `io` package in your programs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了`io.Writer`和`io.Reader`接口的样子以及它们应该如何表现，让我们看看一些如何在你的程序中使用这些接口和`io`包的例子。
- en: 8.4.2\. Working together
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 协同工作
- en: This example shows how different packages from the standard library work together
    by providing support for values from types that implement the `io.Writer` interface.
    The example uses the `bytes`, `fmt`, and `os` packages to buffer, concatenate,
    and write a string to `stdout`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了标准库中不同包是如何通过为实现`io.Writer`接口的类型提供支持而协同工作的。该例子使用了`bytes`、`fmt`和`os`包来缓冲、连接字符串并将字符串写入`stdout`。
- en: Listing 8.37\. listing37.go
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.37\. listing37.go
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When you run the program in [listing 8.37](#ch08ex37), you’ll get the following
    output.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [列表 8.37](#ch08ex37) 中运行程序时，你会得到以下输出。
- en: Listing 8.38\. Output for listing37.go
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.38\. listing37.go 的输出
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This program is using three packages from the standard library to write “Hello
    World!” to the terminal window. The program starts on line 15 by declaring a variable
    of type `Buffer` from the `bytes` package, which is initialized to its zero value.
    On line 16 a `byte` slice is created and initialized with the string `"Hello"`.
    The `byte` slice is passed into the `Write` method and becomes the initial content
    for the buffer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序正在使用标准库中的三个包将 “Hello World!” 写入终端窗口。程序从第 15 行开始，声明了一个来自 `bytes` 包的 `Buffer`
    类型变量，并将其初始化为其零值。在第 16 行创建了一个 `byte` 切片，并用字符串 `"Hello"` 初始化。`byte` 切片被传递到 `Write`
    方法中，成为缓冲区的初始内容。
- en: Line 20 uses the `Fprintf` function from the `fmt` package to append the string
    `"World!"` to the buffer. Let’s look at the declaration of the `Fprintf` function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第 20 行使用 `fmt` 包中的 `Fprintf` 函数将字符串 `"World!"` 追加到缓冲区中。让我们看看 `Fprintf` 函数的声明。
- en: Listing 8.39\. golang.org/src/fmt/print.go
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.39\. golang.org/src/fmt/print.go
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What’s important to note is the first parameter of the `Fprintf` function. It
    accepts values from types that implement the `io.Writer` interface. This means
    that the `Buffer` type from the `bytes` package must implement this interface
    since we’re able to pass the address of a variable of that type through. In the
    source code for the `bytes` package, we should then find the `Write` method declared
    for the `Buffer` type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要一点是 `Fprintf` 函数的第一个参数。它接受实现了 `io.Writer` 接口类型的值。这意味着 `bytes` 包中的 `Buffer`
    类型必须实现此接口，因为我们能够通过传递该类型变量的地址。在 `bytes` 包的源代码中，我们应该找到为 `Buffer` 类型声明的 `Write` 方法。
- en: Listing 8.40\. golang.org/src/bytes/buffer.go
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.40\. golang.org/src/bytes/buffer.go
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Listing 8.40](#ch08ex40) shows the current implementation of the `Write` method
    for the `Buffer` type that implements the `io.Writer` interface. Because of the
    implementation of this method, we can pass pointers of type `Buffer` as the first
    parameter to `Fprintf`. We use the `Fprintf` function in our example to append
    the string `"World!"` to the internal buffer of the `Buffer` type variable via
    the implementation of the `Write` method.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.40](#ch08ex40) 展示了实现了 `io.Writer` 接口的 `Buffer` 类型的 `Write` 方法的当前实现。由于此方法的实现，我们可以将
    `Buffer` 类型指针作为 `Fprintf` 的第一个参数传递。我们在示例中使用 `Fprintf` 函数通过 `Write` 方法的实现将字符串 `"World!"`
    追加到 `Buffer` 类型变量的内部缓冲区中。'
- en: Let’s review the last line of [listing 8.37](#ch08ex37), which writes the entire
    buffer to `stdout`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾 [列表 8.37](#ch08ex37) 的最后一行，该行将整个缓冲区写入 `stdout`。
- en: 'Listing 8.41\. listing37.go: lines 22–25'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.41\. listing37.go: 行 22–25'
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: On line 24 of [listing 8.37](#ch08ex37), the contents of the `Buffer` type variable
    are written to `stdout` using the `WriteTo` method. This method accepts a value
    that implements the `io.Writer` interface. In our program we pass the value of
    the `Stdout` variable from the `os` package.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.37](#ch08ex37) 的第 24 行，`Buffer` 类型变量的内容使用 `WriteTo` 方法写入 `stdout`。此方法接受一个实现了
    `io.Writer` 接口的对象。在我们的程序中，我们传递了来自 `os` 包的 `Stdout` 变量的值。
- en: Listing 8.42\. golang.org/src/os/file.go
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.42\. golang.org/src/os/file.go
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The declaration of these variables comes from the type returned by the `NewFile`
    function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的声明来自 `NewFile` 函数返回的类型。
- en: Listing 8.43\. golang.org/src/os/file_unix.go
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.43\. golang.org/src/os/file_unix.go
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see in [listing 8.43](#ch08ex43), the `NewFile` function returns
    a pointer of type `File`. This is the type of the `Stdout` variable. Since we
    can pass pointers of this type as a parameter to the `WriteTo` method, it must
    implement the `io.Writer` interface. In the source code for the `os` package,
    we should find the `Write` method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [列表 8.43](#ch08ex43) 中看到的，`NewFile` 函数返回一个 `File` 类型的指针。这是 `Stdout` 变量的类型。由于我们可以将此类型的指针作为参数传递给
    `WriteTo` 方法，因此它必须实现 `io.Writer` 接口。在 `os` 包的源代码中，我们应该找到 `Write` 方法。
- en: Listing 8.44\. golang.org/src/os/file.go
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.44\. golang.org/src/os/file.go
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Sure enough, [listing 8.44](#ch08ex44) shows the implementation of the `io.Writer`
    interface for pointers of type `File`. Look again at line 24 from [listing 8.37](#ch08ex37).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，[列表 8.44](#ch08ex44) 展示了 `File` 类型指针的 `io.Writer` 接口实现。再次查看 [列表 8.37](#ch08ex37)
    中的第 24 行。
- en: 'Listing 8.45\. listing37.go: lines 22–25'
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 8.45\. listing37.go: 行 22–25'
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You see that the `WriteTo` method is able to write the contents of the buffer
    to `stdout` which results in the string `"Hello World!"` being displayed on our
    terminal window. The method will use the implementation of the `Write` method
    from the `File` type via the interface value.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`WriteTo`方法能够将缓冲区的内容写入`stdout`，这导致字符串`"Hello World!"`在我们的终端窗口中显示。该方法将通过接口值使用`File`类型的`Write`方法实现。
- en: This example shows the beauty of interfaces and the power they bring to the
    language. Thanks to the implementation of the interface by both the `bytes.Buffer`
    and `os.File` types, we were able to reuse functionality in the standard library
    and have these types work together to implement a solution. Next let’s look at
    an example that’s a bit more practical.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了接口的美丽之处以及它们为语言带来的强大功能。多亏了`bytes.Buffer`和`os.File`类型对接口的实现，我们能够重用标准库中的功能，并使这些类型协同工作以实现解决方案。接下来，让我们看看一个更实用的例子。
- en: 8.4.3\. Simple curl
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.3. 简单的curl
- en: A command-line tool called `curl` can be found on both Linux and Mac OS X systems.
    The tool allows you to specify a URL, and it will perform an HTTP request and
    save the content. By using the `http`, `io`, and `os` packages, you can write
    your own version of `curl` in just a few lines of code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和Mac OS X系统上都可以找到一个名为`curl`的命令行工具。该工具允许您指定一个URL，然后执行HTTP请求并保存内容。通过使用`http`、`io`和`os`包，您只需几行代码就可以编写自己的`curl`版本。
- en: Let’s take a look at an example that implements a basic version of `curl`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实现`curl`基本版本的例子。
- en: Listing 8.46\. listing46.go
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.46. listing46.go
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[Listing 8.46](#ch08ex46) shows a very bare-bones implementation of `curl`
    that can be used to download, display, and save the content of any HTTP `Get`
    request. The example will write the response to a file and to `stdout` at the
    same time. To keep the example small, the program doesn’t check for valid command-line
    arguments nor provide switches for advanced options.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8.46](#ch08ex46)展示了`curl`一个非常基础的实现，可以用来下载、显示和保存任何HTTP `Get`请求的内容。该示例将同时将响应写入文件和`stdout`。为了保持示例的简洁，程序不会检查有效的命令行参数也不提供高级选项的开关。'
- en: On line 15 the program takes the first argument from the command line and performs
    an HTTP `Get`. If the first argument is a URL and there are no errors, the variable
    `r` contains the response. On line 21 we open a file based on the second command-line
    parameter. If we’re successful in opening the file, then on line 25 we schedule
    the closing of the file with the `defer` statement.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15行，程序从命令行获取第一个参数并执行HTTP `Get`操作。如果第一个参数是URL且没有错误，变量`r`将包含响应。在第21行，我们根据第二个命令行参数打开一个文件。如果我们成功打开文件，那么在第25行，我们使用`defer`语句安排关闭文件。
- en: Since we want to write the content of the request to both `stdout` and to our
    file, on line 29 we combine the file and `stdout` values together into a single
    `io.Writer` value by using the `MultiWriter` function from the `io` package. On
    line 33 we use the `Copy` function from the `io` package to read the content from
    the response body and to write that to both destinations. With one call to `Copy`,
    thanks to the value provided by the `MultiWriter` function we can use a single
    call that writes the content to both destinations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望将请求内容同时写入`stdout`和我们的文件，所以在第29行，我们使用`io`包中的`MultiWriter`函数将文件和`stdout`值组合成一个单一的`io.Writer`值。在第33行，我们使用`io`包中的`Copy`函数从响应体中读取内容，并将其写入两个目的地。通过一次调用`Copy`，多亏了`MultiWriter`函数提供的值，我们可以使用单个调用将内容写入两个目的地。
- en: Thanks to the support already provided by the `io` package and the implementation
    of the `io.Writer` and `io.Reader` interfaces by the `http` and `os` packages,
    we don’t need to write any code to perform these lower-level functions. We can
    leverage everything that already exists and just focus on the problem we’re trying
    to solve. If we support these interfaces with our own types, we get a huge amount
    of functionality for free.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`io`包已经提供的支持以及`http`和`os`包对`io.Writer`和`io.Reader`接口的实现，我们不需要编写任何代码来执行这些底层功能。我们可以利用已经存在的一切，只需专注于我们试图解决的问题。如果我们用自己的类型支持这些接口，我们将获得大量的免费功能。
- en: 8.4.4\. Conclusion
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.4. 结论
- en: There’s an incredible amount of functionality that can be found in the `io`
    package, and it can all be accessed through values from types that implement the
    `io.Writer` and `io.Reader` interfaces. Other packages such as the `http` package
    follow a similar pattern, declaring interfaces as part of the packages API and
    providing support for using the `io` package as well. It’s worth your time to
    explore what’s provided by the standard library and how it’s implemented—not only
    to save you from reinventing the wheel, but also to learn idiomatic Go from the
    language designers for your own packages and APIs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`io`包中可以找到大量的功能，并且所有这些功能都可以通过实现`io.Writer`和`io.Reader`接口的类型值来访问。其他包，如`http`包，遵循类似的模式，将接口作为包API的一部分进行声明，并提供对使用`io`包的支持。花时间去探索标准库提供了什么以及它是如何实现的，不仅可以帮助你避免重复造轮子，还可以从语言设计者那里学习到为你的包和API编写惯用Go语言的方法。
- en: 8.5\. Summary
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5. 摘要
- en: The standard library comes with special guarantees and is widely used by the
    community.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库提供了特殊的保证，并且被社区广泛使用。
- en: Using packages from the standard library makes it easier to manage and trust
    your code.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准库中的包可以更容易地管理和信任你的代码。
- en: Well over 100 packages are organized within 38 different categories.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过100个包被组织在38个不同的类别中。
- en: The `log` package from the standard library has everything you need for logging.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库中的`log`包包含了你进行日志记录所需的一切。
- en: The standard library has two packages called `xml` and `json` that make working
    with these data formats trivial.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库中有两个名为`xml`和`json`的包，它们使得处理这些数据格式变得非常简单。
- en: The `io` package supports working with streams of data very efficiently.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io`包支持非常高效地处理数据流。'
- en: Interfaces allow your code to compose with existing functionality.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口允许你的代码与现有功能进行组合。
- en: Reading code from the standard library is a great way to get a feel for idiomatic
    Go.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读标准库中的代码是了解惯用Go语言的好方法。
