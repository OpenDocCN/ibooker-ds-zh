- en: Chapter 8\. Control flow
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 控制流
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Repeating code with a `while` loop
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`while`循环重复代码
- en: 'Making decisions: the `if-elif-else` statement'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做出决定：`if-elif-else`语句
- en: Iterating over a list with a `for` loop
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历列表
- en: Using list and dictionary comprehensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表和字典推导式
- en: Delimiting statements and blocks with indentation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缩进来界定语句和代码块
- en: Evaluating Boolean values and expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估布尔值和表达式
- en: Python provides a complete set of control-flow elements, with loops and conditionals.
    This chapter examines each element in detail.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一套完整的控制流元素，包括循环和条件判断。本章将详细检查每个元素。
- en: 8.1\. The while loop
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. while循环
- en: 'You’ve come across the basic `while` loop several times already. The full `while`
    loop looks like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经多次遇到基本的`while`循环。完整的`while`循环看起来像这样：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`condition` is a Boolean expression—that is, one that evaluates to a `True`
    or `False` value. As long as it’s `True`, the `body` is executed repeatedly. When
    the `condition` evaluates to `False`, the `while` loop executes the `post-code`
    section and then terminates. If the `condition` starts out by being `False`, the
    `body` won’t be executed at all—just the `post-code` section. The `body` and `post-code`
    are each sequences of one or more Python statements that are separated by newlines
    and are at the same level of indentation. The Python interpreter uses this level
    to delimit them. No other delimiters, such as braces or brackets, are necessary.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition`是一个布尔表达式——也就是说，它评估为`True`或`False`值。只要它是`True`，`body`就会重复执行。当`condition`评估为`False`时，`while`循环执行`post-code`部分，然后终止。如果`condition`一开始就是`False`，则`body`根本不会执行——只执行`post-code`部分。`body`和`post-code`各自是一系列由换行符分隔的Python语句，并且处于相同的缩进级别。Python解释器使用这个级别来界定它们。不需要其他界定符，如花括号或方括号。'
- en: Note that the `else` part of the `while` loop is optional and not often used.
    That’s because as long as there’s no `break` in the `body`, this loop
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`while`循环的`else`部分是可选的，并且不常使用。这是因为只要`body`中没有`break`，这个循环
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and this loop
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以及这个循环
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: do the same things—and the second is simpler to understand. I probably wouldn’t
    mention the `else` clause except that if you don’t know about it, you may find
    it confusing if you run across this syntax in another person’s code. Also, it’s
    useful in some situations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 做同样的事情——第二个更容易理解。我可能不会提到`else`子句，除非你不知道它，你可能会在别人的代码中遇到这种语法时感到困惑。此外，在某些情况下它很有用。
- en: The two special statements `break` and `continue` can be used in the `body`
    of a `while` loop. If `break` is executed, it immediately terminates the `while`
    loop, and not even the `post-code` (if there is an `else` clause) is executed.
    If `continue` is executed, it causes the remainder of the `body` to be skipped
    over; the `condition` is evaluated again, and the loop proceeds as normal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的`body`中可以使用两个特殊语句`break`和`continue`。如果执行`break`，它将立即终止`while`循环，并且甚至不会执行`post-code`（如果有`else`子句）。如果执行`continue`，它将跳过`body`的剩余部分；重新评估`condition`，然后循环按正常方式继续。
- en: 8.2\. The if-elif-else statement
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. if-elif-else语句
- en: The most general form of the if-then-else construct in Python is
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python中if-then-else构造的最一般形式是
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It says: If `condition1` is `True`, execute `body1`; otherwise, if `condition2`
    is `True`, execute `body2`; otherwise . . . and so on until it either finds a
    condition that evaluates to `True` or hits the `else` clause, in which case it
    executes `body(n)`. As with the `while` loop, the `body` sections are again sequences
    of one or more Python statements that are separated by newlines and are at the
    same level of indentation.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它说：如果`condition1`为`True`，则执行`body1`；否则，如果`condition2`为`True`，则执行`body2`；否则……以此类推，直到找到评估为`True`的条件或遇到`else`子句，在这种情况下，它将执行`body(n)`。与`while`循环一样，`body`部分又是包含一个或多个Python语句的序列，这些语句通过换行符分隔，并且处于相同的缩进级别。
- en: You don’t need all that luggage for every conditional, of course. You can leave
    out the `elif` parts, the `else` part, or both. If a conditional can’t find any
    body to execute (no conditions evaluate to `True`, and there’s no `else` part),
    it does nothing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要在每个条件判断中都使用所有这些。你可以省略`elif`部分、`else`部分，或者两者都省略。如果一个条件判断找不到要执行的`body`（没有条件评估为`True`，且没有`else`部分），它将不执行任何操作。
- en: 'The `body` after the `if` statement is required. But you can use the `pass`
    statement here (as you can anywhere in Python where a statement is required).
    The `pass` statement serves as a placeholder where a statement is needed, but
    it performs no action:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句之后的 `body` 是必需的。但在这里可以使用 `pass` 语句（就像你可以在 Python 中需要语句的任何地方一样）。`pass`
    语句在需要语句的地方充当占位符，但它不执行任何操作：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There’s no case (or switch) statement in Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中没有 case（或 switch）语句。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Where’s the case statement in Python?**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 中哪里有 case 语句？**'
- en: 'As just mentioned, there’s no case statement in Python. In most cases where
    a case or switch statement would be used in other languages, Python gets by just
    fine with a ladder of if... elif... elif... else. In the few cases where that
    gets cumbersome, a dictionary of functions usually works, as in this example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才提到的，Python 中没有 case 语句。在大多数情况下，在其他语言中会使用 case 或 switch 语句的地方，Python 只需通过一系列的
    if... elif... elif... else 就可以很好地处理。在极少数情况下，这会变得繁琐，通常可以使用函数字典来解决这个问题，就像这个例子中所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* run function from dictionary**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从字典中运行函数**'
- en: In fact, there have been proposals (see PEP 275 and PEP 3103) to add a case
    statement to Python, but overall consensus has been that it’s not needed or worth
    the trouble.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，已经有人提出了（参见 PEP 275 和 PEP 3103）在 Python 中添加 case 语句的建议，但总体上共识是它不是必需的，也不值得麻烦。
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.3\. The for loop
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 循环语句
- en: A `for` loop in Python is different from `for` loops in some other languages.
    The traditional pattern is to increment and test a variable on each iteration,
    which is what C `for` loops usually do. In Python, a `for` loop iterates over
    the values returned by any iterable object—that is, any object that can yield
    a sequence of values. For example, a `for` loop can iterate over every element
    in a list, a tuple, or a string. But an iterable object can also be a special
    function called `range` or a special type of function called a *generator* or
    a generator expression, which can be quite powerful. The general form is
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `for` 循环与其他语言的 `for` 循环不同。传统的模式是在每次迭代中递增并测试一个变量，这正是 C 语言 `for` 循环通常所做的。在
    Python 中，`for` 循环遍历任何可迭代对象返回的值——也就是说，任何可以产生值序列的对象。例如，`for` 循环可以遍历列表、元组或字符串中的每个元素。但可迭代对象也可以是一个特殊函数，称为
    `range` 或一种特殊类型的函数，称为 *生成器* 或生成器表达式，这可以非常强大。其一般形式是
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`body` is executed once for each element of `sequence`. `item` is set to be
    the first element of `sequence`, and `body` is executed; then `item` is set to
    be the second element of `sequence`, and `body` is executed, and so on for each
    remaining element of the `sequence`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`body` 对 `sequence` 的每个元素执行一次。`item` 被设置为 `sequence` 的第一个元素，然后执行 `body`；然后
    `item` 被设置为 `sequence` 的第二个元素，然后执行 `body`，依此类推，直到 `sequence` 的每个剩余元素。'
- en: The `else` part is optional. Like the `else` part of a `while` loop, it’s rarely
    used. `break` and `continue` do the same thing in a `for` loop as in a `while`
    loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 部分是可选的。就像 `while` 循环的 `else` 部分一样，它很少被使用。在 `for` 循环中，`break` 和 `continue`
    与在 `while` 循环中做的是相同的事情。'
- en: 'This small loop prints out the reciprocal of each number in `x`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小循环会打印出 `x` 中每个数的倒数：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 8.3.1\. The range function
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. range 函数
- en: 'Sometimes, you need to loop with explicit indices (such as the positions at
    which values occur in a list). You can use the `range` command together with the
    `len` command on the list to generate a sequence of indices for use by the `for`
    loop. This code prints out all the positions in a list where it finds negative
    numbers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要使用显式索引进行循环（例如，列表中值出现的位置）。你可以使用 `range` 命令与列表上的 `len` 命令一起生成一个用于 `for`
    循环的索引序列。以下代码会打印出列表中所有出现负数的位置：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Given a number *n*, `range(n)` returns a sequence 0, 1, 2, ..., *n* – 2, *n*
    – 1\. So passing it the length of a list (found using `len`) produces a sequence
    of the indices for that list’s elements. The `range` function doesn’t build a
    Python list of integers; it just appears to. Instead, it creates a range object
    that produces integers on demand. This is useful when you’re using explicit loops
    to iterate over really large lists. Instead of building a list with 10 million
    elements in it, for example, which would take up quite a bit of memory, you can
    use `range(10000000)`, which takes up only a small amount of memory and generates
    a sequence of integers from 0 up to (but *not* including) 10000000 as needed by
    the `for` loop.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数字*n*，`range(n)`返回一个序列0, 1, 2, ..., *n* – 2, *n* – 1。所以传递列表的长度（使用`len`找到）会产生该列表元素的索引序列。`range`函数不会构建一个包含100万个元素的Python列表；它只是看起来如此。相反，它创建了一个range对象，按需生成整数。这在您使用显式循环遍历非常大的列表时很有用。例如，您不需要构建一个包含1000万个元素的列表，这将占用相当多的内存，您可以使用`range(10000000)`，它只占用很少的内存，并且根据`for`循环的需要生成从0到（但不包括）10000000的整数序列。
- en: 8.3.2\. Controlling range with starting and stepping values
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 使用起始值和步长值控制范围
- en: 'You can use two variants on the `range` function to gain more control over
    the sequence it produces. If you use `range` with two numeric arguments, the first
    argument is the starting number for the resulting sequence, and the second number
    is the number the resulting sequence goes up to (but doesn’t include). Here are
    a few examples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`range`函数的两个变体来获得对其产生的序列的更多控制。如果您使用两个数字参数的`range`，第一个参数是结果序列的起始数字，第二个数字是结果序列将到达的数字（但不包括）。以下是一些示例：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`list()` is used only to force the items `range` would generate to appear as
    a list. It’s not normally used in actual code ***1***.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`仅用于强制`range`生成的项以列表的形式出现。它通常不在实际代码中使用***1***。'
- en: 'This still doesn’t allow you to count backward, which is why the value of `list(range(5,
    3))` is an empty list. To count backward, or to count by any amount other than
    1, you need to use the optional third argument to `range`, which gives a step
    value by which counting proceeds:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不允许您反向计数，这就是为什么`list(range(5, 3))`的值是一个空列表的原因。要反向计数或按任何不是1的量计数，您需要使用`range`的第三个可选参数，它提供了一个步长值，计数就按这个步长值进行：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sequences returned by `range` always include the starting value given as an
    argument to `range` and never include the ending value given as an argument.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`返回的序列始终包含作为`range`参数给出的起始值，并且从不包含作为参数给出的结束值。'
- en: 8.3.3\. Using break and continue in for loops
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 在for循环中使用break和continue
- en: The two special statements `break` and `continue` can also be used in the body
    of a `for` loop. If `break` is executed, it immediately terminates the `for` loop,
    and not even the `post-code` (if there is an `else` clause) is executed. If `continue`
    is executed in a `for` loop, it causes the remainder of the `body` to be skipped
    over, and the loop proceeds as normal with the next item.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 两个特殊语句`break`和`continue`也可以用在`for`循环体中。如果执行`break`，它将立即终止`for`循环，并且即使有`else`子句，也不会执行`post-code`。如果在`for`循环中执行`continue`，它将导致跳过`body`的剩余部分，并且循环将正常继续到下一个项目。
- en: 8.3.4\. The for loop and tuple unpacking
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 循环和元组解包
- en: 'You can use tuple unpacking to make some `for` loops cleaner. The following
    code takes a list of two-element tuples and calculates the value of the sum of
    the products of the two numbers in each tuple (a moderately common mathematical
    operation in some fields):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用元组解包来使一些`for`循环更简洁。以下代码接受一个包含两个元素元组的列表，并计算每个元组中两个数字乘积之和的值（在某些领域中这是一种相当常见的数学运算）：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s the same thing, but cleaner:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是同样的内容，但更简洁：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code uses a tuple `x, y` immediately after the `for` keyword instead of
    the usual single variable. On each iteration of the `for` loop, `x` contains element
    `0` of the current tuple from `list`, and `y` contains element `1` of the current
    tuple from `list`. Using a tuple in this manner is a convenience of Python, and
    doing this indicates to Python that each element of the list is expected to be
    a tuple of appropriate size to unpack into the variable names mentioned in the
    tuple after the `for`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在`for`关键字之后立即使用一个元组`x, y`，而不是通常的单个变量。在`for`循环的每次迭代中，`x`包含来自`list`的当前元组的第`0`个元素，而`y`包含来自`list`的当前元组的第`1`个元素。以这种方式使用元组是Python的一个便利之处，这样做表示Python期望列表中的每个元素都是一个适当大小的元组，可以解包到元组后面提到的变量名中。
- en: 8.3.5\. The enumerate function
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.5\. enumerate函数
- en: 'You can combine tuple unpacking with the `enumerate` function to loop over
    both the items and their index. This is similar to using `range` but has the advantage
    that the code is clearer and easier to understand. Like the previous example,
    the following code prints out all the positions in a list where it finds negative
    numbers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将元组解包与`enumerate`函数结合使用，以同时遍历项目和它们的索引。这与使用`range`类似，但它的优点是代码更清晰、更容易理解。像上一个示例一样，以下代码打印出列表中所有找到负数的位置：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `enumerate` function returns tuples of (index, item) ***1***. You can access
    the item without the index ***2***. The index is also available ***3***.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate`函数返回包含(index, item)的元组***1***。你可以访问项目而不需要索引***2***。索引也是可用的***3***。'
- en: 8.3.6\. The zip function
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.6\. zip函数
- en: 'Sometimes, it’s useful to combine two or more iterables before looping over
    them. The `zip` function takes the corresponding elements from one or more iterables
    and combines them into tuples until it reaches the end of the shortest iterable:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在遍历它们之前将两个或多个可迭代对象组合起来是有用的。`zip`函数从一个或多个可迭代对象中取出相应的元素，并将它们组合成元组，直到达到最短可迭代对象的末尾：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* y is 3 elements; x is 4 elements.**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* y有3个元素；x有4个元素。**'
- en: '***2* z has only 3 elements.**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* z只有3个元素。**'
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Looping and if statements'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：循环和if语句
- en: Suppose that you have a list `x = [1, 3, 5, 0, -1, 3, -2]`, and you need to
    remove all negative numbers from that list. Write the code to do this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个列表`x = [1, 3, 5, 0, -1, 3, -2]`，你需要从该列表中移除所有负数。请编写执行此操作的代码。
- en: How would you count the total number of negative numbers in a list `y = [[1,
    -1, 0], [2, 5, -9], [-2, -3, 0]]`?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何计算列表`y = [[1, -1, 0], [2, 5, -9], [-2, -3, 0]]`中负数的总数？
- en: What code would you use to print `very low` if the value of `x` is below -5,
    `low` if it’s from -5 up to 0, `neutral` if it’s equal to 0, `high` if it’s greater
    than 0 up to 5, and `very high` if it’s greater than 5?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`的值小于-5，你会使用什么代码来打印`very low`，如果它在-5到0之间，你会打印`low`，如果它等于0，你会打印`neutral`，如果它大于0且小于等于5，你会打印`high`，如果它大于5，你会打印`very
    high`？
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.4\. List and dictionary comprehensions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 列表和字典推导式
- en: 'The pattern of using a `for` loop to iterate through a list, modify or select
    individual elements, and create a new list or dictionary is very common. Such
    loops often look a lot like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历列表、修改或选择单个元素，并创建新的列表或字典的模式非常常见。这样的循环通常看起来像以下这样：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This sort of situation is so common that Python has a special shortcut for
    such operations, called a *comprehension*. You can think of a list or dictionary
    comprehension as a one-line `for` loop that creates a new list or dictionary from
    a sequence. The pattern of a list comprehension is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况如此常见，以至于Python为这种操作提供了一个特殊的快捷方式，称为*列表推导式*。你可以将列表或字典推导式视为一个单行`for`循环，它从一个序列中创建新的列表或字典。列表推导式的模式如下：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'and a dictionary comprehension looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导式看起来像这样：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In both cases, the heart of the expression is similar to the beginning of a
    `for` loop—`for variable in list`—with some expression using that variable to
    create a new key or value and an optional conditional expression using the value
    of the variable to select whether it’s included in the new list or dictionary.
    The following code does exactly the same thing as the previous code but is a list
    comprehension:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，表达式的核心类似于`for`循环的开始——`for variable in list`——使用一些使用该变量的表达式来创建新的键或值，以及一个可选的条件表达式，使用变量的值来选择是否将其包含在新的列表或字典中。以下代码与之前的代码完全相同，但是一个列表推导式：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can even use `if` statements to select items from the list:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用`if`语句从列表中选择项目：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Dictionary comprehensions are similar, but you need to supply both a key and
    a value. If you want to do something similar to the previous example but have
    the number be the key and the number’s square be the value in a dictionary, you
    can use a dictionary comprehension, like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导式类似，但你需要提供键和值。如果你想做一些类似于上一个示例的操作，但将数字作为键，将数字的平方作为字典中的值，你可以使用字典推导式，如下所示：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: List and dictionary comprehensions are very flexible and powerful, and when
    you get used to them, they make list-processing operations much simpler. I recommend
    that you experiment with them and try them any time you find yourself writing
    a `for` loop to process a list of items.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和字典推导式非常灵活且强大，当你习惯使用它们时，它们会使列表处理操作变得更加简单。我建议你尝试使用它们，并在你发现自己正在编写用于处理项目列表的`for`循环时尝试使用它们。
- en: 8.4.1\. Generator expressions
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 生成器表达式
- en: 'Generator expressions are similar to list comprehensions. A generator expression
    looks a lot like a list comprehension, except that in place of square brackets,
    it uses parentheses. The following example is the generator-expression version
    of the list comprehension already discussed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式与列表推导式类似。生成器表达式看起来很像列表推导式，除了它使用圆括号而不是方括号。以下示例是前面讨论的列表推导式的生成器表达式版本：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other than the change from square brackets, notice that this expression doesn’t
    return a list. Instead, it returns a generator object that could be used as the
    iterator in a `for` loop, as shown, which is very similar to what the `range()`
    function does. The advantage of using a generator expression is that the entire
    list isn’t generated in memory, so arbitrarily large sequences can be generated
    with little memory overhead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从方括号到圆括号的变化外，请注意，这个表达式不返回列表。相反，它返回一个生成器对象，可以用作`for`循环中的迭代器，如下所示，这与`range()`函数非常相似。使用生成器表达式的优点是，整个列表不需要在内存中生成，因此可以以很小的内存开销生成任意大的序列。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Comprehensions'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：列表推导式
- en: What list comprehension would you use to process the list `x` so that all negative
    values are removed?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你会用什么列表推导式来处理列表`x`，以便移除所有负值？
- en: 'Create a generator that returns only odd numbers from 1 to 100\. (Hint: A number
    is odd if there is a remainder if divided by 2; use `% 2` to get the remainder
    of division by 2.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个生成器，只返回从1到100的奇数。（提示：如果一个数除以2有余数，那么这个数就是奇数；使用`% 2`来获取除以2的余数。）
- en: Write the code to create a dictionary of the numbers and their cubes from 11
    through 15.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以创建从11到15的数字及其立方体的字典。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.5\. Statements, blocks, and indentation
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. 语句、块和缩进
- en: Because the control flow constructs you’ve encountered in this chapter are the
    first to make use of blocks and indentation, this is a good time to revisit the
    subject.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在本章中遇到的控制流构造是第一个使用块和缩进的，现在是回顾这个主题的好时机。
- en: 'Python uses the indentation of the statements to determine the delimitation
    of the different blocks (or bodies) of the control-flow constructs. A block consists
    of one or more statements, which are usually separated by newlines. Examples of
    Python statements are the assignment statement, function calls, the `print` function,
    the placeholder `pass` statement, and the `del` statement. The control-flow constructs
    (`if-elif-else`, `while`, and `for` loops) are compound statements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用语句的缩进来确定不同控制流构造的不同块（或主体）的界限。一个块由一个或多个语句组成，通常由换行符分隔。Python语句的例子包括赋值语句、函数调用、`print`函数、占位符`pass`语句和`del`语句。控制流构造（`if-elif-else`、`while`和`for`循环）是复合语句：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A compound statement contains one or more clauses that are each followed by
    indented blocks. Compound statements can appear in blocks just like any other
    statements. When they do, they create nested blocks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 复合语句包含一个或多个子句，每个子句后面都跟着缩进的块。复合语句可以像任何其他语句一样出现在块中。当它们这样做时，会创建嵌套的块。
- en: 'You may also encounter a couple of special cases. Multiple statements may be
    placed on the same line if they’re separated by semicolons. A block containing
    a single line may be placed on the same line after the semicolon of a clause of
    a compound statement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能遇到一些特殊情况。如果多个语句由分号分隔，它们可以放在同一行上。一个包含单行的块可以放在复合语句子句的分号之后同一行上：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Improperly indented code results in an exception being raised. You may encounter
    two forms of this exception. The first is
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确的缩进会导致抛出异常。你可能遇到两种形式的这种异常。第一种是
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code indented a line that shouldn’t have been indented. In the basic mode,
    the carat (`^`) indicates the spot where the problem occurred. In the IDLE Python
    shell (see [figure 8.1](#ch08fig01)), the invalid indent is highlighted. The same
    message would occur if the code didn’t indent where necessary (that is, the first
    line after a compound statement clause).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码缩进了不应该缩进的行。在基本模式下，符号`^`表示问题发生的位置。在IDLE Python shell中（见[图8.1](#ch08fig01)），无效的缩进会被突出显示。如果代码在必要的地方没有缩进（即复合语句子句之后的第一个行），也会出现相同的消息。
- en: Figure 8.1\. Indentation error
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 缩进错误
- en: '![](images/08fig01_alt.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/08fig01_alt.jpg)'
- en: One situation where this can occur can be confusing. If you’re using an editor
    that displays tabs in four-space increments (or Windows interactive mode, which
    indents the first tab only four spaces from the prompt) and indent one line with
    four spaces and then the next line with a tab, the two lines may appear to be
    at the same level of indentation. But you receive this exception because Python
    maps the tab to eight spaces. The best way to avoid this problem is to use only
    spaces in Python code. If you must use tabs for indentation, or if you’re dealing
    with code that uses tabs, be sure never to mix them with spaces.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能让人困惑。如果你使用的是以四个空格为单位的制表符显示编辑器（或者Windows交互模式，其中第一个制表符从提示符开始缩进四个空格），并且用四个空格缩进一行，然后用制表符缩进下一行，这两行可能看起来处于相同的缩进级别。但你会收到这个异常，因为Python将制表符映射为八个空格。避免这种问题的最好方法是只使用空格在Python代码中。如果你必须使用制表符进行缩进，或者如果你正在处理使用制表符的代码，确保永远不要将它们与空格混合。
- en: 'On the subject of the basic interactive mode and the IDLE Python shell, you’ve
    likely noticed that you need an extra line after the outermost level of indentation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本交互模式和IDLE Python壳中，你可能已经注意到，在最外层缩进级别之后需要额外的空行：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: No line is necessary after the line `z = 2`, but one is needed after the line
    `v = 0`. This line is unnecessary if you’re placing your code in a module in a
    file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `z = 2` 这一行后面不需要空行，但在 `v = 0` 这一行后面需要。如果你将代码放在文件中的模块里，这一行是不必要的。
- en: 'The second form of exception occurs if you indent a statement in a block less
    than the legal amount:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码块中缩进一个语句少于合法的数量，就会发生第二种形式的异常：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the line containing `z = 2` isn’t lined up properly below the
    line containing `y = 2`. This form is rare, but I mention it again because in
    a similar situation, it may be confusing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，包含 `z = 2` 的行没有正确地与包含 `y = 2` 的行对齐。这种形式很少见，但我再次提到它，因为在类似的情况下，它可能会让人困惑。
- en: Python allows you to indent any amount and won’t complain regardless of how
    much you vary indentation as long as you’re consistent within a single block.
    Please don’t take improper advantage of this flexibility. The recommended standard
    is to use four spaces for each level of indentation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你缩进任意数量，只要你在单个代码块内保持一致性，它就不会抱怨缩进的变化。请不要滥用这种灵活性。建议的标准是每级缩进使用四个空格。
- en: 'Before leaving indentation, I’ll cover breaking up statements across multiple
    lines, which of course is necessary more often as the level of indentation increases.
    You can explicitly break up a line by using the backslash character. You can also
    implicitly break any statement between tokens when within a set of `()`, `{}`,
    or `[]` delimiters (that is, when typing a set of values in a list, a tuple, or
    a dictionary; a set of arguments in a function call; or any expression within
    a set of brackets). You can indent the continuation line of a statement to any
    level you desire:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束缩进之前，我将介绍如何在多行中拆分语句，当然，随着缩进级别的增加，这种情况更加常见。你可以通过使用反斜杠字符显式地拆分一行。你还可以在 `()`、
    `{}` 或 `[]` 分隔符内隐式地拆分任何语句（即，在输入列表、元组或字典中的值集；函数调用中的参数集；或括号内的任何表达式）。你可以根据需要将语句的续行缩进到任何级别：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can break a string with a `\` as well. But any indentation tabs or spaces
    become part of the string, and the line *must* end with the `\`. To avoid this
    situation, remember that any string literals separated by whitespace are automatically
    concatenated by the Python interpreter:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用反斜杠 `\` 来中断字符串。但任何缩进的制表符或空格都成为字符串的一部分，并且该行*必须*以反斜杠结束。为了避免这种情况，请记住，任何由空白分隔的字符串字面量都会被Python解释器自动连接：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 8.6\. Boolean values and expressions
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6. 布尔值和表达式
- en: The previous examples of control flow use conditional tests in a fairly obvious
    manner but never really explain what constitutes true or false in Python or what
    expressions can be used where a conditional test is needed. This section describes
    these aspects of Python.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之前关于控制流的例子以相当明显的方式使用了条件测试，但从未真正解释在Python中什么是真或假，或者需要条件测试时可以使用哪些表达式。本节描述了Python的这些方面。
- en: Python has a Boolean object type that can be set to either `True` or `False`.
    Any expression with a Boolean operation returns `True` or `False`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个布尔对象类型，可以设置为 `True` 或 `False`。任何带有布尔操作的运算表达式都会返回 `True` 或 `False`。
- en: 8.6.1\. Most Python objects can be used as Booleans
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.1. 大多数Python对象都可以用作布尔值
- en: 'In addition, Python is similar to C with respect to Boolean values, in that
    C uses the integer `0` to mean false and any other integer to mean true. Python
    generalizes this idea: `0` or empty values are `False`, and any other values are
    `True`. In practical terms, this means the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 在布尔值方面与 C 类似，即 C 使用整数 `0` 表示假，而任何其他整数表示真。Python 将这一概念推广：`0` 或空值是 `False`，而任何其他值都是
    `True`。从实际意义上讲，这意味着以下内容：
- en: The numbers `0`, `0.0`, and `0+0j` are all `False`; any other number is `True`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `0`、`0.0` 和 `0+0j` 都是 `False`；任何其他数字都是 `True`。
- en: The empty string `""` is `False`; any other string is `True`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串 `""` 是 `False`；任何其他字符串都是 `True`。
- en: The empty list `[]` is `False`; any other list is `True`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表 `[]` 是 `False`；任何其他列表都是 `True`。
- en: The empty dictionary `{}` is `False`; any other dictionary is `True`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字典 `{}` 是 `False`；任何其他字典都是 `True`。
- en: The empty set `set()` is `False`; any other set is `True`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空集合 `set()` 是 `False`；任何其他集合都是 `True`。
- en: The special Python value `None` is always `False`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊的 Python 值 `None` 总是 `False`。
- en: We haven’t looked at some Python data structures yet, but generally, the same
    rule applies. If the data structure is empty or `0`, it’s taken to mean false
    in a Boolean context; otherwise, it’s taken to mean true. Some objects, such as
    file objects and code objects, don’t have a sensible definition of a `0` or empty
    element, and these objects shouldn’t be used in a Boolean context.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有查看一些 Python 数据结构，但通常，相同的规则适用。如果数据结构为空或 `0`，则在布尔上下文中被认为是假；否则，被认为是真。某些对象，如文件对象和代码对象，没有合理的
    `0` 或空元素的定义，这些对象不应在布尔上下文中使用。
- en: 8.6.2\. Comparison and Boolean operators
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.2. 比较和布尔运算符
- en: 'You can compare objects by using normal operators: `<`, `<=`, `>`, `>=`, and
    so forth. `==` is the equality test operator, and`!=` is the “not equal to” test.
    There are also `in` and `not in` operators to test membership in sequences (lists,
    tuples, strings, and dictionaries), as well as `is` and `is not` operators to
    test whether two objects are the same.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用常规运算符比较对象：`<`, `<=`, `>`, `>=` 等等。`==` 是相等测试运算符，而 `!=` 是“不等于”测试。还有 `in`
    和 `not in` 运算符用于测试序列（列表、元组、字符串和字典）中的成员资格，以及 `is` 和 `is not` 运算符用于测试两个对象是否相同。
- en: 'Expressions that return a Boolean value may be combined into more complex expressions
    using the `and`, `or`, and `not` operators. This code snippet checks to see whether
    a variable is within a certain range:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 返回布尔值的表达式可以使用 `and`、`or` 和 `not` 运算符组合成更复杂的表达式。以下代码片段检查一个变量是否在某个范围内：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Python offers a nice shorthand for this particular type of compound statement.
    You can write it as you would in a math paper:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 为这种特定类型的复合语句提供了一种简洁的缩写。您可以像在数学论文中那样编写它：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Various rules of precedence apply; when in doubt, you can use parentheses to
    make sure that Python interprets an expression the way you want it to. Using parentheses
    is probably a good idea for complex expressions, regardless of whether it’s necessary,
    because it makes clear to future maintainers of the code exactly what’s happening.
    See the Python documentation for more details on precedence.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级规则适用；如有疑问，您可以使用括号确保 Python 以您期望的方式解释表达式。使用括号可能是复杂表达式的良好做法，无论是否必要，因为它可以使未来的代码维护者清楚地了解正在发生的事情。有关优先级的更多详细信息，请参阅
    Python 文档。
- en: The rest of this section provides more advanced information. If you’re reading
    this book as you’re learning the language, you may want to skip that material
    for now.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分提供更高级的信息。如果您在学习语言的同时阅读这本书，您可能现在想跳过这部分内容。
- en: 'The `and` and `or` operators return objects. The `and` operator returns either
    the first false object (that an expression evaluates to) or the last object. Similarly,
    the `or` operator returns either the first true object or the last object. This
    may seem a little confusing, but it works correctly; if an expression with `and`
    has even one false element, that element makes the entire expression evaluate
    as `False`, and that `False` value is returned. If all of the elements are `True`,
    the expression is `True`, and the last value, which must also be `True,` is returned.
    The converse is true for `or`; only one `True` element makes the statement logically
    `True`, and the first `True` value found is returned. If no `True` values are
    found, the last (`False`) value is returned. In other words, as with many other
    languages, evaluation stops as soon as a true expression is found for the `or`
    operator or as soon as a false expression is found for the `and` operator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 和 `or` 运算符返回对象。`and` 运算符返回第一个为假的对象（表达式评估到的）或最后一个对象。同样，`or` 运算符返回第一个为真的对象或最后一个对象。这可能会有些令人困惑，但它工作得正确；如果
    `and` 运算符的表达式中有任何一个是假的，那么这个元素就会使整个表达式评估为 `False`，并返回这个 `False` 值。如果所有元素都是 `True`，则表达式为
    `True`，并返回最后一个值，这个值也必须是 `True`。对于 `or` 运算符，情况相反；只有一个 `True` 元素会使语句在逻辑上为 `True`，并返回找到的第一个
    `True` 值。如果没有找到 `True` 值，则返回最后一个（`False`）值。换句话说，就像许多其他语言一样，对于 `or` 运算符，一旦找到真表达式，评估就会停止；对于
    `and` 运算符，一旦找到假表达式，评估就会停止：'
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `==` and`!=` operators test to see whether their operands contains the
    same values. `==` and `!=` are used in most situations, as opposed to `is` and
    `is not` operators, which test to see whether their operands are the same object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 和 `!=` 运算符用于测试它们的操作数是否包含相同的值。`==` 和 `!=` 在大多数情况下使用，而不是 `is` 和 `is not`
    运算符，后者用于测试操作数是否是同一个对象：'
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* They reference the same object.**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 它们引用的是同一个对象。**'
- en: '***2* x has been assigned to a different object.**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* x 被分配给了不同的对象。**'
- en: Revisit [section 5.6](kindle_split_016.html#ch05lev1sec6), “[Nested lists and
    deep copies](kindle_split_016.html#ch05lev1sec6),” if this example isn’t clear
    to you.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子对你来说不清楚，请回顾 [第 5.6 节](kindle_split_016.html#ch05lev1sec6)，“[嵌套列表和深拷贝](kindle_split_016.html#ch05lev1sec6)。”
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Booleans and truthiness'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：布尔值和真值
- en: 'Decide whether the following statements are true or false: `1, 0, -1, [0],
    1 and 0, 1 > 0 or [].`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 判断以下语句是否为真：`1, 0, -1, [0], 1 and 0, 1 > 0 or [].`
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.7\. Writing a simple program to analyze a text file
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7\. 编写一个简单的程序来分析文本文件
- en: To give you a better sense of how a Python program works, this section looks
    at a small sample that roughly replicates the UNIX `wc` utility and reports the
    number of lines, words, and characters in a file. The sample in this listing is
    deliberately written to be clear to programmers who are new to Python and to be
    as simple as possible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解 Python 程序的工作方式，本节将查看一个小样本，该样本大致复制了 UNIX `wc` 工具，并报告文件中的行数、单词数和字符数。这个列表中的样本故意写成对
    Python 新手程序员来说尽可能清晰，并且尽可能简单。
- en: Listing 8.1\. word_count.py
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. word_count.py
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Opens file**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打开文件**'
- en: '***2* Reads file; splits into lines**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 读取文件；分割成行**'
- en: '***3* Gets number of lines with len()**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 len() 获取行数**'
- en: '***4* Initializes other counts**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 初始化其他计数**'
- en: '***5* Iterates through lines**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 遍历行**'
- en: '***6* Splits into words**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 分割成单词**'
- en: '***7* Returns number of characters**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 返回字符数**'
- en: '***8* Prints answers**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 打印答案**'
- en: To test, you can run this sample against a sample file containing the first
    paragraph of this chapter’s summary, like this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，你可以运行这个示例，针对包含本章总结第一段内容的样本文件，如下所示。
- en: Listing 8.2\. word_count.tst
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. word_count.tst
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Upon running word_count.py, you get the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 word_count.py 后，你会得到以下输出：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code can give you an idea of a Python program. There isn’t much code, and
    most of the work gets done in three lines of code in the `for` loop. In fact,
    this program could be made even shorter and more idiomatic. Most Pythonistas see
    this conciseness as one of Python’s great strengths.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以给你一个 Python 程序的思路。代码并不多，大部分工作都在 `for` 循环的三个代码行中完成。实际上，这个程序可以变得更短、更符合 Python
    习惯。大多数 Python 程序员都认为这种简洁性是 Python 的一个伟大优势。
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 8: Refactor word_count'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验 8：重构 word_count
- en: Rewrite the word-count program from [section 8.7](#ch08lev1sec7) to make it
    shorter. You may want to look at the string and list operations already discussed,
    as well as think about different ways to organize the code. You may also want
    to make the program smarter so that only alphabetic strings (not symbols or punctuation)
    count as words.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将第8.7节（[section 8.7](#ch08lev1sec7)）中的单词计数程序重写以使其更短。你可能需要查看已经讨论过的字符串和列表操作，以及考虑不同的代码组织方式。你可能还想使程序更智能，以便只有字母字符串（不是符号或标点）被计算为单词。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python uses indentation to group blocks of code.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python使用缩进来分组代码块。
- en: Python has loops using `while` and `for`, and conditionals using `if-elif-else`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python使用`while`和`for`循环，以及`if-elif-else`条件语句。
- en: Python has the Boolean values `True` and `False`, which can be referenced by
    variables.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python有布尔值`True`和`False`，可以通过变量来引用。
- en: Python also considers any 0 or empty value to be `False` and any nonzero or
    nonempty value to be `True`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python还将任何0或空值视为`False`，任何非零或非空值视为`True`。
