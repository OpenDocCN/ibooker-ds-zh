- en: 3 Introducing continuous testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 引入持续测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating a process of writing tests as you write code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写代码的同时创建编写测试的过程
- en: Establishing testing boundaries for sections of code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为代码部分建立测试边界
- en: Creating a quality gate using tests in our pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的管道中的测试创建一个质量门
- en: Using code coverage as a guide for refactoring and testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码覆盖率作为重构和测试的指南
- en: The head of QA comes by your desk and grabs the chair next to you. They look
    a little frustrated, which makes sense because the QA team has been under immense
    pressure to get a new release out the door. It always seems like they are hammered
    with a ton of bugs, problems, and misinterpreted features. The development and
    QA teams always seem to be butting heads instead of working together to solve
    problems. The QA team feels that they are the gateway of a quality project, while
    development feels that QA gets in the way. Developers keep releasing buggy code
    and are engaged in a sadistic version of Whack-a-Mole with bugs. This relationship
    is so strained that it is unhealthy. When you saw QA coming toward your desk,
    you knew that this wasn’t going to be an easy conversation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: QA负责人走到你的办公桌旁，拿起你旁边的椅子。他们看起来有些沮丧，这是有道理的，因为QA团队一直在承受巨大的压力，要推出一个新版本。他们似乎总是被大量的错误、问题和误解的功能压得喘不过气来。开发和QA团队似乎总是在互相冲突，而不是一起解决问题。QA团队感觉自己是质量项目的门户，而开发团队感觉QA阻碍了他们。开发者不断发布有错误的代码，并陷入了一种虐待狂式的Whack-a-Mole游戏，与错误作斗争。这种关系紧张到不健康。当你看到QA朝你的桌子走来时，你就知道这将不会是一次轻松的对话。
- en: “Look, I’m sure you know that we are underwater at this point with the weekend
    release coming up. But I just got word that you are writing a new project to replace
    our existing translation service. We’ve been debugging that product for years,
    and at this point it is stable, so I’m not sure I’m comfortable replacing it.
    Yet our PM insists that this is something we need to do to grow as a company.
    I know you are still in the early stages of development, but I want there to be
    some sort of assurance that this product will work and that my team won’t have
    to spend hours finding the same bugs we encountered years ago. Our time shouldn’t
    be wasted dealing with these little bugs. We need to be focusing on our product
    being the best possible one for the customer. Do you understand?”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “看，我确信你知道我们现在处于周末发布即将到来时的水下状态。但我刚刚得到消息，你正在编写一个新项目来替换我们现有的翻译服务。我们已经对这个产品进行了多年的调试，到目前为止它已经稳定，所以我不确定我是否愿意替换它。然而，我们的项目经理坚持认为这是我们作为公司成长所必须做的事情。我知道你还在开发的早期阶段，但我希望有一种保证，这个产品能够工作，而且我的团队不需要花费数小时去寻找我们多年前遇到的相同错误。我们不应该浪费时间处理这些小错误。我们需要专注于我们的产品成为客户可能拥有的最佳产品。你明白吗？”
- en: You nod your head and take some notes. No one likes to write bad software. No
    one feels good after they are blamed for a bug. No one likes to create more work
    for anyone else. QA stands for quality assurance, but this is a misnomer. A single
    person or group will never be able to assure quality, so having a special team
    be responsible for quality seems dubious. Quality should be the focus of everyone
    in the company, and various groups should test the product in different ways to
    make sure it’s the best product you can release. You decide to sketch this out
    and explain your plan to the head of QA.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你点头并做了些笔记。没有人喜欢编写糟糕的软件。没有人愿意因为被指责为错误而感到良好。没有人愿意给其他人增加更多的工作。QA代表质量保证，但这是一种误解。单个人或团队永远无法保证质量，所以让一个特殊的团队负责质量似乎有些可疑。质量应该是公司每个人的关注点，不同的团队应该以不同的方式测试产品，以确保它是您可以发布的最佳产品。你决定勾勒出这个计划，并向QA负责人解释你的计划。
- en: “What you are proposing is moving testing closer to the source code and using
    it as a way of documenting various test cases,” the QA lead comments. “I know
    we have some unit tests in other areas, but they don’t ever seem to catch the
    bugs we need. Our problem is that these tests seem to be written after the code,
    and they don’t meet our business requirements. They are also never run, so we
    don’t use them. It would be nice if we could have these tests run before anyone
    needs to test them. Do you think that’s something you would be able to do?”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “你提出的建议是将测试更靠近源代码，并使用它作为记录各种测试案例的方式，”QA负责人评论道。“我知道我们在其他区域有一些单元测试，但它们似乎从未捕捉到我们需要的错误。我们的问题是这些测试似乎是在代码之后编写的，并且它们不符合我们的业务需求。它们也从未运行过，所以我们没有使用它们。如果这些测试在需要测试之前就能运行，那将很好。你认为你能做到这一点吗？”
- en: Sure, why not? You take some notes, find the bugs and feature requests for the
    old system, and get to work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为什么不呢？你记下一些笔记，找到旧系统的bug和功能请求，然后开始工作。
- en: 3.1 What to test
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 要测试什么
- en: Where do you start? This is a great question, especially if you are somewhat
    new to development. Programming books will show you the language, and many will
    go as far as to show you the modern testing frameworks or libraries, but they
    won’t show you how to write tests. They also won’t show you what to test. Determining
    what to test and how to test it is a skill that develops over time and is something
    for which your team should have set standards.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从哪里开始？这是一个很好的问题，尤其是如果你对开发还不是很熟悉。编程书籍会向你展示语言，许多书籍甚至会展示现代测试框架或库，但它们不会向你展示如何编写测试。它们也不会向你展示要测试什么。确定要测试的内容以及如何测试它是一种随着时间的推移而发展的技能，并且你的团队应该为此设定标准。
- en: For example, the head of QA is concerned about repeated bugs and wasted time.
    Developers are also concerned about bugs because they waste time. QA has been
    trained to think about various use cases, while developers have a clearer understanding
    of how the system works. When you are given a task to develop, it doesn’t hurt
    to sketch out some use cases and test cases ahead of time. Once this list has
    been written, bounce it off of someone to see if you missed anything. Let’s look
    at our code in the following listing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，质量保证（QA）团队的负责人关心重复的bug和浪费的时间。开发者们也关心bug，因为它们会浪费时间。QA团队已经训练有素，能够考虑各种用例，而开发者们对系统的工作原理有更清晰的理解。当你被分配一个开发任务时，提前草拟一些用例和测试用例并不会有什么坏处。一旦这个列表被写出来，可以拿给其他人看看是否遗漏了什么。让我们看看以下列表中的代码。
- en: Listing 3.1 `Main.go`
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 `Main.go`
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What was our code supposed to do? Translate a given word into another language.
    Does our code do that? No. Remember, we did a minimal amount of work in the last
    chapter to get our pipeline working. Now we are going to focus on what the business
    or customers want from our code. If we look at our current implementation, we’ll
    notice that there are three parts: the translation service, the translation handler,
    and the server. The service may be the least clear because it is the hardcoded
    value in the `Resp` struct. But in the future, this will be the core piece of
    our product and will not be hardcoded. The handler will be in charge of taking
    the requests and converting them so that they can be passed to the service and
    return the results. The server will then run the handler to tie the whole thing
    together.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码本应该做什么？将给定的单词翻译成另一种语言。我们的代码做到了吗？没有。记住，我们在上一章中只做了最小的工作来让我们的管道工作。现在我们将专注于业务或客户希望从我们的代码中获得什么。如果我们看看我们的当前实现，我们会注意到有三个部分：翻译服务、翻译处理程序和服务器。服务可能最不清晰，因为它是在`Resp`结构体中硬编码的值。但将来，这将是我们的产品的核心部分，而不会是硬编码的。处理程序将负责接收请求并将它们转换成可以传递给服务并返回结果的形式。然后服务器将运行处理程序，将整个系统串联起来。
- en: 'The best way to start testing is to break our work into easily testable units.
    These are called *systems under test*, or SUT. The SUT has a clear boundary on
    what you are testing and should be treated as a *black box*, meaning that you
    are mostly testing the inputs and asserting the outputs are correct. We will break
    our SUTs into the following categories: service, handler, and server.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开始测试的最好方式是将我们的工作分解成易于测试的单位。这些被称为*测试系统*（SUT）。SUT有一个清晰的测试边界，你应该将其视为一个*黑盒*，这意味着你主要测试输入并断言输出是正确的。我们将我们的SUTs分为以下类别：服务、处理程序和服务器。
- en: 'Right now, our code is one giant main method that makes it difficult to test,
    so let’s break it down. First, let’s tackle the service that houses all of our
    business logic. Remember that our service is a translation service, so the main
    business functions could be defined as taking a word plus a language and returning
    the translated word. The definition would look something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的代码是一个巨大的主方法，这使得测试变得困难，所以让我们将其分解。首先，让我们处理包含所有业务逻辑的服务。记住，我们的服务是一个翻译服务，所以主要业务功能可以定义为接受一个单词和一个语言，并返回翻译后的单词。定义可能看起来像这样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s create the file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建文件：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Great; this gives us something to start with. Let’s create a package called
    `translation`. In it, we will create a file called `translator.go`. Open `translator.go`,
    and add the code in the following listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很好；这给了我们一个起点。让我们创建一个名为`translation`的包。在其中，我们将创建一个名为`translator.go`的文件。打开`translator.go`，并添加以下列表中的代码。
- en: Listing 3.2 `translator.go`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 `translator.go`
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A new package is created for translations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为翻译创建了一个新包。
- en: ❷ Defines the minimum response for tests
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义测试的最小响应
- en: Now that we’ve established our initial package, we need to come up with an idea
    of what we should be testing. We have established the least amount of code needed
    to write a test. Let’s now take a moment and think about what would need to be
    tested. Sometimes a great primer for writing tests can be to follow a given-when-then
    format. This format is derived from behavior-driven development and gives us a
    general format for how we want to structure our tests. For example, “Given a word
    when it is to be translated into English should then return the word.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了初始包，我们需要想出一个我们应该测试的想法。我们已经确定了编写测试所需的最少代码量。现在让我们花点时间思考一下我们需要测试什么。有时，遵循给定的“当...时，如果...，则...”格式可以成为编写测试的一个很好的入门。这个格式源于行为驱动开发，为我们提供了我们想要如何结构化测试的一般格式。例如，“给定一个单词，当它需要翻译成英语时，应该返回该单词。”
- en: 'Here, we have broken down the business need. Let’s write out some more to complete
    our unit testing list:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经分解了业务需求。让我们再写一些来完善我们的单元测试列表：
- en: Given a word when it is to be translated into English should then return the
    word.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个单词需要翻译成英语时，应该返回该单词。
- en: Given a capitalized word or language when translating should then return the
    same answer as an uncapitalized word or language.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译时遇到大写单词或语言，应该返回与小写单词或语言相同的答案。
- en: Given a word or language with extra spaces when translating should then return
    the same answer as a word or language without spaces.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译时遇到包含额外空格的单词或语言，应该返回与没有空格的单词或语言相同的答案。
- en: Give a word or language when translating that is not supported should then return
    an empty string.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译时遇到不支持的语言或单词，应该返回一个空字符串。
- en: Here is where you can involve your testers or team. Send them this list to make
    sure you didn’t miss anything and that it meets the business requirements. Remember,
    this is just a starting point. You may find that this list expands as you write
    more tests. This list is crucial in writing solid and consistent tests that help
    instill confidence in your code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以涉及你的测试人员或团队。将此列表发送给他们，以确保你没有遗漏任何内容，并且它符合业务需求。记住，这只是一个起点。你可能发现随着你编写更多的测试，这个列表会扩展。这个列表对于编写稳固和一致的测试至关重要，这些测试有助于增强对代码的信心。
- en: 3.2 Writing unit tests
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编写单元测试
- en: We have our approved list of tests; now we can start writing them. For that,
    we will use Go’s built-in testing library and focus on writing the least amount
    of code possible to satisfy that test. Let’s do that using our first item on the
    list. Open your test file, and add the code in the following listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了经过批准的测试列表；现在我们可以开始编写它们了。为此，我们将使用Go的内置测试库，并专注于编写尽可能少的代码来满足这些测试。让我们使用列表上的第一项来做这件事。打开你的测试文件，并添加以下列表中的代码。
- en: Listing 3.3 `translator_test.go`
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 `translator_test.go`
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Uses a separate package to provide black box testing
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用单独的包提供黑盒测试
- en: ❷ Adds all variables to be used in tests for clearer organization
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将所有要在测试中使用的变量添加到测试中，以便有更清晰的组织
- en: ❸ Calls the function to be tested and captures the result
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用要测试的函数并捕获结果
- en: ❹ Checks the expected value
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查预期值
- en: ❺ Provides clear error responses for easier debugging of tests
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 提供清晰的错误响应，以便更容易调试测试
- en: Here is our first test. You will notice a few interesting things about this
    code. The first is the `Arrange`, `Act`, `Assert` pattern that we have established.
    Do you notice how they translate from the Given, When, Then sentences from our
    business needs list? This is to help us focus on what we are testing and point
    back to a list of testable items. We’ll incorporate this back into the tests shortly
    so that the cases that we have covered are more clear.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的第一个测试。你将注意到这个代码中的一些有趣之处。首先是“安排”、“行动”、“断言”模式，这是我们建立的。你注意到它们是如何从业务需求列表中的“给定”、“当”、“然后”句子中转换过来的吗？这是为了帮助我们关注我们正在测试的内容，并指向一个可测试项的列表。我们将在不久的将来将这个模式结合到测试中，以便我们覆盖的案例更加清晰。
- en: You will also notice the use of the *black box* testing approach. This refers
    to code packages in which tests cannot see inside the code to see how it works.
    This allows us to write tests that assert behavior and not implementation. Remember
    that the system under test should be tested on its inputs and outputs and not
    how it works internally. This also requires you to think of an appropriate *interface*,
    or exposed definition for your application and code. The unit you are developing
    is an abstraction for others to use. Writing good tests helps drive a good interface.
    Having a good interface is important because once an interface is exposed, you
    will need to support it in the future, and it will become hard to change.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到使用*黑盒*测试方法。这指的是测试无法看到代码内部工作方式的代码包。这允许我们编写断言行为的测试，而不是实现。记住，应该测试系统在输入和输出上的表现，而不是其内部工作方式。这也要求你考虑一个合适的*接口*，或者你应用程序和代码的公开定义。你正在开发的单元是供他人使用的抽象。编写好的测试有助于推动良好的接口。拥有良好的接口很重要，因为一旦接口被公开，你将需要在将来支持它，而且它将变得难以更改。
- en: Run all of your tests by typing the Go test command `go test ./...`. You should
    see a failure. Now we need to fix it. Again, we will try to write the least amount
    of code possible to satisfy this test. We can handle that in our code by just
    returning the `word`, as in the following listing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入Go测试命令`go test ./...`运行所有测试。你应该看到失败。现在我们需要修复它。同样，我们将尝试编写尽可能少的代码来满足这个测试。我们可以在代码中通过只返回`word`来处理这个问题，如下面的列表所示。
- en: Listing 3.4 `translator.go`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 `translator.go`
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Provides the minimum effort in fixing the test
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在修复测试中提供最小的努力
- en: After running this test, you will see that it passes! This is what in *test-driven
    development* is called the *red, green, refactor*. First, the test fails the first
    expectation, giving you a red error; then you fix the test, which makes it go
    green; then you add to the test or change the underlying code to make it simpler,
    which is refactoring. This limits the amount of work you are doing for the given
    feature.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试后，你会看到它通过了！这就是在*测试驱动开发*中被称为*红、绿、重构*的东西。首先，测试未能满足第一个预期，给你一个红色的错误；然后你修复测试，使其变为绿色；然后你添加到测试或更改底层代码以使其更简单，这就是重构。这限制了为给定功能所做的工作量。
- en: Test-driven development is a design practice that many developers follow and
    was popularized by Kent Beck. In his book, *Test-Driven Development By Example*
    (Addison-Wesley Professional, 2002), Beck outlines a pattern of writing a failing
    test, making it pass, and then changing the code to make it fail again by taking
    an item off of the test list that we wrote earlier.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种许多开发者遵循的设计实践，由Kent Beck推广。在他的书《通过示例进行测试驱动开发》（Addison-Wesley Professional，2002年）中，Beck概述了一个编写失败测试、使其通过，然后通过从我们之前编写的测试列表中移除一项来使代码再次失败的模式。
- en: Why not just write all of the tests at once and be done with them? This is a
    great question and one that we should consider in a larger context. Test-driven
    development is a development pattern. It influences how you do something. By following
    this pattern, you are forcing developers to think through the code they are writing
    in the context of the requirements. It moves the development stage to a secondary
    operation by forcing the developer to first consider the requirements, prove that
    the requirements are satisfied, and then actually implement them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不一次性写完所有测试然后结束呢？这是一个很好的问题，我们应该在更广泛的背景下考虑。测试驱动开发是一种开发模式。它影响你做事的方式。通过遵循这个模式，你迫使开发者从需求的角度思考他们所写的代码。它通过迫使开发者首先考虑需求，证明需求得到满足，然后实际实现它们，将开发阶段移至次要操作。
- en: 'To think of this another way, you can view each test as an experiment you wish
    to do to *prove* that your code works. In the scientific method, there are three
    main steps you complete: question, test, and results. With your test code, you
    can wonder what the result of input *x* should be based on the expected business
    logic. Testing will call the method, and the results will be asserted in your
    code.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以另一种方式思考，你可以将每个测试视为你希望进行的实验，以*证明*你的代码是否工作。在科学方法中，有三个主要步骤你需要完成：问题、测试和结果。通过你的测试代码，你可以根据预期的业务逻辑推测输入*x*的结果。测试将调用方法，结果将在你的代码中断言。
- en: A developer, Ian Cooper, put it another way when he advocated for developers
    to be “duct tape programmers.” With a basic test and interface defined, the developers
    should just move forward and make it work. Then they can use tests to help refine
    their implementation, revisit it, and be confident that it works as expected.
    This drive helps developers meet the requirements without over-engineering a solution.
    Code is supposed to be dynamic, not static, so developers should be revisiting
    their code, refactoring it to be better, and constantly improving.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者 Ian Cooper 在提倡开发者成为“胶带程序员”时，用另一种方式表达了这一点。在定义了基本的测试和接口后，开发者应该继续前进并使其工作。然后他们可以使用测试来帮助他们完善实现，重新审视它，并确信它按预期工作。这种推动帮助开发者满足需求，而不需要过度设计解决方案。代码应该是动态的，而不是静态的，因此开发者应该定期回顾他们的代码，重构它以使其更好，并不断改进。
- en: We’ve now satisfied this test. To verify it, run your `go test ./...` command
    again, and see things passing. Now let’s add some more languages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经满足了这项测试。为了验证它，再次运行你的 `go test ./...` 命令，并查看是否通过。现在让我们添加更多语言。
- en: 3.3 Refactor, refactor, refactor
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 重构，重构，重构
- en: 'For our demo, we want to support some other languages. Let’s add German and
    Finnish to our requirements, and while we are at it, we can cross off one of our
    test cases:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们希望支持一些其他语言。让我们将德语和芬兰语添加到我们的需求中，同时，我们可以划掉我们的一个测试用例：
- en: Given a word when it is to be translated into English should then return the
    word.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个单词要翻译成英语时，应返回该单词。
- en: Given a capitalized word or language when translating should then return the
    same answer as an uncapitalized word or language.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译一个首字母大写的单词或语言时，应返回与未大写单词或语言相同的答案。
- en: Given a word or language with extra spaces when translating should then return
    the same answer as a word or language without spaces.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译一个带有额外空格的单词或语言时，应返回与没有空格的单词或语言相同的答案。
- en: Given a word or language when translating that is not supported should then
    return an empty string.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译一个不支持单词或语言时，应返回一个空字符串。
- en: Given the word *hello* when translating should then be translated into “hallo”
    and “hei” for languages German and Finnish.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译单词 *hello* 时，应翻译成德语和芬兰语的“hallo”和“hei”。
- en: We crossed off the first item because we have a satisfied test case. This does
    not mean that this test will never fail. It will fail eventually, but we have
    in place a test to protect us from having the business case missed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们划掉了第一个项目，因为我们有一个满足的测试用例。这并不意味着这个测试永远不会失败。它最终会失败，但我们已经实施了一个测试来保护我们不会错过业务案例。
- en: NOTE If you find yourself changing a test instead of changing the implementation,
    you should consider the business effect of the change. Tests align with business
    requirements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你发现自己是在更改测试而不是更改实现，你应该考虑更改的业务影响。测试与业务需求相一致。
- en: Let’s add some language support. We will update our tests to include the code
    in the following listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些语言支持。我们将更新我们的测试，包括以下列表中的代码。
- en: Listing 3.5 `translator_test.go`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 `translator_test.go`
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Tests to see if translation works for English
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试翻译是否适用于英语
- en: ❷ Tests to see if translation works for German
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试翻译是否适用于德语
- en: ❸ Tests to see if translation works for Finnish
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试翻译是否适用于芬兰语
- en: ❹ Tests to see that Dutch returns an empty string
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试荷兰语返回空字符串
- en: Run it, and see that the test fails.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，并查看测试是否失败。
- en: That means that we have different features to add to our service. Switch back
    to our `translator.go` file, and modify it so that we can handle these new test
    cases. Again, our tests are helping to drive the functionality of our code. Here
    we see that we are supporting translations in both German and Finnish but not
    Dutch, and that if a translation is not found, we return an empty string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要为我们的服务添加不同的功能。切换回我们的 `translator.go` 文件，并修改它，以便我们可以处理这些新的测试用例。同样，我们的测试正在帮助我们推动代码的功能。在这里我们看到我们支持德语和芬兰语的翻译，但不支持荷兰语，并且如果找不到翻译，我们返回一个空字符串。
- en: In this case, we are not just testing the “happy path” but also a negative one.
    Asserting the behavior of positive results is important, but more often than not,
    errors or edge cases are going to occur. *Edge cases* are rare or extreme conditions
    that can happen on a system and that you aren’t expecting. An example of this
    is inputting strange characters as input or very large or small numbers. Here
    we can say that we need to handle the case when we don’t have a translation for
    a language. The following listing outlines what the code would look like.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不仅测试了“正常路径”，还测试了负面路径。断言积极结果的行为很重要，但更常见的是，错误或边缘情况会发生。“边缘情况”是系统上可能发生而你又没有预料到的罕见或极端条件。一个例子是输入奇怪的字符作为输入或非常大或非常小的数字。在这里，我们可以说我们需要处理我们没有翻译的语言的情况。下面的列表概述了代码可能的样子。
- en: Listing 3.6 `translator.go`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 `translator.go`
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Checks the language being passed and returns the translated word
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查传入的语言并返回翻译后的单词
- en: ❷ If unknown, returns an empty string
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果未知，则返回空字符串
- en: You should be able to see your test pass now. This cycle can continue for a
    long time. In some cases, you can head off some of the minor things right away.
    Keep in mind that you shouldn’t leap too far ahead in your development at the
    risk of over-design. Try to anticipate some different use cases, as we will see
    in the next section. For now, we have established a pattern for working on this
    function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够看到你的测试通过了。这个周期可以持续很长时间。在某些情况下，你可以立即解决一些小问题。记住，你不应该在开发中跳得太远，以免过度设计。尝试预测一些不同的用例，正如我们将在下一节中看到的那样。现在，我们已经为这个函数的工作建立了一个模式。
- en: Can you see some other edge cases in our code? Did we capture them on our list?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在我们的代码中看到其他边缘情况吗？我们是否在我们的列表中捕捉到了它们？
- en: Tests will also need to be refactored to help make things clearer and easy to
    expand. I’m sure some of you who are familiar with writing software cringed a
    little at the repetitive code in our tests. We can alter our structure slightly
    to make it easier to add tests through the use of table tests. The following listing
    provides an example of how we can refactor our tests to be concise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试也需要重构以帮助使事情更清晰且易于扩展。我相信熟悉编写软件的你们中的一些人在看到我们测试中的重复代码时可能会皱一下眉头。我们可以稍微改变我们的结构，使其更容易通过使用表格测试添加测试。下面的列表提供了一个示例，说明我们如何重构我们的测试以使其简洁。
- en: Listing 3.7 `translator_test.go`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 `translator_test.go`
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates an array of anonymous structs containing all test cases
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含所有测试用例的匿名结构体数组
- en: ❷ Each case houses input and output results for tests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个案例包含测试的输入和输出结果。
- en: ❸ Iterates over sets of test cases
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历测试用例集
- en: ❹ Runs the test and captures the results
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 运行测试并捕获结果
- en: ❺ Checks results and responds with proper errors
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查结果并以适当的错误响应
- en: This pattern of testing is common in Go and other languages because it puts
    all of your test scenarios in one place and again pushes for a cleaner interface
    to our test code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试模式在 Go 和其他语言中很常见，因为它将所有的测试场景放在一个地方，并且再次推动我们测试代码的更清晰接口。
- en: Now our assertion area is very small and is no longer repeated, and our tests
    are organized in such a way that we can quickly add more results. Run your tests
    to make sure the refactoring worked. Everything should pass. Now let’s add a case
    that we may have not been expecting. Remember that our system is supposed to just
    handle “hello” for the time being. What happens if we input a word other than
    “hello”? Let’s see what happens when we add the code in the following listing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的断言区域非常小，不再重复，我们的测试以这种方式组织，我们可以快速添加更多结果。运行你的测试以确保重构有效。一切都应该通过。现在让我们添加一个我们可能没有预料到的案例。记住，我们的系统目前应该只处理“hello”。如果我们输入的不是“hello”这个词会发生什么？让我们看看当我们添加以下列表中的代码时会发生什么。
- en: Listing 3.8 `translator_test.go`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 `translator_test.go`
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Negative case of an untranslatable word and unsupported language
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 无法翻译的单词和不支持的语言的负面案例
- en: Run your test. It passes. Was this what you were expecting? Did you cover all
    of the other cases? Remember earlier when I asked about other edge cases? This
    is where you need to put on your user hat and not your developer hat to start
    seeing where your code can go wrong. Often, we rely on other team members to find
    these cases (often in QA), but if it has reached that point in testing, then you
    are wasting valuable cycles and potentially sending out bugs in your code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的测试。它通过了。这是你预期的吗？你覆盖了所有其他情况吗？记得我之前问过其他边缘情况吗？这就是你需要戴上用户帽而不是开发者帽，开始看到你的代码可能出错的地方。我们经常依赖其他团队成员来找出这些情况（通常在QA中），但如果测试已经到了那个阶段，那么你正在浪费宝贵的周期，并且可能正在发送带有错误的代码。
- en: NOTE The closer the quality checks are to the implementation, the less chance
    there is for rework, which translates into higher levels of work in progress,
    which translates to lost money.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：质量检查越接近实现，重做的机会就越小，这转化为更高水平的工作进度，进而转化为损失的钱。
- en: Alan Perlis, a famous computer scientist, once said, “A software system can
    best be designed if the testing is interlaced with the designing instead of being
    used after the design.” This sums up why we are focusing on unit tests at the
    moment. Unit tests can be integrated into our development process to create leaner
    and more well-defined code. The corresponding tests will help guard us against
    making business-level logic changes that would affect the system. This does not
    mean that more tests are better. What is needed are quality tests that assert
    functionality and not fragile tests that fail constantly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的计算机科学家艾伦·佩利斯曾经说过：“如果测试与设计交织在一起，而不是在设计之后使用，那么软件系统将得到最佳设计。”这总结了为什么我们现在专注于单元测试。单元测试可以集成到我们的开发过程中，以创建更精简和更明确的代码。相应的测试将帮助我们防止做出影响系统的业务级逻辑更改。这并不意味着测试越多越好。我们需要的是质量测试，它们断言功能，而不是经常失败的脆弱测试。
- en: Now that we can start thinking more from a user perspective, we can focus on
    adding more edge cases to our unit tests to ensure that things are working as
    expected. Let’s add another test (see the following code listing).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从用户的角度进行更多思考，我们可以专注于向我们的单元测试中添加更多边缘情况，以确保一切按预期工作。让我们再添加一个测试（见下面的代码列表）。
- en: Listing 3.9 `translator_test.go`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 `translator_test.go`
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Negative case of an untranslatable word with a supported language
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 支持语言中不可翻译单词的负面案例
- en: Run your test. Now you should see a failure! We get “hallo” back when we are
    looking for an empty string since we are only translating “hello.” How can we
    solve this? Go to our service again and add the code in the following listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的测试。现在你应该看到失败！当我们寻找空字符串时，我们得到了“hallo”，因为我们只翻译了“hello”。我们如何解决这个问题？再次访问我们的服务，并在下面的列表中添加代码。
- en: Listing 3.10 `translator.go`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 `translator.go`
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Adds check for supported word
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加对支持单词的检查
- en: Run your test again; now it passes! There is one final case we should possibly
    consider at this point. All too often developers will forget about input sanitation,
    or the process of making input uniform. This can range from white space being
    used, to negative numbers, invalid parameters, and uppercase or lowercase letters,
    just to name a few. How robust would our service be right now if we were to add
    uppercase letters? Let’s find out by adding the code in the following listing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的测试；现在它通过了！在这个时候，我们可能需要考虑一个最后的案例。开发者往往会忘记关于输入清理，或者使输入统一的过程。这可以包括空白字符的使用，到负数，无效参数，以及大写或小写字母，仅举几例。如果我们添加大写字母，我们的服务现在将有多强大？让我们通过在下面的列表中添加代码来找出答案。
- en: Listing 3.11 `translator_test.go`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 `translator_test.go`
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Edge case of capitalized language
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 大写语言边缘情况
- en: ❷ Edge case of the capitalized word
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 大写单词的边缘情况
- en: ❸ Edge case of space in word
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 单词中空格的边缘情况
- en: I know I said one final case, but here are three different test cases! Can you
    guess what the fixes need to be?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我说了一个最后的案例，但这里有三个不同的测试案例！你能猜出需要进行的修复是什么吗？
- en: Often it is the job of the service to implement “input sanitation” to ensure
    that the service is durable and flexible enough to handle most incoming messages.
    This is often a favorite verification technique that many QA members will attempt
    to do as soon as you create a service or a web page and should be handled at various
    levels just in case. In this instance, we can add a method that cleans the input
    for both the language and the word, using the code in the following listing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务的职责是实现“输入清理”以确保服务足够耐用和灵活，能够处理大多数传入的消息。这通常是一种许多QA成员在你创建服务或网页时就会尝试进行的 favorite
    验证技术，并且应该在各个级别上处理，以防万一。在这种情况下，我们可以添加一个方法来清理语言和单词的输入，使用以下列表中的代码。
- en: Listing 3.12 `translator.go`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 `translator.go`
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Sanitizes incoming word
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 清理传入的单词
- en: ❷ Sanitizes incoming language
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 清理传入的语言
- en: ❸ Creates a function to sanitize input
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个清理输入的函数
- en: Tests should pass now, but this is just the tip of the iceberg. We still have
    a lot of additional testing to do. We’ve only tackled the service layer, and it
    is still pretty fragile. Now we need to examine how the values get to the service
    in the first place, and this is through our handler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在应该通过，但这只是冰山一角。我们仍然有很多额外的测试要做。我们只处理了服务层，它仍然相当脆弱。现在我们需要检查值最初是如何到达服务的，这是通过我们的处理程序。
- en: 3.4 Testing pyramid
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 测试金字塔
- en: 'Earlier we identified three distinct pieces of our system to be tested: service,
    handler, and server. Each portion can be tested in different ways. Broadly, these
    tests are separated into two categories:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们确定了三个需要测试的系统部分：服务、处理程序和服务器。每个部分都可以用不同的方式进行测试。广义上，这些测试分为两大类：
- en: '*Unit-level tests*—Small, contained tests that run portions of code in isolation.
    These can be viewed as testing individual boards and screws that are building
    a bridge. If one is rotten or rusted, you don’t want to use it. In isolation,
    these tests become easier to write and manage and are the foundation of any automated
    test platform.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元级测试*—小型、独立的测试，在隔离状态下运行代码的部分。这些测试可以看作是测试正在建造桥梁的个别板和螺丝。如果一个已经腐烂或生锈，你不想使用它。在隔离状态下，这些测试变得更容易编写和管理，并且是任何自动化测试平台的基础。'
- en: '*System-level tests*—Require interactions between various code segments or
    systems. This category envelops a large number of testing types and practices
    that become complicated to manage and therefore become less reliable or more expensive
    (in time and resources) to run.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统级测试*—需要各种代码段或系统之间的交互。这个类别包括大量测试类型和实践，管理起来变得复杂，因此变得不太可靠或更昂贵（在时间和资源上）。'
- en: Figure 3.1 demonstrates this difference.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1展示了这种差异。
- en: '![](../../OEBPS/Images/CH03_F01_Holmes4.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH03_F01_Holmes4.png)'
- en: Figure 3.1 Testing is broken down into individual units, which are tested in
    isolation, and systems, which test how things work in integrated environments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1将测试分解为单个单元，这些单元在隔离状态下进行测试，以及系统，这些系统测试在集成环境中的工作方式。
- en: Unit tests are the fastest tests to run and should encompass all of the building
    blocks (or units) of our system. In figure 3.2, we can see testing as a pyramid
    wherein the unit tests form the base because of the number of tests. If the unit
    tests do not pass, we should not move up the testing pyramid to more extensive
    tests. This saves us time, as unit tests should be fast to run, easy to understand,
    and simple to debug. As we move up the pyramid, we see *integration* tests that
    verify the functionality between units of work, often including the integration
    with an external dependency such as a database. Finally, you have a layer of testing
    that verifies the system as a whole or tests it from end to end to see that the
    system works completely as expected. Additional types of end-to-end testing are
    available, such as *load testing*, which tests how the system functions with a
    large number of users. The inverted pyramid in figure 3.2 is an unstable pattern,
    while the regular pyramid supports itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是运行最快的测试，应该包括我们系统中的所有构建块（或单元）。在图3.2中，我们可以看到测试被看作是一个金字塔，其中单元测试构成了基础，因为测试的数量。如果单元测试没有通过，我们就不应该向上移动到测试金字塔的更广泛的测试。这可以节省我们的时间，因为单元测试应该运行得快，易于理解，并且易于调试。当我们向上移动金字塔时，我们看到
    *集成* 测试，这些测试验证了工作单元之间的功能，通常包括与外部依赖项（如数据库）的集成。最后，你有一个测试层，它验证整个系统或从端到端测试它，以查看系统是否完全按预期工作。还有其他类型的端到端测试可用，例如
    *负载测试*，它测试系统在大量用户下的功能。图3.2中的倒金字塔是一个不稳定的模式，而常规金字塔则能够自我支撑。
- en: '![](../../OEBPS/Images/CH03_F02_Holmes4.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F02_Holmes4.png)'
- en: Figure 3.2 End-to-end tests are smaller at the top because they are more expensive
    and not as dependable. They should be supported by larger suites of integration
    and unit tests. Each layer should run on its own. Start with unit tests and progress
    up the pyramid in different phases.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 端到端测试在顶部较小，因为它们更昂贵且不可靠。它们应该由更大的集成和单元测试套件支持。每一层都应该独立运行。从单元测试开始，然后在不同阶段向上移动金字塔。
- en: Moving up the pyramid on the left, each layer becomes smaller. This is because
    as we move up, the ability to run these tests become more expensive because they
    may require dependencies or more resources. They may also not be consistent in
    how they run, and therefore the results may not be *deterministic*, or predictable.
    If we were to flip the pyramid into a “snow cone” on the right, we can imagine
    the world we would be in. End-to-end tests constantly change because of the ever-evolving
    nature of our application. If we spend so much time expanding that level of testing,
    we will have an immense amount of rework with no ability to verify if the underlying
    modules are working. If a failure occurs, you untangle all of the inner workings
    of the system to verify the results, whereas if you have an extensive unit test
    suite, you can verify bugs or changes at the module level.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边的金字塔上向上移动，每一层都变得更小。这是因为当我们向上移动时，运行这些测试的能力变得更加昂贵，因为它们可能需要依赖项或更多资源。它们在运行方式上也可能不一致，因此结果可能不是**确定性的**，或不可预测的。如果我们把金字塔翻转成右边的“冰淇淋锥”，我们可以想象我们会处于一个怎样的世界。端到端测试不断变化，因为我们的应用程序的性质不断演变。如果我们花太多时间扩展这一级别的测试，我们将会有大量的返工，而无法验证底层模块是否正常工作。如果发生故障，你需要解开系统的所有内部工作来验证结果，而如果你有一个广泛的单元测试套件，你可以在模块级别验证错误或更改。
- en: You will find where you will need to expand or contract to test based on your
    team’s needs. We have already established unit tests at the service level, establishing
    our base. Now we want to expand it to include some other automated tests to ensure
    our system works as expected.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你将找到根据你团队的需求需要扩展或缩减以进行测试的地方。我们已经在服务级别建立了单元测试，建立了基础。现在我们希望将其扩展到包括一些其他自动化测试，以确保我们的系统按预期工作。
- en: 3.5 System testing
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 系统测试
- en: 'Now that we’ve established a separate service for translation, we can call
    this service with a REST handler. In Go and many programming languages or frameworks,
    the implementation of the HTTP protocol is agnostic to the output: HTML, plain
    text, GraphQL syntax, and almost anything that can be returned. We try to organize
    our Handler files by the type of response they send. In this case, we send a REST
    API response.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为翻译建立了一个独立的服务，我们可以使用REST处理程序来调用这个服务。在Go和许多编程语言或框架中，HTTP协议的实现与输出无关：HTML、纯文本、GraphQL语法，几乎任何可以返回的内容。我们试图根据它们发送的响应类型来组织我们的处理程序文件。在这种情况下，我们发送REST
    API响应。
- en: REST stands for *Representational State Transfer*, which is a generic name for
    a generic style of API writing. Though most will associate it with JSON (JavaScript
    Object Notation), it can also be used with files or the XML format. The design
    is extremely flexible using the basic HTTP calls (POST, PUT, DELETE, etc.) and
    using HTTP headers to send the information to the user to help decode the information.
    For right now, we will use JSON for our format.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: REST代表**表示性状态转移**，这是一个通用的API编写风格的名称。尽管大多数人会将其与JSON（JavaScript对象表示法）联系起来，但它也可以与文件或XML格式一起使用。该设计使用基本的HTTP调用（POST、PUT、DELETE等）以及使用HTTP头向用户发送信息以帮助解码信息，具有极高的灵活性。目前，我们将使用JSON作为我们的格式。
- en: 'To do this, we create a new package called `handlers/rest`. In it, we will
    create a file called `translate.go`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们创建一个新的包，名为`handlers/rest`。在其中，我们将创建一个名为`translate.go`的文件：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For now, we know that our service only handles a single word, “hello,” so we
    are only going to support that request; otherwise, we will return a “not found,”
    or 404 error. By default, the translation will be English unless the user passes
    `?language=` parameter. Let’s use the code in the following listing to build an
    empty handler to get our tests started.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们知道我们的服务只处理单个单词，“hello”，所以我们只支持那个请求；否则，我们将返回“未找到”，或404错误。默认情况下，翻译将是英语，除非用户传递`?language=`参数。让我们使用以下列表中的代码来构建一个空的处理程序以开始测试。
- en: Listing 3.13 `translator.go`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 `translator.go`
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ New rest package for API work
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新的API工作休息包
- en: ❷ Builds a struct to house the response structure
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建一个结构体来存放响应结构
- en: ❸ Hardcoded response for initial work
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 初始工作的硬编码响应
- en: I’m sure you realize that this is the content from our `main` function. However,
    we will replace this with the actual business logic shortly. This process allows
    us to iterate and test as we go. We have also pulled our handler out of the main
    function so that it can be easily tested. Like our unit test, we want to test
    just an individual portion of the code, but unlike our unit test, we depend on
    an external part of the same system to test. A change in the `translate` library
    would affect this test, so it is not considered a unit test but a system test.
    In future chapters, we will refactor this to work in isolation, but for now, we’ll
    have it integrate directly with the service (see the following listing).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经意识到这是来自我们的`main`函数的内容。然而，我们将很快用实际的业务逻辑来替换它。这个过程允许我们边迭代边测试。我们还把处理器从主函数中提取出来，以便它可以很容易地进行测试。像我们的单元测试一样，我们只想测试代码的一个部分，但与我们的单元测试不同，我们依赖于同一系统的外部部分进行测试。`translate`库的更改会影响这个测试，所以它不被视为单元测试，而是系统测试。在未来的章节中，我们将重构它以独立工作，但现在，我们将让它直接与服务集成（见以下列表）。
- en: Listing 3.14 `translator_test.go`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 `translator_test.go`
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Creates a new testing package to use black box testing
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的测试包以使用黑盒测试
- en: ❷ Imports a rest package for testing
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入rest包进行测试
- en: ❸ Creates an HTTP recorder that will be used for assertion
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个用于断言的HTTP记录器
- en: ❹ Creates a new request against a given endpoint with no body content
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个针对给定端点的新请求，没有正文内容
- en: ❺ Registers a handler to test against
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 注册一个用于测试的处理程序
- en: ❻ Serves the content to pass through the handler for a response based on the
    request
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将内容传递给处理器以根据请求生成响应
- en: ❼ Checks the status code from the response
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 检查响应的状态码
- en: ❽ Decodes the body of the response into a struct to be asserted
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将响应体解码为要断言的结构
- en: Run the tests, and you should get a failure! This is because we are not using
    the service to lowercase our messages. Let’s change our handler to now use the
    service instead of the hardcoded values we wrote. We will find that our tests
    in the handler and the service will be “tightly coupled,” meaning that changes
    in one affect the other and that the series of tests will look similar. But remember
    what we are testing here is not the logic of the service but rather the handling
    and transformation of the request and response process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，你应该得到一个失败！这是因为我们没有使用服务来将消息转换为小写。让我们将我们的处理器更改为现在使用服务而不是我们编写的硬编码值。我们会发现处理器和服务的测试将是“紧密耦合”的，这意味着一个的变化会影响另一个，并且测试序列将看起来很相似。但请记住，我们在这里测试的不是服务的逻辑，而是请求和响应处理和转换。
- en: You will also notice that we are not only asserting the body of the response
    message but also the status code. HTTP status codes help convey additional information
    to the end user by telling them what happened at a system level. 200 OK is one
    of the most common and tells us that everything went fine. Table 3.1 lists common
    codes to use to help send messages.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到，我们不仅断言响应消息的正文，还断言状态码。HTTP状态码通过告诉用户系统层面发生了什么来帮助传达额外的信息。200 OK是最常见的，告诉我们一切正常。表3.1列出了用于发送消息的常见代码。
- en: Table 3.1 Common HTTP messages that most APIs utilize
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 常见API使用的HTTP消息
- en: '| Code | Message | Common Uses |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Code | 消息 | 常见用途 |'
- en: '| 200 | OK | Everything went as expected. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 200 | OK | 一切如预期进行。 |'
- en: '| 201 | Created | New entity was added to the system. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 201 | 已创建 | 新实体已添加到系统中。 |'
- en: '| 401 | Unauthorized | Missing credentials. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 401 | 未授权 | 缺少凭证。 |'
- en: '| 403 | Forbidden | Not allowed to access to endpoint or resource. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 403 | 禁止 | 不允许访问端点或资源。 |'
- en: '| 404 | Not Found | Cannot find resource or endpoint. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 404 | 未找到 | 无法找到资源或端点。 |'
- en: '| 500 | Internal Server Error | System failed for some unknown reason. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 内部服务器错误 | 系统因某些未知原因失败。 |'
- en: '| 503 | Service Unavailable | System isn’t working and is known. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 503 | 服务不可用 | 系统不工作且已知。 |'
- en: In general, these codes are broken into several broader categories, as spelled
    out in table 3.2.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些代码被分为几个更广泛的类别，如表3.2所示。
- en: Table 3.2 General grouping of HTTP messages
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 HTTP消息的一般分组
- en: '| Code | Type | Common Uses |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| Code | 类型 | 常见用途 |'
- en: '| 1xx | Informational | Information about the system. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 1xx | 信息性 | 系统信息。 |'
- en: '| 2xx | Successful | Everything went as expected. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 2xx | 成功 | 一切如预期进行。 |'
- en: '| 3xx | Redirect | Something has moved and needs to change the request. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 3xx | 重定向 | 有所移动，需要更改请求。 |'
- en: '| 4xx | Client error | Client has something wrong. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 4xx | 客户端错误 | 客户端有错误。 |'
- en: '| 5xx | Server error | Server failed to process request. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 5xx | 服务器错误 | 服务器未能处理请求。 |'
- en: Our response code should reflect the type of message we are returning. The proper
    message in the body of our response should provide the necessary information.
    We do this by adding the code in the following listing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们响应代码应该反映我们返回的消息类型。我们响应体中的适当消息应提供必要的信息。我们通过在以下列表中添加代码来完成此操作。
- en: Listing 3.15 `translator.go`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 `translator.go`
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Sets the header for the content type to be a JSON specification
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置内容类型的头部为JSON规范
- en: ❷ Default language to English for now
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 目前默认语言为英语
- en: ❸ Gets word from the URL path
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从URL路径中获取单词
- en: ❹ Translates the word
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 翻译单词
- en: We will now add some additional functionality. But, as before, let’s restructure
    these tests to be table tests so that we can rapidly refactor what we are writing.
    We’ll rewrite it using the code in the following listing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加一些额外的功能。但就像之前一样，让我们重新结构化这些测试以成为表格测试，这样我们可以快速重构我们正在编写的代码。我们将使用以下列表中的代码来重写它。
- en: Listing 3.16 `translator_test.go`
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 `translator_test.go`
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Defines test cases to be an endpoint, status, translation, and language
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义测试案例为一个端点、状态、翻译和语言
- en: ❷ Registers Handler
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注册处理程序
- en: ❸ Iterates through all test scenarios
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历所有测试场景
- en: Run your tests, and you’ll see a new failure. Let’s fix the test (see the following
    code listing).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的测试，你会看到一个新的失败。让我们修复测试（见以下代码列表）。
- en: Listing 3.17 `translator.go`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 `translator.go`
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Retrieves language from query parameters
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从查询参数中检索语言
- en: Run your tests, and add one more case, where if a translation is missing, the
    response should be `404 Not Found` with no values. Let’s add it (see the following
    listing).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的测试，并添加一个额外的案例，如果翻译缺失，响应应该是没有值的`404 Not Found`。让我们添加它（见以下列表）。
- en: Listing 3.18 `translator_test.go`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 `translator_test.go`
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ On a missing language or translation, we should get a 404 error code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在缺少语言或翻译的情况下，我们应该得到404错误代码。
- en: See the failures, and fix the code (see the following listing).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 查看失败，并修复代码（见以下列表）。
- en: Listing 3.19 `translator.go`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 `translator.go`
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We should have success!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会成功！
- en: 3.6 Adding it to the pipeline
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 将其添加到管道中
- en: Now that we’ve refactored our services, we should update our function and add
    the tests to the pipeline. First, let’s update our `main.go` file to use our new
    handler and service (see the following listing).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了我们的服务，我们应该更新我们的函数并将测试添加到管道中。首先，让我们更新我们的`main.go`文件以使用我们新的处理程序和服务（见以下列表）。
- en: Listing 3.20 `main.go`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 `main.go`
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Sets the port to listen on
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置要监听的端口
- en: ❷ Registers the translation Handler
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注册翻译处理程序
- en: ❸ Logs the listening port
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 记录监听端口
- en: ❹ Runs the server and logs if it fails
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 运行服务器并记录如果它失败
- en: Ah, that looks so much cleaner! We have successfully pulled out a good portion
    of our application into smaller pieces that can be tested on their own, making
    the system easier to reason about. We’ve spent all of this time writing these
    tests so that we can use them to help verify functionality when we check our code.
    Once we add this to our pipeline it will be just like the build step in that it
    protects us from pushing broken changes out, yet testing becomes our first “gate”
    in the system.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，看起来整洁多了！我们已经成功地将应用程序的大部分内容拆分成更小的部分，这些部分可以单独进行测试，这使得系统更容易推理。我们花费了所有这些时间编写这些测试，以便在检查代码时可以使用它们来帮助验证功能。一旦我们将这些添加到我们的管道中，它将就像构建步骤一样，它保护我们不会推送有缺陷的更改，而测试成为我们系统中的第一个“关卡”。
- en: A *quality gate* is a term used in industrial engineering in which a product
    is checked for quality before various stages along the assembly line. You want
    to protect each stage from wasting time. In our little program, the build step
    runs fairly quickly, but on larger, more complicated systems, build times can
    take much longer, so we want to make sure we don’t waste time trying to build
    something that is broken or shipping code that doesn’t work as intended.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*质量关卡*是工业工程中的一个术语，其中在组装线各个阶段之前检查产品的质量。你希望保护每个阶段不浪费时间。在我们的小程序中，构建步骤运行得相当快，但在更大、更复杂的系统中，构建时间可能会更长，所以我们想确保我们不会浪费时间尝试构建有缺陷的东西或发送不按预期工作的代码。'
- en: Suppose that you are planning on cooking a meal. You mix a bunch of ingredients
    for a recipe to get to a step and realize that the main ingredient has gone bad.
    Now you either need to run to the store quickly or scrap the whole thing, wasting
    either time or money. But if you had checked the quality of all of the ingredients
    ahead of time, you would have been able to save yourself some trouble.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在计划做一顿饭。你混合了一堆原料按照食谱进行，然后意识到主要原料已经变质。现在你可能需要快速去商店或者丢弃整个东西，浪费时间和金钱。但如果你提前检查了所有原料的质量，你就可以避免一些麻烦。
- en: We will structure our pipeline to do the same. By adding a testing step before
    the build step, we can make sure that our code is running before we build. Most
    CI systems allow you to create a dependency graph between various steps in order
    to chain these steps together to save time and effort on the system as a whole.
    We will extend this in the future to add additional guards, builds, and deployments
    that can be run in parallel.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建我们的管道以执行相同的操作。通过在构建步骤之前添加测试步骤，我们可以确保在构建之前代码正在运行。大多数CI系统允许你在各个步骤之间创建依赖图，以便将这些步骤链接起来，从而在整个系统上节省时间和精力。我们将在未来扩展这一功能，以添加可以并行运行的额外保护、构建和部署。
- en: For now, let’s add the test check to the pipeline from the code in the following
    listing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将测试检查添加到以下列表中的代码管道中。
- en: Listing 3.21 `pipeline.yml`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.21 `pipeline.yml`
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Only runs on the main branch
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅在主分支上运行
- en: ❷ Defines base operating system
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义基本操作系统
- en: ❸ Sets up the Go environment
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置Go环境
- en: ❹ Checks out the code
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检出代码
- en: ❺ Runs tests
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 运行测试
- en: ❻ Waits for tests to pass before moving onto the build step
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在进行构建步骤之前等待测试通过
- en: Commit your changes, and push your branch! Go to your repository, and watch
    the tests run. Now you can see the results.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 提交你的更改，并推送你的分支！前往你的仓库，并观察测试运行。现在你可以看到结果。
- en: 3.7 Code coverage
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 代码覆盖率
- en: Writing tests to see if the code works is helpful. We added several tests to
    poke and prod various parts of our system and added functionality as we went.
    But did we get it all? Do we need to test *everything*?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试以查看代码是否工作是有帮助的。我们在进行过程中添加了几个测试来检查系统的各个部分，并添加了功能。但我们是否都做到了？我们需要测试*所有*内容吗？
- en: 'Many languages, including Go, provide the ability to see the “code coverage”
    of your tests, which means they will highlight a percentage of the code that has
    been tested and highlight areas that may have been missed. As your code grows,
    you will have branches of logic that you may need to test or additional error
    conditions that may occur, and it is always helpful to make sure you can extend
    the testing so you hit all of the areas you need. Let’s see how much we have already
    tested:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言，包括Go，提供了查看测试“代码覆盖率”的能力，这意味着它们会突出显示已测试代码的百分比，并突出显示可能被遗漏的区域。随着代码的增长，你将会有需要测试的逻辑分支或可能发生的额外错误条件，确保你可以扩展测试以覆盖所有需要测试的区域总是很有帮助。让我们看看我们已经测试了多少：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Figure 3.3 shows the coverage.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3显示了覆盖率。
- en: '![](../../OEBPS/Images/CH03_F03_Holmes4.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3输出反映了包中行的覆盖率](../../OEBPS/Images/CH03_F03_Holmes4.png)'
- en: Figure 3.3 Output reflects the coverage of lines in a package.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3显示了覆盖率。
- en: You should see a chart showing all of the tested files and the coverage amounts,
    along with a total at the bottom. The percentage tells us that we haven’t hit
    all of our code and should perhaps consider adding more testing. You may be wondering
    how much coverage is needed. Over time, your code coverage should increase due
    to the addition of more tests. This ensures that you are improving your system
    over time. This can mean writing more tests in areas that are lacking or even
    deleting unused code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个图表，显示所有已测试的文件和覆盖率数量，以及底部的总数。百分比告诉我们我们没有覆盖所有代码，也许我们应该考虑添加更多测试。你可能想知道需要多少覆盖率。随着时间的推移，你的代码覆盖率应该会随着更多测试的添加而增加。这确保了你在随着时间的推移改进你的系统。这可能意味着在缺乏测试的区域编写更多测试，甚至删除未使用的代码。
- en: 'Code coverage can be a hot topic in some development groups. Some people say
    you need to cover every line of code and test every possible way a portion of
    code can be executed to ensure the highest quality. While this is a worthwhile
    endeavor, it won’t mean that your code is working as intended. Attempting to reach
    total code coverage can lead to poorly written tests that are difficult to maintain
    over time. Often arbitrary goals like this, while well intended, lead toward blocking
    the overall goal of the company: delivering a product.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率在某些开发团队中可能是一个热门话题。有些人说你需要覆盖每一行代码，测试代码片段可以执行的每一种可能的方式，以确保最高的质量。虽然这是一个值得追求的目标，但这并不意味着你的代码按预期工作。试图达到总代码覆盖率可能导致编写糟糕的测试，这些测试随着时间的推移难以维护。通常，像这样的任意目标，虽然初衷良好，但可能导致阻碍公司整体目标：交付产品。
- en: What we want to do is enforce a certain level of testing, say 80%, and we also
    want to provide our developers an easy way to see if there are any branches or
    areas they are missing that they can easily add tests to. We will add some tools
    to our Makefile to make this easier.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要强制执行一定水平的测试，比如80%，我们还希望为我们的开发者提供一个简单的方法来查看是否有任何分支或区域他们遗漏了，他们可以轻松添加测试。我们将添加一些工具到我们的Makefile中，以使这更容易。
- en: Go has a built-in tool that allows you to output a coverage profile and then
    use tools that help you manipulate it so that you can see the coverage and generate
    a report. First, let’s open our Makefile and add the code in the following listing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个内置的工具，允许你输出覆盖率配置文件，然后使用帮助你操作它的工具，这样你就可以看到覆盖率并生成报告。首先，让我们打开我们的Makefile，并添加以下列表中的代码。
- en: Listing 3.22 Makefile
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.22 Makefile
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Generates the output coverage from the test
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从测试生成输出覆盖率
- en: ❷ Uses the code coverage tool to find the total line count and check the value
    to make sure it meets coverage expectations
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用代码覆盖率工具查找总行数并检查该值以确保满足覆盖率预期
- en: This script will help ensure that the coverage profile is created instead of
    just running `go` `test`. Remember, we want to provide the same tools to our developers
    that the pipeline will use to help keep the two in sync. The second line provides
    a bit of “Unix magic” that pipes the results from the coverage tool into a `grep`
    command to look for the total and then checks the result to make sure it is higher
    than our minimum testing threshold. The result of this will return an error code
    if the condition does not pass, meaning that our pipeline will fail.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将确保创建覆盖率配置文件，而不仅仅是运行`go test`。记住，我们希望为我们的开发者提供与管道相同的工具，以帮助保持两者同步。第二行提供了一些“Unix魔法”，它将覆盖率工具的结果通过管道传递到`grep`命令中，以查找总数，然后检查结果以确保它高于我们的最低测试阈值。如果条件不满足，此结果将返回一个错误代码，这意味着我们的管道将失败。
- en: Now we can use this same coverage profile to generate a coverage report, which
    we will add as an artifact to our pipeline. It will help guide our current and
    future testing efforts to see where we are lacking. This can also help leaders
    on the team determine if they should do a testing day where developers take a
    day to clean up code and add tests. We’ll discuss more activities like this in
    later chapters, but what you should understand now is that communication is key
    to building a successful team. Reports that come from the pipeline are great in
    helping steer the overall developer experience and product development as time
    goes on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个相同的覆盖率配置文件来生成一个覆盖率报告，我们将将其作为工件添加到我们的管道中。这将有助于指导我们当前的测试工作，并查看我们哪些地方做得不够。这也可以帮助团队领导决定是否应该进行一个测试日，让开发者花一天时间清理代码并添加测试。我们将在后面的章节中讨论更多类似的活动，但你现在应该明白，沟通是构建成功团队的关键。随着时间的推移，来自管道的报告在帮助引导整体开发者体验和产品开发方面非常出色。
- en: NOTE Communication is key to building a successful team.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：沟通是构建成功团队的关键。
- en: 'To generate a report, we will add another tool to the Makefile:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成报告，我们将在Makefile中添加另一个工具：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the report in figure 3.4, you will see lines that you have been able to test
    and those that have been missed. Do you see any areas that we could have tested?
    Can we refactor our code so that it is easier to get to these missing sections?
    Try it yourself to see if you can get to a higher level, and time yourself to
    see how long that takes and if it helps to solve a possible bug.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.4的报告中的报告中，你会看到你已经测试过的行和遗漏的行。你看到我们可能测试过的区域了吗？我们能重构我们的代码，使其更容易到达这些遗漏的部分吗？试着做一下，看看你是否能提高到一个更高的水平，并计时看看这需要多长时间，以及这是否有助于解决可能的错误。
- en: '![](../../OEBPS/Images/CH03_F04_Holmes4.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH03_F04_Holmes4.png)'
- en: Figure 3.4 Lines are highlighted in green if the test code has covered that
    code, while lines in red have not. If you are unable to differentiate the color,
    please note that the error section is the only untested area of the code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 如果测试代码覆盖了该代码，则行以绿色突出显示，而红色行则未覆盖。如果您无法区分颜色，请注意，错误部分是代码中唯一未测试的区域。
- en: 'These output files should be stored locally and should not be checked into
    our source control. Open your `.gitignore`, and add the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输出文件应存储在本地，并且不应提交到我们的源代码控制中。打开您的`.gitignore`文件，并添加以下内容：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we can update our CI code to run a coverage check and upload a report. Your
    team could do some additional steps post-processing to allow for publishing these
    results to a team dashboard or a Slack post for others to see easily, but for
    now, we will allow it to be downloaded along with the binary (see the following
    listing).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新我们的CI代码来运行覆盖率检查并上传报告。您的团队可以执行一些额外的后处理步骤，以便将这些结果发布到团队仪表板或Slack帖子，以便其他人可以轻松查看，但就目前而言，我们将允许它和二进制文件一起下载（见以下列表）。
- en: Listing 3.23 `pipeline.yml`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.23 `pipeline.yml`
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Uses the test make command
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用测试make命令
- en: ❷ Checks coverage for the tests
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查测试覆盖率
- en: ❸ Generates a report based on coverage
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 根据覆盖率生成报告
- en: ❹ Uploads reports to an archive
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将报告上传到存档
- en: We have now successfully added the first check on our system. Testing can seem
    cumbersome at first to some, and others may need convincing of its benefits, but
    it is an easy way to make sure you are moving forward with quality code. In the
    future, you will find a test that saves you from making a mistake. Even while
    writing this book, I’ve found that the tests that I’ve written have fixed bugs
    in my sample code. Stopping to think and work through the problems at hand helps
    you become a better developer as well.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功在我们的系统中添加了第一个检查。对于一些人来说，测试可能一开始会显得繁琐，而其他人可能需要被说服其好处，但这是一个确保您以高质量代码前进的简单方法。在未来，您会发现一个可以帮您避免犯错的测试。即使在编写这本书的过程中，我也发现我所编写的测试修复了我示例代码中的错误。停下来思考并解决手头的问题可以帮助您成为一名更好的开发者。
- en: Testing is a very sensitive area for some development teams. Some members will
    have a higher level of passion for it than others. It becomes important that you
    and your team establish the testing patterns and practices you’d like to accomplish
    and standardize them if possible. Testing should not become dogmatic, nor should
    it hinder the development of your product. It is a tool to tell your company and
    your customers that you are meeting their expectations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于某些开发团队来说是一个非常敏感的领域。一些成员可能比其他人对此有更高的热情。因此，您和您的团队建立您希望实现的测试模式和最佳实践，并在可能的情况下进行标准化是很重要的。测试不应成为教条，也不应阻碍您产品的开发。它是向您的公司和客户表明您正在满足他们期望的工具。
- en: You look up and see people leaving the office. It’s the end of the day, and
    you’ve committed and pushed your code. When you navigate to the repository, you
    see a nice little green check mark, and you smile. In a day, you’ve written a
    proof of concept with tests to go along with it. Tomorrow you will need to find
    a way to get it live before your demo at noon. Luckily, you have a plan in mind.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您抬头看到人们正在离开办公室。这是一天结束的时候，您已经提交并推送了您的代码。当您导航到仓库时，您会看到一个漂亮的绿色勾选标记，您笑了。在一天之内，您已经编写了一个带有测试的概念证明。明天您需要找到一种方法在中午的演示之前将其上线。幸运的是，您已经有了计划。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Automated testing helps validate that the system works as expected.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试有助于验证系统按预期工作。
- en: Unit tests are small, independently run tests that focus on a small portion
    of code.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试是小型、独立运行的测试，专注于代码的一小部分。
- en: System tests integrate into multiple modules that assert the overall behavior
    of the system.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试集成到多个模块中，这些模块断言系统的整体行为。
- en: Focus on testing the interface to the code and not the code itself.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于测试代码的接口，而不是代码本身。
- en: Strive for high test coverage, but it’s okay for it to be less than 100%.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力求高覆盖率，但低于100%也是可以的。
