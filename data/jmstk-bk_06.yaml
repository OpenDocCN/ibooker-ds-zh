- en: 5 Building an e-commerce site
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 构建电子商务网站
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Establishing the needs of a typical e-commerce site
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定典型电子商务网站的需求
- en: Comparing headless e-commerce systems for managing products and checkout
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较无头电子商务系统以管理产品和结账
- en: Choosing a static site generator for an e-commerce site
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为电子商务网站选择静态网站生成器
- en: Creating and configuring a new site using Next.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Next.js创建和配置新网站
- en: Building a product listing, product detail, and shopping cart in Next.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Next.js中构建产品列表、产品详情和购物车
- en: Importing and using Markdown content in a Next.js site
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Next.js网站中导入和使用Markdown内容
- en: An e-commerce site has many requirements that might make it seem ill-suited
    for an architecture based on static assets, as the Jamstack is. While the content
    aspects, such as product listings and detail pages, can be made to fit easily
    within a statically generated site, things like shopping carts, checkout processing,
    and order histories appear too dynamic and interactive to function without server-side
    rendering.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 电子商务网站有许多可能使其看起来不适合基于静态资产的架构（如Jamstack）的要求。尽管内容方面，如产品列表和详情页面，可以轻松地适应静态生成的网站，但像购物车、结账处理和订单历史这样的功能似乎过于动态和交互，没有服务器端渲染就无法运行。
- en: 'Up until only a three or four years ago, this is exactly the advice I would
    give: static site generators were not a good fit for e-commerce sites. However,
    the Jamstack does more than just build sites with static site generators. A core
    piece of the Jamstack is its ability to use JavaScript and APIs on the client
    side to enable dynamic functionality that would otherwise be impossible using
    static site tooling. Thus, it is entirely possible today to build fully functioning
    e-commerce sites using the Jamstack.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 直到三四年前，这正是我会给出的建议：静态网站生成器不适合电子商务网站。然而，Jamstack不仅仅是用静态网站生成器构建网站。Jamstack的核心功能之一是能够在客户端使用JavaScript和API来实现动态功能，这些功能使用静态网站工具是做不到的。因此，今天完全有可能使用Jamstack构建功能齐全的电子商务网站。
- en: Saying something is possible does not necessarily mean it is right. However,
    I’d argue that, in many if not most cases, adopting the Jamstack for e-commerce
    is the right idea. This is because there is a whole cottage industry of research
    showing the impact performance can have on conversion rates and, therefore, sales.
    For instance, one analysis found that “if a site makes $100,000/day, [a] one second
    improvement in page speed brings $7,000 daily” ([http://mng.bz/Nxj7](http://mng.bz/Nxj7)).
    In other words, the performance improvements that Jamstack offers will not only
    improve your users’ experiences, but that improved experience can improve your
    bottom line.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 说某事是可能的，并不意味着它就是正确的。然而，我会争辩说，在许多情况下，如果不是大多数情况下，采用Jamstack进行电子商务是正确的想法。这是因为有一整个小行业的研究表明性能可以对转化率以及因此产生的销售额产生影响。例如，一项分析发现，“如果一个网站每天赚10万美元，[页面速度]提高一秒就能带来7000美元的日收入”([http://mng.bz/Nxj7](http://mng.bz/Nxj7))。换句话说，Jamstack提供的性能改进不仅会提升用户体验，而且这种改进的用户体验还可以提高你的利润。
- en: 5.1 Requirements of an e-commerce site
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1 电子商务网站的要求
- en: E-commerce sites can vary greatly in complexity. Some sites provide only a handful
    of products or services and a simple checkout process, without any real feature
    frills. Others offer all kinds of dynamic content, such as user reviews, personalized
    recommendations, wish lists, and more. All these features are possible using the
    Jamstack, and some of the tools that we’ll discuss even offer special APIs for
    achieving them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 电子商务网站在复杂性上可以有很大差异。一些网站只提供少量产品或服务以及简单的结账流程，没有任何真正的功能装饰。其他网站提供各种动态内容，如用户评论、个性化推荐、愿望清单等。所有这些功能都使用Jamstack实现，我们讨论的一些工具甚至提供专门的API来实现这些功能。
- en: 'Let’s look at a few core requirements for a typical e-commerce site:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看典型电子商务网站的一些核心要求：
- en: An e-commerce site has a list of products or services. This content should be
    easily updated and managed through some form of content management system to allow
    for quick and easy updates by nontechnical users tasked with maintaining the site.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务网站有一系列产品或服务。这些内容应通过某种形式的内容管理系统轻松更新和管理，以便非技术用户能够快速轻松地更新网站。
- en: E-commerce sites have regular content pages beyond the product listings for
    things like the About page or terms of service. In most cases, these are infrequently
    updated, so they may not require integration within external content management.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务网站除了产品列表之外，还有常规的内容页面，如关于页面或服务条款。在大多数情况下，这些页面更新不频繁，因此可能不需要集成到外部内容管理中。
- en: E-commerce sites generally have a shopping cart where users can dynamically
    add and remove items and proceed to the checkout process.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务网站通常有一个购物车，用户可以动态添加和删除商品，然后进行结账流程。
- en: An e-commerce site must have a checkout process to complete the purchase. In
    most cases this is integrated within the site, but in some cases the final checkout
    process can be offloaded to a third party for processing and confirmation.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务网站必须有一个结账流程来完成购买。在大多数情况下，这集成在网站上，但在某些情况下，最终的结账流程可以外包给第三方进行处理和确认。
- en: 5.1.1 The example site requirements
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 示例网站要求
- en: The example we’re going to build for this chapter is a simple storefront, called
    the Jam Store, for selling toy figures and rubber ducks. It includes all the basic
    requirements discussed. Currently, we have a limited inventory of only four items,
    but we expect it to expand (see figure 5.1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本章构建的示例是一个简单的店面，称为“果酱店”，用于销售玩具人偶和橡皮鸭。它包括所有讨论的基本要求。目前，我们只有四个商品的有限库存，但我们预计它会扩大（见图
    5.1）。
- en: '![CH05_F01_Camden2](Images/CH05_F01_Camden2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F01_Camden2](Images/CH05_F01_Camden2.png)'
- en: Figure 5.1 The final result of our example e-commerce project is a store that
    sells toy figures.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 我们这个示例电子商务项目的最终结果是出售玩具人偶的商店。
- en: Our site will integrate with content management for adding and editing our product
    listings. However, our other content page—our About page—will be infrequently
    updated, so it will be managed as simply a Markdown file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网站将集成内容管理以添加和编辑我们的产品列表。然而，我们的其他内容页面——我们的关于页面——更新不频繁，因此它将作为一个简单的 Markdown 文件进行管理。
- en: Users will be able to add items to their shopping cart from the product detail
    page. They’ll be able to modify quantities or delete items from their cart via
    the My Cart page before proceeding to checkout. Since we’re small (and for the
    sake of simplicity), the checkout process will be offloaded to a third party to
    manage final shipping and order confirmation details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将从产品详情页面添加商品到购物车。他们可以通过“我的购物车”页面修改数量或删除商品，然后再进行结账。由于我们规模较小（以及为了简化），结账流程将外包给第三方来管理最终的运输和订单确认细节。
- en: 5.2 Choosing the right tools
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2 选择合适的工具
- en: There are myriad ways to build a Jamstack e-commerce site, including building
    a custom solution from scratch. However, there are a lot of complexities in e-commerce
    that can make this a bit of a daunting task. The Jamstack generally favors leveraging
    existing services wherever possible to simplify development, and in this case,
    we’ll use a type of service called headless e-commerce.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个 Jamstack 电子商务网站有无数种方法，包括从头开始构建自定义解决方案。然而，电子商务中有许多复杂性，可能会使这项任务显得有些令人畏惧。Jamstack
    通常倾向于尽可能利用现有服务以简化开发，在这种情况下，我们将使用一种称为无头电子商务的服务。
- en: 5.2.1 What is headless e-commerce?
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 什么是无头电子商务？
- en: In chapter 4, we learned about a concept called a headless CMS, wherein the
    CMS provides the backend content management tools that are decoupled from the
    frontend presentation. Headless e-commerce is the same concept applied to e-commerce
    tooling. A *headless e-commerce solution* provides the tools for managing a shopping
    cart, orders, shipping, and, in many cases, products/services and inventory that
    are not tied to a specific frontend solution, allowing you to customize the frontend
    to suit your needs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们了解了一个名为无头 CMS 的概念，其中 CMS 提供了与前端展示解耦的后端内容管理工具。无头电子商务是将此概念应用于电子商务工具。一个
    *无头电子商务解决方案* 提供了管理购物车、订单、运输以及在很多情况下，与特定前端解决方案无关的产品/服务及库存的工具，允许您根据需要自定义前端。
- en: 'I’d argue there is even more variation in the types of headless e-commerce
    than in headless CMS, where we had just two primary types (API-based and Git-based).
    There are no commonly accepted categories of headless CMSs, but—borrowing from
    the work of François Lanthier Nadeau ([https://snipcart.com/blog/headless-ecommerce](https://snipcart.com/blog/headless-ecommerce))—CEO
    of SnipCart (one of the solutions we’ll discuss), here are the broad types:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为无头电子商务的类型比无头 CMS 的类型更多样化，在无头 CMS 中我们只有两种主要类型（基于 API 和基于 Git）。没有普遍接受的无头 CMS
    类别，但——借鉴 François Lanthier Nadeau 的研究成果（[https://snipcart.com/blog/headless-ecommerce](https://snipcart.com/blog/headless-ecommerce)）——SnipCart（我们将讨论的解决方案之一）的
    CEO（一位无头电子商务领域的专家），以下是广泛的类型：
- en: '*All-in-one solutions*—As the name implies, these provide full packages to
    manage every aspect of an e-commerce site, from content to products, to orders,
    shipping, and so on. In most cases, these tools are more geared toward a full-stack
    solution (coupled) that provides both the front- and backend for the site, but
    they also offer APIs to access the backend as a decoupled headless alternative
    that can be used in a Jamstack site.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全栈解决方案*——正如其名所示，这些解决方案提供全面的服务来管理电子商务网站的各个方面，从内容到产品，再到订单、运输等等。在大多数情况下，这些工具更倾向于提供全栈解决方案（耦合）的网站，既提供前端也提供后端，但它们也提供
    API 以作为解耦的无头替代方案，可以在 Jamstack 网站中使用。'
- en: '*Add-on solutions*—These tools offer a complete shopping cart and checkout
    solution that effectively lie on top of your site. This is typically done by including
    a script that embeds an overlay. These tools usually don’t manage content and
    don’t necessarily require that you manage your product listings through their
    service.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*增强型解决方案*——这些工具提供完整的购物车和结账解决方案，实际上是在你的网站之上运行的。这通常是通过包含一个嵌入覆盖层的脚本来完成的。这些工具通常不管理内容，也不一定要求你通过他们的服务管理你的产品列表。'
- en: '*API-based solutions*—Like their headless CMS counterparts, all of the functionality
    from these services is available only via API calls. While the backend manages
    everything from products to shopping carts, orders, and shipping, they make no
    assumptions on how the frontend is built. Everything from adding and removing
    items from a cart to the checkout process is handled via calls to the API, using
    JavaScript in the case of a Jamstack site.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于 API 的解决方案*——与它们的无头 CMS 对应物一样，这些服务的所有功能都仅通过 API 调用提供。虽然后端管理从产品到购物车、订单和运输的各个方面，但它们对前端构建方式没有假设。从添加和删除购物车中的项目到结账过程，所有这些操作都是通过调用
    API 来处理的，在 Jamstack 网站的情况下使用 JavaScript。'
- en: 'From a Jamstack perspective, both the all-in-one solutions and the API-based
    solutions will be consumed the same way: a Jamstack site will use the APIs provided
    by the all-in-one solution rather than rely on any of the frontend development
    tools.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Jamstack 的角度来看，无论是全栈解决方案还是基于 API 的解决方案，它们的消费方式都是相同的：一个 Jamstack 网站将使用全栈解决方案提供的
    API，而不是依赖任何前端开发工具。
- en: The add-on solutions generally require the least amount of development effort,
    but the tradeoff is usually in ease of customizability. Once you’ve built a site
    with product/ service listings, you can simply connect it with the headless e-commerce
    tool that manages the rest. On the other hand, the all-in-one and API-based solutions
    both require more development effort, as the frontend for things like the cart
    and checkout need to be custom built, but by relying on only APIs, the developer
    can create the frontend however they choose.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 增强型解决方案通常需要的开发工作量最少，但通常以可定制性为代价。一旦你用产品/服务列表构建了网站，你只需简单地将其连接到管理其余部分的头颈电子商务工具。另一方面，全栈和基于
    API 的解决方案都需要更多的开发工作量，因为像购物车和结账这样的前端需要定制构建，但通过仅依赖 API，开发者可以按照自己的选择创建前端。
- en: 'TIP For a more in-depth look at a range of headless e-commerce options, check
    out this detailed post by Bejamas: [https://bejamas.io/blog/jamstack-ecommerce/](https://bejamas.io/blog/jamstack-ecommerce/).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：想深入了解一系列无头电子商务选项，请查看 Bejamas 的这篇详细文章：[https://bejamas.io/blog/jamstack-ecommerce/](https://bejamas.io/blog/jamstack-ecommerce/)。
- en: 5.2.2 Headless e-commerce options
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 无头电子商务选项
- en: Before we get into which option we’ll choose, let’s look at a few of the most
    popular headless e-commerce solutions, one from each category.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论我们将选择哪种选项之前，让我们先看看一些最受欢迎的无头电子商务解决方案，每个类别中各一个。
- en: Shopify
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify
- en: Shopify ([https://shopify.dev/](https://shopify.dev/)) is one of the most popular
    all-in-one e-commerce options on the market. Shopify’s services can be used in
    a Jamstack site via their Storefront API ([https://shopify.dev/api/storefront](https://shopify.dev/api/storefront)).
    This is a GraphQL API that offers access to the full range of Shopify’s services
    for product information, orders, and checkout. Shopify also offers a JavaScript
    SDK [(http://mng.bz/Dxja)](http://mng.bz/Dxja) for the Storefront API, which simplifies
    the code needed to interact with their API. Butcher Box (see figure 5.2) and Victoria
    Beckham Beauty are two storefronts built with the Jamstack and that access the
    Shopify’s Storefront API.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify ([https://shopify.dev/](https://shopify.dev/)) 是市场上最受欢迎的全功能电子商务选项之一。Shopify
    的服务可以通过他们的 Storefront API ([https://shopify.dev/api/storefront](https://shopify.dev/api/storefront))
    在 Jamstack 网站中使用。这是一个提供对 Shopify 产品信息、订单和结账等全面服务的 GraphQL API。Shopify 还提供了一个用于
    Storefront API 的 JavaScript SDK [(http://mng.bz/Dxja)](http://mng.bz/Dxja)，它简化了与他们的
    API 交互所需的代码。Butcher Box（见图 5.2）和 Victoria Beckham Beauty 是两个使用 Jamstack 构建，并访问
    Shopify Storefront API 的店面。
- en: '![CH05_F02_Camden2](Images/CH05_F02_Camden2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F02_Camden2](Images/CH05_F02_Camden2.png)'
- en: Figure 5.2 Butcher Box is an example of an online store built with the Jamstack
    and that uses Gatsby to access the Storefront API.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 Butcher Box 是一个使用 Jamstack 构建，并使用 Gatsby 访问 Storefront API 的在线商店的例子。
- en: Snipcart
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Snipcart
- en: Snipcart ([https://snipcart.com/](https://snipcart.com/)) is an example of an
    add-on e-commerce solution. At its most basic, enabling a site to work with Snipcart
    only requires that it include the Snipcart JavaScript and CSS files and then add
    custom HTML attributes to an Add to Cart button. That’s it. The link will trigger
    the Snipcart cart overlay to appear with all of the cart management and checkout
    features built in. Snipcart does include a number of customization options as
    well as a JavaScript SDK if you want to access any of its features programmatically
    rather than via the embedded cart and checkout.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Snipcart ([https://snipcart.com/](https://snipcart.com/)) 是一个附加电子商务解决方案的例子。在最基本的情况下，使网站与
    Snipcart 一起工作只需要包含 Snipcart 的 JavaScript 和 CSS 文件，然后向“添加到购物车”按钮添加自定义 HTML 属性。就这样。链接将触发
    Snipcart 购物车覆盖层出现，其中包含所有内置的购物车管理和结账功能。Snipcart 还包括一些定制选项，以及一个 JavaScript SDK，如果您想通过编程方式访问其任何功能而不是通过嵌入的购物车和结账。
- en: 'NOTE For a quick tutorial on setting up a Jamstack site built with Hugo that
    uses Snipcart for e-commerce functionality, check out this tutorial and sample
    app: [https://www.stackbit.com/blog/ecommerce-jamstack/](https://www.stackbit.com/blog/ecommerce-jamstack/).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您想快速了解使用 Hugo 构建，并使用 Snipcart 进行电子商务功能的 Jamstack 网站的设置教程，请查看这篇教程和示例应用程序：[https://www.stackbit.com/blog/ecommerce-jamstack/](https://www.stackbit.com/blog/ecommerce-jamstack/)。
- en: Commerce.js
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Commerce.js
- en: Commerce.js ([https://commercejs.com/](https://commercejs.com/)) is an example
    of an API-based headless e-commerce solution that has been used to build sites
    like INGMARSON, shown in figure 5.3\. It provides all of the tools for building
    an e-commerce site—product management, discounts, shopping cart, checkout, and
    more—that can be managed via a web-based backend but are accessed within your
    application through the JavaScript SDK and command-line tool. To help you get
    started, they also provide prebuilt example sites using popular web frameworks
    like React and Vue. Our sample application will use Commerce.js.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Commerce.js ([https://commercejs.com/](https://commercejs.com/)) 是一个基于 API 的无头电子商务解决方案的例子，它已被用于构建如图
    5.3 所示的 INGMARSON 网站等。它提供了构建电子商务网站所需的所有工具——产品管理、折扣、购物车、结账等，这些可以通过基于网络的后端进行管理，但在您的应用程序中通过
    JavaScript SDK 和命令行工具访问。为了帮助您开始，他们还提供了使用流行的网络框架如 React 和 Vue 的预构建示例网站。我们的示例应用程序将使用
    Commerce.js。
- en: '![CH05_F03_Camden2](Images/CH05_F03_Camden2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F03_Camden2](Images/CH05_F03_Camden2.png)'
- en: Figure 5.3 INGMARSON is an online clothing retailer that used the Jamstack with
    Gatsby and Snipcart to enable its e-commerce features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 INGMARSON 是一个使用 Gatsby 和 Snipcart 的 Jamstack 构建在线服装零售商，它启用了其电子商务功能。
- en: 5.2.3 Why Commerce.js?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 为什么选择 Commerce.js？
- en: The decision to use commerce.js wasn’t purely driven by the technical requirements
    of our sample application. The goal of the sample application, beyond being functional,
    is to teach some of the underlying concepts required to use Jamstack tools and
    frameworks. By requiring more custom code, using an API-based solution will allow
    us to explore more of the code needed to build a Jamstack application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用commerce.js的决定并不仅仅是由我们示例应用程序的技术需求驱动的。除了功能性之外，示例应用程序的目标是教授使用Jamstack工具和框架所需的一些基本概念。通过需要更多自定义代码，使用基于API的解决方案将使我们能够探索构建Jamstack应用程序所需的一些代码。
- en: 'If you are evaluating which type of solution to choose, here are my recommendations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在评估选择哪种类型的解决方案，以下是我的建议：
- en: Choose an add-on solution if your priority is building your site quickly and
    easily over customizing the shopping cart or checkout process.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的优先级是快速轻松地构建网站而不是定制购物车或结账流程，请选择一个附加解决方案。
- en: Choose an API-based solution if your priority is to maintain control over the
    design and user experience, including the shopping cart and checkout, and you
    are comfortable with the additional code it will require.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的优先级是保持对设计和用户体验的控制，包括购物车和结账流程，并且您对需要额外代码感到舒适，请选择基于API的解决方案。
- en: From a technical Jamstack point of view, you’ll choose an all-in-one solution
    for the same reasons you choose an API-based solution. However, in some cases
    there may be additional features offered or existing business relationships that
    may make an all-in-one option a better fit.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从技术角度考虑，您会选择一个一站式解决方案，原因与您选择基于API的解决方案相同。然而，在某些情况下，可能会有额外的功能提供或现有的商业关系，这可能使一站式解决方案更适合。
- en: 5.2.4 Static site generator options
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 静态网站生成器选项
- en: 'There aren’t any specific static site generators (SSGs)—that I am aware of—that
    are geared toward e-commerce, so really any SSG will work. Nonetheless, we’re
    planning on integrating with APIs both at build time—to populate product listings—and
    on the client-side—to enable shopping cart functionality. JavaScript-based SSGs
    make it easy to integrate with APIs during build time, and, more specifically,
    the JavaScript framework-based options can offer tools that make some of the client-side
    scripting easier. Let’s look at a few of these options:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我所了解的没有特定的静态网站生成器（SSG）专门针对电子商务，所以实际上任何SSG都可以工作。尽管如此，我们计划在构建时与API集成——以填充产品列表——以及在客户端集成——以启用购物车功能。基于JavaScript的SSG在构建时与API集成变得容易，而且更具体地说，基于JavaScript框架的选项可以提供使一些客户端脚本更容易的工具。让我们看看这些选项中的几个：
- en: '*Gatsby*—Gatsby is a very popular React-based SSG. Some things that make Gatsby
    unique are its use of GraphQL for accessing data, including things like content
    and other internal data structures, as well as its plug-in system. Gatsby’s large
    community has created thousands of plug-ins (over 2,500 as of this writing) that
    cover nearly any functionality or integration you might need.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Gatsby*—Gatsby是一个非常流行的基于React的SSG。使Gatsby独特的一些事情是它使用GraphQL来访问数据，包括内容和其他内部数据结构，以及其插件系统。Gatsby庞大的社区已经创建了数千个插件（截至本文撰写时超过2,500个），几乎覆盖了您可能需要的任何功能或集成。'
- en: '*Next.js*—Next.js is a React-based meta framework (a framework on top of a
    framework). It is not purely a static site generator. Next.js can be used for
    creating a standard React single-page application (SPA) with server-side rendering
    (SSR). It also provides tools to generate sites as static assets for a Jamstack
    application, but it even allows a site to determine whether a specific route (i.e.,
    a path within the application) should be dynamic or static. This allows developers
    to build applications that are “hybrid,” combining both SSR and static.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Next.js*—Next.js是一个基于React的元框架（一个框架之上的框架）。它不仅仅是一个静态网站生成器。Next.js可以用于创建具有服务器端渲染（SSR）的标准React单页应用程序（SPA）。它还提供了生成作为Jamstack应用程序静态资源的工具，但甚至允许网站确定特定的路由（即应用程序内的路径）应该是动态的还是静态的。这允许开发者构建“混合”应用程序，结合SSR和静态。'
- en: '*Nuxt.js*—As the name might imply, Nuxt.js shares a lot of similarities with
    Next.js, including the ability to use it for either SSR or static (and Nuxt 3
    has added support for the hybrid SSR/SSG approach). However, Nuxt.js uses the
    Vue framework rather than React.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Nuxt.js*—正如其名称可能暗示的那样，Nuxt.js与Next.js有很多相似之处，包括能够用于SSR或静态（Nuxt 3还增加了混合SSR/SSG方法的兼容性）。然而，Nuxt.js使用Vue框架而不是React。'
- en: '*Gridsome*—Gridsome has a lot in common with Gatsby. It includes a lot of core
    features that define Gatsby—its use of GraphQL, its focus on generating static
    assets for Jamstack, and its plug-in ecosystem—but uses Vue instead of React.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Gridsome*——Gridsome 与 Gatsby 有很多共同之处。它包括许多定义 Gatsby 的核心功能——它的 GraphQL 使用、它对生成
    Jamstack 静态资产的关注以及它的插件生态系统——但使用 Vue 而不是 React。'
- en: '*Scully*—While there are numerous React-based and Vue-based SSGs, Scully is,
    as of this writing, the only option for developers who prefer to use the Angular
    framework. It is geared toward developing pure static-based Jamstack applications
    and has a plug-in ecosystem like Gatsby and Gridsome.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Scully*——虽然有许多基于 React 和 Vue 的 SSG，但截至本文撰写时，Scully 是唯一一个面向喜欢使用 Angular 框架的开发者的选项。它专注于开发基于纯静态的
    Jamstack 应用程序，并拥有类似于 Gatsby 和 Gridsome 的插件生态系统。'
- en: We’ll be using Next.js to build our sample application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Next.js 来构建我们的示例应用程序。
- en: 5.2.5 Why Next.js?
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 为什么选择 Next.js？
- en: 'So which static site generator should you use? Honestly, it mostly comes down
    to personal preference. Unless your e-commerce site has a specific need that is
    addressed by the availability of SSR in either Next.js or Nuxt.js, any of the
    options listed will work just as well. The question then becomes: do you prefer
    React, Vue, or Angular? Beyond that, it is simply a matter of features (GraphQL,
    plug-ins) or style preference.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该使用哪个静态站点生成器呢？说实话，这主要取决于个人喜好。除非你的电子商务网站有特定的需求，而这个需求可以通过 Next.js 或 Nuxt.js
    中 SSR 的可用性来满足，否则列出的任何选项都能同样好地工作。那么问题就变成了：你更喜欢 React、Vue 还是 Angular？除此之外，这只是关于功能（GraphQL、插件）或风格偏好的问题。
- en: Recent versions of Next.js also offer a new form of rendering called incremental
    static regeneration (ISR) that can be particularly useful for e-commerce sites
    with a large number of products and therefore lots of pages. ISR essentially defers
    the rendering of a page until it is first requested by a user. This means that
    an e-commerce site with thousands of products might only need to generate the
    most popular 200 product pages and render the remaining pages when they are first
    requested. This means that the first user who requests a page may see a small
    delay in receiving the page, but subsequent users will receive the page as if
    they were statically generated. You can learn more about ISR in the Vercel docs
    ([http://mng.bz/lanB](http://mng.bz/lanB)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 的最新版本还提供了一种新的渲染形式，称为增量静态再生（ISR），这对于拥有大量产品因而页面众多的电子商务网站尤其有用。ISR 实质上是在用户首次请求页面时才进行渲染。这意味着拥有数千个产品的电子商务网站可能只需要生成最受欢迎的
    200 个产品页面，并在首次请求时渲染剩余的页面。这意味着第一个请求页面的用户可能会在收到页面时看到轻微的延迟，但后续用户将像静态生成一样收到页面。您可以在
    Vercel 文档中了解更多关于 ISR 的信息（[http://mng.bz/lanB](http://mng.bz/lanB)）。
- en: 5.3 Getting set up to build the example e-commerce site
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3 准备构建示例电子商务网站
- en: Now that we’ve made our tool choices—Commerce.js for e-commerce and Next.js
    for the SSG—let’s get started building the sample application. The first thing
    we need to do is get everything set so that we can begin coding.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做出了工具选择——使用 Commerce.js 进行电子商务和 Next.js 进行 SSG——让我们开始构建示例应用程序。我们需要做的第一件事是设置好一切，以便我们可以开始编码。
- en: 5.3.1 Setting up Next.js
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 设置 Next.js
- en: 'Next.js doesn’t install like some of the examples in prior chapters that used
    binaries or global npm installs. Instead, Next.js provides a tool called Create
    Next App ([https://nextjs.org/docs/api-reference/create-next-app](https://nextjs.org/docs/api-reference/create-next-app))
    to generate a new site, either a blank or one from a long list of starter templates.
    This doesn’t require you install anything but instead a npx command: a package
    runner built into npm that can run an npm script without requiring an install.
    You can run npx create-next-app without any parameters, and it will create a simple
    one-page web app with the basic default Next.js application files and folder structure.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 的安装方式与之前章节中使用的某些示例不同，那些示例使用了二进制文件或全局 npm 安装。相反，Next.js 提供了一个名为 Create
    Next App 的工具（[https://nextjs.org/docs/api-reference/create-next-app](https://nextjs.org/docs/api-reference/create-next-app)），用于生成一个新的网站，无论是空白网站还是从长长的起始模板列表中选择的一个。这不需要你安装任何东西，而是需要一个
    npx 命令：一个内置在 npm 中的包运行器，可以在不要求安装的情况下运行 npm 脚本。你可以不带任何参数运行 npx create-next-app，它将创建一个简单的单页网页应用程序，包含基本的默认
    Next.js 应用程序文件和文件夹结构。
- en: 'Create Next App can also use a template. This can be any GitHub repo, but the
    Next.js team already provides over 250 examples [(https://github.com/vercel/next.js/
    tree/main/examples)](https://github.com/vercel/next.js/tree/main/examples) that
    you can use. We’ll use one of these examples, with-tailwindcss, as the basis for
    our example e-commerce store that sells toy figurines. We’re going to build a
    product listing page, product detail page, and shopping cart, but to make this
    easier, we’ll take advantage of the starter templates that Next.js provides. The
    particular starter we’ve chosen includes the Tailwind CSS library that will give
    us some basic styling building blocks to work with. This is a huge help: while
    I am many things, a designer is not one of them. To learn more about Tailwind,
    check out [tailwindcss.com](https://tailwindcss.com/).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Create Next App 还可以使用模板。这可以是任何 GitHub 仓库，但 Next.js 团队已经提供了超过 250 个示例 [(https://github.com/vercel/next.js/tree/main/examples)](https://github.com/vercel/next.js/tree/main/examples)，你可以使用这些示例。我们将使用这些示例之一，with-tailwindcss，作为我们示例电子商务商店的基础，该商店销售玩具人偶。我们将构建产品列表页面、产品详情页面和购物车，但为了使这更容易，我们将利用
    Next.js 提供的启动模板。我们选择的特定启动模板包括 Tailwind CSS 库，这将为我们提供一些基本的样式构建块来工作。这对我们来说是一个巨大的帮助：虽然我是许多事物，但设计师不是其中之一。想了解更多关于
    Tailwind 的信息，请访问 [tailwindcss.com](https://tailwindcss.com/)。
- en: 'Let’s get started by running create-next-app and specifying the Tailwind CSS
    example. Run the following command wherever you keep your web projects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从运行 create-next-app 并指定 Tailwind CSS 示例开始。在你的网页项目存储位置运行以下命令：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create Next App will ask you for a project name. This will be used as the name
    of the folder that the project will be placed within. For this example, let’s
    use next-ecommerce. Create Next App will not only generate the project files,
    but also install all the dependencies for us. All we need to do is change the
    directory into the project folder and run it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Create Next App 会要求你输入项目名称。这将用作项目放置的文件夹名称。在这个例子中，让我们使用 next-ecommerce。Create
    Next App 不仅会生成项目文件，还会为我们安装所有依赖项。我们只需要将目录切换到项目文件夹并运行它：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you prefer to use npm instead of Yarn, you can alternatively run npm run
    dev.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 npm 而不是 Yarn，你可以运行 npm run dev 作为替代。
- en: By default, the site will be running at http://localhost:3000\. If you open
    that in the browser, you should see the standard Next.js start shown in figure
    5.4.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，网站将在 http://localhost:3000 上运行。如果你在浏览器中打开它，你应该会看到图 5.4 中显示的标准 Next.js
    启动画面。
- en: '![CH05_F04_Camden2](Images/CH05_F04_Camden2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F04_Camden2](Images/CH05_F04_Camden2.png)'
- en: Figure 5.4 The default Next.js site that is generated when running npx create-next-app
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 运行 npx create-next-app 生成的默认 Next.js 网站
- en: Let’s start by adding a basic navigation component for this site (listing 5.1).
    The pages we’ll link to aren’t created yet, but we’ll fix that soon enough. First,
    create a components folder in the root of your site and create a file named nav.js
    inside that folder. We’ll have two navigation items that are set in the links
    variable as “My Cart” and “About.” These will link to /cart and /about, respectively.
    We loop through the links in this array using the JavaScript map() function to
    create the navigation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为这个网站添加一个基本的导航组件开始（列表 5.1）。我们将链接到的页面尚未创建，但我们很快就会解决这个问题。首先，在网站的根目录下创建一个名为
    components 的文件夹，并在该文件夹内创建一个名为 nav.js 的文件。我们将有两个导航项，在 links 变量中设置为“我的购物车”和“关于”。这些将分别链接到
    /cart 和 /about。我们使用 JavaScript 的 map() 函数遍历这个数组中的链接来创建导航。
- en: Listing 5.1 The updated navigation in /components/nav.js
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 /components/nav.js 中的更新后的导航
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ll use this component to display the navigation across our pages. Let’s start
    by clearing out much of the default content on the default site’s home page and
    include the navigation component. For now, the page only imports the nav.js component
    and displays it above the main section that, for now, contains some dummy text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个组件来在页面间显示导航。让我们先清除默认网站主页上的大部分默认内容，并包含导航组件。目前，页面只导入 nav.js 组件并在主部分上方显示它，目前这部分包含一些占位文本。
- en: Listing 5.2 Including the navigation in /pages/index.js
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 在 /pages/index.js 中包含导航
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that our project code is set, we need to set up and populate Commerce.js
    so that we can populate the data on the page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了项目代码，我们需要设置并填充 Commerce.js，以便我们可以在页面上填充数据。
- en: 5.3.2 Setting up Commerce.js
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 设置 Commerce.js
- en: 'To get started, we’ll need to sign up for a Commerce.js account via [commercejs.com](https://commercejs.com/).
    Don’t worry: the free account is generous enough for the purposes of this example.
    Once you’re signed up, you’ll be brought to the dashboard. This is where we’ll
    create the categories and products that will populate our e-commerce store. I’ll
    provide you some guidance on what to populate these with, but I should note that
    you are free to use whatever you choose; there is nothing in the code we’ll write
    that requires that you use the products and categories I use.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要通过 [commercejs.com](https://commercejs.com/) 注册一个Commerce.js账户。不用担心：免费账户对于本例的目的来说已经足够慷慨了。注册后，您将被带到仪表板。这就是我们将创建将填充我们的电子商务商店的类别和产品的地方。我将为您提供一些关于如何填充这些信息的指导，但应该注意的是，您可以使用您选择的任何内容；我们编写的代码中没有任何内容要求您使用我使用的产品和类别。
- en: In order for our e-commerce toy figurine store to work, it will need some products,
    each of which will be assigned to a category. We’ll need to populate these within
    Commerce.js via their web-based backend.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的电子商务玩具人偶店能够运行，它需要一些产品，每个产品都将被分配到一个类别。我们需要通过它们的基于Web的后端在Commerce.js中填充这些信息。
- en: 'Let’s start by creating some categories. As you saw in figure 5.1, our store
    is comprised of some toys, figurines, and rubber ducks. Thus, we’ll create two
    categories: Figures and Ducks. To create categories, click the Products navigation
    item on the left-hand side of the Commerce.js dashboard and then choose Categories.
    We’ll need to provide a category name, and it will auto-fill a slug for us. We
    can use the default that it provides (figure 5.5).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一些类别开始。正如您在图5.1中看到的，我们的商店由一些玩具、人偶和橡皮鸭组成。因此，我们将创建两个类别：人偶和鸭子。要创建类别，请点击Commerce.js仪表板左侧的“产品”导航项，然后选择“类别”。我们需要提供类别名称，它将自动为我们填写一个别名。我们可以使用它提供的默认值（图5.5）。
- en: '![CH05_F05_Camden2](Images/CH05_F05_Camden2.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F05_Camden2](Images/CH05_F05_Camden2.png)'
- en: Figure 5.5 Create a new product category within the Commerce.js dashboard.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 在Commerce.js仪表板中创建一个新的产品类别。
- en: Next, let’s create some products. Click the Products item on the left-hand navigation
    and then click Products. There is a lot of detail we can provide (see figure 5.6),
    but, for our purposes, we don’t need to fill in all of them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些产品。点击左侧导航栏中的“产品”项，然后点击“产品”。我们可以提供很多详细信息（见图5.6），但就我们的目的而言，我们不需要填写所有这些信息。
- en: '![CH05_F06_Camden2](Images/CH05_F06_Camden2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F06_Camden2](Images/CH05_F06_Camden2.png)'
- en: Figure 5.6 Create a new product within the Commerce.js dashboard. Please note
    that, for readability purposes, only the relevant sections of the page are displayed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 在Commerce.js仪表板中创建一个新的产品。请注意，为了可读性，只显示了页面上的相关部分。
- en: 'As we create new products, the key items to complete are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建新产品时，需要完成的关键项如下：
- en: '*Name*—Feel free to name the product however you like.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*名称*—您可以随意命名产品。'
- en: '*Description*—Again, feel free to add whatever type of description you choose.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*—再次，您可以自由添加您选择的任何类型的描述。'
- en: '*Categories*—Assuming you used the suggested categories, this will be either
    Figures or Ducks.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类别*—假设您使用了建议的类别，这将要么是“插图”要么是“鸭子”。'
- en: '*Price*—Provide whatever price you want.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*价格*—提供您想要的任何价格。'
- en: '*Images*—I’ve provided some sample images in the book’s GitHub repository [(https://github.com/cfjedimaster/the-jamstack-book)](https://github.com/cfjedimaster/the-jamstack-book).
    For our design, we’ll need two images for each product: one that is 400 × 400
    px and one that is 350 × 192px.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图片*—我在本书的GitHub仓库中提供了一些示例图片 [(https://github.com/cfjedimaster/the-jamstack-book)](https://github.com/cfjedimaster/the-jamstack-book)。对于我们的设计，我们需要为每个产品提供两张图片：一张是400
    × 400 px，另一张是350 × 192px。'
- en: '*Custom permalink*—A random permalink will be generated automatically if you
    don’t provide one, but it’s best that we do. This will be used within the application
    to construct the path to view the product.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义永久链接*—如果您不提供，系统会自动生成一个随机永久链接，但最好我们还是提供。这将用于应用程序中构建查看产品的路径。'
- en: Once we’ve created some products, we’re ready to go back to the project we generated
    and start coding. But first, we’ll need our API key to allow our project to access
    the data in Commerce.js. Click the Developer item on the left-hand navigation
    menu and then choose API keys. We’ll just need to copy the public key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一些产品，我们就可以回到我们生成的项目并开始编码。但首先，我们需要我们的API密钥，以便我们的项目可以访问Commerce.js中的数据。点击左侧导航菜单中的“开发者”项，然后选择“API密钥”。我们只需要复制公钥。
- en: 5.3.3 Setting Next.js environment variables
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 设置Next.js环境变量
- en: If you still have the local web server running your site, go ahead and stop
    it for now, as we’ll be making changes to the site’s configuration.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然在运行本地Web服务器来运行你的网站，请现在停止它，因为我们将对网站的配置进行更改。
- en: In order to connect to the Commerce.js API from our site, we’ll need the API
    key. However, we need to keep that key in a place that doesn’t expose it directly
    in our code, which will be checked into GitHub. Next.js includes the ability to
    automatically load environment variables (see [https://nextjs.org/docs/basic-features/environment-variables](https://nextjs.org/docs/basic-features/environment-variables)),
    which can be used to keep secrets like API keys or general configuration variables
    that you intend to reuse throughout your application. We will store our Commerce.js
    public API key as an environment variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的网站连接到Commerce.js API，我们需要API密钥。然而，我们需要将这个密钥放在一个不会直接在我们的代码中暴露的地方，这个代码将被提交到GitHub。Next.js包括自动加载环境变量的能力（见[https://nextjs.org/docs/basic-features/environment-variables](https://nextjs.org/docs/basic-features/environment-variables)），这可以用来存储像API密钥或你打算在整个应用程序中重复使用的通用配置变量等秘密。我们将把我们的Commerce.js公开API密钥存储为环境变量。
- en: Create a file named .env.local in the root of your project. By default, any
    variable we store in this file will be accessible via process.env.ENV_VARIABLE_NAME.
    For instance, a variable named CHEC_PUBLIC_KEY would be accessible as process.env
    .CHEC_PUBLIC_KEY. This is only accessible in the Node.js environment, either on
    the server in the case of an SSR application or in the build when using Next.js
    as an SSG. If you need to access this variable via client-side JavaScript, you
    can prefix the name of the variable with NEXT_PUBLIC_.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录下创建一个名为.env.local的文件。默认情况下，我们在这个文件中存储的任何变量都可以通过process.env.ENV_VARIABLE_NAME访问。例如，名为CHEC_PUBLIC_KEY的变量可以通过process.env.CHEC_PUBLIC_KEY访问。这仅在Node.js环境中可用，无论是作为SSR应用程序的服务器端，还是在使用Next.js作为SSG时的构建过程中。如果你需要通过客户端JavaScript访问这个变量，你可以将变量的名称前缀为NEXT_PUBLIC_。
- en: 'We’ll need this variable to configure the Commerce.js SDK at build time, so
    we do not need it to be public. Let’s put the following contents in .env.local,
    replacing {{MY_API_KEY}} with your Commerce.js public API key:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个变量在构建时配置Commerce.js SDK，因此我们不需要将其设置为公开。让我们在.env.local文件中放入以下内容，将{{MY_API_KEY}}替换为你的Commerce.js公开API密钥：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The .env file is useful for keeping things like API keys that you don’t want
    to publish in your project repository. While this is intended to be a public key
    and will be accessible for people who inspect any API calls we make from the client,
    it’s still advisable to keep it out of your published code. Plus, this gives us
    a single place to store the variable and reuse it wherever necessary within the
    application. The .env.local should already be in the .gitignore file that was
    generated with the project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: .env文件对于存储像API密钥这样的东西很有用，你不想在项目存储库中发布。虽然这是一个公开密钥，并且可以从客户端检查我们发出的任何API调用的人访问，但仍然建议将其从发布代码中排除。此外，这给我们提供了一个存储变量的单一位置，并在应用程序中需要时重复使用它。.env.local应该已经包含在项目生成的.gitignore文件中。
- en: 5.3.4 Loading the Commerce.js SDK
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 加载Commerce.js SDK
- en: 'Commerce.js provides a Commerce.js SDK ([https://commercejs.com/docs/](https://commercejs.com/docs/))
    that helps make it easier for us to interact with the Commerce.js API via JavaScript.
    Let’s install the SDK via Yarn. Run the following command. Be sure you are in
    the root of your site when running this command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Commerce.js提供了一个Commerce.js SDK（[https://commercejs.com/docs/](https://commercejs.com/docs/)），它帮助我们通过JavaScript更容易地与Commerce.js
    API交互。让我们通过Yarn安装SDK。运行以下命令。确保你在运行此命令时位于网站的根目录：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To configure the SDK, we need to pass the API key that we stored as an environment
    variable in the previous section. We don’t want to have to pass this on every
    page that uses the SDK, so let’s create a lib file that configures the SDK we
    can reuse throughout the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置SDK，我们需要传递我们在上一节中存储为环境变量的API密钥。我们不希望在每个使用SDK的页面上传递这个密钥，所以让我们创建一个lib文件来配置SDK，这样我们就可以在整个应用程序中重复使用它。
- en: 'Create a folder named lib in the root of your project and then a file named
    commerce.js. This file will import the SDK and set the API key within a new instance
    of the Commerce object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录下创建一个名为lib的文件夹，然后创建一个名为commerce.js的文件。这个文件将导入SDK并在Commerce对象的新实例中设置API密钥：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, whenever we need to use the Commerce.js SDK, we only need to import lib/commerce,
    and we’ll have access to the already configured Commerce.js SDK object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们需要使用Commerce.js SDK时，我们只需要导入lib/commerce，我们就可以访问已经配置好的Commerce.js SDK对象。
- en: 5.4 Building the Jam Store e-commerce site
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4 构建“Jam Store”电子商务网站
- en: Everything is set up for our example e-commerce site that sells toy figurines.
    We’ve run create-next-app to generate a project with some basic site code for
    us to start with, which includes Tailwind CSS for some styling. We’ve also populated
    Commerce.js with some sample products and categories that will populate our store.
    Finally, we set up the Commerce.js SDK within our project and the API key stored
    as an environment variable so that we can connect to Commerce.js from our site.
    Now we can begin to create our product listing page, product detail page, and
    shopping cart to make our e-commerce site complete.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都已为我们的示例电子商务网站搭建完毕，该网站销售玩具人偶。我们已运行`create-next-app`来生成一个项目，其中包含一些基本的网站代码，以便我们开始，这包括用于一些样式的Tailwind
    CSS。我们还用一些示例产品和类别填充了Commerce.js，以填充我们的商店。最后，我们在项目中设置了Commerce.js SDK，并将API密钥存储为环境变量，以便我们可以从我们的网站连接到Commerce.js。现在我们可以开始创建我们的产品列表页面、产品详情页面和购物车，以使我们的电子商务网站完整。
- en: We’re going to cover a lot of code in the upcoming sections. The goal here is
    to explore some of the key aspects you’ll need to understand how to build sites
    using Next.js. It isn’t critical that you understand every line of each code listing.
    I’ll call out any of the critical concepts and portions that you need to pay attention
    to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将涵盖大量的代码。这里的目的是探索一些你需要了解如何使用Next.js构建网站的关键方面。并不是你必须理解每个代码列表的每一行。我将指出任何关键概念和需要你注意的部分。
- en: 5.4.1 Creating the product listing component
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 创建产品列表组件
- en: Let’s build the home page that will list all of the available products pulled
    from Commerce.js. We’ll get some help from Tailblocks ([https://tailblocks.cc/](https://tailblocks.cc/)),
    a repository of ready-to-use code blocks built for Tailwind. Our product listing
    and product detail pages will be based on some of the code samples from their
    e-commerce category.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个主页，该主页将列出从Commerce.js获取的所有可用产品。我们将从Tailblocks ([https://tailblocks.cc/](https://tailblocks.cc/))获取一些帮助，Tailblocks是一个为Tailwind构建的现成代码块存储库。我们的产品列表和产品详情页面将基于他们电子商务类别中的某些代码示例。
- en: The product listing will loop over the products and display a product card.
    Let’s create the product card as a reusable component. Create a folder named products
    within the components directory, and then create a file named ProductList.js inside
    the folder.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 产品列表将遍历产品并显示产品卡。让我们创建一个可重用的产品卡组件。在components目录中创建一个名为products的文件夹，然后在文件夹中创建一个名为ProductList.js的文件。
- en: Let’s look at the code for the ProductList.js component that will be used to
    generate each product card in the product listing. This component takes a product
    object that is passed via props and populates the values in the product card.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用于生成产品列表中每个产品卡的ProductList.js组件的代码。该组件接收通过props传递的产品对象，并在产品卡中填充值。
- en: We’ll write ProductList to accept properties (props) that we’ll pass in when
    we use this component. This is how we’ll pass in the product that will populate
    the page.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写ProductList来接受属性（props），当使用此组件时我们将传递这些属性。这就是我们将传递将填充页面的产品的方式。
- en: The component will return the HTML that will be rendered by the component, populating
    the various dynamic elements using the product details in the product property
    that is passed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将返回由组件渲染的HTML，使用传递的产品属性中的产品详细信息填充各种动态元素。
- en: Listing 5.3 The product card component in /components/products/ProductList.js
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 /components/products/ProductList.js中的产品卡组件
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You may notice that we import the next/link component ([https://nextjs.org/docs/api-reference/next/link](https://nextjs.org/docs/api-reference/next/link)).
    This is a helper component that is built into Next.js for client-side route transitions
    that are common in most single-page applications, enabling faster page loads.
    In this component, we use the link component to link to the product detail page
    using the permalink property we set on the product in Commerce.js.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们导入了next/link组件 ([https://nextjs.org/docs/api-reference/next/link](https://nextjs.org/docs/api-reference/next/link))。这是一个内置在Next.js中的辅助组件，用于大多数单页应用中常见的客户端路由转换，从而实现更快的页面加载。在这个组件中，我们使用链接组件通过在Commerce.js中设置的产品上的永久链接属性来链接到产品详情页面。
- en: One other thing worth noting is that each product returned by Commerce.js will
    have an array of images associated with it—in our case two because we’ve added
    two images for each product. For the product listing, we need the smaller thumbnail
    that is 350 pixels wide. In order to get this, we use a JavaScript array filter
    function ([http://mng.bz/Bx8r](http://mng.bz/Bx8r)) to loop through the product
    assets array and filter any images that are not 350 pixels wide. We set the thumbnail
    variable to the first item in the returned array.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Commerce.js 返回的每个产品都将有一个与之关联的图像数组——在我们的例子中是两个，因为我们为每个产品添加了两张图片。对于产品列表，我们需要宽度为
    350 像素的小缩略图。为了获取这个缩略图，我们使用 JavaScript 数组过滤函数 ([http://mng.bz/Bx8r](http://mng.bz/Bx8r))
    遍历产品资源数组，并过滤掉任何不是 350 像素宽度的图像。我们将缩略图变量设置为返回数组中的第一个项目。
- en: 5.4.2 Building the product listing
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 构建产品列表
- en: Let’s combine the ProductList component and the commerce lib file to create
    the home page listing. Let’s look at the final code for index.js. This code replaces
    the existing contents of index.js that we created earlier. This page calls the
    Commerce.js API within a special method of Next.js called getStaticProps().
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 ProductList 组件和 commerce 库文件结合起来创建主页列表。让我们看看 index.js 的最终代码。这段代码替换了之前创建的
    index.js 中的现有内容。这个页面在 Next.js 的一个特殊方法 getStaticProps() 中调用 Commerce.js API。
- en: The getStaticProps()method is one of Next.js’ built-in data-fetching methods.
    It is called at build time, so it is specifically designed for static routes within
    your Next.js application. Because we are building a typical Jamstack application,
    all of our routes are generated as static assets. We can use getStaticProps()
    to get any data our page needs and add it to the props object. In this case, we
    only need the array of products that will be passed into our output, where we
    will loop though the products, passing each product to the ProductList component
    we created earlier to output the product card.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: getStaticProps() 方法是 Next.js 内置的数据获取方法之一。它在构建时被调用，因此专门设计用于 Next.js 应用程序中的静态路由。由于我们正在构建一个典型的
    Jamstack 应用程序，所有路由都作为静态资源生成。我们可以使用 getStaticProps() 获取页面所需的任何数据，并将其添加到 props 对象中。在这种情况下，我们只需要传递给输出的产品数组，我们将遍历这些产品，将每个产品传递给之前创建的
    ProductList 组件以输出产品卡片。
- en: Listing 5.4 The home page, including the product listing in /pages/index.js
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 主页，包括 /pages/index.js 中的产品列表
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is worth noting that you need to import both /lib/commerce.js, which sets
    up our Commerce.js SDK to connect to the API, and /components/products/ProductList.js,
    which is the component for the product card that we created earlier. As we loop
    through, passing each product as a property into ProductList, we also set a unique
    key property. This helps React identify changes within the virtual DOM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你需要导入 /lib/commerce.js，它设置我们的 Commerce.js SDK 以连接到 API，以及 /components/products/ProductList.js，这是我们之前创建的产品卡片组件。当我们遍历，将每个产品作为属性传递给
    ProductList 时，我们还设置了一个唯一的键属性。这有助于 React 识别虚拟 DOM 中的变化。
- en: You may also notice that our getStaticProps() method is set as async. This is
    done so that we can use the JavaScript await operator. This allows us to reduce
    the amount of code needed by waiting for the result of an API call that returns
    a JavaScript promise, as the Commerce.js SDK does. Thus, our products constant
    waits for the commerce.products.list() method to return a result, preventing us
    from trying to return the value in the props before the API response is received.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，我们的 getStaticProps() 方法被设置为异步。这样做是为了我们可以使用 JavaScript 的 await 操作符。这允许我们通过等待返回
    JavaScript promise 的 API 调用的结果来减少所需的代码量，正如 Commerce.js SDK 所做的那样。因此，我们的 products
    常量等待 commerce.products.list() 方法返回结果，防止我们在收到 API 响应之前尝试在 props 中返回值。
- en: If we restart the server and reload the page in our browser, we should now see
    the products we entered via the Commerce.js dashboard listed. It should look like
    the image we saw in figure 5.1.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新启动服务器并在浏览器中重新加载页面，我们现在应该会看到通过 Commerce.js 控制台输入的产品列表。它应该看起来像我们在图 5.1 中看到的图像。
- en: 5.4.3 Building the Product Detail page
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 构建产品详情页面
- en: We’ll need to generate a product detail page dynamically for each product returned
    by Commerce.js (see listing 5.5). To do this, we’re going to use a feature of
    Next.js called *dynamic routes* ([https://nextjs.org/docs/routing/dynamic-routes](https://nextjs.org/docs/routing/dynamic-routes)).
    A dynamic route is recognizable because the file name is surrounded by square
    brackets. The text between the brackets will be the parameter we’ll use to generate
    the page. Let’s see how this works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为 Commerce.js 返回的每个产品动态生成一个产品详情页（见列表 5.5）。为此，我们将使用 Next.js 的一个名为 *动态路由*
    的功能 ([https://nextjs.org/docs/routing/dynamic-routes](https://nextjs.org/docs/routing/dynamic-routes))。动态路由可以通过文件名被方括号包围来识别。方括号之间的文本将是我们将用于生成页面的参数。让我们看看它是如何工作的。
- en: If you recall from when we created the ProductList component, we want the path
    to our product detail page to be /product/[permalink], where [permalink] is the
    permalink value we set in the product’s properties in Commerce.js. We’ll do this
    by creating a /pages/products folder and creating a [permalink].js file within
    that folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们创建 ProductList 组件的时候，我们希望产品详情页的路径为 /product/[permalink]，其中 [permalink]
    是在 Commerce.js 中设置的产品属性中的永久链接值。我们将通过创建一个 /pages/products 文件夹并在该文件夹内创建一个 [permalink].js
    文件来实现这一点。
- en: There will be a number of things happening on this page that we’ll need to work
    out so that items can be added to the shopping cart, but, for now, let’s focus
    on getting the detail pages to display. We render the product that we will pass
    to the component (we’ll get to that in a moment), which pulls the proper image
    for the page based on the image width.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上将发生许多事情，我们需要解决这些问题，以便可以将项目添加到购物车中，但，现在，让我们专注于让详情页显示出来。我们渲染将要传递给组件的产品（我们稍后会讨论这一点），它根据图像宽度拉取页面上的正确图像。
- en: Listing 5.5 The Product Detail page in /pages/product/[permalink].js
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 /pages/product/[permalink].js 中的产品详情页
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Perhaps you saw the strange property we used called dangerouslySetInnerHTML.
    Because the product description can contain HTML formatting, we need to render
    it using innerHTML in the DOM. However, in simple terms, since React uses a virtual
    DOM, we need to notify React that we are setting the innerHTML, which requires
    the use of the dangerouslySetInnerHTML method. (You can read this article [[http://mng.bz/doYv](http://mng.bz/doYv)]
    for a more in-depth explanation.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可能您注意到了我们使用的那个名为 dangerouslySetInnerHTML 的奇怪属性。因为产品描述可能包含 HTML 格式，我们需要在 DOM
    中使用 innerHTML 来渲染它。然而，简单来说，由于 React 使用虚拟 DOM，我们需要通知 React 我们正在设置 innerHTML，这需要使用
    dangerouslySetInnerHTML 方法。（您可以阅读这篇文章 [[http://mng.bz/doYv](http://mng.bz/doYv)]
    以获得更深入的说明。）
- en: At this point, all we’ve done is render the HTML, but, because this is a dynamic
    route, we need to tell Next.js what pages to render when it outputs the static
    files for our site. In our case, we plan on rendering one for each product using
    the permalink for each to determine the file name of the page. To do this, we’ll
    need to add another special method built into Next.js for generating static sites
    called getStaticPaths(), as seen in listing 5.6.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是渲染了 HTML，但由于这是一个动态路由，我们需要告诉 Next.js 在输出我们网站的静态文件时渲染哪些页面。在我们的情况下，我们计划为每个产品渲染一个页面，使用每个产品的永久链接来确定页面的文件名。为此，我们需要添加另一个内置
    Next.js 的用于生成静态站点的特殊方法，即 getStaticPaths()，如列表 5.6 所示。
- en: Listing 5.6 The getStaticPaths() and getStaticProps() methods
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 getStaticPaths() 和 getStaticProps() 方法
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The getStaticPaths() method returns an array of path strings. We’ll use Commerce.js
    to return a list of products and then populate these path strings with the product
    permalinks. The only other thing we need to return is a fallback key. When this
    key is false, as we’ve set, any path not returned by this method will return a
    404\. If it is true, Next.js will return a fallback version of the page instead
    of a 404\. This would be useful if we were generating a large number of pages,
    causing a slow build. For any page not yet rendered, the user would see a loading
    indicator while getStaticProps() is called to populate the page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: getStaticPaths() 方法返回一个路径字符串数组。我们将使用 Commerce.js 返回产品列表，然后使用产品永久链接填充这些路径字符串。我们还需要返回一个回退键。当这个键为
    false，正如我们设置的，任何此方法未返回的路径将返回 404。如果它是 true，Next.js 将返回页面的回退版本而不是 404。如果我们正在生成大量页面，这会很有用，因为它会导致构建缓慢。对于任何尚未渲染的页面，当
    getStaticProps() 被调用以填充页面时，用户将看到加载指示器。
- en: Speaking of getStaticProps(), we need to create that function to populate the
    product details that will be rendered. In order to get the specific product details
    for this page, we’ll use the permalink variable that is passed in via the page
    context variable (ctx). This is populated with the value from /product/[permalink]
    path that we generated using the product permalink. We can then use the permalink
    to query Commerce.js to give us the product detail that it matches.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 说到getStaticProps()，我们需要创建该函数以填充将要渲染的产品详情。为了获取此页面的特定产品详情，我们将使用通过页面上下文变量（ctx）传入的permalink变量。这个变量由我们使用产品permalink生成的/product/[permalink]路径填充。然后我们可以使用permalink查询Commerce.js以获取匹配的产品详情。
- en: Add both these methods to the [permalink].js page we created. You can place
    them below the code from listing 5.5.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个方法添加到我们创建的[permalink].js页面中。您可以将它们放置在列表5.5中的代码下方。
- en: The product detail we’ve created so far looks like figure 5.7.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的产品详情看起来像图5.7。
- en: '![CH05_F07_Camden2](Images/CH05_F07_Camden2.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F07_Camden2](Images/CH05_F07_Camden2.png)'
- en: Figure 5.7 The product detail listing for one of our products
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 我们产品详情列表之一
- en: 5.4.4 Enabling add-to-cart functionality
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.4 启用添加到购物车功能
- en: So far, all the code we’ve written runs at build time, but each cart is unique
    to each user. Therefore, the add-to-cart functionality cannot be statically prerendered
    and needs to run on the client (i.e., the browser). To do this, we’ll need to
    use the environment variable to configure the Commerce.js client-side script with
    our API key, which is currently only available at build time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的所有代码都在构建时运行，但每个购物车都是针对每个用户的。因此，添加到购物车功能不能静态预渲染，需要在客户端（即浏览器）上运行。为此，我们需要使用环境变量来配置带有我们的API密钥的Commerce.js客户端脚本，该密钥目前仅在构建时可用。
- en: To make our CHEC_PUBLIC_KEY environment variable accessible to this script,
    we need to create a Next.js configuration file as next.config.js in the root of
    our project. In this file, we will tell Next.js to make this environment variable
    available on the client.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的CHEC_PUBLIC_KEY环境变量可供此脚本访问，我们需要在项目根目录中创建一个Next.js配置文件，命名为next.config.js。在这个文件中，我们将告诉Next.js在客户端使这个环境变量可用。
- en: Listing 5.7 The Next.js configuration file in next.config.js
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 Next.js配置文件在next.config.js中
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we could not use the NEXT_PUBLIC_ shortcut that Next.js provides because
    Commerce.js expects the key using a specific variable name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法使用Next.js提供的NEXT_PUBLIC_快捷方式，因为Commerce.js期望使用特定的变量名来使用密钥。
- en: If you have your local server still running, you’ll need to stop and restart
    it after making a configuration change.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的本地服务器仍在运行，您需要在进行配置更改后停止并重新启动它。
- en: 'Let’s go back to our /pages/product/[permalink].js file and add some methods
    to enable the add-to-cart functionality. Because of our configuration change,
    we can now call Commerce.js from the client. Let’s add a new method to the ProductDetail
    function in [permalink].js. Before we do that though, we need to import the Commerce.js
    library at the top of the file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的/pages/product/[permalink].js文件，并添加一些方法以启用添加到购物车功能。由于我们的配置更改，我们现在可以从客户端调用Commerce.js。让我们在[permalink].js中的ProductDetail函数中添加一个新方法。但在我们这样做之前，我们需要在文件顶部导入Commerce.js库：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can place the code for our handleAddToCart() function prior to the return.
    This method will tell Commerce.js to add the current product to our cart. For
    now, we’ll just dump the complete cart contents into the browser console so that
    we can see that it’s working:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将我们的handleAddToCart()函数的代码放置在return之前。此方法将告诉Commerce.js将当前产品添加到我们的购物车中。目前，我们将只是将完整的购物车内容输出到浏览器控制台，以便我们可以看到它是否正常工作：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each time we call this method, we’re telling Commerce.js to add one item of
    this product to the cart. This will either add a new product or increment the
    product if it already exists in the cart. Within the same file, let’s call this
    method by modifying the Add to Cart button to call this function. Replace the
    current button code that is within the render() method with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用此方法时，我们都在告诉Commerce.js将此产品的一项添加到购物车中。这将添加一个新的产品，或者如果该产品已经在购物车中，则增加该产品的数量。在同一文件中，让我们通过修改“添加到购物车”按钮来调用此方法。用以下代码替换render()方法中的当前按钮代码：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you save the file and it refreshes in your browser, open your browser
    developer tools console. When you click the Add to Cart button, you should receive
    something like the following response:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中刷新后，打开浏览器开发者工具控制台。当您点击“添加到购物车”按钮时，您应该收到以下类似响应：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Of course, dumping results into the browser console isn’t the ideal user interaction.
    What we need to do instead is let the user know that the item was successfully
    added. We’ll use a state variable to do this that will be set via React’s useState
    hook. First, we need to add an import for the hook at the top of the file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将结果直接输出到浏览器控制台并不是理想的用户交互方式。我们需要做的是让用户知道项目已成功添加。我们将使用一个状态变量来完成此操作，该变量将通过 React
    的 useState 钩子设置。首先，我们需要在文件顶部添加对钩子的导入：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can create the cartText state variable and the setCartText() function
    that will allow us to change the value of this state variable using this hook.
    State variables in React should not be changed directly, thus the need for the
    setter method. In addition, the useState hook allows us to pass in a default value,
    which, in this case, will be “Add to Cart.” Add this line directly beneath the
    export default function line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建 cartText 状态变量和 setCartText() 函数，这将允许我们使用此钩子更改此状态变量的值。在 React 中，不应直接更改状态变量，因此需要设置方法。此外，useState
    钩子允许我们传入一个默认值，在这种情况下，将是“添加到购物车”。将此行直接添加到 export default 函数行下方：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let’s update the button again to use that variable instead of hardcoded
    text:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们再次更新按钮，使用该变量而不是硬编码的文本：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This by itself won’t display anything differently than we were already displaying
    because we aren’t updating the value on any state changes. To do that, we need
    to modify our handleAddToCart() method by removing the console log and adding
    some code to change the cartText state variable when the item is successfully
    added. We do not modify the state directly but instead use the setCartText() method
    to update it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此本身不会显示与我们之前显示的任何不同，因为我们没有在状态更改时更新值。为了做到这一点，我们需要通过移除 console.log 并添加一些代码来更改
    cartText 状态变量，当项目成功添加时来修改我们的 handleAddToCart() 方法。我们不直接修改状态，而是使用 setCartText()
    方法来更新它：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, if we try the page out, our cart text will display that the item was added
    and display the quantity of that item in the cart. Clicking the Add to Cart button
    should display “Added (1)” or, if the product was already in your cart, “Added
    (2).”
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试运行页面，购物车文本将显示已添加项目，并显示购物车中该项目的数量。点击“添加到购物车”按钮应显示“已添加（1）”或，如果该产品已经在您的购物车中，“已添加（2）。”
- en: 5.4.5 Building the shopping cart
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.5 构建购物车
- en: 'At this point, users can view all of our products, click through to view specific
    products details, and add products to their cart. Next, let’s allow them to view
    the items that are in their cart. To do that, we’re going to borrow the design
    and layout from this pen in Codepen: [https://codepen.io/abdelrhman/pen/BaNPVJO](https://codepen.io/abdelrhman/pen/BaNPVJO).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，用户可以查看我们所有的产品，点击查看具体产品的详细信息，并将产品添加到他们的购物车中。接下来，让我们允许他们查看他们购物车中的项目。为此，我们将从
    Codepen 中的此笔借用设计和布局：[https://codepen.io/abdelrhman/pen/BaNPVJO](https://codepen.io/abdelrhman/pen/BaNPVJO)。
- en: Create a /pages/cart.js file. This page will be different than prior pages,
    as it will not use getStaticProps(). Why? Because none of the properties that
    populate this page can be statically prerendered. The contents of the cart must
    be retrieved on the client, as it is tied to the specific user.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 /pages/cart.js 文件。这个页面将不同于之前的页面，因为它不会使用 getStaticProps()。为什么？因为填充此页面的所有属性都无法静态预渲染。购物车的内容必须在客户端检索，因为它与特定用户相关。
- en: Instead of props, we’ll make extensive use of state to populate the page with
    the user’s cart details. This will allow us to update the state when the cart
    contents are retrieved and as the user interacts with the page to modify or remove
    items from their cart. Let’s begin by creating the structure for our component
    and setting the state variables we’ll need.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会使用 props，而是会大量使用 state 来填充页面，显示用户的购物车详细信息。这将允许我们在获取购物车内容时以及用户与页面交互以修改或从购物车中删除项目时更新状态。让我们首先创建组件的结构并设置我们需要的状态变量。
- en: Listing 5.8 Creating the initial cart page in /pages/cart.js
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 在 /pages/cart.js 中创建初始购物车页面
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, let’s populate the return().The contents of our return()as it creates
    the shopping cart by looping through the items array that will contain our cart
    items and populating the remaining pieces of the output with other state variables
    are shown. Please note this leaves out some portions for readability purposes
    (denoted by a “...”). You can find the full code in the GitHub repository ([http://mng.bz/8lRB](https://shortener.manning.com/8lRB)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们填充 `return()`。我们的 `return()` 方法通过遍历包含购物车项目的 `items` 数组来创建购物车，并用其他状态变量填充输出剩余部分的内容。请注意，为了可读性，省略了一些部分（用“...”表示）。您可以在
    GitHub 仓库中找到完整的代码（[http://mng.bz/8lRB](https://shortener.manning.com/8lRB)）。
- en: Listing 5.9 The contents of the render() method in /pages/cart.js
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 /pages/cart.js 中 render() 方法的代码内容
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ve set up the layout and the necessary state variables, but if you browse
    to the cart by clicking the My Cart navigation button, you’ll see that the page
    has no contents—even if you have items in your cart (figure 5.8).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了布局和必要的状态变量，但如果你通过点击“我的购物车”导航按钮浏览到购物车，你会看到页面没有内容——即使你的购物车中有项目（图 5.8）。
- en: '![CH05_F08_Camden2](Images/CH05_F08_Camden2.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F08_Camden2](Images/CH05_F08_Camden2.png)'
- en: Figure 5.8 The statically prerendered cart page has no details. These must be
    loaded for each user via the browser.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 静态预渲染的购物车页面没有详细信息。这些信息必须通过浏览器为每个用户加载。
- en: What we need to do next is load the contents of a user’s cart from Commerce.js
    when the page is ready. For this, we’ll use the useEffect() hook, which tells
    React to perform some action after the render is complete.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是在页面准备好时从 Commerce.js 加载用户的购物车内容。为此，我们将使用 `useEffect()` 钩子，它告诉 React
    在渲染完成后执行某些操作。
- en: 'Our useEffect() hook will call Commerce.js to get the user’s cart and then
    update the component state variables to populate the page with the user’s cart
    items and quantities. We’ve placed this code in a separate method contained within
    the hook because we need to call it asynchronously. (This is because asynchronous
    methods always return a promise, but useEffect() can only return a function, thus
    we cannot make useEffect() asynchronous.) Let’s place this directly above the
    return:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `useEffect()` 钩子将调用 Commerce.js 获取用户的购物车，然后更新组件状态变量以在页面上填充用户的购物车项目和数量。我们将此代码放置在钩子内的一个单独的方法中，因为我们需要异步调用它。（这是因为异步方法总是返回一个承诺，但
    `useEffect()` 只能返回一个函数，因此我们无法使 `useEffect()` 异步。）让我们将其直接放置在返回语句上方：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When the page reloads, you should now see the items you’ve added to your cart
    listed (figure 5.9).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面重新加载时，你现在应该能看到你添加到购物车中的项目列表（图 5.9）。
- en: '![CH05_F09_Camden2](Images/CH05_F09_Camden2.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F09_Camden2](Images/CH05_F09_Camden2.png)'
- en: Figure 5.9 The contents of the cart are loaded on the client using the useEffect()
    hook and populated on the page.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 购物车的内容通过 `useEffect()` 钩子在客户端加载，并在页面上填充。
- en: 'So far so good, but the user is unable to add or subtract (and ultimately remove)
    items from the cart. Let’s add a method right above our useEffect() method to
    handle that. This method will call Commerce.js to update the quantity and then
    update the relevant state variables:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但用户无法添加或减去（最终移除）购物车中的项目。让我们在我们的 `useEffect()` 方法上方添加一个方法来处理这个问题。此方法将调用
    Commerce.js 更新数量，然后更新相关的状态变量：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our handleUpdateQuantity method will handle adding, subtracting, or even manually
    supplying the quantity. First, call it from the Remove link. Removing it is simply
    a matter of setting the quantity to zero:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `handleUpdateQuantity` 方法将处理添加、减去或甚至手动提供数量的操作。首先，从移除链接中调用它。移除它只是将数量设置为零：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we’ll add it to the subtract button by subtracting one from the current
    quantity:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过从当前数量中减一来将其添加到减号按钮：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, add it to the plus button by adding one to the current quantity:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将当前数量加一来将其添加到加号按钮：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have to handle the input field that allows a user to manually specify a
    new quantity differently. We need a method that will be called when the value
    is changed and, if the value provided is a number, update the quantity. This method
    can go under the handleUpdateQuantity() method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以不同的方式处理允许用户手动指定新数量的输入字段。我们需要一个方法，当值更改时将被调用，并且如果提供的值是数字，则更新数量。此方法可以放在 `handleUpdateQuantity()`
    方法下方：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We’ll need to call the method when the user changes the value in the text box
    by adding an onChange event handler to the input field:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过在文本框中更改值时，我们需要调用该方法。为此，我们需要在输入字段上添加一个 `onChange` 事件处理器：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should now be able to increase, decrease, remove, and update the inventory
    of any item in your cart.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够增加、减少、删除和更新购物车中任何商品的库存。
- en: The last thing we need to do is enable the checkout process. Commerce.js offers
    the ability to use a hosted checkout option. This means that when a user clicks
    the Checkout button, they will be guided through the process on Commerce.js rather
    than through a customized checkout. Of course, should you want to, you can create
    a custom checkout, but, for the sake of simplicity, we’re going to use the hosted
    option.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是启用结账流程。Commerce.js 提供了使用托管结账选项的能力。这意味着当用户点击结账按钮时，他们将通过 Commerce.js
    的流程进行引导，而不是通过自定义结账。当然，如果您想的话，您可以创建一个自定义结账，但为了简单起见，我们将使用托管选项。
- en: 'To do this, all we need is one simple handler function that we can place under
    the handleQuantityChange() method. This method simply opens a new window using
    the checkout URL that Commerce.js provides:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需要一个简单的处理函数，我们可以将其放置在 handleQuantityChange() 方法之下。此方法简单地使用 Commerce.js
    提供的结账 URL 打开一个新窗口：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we need add the click event to the Checkout button so that it triggers
    that method when the button is clicked:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要给结账按钮添加点击事件，以便在按钮被点击时触发该方法：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Clicking the Checkout button will now open a new tab with the hosted checkout
    on Commerce.js (figure 5.10).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 点击结账按钮现在将打开一个新的标签页，在 Commerce.js 上进行托管结账（图 5.10）。
- en: '![CH05_F10_Camden2](Images/CH05_F10_Camden2.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F10_Camden2](Images/CH05_F10_Camden2.png)'
- en: Figure 5.10 Our e-commerce store uses a hosted checkout on Commerce.js rather
    than a customized checkout.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 我们的电子商务商店使用 Commerce.js 的托管结账而不是自定义结账。
- en: 5.4.6 Adding Markdown content
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.6 添加 Markdown 内容
- en: 'Our e-commerce experience is complete, but we still have one final touch to
    put on our site: the About page that will be driven by file-based Markdown content.
    Next.js does not have Markdown support built in, but it’s relatively easy to add.
    Let’s see how.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电子商务体验已经完成，但我们还需要在我们的网站上添加一个最后的修饰：由基于文件的 Markdown 内容驱动的关于页面。Next.js 没有内置
    Markdown 支持，但添加它相对容易。让我们看看如何。
- en: 'We’re going to need three npm plug-ins to enable this support:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要三个 npm 插件来启用此支持：
- en: raw-loader—This package will enable us to import the raw Markdown files as strings
    within our Webpack configuration.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: raw-loader—此包将使我们能够在 Webpack 配置中将原始 Markdown 文件作为字符串导入。
- en: gray-matter—Our Markdown files will contain front matter metadata. This library
    will allow us to easily parse that metadata.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gray-matter—我们的 Markdown 文件将包含前端元数据。此库将使我们能够轻松解析这些元数据。
- en: react-markdown—As we’ve discussed, React applications use a virtual DOM, and
    this library will render the Markdown within React’s virtual DOM, meaning that
    React will be able to properly update only the changed DOM elements.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: react-markdown—正如我们之前讨论的，React 应用程序使用虚拟 DOM，这个库将在 React 的虚拟 DOM 中渲染 Markdown，这意味着
    React 只能正确更新更改的 DOM 元素。
- en: 'If you’re still running your local site, you’ll need to stop it first. Next,
    install all three libraries:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍在运行本地站点，您需要先停止它。接下来，安装所有三个库：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s use raw-loader first. To do this, we need to edit the Webpack configuration
    of our Next.js site. Webpack is a popular module bundler for building web apps
    that Next.js uses to bundle its JavaScript files for the browser. To edit the
    Webpack configuration, open next.config.js and add a new rule that looks for files
    with the .md extension and loads them with the raw-loader.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用 raw-loader。为此，我们需要编辑我们的 Next.js 网站的 Webpack 配置。Webpack 是一个流行的模块打包器，Next.js
    使用它来打包其浏览器中的 JavaScript 文件。要编辑 Webpack 配置，打开 next.config.js 并添加一个新规则，该规则查找具有 .md
    扩展名的文件，并使用 raw-loader 加载它们。
- en: Listing 5.10 The Next.js configuration file at next.config.js to load Markdown
    files
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 在 next.config.js 中的 Next.js 配置文件以加载 Markdown 文件
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create a new file at /pages/about.js for our About page. Within the getStaticProps()
    method, we can use the filesystem to load the raw Markdown file from /content/
    about.md. We’ll then use the gray-matter library to read raw Markdown and separate
    the front matter metadata from the content. We’ll pass the front matter and Markdown
    content as props to the page, where ReactMarkdown is used to render the Markdown
    as React components.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 /pages/about.js 中为我们的关于页面创建一个新文件。在 getStaticProps() 方法中，我们可以使用文件系统从 /content/about.md
    加载原始 Markdown 文件。然后，我们将使用 gray-matter 库读取原始 Markdown 并将前端元数据与内容分开。我们将把前端元数据和 Markdown
    内容作为 props 传递给页面，其中 ReactMarkdown 用于将 Markdown 渲染为 React 组件。
- en: Listing 5.11 The About page that loads Markdown content at /pages/about.js
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 在 /pages/about.js 中加载 Markdown 内容的关于页面
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you may have guessed from the code, before this page will work, we need
    to create a Markdown file at /content/about.md. Placing content files in a /content
    folder is a typical structure of Next.js sites that load Markdown content. My
    about.md file is pretty simple, but feel free to experiment by adding more Markdown
    markup of your own:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从代码中猜到的，在页面工作之前，我们需要在 /content/about.md 创建一个 Markdown 文件。将内容文件放在 /content
    文件夹是 Next.js 站点加载 Markdown 内容的典型结构。我的 about.md 文件相当简单，但请随意通过添加您自己的更多 Markdown
    标记来实验：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let’s restart our local site using yarn dev and see our About page by clicking
    on the About navigation item (figure 5.11).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 yarn dev 重新启动本地站点，并通过点击“关于”导航项来查看“关于”页面（图 5.11）。
- en: '![CH05_F11_Camden2](Images/CH05_F11_Camden2.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F11_Camden2](Images/CH05_F11_Camden2.png)'
- en: Figure 5.11 Our About page renders a title and body of the page from a combination
    of Markdown front matter and Markdown markup in the about.md file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 我们的“关于”页面从 about.md 文件中的 Markdown 前置内容和 Markdown 标记的组合中渲染页面标题和正文。
- en: 5.5 What’s next?
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5 接下来是什么？
- en: We now have a fully functional e-commerce site, but there are a number of ways
    we can continue to improve it. The first and probably most obvious is to build
    the checkout process as custom rather than utilize the hosted checkout. We also
    never tackled issues such as discounts, sales tax, and shipping. These are things
    that can be managed and customized via the Commerce.js dashboard and then integrated
    into the site.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了一个功能齐全的电子商务网站，但我们可以通过多种方式继续改进它。首先，也是最明显的方法是构建自定义的结账过程，而不是使用托管结账。我们还从未解决过诸如折扣、销售税和运输等问题。这些都是可以通过
    Commerce.js 控制台进行管理和定制的，然后集成到网站上。
- en: An e-commerce site has a lot of potential complexity that we don’t have space
    to cover here. We chose to use Commerce.js as an API-based headless CMS in part
    because it helps illustrate many of the requirements for building a site with
    Next.js. However, one of the biggest decisions you’ll make when building your
    own Jamstack e-commerce site is how much to favor the granular customizability
    of an API-based tool like Commerce.js over an add-on solution such as Snipcart
    that is faster to implement. There’s no correct answer; it all depends on the
    requirements of your site.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 电子商务网站有很多潜在的复杂性，我们在这里没有空间涵盖。我们选择使用 Commerce.js 作为基于 API 的无头 CMS，部分原因是因为它有助于说明使用
    Next.js 构建网站时的许多要求。然而，在构建自己的 Jamstack 电子商务网站时，您将做出的最大决定之一是，在实现速度较快的扩展解决方案（如 Snipcart）和基于
    API 的工具（如 Commerce.js）的粒度化可定制性之间如何权衡。没有正确答案；这完全取决于您网站的需求。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The dynamic user interface requirements of an e-commerce site make a perfect
    fit for the JavaScript-framework-based SSGs. JavaScript frameworks like React
    come with tools that make it easier to dynamically update the DOM in the browser,
    which can help you build highly dynamic page components like a shopping cart.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务网站的动态用户界面需求非常适合基于 JavaScript 框架的 SSGs。例如，React 框架自带工具，可以更容易地在浏览器中动态更新 DOM，这有助于构建高度动态的页面组件，如购物车。
- en: 'A headless e-commerce system provides the backend to a Jamstack e-commerce
    site. There are three types of headless e-commerce systems:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头电子商务系统为 Jamstack 电子商务网站提供后端。有三种类型的无头电子商务系统：
- en: All-in-one solutions are typically used for building both the frontend and backend
    of an e-commerce site, but generally provide headless options.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一体化解决方案通常用于构建电子商务网站的前端和后端，但通常提供无头选项。
- en: An add-on solution is designed to be easy to implement by providing both the
    UI and management for the entire cart and the checkout process.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展解决方案旨在通过提供整个购物车和结账过程的 UI 和管理来简化实现。
- en: An API-based solution allows granular customization by accessing all of its
    data and management capabilities via an API, but it requires more code to implement.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 API 的解决方案允许通过 API 访问其所有数据和管理工作能力来实现粒度化的定制，但需要更多的代码来实现。
- en: Next.js is a React-based meta framework that provides tools for building either
    server-side rendering or static prerendering—or even a combination of both. Next.js
    makes it relatively simple to integrate with external API-based data sources like
    Commerce.js using built-in functions like getStaticPaths() and getStaticProps().
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 是一个基于 React 的元框架，它提供了构建服务器端渲染或静态预渲染的工具，甚至可以两者结合。Next.js 通过内置函数如 getStaticPaths()
    和 getStaticProps()，使得与像 Commerce.js 这样的基于 API 的外部数据源集成变得相对简单。
- en: Next.js doesn’t have built-in support for loading Markdown content, but it can
    be achieved through the use of multiple npm libraries. The raw-loader library
    provides the ability to import raw text files via Webpack. The gray-matter library
    reads the front matter metadata from a Markdown file. Finally, the react-markdown
    component renders Markdown within the React virtual DOM.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 没有内置支持加载 Markdown 内容，但可以通过使用多个 npm 库来实现。raw-loader 库提供了通过 Webpack 导入原始文本文件的能力。gray-matter
    库可以从 Markdown 文件中读取元数据。最后，react-markdown 组件在 React 虚拟 DOM 中渲染 Markdown。
