- en: Chapter 5\. Integration-testing microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 集成测试微服务
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding integration tests in a microservices architecture context
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务架构背景下理解集成测试
- en: Differentiating between integration and component tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分集成测试和组件测试
- en: Writing integration tests for persistence layers and gateway layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为持久层和网关层编写集成测试
- en: Operating with multiple deployments in Arquillian
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Arquillian 中操作多个部署
- en: In the preceding chapters, you read about how to write *unit* and *component*
    tests for a microservices-based architecture. There are also *integration* tests,
    which in the microservices world have a meaning that’s slightly different than
    in other architectures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何为基于微服务架构编写*单元*和*组件*测试。还有*集成*测试，在微服务世界中，其含义与其他架构略有不同。
- en: Integration tests check the interactions between different modules (or classes),
    usually belonging to the same subsystem, to verify that they collaborate as expected
    when providing a high-level feature. Integration tests also check that all communication
    paths performed through the subsystem are correct, and detect any incorrect premises
    that each module might have about how its peers are expected to act.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试检查不同模块（或类）之间的交互，通常属于同一个子系统，以验证它们在提供高级功能时是否按预期协作。集成测试还检查通过子系统执行的所有通信路径是否正确，并检测每个模块可能对同伴如何行动的预期有任何不正确的假设。
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Usually a module is considered a *class* in an object-oriented language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在面向对象语言中，一个模块被认为是一个*类*。
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Generally speaking, integration tests aren’t slow per se, but their speed depends
    on the logic and the interactions with modules in the subsystem under test that
    impact test performance. Because such subsystems usually require one or more container(s)
    in which to run (servlet container, CDI container, Spring container, and so forth),
    integration tests are slower than unit tests because they need to start and stop
    the container(s) they require.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，集成测试本身并不慢，但它们的速度取决于逻辑以及与被测试子系统模块的交互，这些交互会影响测试性能。由于这样的子系统通常需要一个或多个容器来运行（如servlet容器、CDI容器、Spring容器等），因此集成测试比单元测试慢，因为它们需要启动和停止所需的容器。
- en: '[Figure 5.1](kindle_split_014_split_000.xhtml#ch05fig01) illustrates what an
    integration test might look like. As you can see, a test involves calling at least
    one module (or class) and all the associated peers of that module. The purpose
    of such a test is to verify not the behavior of each module, but rather the communication
    between modules.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](kindle_split_014_split_000.xhtml#ch05fig01)展示了集成测试可能的样子。如图所示，测试至少涉及调用一个模块（或类）及其所有相关联的同伴。此类测试的目的是验证的不是每个模块的行为，而是模块之间的通信。'
- en: Figure 5.1\. Integration tests involving different modules
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 涉及不同模块的集成测试
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: Moving on from this brief introduction to the concept of integration tests,
    let’s see how integration tests apply to the microservices architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在对集成测试的概念进行简要介绍之后，让我们看看集成测试如何应用于微服务架构。
- en: 5.1\. Integration testing in the microservices architecture
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 微服务架构中的集成测试
- en: You know what integration testing is; in this section, you’ll see how to apply
    integration test concepts to a microservices architecture. Integration tests can
    be written to test any subsystem. For microservices architectures, integration
    tests are typically focused on verifying the interaction between subsystems in
    charge of communicating with external components such as data stores and/or other
    (micro)services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了集成测试是什么；在本节中，你将看到如何将集成测试概念应用于微服务架构。集成测试可以编写来测试任何子系统。对于微服务架构，集成测试通常集中在验证负责与外部组件（如数据存储和/或其他（微）服务）通信的子系统之间的交互。
- en: The goal of integration tests in microservices is to verify that the subsystem
    (or a concrete module) can communicate correctly, rather than testing the external
    element. For this reason, these tests should cover only basic success-and-error
    paths for integration between the subsystem and the external component at hand.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务中集成测试的目标是验证子系统（或具体模块）可以正确通信，而不是测试外部元素。因此，这些测试应仅涵盖子系统与外部组件之间集成的基本成功和错误路径。
- en: '[Figure 5.2](kindle_split_014_split_001.xhtml#ch05fig02) shows the schema of
    an integration test in a microservice scenario. You can see how a test verifies
    that one module (or class) can communicate with an external component, but without
    testing the external component.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](kindle_split_014_split_001.xhtml#ch05fig02) 展示了微服务场景中集成测试的架构。你可以看到测试是如何验证一个模块（或类）可以与外部组件通信，但又不测试外部组件。'
- en: Figure 5.2\. Integration test within a microservice
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 微服务中的集成测试
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because you’re testing whether communication between a subsystem belonging to
    a microservice and the external service is possible, the *ideal* scenario would
    be to *not* use any test doubles for external components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在测试微服务所属的子系统与外部服务之间的通信是否可行，因此*理想*的情况是*不*使用任何测试替身（test doubles）来模拟外部组件。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Keep the following important things in mind:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住以下重要事项：
- en: Integration tests verify the connection between internal modules and *external*
    components, such as a database or other (micro)services, not other *internal*
    modules.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试验证内部模块与*外部*组件（如数据库或其他（微）服务）之间的连接，而不是其他*内部*模块。
- en: Integration tests use real external components to validate whether communication
    with a real service is possible.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试使用真实的外部组件来验证与真实服务的通信是否可行。
- en: Preparation of the environment for executing tests is likely to be difficult
    and/or tedious.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备测试执行的环境可能会很困难且/或繁琐。
- en: Before we look at a concrete example, the following sections review which parts
    of the microservice anatomy should be tested using integration tests. In [figure
    5.3](kindle_split_014_split_001.xhtml#ch05fig03), they’re surrounded by broken
    lines.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看具体示例之前，以下部分回顾了在微服务架构中应该使用集成测试测试微服务解剖学的哪些部分。在[图 5.3](kindle_split_014_split_001.xhtml#ch05fig03)中，它们被虚线包围。
- en: Figure 5.3\. Layers to write integration tests for in a microservice architecture
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3\. 在微服务架构中编写集成测试的层
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: 5.1.1\. Gateway component layer
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 网关组件层
- en: Gateway layers contain the logic to connect to an external service, typically
    using an HTTP/S client. They connect to another microservice of the system or
    a service deployed outside your local infrastructure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 网关层包含连接到外部服务的逻辑，通常使用 HTTP/S 客户端。它们连接到系统中的另一个微服务或部署在你本地基础设施之外的服务。
- en: Integration tests are responsible for verifying connections to the service as
    well as for detecting any protocol issues, such as missing HTTP headers, incorrect
    SSL handling, or request/response body mismatches. All error-handling circumstances
    must be tested to ensure that the service and protocol client behave as expected
    when such conditions arise.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试负责验证服务连接以及检测任何协议问题，例如缺少 HTTP 头部、错误的 SSL 处理或请求/响应体不匹配。必须测试所有错误处理情况，以确保在出现此类条件时，服务和协议客户端的行为符合预期。
- en: Sometimes it’s difficult to verify abnormal behaviors such as timeouts or slow
    responses from external components. In [chapter 9](kindle_split_018_split_000.xhtml#ch09),
    you’ll learn how to provoke these situations without having to use test doubles.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时很难验证外部组件的异常行为，如超时或缓慢的响应。在第 9 章（kindle_split_018_split_000.xhtml#ch09）中，你将学习如何在不使用测试替身的情况下引发这些情况。
- en: 5.1.2\. Data mappers and repositories
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 数据映射器和仓库
- en: Repositories act as gateways to data sources by connecting to them, executing
    queries on them, and adapting the output to domain object models. Integration
    tests are responsible for verifying that the datasource schema is the one expected
    by the code. This assumption is especially important in the case of NoSQL databases.
    Because they don’t have schema, they’re considered *schemaless*. You need to be
    sure the code knows how to deal with this situation. When you’re using an ORM
    such as JPA, these tests also give you confidence that any mapping configured
    on the entities is correct.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库通过连接到数据源、在它们上执行查询以及将输出适配到领域对象模型来充当数据源的门径。集成测试负责验证数据源模式是否与代码期望的一致。在 NoSQL 数据库的情况下，这个假设尤为重要。因为它们没有模式，所以被认为是*无模式的*。你需要确保代码知道如何处理这种情况。当你使用
    JPA 等对象关系映射（ORM）工具时，这些测试也让你有信心，任何在实体上配置的映射都是正确的。
- en: Now that you know how to apply unit testing techniques to a microservices architecture,
    let’s see what tools you can use to write these tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何将单元测试技术应用到微服务架构中，让我们看看你可以使用哪些工具来编写这些测试。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Many tools for writing integration tests are available, but the tools we’ll
    examine in this chapter are currently the most widely adopted and accepted by
    the Java community. The following sections assume that you’ve already read [chapter
    4](kindle_split_013_split_000.xhtml#ch04) and that you understand at least the
    basics of the Arquillian framework.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用于编写集成测试的工具都可用，但本章我们将探讨的工具是目前 Java 社区最广泛采用和接受的。以下几节假设你已经阅读了 [第 4 章](kindle_split_013_split_000.xhtml#ch04)，并且至少理解了
    Arquillian 框架的基本知识。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2\. Persistence testing with the Arquillian Persistence Extension
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 使用 Arquillian 持久化扩展进行持久化测试
- en: 'Writing integration tests for a persistence layer is a bit more complicated
    than a simple unit test. Because results stored in the storage system are persistent,
    any execution of a test might influence the subsequent execution of another test
    by changing the data. This may be a cause for concern: tests are no longer completely
    *isolated* from each other. They’re connected by data.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为持久化层编写集成测试比简单的单元测试要复杂一些。因为存储系统中的结果都是持久的，任何测试的执行都可能通过改变数据而影响后续测试的执行。这可能会引起担忧：测试不再完全
    *隔离*。它们通过数据相互连接。
- en: 'In all but a few edge cases, tests should be independent of external factors
    and also of each other, because any data change performed by one test could cause
    other tests to fail in often subtle ways that can be difficult to diagnosis. Let’s
    look at an example of how this can happen in a simple persistence test. Suppose
    you have an object with two methods: one for creating a new movie and another
    for finding all movies. One possible test class might be the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有但少数边缘情况下，测试应该独立于外部因素以及彼此，因为一个测试执行的数据更改可能会以通常难以诊断的微妙方式导致其他测试失败。让我们看看一个简单的持久化测试中这种情况是如何发生的。假设你有一个具有两个方法的对象：一个用于创建新电影，另一个用于查找所有电影。一个可能的测试类可能如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Depending on unique constraints, this test may fail the second time you
    execute it.**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据独特的约束条件，这个测试可能在第二次执行时失败。**'
- en: '***2* Depending on execution order, one or more movies may have been inserted.**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根据执行顺序，可能已经插入了一个或多个电影。**'
- en: As you can see, this test isn’t predictable. Although the repository code may
    be correctly written, tests may fail depending on test execution order. If the
    `shouldInsertAMovie` test method is executed last (there’s no guarantee of any
    execution order), then the `shouldFindAllMovies` test method will fail because
    no movies are stored in the database, and one is expected. This confirms how important
    it is that each test execution is isolated from another execution in terms of
    data. [Figure 5.4](kindle_split_014_split_002.xhtml#ch05fig04) illustrates one
    test execution that causes the `shouldFindAllMovies` test to fail.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个测试是不可预测的。尽管存储库代码可能编写正确，但测试可能会根据测试执行顺序而失败。如果 `shouldInsertAMovie` 测试方法最后执行（没有保证任何执行顺序），那么
    `shouldFindAllMovies` 测试方法将失败，因为数据库中没有存储电影，而预期有一个。这证实了每个测试执行在数据方面相互隔离的重要性。[图 5.4](kindle_split_014_split_002.xhtml#ch05fig04)
    说明了导致 `shouldFindAllMovies` 测试失败的测试执行。
- en: Figure 5.4\. Failing test execution
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 测试执行失败
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: '[Figure 5.5](kindle_split_014_split_002.xhtml#ch05fig05) shows a false-positive
    scenario, where all tests pass. A *false positive* can lull you into a false sense
    of security. You can see that this test has the potential to fail on any given
    run, but would you instantly spot the cause if it did?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.5](kindle_split_014_split_002.xhtml#ch05fig05) 展示了一个假阳性场景，其中所有测试都通过。一个
    *假阳性* 可能会让你产生一种虚假的安全感。你可以看到这个测试在任意一次运行中都有可能失败，但你能否立刻发现原因？'
- en: Figure 5.5\. Successful test execution
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 测试执行成功
- en: '![](Images/05fig05_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05_alt.jpg)'
- en: 'It’s easy to fix this problem with the right tools: you only need to revert
    the database data to a known and predictable state before each test method execution.
    This means that before each execution, the database must be modified by cleaning/reverting
    previous modifications; then you recreate the database in a known state by inserting
    some known/expected data for the test. Following this strategy, each test will
    always find a database with the same data, independent of the test execution order,
    as shown in [figure 5.6](kindle_split_014_split_002.xhtml#ch05fig06).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的工具很容易解决这个问题：你只需要在每个测试方法执行之前将数据库数据回滚到已知和可预测的状态。这意味着在每次执行之前，数据库必须通过清理/回滚之前的修改来修改；然后通过为测试插入一些已知/预期的数据来重新创建数据库到一个已知的状态。遵循此策略，每个测试都将始终找到一个具有相同数据的数据库，独立于测试执行顺序，如[图5.6](kindle_split_014_split_002.xhtml#ch05fig06)所示。
- en: Figure 5.6\. Lifecycle of a safe persistence test
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. 安全持久化测试的生命周期
- en: '![](Images/05fig06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig06.jpg)'
- en: Before each test execution, the database is purged of any data changes that
    were made previously. Then, all data that will be expected by the test is inserted;
    for example, a test may verify some expected query results. After this revert,
    you can consider the database to be in a known state. It contains only the data
    you expect to be present, and each test can be executed in a consistent manner.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试执行之前，数据库将清除之前所做的任何数据更改。然后，插入测试预期所需的所有数据；例如，一个测试可能验证一些预期的查询结果。在此回滚之后，你可以认为数据库处于一个已知状态。它只包含你期望存在的数据，每个测试都可以以一致的方式进行执行。
- en: 'Even this solution has two aspects that make it imperfect and that could be
    improved:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个解决方案也有两个方面使其不完美并且可以改进：
- en: Maintaining the database in a known state involves a huge amount of boilerplate
    code that will be repeated before each persistence test.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护数据库到一个已知状态涉及大量的样板代码，这些代码将在每个持久化测试之前重复。
- en: There’s no standard mechanism to insert data, so you might have to write SQL
    statements over and over.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有标准机制来插入数据，因此你可能不得不反复编写SQL语句。
- en: 'Fortunately, the *Arquillian Persistence Extension* drastically improves writing
    persistence tests using Arquillian. The Arquillian Persistence Extension can help
    you with the task of writing persistence tests correctly. It exposes the following
    features:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，*Arquillian持久化扩展*极大地改善了使用Arquillian编写持久化测试。Arquillian持久化扩展可以帮助你正确地编写持久化测试。它提供了以下功能：
- en: Each test wrapped in an isolated transaction
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试都包含在一个独立的交易中
- en: Database seeding at the class or method level using DbUnit
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DbUnit在类或方法级别进行数据库初始化
- en: Support for SQL, JPA, NoSQL, and more
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持SQL、JPA、NoSQL等更多
- en: Support for XML, Excel (XLS), YAML, and JSON dataset formats
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持XML、Excel（XLS）、YAML和JSON数据集格式
- en: Cleaning of the database before each test method execution
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试方法执行之前清理数据库
- en: Customizations using SQL files directly
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL文件直接进行自定义
- en: Comparison of database states at the end of each test using a known final dataset,
    which also supports column exclusions
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已知最终数据集在每次测试结束时比较数据库状态，这也支持列排除
- en: Unified programmatic (DSL) and declarative (annotations) ways of seeding data
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一程序性（DSL）和声明性（注解）的数据初始化方式
- en: This extension can save you from having to write a lot of boilerplate code for
    each test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展可以帮助你避免为每个测试编写大量的样板代码。
- en: 5.2.1\. Declarative approach
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 声明式方法
- en: 'A test written using the Arquillian Persistence Extension might look like the
    following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Arquillian持久化扩展编写的测试可能看起来像以下这样：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Defines the test as an Arquillian test**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将测试定义为Arquillian测试**'
- en: '***2* Defines the ShrinkWrap deployment file to be used**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义要使用的ShrinkWrap部署文件**'
- en: '***3* Injects any EJB or even the UserTransaction used**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入任何EJB或甚至UserTransaction**'
- en: '***4* Populates the database with the specified data before executing the test
    method**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在执行测试方法之前用指定数据填充数据库**'
- en: '***5* Applies a given SQL script before executing the test method**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在执行测试方法之前应用给定的SQL脚本**'
- en: '***6* Validates that the database content is as defined by the file after executing
    the test method**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 验证在执行测试方法之后数据库内容是否与文件中定义的一致**'
- en: Notice that the Arquillian Persistence Extension relies heavily on annotations,
    which means you don’t need to write any boilerplate code in your tests. Just let
    the extension maintain the database in a known state for you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Arquillian持久化扩展严重依赖于注解，这意味着你不需要在测试中编写任何样板代码。只需让扩展为你维护数据库到一个已知状态。
- en: 'In the example, YAML format is used to populate and validate the database.
    For YAML datasets, an element found at far left in the document is a table name.
    This element can contain a list (or array) of elements. Each element’s list in
    YAML is denoted with a hyphen (`-`) symbol. Each element is a row in the database.
    Finally, each element contains attributes that represent the column names and
    values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，使用 YAML 格式来填充和验证数据库。对于 YAML 数据集，文档最左侧的元素是表名。此元素可以包含一个元素列表（或数组）。YAML 中每个元素的列表用连字符（`-`）符号表示。每个元素是数据库中的一行。最后，每个元素包含表示列名和值的属性：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example defines two tables. Two rows are inserted in `table1`, adding values
    to `column1` and `column2`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例定义了两个表。在 `table1` 中插入两行，向 `column1` 和 `column2` 添加值。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can explicitly set a `null` value for a given column by using the `null`
    keyword. For example, `producedBy: "[null]"`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以使用 `null` 关键字显式地为给定列设置 `null` 值。例如，`producedBy: "[null]"`。'
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the sequence diagram in [figure 5.7](kindle_split_014_split_002.xhtml#ch05fig07),
    you can see what happens internally when an Arquillian Persistence Extension test
    is executed. First, the application server of your choice is started, and the
    archive defined by the deployment method is packaged by ShrinkWrap and deployed.
    The test then starts its execution, and the following steps happen for each test
    method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5.7](kindle_split_014_split_002.xhtml#ch05fig07) 的时序图中，您可以看到当执行 Arquillian
    持久化扩展测试时内部发生的情况。首先，启动您选择的应用程序服务器，并且通过 ShrinkWrap 打包由部署方法定义的存档并部署。然后，测试开始执行，并且以下步骤为每个测试方法发生：
- en: Figure 5.7\. Arquillian Persistence Extension lifecycle
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.7\. Arquillian 持久化扩展生命周期
- en: '![](Images/05fig07_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig07_alt.jpg)'
- en: '**1**.  The database is cleaned so previous executions don’t affect the current
    test method.'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 数据库被清理，以确保之前的执行不会影响当前的测试方法。'
- en: '**2**.  The entire test is executed within a transaction.'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 整个测试在事务中执行。'
- en: '**3**.  The database is seeded with a known dataset if the `@UsingDataSet`
    annotation is present.'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 如果存在 `@UsingDataSet` 注解，数据库将使用已知数据集进行初始化。'
- en: '**4**.  The test body is executed.'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 执行测试主体。'
- en: '**5**.  The final state of the database is verified if a `@ShouldMatchDataSet`
    annotation is present.'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 如果存在 `@ShouldMatchDataSet` 注解，则验证数据库的最终状态。'
- en: After the execution of all tests, the deployment file is undeployed and the
    application server is terminated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行所有测试之后，部署文件将被卸载，并且应用程序服务器将被终止。
- en: You now know how to write persistence tests for SQL systems. Let’s see how to
    do it for NoSQL databases.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道如何为 SQL 系统编写持久化测试。让我们看看如何为 NoSQL 数据库执行此操作。
- en: 5.2.2\. Programmatic approach
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 编程方法
- en: You’ve seen how to populate your anemic environment with some data by using
    annotations. The Arquillian Persistence Extension also allows you to populate
    data using a programmatic approach. This approach is valid only when using Arquillian
    in client mode (or using the `standalone` dependency). One important aspect of
    the programmatic approach is that you can use an Arquillian runner (`@RunWith(Arquillian.class)`)
    or, alternatively, register a *JUnit rule* (`@Rule public ArquillianPersistenceRule
    arquillianPersistenceRule = new ArquillianPersistenceRule();`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何通过使用注解来使用一些数据填充您贫血的环境。Arquillian 持久化扩展还允许您使用编程方法来填充数据。这种方法仅在以客户端模式使用
    Arquillian（或使用 `standalone` 依赖项）时有效。编程方法的一个重要方面是您可以使用 Arquillian 运行器（`@RunWith(Arquillian.class)`）或者，作为替代，注册一个
    *JUnit 规则*（`@Rule public ArquillianPersistenceRule arquillianPersistenceRule =
    new ArquillianPersistenceRule();`）。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, the annotation approach can only be used with DbUnit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，注解方法只能与 DbUnit 一起使用。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Standard RDBMSs
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 标准关系型数据库管理系统
- en: Two different technologies are supported for populating data in relational databases.
    The first is DbUnit, introduced in the previous section, and the second is *Flyway*,
    a Java tool for describing database migrations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 支持两种不同的技术来填充关系型数据库中的数据。第一种是前面章节中介绍的 DbUnit，第二种是 *Flyway*，这是一个用于描述数据库迁移的 Java
    工具。
- en: 'Let’s look at an example using DbUnit:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 DbUnit 的一个示例来查看：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* DbUnit annotation that sets DbUnit as the backend**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置 DbUnit 作为后端的 DbUnit 注解**'
- en: '***2* Configures the JDBC connectionUpdates the database using the provided
    dataset**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置 JDBC 连接，使用提供的数据集更新数据库**'
- en: '***3* Updates the database using the provided dataset**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用提供的数据集更新数据库**'
- en: '***4* Cleans the database before the next execution**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在下一次执行之前清理数据库**'
- en: 'As you can see, this test is pretty similar to any other Arquillian test, with
    one slight difference: the test is enriched with a `RdbmsPopulator` instance.
    This instance is responsible for populating the dataset for the required RDBMS
    backend. The DbUnit populator is injected into the test, and the test.json file,
    located at the root of the classpath, is used to seed the given SQL database instance.
    In a similar way, you can use Flyway by annotating a field with `@Flyway`, which
    points to a dataset migration directory.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个测试与任何其他Arquillian测试非常相似，只有一个细微的差别：测试通过添加一个`RdbmsPopulator`实例来丰富。该实例负责为所需的RDBMS后端填充数据集。DbUnit填充器被注入到测试中，并且位于类路径根目录的test.json文件被用来初始化给定的SQL数据库实例。以类似的方式，你可以通过注解一个字段为`@Flyway`来使用Flyway，它指向数据集迁移目录。
- en: NoSQL systems
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: NoSQL系统
- en: Next, let’s see how to use same approach to populate datasets for NoSQL databases.
    The Arquillian Persistence Extension uses *NoSQLUnit* under the hood for the dataset
    format and populating data. (We’ll cover this topic more deeply later in the chapter.)
    For now, the only thing you need to know is that NoSQLUnit is similar to DbUnit,
    but for NoSQL databases.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用相同的方法来填充NoSQL数据库的数据集。Arquillian持久化扩展在底层使用*NoSQLUnit*来处理数据集格式和填充数据。（我们将在本章后面更深入地介绍这个主题。）目前，你需要知道的是，NoSQLUnit类似于DbUnit，但适用于NoSQL数据库。
- en: 'Currently, the Arquillian Persistence Extension supports the following NoSQL
    databases: Couchbase, MongoDB, Vault, and Redis. The following example uses MongoDB:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Arquillian持久化扩展支持以下NoSQL数据库：Couchbase、MongoDB、Vault和Redis。以下示例使用MongoDB：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* MongoDB annotation that sets MongoDB as the backend**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置MongoDB作为后端的MongoDB注解**'
- en: '***2* Configures the MongoDB connection**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置MongoDB连接**'
- en: '***3* Updates the database using the provided dataset**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用提供的数据集更新数据库**'
- en: '***4* Cleans the database before the next execution**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在下一次执行前清理数据库**'
- en: This test is similar to the one for SQL databases. The test is enriched with
    a `NoSqlPopulator` instance, which is responsible for populating the dataset for
    the required NoSQL backend. The MongoDB populator is injected into the test, and
    the books.json file, located at the root of the classpath, is used to seed the
    specified NoSQL database instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与SQL数据库的测试类似。测试通过添加一个`NoSqlPopulator`实例来丰富，该实例负责为所需的NoSQL后端填充数据集。MongoDB填充器被注入到测试中，并且位于类路径根目录的books.json文件被用来初始化指定的NoSQL数据库实例。
- en: In a similar way, you can configure your test to use any other of the supported
    NoSQL databases.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，你可以配置你的测试以使用任何其他支持的NoSQL数据库。
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Each supported populator has its own artifact. For example, to use the MongoDB
    populator, you’ll need to register the `org.arquillian.ape:arquillian-ape-nosql-mongodb`
    artifact in the build script.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个支持的填充器都有自己的工件。例如，要使用MongoDB填充器，你需要在构建脚本中注册`org.arquillian.ape:arquillian-ape-nosql-mongodb`工件。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: REST services
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: REST服务
- en: You’ve learned how to populate data into persistent storage before executing
    your test, and how to clean the environment after the execution. In a microservices
    architecture, it’s common for a service A to call a service B to obtain data.
    In this kind of integration test, you can experience the same problems as for
    persistence backend tests. You need to populate some data to service B before
    testing the *gateway* of service A. This testing scenario is also supported in
    the Arquillian Persistence Extension using the same approach as in previous sections.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何在执行测试之前将数据填充到持久存储中，以及如何在执行后清理环境。在微服务架构中，服务A通常调用服务B以获取数据是很常见的。在这种集成测试中，你需要在测试服务A的*网关*之前向服务B填充一些数据。Arquillian持久化扩展也支持这种测试场景，使用与前面章节相同的方法。
- en: For REST services, Postman ([www.getpostman.com](http://www.getpostman.com))
    Collection Format v2 ([https://schema.getpostman.com/json/collection/v2.0.0/docs/index.html](https://schema.getpostman.com/json/collection/v2.0.0/docs/index.html))
    is the format used for setting the dataset of operations to execute against a
    service.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REST服务，Postman ([www.getpostman.com](http://www.getpostman.com)) Collection
    Format v2 ([https://schema.getpostman.com/json/collection/v2.0.0/docs/index.html](https://schema.getpostman.com/json/collection/v2.0.0/docs/index.html))
    是用于设置要执行的操作数据集的格式。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**About Postman**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于Postman**'
- en: Postman is a GUI program that allows you to develop and test (REST) APIs. It
    also supports importing REST definitions from different formats such as RAML and
    Swagger.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Postman是一个GUI程序，允许您开发并测试（REST）API。它还支持从不同的格式（如RAML和Swagger）导入REST定义。
- en: In Postman, collections are the main place to store individual requests and
    responses so they can be organized to accurately mirror the API. From a user perspective,
    a *collection* is a group of requests that can be executed one by one or all at
    once. A collection can be exported into a JSON file following the JSON schema
    defined at [https://schema.getpostman.com](https://schema.getpostman.com).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，集合是存储单个请求和响应的主要地方，以便可以组织以准确反映API。从用户的角度来看，一个*集合*是一组可以逐个或全部执行的请求。一个集合可以导出为遵循[https://schema.getpostman.com](https://schema.getpostman.com)中定义的JSON模式的JSON文件。
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The Arquillian Persistence Extension for REST services reads JSON files following
    the Collection v2 format and replies using all defined requests against the specified
    service. To create this file, you can follow two possible approaches:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian持久性扩展用于REST服务读取遵循Collection v2格式的JSON文件，并使用所有定义的请求对指定的服务进行响应。要创建此文件，您可以遵循两种可能的方法：
- en: Create a JSON file from scratch following the Collection v2 schema.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始创建一个遵循Collection v2模式的JSON文件。
- en: Create a collection using Postman, and export it (see [figure 5.8](kindle_split_014_split_002.xhtml#ch05fig08)).
    We recommend using this approach because it’s the easiest and fastest way to create
    the file.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Postman创建一个集合，并导出它（见[图 5.8](kindle_split_014_split_002.xhtml#ch05fig08)）。我们推荐使用这种方法，因为它是最简单、最快创建文件的方式。
- en: Figure 5.8\. Example of exporting a collection
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.8. 导出集合的示例
- en: '![](Images/05fig08_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig08_alt.jpg)'
- en: Let’s look at an example in which a Postman collection is used to populate a
    service with a Hello message.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用Postman集合向服务填充Hello消息的示例。
- en: Listing 5.1\. `PostmanTest`
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1. `PostmanTest`
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Sets Postman as the backend to populate data**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. 将Postman设置为后端以填充数据***'
- en: '***2* Configures the service location to be updated**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2. 配置要更新的服务位置***'
- en: '***3* Sends REST calls to the configured service**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3. 向配置的服务发送REST调用***'
- en: This test is similar to those for databases. It’s enriched with a `RestPopulator`
    instance that’s responsible for populating the dataset for the required service.
    The Postman populator is injected into the test, and the message.json Postman
    collection file, located at the root of the classpath, is used to replay all requests
    defined in the file against the configured service.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试类似于数据库的测试。它通过一个负责为所需服务填充数据集的`RestPopulator`实例进行了丰富。Postman填充器被注入到测试中，并且位于类路径根目录的message.json
    Postman集合文件被用来对配置的服务重放文件中定义的所有请求。
- en: The message.json file is shown next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个展示的是message.json文件。
- en: Listing 5.2\. message.json
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2. message.json
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This collection contains only one request (but it can contain multiple lists),
    named `My message`. This creates a `POST` request against the specified `url`
    with a `Content-Type` header of `text/plain` and the body content `Message in
    a Bottle`, which is then executed when the `execute` method of the `RestPopulator`
    class is called.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合只包含一个请求（但可以包含多个列表），名称为`My message`。这将在指定的`url`上创建一个带有`Content-Type`头为`text/plain`和正文内容`Message
    in a Bottle`的`POST`请求，该请求在调用`RestPopulator`类的`execute`方法时执行。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The URL field in this example points to `localhost`. Meanwhile, the test points
    to example.com. This is fine, because the Arquillian Persistence Extension adapts
    the `url` field for requests (host and port) to the one configured in the `RestPopulator`.
    So, in the message.json request, the URL http://localhost:8080/message is replaced
    at runtime with http://example.com:8080/message.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，URL字段指向`localhost`。同时，测试指向example.com。这是可以的，因为Arquillian持久性扩展会根据`RestPopulator`中配置的来适配请求的`url`字段（主机和端口）。因此，在message.json请求中，运行时将http://localhost:8080/message替换为http://example.com:8080/message。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you’ve seen how to use the Arquillian Persistence Extension, let’s
    go a little deeper into how NoSQLUnit works.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何使用Arquillian持久性扩展，让我们更深入地了解NoSQLUnit是如何工作的。
- en: 5.2.3\. Persistence testing with NoSQLUnit
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3. 使用NoSQLUnit进行持久性测试
- en: In NoSQL databases, you face the same challenges you face with SQL databases,
    including the isolation problem. Because NoSQL databases are persistent from the
    point of view of the lifecycle of tests (although distributed caches usually aren’t
    persistent), these tests still need to manage databases in order to revert them
    to a known state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NoSQL 数据库中，你面临与 SQL 数据库相同的问题，包括隔离问题。由于 NoSQL 数据库从测试生命周期的角度来看是持久的（尽管分布式缓存通常不是持久的），这些测试仍然需要管理数据库，以便将其恢复到已知状态。
- en: 'To write persistence tests for NoSQL databases, there’s a project equivalent
    to DbUnit, called NoSQLUnit. NoSQLUnit is a JUnit extension that helps you write
    NoSQL persistence tests following the same approach taken by DbUnit, but adapted
    to common NoSQL databases. It comes with the following features:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 NoSQL 数据库编写持久化测试，有一个与 DbUnit 相当的项目，称为 NoSQLUnit。NoSQLUnit 是一个 JUnit 扩展，它帮助你按照
    DbUnit 采取的相同方法编写 NoSQL 持久化测试，但适应了常见的 NoSQL 数据库。它具有以下功能：
- en: Manages the lifecycle of databases, including starting and stopping cycles.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据库的生命周期，包括启动和停止周期。
- en: Seeds the database at the class or level method. Due to the heterogeneity of
    the NoSQL space, each implementation has its own format.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类或方法级别上初始化数据库。由于 NoSQL 空间的异构性，每个实现都有自己的格式。
- en: Cleans the database before each test method is executed.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试方法执行之前清理数据库。
- en: Compares the database state at the end of each test using a known final dataset,
    and supports column exclusions.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已知的最终数据集比较每个测试结束时的数据库状态，并支持列排除。
- en: Supports Cassandra, Couchbase, CouchDB, Elasticsearch, HBase, Infinispan, MongoDB,
    Vault, Neo4J, and Redis.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Cassandra、Couchbase、CouchDB、Elasticsearch、HBase、Infinispan、MongoDB、Vault、Neo4J
    和 Redis。
- en: Again, NoSQLUnit saves you from having to write a lot of boilerplate code for
    each test. The following listing shows a sample test written using NoSQLUnit.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，NoSQLUnit 可以帮助你避免为每个测试编写大量的样板代码。以下列表显示了一个使用 NoSQLUnit 编写的示例测试。
- en: Listing 5.3\. CommentsPersistenceTest.java
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. CommentsPersistenceTest.java
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Starts an in-memory instance of MongoDB (FongoDB project)**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 启动 MongoDB（FongoDB 项目）的内存实例**'
- en: '***2* Configures a connection to the database to be used by the test**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置用于测试的数据库连接**'
- en: '***3* Populates a JSON document into the MongoDB instance before each test**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在每个测试之前将 JSON 文档填充到 MongoDB 实例中**'
- en: '***4* Validates that the content of the database is as defined by the file
    after executing the test method**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 验证测试方法执行后数据库的内容是否符合文件定义**'
- en: 'For MongoDB, NoSQLUnit expects a JSON file with the following schema for populating
    and validating data:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 MongoDB，NoSQLUnit 预期一个具有以下模式的 JSON 文件来填充和验证数据：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Specifies the collection in which documents are stored**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定文档存储的集合**'
- en: '***2* Registers indexes for the collection**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为集合注册索引**'
- en: '***3* Defines one index for the code field**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为代码字段定义一个索引**'
- en: '***4* Array of raw JSON documents to store**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 存储原始 JSON 文档的数组**'
- en: 'Any root element represents a collection where you can insert documents; in
    this case, the collection `collection1` is defined. After that, you define an
    array with two kinds of documents: one that defines which indexes are created
    in the collection, and an array of raw JSON documents that are stored in the collection.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 任何根元素都代表一个可以插入文档的集合；在这种情况下，定义了集合 `collection1`。之后，你定义一个包含两种文档的数组：一种定义在集合中创建哪些索引，以及存储在集合中的原始
    JSON 文档数组。
- en: Notice that NoSQLUnit follows an approach similar to the Arquillian Persistence
    Extension by cleaning the database before executing each test method and then
    populating the database with the given data. It can also verify that the state
    of the database is as expected after each test method executes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 NoSQLUnit 在执行每个测试方法之前清理数据库，然后使用给定数据填充数据库的方法与 Arquillian 持久化扩展类似。它还可以验证在测试方法执行后数据库的状态是否符合预期。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Nothing is stopping you from using NoSQLUnit standalone outside of the Arquillian
    runner (using the NoSQLUnit JUnit runner). But we encourage you to use the Arquillian
    Persistence Extension together with NoSQLUnit.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何阻止你在 Arquillian 运行器之外使用 NoSQLUnit 独立版本（使用 NoSQLUnit JUnit 运行器）。但我们鼓励你将 Arquillian
    持久化扩展与 NoSQLUnit 一起使用。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now you’ve seen how to use NoSQLUnit with MongoDB. But each NoSQL database
    is different, and it’s easy to see that a graph database, such as Neo4J, models
    data completely differently than MongoDB: one deals with nodes and the relationships
    between them, and the other one stores data in “buckets.”'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何使用NoSQLUnit与MongoDB一起使用。但每个NoSQL数据库都是不同的，很容易看出，与Neo4J这样的图数据库相比，MongoDB的数据模型完全不同：一个处理节点及其之间的关系，而另一个在“桶”中存储数据。
- en: Next, let’s see how NoSQLUnit works with Redis. The first step is to configure
    a Redis connection. Instead of using an embedded connection, as in the previous
    example, you make a direct connection to an already running Redis instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看NoSQLUnit如何与Redis一起工作。第一步是配置一个Redis连接。与上一个示例中使用嵌入式连接不同，您将直接连接到一个已经运行的Redis实例。
- en: Listing 5.4\. RedisPersistenceTest.java
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. RedisPersistenceTest.java
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Rule defining the connection details**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义连接细节的规则**'
- en: '***2* Creates a connection to an already running Redis service**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 连接到一个已经运行的Redis服务**'
- en: '***3* Populates the given data**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 填充给定数据**'
- en: 'When using Redis, NoSQLUnit expects a JSON file with the following schema for
    populating and validating data:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Redis时，NoSQLUnit期望一个JSON文件，其模式如下，用于填充和验证数据：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* A simple key/value**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 简单的键/值**'
- en: '***2* A key and a list of values**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 键和值列表**'
- en: '***3* A key and a set of values ordered by score**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 按分数排序的键和值集合**'
- en: '***4* A key with a hash of key/values elements**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 包含键/值元素的哈希**'
- en: '***5* A key with a set of unduplicated values**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 包含唯一值的键集合**'
- en: 'The root element must be called `data`. Depending on the kind of structured
    data you need to store, the root element should be followed by one or more child
    elements. The `key` field sets the key of the element, and the `value` field is
    used to set a value. You can store the following types of elements:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素必须命名为`data`。根据您需要存储的结构化数据类型，根元素后面应跟一个或多个子元素。`key`字段设置元素的键，`value`字段用于设置值。您可以存储以下类型的元素：
- en: '`simple`—Contains an array of simple key/value entries.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simple`—包含一个简单的键/值条目数组。'
- en: '`list`—Contains a `key` field for the key name and a `value` field with an
    array of values.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`—包含一个`key`字段用于键名和一个`value`字段，其中包含一个值数组。'
- en: '`set`—Stores a key in a set (no duplicates allowed). The structure is the same
    as for the `list` element.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`—在集合中存储一个键（不允许重复）。结构与`list`元素相同。'
- en: '`sortset`—Stores a key in a sorted set of values. Each value also has a `score`
    field of type `Number`, to specify its order in the sorted set.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortset`—在排序集合中存储一个键。每个值还有一个`score`字段，其类型为`Number`，用于指定其在排序集合中的顺序。'
- en: '`hash`—Stores a key in a map of fields/values. The `field` field sets the field
    name, and `value` sets the field’s value.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash`—在字段/值映射中存储一个键。`field`字段设置字段名称，`value`设置字段的值。'
- en: Clearly, depending on the defined NoSQL database, the data-seeding file is likely
    to be very different.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，根据定义的NoSQL数据库，数据填充文件可能非常不同。
- en: Now that we’ve introduced two technologies for writing tests for data mappers
    and repositories, let’s look at two more that will help you perform integration
    tests for gateways.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了两种用于编写数据映射器和存储库测试的技术，让我们看看另外两种将帮助您执行网关的集成测试。
- en: 5.2.4\. Persistence testing with Arquillian multideployment
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4\. 使用Arquillian多部署进行持久性测试
- en: 'Up to now, each test class in this book has had its own deployment method.
    But when you’re writing integration tests for gateway components, you may need
    to deploy two archives: one that contains the gateway class and its related classes,
    and another that contains the service the gateway connects to.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的每个测试类都有自己的部署方法。但当你编写网关组件的集成测试时，您可能需要部署两个存档：一个包含网关类及其相关类，另一个包含网关连接到的服务。
- en: Of course, you can only have multiple deployments if you’re able to deploy the
    test on the other microservice. For example, if you’re communicating with an external
    service that’s outside the control of your project, such as YouTube or the IGDB
    site, you need to use the external service directly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只有当您能够将测试部署到其他微服务时，您才能有多个部署。例如，如果您正在与一个位于您项目控制之外的外部服务通信，例如YouTube或IGDB网站，您需要直接使用该外部服务。
- en: Also, sometimes a service can’t be deployed using Arquillian; perhaps it isn’t
    written in Java, or it was written by an external team and you don’t have access
    and therefore can’t deploy it. In these cases, you need to use a staging server
    with the service deployed, to test the gateway against the real service.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时一个服务无法使用Arquillian进行部署；可能是因为它不是用Java编写的，或者它是由外部团队编写的，您没有访问权限，因此无法部署它。在这些情况下，您需要使用一个已部署服务的预发布服务器，以测试网关对真实服务的测试。
- en: 'The examples thus far have used a single deployment for their tests. Arquillian
    allows more than one deployment per test class and also lets you operate on more
    than one deployment per test method. The `@Deployment` annotation has an attribute
    that’s required for multiple deployment usage: `name`. Setting your own name for
    an archive overrides the default `DEFAULT` value. The `order` attribute may also
    come in handy when testing against multiple deployments; it defines the order
    in which the deployments are sent to the container, if the order matters. You
    also need to use the `@OperateOnDeployment` Arquillian annotation to specify which
    deployment context a test uses. This annotation takes a string, which must match
    the name specified in the `@Deployment` annotation.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的示例都使用了单个部署进行测试。Arquillian允许每个测试类有多个部署，并且还允许您在每个测试方法上操作多个部署。`@Deployment`注解有一个在多部署使用中必需的属性：`name`。为存档设置自己的名称将覆盖默认的`DEFAULT`值。`order`属性在针对多个部署进行测试时也可能很有用；它定义了部署发送到容器的顺序，如果顺序很重要。您还需要使用`@OperateOnDeployment`
    Arquillian注解来指定测试使用的部署上下文。此注解接受一个字符串，该字符串必须与`@Deployment`注解中指定的名称匹配。
- en: 'Here’s an example of multiple deployment:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个多部署的例子：
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Deploys the first deployment file**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 部署第一个部署文件**'
- en: '***2* Deploys the second deployment file**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 部署第二个部署文件**'
- en: '***3* URL of the first deployment**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 首次部署的URL**'
- en: '***4* Test that operates on the X deployment context**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在X部署上下文中运行的测试**'
- en: '***5* URL of the second deployment**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 第二次部署的URL**'
- en: Here, two archives are deployed to the application server. Subsequently, you
    can refer to each one by using `@OperateOnDeployment` annotation to inject the
    `URL` where they’re deployed or to choose the deployment context for the test.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个存档被部署到应用程序服务器。随后，您可以使用`@OperateOnDeployment`注解通过它们部署的`URL`引用每个存档，或者为测试选择部署上下文。
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Arquillian multideployment works only if you’re using the same container for
    all deployment artifacts. You can’t mix two or more different containers in the
    same test. This is a limitation if you’re using different application services
    for each microservice; if you’re using the same application service, then you
    can use this approach to write integration tests for gateway applications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian多部署仅在您为所有部署工件使用相同容器时才有效。您不能在同一个测试中混合两个或更多不同的容器。如果您为每个微服务使用不同的应用程序服务，这是一个限制；如果您使用相同的应用程序服务，则可以使用这种方法为网关应用程序编写集成测试。
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can use Arquillian multideployment to test cluster capabilities or a cluster’s
    configuration.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Arquillian多部署来测试集群功能或集群的配置。
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Arquillian multideployment is useful for writing integration tests that verify
    communication between two services. But another Arquillian feature may help you
    test gateway components to other services: an Arquillian sequence.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian多部署对于编写验证两个服务之间通信的集成测试非常有用。但另一个Arquillian特性可能有助于您测试网关组件对其他服务的测试：一个Arquillian序列。
- en: 5.2.5\. Persistence testing with Arquillian sequence
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5\. 使用Arquillian序列进行持久性测试
- en: 'Sometimes, when you’re writing tests for gateways that communicate with another
    service, you want to set the execution order for the integration tests. A typical
    example is authentication: before accessing an external service, you may need
    to authenticate against it. So, it seems logical that the test of logging in to
    the service should be executed before any other test. The test is dependent on
    the order of execution.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当您为与另一个服务通信的网关编写测试时，您可能想要设置集成测试的执行顺序。一个典型的例子是身份验证：在访问外部服务之前，您可能需要对其进行身份验证。因此，似乎登录服务的测试应该在任何其他测试之前执行。测试依赖于执行顺序。
- en: 'There are many different strategies to address this, but in Arquillian you
    can use the `InSequence` annotation. `InSequence` forces a method-execution order
    for JUnit tests. It receives one integer as a parameter, which indicates the execution
    order of each test method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的策略来解决这个问题，但在 Arquillian 中，您可以使用 `InSequence` 注解。`InSequence` 强制 JUnit
    测试的方法执行顺序。它接收一个整数作为参数，该参数表示每个测试方法的执行顺序：
- en: '[PRE12]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Sets the execution order**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置执行顺序**'
- en: This example uses `@InSequence` to first execute the `login` test and then execute
    the `logout` test.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 `@InSequence` 首先执行 `login` 测试，然后执行 `logout` 测试。
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can run both `login` and `logout` tests individually from your IDE. The
    `InSequence` annotation is useful when the full test class is executed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您的 IDE 中单独运行 `login` 和 `logout` 测试。当完整测试类执行时，`InSequence` 注解非常有用。
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’re familiar with integration test tools, let’s see what you need
    to do to start using them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了集成测试工具，让我们看看您需要做什么才能开始使用它们。
- en: 5.2.6\. Build-script modifications
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.6\. 构建脚本修改
- en: To use the Arquillian Persistence Extension or NoSQLUnit, you need to define
    them as test dependencies in your build script. In the case of Gradle, this information
    goes in the `dependencies` block.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Arquillian Persistence Extension 或 NoSQLUnit，您需要在您的构建脚本中将它们定义为测试依赖项。在 Gradle
    的情况下，此信息位于 `dependencies` 块中。
- en: To use Arquillian multideployment or the `@InSequence` annotation, you don’t
    need to add extra dependencies—just the Arquillian dependency, because this feature
    comes from the Arquillian core. As you saw in [chapter 4](kindle_split_013_split_000.xhtml#ch04),
    to use Arquillian, you need to register an Arquillian BOM file and an Arquillian
    JUnit dependency; and if you’re using WildFly Swarm, you need to add the WildFly
    Swarm Arquillian extension. After adding Arquillian as a dependency, you can start
    writing Arquillian tests and using multideployment and sequence features.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Arquillian 多部署或 `@InSequence` 注解，您不需要添加额外的依赖项——只需 Arquillian 依赖项，因为此功能来自
    Arquillian 核心。正如您在 [第 4 章](kindle_split_013_split_000.xhtml#ch04) 中所看到的，要使用 Arquillian，您需要注册一个
    Arquillian BOM 文件和一个 Arquillian JUnit 依赖项；如果您使用 WildFly Swarm，您需要添加 WildFly Swarm
    Arquillian 扩展。在添加 Arquillian 作为依赖项后，您就可以开始编写 Arquillian 测试并使用多部署和序列功能。
- en: 'If you need to write integration tests for the SQL persistence layer, you must
    add an Arquillian Persistence Extension dependency:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为 SQL 持久层编写集成测试，您必须添加 Arquillian Persistence Extension 依赖项：
- en: '[PRE13]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, to write integration tests for NoSQL databases, you need to add a
    NoSQLUnit dependency. Because NoSQL databases are by definition heterogeneous,
    each NoSQLUnit-supported database has its own dependency. This is the dependency
    for MongoDB:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了编写 NoSQL 数据库的集成测试，您需要添加 NoSQLUnit 依赖项。因为 NoSQL 数据库根据定义是异构的，每个 NoSQLUnit
    支持的数据库都有自己的依赖项。这是 MongoDB 的依赖项：
- en: '[PRE14]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And this is the dependency for Redis:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Redis 的依赖项：
- en: '[PRE15]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once you’ve registered dependencies in the build script, you can begin to write
    integration tests for repositories and gateways.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在构建脚本中注册了依赖项，您就可以开始编写存储库和网关的集成测试。
- en: 5.3\. Writing integration tests for the Gamer application
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 为 Gamer 应用程序编写集成测试
- en: 'In this section, you’ll write integration tests for the Gamer application.
    Usually, unit tests are created in the de facto test directory, src/test/java.
    For integration tests, you can follow three different strategies:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将为 Gamer 应用程序编写集成测试。通常，单元测试是在事实上的测试目录 src/test/java 中创建的。对于集成测试，您可以遵循三种不同的策略：
- en: Create a special package in src/test/java called, for example, `integration-tests`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 src/test/java 中创建一个特殊的包，例如，`integration-tests`。
- en: Create another source folder in the project called, for example, src/integrationTests/java.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目中创建另一个源文件夹，例如，src/integrationTests/java。
- en: Create a new module/subproject in the main project called, for example, `integration-tests`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主项目中创建一个新的模块/子项目，例如，`integration-tests`。
- en: Each of these strategies has advantages and disadvantages and may require you
    to modify your build script. We don’t have a strong opinion about which strategy
    is best; it depends on what your team is comfortable with. In this book, you’ll
    use the first and third strategies, because they’re the most common and the easiest
    to integrate with build tools.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略中的每一个都有其优缺点，可能需要您修改您的构建脚本。我们没有关于哪种策略最好的强烈意见；这取决于您的团队感到舒适的程度。在这本书中，您将使用第一种和第三种策略，因为它们是最常见且最容易与构建工具集成的。
- en: 5.3.1\. Testing the Comments class
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. 测试 Comments 类
- en: Let’s look at how to write an integration test for the `book.comments.boundary.Comments`
    class. This simple class, shown in the next listing, implements logic for storing
    comments in MongoDB and getting comments with ratings from MongoDB (code/comments/src/main/java/book/comments/boundary/Comments.java).
    It also creates a MongoDB connection from the configuration provided in the resources.xml
    file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写 `book.comments.boundary.Comments` 类的集成测试。这个简单的类，如下一列表所示，实现了在 MongoDB
    中存储评论和从 MongoDB 获取带评分的评论的逻辑（code/comments/src/main/java/book/comments/boundary/Comments.java）。它还从
    resources.xml 文件中提供的配置创建 MongoDB 连接。
- en: Listing 5.5\. `Comments` class
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. `Comments` 类
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Listing 5.6](kindle_split_014_split_003.xhtml#ch05ex06) shows a test for the
    `createComment` logic (code/comments/i-tests/src/test/java/book/comments/CommentsTest.java).
    In this persistence test, you need three elements:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.6](kindle_split_014_split_003.xhtml#ch05ex06) 展示了对 `createComment` 逻辑的测试（code/comments/i-tests/src/test/java/book/comments/CommentsTest.java）。在这个持久性测试中，你需要三个元素：'
- en: A running MongoDB instance. It can be started manually or using a build script.
    In [chapter 8](kindle_split_017_split_000.xhtml#ch08), you’ll learn another way
    that uses Docker.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在运行的 MongoDB 实例。它可以手动启动或使用构建脚本启动。在 [第 8 章](kindle_split_017_split_000.xhtml#ch08)
    中，你将了解另一种使用 Docker 的方法。
- en: An empty MongoDB `comments` collection into which to insert data. It’s important
    to create a document in an empty collection, to avoid any possibility of a constraint
    violation.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空的 MongoDB `comments` 集合，用于插入数据。在空集合中创建一个文档很重要，以避免任何约束违规的可能性。
- en: The expected dataset, to verify that the `comments` collection has the expected
    data.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期数据集，以验证 `comments` 集合具有预期数据。
- en: Listing 5.6\. Testing the `createComment` logic
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 测试 `createComment` 逻辑
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Sets the test as an Arquillian test**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将测试设置为 Arquillian 测试**'
- en: '***2* Adds a NoSQLUnit libraries archive, because the test is executed on a
    container**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加 NoSQLUnit 库存档，因为测试是在容器上执行的**'
- en: '***3* Renames the MongoDB test configuration file resources-test.xml to the
    correct name and location**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 MongoDB 测试配置文件 resources-test.xml 重命名为正确的名称和位置**'
- en: '***4* Adds the expected dataset to the package**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将预期数据集添加到包中**'
- en: '***5* Registers the NoSQLUnit MongoDB rule**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 注册 NoSQLUnit MongoDB 规则**'
- en: '***6* Injects the Comments boundary class into the test**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将注释边界类注入到测试中**'
- en: '***7* Cleans the MongoDB database before executing the test**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在执行测试之前清理 MongoDB 数据库**'
- en: '***8* Sets the expected data in the comments collection**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 在注释集合中设置预期数据**'
- en: 'The following things are important to note about the persistence test:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 关于持久性测试需要注意以下事项：
- en: It’s a normal Arquillian test that executes a NoSQLUnit JUnit rule.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个正常的 Arquillian 测试，它执行 NoSQLUnit JUnit 规则。
- en: The test is executed on the container side, which means you must add everything
    you need in the classpath in the `WebArchive`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是在容器端执行的，这意味着你必须将所有需要的添加到 `WebArchive` 的类路径中。
- en: '`UsingDataSet` and `ShouldMatchDataSet` simplify the management of the persistence
    state by asserting that the test is always in a known/desired state for execution.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsingDataSet` 和 `ShouldMatchDataSet` 通过断言测试始终处于已知/期望的状态来简化持久性状态的管理。'
- en: The expected dataset is shown next (code/comments/i-tests/src/test/resources/expected-insert-comments.json).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 预期数据集如下所示（code/comments/i-tests/src/test/resources/expected-insert-comments.json）。
- en: Listing 5.7\. Dataset
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 数据集
- en: '[PRE18]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, you set the desired state of the MongoDB database after test execution.
    In this case, the database should contain a collection called `comments` that
    holds one document with these three attributes:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你设置测试执行后 MongoDB 数据库的期望状态。在这种情况下，数据库应包含一个名为 `comments` 的集合，该集合包含一个具有以下三个属性的文档：
- en: '`comment`, which has the value `"This Game is Awesome"`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comment`，其值为 `"This Game is Awesome"`。'
- en: '`rate`, which has the value `5`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate`，其值为 `5`'
- en: '`gameId`, which has the value `1`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameId`，其值为 `1`'
- en: After you execute the test, if the MongoDB database is in the given state, the
    test will succeed; if not, the test will fail.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试后，如果 MongoDB 数据库处于给定的状态，则测试将成功；如果不处于该状态，则测试将失败。
- en: 5.3.2\. Testing the CommentsGateway class
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 测试 CommentsGateway 类
- en: Now, let’s look at how to write an integration test for the `book.aggr.CommentsGateway`
    class. This class, shown in [listing 5.8](kindle_split_014_split_003.xhtml#ch05ex08),
    is a simple `boundary` class that acts as gateway between the aggregator service
    and the comments service (code/aggregator/src/main/java/book/aggr/CommentsGateway).
    It’s responsible for communicating with the comments service to create new comments
    or get information about them.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为`book.aggr.CommentsGateway`类编写集成测试。这个类，如[列表5.8](kindle_split_014_split_003.xhtml#ch05ex08)所示，是一个简单的`boundary`类，充当聚合服务与评论服务之间的网关（code/aggregator/src/main/java/book/aggr/CommentsGateway）。它负责与评论服务通信，以创建新评论或获取有关它们的详细信息。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: HK2 is a lightweight, dynamic DI framework that can be used with Jersey.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: HK2是一个轻量级、动态的DI框架，可以与Jersey一起使用。
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 5.8\. `CommentsGateway` class
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. `CommentsGateway`类
- en: '[PRE19]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Annotation placed on classes that are to be automatically added to HK2**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 标注在要自动添加到HK2的类上**'
- en: '***2* Builds a connection to the comments service**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 建立与评论服务的连接**'
- en: '***3* Gets URL to connect to Comments service**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取连接到评论服务的URL**'
- en: '***4* Creates a comment**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一条评论**'
- en: '***5* Registers a marshaller to convert a JsonObject to JSON**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 注册一个marshaller以将JsonObject转换为JSON**'
- en: '***6* Makes an asynchronous call that returns the java.util.concurrent.Future
    class**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 执行一个异步调用，该调用返回java.util.concurrent.Future类**'
- en: '***7* Executes a POST**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 执行一个POST请求**'
- en: 'Let’s write a test for the `createComment` method: see [listing 5.9](kindle_split_014_split_003.xhtml#ch05ex09)
    (code/aggregator/i-tests/src/test/java/book/aggr/CommentsGatewayTest.java). Notice
    that in this case, you need to do the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`createComment`方法编写一个测试：请参阅[列表5.9](kindle_split_014_split_003.xhtml#ch05ex09)（code/aggregator/i-tests/src/test/java/book/aggr/CommentsGatewayTest.java）。请注意，在这种情况下，你需要执行以下操作：
- en: '**1**.  Deploy the comments service in Tomcat.'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  在Tomcat中部署评论服务。'
- en: '**2**.  Start a MongoDB instance, because it’s the storage server used in that
    service.'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  启动一个MongoDB实例，因为它是该服务使用的存储服务器。'
- en: '**3**.  Execute the test from the aggregator service for the `CommentsGateway`
    class.'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  从聚合服务执行针对`CommentsGateway`类的测试。'
- en: 'Ideally, this test should deploy two artifacts: the comments service is deployed
    in its application server (Apache Tomcat); and, from the aggregator, `CommentsGateway`
    should be deployed in its application server (Apache TomEE). This seems like a
    perfect match for Arquillian’s multideployment feature.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这个测试应该部署两个工件：评论服务部署在其应用程序服务器（Apache Tomcat）中；从聚合器来看，`CommentsGateway`应该部署在其应用程序服务器（Apache
    TomEE）中。这似乎非常适合Arquillian的多部署功能。
- en: The problem is that you can’t use that feature in this case. The aggregator
    service runs on an Apache Tomcat server, and the comments service runs on an Apache
    TomEE server—and Arquillian multideployments only work when you’re using the same
    server for all deployments. Despite this limitation, you can use Arquillian in
    client mode and deploy the entire comments service in its own server (Apache TomEE),
    and use `CommentsGateway` in client mode instead of deploying it, too.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于在这种情况下你不能使用该功能。聚合服务运行在Apache Tomcat服务器上，而评论服务运行在Apache TomEE服务器上——Arquillian多部署仅在所有部署使用相同服务器时才有效。尽管存在这种限制，你可以在客户端模式下使用Arquillian，并在自己的服务器（Apache
    TomEE）上部署整个评论服务，同时也可以在客户端模式下使用`CommentsGateway`而不是部署它。
- en: 'This test has the following features:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试具有以下功能：
- en: A `@Deployment` method with the `testable` attribute set to `false` so the test
    is run in client mode
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有`testable`属性设置为`false`的`@Deployment`方法，以便测试以客户端模式运行
- en: Deployment of an entire application, rather than a microdeployment
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署整个应用程序，而不是微部署
- en: The test, using the `CommentsGateway` class
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CommentsGateway`类的测试
- en: Listing 5.9\. Testing the `createComment` method
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9\. 测试`createComment`方法
- en: '[PRE20]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Sets the test in client mode**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将测试设置为客户端模式**'
- en: '***2* Builds an artifact by running the Gradle assemble task in the comments
    service**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过在评论服务中运行Gradle assemble任务来构建一个工件**'
- en: '***3* Injects the URL where the comments service is deployed**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入评论服务部署的URL**'
- en: '***4* Instantiates a new CommentsGateway class, and executes the create method**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 实例化一个新的CommentsGateway类，并执行创建方法**'
- en: '***5* Asserts that the returned ID is a MongoDB object ID**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 断言返回的ID是MongoDB对象ID**'
- en: This test runs in client mode. This means Arquillian deploys the test archive
    “as is” to the container and runs the test in the same JVM as the test runner.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在客户端模式下运行。这意味着Arquillian将测试存档“原样”部署到容器中，并在与测试运行器相同的JVM中运行测试。
- en: The test also demonstrates another way to use the ShrinkWrap project. In the
    previous chapter, you saw how to use ShrinkWrap to create a microdeployment (a
    deployment file containing only parts of the application). But in this example,
    you create the project dynamically by using `EmbeddedGradleImporter`. With `EmbeddedGradleImporter`,
    you set the root directory where the build.gradle file is located, and ShrinkWrap
    takes care of calling Gradle tasks to assemble the project and return it as a
    valid archive. It ignores the test steps by default, to avoid possible infinite
    recursion.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 测试还演示了另一种使用 ShrinkWrap 项目的途径。在前一章中，你看到了如何使用 ShrinkWrap 创建微部署（只包含应用程序部分的应用程序部署文件）。但在这个例子中，你通过使用
    `EmbeddedGradleImporter` 动态创建项目。使用 `EmbeddedGradleImporter`，你设置 build.gradle 文件所在的根目录，ShrinkWrap
    负责调用 Gradle 任务来组装项目，并将其作为有效的存档返回。默认情况下，它忽略测试步骤，以避免可能的无穷递归。
- en: There’s also a `MavenImporter` class you can use if the project will be managed
    by Maven.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目将由 Maven 管理，你也可以使用 `MavenImporter` 类。
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use the *Maven resolver* to resolve an artifact from your artifact repository
    instead of building it every time. An example of such a call is `Maven.resolver().resolve("org.gamer:game-aggregator:war:1.0.0").withTransitivity().as(WebArchive.class);`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *Maven 解析器* 从你的工件仓库中解析工件，而不是每次都构建它。这样的调用示例是 `Maven.resolver().resolve("org.gamer:game-aggregator:war:1.0.0").withTransitivity().as(WebArchive.class);`。
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Integration tests should also cover unexpected behaviors such as timeouts,
    slow responses from external communications, and internal errors. Such cases can
    be difficult to reproduce, so the best approach is to use a stub version of the
    external component with WireMock, which we introduced in [chapter 4](kindle_split_013_split_000.xhtml#ch04).
    It’s best to put these corner test cases in a class other than the one containing
    the tests that validate whether the gateway works in normal conditions. Dividing
    test classes between expected and abnormal behaviors provides several advantages:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试还应涵盖意外行为，如超时、外部通信缓慢响应和内部错误。这些情况可能难以重现，因此最佳方法是使用 WireMock 的外部组件的模拟版本，我们在第
    4 章中介绍了它。最好将这些边缘测试案例放在一个不同于验证网关在正常条件下工作的测试类的类中。将测试类分为预期和异常行为提供了几个优点：
- en: You can run these tests in parallel.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以并行运行这些测试。
- en: For an external reader, it’s easier to understand how the class works in normal
    circumstances.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于外部读者来说，更容易理解该类在正常情况下的工作方式。
- en: You don’t mix infrastructure code. In one case, you’re deploying the real service;
    and in the other, you’re deploying a stub service.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会混合基础设施代码。在一个案例中，你部署的是真实服务；在另一个案例中，你部署的是模拟服务。
- en: The following integration test checks abnormal situations for the `CommentsGateway`
    class (code/aggregator/i-tests/src/test/java/book/aggr/CommentsNegativeTest.java).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下集成测试检查 `CommentsGateway` 类（code/aggregator/i-tests/src/test/java/book/aggr/CommentsNegativeTest.java）的异常情况。
- en: Listing 5.10\. Testing unexpected behavior
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 测试意外行为
- en: '[PRE21]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Starts the WireMock server**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 启动 WireMock 服务器**'
- en: '***2* Records stub execution**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 记录模拟执行**'
- en: '***3* Configures CommentsGateway to use a WireMock stub**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 配置 CommentsGateway 使用 WireMock 模拟**'
- en: '***4* Verifies that the error code and message use an internal server error
    type**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 验证错误代码和消息使用内部服务器错误类型**'
- en: '***5* Sets the response time to 1 second**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 设置响应时间为 1 秒**'
- en: '***6* Verifies that a timeout exception is thrown**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 验证是否抛出超时异常**'
- en: 'In this case, you’re testing two scenarios: how the gateway behaves when the
    external service returns a server error, and how the gateway behaves when the
    external service takes more time than expected to return a response. For the latter
    case, you configure a fixed delay of 1 second: it’s enough, because `CommentsGateway`
    is configured with a timeout of a half second.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你正在测试两种场景：当外部服务返回服务器错误时，网关的行为，以及当外部服务返回响应所需时间超过预期时，网关的行为。对于后一种情况，你配置了1秒的固定延迟：这已经足够了，因为
    `CommentsGateway` 配置了半秒的超时。
- en: You can test other abnormal situations in a similar way. This test demonstrates
    the most common use cases.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用类似的方式测试其他异常情况。这个测试演示了最常见的使用案例。
- en: This is the last integration test we’ll show you. As you’ve learned, you can
    write integration tests to verify communication with external elements of the
    service, such as other services or persistence servers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将向您展示的最后一个集成测试。正如您所学的，您可以编写集成测试来验证与服务的其他外部元素（如其他服务或持久化服务器）的通信。
- en: 5.4\. Exercises
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 练习
- en: 'After reading this chapter, you’re ready to write tests for `book.games.boundary.IgdbGateway`,
    which is located in the aggregator service. This gateway connects to an external
    public service: the IGDB site.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您就可以为位于聚合服务中的`book.games.boundary.IgdbGateway`编写测试了。这个网关连接到一个外部公开服务：IGDB网站。
- en: 'For this test, we suggest that you use what you learned in [chapter 4](kindle_split_013_split_000.xhtml#ch04)
    about Arquillian and WildFly Swarm: deploy the gateway class into WildFly Swarm,
    because the service to which the gateway connects is already deployed, and test
    the methods. To test abnormal behaviors, use WireMock, as you did to test the
    comments gateway earlier in this chapter.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次测试，我们建议您使用在[第4章](kindle_split_013_split_000.xhtml#ch04)中学到的关于Arquillian和WildFly
    Swarm的知识：将网关类部署到WildFly Swarm中，因为网关连接的服务已经部署，并测试这些方法。为了测试异常行为，使用WireMock，就像您在本章早期测试评论网关时做的那样。
- en: Also try writing a test for `book.video.boundary.YouTubeVideos` from the video
    service. This is a persistence test using Redis as the backend. Use what you learned
    about the Spring Boot testing framework in [chapter 4](kindle_split_013_split_000.xhtml#ch04)
    and [section 5.2](kindle_split_014_split_002.xhtml#ch05lev1sec2).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 还尝试编写一个针对视频服务中的`book.video.boundary.YouTubeVideos`的测试。这是一个使用Redis作为后端存储的持久化测试。使用您在[第4章](kindle_split_013_split_000.xhtml#ch04)和[第5.2节](kindle_split_014_split_002.xhtml#ch05lev1sec2)中学到的关于Spring
    Boot测试框架的知识。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Integration tests are responsible for testing communication between a microservice
    and its data stores or external components.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试负责测试微服务与其数据存储或外部组件之间的通信。
- en: You can develop persistence tests for SQL and NoSQL databases that are isolated
    between executions.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为隔离执行的SQL和NoSQL数据库开发持久化测试。
- en: Tests for gateway classes may need to communicate with external services.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关类的测试可能需要与外部服务进行通信。
- en: You can resolve artifacts in tests from an artifact store or build them before
    executing the test.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在测试中从工件存储库解析工件，或者在执行测试之前构建它们。
- en: The main difficulty with integration tests is having external components and
    data stores deployed, up, and running. For example, you may need to install in
    your test environment the data store used in production, or deploy an external
    service the same way you do in production.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试的主要困难在于外部组件和数据存储的部署、启动和运行。例如，您可能需要在测试环境中安装生产中使用的存储，或者以与生产相同的方式部署外部服务。
- en: Arquillian provides a multideployment feature, but it’s limited because you
    need to run the deployments on the same application server. One possible workaround
    is to deploy the entire application using Arquillian and ShrinkWrap resolvers,
    and use a gateway class from outside the container. This is a valid approach,
    but you’re still constrained by the technology used in the gateway and the external
    component implementation.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arquillian提供了一个多部署功能，但它有限，因为您需要在同一应用服务器上运行部署。一个可能的解决方案是使用Arquillian和ShrinkWrap解析器部署整个应用程序，并使用容器外的网关类。这是一个有效的方法，但您仍然受限于网关和外部组件实现中使用的技术。
