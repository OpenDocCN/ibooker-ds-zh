- en: 4 Dictionaries and sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 字典和集合
- en: Dictionaries ([http://mng.bz/5aAz](http://mng.bz/5aAz)), or *dicts*, are one
    of Python’s most powerful and important data structures. You may recognize them
    from other programming languages, in which they can be known as “hashes,” “associative
    arrays,” “hash maps,” or “hash tables.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字典（[http://mng.bz/5aAz](http://mng.bz/5aAz)），或称为*dicts*，是Python中最强大和最重要的数据结构之一。你可能在其他编程语言中认识它们，在那里它们可以被称为“散列”、“关联数组”、“哈希映射”或“哈希表”。
- en: In a dict, we don’t enter individual elements, as in a list or tuple. Rather,
    we enter pairs of data, with the first item known as the *key* and the second
    item known as the *value*. Whereas the index in a string, list, or tuple is always
    an integer, and always starts with 0, dict keys can come from a wide variety of
    Python types--typically integers or strings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中，我们不像在列表或元组中那样输入单个元素。相反，我们输入数据对，第一个项目被称为*键*，第二个项目被称为*值*。而字符串、列表或元组中的索引始终是整数，并且始终从0开始，字典键可以来自Python的广泛类型--通常是整数或字符串。
- en: This seemingly small difference, that we can use arbitrary keys to locate our
    values, rather than using integer indexes, is actually crucial. Many programming
    tasks involve name-value pairs--such as usernames/user IDs, IP addresses/hostnames,
    and email addresses/encrypted passwords. Moreover, much of the Python language
    itself is implemented using dicts. So knowing how dicts work, and how to better
    use them, will give you insights into the actual implementation of Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似微小的差异，即我们可以使用任意的键来定位我们的值，而不是使用整数索引，实际上是非常重要的。许多编程任务都涉及名称值对--如用户名/用户ID、IP地址/主机名和电子邮件地址/加密密码。此外，Python语言本身的大部分实现都是使用字典完成的。因此，了解字典的工作原理以及如何更好地使用它们，将帮助你了解Python的实际实现。
- en: 'I use dicts in three main ways:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我主要用三种方式使用字典：
- en: '*As small databases, or records* --It’s often convenient to use dicts for storing
    name-value pairs. We can load a configuration file into Python as a dict, retrieving
    the values associated with the configuration options. We can store information
    about a file, or a user’s preference, or a variety of other things with standard
    names and unknown values. When used this way, you define a dict once, often at
    the top of a program, and it doesn’t change.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为小型数据库或记录* --使用字典来存储名称值对通常很方便。我们可以将配置文件加载到Python中作为字典，检索与配置选项关联的值。我们可以使用标准名称和未知值来存储有关文件、用户偏好或各种其他信息。当这样使用时，你只需定义一次字典，通常在程序的顶部，并且它不会改变。'
- en: '*For storing closely related names and values* --Rather than creating a number
    of separate variables, you can create a dict with several key-value pairs. I do
    this when I want to store (for example) several pieces of information about a
    website, such as its URL, my username, and the last date I visited. Sure, you
    could use several variables to keep track of this information, but a dict lets
    you manage it more easily--as well as pass it to a function or method all at once,
    via a single variable.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为了存储紧密相关的名称和值* --而不是创建多个单独的变量，你可以创建一个包含多个键值对的字典。当我想要存储（例如）关于一个网站的多条信息时，我会这样做，比如它的URL、我的用户名以及我最后一次访问的日期。当然，你可以使用多个变量来跟踪这些信息，但字典让你更容易管理它--以及一次性通过单个变量将其传递给函数或方法。'
- en: '*For accumulating information over time* --If you’re keeping track of which
    errors have occurred in your program, and how many times each error has happened,
    a dict can be a great way to do this. You can also use one of the classes that
    inherit from `dict`, such as `Counter` or `defaultdict`, both defined in the `collections`
    module ([http://mng.bz/6Qwy](http://mng.bz/6Qwy)). When used this way, a dict
    grows over time, adding new key-value pairs and updating the values as the program
    executes.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为了随着时间的推移积累信息* --如果你正在跟踪程序中发生的错误以及每个错误发生的次数，字典可以是一个很好的方式来完成这项工作。你还可以使用从`dict`继承的类之一，例如`Counter`或`defaultdict`，这两个类都在`collections`模块中定义（[http://mng.bz/6Qwy](http://mng.bz/6Qwy)）。当这样使用时，字典会随着时间的推移而增长，添加新的键值对，并在程序执行时更新值。'
- en: You’ll undoubtedly find additional ways to use dicts in your programs, but these
    are the three that occur most often in my work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你无疑会发现更多在程序中使用字典的方法，但这些都是我在工作中最常遇到的三种。
- en: Hashing and dicts
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希和字典
- en: From what I’ve written so far, it might sound like any Python object can be
    used as the key or value in a dict. But that’s not true. While absolutely anything
    can be stored in a Python value, only *hashable* types, meaning those on which
    we can run the `hash` function, can be used as keys. This same `hash` function
    ensures that a dict’s keys are unique, and that searching for a key can be quite
    fast.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从我迄今为止所写的来看，可能听起来任何Python对象都可以用作字典中的键或值。但这并不正确。虽然绝对可以将任何东西存储在Python值中，但只有*可哈希*的类型，即我们可以运行`hash`函数的类型，才能用作键。这个相同的`hash`函数确保了字典的键是唯一的，并且搜索键可以非常快。
- en: What’s a hash function? Why does Python use one? And how does it affect what
    we do?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是哈希函数？Python为什么使用它？它如何影响我们所做的工作？
- en: The basic idea is as follows. Let’s assume that you have a building with 26
    offices. If a visitor comes looking to meet with a Ms. Smith, how can they know
    where to find her? Without a receptionist or office directory, the visitor will
    need to go through the offices, one by one, looking for Ms. Smith’s office.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的想法是这样的。假设你有一个有26个办公室的大楼。如果一个访客来寻找与史密斯女士见面，他们如何知道在哪里找到她？如果没有接待员或办公室目录，访客将需要逐个走过办公室，寻找史密斯女士的办公室。
- en: This is the way that we search through a string, list, or tuple in Python. The
    time it takes to find a value in such a sequence is described in computer science
    literature as `O(n)`. This means that as the sequence gets longer, finding what
    you’re looking for takes proportionally more time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们通过Python中的字符串、列表或元组进行搜索的方式。在这样一个序列中找到值所需的时间在计算机科学文献中被描述为`O(n)`。这意味着随着序列变长，找到你想要的东西需要成比例更多的时间。
- en: Now let’s reimagine our office environment. There’s still no directory or receptionist,
    but there is a sign saying that if you’re looking for an employee, then just go
    to the office whose number matches the first letter of their last name--using
    the scheme a=1, b=2, c=3, and so forth.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重新想象我们的办公室环境。仍然没有目录或接待员，但有一个标志说，如果你在寻找员工，只需去与他们的姓氏首字母对应的办公室——使用方案a=1，b=2，c=3等等。
- en: Since the visitor wants to find Ms. Smith, they calculate that S is the 19th
    letter in the English alphabet, go to room 19, and are delighted to find that
    she’s there. If the visitor were looking for Mr. Jones, of course, they would
    instead go to room 10, since J is the 10th letter of the alphabet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访客想找到史密斯女士，他们计算出S是英语字母表中的第19个字母，去了19号房间，很高兴地发现她在那里。如果访客在寻找琼斯先生，当然，他们就会去10号房间，因为J是字母表中的第10个字母。
- en: This sort of search, as you can see, doesn’t require much time at all. Indeed,
    it doesn’t matter whether our company has two employees or 25 employees, or even
    250 employees--as the company grows, visitors can still find our employees’ offices
    in the same amount of time. This is known in the programming world as `O(1)`,
    or *constant time*, and it’s pretty hard to beat.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种搜索，正如你所见，几乎不需要任何时间。实际上，无论我们的公司有两名员工还是25名员工，甚至250名员工——随着公司的发展，访客仍然可以在相同的时间内找到我们的员工办公室。这在编程世界中被称为`O(1)`，或*常数时间*，而且很难被超越。
- en: 'Of course, there is a catch: what if we have two people whose last names both
    begin with “S”? We can solve this problem a few different ways. For example, we
    can use the first two letters of the last name, or have all of the people whose
    names begin with “S” share an office. Then we have to search through all of the
    people in a given office, which typically won’t be too terrible.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一个问题：如果我们有两个人的姓氏都以“S”开头怎么办？我们可以用几种不同的方法解决这个问题。例如，我们可以使用姓氏的前两个字母，或者让所有姓氏以“S”开头的人共享一个办公室。然后我们必须在给定的办公室中搜索所有人，这通常不会太糟糕。
- en: The description I’ve given you here is a simplified version of a hash function.
    Such functions are used in a variety of places in the programming world. For example,
    they’re especially popular for cryptography and security, because while their
    mapping of inputs to outputs is deterministic, it’s virtually impossible to calculate
    without using the hash function itself. They’re also central to how Python’s dicts
    work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里所描述的是哈希函数的简化版本。这类函数在编程世界中用于各种地方。例如，它们在密码学和安全性方面特别受欢迎，因为虽然它们的输入到输出的映射是确定的，但没有使用哈希函数本身几乎不可能计算。它们也是Python字典工作的核心。
- en: A dict entry consists of a key-value pair. The key is passed to Python’s hash
    function, which returns the location at which the key-value pair should be stored.
    So if you say `d['a']` `=` `1`, then Python will execute `hash('a')` and use the
    result to store the key-value pair. And when you ask for the value of `d['a']`,
    Python can invoke `hash('a')` and immediately check in the indicated memory slot
    whether the key-value pair is there. Dicts are called *mappings* in the Python
    world, because the hash function *maps* our key to an integer, which we can then
    use to store our key-value pairs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 字典条目由键值对组成。键被传递给 Python 的哈希函数，该函数返回键值对应存储的位置。所以如果你说 `d['a']` `=` `1`，那么 Python
    将执行 `hash('a')` 并使用结果来存储键值对。当你询问 `d['a']` 的值时，Python 可以调用 `hash('a')` 并立即检查指定的内存槽中是否存在键值对。在
    Python 世界中，字典被称为 *映射*，因为哈希函数 *映射* 我们的关键字到一个整数，然后我们可以使用这个整数来存储我们的键值对。
- en: I’m leaving out a number of details here, including the significant behind-the-scenes
    changes that occurred in Python 3.6\. These changes guaranteed that key-value
    pairs will be stored (and retrieved) in chronological order and reduced memory
    usage by about one third. But this mental model should help to explain how dicts
    accomplish search times of `O(1)` (constant time), regardless of how many key-value
    pairs are added, and why they’re used not only by Python developers, but by the
    language itself. You can learn more about this new implementation in a great talk
    by Raymond Hettinger at [http://mng.bz/oPmM](http://mng.bz/oPmM).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里省略了一些细节，包括 Python 3.6 中发生的重大幕后变化。这些变化保证了键值对将按时间顺序存储（和检索），并减少了大约三分之一的内存使用。但这个思维模型应该有助于解释字典如何实现
    `O(1)`（常数时间）的搜索时间，无论添加了多少键值对，以及为什么它们不仅被 Python 开发者使用，还被语言本身使用。你可以在 Raymond Hettinger
    的精彩演讲中了解更多关于这种新实现的信息，[http://mng.bz/oPmM](http://mng.bz/oPmM)。
- en: The hash function explains why Python’s dicts
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数解释了为什么 Python 的字典
- en: always store key-value pairs together
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是存储键值对在一起
- en: guarantee very fast lookup for keys
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证对键的非常快速的查找
- en: ensure key uniqueness
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保键的唯一性
- en: don’t guarantee anything regarding value lookup
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不保证关于值查找的任何内容
- en: 'As for why lists and other mutable built-in types are seen as “unhashable”
    in Python, the reason is simple: if the key changes, the output from running `hash`
    on it will change too. That means the key-value pair might be in the dict but
    not be findable. To avoid such trouble, Python ensures that our keys can’t change.
    The terms *hashable* and *immutable* aren’t the same, but there’s a great deal
    of overlap--and when you’re starting off with the language, it’s not worth worrying
    about the differences very much.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为什么列表和其他可变内置类型在 Python 中被视为“不可哈希”的原因很简单：如果键发生变化，对它运行 `hash` 的输出也会发生变化。这意味着键值对可能在字典中，但无法找到。为了避免这种麻烦，Python
    确保我们的键不能改变。术语 *可哈希* 和 *不可变* 并不相同，但它们有很大的重叠——而且当你刚开始使用这种语言时，不必过分担心这些差异。
- en: Sets
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Closely related to dicts are sets ([http://mng.bz/vxlM](http://mng.bz/vxlM)),
    which you can think of as dicts without values. (I often joke that this means
    sets are actually immoral dicts.) Sets are extremely useful when you need to look
    something up in a large collection, such as filenames, email addresses, or postal
    codes, because searching is `O(1)`, just as in a dict. I’ve also increasingly
    found myself using sets to remove duplicate values from an input list--such as
    IP addresses in a log file, or the license plate numbers of vehicles that have
    passed through a parking garage entrance in a given day.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典密切相关的是集合 ([http://mng.bz/vxlM](http://mng.bz/vxlM))，你可以将其视为没有值的字典。（我经常开玩笑说这意味着集合实际上是“不道德”的字典。）当你在大量集合中查找某些内容时，集合非常有用，例如文件名、电子邮件地址或邮政编码，因为搜索是
    `O(1)`，就像在字典中一样。我也越来越多地发现自己使用集合从输入列表中删除重复值——例如日志文件中的 IP 地址，或者某一天通过停车场入口的车辆的牌照号码。
- en: In this chapter, you’ll use dicts and sets in a variety of ways to solve problems.
    It’s safe to say that nearly every Python program uses dicts, or perhaps an alternative
    dict such as `defaultdict` from the `collections` module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将以各种方式使用字典和集合来解决问题。可以说，几乎每个 Python 程序都使用字典，或者可能是 `collections` 模块中的 `defaultdict`
    这样的字典替代品。
- en: Table 4.1 What you need to know
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `input` | Prompts the user to enter a string, and returns a string. | `input(''Enter
    your name: '')` | [http://mng.bz/wB27](http://mng.bz/wB27) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `input` | 提示用户输入一个字符串，并返回一个字符串。 | `input(''Enter your name: '')` | [http://mng.bz/wB27](http://mng.bz/wB27)
    |'
- en: '| `dict` | Python’s dict type for storing key-value pairs. `dict` can also
    be used to create a new dict. | `d = {''a'':1, ''b'':2}` or `d = dict''a'', 1),
    (''b'', 2` | [http://mng.bz/5aAz](http://mng.bz/5aAz) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `dict` | Python 的字典类型，用于存储键值对。`dict` 还可以用来创建一个新的字典。 | `d = {''a'':1, ''b'':2}`
    或 `d = dict(''a'', 1), (''b'', 2)` | [http://mng.bz/5aAz](http://mng.bz/5aAz)
    |'
- en: '| `d[k]` | Retrieves the value associated with key `k` in dict `d`. | `x =
    d[k]` | [http://mng.bz/5aAz](http://mng.bz/5aAz) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `d[k]` | 在字典 `d` 中检索与键 `k` 关联的值。 | `x = d[k]` | [http://mng.bz/5aAz](http://mng.bz/5aAz)
    |'
- en: '| `dict.get` | Just like `d[k]`, except that it returns `None` (or the second,
    optional argument) if `k` isn’t in `d`. | `x = d.get(k)` or `x = d.get(k, 10)`
    | [http://mng.bz/4AeV](http://mng.bz/4AeV) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `dict.get` | 与 `d[k]` 类似，但如果 `k` 不在 `d` 中，则返回 `None`（或第二个可选参数）。 | `x = d.get(k)`
    或 `x = d.get(k, 10)` | [http://mng.bz/4AeV](http://mng.bz/4AeV) |'
- en: '| `dict.items` | Returns an iterator that returns a key-value pair (as a tuple)
    with each iteration. | `for key, value in d.items():` | [http://mng.bz/4AeV](http://mng.bz/4AeV)
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `dict.items` | 返回一个迭代器，每次迭代返回一个键值对（作为元组）。 | `for key, value in d.items():`
    | [http://mng.bz/4AeV](http://mng.bz/4AeV) |'
- en: '| `set` | Python’s set type for storing unique, hashable items. `set` can also
    be used to create a new set. | `s = {1,2,3} # creates a 3-element set` | [http://mng.bz/K2eE](http://mng.bz/K2eE)
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `set` | Python 的集合类型，用于存储唯一的可哈希项。`set` 还可以用来创建一个新的集合。 | `s = {1,2,3} # 创建一个包含3个元素的集合`
    | [http://mng.bz/K2eE](http://mng.bz/K2eE) |'
- en: '| `set.add` | Adds one item to a set. | `s.add(10)` | [http://mng.bz/yyzq](http://mng.bz/yyzq)
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `set.add` | 向集合中添加一个项目。 | `s.add(10)` | [http://mng.bz/yyzq](http://mng.bz/yyzq)
    |'
- en: '| `set.update` | Adds the elements of one or more iterables to a set. | `s.update([10,
    20, 30, 40, 50])` | [http://mng.bz/MdOn](http://mng.bz/MdOn) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `set.update` | 将一个或多个可迭代对象的元素添加到集合中。 | `s.update([10, 20, 30, 40, 50])` |
    [http://mng.bz/MdOn](http://mng.bz/MdOn) |'
- en: '| `str.isdigit` | Returns `True` if all of the characters in a string are digits
    0-9. | `''12345''.isdigit()``# returns True` | [http://mng.bz/oPVN](http://mng.bz/oPVN)
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `str.isdigit` | 如果字符串中的所有字符都是数字0-9，则返回 `True`。 | `''12345''.isdigit()``#
    返回 True` | [http://mng.bz/oPVN](http://mng.bz/oPVN) |'
- en: Exercise 14 ■ Restaurant
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14 ■ 餐厅
- en: One common use for dicts is as a small database within our program. We set up
    the dict at the top of the program, and then reference it throughout the program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的一个常见用途是在我们的程序中作为一个小型数据库。我们在程序的顶部设置字典，然后在程序中引用它。
- en: For example, you might set up a dict of months, with the month names as keys
    and numbers as values. Or perhaps you’ll have a dict of users, with user IDs as
    the keys and email addresses as the values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能设置一个包含月份的字典，月份名称作为键，数字作为值。或者也许您会有一个包含用户的字典，用户ID作为键，电子邮件地址作为值。
- en: 'In this exercise, I want you to create a new constant dict, called `MENU`,
    representing the possible items you can order at a restaurant. The keys will be
    strings, and the values will be prices (i.e., integers). You should then write
    a function, `restaurant`, that asks the user to enter an order:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我想让你创建一个新的常量字典，称为 `MENU`，代表您可以在餐厅订购的可能项目。键将是字符串，值将是价格（即整数）。然后您应该编写一个名为
    `restaurant` 的函数，让用户输入订单：
- en: If the user enters the name of a dish on the menu, the program prints the price
    and the running total. It then asks the user again for their order.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入的菜名在菜单上，程序将打印价格和累计总金额。然后它会再次询问用户的订单。
- en: If the user enters the name of a dish **not** on the menu, the program scolds
    the user (mildly). It then asks the user again for their order.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入的菜名不在菜单上，程序会轻微地责备用户。然后它会再次询问用户的订单。
- en: If the user enters an empty string, the program stops prompting and prints the
    total amount.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入一个空字符串，程序将停止提示并打印总金额。
- en: 'For example, a session with the user might look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与用户的会话可能如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you can always check to see if a key is in a dict with the `in` operator.
    That returns `True` or `False`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以使用 `in` 操作符始终检查一个键是否在字典中。这返回 `True` 或 `False`。
- en: Working it out
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正在解决这个问题
- en: In this exercise, the dict is defined once and remains constant throughout the
    life of the program. Sure, we could have used a list of lists, or even a list
    of tuples, but when we have name-value pairs, it’s more natural for us to stick
    them into a dict, then retrieve items from the dict via the keys.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，字典只定义一次，并在整个程序生命周期中保持不变。当然，我们可以使用列表的列表，甚至列表的元组，但当我们有名称-值对时，将其放入字典中，然后通过键从字典中检索项目更为自然。
- en: So, what’s happening in this program? First, we set up our dict (`menu`) with
    its keys and values. We also set up `total` so that we can add to it later on.
    We then ask the user to enter a string. We invoke `strip` on the user’s string
    so that if they enter a bunch of space characters (but nothing else), we’ll treat
    that as an empty string too.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个程序中发生了什么？首先，我们设置字典（`menu`）的键和值。我们还设置了`total`，以便稍后可以添加到它。然后我们要求用户输入一个字符串。我们对用户的字符串调用`strip`，这样如果他们输入了一堆空格字符（但没有其他内容），我们也会将其视为空字符串。
- en: If we get empty input from the user, we break out of the loop. As always, we
    check for an empty string not with an explicit `if` `order` `==` `''`, or even
    checking `len(order)` `==` `0`, but rather with `if` `not` `order`, as per Python’s
    conventions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从用户那里得到空输入，我们就跳出循环。一如既往地，我们不是通过显式的 `if` `order` `==` `''` 或检查 `len(order)`
    `==` `0` 来检查空字符串，而是使用 `if` `not` `order`，按照 Python 的惯例。
- en: But if the user gave us a string, then we’ll look for it in the dict. The `in`
    operator checks if the string exists there; if so, we can retrieve the price and
    add it to `total`. If `order` isn’t empty, but it’s not a key in `menu`, we tell
    the user that the product isn’t in stock.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果用户给了我们一个字符串，我们将在字典中查找它。`in`运算符检查字符串是否存在于其中；如果是，我们可以检索价格并将其添加到`total`。如果`order`不为空，但不是`menu`中的键，我们告诉用户该产品无货。
- en: On the one hand, this use of dicts isn’t very advanced or difficult to understand.
    On the other hand, it allows us to work with our data in a fairly straightforward
    way, taking advantage of the fast search that dicts provide and using the associated
    data within our programs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，这种字典的使用并不复杂或难以理解。另一方面，它允许我们以相当直接的方式处理我们的数据，利用字典提供的快速搜索，并在我们的程序中使用关联数据。
- en: Solution
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Defines a constant dict with item names (strings) and prices (integers)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个包含项目名称（字符串）和价格（整数）的常量字典
- en: ❷ Keeps asking the user for input, until an explicit “break” from the loop
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 不断要求用户输入，直到从循环中显式“break”。
- en: ❸ Gets the user’s input, and uses str.strip to remove leading and trailing whitespace
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取用户的输入，并使用`str.strip`去除前导和尾随空格。
- en: ❹ If “order” is an empty string, break out of the loop.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果“order”是一个空字符串，则跳出循环。
- en: ❺ If “order” is a defined menu item, then get its price and add to total.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果“order”是定义好的菜单项，则获取其价格并添加到总金额中。
- en: ❻ If “order” is neither empty nor in the dict, then we don’t serve this item.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果“order”既不为空也不在字典中，则我们不提供此项目。
- en: You can work through this code in the Python Tutor at [http://mng.bz/jgPV](http://mng.bz/jgPV).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行此代码：[http://mng.bz/jgPV](http://mng.bz/jgPV)。
- en: Screencast solution
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'It might, at first, seem weird to think of a key-value store (like a dict)
    as a database. But it turns out that examples abound of where and how you can
    use such a data structure. Here are some additional practice questions you can
    use to improve your skills in this area:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，将键值存储（如字典）视为数据库可能看起来很奇怪。但事实是，有很多例子说明你可以在哪里以及如何使用这种数据结构。以下是一些额外的练习问题，你可以使用它们来提高你在这一领域的技能：
- en: 'Create a dict in which the keys are usernames and the values are passwords,
    both represented as strings. Create a tiny login system, in which the user must
    enter a username and password. If there is a match, then indicate that the user
    has successfully logged in. If not, then refuse them entry. (Note: This is a nice
    little exercise, but please **never** store unencrypted passwords. It’s a major
    security risk.)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个字典，其中键是用户名，值是密码，两者都表示为字符串。创建一个简单的登录系统，其中用户必须输入用户名和密码。如果匹配，则表示用户已成功登录。如果不匹配，则拒绝他们进入。（注意：这是一个很好的小练习，但请**永远**不要存储未加密的密码。这是一个重大的安全风险。）
- en: Define a dict whose keys are dates (represented by strings) from the most recent
    week and whose values are temperatures. Ask the user to enter a date, and display
    the temperature on that date, as well as the previous and subsequent dates, if
    available.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个字典，其键是最近一周的日期（由字符串表示），其值是温度。要求用户输入一个日期，并显示该日期的温度，以及如果有的话，之前的和之后的日期的温度。
- en: Define a dict whose keys are names of people in your family, and whose values
    are their birth dates, as represented by Python `date` objects ([http://mng.bz/
    jggr](http://mng.bz/jggr)). Ask the user to enter the name of someone in your
    family, and have the program calculate how many days old that person is.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个字典，其键是家庭成员的姓名，其值是他们由Python `date`对象表示的出生日期([http://mng.bz/ jggr](http://mng.bz/jggr))。要求用户输入家庭成员的姓名，并让程序计算这个人有多少天。
- en: Exercise 15 ■ Rainfall
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15 ■ 降雨量
- en: Another use for dicts is to accumulate data over the life of a program. In this
    exercise, you’ll use a dict for just that.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的另一个用途是在程序的生命周期中累积数据。在这个练习中，你将使用字典来完成这个任务。
- en: Specifically, write a function, `get_rainfall`, that tracks rainfall in a number
    of cities. Users of your program will enter the name of a city; if the city name
    is blank, then the function prints a report (which I’ll describe) before exiting.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，编写一个名为`get_rainfall`的函数，用于跟踪多个城市的降雨量。你的程序的用户将输入一个城市的名称；如果城市名称为空，则函数在退出前打印一个报告（我将描述）。
- en: If the city name isn’t blank, then the program should also ask the user how
    much rain has fallen in that city (typically measured in millimeters). After the
    user enters the quantity of rain, the program again asks them for a city name,
    rainfall amount, and so on--until the user presses Enter instead of typing the
    name of a city.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果城市名称不为空，则程序还应询问用户该城市有多少降雨量（通常以毫米为单位）。在用户输入降雨量后，程序再次询问他们城市名称、降雨量等——直到用户按下Enter键而不是输入城市名称。
- en: When the user enters a blank city name, the program exits--but first, it reports
    how much total rainfall there was in each city. Thus, if I enter
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入一个空的城市名称时，程序会退出——但在退出之前，它会报告每个城市有多少总降雨量。因此，如果我输入
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: the program should output
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应该输出
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The order in which the cities appear is not important, and the cities aren’t
    known to the program in advance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 城市出现的顺序并不重要，程序事先并不知道这些城市。
- en: Working it out
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: This program uses dicts in a classic way, as a tiny database of names and values
    that grows over the course of the program. In the case of this program, we use
    the `rainfall` dict to keep track of the cities and the amount of rain that has
    fallen there to date.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序以经典的方式使用字典，作为程序生命周期中逐渐增长的名字和值的小型数据库。在这个程序的情况下，我们使用`rainfall`字典来跟踪城市和迄今为止的降雨量。
- en: We use an infinite loop, which is most easily accomplished in Python with `while`
    `True`. Only when the program encounters `break` will it exit from the loop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个无限循环，这在Python中通过`while True`最易实现。只有当程序遇到`break`时，它才会退出循环。
- en: At the top of each loop, we get the name of the city for which the user is reporting
    rainfall. As we’ve already seen, Python programmers typically don’t check to see
    if a string is empty by checking its length. Rather, they check to see if the
    string contains a `True` or `False` value in a Boolean context. If a string is
    empty, then it will be `False` in the `if` statement. Our statement `if` `not`
    `city_name` means, “If the `city_name` variable contains a `False` value,” or,
    in simpler terms, “if `city_name` is empty.”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个循环的顶部，我们获取用户报告降雨量的城市名称。正如我们已经看到的，Python程序员通常不会通过检查字符串的长度来检查字符串是否为空。相反，他们会在布尔上下文中检查字符串是否包含`True`或`False`值。如果一个字符串为空，那么在`if`语句中它将是`False`。我们的语句`if
    not city_name`意味着，“如果`city_name`变量包含一个`False`值”，或者用更简单的话说，“如果`city_name`为空”。
- en: Let’s walk through the execution of this program with the examples provided
    earlier in this section and see how the program works. When the user is asked
    for input the first time, the user is presented with a prompt (figure 4.1). The
    `rainfall` dict has already been defined, and we’re looking to populate it with
    a key-value pair.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过本节前面提供的示例来逐步执行这个程序，看看程序是如何工作的。当用户被要求输入时，用户会看到一个提示（图4.1）。`rainfall`字典已经定义，我们正在寻找填充一个键值对。
- en: '![](../Images/4-1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1](../Images/4-1.png)'
- en: Figure 4.1 Asking the user for the first input
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 请求用户输入第一个输入
- en: After entering a city name (`Boston`), we enter the amount of rain that fell
    (`5`). Because this is the first time that `Boston` has been listed as a city,
    we add a new key-value pair to `rainfall`. We do this by assigning the key `Boston`
    and the value `5` to our dict (figure 4.2).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入城市名称（`Boston`）后，我们输入降雨量（`5`）。因为这是 `Boston` 首次被列为城市，我们在 `rainfall` 中添加一个新的键值对。我们通过将键
    `Boston` 和值 `5` 赋给我们的字典来完成此操作（图 4.2）。
- en: Notice that this code uses `dict.get` with a default, to either get the current
    value associated with `Boston` (if there is one) or `0` (if there isn’t). The
    first time we ask about a city, there’s no key named `Boston`, and certainly no
    previous rainfall.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码使用 `dict.get` 并带有默认值，以获取与 `Boston` 关联的当前值（如果有的话）或 `0`（如果没有）。当我们第一次询问一个城市时，没有名为
    `Boston` 的键，当然也没有之前的降雨量。
- en: There are two parts to this exercise that often surprise or frustrate new Python
    programmers. The first is that `input` ([http://mng.bz/wB27](http://mng.bz/wB27))
    returns a string. This is fine when the user enters a city but not as good when
    the user enters the amount of rain that fell. Storing the rainfall as a string
    works relatively well when a city is entered only once. However, if a city is
    entered more than once, the program will find itself having to add (with the `+`
    operator) two strings together. Python will happily do this, but the result will
    be a newly concatenated string, rather than the value of the added integers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习有两个部分经常让新的 Python 程序员感到惊讶或沮丧。第一点是 `input` ([http://mng.bz/wB27](http://mng.bz/wB27))
    返回一个字符串。当用户输入城市时这很好，但当用户输入降雨量时就不那么好了。当只输入一次城市时，将降雨量存储为字符串相对有效。然而，如果输入了多次城市，程序将发现自己必须使用
    `+` 运算符将两个字符串相加。Python 会乐意这样做，但结果将是一个新拼接的字符串，而不是相加的整数值。
- en: '![](../Images/4-2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-2.png)'
- en: Figure 4.2 After adding the key-value pair to the dict
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 在字典中添加键值对之后
- en: For this reason, we invoke `int` on `mm_rain`, such that we get an integer.
    If you want, you could replace `int` with `float`, and thus get a floating-point
    value back. Regardless, it’s important that if you use `input` to get input from
    the user, and if you want to use a numeric value rather than a string, you must
    convert it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 `mm_rain` 上调用 `int`，以便得到一个整数。如果你想，你可以用 `float` 替换 `int`，从而得到一个浮点数值。无论如何，如果你使用
    `input` 从用户那里获取输入，并且你想使用数值而不是字符串，你必须进行转换。
- en: Trapping input errors
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获输入错误
- en: My solution deliberately doesn’t check to see if the user’s input can be turned
    into an integer. This means that if the user enters a string containing something
    other than the digits 0-9, the call to `int` will return an error. I didn’t want
    to complicate the solution code too much.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案故意不检查用户的输入是否可以转换为整数。这意味着如果用户输入包含除数字 0-9 以外的字符串，`int` 的调用将返回错误。我不想让解决方案代码过于复杂。
- en: If you do want to trap such errors, then you have two basic options. One is
    to wrap the call to `int` inside of a `try` block. If the call to `int` fails,
    you can catch the exception; for example
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想捕获此类错误，那么你有两种基本选择。一种是将对 `int` 的调用包裹在一个 `try` 块中。如果 `int` 的调用失败，你可以捕获异常；例如
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, we let the user enter whatever they want. If we encounter an error
    (exception) when converting, we send the user back to the start of our `while`
    loop, when we ask for the city name. A slightly more complex implementation would
    have the user simply reenter the value of `mm_rain`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们让用户输入他们想要的任何内容。如果我们转换时遇到错误（异常），我们将用户送回到 `while` 循环的开始，再次要求他们输入城市名称。一个稍微复杂一点的实现会让用户简单地重新输入
    `mm_rain` 的值。
- en: A second solution is to use the `str.isdigit` method, which returns `True` if
    a string contains only the digits 0-9, and `False` otherwise; for example
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是使用 `str.isdigit` 方法，如果字符串只包含数字 0-9，则返回 `True`，否则返回 `False`；例如
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, this would send the user back to the start of the `while` loop,
    asking them to enter the city name once again. It also assumes that we’re only
    interested in getting integer values, because `str.isdigit` returns `False` if
    you give it a floating point number.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这将把用户送回到 `while` 循环的开始，要求他们再次输入城市名称。这也假设我们只对获取整数值感兴趣，因为 `str.isdigit` 如果给的是浮点数，将返回
    `False`。
- en: 'You might have noticed that Python’s strings have three methods with similar
    names: `isdigit`, `isdecimal`, and `isnumeric`. In most cases, the three are interchangeable.
    However, you can learn more about how they’re different at [http://mng.bz/eQDv](http://mng.bz/eQDv).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到Python的字符串有三个具有相似名称的方法：`isdigit`、`isdecimal`和`isnumeric`。在大多数情况下，这三个方法是可互换的。然而，你可以在[http://mng.bz/eQDv](http://mng.bz/eQDv)了解更多它们之间的区别。
- en: The second tricky part of this exercise is that you must handle the first time
    a city is named (i.e., before the city’s name is a key in `rainfall`), as well
    as subsequent times.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的第二个难点是，你必须处理第一次提到一个城市的情况（即，在城市的名称成为`rainfall`中的键之前），以及随后的时间。
- en: The first time that someone enters `Boston` as a city name, we’ll need to add
    the key-value pair for that city and its rainfall into our dict. The second time
    that someone enters `Boston` as a city name, we need to add the new value to the
    existing one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次有人将`Boston`作为一个城市名称输入时，我们需要将该城市及其降雨量作为一个键值对添加到我们的字典中。第二次有人将`Boston`作为一个城市名称输入时，我们需要将新的值添加到现有的值上。
- en: One simple solution to this problem is to use the `dict.get` method with two
    arguments. With one argument, `dict.get` either returns the value associated with
    the named key or `None`. But with two arguments, `dict.get` returns either the
    value associated with the key or the second argument (figure 4.3).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法之一是使用带有两个参数的`dict.get`方法。使用一个参数时，`dict.get`要么返回与指定键关联的值，要么返回`None`。但是，使用两个参数时，`dict.get`要么返回与键关联的值，要么返回第二个参数（图4.3）。
- en: '![](../Images/4-3.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-3.png)'
- en: Figure 4.3 Adding to an existing name-value pair
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 向现有的名称-值对添加内容
- en: Thus, when we call `rainfall.get(city_name,` `0)`, Python checks to see if `city_name`
    already exists as a key in `rainfall`. If so, then the call to `rainfall.get`
    will return the value associated with that key. If `city_name` is not in `rainfall`,
    we get `0` back.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们调用`rainfall.get(city_name, 0)`时，Python会检查`city_name`是否已经作为键存在于`rainfall`中。如果是这样，那么对`rainfall.get`的调用将返回与该键关联的值。如果`city_name`不在`rainfall`中，我们将得到`0`。
- en: An alternative solution would use the `defaultdict` ([http://mng.bz/pBy8](http://mng.bz/pBy8)),
    a class defined in the `collections` ([http://mng.bz/6Qwy](http://mng.bz/6Qwy))
    module that allows you to define a dict that works just like a regular one--until
    you ask it for a key that doesn’t exist. In such cases, `defaultdict` invokes
    the function with which it was defined; for example
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案会使用`defaultdict`（[http://mng.bz/pBy8](http://mng.bz/pBy8)），这是一个在`collections`（[http://mng.bz/6Qwy](http://mng.bz/6Qwy)）模块中定义的类，它允许你定义一个字典，它的工作方式就像一个常规字典一样--直到你要求它获取一个不存在的键。在这种情况下，`defaultdict`将调用与它定义的函数；例如
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ defaultdict(int) means that if we say rainfall[k] and k isn’t in rainfall,
    the int function will execute without any arguments, giving us the int 0 back.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `defaultdict(int)`意味着如果我们说`rainfall[k]`而`k`不在`rainfall`中，int函数将无参数执行，返回int
    0。
- en: Solution
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ We don’t know what cities the user will enter, so we create an empty dict,
    ready to be filled.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们不知道用户会输入哪些城市，因此我们创建了一个空的字典，准备填充。
- en: ❷ If you’re from the United States, then you might be surprised to hear that
    other countries measure rainfall in millimeters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果你来自美国，那么你可能会惊讶地听到其他国家用毫米来测量降雨量。
- en: ❸ The first time we encounter a city, we’ll add 0 to its current rainfall. Any
    subsequent time, we’ll add the current rainfall to the previously stored rainfall.
    dict.get makes this possible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第一次遇到一个城市时，我们将0添加到其当前的降雨量。任何随后的时间，我们将当前的降雨量添加到之前存储的降雨量。`dict.get`方法使得这一点成为可能。
- en: You can work through this code in the Python Tutor at [http://mng.bz/WPzd](http://mng.bz/WPzd).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行这段代码：[http://mng.bz/WPzd](http://mng.bz/WPzd)。
- en: Screencast solution
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'It’s pretty standard to use dicts to keep track of accumulated values (such
    as the number of times something has happened, or amounts of money) associated
    with arbitrary values. The keys can represent what you’re tracking, and the values
    can track data having to do with the key. Here are some additional things you
    can do:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典来跟踪与任意值关联的累积值（例如，某事发生的次数或金钱的数量）是非常标准的。键可以代表你正在跟踪的内容，值可以跟踪与键有关的数据。以下是一些你可以做的额外事情：
- en: Instead of printing just the total rainfall for each city, print the total rainfall
    and the average rainfall for reported days. Thus, if you were to enter 30, 20,
    and 40 for Boston, you would see that the total was 90 and the average was 30.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是只打印每个城市的总降雨量，打印总降雨量和报告天数内的平均降雨量。因此，如果你为波士顿输入30、20和40，你会看到总降雨量为90，平均降雨量为30。
- en: Open a log file from a Unix/Linux system--for example, one from the Apache server.
    For each response code (i.e., three-digit code indicating the HTTP request’s success
    or failure), store a list of IP addresses that generated that code.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开Unix/Linux系统的一个日志文件——例如，Apache服务器的一个日志文件。对于每个响应代码（即表示HTTP请求成功或失败的三个数字代码），存储生成该代码的IP地址列表。
- en: Read through a text file on disk. Use a dict to track how many words of each
    length are in the file--that is, how many three-letter words, four-letter words,
    five-letter words, and so on. Display your results.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取磁盘上的文本文件。使用字典来跟踪文件中每种长度的单词数量——也就是说，有多少个三字母单词、四字母单词、五字母单词等等。显示你的结果。
- en: Exercise 16 ■ Dictdiff
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16 ■ Dictdiff
- en: Knowing how to work with dicts is crucial to your Python career. Moreover, once
    your learn how to use `dict.get` effectively, you’ll find that your code is shorter,
    more elegant, and more maintainable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何处理字典对于你的Python职业生涯至关重要。此外，一旦你学会了如何有效地使用`dict.get`，你会发现你的代码更短、更优雅、更易于维护。
- en: Write a function, `dictdiff`, that takes two dicts as arguments. The function
    returns a new dict that expresses the difference between the two dicts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数`dictdiff`，该函数接受两个字典作为参数。该函数返回一个新的字典，表示两个字典之间的差异。
- en: 'If there are no differences between the dicts, `dictdiff` returns an empty
    dict. For each key-value pair that differs, the return value of `dictdiff` will
    have a key-value pair in which the value is a list containing the values from
    the two different dicts. If one of the dicts doesn’t contain that key, it should
    contain `None`. The following provides some examples:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字典之间没有差异，`dictdiff`将返回一个空字典。对于每个不同的键值对，`dictdiff`的返回值将包含一个键值对，其值是一个包含来自两个不同字典的值的列表。如果一个字典不包含该键，则它应该包含`None`。以下提供了一些示例：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Prints “{}”, because we’re comparing d1 with itself
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印“{}”，因为我们正在比较d1与自身
- en: '❷ Prints “{''c'': [3, 4]}”, because d1 contains c:3 and d2 contains c:4'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ 打印“{''c'': [3, 4]}”，因为d1包含c:3而d2包含c:4'
- en: '❸ Prints “{''c'': [None, 4], ''d'': [3, None]}”, because d4 has c:4 and d3
    has d:3'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ 打印“{''c'': [None, 4], ''d'': [3, None]}”，因为d4有c:4而d3有d:3'
- en: '❹ Prints “{''c'': [3, None], ''d'': [None, 4]}”, because d1 has c:3 and d5
    has d:4'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ 打印“{''c'': [3, None], ''d'': [None, 4]}”，因为d1有c:3而d5有d:4'
- en: Working it out
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Let’s start by thinking about the overall design of this program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑这个程序的整体设计：
- en: We create an empty `output` dict.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个空的`output`字典。
- en: We go through each of the keys in `first` and `second`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们遍历`first`和`second`中的每个键。
- en: For each key, we check if the key also exists in the other dict.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个键，我们检查该键是否也存在于另一个字典中。
- en: If the key exists in both, then we check if the values are the same.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键在两个字典中都存在，那么我们检查值是否相同。
- en: If the values are the same, then we do nothing to `output`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值相同，那么我们对`output`不做任何操作。
- en: If the values are different, then we add a key-value pair to `output`, with
    the currently examined key and a list of the values from `first` and `second`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值不同，那么我们将一个键值对添加到`output`中，其中包含当前检查的键和来自`first`和`second`的值列表。
- en: If the key doesn’t exist in one dict, then we use `None` as the value.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键在一个字典中不存在，那么我们使用`None`作为值。
- en: 'This all sounds good, but there’s a problem with this approach: it means that
    we’re going through each of the keys in `first` and then each of the keys in `second`.
    Given that at least some keys will hopefully overlap, this sounds like an inefficient
    approach. It would be better and smarter for us to collect all of the keys from
    `first` and `second`, put them into a set (thus ensuring that each appears only
    once), and then iterate over them.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很好，但这种方法有一个问题：这意味着我们正在遍历`first`中的每个键，然后遍历`second`中的每个键。鉴于至少一些键可能会重叠，这听起来像是一个低效的方法。对我们来说，最好和最聪明的方法是收集`first`和`second`中的所有键，将它们放入一个集合中（从而确保每个键只出现一次），然后遍历它们。
- en: 'It turns out that `dict.keys()` returns a special object of type `dict_keys`.
    But that object implements several of the same methods available on sets, including
    `|` (union) and `&` (intersection)! The result is a set containing the unique
    keys from both dicts together:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明 `dict.keys()` 返回一个特殊的 `dict_keys` 类型的对象。但该对象实现了与集合上相同的几个方法，包括 `|`（并集）和
    `&`（交集）！结果是包含两个字典中所有唯一键的集合：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Note* In Python 2, `dict.keys` and many similar methods returned lists, which
    support the `+` operator. In Python 3, almost all such methods were modified to
    return iterators. When the returned result is small, there’s almost no difference
    between the implementations. But when the returned result is large, there’s a
    big difference, and most prefer to use an iterator. Thus, the behavior in Python
    3 is preferable, even if it’s a bit surprising for people moving from Python 2.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在 Python 2 中，`dict.keys` 和许多类似的方法返回列表，支持 `+` 操作符。在 Python 3 中，几乎所有这样的方法都被修改为返回迭代器。当返回的结果很小的时候，实现之间几乎没有什么区别。但是当返回的结果很大时，差别就很大了，大多数人更喜欢使用迭代器。因此，Python
    3 的行为更可取，即使对于从 Python 2 转移过来的人来说有点令人惊讶。'
- en: Because a set is effectively a dict without values, we know for sure that by
    putting these lists into our `all_keys` set, we’ll only pass through each key
    once. Rather than checking whether a key exists in each dict, and then retrieving
    its value, and then checking whether the values are the same, I used the `dict.get`
    ([http://mng.bz/4AeV](http://mng.bz/4AeV)) method. This saves us from getting
    a `KeyError` exception. Moreover, if one of the dicts lacks the key in question,
    we get `None` back. We can use that not only to check whether the dicts are the
    same, but also to retrieve the values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因为集合实际上是一个没有值的字典，所以我们确信，通过将这些列表放入我们的 `all_keys` 集合中，我们只会遍历每个键一次。而不是检查每个字典中是否存在键，然后检索其值，然后检查值是否相同，我使用了
    `dict.get` ([http://mng.bz/4AeV](http://mng.bz/4AeV)) 方法。这使我们免于得到 `KeyError` 异常。此外，如果一个字典缺少相关的键，我们会得到
    `None`。我们可以利用这一点不仅来检查字典是否相同，还可以检索值。
- en: 'Now let’s walk through each of the examples I gave as part of the problem description
    and see what happens:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一分析我在问题描述中给出的每个例子，看看会发生什么：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We see this example in figure 4.4\. In this figure, we see that the local variables
    `first` and `second` both point to the same dict, `d1`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图 4.4 中看到了这个例子。在这个图中，我们可以看到局部变量 `first` 和 `second` 都指向同一个字典，`d1`。
- en: '![](../Images/4-4.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-4.png)'
- en: Figure 4.4 Taking the diff of `d1` and itself
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 比较 `d1` 和自身的差异
- en: When we iterate over the combined set of keys (figure 4.5), we’re actually iterating
    over the keys of `d1`. Because we never find any differences, the return value
    (`output`) is `{}`, the empty dict.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历键的合并集合（图 4.5）时，我们实际上是在遍历 `d1` 的键。因为我们从未找到任何差异，所以返回值（`output`）是 `{}`，一个空字典。
- en: '![](../Images/4-5.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-5.png)'
- en: Figure 4.5 Iterating over the keys of `d1`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 遍历 `d1` 的键
- en: When we compare `d1` and `d2`, we see that `first` and `second` point to two
    different dicts (figure 4.6). They also have the same keys, but different values
    for the `c` key. We can see in figure 4.7 how our `output` dict gets a new key-value
    pair, representing the `c` key’s different values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较 `d1` 和 `d2` 时，我们看到 `first` 和 `second` 指向两个不同的字典（图 4.6）。它们也有相同的键，但对于 `c`
    键有不同的值。我们可以在图 4.7 中看到我们的 `output` 字典如何获得一个新的键值对，代表 `c` 键的不同值。
- en: '![](../Images/4-6.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-6.png)'
- en: Figure 4.6 Comparing `d1` and `d2`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 比较 `d1` 和 `d2`
- en: '![](../Images/4-7.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-7.png)'
- en: Figure 4.7 Adding a value to `output`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 向 `output` 添加值
- en: When we compare `d3` and `d4`, we can see how things get more complex. Our `output`
    dict will now have two key-value pairs, and each value will be (as specified)
    a list. In this way, you can see how we build our dict from nothing to become
    a report describing the differences between the two arguments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较 `d3` 和 `d4` 时，我们可以看到事情变得更加复杂。我们的 `output` 字典现在将有两个键值对，每个值都将是一个列表。这样，你可以看到我们如何从无到有构建我们的字典，成为描述两个参数之间差异的报告。
- en: Solution
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Gets all keys from both first and second, without repeats
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从第一个和第二个中获取所有键，不重复
- en: ❷ Takes advantage of the fact that dict.get returns None when a key doesn’t
    exist
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 利用字典的 get 方法在键不存在时返回 None 的特性
- en: You can work through this code in the Python Tutor at [http://mng.bz/8prW](http://mng.bz/8prW).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行这段代码，链接为 [http://mng.bz/8prW](http://mng.bz/8prW)。
- en: Screencast solution
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'Python functions can return any object they like, and that includes dicts.
    It’s often useful to write a function that creates a dict; the function can combine
    or summarize other dicts (as in this exercise), or it can turn other objects into
    dicts. Here are some ideas that you can pursue:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数可以返回它们喜欢的任何对象，这包括字典。编写一个创建字典的函数通常很有用；该函数可以组合或总结其他字典（如本练习所示），或者可以将其他对象转换为字典。以下是一些你可以追求的想法：
- en: The `dict.update` method merges two dicts. Write a function that takes any number
    of dicts and returns a dict that reflects the combination of all of them. If the
    same key appears in more than one dict, then the most recently merged dict’s value
    should appear in the output.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict.update` 方法合并两个字典。编写一个函数，它接受任意数量的字典，并返回一个反映所有这些字典组合的字典。如果同一个键出现在多个字典中，则输出中应显示最近合并的字典的值。'
- en: Write a function that takes any even number of arguments and returns a dict
    based on them. The even-indexed arguments become the dict keys, while the odd-numbered
    arguments become the dict values. Thus, calling the function with the arguments
    ('a', 1, 'b', 2) will result in the dict {'a':1, 'b':2} being returned.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，它接受任意数量的偶数个参数，并根据它们返回一个字典。偶数索引的参数成为字典键，而奇数索引的参数成为字典值。因此，使用 ('a', 1, 'b',
    2) 作为参数调用该函数将返回字典 {'a':1, 'b':2}。
- en: Write a function , `dict_partition`, that takes one dict (`d`) and a function
    (`f`) as arguments. `dict_partition` will return two dicts, each containing key-value
    pairs from `d`. The decision regarding where to put each of the key-value pairs
    will be made according to the output from `f`, which will be run on each key-value
    pair in `d`. If `f` returns `True`, then the key-value pair will be put in the
    first output dict. If `f` returns `False`, then the key-value pair will be put
    in the second output dict.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数 `dict_partition`，它接受一个字典 (`d`) 和一个函数 (`f`) 作为参数。`dict_partition` 将返回两个字典，每个字典都包含来自
    `d` 的键值对。关于将每个键值对放在哪里，将根据 `f` 的输出做出决定，`f` 将在 `d` 中的每个键值对上运行。如果 `f` 返回 `True`，则键值对将放入第一个输出字典中。如果
    `f` 返回 `False`，则键值对将放入第二个输出字典中。
- en: Exercise 17 ■ How many different numbers?
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 17 ■ 有多少个不同的数字？
- en: In my consulting work, I’m sometimes interested in finding error messages, IP
    addresses, or usernames in a log file. But if a message, address, or username
    appears twice, then there’s no added benefit. I’d thus like to ensure that I’m
    looking at each value once and only once, without the possibility of repeats.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的咨询工作中，我有时对在日志文件中查找错误消息、IP 地址或用户名感兴趣。但如果消息、地址或用户名出现两次，那么就没有额外的收益。因此，我想确保我只查看每个值一次，而且没有重复的可能性。
- en: 'In this exercise, you can assume that your Python program contains a list of
    integers. We want to print the number of different integers contained within that
    list. Thus, consider the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你可以假设你的 Python 程序包含一个整数列表。我们想打印列表中包含的不同整数的数量。因此，考虑以下：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the definition provided, running `len(numbers)` will return `7`, because
    the list contains seven elements. How can we get a result of `4`, reflecting the
    fact that the list contains four different values? Write a function, called `how_many_different_numbers`,
    that takes a single list of integers and returns the number of different integers
    it contains.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的定义，运行 `len(numbers)` 将返回 `7`，因为列表包含七个元素。我们如何得到 `4` 的结果，反映列表包含四个不同值的事实？编写一个名为
    `how_many_different_numbers` 的函数，它接受一个整数列表，并返回其中包含的不同整数的数量。
- en: Working it out
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: A set, by definition, contains unique elements--just as a dict’s keys are guaranteed
    to be unique. Thus, if you ever have a list of values from which you want to remove
    all of the duplicates, you can just create a set. You can create the set as in
    the solution code
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，一个集合包含唯一的元素——就像字典的键保证是唯一的。因此，如果你有一个值列表，你想从中删除所有重复项，你只需创建一个集合。你可以像解决方案代码中那样创建集合。
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'or you can do so by creating an empty set, and then adding new elements to
    it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过创建一个空集合，然后向其中添加新元素来实现：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This example uses `set.add`, which adds one new element to a set. You can add
    items en masse with `set.update`, which takes an iterable as an argument:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 `set.add`，它向集合中添加一个新元素。你可以使用 `set.update` 批量添加项目，它接受一个可迭代对象作为参数：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ You can only use set.update with an iterable. Think of it as shorthand for
    running a for loop on each of the elements of numbers, invoking set.add on the
    current iteration’s item.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你只能使用`set.update`与一个可迭代对象。把它想象成对`numbers`中的每个元素运行一个for循环，并在当前迭代的项上调用`set.add`。
- en: 'Finally, you might be tempted to use the curly-brace syntax for sets:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想尝试使用集合的大括号语法：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Doesn’t work!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不起作用！
- en: This code won’t work, because Python thinks you want to add the list `numbers`
    to the set as a single element. And just as lists can’t be dict keys, they also
    can’t be elements in a set.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不会工作，因为Python认为你想要将列表`numbers`作为一个单独的元素添加到集合中。正如列表不能作为字典的键一样，它们也不能作为集合的元素。
- en: 'But of course, we don’t want to add `numbers`. Rather, we want to add the elements
    from within `numbers`. Here we can use the `*` (splat) operator, but in a slightly
    different way than we’ve seen before:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想添加`numbers`。相反，我们想要添加`numbers`内部的元素。在这里，我们可以使用`*`（展开）操作符，但与之前看到的方式略有不同：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This tells Python that it should take the elements of `numbers` and feed them
    (in a sort of `for` loop) to the curly braces. And indeed, this works just fine.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Python应该取`numbers`的元素并将它们（以一种`for`循环的方式）喂给大括号。确实，这可以正常工作。
- en: Is it better to use `set` without the `*`, or `{}` with the `*`? That’s a judgment
    call. I’m partial to the curly braces and `*`, but I also understand that `*`
    can be confusing to many people and might make your code less readable/maintainable
    to newcomers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不带`*`的`set`，还是带`*`的大括号`{}`？这是一个判断问题。我偏爱大括号和`*`，但我也理解`*`可能会让很多人感到困惑，并可能使新手的代码可读性/可维护性降低。
- en: Solution
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Invokes set on numbers, thus returning a set with the unique elements from
    numbers
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对`numbers`调用`set`，从而返回一个包含`numbers`中唯一元素的集合
- en: You can work through this code in the Python Tutor at [http://mng.bz/EdQD](http://mng.bz/EdQD).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行这段代码：[http://mng.bz/EdQD](http://mng.bz/EdQD)。
- en: Screencast solution
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: Whenever I hear the word *unique* or *different* in a project’s specification,
    I think of sets, because they automatically enforce uniqueness and work with a
    sequence of values. So if you have a sequence of usernames, dates, IP addresses,
    e-mail addresses, or products and want to reduce that to a sequence containing
    the same data, but with each item appearing only once, then sets can be extremely
    useful.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我听到项目规范中的“唯一”或“不同”这个词时，我会想到集合，因为它们自动强制唯一性并处理一系列值。所以如果你有一系列用户名、日期、IP地址、电子邮件地址或产品，并且想要将它们减少到一个包含相同数据但每个项目只出现一次的序列，那么集合可以非常有用。
- en: 'Here are some things you can try to work with sets even more:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以尝试的方法来更好地处理集合：
- en: Read through a server (e.g., Apache or nginx) log file. What were the different
    IP addresses that tried to access your server?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取服务器（例如Apache或nginx）的日志文件。尝试访问你的服务器的不同IP地址有哪些？
- en: Reading from that same server log, what response codes were returned to users?
    The 200 code represents “OK,” but there are also 403, 404, and 500 errors. (Regular
    expressions aren’t required here but will probably help.)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从同一个服务器日志中读取，返回给用户的响应代码有哪些？200代码表示“OK”，但也有403、404和500错误。（这里不需要正则表达式，但可能有所帮助。）
- en: Use `os.listdir` ([http://mng.bz/YreB](http://mng.bz/YreB)) to get the names
    of files in the current directory. What file extensions (i.e., suffixes following
    the final `.` character) appear in that directory? It’ll probably be helpful to
    use `os.path.splitext` ([http://mng.bz/GV4v](http://mng.bz/GV4v)).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.listdir` ([http://mng.bz/YreB](http://mng.bz/YreB)))来获取当前目录中的文件名。该目录中出现了哪些文件扩展名（即跟随最后一个`.`字符的后缀）？使用`os.path.splitext`
    ([http://mng.bz/GV4v](http://mng.bz/GV4v)))可能会有所帮助。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Dicts are, without a doubt, the most versatile and important data structure
    in the Python world. Learning to use them effectively and efficiently is a crucial
    part of becoming a fluent developer. In this chapter, we practiced several ways
    to use them, including tracking counts of elements and storing data we got from
    the user. We also saw that you can use `dict.get` to retrieve from a dict without
    having to fear that the key doesn’t exist.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，字典是 Python 世界中最灵活和最重要的数据结构。学会有效地和高效地使用它们是成为一名熟练的开发者的关键部分。在本章中，我们练习了多种使用字典的方法，包括跟踪元素的数量和存储从用户那里获取的数据。我们还看到，你可以使用
    `dict.get` 来从字典中检索，而无需担心键不存在。
- en: When working with dicts, remember
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当与字典一起工作时，请记住
- en: The keys must be hashable, such as a number or string.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键必须是可哈希的，例如数字或字符串。
- en: The values can be anything at all, including another dict.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值可以是任何东西，包括另一个字典。
- en: The keys are unique.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键是唯一的。
- en: You can iterate over the keys in a `for` loop or comprehension.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `for` 循环或推导式遍历字典中的键。
