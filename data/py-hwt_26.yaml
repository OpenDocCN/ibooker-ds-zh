- en: Appendix F. solutions to the challenges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录F.挑战的解决方案
- en: Chapter 1
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章
- en: No challenges to get started with Python. You *win!*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有挑战开始使用Python。你 *赢了*！
- en: Chapter 2
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第2章
- en: Section 2.1
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.1节
- en: 'We start with the following dict object:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下字典对象开始：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Following is the solution for producing the desired output:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为产生所需输出提供的解决方案：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Normally, we use curly braces to interpolate variables, so to make them mean
    the brace symbols themselves instead of interpolations, you need to use {{ to
    mean the brace symbol itself. Thus, {{{var_name} is interpreted as one left curly
    brace plus an interpolated string from var_name.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用花括号来插值变量，因此要使它们表示花括号符号本身而不是插值，你需要使用 {{ 来表示花括号符号本身。因此，{{{var_name} 被解释为一个左花括号加上来自
    var_name 的插值字符串。
- en: Section 2.2
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.2节
- en: 'When we use the input function to collect users’ input, we’re getting strings.
    When we expect numeric values, we need to convert them to a corresponding numeric
    value. We can have the following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 input 函数收集用户输入时，我们得到的是字符串。当我们期望数值时，我们需要将它们转换为相应的数值。我们可以有以下代码：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Converts a string to a floating-point number
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将字符串转换为浮点数
- en: ❷ .1f is the floating-point format specifier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ .1f 是浮点格式说明符。
- en: 'If you look at how x_output is created multiple times, you may notice a pattern
    of repetition: the only difference is the adjective that describes weather. Thus,
    a better solution is'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次查看x_output的创建方式，你可能注意到一个重复的模式：唯一的不同之处在于描述天气的形容词。因此，更好的解决方案是
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Section 2.3
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.3节
- en: 'The argument maxsplit specifies the maximal number of splits when you use split
    or rsplit. When you ignore this argument, both methods will use all occurrences
    of the separator. Alternatively, if you set this argument that is greater than
    the number of occurrences, you expect the same result for both methods as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 maxsplit 指定当你使用 split 或 rsplit 时最大分割次数。当你忽略此参数时，两种方法都将使用分隔符的所有出现。或者，如果你设置此参数大于出现次数，你期望两种方法的结果相同，如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you use a number that is smaller than the maximally available splits, however,
    you expect split and rsplit to produce different results:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用一个小于最大可用分割次数的数字，你期望 split 和 rsplit 产生不同的结果：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Section 2.4
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.4节
- en: 'Suppose that you want to split the following string:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要拆分以下字符串：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the separators are a variable mixture of _ and ,. To split
    such string data, we can use the following pattern: [,_]+, which means that there
    can be multiple matching occurrences of _ or , in the string. Applying this pattern,
    we can create the desired split:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，分隔符是 _ 和 , 的可变混合。为了拆分此类字符串数据，我们可以使用以下模式：[,_]+，这意味着字符串中可以有多个匹配的 _ 或 , 出现。应用此模式，我们可以创建所需的拆分：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Uses the raw string for pattern creation
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用原始字符串进行模式创建
- en: Section 2.5
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第2.5节
- en: 'When we process multiline text, we can use \n to identify the end of a line.
    Thus, to extract the needed records without splitting the lines, we can try the
    following pattern by specifying that the record ends with a newline character:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理多行文本时，我们可以使用 \n 来标识行的结束。因此，为了在不拆分行的情况下提取所需的记录，我们可以尝试以下模式，指定记录以换行符结束：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Everything appears to work, but there is one exception: we also include the
    incorrect record (''234'', ''random'', ''record''). If we compare this record
    with our pattern, matching it isn’t a surprise because we don’t have any restriction
    in terms of what precedes the three-digit identifier. Following is a more accurate
    way to build the pattern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎一切正常，但有一个例外：我们还包含了错误的记录 ('234', 'random', 'record')。如果我们将此记录与我们的模式进行比较，匹配它并不令人惊讶，因为我们对三位标识符之前的内容没有任何限制。以下是一个更精确的构建模式的方法：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The part (?<!\d) is known as the *negative look-behind assertion**,* which means
    that it matches text that has a three-digit number only if it’s *not* preceded
    by any number. Please note that this example shows advanced use of regular expressions.
    You can find more information on the official Python website at [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 部分模式 (?<!\d) 被称为 *负向后视断言**，这意味着它只匹配没有数字在其前面的三位数字文本。请注意，此示例展示了正则表达式的高级用法。你可以在官方Python网站上找到更多信息：[https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html)。
- en: Chapter 3
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章
- en: Section 3.1
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第3.1节
- en: When you need to hold a series of places, such as a person’s trip history, you
    want to use list as the data model because you expect that users may change the
    places they’ve visited (to add new ones, for example).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要保存一系列位置，例如一个人的旅行历史时，您希望使用列表作为数据模型，因为您预计用户可能会更改他们访问过的地方（例如添加新的地方）。
- en: 'A place has a specific coordinate, and you don’t expect it to change. Thus,
    you want to use tuple to hold the coordinate data:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个位置有一个特定的坐标，您不希望它改变。因此，您希望使用元组来保存坐标数据：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Section 3.2
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第3.2节
- en: 'Following is the list that we want to sort based on the length of the descriptions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们想要根据描述长度进行排序的列表：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We know that we need to set a function to the key argument, and the function
    should calculate the length of a task’s description as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要将一个函数设置到关键字参数中，并且该函数应该按照以下方式计算任务描述的长度：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We define the function using_by_desc_len, which returns the task’s description
    length. As a reminder, this function will serve as the key argument, which must
    take exactly one argument. It’s necessary to set the reverse argument to True,
    as the challenge requires the task to have a higher rank if its description is
    longer. If you already know lambda functions (section 7.1), you can use the following
    code to sort:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为using_by_desc_len的函数，该函数返回任务的描述长度。作为提醒，此函数将作为键参数，它必须接受恰好一个参数。由于挑战要求如果描述更长，则任务具有更高的排名，因此必须将reverse参数设置为True。如果您已经了解lambda函数（第7.1节），则可以使用以下代码进行排序：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Section 3.3
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第3.3节
- en: 'Because a named tuple is a tuple object, we can’t change it due to its immutability.
    If we insist, we’ll encounter an AttributeError:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命名元组是一个元组对象，我们不能更改它，因为它是不可变的。如果我们坚持这样做，我们将遇到AttributeError：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But named tuples provide a workaround in the form of the _replace method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但命名元组提供了一种名为_replace方法的解决方案：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Please note that this method creates a new tuple object that has the changed
    value instead of making an in-place change of the original object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此方法创建了一个新的元组对象，它具有更改后的值，而不是对原始对象进行原地更改。
- en: Section 3.4
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第3.4节
- en: 'Suppose that we have the dict object numbers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为numbers的字典对象：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Expect a different value on your computer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在您的计算机上预期不同的值。
- en: 'In this code snippet, we also obtain the keys by using the keys method, which
    is a dictionary view object. The built-in id function can get the memory address
    of this view object. We’ll change the dict object by adding a new key-value pair:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们通过使用keys方法获取键，该方法是一个字典视图对象。内置的id函数可以获取此视图对象的内存地址。我们将通过添加新的键值对来更改字典对象：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After this change, we see that the keys are updated automatically in the numbers_key
    object and that the memory address stays the same because the update manipulates
    the same object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之后，我们可以看到keys在numbers_key对象中自动更新，并且内存地址保持不变，因为更新操作是针对同一个对象的：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Section 3.5
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第3.5节
- en: 'The keys in a dict object must be hashable because the hash values will be
    used by the underlying hash table as the storage mechanism. When you have keys
    that have the same hash values, the *last-seen rule applies:* the value associated
    with the key that is set later becomes the value for the key. In our case, an
    integer of 1 and a floating-point number of 1.0 have the same hash value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 字典对象中的键必须是可哈希的，因为哈希值将被底层哈希表用作存储机制。当您有具有相同哈希值的键时，将应用*最近查看规则*：稍后设置的键的值成为该键的值。在我们的例子中，整数1和浮点数1.0具有相同的哈希值：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Thus, under the last-seen rule, we should expect the value associated with
    1.0 to become the key’s value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据最近查看规则，我们应该期望与1.0关联的值成为键的值：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Section 3.6
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第3.6节
- en: 'As indicated in the hint, these evaluations are known as *short-circuit evaluations**.*
    When Python tries to evaluate expr_a or expr_b, if it finds the first expression
    to be True, it uses the first object; otherwise, it uses the second expression.
    Some examples support this rule:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如提示所示，这些评估被称为*短路评估**。当Python尝试评估expr_a或expr_b时，如果它发现第一个表达式为True，则使用第一个对象；否则，它使用第二个表达式。一些例子支持这个规则：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When Python tries to evaluate expr_a and expr_b, if it finds the first expression
    to be False, it uses the first object; otherwise, it uses the second expression.
    Some examples support this rule:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python尝试评估expr_a和expr_b时，如果它发现第一个表达式为False，则使用第一个对象；否则，它使用第二个表达式。一些例子支持这个规则：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This rule may be trickier to remember than the or operations. Here’s a hint:
    because they’re short-circuit evaluations for and operations, they’re evaluated
    to be True only if both are True. Thus, if Python finds the first expression to
    be False, the evaluation is done; the result must be False. For this reason, Python
    uses the first expression.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则可能比或操作更难记住。这里有一个提示：因为它们是and操作的短路评估，所以只有当两者都为True时才被评估为True。因此，如果Python发现第一个表达式为False，则执行评估；结果必须是False。因此，Python使用第一个表达式。
- en: Chapter 4
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章
- en: Section 4.1
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.1节
- en: 'When you create a subsequence from a slice, it should be exactly like the original
    sequence. A few examples follow:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个切片创建子序列时，它应该与原始序列完全相同。以下是一些示例：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can do the same slicing with a range object. As you might expect, the subsequence
    is also a range object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用range对象进行相同的切片操作。正如你所期望的，子序列也是一个range对象：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Section 4.2
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.2节
- en: 'We need to obtain sales for November. Following is the entire year’s data:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要获取11月的销售额。以下是整年的数据：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As discussed in the section, we can obtain this data point with revenue_by_month[-2]
    using the negative index. If we want to use a positive index, we can obtain it
    by calculating the length:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如同该节所述，我们可以使用revenue_by_month[-2]通过负索引来获取这个数据点。如果我们想使用正索引，我们可以通过计算长度来获取它：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Section 4.3
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3节
- en: 'If you run the following code snippet, you’ll encounter a ValueError:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行以下代码片段，你会遇到ValueError：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The reason for this error is that although task_to_search appears to have the
    same attributes for the third item in the tasks list, the instance objects of
    a custom class aren’t comparable out of the box. Built-in data, such as strings,
    is comparable, so you can use the index method to locate the item. To make the
    comparison work, you must override the __eq__ special method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误的原因是，尽管task_to_search看起来在tasks列表的第三项具有相同的属性，但自定义类的实例对象默认是不可比较的。内置数据，如字符串，是可比较的，因此你可以使用索引方法来定位项目。为了使比较工作，你必须重写__eq__特殊方法：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note that you’ll learn about defining custom classes in chapter 8.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你将在第8章学习如何定义自定义类。
- en: Section 4.4
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.4节
- en: 'When you unpack a list object with embedded structures, you can unpack the
    inner ones as though they stand alone. The following code shows how:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你解包一个包含嵌套结构的列表对象时，你可以像它们独立存在一样解包内部结构。以下代码展示了如何操作：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Section 4.5
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.5节
- en: 'If you multiply the nested list object by 3 directly, you’re repeating the
    elements three times:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接将嵌套列表对象乘以3，你将重复元素三次：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The desired output, however, multiplies each element by 3\. With this kind
    of data, you must use for loops:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所需的输出是将每个元素乘以3。对于这种类型的数据，你必须使用for循环：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The embedded for loops are not easy to read. A better solution is to use list
    comprehension, as discussed in section 5.2:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的for循环不易阅读。一个更好的解决方案是使用列表推导，如第5.2节所述：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notably, if your application involves lots of numeric computation, data structures
    such as array in the NumPy library (see the package-installation instructions
    in appendix B online) are better options. You can find a cleaner solution by using
    the NumPy library as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你的应用程序涉及大量的数值计算，那么NumPy库中的数组等数据结构（参见附录B中的包安装说明）是更好的选择。你可以通过以下方式使用NumPy库找到更简洁的解决方案：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As shown in this code snippet, multiplication with a NumPy array is like other
    algebraic operations that you normally do with numbers. Isn’t this approach much
    more convenient?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，与NumPy数组相乘的操作类似于你通常用数字进行的其他代数运算。这种做法不是更方便吗？
- en: Chapter 5
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第5章
- en: Section 5.1
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第5.1节
- en: 'To join three or even more iterables, we list them sequentially. Each item
    of the zip iterator consists of one member from each iterable, forming a tuple
    object, as in this example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接三个或更多可迭代对象，我们按顺序列出它们。zip迭代器的每个项目都包含来自每个可迭代对象的一个成员，形成一个元组对象，如下例所示：
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The number of items forming from the zip depends on the iterable with the fewest
    items. The following example provides an illustration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由zip操作形成的元素数量取决于元素最少的可迭代对象。以下示例提供了一个说明：
- en: '[PRE35]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One iterable, numbers_fewer, has two items, whereas the other, numbers_more,
    has four items. When we zip them, we have two pairs, matching the number of numbers_fewer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可迭代对象numbers_fewer有两个元素，而另一个numbers_more有四个元素。当我们zip它们时，我们有两个配对，与numbers_fewer的数量相匹配。
- en: Section 5.2
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第5.2节
- en: 'Try running the code using (expression for item in iterable). Consider the
    following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用（expression for item in iterable）运行代码。以下是一个示例：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As shown in this code snippet, the expression (x*x for x in numbers) creates
    a generator, which is a kind of memory-efficient iterator (section 7.4). Apparently,
    it’s not a tuple object, and there’s no such thing as tuple comprehension in Python.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，表达式 (x*x for x in numbers) 创建了一个生成器，这是一种内存高效的迭代器（见第 7.4 节）。显然，它不是一个元组对象，Python
    中也没有元组推导的概念。
- en: Section 5.3
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5.3 节
- en: 'Suppose that we have the following dict object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下的字典对象：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can iterate through the keys of this dict object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历这个字典对象的键：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can iterate through the values of this dict object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历这个字典对象的值：
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can iterate through the key-value pairs:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历键值对：
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, the items form the key and value as tuple objects, and
    we can unpack the tuple. Notably, there is syntactic sugar. When we iterate over
    the keys, we can use the dict object itself directly, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，这些项作为键和值形成元组对象，我们可以解包这个元组。值得注意的是，这里有一个语法糖。当我们遍历键时，我们可以直接使用字典对象本身，如下所示：
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Section 5.4
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5.4 节
- en: For your reference, the list of tasks that you need to search through is
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 供您参考，您需要搜索的任务列表如下
- en: '[PRE42]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When you try to find the urgent task by using a break statement, you can do
    the following (as shown in listing 5.7):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试使用 break 语句查找紧急任务时，您可以这样做（如列表 5.7 所示）：
- en: '[PRE43]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The challenge is asking about what happens if we don’t set an initial value
    for first_urgent_task1. Because it’s possible that we may not encounter any urgent
    task, the first_urgent_task1 is never set, making it unusable. Consider the following
    modification to see the potential problem:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于询问如果我们没有为 first_urgent_task1 设置初始值会发生什么。因为可能我们可能不会遇到任何紧急任务，所以 first_urgent_task1
    永远不会被设置，使其无法使用。考虑以下修改以查看潜在的问题：
- en: '[PRE44]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As shown in this code snippet, we require a task to be urgent if its urgency
    level is greater than 5\. With this condition, it appears that no tasks meet this
    criterion, so first_urgen_task2 is never set. When we try to print it out, we
    encounter a NameError (see section 10.4).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，如果任务的紧急程度大于 5，我们要求任务必须是紧急的。在这种情况下，似乎没有任务满足这一标准，因此 first_urgen_task2
    永远不会被设置。当我们尝试打印它时，我们会遇到 NameError（见第 10.4 节）。
- en: Chapter 6
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章
- en: Section 6.1
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.1 节
- en: 'We can embed a timestamp as a default argument. This timestamp reflects the
    time when it’s defined instead of the time when it’s called:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将时间戳作为默认参数嵌入。这个时间戳反映了定义时的时间，而不是调用时的时间：
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, we call the function multiple times, thinking that we could
    get different timestamps. But every timestamp is the same, showing the time when
    the function was created.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们多次调用函数，以为我们可以得到不同的时间戳。但每个时间戳都是相同的，显示了函数创建的时间。
- en: Section 6.2
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.2 节
- en: 'The return value has the same structure, latitude and longitude, and we can
    create a named tuple to capture these two values. Following is a possible refactored
    version:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值具有相同的结构，纬度和经度，我们可以创建一个命名元组来捕获这两个值。以下是一个可能的重构版本：
- en: '[PRE46]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Instead of returning two values, now we can return only a tuple object for each
    of these functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为这些函数中的每一个只返回一个元组对象，而不是返回两个值。
- en: Section 6.3
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.3 节
- en: 'The following function can take an argument as a list of int or str, with the
    type hints provided:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数可以接受一个作为 int 或 str 列表参数，并提供类型提示：
- en: '[PRE47]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the example, we use the type hint: list[int | str], meaning that the list
    object can consist of integers or strings.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用类型提示：list[int | str]，这意味着列表对象可以包含整数或字符串。
- en: Section 6.4
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.4 节
- en: The call example(a=1, b=2) is valid, as we’re using two keyword arguments. The
    call example(1, 2) is invalid, as we’re using positional arguments, but the function
    accepts keyword arguments. The call example(2a=1, 2b=2) is invalid, as these identifiers
    are invalid (they can’t start with a number). The call example() is valid, as
    it’s using zero keyword arguments. **kwargs means a variable number of keyword
    arguments, including zero keyword arguments.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 example(a=1, b=2) 是有效的，因为我们使用了两个关键字参数。调用 example(1, 2) 是无效的，因为我们使用了位置参数，但函数接受关键字参数。调用
    example(2a=1, 2b=2) 是无效的，因为这些标识符是无效的（它们不能以数字开头）。调用 example() 是有效的，因为它使用了零个关键字参数。**kwargs
    表示可变数量的关键字参数，包括零个关键字参数。
- en: Section 6.5
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.5 节
- en: 'We can have the following docstring using Google style:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 Google 风格的文档字符串：
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Chapter 7
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 章
- en: Section 7.1
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7.1 节
- en: 'All lambda functions have the name <lambda>, a nominal name for them, which
    is also why lambda functions are known as anonymous. By contrast, a regularly
    defined function has a name that matches the identifier defined in the function
    head:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 lambda 函数都有一个名为 `<lambda>` 的名称，这是它们的官方名称，这也是为什么 lambda 函数被称为匿名函数。相比之下，一个常规定义的函数有一个与函数头部中定义的标识符相匹配的名称：
- en: '[PRE49]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Section 7.2
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2 节
- en: As stated in the hint, it’s possible that the user might use an argument that
    doesn’t match any of the specified conditions. We should be prepared for this
    kind of undesired calling. By using get, we can use the fallback_action when the
    specified action isn’t in the actions dict object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如提示所述，用户可能会使用不匹配任何指定条件的参数。我们应该为这种不期望的调用做好准备。通过使用 `get`，当指定的操作不在 `actions` 字典对象中时，我们可以使用
    `fallback_action`。
- en: Section 7.3
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3 节
- en: 'As shown in the hints, we need to add another layer of function that deals
    with the argument. Here’s the solution:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如提示所示，我们需要添加另一层函数来处理参数。这是解决方案：
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The outmost function logging_time_app is the decorator, which takes the app
    name as its argument. Within this function, we define our typical decorator as
    we normally do, and this decorator takes the actual function that we’re going
    to decorate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的函数 `logging_time_app` 是装饰器，它将应用程序名称作为其参数。在这个函数内部，我们定义了我们通常使用的典型装饰器，并且这个装饰器接受我们将要装饰的实际函数。
- en: Section 7.4
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4 节
- en: 'Based on the hint, we can write the following generator function, which yields
    numbers in the Fibonacci sequence:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提示，我们可以编写以下生成器函数，它生成斐波那契数列中的数字：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As the Fibonacci sequence is built up by summing two consecutive numbers to
    create the next one, we initialize the sequence with its first two numbers and
    create the subsequent ones accordingly. We can try this function by creating a
    list object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于斐波那契数列是通过将两个连续的数字相加来创建下一个数字，因此我们用其前两个数字初始化序列，并相应地创建后续的数字。我们可以通过创建一个列表对象来尝试这个函数：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The list represents a Fibonacci sequence up to 13.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表表示了直到 13 的斐波那契数列。
- en: Section 7.5
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5 节
- en: 'Suppose that we have the function run_stats_model and the partial function
    run_stats_model_a:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `run_stats_model` 的函数和一个名为 `run_stats_model_a` 的部分函数：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The partial function is created from run_stats_model. Using the hint, we can
    see this partial function’s attributes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `run_stats_model` 创建部分函数。使用提示，我们可以查看这个部分函数的属性：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you may see, the function has an attribute called func, which may be the
    one telling us which function is the source function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该函数有一个名为 `func` 的属性，这可能是告诉我们哪个函数是源函数的属性：
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Indeed, it’s the function run_stats_model. You can also try finding out what
    the attributes args and keywords are.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，它是 `run_stats_model` 函数。您还可以尝试找出 `args` 和 `keywords` 属性是什么。
- en: Chapter 8
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 8 章节内容
- en: Section 8.1
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 8.1 节
- en: 'In section 6.1, I said that we should use None as the default value for a mutable
    argument. We should do the same thing with the __init__ method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 6.1 节中，我说过我们应该使用 `None` 作为可变参数的默认值。我们也应该在 `__init__` 方法中做同样的事情：
- en: '[PRE56]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can also try the ternary expression var = value_true if condition else value_
    false. Thus, we can update the preceding code this way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试三元表达式 `var = value_true if condition else value_false`。因此，我们可以这样更新前面的代码：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Section 8.2
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 8.2 节
- en: 'As we create an instance object from the tuple object, we need access to the
    class’s constructor. Thus, we need to define a class method to access a class’s
    data:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从一个元组对象创建实例对象，我们需要访问类的构造函数。因此，我们需要定义一个类方法来访问类的数据：
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Section 8.3
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 8.3 节
- en: 'Following the example shown in listing 8.9, we can apply the same thing to
    urgency:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 按照列表 8.9 中所示的示例，我们可以将相同的方法应用到紧急情况：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For detailed explanations, see listing 8.9.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 详细说明请见列表 8.9。
- en: Section 8.4
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 8.4 节
- en: 'Instead of hardcoding the class name, we can use its special attributes to
    retrieve this information programmatically:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用硬编码类名，而是使用其特殊属性以编程方式检索此信息：
- en: '[PRE60]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The __class__ special attribute gets the instance object’s class, which has
    the __name__ special attribute to get its class name.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊属性 `__class__` 获取实例对象的类，该类具有 `__name__` 特殊属性，可以获取其类名。
- en: Section 8.5
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 8.5 节
- en: 'The following code shows how to override the initialization method in a subclass:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何在子类中重写初始化方法：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the Supervisor class’s __init__ method, we use super() to create a proxy
    object to its superclass Employee, so we can use its __init__ method by sending
    name and employee_id.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Supervisor` 类的 `__init__` 方法中，我们使用 `super()` 创建其超类 `Employee` 的代理对象，这样我们就可以通过发送
    `name` 和 `employee_id` 来使用其 `__init__` 方法。
- en: Chapter 9
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 9 章节内容
- en: Section 9.1
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 9.1 节
- en: 'Because move_to is related to a specific instance, we can convert it to an
    instance method of the Direction class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为move_to与特定实例相关，我们可以将其转换为Direction类的实例方法：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As shown in this code snippet, we rename the move_to method’s first argument
    as self, which refers to the instance object. Within the body, we can use self.__class__
    to get a reference to the class Direction.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们将move_to方法的第一个参数重命名为self，它指向实例对象。在函数体内，我们可以使用self.__class__来获取对Direction类的引用。
- en: Section 9.2
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.2节
- en: 'When we create a data class, if we’re setting a default value for a field,
    we can use the dataclasses module’s field function, which handles setting the
    default value for mutable fields. The following code shows how to implement this
    feature:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建数据类时，如果我们为字段设置默认值，我们可以使用dataclasses模块的field函数，该函数处理可变字段的默认值设置。以下代码显示了如何实现此功能：
- en: '[PRE63]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this code, the dishes field is mutable, and we can specify the default_factory
    argument as list so that it creates an empty list object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，dishes字段是可变的，我们可以将default_factory参数指定为list，以便创建一个空列表对象。
- en: Section 9.3
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.3节
- en: 'As stated in the hint, tuple objects are serializable, and we can convert them
    directly to JavaScript Object Notation (JSON) strings as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如提示所述，元组对象是可序列化的，我们可以直接将它们转换为JavaScript对象表示法（JSON）字符串，如下所示：
- en: '[PRE64]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Section 9.4
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.4节
- en: 'Suppose that you build a client management app, using the following Client
    data model:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你构建了一个客户管理应用，使用以下Client数据模型：
- en: '[PRE65]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Everything should be straightforward. When you get an instance object’s initials,
    it’s using the value that you set initially. But the app has a function that allows
    users to change their names, so their initials may be updating too. To make the
    initials calculate on the go, we can convert the attribute initials to a function
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都应该很简单。当你获取实例对象的缩写时，它使用你最初设置的值。但是，应用程序有一个允许用户更改其名称的功能，因此他们的缩写也可能在更新。为了使缩写即时计算，我们可以将属性initials转换为函数，如下所示：
- en: '[PRE66]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This approach works—but it may break your code. Previously, you used client.initials
    to access a client’s initials; now you must use client.initials(). To avoid using
    the call operator, you can apply the property decorator:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行——但它可能会破坏你的代码。之前，你使用client.initials来访问客户的缩写；现在你必须使用client.initials()。为了避免使用调用操作符，你可以应用属性装饰器：
- en: '[PRE67]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This way, you can keep your application programming interface (API) consistent
    by using just client.initials, but you provide the calculation on the go by calling
    a function for this property. Thus, using a decorator can help you avoid API break
    changes. You can keep your API consistent even though the implementation has become
    a property instead of an attribute.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你只需使用client.initials来保持你的应用程序编程接口（API）的一致性，但通过调用此属性的函数来提供即时计算。因此，使用装饰器可以帮助你避免API中断更改。即使实现已经变成属性而不是属性，你也能保持API的一致性。
- en: Section 9.5
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.5节
- en: 'Because all these methods can be nonpublic, I’m converting them to protected
    methods by using an underscore prefix:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有这些方法都可以是非公开的，所以我通过使用下划线前缀将它们转换为受保护的方法：
- en: '[PRE68]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Chapter 10
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: Section 10.1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第10.1节
- en: 'As mentioned in the hint, the collections.abc module has the Iterable class,
    and iterables should generally have implemented the required method __iter__.
    Thus, we can use the isinstance function on this class to examine whether an object
    is an iterable:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如提示所述，collections.abc模块有Iterable类，可迭代对象通常应该实现了所需的__iter__方法。因此，我们可以使用isinstance函数在这个类上检查一个对象是否是可迭代的：
- en: '[PRE69]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Using this updated function, we can check some common data types:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个更新的函数，我们可以检查一些常见的数据类型：
- en: '[PRE70]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Section 10.2
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第10.2节
- en: 'To test how using a variable in a function changes the reference count, we
    can write a trivial function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试在函数中使用变量如何改变引用计数，我们可以编写一个简单的函数：
- en: '[PRE71]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If we call get_detail with the task variable, the reference count becomes
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用task变量调用get_detail，引用计数变为
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Why 4? The first count is the task variable itself. When you call get_detail,
    you send task, making the count 2. The function get_detail takes task, making
    the count 2. Within the function’s body, calling sys.getrefcount adds another
    count, making the count 4.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是4？第一次计数是任务变量本身。当你调用get_detail时，你发送task，使计数变为2。函数get_detail接收task，使计数变为2。在函数体内，调用sys.getrefcount添加另一个计数，使计数变为4。
- en: Section 10.3
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第10.3节
- en: 'According to the requirements specified in the challenge, we can update our
    Task class to the following edition:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据挑战中指定的要求，我们可以将我们的Task类更新为以下版本：
- en: '[PRE73]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the __copy__ method, we create a new title and a new tags list for the copied
    object. We can check whether the __copy__ method works as intended by using this
    code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'In the __copy__ method, we create a new title and a new tags list for the copied
    object. We can check whether the __copy__ method works as intended by using this
    code:'
- en: '[PRE74]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To double-check whether the tags attributes of these two objects are indeed
    different, we can try changing one list:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'To double-check whether the tags attributes of these two objects are indeed
    different, we can try changing one list:'
- en: '[PRE75]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Everything works as expected: task.tags and new_task.tags are two distinct
    list objects.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'Everything works as expected: task.tags and new_task.tags are two distinct
    list objects.'
- en: Section 10.4
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第10.4节
- en: 'In Python, the if...else... statement doesn’t form its own scope, unlike classes
    and functions. As there is no scope, you can change a global variable without
    using the global keyword, as shown in this example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'In Python, the if...else... statement doesn’t form its own scope, unlike classes
    and functions. As there is no scope, you can change a global variable without
    using the global keyword, as shown in this example:'
- en: '[PRE76]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ❶ You may get a different result because of the randomness.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ You may get a different result because of the randomness.
- en: As shown in this code snippet, we change the weather variable without the global
    keyword, indicating that the if...else... statement doesn’t form a scope, making
    weather fall outside it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: As shown in this code snippet, we change the weather variable without the global
    keyword, indicating that the if...else... statement doesn’t form a scope, making
    weather fall outside it.
- en: Section 10.5
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第10.5节
- en: 'When you define a decorator as a class, to keep the metadata for a decorated
    function, you know that you need to wrap the function. But unlike a decorator
    function, in which you use the wraps decorator, a class-based decorator uses the
    method update_wrapper, which helps keep the metadata:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'When you define a decorator as a class, to keep the metadata for a decorated
    function, you know that you need to wrap the function. But unlike a decorator
    function, in which you use the wraps decorator, a class-based decorator uses the
    method update_wrapper, which helps keep the metadata:'
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Using update_wrapper is like using the wraps decorator. You update the wrapper
    in the __init__ method of the TimeLogger class. Notably, the wraps decorator is
    syntactic sugar, as it’s invoking the update_wrapper under the hood.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Using update_wrapper is like using the wraps decorator. You update the wrapper
    in the __init__ method of the TimeLogger class. Notably, the wraps decorator is
    syntactic sugar, as it’s invoking the update_wrapper under the hood.
- en: Chapter 11
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章
- en: Section 11.1
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第11.1节
- en: 'We need to add a line break to each item. Using the list comprehension, we
    can create a new list object by using the list_data:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要给每个项目添加一个换行符。使用列表推导式，我们可以通过list_data创建一个新的列表对象：
- en: '[PRE78]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'With the updated list, we can use the writelines function to produce the desired
    file. We can double-check whether the writing is successful by reading the data:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'With the updated list, we can use the writelines function to produce the desired
    file. We can double-check whether the writing is successful by reading the data:'
- en: '[PRE79]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Section 11.2
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第11.2节
- en: 'The writerows works with a list object, so we can embed each row’s data (list
    object) within an outer list object, as suggested by the hint:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'The writerows works with a list object, so we can embed each row’s data (list
    object) within an outer list object, as suggested by the hint:'
- en: '[PRE80]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then we can run the following code to write this list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'Then we can run the following code to write this list:'
- en: '[PRE81]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If we open the file tasks_writer.txt, we should see that the data is entered
    correctly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开文件tasks_writer.txt，我们应该看到数据被正确输入。
- en: Section 11.3
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第11.3节
- en: 'We override the __reduce__ method within the MaliciousTask class as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'We override the __reduce__ method within the MaliciousTask class as follows:'
- en: '[PRE82]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Specifically, we use ('rm hacking.txt',) instead of ('touch hacking.txt'). The
    command rm means that we’ll delete the specified file. After updating the class,
    we can run the code in listing 11.14 to see the effect.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Specifically, we use ('rm hacking.txt',) instead of ('touch hacking.txt'). The
    command rm means that we’ll delete the specified file. After updating the class,
    we can run the code in listing 11.14 to see the effect.
- en: Section 11.4
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第11.4节
- en: 'We can call the exists method on an instance of the Path class to check a file’s
    existence. Thus, we can update listing 11.17 to the following version:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can call the exists method on an instance of the Path class to check a file’s
    existence. Thus, we can update listing 11.17 to the following version:'
- en: '[PRE83]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ❶ Removes the existing folder
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 移除现有的文件夹
- en: As highlighted in this code, we copy the files only if the file at the target
    path doesn’t exist, preventing us from overwriting already-processed files.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: As highlighted in this code, we copy the files only if the file at the target
    path doesn’t exist, preventing us from overwriting already-processed files.
- en: Section 11.5
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第11.5节
- en: 'We know that we can find a file’s modification time by accessing st_mtime of
    a file’s status. Thus, we can create the following function to return the files
    whose modification times are within the past 24 hours:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道可以通过访问文件的st_mtime属性来找到文件的修改时间。因此，我们可以创建以下函数来返回过去24小时内修改的文件：
- en: '[PRE84]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The pattern "*" allows us to go over all the files in the directory. We specify
    that the file’s modification time must reside in the range of the previous 24
    hours. If a file meets this requirement, we add it to the good_files list as this
    function’s final output.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 模式"*"允许我们遍历目录中的所有文件。我们指定文件的修改时间必须在过去的24小时内。如果一个文件满足这个要求，我们就将其添加到good_files列表中，作为这个函数的最终输出。
- en: Chapter 12
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: Section 12.1
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第12.1节
- en: 'We can call the logger’s hasHandlers method to check whether the logger has
    any handlers before we add the handler:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用记录器的hasHandlers方法来检查在添加处理器之前记录器是否有任何处理器：
- en: '[PRE85]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To clear the handlers, we can manipulate the logger’s handlers attribute, which
    is a list object:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清除处理器，我们可以操作记录器的handlers属性，它是一个列表对象：
- en: '[PRE86]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ❶ Removes all the handlers
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 移除所有处理器
- en: Section 12.2
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第12.2节
- en: 'To demonstrate what happens, I use a stream handler so that the messages can
    be printed in the console:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示会发生什么，我使用了一个流处理器，以便消息可以在控制台中打印：
- en: '[PRE87]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If you run this code in the console, you’ll see that only the warning message
    is shown; the logging message at the INFO level is lower than the logger’s level,
    so it won’t be sent to the handler. By contrast, the message at the WARNING level
    meets the logger’s level requirement and is forwarded to the handler.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个控制台中运行此代码，你会看到只显示了警告消息；INFO级别的日志消息低于记录器的级别，因此它不会被发送到处理器。相比之下，WARNING级别的消息符合记录器的级别要求，并被转发到处理器。
- en: Section 12.3
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第12.3节
- en: 'As suggested by the hint, you can run the potentially problematic code in the
    console and see what happens. Here’s an example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如提示所示，你可以在控制台中运行可能有问题代码并查看发生了什么。以下是一个示例：
- en: '[PRE88]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You’ll see that you encounter the ValueError exception. Step backward and add
    this exception in the try...except... statement:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到你遇到了ValueError异常。回退并在这个try...except...语句中添加这个异常：
- en: '[PRE89]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Section 12.4
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第12.4节
- en: 'If you run the code in the challenge, you’ll see that your console has the
    following output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行挑战中的代码，你会看到你的控制台有如下输出：
- en: '[PRE90]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You don’t see the task get returned, as the return statement in the finally
    gets executed before the try clause’s return statement.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你看不到任务被返回，因为在try子句的返回语句执行之前，finally子句中的返回语句已经执行了。
- en: Section 12.5
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第12.5节
- en: 'To allow you to try the code multiple times, I’m defining a function that can
    create a task based on different kinds of input:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你能够多次尝试代码，我定义了一个函数，可以根据不同的输入创建任务：
- en: '[PRE91]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This function uses all four clauses in exception handling. Try calling this
    function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了异常处理中的所有四个子句。尝试调用这个函数：
- en: '[PRE92]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: When you use a non-str object, you see that the try, except, and finally clauses
    get executed. When you use a str object, you see that the try, else, and finally
    clauses get executed.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用非str对象时，你会看到try、except和finally子句被执行。当你使用str对象时，你会看到try、else和finally子句被执行。
- en: Chapter 13
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章
- en: Section 13.1
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.1节
- en: 'There are different ways to make the tracebacks more complicated. Following
    is a possible solution:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法使回溯更加复杂。以下是一个可能的解决方案：
- en: '[PRE93]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the class, we use multiple methods to call one another, resulting in a traceback
    that has multiple calls.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，我们使用多种方法相互调用，导致回溯有多个调用。
- en: Section 13.2
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.2节
- en: 'Namespaces track variables dynamically. Calling the built-in locals function
    reveals what’s available in the local namespace at the specific moment. The following
    code snippet is a snapshot of the changes:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间动态跟踪变量。调用内置的locals函数可以揭示在特定时刻本地命名空间中可用的内容。以下代码片段是变化的快照：
- en: '[PRE94]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Section 13.3
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.3节
- en: 'We can have the following function create an instance of the Task class from
    a tuple object:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义以下函数，从元组对象创建Task类的实例：
- en: '[PRE95]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can define the following test function in the test class for the create_task_
    from_tuple function:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在create_task_from_tuple函数的测试类中定义以下测试函数：
- en: '[PRE96]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Section 13.4
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.4节
- en: 'You can update the method to make it raise an exception explicitly. You need
    to change the Task class in the test_class.py file as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更新方法使其显式地抛出异常。你需要按照以下方式更改test_class.py文件中的Task类：
- en: '[PRE97]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When you run the test_task_class.py again, you’ll see the following output
    in the command-line tool, showing that we encounter an error due to the TypeError
    in our code. Note that the output shows ..E instead of ..F because it’s an error
    instead of a test failure:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行test_task_class.py时，你将在命令行工具中看到以下输出，显示我们遇到了由于代码中的TypeError而导致的错误。请注意，输出显示..E而不是..F，因为它是一个错误而不是测试失败：
- en: '[PRE98]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Chapter 14
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第14章
- en: Section 14.1
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第14.1节
- en: 'Use a tool such as Terminal if your computer is a Mac or a command-line tool
    if your computer operates under Windows. Navigate to the desired directory, and
    then run the following command to create a virtual environment:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的电脑是Mac，请使用终端；如果您的电脑在Windows下运行，请使用命令行工具。导航到所需的目录，然后运行以下命令以创建虚拟环境：
- en: '[PRE99]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'After creating the virtual environment, you need to activate it by running
    the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境后，您需要运行以下命令来激活它：
- en: '[PRE100]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To install the pandas library, run the following command:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装pandas库，请运行以下命令：
- en: '[PRE101]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: To use this virtual environment in Visual Studio Code, see section 14.1.4 for
    detailed instructions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Visual Studio Code中使用此虚拟环境，请参阅第14.1.4节以获取详细说明。
- en: Section 14.2
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第14.2节
- en: 'We can use a Boolean flag to indicate whether the record is found:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用布尔标志来指示记录是否找到：
- en: '[PRE102]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As shown in this code snippet, we set an initial False value for the flag. If
    we find the record, we make it True. We can raise an exception when the Boolean
    value is False.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们为标志设置了一个初始的False值。如果我们找到记录，我们将其设置为True。当布尔值为False时，我们可以引发异常。
- en: Section 14.3
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 第14.3节
- en: 'Chapter 7 covered how to create a time-logging decorator. Here’s a possible
    implementation taken from listing 7.9:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章介绍了如何创建一个时间记录装饰器。以下是一个可能的实现，摘自列表7.9：
- en: '[PRE103]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can use this decorator to decorate the methods in the class. To show a
    proof of concept, I decorate the load_tasks method:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这个装饰器来装饰类中的方法。为了展示一个概念证明，我装饰了load_tasks方法：
- en: '[PRE104]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Although I don’t intend to perform a formal comparison, it appears that the
    SQLite 3 database outperforms the CSV file in terms of data-reading speed. Please
    note that we’re dealing with a small amount of data, so the difference between
    these two sources appears to be trivial:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我并不打算进行正式的比较，但看起来SQLite 3数据库在数据读取速度方面优于CSV文件。请注意，我们处理的是少量数据，因此这两个来源之间的差异似乎微不足道：
- en: '[PRE105]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Section 14.4
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 第14.4节
- en: 'We can use any iterable as the option in the selectbox widget in streamlit.
    When we use a dict object as an iterable, using the dict and dict.keys() is the
    same, as in this example:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在streamlit的selectbox小部件中使用任何可迭代对象作为选项。当我们使用字典对象作为可迭代对象时，使用dict和dict.keys()是相同的，如下例所示：
- en: '[PRE106]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
