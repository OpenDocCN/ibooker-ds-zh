- en: Chapter 7\. Handling errors and exceptions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章. 处理错误和异常
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: Holding information about errors with the `Either` type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Either`类型保存错误信息
- en: Easier error handling with the biased `Result` type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有偏`Result`类型简化错误处理
- en: Accessing the data inside a `Result`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`Result`内部的数据
- en: Applying effects to `Result` data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`Result`数据应用效果
- en: Lifting functions to operate on `Result`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数提升到在`Result`上操作
- en: In [chapter 6](kindle_split_013.xhtml#ch06), you learned how to deal with optional
    data without having to manipulate `null` references by using the `Option` data
    type. As you saw, this data type is perfect for dealing with the absence of data
    when this isn’t the result of an error. But it’s not an efficient way to handle
    errors, because, although it allows you to cleanly report the absence of data,
    it swallows the cause of this absence. All missing data is thus treated the same
    way, and it’s up to the caller to try to figure out what happened, which is generally
    impossible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_013.xhtml#ch06)中，你学习了如何使用`Option`数据类型处理可选数据，而无需通过操作`null`引用来处理。正如你所看到的，这种数据类型在处理数据缺失（且非错误结果）时非常完美。但它不是处理错误的有效方式，因为尽管它允许你干净地报告数据缺失，但它吞没了这种缺失的原因。因此，所有缺失的数据都被同等对待，而调用者必须尝试弄清楚发生了什么，这通常是不可能的。
- en: 7.1\. The problems to be solved
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 需要解决的问题
- en: 'Most of the time, the absence of data is the result of an error, either in
    the input data or in the computation. These are two very different cases, but
    they end with the same result: data is absent, and it was meant to be present.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，数据缺失是输入数据或计算错误的结果。这两种情况非常不同，但最终结果相同：数据缺失，而它本应存在。
- en: 'In classical imperative programming, when a function or a method takes an object
    parameter, most programmers know that they should test this parameter for `null`.
    What they should do if the parameter is `null` is often undefined. Remember the
    example from [listing 6.3](kindle_split_013.xhtml#ch06ex03) in [chapter 6](kindle_split_013.xhtml#ch06):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的命令式编程中，当一个函数或方法接受一个对象参数时，大多数程序员都知道他们应该测试这个参数是否为`null`。如果参数是`null`，他们应该做什么通常是未定义的。记住[第6章](kindle_split_013.xhtml#ch06)中的[列表6.3](kindle_split_013.xhtml#ch06ex03)的例子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, output of “No data” was obtained because the `"Goofy"` key
    was not in the map. This could be considered a normal case. But take a look at
    this one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于`"Goofy"`键不在映射中，所以得到了“无数据”的输出。这可以被视为一个正常情况。但看看这个例子：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the user enters an empty string, what should you do? An obvious solution
    would be to validate the input and return an `Option<String>`. In the absence
    of a valid string, you could return `None`. But although you haven’t yet learned
    how to functionally let the user input a string, you can be sure that such an
    operation could throw an exception. The program would look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入一个空字符串，你应该怎么办？一个明显的解决方案是验证输入并返回`Option<String>`。在没有有效字符串的情况下，你可以返回`None`。但尽管你还没有学习如何函数式地让用户输入字符串，你可以确信这样的操作可能会抛出异常。程序看起来像这样：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now think about what could happen:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑可能会发生什么：
- en: Everything goes well, and you get an email printed to the console.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切顺利，你会在控制台看到一个电子邮件。
- en: An `IOException` is thrown, and you get “No data” printed to the console.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出`IOException`，并在控制台打印出“无数据”。
- en: The name entered by the user doesn’t validate, and you get “No data.”
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入的名称无效，你得到“无数据”。
- en: The name validates but isn’t found in the map. You get “No data.”
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称验证通过，但在映射中找不到。你得到“无数据”。
- en: The name is found in the map, but the corresponding toon has no email. You get
    “No data.”
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称在映射中找到，但对应的卡通没有电子邮件。你得到“无数据”。
- en: What you need is different messages printed to the console to indicate what’s
    happening in each case.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是在控制台打印不同的消息来指示每种情况发生的情况。
- en: If you wanted to use the types you already know, you could use a `Tuple<Option<T>,
    Option<String>>` as the return type of each method, but this is a bit complicated.
    `Tuple` is a product type, which means that the number of elements that can be
    represented by a `Tuple<T, U>` is the number of possible `T` multiplied by the
    number of possible `U`. You don’t need that because every time you have a value
    for `T`, you’ll have `None` for `U`. In the same way, each time `U` is `Some`,
    `T` will be `None`. What you need is a sum type, which means a type `E<T, U>`
    that will hold either a `T` *or* a `U`, but not a `T` *and* a `U`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用你已知的类型，你可以使用 `Tuple<Option<T>, Option<String>>` 作为每个方法的返回类型，但这有点复杂。`Tuple`
    是一个乘积类型，这意味着 `Tuple<T, U>` 可以表示的元素数量是 `T` 的可能数量乘以 `U` 的可能数量。你不需要这个，因为每次你有 `T`
    的值时，`U` 将会是 `None`。同样，每次 `U` 是 `Some` 时，`T` 将会是 `None`。你需要的是一个和类型，这意味着一个 `E<T,
    U>` 类型，它将持有 `T` 或 `U` 中的一个，但不是 `T` 和 `U` 两个。
- en: 7.2\. The Either type
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. Either 类型
- en: Designing a type that can hold either a `T` or a `U` is easy. You just have
    to slightly modify the `Option` type by changing the `None` type to make it hold
    a value. You’ll also change the names. The two private subclasses of the `Either`
    type will be called `Left` and `Right`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个可以持有 `T` 或 `U` 的类型很容易。你只需要稍微修改 `Option` 类型，将 `None` 类型改为可以持有值。你也会更改名称。`Either`
    类的两个私有子类将被称为 `Left` 和 `Right`。
- en: Listing 7.1\. The `Either` type
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. `Either` 类型
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you can easily use `Either` instead of `Option` to represent values that
    could be absent due to errors. You have to parameterize `Either` with the type
    of your data and the type of the error. By convention, you’ll use the `Right`
    subclass to represent success (which is “right”) and the `Left` to represent error.
    But you won’t call the subclass `Wrong` because the `Either` type may be used
    to represent data that can be represented by one type or another, both being valid.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以轻松地使用 `Either` 而不是 `Option` 来表示可能由于错误而缺失的值。你必须用你的数据和错误类型参数化 `Either`。按照惯例，你将使用
    `Right` 子类来表示成功（即“正确”），而使用 `Left` 来表示错误。但你不会调用子类为 `Wrong`，因为 `Either` 类型可以用来表示可以由一种类型或另一种类型表示的数据，两者都是有效的。
- en: 'Of course, you have to choose what type will represent the error. You can choose
    `String` in order to carry an error message, or you can choose `Exception`. For
    example, the `max` function you defined in [chapter 6](kindle_split_013.xhtml#ch06)
    could be modified as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你必须选择哪种类型将代表错误。你可以选择 `String` 来携带错误信息，或者你可以选择 `Exception`。例如，你可以在 [第 6 章](kindle_split_013.xhtml#ch06)
    中定义的 `max` 函数如下修改：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 7.2.1\. Composing Either
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 组合 Either
- en: To compose methods or functions returning `Either`, you need to define the same
    methods you defined on the `Option` class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要组合返回 `Either` 的方法和函数，你需要定义与 `Option` 类上定义的相同的方法。
- en: Exercise 7.1
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.1
- en: 'Define a `map` method to change an `Either<E, A>` into an `Either<E, B>`, given
    a function from `A` to `B`. The signature of the `map` method is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `map` 方法，将 `Either<E, A>` 转换为 `Either<E, B>`，给定一个从 `A` 到 `B` 的函数。`map`
    方法的签名如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Hint
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: I’ve used type parameters `E` and `A` to make clear which side you should map,
    `E` standing for *error*. But it would be possible to define two `map` methods
    (call them `mapLeft` and `mapRight`) to map one or the other side of an `Either`
    instance. In other words, you’re developing a “biased” version of `Either` that
    will be mappable on one side only.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了类型参数 `E` 和 `A` 来明确指出你应该映射哪一侧，`E` 代表 *错误*。但也可以定义两个 `map` 方法（可以称它们为 `mapLeft`
    和 `mapRight`），以映射 `Either` 实例的一侧或另一侧。换句话说，你正在开发一个“有偏”的 `Either` 版本，它只能在一侧进行映射。
- en: Solution 7.1
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 7.1
- en: 'The `Left` implementation is a bit more complex than the `None` implementation
    for `Option` because you have to construct a new `Either` holding the same (error)
    value as the original:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Left` 的实现比 `Option` 的 `None` 实现要复杂一些，因为你必须构造一个新的 `Either`，它持有与原始相同的（错误）值：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Right` implementation is exactly like the one in `Some`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Right` 的实现与 `Some` 中的实现完全相同：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Exercise 7.2
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.2
- en: 'Define a `flatMap` method to change an `Either<E, A>` into an `Either<E, B>`,
    given a function from `A` to `Either<E, B>`. The signature of the `flatMap` method
    is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `flatMap` 方法，将 `Either<E, A>` 转换为 `Either<E, B>`，给定一个从 `A` 到 `Either<E,
    B>` 的函数。`flatMap` 方法的签名如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Solution 7.2
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 7.2
- en: 'The `Left` implementation is exactly the same as for the `map` method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Left` 的实现与 `map` 方法完全相同：'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Right` implementation is the same as the `Option.flatMap` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Right` 的实现与 `Option.flatMap` 方法相同：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Exercise 7.3
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.3
- en: 'Define methods `getOrElse` and `orElse` with the following signatures:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 定义具有以下签名的`getOrElse`和`orElse`方法：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Hint
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Not all exercises have a satisfying solution!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有练习都有令人满意的解决方案！
- en: Solution 7.3
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 7.3
- en: 'The `orElse` method can be defined in the `Either` class, because the same
    implementation works for both subclasses:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`orElse`方法可以在`Either`类中定义，因为相同的实现适用于两个子类：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Solutions for the `getOrElse` methods are straightforward. In the `Right` subclass,
    you just have to return the contained value:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrElse`方法的解决方案很简单。在`Right`子类中，你只需返回包含的值：'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `Left` subclass, just return the default value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Left`子类中，只需返回默认值：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method works, but it’s far from ideal. The problem is that you don’t know
    what has happened if no value was available. You simply get the default value,
    not even knowing if it’s the result of a computation or the result of an error.
    To handle error cases correctly, you’d need a biased version of `Either`, where
    the left type is known. Rather than using `Either` (which, by the way, has many
    other interesting uses), you can create a specialized version using a known fixed
    type for the `Left` class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但远非理想。问题是，如果没有值可用，你不知道发生了什么。你只是得到默认值，甚至不知道它是计算的结果还是错误的结果。为了正确处理错误情况，你需要一个已知左类型的`Either`的偏置版本。而不是使用`Either`（顺便说一下，`Either`有很多其他有趣的用途），你可以创建一个使用已知固定类型的`Left`类的专用版本。
- en: 'The first question you might ask is, “What type should I use?” Obviously, two
    different types come to mind: `String` and `RuntimeException`. A string can hold
    an error message, as an exception does, but many error situations will produce
    an exception. Using a `String` as the type carried by the `Left` value will force
    you to ignore the relevant information in the exception and use only the included
    message. It’s thus better to use `RuntimeException` as the `Left` value. That
    way, if you only have a message, you can wrap it into an exception.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问的第一个问题是，“我应该使用什么类型？”显然，会想到两种不同的类型：`String`和`RuntimeException`。字符串可以保存错误消息，就像异常一样，但许多错误情况会产生异常。使用`String`作为`Left`值携带的类型将迫使你忽略异常中的相关信息，而只使用包含的消息。因此，最好使用`RuntimeException`作为`Left`值。这样，如果你只有一条消息，你可以将其包装成一个异常。
- en: 7.3\. The Result type
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 结果类型
- en: Because the new type will generally represent the result of a computation that
    might have failed, you’ll call it `Result`. It’s very similar to the `Option`
    type, with the difference that the subclasses are named `Success` and `Failure`,
    as shown in the following listing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为新的类型通常表示可能失败的计算结果，所以你可以将其称为`Result`。它与`Option`类型非常相似，不同之处在于子类被命名为`Success`和`Failure`，如下所示。
- en: Listing 7.2\. The `Result` class
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2. `Result`类
- en: '![](Images/ch07ex02-0.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex02-0.jpg)'
- en: '![](Images/ch07ex02-1.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex02-1.jpg)'
- en: This class is much like the `Option` class, with the additional stored exception.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与`Option`类非常相似，除了存储了异常。
- en: 7.3.1\. Adding methods to the Result class
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1. 向Result类添加方法
- en: You’ll need the same methods in the `Result` class that you defined in the `Option`
    and `Either` classes, with small differences.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`Result`类中定义与在`Option`和`Either`类中定义相同的方法，但有细微差别。
- en: Exercise 7.4
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.4
- en: 'Define `map`, `flatMap`, `getOrElse`, and `orElse` for the `Result` class.
    For `getOrElse`, you can define two methods: one taking a value as its argument,
    and one taking a `Supplier`. Here are the signatures:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Result`类定义`map`、`flatMap`、`getOrElse`和`orElse`。对于`getOrElse`，你可以定义两个方法：一个接受一个值作为其参数，另一个接受一个`Supplier`。以下是签名的示例：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first version of `getOrElse` is useful when the default value is a literal
    because it’s already evaluated. In that case, you don’t need to use lazy evaluation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrElse`的第一个版本在默认值是字面量时很有用，因为它们已经评估过了。在这种情况下，你不需要使用懒加载。'
- en: Solution 7.4
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 7.4
- en: 'This time, you’ll have no problem with `getOrElse`, because you just have to
    throw the exception contained in a `Failure`. All other methods are very similar
    to those of the `Either` class. Here are the implementations for the `Success`
    class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你不会在`getOrElse`上遇到问题，因为你只需要抛出`Failure`中包含的异常。所有其他方法都与`Either`类中的方法非常相似。以下是`Success`类的实现：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here are the implementations for the `Failure` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Failure`类的实现：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As in `Option`, `map` and `flatMap` can’t return `this` in the `Failure` class
    because the type would be invalid.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Option`中，`map`和`flatMap`不能在`Failure`类中返回`this`，因为类型将无效。
- en: 'Finally, you can define the `orElse` method in the parent class because the
    implementation is valid for both subclasses:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在父类中定义`orElse`方法，因为实现对于两个子类都是有效的：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 7.4\. Result patterns
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 结果模式
- en: The `Result` class can now be used in a functional way, which means through
    composing methods representing computations that may succeed or fail. This is
    important because `Result` and similar types are often described as containers
    that may or may not contain a value. This description is partly wrong. `Result`
    is a computational context for a value that may or may not be present. The way
    to use it is not by retrieving the value, but by composing instances of `Result`
    using its specific methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`类现在可以以函数式方式使用，这意味着通过组合表示可能成功或失败的计算的方法。这很重要，因为`Result`和类似类型通常被描述为可能包含或不包含值的容器。这种描述部分是错误的。`Result`是一个可能存在或不存在的值的计算上下文。使用它的方式不是通过检索值，而是通过使用其特定方法组合`Result`的实例。'
- en: You can, for example, modify the previous `ToonMail` example to use this class.
    First you have to modify the `Map` and `Toon` classes as shown in [listings 7.3](#ch07ex03)
    and [7.4](#ch07ex04).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以修改之前的`ToonMail`示例以使用这个类。首先，你必须像[列表7.3](#ch07ex03)和[7.4](#ch07ex04)中所示修改`Map`和`Toon`类。
- en: Listing 7.3\. The modified `Map` class with the `get` method returning a `Result`
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3. 返回`Result`的修改后的`Map`类
- en: '![](Images/ch07ex03-0.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex03-0.jpg)'
- en: '![](Images/ch07ex03-1.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex03-1.jpg)'
- en: Listing 7.4\. The modified `Toon` class with the modified `mail` property
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4. 修改后的`Toon`类及其修改后的`mail`属性
- en: '![](Images/185fig01_alt.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/185fig01_alt.jpg)'
- en: Now you can modify the `ToonMail` program as follows.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以像下面这样修改`ToonMail`程序。
- en: Listing 7.5\. The modified program, using `Result`
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5. 使用`Result`修改后的程序
- en: '![](Images/185fig02_alt.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/185fig02_alt.jpg)'
- en: The program in [listing 7.5](#ch07ex05) uses the `getName` method to simulate
    an input operation that may throw an exception. To represent an exception being
    thrown, you just have to return a `Failure` wrapping the exception.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.5](#ch07ex05)中的程序使用`getName`方法模拟一个可能抛出异常的输入操作。要表示抛出异常，只需返回一个包含异常的`Failure`即可。'
- en: Note how the various operations returning a `Result` are composed. You don’t
    need to access the value contained in the `Result` (which may be an exception).
    The `flatMap` method is used for such composition.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，各种返回`Result`的操作是如何组合的。你不需要访问`Result`中包含的值（这可能是一个异常）。`flatMap`方法用于这种组合。
- en: 'Try to run this program with various implementations of the `getName` method,
    such as these:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用各种`getName`方法的实现运行这个程序，例如这些：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s what the program prints in each case:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序在每种情况下打印的内容：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This result may seem good, but it’s not. The problem is that Minnie, having
    no email, and Goofy, not being in the map, are reported as failures. They might
    be failures, but they might alternatively be normal cases. After all, if having
    no email was a failure, you wouldn’t have allowed a `Toon` instance to be created
    without one. Obviously this is not a failure, but only optional data. The same
    is true for the map. It might be an error if a key isn’t in the map (assuming
    it was supposed to be there), but from the map point of view, it’s just optional
    data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果看起来可能不错，但实际上并不好。问题是，由于Minnie没有电子邮件，而Goofy不在地图中，它们都被报告为失败。它们可能是失败，但也可能是正常情况。毕竟，如果你认为没有电子邮件是失败，你就不会允许创建一个没有电子邮件的`Toon`实例。显然，这并不是失败，而只是可选数据。对于地图来说也是如此。如果一个键不在地图中（假设它应该在那里），这可能是一个错误，但从地图的角度来看，它只是可选数据。
- en: 'You might think this isn’t a problem because you already have a type for this:
    the `Option` type you developed in [chapter 6](kindle_split_013.xhtml#ch06). But
    look at the way you’ve composed your functions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这不是问题，因为你已经有了这种类型的类型：你在[第6章](kindle_split_013.xhtml#ch06)中开发的`Option`类型。但看看你如何组合你的函数：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This was only possible because `getName`, `Map.get`, and `Toon.getEmail` all
    return a `Result`. If `Map.get` and `Toon.getMail` were to return `Option`s, they’d
    no longer compose with `getName`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可能，仅仅是因为`getName`、`Map.get`和`Toon.getEmail`都返回一个`Result`。如果`Map.get`和`Toon.getMail`返回`Option`，它们就不再与`getName`组合。
- en: 'It would still be possible to convert a `Result` to and from an `Option`. For
    example, you could add a `toOption` method in `Result`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以将`Result`转换为`Option`，然后再转换回来。例如，你可以在`Result`中添加一个`toOption`方法：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Success` implementation would be
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success`的实现将是'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Failure` implementation would be
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Failure`的实现将是'
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You could then use it as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用它如下所示：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, this would require you to use the version of `Map` you defined in
    [chapter 6](kindle_split_013.xhtml#ch06) ([listing 6.2](kindle_split_013.xhtml#ch06ex02))
    and a specific version of the `Toon` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这需要您使用[第6章](kindle_split_013.xhtml#ch06)中定义的`Map`版本以及`Toon`类的特定版本：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But you would have lost all the benefit of using `Result`! Now if an exception
    is thrown inside the `getName` method, it’s still wrapped in a `Failure`, but
    the exception is lost in the `toOption` method, and the program simply prints
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但您会失去使用`Result`的所有好处！现在如果在`getName`方法内部抛出异常，它仍然被包裹在`Failure`中，但异常在`toOption`方法中丢失，程序简单地打印
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You may think you should go the other way and convert an `Option` into a `Result`.
    This would work (although, in your example, you should call the new `toResult`
    method on both `Option` instances returned by `Map.get` and `Toon.getMail`), but
    it would be tedious, and because you’ll usually have to convert `Option` to `Result`,
    a much better way would be to cast this conversion into the `Result` class. All
    you have to do is create a new subclass corresponding to the `None` case, because
    the `Some` case doesn’t need conversion, apart from changing its name for `Success`.
    [Listing 7.6](#ch07ex06) shows the new `Result` class with the new subclass called
    `Empty`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为应该反过来将`Option`转换为`Result`。这会起作用（尽管，在您的例子中，您应该在`Map.get`和`Toon.getMail`返回的`Option`实例上调用新的`toResult`方法），但这会很繁琐，并且因为您通常需要将`Option`转换为`Result`，所以一个更好的方法是将这种转换铸造成`Result`类。您只需创建一个新的子类，对应于`None`情况，因为`Some`情况不需要转换，除了将其名称更改为`Success`。[列表7.6](#ch07ex06)显示了带有新子类`Empty`的新`Result`类。
- en: Listing 7.6\. The new `Result` class handling errors and optional data
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. 新的`Result`类处理错误和可选数据
- en: '![](Images/ch07ex06-0.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex06-0.jpg)'
- en: '![](Images/ch07ex06-1.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex06-1.jpg)'
- en: Now you can again modify your `ToonMail` application, as shown in [listings
    7.7](#ch07ex07) through [7.9](#ch07ex09).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以再次修改您的`ToonMail`应用程序，如[列表7.7](#ch07ex07)至[7.9](#ch07ex09)所示。
- en: Listing 7.7\. The `Map` class using the new `Result.Empty` class for optional
    data
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 使用新的`Result.Empty`类处理可选数据的`Map`类
- en: '![](Images/ch07ex07-0.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex07-0.jpg)'
- en: '![](Images/ch07ex07-1.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex07-1.jpg)'
- en: Listing 7.8\. The `Toon` class using `Result.Empty` for optional data
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8\. 使用`Result.Empty`处理可选数据的`Toon`类
- en: '![](Images/190fig01_alt.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/190fig01_alt.jpg)'
- en: Listing 7.9\. The `ToonMail` application handling optional data correctly
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. 正确处理可选数据的`ToonMail`应用程序
- en: '![](Images/190fig02_alt.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/190fig02_alt.jpg)'
- en: 'Now your programs print the following results for each implementation of the
    `getName` method (commented out in [listing 7.9](#ch07ex09)):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的程序为`getName`方法的每个实现打印以下结果（在[列表7.9](#ch07ex09)中已注释）：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You may think that something is missing because you can’t distinguish between
    the two different empty cases, but this isn’t the case. Error messages aren’t
    needed for optional data, so if you think you need a message, the data isn’t optional.
    The success result is optional, but in that case a message is mandatory, so you
    should be using a `Failure`. This will create an exception, but nothing forces
    you to throw it!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为缺少了某些内容，因为您无法区分两种不同的空情况，但这并不是事实。对于可选数据不需要错误消息，所以如果您认为需要消息，数据就不是可选的。成功结果是可选的，但在那种情况下，消息是强制性的，所以您应该使用`Failure`。这将创建一个异常，但没有任何东西强迫您抛出它！
- en: 7.5\. Advanced Result handling
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 高级`Result`处理
- en: 'So far, you’ve seen a very limited use of `Result`. `Result` should never be
    used for directly accessing the wrapped value (if it exists). The way you used
    `Result` in the previous example corresponds to the simpler specific composition
    use case: get the result of one computation and use it for the input of the next
    computation. More specific use cases exist. You could choose to use the result
    only if it matches some predicate (which means some condition). You could also
    use the failure case, for which you’d need to map the failure to something else,
    or transform the failure into a success of exception (`Success<Exception`>). You
    might also need to use several `Result`s as the input for a single computation.
    You’d probably benefit from some helper methods that create `Result` from computations,
    in order to deal with legacy code. Finally, you’ll sometimes need to apply effects
    to `Result`s.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你看到的 `Result` 的使用非常有限。`Result` 永远不应该用于直接访问包装值（如果存在）。你在上一个例子中使用 `Result`
    的方式对应于更简单的特定组合用例：获取一个计算的结果并将其用作下一个计算的输入。还存在更具体的用例。你可以选择仅在结果匹配某些谓词（这意味着某些条件）时使用结果。你也可以使用失败情况，你需要将失败映射到其他东西，或者将失败转换为成功或异常（`Success<Exception>`）。你可能还需要将多个
    `Result` 作为单个计算的输入。你可能将受益于一些辅助方法，这些方法可以从计算中创建 `Result`，以便处理遗留代码。最后，有时你需要将效果应用于
    `Result`。
- en: 7.5.1\. Applying predicates
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1\. 应用谓词
- en: Applying a predicate to a `Result` is something that you’ll often have to do.
    This is something that can easily be abstracted, so that you can write it only
    once.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将谓词应用于 `Result` 是你经常会做的事情。这是一件可以很容易地抽象的事情，这样你就可以只写一次。
- en: Exercise 7.5
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.5
- en: Write a method `filter` taking a condition that’s represented by a function
    from `T` to `Boolean`, and returning a `Result<T>`, which will be a `Success`
    or a `Failure` depending on whether the condition holds for the wrapped value.
    The signature will be
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `filter` 的方法，该方法接受一个从 `T` 到 `Boolean` 的函数作为条件，并返回一个 `Result<T>`，这将根据包装值是否满足条件而返回
    `Success` 或 `Failure`。其签名将是
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create a second method taking a condition as its first argument and a `String`
    as a second argument, and using the string argument for the potential `Failure`
    case.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个接受条件作为第一个参数和 `String` 作为第二个参数的第二个方法，并使用字符串参数作为潜在的 `Failure` 情况。
- en: Hint
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Although it’s possible to define abstract methods in the `Result` class and
    implement them in subclasses, try not to do so. Instead use one or more methods
    you’ve previously defined to create a single implementation in the `Result` class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 `Result` 类中定义抽象方法并在子类中实现它们是可能的，但请尽量不要这样做。相反，使用你之前定义的一个或多个方法在 `Result` 类中创建单个实现。
- en: Solution 7.5
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5 解答
- en: 'You have to create a function that takes the wrapped value as a parameter,
    applies the function to it, and returns the same `Result` if the condition holds
    or `Empty` (or `Failure`) otherwise. Then all you have to do is `flatMap` this
    function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须创建一个函数，该函数接受包装值作为参数，将其应用于函数，并在条件成立时返回相同的 `Result`，否则返回 `Empty`（或 `Failure`）。然后你只需要
    `flatMap` 这个函数：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Exercise 7.6
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.6
- en: 'Define an `exists` method that takes a function from `T` to `Boolean` and returns
    `true` if the wrapped value matches the condition, or `false` otherwise. Here’s
    the method signature:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `exists` 方法，该方法接受一个从 `T` 到 `Boolean` 的函数，如果包装值匹配条件，则返回 `true`，否则返回 `false`。这是方法的签名：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Hint
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Once again, try not to define an implementation in each subclass. Instead, create
    a single implementation in the parent class using the methods you have at your
    disposal.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，请尽量不要在每个子类中定义实现。相反，使用你拥有的方法在父类中创建单个实现。
- en: Solution 7.6
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6 解答
- en: 'The solution is simply to `map` the function to `Result<T>`, giving a `Result<Boolean>`,
    and then to use `getOrElse` with `false` as the default value. You don’t need
    to use a `Supplier` because the default value is a literal:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单，将函数 `map` 到 `Result<T>`，得到一个 `Result<Boolean>`，然后使用 `getOrElse` 并将 `false`
    作为默认值。你不需要使用 `Supplier`，因为默认值是一个字面量：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using `exists` as the name of this method may seem questionable. But it’s the
    same method that could be applied to a list, returning `true` if at least one
    element satisfies the condition, so it makes sense to use the same name. Some
    might argue that this implementation would also work for a `forAll` method that
    returns `true` if all elements in the list fulfill the condition. It’s up to you
    either to choose another name or to define a `forAll` method in the `Result` class
    with the same implementation. The important point is understanding what makes
    `List` and `Result` similar and what makes them different.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`exists`作为此方法的名称可能看起来有些可疑。但这是可以应用于列表的相同方法，如果至少有一个元素满足条件，则返回`true`，因此使用相同的名称是有意义的。有些人可能会争论，这种实现也可以用于返回`true`的所有列表元素都满足条件的`forAll`方法。这取决于您是选择另一个名称还是定义一个具有相同实现的`forAll`方法在`Result`类中。重要的是理解`List`和`Result`的相似之处和不同之处。
- en: 7.5.2\. Mapping failures
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2\. 映射失败
- en: It’s sometimes useful to change a `Failure` into a different one, as in the
    following example.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将`Failure`转换为另一个`Failure`是有用的，如下例所示。
- en: Listing 7.10\. A memory monitor
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.10\. 内存监控
- en: '![](Images/ch07ex10-0.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch07ex10-0.jpg)'
- en: '![](Images/ch07ex10-1.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch07ex10-1.jpg)'
- en: In multithreaded Java programs, an `OutOfMemoryError` (OOME) will often crash
    a thread but not the application, leaving it in an indeterminate state. To solve
    this problem, you have to catch the error and cleanly stop the application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程Java程序中，`OutOfMemoryError`（OOME）通常会崩溃一个线程，但不会崩溃应用程序，使其处于不确定状态。为了解决这个问题，您必须捕获错误并干净地停止应用程序。
- en: Catching an OOME is generally done with the help of an `UncaughtException-Handler`.
    This approach allows you to put the handler in a low-level library and to continue
    asking business developers not to catch OOMEs. But when an OOME is caught, there’s
    sometimes not enough memory left to run the handler, leading to the application’s
    erratic behavior. One way to solve this problem is to monitor memory with `MemoryPoolMXBean`.
    This solution allows you to register a notification handler that will be called
    automatically after garbage collection if it results in not enough memory being
    freed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用`UncaughtException-Handler`来捕获OOME。这种方法允许您将处理程序放在低级库中，并继续要求业务开发者不要捕获OOMEs。但是，当捕获到OOME时，有时剩余的内存不足以运行处理程序，导致应用程序出现异常行为。解决此问题的一种方法是用`MemoryPoolMXBean`监控内存。此解决方案允许您注册一个通知处理程序，如果垃圾回收后释放的内存不足，它将被自动调用。
- en: In the example, if you call the `monitorMemory` method with `0.8` as the parameter
    value, the notification listener will be called if more than 80% of the heap is
    still occupied immediately after a garbage collection. At this time, you hope
    to have enough memory left to cleanly log the problem and stop the application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，如果您使用`0.8`作为参数值调用`monitorMemory`方法，如果垃圾回收后堆占用率仍然超过80%，则将调用通知监听器。此时，您希望有足够的内存来干净地记录问题并停止应用程序。
- en: This program works fine (although the code is horrible, mostly due to how the
    Java library is written, with methods taking `null` as parameters, forcing you
    to cast the `MemoryPoolMXBean` into a `NotificationEmitter`, but that’s another
    story).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序运行良好（尽管代码很糟糕，这主要是由于Java库的编写方式，方法接受`null`作为参数，迫使您将`MemoryPoolMXBean`强制转换为`NotificationEmitter`，但这又是另一个故事）。
- en: Note that this program makes use of the `first` method on `List`, which you
    haven’t defined yet. This method is very similar to the filter method, although
    it returns a `Result`, possibly wrapping the first element satisfying the condition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此程序使用了`List`上的`first`方法，而您尚未定义该方法。此方法与filter方法非常相似，尽管它返回一个`Result`，可能包含满足条件的第一个元素。
- en: 'Although the program works, you have a problem: if for any reason the `find-PSOldGenPool`
    method returns a `Failure`, whether because you misspelled `"PS Old Gen"` or because
    you’re using a new version of Java in which the name has changed, you’ll get the
    following error message in the `Failure`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然程序可以工作，但您有一个问题：如果由于任何原因`find-PSOldGenPool`方法返回一个`Failure`，无论是由于您拼写错误`"PS Old
    Gen"`还是因为您正在使用Java的新版本，其中名称已更改，您将在`Failure`中收到以下错误消息：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Exercise 7.7
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习7.7
- en: Define a `mapFailure` method that takes a `String` as its argument and transforms
    a `Failure` into another `Failure` using the string as its error message. If the
    `Result` is `Empty` or `Success`, this method should do nothing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`mapFailure`方法，该方法接受一个`String`作为参数，并使用该字符串作为错误消息将一个`Failure`转换成另一个`Failure`。如果`Result`是`Empty`或`Success`，则此方法应不执行任何操作。
- en: Hint
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Define an abstract method in the parent class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在父类中定义一个抽象方法。
- en: Solution 7.7
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案7.7
- en: 'Here’s the abstract method in the parent class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是父类中的抽象方法：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Empty` and `Success` implementations just return `this`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty`和`Success`实现只是返回`this`：'
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Failure` implementation wraps the existing exception into a new one created
    with the given message. It then creates a new `Failure` by calling the corresponding
    static factory method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Failure`实现将现有的异常包装到一个使用给定消息创建的新异常中。然后通过调用相应的静态工厂方法创建一个新的`Failure`：'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You could choose `RuntimeException` as the exception type, or a more specific
    custom subtype of `RuntimeException`. Note that some other methods of the same
    kind might be useful, such as these:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择`RuntimeException`作为异常类型，或者一个更具体的自定义子类型`RuntimeException`。请注意，可能还有其他类似的方法是有用的，例如这些：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Another useful method would be one that maps an `Empty` to a `Failure`, given
    a `String` message.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的方法是将`Empty`映射到`Failure`，给定一个`String`消息。
- en: 7.5.3\. Adding factory methods
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3\. 添加工厂方法
- en: 'You’ve seen how `Success` and `Failure` can be created from a value. Some other
    use cases are so frequent that they deserve to be abstracted into supplemental
    static factory methods. To adapt legacy libraries, you’ll probably often create
    `Result` from a value that could possibly be `null`. To do this, you could use
    a static factory method with the following signatures:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何从值创建`Success`和`Failure`。一些其他的使用案例非常频繁，值得将其抽象为补充静态工厂方法。为了适应遗留库，你可能经常需要从可能为`null`的值创建`Result`。为此，你可以使用以下签名的静态工厂方法：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A method creating a `Result` from a function from `T` to `Boolean` and an instance
    of `T` might also be useful:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从`T`到`Boolean`的函数和一个`T`实例创建`Result`的方法也可能有用：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Exercise 7.8
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习7.8
- en: Define these static factory methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 定义这些静态工厂方法。
- en: Hint
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You have to make a choice about what to return in each case.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在每个情况下做出选择。
- en: Solution 7.8
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案7.8
- en: 'There are no difficulties in this exercise. Here are possible implementations,
    based on the choice to return `Empty` when no error message is used, and a `Failure`
    otherwise:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习没有困难。以下是基于选择在未使用错误消息时返回`Empty`，否则返回`Failure`的可能实现：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that you should handle the possibility that the message parameter may be
    `null`. Not doing so would throw an NPE, so a `null` message would be considered
    a bug. Instead, you could check the parameter and use a default value in the case
    of `null`. This is up to you. In any case, consistently checking parameters for
    `null` should be abstracted, as you’ll see in [chapter 15](kindle_split_022.xhtml#ch15).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该处理消息参数可能为`null`的可能性。如果不这样做，将会抛出NPE，因此`null`消息将被视为一个错误。相反，你可以检查参数，并在`null`的情况下使用默认值。这取决于你。在任何情况下，一致地检查`null`参数应该被抽象化，正如你将在第15章中看到的[chapter
    15](kindle_split_022.xhtml#ch15)。
- en: 7.5.4\. Applying effects
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.4\. 应用效果
- en: So far, you haven’t applied any effects to values wrapped in `Result`, other
    than by getting these values (through `getOrElse`). This isn’t satisfying because
    it destroys the advantage of using `Result`. On the other hand, you haven’t yet
    learned the necessary techniques to apply effects functionally. Effects include
    anything that modifies something in the outside world, such as writing to the
    console, to a file, to a database, or to a field in a mutable component, or sending
    a message locally or over a network.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有对`Result`中包装的值应用任何效果，除了通过`getOrElse`获取这些值。这并不令人满意，因为它破坏了使用`Result`的优势。另一方面，你还没有学习到应用函数式技术所需的必要技术。效果包括任何修改外部世界中的事物，例如写入控制台、文件、数据库或可变组件的字段，或者发送本地或网络消息。
- en: The technique I’ll show you now isn’t functional, but it is an interesting abstraction
    that allows you to use `Result` without knowing the functional techniques involved.
    You can use the technique shown here until we look at the functional versions,
    or you may even find that this is powerful enough to be used on a regular basis.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在要展示的技术不是函数式的，但它是一个有趣的高级抽象，允许你在不知道涉及的函数式技术的情况下使用`Result`。你可以使用这里展示的技术，直到我们查看函数式版本，或者你可能甚至会发现这足够强大，可以经常使用。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The technique discussed in this section is the approach taken by the functional
    constructs of Java 8, which isn’t surprising, because Java isn’t a functional
    programming language.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的技术是Java 8函数式构造所采取的方法，这并不奇怪，因为Java不是函数式编程语言。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To apply an effect, use the `Effect` interface you developed in [chapter 3](kindle_split_010.xhtml#ch03).
    This is a very simple functional interface:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用效果，请使用你在 [第 3 章](kindle_split_010.xhtml#ch03) 中开发的 `Effect` 接口。这是一个非常简单的函数式接口：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You could name this interface `Consumer` and define an `accept` method instead,
    as is the case in Java 8\. I’ve already said that this name was very badly chosen,
    because a `Consumer` should have a consume method. But, in fact, a `Consumer`
    doesn’t consume anything—after applying an effect to a value, the value is left
    unchanged and is still available for further computations or effects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个接口命名为 `Consumer` 并定义一个 `accept` 方法，就像 Java 8 中的那样。我已经说过这个名字选得很糟糕，因为 `Consumer`
    应该有一个 `consume` 方法。但实际上，`Consumer` 并不消费任何东西——在将效果应用于一个值之后，该值保持不变，仍然可用于进一步的计算或效果。
- en: Exercise 7.9
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.9
- en: Define a `forEach` method that takes an `Effect` as its parameter and applies
    it to the wrapped value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `forEach` 方法，它接受一个 `Effect` 作为参数并将其应用于包装值。
- en: Hint
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Define an abstract method in the `Result` class with an implementation in each
    subclass.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Result` 类中定义一个抽象方法，并在每个子类中实现它。
- en: Solution 7.9
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 7.9
- en: 'Here’s the abstract method declaration in `Result`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Result` 中的抽象方法声明：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Empty` and `Failure` implementations do nothing. As a result, you only
    need to implement the method in `Empty`, because `Failure` extends this class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 和 `Failure` 实现什么都不做。因此，你只需要在 `Empty` 中实现该方法，因为 `Failure` 扩展了这个类：'
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Success` implementation is straightforward. You just have to apply the
    effect to the value:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success` 实现很简单。你只需将效果应用于值：'
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This `forEach` method would be perfect for the `Option` class you created in
    [chapter 6](kindle_split_013.xhtml#ch06). But that’s not the case for `Result`.
    Generally, you want to take special actions on a failure. One simple way to handle
    failure is to throw the exception.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `forEach` 方法对于你创建的 `Option` 类来说非常完美，在 [第 6 章](kindle_split_013.xhtml#ch06)
    中。但对于 `Result` 来说并非如此。通常，你希望在失败时采取特殊操作。处理失败的一个简单方法就是抛出异常。
- en: Exercise 7.10
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.10
- en: 'Define the `forEachOrThrow` method to handle this use case. Here’s its signature
    in the `Result` class:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `forEachOrThrow` 方法以处理此用例。以下是 `Result` 类中的签名：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Hint
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You have a choice to make for the `Empty` case.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Empty` 的情况，你有选择权。
- en: Solution 7.10
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 7.10
- en: 'The `Success` implementation is identical to that of the `forEach` method.
    The `Failure` implementation just throws the wrapped exception:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success` 实现与 `forEach` 方法的实现相同。`Failure` 实现只是抛出包装的异常：'
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Empty` implementation is more of a problem. You can choose to do nothing,
    considering that `Empty` isn’t an error. Or you can decide that calling `forEachOrThrow`
    means that you want to convert the absence of data into an error. This is a tough
    decision to make. `Empty` is not an error by itself. And if you need to make it
    an error, you can use one of the `mapFailure` methods, so it’s probably better
    to implement `forEachOrThrow` in `Empty` as a do-nothing method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 实现可能是个问题。你可以选择什么都不做，因为 `Empty` 不是一个错误。或者你可以决定调用 `forEachOrThrow` 意味着你希望将数据的缺失转换为错误。这是一个艰难的决定。`Empty`
    本身不是错误。如果你需要将其变为错误，可以使用 `mapFailure` 方法之一，所以可能最好在 `Empty` 中实现 `forEachOrThrow`
    作为一种不执行任何操作的方法。'
- en: Exercise 7.11
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.11
- en: The more general use case when applying an effect to `Result` is applying the
    effect if it’s a `Success`, and handling the exception in some way if it’s a `Failure`.
    The `forEachOrThrow` method is fine for throwing, but sometimes you just want
    to log the error and continue. Rather than defining a method for logging, define
    a `forEachOrException` method that will apply an effect if a value is present
    and return a `Result`. This `Result` will be `Empty` if the original `Result`
    was a `Success`, or `Empty` and `Success <RuntimeException>` if it was a `Failure`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当将效果应用于 `Result` 的更通用用例时，如果它是 `Success`，则应用效果；如果它是 `Failure`，则以某种方式处理异常。`forEachOrThrow`
    方法对于抛出来说很好，但有时你只想记录错误并继续。与其定义一个用于记录的方法，不如定义一个 `forEachOrException` 方法，该方法将在值存在时应用效果并返回一个
    `Result`。如果原始 `Result` 是 `Success`，则该 `Result` 将是 `Empty`；如果它是 `Failure`，则将是 `Empty`
    和 `Success <RuntimeException>`。
- en: Solution 7.11
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 7.11
- en: 'The method is declared as `abstract` in the `Result` parent class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在 `Result` 父类中声明为 `abstract`：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Empty` implementation returns `Empty`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 实现返回 `Empty`：'
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Success` implementation applies the effect to the wrapped value and returns
    `Empty`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success` 实现将效果应用于包装值并返回 `Empty`：'
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Failure` implementation returns a `Success<RuntimeException>` holding
    the original exception, so that you can act on it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Failure` 实现返回一个包含原始异常的 `Success<RuntimeException>`，这样你就可以对其采取行动：'
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The typical use case for this method is as follows (using a hypothetical `Logger`
    type with a `log` method):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的典型用例如下（使用一个假设的 `Logger` 类型及其 `log` 方法）：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Remember that these methods aren’t functional, but they are a good and simple
    way to use `Result`. If you prefer to apply effects functionally, you’ll have
    to wait until [chapter 13](kindle_split_020.xhtml#ch13).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些方法不是函数式的，但它们是使用 `Result` 的好方法。如果你更喜欢以函数式的方式应用效果，你将不得不等到 [第 13 章](kindle_split_020.xhtml#ch13)。
- en: 7.5.5\. Advanced result composition
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.5\. 高级结果组合
- en: Use cases for `Result` are more or less the same as for `Option`. In the previous
    chapter, you defined a `lift` method for composing `Options` by transforming a
    function from `A` to `B` into a function from `Option<A>` to `Option<B>`. You
    can do the same for `Result`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 的用例与 `Option` 大致相同。在前一章中，你定义了一个 `lift` 方法，通过将一个从 `A` 到 `B` 的函数转换为一个从
    `Option<A>` 到 `Option<B>` 的函数来组合 `Options`。你也可以为 `Result` 做同样的事情。'
- en: Exercise 7.12
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.12
- en: 'Write a `lift` method for `Result`. This will be a static method in the `Result`
    class with the following signature:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `Result` 编写一个 `lift` 方法。这将是 `Result` 类中的一个静态方法，其签名如下：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Solution 7.12
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 7.12
- en: 'Here’s the very simple solution:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的解决方案：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Exercise 7.13
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.13
- en: 'Define `lift2` for lifting a function from `A` to `B` to `C`, and `lift3` for
    functions from `A` to `B` to `C` to `D`, with the following signatures:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `lift2` 用于将函数从 `A` 升级到 `B` 到 `C`，以及 `lift3` 用于从 `A` 到 `B` 到 `C` 到 `D` 的函数，以下是其签名：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Solution 7.13
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 7.13
- en: 'Here are the solutions:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决方案：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: I guess you can see the pattern. You could define `lift` for any number of parameters
    that way.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你可以看到模式。你可以用这种方法为任何数量的参数定义 `lift`。
- en: Exercise 7.14
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 7.14
- en: In [chapter 6](kindle_split_013.xhtml#ch06), you defined a `map2` method, taking
    as its arguments an `Option<A>`, an `Option<B>`, and a function from `A` to `B`
    to `C`, and returning an `Option<C>`. Define a `map2` method for `Result`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](kindle_split_013.xhtml#ch06) 中，你定义了一个 `map2` 方法，它接受一个 `Option<A>`、一个
    `Option<B>` 和一个从 `A` 到 `B` 到 `C` 的函数作为参数，并返回一个 `Option<C>`。为 `Result` 定义一个 `map2`
    方法。
- en: Hint
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t use the method you defined for `Option`. Instead, use the `lift2` method.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用你为 `Option` 定义的函数。相反，使用 `lift2` 方法。
- en: Solution 7.14
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 7.14
- en: The solution defined for `Option` was
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `Option` 定义的解决方案是
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is the same pattern you used for `lift2`. So the `map2` method will look
    like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `lift2` 中使用的相同模式。所以 `map2` 方法将看起来像这样：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A common use case for such functions is calling methods or constructors with
    arguments of type `Result` returned by other functions or methods. Take the previous
    `ToonMail` example. To populate the `Toon` map, you could construct toons by asking
    the user to input the first name, last name, and mail on the console, using the
    following methods:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数的常见用例是调用由其他函数或方法返回的 `Result` 类型的参数的方法或构造函数。以之前的 `ToonMail` 示例为例。要填充 `Toon`
    映射，你可以通过要求用户在控制台输入名字、姓氏和电子邮件来构建 toons，使用以下方法：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The real implementation will be different, but you still have to learn how to
    functionally get input from the console. For now, you’ll use these mock implementations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的实现可能会有所不同，但你仍然需要学习如何从控制台功能性地获取输入。现在，你将使用这些模拟实现。
- en: 'Using these implementations, you could create a `Toon` as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些实现，你可以创建一个 `Toon` 如下：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But you’re reaching the limits of abstraction. You might have to call methods
    or constructors with more than three arguments. In such a case, you could use
    the following pattern:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 但你正在达到抽象的极限。你可能需要调用带有超过三个参数的方法或构造函数。在这种情况下，你可以使用以下模式：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This pattern has two advantages:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式有两个优点：
- en: You can use any number of arguments.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用任意数量的参数。
- en: You don’t need to define a function.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要定义一个函数。
- en: 'Note that you could use `lift3` without defining the function separately, but
    you’d have to specify the types because of the poor type inference capacities
    of Java:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以不单独定义函数而使用 `lift3`，但因为你需要指定类型，所以 Java 的类型推断能力较差：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Your new pattern is sometimes called *comprehension*. Some languages have syntactic
    sugar for such constructs, roughly equivalent to this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新模式有时被称为 *理解*。一些语言为这样的结构提供了语法糖，大致相当于以下内容：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Java doesn’t have this kind of syntactic sugar, but it’s easy to do without
    it. Just notice that the calls to `flatMap` or `map` are nested. Start with a
    call to the first method (or start from a `Result` instance), `flatMap` each new
    call, and end by mapping the call to the constructor or method you intend to use.
    For example, to call a method taking five parameters when you only have five `Result`
    instances, use the following approach:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Java 没有这种语法糖，但即使没有它也很容易做到。只需注意对 `flatMap` 或 `map` 的调用是嵌套的。从一个方法的调用开始（或从一个 `Result`
    实例开始），对每个新的调用使用 `flatMap`，然后通过映射到你要使用的构造函数或方法来结束。例如，当你只有五个 `Result` 实例时，需要调用一个接受五个参数的方法，可以使用以下方法：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This example is a bit contrived, but it shows you how the pattern can be extended.
    The fact that the last call (the most deeply nested) is to `map` instead of `flatMap`,
    however, is not inherent to the pattern. That’s only because the last method (`compute`)
    returns a raw value. If it returned a `Result`, you’d have to use `flatMap` instead
    of `map`. But because this last method is often a constructor, and constructors
    always return raw values, you’ll often find yourself using `map` as the last method
    call.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有点牵强，但它展示了如何扩展这个模式。然而，最后一个调用（最深层嵌套的调用）是 `map` 而不是 `flatMap`，这并不是模式固有的。那只是因为最后一个方法（`compute`）返回一个原始值。如果它返回一个
    `Result`，你就必须使用 `flatMap` 而不是 `map`。但是，因为最后一个方法通常是构造函数，而构造函数总是返回原始值，所以你经常会发现自己使用
    `map` 作为最后一个方法调用。
- en: 7.6\. Summary
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6. 摘要
- en: Representing the absence of data due to an error is necessary. The `Option`
    type doesn’t allow this.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示由于错误而缺失数据是必要的。`Option` 类型不允许这样做。
- en: The `Either` type allows you to represent data of either one type (`Right`)
    or another (`Left`).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either` 类型允许你表示一种类型（`Right`）或另一种类型（`Left`）的数据。'
- en: '`Either` can be mapped or flat-mapped like `Option`, but it can be on both
    sides (right or left).'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either` 可以像 `Option` 一样进行映射或扁平映射，但它可以在两边（右或左）进行。'
- en: '`Either` can be biased by making one side (`Left`) always represent the same
    type (`RuntimeException`). You call this biased `Either` type `Result`. Success
    is represented by a `Success` subtype and failure by a `Failure` subtype.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either` 可以通过使一边（`Left`）始终代表相同的类型（`RuntimeException`）来产生偏差。你将这种偏差的 `Either`
    类型称为 `Result`。成功由 `Success` 子类型表示，失败由 `Failure` 子类型表示。'
- en: One way to use the `Result` type is to get the wrapped value if it’s present
    or to use a provided default type otherwise.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Result` 类型的一种方法是在存在包装值时获取它，或者在没有时使用提供的默认类型。
- en: The default type, if not a literal, must be lazily evaluated.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认类型，如果不是字面量，必须进行惰性评估。
- en: Composing `Option` (representing optional data) with `Result` (representing
    data or an error) is tedious. This use case is made easier by adding an `Empty`
    subtype to `Result`, making the `Option` type useless.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Option`（表示可选数据）与 `Result`（表示数据或错误）组合是繁琐的。通过向 `Result` 添加一个 `Empty` 子类型，使
    `Option` 类型变得无用，这个用例变得更加简单。
- en: Failures can be mapped if needed, such as to make error messages more explicit.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，可以映射失败，例如使错误消息更加明确。
- en: Several static factory methods simplify `Result` creation from various situations
    like using nullable data, or conditional data, which is represented by data and
    a condition that must be fulfilled.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个静态工厂方法简化了从各种情况创建 `Result` 的过程，例如使用可空数据或条件数据，这些数据由数据和必须满足的条件表示。
- en: Effects can be applied to `Result` (although in a nonfunctional way) through
    the `forEach` method.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过 `forEach` 方法将效果应用于 `Result`（尽管不是以函数式的方式）。
- en: The `forEachOrThrow` method handles the specific cases where an effect must
    be applied if data is present or an exception thrown otherwise.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachOrThrow` 方法处理必须应用效果（如果存在数据）或抛出异常（否则）的特定情况。'
- en: The `forEach` and `forEachOrThrow` methods are specific cases of the more general
    `forEachOrException`. This method applies an effect (if a value is present) and
    returns either `Empty` (if the effect could be applied) or `Success<RuntimeException>`
    (if data was missing).
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach` 和 `forEachOrThrow` 方法是更通用的 `forEachOrException` 方法的特例。该方法应用一个效果（如果存在值），并返回
    `Empty`（如果效果可以应用）或 `Success<RuntimeException>`（如果数据缺失）。'
- en: You can lift functions from `A` to `B` (using the `lift` method) to operate
    from `Result<A>` to `Result<B>`. You can lift functions from `A` to `B` to `C`
    (through the `lift2` method) to a function from `Result<A>` to `Result<B>` to
    `Result<C>`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `lift` 方法将函数从 `A` 升级到 `B`（从 `Result<A>` 操作到 `Result<B>`）。你可以通过 `lift2`
    方法将函数从 `A` 升级到 `B` 到 `C`（通过 `Result<A>` 到 `Result<B>` 到 `Result<C>`）。
- en: You can use the comprehension pattern to compose any number of `Result`s.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用理解模式组合任意数量的 `Result`。
