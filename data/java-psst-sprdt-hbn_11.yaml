- en: 9 Advanced entity association mappings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 高级实体关联映射
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Applying mapping through one-to-one entity associations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一对一实体关联应用映射
- en: Using one-to-many mapping options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一对一映射选项
- en: Creating many-to-many and ternary entity relationships
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多对多和三元实体关系
- en: Working with entity associations with maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射与实体关联的map
- en: In the previous chapter, we demonstrated a unidirectional *many-to-one* association,
    made it bidirectional, and finally enabled transitive state changes with cascading
    options. One reason we are discussing more advanced entity mappings in a separate
    chapter is that we consider quite a few of them rare or at least optional. It’s
    possible to only use component mappings and many-to-one (occasionally *one-to-one*)
    entity associations. You can write a sophisticated application without ever mapping
    a collection! We’ve demonstrated the particular benefits to be gained from collection
    mappings in the previous chapter, and the rules for when a collection mapping
    is appropriate also apply to all the examples in this chapter. Always make sure
    you actually need a collection before attempting a complex collection mapping.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们演示了一个单向的*多对一*关联，使其双向，并最终通过级联选项启用传递状态变化。我们之所以在单独的一章中讨论更高级的实体映射，是因为我们认为其中许多是罕见的，或者至少是可选的。可能只使用组件映射和多对一（偶尔*一对一*）实体关联。您可以在不映射集合的情况下编写复杂的应用程序！我们在上一章中展示了从集合映射中获得的具体好处，并且何时进行集合映射的规则也适用于本章的所有示例。始终确保您确实需要集合，然后再尝试复杂的集合映射。
- en: 'We’ll start with mappings that don’t involve collections: one-to-one entity
    associations.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从不涉及集合的映射开始：一对一实体关联。
- en: Major new features in JPA 2
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2的主要新特性
- en: '*Many-to-one* and *one-to-one* associations may now be mapped with an intermediate
    join/link table.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*多对一*和*一对一*关联现在可以通过中间连接/链接表进行映射。'
- en: Embeddable component classes may have unidirectional associations to entities,
    even many-valued with collections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入组件类可以与实体具有单向关联，即使是有集合的多值关联。
- en: 9.1 One-to-one associations
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 一对一关联
- en: We argued in section 6.2 that the relationships between `User` and `Address`
    (the user has a `billingAddress`, `homeAddress`, and `shippingAddress`) are best
    represented with an `@Embeddable` component mapping. This is usually the simplest
    way to represent one-to-one relationships because the lifecycle is typically dependent
    in such a case. It’s either aggregation or composition in UML.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第6.2节中论证，`User`和`Address`（用户有一个`billingAddress`、`homeAddress`和`shippingAddress`）之间的关系最好用`@Embeddable`组件映射来表示。这通常是表示一对一关系的最简单方式，因为在这种情况下生命周期通常是依赖的。在UML中，这要么是聚合，要么是组合。
- en: What about using a dedicated `ADDRESS` table and mapping both `User` and `Address`
    as entities? One benefit of this model is that shared references are possible—another
    entity class (let’s say `Shipment`) can also have a reference to a particular
    `Address` instance. If a `User` also has a reference to this instance as their
    `shippingAddress`, the `Address` instance has to support shared references and
    needs its own identity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用专门的`ADDRESS`表并将`User`和`Address`都映射为实体的想法如何？这种模型的一个好处是可能存在共享引用——另一个实体类（让我们说`Shipment`）也可以引用特定的`Address`实例。如果一个`User`也将此实例作为他们的`shippingAddress`引用，则`Address`实例必须支持共享引用并需要其自己的标识。
- en: In this case, `User` and `Address` classes have a true one-to-one association.
    Look at the revised class diagram in figure 9.1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`User`和`Address`类有一个真正的一对一关联。请看图9.1中修改后的类图。
- en: '![](../../OEBPS/Images/CH09_F01_Tudose2.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F01_Tudose2.png)'
- en: Figure 9.1 `Address` as an entity with two associations, supporting shared references
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 `Address`作为具有两个关联的实体，支持共享引用
- en: We are working on the CaveatEmptor application, and we need to map the entities
    from figure 9.1\. There are several possible mappings for one-to-one associations.
    The first strategy we’ll consider is a shared primary key value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发CaveatEmptor应用程序，我们需要将图9.1中的实体进行映射。一对一关联有几种可能的映射方式。我们将考虑的第一种策略是共享主键值。
- en: Note To be able to execute the examples from the source code, you’ll first need
    to run the Ch09.sql script.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 要能够执行源代码中的示例，您首先需要运行Ch09.sql脚本。
- en: 9.1.1 Sharing a primary key
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 共享主键
- en: Rows in two tables related by a primary key association share the same primary
    key values. If each user has exactly one shipping address, then the approach would
    be that the `User` has the same primary key value as the (shipping) `Address`.
    The main difficulty with this approach is ensuring that associated instances are
    assigned the same primary key value when the instances are saved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由主键关联关系连接的两个表中的行共享相同的键值。如果每个用户恰好有一个送货地址，那么方法将是 `User` 与（送货）`Address` 具有相同的键值。这种方法的主要困难在于确保在实例保存时分配给关联实例相同的键值。
- en: Before we look at this problem, let’s create the basic mapping. The `Address`
    class is now a standalone entity; it’s no longer a component. The source code
    that follows can be found in the onetoone-sharedprimarykey folder.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这个问题之前，让我们创建基本的映射。`Address` 类现在是一个独立的实体；它不再是组件。以下源代码可以在 onetoone-sharedprimarykey
    文件夹中找到。
- en: Listing 9.1 `Address` class as a standalone entity
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 `Address` 类作为一个独立的实体
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `User` class is also an entity with the `shippingAddress` association property.
    We’ll introduce two new annotations here: `@OneToOne` and `@PrimaryKeyJoinColumn``.`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类也是一个具有 `shippingAddress` 关联属性的实体。在这里，我们将引入两个新的注解：`@OneToOne` 和 `@PrimaryKeyJoinColumn``。'
- en: '`@OneToOne` does what you’d expect: it’s required to mark an entity-valued
    property as a one-to-one association. We’ll require that a `User` has an `Address`
    with the `optional=false` clause. We’ll force the cascading of changes from `User`
    to `Address` with the `cascade = CascadeType.ALL` clause. The `@PrimaryKeyJoinColumn`
    annotation selects the shared primary key strategy we’d like to map.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OneToOne` 做了你期望的事情：它将实体值属性标记为一对一关联。我们将需要 `User` 有一个 `Address`，带有 `optional=false`
    子句。我们将通过 `cascade = CascadeType.ALL` 子句强制从 `User` 到 `Address` 的更改级联。`@PrimaryKeyJoinColumn`
    注解选择了我们想要映射的共享主键策略。'
- en: Listing 9.2 `User` entity and `shippingAddress` association
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 `User` 实体和 `shippingAddress` 关联
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ For the `User`, we don’t declare an identifier generator. As mentioned in
    section 5.2.4, this is one of the rare cases where we’ll use an *application-assigned*
    identifier value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 对于 `User`，我们没有声明标识符生成器。如第 5.2.4 节所述，这是我们很少使用应用程序分配的标识符值的情况之一。
- en: Ⓑ The relationship between `User` and `Address` is one-to-one.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `User` 和 `Address` 之间的关系是一对一。
- en: Ⓒ As usual, we should prefer the lazy-loading strategy, so we override the default
    `FetchType.EAGER` with `LAZY`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 如同往常，我们应该优先考虑延迟加载策略，因此我们覆盖了默认的 `FetchType.EAGER` 为 `LAZY`。
- en: Ⓓ The `optional=false` switch specifies that a `User` must have a `shippingAddress`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `optional=false` 开关指定一个 `User` 必须有一个 `shippingAddress`。
- en: Ⓔ The Hibernate-generated database schema reflects this with a foreign key constraint.
    Any change here must be cascaded to `Address`. The primary key of the `USERS`
    table also has a foreign key constraint referencing the primary key of the `ADDRESS`
    table. See the tables in figure 9.2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ Hibernate 生成的数据库模式通过外键约束反映了这一点。任何更改都必须级联到 `Address`。`USERS` 表的主键也具有引用 `ADDRESS`
    表主键的外键约束。请参阅图 9.2 中的表。
- en: Ⓕ Using `@PrimaryKeyJoinColumn` makes this a unidirectional shared primary key
    one-to-one association mapping, from `User` to `Address`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 使用 `@PrimaryKeyJoinColumn` 使得这成为一个单向共享主键一对一关联映射，从 `User` 到 `Address`。
- en: 'Ⓖ The constructor design weakly enforces this: the public API of the class
    requires an identifier value to create an instance.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 构造函数设计弱化了这一点：类的公共 API 需要一个标识符值来创建一个实例。
- en: '![](../../OEBPS/Images/CH09_F02_Tudose2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F02_Tudose2.png)'
- en: Figure 9.2 The `USERS` table has a foreign key constraint on its primary key.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 `USERS` 表在其主键上有一个外键约束。
- en: 'For some of the examples in this chapter, we’ll need to make a few changes
    to our usual configuration for the tests, as the execution will need to be transactional.
    The `SpringDataConfiguration` class will require more annotations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的一些示例，我们需要对我们的测试配置进行一些更改，因为执行需要是事务性的。`SpringDataConfiguration` 类将需要更多的注解：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ⓐ `@Configuration` specifies that this class declares one or more bean definitions
    to be used by the Spring container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `@Configuration` 指定这个类声明了一个或多个由 Spring 容器使用的 bean 定义。
- en: Ⓑ `@EnableTransactionManagement` enables the transaction management capabilities
    of Spring through annotations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `@EnableTransactionManagement` 通过注解启用 Spring 的事务管理功能。
- en: Ⓒ We’ll need to execute a few operations in a transactional way to test the
    code from this chapter. `@ComponentScan` requires Spring to scan the package provided
    as an argument, and its subpackages, for components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 我们需要以事务方式执行一些操作来测试本章的代码。`@ComponentScan`要求Spring扫描提供的包及其子包以查找组件。
- en: Ⓓ `@EnableJpaRepositories` scans the indicated package to find Spring Data repositories.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `@EnableJpaRepositories`扫描指定的包以查找Spring Data仓库。
- en: 'We’ll isolate the operations against the database in a dedicated `TestService`
    class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在专门的`TestService`类中隔离对数据库的操作：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ The `TestService` class is annotated as `@Service` to allow Spring to automatically
    create a bean, later to be injected in the effective test. Remember that in the
    `SpringDataConfiguration` class, we scan the `com.manning.javapersistence .ch09`
    package and its subpackages for components.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `TestService`类被注解为`@Service`，以允许Spring自动创建一个豆，稍后将其注入到有效的测试中。记住，在`SpringDataConfiguration`类中，我们扫描`com.manning.javapersistence
    .ch09`包及其子包以查找组件。
- en: Ⓑ Inject two repository beans.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 注入两个仓库豆。
- en: Ⓒ Define the `storeLoadEntities` method, annotating it with `@Transactional`.
    The operations we’ll need to execute against the database need to be transactional,
    and we’ll let Spring control this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 定义`storeLoadEntities`方法，并使用`@Transactional`注解。我们需要对数据库执行的操作必须是事务性的，我们将让Spring来控制这一点。
- en: The testing class will differ from the previously presented ones, as it will
    delegate to the `TestService` class. This will allow us to keep the transactional
    operations isolated in their own methods and to call those methods from the test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类将与之前展示的不同，因为它将委托给`TestService`类。这将允许我们将事务性操作隔离在其自己的方法中，并从测试中调用这些方法。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The JPA specification doesn’t include a standardized method for dealing with
    the problem of shared primary key generation. This means we’re responsible for
    setting the identifier value of a `User` instance correctly before we save it
    to the identifier value of the linked `Address` instance:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JPA规范没有包括处理共享主键生成问题的标准化方法。这意味着在我们将`User`实例保存到关联的`Address`实例的标识符值之前，我们必须正确设置`User`实例的标识符值：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ⓐ Persist the `Address`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 持久化`Address`。
- en: Ⓑ Take its generated identifier value and set it on `User`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 取其生成的标识符值并将其设置在`User`上。
- en: Ⓒ Save it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 保存它。
- en: 'There are three problems with the mapping and code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和代码有三个问题：
- en: We have to remember that the `Address` must be saved first and then get its
    identifier value. This is only possible if the `Address` entity has an identifier
    generator that produces values on `save()` before the `INSERT`, as we discussed
    in section 5.2.5\. Otherwise, `someAddress.getId()` returns `null`, and we can’t
    manually set the identifier value of the `User`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须记住，`Address`必须首先保存，然后才能获取其标识符值。这只有在`Address`实体具有在`INSERT`之前在`save()`时产生值的标识符生成器的情况下才可能，正如我们在5.2.5节中讨论的那样。否则，`someAddress.getId()`返回`null`，我们无法手动设置`User`的标识符值。
- en: 'Lazy loading with proxies only works if the association is non-optional. This
    is often a surprise for developers new to JPA. The default for `@OneToOne` is
    `FetchType.EAGER`: when Hibernate or Spring Data JPA using Hibernate loads a `User`,
    it loads the `shippingAddress` right away. Conceptually, lazy loading with proxies
    only makes sense if Hibernate knows that there is a linked `shipping-Address`.
    If the property were nullable, Hibernate would have to check in the database whether
    the property value is `NULL` by querying the `ADDRESS` table. If we have to check
    the database, we might as well load the value right away, because there would
    be no benefit in using a proxy.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当关联是非可选的时，使用代理的延迟加载才有效。这对于刚开始接触JPA的开发者来说通常是一个惊喜。`@OneToOne`的默认值是`FetchType.EAGER`：当Hibernate或Spring
    Data JPA使用Hibernate加载一个`User`时，它会立即加载`shippingAddress`。从概念上讲，只有当Hibernate知道存在一个链接的`shipping-Address`时，使用代理的延迟加载才有意义。如果属性是可空的，Hibernate将不得不通过查询`ADDRESS`表来检查属性值是否为`NULL`。如果我们必须检查数据库，我们不妨立即加载值，因为使用代理将没有好处。
- en: The one-to-one association is unidirectional; sometimes we need bidirectional
    navigation.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一关联是单向的；有时我们需要双向导航。
- en: 'The first problem has no other solution. In the preceding example we are doing
    exactly this: saving the `Address,` getting its primary key, and manually setting
    it as the identifier value of the `User`. This is one of the reasons we should
    always prefer identifier generators capable of producing values before any SQL
    `INSERT`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题没有其他解决方案。在先前的例子中，我们正是这样做的：保存`Address`，获取其主键，并将其手动设置为`User`的标识符值。这也是我们应该始终优先选择能够在任何SQL
    `INSERT`之前产生值的标识符生成器的原因之一。
- en: A `@OneToOne(optional=true)` association doesn’t support lazy loading with proxies.
    This is consistent with the JPA specification. `FetchType.LAZY` is a hint for
    the persistence provider, not a requirement. We could get lazy loading of nullable
    `@OneToOne` with bytecode instrumentation, as you’ll see in section 12.1.3.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OneToOne(optional=true)`关联不支持使用代理的延迟加载。这与JPA规范一致。`FetchType.LAZY`是对持久化提供者的提示，而不是要求。我们可以通过字节码插装获得可空`@OneToOne`的延迟加载，如第12.1.3节所示。'
- en: As for the last problem, if we make the association bidirectional (where the
    `Address` references the `User` and the `User` references the `Address`), we can
    also use a special Hibernate-only identifier generator to help with assigning
    key values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于最后一个问题，如果我们使关联双向（其中`Address`引用`User`，而`User`引用`Address`），我们也可以使用一个仅Hibernate专用的标识符生成器来帮助分配键值。
- en: 9.1.2 The foreign primary key generator
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 外部主键生成器
- en: A bidirectional mapping always requires a `mappedBy` side. We’ll pick the `User`
    side—this is a matter of taste and perhaps other, secondary requirements. (The
    source code that follows can be found in the onetoone-foreigngenerator folder.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 双向映射始终需要一个`mappedBy`端。我们将选择`User`端——这是一个口味和可能的其他次要要求的问题。（随后的源代码可以在`onetoone-foreigngenerator`文件夹中找到。）
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have added the `mappedBy` option, telling Hibernate or Spring Data JPA using
    Hibernate that the lower-level details are now mapped by “the property on the
    other side,” named `user`. As a convenience, we enable `CascadeType.PERSIST`;
    transitive persistence will make it easier to save the instances in the right
    order. When we make the `User` persistent, Hibernate makes the `shippingAddress`
    persistent and generates the identifier for the primary key automatically.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`mappedBy`选项，告诉Hibernate或Spring Data JPA使用Hibernate，现在低级细节由“另一边的属性”映射，命名为`user`。为了方便，我们启用了`CascadeType.PERSIST`；传递性持久化将使按正确顺序保存实例变得更容易。当我们使`User`持久化时，Hibernate会使其`shippingAddress`持久化并自动生成主键标识符。
- en: 'Next, let’s look at the “other side”: the `Address`. We’ll use the `@GenericGenerator`
    on the identifier property to define a special-purpose primary key value generator
    with the Hibernate-only `foreign` strategy. We didn’t mention this generator in
    the overview in section 5.2.5 because the shared primary key one-to-one association
    is its only use case. When persisting an instance of `Address`, this special generator
    grabs the value of the `user` property and takes the identifier value of the referenced
    entity instance, the `User`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看“另一边”：`Address`。我们将在标识符属性上使用`@GenericGenerator`来定义一个具有Hibernate专用`foreign`策略的特殊用途主键值生成器。在5.2.5节概述中我们没有提到这个生成器，因为共享主键一对一关联是其唯一用例。当持久化`Address`实例时，这个特殊的生成器会抓取`user`属性的值并获取引用实体实例的标识符值，即`User`。
- en: Listing 9.3 `Address` has the special foreign key generator
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 `Address`具有特殊的 foreign key 生成器
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ⓐ With the `@GenericGenerator` annotation, when we persist an instance of `Address`,
    this special generator grabs the value of the `user` property and takes the identifier
    value of the referenced entity instance, the `User`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用`@GenericGenerator`注解，当我们持久化`Address`实例时，这个特殊的生成器会抓取`user`属性的值并获取引用实体实例的标识符值，即`User`。
- en: Ⓑ The `@OneToOne` mapping is set to `optional=false`, so an `Address` must have
    a reference to a `User`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `@OneToOne`映射被设置为`optional=false`，因此`Address`必须有一个对`User`的引用。
- en: Ⓒ The `user` property is marked as a shared primary key entity association with
    the `@PrimaryKeyJoinColumn` annotation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `user`属性被标记为具有`@PrimaryKeyJoinColumn`注解的共享主键实体关联。
- en: Ⓓ The public constructors of `Address` now require a `User` instance. The foreign
    key constraint reflecting `optional=false` is now on the primary key column of
    the `ADDRESS` table, as you can see in the schema in figure 9.3.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `Address`的公共构造函数现在需要一个`User`实例。反映`optional=false`的外键约束现在位于`ADDRESS`表的主键列上，如图9.3中的模式所示。
- en: '![](../../OEBPS/Images/CH09_F03_Tudose2.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F03_Tudose2.png)'
- en: Figure 9.3 The `ADDRESS` table has a foreign key constraint on its primary key.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 `ADDRESS` 表在其主键上有一个外键约束。
- en: 'Thanks to this new code, we no longer have to call `address.getId()` or `user.getId()`
    in our unit of work. Storing data is simplified:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这段新代码，我们不再需要在我们的工作单元中调用`address.getId()`或`user.getId()`。存储数据简化了：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ⓐ We must link both sides of a bidirectional entity association. Note that with
    this mapping, we won’t get lazy loading of `User#shippingAddress` (it’s optional/nullable),
    but we can load `Address#user` on demand with proxies (it’s non-optional).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们必须链接双向实体关联的两边。注意，使用这种映射，我们不会得到`User#shippingAddress`的懒加载（它是可选的/可以为null），但我们可以按需使用代理加载`Address#user`（它不是可选的）。
- en: Ⓑ When we persist the user, we’ll get the transitive persistence of `shippingAddress`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 当我们持久化用户时，我们将获得`shippingAddress`的传递性持久化。
- en: Shared primary key one-to-one associations are relatively rare. Instead, we’ll
    often map a “to-one” association with a foreign key column and a unique constraint.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 共享主键的一对一关联相对较少。相反，我们通常会使用外键列和唯一约束来映射“一对一”关联。
- en: 9.1.3 Using a foreign key join column
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 使用外键连接列
- en: 'Instead of sharing a primary key, two rows can have a relationship based on
    a simple additional foreign key column. One table has a foreign key column that
    references the primary key of the associated table. (The source and target of
    this foreign key constraint can even be the same table: we call this a *self-referencing
    relationship*.) The source code that follows can be found in the onetoone-foreignkey
    folder.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 两个行不必共享主键，它们可以根据一个简单的附加外键列建立关系。一个表有一个外键列，它引用相关表的主键。（这个外键约束的源和目标甚至可以是同一个表：我们称之为*自引用关系*。）接下来的源代码可以在`onetoone-foreignkey`文件夹中找到。
- en: Let’s change the mapping for `User#shippingAddress`. Instead of having a shared
    primary key, we’ll now add a `SHIPPINGADDRESS_ID` column in the `USERS` table.
    This column has a `UNIQUE` constraint, so no two users can reference the same
    shipping address. Look at the schema in figure 9.4.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变`User#shippingAddress`的映射。我们不再使用共享主键，而是在`USERS`表中添加一个`SHIPPINGADDRESS_ID`列。这个列有一个`UNIQUE`约束，所以没有两个用户可以引用相同的送货地址。查看图
    9.4 中的模式。
- en: '![](../../OEBPS/Images/CH09_F04_Tudose2.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F04_Tudose2.png)'
- en: Figure 9.4 A one-to-one join column association between the `USERS` and `ADDRESS`
    tables
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 `USERS` 表和 `ADDRESS` 表之间的一对一连接列关联
- en: The `Address` is a regular entity class, like the first one we demonstrated
    in this chapter, in listing 9.1\. The `User` entity class has the `shippingAddress`
    property, implementing this unidirectional association.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`是一个常规的实体类，就像我们在本章中演示的第一个一样，在列表 9.1 中。`User`实体类有`shippingAddress`属性，实现了这个单向关联。'
- en: 'We should enable lazy loading for this `User`–`Address` association. Unlike
    with shared primary keys, we don’t have a problem with lazy loading here: when
    a row of the `USERS` table has been loaded, it contains the value of the `SHIPPINGADDRESS_ID`
    column. Hibernate or Spring Data using Hibernate, therefore, knows whether an
    `ADDRESS` row is present, and a proxy can be used to load the `Address` instance
    on demand.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为这个`User`–`Address`关联启用懒加载。与共享主键不同，这里我们没有懒加载的问题：当`USERS`表的一行被加载时，它包含`SHIPPINGADDRESS_ID`列的值。因此，Hibernate或使用Hibernate的Spring
    Data知道是否存在`ADDRESS`行，并且可以使用代理按需加载`Address`实例。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ⓐ We don’t need any special identifier generators or primary key assignments;
    we’ll make sure the `shippingAddress` is not null.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们不需要任何特殊的标识符生成器或主键分配；我们将确保`shippingAddress`不为空。
- en: Ⓑ Instead of `@PrimaryKeyJoinColumn`, we apply the regular `@JoinColumn`, which
    will default to `SHIPPINGADDRESS_ID`. If you’re more familiar with SQL than JPA,
    it helps to think “foreign key column” every time you see `@JoinColumn` in a mapping.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 我们不使用`@PrimaryKeyJoinColumn`，而是应用常规的`@JoinColumn`，它将默认为`SHIPPINGADDRESS_ID`。如果你比JPA更熟悉SQL，每次你在映射中看到`@JoinColumn`时，都将其视为“外键列”会有所帮助。
- en: In the mapping, we set `optional=false`, so the user must have a shipping address.
    This won’t affect the loading behavior but it is a logical consequence of the
    `unique=true` setting on the `@JoinColumn`. This setting adds a unique constraint
    to the generated SQL schema. If the values of the `SHIPPINGADDRESS_ID` column
    must be unique for all users, only one user could possibly have “no shipping address.”
    Hence, nullable unique columns typically aren’t meaningful.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射中，我们设置`optional=false`，因此用户必须有一个运输地址。这不会影响加载行为，但它是在`@JoinColumn`上的`unique=true`设置的逻辑后果。此设置向生成的SQL模式添加了唯一约束。如果`SHIPPINGADDRESS_ID`列的值对所有用户都必须是唯一的，那么可能只有一个用户没有“运输地址”。因此，可空唯一列通常没有意义。
- en: 'Creating, linking, and storing instances is straightforward:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、链接和存储实例是直接的：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ⓐ Create the link between the user and the address.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 创建用户和地址之间的链接。
- en: Ⓑ When we save `john`, we’ll transitively save the `address`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 当我们保存`john`时，我们将递归地保存`address`。
- en: 'We’ve now completed two basic one-to-one association mappings: the first with
    a shared primary key, and the second with a foreign key reference and a unique
    column constraint. The last option we want to discuss is a bit more exotic: mapping
    a one-to-one association with the help of an additional table.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了两个基本的一对一关联映射：第一个使用共享主键，第二个使用外键引用和唯一列约束。我们想要讨论的最后一个选项稍微有些特别：通过一个额外的表来映射一对一关联。
- en: 9.1.4 Using a join table
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 使用连接表
- en: You’ve probably noticed that nullable columns can be problematic. Sometimes
    a better solution for optional values is to use an intermediate table, which contains
    a row if a link is present and doesn’t if it’s not.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，可空列可能会带来问题。有时，对于可选值来说，使用一个中间表是一个更好的解决方案，如果存在链接，则该表包含一行，如果不存，则不包含。
- en: Let’s consider the `Shipment` entity in CaveatEmptor and discuss its purpose.
    Sellers and buyers interact in CaveatEmptor by starting and bidding on auctions.
    Shipping goods seems outside the scope of the application; the seller and the
    buyer agree on a method of shipment and payment after the auction ends. They can
    do this offline, outside of CaveatEmptor.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑CaveatEmptor中的`Shipment`实体，并讨论其目的。卖家和买家通过在CaveatEmptor中开始和竞标拍卖来互动。运输商品似乎超出了应用程序的范围；拍卖结束后，卖家和买家会就运输和支付方式达成一致。他们可以在CaveatEmptor之外离线完成此事。
- en: On the other hand, we could offer an escrow service in CaveatEmptor. Sellers
    would use this service to create a trackable shipment once the auction ends. The
    buyer would pay the price of the auction item to a trustee (us), and we’d inform
    the seller that the money is available. Once the shipment arrives and the buyer
    accepts it, we’d transfer the money to the seller.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以在CaveatEmptor中提供托管服务。拍卖结束后，卖家将使用此服务创建一个可追踪的运输。买家将拍卖物品的价格支付给受托人（我们），我们会通知卖家资金已可用。一旦运输到达且买家接受，我们将把资金转给卖家。
- en: 'If you’ve ever participated in an online auction of significant value, you’ve
    probably used such an escrow service. But we want more in CaveatEmptor: not only
    will we provide trust services for completed auctions, but we also allow users
    to create trackable and trusted shipments for any deals they make outside an auction,
    outside CaveatEmptor. This scenario calls for a `Shipment` entity with an optional
    one-to-one association to `Item`. The class diagram for this domain model is shown
    in figure 9.5.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经参与过价值重大的在线拍卖，你可能已经使用过这样的托管服务。但我们在CaveatEmptor中希望提供更多：我们不仅将为完成的拍卖提供信任服务，还允许用户为他们在拍卖之外、在CaveatEmptor之外达成的任何交易创建可追踪和可信任的运输。这种情况需要一个具有可选一对一关联到`Item`的`Shipment`实体。该领域模型的类图如图9.5所示。
- en: '![](../../OEBPS/Images/CH09_F05_Tudose2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F05_Tudose2.png)'
- en: Figure 9.5 `Shipment` has an optional link with an auction `Item`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 `Shipment`与拍卖`Item`有一个可选的链接。
- en: Note We briefly considered abandoning the CaveatEmptor example for this section
    because we couldn’t find a natural scenario that requires optional one-to-one
    associations. If this escrow example seems contrived, consider the equivalent
    problem of assigning employees to workstations. This is also an optional one-to-one
    relationship.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们简要考虑放弃本节的CaveatEmptor示例，因为我们找不到一个需要可选一对一关联的自然场景。如果这个托管示例看起来很牵强，请考虑将员工分配到工作站的问题。这也是一个可选的一对一关系。
- en: In the database schema, we’ll add an intermediate link table called `ITEM_SHIPMENT`.
    A row in this table represents a `Shipment` made in the context of an auction.
    Figure 9.6 shows the tables.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库模式中，我们将添加一个名为 `ITEM_SHIPMENT` 的中间链接表。这个表中的一行代表在拍卖背景下进行的运输。图9.6显示了这些表。
- en: '![](../../OEBPS/Images/CH09_F06_Tudose2.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F06_Tudose2.png)'
- en: Figure 9.6 The intermediate table links items and shipments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 中间表连接了项目和运输。
- en: 'Note how the schema enforces uniqueness and the one-to-one relationship: the
    primary key of `ITEM_SHIPMENT` is the `SHIPMENT_ID` column, and the `ITEM_ID`
    column is unique. An item can therefore be in only one shipment. Of course, that
    also means a shipment can contain only one item.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模式如何强制唯一性和一对一关系：`ITEM_SHIPMENT` 的主键是 `SHIPMENT_ID` 列，而 `ITEM_ID` 列是唯一的。因此，一个项目只能在一个运输中。当然，这也意味着一个运输只能包含一个项目。
- en: We’ll map this model with a `@OneToOne` annotation in the `Shipment` entity
    class. The source code that follows can be found in the onetoone-jointable folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Shipment` 实体类中的 `@OneToOne` 注解来映射此模型。下面的源代码可以在 onetoone-jointable 文件夹中找到。
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Ⓐ Lazy loading has been enabled, with a twist: when Hibernate or Spring Data
    JPA using Hibernate loads a `Shipment`, it queries both the `SHIPMENT` and the
    `ITEM_ SHIPMENT` join table. Hibernate has to know if a link to an `Item` is present
    before it can use a proxy. It does that in one outer join SQL query, so we won’t
    see any extra SQL statements. If there is a row in `ITEM_SHIPMENT`, Hibernate
    uses an `Item` placeholder.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 懒加载已被启用，但有一个转折：当Hibernate或Spring Data JPA使用Hibernate加载一个 `Shipment` 时，它会查询
    `SHIPMENT` 和 `ITEM_ SHIPMENT` 连接表。Hibernate在使用代理之前必须知道是否存在对 `Item` 的链接。它通过一个外连接SQL查询来完成，所以我们不会看到任何额外的SQL语句。如果
    `ITEM_SHIPMENT` 中有一行，Hibernate将使用一个 `Item` 代理。
- en: Ⓑ The `@JoinTable` annotation is new; we always have to specify the name of
    the intermediate table. This mapping effectively hides the join table; there is
    no corresponding Java class. The annotation defines the column names of the `ITEM_SHIPMENT`
    table.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `@JoinTable` 注解是新的；我们总是必须指定中间表的名字。这种映射有效地隐藏了连接表；没有对应的Java类。注解定义了 `ITEM_SHIPMENT`
    表的列名。
- en: Ⓒ The join column is `SHIPMENT_ID` (it would default to `ID`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 连接列是 `SHIPMENT_ID`（默认为 `ID`）。
- en: Ⓓ The inverse join column is `ITEM_ID` (it would default to `AUCTION_ID`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 反向连接列是 `ITEM_ID`（默认为 `AUCTION_ID`）。
- en: Ⓔ Hibernate generates the `UNIQUE` constraint on the `ITEM_ID` column in the
    schema. Hibernate also generates the appropriate foreign key constraints on the
    columns of the join table.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ Hibernate在模式中生成 `UNIQUE` 约束在 `ITEM_ID` 列上。Hibernate还在连接表的列上生成适当的外键约束。
- en: 'Here we store a `Shipment` without `Item`s and another linked to a single `Item`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们存储了一个没有 `Item` 的 `Shipment` 和另一个与单个 `Item` 链接的 `Shipment`：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This completes our discussion of one-to-one association mappings. To summarize,
    you should use a shared primary key association if one of the two entities is
    always stored before the other and can act as the primary key source. Use a foreign
    key association in all other cases, or a hidden intermediate join table when the
    one-to-one association is optional.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对一对一关联映射的讨论。总结来说，如果两个实体中有一个总是存储在另一个之前并且可以作为主键源，则应使用共享主键关联。在其他所有情况下，使用外键关联，或者当一对一关联是可选的时候，使用隐藏的中间连接表。
- en: We’ll now focus on plural, or *many-valued*, entity associations, beginning
    with some advanced options for one-to-many.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将关注复数或*多值*实体关联，从一对一的一些高级选项开始。
- en: 9.2 One-to-many associations
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 一对多关联
- en: A *plural entity association* is, by definition, a collection of entity references.
    We mapped one of these, a one-to-many association, in section 8.3.2\. One-to-many
    associations are the most important kind of entity association involving a collection.
    We’ll go so far as to discourage the use of more complex association styles when
    a simple bidirectional many-to-one or one-to-many will do the job.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，*复数实体关联*是一组实体引用。我们在第8.3.2节中映射了其中之一，即一对一关联。一对多关联是涉及集合的最重要的一种实体关联。当简单的一对多或双向多对一足以完成任务时，我们将劝阻使用更复杂的关联样式。
- en: Also, remember that you don’t have to map any collection of entities if you
    don’t want to; you can always write an explicit query instead of direct access
    through iteration. If you decide to map collections of entity references, you
    have a few options, and we’ll analyze some more complex situations now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，如果你不想映射任何实体集合，你完全可以这样做；你总是可以写一个显式查询而不是通过迭代直接访问。如果你决定映射实体引用集合，你有一些选择，我们现在将分析一些更复杂的情况。
- en: 9.2.1 Considering one-to-many bags
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 考虑一对多袋
- en: So far, we have only seen a `@OneToMany` on a `Set`, but it’s possible to use
    a bag mapping for a bidirectional one-to-many association. Why would we do this?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了在 `Set` 上的 `@OneToMany`，但我们可以为双向一对多关联使用袋映射。我们为什么要这样做呢？
- en: Bags have the most efficient performance characteristics of all the collections
    we can use for a bidirectional one-to-many entity association. By default, collections
    in Hibernate are loaded when they’re accessed for the first time in the application.
    Because a bag doesn’t have to maintain the index of its elements (like a list)
    or check for duplicate elements (like a set), we can add new elements to the bag
    without triggering the loading. This is an important feature if we’re going to
    map a possibly large collection of entity references.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 袋具有所有可用于双向一对多实体关联的集合中最有效的性能特征。默认情况下，Hibernate 中的集合在第一次访问时加载。因为袋不需要维护其元素的索引（如列表）或检查重复元素（如集合），所以我们可以向袋中添加新元素而不触发加载。如果我们打算映射可能很大的实体引用集合，这是一个重要的特性。
- en: On the other hand, we can’t eager-fetch two collections of bag type simultaneously,
    as the generated `SELECT` queries are unrelated and need to be kept separately.
    This might happen if `bids` and `images` of an `Item` were one-to-many bags, for
    example. This is no big loss, because fetching two collections simultaneously
    always results in a Cartesian product; we want to avoid this kind of operation,
    whether the collections are bags, sets, or lists. We’ll come back to fetching
    strategies in chapter 12\. In general, we’d say that a bag is the best inverse
    collection for a one-to-many association if it is mapped as a `@OneToMany(mappedBy
    = "...")`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们不能同时 eager-fetch 两个袋类型集合，因为生成的 `SELECT` 查询是无关的，需要分别保存。例如，如果 `Item` 的
    `bids` 和 `images` 是一对多袋，这种情况可能会发生。这并不是什么大损失，因为同时获取两个集合总是会产生笛卡尔积；我们想要避免这种操作，无论集合是袋、集合还是列表。我们将在第
    12 章中回到获取策略。一般来说，如果我们把袋映射为 `@OneToMany(mappedBy = "...")`，那么袋是一个一对多关联的最佳反向集合。
- en: To map our bidirectional one-to-many association as a bag, we have to replace
    the type of the `bids` collection in the `Item` entity with a `Collection` and
    an `ArrayList` implementation. The mapping for the association between `Item`
    and `Bid` remains essentially unchanged. (The source code that follows can be
    found in the onetomany-bag folder.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的双向一对多关联映射为袋，我们必须将 `Item` 实体中 `bids` 集合的类型替换为 `Collection` 和 `ArrayList`
    实现。`Item` 和 `Bid` 之间的关联映射基本上保持不变。（后续的源代码可以在 onetomany-bag 文件夹中找到。）
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Bid` side with its `@ManyToOne` (which is the “mapped by” side) and even
    the tables are the same as in section 8.3.1.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与其 `@ManyToOne`（即“mapped by”侧）以及表格相同的 `Bid` 侧。
- en: 'A bag also allows duplicate elements, which a set does not:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合允许重复元素，而集合则不允许：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It turns out that isn’t relevant in this case because *duplicate* means we’ve
    added a particular reference to the same `Bid` instance several times We wouldn’t
    do this in our application code. Even if we added the same reference several times
    to this collection, though, Hibernate or Spring Data JPA using Hibernate would
    ignore it—there is no persistent effect. The side relevant for updates of the
    database is the `@ManyToOne`, and the relationship is already “mapped by” that
    side. When we load the `Item`, the collection doesn’t contain the duplicate:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在这种情况下这不相关，因为 *重复* 意味着我们已经将特定的引用添加到同一个 `Bid` 实例中多次。我们不会在我们的应用程序代码中这样做。即使我们多次将相同的引用添加到这个集合中，Hibernate
    或使用 Hibernate 的 Spring Data JPA 也会忽略它——没有持久化效果。与数据库更新相关的方面是 `@ManyToOne`，关系已经由那一侧“映射”。当我们加载
    `Item` 时，集合不包含重复项：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As mentioned previously, the advantage of bags is that the collection doesn’t
    have to be initialized when we add a new element:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，袋的优势在于当我们添加新元素时，集合不需要初始化：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ⓐ This code example triggers one SQL `SELECT` to load the Item. Hibernate still
    initializes and returns an `Item` proxy with a `SELECT` as soon as we call `item.addBid()`.
    But as long as we don’t iterate the `Collection`, no more queries are necessary,
    and an `INSERT` for the new `Bid` will be made without loading all the bids. If
    the collection is a `Set` or a `List`, Hibernate loads all the elements when we
    add another element.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 这个代码示例触发一个SQL `SELECT`来加载`Item`。每当调用`item.addBid()`时，Hibernate都会立即初始化并返回一个带有`SELECT`的`Item`代理。但只要我们不迭代`Collection`，就不需要更多的查询，并且会为新的`Bid`执行一个`INSERT`操作，而不需要加载所有出价。如果集合是`Set`或`List`，当添加另一个元素时，Hibernate会加载所有元素。
- en: We’ll now change the collection to a persistent `List`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将集合更改为持久`List`。
- en: 9.2.2 Unidirectional and bidirectional list mappings
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 单向和双向列表映射
- en: 'If we need a real list to hold the position of the elements in a collection,
    we have to store that position in an additional column. For a one-to-many mapping,
    this also means we should change the `Item#bids` property to `List` and initialize
    the variable with an `ArrayList`. This will be a unidirectional mapping: there
    will be no other “mapped by” side. The `Bid` will not have a `@ManyToOne` property.
    For persistent list indexes, we’ll use the annotation `@OrderColumn`. (The source
    code that follows can be found in the onetomany-list folder.)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个真正的列表来保存集合中元素的位置，我们必须在额外的列中存储该位置。对于一对一映射，这也意味着我们应该将`Item#bids`属性更改为`List`并使用`ArrayList`初始化变量。这将是一个单向映射：将没有其他“由...映射”的一侧。`Bid`将没有`@ManyToOne`属性。对于持久列表索引，我们将使用`@OrderColumn`注解。（随后的源代码可以在`onetomany-list`文件夹中找到。）
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Ⓐ As mentioned, this is a unidirectional mapping: there is no other “mapped
    by” side. The `Bid` doesn’t have a `@ManyToOne` property. The `@OrderColumn` annotation
    will set the name of the index column to be `BID_POSITION`. Otherwise, it would
    default to `BIDS_ORDER`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 如前所述，这是一个单向映射：没有其他“由...映射”的一侧。`Bid`没有`@ManyToOne`属性。`@OrderColumn`注解将索引列的名称设置为`BID_POSITION`。否则，它将默认为`BIDS_ORDER`。
- en: Ⓑ As usual, we should make the column `NOT NULL`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 如同往常，我们应该使列`NOT NULL`。
- en: The database view of the `BID` table, with the join and order columns, is shown
    in figure 9.7.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`BID`表的数据库视图，包括连接和排序列，如图9.7所示。'
- en: '![](../../OEBPS/Images/CH09_F07_Tudose2.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F07_Tudose2.png)'
- en: Figure 9.7 The `BID` table contains the `ITEM_ID` (join column) and `BID_POSITION`
    (order column).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 `BID`表包含`ITEM_ID`（连接列）和`BID_POSITION`（排序列）。
- en: The stored index of each collection starts at zero and is contiguous (there
    are no gaps). Hibernate or Spring Data JPA using Hibernate will execute potentially
    many SQL statements when we add, remove, and shift elements of the `List`. We
    talked about this performance issue in section 8.1.6.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合的存储索引从零开始，并且是连续的（没有间隔）。当我们添加、删除和移动`List`的元素时，Hibernate将执行可能很多的SQL语句。我们已经在第8.1.6节中讨论了这个问题。
- en: 'Let’s make this mapping bidirectional, with a `@ManyToOne` property on the
    `Bid` entity:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个映射改为双向的，在`Bid`实体上添加一个`@ManyToOne`属性：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ⓐ The `Item#bids` collection is no longer read-only because Hibernate now has
    to store the index of each element. If the `Bid#item` side was the owner of the
    relationship, Hibernate would ignore the collection when storing data and not
    write the element indexes. We have to map the `@JoinColumn` twice and then disable
    writing on the `@ManyToOne` side with `updatable=false` and `insertable=false`.
    Hibernate now considers the collection side when storing data, including the index
    of each element. The `@ManyToOne` is effectively read-only, as it would be if
    it had a `mappedBy` attribute.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `Item#bids`集合不再是只读的，因为Hibernate现在必须存储每个元素的索引。如果`Bid#item`端是关系的所有者，Hibernate将忽略集合在存储数据时，并且不会写入元素索引。我们必须将`@JoinColumn`映射两次，然后使用`updatable=false`和`insertable=false`禁用`@ManyToOne`端的写入。现在，Hibernate在存储数据时考虑集合端，包括每个元素的索引。`@ManyToOne`实际上是只读的，就像它有`mappedBy`属性一样。
- en: 'You probably expected different code—maybe `@ManyToOne(mappedBy="bids")` and
    no additional `@JoinColumn` annotation. But `@ManyToOne` doesn’t have a `mappedBy`
    attribute: it’s always the “owning” side of the relationship. We’d have to make
    the other side, `@OneToMany`, the `mappedBy` side.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望不同的代码——可能是`@ManyToOne(mappedBy="bids")`和没有额外的`@JoinColumn`注解。但是`@ManyToOne`没有`mappedBy`属性：它总是关系的“拥有”端。我们必须将另一端，`@OneToMany`，作为`mappedBy`端。
- en: Finally, the Hibernate schema generator always relies on the `@JoinColumn` of
    the `@ManyToOne` side. Hence, if we want the correct schema produced, we should
    add the `@NotNull` on this side or declare `@JoinColumn(nullable=false)`. The
    generator ignores the `@OneToMany` side and its join column if there is a `@ManyToOne`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Hibernate模式生成器始终依赖于`@ManyToOne`侧的`@JoinColumn`。因此，如果我们想要生成正确的模式，我们应该在这侧添加`@NotNull`或声明`@JoinColumn(nullable=false)`。如果存在`@ManyToOne`，生成器会忽略`@OneToMany`侧及其连接列。
- en: 'In a real application, we wouldn’t map this association with a `List`. Preserving
    the order of elements in the database seems like a common use case, but it isn’t
    actually very useful: sometimes we’ll want to show a list with the highest or
    newest bid first, or only show bids made by a certain user, or show bids made
    within a certain time range. None of these operations requires a persistent list
    index. As mentioned in section 3.2.4, it’s best to avoid storing a display order
    in the database, as the display order may change frequently; keep it flexible
    with queries instead of using hardcoded mappings. Furthermore, maintaining the
    index when the application removes, adds, or shifts elements in a list can be
    expensive and may trigger many SQL statements. Map the foreign key join column
    with `@ManyToOne`, and drop the collection.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们不会用`List`来映射这个关联。在数据库中保留元素顺序似乎是一个常见的用例，但实际上并不太有用：有时我们可能希望首先显示最高或最新的出价列表，或者只显示某个特定用户的出价，或者显示在一定时间范围内的出价。这些操作都不需要持久化的列表索引。如第3.2.4节所述，最好避免在数据库中存储显示顺序，因为显示顺序可能会频繁更改；而是通过查询保持其灵活性，而不是使用硬编码的映射。此外，当应用程序在列表中删除、添加或移动元素时，维护索引可能会很昂贵，并可能触发许多SQL语句。使用`@ManyToOne`映射外键连接列，并删除集合。
- en: 'Next we’ll work on one more scenario with a one-to-many relationship: an association
    mapped to an intermediate join table.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将处理另一个具有一对多关系的场景：一个关联映射到中间连接表。
- en: 9.2.3 Optional one-to-many with a join table
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 使用连接表的可选一对多
- en: 'A useful addition to the `Item` class is a `buyer` property. We can then call
    `someItem .getBuyer()` to access the `User` who made the winning bid. If it’s
    made bidirectional, this association will also help us render a screen that shows
    all the auctions a particular user has won: we could call `someUser.getBoughtItems()`
    instead of writing a query.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`类的一个有用补充是`buyer`属性。然后我们可以调用`someItem.getBuyer()`来访问出价获胜的`User`。如果将其双向化，这个关联也将帮助我们渲染一个显示特定用户赢得的所有拍卖的屏幕：我们可以调用`someUser.getBoughtItems()`而不是编写查询。'
- en: From the point of view of the `User` class, the association is one-to-many.
    Figure 9.8 shows the classes and their relationship.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从`User`类的角度来看，这个关联是一对多。图9.8显示了类及其关系。
- en: '![](../../OEBPS/Images/CH09_F08_Tudose2.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F08_Tudose2.png)'
- en: Figure 9.8 The `User–Item` “bought” relationship
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 `User-Item`“购买”关系
- en: Why is this association different from the one between `Item` and `Bid`? The
    multiplicity `0..*` in UML indicates that the reference is optional. This doesn’t
    influence the Java domain model much, but it has consequences for the underlying
    tables. We expect a `BUYER_ID` foreign key column in the `ITEM` table, but now
    the column has to be nullable because a user may not have bought a particular
    `Item` (as long as the auction is still running).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个关联与`Item`和`Bid`之间的关联不同？UML中的多重度`0..*`表示引用是可选的。这不会对Java领域模型产生太大影响，但它对底层表有影响。我们期望在`ITEM`表中有一个`BUYER_ID`外键列，但现在这个列必须是可空的，因为用户可能没有购买特定的`Item`（只要拍卖仍在进行中）。
- en: 'We could accept that the foreign key column can be `NULL` and apply additional
    constraints: “Allowed to be `NULL` only if the auction end time hasn’t been reached
    or if no bid has been made.” However, we always try to avoid nullable columns
    in a relational database schema. Unknown information degrades the quality of the
    data we store. Tuples represent propositions that are true, and we can’t assert
    something we don’t know. Moreover, in practice, many developers and DBAs don’t
    create the right constraints and rely on often buggy application code to provide
    data integrity.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以接受外键列可以是`NULL`，并应用额外的约束：“只有在拍卖结束时间未到达或没有出价的情况下才允许为`NULL`。”然而，我们总是尽量避免在关系数据库模式中存在可空列。未知信息会降低我们存储的数据质量。元组代表真实的命题，我们不能断言我们不知道的事情。此外，在实践中，许多开发人员和数据库管理员没有创建正确的约束，而是依赖于经常出现错误的程序代码来提供数据完整性。
- en: An optional entity association, be it one-to-one or one-to-many, is best represented
    in an SQL database with a join table. Figure 9.9 shows an example schema.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选的实体关联，无论是一对一还是一对多，在SQL数据库中最好通过连接表来表示。图9.9显示了示例模式。
- en: '![](../../OEBPS/Images/CH09_F09_Tudose2.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F09_Tudose2.png)'
- en: Figure 9.9 An intermediate table links users and items.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 一个中间表连接用户和物品。
- en: 'We added a join table earlier in this chapter for a one-to-one association.
    To guarantee the multiplicity of one-to-one, we applied a unique constraint on
    a foreign key column of the join table. In the current case, we have a one-to-many
    multiplicity, so only the `ITEM_ID` primary key column has to be unique: only
    one `User` can buy any given `Item` once. The `BUYER_ID` column isn’t unique because
    a `User` can buy many `Item`s. (The source code that follows can be found in the
    `onetomany-jointable` folder.)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早期添加了一个连接表用于一对一关联。为了保证一对一的多重性，我们在连接表的外键列上应用了唯一约束。在当前情况下，我们有一个一对多的多重性，因此只有`ITEM_ID`主键列必须是唯一的：只有一个`User`可以购买任何给定的`Item`一次。`BUYER_ID`列不是唯一的，因为一个`User`可以购买多个`Item`。（随后的源代码可以在`onetomany-jointable`文件夹中找到。）
- en: 'The mapping of the `User#boughtItems` collection is simple:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`User#boughtItems`集合的映射很简单：'
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the usual read-only side of a bidirectional association, with the actual
    mapping to the schema on the “mapped by” side, the `Item#buyer`. It will be a
    clean, optional one-to-many/many-to-one relationship.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是双向关联的只读一侧，实际映射到“由...映射”侧的模式，即`Item#buyer`。这将是一个干净、可选的一对多/多对一关系。
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ⓐ If an `Item` hasn’t been bought, there is no corresponding row in the `ITEM_BUYER`
    join table. The relationship will thus be optional. The join column is named `ITEM_ID`
    (it would default to `ID`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 如果一个`Item`没有被购买，`ITEM_BUYER`连接表中就没有对应的行。因此，这种关系将是可选的。连接列名为`ITEM_ID`（它将默认为`ID`）。
- en: Ⓑ The inverse join column will default to `BUYER_ID`, and it is not nullable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 反向连接列将默认为`BUYER_ID`，且不可为空。
- en: 'We don’t have any problematic nullable columns in our schema. Still, we should
    write a procedural constraint and a trigger that runs on `INSERT` for the `ITEM_BUYER`
    table: “Only allow insertion of a buyer if the auction end time for the given
    item has been reached and the user made the winning bid.”'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式中没有任何有问题的可空列。尽管如此，我们应该为`ITEM_BUYER`表编写一个过程约束和一个在`INSERT`上运行的触发器：“只有当给定物品的拍卖结束时间到达且用户做出了获胜出价时，才允许插入买家。”
- en: The next example is our last with one-to-many associations. So far, you’ve seen
    one-to-many associations from an entity to another entity. An embeddable component
    class may also have a one-to-many association to an entity, and this is what we’ll
    deal with now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子是我们最后一个关于一对多关联的例子。到目前为止，你已经看到了从一个实体到另一个实体的多对一关联。一个嵌入式组件类也可以有一个到实体的多对一关联，这正是我们现在要处理的。
- en: 9.2.4 One-to-many association in an embeddable class
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 嵌入式类中的一对多关联
- en: 'Consider again the embeddable component mapping we’ve been repeating for a
    few chapters: the `Address` of a `User`. We’ll now extend this example by adding
    a one-to-many association from `Address` to `Shipment`: a collection called `deliveries`.
    Figure 9.10 shows the UML class diagram for this model.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑我们重复了几章的嵌入式组件映射：`User`的`Address`。现在我们将通过添加从`Address`到`Shipment`的一对多关联来扩展这个例子：一个名为`deliveries`的集合。图9.10显示了该模型的UML类图。
- en: '![](../../OEBPS/Images/CH09_F10_Tudose2.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F10_Tudose2.png)'
- en: Figure 9.10 The one-to-many relationship from `Address` to `Shipment`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 从`Address`到`Shipment`的一对多关系
- en: The `Address` is an `@Embeddable` class, not an entity. It can own a unidirectional
    association to an entity; here, it’s a one-to-many multiplicity to `Shipment`.
    We’ll look at an embeddable class having a many-to-one association with an entity
    in the next section. (The source code that follows can be found in the onetomany-embeddable
    folder.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`是一个`@Embeddable`类，不是一个实体。它可以拥有一个到实体的单向关联；这里，它是一个到`Shipment`的一对多多重性。我们将在下一节中查看一个与实体有多个到一关联的嵌入式类。（随后的源代码可以在`onetomany-embeddable`文件夹中找到。）'
- en: 'The `Address` class has a `Set<Shipment>` representing this association:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`类有一个`Set<Shipment>`来表示这个关联：'
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ⓐ The first mapping strategy for this association is with a `@JoinColumn` named
    `DELIVERY_ADDRESS_USER_ID` (it would default to `DELIVERIES_ID`).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 这个关联的第一个映射策略是与一个名为`@JoinColumn`的`DELIVERY_ADDRESS_USER_ID`（它将默认为`DELIVERIES_ID`）。
- en: This foreign key-constrained column is in the `SHIPMENT` table, as you can see
    in fig-ure 9.11.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个外键约束列位于 `SHIPMENT` 表中，如图 9.11 所示。
- en: '![](../../OEBPS/Images/CH09_F11_Tudose2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F11_Tudose2.png)'
- en: Figure 9.11 A primary key in the `USERS` table links the `USERS` and `SHIPMENT`
    tables.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 `USERS` 表中的主键将 `USERS` 和 `SHIPMENT` 表链接起来。
- en: 'Embeddable components don’t have their own identifier, so the value in the
    foreign key column is the value of a `User`’s identifier, which embeds the `Address`.
    Here we also declare the join column `nullable` `=` `false`, so a `Shipment` must
    have an associated delivery address. Of course, bidirectional navigation isn’t
    possible: the `Shipment` can’t have a reference to the `Address` because embedded
    components can’t have shared references.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入组件没有自己的标识符，因此外键列中的值是 `User` 标识符的值，它嵌入 `Address`。在这里，我们也声明连接列 `nullable` `=`
    `false`，因此 `Shipment` 必须有一个相关的配送地址。当然，双向导航是不可能的：`Shipment` 不能引用 `Address`，因为嵌入组件不能有共享引用。
- en: If the association is optional and we don’t want a nullable column, we can map
    the association to an intermediate join/link table, as shown in figure 9.12.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关联是可选的，并且我们不希望有可空列，我们可以将关联映射到一个中间连接/链接表，如图 9.12 所示。
- en: '![](../../OEBPS/Images/CH09_F12_Tudose2.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F12_Tudose2.png)'
- en: Figure 9.12 Using an intermediate table between `USERS` and `SHIPMENT` to represent
    an optional association
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 使用 `USERS` 和 `SHIPMENT` 之间的中间表来表示可选关联
- en: The mapping of the collection in `Address` now uses a `@JoinTable` instead of
    a `@JoinColumn`. (The source code that follows can be found in the onetomany-embeddable-jointable
    folder.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address` 集合的映射现在使用 `@JoinTable` 而不是 `@JoinColumn`。（后续的源代码可以在 onetomany-embeddable-jointable
    文件夹中找到。）'
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ⓐ The name of the join table will be `DELIVERIES` (it would otherwise default
    to `USERS_SHIPMENT`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 连接表的名称将是 `DELIVERIES`（否则默认为 `USERS_SHIPMENT`）。
- en: Ⓑ The name of the join column will be `USER_ID` (it would otherwise default
    to `USERS_ID`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 连接列的名称将是 `USER_ID`（否则默认为 `USERS_ID`）。
- en: Ⓒ The name of the inverse join column will be `SHIPMENT_ID` (it would otherwise
    default to `SHIPMENTS_ID`).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 反向连接列的名称将是 `SHIPMENT_ID`（否则默认为 `SHIPMENTS_ID`）。
- en: Note that if we declare neither `@JoinTable` nor `@JoinColumn`, the `@OneToMany`
    in an embeddable class defaults to a join table strategy.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们既没有声明 `@JoinTable` 也没有声明 `@JoinColumn`，则嵌入类中的 `@OneToMany` 默认为连接表策略。
- en: From within the owning entity class, we can override property mappings of an
    embedded class with `@AttributeOverride`, as demonstrated in section 6.2.3\. If
    we want to override the join table or column mapping of an entity association
    in an embeddable class, we can use `@AssociationOverride` in the owning entity
    class instead. We can’t, however, switch the mapping strategy; the mapping in
    the embeddable component class decides whether a join table or join column is
    used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有实体类内部，我们可以使用 `@AttributeOverride` 覆盖嵌入类的属性映射，如 6.2.3 节中所示。如果我们想覆盖嵌入类中实体关联的连接表或列映射，我们可以在拥有实体类中使用
    `@AssociationOverride`。然而，我们无法切换映射策略；嵌入组件类中的映射决定是否使用连接表或连接列。
- en: A join table mapping is, of course, also applicable in true *many-to-many* mappings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 连接表映射当然也适用于真正的 *多对多* 映射。
- en: 9.3 Many-to-many and ternary associations
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 多对多和三元关联
- en: The association between `Category` and `Item` is a *many-to-many* association,
    as you can see in figure 9.13\. In a real system, we may not have a many-to-many
    association—our experience is that there is almost always other information that
    must be attached to each link between associated instances. Some examples are
    the timestamp when an `Item` was added to a `Category`, and the `User` responsible
    for creating the link. We’ll expand the example later in this section to cover
    such cases, but we’ll start with a regular and simpler many-to-many association.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category` 和 `Item` 之间的关联是一个 *多对多* 关联，如图 9.13 所示。在一个真实系统中，我们可能没有多对多关联——我们的经验是，几乎总是有其他信息必须附加到关联实例之间的每个链接上。一些例子是
    `Item` 被添加到 `Category` 时的戳记，以及创建链接的 `User`。我们将在本节稍后扩展示例以涵盖此类情况，但我们将从一个常规和更简单的多对多关联开始。'
- en: '![](../../OEBPS/Images/CH09_F13_Tudose2.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F13_Tudose2.png)'
- en: Figure 9.13 A many-to-many association between `Category` and `Item`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 `Category` 和 `Item` 之间的多对多关联
- en: 9.3.1 Unidirectional and bidirectional many-to-many associations
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 单向和双向多对多关联
- en: A join table in the database represents a regular many-to-many association,
    which some developers also call a *link table* or *association table*. Figure
    9.14 shows a many-to-many relationship with a link table.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的连接表代表了一个常规的多对多关联，一些开发者也将其称为 *链接表* 或 *关联表*。图 9.14 展示了一个带有链接表的多对多关系。
- en: '![](../../OEBPS/Images/CH09_F14_Tudose2.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F14_Tudose2.png)'
- en: Figure 9.14 `CategorizedItem` is the link between `Category` and `Item`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 `CategorizedItem` 是 `Category` 和 `Item` 之间的链接。
- en: The `CATEGORY_ITEM` link table has two columns, both with foreign key constraints
    referencing the `CATEGORY` and `ITEM` tables, respectively. Its primary key is
    a composite key of both columns. We can only link a particular `Category` and
    `Item` once, but we can link the same item to several categories. The source code
    that follows can be found in the `manytomany-bidirectional` folder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`CATEGORY_ITEM` 链接表有两列，这两列分别通过外键约束引用 `CATEGORY` 和 `ITEM` 表。它的主键是这两列的复合键。我们只能将特定的
    `Category` 和 `Item` 链接一次，但我们可以将相同的项链接到多个类别。下面的源代码可以在 `manytomany-bidirectional`
    文件夹中找到。'
- en: 'In JPA, we map many-to-many associations with `@ManyToMany` on a collection:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JPA 中，我们使用 `@ManyToMany` 注解在集合上映射多对多关联：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As usual, we can enable `CascadeType.PERSIST` to make it easier to save data.
    When we reference a new `Item` from the collection, Hibernate or Spring Data JPA
    using Hibernate makes it persistent. Let’s make this association bidirectional
    (we don’t have to if we don’t need to):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们可以启用 `CascadeType.PERSIST` 以便更容易保存数据。当我们从集合中引用新的 `Item` 时，Hibernate 或使用
    Hibernate 的 Spring Data JPA 会使其持久化。让我们使这个关联双向（如果我们不需要，我们不必这样做）：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As in any bidirectional mapping, one side is “mapped by” the other side. The
    `Item#categories` collection is effectively read-only; Hibernate will analyze
    the content of the `Category#items` side when storing data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何双向映射中，一方是“由”另一方“映射”的。`Item#categories` 集合实际上是只读的；Hibernate 将在存储数据时分析 `Category#items`
    方的内容。
- en: 'Next we’ll create two categories and two items and link them with many-to-many
    multiplicity:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个类别和两个项目，并以多对多的方式将它们链接起来：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because we enabled transitive persistence, saving the categories makes the
    entire network of instances persistent. On the other hand, the cascading options
    `ALL`, `REMOVE`, and orphan deletion (discussed in section 8.3.3) aren’t meaningful
    for many-to-many associations. This is a good point for testing whether we understand
    entities and value types. Try to come up with reasonable answers as to why these
    cascading types don’t make sense for a many-to-many association. Hint: Think about
    what may happen if deleting a record will automatically delete a related record.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们启用了传递性持久化，保存类别会使整个实例网络持久化。另一方面，级联选项 `ALL`、`REMOVE` 和孤儿删除（在第 8.3.3 节中讨论）对于多对多关联来说没有意义。这是一个测试我们是否理解实体和价值类型的好点。试着想出合理的答案，解释为什么这些级联类型对于多对多关联来说没有意义。提示：考虑如果删除一条记录会自动删除相关记录可能会发生什么。
- en: Could we use a `List` instead of a `Set`, or even a bag? The `Set` matches the
    database schema perfectly because there can be no duplicate links between `Category`
    and `Item`. A bag implies duplicate elements, so we would need a different primary
    key for the join table. Hibernate’s proprietary `@CollectionId` annotation can
    provide this, as demonstrated in section 8.1.5\. However, one of the alternative
    many-to-many strategies we’ll discuss in a moment is a better choice if we need
    to support duplicate links.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否用 `List` 代替 `Set`，甚至是一个包？`Set` 完美地匹配数据库模式，因为在 `Category` 和 `Item` 之间不能有重复的链接。一个包意味着有重复的元素，因此我们需要为连接表提供一个不同的主键。Hibernate
    的专有 `@CollectionId` 注解可以提供这一点，如第 8.1.5 节中所示。然而，如果我们需要支持重复链接，我们将在稍后讨论的替代多对多策略是一个更好的选择。
- en: We can map indexed collections such as a `List` with the regular `@ManyToMany`,
    but only on one side. Remember that in a bidirectional relationship, one side
    has to be “mapped by” the other side, meaning its value is ignored when Hibernate
    synchronizes with the database. If both sides are lists, we can only make the
    index of one side persistent.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用常规的 `@ManyToMany` 将索引集合（如 `List`）映射，但只能在一方进行。记住，在双向关系中，一方必须由另一方“映射”，这意味着当
    Hibernate 与数据库同步时，其值会被忽略。如果双方都是列表，我们只能使一方的索引持久化。
- en: A regular `@ManyToMany` mapping hides the link table; there is no corresponding
    Java class, only some collection properties. So whenever someone says, “My link
    table has more columns with information about the link” (and, in our experience,
    someone always says this sooner rather than later), we need to map this information
    to a Java class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正规的`@ManyToMany`映射隐藏了链接表；没有对应的Java类，只有一些集合属性。所以，每当有人说，“我的链接表有更多关于链接的信息的列”（在我们的经验中，总是有人会早点说），我们需要将这个信息映射到一个Java类。
- en: 9.3.2 Many-to-many with an intermediate entity
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 通过中间实体进行多对多
- en: We can always represent a many-to-many association as two many-to-one associations
    to an intervening class, and this is what we’ll do next. We won’t hide the link
    table; we’ll represent it with a Java class. This model is usually more easily
    extensible, so we tend not to use regular many-to-many associations in applications.
    It’s a lot of work to change the code later when more columns are inevitably added
    to a link table, so before mapping a `@ManyToMany` as shown in the previous section,
    consider the alternative shown in fig-ure 9.15.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以将多对多关联表示为两个多对一关联到一个中间类，这就是我们接下来要做的。我们不会隐藏链接表；我们将用Java类来表示它。这种模型通常更容易扩展，所以我们通常不会在应用程序中使用常规的多对多关联。当不可避免地添加更多列到链接表时，更改代码的工作量很大，所以在映射如前节所示的`@ManyToMany`之前，请考虑图9.15中所示的替代方案。
- en: '![](../../OEBPS/Images/CH09_F15_Tudose2.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F15_Tudose2.png)'
- en: Figure 9.15 `CategorizedItem` will be the link between `Category` and `Item`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 `CategorizedItem`将是`Category`和`Item`之间的链接。
- en: Imagine that we need to record some information each time we add an `Item` to
    a `Category`. The `CategorizedItem` entity captures the timestamp and the user
    who created the link. This domain model requires additional columns on the join
    table, as you can see figure 9.16
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，每次我们将一个`Item`添加到`Category`时，我们需要记录一些信息。`CategorizedItem`实体捕获了时间戳和创建链接的用户。这个领域模型需要在链接表上添加额外的列，如图9.16所示。
- en: '![](../../OEBPS/Images/CH09_F16_Tudose2.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F16_Tudose2.png)'
- en: Figure 9.16 Additional columns on the join table in a many-to-many relationship
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 多对多关系中链接表上的附加列
- en: The `CategorizedItem` entity maps to the link table, as you’ll see in listing
    9.4\. (The source code that follows can be found in the manytomany-linkentity
    folder.) This will involve a large chunk of code with some new annotations. First,
    it will be an immutable entity class (annotated with `@org.hibernate.annotations.Immutable`),
    so we’ll never update properties after creation. Hibernate can make some optimizations,
    such as avoiding dirty checking during flushing of the persistence context, if
    we declare the class immutable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategorizedItem`实体映射到链接表，你将在列表9.4中看到。（随后的源代码可以在`manytomany-linkentity`文件夹中找到。）这将涉及一大段代码和一些新的注解。首先，它将是一个不可变实体类（用`@org.hibernate.annotations.Immutable`注解），因此我们永远不会在创建后更新属性。如果我们声明类不可变，Hibernate可以执行一些优化，例如在持久化上下文刷新期间避免脏检查。'
- en: The entity class will have a composite key, which we’ll encapsulate in a static
    nested embeddable component class for convenience. The identifier property and
    its composite key columns will be mapped to the entity’s table through the `@EmbeddedId`
    annotation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类将有一个组合键，我们将将其封装在一个静态嵌套的可嵌入组件类中，以便于使用。标识符属性及其组合键列将通过`@EmbeddedId`注解映射到实体表。
- en: Listing 9.4 Mapping a many-to-many relationship with `CategorizedItem`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 使用`CategorizedItem`映射多对多关系
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ⓐ The class is immutable, as annotated with `@org.hibernate.annotations .Immutable`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 该类是不可变的，如通过`@org.hibernate.annotations .Immutable`注解所示。
- en: Ⓑ An entity class needs an identifier property. The primary key of the link
    table is the composite of `CATEGORY_ID` and `ITEM_ID`. We can externalize this
    `Id` class into its own file, of course.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 实体类需要一个标识符属性。链接表的主键是由`CATEGORY_ID`和`ITEM_ID`组合而成的。当然，我们可以将这个`Id`类外部化到它自己的文件中。
- en: Ⓒ The new `@EmbeddedId` annotation maps the identifier property and its composite
    key columns to the entity’s table.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 新的`@EmbeddedId`注解将标识符属性及其组合键列映射到实体表。
- en: Ⓓ The basic property mapping the `addedBy` username to a column of the join
    table.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 将`addedBy`用户名映射到链接表的一个列的基本属性。
- en: Ⓔ The basic property mapping the `addedOn` timestamp to a column of the join
    table. This is the “additional information about the link” that interests us.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 将`addedOn`时间戳映射到链接表的一个列的基本属性。这是我们感兴趣的“关于链接的附加信息”。
- en: Ⓕ The `@ManyToOne` property `category` is already mapped in the identifier.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `@ManyToOne` 属性 `category` 已经在标识符中进行了映射。
- en: Ⓖ The `@ManyToOne` property `item` is already mapped in the identifier. The
    trick here is to make them read-only, with the `updatable=false`, `insertable=false`
    settings. This means Hibernate or Spring Data JPA using Hibernate writes the values
    of these columns by taking the identifier value of `CategorizedItem`. At the same
    time, we can read and browse the associated instances through `categorizedItem
    .getItem()` and `getCategory()`. (If we map the same column twice without making
    one mapping read-only, Hibernate or Spring Data JPA using Hibernate will complain
    on startup about a duplicate column mapping.)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ `@ManyToOne` 属性 `item` 已经在标识符中进行了映射。这里的技巧是使它们只读，使用 `updatable=false`、`insertable=false`
    设置。这意味着 Hibernate 或使用 Hibernate 的 Spring Data JPA 会通过取 `CategorizedItem` 的标识符值来写入这些列的值。同时，我们可以通过
    `categorizedItem.getItem()` 和 `getCategory()` 读取和浏览关联的实例。（如果我们没有将同一列映射为只读，Hibernate
    或使用 Hibernate 的 Spring Data JPA 在启动时会抱怨重复的列映射。）
- en: Ⓗ We can also see that constructing a `CategorizedItem` involves setting the
    values of the identifier. The application always assigns composite key values;
    Hibernate doesn’t generate them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 我们还可以看到，构建一个 `CategorizedItem` 涉及到设置标识符的值。应用程序始终分配复合键值；Hibernate 不生成它们。
- en: Ⓘ The constructor sets the `addedBy` field value and guarantees referential
    integrity by managing collections on both sides of the association.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 构造函数设置了 `addedBy` 字段值，并通过管理关联两边的集合来保证引用完整性。
- en: Ⓙ The constructor sets the `categoryId` field value. We’ll map these collections
    next to enable bidirectional navigation. This is a unidirectional mapping and
    enough to support the many-to-many relationship between `Category` and `Item`.
    To create a link, we instantiate and persist a `CategorizedItem`. If we want to
    break a link, we remove the `CategorizedItem`. The constructor of `CategorizedItem`
    requires that we provide already persistent `Category` and `Item` instances.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 构造函数设置了 `categoryId` 字段值。我们将映射这些集合以启用双向导航。这是一个单向映射，足以支持 `Category` 和 `Item`
    之间的多对多关系。要创建一个链接，我们实例化并持久化一个 `CategorizedItem`。如果我们想断开一个链接，我们删除 `CategorizedItem`。`CategorizedItem`
    的构造函数要求我们提供已经持久化的 `Category` 和 `Item` 实例。
- en: 'If bidirectional navigation is required, we can map a `@OneToMany` collection
    in `Category` and/or `Item`. Here it is in `Category`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要双向导航，我们可以在 `Category` 和/或 `Item` 中映射一个 `@OneToMany` 集合。这里是在 `Category` 中的示例：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here it is in `Item`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Item` 中的示例：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Both sides are “mapped by” the annotations in `CategorizedItem`, so Hibernate
    already knows what to do when we iterate through the collection returned by either
    `getCategorizedItems()` method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 双方都由 `CategorizedItem` 中的注解“映射”，所以当遍历由 `getCategorizedItems()` 方法返回的集合时，Hibernate
    已经知道该怎么做。
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The primary advantage of this strategy is the possibility of bidirectional
    navigation: we can get all items in a category by calling `someCategory.getCategorizedItems()`,
    and we can also navigate from the opposite direction with `someItem .getCategorizedItems()`.
    A disadvantage is the more complex code needed to manage the `CategorizedItem`
    entity instances to create and remove links, which we have to save and delete
    independently. We also need some infrastructure in the `CategorizedItem` class,
    such as the composite identifier. One small improvement would be to enable `CascadeType.PERSIST`
    on some of the associations, reducing the number of calls to `save()`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的主要优势是双向导航的可能性：我们可以通过调用 `someCategory.getCategorizedItems()` 来获取一个类别中的所有项目，我们也可以通过
    `someItem.getCategorizedItems()` 从相反方向导航。一个缺点是需要更复杂的代码来管理 `CategorizedItem` 实例，以创建和删除链接，我们必须独立地保存和删除它们。我们还需要在
    `CategorizedItem` 类中提供一些基础设施，例如复合标识符。一个小改进是，可以在一些关联上启用 `CascadeType.PERSIST`，从而减少对
    `save()` 的调用次数。
- en: In this example, we stored the user who created the link between `Category`
    and `Item` as a simple name string. If the join table instead had a foreign key
    column called `USER_ID`, we’d have a ternary relationship. The `CategorizedItem`
    would have a `@ManyToOne` for `Category`, `Item`, and `User`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建 `Category` 和 `Item` 之间链接的用户存储为一个简单的名称字符串。如果连接表有一个名为 `USER_ID` 的外键列，我们就会有一个三元关系。`CategorizedItem`
    将会有一个 `@ManyToOne` 用于 `Category`、`Item` 和 `User`。
- en: In the following section, we’ll demonstrate another many-to-many strategy. To
    make it a bit more interesting, we’ll make it a ternary association.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示另一种多对多策略。为了使其更有趣，我们将使其成为一个三元关联。
- en: 9.3.3 Ternary associations with components
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 使用组件的三元关联
- en: In the previous section, we represented a many-to-many relationship with an
    entity class mapped to a link table. A potentially simpler alternative is mapping
    to an embeddable component class. The source code that follows can be found in
    the manytomany-ternary folder.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们使用一个映射到链接表的实体类来表示多对多关系。一个潜在的更简单替代方案是映射到一个可嵌入组件类。以下源代码可以在`manytomany-ternary`文件夹中找到。
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ⓐ The `@NotNull` annotations do not generate an SQL constraint, so the annotated
    fields will not be part of the primary key.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `@NotNull`注解不会生成SQL约束，因此被注解的字段不会成为主键的一部分。
- en: The new mappings here are `@ManyToOne` associations in an `@Embeddable` and
    the additional foreign key join column `USER_ID`, making this a ternary relationship.
    Look at the database schema in figure 9.17.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新映射是`@Embeddable`中的`@ManyToOne`关联以及额外的外键连接列`USER_ID`，这使得这是一个三元关系。查看图9.17中的数据库模式。
- en: '![](../../OEBPS/Images/CH09_F17_Tudose2.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F17_Tudose2.png)'
- en: Figure 9.17 A link table with three foreign key columns
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 一个具有三个外键列的链接表
- en: 'The owner of the embeddable component collection is the `Category` entity:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入组件集合的所有者是`Category`实体：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Unfortunately, this mapping isn’t perfect: when we map an `@ElementCollection`
    of embeddable type, all properties of the target type that are `nullable=false`
    become part of the (composite) primary key. We want all columns in `CATEGORY_ITEM`
    to be `NOT NULL`. Only the `CATEGORY_ID` and `ITEM_ID` columns should be part
    of the primary key, though. The trick is to use the Bean Validation `@NotNull`
    annotation on properties that shouldn’t be part of the primary key. In that case
    (because it’s an embeddable class), Hibernate ignores the Bean Validation annotation
    for primary key realization and SQL schema generation. The downside is that the
    generated schema won’t have the appropriate `NOT NULL` constraints on the `USER_ID`
    and `ADDEDON` columns, which we should fix manually.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种映射并不完美：当我们映射可嵌入类型的`@ElementCollection`时，目标类型中所有`nullable=false`的属性都成为（组合）主键的一部分。我们希望`CATEGORY_ITEM`中的所有列都是`NOT
    NULL`。尽管如此，只有`CATEGORY_ID`和`ITEM_ID`列应该包含在主键中。技巧是使用Bean Validation `@NotNull`注解在不应包含在主键中的属性上。在这种情况下（因为它是一个可嵌入类），Hibernate会忽略Bean
    Validation注解用于主键实现和SQL模式生成。缺点是生成的模式不会在`USER_ID`和`ADDEDON`列上有适当的`NOT NULL`约束，我们应该手动修复。
- en: 'The advantage of this strategy is the implicit lifecycle of the link components.
    To create an association between a `Category` and an `Item`, add a new `CategorizedItem`
    instance to the collection. To break the link, remove the element from the collection.
    No extra cascading settings are required, and the Java code is simplified (albeit
    spread over more lines):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的优势在于链接组件的隐式生命周期。要创建`Category`和`Item`之间的关联，请向集合中添加一个新的`CategorizedItem`实例。要断开链接，请从集合中删除该元素。不需要额外的级联设置，Java代码也简化了（尽管分散在更多行中）：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There is no way to enable bidirectional navigation: an embeddable component,
    such as `CategorizedItem`, by definition can’t have shared references. We can’t
    navigate from `Item` to `CategorizedItem`, and there is no mapping of this link
    in `Item`. Instead, we can write a query to retrieve the categories, given an
    `Item`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 无法启用双向导航：可嵌入组件，如`CategorizedItem`，按定义不能有共享引用。我们不能从`Item`导航到`CategorizedItem`，在`Item`中也没有这种链接的映射。相反，我们可以编写一个查询来检索类别，给定一个`Item`：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `findCategoryWithCategorizedItems` method is annotated with the `@Query`
    annotation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`findCategoryWithCategorizedItems`方法被`@Query`注解标注：'
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve now completed our first ternary association mapping. In the previous chapters,
    we saw ORM examples with maps; the keys and values of those maps were always of
    basic or embeddable type. In the following section, we’ll use more complex key/value
    pair types and their mappings.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了第一个三元关联映射。在前几章中，我们看到了使用映射的ORM示例；那些映射的键和值总是基本或可嵌入类型。在下一节中，我们将使用更复杂的关键/值对类型及其映射。
- en: 9.4 Entity associations with maps
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用映射的实体关联
- en: Map keys and values can be references to other entities, providing another strategy
    for mapping many-to-many and ternary relationships. First, let’s assume that only
    the value of each map entry is a reference to another entity.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 映射键和值可以是其他实体的引用，这为映射多对多和三元关系提供了另一种策略。首先，让我们假设每个映射条目的值仅是另一个实体的引用。
- en: 9.4.1 One-to-many with a property key
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 使用属性键的一对多
- en: If the value of each map entry is a reference to another entity, we have a one-to-many
    entity relationship. The key of the map is of a basic type, such as a `Long` value.
    (The source code that follows can be found in the maps-mapkey folder.)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个映射条目的值是另一个实体的引用，我们有一个一对一的实体关系。映射的键是基本类型，例如`Long`值。（后续的源代码可以在`maps-mapkey`文件夹中找到。）
- en: 'An example of this structure would be an `Item` entity with a map of `Bid`
    instances, where each map entry is a pair consisting of `Bid` identifier and reference
    to a `Bid` instance. When we iterate through `someItem.getBids()`, we iterate
    through map entries that look like `(1, <reference to Bid with PK 1>)`, `(2, <reference
    to Bid with PK 2>)`, and so on:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构的例子是一个具有`Bid`实例映射的`Item`实体，其中每个映射条目是一个由`Bid`标识符和`Bid`实例引用组成的对。当我们遍历`someItem.getBids()`时，我们遍历看起来像`(1,
    <对具有PK 1的Bid的引用>)`、`(2, <对具有PK 2的Bid的引用>)`等映射条目：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The underlying tables for this mapping are nothing special; we have `ITEM` and
    `BID` tables, with an `ITEM_ID` foreign key column in the `BID` table. This is
    the same schema as demonstrated in figure 8.14 for a one-to-many/many-to-one mapping
    with a regular collection instead of a `Map`. Our motivation here is a slightly
    different representation of the data in the application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射的底层表没有什么特别之处；我们拥有`ITEM`和`BID`表，在`BID`表中有一个`ITEM_ID`外键列。这与图8.14中展示的具有常规集合而不是`Map`的一对多/多对一映射的架构相同。我们在这里的动机是应用中数据的不同表示形式。
- en: 'In the `Item` class, we’ll include a `Map` property named `bids`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Item`类中，我们将包含一个名为`bids`的`Map`属性：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'New here is the `@MapKey` annotation. It maps a property of the target entity:
    in this case, the `Bid` entity, as the key of the map. The default if we omit
    the `name` attribute is the identifier property of the target entity, so the `name`
    option here is redundant. Because the keys of a map form a set, we should expect
    values to be unique for a particular map. This is the case for `Bid` primary keys
    but likely not for any other property of `Bid`. It’s up to us to ensure that the
    selected property has unique values—Hibernate or Spring Data JPA using Hibernate
    won’t check.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的是`@MapKey`注解。它将目标实体的一个属性映射为映射的键：在这种情况下，是`Bid`实体，作为映射的键。如果我们省略`name`属性，则默认是目标实体的标识符属性，所以这里的`name`选项是多余的。因为映射的键形成一个集合，我们应该期望特定映射的值是唯一的。对于`Bid`主键来说是这样，但对于`Bid`的任何其他属性可能不是这样。确保所选属性具有唯一值的责任在我们身上——Hibernate或使用Hibernate的Spring
    Data JPA不会进行检查。
- en: The primary and rare use case for this mapping technique is to iterate map entries
    with some property of the entry entity value as the entry key, maybe because it’s
    convenient for how we’d like to render the data. A more common situation is a
    map in the middle of a ternary association.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射技术的首要且罕见的使用场景是将具有实体值属性作为条目键的映射条目迭代，可能是因为它符合我们想要呈现数据的方式。更常见的情况是在三元关联中间的映射。
- en: 9.4.2 Key/value ternary relationship
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 关键字/值三元关系
- en: You may be a little bored by now with all the mapping experiments that we’ve
    executed, but we promise this is the last time we’ll show another way of mapping
    the association between `Category` and `Item`. Previously, in section 9.3.3, we
    used an embeddable `CategorizedItem` component to represent the link. Here we’ll
    show a representation of the relationship with a `Map` instead of an additional
    Java class. The key of each map entry is an `Item`, and the related value is the
    `User` who added the `Item` to the `Category`, as shown in figure 9.18.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经对我们执行的所有映射实验感到有些厌烦了，但我们承诺这是我们最后一次展示另一种表示`Category`和`Item`之间关联的方式。之前，在9.3.3节中，我们使用了一个可嵌入的`CategorizedItem`组件来表示链接。在这里，我们将展示一个使用`Map`而不是额外Java类的关联表示。每个映射条目的键是一个`Item`，相关的值是添加`Item`到`Category`中的`User`，如图9.18所示。
- en: '![](../../OEBPS/Images/CH09_F18_Tudose2.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F18_Tudose2.png)'
- en: Figure 9.18 A `Map` with entity associations as key/value pairs
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18 具有实体关联作为键/值对的Map]'
- en: 'The link/join table in the schema, as you can see in figure 9.19, has three
    columns: `CATEGORY_ID`, `ITEM_ID`, and `USER_ID`. The `Map` is owned by the `Category`
    entity. The source code that follows can be found in the maps-ternary folder.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如图9.19所示，架构中的链接/连接表有三个列：`CATEGORY_ID`、`ITEM_ID`和`USER_ID`。`Map`属于`Category`实体。后续的源代码可以在`maps-ternary`文件夹中找到。
- en: '![](../../OEBPS/Images/CH09_F19_Tudose2.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F19_Tudose2.png)'
- en: Figure 9.19 The link table represents the `Map` key/value pairs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19 链接表表示Map键/值对]'
- en: The following code models the relationship between `Category` and `Item` using
    a map.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用映射来表示`Category`和`Item`之间的关系。
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ⓐ The `@MapKeyJoinColumn` is optional; Hibernate or Spring Data JPA using Hibernate
    will default to the column name `ITEMADDEDBY_KEY` for the join/foreign key column
    referencing the `ITEM` table.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `@MapKeyJoinColumn`是可选的；Hibernate或使用Hibernate的Spring Data JPA将默认使用列名`ITEMADDEDBY_KEY`作为引用`ITEM`表的连接/外键列。
- en: 'To create a link between all three entities, all instances must already be
    in persistent state and then put into the map:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这三个实体之间创建链接，所有实例必须已经处于持久状态，然后放入映射中：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To remove the link, remove the entry from the map. This manages a complex relationship,
    hiding a database link table with three columns. But remember that, in practice,
    link tables often grow additional columns, and changing all the Java application
    code later is expensive if you depend on a `Map` API. Earlier, we had an `ADDEDON`
    column with a timestamp when the link was created, but we had to drop it for this
    mapping.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除链接，请从映射中删除条目。这管理了一个复杂的关系，隐藏了一个具有三个列的数据库链接表。但请记住，在实际操作中，链接表通常会增长额外的列，如果你依赖于`Map`
    API，那么稍后更改所有Java应用程序代码将非常昂贵。早些时候，我们有一个`ADDEDON`列，用于记录链接创建的时间戳，但我们必须为了这次映射而丢弃它。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Complex entity associations can be mapped using one-to-one associations, one-to-many
    associations, many-to-many associations, ternary associations, and entity associations
    with maps.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂实体关联可以使用一对一关联、一对多关联、多对多关联、三元关联以及带有映射的实体关联进行映射。
- en: You can create one-to-one associations by sharing a primary key, using a foreign
    primary key generator, using a foreign key join column, or using a join table.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过共享主键、使用外键主键生成器、使用外键连接列或使用连接表来创建一对一关联。
- en: You can create one-to-many associations by considering one-to-many bags, using
    unidirectional and bidirectional list mappings, applying optional one-to-many
    with a join table, or creating one-to-many associations in an embeddable class.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过考虑一对多包、使用单向和双向列表映射、应用可选的一对多与连接表或在一个可嵌入类中创建一对多关联来创建一对多关联。
- en: You can create unidirectional and bidirectional many-to-many associations and
    many-to-many associations with an intermediate entity.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建单向和双向多对多关联，以及带有中间实体的多对多关联。
- en: You can build ternary associations with components and entity associations with
    maps.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用组件和带有映射的实体关联来构建三元关联。
- en: You can often best represent many-to-many entity associations as two many-to-one
    associations from an intermediate entity class or with a collection of components.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你通常可以将多对多实体关联表示为从中间实体类或组件集合出发的两个多对一关联。
- en: Before attempting a complex collection mapping, always make sure you actually
    need a collection. Ask yourself whether you frequently iterate through its elements.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尝试复杂的集合映射之前，请务必确保你确实需要集合。问问自己你是否经常遍历其元素。
- en: The Java structures used in this chapter may sometimes make data access easier,
    but typically they complicate data storage, updates, and deletion.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中使用的Java结构有时可以简化数据访问，但通常它们会复杂化数据存储、更新和删除。
