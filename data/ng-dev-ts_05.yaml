- en: Chapter 6\. Reactive programming in Angular
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. Angular中的响应式编程
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Handling events as observables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件作为观察者处理
- en: Using observables with Angular `Router` and forms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular `Router`和表单中使用观察者
- en: Using observables in HTTP requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTTP请求中使用观察者
- en: Minimizing network load by discarding unwanted HTTP responses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过丢弃不需要的HTTP响应来最小化网络负载
- en: The goal of the first five chapters was to jump-start your application development
    with Angular. In those chapters, we discussed how to generate a new project from
    scratch, covering modules, routing, and dependency injection. In this chapter,
    we’ll show you how Angular supports a *reactive* style of programming, in which
    your app reacts on changes either initiated by the user or by asynchronous events
    like data arriving from a router, form, or server. You’ll learn which Angular
    APIs support data push and allow you to subscribe to RxJS-based observable data
    streams.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前五章的目标是使用Angular快速启动应用程序开发。在这些章节中，我们讨论了如何从头开始生成新项目，包括模块、路由和依赖注入。在本章中，我们将向您展示Angular如何支持一种*响应式*编程风格，其中您的应用程序对用户发起的更改或异步事件（如来自路由器、表单或服务器的数据到达）做出的反应。您将了解哪些Angular
    API支持数据推送并允许您订阅基于RxJS的观察者数据流。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re not familiar with RxJS library concepts such as observables, observers,
    operators, and subscriptions, read [appendix D](kindle_split_028.xhtml#app04)
    before proceeding with this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉RxJS库的概念，如观察者、观察者、操作符和订阅，请在继续本章之前阅读[附录D](kindle_split_028.xhtml#app04)。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Angular offers ready-to-use observables for implementing various scenarios:
    handling events, subscribing to the route’s parameters, checking the status of
    a form, handling HTTP requests, and more. You’ll see some examples of using Angular
    observables, but each of the following chapters contains reactive code as well.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了可用于实现各种场景的现成观察者：处理事件、订阅路由的参数、检查表单的状态、处理HTTP请求等。您将看到一些使用Angular观察者的示例，但以下每一章都包含响应式代码。
- en: You may say that any JavaScript app can use event listeners and provide callbacks
    to handle events, but we’ll show you how to treat events as data streams that
    *push* values to the observers over time. You’ll be writing code that *subscribes*
    to observable event streams and handles them in the observer objects. You’ll be
    able to apply one or more operators to handle an event as it moves to the observer,
    which isn’t possible with the regular event listeners.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会说，任何JavaScript应用程序都可以使用事件监听器并提供回调来处理事件，但我们将向您展示如何将事件视为随时间向观察者推送值的**数据流**。您将编写代码来**订阅**观察者事件流并在观察者对象中处理它们。您将能够对事件应用一个或多个操作符，在它移动到观察者时进行处理，这是使用常规事件监听器所不可能的。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Source code for this chapter can be found at [https://github.com/Farata/angulartypescriptand](https://github.com/Farata/angulartypescriptand)
    [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
    You can find the code samples used in this section in the directory named observables.
    Open this directory in your IDE and run `npm install` to install Angular and its
    dependencies. We provide instructions on how to run code samples when it’s required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/Farata/angulartypescriptand](https://github.com/Farata/angulartypescriptand)
    [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)找到。您可以在名为observables的目录中找到本节使用的代码示例。在您的IDE中打开此目录，并运行`npm
    install`以安装Angular及其依赖项。当需要时，我们提供有关如何运行代码示例的说明。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s start by discussing how to handle events with and without observables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何使用和不使用观察者来处理事件。
- en: 6.1\. Handling events without observables
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 不使用观察者处理事件
- en: Each DOM event is represented by the object containing properties describing
    the event. Angular applications can handle standard DOM events and can emit custom
    events as well. A handler function for a UI event can be declared with an optional
    `$event` parameter. With standard DOM events, you can use any functions or properties
    of the browser’s `Event` object (see “Event” in the Mozilla Developer Network
    documentation, [http://mzl.la/1EAG6iw](http://mzl.la/1EAG6iw)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个DOM事件都由包含描述事件属性的对象表示。Angular应用程序可以处理标准DOM事件，也可以发出自定义事件。一个UI事件的处理器函数可以用可选的`$event`参数声明。对于标准DOM事件，你可以使用浏览器`Event`对象的任何函数或属性（参见Mozilla开发者网络文档中的“事件”，[http://mzl.la/1EAG6iw](http://mzl.la/1EAG6iw))）。
- en: In some cases, you won’t be interested in reading the event object’s properties,
    such as when the only button on a page is clicked and this is all that matters.
    In other cases, you may want to know specific information, like what character
    was entered in the `<input>` field when the `keyup` event was dispatched. The
    following code listing shows how to handle a DOM `keyup` event and print the value
    from the input field that emitted this event.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能对读取事件对象的属性不感兴趣，例如，当页面上只有一个按钮被点击，而这正是你所关心的。在其他情况下，你可能想了解特定的信息，比如当`keyup`事件被派发时，在`<input>`字段中输入了什么字符。下面的代码示例展示了如何处理DOM的`keyup`事件并打印出触发此事件的输入字段的值。
- en: Listing 6.1\. Handling the `keyup` event
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 处理keyup事件
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Binds to the keyup event**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 绑定到keyup事件**'
- en: '***2* Event handler method**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 事件处理方法**'
- en: 'In this code snippet, you care only about one property of the `Event` object:
    the `target`. By applying *object destructuring* (see [section A.9.1](kindle_split_025.xhtml#app01lev2sec4)
    in [appendix A](kindle_split_025.xhtml#app01)), the `onKey()` handler can get
    the reference to the `target` property on the fly by using curly braces with the
    function argument:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你只关心`Event`对象的一个属性：`target`。通过应用*对象解构*（参见附录A中的[第A.9.1节](kindle_split_025.xhtml#app01lev2sec4)），`onKey()`处理程序可以通过使用花括号和函数参数来即时获取`target`属性的引用：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If your code dispatches a custom event, it can carry application-specific data,
    and the event object can be strongly typed (not be `any` type). You’ll see how
    to specify the type of a custom event in [listing 8.4](kindle_split_017.xhtml#ch08ex04)
    in [chapter 8](kindle_split_017.xhtml#ch08).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码派发了一个自定义事件，它可以携带应用程序特定的数据，并且事件对象可以是强类型的（不是`any`类型）。你将在第8章[列表8.4](kindle_split_017.xhtml#ch08ex04)中看到如何指定自定义事件的类型。
- en: A traditional JavaScript application treats a dispatched event as a one-time
    deal; for example, one click results in one function invocation. Angular offers
    another approach where you can consider any event as an observable stream of data
    happening over time. For example, if the user enters several characters in the
    `<input>` field, each of the characters can be treated as an emission of the observable
    stream.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个传统的JavaScript应用程序将派发的事件视为一次性的事件；例如，一次点击导致一次函数调用。Angular提供了一种不同的方法，你可以将任何事件视为随时间发生的数据的可观察流。例如，如果用户在`<input>`字段中输入了几个字符，每个字符都可以被视为可观察流的一次发射。
- en: You can subscribe to observable events and specify the code to be invoked when
    each new value is emitted and, optionally, the code for error processing and stream
    completion. Often you’ll specify a number of chained RxJS operators and then invoke
    the `subscribe()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以订阅可观察的事件，并指定在每次新值发出时调用的代码，以及可选的错误处理和流完成的代码。通常，你会指定多个链式RxJS操作符，然后调用`subscribe()`方法。
- en: 'Why do we even need to apply RxJS operators to events coming from the UI? Let’s
    consider an example that uses event binding to handle multiple `keyup` events
    as the user types a stock symbol to get its price:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要将RxJS操作符应用于来自UI的事件？让我们考虑一个使用事件绑定来处理用户在输入股票符号以获取其价格时派发的多个`keyup`事件的例子：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Isn’t this technique good enough for handling multiple events dispatched as
    the user types? Imagine that the preceding code is used to get a price quote for
    AAPL stock. After the user types the first `A`, the `getStockPrice()` function
    will make a request to the server, which will return the price of `A`, if there
    is such a stock. Then the user enters the second `A`, which results in another
    server request for the `AA` price quote. The process repeats for `AAP` and `AAPL`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于处理用户输入时派发的多个事件是否足够好？想象一下，前面的代码被用来获取AAPL股票的报价。当用户输入第一个`A`时，`getStockPrice()`函数将向服务器发送请求，如果存在这样的股票，服务器将返回`A`的价格。然后用户输入第二个`A`，这将导致另一个服务器请求`AA`的报价。这个过程会重复进行，直到`AAP`和`AAPL`。
- en: 'This isn’t what you want. To defer the invocation of `getStockPrice()`, you
    can place it inside the `setTimeout()` function with, say, a 500-millisecond delay
    to give the user enough time to type several letters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你想要的。为了延迟`getStockPrice()`的调用，你可以将其放在`setTimeout()`函数中，例如，延迟500毫秒，以给用户足够的时间输入几个字母：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don’t forget to call `clearTimeout()` and start another timer should the user
    continue typing in the input field.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在输入字段中继续输入，不要忘记调用`clearTimeout()`并启动另一个计时器。
- en: How about composing several functions that should preprocess the event before
    invoking `getStockPrice()`? There’s no elegant solution to this. What if the user
    types slowly, and during the 500-millisecond interval manages only to enter AAP?
    The first request for AAP goes to the server, and 500 milliseconds later the second
    request for AAPL is sent. A program can’t discard the results of the first HTTP
    request if the client returns a `Promise` object, and may overload the network
    with unwanted HTTP responses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在调用 `getStockPrice()` 之前预处理事件的几个函数的组合，有没有优雅的解决方案？如果用户输入缓慢，在 500 毫秒的间隔内只能输入
    AAP，第一个请求 AAP 发送到服务器，500 毫秒后发送第二个请求 AAPL。如果客户端返回一个 `Promise` 对象，程序无法丢弃第一个 HTTP
    请求的结果，并且可能会因不想要的 HTTP 响应而过载网络。
- en: Handling events with RxJS offers you a convenient operator named `debounceTime`
    that makes the observable emit the next value only if a specified time passes
    (such as 500 milliseconds) and the data producer (the `<input>` field in our case)
    doesn’t produce new values during this interval. There’s no need to clear and
    re-create the timer. Also, the `switchMap` operator allows easy cancellation of
    the observable waiting for a pending request (for example, `getStockPrice()`)
    if the observable emits new values (for example, the user keep typing). What can
    Angular offer to handle events from an input field with subscribers?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RxJS 处理事件为你提供了一个名为 `debounceTime` 的方便操作符，该操作符使得可观察对象仅在经过指定时间（例如 500 毫秒）且数据生产者（在我们的例子中是
    `<input>` 字段）在此期间没有产生新值时才发出下一个值。无需清除和重新创建计时器。此外，`switchMap` 操作符允许轻松取消等待挂起请求（例如，`getStockPrice()`）的可观察对象，如果可观察对象发出新值（例如，用户持续输入）。Angular
    可以提供什么来处理具有订阅者的输入字段事件？
- en: 6.2\. Turning DOM events into observables
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 将 DOM 事件转换为可观察对象
- en: In Angular applications, you can get direct access to any DOM element using
    a special class, `ElementRef`, and we’ll use this feature to illustrate how you
    can subscribe to events of an arbitrary HTML element. You’ll create an app that
    will subscribe to the `<input>` element where the user inputs the stock symbol
    to get its price, as discussed in the previous section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，你可以使用一个特殊的类 `ElementRef` 直接访问任何 DOM 元素，我们将使用这个特性来说明如何订阅任意 HTML
    元素的事件。你将创建一个应用程序，它将订阅用户输入股票符号以获取其价格的 `<input>` 元素，如前所述。
- en: 'To turn a DOM event into an observable stream, you need to do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个 DOM 事件转换为可观察对象流，你需要执行以下操作：
- en: '**1**.  Get a reference to the DOM object.'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 获取 DOM 对象的引用。'
- en: '**2**.  Create an observable using `Observable.fromEvent()`, providing the
    reference to the DOM object and the event you want to subscribe to.'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 使用 `Observable.fromEvent()` 创建一个可观察对象，提供 DOM 对象和要订阅的事件的引用。'
- en: '**3**.  Subscribe to this observable and handle the events.'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 订阅此可观察对象并处理事件。'
- en: In a regular JavaScript app, to get a reference to the DOM element, you use
    a DOM selector API, `document.querySelector()`. In Angular, you can use the `@ViewChild()`
    decorator to get a reference to an element from a component template.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个常规的 JavaScript 应用中，要获取 DOM 元素的引用，你使用 DOM 选择器 API，`document.querySelector()`。在
    Angular 中，你可以使用 `@ViewChild()` 装饰器从组件模板中获取元素的引用。
- en: 'To uniquely identify the template elements, you’ll use local template variables
    that start with the hash symbol. The following code snippet uses the local template
    variable `#stockSymbol` as an ID of the `<input>` element:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了唯一标识模板元素，你将使用以哈希符号开始的局部模板变量。以下代码片段使用局部模板变量 `#stockSymbol` 作为 `<input>` 元素的
    ID：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you need to get a reference to the preceding element inside the TypeScript
    class, you can use the `@ViewChild('stockSymbol')` decorator, and the application
    in the following listing illustrates how to do that. Note that you import only
    those RxJS members that you actually use.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在 TypeScript 类内部获取前一个元素的引用，你可以使用 `@ViewChild('stockSymbol')` 装饰器，以下列表中的应用程序展示了如何做到这一点。注意，你只导入那些你实际使用的
    RxJS 成员。
- en: Listing 6.2\. fromevent/app.component.ts
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. fromevent/app.component.ts
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Declares the property myInputField that holds a reference to the <input>
    field**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个名为 myInputField 的属性，该属性包含对 <input> 字段的引用**'
- en: '***2* Places the code in the ngAfterViewInit() component lifecycle method**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将代码放置在 ngAfterViewInit() 组件生命周期方法中**'
- en: '***3* Creates an observable from the keyup event**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从 keyup 事件创建可观察对象**'
- en: '***4* Waits for a 500 ms pause in the observable’s emissions**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 等待可观察对象发射暂停 500 毫秒**'
- en: '***5* Converts the DOM event into the target.value property, which has the
    stock symbol entered by the user**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将 DOM 事件转换为 target.value 属性，该属性包含用户输入的股票代码**'
- en: '***6* Invokes the getStockQuoteFromServer() method for each value emitted by
    the observable**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 对可观察对象发出的每个值调用 getStockQuoteFromServer() 方法**'
- en: '***7* Prints the generated random stock price**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 打印生成的随机股票价格**'
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Starting from Angular 6, instead of `Observable.fromEvent()`, just write `fromEvent()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Angular 6 开始，不再使用 `Observable.fromEvent()`，只需写 `fromEvent()`。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In [listing 6.2](#ch06ex02), the code to subscribe to events is placed in the
    `ngAfterViewInit()` component lifecycle method, which Angular invokes when the
    component’s UI is initialized. You’ll learn about component lifecycle methods
    in [section 9.2](kindle_split_018.xhtml#ch09lev1sec2) in [chapter 9](kindle_split_018.xhtml#ch09).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6.2](#ch06ex02) 中，订阅事件的代码放置在 `ngAfterViewInit()` 组件生命周期方法中，Angular 在组件的
    UI 初始化时调用此方法。你将在第 9 章 [ch09](kindle_split_018.xhtml#ch09) 的 [第 9.2 节](kindle_split_018.xhtml#ch09lev1sec2)
    中了解组件生命周期方法。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can see this code sample in action by running the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来查看此代码示例的实际效果：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open the browser’s console and start entering the stock symbol. Depending on
    the speed of your typing, you’ll see one or more messages in the console reporting
    stock price(s).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器的控制台并开始输入股票代码。根据你打字的速度，你将在控制台中看到一条或几条报告股票价格的消息。
- en: It’s great that you can turn any DOM event into an observable, but directly
    accessing the DOM by using `ElementRef` is discouraged, because it may present
    some security vulnerabilities (see [https://angular.io/api/core/ElementRef](https://angular.io/api/core/ElementRef)
    for details). What’s a better way to subscribe to value changes in a DOM object?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何 DOM 事件转换为可观察对象，但直接使用 `ElementRef` 访问 DOM 是不被推荐的，因为这可能会带来一些安全漏洞（有关详细信息，请参阅
    [https://angular.io/api/core/ElementRef](https://angular.io/api/core/ElementRef)）。那么，更好的方法是订阅
    DOM 对象中的值变化吗？
- en: 6.3\. Handling observable events with the Forms API
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 使用表单 API 处理可观察事件
- en: 'The Angular Forms API (covered in [chapters 10](kindle_split_019.xhtml#ch10)
    and [11](kindle_split_020.xhtml#ch11)) offers ready-to-use observables that push
    notifications about important events that are happening with the entire form or
    with form control. Here are two examples:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 表单 API（在第 10 章 [chapters 10](kindle_split_019.xhtml#ch10) 和第 11 章 [11](kindle_split_020.xhtml#ch11)
    中介绍）提供了现成的可观察对象，用于推送有关整个表单或表单控件发生的所有重要事件的通告。以下有两个示例：
- en: '**`valueChanges`—** This property is an observable that emits data when the
    value of the form control is changing.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`valueChanges`—** 这个属性是一个可观察对象，当表单控件的值发生变化时，它会发出数据。'
- en: '**`statusChanges`—** This property is an observable that emits the validity
    status of the form control or the entire form. The status changes from valid to
    invalid or vice versa.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`statusChanges`—** 这个属性是一个可观察对象，它发出表单控件或整个表单的有效性状态。状态从有效变为无效或反之亦然。'
- en: In this section, we’ll show you how to use the `valueChanges` property with
    the HTML `<input>` element.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何使用 `valueChanges` 属性与 HTML `<input>` 元素一起使用。
- en: The `FormControl` class, one of the fundamental blocks of forms processing,
    represents a form control. By default, whenever the value of the form control
    changes, the underlying `FormControl` object emits an event through its `valueChanges`
    property of type `Observable`, and you can subscribe to it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl` 类是表单处理的基本块之一，它表示一个表单控件。默认情况下，每当表单控件的值发生变化时，底层的 `FormControl`
    对象会通过其 `valueChanges` 属性（类型为 `Observable`）发出一个事件，你可以订阅它。'
- en: Let’s rewrite the app from the previous section by using the Forms API to subscribe
    to the `input` event of the `<input>` field and generate stock quotes. The form
    elements can be bound to component properties via the `formControl` directive,
    and you’ll use it instead of accessing the DOM object directly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用表单 API 订阅 `<input>` 字段的 `input` 事件并生成股票报价来重写上一节的 app。表单元素可以通过 `formControl`
    指令绑定到组件属性，你将使用它而不是直接访问 DOM 对象。
- en: The following listing applies the RxJS `debounceTime` operator prior to invoking
    `subscribe()`, instructing the `this.searchInput.valueChanges` observable to emit
    the data if the user isn’t typing anything during 500 milliseconds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表在调用 `subscribe()` 之前应用了 RxJS `debounceTime` 操作符，指示 `this.searchInput.valueChanges`
    可观察对象在用户500毫秒内没有输入任何内容时发出数据。
- en: Listing 6.3\. formcontrol/app.component.ts
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. formcontrol/app.component.ts
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Links this <input> element to the component property searchInput**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将此 <input> 元素链接到组件属性 searchInput**'
- en: '***2* The valueChanges property is an observable.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* valueChanges 属性是一个可观察对象。**'
- en: '***3* Waits for 500 ms of quiet time before emitting the content of the <input>
    element**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在发出 `<input>` 元素的内容之前等待 500 毫秒的静默时间**'
- en: '***4* Subscribes to the observable**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 订阅可观察对象**'
- en: Your `subscribe()` method provides the `Observer` with one method (no error
    or stream-completion handlers). Each value from the stream generated by the `searchInput`
    control is given to the `getStockQuoteFromServer()` method. In a real-world scenario,
    this method would issue a request to the server (and you’ll see such an app in
    [section 6.4](#ch06lev1sec4)), but your method just generates and prints a random
    stock price.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `subscribe()` 方法为 `Observer` 提供了一个方法（没有错误或流完成处理程序）。`searchInput` 控制器生成的流中的每个值都传递给
    `getStockQuoteFromServer()` 方法。在现实世界的场景中，此方法会向服务器发出请求（您将在 [第 6.4 节](#ch06lev1sec4)
    中看到这样的应用程序），但您的方法只是生成并打印一个随机的股票价格。
- en: If you didn’t use the `debounceTime` operator, `valueChanges` would be emitting
    values after each character typed by the user. [Figure 6.1](#ch06fig01) shows
    what happens after you start this application and enter `AAPL` in the input field.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用 `debounceTime` 操作符，`valueChanges` 将会在用户每次输入字符后发出值。[图 6.1](#ch06fig01)
    展示了您启动此应用程序并在输入字段中输入 `AAPL` 后会发生什么。
- en: Figure 6.1\. Getting the price for AAPL
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 获取 AAPL 的价格
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig01_alt.jpg)'
- en: 'To see this app in action, run the following command in the Terminal:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请在终端中运行以下命令：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may argue that you could implement this example in [listing 6.3](#ch06ex03)
    and [figure 6.1](#ch06fig01) by simply binding to the `change` event, which would
    be dispatched when the user finished entering the stock symbol and moved the focus
    out of the input field. This is true, but in many scenarios you’ll want an immediate
    response from the server, such as retrieving and filtering a data collection as
    the user types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会争辩说，您可以通过简单地绑定到 `change` 事件来实现此示例，该事件会在用户完成输入股票符号并将焦点从输入字段移出时触发。这是真的，但在许多场景中，您可能希望从服务器获得即时响应，例如在用户输入时检索和过滤数据集合。
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In [listing 6.3](#ch06ex03), you don’t make any network requests to the server
    for price quotes—you generate random numbers on the user’s computer. Even if the
    user enters a wrong stock symbol, this code sample will invoke `Math.random()`,
    which has a negligible effect on the application’s performance. In a real-world
    application, the user’s typos may generate network requests that introduce delays
    while returning quotes for mistakenly entered stock symbols. How would you go
    about discarding the results of unwanted requests?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [代码示例 6.3](#ch06ex03) 中，您没有向服务器发送任何网络请求以获取价格报价——您在用户的计算机上生成随机数。即使用户输入了错误的股票符号，此代码示例也会调用
    `Math.random()`，这对应用程序的性能影响微乎其微。在现实世界的应用程序中，用户的输入错误可能会生成网络请求，在返回错误输入的股票符号的报价时引入延迟。您将如何处理丢弃不想要的请求的结果？
- en: 6.4\. Discarding results of unwanted HTTP requests with switchMap
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 使用 `switchMap` 抛弃不想要的 HTTP 请求的结果
- en: One of the advantages of observables over promises is that observables can be
    cancelled. In the previous section, we offered one scenario in which a typo might
    result in a server request that returns unwanted results. Implementing master-detail
    views is another use case for a request cancellation. Say a user clicks a row
    in a list of products to see the product details that must be retrieved from the
    server. Then they change their mind and click another row, which issues another
    server request; in that case, the results of the pending request should ideally
    be discarded.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象相较于承诺的优势之一是可观察对象可以被取消。在前一节中，我们提供了一个场景，即一个打字错误可能导致服务器请求返回不希望的结果。实现主从视图是请求取消的另一个用例。比如说，当用户点击产品列表中的一行以查看必须从服务器检索的产品详情时。然后他们改变主意并点击另一行，这会发出另一个服务器请求；在这种情况下，理想情况下应该丢弃挂起的请求的结果。
- en: 'In Angular, HTTP requests return observables. Let’s look at how to discard
    the results of pending HTTP requests by creating an application that issues HTTP
    requests as the user types in the input field. We’ll use two observable streams:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，HTTP 请求返回可观察对象。让我们看看如何通过创建一个在用户在输入字段中输入时发出 HTTP 请求的应用程序来丢弃挂起的 HTTP
    请求的结果。我们将使用两个可观察流：
- en: The observable stream produced by the search `<input>` field
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由搜索 `<input>` 字段产生的可观察流
- en: The observable stream produced by the HTTP requests issued while the user is
    typing in the search field
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在搜索字段中输入时产生的 HTTP 请求的可观察流
- en: 'For this example, you’ll use the free weather service at [http://openweathermap.org](http://openweathermap.org),
    which provides an API for making weather requests for cities around the world.
    To use this service, go to OpenWeatherMap and receive an application ID (`appid`).
    This service returns the weather information as a JSON-formatted `string`. For
    example, to get the current temperature in London in Fahrenheit (`units=imperial`),
    the URL could look like this: [http://api.openweathermap.org/data/2.5/find?q=London&units=imperial&appid=12345](http://api.openweathermap.org/data/2.5/find?q=London&units=imperial&appid=12345).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将使用位于 [http://openweathermap.org](http://openweathermap.org) 的免费天气服务，该服务为全球各地的城市提供天气请求的
    API。要使用此服务，请访问 OpenWeatherMap 并接收一个应用程序 ID (`appid`)。此服务以 JSON 格式返回天气信息。例如，要获取伦敦当前的华氏温度
    (`units=imperial`)，URL 可能如下所示：[http://api.openweathermap.org/data/2.5/find?q=London&units=imperial&appid=12345](http://api.openweathermap.org/data/2.5/find?q=London&units=imperial&appid=12345)。
- en: You’ll construct the request URL by concatenating the base URL with the entered
    city name and the application ID. As the user enters the letters of the city name,
    the code subscribes to the event stream and issues HTTP requests. If a new request
    is issued before the response from the previous one comes back, the `switchMap`
    operator (explained in [section D.8](kindle_split_028.xhtml#app04lev1sec8) in
    [appendix D](kindle_split_028.xhtml#app04)) cancels and discards the previous
    inner observable (so the results of the previous HTTP request never reach the
    browser) and sends the new one to this weather service. This example, shown in
    the following listing, also uses the `FormControl` directive to generate an observable
    stream from the input field where the user enters the name of the city.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过将基本 URL 与输入的城市名称和应用程序 ID 连接来构建请求 URL。当用户输入城市名称的字母时，代码会订阅事件流并发出 HTTP 请求。如果在上一个响应返回之前发出新的请求，`switchMap`
    操作符（在 [附录 D](kindle_split_028.xhtml#app04) 中的 [第 D.8 节](kindle_split_028.xhtml#app04lev1sec8)
    解释）将取消并丢弃先前的内部可观察对象（因此先前的 HTTP 请求的结果永远不会到达浏览器），并将新的请求发送到这个天气服务。以下列表中的示例还使用了 `FormControl`
    指令从用户输入城市名称的输入字段生成可观察的流。
- en: Listing 6.4\. weather/app.component
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. weather/app.component
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Creates the subscription in ngOnInit(), which is invoked after component
    properties are initialized**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 `ngOnInit()` 中创建订阅，该函数在组件属性初始化后调用**'
- en: '***2* The switchMap operator takes the entered value from the input field (the
    first observable) and passes it to the getWeather() method, which issues the HTTP
    request to the weather service.**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `switchMap` 操作符从输入字段中获取输入值（第一个可观察对象）并将其传递给 `getWeather()` 方法，该方法向天气服务发出
    HTTP 请求。**'
- en: '***3* Initializes the weather variable with the info on temperature and humidity**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用温度和湿度信息初始化天气变量**'
- en: '***4* The getWeather() method constructs the URL and defines the HTTP GET request.**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* `getWeather()` 方法构建 URL 并定义 HTTP GET 请求。**'
- en: '***5* Intercepts errors if the user enters a city that doesn’t exist**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果用户输入的城市不存在，则拦截错误**'
- en: '***6* To keep the app running, returns an empty observable in case of 404**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 为了使应用程序继续运行，在发生 404 错误时返回一个空的观察对象**'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Starting from TypeScript 2.7, you need to initialize the class variables either
    during declaration or in the constructor: for example, `weather = ''''`. If you
    don’t want to do this, set the TypeScript compiler’s `strictPropertyInitialization`
    option to `false`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从 TypeScript 2.7 开始，您需要在声明或构造函数中初始化类变量：例如，`weather = ''`。如果您不想这样做，请将 TypeScript
    编译器的 `strictPropertyInitialization` 选项设置为 `false`。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Note two observables in [listing 6.4](#ch06ex04):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 [列表 6.4](#ch06ex04) 中的两个可观察对象：
- en: The `FormControl` directive creates an observable from the input field events
    (`this.searchInput.valueChanges`).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl` 指令从输入字段事件（`this.searchInput.valueChanges`）创建一个可观察对象。'
- en: '`getWeather()` also returns an observable.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getWeather()` 也返回一个可观察对象。'
- en: 'We often use the `switchMap` operator when the data generated by the outer
    observable (the `FormControl`, in this case) is given to the inner observable
    (the `getWeather()` function): Observable1 - > `switchMap(function)` - > Observable2
    - > `subscribe()`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当外部可观察对象（在这种情况下为 `FormControl`）生成数据传递给内部可观察对象（`getWeather()` 函数）时，我们经常使用 `switchMap`
    操作符：可观察对象 1 -> `switchMap(function)` -> 可观察对象 2 -> `subscribe()`。
- en: If Observable1 pushes the new value, but the inner Observable2 hasn’t finished
    yet, Observable2 gets cancelled. We’re switching over from the current inner observable
    to the new one, and the `switchMap` operator unsubscribes from the pending Observable2
    and resubscribes again to handle the new value produced by Observable1.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Observable1推送了新值，但内部Observable2还没有完成，Observable2会被取消。我们正在从当前的内部观察者切换到新的观察者，`switchMap`操作符会取消订阅挂起的Observable2并重新订阅以处理Observable1产生的新值。
- en: In [listing 6.4](#ch06ex04), if the observable stream from the UI pushes the
    next value before the observable returned by `getWeather()` has emitted a value,
    `switchMap` kills the observable from `getWeather()`, gets the new value for the
    city from the UI, and invokes `getWeather()` again. Cancelling `getWeather()`
    results in `HttpClient` discarding the results of the pending HTTP request that
    was slow and didn’t complete in time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表6.4](#ch06ex04)中，如果UI的观察者流在`getWeather()`返回的观察者发出值之前推送了下一个值，`switchMap`会杀死`getWeather()`的观察者，从UI获取城市的新值，并再次调用`getWeather()`。取消`getWeather()`会导致`HttpClient`丢弃缓慢且未及时完成的挂起HTTP请求的结果。
- en: The `subscribe()` method has only a callback for handling data coming from the
    server, where you extract the temperature and humidity from the returned JSON.
    If the user makes a request to a nonexistent city, the API offered by this weather
    service returns 404. You intercept and handle this error in the `catchError` operator.
    Imagine a slow typer who enters `Lo` while trying to find the weather in *London*.
    The HTTP request for `Lo` goes out, a 404 is returned, and you create an empty
    observable so the `subscribe()` method will get an empty result, which is not
    an error.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe()`方法只有一个用于处理来自服务器的数据的回调，其中您可以从返回的JSON中提取温度和湿度。如果用户请求一个不存在的城市，这个天气服务提供的API会返回404。您在`catchError`操作符中拦截并处理这个错误。想象一下，一个打字慢的用户在尝试查找伦敦的天气时输入了`Lo`。对`Lo`的HTTP请求发出，返回了404，然后您创建了一个空的观察者，以便`subscribe()`方法得到一个空的结果，这并不是一个错误。'
- en: 'To run this app, you need to first obtain your own key (it takes one minute)
    at [http://api.openweathermap.org](http://api.openweathermap.org) and replace
    12345 in the code in [listing 6.4](#ch06ex04) with your own key. Then you can
    run this app with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此应用，您需要首先在[http://api.openweathermap.org](http://api.openweathermap.org)获取您自己的密钥（需要一分钟），并将[列表6.4](#ch06ex04)中的代码中的12345替换为您自己的密钥。然后您可以使用以下命令运行此应用：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The browser will open the app at http://localhost:4200, rendering a window with
    a single input field where you can enter the city name. [Figure 6.2](#ch06fig02)
    shows the network traffic as you type the word *London* on a computer with a fast
    200 Mbps internet connection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将在http://localhost:4200打开应用，渲染一个包含单个输入字段的窗口，您可以在其中输入城市名称。[图6.2](#ch06fig02)显示了在具有快速200
    Mbps互联网连接的计算机上键入单词*London*时的网络流量。
- en: Figure 6.2\. Getting weather without throttling
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2. 不进行节流获取天气
- en: '![](Images/06fig02_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片6.2](Images/06fig02_alt.jpg)'
- en: In this case, six HTTP requests were made and returned the HTTP responses. Read
    the queries in the first two. The requests for the cities `L` and `Lo` came back
    with 404\. But requests for `Lon`, `Lond`, `Londo`, and `London` completed successfully,
    sending back hundreds of bytes each, unnecessarily congesting the network. Add
    these bytes up—you’ll get 3,134 bytes in total, but users on a fast network wouldn’t
    even notice this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，进行了六次HTTP请求并返回了HTTP响应。阅读前两行的查询。对于城市`L`和`Lo`的请求返回了404。但对于`Lon`、`Lond`、`Londo`和`London`的请求则成功完成，每个请求都返回了数百字节，不必要地拥塞了网络。将这些字节加起来——总共是3,134字节，但在快速网络上的用户甚至都不会注意到这一点。
- en: Now let’s emulate a slow network and verify that discarding unwanted results
    works. On a slow internet connection, each HTTP request takes more than 200 ms
    to complete, but the user keeps typing, and the responses of the pending HTTP
    requests should be discarded.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们模拟一个慢速网络并验证丢弃不需要的结果是否有效。在慢速互联网连接上，每个HTTP请求需要超过200毫秒才能完成，但用户一直在打字，挂起的HTTP请求的响应应该被丢弃。
- en: The Network tab of Chrome Developer Tools has a dropdown with selected option
    Online, which means use the full connection speed. Now, let’s emulate a slow connection
    by selecting the Slow 3G option instead. Retyping the word *London* results in
    multiple HTTP requests, but the connection is slow now, and the results of pending
    requests are discarded and never reach the browser, as shown in [figure 6.3](#ch06fig03).
    Note that this time you get 789 bytes back, which is much better than 3,134.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 开发者工具的网络标签页有一个下拉菜单，默认选项为 Online，这意味着使用完整的连接速度。现在，让我们通过选择 Slow 3G 选项来模拟慢速连接。重新输入单词
    *London* 会产生多个 HTTP 请求，但现在连接变慢了，挂起的请求的结果被丢弃，并且永远不会到达浏览器，如图 [6.3](#ch06fig03) 所示。请注意，这次你收到了
    789 字节，这比 3,134 字节要好得多。
- en: Figure 6.3\. Getting weather with throttling
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. 使用节流获取天气
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig03_alt.jpg)'
- en: With very little programming, you save bandwidth by eliminating the need for
    the browser to handle four HTTP responses for cities you’re not interested in
    and that may not even exist. Just by adding one line with `switchMap`, you accomplish
    a lot. Indeed, with good frameworks or libraries, you write less code. Angular
    pipes also allow you to achieve more with less manual coding, and in the next
    section you’ll learn about `AsyncPipe`, which will eliminate the need to make
    the `subscribe()` call.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过非常少的编程，你可以通过消除浏览器处理你感兴趣的城市的四个 HTTP 响应的需求来节省带宽，这些城市可能甚至不存在。只需添加一行 `switchMap`，你就能完成很多事情。确实，使用好的框架或库，你写的代码更少。Angular
    管道还允许你用更少的手动编码实现更多功能，在下一节中，你将了解 `AsyncPipe`，它将消除调用 `subscribe()` 的需求。
- en: 6.5\. Using AsyncPipe
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 使用 AsyncPipe
- en: '[Section 2.5](kindle_split_011.xhtml#ch02lev1sec5) in [chapter 2](kindle_split_011.xhtml#ch02)
    introduced you to pipes, which are used in a component template and can convert
    the data right inside the template. For example, a `DatePipe` could convert and
    display a date in the specified format. A pipe is placed in the template after
    the vertical bar, for example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 2.5 节](kindle_split_011.xhtml#ch02lev1sec5) 在 [第 2 章](kindle_split_011.xhtml#ch02)
    中介绍了管道，它们用于组件模板中，可以在模板内直接转换数据。例如，`DatePipe` 可以将日期转换为指定的格式并显示。管道放置在模板中的竖线之后，例如：'
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code snippet, `birthday` is a component property of type `Date`. Angular
    offers an `AsyncPipe` that can take a component property of type `Observable`,
    autosubscribe to it, and render the result in the template.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`birthday` 是一个类型为 `Date` 的组件属性。Angular 提供了一个 `AsyncPipe`，它可以接受类型为 `Observable`
    的组件属性，自动订阅它，并在模板中渲染结果。
- en: The next listing declares a `numbers` variable of type `Observable<number>`
    and initializes it with an observable that emits a sequential number with an interval
    of 1 second. The `take(10)` operator will limit the emission to the first 10 numbers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表声明了一个类型为 `Observable<number>` 的 `numbers` 变量，并用一个每秒发出连续数字的观察者初始化它。`take(10)`
    操作符将限制发射到前 10 个数字。
- en: Listing 6.5\. asyncpipe/app.component.ts
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. asyncpipe/app.component.ts
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Autosubscribes to observable numbers**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 自动订阅可观察的数字**'
- en: '***2* Emits sequential numbers every second**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每秒发出连续数字**'
- en: '***3* Takes only 10 numbers from 0 to 9**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 只取 0 到 9 之间的 10 个数字**'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Starting in Angular 6, instead of `Observable.interval()`, just write `interval()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Angular 6 开始，不再使用 `Observable.interval()`，只需写 `interval()`。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As explained in [appendix D](kindle_split_028.xhtml#app04), to start getting
    data from an observable, we need to invoke the `subscribe()` method. In [listing
    6.5](#ch06ex05), there’s no explicit invocation of `subscribe()`, but note the
    `async` pipe in the template. The `async` pipe autosubscribes to the `numbers`
    observable and displays the numbers from 0 to 9 as they’re being pushed by the
    observable. To see this example in action, run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [附录 D](kindle_split_028.xhtml#app04) 中所述，要从可观察对象获取数据，我们需要调用 `subscribe()`
    方法。在 [列表 6.5](#ch06ex05) 中，没有显式调用 `subscribe()`，但请注意模板中的 `async` 管道。`async` 管道会自动订阅
    `numbers` 可观察对象，并显示可观察对象推送的从 0 到 9 的数字。要查看此示例的实际效果，请运行以下命令：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This was a pretty simple example that never throws any errors. In real-world
    applications, things happen, and you should add error handling to the observable
    with the `catch` operator, as you did in the previous section in the weather example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的例子，它永远不会抛出任何错误。在现实世界的应用中，事情会发生，你应该使用 `catch` 操作符向可观察对象添加错误处理，就像你在上一节中的天气示例中所做的那样。
- en: Now let’s consider one more app that uses the `async` pipe. This time, you’ll
    invoke a function that returns an observable array of products, and you’ll use
    the `async` pipe to render its values. This app will use the `ProductService`
    injectable, whose `getProducts()` method returns an observable array of the `Product`
    objects, as shown in the following listing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个使用`async`管道的应用程序。这次，你将调用一个返回产品观察者数组的函数，并使用`async`管道来渲染其值。此应用程序将使用可注入的`ProductService`，其`getProducts()`方法返回`Product`对象的观察者数组，如以下列表所示。
- en: Listing 6.6\. asyncpipe-products/product.service.ts
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. asyncpipe-products/product.service.ts
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Defines the Product type**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义产品类型**'
- en: '***2* Populates the products array**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 填充产品数组**'
- en: '***3* Turns the products array into an observable**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将产品数组转换为观察者**'
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Starting from Angular 6, instead of `Observable.of()` just write `of()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular 6开始，只需写`of()`而不是`Observable.of()`。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The next listing shows an app component that gets the `ProductService` injected
    and invokes `getProducts()`, which returns an observable. Note that there’s no
    explicit invocation of `subscribe()` there—you use the `async` pipe in the template.
    In this component, you use Angular’s structural directive `*ngFor` to iterate
    through products and for each product render the `<li>` element with the product
    title and price, as you can see in the following listing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了获取`ProductService`注入并调用`getProducts()`的应用组件，它返回一个观察者。请注意，那里没有显式调用`subscribe()`——你在模板中使用`async`管道。在这个组件中，你使用Angular的结构指令`*ngFor`遍历产品，并为每个产品渲染带有产品标题和价格的`<li>`元素，如以下列表所示。
- en: Listing 6.7\. asyncpipe-products/app.component.ts
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. asyncpipe-products/app.component.ts
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Iterates through products and pipes them to async for subscription**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历产品并将它们通过异步管道进行订阅**'
- en: '***2* Renders the product title and price**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 渲染产品标题和价格**'
- en: '***3* Declares the observable products$ using generics syntax for type checking**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用泛型语法声明观察者`products$`以进行类型检查**'
- en: '***4* Assigns the value to products$**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将值分配给`products$**`'
- en: It’s important to understand that the `getProducts()` function returns an empty
    observable that hasn’t emitted anything yet, and you assign it to the `products$`
    variable. No data is pushed to this component until you subscribe to `products$`,
    and the `async` pipe does it in the template.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`getProducts()`函数返回一个空的观察者（observable），它还没有发出任何内容，并且你将其分配给`products$`变量。在订阅`products$`之前，不会向此组件推送任何数据，并且`async`管道在模板中执行此操作。
- en: 'To see this application in action, run the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请运行以下命令：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Figure 6.4](#ch06fig04) shows how the browser will render products.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.4](#ch06fig04)显示了浏览器将如何渲染产品。'
- en: Figure 6.4\. Rendering observable products
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. 渲染观察者产品
- en: '![](Images/06fig04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig04.jpg)'
- en: 'Since we’re talking about pipes, let’s apply the Angular built-in `currency`
    pipe to show the price in US dollars. All it takes is adding the `currency` pipe
    right after `product.price`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论管道，让我们应用Angular内置的`currency`管道来显示美元价格。只需在`product.price`之后添加`currency`管道即可：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can read more about the `currency` pipe and its parameters at [https://angular.io/api/common/CurrencyPipe](https://angular.io/api/common/CurrencyPipe).
    [Figure 6.5](#ch06fig05) shows how the browser will render products after applying
    the currency pipe for US dollars.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://angular.io/api/common/CurrencyPipe](https://angular.io/api/common/CurrencyPipe)上阅读更多关于`currency`管道及其参数的信息。[图6.5](#ch06fig05)显示了浏览器在应用货币管道后如何渲染美元产品。
- en: Figure 6.5\. Rendering observable products
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 渲染观察者产品
- en: '![](Images/06fig05.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig05.jpg)'
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using async as**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用async as**'
- en: 'With async pipes, you can use the special syntax `async as` to avoid creating
    multiple subscriptions in templates. Consider the following code, which creates
    two subscriptions in a template, assuming that there’s an observable `product$`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步管道（async pipes），你可以使用特殊的语法`async as`来避免在模板中创建多个订阅。考虑以下代码，它在模板中创建了两个订阅，假设存在一个名为`product$`的观察者：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* First subscription**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第一次订阅**'
- en: '***2* Second subscription**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第二次订阅**'
- en: 'The following code rewrites the previous by creating a local template variable,
    `product`, which would store the reference to a single subscription and then reuse
    it in multiple places in the same template:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过创建一个局部模板变量`product`，该变量将存储单个订阅的引用，并在同一模板的多个位置重用它来重写之前的代码：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Creates a subscription and stores it in the product variable**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建订阅并将其存储在产品变量中**'
- en: '***2* Uses the subscription called product**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用名为 product 的订阅**'
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now let’s see where observables can be used during navigation with the router.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在路由器导航过程中如何使用可观察属性。
- en: 6.6\. Observables and the router
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6\. 可观察属性和路由器
- en: Angular Router offers you observable properties in various classes. Is there
    an easy way to find them? The fastest way is to open the type definition file
    (see [appendix B](kindle_split_026.xhtml#app02)) for the class you’re interested
    in. Usually, IDEs offer you an option on the context (right-click) menu to go
    to the declaration of the selected class. Let’s use the `ActivatedRoute` class
    as an example and take a look at its declaration. It’s located in the router_state.d.ts
    file (we removed some content for brevity), as shown in the following listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器在多个类中提供了可观察属性。有没有简单的方法可以找到它们？最快的方法是打开你感兴趣的类的类型定义文件（见附录 B（kindle_split_026.xhtml#app02））。通常，IDEs
    在上下文（右键单击）菜单中提供选项，以便转到所选类的声明。让我们以 `ActivatedRoute` 类为例，看看它的声明。它位于 router_state.d.ts
    文件中（我们为了简洁起见删除了一些内容），如下所示。
- en: Listing 6.8\. A fragment from `ActivatedRoute`
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. `ActivatedRoute` 的一个片段
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In [section 3.4](kindle_split_012.xhtml#ch03lev1sec4) in [chapter 3](kindle_split_012.xhtml#ch03),
    you injected `ActivatedRoute` into the `ProductDetailComponent` so it could receive
    the route parameters during navigation. Back then, you used the `snapshot` property
    of `ActivatedRoute` to get the value from the parent route. This technique works
    fine if you need to get parameters that never change. But if the parameters in
    the parent route change over time, you need to subscribe to an observable such
    as `paramMap`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章的第 3.4 节（kindle_split_012.xhtml#ch03lev1sec4）中，你将 `ActivatedRoute` 注入到
    `ProductDetailComponent` 中，以便在导航期间接收路由参数。当时，你使用了 `ActivatedRoute` 的 `snapshot`
    属性来获取父路由的值。如果你需要获取永远不会改变的参数，这种技术效果很好。但是，如果父路由中的参数随时间变化，你需要订阅一个可观察的属性，如 `paramMap`。
- en: Why would the value of the parent’s parameter change? Imagine a component that
    shows a list of products, and when the user selects a product, the app navigates
    to the route that shows product details. Often, these use cases are called *master-detail
    communications*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么父参数的值会改变？想象一个显示产品列表的组件，当用户选择一个产品时，应用会导航到显示产品详情的路由。通常，这些用例被称为 *主-详细信息通信*。
- en: 'When the user clicks the product for the first time, the router performs the
    following steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户第一次点击产品时，路由器执行以下步骤：
- en: '**1**.  Instantiates `ProductDetailComponent`'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 实例化 `ProductDetailComponent`'
- en: '**2**.  Attaches `ProductDetailComponent` to the DOM object'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 将 `ProductDetailComponent` 组件附加到 DOM 对象'
- en: '**3**.  Renders `ProductDetailComponent` in the router outlet'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 在路由出口处渲染 `ProductDetailComponent` 组件'
- en: '**4**.  Passes the parameter (for example, product ID) to `ProductDetailComponent`'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 将参数（例如，产品 ID）传递给 `ProductDetailComponent`'
- en: If the user selects another product in the parent’s component, the first three
    steps won’t be performed, because `ProductDetailComponent` is already instantiated,
    attached to the DOM, and rendered by the browser. The router will just pass a
    newly selected product ID to `ProductDetailComponent`, and that’s why subscribing
    to `paramMap` is the way to go. The following listing implements this scenario,
    starting from `AppComponent`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在父组件中选择另一个产品，前三个步骤将不会执行，因为 `ProductDetailComponent` 已经实例化，附加到 DOM 上，并且由浏览器渲染。路由器将只传递一个新的产品
    ID 到 `ProductDetailComponent`，这就是为什么订阅 `paramMap` 是最佳做法。以下列表实现了这个场景，从 `AppComponent`
    开始。
- en: Listing 6.9\. master-detail/app.component.ts
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. master-detail/app.component.ts
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Defines the Product type**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义产品类型**'
- en: '***2* When the user selects an item, invokes the onSelect() handler**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当用户选择一个项目时，调用 onSelect() 处理程序**'
- en: '***3* Injects the router so you can use its navigate() method**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入路由器以便可以使用其 navigate() 方法**'
- en: '***4* Navigates to the productDetail route**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导航到产品详情路由**'
- en: 'The routes for this app are configured as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用的路由配置如下：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ProductDetailComponent`’s code that subscribes to `paramMap` is shown in
    the following listing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了 `ProductDetailComponent` 订阅 `paramMap` 的代码。
- en: Listing 6.10\. master-detail/product.detail.component.ts
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. master-detail/product.detail.component.ts
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Embeds the value of productId into the header**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 productId 的值嵌入到标题中**'
- en: '***2* Subscribes to the paramMap observable**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 订阅 paramMap 可观察属性**'
- en: '***3* Extracts the current product id and assigns it to the productId property
    for displaying in the UI**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从当前产品 ID 中提取并将其分配给 productId 属性以在 UI 中显示**'
- en: 'Now `ProductDetailComponent` will render the text identifying the current product
    according to user selections. [Figure 6.6](#ch06fig06) shows how the UI looks
    after the user selects the second product in the list. To see this app in action,
    run the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ProductDetailComponent` 将根据用户选择渲染识别当前产品的文本。[图 6.6](#ch06fig06) 展示了用户在列表中选择第二个产品后
    UI 的外观。要查看此应用程序的实际运行情况，请运行以下命令：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Figure 6.6\. Implementing a master-detail scenario
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.6\. 实现主从场景
- en: '![](Images/06fig06_alt.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片 6.6](Images/06fig06_alt.jpg)'
- en: In [chapter 7](kindle_split_016.xhtml#ch07), you’ll rewrite ngAuction, and you’ll
    see how the `ObservableMedia` class from the Flex Layout library will notify you
    about changes in the screen size (for example, the user reduces the width of the
    window). This observable is also quite handy in changing the UI layout based on
    the viewport width of smaller devices like smartphones and tablets.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](kindle_split_016.xhtml#ch07) 中，您将重写 ngAuction，您将看到 Flex Layout 库中的
    `ObservableMedia` 类如何通知您屏幕尺寸的变化（例如，用户减小窗口宽度）。此可观察对象在根据智能手机和平板电脑等较小设备的视口宽度更改 UI
    布局时也非常方便。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Using observable data streams simplifies asynchronous programming. You can subscribe
    to and unsubscribe from a stream as you need.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可观察的数据流简化了异步编程。您可以根据需要订阅和取消订阅流。
- en: Using the `async` pipe is a preferable way to subscribe to observables.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `async` 管道是订阅可观察对象的首选方式。
- en: The `async` pipe automatically unsubscribes from the observable.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` 管道会自动取消订阅可观察对象。'
- en: Using the `switchMap` operator combined with `HttpClient` allows you to easily
    discard unwanted results of pending HTTP requests.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `switchMap` 操作符结合 `HttpClient` 可以让您轻松丢弃挂起 HTTP 请求的不想要的输出。
