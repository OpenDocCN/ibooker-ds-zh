- en: 7 Designing a reactive application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 设计一个反应性应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What a reactive application is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应性应用程序是什么
- en: Introducing the reactive application scenario used throughout part 2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍在第2部分中使用的反应性应用程序场景
- en: The first part of this book taught you *asynchronous programming* with Vert.x.
    This is key to writing scalable and resource-efficient applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分教你使用 Vert.x 进行 *异步编程*。这是编写可伸缩和资源高效应用程序的关键。
- en: It is now time to explore what makes an application *reactive*, as we strive
    for both *scalability* and *dependability*. To do that, we will focus the following
    chapters on developing a fully reactive application out of several event-driven
    microservices. In this chapter, we’ll specify these services.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索是什么使一个应用程序 *具有反应性*，因为我们追求的是 *可伸缩性* 和 *可靠性*。为了做到这一点，我们将以下章节的重点放在从几个事件驱动的微服务中开发一个完全反应性应用程序上。在本章中，我们将指定这些服务。
- en: 7.1 What makes an application reactive
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 什么是使应用程序具有反应性的因素
- en: 'In previous chapters we covered some elements of *reactive*:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了一些 *reactive* 的元素：
- en: Back-pressure, as a necessary ingredient in asynchronous stream processing to
    regulate event throughput
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力反馈，作为异步流处理中调节事件吞吐量的必要成分
- en: Reactive programming as a way to compose asynchronous operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程作为一种组合异步操作的方法
- en: 'It is now time to explore the last facet: *reactive applications*. In chapter
    1 I summarized *The Reactive Manifesto*, which declares that reactive applications
    are *responsive*, *resilient*, *elastic*, and *message-driven*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索最后一个方面：*反应性应用程序*。在第1章中，我总结了 *反应性宣言*，它宣称反应性应用程序是 *响应性*、*弹性*、*可伸缩性* 和 *消息驱动*
    的。
- en: The key property of reactive applications is that they remain *responsive* under
    demanding workloads and when they face the failure of other services. By “responsive,”
    we mean that latency for service response remains under control. A good responsiveness
    example would be a service that responds within 500 ms in the 99% percentile,
    provided that 500 ms is a good number given the service’s functional requirements
    and operational constraints.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 反应性应用程序的关键特性是它们在面临繁重的工作负载和其他服务的故障时仍然保持 *响应性*。通过“响应性”，我们指的是服务响应的延迟保持可控。一个良好的响应性例子是一个在99%的百分位数内响应时间在500毫秒内的服务，前提是考虑到服务的功能需求和操作限制，500毫秒是一个合理的数字。
- en: An increasing workload will almost always degrade latency, but in the case of
    a reactive application, the goal is to avoid latency explosion when the service
    is under stress. Part 1 of this book mostly taught you asynchronous programming
    with Vert.x, which is the key ingredient for facing growing workloads. You saw
    that asynchronous processing of events allowed you to multiplex thousands of open
    network connections on a single thread. This model (when implemented correctly!)
    is much more resource-friendly and scalable than the traditional “1 thread per
    connection” model.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着工作负载的增加，几乎总是会导致延迟降低，但在反应性应用程序的情况下，目标是避免在服务受到压力时发生延迟爆炸。本书的第一部分主要教你使用 Vert.x
    进行异步编程，这是应对增长工作负载的关键成分。你看到异步处理事件允许你在单个线程上复用数千个打开的网络连接。这种模型（如果正确实现！）比传统的“每个连接一个线程”模型更加资源友好和可伸缩。
- en: 'So Vert.x gives us a foundation for asynchronous programming on top of the
    JVM in order to meet demanding workloads, but what about dealing with failure?
    This is the other core challenge that we have to meet, and the answer is not a
    magic tool we can pick off the shelf. Suppose we have a service that talks to
    a database that becomes irresponsive because of an internal problem, like a deadlock.
    Some time will elapse before our service is notified of an error, perhaps in the
    form of a TCP connection timeout. In such a case, the latency explodes. By contrast,
    if the database is down, we get an immediate TCP connection error: latency is
    very good, but since the service cannot talk to its database, it is unable to
    process a request.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 Vert.x 为我们在 JVM 上进行异步编程提供了一个基础，以满足繁重的工作负载，但如何处理故障呢？这是我们必须要面对的另一个核心挑战，而且答案不是我们可以从货架上拿出的魔法工具。假设我们有一个与数据库通信的服务，由于内部问题（如死锁）变得无响应。在服务被通知错误之前，会有一些时间流逝，可能以
    TCP 连接超时的方式出现。在这种情况下，延迟会爆炸。相比之下，如果数据库宕机，我们会立即收到 TCP 连接错误：延迟非常好，但由于服务无法与其数据库通信，它无法处理请求。
- en: 'You will see in the last chapter of this part how to experiment with “what
    happens when things go wrong,” and we’ll discuss possible solutions for keeping
    services responsive. You might be tempted to enforce strict timeouts on all calls
    to other services (including databases), or to use *circuit-breakers* (more on
    that in the last chapter) everywhere, but a more analytical approach will help
    you see which solution to use, if any, and when. It is also important to see failure
    in the light of a service’s functional requirements and application domain: the
    response to failure may not always be an error. For instance, if we can’t get
    the latest temperature update from a sensor, we may serve the last known value
    and attach a timestamp to it, so the requester has all the necessary context attached
    to the data.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本部分的最后一章中看到如何进行“当事情出错时会发生什么”的实验，我们将讨论保持服务响应性的可能解决方案。你可能倾向于对所有调用其他服务的调用（包括数据库）实施严格的超时，或者在每个地方使用*断路器*（更多内容将在最后一章中介绍），但更分析性的方法将帮助你看到如果需要，应该使用哪种解决方案，以及何时使用。同时，也很重要从服务功能需求和应用程序领域来审视失败：对失败的响应可能并不总是错误。例如，如果我们无法从传感器获取最新的温度更新，我们可能提供最后已知值并附上时间戳，以便请求者有所有必要的数据上下文。
- en: It is now time to build a reactive application, both to explore some elements
    of the Vert.x stack and to learn how to concretely build *responsive* applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建一个响应式应用程序了，这不仅是为了探索Vert.x堆栈的一些元素，也是为了学习如何具体构建*响应式*应用程序。
- en: 7.2 The 10k steps challenge scenario
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 10k步挑战场景
- en: The application that we will implement in the upcoming chapters supports a (not
    so) fictional fitness-tracker challenge. Suppose we want to build an application
    to track and score users’ steps, as illustrated in figure 7.1.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中实现的应用程序支持一个（并非那么）虚构的健身追踪器挑战。假设我们想要构建一个应用程序来跟踪和评分用户的步数，如图7.1所示。
- en: '![](../Images/CH07_F01_Ponge.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F01_Ponge.png)'
- en: Figure 7.1 10k steps challenge application and actors overview
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 10k步挑战应用程序和参与者概述
- en: 'The application described in figure 7.1 would work as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1中描述的应用程序将按以下方式工作：
- en: Users sport connected pedometers that track how many steps they take.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户佩戴连接的计步器，以跟踪他们走了多少步。
- en: The pedometers regularly send step-count updates to the application that manages
    the challenge.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计步器定期向管理挑战的应用程序发送步数更新。
- en: The goal is to walk at least 10,000 steps each day, and users are greeted by
    an email every day when they do so.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是每天至少走10,000步，当用户这样做时，每天都会收到一封电子邮件。
- en: Users may choose to be publicly listed in rankings of step counts over the last
    24 hours.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以选择在过去的24小时内公开列出步数排名。
- en: Participants can also connect to a web application to see their data and update
    their information, such as their city and whether they want to appear in public
    rankings.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者还可以连接到网络应用程序来查看他们的数据和更新他们的信息，例如他们的城市以及他们是否希望出现在公共排名中。
- en: The web application allows new users to register by providing their device identifier
    as well as some basic information, such as their city and whether they intend
    to appear in public rankings (figure 7.2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序允许新用户通过提供他们的设备标识符以及一些基本信息（如他们的城市以及他们是否希望出现在公共排名中）来注册（图7.2）。
- en: '![](../Images/CH07_F02_Ponge.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F02_Ponge.png)'
- en: Figure 7.2 Screenshot of the user web application registration form
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 用户网络应用程序注册表单截图
- en: Once connected, a user can update some basic details and get reminded of their
    total steps, monthly steps, and daily steps (figure 7.3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，用户可以更新一些基本详情，并提醒他们总步数、月步数和日步数（图7.3）。
- en: '![](../Images/CH07_F03_Ponge.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F03_Ponge.png)'
- en: Figure 7.3 Screenshot of the user web application user-details page
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 用户网络应用程序用户详情页截图
- en: There is also a separate web application that offers a public dashboard (figure
    7.4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个独立的网络应用程序，提供公共仪表板（图7.4）。
- en: '![](../Images/CH07_F04_Ponge.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F04_Ponge.png)'
- en: Figure 7.4 Screenshot of the public dashboard web application
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 公共仪表板网络应用程序截图
- en: The dashboard offers a ranking of public profiles over the last 24 hours, the
    current pedometer device update throughput, and trends by city. All the information
    displayed in the dashboard is updated live.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板提供了过去24小时内公共个人资料的排名、当前计步器设备更新吞吐量以及按城市划分的趋势。仪表板中显示的所有信息都是实时更新的。
- en: 7.3 One application, many services
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 一个应用程序，多种服务
- en: 'The application is decomposed as a set of (micro) services that interact with
    each other as in figure 7.5\. Each service fulfills a single functional purpose
    and could well be used by another application. There are four public services:
    two user-facing web applications, one service for receiving pedometer device updates,
    and one service to expose a public HTTP API. The public API is used by the user
    web application, and we could similarly have mobile applications connect to it.
    There are four internal services: one to manage user profiles, one to manage activity
    data, one to congratulate users over email, and one to compute various stats over
    continuous events.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序被分解为一系列（微）服务，它们如图7.5所示相互交互。每个服务完成单一的功能目的，并且可能被另一个应用程序使用。有四个公共服务：两个面向用户的Web应用程序、一个用于接收计步器设备更新的服务以及一个用于公开HTTP
    API的服务。公共API被用户Web应用程序使用，同样，移动应用程序也可以连接到它。有四个内部服务：一个用于管理用户配置文件、一个用于管理活动数据、一个用于通过电子邮件祝贺用户，以及一个用于计算连续事件的各种统计数据。
- en: '![](../Images/CH07_F05_Ponge.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5](../Images/CH07_F05_Ponge.png)'
- en: Figure 7.5 Overview of the application architecture
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 应用程序架构概述
- en: Note You may have heard of *command query responsibility segregation* (CQRS)
    and *event-sourcing*, which are patterns found in event-driven architectures.[1](#pgfId-1012934)
    CQRS structures how to read and write information, while event sourcing is about
    materializing the application state as a sequence of facts. Our proposed application
    architecture relates to both notions, but because it’s not strictly faithful to
    the definitions, I prefer to just call it an “event-driven microservices architecture.”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能听说过*命令查询责任分离*（CQRS）和*事件溯源*，这些是事件驱动架构中发现的模式。[1](#pgfId-1012934) CQRS定义了如何读取和写入信息，而事件溯源则是将应用程序状态作为一系列事实来体现。我们提出的应用架构与这两个概念都相关，但由于它并不严格符合定义，我更喜欢将其称为“事件驱动微服务架构”。
- en: 'All services are powered by Vert.x, and we also need some third-party middleware,
    labelled “infrastructure services” in figure 7.5\. We’ll use two different types
    of databases: a document-oriented database (MongoDB) and a relational database
    (PostgreSQL). We need an SMTP server to send emails, and Apache Kafka is used
    for event-stream processing between some services. Because the ingestion service
    may receive updates from HTTP and AMQP, we’ll also use an ActiveMQ Artemis server.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务都由Vert.x提供支持，我们还需要一些第三方中间件，如图7.5中标记的“基础设施服务”。我们将使用两种不同类型的数据库：一种文档型数据库（MongoDB）和一种关系型数据库（PostgreSQL）。我们需要一个SMTP服务器来发送电子邮件，Apache
    Kafka用于某些服务之间的事件流处理。由于摄入服务可能从HTTP和AMQP接收更新，我们还将使用ActiveMQ Artemis服务器。
- en: 'There are two types of arrows in figure 7.5\. Event flows show important event
    exchanges between services. For instance, the ingestion service sends events to
    Kafka, whereas the event stats service both consumes and produces Kafka events.
    I also denoted dependencies: for example, the public API service depends on the
    user profile and activities services, which in turn depend on their own databases
    for data persistence.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5中有两种类型的箭头。事件流显示了服务之间的重要事件交换。例如，摄入服务向Kafka发送事件，而事件统计服务既消费又生产Kafka事件。我还指出了依赖关系：例如，公共API服务依赖于用户配置文件和活动服务，而这些服务又依赖于它们自己的数据库以实现数据持久化。
- en: We can illustrate one example of interactions between services by looking at
    how a device update impacts the dashboard web application’s city trends ranking,
    as in figure 7.6.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过观察设备更新如何影响仪表板Web应用的“城市趋势排名”，如图7.6所示，来展示服务之间交互的一个例子。
- en: '![](../Images/CH07_F06_Ponge.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6](../Images/CH07_F06_Ponge.png)'
- en: Figure 7.6 From a device update to a city trend update
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 从设备更新到城市趋势更新
- en: It all starts with a pedometer sending an update to the ingestion service, which
    verifies that the update contains all required data. The ingestion service then
    sends the update to a Kafka topic, and the pedometer device is acknowledged so
    it knows that the update has been received and will be processed. The update will
    be handled by multiple consumers listening on that particular Kafka topic, and
    among them is the activity service. This service will record the data to the PostgreSQL
    database and then publish another record to a Kafka topic with the number of steps
    recorded by the pedometer on that day. This record is picked up by the event stats
    service, which observes updates over windows of five seconds, splits them by city,
    and aggregates the number of steps. It then posts an update with the increment
    in steps observed for a given city as another Kafka record. This record is then
    consumed by the dashboard web application, which finally sends an update to all
    connected web browsers, which in turn update the display.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一切始于步数计向摄入服务发送更新，该服务验证更新是否包含所有所需数据。摄入服务然后将更新发送到Kafka主题，步数计设备得到确认，以便它知道更新已被接收并将被处理。更新将由多个在该特定Kafka主题上监听的消费者处理，其中之一是活动服务。该服务将数据记录到PostgreSQL数据库，然后向另一个Kafka主题发布一个记录，记录步数计当天记录的步数。此记录被事件统计服务拾取，该服务观察五个秒窗口内的更新，按城市分割它们，并汇总步数。然后，它发布一个更新，其中包含观察到的特定城市的步数增量作为另一个Kafka记录。然后，该记录被仪表板Web应用程序消费，最终向所有连接的Web浏览器发送更新，这些浏览器随后更新显示。
- en: About the application architecture
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于应用架构
- en: As you dig through the specifications and implementations of the services, you
    may find the decomposition a bit artificial at times. For instance, the user profile
    and activity services could well be just one, saving some requests to join data
    from the two services. Remember that the decomposition was made for pedagogical
    reasons, and to show relevant elements from the Vert.x stack.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你深入研究服务的规范和实现时，你可能会发现分解有时有点人为。例如，用户配置文件和活动服务完全可以合并为一个，从而节省一些从两个服务中合并数据的请求。记住，分解是为了教学目的，并展示Vert.x堆栈的相关元素。
- en: Making an application from (micro) services requires some compromises, especially
    as some services may be pre-existing, and you have to deal with them as they are,
    or you have limited ability to evolve them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从（微）服务构建应用程序需要一些妥协，特别是当一些服务可能是预存在的，你必须按其现状处理它们，或者你有限的能力去进化它们。
- en: You may also find that the proposed architecture is not a nicely layered one,
    with some services nicely decoupled and some others having stronger dependencies
    on others. Again, this is done intentionally for pedagogical purposes. More often
    than not, real-world applications have to make compromises to deliver working
    software rather than pursue the quest for architectural perfection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能会发现，提出的架构不是一个很好地分层的一个，有些服务很好地解耦，而有些其他服务对其他服务的依赖性更强。再次强调，这是出于教学目的故意为之。在大多数情况下，现实世界中的应用程序必须做出妥协，以交付可工作的软件，而不是追求架构的完美。
- en: 7.4 Service specifications
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4服务规范
- en: 'Let’s discuss the functional and technical specifications of the application
    services. For each service, we’ll consider the following elements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论应用服务的功能和技术规范。对于每个服务，我们将考虑以下要素：
- en: Functional overview
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能概述
- en: API description, if any
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，API描述
- en: Technical points of interest, including crash recovery
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术要点，包括崩溃恢复
- en: Scaling and deployment considerations
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模化和部署考虑因素
- en: 7.4.1 User profile service
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1用户配置文件服务
- en: 'The user profile service manages the profile data for a unique user. A user
    is identified by the following information:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 用户配置文件服务管理唯一用户的配置文件数据。用户通过以下信息识别：
- en: A username (must be unique)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户名（必须是唯一的）
- en: A password
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个密码
- en: An email address
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电子邮件地址
- en: A city
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个城市
- en: A pedometer device identifier (must be unique)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步数计设备标识符（必须是唯一的）
- en: Whether the user wants to appear in public rankings or not
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否希望出现在公共排名中
- en: The service exposes an HTTP API and persists data in a MongoDB database (see
    figure 7.7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务公开一个HTTP API，并将数据持久化在MongoDB数据库中（见图7.7）。
- en: '![](../Images/CH07_F07_Ponge.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F07_Ponge.png)'
- en: Figure 7.7 User profile service
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7用户配置文件服务
- en: The service falls into the category of CRUD (for *create*, *read*, *update*,
    and *delete*) services that sit on top of a database. Table 7.1 identifies the
    different elements of the HTTP API.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务属于 CRUD（用于 *创建*、*读取*、*更新* 和 *删除*）服务的类别，这些服务位于数据库之上。表 7.1 识别了 HTTP API 的不同元素。
- en: Table 7.1 User profile HTTP API
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 用户配置文件 HTTP API
- en: '| Purpose | Path | Method | Data | Response | Status code |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 路径 | 方法 | 数据 | 响应 | 状态码'
- en: '| Register a new user | `/register` | `POST` | Registration JSON document |
    N/A | 200 on success, 409 when the username or device identifier already exists,
    500 for technical errors |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 注册新用户 | `/register` | `POST` | 注册 JSON 文档 | N/A | 成功时返回 200，当用户名或设备标识符已存在时返回
    409，技术错误时返回 500'
- en: '| Get a user’s details | `/<username>` | `GET` | N/A | User data in JSON |
    200 on success, 404 if the username does not exist, 500 for technical errors |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 获取用户详细信息 | `/<username>` | `GET` | N/A | JSON 格式的用户数据 | 成功时返回 200，用户名不存在时返回
    404，技术错误时返回 500'
- en: '| Update some user details | `/<username>` | `PUT` | User data in JSON | N/A
    | 200 on success, 500 for technical errors |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 更新某些用户详细信息 | `/<username>` | `PUT` | JSON 格式的用户数据 | N/A | 成功时返回 200，技术错误时返回
    500'
- en: '| Credentials validation | `/authenticate` | `POST` | Credentials in JSON |
    N/A | 200 on success, 401 when authentication fails |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 凭据验证 | `/authenticate` | `POST` | JSON 格式的凭据 | N/A | 成功时返回 200，认证失败时返回 401'
- en: '| Reverse lookup of a user by their device | `/owns/<deviceId>` | `GET` | N/A
    | JSON data with the username owning the device | 200 on success, 404 if the device
    does not exist, 500 for technical errors |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 通过设备查找用户 | `/owns/<deviceId>` | `GET` | N/A | 包含拥有设备用户名的 JSON 数据 | 成功时返回
    200，设备不存在时返回 404，技术错误时返回 500'
- en: This service is not to be publicly exposed; it is meant to be consumed by other
    services. There is no authentication mechanism in place. The service is here to
    provide a facade for operations on top of the database. Both the service and the
    database can be scaled independently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务不应公开暴露；它旨在由其他服务消费。没有设置认证机制。此服务旨在提供对数据库操作的伪装。服务和数据库都可以独立扩展。
- en: Note The API described in table 7.1 does not follow the architectural principles
    of *representational state transfer* (REST) interfaces. A *RESTful* interface
    would expose user resources as, say, `/user/<username>`, and instead of registering
    new users through a `POST` request at `/register`, we would do so on the `/user`
    resource. Both faithful REST structures and more liberal HTTP API structures are
    valid choices.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：表 7.1 中描述的 API 不遵循 *表示状态转换*（REST）接口的架构原则。一个 *RESTful* 接口会暴露用户资源，例如 `/user/<username>`，而不是通过
    `/register` 资源上的 `POST` 请求注册新用户。忠实于 REST 结构和更自由的 HTTP API 结构都是有效的选择。
- en: 7.4.2 Ingestion service
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 数据摄取服务
- en: The ingestion service collects pedometer device updates and forwards records
    with update data to a Kafka stream for other services to process the events. The
    service receives device updates from either an HTTP API or an AMQP queue, as illustrated
    in figure 7.8\. The service is a form of *protocol adapter* or *mediator*, as
    it converts events from one protocol (HTTP or AMQP) to another protocol (Kafka
    record streams).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据摄取服务收集计步器设备更新，并将带有更新数据的记录转发到 Kafka 流，以便其他服务处理事件。服务从 HTTP API 或 AMQP 队列接收设备更新，如图
    7.8 所示。该服务是一种 *协议适配器* 或 *调解者*，因为它将一个协议（HTTP 或 AMQP）的事件转换为另一个协议（Kafka 记录流）。
- en: '![](../Images/CH07_F08_Ponge.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F08_Ponge.png)'
- en: Figure 7.8 Ingestion service
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 数据摄取服务
- en: 'A device update is a JSON document with the following entries:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设备更新是一个包含以下条目的 JSON 文档：
- en: The device identifier
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备标识符
- en: A synchronization identifier, which is a monotonically increasing long integer
    that the device updates for each successful synchronization
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个同步标识符，它是一个单调递增的长整数，设备在每次成功同步时更新
- en: The number of steps since the last synchronization
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上次同步以来的步数
- en: The HTTP API supports a single operation, as shown in table 7.2.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP API 支持单个操作，如表 7.2 所示。
- en: Table 7.2 Ingestion service HTTP API
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 数据摄取服务 HTTP API
- en: '| Purpose | Path | Method | Data | Response | Status code |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 路径 | 方法 | 数据 | 响应 | 状态码'
- en: '| Ingest a pedometer update | `/ingest` | `POST` | JSON document | N/A | 200
    on success, 500 for technical errors |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 摄入计步器更新 | `/ingest` | `POST` | JSON 文档 | N/A | 成功时返回 200，技术错误时返回 500'
- en: The AMQP client receives messages from the `step-events` address. The JSON data
    is the same in both the HTTP API and AMQP client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP 客户端从 `step-events` 地址接收消息。HTTP API 和 AMQP 客户端中的 JSON 数据相同。
- en: The service is meant to be publicly exposed so that it can receive pedometer
    updates. We assume that some reverse proxy will be used, offering encryption and
    access control. For instance, device updates over HTTPS could make use of client
    certificate checks to filter out unauthorized or unpatched devices.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务旨在公开暴露，以便它可以接收计步器更新。我们假设将使用某些反向代理，提供加密和访问控制。例如，通过 HTTPS 的设备更新可以使用客户端证书检查来过滤掉未经授权或未打补丁的设备。
- en: AMQP and HTTP clients only get acknowledgements when records have been written
    to Kafka. In the case of HTTP, this means that a device cannot consider the synchronization
    to be successful until it has received an HTTP 200 response. The service does
    not check for duplicates, so it is safe for a device to consider the ingestion
    operation idempotent. As you will see, it is the role of the activity service
    to keep data consistent, and not that of the ingestion service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP 和 HTTP 客户端只有在记录已写入 Kafka 后才会收到确认。在 HTTP 的情况下，这意味着设备只有在收到 HTTP 200 响应后才能认为同步成功。服务不会检查重复项，因此设备可以安全地认为摄取操作是幂等的。正如你将看到的，保持数据一致性的角色是活动服务，而不是摄取服务。
- en: The service can be scaled independently of the AMQP and the Kafka servers/ clusters.
    If the service crashes before some form of acknowledgement has been made, a client
    can always safely retry because of idempotency.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务可以独立于 AMQP 和 Kafka 服务器/集群进行扩展。如果服务在做出某种形式的确认之前崩溃，客户端可以安全地重试，因为操作是幂等的。
- en: 7.4.3 Activity service
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 活动服务
- en: The activity service keeps track of step-activity updates sent by the pedometers.
    The service stores events to a PostgreSQL database and offers an HTTP API to gather
    some statistics, such as daily, monthly, and total step counts for a given device.
    Updates are received from a Kakfa topic, which is fed by the ingestion service
    (see figure 7.9).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 活动服务跟踪计步器发送的步数活动更新。服务将事件存储到 PostgreSQL 数据库中，并提供 HTTP API 来收集一些统计数据，例如特定设备的每日、每月和总步数。更新来自
    Kafka 主题，该主题由摄取服务提供数据（见图 7.9）。
- en: '![](../Images/CH07_F09_Ponge.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![活动服务图](../Images/CH07_F09_Ponge.png)'
- en: Figure 7.9 Activity service
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 活动服务
- en: The activity service also publishes events with the number of steps for a device
    on the current day. This way, other services can subscribe to the corresponding
    Kafka topic and be notified rather than having to regularly poll the activity
    service for updates.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 活动服务还会发布关于当前日设备步数的事件。这样，其他服务可以订阅相应的 Kafka 主题并接收通知，而不是需要定期轮询活动服务以获取更新。
- en: The HTTP API is shown in table 7.3.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP API 在表 7.3 中展示。
- en: Table 7.3 Activity service HTTP API
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.3 活动服务 HTTP API
- en: '| Purpose | Path | Method | Data | Response | Status code |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 路径 | 方法 | 数据 | 响应 | 状态码 |'
- en: '| Total step count for a device | `/<device id>/total` | `GET` | N/A | JSON
    document | 200 on success, 404 if the device does not exist, 500 for technical
    errors |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 设备的总步数 | `/device id/total` | `GET` | N/A | JSON 文档 | 成功时返回 200，设备不存在时返回
    404，技术错误时返回 500 |'
- en: '| Step count for a device in a particular month | `/<device id>/<year>/<month>`
    | `GET` | N/A | JSON document | 200 on success, 404 if the device does not exist,
    500 for technical errors |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 特定月份设备的步数 | `/device id/year/month` | `GET` | N/A | JSON 文档 | 成功时返回 200，设备不存在时返回
    404，技术错误时返回 500 |'
- en: '| Step count for a device on a particular day | `/<device id>/<year>/<month>/<day>`
    | `GET` | N/A | JSON document | 200 on success, 404 if the device does not exist,
    500 for technical errors |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 特定日期设备的步数 | `/device id/year/month/day` | `GET` | N/A | JSON 文档 | 成功时返回 200，设备不存在时返回
    404，技术错误时返回 500 |'
- en: '| Ranking of the devices in decreasing number of steps over the last 24 hours
    | `/ranking-last-24-hours` | `GET` | N/A | JSON document | 200 on success, 500
    for technical errors |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 过去 24 小时内按步数递减的设备排名 | `/ranking-last-24-hours` | `GET` | N/A | JSON 文档 |
    成功时返回 200，技术错误时返回 500 |'
- en: Most of the operations are queries for a given device. As you will see in another
    chapter, the last operation provides an efficient query for getting a device’s
    ranking, which is useful when the dashboard service starts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作是对特定设备的查询。正如你将在另一章中看到的，最后一次操作提供了一个高效的查询，用于获取设备的排名，这在仪表板服务启动时非常有用。
- en: 'The events sent to the `daily.step.updates` Kafka topic contain the following
    information in a JSON document:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到 `daily.step.updates` Kafka 主题的事件包含以下信息，在一个 JSON 文档中：
- en: The device identifier
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备标识符
- en: A timestamp
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: The number of steps recorded on the current day
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当天记录的步数
- en: 'For each incoming device update, there need to be three operations in this
    order:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个传入的设备更新，需要按照以下顺序执行三个操作：
- en: A database insert
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库插入
- en: A database query to get the number of steps for the device on the current day
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前设备当天步数的数据库查询
- en: A Kafka record write
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kafka记录写入
- en: 'Each of these operations may fail, and we don’t have a distributed transaction
    broker in place. We ensure idempotency and correctness as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的每一个都可能失败，我们没有设置分布式事务代理。我们确保了幂等性和正确性，如下所示：
- en: We only acknowledge the incoming device update records in Kafka after the last
    operation has completed.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只在最后一个操作完成后才确认Kafka中的传入设备更新记录。
- en: The database schema enforces some uniqueness constraints on the events being
    stored, so the insertion operation can fail if an event is being processed again.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式对存储的事件施加了一些唯一性约束，因此如果事件正在再次处理，插入操作可能会失败。
- en: We handle a duplicate insertion error as a normal case to have idempotency,
    and we follow along with the next steps until they have all completed.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将重复插入错误视为正常情况以实现幂等性，并继续执行后续步骤，直到它们全部完成。
- en: Successfully writing a daily steps update record to Kafka allows us to acknowledge
    the initial device update record, and the system can make progress with the other
    incoming records.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功将每日步数更新记录写入Kafka后，我们可以确认初始设备更新记录，系统可以继续处理其他传入的记录。
- en: The activity service is not meant to be publicly exposed, so just like the user
    profile service, there is no authentication in place. It can be scaled independently
    of the database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 活动服务不打算公开，因此就像用户资料服务一样，没有设置身份验证。它可以独立于数据库进行扩展。
- en: 7.4.4 Public API
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.4 公共API
- en: This service exposes a public HTTP API for other services to consume. It essentially
    acts as a *facade* over the user profile and activity services, as shown in figure
    7.10.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务公开了一个公共HTTP API，供其他服务消费。它本质上是对用户资料和活动服务的**门面**，如图7.10所示。
- en: '![](../Images/CH07_F10_Ponge.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F10_Ponge.png)'
- en: Figure 7.10 Public API
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 公共API
- en: The service is a form of *edge service* or *API gateway* as it forwards and
    composes requests to other services. Since this is a public HTTP API, the service
    requires authentication for most of its operations. To do that we’ll use *JSON
    web tokens* ([https://tools .ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)),
    which we’ll discuss in chapter 8, along with the service implementation. Since
    we want the public API to be usable from any HTTP client, including JavaScript
    code running in a web browser, we need to support *cross-origin resource sharing*,
    or CORS ([https://fetch.spec.whatwg.org/#http-cors-protocol](https://fetch.spec.whatwg.org/#http-cors-protocol)).
    Again we will dig into the details in due time. The HTTP API operations are described
    in table 7.4.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务是一种**边缘服务**或**API网关**，因为它将请求转发并组合到其他服务。由于这是一个公共HTTP API，该服务需要对其大多数操作进行身份验证。为此，我们将使用*JSON
    Web Tokens* ([https://tools .ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))，我们将在第8章中讨论，包括服务实现。由于我们希望公共API可以从任何HTTP客户端使用，包括在网页浏览器中运行的JavaScript代码，我们需要支持*跨源资源共享*，或CORS
    ([https://fetch.spec.whatwg.org/#http-cors-protocol](https://fetch.spec.whatwg.org/#http-cors-protocol))。我们将在适当的时候深入探讨细节。HTTP
    API操作在表7.4中描述。
- en: Table 7.4 Public API HTTP interface
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.4 公共API HTTP接口
- en: '| Purpose | Path | Method | Data | Response | Status code |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 路径 | 方法 | 数据 | 响应 | 状态码 |'
- en: '| Register a new user and device | `/register` | `POST` | JSON document with
    registration data | N/A | 200 on success, 502 otherwise |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 注册新用户和设备 | `/register` | `POST` | JSON格式的注册数据文档 | N/A | 成功时返回200，否则返回502
    |'
- en: '| Get a JWT token to use the API | `/token` | `POST` | JSON document with credentials
    | JWT token (plain text) | 200 on success, 401 otherwise |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 获取用于API的JWT令牌 | `/token` | `POST` | JSON格式的凭据文档 | JWT令牌（纯文本） | 成功时返回200，否则返回401
    |'
- en: '| Get a user’s data (requires a valid JWT) | `/<username>` | `GET` | N/A |
    JSON document | 200 on success, 404 if not found, 502 otherwise |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 获取用户数据（需要有效的JWT） | `/<username>` | `GET` | N/A | JSON文档 | 成功时返回200，未找到时返回404，否则返回502
    |'
- en: '| Update a user’s data (requires a valid JWT) | `/<username>` | `PUT` | JSON
    document | N/A | 200 on success, 404 if not found, 502 otherwise |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 更新用户数据（需要有效的JWT） | `/<username>` | `PUT` | JSON文档 | N/A | 成功时返回200，未找到时返回404，否则返回502
    |'
- en: '| Total steps of a user (requires a valid JWT) | `/<username>/total` | `GET`
    | N/A | JSON document | 200 on success, 404 if not found, 502 otherwise |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 用户总步数（需要有效的JWT） | `/<username>/total` | `GET` | N/A | JSON文档 | 成功时返回200，未找到时返回404，否则返回502
    |'
- en: '| Total steps of a user in a month (requires a valid JWT) | `/<username>/<year>/<month>`
    | `GET` | N/A | JSON document | 200 on success, 404 if not found, 502 otherwise
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 用户一个月内的总步数（需要有效的JWT） | `/<username>/<year>/<month>` | `GET` | N/A | JSON文档
    | 成功时返回200，未找到时返回404，其他情况返回502 |'
- en: '| Total steps of a user on a day (requires a valid JWT) | `/<username>/<year>/<month>/<day>`
    | `GET` | N/A | JSON document | 200 on success, 404 if not found, 502 otherwise
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 用户一天内的总步数（需要有效的JWT） | `/<username>/<year>/<month>/<day>` | `GET` | N/A |
    JSON文档 | 成功时返回200，未找到时返回404，其他情况返回502 |'
- en: Note that the request paths will be prefixed with `/api/v1`, so requesting a
    token is a `POST` request to `/api/v1/token`. It is always a good idea to have
    some versioning scheme in the URLs of a public API. The JWT tokens are restricted
    to the username that was used to obtain it, so user `B` cannot perform, say, a
    request to `/api/v1/A/ 2019/07/14`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，请求路径将带有`/api/v1`前缀，因此请求令牌是向`/api/v1/token`的`POST`请求。在公共API的URL中始终有一些版本控制方案是一个好主意。JWT令牌仅限于用于获取它的用户名，因此用户`B`不能执行，例如，向`/api/v1/A/
    2019/07/14`的请求。
- en: The public API service can be scaled to multiple instances. In a production
    setting, a load-balancing HTTP proxy should dispatch requests to the instances.
    There is no state to maintain in the service, since it forwards and composes requests
    to the other services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 公共API服务可以扩展到多个实例。在生产环境中，负载均衡HTTP代理应将请求分发到这些实例。在服务中不需要维护任何状态，因为它将请求转发和组合到其他服务。
- en: 7.4.5 User web application
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.5 用户Web应用程序
- en: The user web application provides a way for a user to register, update their
    details, and check some basic data about their activity. As shown in figure 7.11,
    there is a backend to serve the web application’s static assets to web browsers
    over HTTP.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用户Web应用程序提供了一种方式，让用户可以注册、更新他们的详细信息，并检查一些关于他们活动的基本数据。如图 7.11 所示，有一个后端通过HTTP向Web浏览器提供Web应用程序的静态资源。
- en: '![](../Images/CH07_F11_Ponge.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F11_Ponge.png)'
- en: Figure 7.11 User web application
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 用户Web应用程序
- en: The frontend is a *single-page application* written in JavaScript and the Vue.JS
    framework. It is served by the user web application service, and all interactions
    with the application’s backend happen through calls to the public API service.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前端是一个用JavaScript和Vue.JS框架编写的*单页应用程序*。它由用户Web应用程序服务提供，并且所有与应用程序后端的交互都通过调用公共API服务来完成。
- en: As such, this service is more a Vue.JS application than a Vert.x application,
    although it is still interesting to see how Vert.x serves static content with
    minimal effort. We could have chosen other popular JavaScript frameworks, or even
    no framework at all. I find Vue.JS to be a simple and efficient choice. Also,
    since Vue.JS embraces *reactive idioms*, it makes for a fully reactive application
    from the backend API to the frontend.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个服务更像是Vue.JS应用程序而不是Vert.x应用程序，尽管看到Vert.x如何以最小的努力提供静态内容仍然很有趣。我们本可以选择其他流行的JavaScript框架，或者甚至完全不使用框架。我发现Vue.JS是一个简单而高效的选择。此外，由于Vue.JS拥抱*响应式惯用用法*，它使得从后端API到前端的应用程序完全响应。
- en: The service itself just serves static files, so it can be scaled to multiple
    instances and put behind a load balancer in a production setting. There is no
    state on the server side, either in the service or in the public API in use. It
    is the frontend application that stores some state in users’ web browsers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务本身仅提供静态文件，因此可以扩展到多个实例，并在生产环境中放在负载均衡器后面。在服务器端也没有状态，无论是在服务中还是在使用的公共API中。是前端应用程序在用户的Web浏览器中存储一些状态。
- en: 7.4.6 Event stats service
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.6 事件统计服务
- en: The event stats service reacts to selected events from Kafka topics to produce
    statistics and publish them as Kafka records for other services to consume, as
    illustrated in figure 7.12.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 事件统计服务响应Kafka主题中选定的事件，生成统计数据并将它们作为Kafka记录发布给其他服务，如图 7.12 所示。
- en: '![](../Images/CH07_F12_Ponge.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F12_Ponge.png)'
- en: Figure 7.12 Event stats service
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 事件统计服务
- en: 'The service performs the following computations:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务执行以下计算：
- en: Based on time windows of five seconds, it computes the throughput of device
    updates based on the number of events received on the `incoming.steps` topic,
    and it then emits a record to the `event-stats.throughput` topic.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于五秒的时间窗口，它根据接收到的`incoming.steps`主题上的事件数量计算设备更新的吞吐量，然后向`event-stats.throughput`主题发出记录。
- en: Events received on the `daily.step.updates` topic carry data on the number of
    steps from a device on the current day. This data lacks user data (name, city,
    etc.), so for each event the service queries the user profile service to enrich
    the original record with user data, and then sends it to the `event-stats.user-activity.updates`
    topic.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `daily.step.updates` 主题上接收的事件包含来自设备当天步数的数量数据。这些数据缺少用户数据（姓名、城市等），因此对于每个事件，该服务查询用户配置文件服务以丰富原始记录的用户数据，然后将其发送到
    `event-stats.user-activity.updates` 主题。
- en: The service computes city trends by processing the events from the `event-stats.user-activity.updates`
    topic over time windows of five seconds, and for each city it publishes an update
    with the aggregated number of steps for that city to the `event-stats.city-trends.updates`
    topic.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务通过处理来自 `event-stats.user-activity.updates` 主题的事件，在五秒的时间窗口内计算城市趋势，并为每个城市将其聚合的步数更新发布到
    `event-stats.city-trends.updates` 主题。
- en: Kafka records can be acknowledged in an automatic fashion by batches, as there
    is little harm in processing a record again, especially for the throughput and
    city trends computations. To ensure that exactly one record is produced for an
    activity update, a manual acknowledgement is possible, although an occasional
    duplicate record should not impact a consuming service.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka 记录可以自动批量确认，因为再次处理记录几乎没有损害，尤其是对于吞吐量和城市趋势计算。为了确保活动更新恰好产生一个记录，可以进行手动确认，尽管偶尔的重复记录不应影响消费服务。
- en: The event stats service is not meant to be public, and it does not offer any
    interface for other services. Finally, the service should be deployed as a single
    instance due to the nature of the computations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事件统计服务并不打算公开，它不提供任何接口供其他服务使用。最后，由于计算的性质，该服务应作为单个实例部署。
- en: 7.4.7 Congrats service
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.7 庆祝服务
- en: The role of the congrats service is to monitor when a device reaches at least
    10,000 steps on a day, and then to send a congratulation email to the owner, as
    shown in figure 7.13.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 庆祝服务的角色是监控设备在一天内达到至少 10,000 步的情况，然后向所有者发送祝贺电子邮件，如图 7.13 所示。
- en: '![](../Images/CH07_F13_Ponge.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F13_Ponge.png)'
- en: Figure 7.13 Congrats service
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 庆祝服务
- en: The service makes calls to the user profile service to get the email of the
    user associated with a device, and then it contacts an SMTP server to send an
    email.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务调用用户配置文件服务以获取与设备关联的用户的电子邮件，然后它联系 SMTP 服务器发送电子邮件。
- en: Note that we could have reused the `event-stats.user-activity.updates` Kafka
    topic fed by the event stats service, as it enriches the messages received from
    `daily.step.updates` with user data, including an email address. An implementation
    detail in how Kafka record keys are being produced for both topics makes it simpler
    to enforce that at most one message is sent to a user each day by using the records
    from `daily.step.updates` and then getting the email from the user profile service.
    This does not add much network and processing overhead either, since a user must
    receive an email only for the first activity update with at least 10,000 steps
    on a given day.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以重用由事件统计服务提供数据的 `event-stats.user-activity.updates` Kafka 主题，因为它丰富了从 `daily.step.updates`
    收到的消息，包括电子邮件地址。这两个主题的 Kafka 记录键的生产实现细节使得使用 `daily.step.updates` 中的记录，然后从用户配置文件服务获取电子邮件，来确保每天最多向用户发送一条消息变得简单。这也不会增加太多的网络和处理开销，因为用户只需在给定的一天内至少收到一条包含至少
    10,000 步的活动更新电子邮件。
- en: This service is not to be publicly exposed, and it does not expose any API.
    A single instance should suffice in a production setting, but the service can
    be scaled to multiple instances sharing the same Kafka consumer group so that
    they can split the workload among them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务不应公开，也不暴露任何 API。在生产环境中，单个实例应该足够，但该服务可以被扩展到多个实例，它们共享相同的 Kafka 消费者组，以便它们可以在彼此之间分配工作负载。
- en: 7.4.8 Dashboard web application
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.8 仪表板 Web 应用程序
- en: The dashboard web application offers live updates on the incoming updates throughput,
    city trends, and public user ranking. As seen in figure 7.14, the service consumes
    Kafka records emitted by the event stats service and regularly pushes updates
    to the web application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板 Web 应用程序提供有关传入更新吞吐量、城市趋势和公共用户排名的实时更新。如图 7.14 所见，该服务消费事件统计服务发出的 Kafka 记录，并定期将更新推送到
    Web 应用程序。
- en: '![](../Images/CH07_F14_Ponge.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F14_Ponge.png)'
- en: Figure 7.14 Dashboard web application
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 仪表板 Web 应用程序
- en: The web application is written using the Vue.JS framework, just like the user
    web application described earlier. The frontend and backend are connected using
    the Vert.x event bus, so both the Vert.x and Vue.JS code bases can communicate
    with the same programming model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序使用Vue.JS框架编写，就像之前描述的用户Web应用程序一样。前端和后端使用Vert.x事件总线连接，因此Vert.x和Vue.JS代码库可以使用相同的编程模型进行通信。
- en: Throughput and city trend updates from Kafka topics are directly forwarded over
    the Vert.x event bus, so the connected web application client receives the updates
    in real time. The backend maintains in-memory data about the number of steps over
    the last 24 hours for all users who have made their profile public. The ranking
    is updated every 5 seconds, and the result is pushed to the web application over
    the event bus so that the ranking is updated in the connected web browsers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Kafka主题的吞吐量和城市趋势更新直接转发到Vert.x事件总线，因此连接的Web应用程序客户端可以实时接收更新。后端维护有关过去24小时内所有已公开其配置文件的用户步数的内存数据。排名每5秒更新一次，结果通过事件总线推送到Web应用程序，以便在连接的Web浏览器中更新排名。
- en: Since the backend is event-driven over Kafka topics, a good question is what
    happens when the service starts (or when it recovers from a crash). Indeed, on
    a fresh start we do not have all the step data from the last 24 hours, and we
    will only receive updates from the service’s start time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后端是通过Kafka主题事件驱动的，一个很好的问题是当服务启动时（或从崩溃中恢复时）会发生什么。确实，在全新启动时，我们没有过去24小时的步数数据，我们只会从服务的启动时间接收更新。
- en: We need a *hydration* phase when the service starts, where we query the activity
    service and get the rankings over the last 24 hours. We then need to query the
    user profile service for each entry of the ranking, since we need to correlate
    each device with a user profile. This is a potentially costly operation, but it
    shouldn’t happen very often.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务启动时，我们需要一个*水合*阶段，在这个阶段中，我们查询活动服务并获取过去24小时的排名。然后我们需要查询用户配置文件服务以获取排名中的每个条目，因为我们需要将每个设备与一个用户配置文件关联起来。这是一个可能代价高昂的操作，但这种情况不应该经常发生。
- en: Note that waiting for the hydration to complete does not prevent the processing
    of user activity updates, as eventually only the most recent value from either
    a Kafka record or the hydration data will prevail when updating the in-memory
    data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，等待水合完成并不会阻止处理用户活动更新，因为最终在更新内存数据时，只有来自Kafka记录或水合数据的最新值才会生效。
- en: The dashboard web application service is meant to be publicly exposed. It can
    be scaled to multiple instances if need be, and it can be put behind an HTTP proxy
    load balancer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板Web应用程序服务旨在公开暴露。如果需要，它可以扩展到多个实例，并且可以放在HTTP代理负载均衡器后面。
- en: 7.5 Running the application
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 运行应用程序
- en: To run the application, you need to run all the infrastructure services and
    all the microservices. The complete source code of the application can be found
    in the part2-steps-challenge folder of the source code repository.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，您需要运行所有基础设施服务和所有微服务。应用程序的完整源代码可以在源代码仓库的part2-steps-challenge文件夹中找到。
- en: First of all, Docker must be installed on your machine, because building the
    application requires containers to be started while executing test suites. The
    application can be built with Gradle using the `gradle assemble` command, or with
    `gradle build` if you also want to run the tests as part of the build and have
    Docker running.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须在您的机器上安装Docker，因为构建应用程序需要在执行测试套件时启动容器。可以使用`gradle assemble`命令使用Gradle构建应用程序，或者如果您还想在构建过程中运行测试并且Docker正在运行，可以使用`gradle
    build`。
- en: Once the application services have been built, you will need to run all infrastructure
    services like PostgreSQL, MongoDB, Apache Kafka, and so on. You can greatly simplify
    the task by running them from Docker containers. To do that, the `docker-compose.yml`
    file describes several containers to be run with Docker Compose, a simple and
    effective tool for managing several containers at once. Running `docker-compose
    up` will start all the containers, and `docker-compose down` will stop and remove
    them all. You can also press `Ctrl+C` in a terminal running Docker Compose, and
    it will stop the containers (but not remove them, so they can be started with
    the current state again).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了应用程序服务，您将需要运行所有基础设施服务，如 PostgreSQL、MongoDB、Apache Kafka 等。您可以通过从 Docker
    容器运行它们来极大地简化任务。为此，`docker-compose.yml` 文件描述了要使用 Docker Compose 运行的几个容器，Docker
    Compose 是一个简单有效的工具，可以同时管理多个容器。运行 `docker-compose up` 将启动所有容器，而 `docker-compose
    down` 将停止并删除它们。您还可以在运行 Docker Compose 的终端中按 `Ctrl+C`，它将停止容器（但不会删除它们，因此可以再次以当前状态启动）。
- en: tip On macOS and Windows, I recommend installing Docker Desktop. Most Linux
    distributions offer Docker as a package. Note that `docker` needs to run as `root`,
    so on Linux you may need to add your user to a special group to avoid using `sudo`.
    The official Docker documentation provides troubleshooting instructions ([https://docs.docker.com/engine/install/linux-postinstall/](https://docs.docker.com/engine/install/linux-postinstall/)).
    In all cases, make sure that you can successfully run the `docker run hello-world`
    command as a user.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在 macOS 和 Windows 上，我建议安装 Docker Desktop。大多数 Linux 发行版都提供 Docker 作为软件包。请注意，`docker`
    需要以 `root` 用户身份运行，因此在 Linux 上您可能需要将您的用户添加到特殊组中，以避免使用 `sudo`。官方 Docker 文档提供了故障排除说明（[https://docs.docker.com/engine/install/linux-postinstall/](https://docs.docker.com/engine/install/linux-postinstall/)）。在所有情况下，请确保您可以作为用户成功运行
    `docker run hello-world` 命令。
- en: 'The container images that we will need to run are the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行的容器镜像如下：
- en: MongoDB with an initialization script to prepare a collection and indexes
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 配有初始化脚本以准备集合和索引
- en: PostgreSQL with an initialization script to create the schema
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 配有初始化脚本以创建模式
- en: Apache Kafka with Apache ZooKeeper from the Strimzi project images (see [https://strimzi.io](https://strimzi.io))
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Strimzi 项目的 Apache Kafka 和 Apache ZooKeeper 镜像（见 [https://strimzi.io](https://strimzi.io)）
- en: ActiveMQ Artemis
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActiveMQ Artemis
- en: MailHog, an SMTP server suitable for integration testing ([https://github.com/
    mailhog/MailHog](https://github.com/mailhog/MailHog))
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MailHog，一个适合集成测试的 SMTP 服务器（[https://github.com/mailhog/MailHog](https://github.com/mailhog/MailHog)）
- en: 'All microservices are packaged as self-contained executable JAR files. For
    example, you can run the activity service as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有微服务都打包为自包含的可执行 JAR 文件。例如，您可以按以下方式运行活动服务：
- en: '[PRE0]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That being said, starting all services manually is not very convenient, so
    the project also contains a `Procfile` file to run all the services. The file
    contains lines with service names and associated shell commands. You can then
    use the Foreman tool to run the services ([https://github.com/ddollar/foreman](https://github.com/ddollar/foreman))
    or a compatible tool like Hivemind ([https://github.com/DarthSim/hivemind](https://github.com/DarthSim/hivemind)):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，手动启动所有服务并不方便，因此项目还包含一个 `Procfile` 文件来运行所有服务。该文件包含服务名称和相关shell命令的行。您可以使用
    Foreman 工具来运行服务（[https://github.com/ddollar/foreman](https://github.com/ddollar/foreman)）或兼容的工具，如
    Hivemind（[https://github.com/DarthSim/hivemind](https://github.com/DarthSim/hivemind)）：
- en: '[PRE1]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is very convenient, as you can run all the services from two terminal panes,
    as illustrated in figure 7.15.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，因为您可以从两个终端窗口运行所有服务，如图 7.15 所示。
- en: '![](../Images/CH07_F15_Ponge.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH07_F15_Ponge.png)'
- en: Figure 7.15 Running the microservices and infrastructure services with Docker
    Compose and Foreman
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 使用 Docker Compose 和 Foreman 运行微服务和基础设施服务
- en: 'Foreman can also generate various system service descriptors from a Procfile:
    initab, launchd, systemd, and more. Finally, Foreman is written in Ruby, but there
    are also ports to other languages listed on the project page.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Foreman 还可以从 Procfile 生成各种系统服务描述符：initab、launchd、systemd 等。最后，Foreman 是用 Ruby
    编写的，但在项目页面上还列出了其他语言的端口。
- en: tip Foreman simplifies running all services, but you don’t have to use it. You
    can run each individual service on the command line. The content of Procfile will
    show you the exact command for each service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：Foreman 简化了运行所有服务的过程，但您不必使用它。您可以在命令行上单独运行每个服务。Procfile 的内容将显示每个服务的确切命令。
- en: The next chapters will illustrate the challenges of implementing a reactive
    application by building on top of a set of (imperfect!) microservices that cover
    the topics of web, APIs, messaging, data, and continuous stream processing. In
    the next chapter, we’ll explore the web stack used to implement some of the services
    described in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 下一章将通过构建一组（不完美！）覆盖Web、API、消息、数据和连续流处理主题的微服务来阐述实现响应式应用的挑战。在下一章中，我们将探讨用于实现本章描述的一些服务的Web堆栈。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3. 摘要
- en: A reactive application focuses on controlling latency under various workloads
    and in the presence of failures from other services.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6. 响应式应用专注于在各种工作负载和存在其他服务故障的情况下控制延迟。
- en: A reactive application can be decomposed as a set of independently scaled event-driven
    microservices.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2. 一个响应式应用可以被分解为一系列独立扩展的事件驱动微服务。
- en: '* * *'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 5. ***
- en: 1.For an introduction, see Martin Fowler’s articles on CQRS ([https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html))
    and event sourcing ([https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 对于介绍，请参阅马丁·福勒关于CQRS([https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html))和事件溯源([https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html))的文章。
