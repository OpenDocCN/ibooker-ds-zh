- en: 4 Case study 1 solution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 案例研究 1 解决方案
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: Card game simulations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扑克牌游戏模拟
- en: Probabilistic strategy optimization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率策略优化
- en: Confidence intervals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信区间
- en: Our aim is to play a card game in which the cards are iteratively flipped until
    we tell the dealer to stop. Then one additional card is flipped. If that card
    is red, we win a dollar; otherwise, we lose a dollar. Our goal is to discover
    a strategy that best predicts a red card in the deck. We will do so by
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是玩一个扑克牌游戏，其中牌会迭代翻转，直到我们告诉发牌人停止。然后翻转一张额外的牌。如果那张牌是红色，我们就赢得一美元；否则，我们损失一美元。我们的目标是发现一种最佳预测牌堆中红牌的策略。我们将通过
- en: Developing multiple strategies for predicting red cards in a randomly shuffled
    deck.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发多种策略来预测随机洗牌牌堆中的红牌。
- en: Applying each strategy across multiple simulations to compute its probability
    of success within a high confidence interval. If these computations prove to be
    intractable, we will instead focus on those strategies that perform best across
    a 10-card sample space.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多次模拟中应用每种策略，以计算其在高置信区间内的成功概率。如果这些计算难以实现，我们将专注于在 10 张牌样本空间中表现最好的策略。
- en: Returning the simplest strategy associated with the highest probability of success.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回与最高成功概率相关的最简单策略。
- en: Warning Spoiler alert! The solution to case study 1 is about to be revealed.
    I strongly encourage you to try to solve the problem prior to reading the solution.
    The original problem statement is available for reference at the beginning of
    the case study.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 揭示警告！案例研究 1 的解决方案即将揭晓。我强烈建议你在阅读解决方案之前尝试解决这个问题。原始问题陈述可在案例研究开头参考。
- en: 4.1 Predicting red cards in a shuffled deck
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 预测洗牌牌堆中的红牌
- en: We start by creating a deck holding 26 red cards and 26 black cards. Black cards
    are represented by 0s, and red cards are represented by 1s.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含 26 张红牌和 26 张黑牌的牌堆。黑牌用 0 表示，红牌用 1 表示。
- en: Listing 4.1 Modeling a 52-card deck
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 建模一副 52 张牌
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We proceed to shuffle the deck.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续洗牌。
- en: Listing 4.2 Shuffling a 52-card deck
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 洗一副 52 张牌
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we iteratively flip over the cards in the deck, stopping when the next card
    is more likely to be red. Then we flip over the next card. We win if that card
    is red.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们迭代地翻转牌堆中的牌，直到下一张牌更有可能是红色。然后我们翻转下一张牌。如果那张牌是红色，我们就赢了。
- en: How do we decide when we should stop? One simple strategy is to terminate the
    game when the number of red cards remaining in the deck is greater than the number
    of black cards remaining in the deck. Let’s execute that strategy on the shuffled
    deck.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何决定何时停止？一个简单的策略是在剩余牌堆中的红牌数量大于剩余牌堆中的黑牌数量时终止游戏。让我们在洗好的牌堆上执行这个策略。
- en: Listing 4.3 Coding a card game strategy
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 编写扑克牌游戏策略
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Subtracts the total cards seen thus far from 52\. This total equals i + 1,
    since i is initially set to zero. Alternatively, we can run enumerate(shuffled_deck[:-1],
    1) so that i is initially set to 1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 52 张牌中减去到目前为止看到的总牌数。这个总数等于 i + 1，因为 i 初始设置为 0。或者，我们可以运行 `enumerate(shuffled_deck[:-1],
    1)`，这样 i 初始设置为 1。
- en: The strategy yielded a win on our very first try. Our strategy halts when the
    fraction of remaining red cards is greater than half of the remaining total cards.
    We can generalize that fraction to equal a `min_red_fraction` parameter, thus
    halting when the red card ratio is greater than the inputted parameter value.
    This generalized strategy is implemented next with `min_red_fraction` preset to
    0.5.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略在第一次尝试时就取得了胜利。我们的策略在剩余红牌的比例大于剩余总牌数的一半时停止。我们可以将这个比例推广到等于 `min_red_fraction`
    参数，从而在红牌比例大于输入参数值时停止。接下来，我们将实现这个推广策略，将 `min_red_fraction` 预设为 0.5。
- en: Listing 4.4 Generalizing the card game strategy
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 通用扑克牌游戏策略
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Shuffles the unshuffled deck if no input deck is provided
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果没有提供输入牌堆，则洗洗未洗的牌堆
- en: ❷ Optionally returns the card index along with the final card
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可选地返回卡片索引和最终卡片
- en: 4.1.1 Estimating the probability of strategy success
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 估计策略成功的概率
- en: Let’s apply our basic strategy to a series of 1,000 random shuffles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的基本策略应用到一系列 1,000 次随机洗牌中。
- en: Listing 4.5 Running the strategy over 1,000 shuffles
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 在 1,000 次洗牌中运行策略
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The total fraction of 1s in observations corresponds to the observed fraction
    of red cards and therefore to the fraction of wins. We can compute this fraction
    by summing the 1s in `observations` and dividing by the array size. As an aside,
    that computation can also be carried out by calling `observations.mean()`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 观测中1的总分数对应于红牌的观测分数，因此也对应于获胜的分数。我们可以通过将`observations`中的1相加并除以数组大小来计算这个分数。顺便说一句，这个计算也可以通过调用`observations.mean()`来完成。
- en: Listing 4.6 Computing the frequency of wins
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 计算获胜频率
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ve won 51.1% of the total games! Our strategy appears to be working: 511
    wins and 489 losses will net us a total profit of $22.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们赢得了51.1%的总游戏！我们的策略似乎正在起作用：511次胜利和489次失败将给我们带来总利润22美元。
- en: Listing 4.7 Computing total profit
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 计算总利润
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The strategy worked well for a sample size of 1,000 shuffles. We now plot the
    strategy’s win-frequency convergence over a series of sample sizes ranging from
    1 through 10,000 (figure 4.1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于1,000次洗牌的样本量，该策略效果良好。现在我们绘制策略的获胜频率收敛图，样本量从1到10,000（图4.1）。
- en: '![](../Images/04-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-01.png)'
- en: Figure 4.1 The number of played games plotted against the observed win-count
    frequency. The frequencies fluctuate around a value of 0.5\. We cannot tell if
    the probability of winning is above or below 0.5.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 游戏次数与观测到的获胜计数频率的对比。频率围绕0.5的值波动。我们无法判断获胜的概率是高于还是低于0.5。
- en: Listing 4.8 Plotting simulated frequencies of wins
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 绘制模拟获胜频率
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Returns the frequency of wins for a specified number of games
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回指定游戏数量的获胜频率
- en: The strategy yields a win frequency of over 50% when 10,000 card shuffles are
    sampled. However, the strategy also fluctuates above and below 50% throughout
    the entire sampling process. How confident are we that the probability of a win
    is actually greater than 0.5? We can find out using confidence interval analysis
    (figure 4.2). We compute the confidence interval by sampling 10,000 card shuffles
    300 times, for a total of 3 million shuffles. Shuffling an array is a computationally
    expensive procedure, so listing 4.9 takes approximately 40 seconds to run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当采样10,000次牌洗动作时，该策略的获胜频率超过50%。然而，在整个采样过程中，策略的获胜频率也上下波动。我们有多大的信心认为获胜的概率实际上大于0.5？我们可以通过置信区间分析（图4.2）来找出答案。我们通过采样10,000次牌洗动作300次，总共3百万次洗牌来计算置信区间。洗牌数组是一个计算密集型的过程，所以列表4.9的运行大约需要40秒。
- en: '![](../Images/04-02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-02.png)'
- en: Figure 4.2 A histogram of 300 binned frequencies plotted against their associated
    relative likelihoods. Highlighted bars delineate the 95% confidence interval.
    That interval covers a frequency range of roughly 0.488–0.508.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 300个分箱频率的直方图与它们相关的相对似然性对比。高亮条表示95%的置信区间。该区间覆盖的频率范围大约是0.488–0.508。
- en: Listing 4.9 Computing the confidence interval for 3 million shuffles
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 计算3百万次洗牌的置信区间
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ As a reminder, we defined the compute_high_confidence_interval function in
    section 3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为提醒，我们在第3节中定义了compute_high_confidence_interval函数。
- en: 'We are quite confident that the actual probability lies somewhere between 0.488
    and 0.509\. However, we still don’t know whether that probability is above 0.5
    or below 0.5\. This is a problem: even a minor misinterpretation of the true probability
    could cause us to lose money.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相当确信实际概率位于0.488和0.509之间。然而，我们仍然不知道这个概率是高于0.5还是低于0.5。这是一个问题：对真实概率的微小误解可能导致我们亏损。
- en: Imagine that the true probability is 0.5001\. If we apply our strategy to 1
    billion shuffles, we should expect to win $200,000\. Now suppose we were wrong,
    and the actual probability is 0.4999\. In this scenario, we will lose $200,000\.
    A tiny error over the fourth decimal space could cost us hundreds of thousands
    of dollars.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，真实概率是0.5001。如果我们把我们的策略应用到10亿次洗牌中，我们应该期望赢得20万美元。现在假设我们错了，实际概率是0.4999。在这种情况下，我们将损失20万美元。第四位小数点上的微小错误可能使我们损失数十万美元。
- en: We must be absolutely certain that the true probability lies above 0.5\. Thus,
    we must narrow the 95% confidence interval by increasing the sample size at the
    expense of running time. The following code samples 50,000 shuffles over 3,000
    iterations. It takes approximately an hour to run.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须绝对确信真实概率位于0.5以上。因此，我们必须通过增加样本量来缩小95%的置信区间，这将以运行时间为代价。以下代码在3,000次迭代中采样了50,000次洗牌。运行大约需要一个小时。
- en: Warning The following code will take an hour to run.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 以下代码将运行一个小时。
- en: Listing 4.10 Computing the confidence interval for 150 million shuffles
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 计算 1.5 亿次洗牌的置信区间
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve executed our sampling. Unfortunately, the new confidence interval still
    does not discern whether the true probability lies above 0.5\. So what should
    we do? Increasing the number of samples is not computationally feasible (unless
    we’re willing to let the simulation run for a couple of days). Perhaps increasing
    `min_red_fraction` from 0.5 to 0.75 will yield an improvement. Let’s update our
    strategy and go for a long walk as our simulation takes another hour to run.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经执行了采样。不幸的是，新的置信区间仍然无法判断真实概率是否高于 0.5。那么我们应该怎么办？增加样本数量在计算上不可行（除非我们愿意让模拟运行几天）。也许将
    `min_red_fraction` 从 0.5 增加到 0.75 会带来改进。让我们更新我们的策略，并在我们的模拟再运行一个小时的同时去散步。
- en: Warning The following code will take an hour to run.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 以下代码将运行一个小时。
- en: Listing 4.11 Computing the confidence interval for an updated strategy
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 计算更新策略的置信区间
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nope! The span of our confidence interval remains unresolved since it still
    covers both profitable and unprofitable probabilities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不好！我们的置信区间的跨度仍然没有解决，因为它仍然覆盖了有利和无利的概率。
- en: Perhaps we can gain more insight by applying our strategies to a 10-card deck.
    That deck’s sample space can be explored in its entirety, thus letting us compute
    the exact probability of a win.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的策略应用于 10 张牌的牌组，我们可能可以获得更多的洞察。该牌组的样本空间可以完全探索，因此我们可以计算出获胜的确切概率。
- en: 4.2 Optimizing strategies using the sample space for a 10-card deck
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 使用 10 张牌的牌组样本空间优化策略
- en: The following code computes the sample space for a 10-card deck. Then it applies
    our basic strategy to that sample space. The final output is the probability that
    the strategy will yield a win.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码计算了 10 张牌的牌组的样本空间。然后它将我们的基本策略应用于该样本空间。最终输出是策略获胜的概率。
- en: Listing 4.12 Applying a basic strategy to a 10-card deck
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 将基本策略应用于 10 张牌的牌组
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ As a reminder, itertools was previously imported in section 3.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为提醒，itertools 在第 3 节之前已经被导入。
- en: ❷ Event condition where our basic strategy yields a win
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 事件条件，我们的基本策略能够获胜
- en: ❸ We defined the compute_event_probability function in section 1.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们在第 1 节中定义了 `compute_event_probability` 函数。
- en: Surprisingly, our basic strategy yields a win only 50% of the time. This is
    no better than selecting the first card at random! Maybe our `min_red_fraction`
    parameter was insufficiently low. We can find out by sampling all the two-decimal
    `min_red_fraction` values between 0.50 and 1.0\. The following code computes the
    win probabilities over a range of `min_red_fraction` values and returns the minimum
    and maximum probabilities.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们的基本策略只有 50% 的时间能够获胜。这并不比随机选择第一张牌好！也许我们的 `min_red_fraction` 参数设置得太低。我们可以通过采样
    0.50 和 1.0 之间的所有两位小数 `min_red_fraction` 值来找出答案。以下代码计算了 `min_red_fraction` 值范围内的获胜概率，并返回最小和最大概率。
- en: Listing 4.13 Applying multiple strategies to a 10-card deck
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 将多个策略应用于 10 张牌的牌组
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both the lowest and highest probabilities are equal to 0.5! None of our strategies
    have outperformed a random card choice. Perhaps adjusting the deck size will yield
    some improvement. Let’s analyze the sample spaces of decks containing two, four,
    six, and eight cards. We apply all strategies to each sample space and return
    their probabilities of winning. Then we search for a probability that isn’t equal
    to 0.5.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最低和最高的概率都等于 0.5！我们的任何策略都没有优于随机选择一张牌。也许调整牌组大小会有所改进。让我们分析包含两张、四张、六张和八张牌的牌组的样本空间。我们将所有策略应用于每个样本空间，并返回它们获胜的概率。然后我们寻找一个不等于
    0.5 的概率。
- en: Listing 4.14 Applying multiple strategies to multiple decks
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 将多个策略应用于多个牌组
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All of the strategies yield a probability of 0.5 across the small decks. Each
    time we increase the deck size, we add two additional cards to the deck, but this
    fails to improve performance. A strategy that fails on a 2-card deck continues
    to fail on a 4-card deck, and a strategy that fails on an 8-card deck continues
    to fail on a 10-card deck. We can extrapolate this logic even further. A strategy
    that fails on a 10-card deck will probably fail on a 12-card deck, and thus on
    a 14-card deck and a 16-card deck. Eventually, it will fail on a 52-card deck.
    Qualitatively, this inductive argument makes sense. Mathematically, it can be
    proven to be true. Right now, we don’t need to concern ourselves with the math.
    What’s important is that our instincts have been proven wrong. Our strategies
    don’t work on a 10-card deck, and we have little reason to believe they will work
    on a 52-card deck. Why do the strategies fail?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有策略在小型牌堆中产生的概率都是0.5。每次我们增加牌堆大小，我们都会向牌堆中增加两张牌，但这并不能提高性能。在2张牌的牌堆上失败的战略在4张牌的牌堆上仍然会失败，在8张牌的牌堆上失败的战略在10张牌的牌堆上仍然会失败。我们可以进一步推断这个逻辑。在10张牌的牌堆上失败的战略可能会在12张牌的牌堆上失败，从而在14张牌的牌堆上失败，在16张牌的牌堆上失败。最终，它将在52张牌的牌堆上失败。从定性角度来看，这个归纳论证是有道理的。从数学角度来看，它可以被证明是正确的。现在，我们不需要担心数学。重要的是，我们的直觉已经被证明是错误的。我们的战略在10张牌的牌堆上不起作用，我们没有理由相信它们会在52张牌的牌堆上起作用。为什么这些战略会失败？
- en: 'Intuitively, our initial strategy made sense: if there are more red cards than
    black cards in the deck, then we are more likely to pick a red card from the deck.
    However, we failed to take into account those scenarios when the red cards never
    outnumber the black cards. For instance, suppose the first 26 cards are red and
    the remainder are black. In these circumstances, our strategies will fail to halt,
    and we will lose. Also, let’s consider a shuffled deck where the first 25 cards
    are red, the next 26 cards are black, and the final card is red. Here, our strategy
    will fail to halt, but we will still win. It seems each strategy can lead to one
    of four scenarios:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 直观来看，我们的初始战略是有道理的：如果牌堆中红牌比黑牌多，那么我们更有可能从牌堆中抽到红牌。然而，我们没有考虑到那些红牌从未超过黑牌的场景。例如，假设前26张牌都是红牌，剩下的都是黑牌。在这种情况下，我们的战略将无法停止，我们将失败。此外，让我们考虑一个洗好的牌堆，前25张牌是红牌，接下来的26张牌是黑牌，最后一张牌是红牌。在这里，我们的战略将无法停止，但我们仍然会获胜。似乎每种战略都可以导致以下四种场景之一：
- en: Strategy halts and the next card is red. We win.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略停止且下一张牌是红牌。我们获胜。
- en: Strategy halts and the next card is black. We lose.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略停止且下一张牌是黑牌。我们失败。
- en: Strategy doesn’t halt and the final card is red. We win.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略没有停止且最后一张牌是红牌。我们获胜。
- en: Strategy doesn’t halt and the final card is black. We lose.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略没有停止且最后一张牌是黑牌。我们失败。
- en: Let’s sample how frequently the four scenarios occur across 50,000 card shuffles.
    We record these frequencies over our range of two-digit `min_red_fraction` values.
    We then plot each `min_red_fraction` value against the occurrence rates observed
    from the four scenarios (figure 4.3).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采样这四种场景在50,000次洗牌中发生的频率。我们在`min_red_fraction`两位数值范围内记录这些频率。然后，我们将每个`min_red_fraction`值与从四种场景观察到的发生率进行对比（图4.3）。
- en: '![](../Images/04-03.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-03.png)'
- en: Figure 4.3 The `min_red_fraction` parameter is plotted against the sampled frequencies
    for all four possible scenarios. Scenario A initially has a frequency of roughly
    0.49, but eventually it drops to 0.25\. Scenario C has a frequency of roughly
    0.01, but eventually it increases to 0.25\. The frequency sums for A and C remain
    at approximately 0.5, thus reflecting a 50% chance of winning the game.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 `min_red_fraction`参数与所有四种可能场景的采样频率的关系。场景A最初频率约为0.49，但最终降至0.25。场景C的频率约为0.01，但最终增加到0.25。A和C的频率总和保持在约0.5，从而反映了赢得游戏的50%的机会。
- en: Listing 4.15 Plotting strategy outcomes across a 52-card deck
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 在52张牌的牌堆中绘制战略结果
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ We execute a strategy across num_repeats simulations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们在num_repeats次模拟中执行战略。
- en: ❷ This list contains all instances of wins.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此列表包含所有获胜的实例。
- en: ❸ Scenario where our strategy halts and we win
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们的战略停止并获胜的场景
- en: ❹ Scenario where our strategy doesn’t halt and we win
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们的战略没有停止但获胜的场景
- en: ❺ This list contains all instances of losses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 此列表包含所有失败的实例。
- en: ❻ Scenario where our strategy halts and we lose
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 我们的战略停止但失败的场景
- en: ❼ Scenario where our strategy doesn’t halt and we lose
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 我们的战略没有停止但失败的场景
- en: ❽ We return the observed frequencies for all four scenarios.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 我们返回所有四种场景的观察频率。
- en: ❾ We scan the scenario frequencies across multiple strategies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 我们在多个策略中扫描场景频率。
- en: ❿ The bbox_to_anchor parameter is used to position the legend above the plot
    to avoid overlap with the four plotted curves.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ `bbox_to_anchor` 参数用于将图例放置在图表上方，以避免与四个绘制的曲线重叠。
- en: Let’s examine the plot at the `min_red_fraction` value of 0.5\. Here, scenario
    A (*Strategy Halts*. *We Win*.) is the most common outcome, with a frequency of
    approximately 0.49\. Meanwhile, a halt leads to a loss approximately 46% of the
    time (strategy B). So why do we maintain a 50% chance of winning the game? Well,
    in 1% of the cases, our strategy fails to halt, but we still win (scenario C).
    The strategy’s weakness is counterbalanced by random chance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察 `min_red_fraction` 值为 0.5 的图表。在这里，场景 A（策略停止。我们赢了。）是最常见的结局，频率约为 0.49。同时，停止策略大约有
    46% 的时间会导致损失（策略 B）。那么，为什么我们保持 50% 的获胜机会呢？好吧，在 1% 的情况下，我们的策略未能停止，但我们仍然赢了（场景 C）。策略的弱点被随机机会所抵消。
- en: Within the plot, as the `min_red_fraction` goes up, the frequency of scenario
    A goes down. The more conservative we are, the less likely we are to stop the
    game prematurely and yield a win. Meanwhile, the success rate of scenario C increases.
    The more conservative we are, the higher the likelihood of reaching the final
    card and winning by chance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，随着 `min_red_fraction` 的增加，场景 A 的频率下降。我们越保守，就越不可能提前停止游戏并获得胜利。同时，场景 C 的成功率增加。我们越保守，达到最终卡片并偶然获胜的可能性就越高。
- en: 'As `min_red_fraction` increases, both scenario A and scenario C converge to
    a frequency of 0.25\. Thus the probability of a win remains at 50%. Sometimes
    our strategy halts, and we do win. Other times, the strategy halts, and we still
    lose. Any advantage that each strategy offers is automatically wiped out by these
    losses. However, we occasionally get lucky: our strategy fails to halt, yet we
    win the game. These lucky wins amend our losses, and our probability of winning
    stays the same. No matter what we do, our likelihood of winning remains fifty-fifty.
    Therefore, the optimal strategy we can offer is to pick the first card in the
    shuffled deck.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `min_red_fraction` 的增加，场景 A 和场景 C 都收敛到频率 0.25。因此，获胜的概率保持在 50%。有时我们的策略停止了，我们确实赢了。其他时候，策略停止了，我们仍然输了。任何策略提供的优势都会被这些损失自动抹去。然而，我们偶尔会走运：我们的策略未能停止，但我们赢得了游戏。这些幸运的胜利弥补了我们的损失，我们的获胜概率保持不变。无论我们做什么，我们获胜的可能性始终是五五开。因此，我们可以提供的最佳策略是选择洗好的牌堆中的第一张牌。
- en: Listing 4.16 The optimal winning strategy
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 最佳获胜策略
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Probabilities can be counterintuitive. Innately, we assumed that our planned
    card game strategy would perform better than random. However, this proved not
    to be the case. We must be careful when dealing with random processes. It’s best
    to rigorously test all our intuitive assumptions prior to wagering on any future
    outcome.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率可能具有反直觉性。天生，我们假设我们计划的卡牌游戏策略会比随机策略表现更好。然而，事实并非如此。在处理随机过程时，我们必须小心。最好在押注任何未来结果之前，严格测试我们所有的直觉假设。
- en: Sometimes, even large-scale simulations fail to find a probability within the
    required level of precision. However, by simplifying our problem, we can utilize
    sample spaces to yield insights. Sample spaces allow us to test our intuition.
    If our intuitive solution fails on a toy version of the problem, it is also likely
    to fail on the actual version of the problem.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，即使是大规模的模拟也无法找到所需精度的概率。然而，通过简化我们的问题，我们可以利用样本空间来获得洞察。样本空间使我们能够测试我们的直觉。如果我们的直觉解在问题的玩具版本上失败，那么它也很可能在实际版本上失败。
