- en: 7  Data Cleaning and Preparation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 数据清理和准备
- en: 原文：[https://wesmckinney.com/book/data-cleaning](https://wesmckinney.com/book/data-cleaning)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/data-cleaning](https://wesmckinney.com/book/data-cleaning)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个*Python数据分析第三版*的开放获取网络版本现在作为[印刷版和数字版](https://amzn.to/3DyLaJc)的伴侣可用。如果您发现任何勘误，请[在此处报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto生成的本网站的某些方面与O''Reilly的印刷版和电子书版本的格式不同。'
- en: 'If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *During
    the course of doing data analysis and modeling, a significant amount of time is
    spent on data preparation: loading, cleaning, transforming, and rearranging. Such
    tasks are often reported to take up 80% or more of an analyst''s time. Sometimes
    the way that data is stored in files or databases is not in the right format for
    a particular task. Many researchers choose to do ad hoc processing of data from
    one form to another using a general-purpose programming language, like Python,
    Perl, R, or Java, or Unix text-processing tools like sed or awk. Fortunately,
    pandas, along with the built-in Python language features, provides you with a
    high-level, flexible, and fast set of tools to enable you to manipulate data into
    the right form.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质版](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或再生产。代码示例采用MIT许可证，可在GitHub或Gitee上找到。*
    *在进行数据分析和建模过程中，大量时间花费在数据准备上：加载、清理、转换和重新排列。这些任务通常被报告为占据分析师80%或更多的时间。有时，文件或数据库中存储数据的方式并不适合特定任务。许多研究人员选择使用通用编程语言（如Python、Perl、R或Java）或Unix文本处理工具（如sed或awk）对数据进行自发处理，从一种形式转换为另一种形式。幸运的是，pandas与内置的Python语言功能一起，为您提供了一套高级、灵活和快速的工具，使您能够将数据转换为正确的形式。
- en: If you identify a type of data manipulation that isn’t anywhere in this book
    or elsewhere in the pandas library, feel free to share your use case on one of
    the Python mailing lists or on the pandas GitHub site. Indeed, much of the design
    and implementation of pandas have been driven by the needs of real-world applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现在本书或pandas库中找不到的数据操作类型，请随时在Python邮件列表或pandas GitHub网站上分享您的用例。事实上，pandas的设计和实现很大程度上是由真实应用程序的需求驱动的。
- en: In this chapter I discuss tools for missing data, duplicate data, string manipulation,
    and some other analytical data transformations. In the next chapter, I focus on
    combining and rearranging datasets in various ways.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了有关缺失数据、重复数据、字符串操作和其他一些分析数据转换的工具。在下一章中，我将专注于以各种方式组合和重新排列数据集。
- en: 7.1 Handling Missing Data
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 处理缺失数据
- en: Missing data occurs commonly in many data analysis applications. One of the
    goals of pandas is to make working with missing data as painless as possible.
    For example, all of the descriptive statistics on pandas objects exclude missing
    data by default.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失数据在许多数据分析应用中很常见。pandas的目标之一是尽可能地使处理缺失数据变得轻松。例如，默认情况下，pandas对象上的所有描述性统计都排除缺失数据。
- en: The way that missing data is represented in pandas objects is somewhat imperfect,
    but it is sufficient for most real-world use. For data with `float64` dtype, pandas
    uses the floating-point value `NaN` (Not a Number) to represent missing data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: pandas对象中表示缺失数据的方式有些不完美，但对于大多数真实世界的用途来说是足够的。对于`float64`数据类型，pandas使用浮点值`NaN`（Not
    a Number）表示缺失数据。
- en: 'We call this a *sentinel value*: when present, it indicates a missing (or *null*)
    value:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为*标记值*：当存在时，表示缺失（或*空*）值：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `isna` method gives us a Boolean Series with `True` where values are null:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`isna`方法为我们提供一个布尔Series，其中值为空时为`True`：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In pandas, we've adopted a convention used in the R programming language by
    referring to missing data as NA, which stands for *not available*. In statistics
    applications, NA data may either be data that does not exist or that exists but
    was not observed (through problems with data collection, for example). When cleaning
    up data for analysis, it is often important to do analysis on the missing data
    itself to identify data collection problems or potential biases in the data caused
    by missing data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，我们采用了R编程语言中使用的惯例，将缺失数据称为NA，代表*不可用*。在统计应用中，NA数据可能是不存在的数据，也可能是存在但未被观察到的数据（例如通过数据收集问题）。在清理数据进行分析时，通常重要的是对缺失数据本身进行分析，以识别数据收集问题或由缺失数据引起的数据潜在偏差。
- en: 'The built-in Python `None` value is also treated as NA:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Python `None`值也被视为NA：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The pandas project has attempted to make working with missing data consistent
    across data types. Functions like `pandas.isna` abstract away many of the annoying
    details. See [Table 7.1](#tbl-table_na_method) for a list of some functions related
    to missing data handling.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: pandas项目已经尝试使处理缺失数据在不同数据类型之间保持一致。像`pandas.isna`这样的函数抽象了许多烦人的细节。请参阅[表7.1](#tbl-table_na_method)以获取与处理缺失数据相关的一些函数列表。
- en: 'Table 7.1: NA handling object methods'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：NA处理对象方法
- en: '| Method | Description |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dropna` | Filter axis labels based on whether values for each label have
    missing data, with varying thresholds for how much missing data to tolerate. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `dropna` | 根据每个标签的值是否具有缺失数据来过滤轴标签，对于可以容忍多少缺失数据有不同的阈值。 |'
- en: '| `fillna` | Fill in missing data with some value or using an interpolation
    method such as `"ffill"` or `"bfill"`. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `fillna` | 使用某个值或插值方法（如 `"ffill"` 或 `"bfill"`）填充缺失数据。 |'
- en: '| `isna` | Return Boolean values indicating which values are missing/NA. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `isna` | 返回指示哪些值缺失/NA 的布尔值。 |'
- en: '| `notna` | Negation of `isna`, returns `True` for non-NA values and `False`
    for NA values. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `notna` | `isna` 的否定，对于非 NA 值返回 `True`，对于 NA 值返回 `False`。 |'
- en: Filtering Out Missing Data
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤缺失数据
- en: 'There are a few ways to filter out missing data. While you always have the
    option to do it by hand using `pandas.isna` and Boolean indexing, `dropna` can
    be helpful. On a Series, it returns the Series with only the nonnull data and
    index values:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种过滤缺失数据的方法。虽然您始终可以选择使用 `pandas.isna` 和布尔索引手动执行，但 `dropna` 可能会有所帮助。对于 Series，它返回仅具有非空数据和索引值的
    Series：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the same thing as doing:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这与执行以下操作相同：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With DataFrame objects, there are different ways to remove missing data. You
    may want to drop rows or columns that are all NA, or only those rows or columns
    containing any NAs at all. `dropna` by default drops any row containing a missing
    value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DataFrame 对象，有不同的方法可以删除缺失数据。您可能希望删除所有 NA 的行或列，或者仅删除包含任何 NA 的行或列。`dropna`
    默认情况下会删除包含缺失值的任何行：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Passing `how="all"` will drop only rows that are all NA:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 传递 `how="all"` 将仅删除所有 NA 的行：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keep in mind that these functions return new objects by default and do not modify
    the contents of the original object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些函数默认情况下返回新对象，不会修改原始对象的内容。
- en: 'To drop columns in the same way, pass `axis="columns"`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要以相同方式删除列，请传递 `axis="columns"`：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose you want to keep only rows containing at most a certain number of missing
    observations. You can indicate this with the `thresh` argument:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您只想保留包含至多一定数量缺失观察的行。您可以使用 `thresh` 参数指示这一点：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Filling In Missing Data
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充缺失数据
- en: 'Rather than filtering out missing data (and potentially discarding other data
    along with it), you may want to fill in the “holes” in any number of ways. For
    most purposes, the `fillna` method is the workhorse function to use. Calling `fillna`
    with a constant replaces missing values with that value:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与过滤缺失数据（并可能连同其他数据一起丢弃）不同，您可能希望以任意方式填补任意数量的“空洞”。对于大多数情况，`fillna` 方法是要使用的主要函数。通过使用常量调用
    `fillna` 可以用该值替换缺失值：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Calling `fillna` with a dictionary, you can use a different fill value for
    each column:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过字典调用 `fillna`，您可以为每列使用不同的填充值：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The same interpolation methods available for reindexing (see [Table 5.3](/book/pandas-basics#tbl-table_reindex_function))
    can be used with `fillna`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于重新索引的相同插值方法（请参见 [表 5.3](/book/pandas-basics#tbl-table_reindex_function)）也可用于
    `fillna`：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With `fillna` you can do lots of other things such as simple data imputation
    using the median or mean statistics:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fillna`，您可以做很多其他事情，比如使用中位数或平均统计数据进行简单的数据填充：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See [Table 7.2](#tbl-table_fillna_function) for a reference on `fillna` function
    arguments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见 [表 7.2](#tbl-table_fillna_function) 了解 `fillna` 函数参数的参考。
- en: 'Table 7.2: `fillna` function arguments'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2：`fillna` 函数参数
- en: '| Argument | Description |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `value` | Scalar value or dictionary-like object to use to fill missing values
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `value` | 用于填充缺失值的标量值或类似字典的对象 |'
- en: '| `method` | Interpolation method: one of `"bfill"` (backward fill) or `"ffill"`
    (forward fill); default is `None` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `method` | 插值方法：可以是 `"bfill"`（向后填充）或 `"ffill"`（向前填充）之一；默认为 `None` |'
- en: '| `axis` | Axis to fill on (`"index"` or `"columns"`); default is `axis="index"`
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | 填充的轴（`"index"` 或 `"columns"`）；默认为 `axis="index"` |'
- en: '| `limit` | For forward and backward filling, maximum number of consecutive
    periods to fill |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `limit` | 对于向前和向后填充，最大连续填充周期数 |'
- en: 7.2 Data Transformation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 数据转换
- en: So far in this chapter we’ve been concerned with handling missing data. Filtering,
    cleaning, and other transformations are another class of important operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们一直关注处理缺失数据。过滤、清理和其他转换是另一类重要操作。
- en: Removing Duplicates
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除重复项
- en: 'Duplicate rows may be found in a DataFrame for any number of reasons. Here
    is an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 中可能会出现重复行，原因有很多。这里是一个例子：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The DataFrame method `duplicated` returns a Boolean Series indicating whether
    each row is a duplicate (its column values are exactly equal to those in an earlier
    row) or not:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 方法 `duplicated` 返回一个布尔 Series，指示每行是否为重复行（其列值与较早行中的值完全相等）：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Relatedly, `drop_duplicates` returns a DataFrame with rows where the `duplicated`
    array is `False` filtered out:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，`drop_duplicates` 返回一个 DataFrame，其中过滤掉 `duplicated` 数组为 `False` 的行：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Both methods by default consider all of the columns; alternatively, you can
    specify any subset of them to detect duplicates. Suppose we had an additional
    column of values and wanted to filter duplicates based only on the `"k1"` column:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这两种方法都考虑所有列；或者，您可以指定任何子集来检测重复项。假设我们有一个额外的值列，并且只想基于 `"k1"` 列过滤重复项：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`duplicated` and `drop_duplicates` by default keep the first observed value
    combination. Passing `keep="last"` will return the last one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`duplicated` 和 `drop_duplicates` 默认保留第一个观察到的值组合。传递 `keep="last"` 将返回最后一个：'
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Transforming Data Using a Function or Mapping
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数或映射转换数据
- en: 'For many datasets, you may wish to perform some transformation based on the
    values in an array, Series, or column in a DataFrame. Consider the following hypothetical
    data collected about various kinds of meat:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多数据集，您可能希望根据数组、Series或DataFrame中的值执行一些基于值的转换。考虑收集的关于各种肉类的假设数据：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Suppose you wanted to add a column indicating the type of animal that each
    food came from. Let’s write down a mapping of each distinct meat type to the kind
    of animal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要添加一个指示每种食物来自哪种动物的列。让我们写下每种不同肉类到动物种类的映射：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `map` method on a Series (also discussed in [Ch 5.2.5: Function Application
    and Mapping](/book/pandas-basics#pandas_apply)) accepts a function or dictionary-like
    object containing a mapping to do the transformation of values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'Series 上的 `map` 方法（也在 [Ch 5.2.5: 函数应用和映射](/book/pandas-basics#pandas_apply)
    中讨论）接受一个包含映射的函数或类似字典的对象，用于对值进行转换：'
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We could also have passed a function that does all the work:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递一个执行所有工作的函数：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using `map` is a convenient way to perform element-wise transformations and
    other data cleaning-related operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map` 是执行逐元素转换和其他数据清理相关操作的便捷方式。
- en: Replacing Values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换值
- en: 'Filling in missing data with the `fillna` method is a special case of more
    general value replacement. As you''ve already seen, `map` can be used to modify
    a subset of values in an object, but `replace` provides a simpler and more flexible
    way to do so. Let’s consider this Series:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fillna` 方法填充缺失数据是更一般的值替换的特殊情况。正如您已经看到的，`map` 可以用于修改对象中的一部分值，但 `replace`
    提供了一种更简单、更灵活的方法。让我们考虑这个 Series：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `-999` values might be sentinel values for missing data. To replace these
    with NA values that pandas understands, we can use `replace`, producing a new
    Series:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`-999` 值可能是缺失数据的标记值。要用 pandas 理解的 NA 值替换这些值，可以使用 `replace`，生成一个新的 Series：'
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to replace multiple values at once, you instead pass a list and
    then the substitute value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想一次替换多个值，可以传递一个列表，然后是替代值：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To use a different replacement for each value, pass a list of substitutes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个值使用不同的替代值，传递一个替代列表：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The argument passed can also be a dictionary:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数也可以是一个字典：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Note* *The `data.replace` method is distinct from `data.str.replace`, which
    performs element-wise string substitution. We look at these string methods on
    Series later in the chapter.*  *### Renaming Axis Indexes'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *`data.replace` 方法与 `data.str.replace` 是不同的，后者执行逐元素的字符串替换。我们将在本章后面的 Series
    中查看这些字符串方法。*  *### 重命名轴索引'
- en: 'Like values in a Series, axis labels can be similarly transformed by a function
    or mapping of some form to produce new, differently labeled objects. You can also
    modify the axes in place without creating a new data structure. Here’s a simple
    example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Series 中的值类似，轴标签也可以通过函数或某种形式的映射进行类似转换，以生成新的、不同标记的对象。您还可以在原地修改轴，而不创建新的数据结构。这是一个简单的例子：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Like a Series, the axis indexes have a `map` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Series 一样，轴索引具有 `map` 方法：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can assign to the `index` attribute, modifying the DataFrame in place:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以分配给 `index` 属性，直接修改 DataFrame：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want to create a transformed version of a dataset without modifying
    the original, a useful method is `rename`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要创建一个转换后的数据集副本而不修改原始数据集，一个有用的方法是 `rename`：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notably, `rename` can be used in conjunction with a dictionary-like object,
    providing new values for a subset of the axis labels:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`rename` 可以与类似字典的对象一起使用，为轴标签的子集提供新值：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`rename` saves you from the chore of copying the DataFrame manually and assigning
    new values to its `index` and `columns` attributes.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename` 可以避免手动复制 DataFrame 并为其 `index` 和 `columns` 属性分配新值的繁琐工作。'
- en: Discretization and Binning
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离散化和分箱
- en: 'Continuous data is often discretized or otherwise separated into “bins” for
    analysis. Suppose you have data about a group of people in a study, and you want
    to group them into discrete age buckets:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 连续数据通常被离散化或以其他方式分成“箱子”进行分析。假设您有一组人的研究数据，并且想要将它们分成离散的年龄段：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s divide these into bins of 18 to 25, 26 to 35, 36 to 60, and finally 61
    and older. To do so, you have to use `pandas.cut`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些分成18至25岁、26至35岁、36至60岁，最后是61岁及以上的箱子。为此，您必须使用 `pandas.cut`：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The object pandas returns is a special Categorical object. The output you see
    describes the bins computed by `pandas.cut`. Each bin is identified by a special
    (unique to pandas) interval value type containing the lower and upper limit of
    each bin:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 返回的对象是一个特殊的分类对象。您看到的输出描述了 `pandas.cut` 计算的箱。每个箱由一个特殊的（对于 pandas 是唯一的）区间值类型标识，其中包含每个箱的下限和上限：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that `pd.value_counts(categories)` are the bin counts for the result of
    `pandas.cut`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pd.value_counts(categories)` 是 `pandas.cut` 结果的箱计数。
- en: 'In the string representation of an interval, a parenthesis means that the side
    is *open* (exclusive), while the square bracket means it is *closed* (inclusive).
    You can change which side is closed by passing `right=False`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在区间的字符串表示中，括号表示一侧是 *开放的*（排除的），而方括号表示一侧是 *闭合的*（包含的）。您可以通过传递 `right=False` 来更改哪一侧是闭合的：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can override the default interval-based bin labeling by passing a list
    or array to the `labels` option:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将列表或数组传递给 `labels` 选项，可以覆盖默认的基于区间的箱标签：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you pass an integer number of bins to `pandas.cut` instead of explicit bin
    edges, it will compute equal-length bins based on the minimum and maximum values
    in the data. Consider the case of some uniformly distributed data chopped into
    fourths:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将整数数量的箱传递给 `pandas.cut` 而不是显式的箱边界，它将基于数据中的最小值和最大值计算等长的箱。考虑一下一些均匀分布的数据被分成四等份的情况：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `precision=2` option limits the decimal precision to two digits.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`precision=2` 选项将小数精度限制为两位数。'
- en: 'A closely related function, `pandas.qcut`, bins the data based on sample quantiles.
    Depending on the distribution of the data, using `pandas.cut` will not usually
    result in each bin having the same number of data points. Since `pandas.qcut`
    uses sample quantiles instead, you will obtain roughly equally sized bins:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与之密切相关的函数 `pandas.qcut`，根据样本分位数对数据进行分箱。根据数据的分布，使用 `pandas.cut` 通常不会导致每个箱具有相同数量的数据点。由于
    `pandas.qcut` 使用样本分位数，因此您将获得大致相同大小的箱：
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similar to `pandas.cut`, you can pass your own quantiles (numbers between 0
    and 1, inclusive):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `pandas.cut`，您可以传递自己的分位数（介于 0 和 1 之间的数字）：
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We’ll return to `pandas.cut` and `pandas.qcut` later in the chapter during our
    discussion of aggregation and group operations, as these discretization functions
    are especially useful for quantile and group analysis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的聚合和分组操作讨论中再次回到`pandas.cut`和`pandas.qcut`，因为这些离散化函数对于分位数和分组分析特别有用。
- en: Detecting and Filtering Outliers
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测和过滤异常值
- en: 'Filtering or transforming outliers is largely a matter of applying array operations.
    Consider a DataFrame with some normally distributed data:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤或转换异常值主要是应用数组操作的问题。考虑一个包含一些正态分布数据的DataFrame：
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Suppose you wanted to find values in one of the columns exceeding 3 in absolute
    value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要查找绝对值超过3的某一列中的值：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To select all rows having a value exceeding 3 or –3, you can use the `any`
    method on a Boolean DataFrame:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所有值超过3或-3的行，您可以在布尔DataFrame上使用`any`方法：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The parentheses around `data.abs() > 3` are necessary in order to call the `any`
    method on the result of the comparison operation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data.abs() > 3`周围的括号是必要的，以便在比较操作的结果上调用`any`方法。
- en: 'Values can be set based on these criteria. Here is code to cap values outside
    the interval –3 to 3:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据这些标准设置值。以下是将值限制在区间-3到3之外的代码：
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The statement `np.sign(data)` produces 1 and –1 values based on whether the
    values in `data` are positive or negative:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.sign(data)`语句根据`data`中的值是正数还是负数产生1和-1值：'
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Permutation and Random Sampling
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排列和随机抽样
- en: 'Permuting (randomly reordering) a Series or the rows in a DataFrame is possible
    using the `numpy.random.permutation` function. Calling `permutation` with the
    length of the axis you want to permute produces an array of integers indicating
    the new ordering:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`numpy.random.permutation`函数，可以对Series或DataFrame中的行进行排列（随机重新排序）。调用`permutation`并传入您想要排列的轴的长度会产生一个整数数组，指示新的排序：
- en: '[PRE45]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That array can then be used in `iloc`-based indexing or the equivalent `take`
    function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将该数组用于基于`iloc`的索引或等效的`take`函数：
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By invoking `take` with `axis="columns"`, we could also select a permutation
    of the columns:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`axis="columns"`调用`take`，我们还可以选择列的排列：
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To select a random subset without replacement (the same row cannot appear twice),
    you can use the `sample` method on Series and DataFrame:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择一个不带替换的随机子集（同一行不能出现两次），可以在Series和DataFrame上使用`sample`方法：
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To generate a sample *with* replacement (to allow repeat choices), pass `replace=True`
    to `sample`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个*带有*替换的样本（允许重复选择），请将`replace=True`传递给`sample`：
- en: '[PRE49]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Computing Indicator/Dummy Variables
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算指示/虚拟变量
- en: 'Another type of transformation for statistical modeling or machine learning
    applications is converting a categorical variable into a *dummy* or *indicator*
    matrix. If a column in a DataFrame has `k` distinct values, you would derive a
    matrix or DataFrame with `k` columns containing all 1s and 0s. pandas has a `pandas.get_dummies`
    function for doing this, though you could also devise one yourself. Let’s consider
    an example DataFrame:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种用于统计建模或机器学习应用的转换类型是将分类变量转换为*虚拟*或*指示*矩阵。如果DataFrame中的一列有`k`个不同的值，您将得到一个包含所有1和0的`k`列的矩阵或DataFrame。pandas有一个`pandas.get_dummies`函数可以做到这一点，尽管您也可以自己设计一个。让我们考虑一个示例DataFrame：
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here I passed `dtype=float` to change the output type from boolean (the default
    in more recent versions of pandas) to floating point.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我传递了`dtype=float`以将输出类型从布尔值（pandas较新版本中的默认值）更改为浮点数。
- en: 'In some cases, you may want to add a prefix to the columns in the indicator
    DataFrame, which can then be merged with the other data. `pandas.get_dummies`
    has a prefix argument for doing this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望在指示DataFrame的列中添加前缀，然后将其与其他数据合并。`pandas.get_dummies`有一个用于执行此操作的前缀参数：
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `DataFrame.join` method will be explained in more detail in the next chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame.join`方法将在下一章中详细解释。'
- en: 'If a row in a DataFrame belongs to multiple categories, we have to use a different
    approach to create the dummy variables. Let’s look at the MovieLens 1M dataset,
    which is investigated in more detail in [Ch 13: Data Analysis Examples](#data-analysis-examples):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DataFrame中的一行属于多个类别，则我们必须使用不同的方法来创建虚拟变量。让我们看一下MovieLens 1M数据集，该数据集在[Ch 13：数据分析示例](#data-analysis-examples)中有更详细的研究：
- en: '[PRE52]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'pandas has implemented a special Series method `str.get_dummies` (methods that
    start with `str.` are discussed in more detail later in [String Manipulation](#text_string_manip))
    that handles this scenario of multiple group membership encoded as a delimited
    string:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: pandas实现了一个特殊的Series方法`str.get_dummies`（以`str.`开头的方法将在[字符串操作](#text_string_manip)中更详细地讨论），处理了将多个组成员身份编码为分隔字符串的情况：
- en: '[PRE53]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, as before, you can combine this with `movies` while adding a `"Genre_"`
    to the column names in the `dummies` DataFrame with the `add_prefix` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，与之前一样，您可以将此与`movies`组合，同时在`dummies` DataFrame的列名中添加`"Genre_"`，使用`add_prefix`方法：
- en: '[PRE54]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Note* *For much larger data, this method of constructing indicator variables
    with multiple membership is not especially speedy. It would be better to write
    a lower-level function that writes directly to a NumPy array, and then wrap the
    result in a DataFrame.*  *A useful recipe for statistical applications is to combine
    `pandas.get_dummies` with a discretization function like `pandas.cut`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *对于更大的数据，使用这种构建具有多个成员身份的指示变量的方法并不特别快速。最好编写一个直接写入NumPy数组的低级函数，然后将结果包装在DataFrame中。*
    *在统计应用中的一个有用的技巧是将`pandas.get_dummies`与像`pandas.cut`这样的离散化函数结合使用：*'
- en: '[PRE55]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We will look again at `pandas.get_dummies` later in [Creating dummy variables
    for modeling](#pandas-categorical-dummy).**  **## 7.3 Extension Data Types
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将再次查看`pandas.get_dummies`，在[为建模创建虚拟变量](#pandas-categorical-dummy)中。**  **##
    7.3 扩展数据类型
- en: '*Note* *This is a newer and more advanced topic that many pandas users do not
    need to know a lot about, but I present it here for completeness since I will
    reference and use extension data types in various places in the upcoming chapters.*  *pandas
    was originally built upon the capabilities present in NumPy, an array computing
    library used primarily for working with numerical data. Many pandas concepts,
    such as missing data, were implemented using what was available in NumPy while
    trying to maximize compatibility between libraries that used NumPy and pandas
    together.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *这是一个较新且更高级的主题，许多pandas用户不需要了解太多，但我在这里完整地介绍它，因为在接下来的章节中我将引用和使用扩展数据类型。*
    *pandas最初是建立在NumPy的基础上的，NumPy是一个主要用于处理数值数据的数组计算库。许多pandas概念，如缺失数据，是使用NumPy中可用的内容实现的，同时尽量在使用NumPy和pandas的库之间最大程度地保持兼容性。'
- en: 'Building on NumPy led to a number of shortcomings, such as:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基于NumPy的构建存在许多缺点，例如：
- en: Missing data handling for some numerical data types, such as integers and Booleans,
    was incomplete. As a result, when missing data was introduced into such data,
    pandas converted the data type to `float64` and used `np.nan` to represent null
    values. This had compounding effects by introducing subtle issues into many pandas
    algorithms.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些数值数据类型，如整数和布尔值，缺失数据处理是不完整的。因此，当这些数据中引入缺失数据时，pandas会将数据类型转换为`float64`，并使用`np.nan`表示空值。这导致许多pandas算法中出现了微妙的问题。
- en: Datasets with a lot of string data were computationally expensive and used a
    lot of memory.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有大量字符串数据的数据集在计算上是昂贵的，并且使用了大量内存。
- en: Some data types, like time intervals, timedeltas, and timestamps with time zones,
    could not be supported efficiently without using computationally expensive arrays
    of Python objects.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些数据类型，如时间间隔、时间增量和带时区的时间戳，如果不使用计算昂贵的Python对象数组，将无法有效支持。
- en: More recently, pandas has developed an *extension type* system allowing for
    new data types to be added even if they are not supported natively by NumPy. These
    new data types can be treated as first class alongside data coming from NumPy
    arrays.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，pandas开发了一个*扩展类型*系统，允许添加新的数据类型，即使它们在NumPy中没有原生支持。这些新数据类型可以被视为与来自NumPy数组的数据同等重要。
- en: 'Let''s look at an example where we create a Series of integers with a missing
    value:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们创建一个带有缺失值的整数Series：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Mainly for backward compatibility reasons, Series uses the legacy behavior
    of using a `float64` data type and `np.nan` for the missing value. We could create
    this Series instead using `pandas.Int64Dtype`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 主要出于向后兼容的原因，Series使用了使用`float64`数据类型和`np.nan`表示缺失值的传统行为。我们可以使用`pandas.Int64Dtype`来创建这个Series：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output `<NA>` indicates that a value is missing for an extension type array.
    This uses the special `pandas.NA` sentinel value:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`<NA>`表示扩展类型数组中的值缺失。这使用了特殊的`pandas.NA`标记值：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also could have used the shorthand `"Int64"` instead of `pd.Int64Dtype()`
    to specify the type. The capitalization is necessary, otherwise it will be a NumPy-based
    nonextension type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用缩写`"Int64"`来指定类型，而不是`pd.Int64Dtype()`。大写是必需的，否则它将是一个基于NumPy的非扩展类型：
- en: '[PRE59]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'pandas also has an extension type specialized for string data that does not
    use NumPy object arrays (it requires the pyarrow library, which you may need to
    install separately):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: pandas还有一种专门用于字符串数据的扩展类型，不使用NumPy对象数组（需要安装pyarrow库）：
- en: '[PRE60]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: These string arrays generally use much less memory and are frequently computationally
    more efficient for doing operations on large datasets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串数组通常使用更少的内存，并且在对大型数据集进行操作时通常更高效。
- en: Another important extension type is `Categorical`, which we discuss in more
    detail in [Categorical Data](#pandas-categorical). A reasonably complete list
    of extension types available as of this writing is in [Table 7.3](#tbl-table_pandas_extension_types).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的扩展类型是`Categorical`，我们将在[Categorical Data](#pandas-categorical)中更详细地讨论。截至本文撰写时，可用的扩展类型的相对完整列表在[表7.3](#tbl-table_pandas_extension_types)中。
- en: 'Extension types can be passed to the Series `astype` method, allowing you to
    convert easily as part of your data cleaning process:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展类型可以传递给Series的`astype`方法，允许您在数据清理过程中轻松转换：
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Table 7.3: pandas extension data types'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3：pandas扩展数据类型
- en: '| Extension type | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 扩展类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BooleanDtype` | Nullable Boolean data, use `"boolean"` when passing as string
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `BooleanDtype` | 可空布尔数据，传递字符串时使用`"boolean"` |'
- en: '| `CategoricalDtype` | Categorical data type, use `"category"` when passing
    as string |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `CategoricalDtype` | 分类数据类型，传递字符串时使用`"category"` |'
- en: '| `DatetimeTZDtype` | Datetime with time zone |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `DatetimeTZDtype` | 带时区的日期时间 |'
- en: '| `Float32Dtype` | 32-bit nullable floating point, use `"Float32"` when passing
    as string |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `Float32Dtype` | 32位可空浮点数，传递字符串时使用`"Float32"` |'
- en: '| `Float64Dtype` | 64-bit nullable floating point, use `"Float64"` when passing
    as string |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `Float64Dtype` | 64位可空浮点数，传递字符串时使用`"Float64"` |'
- en: '| `Int8Dtype` | 8-bit nullable signed integer, use `"Int8"` when passing as
    string |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `Int8Dtype` | 8位可空有符号整数，传递字符串时使用`"Int8"` |'
- en: '| `Int16Dtype` | 16-bit nullable signed integer, use `"Int16"` when passing
    as string |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `Int16Dtype` | 16位可空有符号整数，传递字符串时使用`"Int16"` |'
- en: '| `Int32Dtype` | 32-bit nullable signed integer, use `"Int32"` when passing
    as string |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `Int32Dtype` | 32位可空有符号整数，传递字符串时使用`"Int32"` |'
- en: '| `Int64Dtype` | 64-bit nullable signed integer, use `"Int64"` when passing
    as string |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `Int64Dtype` | 64位可空有符号整数，传递字符串时使用`"Int64"` |'
- en: '| `UInt8Dtype` | 8-bit nullable unsigned integer, use `"UInt8"` when passing
    as string |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `UInt8Dtype` | 8位可空无符号整数，传递字符串时使用`"UInt8"` |'
- en: '| `UInt16Dtype` | 16-bit nullable unsigned integer, use `"UInt16"` when passing
    as string |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `UInt16Dtype` | 16位可空无符号整数，传递字符串时使用`"UInt16"` |'
- en: '| `UInt32Dtype` | 32-bit nullable unsigned integer, use `"UInt32"` when passing
    as string |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `UInt32Dtype` | 32位可空无符号整数，传递字符串时使用`"UInt32"` |'
- en: '| `UInt64Dtype` | 64-bit nullable unsigned integer, use `"UInt64"` when passing
    as string |*  *## 7.4 String Manipulation'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '| `UInt64Dtype` | 64位可空无符号整数，在传递为字符串时使用`"UInt64"` |*  *## 7.4字符串操作'
- en: Python has long been a popular raw data manipulation language in part due to
    its ease of use for string and text processing. Most text operations are made
    simple with the string object’s built-in methods. For more complex pattern matching
    and text manipulations, regular expressions may be needed. pandas adds to the
    mix by enabling you to apply string and regular expressions concisely on whole
    arrays of data, additionally handling the annoyance of missing data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Python长期以来一直是一种流行的原始数据处理语言，部分原因是它易于用于字符串和文本处理。大多数文本操作都可以通过字符串对象的内置方法简化。对于更复杂的模式匹配和文本操作，可能需要使用正则表达式。pandas通过使您能够简洁地在整个数据数组上应用字符串和正则表达式，另外处理了缺失数据的烦恼。
- en: Python Built-In String Object Methods
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python内置字符串对象方法
- en: 'In many string munging and scripting applications, built-in string methods
    are sufficient. As an example, a comma-separated string can be broken into pieces
    with `split`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多字符串处理和脚本应用程序中，内置字符串方法已经足够。例如，逗号分隔的字符串可以使用`split`分割成多个部分：
- en: '[PRE62]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`split` is often combined with `strip` to trim whitespace (including line breaks):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`通常与`strip`结合使用以修剪空格（包括换行符）：'
- en: '[PRE63]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'These substrings could be concatenated together with a two-colon delimiter
    using addition:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子字符串可以使用加法和双冒号分隔符连接在一起：
- en: '[PRE64]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'But this isn’t a practical generic method. A faster and more Pythonic way is
    to pass a list or tuple to the `join` method on the string `"::"`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是一种实用的通用方法。更快速和更符合Python风格的方法是将列表或元组传递给字符串`"::"`上的`join`方法：
- en: '[PRE65]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Other methods are concerned with locating substrings. Using Python’s `in` keyword
    is the best way to detect a substring, though `index` and `find` can also be used:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法涉及定位子字符串。使用Python的`in`关键字是检测子字符串的最佳方法，尽管也可以使用`index`和`find`：
- en: '[PRE66]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Note that the difference between `find` and `index` is that `index` raises
    an exception if the string isn’t found (versus returning –1):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`find`和`index`之间的区别在于，如果未找到字符串，`index`会引发异常（而不是返回-1）：
- en: '[PRE67]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Relatedly, `count` returns the number of occurrences of a particular substring:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，`count`返回特定子字符串的出现次数：
- en: '[PRE68]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`replace` will substitute occurrences of one pattern for another. It is commonly
    used to delete patterns, too, by passing an empty string:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace`将一个模式的出现替换为另一个。通常也用于通过传递空字符串来删除模式：'
- en: '[PRE69]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: See [Table 7.4](#tbl-table_string_methods) for a listing of some of Python's
    string methods.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[表7.4](#tbl-table_string_methods)以获取Python的一些字符串方法列表。
- en: Regular expressions can also be used with many of these operations, as you’ll
    see.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式也可以与许多这些操作一起使用，您将看到。
- en: 'Table 7.4: Python built-in string methods'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.4：Python内置字符串方法
- en: '| Method | Description |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `count` | Return the number of nonoverlapping occurrences of substring in
    the string |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 返回字符串中子字符串的非重叠出现次数 |'
- en: '| `endswith` | Return `True` if string ends with suffix |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `endswith` | 如果字符串以后缀结尾，则返回`True` |'
- en: '| `startswith` | Return `True` if string starts with prefix |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `startswith` | 如果字符串以前缀开头，则返回`True` |'
- en: '| `join` | Use string as delimiter for concatenating a sequence of other strings
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `join` | 用作分隔符将字符串用于连接其他字符串序列 |'
- en: '| `index` | Return starting index of the first occurrence of passed substring
    if found in the string; otherwise, raises `ValueError` if not found |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 如果在字符串中找到传递的子字符串，则返回第一个出现的起始索引；否则，如果未找到，则引发`ValueError` |'
- en: '| `find` | Return position of first character of *first* occurrence of substring
    in the string; like `index`, but returns –1 if not found |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `find` | 返回字符串中*第一个*出现的子字符串的第一个字符的位置；类似于`index`，但如果未找到则返回-1 |'
- en: '| `rfind` | Return position of first character of *last* occurrence of substring
    in the string; returns –1 if not found |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `rfind` | 返回字符串中*最后*出现的子字符串的第一个字符的位置；如果未找到则返回-1 |'
- en: '| `replace` | Replace occurrences of string with another string |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `replace` | 用另一个字符串替换字符串的出现 |'
- en: '| `strip, rstrip, lstrip` | Trim whitespace, including newlines on both sides,
    on the right side, or on the left side, respectively |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `strip, rstrip, lstrip` | 修剪空格，包括右侧、左侧或两侧的换行符 |'
- en: '| `split` | Break string into list of substrings using passed delimiter |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `split` | 使用传递的分隔符将字符串拆分为子字符串列表 |'
- en: '| `lower` | Convert alphabet characters to lowercase |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `lower` | 将字母字符转换为小写 |'
- en: '| `upper` | Convert alphabet characters to uppercase |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `upper` | 将字母字符转换为大写 |'
- en: '| `casefold` | Convert characters to lowercase, and convert any region-specific
    variable character combinations to a common comparable form |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `casefold` | 将字符转换为小写，并将任何区域特定的可变字符组合转换为一个通用的可比较形式 |'
- en: '| `ljust, rjust` | Left justify or right justify, respectively; pad opposite
    side of string with spaces (or some other fill character) to return a string with
    a minimum width |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `ljust, rjust` | 分别左对齐或右对齐；用空格（或其他填充字符）填充字符串的对侧，以返回具有最小宽度的字符串 |'
- en: Regular Expressions
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式
- en: '*Regular expressions* provide a flexible way to search or match (often more
    complex) string patterns in text. A single expression, commonly called a *regex*,
    is a string formed according to the regular expression language. Python’s built-in
    `re` module is responsible for applying regular expressions to strings; I’ll give
    a number of examples of its use here.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*提供了一种灵活的方式来在文本中搜索或匹配（通常更复杂的）字符串模式。单个表达式，通常称为*regex*，是根据正则表达式语言形成的字符串。Python的内置`re`模块负责将正则表达式应用于字符串；我将在这里给出一些示例。'
- en: '*Note* *The art of writing regular expressions could be a chapter of its own
    and thus is outside the book’s scope. There are many excellent tutorials and references
    available on the internet and in other books.*  *The `re` module functions fall
    into three categories: pattern matching, substitution, and splitting. Naturally
    these are all related; a regex describes a pattern to locate in the text, which
    can then be used for many purposes. Let’s look at a simple example: suppose we
    wanted to split a string with a variable number of whitespace characters (tabs,
    spaces, and newlines).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *编写正则表达式的艺术可能是一个单独的章节，因此超出了本书的范围。互联网和其他书籍上有许多优秀的教程和参考资料。* *`re` 模块的函数分为三类：模式匹配、替换和拆分。当然，这些都是相关的；正则表达式描述了要在文本中定位的模式，然后可以用于许多目的。让我们看一个简单的例子：假设我们想要使用可变数量的空白字符（制表符、空格和换行符）来拆分字符串。'
- en: 'The regex describing one or more whitespace characters is `\s+`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个或多个空白字符的正则表达式是 `\s+`：
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When you call `re.split(r"\s+", text)`, the regular expression is first *compiled*,
    and then its `split` method is called on the passed text. You can compile the
    regex yourself with `re.compile`, forming a reusable regex object:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用 `re.split(r"\s+", text)` 时，正则表达式首先被 *编译*，然后在传递的文本上调用其 `split` 方法。您可以使用
    `re.compile` 自己编译正则表达式，形成一个可重用的正则表达式对象：
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If, instead, you wanted to get a list of all patterns matching the regex, you
    can use the `findall` method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要获取与正则表达式匹配的所有模式的列表，可以使用 `findall` 方法：
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*Note* *To avoid unwanted escaping with `\` in a regular expression, use *raw*
    string literals like `r"C:\x"` instead of the equivalent `"C:\\x"`.*  *Creating
    a regex object with `re.compile` is highly recommended if you intend to apply
    the same expression to many strings; doing so will save CPU cycles.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *为了避免在正则表达式中使用 `\` 进行不必要的转义，请使用 *原始* 字符串字面量，如 `r"C:\x"`，而不是等效的 `"C:\\x"`。*
    *如果您打算将相同的表达式应用于许多字符串，强烈建议使用 `re.compile` 创建一个正则表达式对象；这样可以节省 CPU 周期。'
- en: '`match` and `search` are closely related to `findall`. While `findall` returns
    all matches in a string, `search` returns only the first match. More rigidly,
    `match` *only* matches at the beginning of the string. As a less trivial example,
    let’s consider a block of text and a regular expression capable of identifying
    most email addresses:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 和 `search` 与 `findall` 密切相关。虽然 `findall` 返回字符串中的所有匹配项，但 `search` 只返回第一个匹配项。更严格地说，`match`
    *仅* 在字符串开头匹配。作为一个不太琐碎的例子，让我们考虑一个文本块和一个能够识别大多数电子邮件地址的正则表达式：'
- en: '[PRE73]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Using `findall` on the text produces a list of the email addresses:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本上使用 `findall` 会产生一个电子邮件地址列表：
- en: '[PRE74]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`search` returns a special match object for the first email address in the
    text. For the preceding regex, the match object can only tell us the start and
    end position of the pattern in the string:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`search` 为文本中的第一个电子邮件地址返回一个特殊的匹配对象。对于前面的正则表达式，匹配对象只能告诉我们模式在字符串中的起始和结束位置：'
- en: '[PRE75]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`regex.match` returns `None`, as it will match only if the pattern occurs at
    the start of the string:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex.match` 返回 `None`，因为它只会匹配如果模式出现在字符串的开头时：'
- en: '[PRE76]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Relatedly, `sub` will return a new string with occurrences of the pattern replaced
    by a new string:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，`sub` 将返回一个新字符串，其中模式的出现被新字符串替换：
- en: '[PRE77]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Suppose you wanted to find email addresses and simultaneously segment each
    address into its three components: username, domain name, and domain suffix. To
    do this, put parentheses around the parts of the pattern to segment:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要查找电子邮件地址，并同时将每个地址分成三个组件：用户名、域名和域后缀。为此，请在模式的部分周围加上括号以进行分段：
- en: '[PRE78]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A match object produced by this modified regex returns a tuple of the pattern
    components with its `groups` method:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由此修改后的正则表达式生成的匹配对象将使用其 `groups` 方法返回模式组件的元组：
- en: '[PRE79]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`findall` returns a list of tuples when the pattern has groups:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式有组时，`findall` 返回一个元组列表：
- en: '[PRE80]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`sub` also has access to groups in each match using special symbols like `\1`
    and `\2`. The symbol `\1` corresponds to the first matched group, `\2` corresponds
    to the second, and so forth:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub` 还可以使用特殊符号如 `\1` 和 `\2` 访问每个匹配中的组。符号 `\1` 对应于第一个匹配组，`\2` 对应于第二个，依此类推：'
- en: '[PRE81]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There is much more to regular expressions in Python, most of which is outside
    the book’s scope. [Table 7.5](#tbl-table_regex_method) provides a brief summary.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的正则表达式还有很多内容，其中大部分超出了本书的范围。[表 7.5](#tbl-table_regex_method) 提供了一个简要总结。
- en: 'Table 7.5: Regular expression methods'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.5：正则表达式方法
- en: '| Method | Description |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `findall` | Return all nonoverlapping matching patterns in a string as a
    list |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `findall` | 返回字符串中所有非重叠匹配模式的列表 |'
- en: '| `finditer` | Like `findall`, but returns an iterator |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `finditer` | 类似于 `findall`，但返回一个迭代器 |'
- en: '| `match` | Match pattern at start of string and optionally segment pattern
    components into groups; if the pattern matches, return a match object, and otherwise
    `None` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `match` | 在字符串开头匹配模式，并可选择将模式组件分段；如果模式匹配，则返回一个匹配对象，否则返回 `None` |'
- en: '| `search` | Scan string for match to pattern, returning a match object if
    so; unlike `match`, the match can be anywhere in the string as opposed to only
    at the beginning |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `search` | 扫描字符串以查找与模式匹配的内容，如果匹配，则返回一个匹配对象；与 `match` 不同，匹配可以出现在字符串的任何位置，而不仅仅是在开头
    |'
- en: '| `split` | Break string into pieces at each occurrence of pattern |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `split` | 在每次模式出现时将字符串分割成片段 |'
- en: '| `sub, subn` | Replace all (`sub`) or first `n` occurrences (`subn`) of pattern
    in string with replacement expression; use symbols `\1, \2, ...` to refer to match
    group elements in the replacement string |**  **### String Functions in pandas'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '| `sub, subn` | 用替换表达式替换字符串中所有 (`sub`) 或前 `n` 次出现 (`subn`) 的模式；使用符号 `\1, \2,
    ...` 来引用替换字符串中的匹配组元素 |**  **### pandas 中的字符串函数'
- en: 'Cleaning up a messy dataset for analysis often requires a lot of string manipulation.
    To complicate matters, a column containing strings will sometimes have missing
    data:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 清理混乱的数据集以进行分析通常需要大量的字符串操作。为了使事情更加复杂，包含字符串的列有时会有缺失数据：
- en: '[PRE82]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'String and regular expression methods can be applied (passing a `lambda` or
    other function) to each value using `data.map`, but it will fail on the NA (null)
    values. To cope with this, Series has array-oriented methods for string operations
    that skip over and propagate NA values. These are accessed through Series’s `str`
    attribute; for example, we could check whether each email address has `"gmail"`
    in it with `str.contains`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将字符串和正则表达式方法应用于每个值（传递 `lambda` 或其他函数）使用 `data.map`，但它将在 NA（空值）上失败。为了应对这一情况，Series
    具有面向数组的字符串操作方法，可以跳过并传播 NA 值。这些方法通过 Series 的 `str` 属性访问；例如，我们可以使用 `str.contains`
    检查每个电子邮件地址中是否包含 `"gmail"`：
- en: '[PRE83]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Note that the result of this operation has an `object` dtype. pandas has *extension
    types* that provide for specialized treatment of strings, integers, and Boolean
    data which until recently have had some rough edges when working with missing
    data:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此操作的结果具有 `object` 类型。pandas 具有提供对字符串、整数和布尔数据进行专门处理的*扩展类型*，这些类型在处理缺失数据时一直存在一些问题：
- en: '[PRE84]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Extension types are discussed in more detail in [Extension Data Types](#pandas-ext-types).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地讨论了扩展类型，请参阅[扩展数据类型](#pandas-ext-types)。
- en: 'Regular expressions can be used, too, along with any `re` options like `IGNORECASE`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用正则表达式，以及任何 `re` 选项，如 `IGNORECASE`：
- en: '[PRE85]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'There are a couple of ways to do vectorized element retrieval. Either use `str.get`
    or index into the `str` attribute:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种进行矢量化元素检索的方法。可以使用 `str.get` 或索引到 `str` 属性：
- en: '[PRE86]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can similarly slice strings using this syntax:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下语法对字符串进行切片：
- en: '[PRE87]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `str.extract` method will return the captured groups of a regular expression
    as a DataFrame:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.extract` 方法将返回正则表达式的捕获组作为 DataFrame：'
- en: '[PRE88]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: See [Table 7.6](#tbl-table_vec_string) for more pandas string methods.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 查看更多 pandas 字符串方法，请参阅[表 7.6](#tbl-table_vec_string)。
- en: 'Table 7.6: Partial listing of Series string methods'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '表 7.6: Series 字符串方法的部分列表'
- en: '| Method | Description |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cat` | Concatenate strings element-wise with optional delimiter |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `cat` | 逐元素连接字符串，可选分隔符 |'
- en: '| `contains` | Return Boolean array if each string contains pattern/regex |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `contains` | 如果每个字符串包含模式/正则表达式，则返回布尔数组 |'
- en: '| `count` | Count occurrences of pattern |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 计算模式的出现次数 |'
- en: '| `extract` | Use a regular expression with groups to extract one or more strings
    from a Series of strings; the result will be a DataFrame with one column per group
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `extract` | 使用具有组的正则表达式从字符串 Series 中提取一个或多个字符串；结果将是一个每组一列的 DataFrame |'
- en: '| `endswith` | Equivalent to `x.endswith(pattern)` for each element |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `endswith` | 对每个元素等同于 `x.endswith(pattern)` |'
- en: '| `startswith` | Equivalent to `x.startswith(pattern)` for each element |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `startswith` | 对每个元素等同于 `x.startswith(pattern)` |'
- en: '| `findall` | Compute list of all occurrences of pattern/regex for each string
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `findall` | 计算每个字符串的模式/正则表达式的所有出现的列表 |'
- en: '| `get` | Index into each element (retrieve *i*-th element) |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `get` | 索引到每个元素（检索第 *i* 个元素） |'
- en: '| `isalnum` | Equivalent to built-in `str.alnum` |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `isalnum` | 等同于内置的 `str.alnum` |'
- en: '| `isalpha` | Equivalent to built-in `str.isalpha` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `isalpha` | 等同于内置的 `str.isalpha` |'
- en: '| `isdecimal` | Equivalent to built-in `str.isdecimal` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `isdecimal` | 等同于内置的 `str.isdecimal` |'
- en: '| `isdigit` | Equivalent to built-in `str.isdigit` |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `isdigit` | 等同于内置的 `str.isdigit` |'
- en: '| `islower` | Equivalent to built-in `str.islower` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `islower` | 等同于内置的 `str.islower` |'
- en: '| `isnumeric` | Equivalent to built-in `str.isnumeric` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `isnumeric` | 等同于内置的 `str.isnumeric` |'
- en: '| `isupper` | Equivalent to built-in `str.isupper` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `isupper` | 等同于内置的 `str.isupper` |'
- en: '| `join` | Join strings in each element of the Series with passed separator
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `join` | 使用传递的分隔符连接 Series 中每个元素的字符串 |'
- en: '| `len` | Compute length of each string |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `len` | 计算每个字符串的长度 |'
- en: '| `lower, upper` | Convert cases; equivalent to `x.lower()` or `x.upper()`
    for each element |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `lower, upper` | 转换大小写；对每个元素等同于 `x.lower()` 或 `x.upper()` |'
- en: '| `match` | Use `re.match` with the passed regular expression on each element,
    returning `True` or `False` whether it matches |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `match` | 对每个元素使用传递的正则表达式的 `re.match`，返回是否匹配的 `True` 或 `False` |'
- en: '| `pad` | Add whitespace to left, right, or both sides of strings |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `pad` | 在字符串的左侧、右侧或两侧添加空格 |'
- en: '| `center` | Equivalent to `pad(side="both")` |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `center` | 等同于 `pad(side="both")` |'
- en: '| `repeat` | Duplicate values (e.g., `s.str.repeat(3)` is equivalent to `x
    * 3` for each string) |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `repeat` | 复制值（例如，`s.str.repeat(3)` 相当于对每个字符串执行 `x * 3`） |'
- en: '| `replace` | Replace occurrences of pattern/regex with some other string |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `replace` | 用其他字符串替换模式/正则表达式的出现 |'
- en: '| `slice` | Slice each string in the Series |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `slice` | 对 Series 中的每个字符串进行切片 |'
- en: '| `split` | Split strings on delimiter or regular expression |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `split` | 按分隔符或正则表达式拆分字符串 |'
- en: '| `strip` | Trim whitespace from both sides, including newlines |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `strip` | 从两侧修剪空白，包括换行符 |'
- en: '| `rstrip` | Trim whitespace on right side |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `rstrip` | 修剪右侧的空白 |'
- en: '| `lstrip` | Trim whitespace on left side |**  **## 7.5 Categorical Data'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '| `lstrip` | 修剪左侧的空白 |**  **## 7.5 分类数据'
- en: This section introduces the pandas `Categorical` type. I will show how you can
    achieve better performance and memory use in some pandas operations by using it.
    I also introduce some tools that may help with using categorical data in statistics
    and machine learning applications.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 pandas 的 `Categorical` 类型。我将展示如何通过使用它在某些 pandas 操作中实现更好的性能和内存使用。我还介绍了一些工具，这些工具可能有助于在统计和机器学习应用中使用分类数据。
- en: Background and Motivation
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景和动机
- en: 'Frequently, a column in a table may contain repeated instances of a smaller
    set of distinct values. We have already seen functions like `unique` and `value_counts`,
    which enable us to extract the distinct values from an array and compute their
    frequencies, respectively:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，表中的一列可能包含较小一组不同值的重复实例。我们已经看到了像 `unique` 和 `value_counts` 这样的函数，它们使我们能够从数组中提取不同的值并分别计算它们的频率：
- en: '[PRE89]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Many data systems (for data warehousing, statistical computing, or other uses)
    have developed specialized approaches for representing data with repeated values
    for more efficient storage and computation. In data warehousing, a best practice
    is to use so-called *dimension tables* containing the distinct values and storing
    the primary observations as integer keys referencing the dimension table:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据系统（用于数据仓库、统计计算或其他用途）已经开发了专门的方法来表示具有重复值的数据，以实现更高效的存储和计算。在数据仓库中，最佳实践是使用所谓的*维度表*，其中包含不同的值，并将主要观察结果存储为引用维度表的整数键：
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can use the `take` method to restore the original Series of strings:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`take`方法恢复原始的字符串Series：
- en: '[PRE91]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This representation as integers is called the *categorical* or *dictionary-encoded*
    representation. The array of distinct values can be called the *categories*, *dictionary*,
    or *levels* of the data. In this book we will use the terms *categorical* and
    *categories*. The integer values that reference the categories are called the
    *category codes* or simply *codes*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种整数表示被称为*分类*或*字典编码*表示。不同值的数组可以称为数据的*类别*、*字典*或*级别*。在本书中，我们将使用术语*分类*和*类别*。引用类别的整数值称为*类别代码*或简称*代码*。
- en: 'The categorical representation can yield significant performance improvements
    when you are doing analytics. You can also perform transformations on the categories
    while leaving the codes unmodified. Some example transformations that can be made
    at relatively low cost are:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行分析时，分类表示可以显著提高性能。您还可以在保持代码不变的情况下对类别执行转换。一些可以以相对较低的成本进行的示例转换包括：
- en: Renaming categories
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名类别
- en: Appending a new category without changing the order or position of the existing
    categories
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追加一个新类别而不改变现有类别的顺序或位置
- en: Categorical Extension Type in pandas
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pandas中的分类扩展类型
- en: pandas has a special `Categorical` extension type for holding data that uses
    the integer-based categorical representation or *encoding*. This is a popular
    data compression technique for data with many occurrences of similar values and
    can provide significantly faster performance with lower memory use, especially
    for string data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: pandas具有专门的`Categorical`扩展类型，用于保存使用基于整数的分类表示或*编码*的数据。这是一种流行的数据压缩技术，适用于具有许多相似值出现的数据，并且可以提供更快的性能和更低的内存使用，特别是对于字符串数据。
- en: 'Let''s consider the example Series from before:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑之前的示例Series：
- en: '[PRE92]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, `df[''fruit'']` is an array of Python string objects. We can convert
    it to categorical by calling:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`df['fruit']`是Python字符串对象的数组。我们可以通过调用以下方式将其转换为分类：
- en: '[PRE93]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The values for `fruit_cat` are now an instance of `pandas.Categorical`, which
    you can access via the `.array` attribute:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`fruit_cat`的值是`pandas.Categorical`的一个实例，您可以通过`.array`属性访问：
- en: '[PRE94]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `Categorical` object has `categories` and `codes` attributes:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`Categorical`对象具有`categories`和`codes`属性：'
- en: '[PRE95]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: These can be accessed more easily using the `cat` accessor, which will be explained
    soon in [Categorical Methods](#pandas-categorical-methods).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`cat`访问器更轻松地访问这些，这将在[Categorical Methods](#pandas-categorical-methods)中很快解释。
- en: 'A useful trick to get a mapping between codes and categories is:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码和类别之间的映射的一个有用技巧是：
- en: '[PRE96]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can convert a DataFrame column to categorical by assigning the converted
    result:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过分配转换后的结果将DataFrame列转换为分类：
- en: '[PRE97]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can also create `pandas.Categorical` directly from other types of Python
    sequences:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接从其他类型的Python序列创建`pandas.Categorical`：
- en: '[PRE98]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If you have obtained categorical encoded data from another source, you can
    use the alternative `from_codes` constructor:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从另一个来源获得了分类编码数据，可以使用替代的`from_codes`构造函数：
- en: '[PRE99]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Unless explicitly specified, categorical conversions assume no specific ordering
    of the categories. So the `categories` array may be in a different order depending
    on the ordering of the input data. When using `from_codes` or any of the other
    constructors, you can indicate that the categories have a meaningful ordering:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 除非明确指定，分类转换假定类别没有特定的排序。因此，`categories`数组的顺序可能会根据输入数据的顺序而有所不同。在使用`from_codes`或任何其他构造函数时，您可以指示类别具有有意义的排序：
- en: '[PRE100]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output `[foo < bar < baz]` indicates that `''foo''` precedes `''bar''`
    in the ordering, and so on. An unordered categorical instance can be made ordered
    with `as_ordered`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`[foo < bar < baz]`表示`'foo'`在排序中位于`'bar'`之前，依此类推。无序的分类实例可以通过`as_ordered`变为有序：
- en: '[PRE101]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As a last note, categorical data need not be strings, even though I have shown
    only string examples. A categorical array can consist of any immutable value types.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，分类数据不一定是字符串，尽管我只展示了字符串示例。分类数组可以由任何不可变的值类型组成。
- en: Computations with Categoricals
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Categoricals进行计算
- en: Using `Categorical` in pandas compared with the nonencoded version (like an
    array of strings) generally behaves the same way. Some parts of pandas, like the
    `groupby` function, perform better when working with categoricals. There are also
    some functions that can utilize the `ordered` flag.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与非编码版本（如字符串数组）相比，在pandas中使用`Categorical`通常表现相同。在处理分类数据时，pandas的某些部分，如`groupby`函数，表现更好。还有一些函数可以利用`ordered`标志。
- en: 'Let''s consider some random numeric data and use the `pandas.qcut` binning
    function. This returns `pandas.Categorical`; we used `pandas.cut` earlier in the
    book but glossed over the details of how categoricals work:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些随机数值数据，并使用`pandas.qcut`分箱函数。这将返回`pandas.Categorical`；我们在本书的早期使用了`pandas.cut`，但忽略了分类的工作原理的细节：
- en: '[PRE102]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Let''s compute a quartile binning of this data and extract some statistics:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算一下这些数据的四分位数分箱，并提取一些统计数据：
- en: '[PRE103]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'While useful, the exact sample quartiles may be less useful for producing a
    report than quartile names. We can achieve this with the `labels` argument to
    `qcut`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有用，确切的样本四分位数可能不如四分位数名称有用于生成报告。我们可以通过`qcut`的`labels`参数实现这一点：
- en: '[PRE104]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The labeled `bins` categorical does not contain information about the bin edges
    in the data, so we can use `groupby` to extract some summary statistics:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 标记的`bins`分类不包含数据中的箱边信息，因此我们可以使用`groupby`来提取一些摘要统计信息：
- en: '[PRE105]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `''quartile''` column in the result retains the original categorical information,
    including ordering, from `bins`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的`'quartile'`列保留了来自`bins`的原始分类信息，包括排序：
- en: '[PRE106]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Better performance with categoricals
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分类数据的更好性能
- en: 'At the beginning of the section, I said that categorical types can improve
    performance and memory use, so let''s look at some examples. Consider some Series
    with 10 million elements and a small number of distinct categories:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开头，我说过分类类型可以提高性能和内存使用，所以让我们看一些例子。考虑一些具有1000万个元素和少量不同类别的Series：
- en: '[PRE107]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now we convert `labels` to categorical:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将`labels`转换为分类：
- en: '[PRE108]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now we note that `labels` uses significantly more memory than `categories`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们注意到`labels`使用的内存比`categories`要多得多：
- en: '[PRE109]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The conversion to category is not free, of course, but it is a one-time cost:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，转换为类别并不是免费的，但这是一次性的成本：
- en: '[PRE110]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'GroupBy operations can be significantly faster with categoricals because the
    underlying algorithms use the integer-based codes array instead of an array of
    strings. Here we compare the performance of `value_counts()`, which internally
    uses the GroupBy machinery:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 由于底层算法使用基于整数的代码数组而不是字符串数组，因此使用分类的GroupBy操作可以显着提高性能。这里我们比较了使用GroupBy机制的`value_counts()`的性能：
- en: '[PRE111]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Categorical Methods
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分类方法
- en: 'Series containing categorical data have several special methods similar to
    the `Series.str` specialized string methods. This also provides convenient access
    to the categories and codes. Consider the Series:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 包含分类数据的Series具有几个类似于`Series.str`专门的字符串方法的特殊方法。这也提供了方便访问类别和代码。考虑Series：
- en: '[PRE112]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The special *accessor* attribute `cat` provides access to categorical methods:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的*访问器*属性`cat`提供了对分类方法的访问：
- en: '[PRE113]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Suppose that we know the actual set of categories for this data extends beyond
    the four values observed in the data. We can use the `set_categories` method to
    change them:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道此数据的实际类别集扩展到数据中观察到的四个值之外。我们可以使用`set_categories`方法来更改它们：
- en: '[PRE114]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'While it appears that the data is unchanged, the new categories will be reflected
    in operations that use them. For example, `value_counts` respects the categories,
    if present:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据看起来没有改变，但使用它们的操作将反映新的类别。例如，如果存在，`value_counts`会尊重类别：
- en: '[PRE115]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In large datasets, categoricals are often used as a convenient tool for memory
    savings and better performance. After you filter a large DataFrame or Series,
    many of the categories may not appear in the data. To help with this, we can use
    the `remove_unused_categories` method to trim unobserved categories:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型数据集中，分类通常被用作一种方便的工具，用于节省内存和提高性能。在过滤大型DataFrame或Series之后，许多类别可能不会出现在数据中。为了帮助解决这个问题，我们可以使用`remove_unused_categories`方法来修剪未观察到的类别：
- en: '[PRE116]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: See [Table 7.7](#tbl-table_categorical_methods) for a listing of available categorical
    methods.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[表7.7](#tbl-table_categorical_methods)列出的可用分类方法。
- en: 'Table 7.7: Categorical methods for Series in pandas'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.7：pandas中Series的分类方法
- en: '| Method | Description |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add_categories` | Append new (unused) categories at end of existing categories
    |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `add_categories` | 在现有类别的末尾追加新的（未使用的）类别 |'
- en: '| `as_ordered` | Make categories ordered |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `as_ordered` | 使类别有序 |'
- en: '| `as_unordered` | Make categories unordered |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `as_unordered` | 使类别无序 |'
- en: '| `remove_categories` | Remove categories, setting any removed values to null
    |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `remove_categories` | 删除类别，将任何删除的值设置为null |'
- en: '| `remove_unused_categories` | Remove any category values that do not appear
    in the data |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `remove_unused_categories` | 删除数据中不存在的任何类别值 |'
- en: '| `rename_categories` | Replace categories with indicated set of new category
    names; cannot change the number of categories |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `rename_categories` | 用指定的新类别名称集替换类别；不能改变类别数量 |'
- en: '| `reorder_categories` | Behaves like `rename_categories`, but can also change
    the result to have ordered categories |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `reorder_categories` | 表现类似于`rename_categories`，但也可以改变结果为有序类别 |'
- en: '| `set_categories` | Replace the categories with the indicated set of new categories;
    can add or remove categories |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `set_categories` | 用指定的新类别集替换类别；可以添加或删除类别 |'
- en: Creating dummy variables for modeling
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为建模创建虚拟变量
- en: When you're using statistics or machine learning tools, you'll often transform
    categorical data into *dummy variables*, also known as *one-hot* encoding. This
    involves creating a DataFrame with a column for each distinct category; these
    columns contain 1s for occurrences of a given category and 0 otherwise.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用统计或机器学习工具时，通常会将分类数据转换为*虚拟变量*，也称为*独热*编码。这涉及创建一个DataFrame，其中每个不同的类别都有一列；这些列包含给定类别的出现为1，否则为0。
- en: 'Consider the previous example:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的例子：
- en: '[PRE117]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'As mentioned previously in this chapter, the `pandas.get_dummies` function
    converts this one-dimensional categorical data into a DataFrame containing the
    dummy variable:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，`pandas.get_dummies`函数将这个一维分类数据转换为包含虚拟变量的DataFrame：
- en: '[PRE118]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 7.6 Conclusion
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 结论
- en: Effective data preparation can significantly improve productivity by enabling
    you to spend more time analyzing data and less time getting it ready for analysis.
    We have explored a number of tools in this chapter, but the coverage here is by
    no means comprehensive. In the next chapter, we will explore pandas's joining
    and grouping functionality.******
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的数据准备可以通过使您花更多时间分析数据而不是准备分析数据来显着提高生产率。本章中我们探讨了许多工具，但这里的覆盖范围并不全面。在下一章中，我们将探讨pandas的连接和分组功能。******
