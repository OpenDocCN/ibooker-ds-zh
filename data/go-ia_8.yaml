- en: Chapter 9\. Testing and benchmarking
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章\. 测试和基准测试
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章内容*'
- en: Writing unit tests to validate your code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试以验证你的代码
- en: Mocking HTTP-based requests and responses using httptest
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 httptest 模拟基于 HTTP 的请求和响应
- en: Documenting your packages with example code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例代码记录你的包
- en: Examining performance with benchmarks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基准测试检查性能
- en: Testing your code is not something that you should wait to do until after you’re
    finished developing your program. With Go’s testing framework, unit testing and
    benchmarking can happen during the development process. Just like the `go build`
    command, there’s a `go test` command to execute explicit test code that you write.
    All you need to do is follow a few guidelines, and you can integrate tests into
    your project and continuous integration systems seamlessly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的代码不是一件你应该等到程序开发完成后才去做的事情。使用 Go 的测试框架，单元测试和基准测试可以在开发过程中进行。就像 `go build` 命令一样，有一个
    `go test` 命令可以执行你编写的显式测试代码。你只需要遵循一些指南，就可以无缝地将测试集成到你的项目和持续集成系统中。
- en: 9.1\. Unit testing
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 单元测试
- en: A *unit test* is a function that tests a specific piece or set of code from
    a package or program. The job of the test is to determine whether the code in
    question is working as expected for a given scenario. One scenario may be a positive-path
    test, where the test is making sure the normal execution of the code doesn’t produce
    an error. This could be a test that validates that the code can insert a job record
    into the database successfully.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试* 是一个测试包或程序中特定代码片段或代码集的函数。测试的任务是确定针对给定场景，所讨论的代码是否按预期工作。一个场景可能是一个正向测试，测试确保代码的正常执行不会产生错误。这可能是一个验证代码能否成功将工作记录插入数据库的测试。'
- en: Other unit tests may test negative-path scenarios to make sure the code produces
    not only an error, but the expected one. This could be a test that makes a query
    against a database where no results are found, or performs an invalid update against
    a database. In both cases, the test would validate that the error is reported
    and the correct error context is provided. In the end, the code you write must
    be predictable no matter how it’s called or executed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其他单元测试可能测试负向路径场景，以确保代码不仅产生错误，而且产生预期的错误。这可能是一个对数据库进行查询但没有找到结果的测试，或者对数据库执行无效更新的测试。在两种情况下，测试都会验证错误被报告，并且提供了正确的错误上下文。最终，你编写的代码必须无论以何种方式调用或执行都是可预测的。
- en: There are several ways in Go to write unit tests. *Basic tests* test a specific
    piece of code for a single set of parameters and result. *Table tests* also test
    a specific piece of code, but the test validates itself against multiple parameters
    and results. There are also ways to mock external resources that the test code
    needs, such as databases or web servers. This helps to simulate the existence
    of these resources during testing without the need for them to be available. Finally,
    when building your own web services, there are ways to test calls coming in to
    the service without ever needing to run the service itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中有几种方法可以编写单元测试。*基本测试* 测试单个参数集和结果的一块特定代码。*表格测试* 也测试特定的代码，但测试会针对多个参数和结果进行验证。还有方法可以模拟测试代码所需的外部资源，例如数据库或网络服务器。这有助于在测试期间模拟这些资源的存在，而无需它们实际可用。最后，当你构建自己的网络服务时，有方法可以测试传入服务的调用，而无需实际运行服务本身。
- en: 9.1.1\. Basic unit test
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 基本单元测试
- en: Let’s start with an example of a unit test.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单元测试的一个例子开始。
- en: Listing 9.1\. listing01_test.go
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. listing01_test.go
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Listing 9.1](#ch09ex01) shows a unit test that’s testing the `Get` function
    from the `http` package. It’s testing that the goinggo.net RSS feed can be downloaded
    properly from the web. When we run this test by calling `go test -v`, where `-v`
    means *provide verbose output*, we get the test results shown in [figure 9.1](#ch09fig01).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.1](#ch09ex01) 展示了一个测试 `http` 包中 `Get` 函数的单元测试。它测试 goinggo.net RSS 提要是否可以从网络上正确下载。当我们通过调用
    `go test -v` 运行此测试时（`-v` 表示 *提供详细输出*），我们得到如图 9.1 所示的测试结果。[图 9.1](#ch09fig01)。'
- en: Figure 9.1\. Output from the basic unit test
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 基本单元测试的输出
- en: '![](09fig01_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01_alt.jpg)'
- en: A lot of little things are happening in this example to make this test work
    and display the results as it does. It all starts with the name of the test file.
    If you look at the top of [listing 9.1](#ch09ex01), you’ll see that the name of
    the test file is listing01_test.go. The Go testing tool will only look at files
    that end in _test.go. If you forget to follow this convention, running `go test`
    inside of a package may report that there are no test files. Once the testing
    tool finds a testing file, it then looks for testing functions to run.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有很多小事情发生，使得这个测试能够正常工作并显示结果。这一切都始于测试文件的名字。如果你查看[列表9.1](#ch09ex01)的顶部，你会看到测试文件的名字是listing01_test.go。Go测试工具只会查看以_test.go结尾的文件。如果你忘记遵循这个约定，在包内部运行`go
    test`可能会报告没有测试文件。一旦测试工具找到一个测试文件，它就会寻找要运行的测试函数。
- en: Let’s take a closer look at the code in the listing01_test.go test file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看listing01_test.go测试文件中的代码。
- en: 'Listing 9.2\. listing01_test.go: lines 01–10'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表9.2\. listing01_test.go: 第01-10行'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In [listing 9.2](#ch09ex02), you can see the import of the `testing` package
    on line 06\. The `testing` package provides the support we need from the testing
    framework to report the output and status of any test. Lines 09 and 10 provide
    two constants that contain the characters for the check mark and X mark that will
    be used when writing test output.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表9.2](#ch09ex02)中，你可以看到第06行对`testing`包的导入。`testing`包提供了测试框架所需的从测试框架中报告任何测试输出和状态的支持。第09行和第10行提供了两个常量，这些常量包含在编写测试输出时将使用的勾号和X号字符。
- en: Next, let’s look at the declaration of the test function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看测试函数的声明。
- en: 'Listing 9.3\. listing01_test.go: lines 12–13'
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表9.3\. listing01_test.go: 第12-13行'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The name of the test function is `TestDownload`, and you can see it on line
    13 in [listing 9.3](#ch09ex03). A test function must be an exported function that
    begins with the word `Test`. Not only must the function start with the word `Test`,
    it must have a signature that accepts a pointer of type `testing.T` and returns
    no value. If we don’t follow these conventions, the testing framework won’t recognize
    the function as a test function and none of the tooling will work against it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数的名字是`TestDownload`，你可以在[列表9.3](#ch09ex03)的第13行看到。一个测试函数必须是一个导出函数，以单词`Test`开头。不仅函数必须以单词`Test`开头，它还必须有一个接受`testing.T`类型指针且不返回任何值的签名。如果我们不遵循这些约定，测试框架将不会识别该函数为测试函数，并且所有工具都不会针对它工作。
- en: The pointer of type `testing.T` is important. It provides the mechanism for
    reporting the output and status of each test. There’s no one standard for formatting
    the output of your tests. I like the test output to read well, which does follow
    the Go idioms for writing documentation. For me, the testing output is documentation
    for the code. The test output should document why the test exists, what’s being
    tested, and the result of the test in clear complete sentences that are easy to
    read. Let’s see how I accomplish this as we review more of the code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing.T` 类型的指针非常重要。它提供了报告每个测试输出和状态机制。对于测试输出的格式化并没有一个统一的标准。我喜欢测试输出读起来清晰，这符合Go编写文档的惯例。对我来说，测试输出就是代码的文档。测试输出应该清晰地说明测试存在的原因、正在测试的内容以及测试的结果，使用易于阅读的完整句子。随着我们进一步审查代码，让我们看看我是如何实现这一点的。'
- en: 'Listing 9.4\. listing01_test.go: lines 14–18'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表9.4\. listing01_test.go: 第14-18行'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You see on lines 14 and 15 in [listing 9.4](#ch09ex04) that two variables are
    declared and initialized. These variables contain the URL we want to test and
    the status we expect back from the response. On line 17 the `t.Log` method is
    used to write a message to the test output. There’s also a format version of this
    method called `t.Logf`. If the verbose option (`-v`) isn’t used when calling `go
    test`, we won’t see any test output unless the test fails.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[列表9.4](#ch09ex04)的第14行和第15行看到，声明并初始化了两个变量。这些变量包含我们想要测试的URL和从响应中期望得到的状态。在第17行，使用`t.Log`方法将消息写入测试输出。还有一个这个方法的格式化版本，称为`t.Logf`。如果在调用`go
    test`时没有使用详细选项（`-v`），除非测试失败，否则我们不会看到任何测试输出。
- en: Each test function should state why the test exists by explaining the *given
    need* of the test. For this test, the given need is to test downloading content.
    After declaring the given need of the test, the test should then state *when*
    the code being tested would execute, and how.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试函数都应该通过解释测试的*给定需求*来说明测试存在的原因。对于这个测试，给定的需求是测试下载内容。在声明测试的给定需求之后，测试应该说明被测试的代码将在*何时*执行以及如何执行。
- en: 'Listing 9.5\. listing01_test.go: lines 19–21'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表9.5\. listing01_test.go: 第19-21行'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You see the `when` clause on line 19 in [listing 9.5](#ch09ex05). It states
    specifically the values for the test. Next, let’s look at the code being tested
    using these values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [清单 9.5](#ch09ex05) 的第 19 行看到 `when` 子句。它具体说明了测试的值。接下来，让我们看看使用这些值进行测试的代码。
- en: 'Listing 9.6\. listing01_test.go: lines 22–30'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '清单 9.6\. listing01_test.go: 行 22–30'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code in [listing 9.6](#ch09ex06) uses the `Get` function from the `http`
    package to make a request to the goinggo.net web server to pull down the RSS feed
    file for the blog. After the `Get` call returns, the error value is checked to
    see if the call was successful or not. In either case, we state what the result
    of the test *should* be. If the call failed, we write an *X* as well to the test
    output along with the error. If the test succeeded, we write a check mark.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9.6](#ch09ex06) 中的代码使用了 `http` 包中的 `Get` 函数向 goinggo.net 网络服务器发起请求，以获取博客的
    RSS 源文件。在 `Get` 调用返回后，会检查错误值以确定调用是否成功。在两种情况下，我们都声明测试的结果应该是怎样的。如果调用失败，我们会在测试输出中写入一个
    *X* 以及错误信息。如果测试成功，我们会写入一个勾号。'
- en: If the call to `Get` does fail, the use of the `t.Fatal` method on line 24 lets
    the testing framework know this unit test has failed. The `t.Fatal` method not
    only reports the unit test has failed, but also writes a message to the test output
    and then stops the execution of this particular test function. If there are other
    test functions that haven’t run yet, they’ll be executed. A formatted version
    of this method is named `t.Fatalf`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Get` 调用失败，第 24 行的 `t.Fatal` 方法会让测试框架知道这个单元测试失败了。`t.Fatal` 方法不仅报告单元测试失败，还会将消息写入测试输出，然后停止执行这个特定的测试函数。如果有其他尚未运行的测试函数，它们将会被执行。这个方法的格式化版本被命名为
    `t.Fatalf`。
- en: When we need to report the test has failed but don’t want to stop the execution
    of the particular test function, we can use the `t.Error` family of methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要报告测试失败但不希望停止特定测试函数的执行时，我们可以使用 `t.Error` 方法族。
- en: 'Listing 9.7\. listing01_test.go: lines 32–41'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '清单 9.7\. listing01_test.go: 行 32–41'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One line 32 in [listing 9.7](#ch09ex07), the status code from the response is
    compared with the status code we expect to receive. Again, we state what the result
    of the test should be. If the status codes match, then we use the `t.Logf` method;
    otherwise, we use the `t.Errorf` method. Since the `t.Errorf` method doesn’t stop
    the execution of the test function, if there were more tests to conduct after
    line 38, the unit test would continue to be executed. If the `t.Fatal` or `t.Error`
    functions aren’t called by a test function, the test will be considered as passing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 9.7](#ch09ex07) 的第 32 行，我们将响应中的状态码与我们期望接收的状态码进行比较。同样，我们声明测试的结果应该是怎样的。如果状态码匹配，我们使用
    `t.Logf` 方法；否则，我们使用 `t.Errorf` 方法。由于 `t.Errorf` 方法不会停止测试函数的执行，如果第 38 行之后还有更多测试要进行，单元测试将继续执行。如果一个测试函数没有调用
    `t.Fatal` 或 `t.Error` 函数，则测试将被视为通过。
- en: If you look at the output of the test one more time (see [figure 9.2](#ch09fig02)),
    you can see how it all comes together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看测试输出（见 [图 9.2](#ch09fig02)），你可以看到所有这些是如何结合在一起的。
- en: Figure 9.2\. Output from the basic unit test
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. 基本单元测试的输出
- en: '![](09fig02_alt.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig02_alt.jpg)'
- en: 'In [figure 9.2](#ch09fig02) you see the complete documentation for the test.
    Given the need to download content, when checking the URL for the `statusCode`
    (which is cut off in the figure), we should be able to make the call and should
    receive a status of 200\. The testing output is clear, descriptive, and informative.
    We know what unit test was run, that it passed, and how long it took: 435 milliseconds.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9.2](#ch09fig02) 中，你可以看到测试的完整文档。考虑到需要下载内容，当检查 `statusCode` 的 URL（在图中被截断）时，我们应该能够发起调用并收到状态码
    200。测试输出清晰、描述性强、信息丰富。我们知道运行了哪个单元测试，它通过了，以及它花费了多长时间：435 毫秒。
- en: 9.1.2\. Table tests
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 表格测试
- en: When you’re testing code that can accept a set of different parameters with
    different results, a table test should be used. A *table test* is like a basic
    unit test except it maintains a table of different values and results. The different
    values are iterated over and run through the test code. With each iteration, the
    results are checked. This helps to leverage a single test function to test a set
    of different values and conditions. Let’s look at an example table test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试可以接受一组不同参数并产生不同结果的代码时，应使用表格测试。*表格测试*类似于基本单元测试，但它维护一个不同值和结果的表格。不同的值会被迭代并运行通过测试代码。在每次迭代中，都会检查结果。这有助于利用单个测试函数来测试一组不同的值和条件。让我们看看一个示例表格测试。
- en: Listing 9.8\. listing08_test.go
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. listing08_test.go
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In [listing 9.8](#ch09ex08), we’ve taken the basic unit test and converted it
    to a table test. Now we can use a single test function to test different URLs
    and status codes against the `http.Get` function. We don’t need to create a new
    test function for each URL and status code we want to test. Let’s look at the
    changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.8](#ch09ex08) 中，我们将基本的单元测试转换为表格测试。现在我们可以使用单个测试函数来测试不同的 URL 和状态码与 `http.Get`
    函数。我们不需要为每个要测试的 URL 和状态码创建一个新的测试函数。让我们看看这些更改。
- en: 'Listing 9.9\. listing08_test.go: lines 12–27'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.9\. listing08_test.go: 行 12–27'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In [listing 9.9](#ch09ex09) you see the same test function, `TestDownload`,
    accepting a pointer of type `testing.T`. But this version of `TestDownload` is
    slightly different. On lines 15 through 27, you see the implementation of the
    table. The first field of the table is a URL to a given resource on the internet,
    and the second field is the status we expect to receive when we make the request
    for the resource.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.9](#ch09ex09) 中，你可以看到相同的测试函数 `TestDownload` 接受一个 `testing.T` 类型的指针。但这个版本的
    `TestDownload` 略有不同。在第 15 到 27 行，你可以看到表的实现。表的第一列是一个指向互联网上给定资源的 URL，第二列是我们请求资源时预期的状态。
- en: Currently, we’ve configured the table with two values. The first value is the
    goinggo.net URL with a status of OK, and the second value is a different URL with
    a status of NotFound. The second URL has been misspelled to cause the server to
    return a NotFound error. When we run this test, we get the test output shown in
    [figure 9.3](#ch09fig03).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经用两个值配置了表。第一个值是 goinggo.net URL，状态为 OK，第二个值是另一个 URL，状态为 NotFound。第二个 URL
    被拼写错误，导致服务器返回 NotFound 错误。当我们运行这个测试时，我们得到如图 9.3 所示的测试输出。
- en: Figure 9.3\. Output from the table test
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. 表格测试的输出
- en: '![](09fig03_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03_alt.jpg)'
- en: The output in [figure 9.3](#ch09fig03) shows how the table of values is iterated
    over and used to conduct the test. The output looks the same as the basic unit
    test except we tested two different URLs this time. Once again, the test passes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 中的输出显示了如何遍历值表并使用它来进行测试。输出看起来与基本单元测试相同，除了这次我们测试了两个不同的 URL。再次，测试通过。
- en: Let’s look at the changes we made to make the table test work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们为了使表测试工作所做出的更改。
- en: 'Listing 9.10\. listing08_test.go: lines 29–34'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.10\. listing08_test.go: 行 29–34'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `for range` loop on line 31 in [listing 9.10](#ch09ex10) allows the test
    to iterate over the table and run the test code for each different URL. The original
    code from the basic unit test is the same except for the use of the table values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.10](#ch09ex10) 中的第 31 行的 `for range` 循环允许测试遍历表，并为每个不同的 URL 运行测试代码。除了使用表值之外，原始代码与基本单元测试相同。'
- en: 'Listing 9.11\. listing08_test.go: lines 35–55'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.11\. listing08_test.go: 行 35–55'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Listing 9.11](#ch09ex11) shows how, on line 35, the code uses the `u.url`
    field for the URL to call. On line 45 the `u.statusCode` field is used to compare
    the actual status code from the response. In the future, new URLs and status codes
    can be added to the table and the core of the test doesn’t need to change.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.11](#ch09ex11) 展示了在第 35 行，代码使用 `u.url` 字段作为调用 URL。在第 45 行，使用 `u.statusCode`
    字段来比较响应的实际状态码。在未来，可以添加新的 URL 和状态码到表中，而测试的核心部分不需要改变。'
- en: 9.1.3\. Mocking calls
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 模拟调用
- en: The unit tests we wrote are great, but they do have a couple of flaws. First,
    they require access to the internet in order for the tests to run successfully.
    [Figure 9.4](#ch09fig04) shows what happens when we run the basic unit test again
    without an internet connection—the test fails.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的单元测试很棒，但它们确实有几个缺陷。首先，测试要成功运行需要访问互联网。[图 9.4](#ch09fig04) 显示了在没有互联网连接的情况下再次运行基本单元测试的情况——测试失败。
- en: Figure 9.4\. Failed test due to having no internet connection
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 由于没有互联网连接而失败的测试
- en: '![](09fig04_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04_alt.jpg)'
- en: You shouldn’t always assume the computer you have to run tests on can access
    the internet. Also, it’s not good practice to have tests depend on servers that
    you don’t own or operate. Both of these things can have a great impact on any
    automation you put into place for continuous integration and deployment. Suddenly
    you can’t deploy a new build because you lost your access to the outside world.
    If the tests fail, you can’t deploy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该总是假设你运行测试的计算机可以访问互联网。此外，让测试依赖于你不在拥有或运营的服务器并不是一个好的做法。这两者都可能对任何自动化持续集成和部署产生重大影响。突然之间，你无法部署新的构建，因为你失去了对外部世界的访问。如果测试失败，你无法部署。
- en: To fix this situation, the standard library has a package called `httptest`
    that will let you mock HTTP-based web calls. Mocking is a technique many developers
    use to simulate access to resources that won’t be available when tests are run.
    The `httptest` package provides you with the ability to mock requests and responses
    from web resources on the internet. By mocking the `http.Get` response in our
    unit test, we can solve the problem we saw in [figure 9.4](#ch09fig04). No longer
    will our test fail because we don’t have an internet connection. Yet the test
    can validate that our `http.Get` call works and handles the expected response.
    Let’s take the basic unit test and change it to mock a call to the goinggo.net
    RSS feed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，标准库中有一个名为 `httptest` 的包，它将允许你模拟基于 HTTP 的网络调用。模拟是许多开发者在测试运行时无法访问资源时使用的技巧。`httptest`
    包为你提供了模拟来自互联网上网络资源的请求和响应的能力。通过在我们的单元测试中模拟 `http.Get` 响应，我们可以解决我们在 [图 9.4](#ch09fig04)
    中看到的问题。我们的测试将不再因为缺少互联网连接而失败。然而，测试可以验证我们的 `http.Get` 调用是否正常工作并处理预期的响应。让我们将基本单元测试修改为模拟对
    goinggo.net RSS 源的调用。
- en: 'Listing 9.12\. listing12_test.go: lines 01–41'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.12\. listing12_test.go: 第 01-41 行'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Listing 9.12](#ch09ex12) shows how we can mock a call to the goinggo.net website
    to simulate the downloading of the RSS feed. On line 17 a package-level variable
    named `feed` is declared and initialized with a literal string that represents
    the RSS XML document we’ll receive from our mock server call. It’s a small snippet
    of the actual RSS feed document and is enough to conduct our test. On line 32
    we have the declaration of a function named `mockServer` that leverages the support
    inside the `httptest` package to simulate a call to a real server on the internet.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.12](#ch09ex12) 展示了如何模拟对 goinggo.net 网站的调用以模拟下载 RSS 源。在第 17 行，声明了一个包级别的变量
    `feed`，并用一个表示我们将从模拟服务器调用中接收的 RSS XML 文档的文本字符串初始化。这是实际 RSS 源文档的一个小片段，足以进行我们的测试。在第
    32 行，我们声明了一个名为 `mockServer` 的函数，该函数利用 `httptest` 包内部的支持来模拟对互联网上真实服务器的调用。'
- en: 'Listing 9.13\. listing12_test.go: lines 32–40'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.13\. listing12_test.go: 第 32-40 行'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `mockServer` function in [listing 9.13](#ch09ex13) is declared to return
    a pointer of type `httptest.Server`. The `httptest.Server` value is the key to
    making all of this work. The code starts out with declaring an anonymous function
    that has the same signature as the `http.HandlerFunc` function type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.13](#ch09ex13) 中的 `mockServer` 函数被声明为返回 `httptest.Server` 类型的指针。`httptest.Server`
    值是使所有这些工作起来的关键。代码从声明一个与 `http.HandlerFunc` 函数类型具有相同签名的匿名函数开始。
- en: Listing 9.14\. golang.org/pkg/net/http/#HandlerFunc
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. golang.org/pkg/net/http/#HandlerFunc
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes the anonymous function a handler function. Once the handler function
    is declared, then on line 39 it’s used as a parameter for the `httptest.NewServer`
    function call to create our mock server. Then the mock server is returned via
    a pointer on line 39.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得匿名函数成为一个处理函数。一旦声明了处理函数，然后在第 39 行，它被用作 `httptest.NewServer` 函数调用的参数来创建我们的模拟服务器。然后，模拟服务器通过第
    39 行的指针返回。
- en: We’ll be able to use this mock server with our `http.Get` call to simulate hitting
    the goinggo.net web server. When the `http.Get` call is made, the handler function
    is actually executed and used to mock the request and response. On line 34 the
    handler function first sets the status code; then, on line 35, the content type
    is set; and finally, on line 36, the XML string named `feed` that represents the
    response is returned as the response body.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够使用这个模拟服务器与我们的 `http.Get` 调用来模拟对 goinggo.net 网服务器的访问。当执行 `http.Get` 调用，处理函数实际上被执行并用于模拟请求和响应。在第
    34 行，处理函数首先设置状态码；然后，在第 35 行，设置内容类型；最后，在第 36 行，返回代表响应的名为 `feed` 的 XML 字符串作为响应体。
- en: Now, let’s look at how the mock server is integrated into the basic unit test
    and how the `http.Get` call is able to use it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将模拟服务器集成到基本单元测试中，以及 `http.Get` 调用如何能够使用它。
- en: 'Listing 9.15\. listing12_test.go: lines 43–74'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.15\. listing12_test.go: 第 43-74 行'
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In [listing 9.15](#ch09ex15) you see the `TestDownload` function once more,
    but this time it’s using the mock server. On lines 48 and 49 a call to the `mockServer`
    function is made, and a call to the `Close` method is deferred for when the test
    function returns. After that, the test code looks identical to the basic unit
    test except for one thing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.15](#ch09ex15) 中，你再次看到了 `TestDownload` 函数，但这次它使用的是模拟服务器。在第 48 和 49 行，调用了
    `mockServer` 函数，并且将 `Close` 方法的调用推迟到测试函数返回时。之后，测试代码看起来与基本单元测试相同，除了有一点不同。
- en: 'Listing 9.16\. listing12_test.go: line 56'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表9.16\. listing12_test.go: 第56行'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time the URL to call is provided to by the `httptest.Server` value. When
    we use the URL provided by the mocking server, the `http.Get` call runs as expected.
    The `http.Get` call has no idea it’s not making a call over the internet. The
    call is made and our handler function is executed underneath, resulting in a response
    of our RSS XML document and a status of `http.StatusOK`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，调用要使用的URL由`httptest.Server`值提供。当我们使用模拟服务器提供的URL时，`http.Get`调用按预期运行。`http.Get`调用不知道它没有通过互联网进行调用。调用被发起，我们的处理函数在下面执行，结果返回我们的RSS
    XML文档和一个状态为`http.StatusOK`的响应。
- en: When we run the test now without an internet connection, we see the test runs
    and passes, as shown in [figure 9.5](#ch09fig05). This figure shows how the test
    is passing again. If you look at the URL used to make the call, you can see it’s
    using the localhost address with port number 52065\. That port number will change
    every time we run the test. The `http` package, in conjunction with the `httptest`
    package and our mock server, knows to route that URL to our handler function.
    Now, we can test our calls to the goinggo.net RSS feed without ever hitting the
    actual server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在没有互联网连接的情况下运行测试时，我们看到测试运行并通过，如图9.5所示。这张图显示了测试再次通过的情况。如果你查看用于发起调用的URL，你可以看到它使用的是localhost地址和端口号52065。每次我们运行测试时，这个端口号都会改变。`http`包与`httptest`包以及我们的模拟服务器一起知道将这个URL路由到我们的处理函数。现在，我们可以测试对goinggo.net
    RSS源头的调用，而无需实际击中服务器。
- en: Figure 9.5\. Successful test without having an internet connection
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. 无需互联网连接的成功测试
- en: '![](09fig05_alt.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig05_alt.jpg)'
- en: 9.1.4\. Testing endpoints
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4\. 测试端点
- en: If you’re building a web API, you’ll want to test all of your endpoints without
    the need to start the web service. The `httptest` package provides a facility
    for doing just this. Let’s take a look at a sample web service that implements
    a single endpoint, and then you can see how to write a unit test that mocks an
    actual call.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个网络API，你将希望测试所有端点，而无需启动网络服务。`httptest`包提供了一种进行此类测试的设施。让我们看看一个实现单个端点的示例网络服务，然后你可以看到如何编写一个模拟实际调用的单元测试。
- en: Listing 9.17\. listing17.go
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.17\. listing17.go
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Listing 9.17](#ch09ex17) shows the code file for the entry point of the web
    service. Inside the `main` function on line 13, the code calls the `Routes` function
    from the internal `handlers` package. This function sets up the routes for the
    different endpoints the web service is hosting. On lines 15 and 16 the `main`
    function displays the port the service is listening on and starts the web service,
    waiting for requests.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.17](#ch09ex17)显示了网络服务入口点的代码文件。在`main`函数的第13行，代码调用了`handlers`包内部的`Routes`函数。该函数设置了网络服务所托管的不同端点的路由。在第15行和第16行，`main`函数显示了服务正在监听的端口，并启动了网络服务，等待请求。'
- en: Now, let’s look at the code for the `handlers` package.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`handlers`包的代码。
- en: Listing 9.18\. `handlers`/handlers.go
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.18\. `handlers`/handlers.go
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code for the `handlers` package in [listing 9.18](#ch09ex18) provides the
    implementation of the handler function and sets up the routes for the web service.
    On line 10 you see the `Routes` function, which uses the default `http.ServeMux`
    from inside the `http` package to configure the routing between the URLs and the
    corresponding handler code. On line 11 we bind the `/sendjson` endpoint to the
    `SendJSON` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.18](#ch09ex18)中`handlers`包的代码提供了处理函数的实现，并为网络服务设置了路由。在第10行，你可以看到`Routes`函数，它使用`http`包内部的默认`http.ServeMux`来配置URL和相应处理代码之间的路由。在第11行，我们将`/sendjson`端点绑定到`SendJSON`函数。'
- en: Starting on line 15, we have the implementation of the `SendJSON` function.
    The function has the same signature as the `http.HandlerFunc` function type that
    you saw in [listing 9.14](#ch09ex14). On line 16 an anonymous struct type is declared,
    and a variable named `u` is created with some values. On lines 24 and 25 the content
    type and status code for the response is set. Finally, on line 26 the `u` value
    is encoded into a JSON document and sent back to the client.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从第15行开始，我们有`SendJSON`函数的实现。该函数与你在[列表9.14](#ch09ex14)中看到的`http.HandlerFunc`函数类型具有相同的签名。在第16行，声明了一个匿名结构体类型，并创建了一个名为`u`的变量，并赋予了一些值。在第24行和第25行设置了响应的内容类型和状态码。最后，在第26行，将`u`值编码成JSON文档并发送给客户端。
- en: If we build the web service and start the server, we see the JSON document served
    up, as in [figures 9.6](#ch09fig06) and [9.7](#ch09fig07).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建Web服务并启动服务器，我们会看到提供的JSON文档，如[图 9.6](#ch09fig06)和[9.7](#ch09fig07)所示。
- en: Figure 9.6\. Running the web service
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.6\. 运行Web服务
- en: '![](09fig06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig06.jpg)'
- en: Figure 9.7\. Web service serving up the JSON document
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.7\. 提供JSON文档的Web服务
- en: '![](09fig07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig07.jpg)'
- en: Now that we have a functioning web service with an endpoint, we can write a
    unit test to test the endpoint.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个具有端点的功能齐全的Web服务，我们可以编写一个单元测试来测试该端点。
- en: Listing 9.19\. `handlers`/handlers_test.go
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.19\. `handlers`/handlers_test.go
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Listing 9.19](#ch09ex19) shows a unit test for the `/sendjson` endpoint. On
    line 03 you see the name of the package is different from the other tests.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.19](#ch09ex19) 展示了 `/sendjson` 端点的单元测试。在第 03 行，你可以看到包名与其他测试不同。'
- en: 'Listing 9.20\. `handlers`/handlers_test.go: lines 01–03'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.20\. `handlers`/handlers_test.go: 行 01–03'
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, as you can see in [listing 9.20](#ch09ex20), the package name also
    ends with `_test`. When the package name ends like this, the test code can only
    access exported identifiers. This is true even if the test code file is in the
    same folder as the code being tested.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，正如你在[列表 9.20](#ch09ex20)中可以看到，包名也以 `_test` 结尾。当包名以这种方式结束时，测试代码只能访问导出的标识符。即使测试代码文件与被测试的代码在同一文件夹中，这也是正确的。
- en: Just like when running the service directly, the routes need to be initialized.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就像直接运行服务一样，路由需要初始化。
- en: 'Listing 9.21\. `handlers`/handlers_test.go: lines 17–19'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.21\. `handlers`/handlers_test.go: 行 17–19'
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On line 17 in [listing 9.21](#ch09ex21), an `init` function is declared to initialize
    the routes. If the routes aren’t initialized before the unit tests are run, then
    the tests will fail with an `http.StatusNotFound` error. Now we can look at the
    unit test for the `/sendjson` endpoint.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 9.21](#ch09ex21)的第 17 行，声明了一个 `init` 函数来初始化路由。如果在运行单元测试之前没有初始化路由，那么测试将因
    `http.StatusNotFound` 错误而失败。现在我们可以查看 `/sendjson` 端点的单元测试。
- en: 'Listing 9.22\. `handlers`/handlers_test.go: lines 21–34'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.22\. `handlers`/handlers_test.go: 行 21–34'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Listing 9.22](#ch09ex22) shows the declaration of the `TestSendJSON` test
    function. The test starts off logging the given need of the test, and then on
    line 25 it creates an `http.Request` value. The request value is configured to
    be a `GET` call against the `/sendjson` endpoint. Since this is a `GET` call,
    `nil` is passed as the third parameter for the post data.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.22](#ch09ex22) 展示了 `TestSendJSON` 测试函数的声明。测试开始时记录测试的给定需求，然后在第 25 行创建了一个
    `http.Request` 值。请求值被配置为对 `/sendjson` 端点的 `GET` 调用。由于这是一个 `GET` 调用，所以将 `nil` 作为第三个参数传递给请求数据。'
- en: Then, on line 33, the `httptest.NewRecorder` function is called to create an
    `http.ResponseRecorder` value. With the `http.Request` and `http.ResponseRecorder`
    values, a call to the `ServerHTTP` method against the default server multiplexer
    (mux) is made on line 34\. Calling this method mocks a request to our `/sendjson`
    endpoint as if it were being made from an external client.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第 33 行，调用 `httptest.NewRecorder` 函数创建了一个 `http.ResponseRecorder` 值。有了 `http.Request`
    和 `http.ResponseRecorder` 值，在第 34 行对默认服务器多路复用器（mux）的 `ServerHTTP` 方法进行了调用。调用此方法模拟了一个对
    `/sendjson` 端点的请求，就像它是由外部客户端发起的一样。
- en: Once the `ServeHTTP` method call completes, the `http.ResponseRecorder` value
    contains the response from our `SendJSON` function handler. Now we can test the
    response.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `ServeHTTP` 方法调用完成，`http.ResponseRecorder` 值将包含来自我们的 `SendJSON` 函数处理器的响应。现在我们可以测试响应。
- en: 'Listing 9.23\. `handlers`/handlers_test.go: lines 36–39'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.23\. `handlers`/handlers_test.go: 行 36–39'
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, the status of the response is checked on line 36\. With any successful
    endpoint call, a status of 200 is expected. If the status is 200, then the JSON
    response is decoded into a Go value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在第 36 行检查响应的状态。对于任何成功的端点调用，期望状态为 200。如果状态是 200，则将JSON响应解码到Go值中。
- en: 'Listing 9.24\. `handlers`/handlers_test.go: lines 41–49'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.24\. `handlers`/handlers_test.go: 行 41–49'
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On line 41 in [listing 9.24](#ch09ex24), an anonymous struct type is declared,
    and a variable named `u` is created and initialized to its zero value. On line
    46 the `json` package is used to decode the JSON document from the response into
    the `u` variable. If the decode fails, the unit test is ended; otherwise, we validate
    the values that were decoded.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 9.24](#ch09ex24)的第 41 行，声明了一个匿名结构体类型，并创建了一个名为 `u` 的变量，并将其初始化为其零值。在第 46
    行，使用 `json` 包将响应中的JSON文档解码到 `u` 变量中。如果解码失败，单元测试将结束；否则，我们验证解码的值。
- en: 'Listing 9.25\. `handlers`/handlers_test.go: lines 51–63'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.25\. `handlers`/handlers_test.go: 行 51–63'
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Listing 9.25](#ch09ex25) shows both checks for each value we expect to receive.
    On line 51 we check that the value of the `Name` field is `"Bill"`, and then on
    line 57 the value of the `Email` field is checked for `"bill@ardanstudios.com"`.
    If these values match, then the unit test passes; otherwise, the unit test fails.
    These two checks use the `Error` method to report failure, so all the fields are
    checked.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.25](#ch09ex25) 展示了对我们期望接收的每个值的检查。在第 51 行，我们检查 `Name` 字段的值为 `"Bill"`，然后在第
    57 行检查 `Email` 字段的值为 `"bill@ardanstudios.com"`。如果这些值匹配，则单元测试通过；否则，单元测试失败。这两个检查使用
    `Error` 方法来报告失败，因此检查了所有字段。'
- en: 9.2\. Examples
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 示例
- en: Go is very focused on having proper documentation for the code you write. The
    *godoc* tool was built to produce documentation directly from your code. In [chapter
    3](kindle_split_011.html#ch03) we talked about the use of the `godoc` tool to
    produce package documentation. Another feature of the `godoc` tool is example
    code. Example code adds another dimension to both testing and documentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go 非常注重编写代码的正确文档。`godoc` 工具就是为了直接从你的代码中生成文档而构建的。在[第 3 章](kindle_split_011.html#ch03)中，我们讨论了使用
    `godoc` 工具生成包文档的使用。`godoc` 工具的另一个特性是示例代码。示例代码为测试和文档增加了另一个维度。
- en: If you use your browser to navigate to the Go documentation for the `json` package,
    you’ll see something like [figure 9.8](#ch09fig08).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用浏览器导航到 Go 的 `json` 包文档，你会看到类似[图 9.8](#ch09fig08)的内容。
- en: Figure 9.8\. Listing of examples for the `json` package
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.8\. `json` 包的示例列表
- en: '![](09fig08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig08.jpg)'
- en: The `json` package has five examples, and they show in the Go documentation
    for the package. If you select the first example, you see a view of the example
    code, as in [figure 9.9](#ch09fig09).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`json` 包有五个示例，它们显示在包的 Go 文档中。如果你选择第一个示例，你会看到一个示例代码的视图，如[图 9.9](#ch09fig09)所示。'
- en: Figure 9.9\. A view of the `Decoder` example in the Go documentation
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.9\. Go 文档中 `Decoder` 示例的视图
- en: '![](09fig09_alt.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig09_alt.jpg)'
- en: You can create your own examples and have them show up in the Go documentation
    for your packages. Let’s look at an example for the `SendJSON` function from our
    previous example.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建自己的示例，并让它们出现在你包的 Go 文档中。让我们看看我们之前示例中的 `SendJSON` 函数的示例。
- en: Listing 9.26\. handlers_example_test.go
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.26\. handlers_example_test.go
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Examples are based on existing functions or methods. Instead of starting the
    function with the word `Test`, we need to use the word `Example`. On line 13 in
    [listing 9.26](#ch09ex26), the name of the example is `ExampleSendJSON`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例基于现有的函数或方法。我们不需要以单词 `Test` 开头函数，而需要使用单词 `Example`。在第 13 行的[列表 9.26](#ch09ex26)中，示例的名称是
    `ExampleSendJSON`。
- en: There’s one rule you need to follow with examples. An example is always based
    on an existing exported function or method. Our example test is for the exported
    function `SendJSON` inside the `handlers` package. If you don’t use the name of
    an existing function or method, the test won’t show in the Go documentation for
    the package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，你需要遵循一条规则。一个示例总是基于一个现有的已导出函数或方法。我们的示例测试是针对 `handlers` 包中的已导出函数 `SendJSON`。如果你不使用现有函数或方法的名称，测试将不会显示在包的
    Go 文档中。
- en: The code you write for an example is to show someone how to use the specific
    function or method. To determine if the test succeeds or fails, the test will
    compare the final output of the function with the output listed at the bottom
    of the example function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你为示例编写的代码是为了向某人展示如何使用特定的函数或方法。为了确定测试是否成功或失败，测试将比较函数的最终输出与示例函数底部列出的输出。
- en: 'Listing 9.27\. handlers_example_test.go: lines 27–31'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.27\. handlers_example_test.go: 行 27–31'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On line 28 in [listing 9.27](#ch09ex27), the code uses `fmt.Println` to write
    the value of `u` to stdout. The value of `u` is initialized from making a call
    to the `/sendjson` endpoint earlier in the function. On line 29 we have a comment
    with the word `Output:`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 28 行的[列表 9.27](#ch09ex27)中，代码使用 `fmt.Println` 将 `u` 的值写入标准输出。`u` 的值是在函数中较早调用
    `/sendjson` 端点时初始化的。在第 29 行我们有一个带有单词 `Output:` 的注释。
- en: The `Output:` marker is used to document the output you expect to have after
    the test function is run. The testing framework knows how to compare the final
    output from stdout against this output comment. If everything matches, the test
    passes, and you have an example that works inside the Go documentation for the
    package. If the output doesn’t match, the test fails.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Output:` 标记用于记录测试函数运行后预期的输出。测试框架知道如何将最终的输出与 stdout 中的输出注释进行比较。如果一切匹配，则测试通过，并且你有一个在包的
    Go 文档内部工作的示例。如果输出不匹配，则测试失败。'
- en: If you start a local `godoc` server (`godoc -http=":3000"`) and navigate to
    the `handlers` package, you can see this all come together, as in [figure 9.10](#ch09fig10).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动一个本地的 `godoc` 服务器 (`godoc -http=":3000"`) 并导航到 `handlers` 包，你可以看到所有这些内容都整合在一起，如
    [图 9.10](#ch09fig10) 所示。
- en: Figure 9.10\. `godoc` view of the `handlers` package
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.10\. `godoc` 视图中的 `handlers` 包
- en: '![](09fig10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig10.jpg)'
- en: You can see in [figure 9.10](#ch09fig10) that the documentation for the `handlers`
    package shows the example for the `SendJSON` function. If you select the `SendJSON`
    link, the documentation will show the code, as in [figure 9.11](#ch09fig11).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图 9.10](#ch09fig10) 中看到，`handlers` 包的文档显示了 `SendJSON` 函数的示例。如果你选择 `SendJSON`
    链接，文档将显示代码，如 [图 9.11](#ch09fig11) 所示。
- en: Figure 9.11\. A full view of the example in `godoc`
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.11\. `godoc` 中的示例全貌
- en: '![](09fig11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig11.jpg)'
- en: '[Figure 9.11](#ch09fig11) shows a complete set of documentation for the example,
    including the code and the expected output. Since this is also a test, you can
    run the example function with the `go test` tool, as in [figure 9.12](#ch09fig12).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.11](#ch09fig11) 展示了示例的完整文档，包括代码和预期输出。由于这也是一个测试，你可以使用 `go test` 工具运行示例函数，如
    [图 9.12](#ch09fig12) 所示。'
- en: Figure 9.12\. Running the example
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.12\. 运行示例
- en: '![](09fig12_alt.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig12_alt.jpg)'
- en: After running the test, you see the test passes. This time when the test is
    run, the specific function `ExampleSendJSON` is specified with the `-run` option.
    The `-run` option takes any regular expression to filter the test functions to
    run. It works with both unit tests and example functions. When an example fails,
    it looks like this [figure 9.13](#ch09fig13).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，你会看到测试通过。这次运行测试时，使用 `-run` 选项指定了特定的函数 `ExampleSendJSON`。`-run` 选项接受任何正则表达式来过滤要运行的测试函数。它适用于单元测试和示例函数。当示例失败时，它看起来像
    [图 9.13](#ch09fig13)。
- en: Figure 9.13\. Running an example that fails
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.13\. 运行一个失败的示例
- en: '![](09fig13_alt.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig13_alt.jpg)'
- en: When an example fails, `go test` shows the output that was produced and what
    was expected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个示例失败时，`go test` 会显示产生的输出和预期的结果。
- en: 9.3\. Benchmarking
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 基准测试
- en: Benchmarking is a way to test the performance of code. It’s useful when you
    want to test the performance of different solutions to the same problem and see
    which solution performs better. It can also be useful to identify CPU or memory
    issues for a particular piece of code that might be critical to the performance
    of your application. Many developers use benchmarking to test different concurrency
    patterns or to help configure work pools to make sure they’re configured properly
    for the best throughput.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试是测试代码性能的一种方法。当你想要测试同一问题的不同解决方案的性能并查看哪个解决方案表现更好时，它很有用。它还可以用来识别可能对应用程序性能至关重要的特定代码片段的
    CPU 或内存问题。许多开发者使用基准测试来测试不同的并发模式，或帮助配置工作池，以确保它们配置得当以获得最佳吞吐量。
- en: Let’s look at a set of benchmark functions that reveal the fastest way to convert
    an integer value to a string. In the standard library, there are three different
    ways to convert an integer value to a string.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一组基准函数，这些函数揭示了将整数值转换为字符串的最快方式。在标准库中，有三种不同的方法可以将整数值转换为字符串。
- en: 'Listing 9.28\. listing28_test.go: lines 01–10'
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.28\. listing28_test.go: 行 01–10'
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Listing 9.28](#ch09ex28) shows the initial code for the listing28_test.go
    benchmarks. As with unit test files, the file name must end in _test.go. The `testing`
    package must also be imported. Next, let’s look at one of the benchmark functions.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.28](#ch09ex28) 展示了列表28_test.go基准测试的初始代码。与单元测试文件一样，文件名必须以 _test.go 结尾。还必须导入
    `testing` 包。接下来，让我们看看其中一个基准函数。'
- en: 'Listing 9.29\. listing28_test.go: lines 12–22'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.29\. listing28_test.go: 行 12–22'
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On line 14 in [listing 9.29](#ch09ex29), you see the first benchmark, named
    `BenchmarkSprintf`. Benchmark functions begin with the word `Benchmark` and take
    as their only parameter a pointer of type `testing.B`. In order for the benchmarking
    framework to calculate performance, it must run the code over and over again for
    a period of time. This is where the `for` loop comes in.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.29](#ch09ex29) 的第 14 行，你可以看到第一个基准测试，命名为 `BenchmarkSprintf`。基准测试函数以单词
    `Benchmark` 开头，并且只接受一个类型为 `testing.B` 的指针作为其唯一参数。为了使基准测试框架能够计算性能，它必须在一个时间段内反复运行代码。这就是
    `for` 循环的作用所在。
- en: 'Listing 9.30\. listing28_test.go: lines 19–22'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.30\. listing28_test.go: 行 19–22'
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `for` loop on line 19 in [listing 9.30](#ch09ex30) shows how to use the
    `b.N` value. On line 20 we have the call to the `Sprintf` function from the `fmt`
    package. This is the function we’re benchmarking to convert an integer value into
    a string.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.30](#ch09ex30) 第 19 行的 `for` 循环显示了如何使用 `b.N` 值。在第 20 行，我们有对 `fmt` 包中
    `Sprintf` 函数的调用。这是我们正在基准测试的函数，用于将整数值转换为字符串。'
- en: By default, the benchmarking framework will call the benchmark function over
    and over again for at least one second. Each time the framework calls the benchmark
    function, it will increase the value of `b.N`. On the first call, the value of
    `b.N` will be `1`. It’s important to place all the code to benchmark inside the
    loop and to use the `b.N` value. If this isn’t done, the results can’t be trusted.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，基准测试框架会反复调用基准测试函数，至少持续一秒。每次框架调用基准测试函数时，它都会增加 `b.N` 的值。在第一次调用时，`b.N` 的值将是
    `1`。将所有要基准测试的代码放置在循环内并使用 `b.N` 值是非常重要的。如果不这样做，结果是不可信的。
- en: If we just want to run benchmark functions, we need to use the `-bench` option.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想运行基准测试函数，我们需要使用 `-bench` 选项。
- en: Listing 9.31\. Running the benchmark test
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.31\. 运行基准测试
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our call to `go test`, we specified the `-run` option passing the string
    `"none"` to make sure no unit tests are run prior to running the specified benchmark
    function. Both of these options take a regular expression to filter the tests
    to run. Since there’s no unit test function that has `none` in its name, `none`
    eliminates any unit tests from running. When we issue this command, we get the
    output shown in [figure 9.14](#ch09fig14).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `go test` 调用中，我们指定了 `-run` 选项，传递字符串 `"none"` 以确保在运行指定的基准测试函数之前不运行任何单元测试。这两个选项都接受一个正则表达式来过滤要运行的测试。由于没有单元测试函数的名称中包含
    `none`，`none` 会消除任何单元测试的运行。当我们发出此命令时，我们得到 [图 9.14](#ch09fig14) 中所示的输出。
- en: Figure 9.14\. Running a single benchmark
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.14\. 运行单个基准测试
- en: '![](09fig14_alt.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig14_alt.jpg)'
- en: The output starts out specifying that there are no tests to run and then proceeds
    to run the `BenchmarkSprintf` benchmark. After the word `PASS`, you see the result
    of running the benchmark function. The first number, `5000000`, represents the
    number of times the code inside the loop was executed. In this case, that’s five
    million times. The next number represents the performance of the code based on
    the number of nanoseconds per operation, so using the `Sprintf` function in this
    context takes 258 nanoseconds on average per call.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出首先指定没有要运行的测试，然后继续运行 `BenchmarkSprintf` 基准测试。在 `PASS` 一词之后，你可以看到运行基准测试函数的结果。第一个数字
    `5000000` 表示循环内代码执行的次数。在这种情况下，那是五百万次。下一个数字表示基于每操作纳秒数的代码性能，因此在这种情况下，使用 `Sprintf`
    函数平均每次调用需要 258 纳秒。
- en: The final output from running the benchmark shows *ok* to represent the benchmark
    finished properly. Then the name of the code file that was executed is displayed,
    and finally, the total time the benchmark ran. The default minimum run time for
    a benchmark is 1 second. You can see how the framework still ran the test for
    approximately a second and a half. You can use another option called `-benchtime`
    if you want to have the test run longer. Let’s run the test again using a bench
    time of three seconds (see [figure 9.15](#ch09fig15)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行基准测试的最终输出显示为 *ok*，表示基准测试正确完成。然后显示执行代码的文件名，最后显示基准测试运行的总时间。基准测试的默认最小运行时间为 1
    秒。你可以看到框架仍然运行了大约一秒半的测试。如果你想使测试运行更长的时间，可以使用另一个选项 `-benchtime`。让我们再次运行测试，使用基准时间为三秒（见
    [图 9.15](#ch09fig15)）。
- en: Figure 9.15\. Running a single benchmark with the `-benchtime` option
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.15\. 使用 `-benchtime` 选项运行单个基准测试
- en: '![](09fig15_alt.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig15_alt.jpg)'
- en: This time the `Sprintf` function was run twenty million times for a period of
    5.275 seconds. The performance of the function didn’t change much. This time the
    performance was 256 nanoseconds per operation. Sometimes by increasing the bench
    time, you can get a more accurate reading of performance. For most tests, increasing
    the bench time over three seconds tends to not provide any difference for an accurate
    reading. But each benchmark is different.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Sprintf` 函数运行了 2000 万次，持续了 5.275 秒。函数的性能没有太大变化。这次的性能是每操作 256 纳秒。有时通过增加基准测试时间，你可以得到更准确的性能读数。对于大多数测试，增加基准测试时间超过三秒通常不会为准确读数提供任何差异。但每个基准测试都是不同的。
- en: Let’s look at the other two benchmark functions and then run all three benchmarks
    together to see what’s the fastest way to convert an integer value to a string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他两个基准测试函数，然后一起运行所有三个基准测试，看看将整数值转换为字符串最快的方法是什么。
- en: 'Listing 9.32\. listing28_test.go: lines 24–46'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 9.32\. listing28_test.go: 行 24–46'
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Listing 9.32](#ch09ex32) shows the other two benchmark functions. The `BenchmarkFormat`
    function benchmarks the use of the `FormatInt` function from the `strconv` package.
    The `BenchmarkItoa` function benchmarks the use of the `Itoa` function from the
    same `strconv` package. You can see the same pattern in these two other benchmark
    functions as in the `BenchmarkSprintf` function. The call is inside the `for`
    loop using `b.N` to control the number of iterations for each call.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.32](#ch09ex32) 显示了其他两个基准测试函数。`BenchmarkFormat` 函数基准测试了 `strconv` 包中 `FormatInt`
    函数的使用。`BenchmarkItoa` 函数基准测试了同一 `strconv` 包中 `Itoa` 函数的使用。你可以看到这两个其他基准测试函数与 `BenchmarkSprintf`
    函数中相同的模式。调用在 `for` 循环内部使用 `b.N` 来控制每个调用的迭代次数。'
- en: One thing we skipped over was the call to `b.ResetTimer`, which is used in all
    three benchmark functions. This method is useful to reset the timer when initialization
    is required before the code can start executing the loop. To have the most accurate
    benchmark times you can, use this method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过的一件事是 `b.ResetTimer` 的调用，它在所有三个基准测试函数中使用。当需要在代码开始执行循环之前进行初始化时，此方法很有用。为了获得最准确的基准测试时间，你可以使用此方法。
- en: When we run all the benchmark functions for a minimum of three seconds, we get
    the result shown in [figure 9.16](#ch09fig16).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行所有基准测试函数至少三秒钟时，我们得到图 9.16 所示的结果。
- en: Figure 9.16\. Running all three benchmarks
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.16\. 运行所有三个基准测试
- en: '![](09fig16_alt.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 的替代文本](09fig16_alt.jpg)'
- en: The results show that the `BenchmarkFormat` test function runs the fastest at
    45.9 nanoseconds per operation. The `BenchmarkItoa` comes in a close second at
    49.4 nanoseconds per operation. Both of those benchmarks were much faster than
    using the `Sprintf` function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，`BenchmarkFormat` 测试函数以每操作 45.9 纳秒的速度运行得最快。`BenchmarkItoa` 以每操作 49.4 纳秒的接近速度排在第二位。这两个基准测试都比使用
    `Sprintf` 函数快得多。
- en: Another great option you can use when running benchmarks is the `-benchmem`
    option. It will provide information about the number of allocations and bytes
    per allocation for a given test. Let’s use that option with the benchmark (see
    [figure 9.17](#ch09fig17)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行基准测试时，你可以使用的另一个优秀选项是 `-benchmem` 选项。它将提供有关给定测试中分配数量和每个分配的字节数的信息。让我们使用这个选项与基准测试一起使用（见图
    9.17）。
- en: Figure 9.17\. Running a benchmark with the `-benchmem` option
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.17\. 使用 `-benchmem` 选项运行基准测试
- en: '![](09fig17_alt.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 的替代文本](09fig17_alt.jpg)'
- en: 'This time with the output you see two new values: a value for `B/op` and one
    for `allocs/op`. The `allocs/op` value represents the number of heap allocations
    per operation. You can see the `Sprintf` functions allocate two values on the
    heap per operation, and the other two functions allocate one value per operation.
    The `B/op` value represents the number of bytes per operation. You can see that
    those two allocations from the `Sprintf` function result in 16 bytes of memory
    being allocated per operation. The other two functions only allocated 2 bytes
    per operation.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你看到两个新的值：一个是 `B/op` 的值，另一个是 `allocs/op` 的值。`allocs/op` 的值表示每个操作中堆分配的数量。你可以看到
    `Sprintf` 函数在每个操作中分配两个值到堆上，而其他两个函数每个操作只分配一个值。`B/op` 的值表示每个操作的字节数。你可以看到来自 `Sprintf`
    函数的这两个分配导致每个操作分配了 16 字节的内存。其他两个函数每个操作只分配了 2 字节。
- en: There are many different options you can use when running tests and benchmarks.
    I suggest you explore all those options and leverage this testing framework to
    the fullest extent when writing your packages and projects. The community expects
    package authors to provide comprehensive tests when publishing packages for open
    use by the community.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试和基准测试时，你可以使用许多不同的选项。我建议你探索所有这些选项，并在编写你的包和项目时充分利用这个测试框架。社区期望包作者在发布供社区公开使用的包时提供全面的测试。
- en: 9.4\. Summary
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 概述
- en: Testing is built into the language and Go provides all the tooling you need.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是语言内置的，Go 提供了你需要的所有工具。
- en: The `go test` tool is used to run tests.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go test` 工具用于运行测试。'
- en: Test files always end with the _test.go file name.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试文件总是以_test.go文件名结尾。
- en: Table tests are a great way to leverage a single test function to test multiple
    values.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格测试是利用单个测试函数测试多个值的一种很好的方式。
- en: Examples are both tests and documentation for a package.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例既是包的测试也是文档。
- en: Benchmarks provide a mechanism to reveal the performance of code.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试提供了一种机制来揭示代码的性能。
