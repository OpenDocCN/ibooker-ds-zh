- en: 3 Your first steps with Cypher query language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 使用 Cypher 查询语言的第一步
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing the Cypher query language syntax
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Cypher 查询语言语法
- en: Creating nodes and relationships with Cypher
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypher 创建节点和关系
- en: Matching and retrieving data from the database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中匹配和检索数据
- en: Removing properties and deleting nodes and relationships
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除属性、删除节点和关系
- en: Best practices for importing a CSV into a graph database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 CSV 导入图数据库的最佳实践
- en: So far, you have learned a bit of graph theory and how to approach the labeled-property
    graph modeling process. Now, you will begin to learn how to perform network analysis
    through practical use cases. To follow the examples in this book, you need to
    set up a Neo4j development environment. If you need some help getting started
    with the setup, see the appendix.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，你已经学习了一些图论知识以及如何处理带标签的属性图建模过程。现在，你将开始学习如何通过实际案例进行网络分析。为了跟随本书中的示例，你需要设置
    Neo4j 开发环境。如果你在设置过程中需要一些帮助，请参阅附录。 '
- en: This chapter will introduce Cypher query language clauses and best practices
    for importing data into a graph database. First, I will do a quick recap of using
    Cypher query language syntax to represent networks in a textual format. If you
    are already familiar with the Cypher query syntax, you can skip most of the chapter
    and just import the data as shown in the last section. Remember from the previous
    chapter that the Cypher syntax uses parentheses to encapsulate a representation
    of a node. A quick reminder how to describe a node with Cypher syntax is shown
    in figure 3.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Cypher 查询语言子句以及将数据导入图数据库的最佳实践。首先，我将简要回顾如何使用 Cypher 查询语言语法以文本格式表示网络。如果你已经熟悉
    Cypher 查询语法，你可以跳过本章的大部分内容，只需按照最后一节所示导入数据即可。记住，从上一章中，Cypher 语法使用括号来封装节点的表示。如何使用
    Cypher 语法描述节点的一个快速提醒如图 3.1 所示。
- en: '![03-01](../../OEBPS/Images/03-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![03-01](../../OEBPS/Images/03-01.png)'
- en: Figure 3.1 Cypher query language syntax to represent a node with its label and
    properties
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 使用 Cypher 查询语言语法表示具有标签和属性的节点
- en: In this example, I have described a node with a label `Person`. The label of
    the node is always preceded by a colon. Node properties are key-value pairs wrapped
    inside the curly brackets. The example node has only a single property with a
    key, `name`, and its value, `Thomas`. In Cypher, you can also add a variable,
    which is used as a reference to the specific node, at the start of the node. You
    can choose any name for the reference variable; in this example, I have chosen
    the reference variable `thomas`. The node variable allows you to refer to this
    particular node later in the Cypher statement, and it is only valid within the
    context of a single Cypher statement. You can use the node variable to access
    its properties and labels; use it in expressions; or create new patterns related
    to a given node. In Cypher, the relationships are represented with square brackets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用标签 `Person` 描述了一个节点。节点的标签总是由一个冒号引导。节点属性是括号内封装的关键值对。示例节点只有一个属性，键为 `name`，值为
    `Thomas`。在 Cypher 中，你还可以在节点的开始处添加一个变量，该变量用作对特定节点的引用。你可以为引用变量选择任何名称；在这个例子中，我选择了引用变量
    `thomas`。节点变量允许你在 Cypher 语句中稍后引用此特定节点，并且它仅在单个 Cypher 语句的上下文中有效。你可以使用节点变量来访问其属性和标签；在表达式中使用它；或创建与给定节点相关的新模式。在
    Cypher 中，关系用方括号表示。
- en: A relationship can only exist when it is adjacent to both a source node and
    a target node. When you are describing a relationship with Cypher, you always
    need to include the adjacent nodes. Each relationship has a single type; like
    node labels, the relationship type is also preceded by a colon. The example in
    figure 3.2 describes a relationship with a `FRIEND` type. Relationship properties
    are described like node properties, and each relationship can be assigned a variable
    (in this example, `f`) that can be used later in the Cypher statement to refer
    to the given connection.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关系只能存在于它相邻于源节点和目标节点时。当你用 Cypher 描述一个关系时，你总是需要包括相邻的节点。每个关系都有一个单一的类型；就像节点标签一样，关系类型也是由冒号引导的。图
    3.2 中的示例描述了一个具有 `FRIEND` 类型的关系。关系属性像节点属性一样描述，并且每个关系都可以分配一个变量（在这个例子中，`f`），该变量可以在
    Cypher 语句中稍后用来引用给定的连接。
- en: '![03-02](../../OEBPS/Images/03-02.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![03-02](../../OEBPS/Images/03-02.png)'
- en: Figure 3.2 Cypher query language syntax to represent a relationship with its
    type and properties
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 使用 Cypher 查询语言语法表示具有类型和属性的节点
- en: Note In Neo4j, each relationship is stored as directed. You can, however, ignore
    the relationship direction when executing a Cypher query or a graph algorithm
    on top of the stored graph. A common practice in Neo4j is to store an undirected
    relationship as a single directed relationship. When executing Cypher queries,
    you can then ignore the direction of the relationship and treat it as undirected.
    While this is a relevant aspect in Neo4j, it can be difficult to understand at
    first, so throughout the book, I will show you practical examples of how to differentiate
    between storing the graph and how to query it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Neo4j中，每个关系都存储为有向的。然而，在执行基于存储图上的Cypher查询或图算法时，您可以忽略关系的方向。在Neo4j中，将无向关系存储为单个有向关系是一种常见的做法。在执行Cypher查询时，您可以忽略关系的方向，将其视为无向的。虽然这在Neo4j中是一个相关方面，但一开始可能难以理解，因此在本书中，我将向您展示如何区分存储图和查询图的实用示例。
- en: 3.1 Cypher query language clauses
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 Cypher查询语言子句
- en: Armed with the knowledge of how to describe a node and a relationship in Cypher,
    we will now begin our discussion of Cypher clauses. To follow along with the examples,
    you need to have a working Neo4j environment ready. I recommend you use the Neo4j
    Browser to execute Cypher queries. Again, if you need some help with setting up
    a Neo4j environment and accessing the Neo4j Browser, I suggest reviewing the appendix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 带着如何在Cypher中描述节点和关系的知识，我们现在将开始讨论Cypher子句。为了跟上示例，您需要准备好一个可工作的Neo4j环境。我建议您使用Neo4j浏览器来执行Cypher查询。再次提醒，如果您需要设置Neo4j环境和访问Neo4j浏览器的帮助，我建议您查阅附录。
- en: 3.1.1 CREATE clause
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 CREATE子句
- en: 'You will begin by learning how to create data with Cypher. The `CREATE` clause
    is used to store nodes and relationships in the graph database. While Cypher query
    language clauses are not case sensitive, it is a best practice to write Cypher
    clauses in uppercase for easier readability. For more information on the Cypher
    style guide, see this Neo4j web page: [https://neo4j.com/developer/cypher/style-guide/](https://neo4j.com/developer/cypher/style-guide/).
    You can store any graph pattern by using Cypher syntax to describe node and relationship
    patterns.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先学习如何使用Cypher创建数据。`CREATE`子句用于在图数据库中存储节点和关系。虽然Cypher查询语言子句不区分大小写，但为了便于阅读，建议使用大写字母编写Cypher子句。有关Cypher风格指南的更多信息，请参阅此Neo4j网页：[https://neo4j.com/developer/cypher/style-guide/](https://neo4j.com/developer/cypher/style-guide/)。您可以使用Cypher语法描述节点和关系模式来存储任何图模式。
- en: You will begin by creating a single node in the graph. The statement in the
    following listing creates a new node with a label `Person` and a single node property.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先在图中创建一个节点。以下列表中的语句创建了一个带有`Person`标签和单个节点属性的节点。
- en: Listing 3.1 Cypher query that stores a node with a label `Person` and a property
    `name` with the value `Satish`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 存储带有标签`Person`和属性`name`（值为`Satish`）的节点的Cypher查询
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With every execution of the query in listing 3.1, a new node will be created
    in the database. The `CREATE` clause does not check for existing data in the graph
    database; it blindly follows the command to create a new pattern in the database.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行列表3.1中的查询，数据库中都会创建一个新的节点。`CREATE`子句不会检查图数据库中的现有数据；它盲目地遵循命令在数据库中创建新的模式。
- en: If you want to retrieve the created graph elements and visualize them in Neo4j
    Browser, you can use the `RETURN` clause. There can be only a single `RETURN`
    clause in a Cypher query and only as the last clause of a query. As always, there
    are some exceptions where you can have multiple `RETURN` clauses in a query. Those
    exceptions are unions and subqueries, which you will learn about later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检索创建的图元素并在Neo4j浏览器中可视化它们，可以使用`RETURN`子句。Cypher查询中只能有一个`RETURN`子句，并且只能作为查询的最后一个子句。像往常一样，有一些例外情况，您可以在查询中包含多个`RETURN`子句。这些例外是并集和子查询，您将在以后学习到。
- en: The Cypher statement in the following listing starts by creating a node with
    the `Person` label and the `name` property.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中的Cypher语句首先创建了一个带有`Person`标签和`name`属性的节点。
- en: Listing 3.2 Cypher query that creates a node and fetches its information with
    the `RETURN` clause
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 创建节点并使用`RETURN`子句检索其信息的Cypher查询
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The created node is referenced with the `p` variable. To fetch the information
    about the created node from the database, you can use the `RETURN` clause and
    define which variables you want to retrieve. In this example, you want to retrieve
    the `p` variable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的节点使用 `p` 变量进行引用。要从数据库中获取创建节点的信息，你可以使用 `RETURN` 子句并定义你想要检索的变量。在这个例子中，你想要检索
    `p` 变量。
- en: The Cypher statement in listing 3.2 produces the output shown in figure 3.3
    in the Neo4j Browser. This visualization depicts a single node that is returned
    by the Cypher statement in listing 3.2\. Additionally, Neo4j Browser has a few
    visualization options, like node color and size options, along with the caption
    definition. Learn more about Neo4j Browser styling in the browser manual ([http://mng.bz/j1ge](http://mng.bz/j1ge)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 中的 Cypher 语句在 Neo4j 浏览器中产生了如图 3.3 所示的输出。这个可视化展示了由列表 3.2 中的 Cypher 语句返回的单个节点。此外，Neo4j
    浏览器还提供了一些可视化选项，如节点颜色和大小选项，以及标题定义。更多关于 Neo4j 浏览器样式的信息可以在浏览器手册中找到（[http://mng.bz/j1ge](http://mng.bz/j1ge)）。
- en: '![03-03](../../OEBPS/Images/03-03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![03-03](../../OEBPS/Images/03-03.png)'
- en: Figure 3.3 The output of the Cypher statement in listing 3.2
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 列表 3.2 中 Cypher 语句的输出
- en: Exercise 3.1
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.1
- en: To get practice creating graphs, create a new node in the graph with a label
    `Person` and two node properties. The first node property holds the information
    about your name, and the second node property holds the information about your
    age.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习创建图，在图中创建一个新的带有标签 `Person` 的节点，并设置两个节点属性。第一个节点属性包含你的姓名信息，第二个节点属性包含你的年龄信息。
- en: You can use multiple `CREATE` clauses in a single Cypher statement. By using
    the variable of nodes and relationships, you can modify and connect them in the
    subsequent `CREATE` queries.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个 Cypher 语句中使用多个 `CREATE` 子句。通过使用节点和关系的变量，你可以在后续的 `CREATE` 查询中修改和连接它们。
- en: The Cypher statement in the following listing demonstrates how to create two
    nodes and a relationship between them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的 Cypher 语句演示了如何创建两个节点及其之间的关系。
- en: Listing 3.3 Cypher query that stores two nodes and a relationship between them
    in the database
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 存储两个节点及其之间关系的 Cypher 查询
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first `CREATE` clause, two nodes are created, and in the second `CREATE`
    clause, a relationship between them is added. While you could combine these two
    `CREATE` clauses into a single clause, it is recommended as a best practice to
    create nodes and relationships separately.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '在第一个 `CREATE` 子句中创建了两个节点，在第二个 `CREATE` 子句中添加了它们之间的关系。虽然你可以将这两个 `CREATE` 子句合并为一个子句，但作为一个最佳实践，建议分别创建节点和关系。 '
- en: You might have noticed that the Cypher statement in listing 3.3 uses a `*` wildcard
    operator in the `RETURN` clause. The wildcard operator `*` will return all variables
    in scope.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到列表 3.3 中的 Cypher 语句在 `RETURN` 子句中使用了 `*` 通配符运算符。通配符运算符 `*` 将返回作用域内的所有变量。
- en: Exercise 3.2
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.2
- en: Try to create two nodes, one that represents you and one that represents the
    organization you work at. You will likely want to use different node labels to
    describe a person and an organization. Then, in the same Cypher statement, create
    a relationship between yourself and your employer. You can try to add a relationship
    property indicating when you started to work in your current role.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建两个节点，一个代表你自己，另一个代表你工作的组织。你可能希望使用不同的节点标签来描述一个人和一个组织。然后，在同一个 Cypher 语句中，创建一个连接你和你的雇主的关系。你可以尝试添加一个关系属性来表示你开始当前职位的日期。
- en: Remember, you can only store directed relationships in the Neo4j graph database.
    Let’s see what happens when you try to create an undirected relationship in the
    following listing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你只能在 Neo4j 图数据库中存储有向关系。让我们看看当你尝试在以下列表中创建无向关系时会发生什么。
- en: Listing 3.4 Cypher query that tries to stores an undirected relationship in
    the database and fails
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 尝试在数据库中存储无向关系并失败的 Cypher 查询
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Cypher statement in listing 3.4 fails due to only being able to store directed
    relationships in the database. While the relationship direction arrow seems to
    be such a small part of the query, it is very influential to how the query will
    behave.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 中的 Cypher 语句失败，因为数据库中只能存储有向关系。虽然关系方向箭头在查询中似乎只是很小的一部分，但它对查询的行为有非常大的影响。
- en: Another common misconception among beginners is that they forget that reference
    variables are only visible within the same Cypher statement. As stated previously,
    the `CREATE` statement performs no database lookup before inserting new data in
    the graph. The following Cypher statement looks OK at first glance, but it is
    actually quite awful.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者中另一个常见的误解是他们忘记引用变量仅在相同的 Cypher 语句中可见。如前所述，`CREATE` 语句在向图中插入新数据之前不执行数据库查找。以下
    Cypher 语句乍一看似乎是好的，但实际上相当糟糕。
- en: Listing 3.5 Cypher query that stores two empty nodes with no labels and a relationship
    between them in the database
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 将两个没有标签且之间有关系的空节点存储到数据库中的 Cypher 查询
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Can you deduce why? As the `CREATE` statement performs no database lookups and
    does not have variable reference visibility between Cypher queries, it will just
    create a new pattern we have described. Therefore, the Cypher statement in listing
    3.5 creates a `FRIEND` relationship between two nodes with no labels and no properties.
    You must be very careful to avoid these types of situations. There are no situations
    in the labeled property graph model in which you would want to have nodes without
    any labels stored in the database. At a minimum, you can add a generic `Node`
    label to each node.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你能推断出原因吗？因为 `CREATE` 语句不执行数据库查找，并且在 Cypher 查询之间没有变量引用可见性，它只会创建我们描述的新模式。因此，列表
    3.5 中的 Cypher 语句在两个没有标签且没有属性的节点之间创建了一个 `FRIEND` 关系。你必须非常小心，避免这些类型的情况。在标记属性图模型中，没有你想在数据库中存储没有任何标签的节点的情况。至少，你可以在每个节点上添加一个通用的
    `Node` 标签。
- en: Note The labeled-property graph model is so flexible that it allows you to create
    nodes without labels or properties. However, you should always strive to, at the
    very least, add a label to every node you store in the database. Having labeled
    nodes will help with model readability as well as query execution performances.
    I can safely say that if you have nodes without a label in your graph, something
    is wrong with either your model or your import process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：标记属性图模型非常灵活，允许你创建没有标签或属性的节点。然而，你应该始终努力至少为你在数据库中存储的每个节点添加一个标签。有标签的节点将有助于模型的可读性以及查询执行性能。我可以安全地说，如果你的图中没有标签的节点，那么你的模型或导入过程可能存在问题。
- en: Exercise 3.3
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.3
- en: The goal of this exercise is to create three nodes and two relationships between
    them. The nodes should represent the city, country, and continent you currently
    live in. Add one relationship between the city and the country and the second
    relationship between the country and the continent. Take a couple of minutes to
    decide what relationship types you want to use and the direction of relationships.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是创建三个节点，并在它们之间建立两个关系。这些节点应代表你目前居住的城市、国家和大陆。在它们之间添加一个城市和国家之间的关系，以及国家与大陆之间的关系。花几分钟时间决定你想要使用的关系类型和关系的方向。
- en: 3.1.2 MATCH clause
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 MATCH 子句
- en: You can search for existing graph patterns stored in the database using the
    `MATCH` clause. Cypher is a declarative query language, which means you only need
    to specify the pattern you are interested in and let the query engine take care
    of how to retrieve those patterns from the database. In the previous section,
    you created at least three nodes with the label `Person` and different `name`
    property values. If you want to find a `Person` node with a specific `name` property
    value, you can use the following query.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `MATCH` 子句在数据库中搜索现有的图模式。Cypher 是一种声明式查询语言，这意味着你只需要指定你感兴趣的模式，然后让查询引擎负责如何从数据库中检索这些模式。在上一节中，你至少创建了三个带有
    `Person` 标签和不同 `name` 属性值的节点。如果你想找到一个具有特定 `name` 属性值的 `Person` 节点，你可以使用以下查询。
- en: Listing 3.6 Cypher statement that searches and retrieves any nodes with a label
    `Person` and a `name` property with a value of `Satish`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 查询并检索具有标签 `Person` 和 `name` 属性值为 `Satish` 的任何节点的 Cypher 语句
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can observe why it was critical first to learn how to describe node and
    relationship patterns with Cypher before you wrote your first Cypher clause. When
    you know how to describe a graph pattern, you can use the `MATCH` clause to retrieve
    it from the database. The query in listing 3.6 uses *inline* graph pattern matching.
    Inline pattern matching uses Cypher pattern syntax to describe a node or relationship
    pattern with its labels and properties. The opposite of inline pattern matching
    is using a `WHERE` clause to describe a graph pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写第一个Cypher子句之前，首先学习如何使用Cypher描述节点和关系模式是至关重要的。当你知道如何描述图模式时，你可以使用`MATCH`子句从数据库中检索它。列表3.6中的查询使用*内联*图模式匹配。内联模式匹配使用Cypher模式语法来描述具有其标签和属性的节点或关系模式。与内联模式匹配相反的是使用`WHERE`子句来描述图模式。
- en: Listing 3.7 Cypher statement that searches and retrieves any nodes with a label
    `Person` and a `name` property with a value of `Satish` using a `WHERE` clause
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 使用`WHERE`子句搜索和检索任何标签为`Person`且`name`属性值为`Satish`的节点的Cypher语句
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The query in listing 3.7 will produce the exact same query plan and results
    as the query in listing 3.6\. The inline syntax is just syntactic sugar that improves
    readability. Using the `WHERE` clause, you have described you want to retrieve
    a node with the label `Person` and the `name` property with a value of `Satish`.
    My personal preference is to describe the node label with inline graph pattern
    and provide additional matching filters in the `WHERE` clause.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7中的查询将产生与列表3.6中查询完全相同的查询计划和结果。内联语法只是提高可读性的语法糖。使用`WHERE`子句，你描述了你想要检索一个标签为`Person`且`name`属性值为`Satish`的节点。我个人的偏好是使用内联图模式描述节点标签，并在`WHERE`子句中提供额外的匹配过滤器。
- en: Listing 3.8 Cypher statement that combines inline graph pattern matching with
    a `WHERE` clause to describe a graph pattern
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 使用内联图模式匹配与`WHERE`子句结合来描述图模式的Cypher语句
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Cypher statement in listing 3.8 introduces the `AS` operator. With the `AS`
    operator, you can name or alias a variable reference, which allows you to produce
    more readable query outputs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8中的Cypher语句引入了`AS`运算符。使用`AS`运算符，你可以命名或别命名一个变量引用，这允许你产生更易读的查询输出。
- en: Exercise 3.4
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.4
- en: As an exercise, try to retrieve all the nodes with a label `Person` from the
    database. You can use the inline graph pattern description, or you can use a `WHERE`
    clause. In the `RETURN` statement, only return the `name` properties of the nodes.
    Use the `AS` operator to alias the `name` property to produce a more readable
    column name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试从数据库中检索所有标签为`Person`的节点。你可以使用内联图模式描述，或者你可以使用`WHERE`子句。在`RETURN`子句中，只返回节点的`name`属性。使用`AS`运算符将`name`属性别名化，以产生更易读的列名。
- en: You can always have multiple `MATCH` clauses in a sequence; however, the `WHERE`
    clause only applies to the previous `MATCH` clause. If you use many `MATCH` clauses
    in a sequence, make sure to append a `WHERE` clause to each `MATCH` clause, where
    needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个序列中始终有多个`MATCH`子句；然而，`WHERE`子句仅适用于前面的`MATCH`子句。如果你在序列中使用多个`MATCH`子句，确保在每个`MATCH`子句之后（如果需要的话）附加一个`WHERE`子句。
- en: Listing 3.9 Cypher statement that combines inline graph pattern matching with
    a `WHERE` clause to describe a graph pattern
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 使用内联图模式匹配与`WHERE`子句结合来描述图模式的Cypher语句
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note A `WHERE` clause can only exist when it follows a `WITH`, a `MATCH`, or
    an `OPTIONAL` `MATCH` clause. When you have many `MATCH` or `WITH` clauses in
    sequence, make sure to append the `WHERE` clause after each of them, where needed.
    You might sometimes get the same results even if you only use a single `WHERE`
    clause after multiple `MATCH` statements, but the query performance will most
    likely be worse.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`WHERE`子句只能存在于它跟随`WITH`、`MATCH`或`OPTIONAL` `MATCH`子句之后。当你连续有多个`MATCH`或`WITH`子句时，确保在每个子句之后（如果需要的话）附加`WHERE`子句。即使你在多个`MATCH`语句之后只使用一个`WHERE`子句，有时你可能会得到相同的结果，但查询性能很可能会更差。
- en: The `MATCH` clause is often used to find existing nodes or relationships in
    the database and then insert additional data with a `CREATE` or `MERGE` clause.
    For example, you could use the `MATCH` clause to find nodes labeled `Person` with
    names `Elaine` and `Satish` and create a new relationship between them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`MATCH`子句通常用于在数据库中查找现有的节点或关系，然后使用`CREATE`或`MERGE`子句插入附加数据。例如，你可以使用`MATCH`子句来查找标签为`Person`且名字为`Elaine`和`Satish`的节点，并在它们之间创建一个新的关系。'
- en: Listing 3.10 Cypher query that find two nodes in the database and creates a
    new `FRIEND` relationship between them
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 在数据库中查找两个节点并创建它们之间新的 `FRIEND` 关系的 Cypher 查询
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The statement in listing 3.10 combines the `MATCH` and `CREATE` clauses to create
    a new relationship between existing nodes in the database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 中的语句将 `MATCH` 和 `CREATE` 子句组合起来，在数据库中的现有节点之间创建一个新的关系。
- en: Exercise 3.5
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.5
- en: If you haven’t yet created a `Person` node with your name as the value of the
    `name` node property, please do that first. Next, in a separate query, use the
    `MATCH` clause to find the `Person` nodes with your name and `Elaine`, which also
    needs to exist in your database, and create a new `FRIENDS` relationship between
    them. You can add any additional relationship properties you think are appropriate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有创建一个以您的名字作为 `name` 节点属性的 `Person` 节点，请首先创建它。接下来，在单独的查询中，使用 `MATCH` 子句查找具有您名字和
    `Elaine` 的 `Person` 节点，`Elaine` 也需要存在于您的数据库中，并在它们之间创建一个新的 `FRIENDS` 关系。您可以添加任何您认为合适的额外关系属性。
- en: A crucial concept when using the `MATCH` clause is to recognize that if a single
    `MATCH` clause within the query does not find any data matching the provided pattern
    in the database, the query will return no results. If you use a single `MATCH`
    clause to retrieve a nonexisting graph pattern from the database, you will get
    no results.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MATCH` 子句的一个关键概念是认识到，如果查询中的单个 `MATCH` 子句在数据库中没有找到任何与提供的模式匹配的数据，查询将返回没有结果。如果您使用单个
    `MATCH` 子句从数据库中检索一个不存在的图模式，您将得到没有结果。
- en: Listing 3.11 Cypher query that matches a nonexistent graph pattern in the database
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 在数据库中匹配一个不存在的图模式的 Cypher 查询
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is intuitive that when you try to retrieve a nonexistent graph pattern from
    the database, you will get no results. What is not so intuitive is that when you
    have multiple `MATCH` clauses in sequence, if only a single `MATCH` clause tries
    to retrieve a nonexistent pattern from the database, the whole query will return
    no results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试从数据库中检索一个不存在的图模式时，您将得到没有结果，这是直观的。不那么直观的是，当您在查询中按顺序有多个 `MATCH` 子句时，如果只有一个
    `MATCH` 子句尝试从数据库中检索一个不存在的模式，整个查询将返回没有结果。
- en: Listing 3.12 Cypher query that matches both an existing and a nonexisting graph
    pattern in the database
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 在数据库中匹配现有和非现有图模式的 Cypher 查询
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The query in listing 3.12 first tries to find a `Person` node with a `name`
    property `Satish`. You have already executed this part of the query before, so
    you know this pattern exists in the database. The second `MATCH` clause tries
    to retrieve a nonexistent pattern from the database. If even a single `MATCH`
    clause in the query retrieves no pattern from the database, the result of the
    query will be empty.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 中的查询首先尝试在数据库中找到一个具有 `name` 属性 `Satish` 的 `Person` 节点。您已经执行了查询的这一部分，所以您知道这个模式存在于数据库中。第二个
    `MATCH` 子句尝试从数据库中检索一个不存在的模式。如果查询中的任何一个 `MATCH` 子句都没有从数据库中检索到任何模式，查询的结果将为空。
- en: OPTIONAL MATCH clause
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的匹配子句
- en: If you do not want your query to stop when a single `MATCH` clause finds no
    existing graph patterns in the database, you can use the `OPTIONAL` `MATCH` clause.
    The `OPTIONAL` `MATCH` clause would return a `null` value if no matching patterns
    were found in the database instead of returning no results, behaving similarly
    to an `OUTER` `JOIN` in SQL. You can rewrite the query in listing 3.12 to expect
    and handle a nonexisting `Organization` pattern by using the `OPTIONAL` `MATCH`
    clause.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望查询在单个 `MATCH` 子句在数据库中找不到现有图模式时停止，您可以使用 `OPTIONAL` `MATCH` 子句。如果数据库中没有找到匹配的模式，`OPTIONAL`
    `MATCH` 子句将返回 `null` 值，而不是返回没有结果，其行为类似于 SQL 中的 `OUTER` `JOIN`。您可以使用 `OPTIONAL`
    `MATCH` 子句重写列表 3.12 中的查询，以期望和处理一个不存在的 `Organization` 模式。
- en: Listing 3.13 Cypher statement that matches both an existing and a nonexisting
    graph pattern in the database
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 在数据库中匹配现有和非现有图模式的 Cypher 语句
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By using the `OPTIONAL` `MATCH` clause as shown in listing 3.13, the statement
    does not return empty results when no graph patterns are found. Instead, the `null`
    value is returned for nonexisting graph patterns while the matched patterns are
    still retrieved.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用列表 3.13 中所示 `OPTIONAL` `MATCH` 子句，当没有找到图模式时，语句不会返回空结果。相反，对于不存在的图模式返回 `null`
    值，而匹配的模式仍然被检索。
- en: The `OPTIONAL` `MATCH` can also be used to retrieve node relationships if they
    exist.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTIONAL` `MATCH` 也可以用来检索存在的节点关系。'
- en: Listing 3.14 Cypher statement that matches both an existing and a nonexisting
    graph pattern in the database
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 匹配数据库中现有和非现有图模式的 Cypher 语句
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Cypher statement in listing 3.14 first matches on a `Person` node that has
    the `name` property value of `Satish`. Next, it uses the `OPTIONAL` `MATCH` to
    match any outgoing `FRIENDS` relationships. If the `FRIENDS` relationships are
    found, it returns the relationships and the original node. However, if no `FRIENDS`
    relationships are found, the Cypher statement in listing 3.14 still returns the
    `Person` node with the `name` property value `Satish`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14 中的 Cypher 语句首先匹配具有 `name` 属性值为 `Satish` 的 `Person` 节点。然后，它使用 `OPTIONAL`
    `MATCH` 来匹配任何出度的 `FRIENDS` 关系。如果找到 `FRIENDS` 关系，则返回关系和原始节点。然而，如果没有找到 `FRIENDS`
    关系，列表 3.14 中的 Cypher 语句仍然返回具有 `name` 属性值 `Satish` 的 `Person` 节点。
- en: Exercise 3.6
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.6
- en: Determine whether the node representing yourself has any `FRIENDS` relationships
    in the database. Start by using the `MATCH` clause to match the `Person` node
    with your name. Next, use the `OPTIONAL` `MATCH` to evaluate whether there are
    any `FRIENDS` relationships attached to the node. Finally, return the specified
    graph patterns with the `RETURN` clause.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确定代表您自己的节点在数据库中是否有任何 `FRIENDS` 关系。首先使用 `MATCH` 子句匹配名为您的 `Person` 节点。接下来，使用 `OPTIONAL`
    `MATCH` 来评估节点是否有任何附加的 `FRIENDS` 关系。最后，使用 `RETURN` 子句返回指定的图模式。
- en: 3.1.3 WITH clause
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 `WITH` 子句
- en: 'Using the `WITH` clause, you can manipulate the data as an intermediate step
    before passing the results to the next part of the Cypher query. The intermediate
    data manipulations within a Cypher statement before passing them on to the next
    part can be one or more of the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `WITH` 子句，您可以在将结果传递到 Cypher 查询的下一部分之前，作为中间步骤来操作数据。在将中间数据操作传递到下一部分之前，Cypher
    语句中的中间数据操作可以是一个或多个以下操作之一：
- en: Filter results
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤结果
- en: Select results
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择结果
- en: Aggregate results
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合结果
- en: Paginate results
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页结果
- en: Limit results
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制结果
- en: For example, you can use the `WITH` clause in combination with `LIMIT` to limit
    the number of rows.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用 `WITH` 子句与 `LIMIT` 结合来限制行数。
- en: Listing 3.15 Cypher statement that uses the `WITH` clause to limit the number
    of rows
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 使用 `WITH` 子句限制行数的 Cypher 语句
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also use the `WITH` clause to define and calculate intermediate variables.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `WITH` 子句来定义和计算中间变量。
- en: Listing 3.16 Cypher statement that uses the `WITH` clause to calculate new variables
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 使用 `WITH` 子句计算新变量的 Cypher 语句
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Cypher statement in listing 3.16 starts by creating a `Person` node with
    `name` and `born` properties. You can use the intermediate `WITH` clause to calculate
    the age based on the year Johann was born. Additionally, you can select any variables
    and alias them, like the example with the `name` property in listing 3.16.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 中的 Cypher 语句首先创建一个具有 `name` 和 `born` 属性的 `Person` 节点。您可以使用中间的 `WITH`
    子句根据约翰出生的年份计算年龄。此外，您还可以选择任何变量并将它们别名为，如列表 3.16 中的 `name` 属性示例。
- en: If you wanted to, you could also use the `WITH` clause in combination with the
    `WHERE` clause to filter intermediate results based on existing or newly defined
    variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您还可以使用 `WITH` 子句与 `WHERE` 子句结合来根据现有或新定义的变量过滤中间结果。
- en: Listing 3.17 Cypher statement that uses the `WITH` clause in combination with
    `WHERE` to filter results
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 使用 `WITH` 子句和 `WHERE` 子句过滤结果的 Cypher 语句
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Cypher statement in listing 3.17 introduces the calculated `age` variable
    in the `WITH` clause. You can use the `WHERE` clause that immediately follows
    the `WITH` clause to filter results based on existing or newly defined variables.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 中的 Cypher 语句在 `WITH` 子句中引入了计算出的 `age` 变量。您可以使用紧随 `WITH` 子句之后的 `WHERE`
    子句根据现有或新定义的变量来过滤结果。
- en: The `WITH` clause is also useful when aggregating data. In chapter 4, we will
    discuss data aggregation in greater depth.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当聚合数据时，`WITH` 子句也非常有用。在第 4 章中，我们将更深入地讨论数据聚合。
- en: 3.1.4 SET clause
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 `SET` 子句
- en: A `SET` clause is used to update labels of nodes and properties of both nodes
    and relationships. The `SET` clause is very often used in combination with the
    `MATCH` clause to update existing node or relationship properties.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SET` 子句来更新节点标签以及节点和关系的属性。`SET` 子句通常与 `MATCH` 子句结合使用，以更新现有节点或关系属性。
- en: Listing 3.18 Cypher statement that uses a `SET` clause to update existing node
    properties
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 使用 `SET` 子句更新现有节点属性的 Cypher 语句
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is also a special syntax for a `SET` clause to change or mutate many properties
    using a map data structure. The *map* data structure originated from Java and
    is identical to a dictionary in Python or a JSON object in JavaScript.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用映射数据结构更改或突变多个属性，`SET` 子句也有特殊的语法。*映射* 数据结构起源于 Java，与 Python 中的字典或 JavaScript
    中的 JSON 对象相同。
- en: Listing 3.19 Cypher statement that uses a map data structure in combination
    with the `SET` clause to update several node properties
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 使用 `SET` 子句结合映射数据结构更新多个节点属性的 Cypher 语句
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that if the `+=` operator of the `SET` clause is replaced with only `=`,
    it overrides all existing properties with only those provided in the map.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果将 `SET` 子句的 `+=` 运算符替换为仅 `=`，则仅用映射中提供的那些属性覆盖所有现有属性。
- en: Exercise 3.7
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.7
- en: By now, there is hopefully a `Person` node with your name in the database. Use
    the `SET` clause to add additional node properties, such as the information about
    your favorite food or your pet’s name.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，数据库中可能已经有一个名为你的名字的 `Person` 节点。使用 `SET` 子句添加额外的节点属性，例如你最喜欢的食物或你宠物的名字。
- en: With the `SET` clause, you can also add additional labels to nodes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SET` 子句，你还可以向节点添加额外的标签。
- en: Listing 3.20 Cypher statement that adds a secondary label to an existing node
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 向现有节点添加二级标签的 Cypher 语句
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Multiple node labels are helpful when you want to tag your nodes for faster
    and easier retrieval. In the example in listing 3.20, you have added the `Student`
    label to the `Satish` node, and in the following exercise, you will add an appropriate
    label to the node representing you, such as `Student`, `Employee`, or other. A
    good guideline to follow when using multiple node labels is that node labels should
    be semantically orthogonal. *Semantically orthogonal* refers to node labels not
    holding the same or similar meaning and having nothing to do with one another.
    Secondary node labels are used to group nodes into different buckets to make each
    subset easily accessible. Note that a single node can have multiple secondary
    labels; for instance, a person could be both employed and attending college simultaneously.
    In that case, you could assign both `Student` and `Employee` labels to it. However,
    you should avoid adding more than a couple of node labels to a single node for
    modeling and performance reasons.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想为节点添加标签以实现更快和更轻松的检索时，多个节点标签是有帮助的。在列表 3.20 的例子中，你向 `Satish` 节点添加了 `Student`
    标签，在接下来的练习中，你将向代表你的节点添加一个适当的标签，例如 `Student`、`Employee` 或其他。在使用多个节点标签时，一个好的指导原则是节点标签应该是语义正交的。*语义正交*
    指的是节点标签不持有相同或相似的意义，并且彼此之间没有任何关系。二级节点标签用于将节点分组到不同的桶中，以便每个子集都易于访问。请注意，单个节点可以有多个二级标签；例如，一个人可以同时被雇佣和上大学。在这种情况下，你可以向它分配
    `Student` 和 `Employee` 标签。然而，出于建模和性能的原因，你应该避免向单个节点添加超过几个节点标签。
- en: In my work, I have also noticed that using multiple labels is helpful in scenarios
    in which you precalculate some values and assign additional node labels based
    on those values. For example, if you work with a customer in a marketing funnel,
    you can add the secondary label to a node according to its funnel stage. Figure
    3.4 shows three `Person` nodes; however, all the nodes have a secondary node label.
    If you had a graph of people on your website, you could use the secondary node
    label to tag their position in the marketing funnel. For example, people who have
    already made the purchase could be tagged with a secondary `Customer` label.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的工作中，我也注意到在以下场景中使用多个标签是有帮助的：你预先计算一些值，并根据这些值分配额外的节点标签。例如，如果你在一个营销漏斗中与客户合作，你可以根据其漏斗阶段向节点添加二级标签。图
    3.4 显示了三个 `Person` 节点；然而，所有节点都有一个二级节点标签。如果你在你的网站上有一个人的图，你可以使用二级节点标签来标记他们在营销漏斗中的位置。例如，已经完成购买的可以标记为二级
    `Customer` 标签。
- en: '![03-04](../../OEBPS/Images/03-04.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![03-04](../../OEBPS/Images/03-04.png)'
- en: Figure 3.4 Using multiple node labels to assign customer funnel stage
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 使用多个节点标签来分配客户漏斗阶段
- en: Exercise 3.8
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.8
- en: Match the `Person` node representing you (i.e., it has your name as the `name`
    property value). Then, add a secondary `Reader` label to it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配代表你的 `Person` 节点（即，它具有你的名字作为 `name` 属性值）。然后，向它添加一个二级 `Reader` 标签。
- en: 3.1.5 REMOVE clause
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.5 REMOVE 子句
- en: The `REMOVE` clause is the opposite of the `SET` clause. It is used to remove
    node labels and node and relationship properties. Removing a node property can
    also be understood as setting its value to `null`. If you want to remove the `hungry`
    property from the `Person` node with the name `Satish`, you can execute the following
    Cypher query.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`REMOVE` 子句是 `SET` 子句的反义。它用于删除节点标签和节点以及关系的属性。删除节点属性也可以理解为将其值设置为 `null`。如果您想从名为
    `Satish` 的 `Person` 节点中删除 `hungry` 属性，您可以执行以下 Cypher 查询。'
- en: Listing 3.21 Cypher statement that removes a node property from an existing
    node in the database
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.21 从数据库中现有节点中删除节点属性的 Cypher 语句
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the `REMOVE` clause, you can also remove labels from existing nodes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `REMOVE` 子句，您还可以从现有节点中删除标签。
- en: Listing 3.22 Cypher statement that removes a node label from an existing node
    in the database
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.22 从数据库中现有节点中删除节点标签的 Cypher 语句
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 3.1.6 DELETE clause
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.6 DELETE 子句
- en: The `DELETE` clause is used to delete nodes and relationships in the database.
    You can first inspect the content of your graph database (if the graph is very
    tiny) with the following Cypher query.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 子句用于在数据库中删除节点和关系。您可以使用以下 Cypher 查询首先检查您的图数据库的内容（如果图非常小）。'
- en: Listing 3.23 Cypher statement that retrieves all nodes and relationships in
    the database
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.23 检索数据库中所有节点和关系的 Cypher 语句
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you run the query in the listing 3.23 in Neo4j Browser, you should get a
    graph visualization similar to the one in figure 3.5.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Neo4j 浏览器中运行列表 3.23 中的查询，您应该得到一个类似于图 3.5 的图可视化。
- en: '![03-05](../../OEBPS/Images/03-05.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![03-05](../../OEBPS/Images/03-05.png)'
- en: Figure 3.5 Visual representation of the current stored graph in the database
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 数据库中当前存储的图的视觉表示
- en: There are currently only a few nodes and relationships in the database, with
    the exact number depending on how many exercises you completed. It is OK if you
    haven’t completed any exercises; however, you need to at least execute the Cypher
    statements in listings 3.3, 3.6, and 3.10 to populate the database with relevant
    data. First, you will delete the relationship between `Person` nodes with the
    `name` properties `Satish` and `Elaine`. To perform a graph pattern deletion,
    you must first use the `MATCH` clause to find the graph pattern and then use the
    `DELETE` clause to delete it from the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前数据库中只有少数节点和关系，确切数量取决于您完成了多少练习。如果您没有完成任何练习，这没关系；然而，您至少需要执行列表 3.3、3.6 和 3.10
    中的 Cypher 语句，以将相关数据填充到数据库中。首先，您将删除具有 `name` 属性 `Satish` 和 `Elaine` 的 `Person`
    节点之间的关系。要执行图模式删除，您必须首先使用 `MATCH` 子句找到图模式，然后使用 `DELETE` 子句将其从数据库中删除。
- en: Listing 3.24 Cypher statement that deletes a relationship between `Person` nodes
    with the `name` properties `Satish` and `Elaine`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.24 删除具有 `name` 属性 `Satish` 和 `Elaine` 的 `Person` 节点之间关系的 Cypher 语句
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In listing 3.24, the `MATCH` clause first matches any relationships directed
    from the `Person` node representing Satish to the node representing Elaine. Notice
    that you didn’t define any relationship type in the `MATCH` clause. When you omit
    the relationship type in the graph pattern description, the `MATCH` clause will
    search for relationships of any type between described nodes. Similarly, you can
    also delete a node from a database, as shown in the following listing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 3.24 中，`MATCH` 子句首先匹配从代表 Satish 的 `Person` 节点指向代表 Elaine 的节点的任何关系。请注意，您在
    `MATCH` 子句中没有定义任何关系类型。当您在图模式描述中省略关系类型时，`MATCH` 子句将在描述的节点之间搜索任何类型的关系。同样，您也可以从数据库中删除节点，如下面的列表所示。
- en: Listing 3.25 Cypher query that deletes a single node from the database
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.25 从数据库中删除单个节点的 Cypher 查询
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, what would happen if you tried to delete the Elaine node from the database?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您尝试从数据库中删除 Elaine 节点，会发生什么？
- en: Listing 3.26 Cypher query that deletes a single node from the database
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.26 从数据库中删除单个节点的 Cypher 查询
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You might wonder why you could delete the node representing Satish but cannot
    delete the node representing Elaine. Luckily, the error, shown in figure 3.6,
    is very descriptive: you cannot delete a node that still has relationships attached
    to it.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么您可以删除代表 Satish 的节点但不能删除代表 Elaine 的节点。幸运的是，图 3.6 中显示的错误信息非常详细：您不能删除仍然有其他节点关系的节点。
- en: '![03-06](../../OEBPS/Images/03-06.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![03-06](../../OEBPS/Images/03-06.png)'
- en: Figure 3.6 An error that occurs when you want to delete a node that has existing
    relationships to other nodes
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 当您想要删除具有与其他节点现有关系的节点时发生的错误
- en: DETACH DELETE clause
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`DETACH DELETE`子句'
- en: As deleting nodes with existing relationships is a frequent procedure, Cypher
    query language provides a `DETACH` `DELETE` clause that first deletes all the
    relationships attached to a node and then deletes the node itself. You can try
    to delete the node representing Elaine with the `DETACH` `DELETE` clause.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于删除具有现有关系的节点是一个常见的操作，Cypher查询语言提供了一个`DETACH DELETE`子句，它首先删除节点上所有附加的关系，然后删除节点本身。你可以尝试使用`DETACH
    DELETE`子句删除代表Elaine的节点。
- en: Listing 3.27 Cypher statement that deletes a single node and all its relationships
    from the database by using the `DETACH DELETE` clause
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.27 使用`DETACH DELETE`子句从数据库中删除单个节点及其所有关系的Cypher语句
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Cypher statement in listing 3.27 deleted both the relationships attached
    to the node as well as the node itself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.27中的Cypher语句删除了节点附加的关系以及节点本身。
- en: Exercise 3.9
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.9
- en: Try to delete the node representing yourself or the node representing a `Person`
    with the name `Michael`. If the given node still has existing relationships, you
    must use the `DETACH` `DELETE` clause to first delete the relationships and then
    delete the node.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试删除代表你自己或代表名为`Michael`的`Person`节点的节点。如果给定的节点仍然存在现有关系，你必须使用`DETACH DELETE`子句先删除关系，然后删除节点。
- en: A Cypher statement that might come in handy when you are toying around with
    a graph database, hopefully not in production, is to delete all the nodes and
    relationships in the database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在图形数据库中玩耍时可能会用到的一个Cypher语句是删除数据库中的所有节点和关系，希望这不是在生产环境中使用。
- en: Listing 3.28 Cypher statement that deletes all the nodes and relationships in
    the database
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.28 删除数据库中所有节点和关系的Cypher语句
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The query in listing 3.28 will first use the `MATCH` clause to find all the
    nodes in the database. As you don’t include any node label in the node description,
    the query engine will return all nodes in the database. With the `DETACH` `DELETE`
    clause, you instruct the query engine first to delete all attached relationships
    to a node and then the node itself. Once the statement is finished, you should
    be left with an empty database.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.28中的查询将首先使用`MATCH`子句在数据库中查找所有节点。由于你未在节点描述中包含任何节点标签，查询引擎将返回数据库中的所有节点。使用`DETACH
    DELETE`子句，你指示查询引擎首先删除节点上所有附加的关系，然后删除节点本身。一旦语句执行完毕，你应该会得到一个空数据库。
- en: 3.1.7 MERGE clause
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.7 `MERGE`子句
- en: In this section, I will assume you are starting with an empty database. If you
    still have data stored inside the database, please run the query in listing 3.28.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将假设你从一个空数据库开始。如果你数据库中仍有数据存储，请运行列表3.28中的查询。
- en: The `MERGE` clause can be understood as a combination of using both the `MATCH`
    and `CREATE` clauses. Using the `MERGE` clause, you instruct the query engine
    first to try to match a given graph pattern, and if it does not exist, it should
    then create the pattern shown in the following listing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE`子句可以理解为`MATCH`和`CREATE`子句的组合使用。使用`MERGE`子句，你指示查询引擎首先尝试匹配给定的图模式，如果不存在，则创建以下列表中显示的模式。'
- en: Listing 3.29 Cypher query that uses the `MERGE` clause to ensure a `Person`
    node with a name `Alicia` exists in the database
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.29 使用`MERGE`子句确保数据库中存在名为`Alicia`的`Person`节点的Cypher查询
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `MERGE` clause only supports inline graph pattern description and cannot
    be used in combination with a `WHERE` clause. The statement in listing 3.29 ensures
    a `Person` node with the `name` property `Alicia` exists in the database. You
    can rerun this query multiple times, and there will always be precisely one `Person`
    node with the name `Alicia` in the database. A statement that can be rerun multiple
    times and always output the same results is also known as an *idempotent* statement.
    When you import data into the graph database, it is advisable to use the `MERGE`
    instead of the `CREATE` clause. Using the `MERGE` clause, you don’t have to worry
    about later deduplication of nodes and can rerun a query several times without
    corrupting your database structure. What do you think will happen if we try to
    use the `MERGE` clause to describe a `Person` node with the name `Alicia` and
    an additional node property location? Let’s examine this in the following listing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE`子句仅支持内联图模式描述，不能与`WHERE`子句结合使用。列表3.29中的语句确保数据库中存在具有`name`属性`Alicia`的`Person`节点。你可以多次运行此查询，数据库中始终只有一个名为`Alicia`的`Person`节点。可以多次运行且始终输出相同结果的语句也称为*幂等*语句。当你将数据导入图数据库时，建议使用`MERGE`子句而不是`CREATE`子句。使用`MERGE`子句，你不必担心后续的节点去重，并且可以多次运行查询而不会破坏你的数据库结构。你认为如果我们尝试使用`MERGE`子句来描述一个名为`Alicia`的`Person`节点以及额外的节点属性位置会发生什么？让我们在下面的列表中检查。'
- en: Listing 3.30 Cypher query merges a single node with two node properties
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.30 Cypher查询合并具有两个节点属性的单一节点
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Exercise 3.10
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.10
- en: Try to match and retrieve all nodes in the database that have a `Person` label
    and a `name` property with value `Alicia`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试匹配和检索数据库中所有具有`Person`标签和`name`属性值为`Alicia`的节点。
- en: By completing exercise 3.10, you can quickly observe that there exist two nodes,
    with the label `Person` and `name` property `Alicia`, in the graph visualization
    shown in figure 3.7.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成练习3.10，你可以快速观察到在图3.7所示的图形可视化中存在两个节点，标签为`Person`，并且具有`name`属性`Alicia`。
- en: '![03-07](../../OEBPS/Images/03-07.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![03-07](../../OEBPS/Images/03-07.png)'
- en: Figure 3.7 Visualization of all the Alicia nodes in the database
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 数据库中所有Alicia节点的可视化
- en: There are two `Person` nodes with the same `name` property in the database.
    Didn’t we just discuss that the `MERGE` clause is idempotent? Remember, the `MERGE`
    clause first tries to match an existing graph pattern, and it only creates the
    full given graph pattern if it does not exist. When you executed the query in
    listing 3.30 to merge a `Person` node with two node properties, the query engine
    first searched for the given pattern. A `Person` node with the `name` property
    `Alicia` and `location` property `Chicago` did not exist in the database at that
    moment. Following the `MERGE` logic, it then created a new `Person` node with
    those two properties.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中有两个具有相同`name`属性的`Person`节点。我们刚才不是讨论了`MERGE`子句是幂等的吗？记住，`MERGE`子句首先尝试匹配现有的图模式，如果不存在，它才创建完整的给定图模式。当你执行列表3.30中的查询以合并具有两个节点属性的`Person`节点时，查询引擎首先搜索给定的模式。在那个时刻，数据库中不存在具有`name`属性`Alicia`和`location`属性`Chicago`的`Person`节点。遵循`MERGE`逻辑，然后它创建了一个具有这两个属性的新`Person`节点。
- en: When designing a graph model, the best practice is to define a unique identifier
    for each node label. A unique identifier consists of defining a unique property
    value for each node in the graph. For example, if you assumed that the `name`
    property of the `Person` nodes is unique, you could use the following `MERGE`
    clause to import `Person` nodes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计图模型时，最佳实践是为每个节点标签定义一个唯一标识符。唯一标识符包括为图中的每个节点定义一个唯一的属性值。例如，如果你假设`Person`节点的`name`属性是唯一的，你可以使用以下`MERGE`子句来导入`Person`节点。
- en: Listing 3.31 Cypher query that merges a node on its unique identifier property
    and then adds additional properties to the node
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.31 Cypher查询在唯一标识符属性上合并节点，然后向节点添加额外的属性
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A `MERGE` clause can be followed by an optional `ON` `CREATE` `SET` and `ON`
    `MATCH` `SET`. In the `MERGE` clause, you used the unique identifier of nodes
    to merge the nodes. If the node is created during this query, you can define additional
    node properties that should be set with the `ON` `CREATE` `SET` clause. Conversely,
    if the node with the label `Person` and the `name` property `Amy` already existed
    in the database, then the `ON` `MATCH` `SET` clause will be invoked.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE`子句后面可以跟一个可选的`ON` `CREATE` `SET`和`ON` `MATCH` `SET`。在`MERGE`子句中，你使用节点的唯一标识符来合并节点。如果在查询过程中创建了节点，你可以使用`ON`
    `CREATE` `SET`子句定义应该设置的额外节点属性。相反，如果具有`Person`标签和`name`属性`Amy`的节点已经在数据库中存在，那么将调用`ON`
    `MATCH` `SET`子句。'
- en: The Cypher statement in listing 3.31 will first merge a `Person` node with the
    `name` property `Amy`. If a node with a label `Person` and the `name` property
    `Amy` does not exist in the database already, then the `MERGE` clause will create
    one and invoke the `ON` `CREATE` `SET` clause to set the `location` and `createdAt`
    properties on the node. Suppose the mentioned node already exists in the database.
    In that case, the query engine will not create any new nodes, and it will only
    update the `updatedAt` node property with the current time as described in the
    `ON` `MATCH` `SET` clause. The `datetime()` function in Cypher returns the current
    time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.31中的Cypher语句将首先合并一个具有`name`属性`Amy`的`Person`节点。如果数据库中不存在具有`Person`标签和`name`属性`Amy`的节点，则`MERGE`子句将创建一个节点并调用`ON`
    `CREATE` `SET`子句来设置节点上的`location`和`createdAt`属性。假设提到的节点已经在数据库中存在。在这种情况下，查询引擎不会创建任何新节点，它只会更新`updatedAt`节点属性，如`ON`
    `MATCH` `SET`子句中所述，将当前时间作为时间。Cypher中的`datetime()`函数返回当前时间。
- en: Very frequently, your import query will look like the following listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 非常频繁地，你的导入查询看起来会像以下列表。
- en: Listing 3.32 Cypher query that merges two nodes and then merges a relationship
    between them
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.32：合并两个节点并在它们之间合并关系的Cypher查询
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The most frequent Cypher structure when importing data into Neo4j is first
    to merge the nodes separately and then merge any relationships between them. Using
    the `MERGE` clause, you don’t have to worry about data duplication or multiple
    query executions. The statement in listing 3.32 ensures there are three graph
    patterns in the database: two nodes describing Jane and Samay and a `FRIEND` relationship
    existing between them. You can rerun this query multiple times, and the output
    will always be the same.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当将数据导入Neo4j时，最频繁使用的Cypher结构是首先分别合并节点，然后合并它们之间的任何关系。使用`MERGE`子句，你不必担心数据重复或多次查询执行。列表3.32中的语句确保数据库中有三个图模式：两个描述Jane和Samay的节点以及它们之间存在的`FRIEND`关系。你可以多次运行此查询，输出始终相同。
- en: The `MERGE` clause also supports merging an undirected relationship. The fact
    that you can omit the relation direction in the `MERGE` clause might be a bit
    confusing. At the beginning of the chapter, I mentioned you can only store a directed
    relationship in the Neo4j database. Let’s see what happens if you run the following
    query.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERGE`子句还支持合并无向关系。你可以在`MERGE`子句中省略关系方向的事实可能会有些令人困惑。在章节的开头，我提到你只能在Neo4j数据库中存储有向关系。让我们看看如果你运行以下查询会发生什么。'
- en: Listing 3.33 Cypher query that merges two nodes and then merges an undirected
    relationship between them
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.33：合并两个节点并在它们之间合并无向关系的Cypher查询
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can observe that two new `Person` nodes were created. When you describe
    an undirected relationship in the `MERGE` clause, the query engine first tries
    to match the relationship while ignoring the direction. Practically, it searches
    for a relationship in both directions. If there are no relationships between the
    nodes in any direction, it then creates a new relationship with an arbitrary direction.
    Having the ability to describe an undirected relationship in the `MERGE` clause
    allows us to import undirected networks more conveniently. If you assume the `FRIEND`
    relationship is undirected—meaning that if Alex is friends with Andrea, then Andrea
    is also friends with Alex—then you should store only a single directed relationship
    between them and treat it as undirected when you are executing graph algorithms
    or queries. You will learn more about this approach in the following chapters.
    For now, it is enough that you are aware that it is possible to describe an undirected
    relationship in the `MERGE` clause.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到创建了两个新的 `Person` 节点。当你使用 `MERGE` 子句描述无向关系时，查询引擎首先尝试匹配关系，而忽略方向。实际上，它在两个方向上搜索关系。如果在任何方向上节点之间没有关系，它就会创建一个新的具有任意方向的关系。能够在
    `MERGE` 子句中描述无向关系，使我们能够更方便地导入无向网络。如果你假设 `FRIEND` 关系是无向的——这意味着如果 Alex 和 Andrea
    是朋友，那么 Andrea 也和 Alex 是朋友——那么你应该只存储他们之间的一条有向关系，并在执行图算法或查询时将其视为无向。你将在接下来的章节中了解更多关于这种方法的信息。现在，你只需要知道，在
    `MERGE` 子句中描述无向关系是可能的。
- en: Note When creating or importing data to Neo4j, you typically want to split a
    Cypher statement into multiple `MERGE` clauses and merge nodes and relationships
    separately to enhance performance. When merging nodes, the best approach is to
    include only the node’s unique identifier property in the `MERGE` clause and add
    additional node properties with the `ON` `MATCH` `SET` or `ON` `CREATE` `SET`
    clauses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在创建或导入数据到 Neo4j 时，通常希望将 Cypher 语句拆分为多个 `MERGE` 子句，并分别合并节点和关系以提高性能。在合并节点时，最佳做法是在
    `MERGE` 子句中仅包含节点的唯一标识符属性，并使用 `ON MATCH SET` 或 `ON CREATE SET` 子句添加额外的节点属性。
- en: Handling relationships is a bit different. If there can be at most a single
    relationship of one type between two nodes, like in the `FRIEND` example, then
    do not include any relationship properties in the `MERGE` clause. Instead, use
    the `ON` `CREATE` `SET` or `ON` `MATCH` `SET` clauses to set any relationship
    properties. However, if your graph model contains multiple relationships of the
    same type between a pair of nodes, then use only the unique identifier property
    of the relationship in the `MERGE` statement and set any additional properties
    the same as previously discussed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 处理关系略有不同。如果两个节点之间最多只有一个类型的关系，例如在 `FRIEND` 示例中，那么不要在 `MERGE` 子句中包含任何关系属性。相反，使用
    `ON CREATE SET` 或 `ON MATCH SET` 子句来设置任何关系属性。然而，如果你的图模型在节点对之间包含多个相同类型的关系，那么在 `MERGE`
    语句中仅使用关系的唯一标识符属性，并设置任何附加属性，如之前讨论的那样。
- en: 3.2 Importing CSV files with Cypher
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 使用 Cypher 导入 CSV 文件
- en: You have learned the basic Cypher clauses that will help you get started. Now,
    you will learn how to import data from external sources. Two frequent input data
    structures for a graph database are the CSV and JSON formats. In this chapter,
    you will learn how to import the CSV-like data structure. Interestingly, dealing
    with CSV files and importing data from a relational database is almost identical.
    In both scenarios, you are dealing with a table that has, hopefully, named columns.
    In this section, you will define unique constraints and import a Twitter dataset
    into a Neo4j graph database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了基本的 Cypher 子句，这将帮助你开始。现在，你将学习如何从外部源导入数据。图数据库的两种常见输入数据结构是 CSV 和 JSON 格式。在本章中，你将学习如何导入类似
    CSV 的数据结构。有趣的是，处理 CSV 文件和从关系型数据库导入数据几乎相同。在这两种情况下，你都在处理一个希望有命名字段的表。在本节中，你将定义唯一约束并将
    Twitter 数据集导入到 Neo4j 图数据库中。
- en: 3.2.1 Clean up the database
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 清理数据库
- en: You need to empty the database before continuing, as you don’t want random nodes
    from the previous examples to persist.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要清空数据库，因为你不想保留之前示例中的随机节点。
- en: Listing 3.34 Cypher query that deletes all the nodes and relationships in the
    database
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.34 删除数据库中所有节点和关系的 Cypher 查询
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 3.2.2 Twitter graph model
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 Twitter 图模型
- en: In the previous chapter, you went through a graph model design process and developed
    the graph model shown in figure 3.8\. There were no data limitations; you just
    assumed you could get any relevant data. Like anything in life, you can’t always
    get exactly what you asked for, but there might be some additional data that wasn’t
    previously considered.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你经历了一个图模型设计过程，并开发了图3.8所示的图模型。没有数据限制；你只是假设你可以获取任何相关数据。就像生活中的任何事物一样，你不可能总是得到你想要的，但可能会有一些之前未考虑到的额外数据。
- en: '![03-08](../../OEBPS/Images/03-08.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![03-08](../../OEBPS/Images/03-08.png)'
- en: Figure 3.8 Initial Twitter graph model you will import
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 初始Twitter图模型，你将导入
- en: You will start by importing the follower network between users. There was a
    `since` property of the `FOLLOWS` relationship in the initial graph model. Unfortunately,
    the Twitter API doesn’t provide the date of creating the `FOLLOWS` relationship,
    so you will have to remove it from the model. See the reference for the Twitter
    API `FOLLOWS` endpoint ([http://mng.bz/W1PW](http://mng.bz/W1PW)) for more information.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先导入用户之间的关注网络。在初始图模型中，`FOLLOWS`关系有一个`since`属性。不幸的是，Twitter API不提供`FOLLOWS`关系的创建日期，所以你将不得不从模型中移除它。有关Twitter
    API `FOLLOWS`端点的更多信息，请参阅参考（[http://mng.bz/W1PW](http://mng.bz/W1PW)）。
- en: There may be a discrepancy between the initial graph modeling design and the
    provided data if you made some assumptions that later didn’t hold up. That is
    why the graph modeling process is iterative. You start with some assumptions and
    change the graph model accordingly as you learn more. On the other hand, the assumption
    that there can only be a single author of a given tweet turns out to be valid.
    And you did not consider that a user can also reply to a given tweet and not just
    retweet it. The graph model has been updated to support storing the information
    when a tweet was made in response to another tweet by adding an `IN_REPLY_TO`
    relationship. It is also important to note the difference between just retweeting
    a post and adding a comment to the retweet. The Twitter interface allows you to
    add a comment to the retweet via a quote tweet (figure 3.9).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你后来发现一些假设并不成立，那么初始的图模型设计和提供的数据之间可能会有差异。这就是为什么图模型过程是迭代的。你开始时有一些假设，随着你获得更多信息，相应地改变图模型。另一方面，一个推文只能有一个作者的假设最终被证明是有效的。你没有考虑到一个用户也可以对某个推文进行回复，而不仅仅是转发。图模型已经更新，通过添加`IN_REPLY_TO`关系来支持存储推文是对另一个推文进行回复的信息。还应注意仅转发帖子与对转发添加评论之间的区别。Twitter界面允许你通过引用推文（图3.9）来对转发添加评论。
- en: '![03-09](../../OEBPS/Images/03-09.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![03-09](../../OEBPS/Images/03-09.png)'
- en: Figure 3.9 Add a comment to the retweet via a quote tweet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 通过引用推文添加对转发的评论。
- en: Because adding a comment has different semantics than just retweeting a post,
    it is important to differentiate between the two scenarios by using different
    relationship types, as shown in figure 3.10.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加评论与仅转发帖子具有不同的语义，因此通过使用不同的关系类型来区分这两种情况是很重要的，如图3.10所示。
- en: '![03-10](../../OEBPS/Images/03-10.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![03-10](../../OEBPS/Images/03-10.png)'
- en: Figure 3.10 Differentiating between retweets and quotes by using different relationship
    types
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 通过不同的关系类型区分转发和引用
- en: By clearly differentiating between retweets and quotes, it will be easier for
    you to find quotes in the graph and analyze their responses. For example, you
    could use NLP techniques to detect the sentiment of the comments and examine which
    tweets or users are most likely to receive comments with positive or negative
    sentiment. Unfortunately, while I was thinking of including them in our graph
    import, I did not fetch any quote tweets during my scraping process, so we will
    skip importing and analyzing them. In the initial import, you will also ignore
    the hashtags, mentions, and links of a tweet.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确区分转发和引用，你将更容易在图表中找到引用内容并分析它们的回应。例如，你可以使用自然语言处理技术来检测评论的情感，并检查哪些推文或用户最有可能收到带有积极或消极情感的评论。不幸的是，当我考虑将它们包含在我们的图表导入中时，我在抓取过程中没有获取任何引用推文，所以我们将跳过导入和分析它们。在初始导入中，你也将忽略推文的标签、提及和链接。
- en: 3.2.3 Unique constraints
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 唯一约束
- en: The Neo4j graph database model is considered *schemaless*, meaning you can add
    any type of nodes and relationships without defining the graph schema model. There
    are, however, some constraints you can add to your graph model to ensure data
    integrity. In my graph journey, I have only used the *unique node property constraint*
    so far. There are two benefits of using the unique node property constraint. The
    first is that it ensures the value of a given node property is unique for all
    the nodes with a specific label. For a beginner, this feature is handy, as it
    informs you and stops an import query that would corrupt data integrity. An additional
    benefit of defining a unique node constraint is that it automatically creates
    an index on the specified node property. By creating an index on the specified
    node property, you will optimize the performance of import and analytical Cypher
    queries. You can think of unique constraints as a concept similar to primary keys
    in relational databases, although the difference is that Neo4j’s unique constraint
    allows null values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j图形数据库模型被认为是无模式的，这意味着你可以在不定义图形模式模型的情况下添加任何类型的节点和关系。然而，你可以在你的图形模型中添加一些约束来确保数据完整性。在我的图形之旅中，我迄今为止只使用了*唯一节点属性约束*。使用唯一节点属性约束有两个好处。第一个好处是它确保给定节点属性值对于具有特定标签的所有节点都是唯一的。对于初学者来说，这个特性很有用，因为它会通知你并阻止可能破坏数据完整性的导入查询。定义唯一节点约束的另一个好处是它会自动在指定的节点属性上创建索引。通过在指定的节点属性上创建索引，你可以优化导入和分析Cypher查询的性能。你可以将唯一约束视为类似于关系数据库中的主键的概念，尽管不同之处在于Neo4j的唯一约束允许空值。
- en: For the initial import, you will define two unique node constraints. One unique
    constraint will ensure there can only be a single `User` node with a specific
    `id` property in the database. The second unique constraint guarantees the `id`
    property of nodes with label `Tweet` will be unique for each node.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初始导入，你将定义两个唯一的节点约束。一个唯一约束将确保数据库中只能有一个具有特定`id`属性的`User`节点。第二个唯一约束保证具有`Tweet`标签的节点的`id`属性对于每个节点都是唯一的。
- en: Listing 3.35 Cypher query that defines two unique node constraints
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.35：定义两个唯一节点约束的Cypher查询
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 3.2.4 LOAD CSV clause
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 `LOAD CSV`子句
- en: The Cypher query language has a `LOAD` `CSV` clause that enables you to open
    and retrieve information from CSV files. The `LOAD` `CSV` clause can fetch local
    CSV files as well as CSV files from the internet. Having the ability to fetch
    CSV files from the internet comes in very handy, as you don’t have to download
    the CSV files to your local computer first. I have stored all the relevant CSV
    files on GitHub ([https://github.com/tomasonjo/graphs-network-science](https://github.com/tomasonjo/graphs-network-science))
    for easier access. The `LOAD` `CSV` clause can load CSV files whether or not they
    contain a header. If the header is present, each row of the CSV file will be available
    as a map data structure that can be used later in the query. Conversely, when
    there is no header present, the rows will be available as lists. The `LOAD` `CSV`
    clause can also be used in combination with a `FIELDTERMINATOR` clause to set
    a custom delimiter, where you are, for example, dealing with a tab-separated value
    format.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher查询语言有一个`LOAD` `CSV`子句，它允许你打开并从CSV文件中检索信息。`LOAD` `CSV`子句可以检索本地CSV文件以及来自互联网的CSV文件。能够从互联网上检索CSV文件非常有用，因为你不必首先将CSV文件下载到你的本地计算机。我已经将所有相关的CSV文件存储在GitHub上（[https://github.com/tomasonjo/graphs-network-science](https://github.com/tomasonjo/graphs-network-science)），以便更容易访问。`LOAD`
    `CSV`子句可以加载包含或不包含标题的CSV文件。如果存在标题，CSV文件的每一行都将作为可以用于后续查询的映射数据结构可用。相反，当没有标题时，行将作为列表可用。`LOAD`
    `CSV`子句还可以与`FIELDTERMINATOR`子句结合使用，以设置自定义的分隔符，例如，当你处理制表符分隔值格式时。
- en: To retrieve information from a specific CSV file, you can use the following
    query.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要从特定的CSV文件中检索信息，你可以使用以下查询。
- en: Listing 3.36 Cypher query that fetches and displays information from a CSV file
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.36：从CSV文件中检索并显示信息的Cypher查询
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The CSV file must be publicly accessible, as the `LOAD` `CSV` clause does not
    feature any authorization support. The statement in listing 3.36 also uses the
    `LIMIT` clause. As mentioned, the `LIMIT` clause is used to limit the number of
    results you want to retrieve.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件必须是公开可访问的，因为`LOAD` `CSV`子句不支持任何授权支持。列表3.36中的语句也使用了`LIMIT`子句。正如提到的，`LIMIT`子句用于限制你想要检索的结果数量。
- en: It is important to note that the `LOAD` `CSV` clause returns all values as strings
    and makes no attempt to identify data types. You must convert the values to the
    correct data type in your Cypher import statements.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`LOAD` `CSV`子句将所有值作为字符串返回，并且不尝试识别数据类型。您必须在Cypher导入语句中将值转换为正确的数据类型。
- en: 3.2.5 Importing the Twitter social network
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 导入Twitter社交网络
- en: 'I have prepared five CSV files that contain the following information:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经准备了五个包含以下信息的CSV文件：
- en: User information
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户信息
- en: Follower network
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注者网络
- en: Information about tweets and their authors
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于推文及其作者的信息
- en: Information about the `MENTIONS` relationships between posts and users
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于帖子与用户之间的`MENTIONS`关系信息
- en: Information about the `RETWEETS` relationships between posts
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于帖子之间的`RETWEETS`关系信息
- en: Information about the `IN_REPLY_TO` relationships between posts
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于帖子之间的`IN_REPLY_TO`关系信息
- en: It is a good practice to split the graph import into multiple statements; I
    could have probably prepared a single CSV file with all the relevant information.
    Still, it makes more sense to split the import into multiple statements for better
    readability and faster import performance. If you are dealing with graphs with
    millions of nodes, then it is advisable to split the import of nodes and relationships.
    In this case, you are dealing with only thousands of nodes, so you don’t have
    to worry about query optimization that much. My general rule of thumb is to split
    the import queries by node labels and relationship types as much as possible.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将图导入拆分为多个语句是一个好习惯；我可能已经准备了一个包含所有相关信息的单个CSV文件。然而，将导入拆分为多个语句以提高可读性和导入性能更有意义。如果您处理的是包含数百万个节点的图，那么建议拆分节点和关系的导入。在这种情况下，您只处理数千个节点，因此不必过多担心查询优化。我的经验法则是尽可能按节点标签和关系类型拆分导入查询。
- en: To begin with, you will import user information into Neo4j. As mentioned, all
    the data is publicly available on GitHub, so there is no need to download any
    files. The CSV structure for user information has the structure shown in table
    3.1.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将导入用户信息到Neo4j中。正如所述，所有数据都在GitHub上公开可用，因此不需要下载任何文件。用户信息的CSV结构如表3.1所示。
- en: Table 3.1 User CSV structure
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 用户CSV结构
- en: '| `id` | `name` | `username` | `createdAt` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `name` | `username` | `createdAt` |'
- en: '| 333011425 | ADEYEMO ADEKUNLE King | ADEYEMOADEKUNL2 | 2011-07-10T20:36:58
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 333011425 | ADEYEMO ADEKUNLE King | ADEYEMOADEKUNL2 | 2011-07-10T20:36:58
    |'
- en: '| 1355257214529892352 | Wajdi Alkayal | WajdiAlkayal | 2021-01-29T20:51:28
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 1355257214529892352 | Wajdi Alkayal | WajdiAlkayal | 2021-01-29T20:51:28
    |'
- en: '| 171172327 | NLP Excellence | excellenceNLP | 2010-07-26T18:48:47 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 171172327 | NLP Excellence | excellenceNLP | 2021-01-29T20:51:28 |'
- en: You can use the following Cypher statement to import user information into the
    Neo4j database.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下Cypher语句将用户信息导入Neo4j数据库。
- en: Listing 3.37 Cypher query that imports user information from a CSV file
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.37 从CSV文件导入用户信息的Cypher查询
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You could have used the `CREATE` clause to import user information. If you started
    with an empty database and trust that I have prepared a CSV file without duplicates,
    the result would be identical.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您本可以使用`CREATE`子句来导入用户信息。如果您从一个空数据库开始，并且信任我已经准备了一个没有重复的CSV文件，那么结果将是相同的。
- en: Dealing with real-world datasets, you often can’t afford the luxury of assuming
    you have clean data present. Hence, it makes sense to write Cypher statements
    that can handle duplicates or other anomalies and are also idempotent. In the
    Cypher statement in listing 3.37, the `LOAD` `CSV` clause first fetches the CSV
    information from the GitHub repository. `LOAD` `CSV` then iterates over every
    row in the file and executes the Cypher statement that follows. In this example,
    it executes the `MERGE` clause in combination with `ON` `CREATE` `SET` for every
    row in the CSV file.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理现实世界的数据集时，您通常无法承担假设数据是干净的这个奢侈。因此，编写可以处理重复或其他异常并且也是幂等的Cypher语句是有意义的。在列表3.37中的Cypher语句中，`LOAD`
    `CSV`子句首先从GitHub仓库中获取CSV信息。然后`LOAD` `CSV`遍历文件中的每一行并执行随后的Cypher语句。在这个例子中，它对CSV文件中的每一行执行`MERGE`子句与`ON`
    `CREATE` `SET`的组合。
- en: Exercise 3.11
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.11
- en: Retrieve five random users from the database to inspect the results and validate
    that the import process of users worked correctly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中检索五个随机用户以检查结果并验证用户导入过程是否正确。
- en: Currently, you only have nodes without any relationships in the database; you
    will continue by importing `FOLLOWS` relationships between users. The CSV file
    that contains the information about the followers has the structure shown in table
    3.2.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，数据库中只有没有任何关系的节点；您将继续导入用户之间的`FOLLOWS`关系。包含关注者信息的CSV文件的结构如表3.2所示。
- en: Table 3.2 Follower’s CSV structure
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 关注者CSV结构
- en: '| `source` | `target` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `source` | `target` |'
- en: '| 14847675 | 1355257214529892352 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 14847675 | 1355257214529892352 |'
- en: '| 1342812984234680320 | 1355257214529892352 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 1342812984234680320 | 1355257214529892352 |'
- en: '| 1398820162732793859 | 1355257214529892352 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 1398820162732793859 | 1355257214529892352 |'
- en: The followers’ CSV file has only two columns. The source column describes the
    start node ID, and the target column describes the end node ID of the follower
    relationships. When dealing with larger CSV files, you can use the `IN` `TRANSACTIONS`
    clause in combination with a Cypher subquery to split the import into several
    transactions, where *x* represents the batch size. Splitting the import into several
    transactions can spare you the headache of running out of memory when doing large
    imports. The follower’s CSV has almost 25,000 rows. By default, the `IN` `TRANSACTIONS`
    clause will split the transaction for every 1,000 rows. Instead of importing the
    whole CSV file in a single transaction, you should use the transaction batching
    clause in combination with a Cypher subquery to, effectively, split it into 25
    transactions. For some reason, you need to prepend `:auto` when using transaction
    batching in Neo4j Browser. In other cases (e.g., when using a Neo4j Python driver
    to import the data), you don’t need to prepend the `:auto` operator, as shown
    in the following listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关注者的CSV文件只有两列。源列描述起始节点ID，目标列描述关注者关系的终点节点ID。在处理较大的CSV文件时，您可以使用`IN TRANSACTIONS`子句与Cypher子查询结合，将导入分成几个事务，其中*x*代表批量大小。将导入分成几个事务可以避免在执行大型导入时耗尽内存的烦恼。关注者的CSV文件有近25,000行。默认情况下，`IN
    TRANSACTIONS`子句将每1,000行分割一个事务。您应该使用事务批量子句与Cypher子查询结合，有效地将其分成25个事务。由于某种原因，在Neo4j浏览器中使用事务批量时需要预先添加`:auto`。在其他情况下（例如，使用Neo4j
    Python驱动程序导入数据时），您不需要预先添加`:auto`运算符，如下面的列表所示。
- en: Listing 3.38 Cypher query that imports the follower network from a CSV file
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.38 从CSV文件导入关注者网络的Cypher查询
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Prepends the :auto operator and uses the LOAD CSV clause, as usual
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预先添加`:auto`运算符并使用LOAD CSV子句，如常操作
- en: ❷ Starts a Cypher subquery using the CALL clause
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用CALL子句启动Cypher子查询
- en: ❸ To use any variables from the enclosing query, you need to explicitly import
    them using a WITH clause.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 要使用封装查询中的任何变量，您需要使用WITH子句显式导入它们。
- en: ❹ Matches start and source users
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 匹配起始用户和源用户
- en: ❺ Merges a relationship between source and target users
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 合并源用户和目标用户之间的关系
- en: ❻ The IN TRANSACTIONS clause indicates the subquery should be batched into single
    transactions for every 1,000 rows.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ `IN TRANSACTIONS`子句表示子查询应每1,000行批量成单个事务。
- en: The statement in listing 3.38 first retrieves the information from a CSV file
    located on GitHub. To define that the import should be split into multiple transactions,
    use the `CALL` `{}` clause to define a Cypher subquery that has the `IN` `TRANSACTIONS`
    clause appended. Any variables used in a Cypher subquery from the enclosing query
    must be explicitly defined and imported using the `WITH` clause. The query steps
    in the Cypher subquery will be executed for every row in the CSV file. For each
    row, it matches the source and the target `User` node. Here, you assume all the
    `User` nodes are already present in the database. Remember, if the `MATCH` clause
    does not find a pattern, it skips the execution of the rest of the query for a
    specific row.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.38中的语句首先从GitHub上的CSV文件检索信息。要定义导入应分成多个事务，请使用`CALL` `{}`子句定义一个带有附加`IN TRANSACTIONS`子句的Cypher子查询。在封装查询中使用的任何变量都必须显式定义并使用`WITH`子句导入。Cypher子查询中的查询步骤将为CSV文件中的每一行执行。对于每一行，它将匹配源和目标`User`节点。在这里，您假设所有`User`节点已经存在于数据库中。记住，如果`MATCH`子句找不到模式，它将跳过特定行的查询的其余部分执行。
- en: 'In the statement in listing 3.38, if, for example, a source node was not found
    by the `MATCH` clause, the Cypher query would skip the creation of the `FOLLOWS`
    relationship. You could avoid this limitation by using the `MERGE` clause instead
    of the `MATCH` clause to identify the source and target `User` nodes. There is,
    however, a drawback: any node created by the `MERGE` clause in listing 3.38 would
    have only the `id` property and no other information, as they were missing from
    the CSV file containing user information.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表3.38中的语句中，例如，如果`MATCH`子句未找到源节点，Cypher查询将跳过创建`FOLLOWS`关系。你可以通过使用`MERGE`子句而不是`MATCH`子句来识别源和目标`User`节点来避免这种限制。然而，有一个缺点：列表3.38中由`MERGE`子句创建的任何节点都只有`id`属性，没有其他信息，因为它们来自包含用户信息的CSV文件中缺失。
- en: Once both the source and the target nodes are identified, the query merges a
    `FOLLOWS` relationship between them. Using the `MERGE` clause, you ensure there
    will be exactly one `FOLLOWS` relationship from the source to the target `User`
    node in the database. This way, you don’t have to worry about having duplicates
    in the input CSV file or rerunning the query multiple times. Another critical
    consideration is that the direction of the `FOLLOWS` relationship in the Twitter
    domain has a semantic value. For example, if user A follows user B, that does
    not imply that user B follows user A. For this reason, you need to add the relationship
    direction indicator in the `MERGE` clause to ensure the relationship is imported
    correctly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了源节点和目标节点，查询将合并它们之间的`FOLLOWS`关系。使用`MERGE`子句，你确保数据库中从源到目标`User`节点的`FOLLOWS`关系恰好只有一个。这样，你就不必担心输入CSV文件中的重复或多次运行查询。另一个关键考虑因素是Twitter域中`FOLLOWS`关系的方向具有语义值。例如，如果用户A关注用户B，这并不意味着用户B也关注用户A。因此，你需要在`MERGE`子句中添加关系方向指示符，以确保正确导入关系。
- en: Note When you are using the `MATCH` clause to identify nodes in Cypher import
    queries, be aware that no additional nodes will be created during the import.
    Therefore, all the relationships between nodes that do not exist in the database
    will also be skipped during the import process.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你使用`MATCH`子句在Cypher导入查询中识别节点时，请注意，在导入过程中不会创建任何额外的节点。因此，在导入过程中也会跳过数据库中不存在的节点之间的关系。
- en: Exercise 3.12
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.12
- en: Retrieve five `FOLLOWS` relationships from the database to validate the import
    process.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中检索五个`FOLLOWS`关系以验证导入过程。
- en: Next, you will import the tweets and their authors. The CSV structure of the
    tweets is as shown in table 3.3.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将导入推文及其作者。推文的CSV结构如表3.3所示。
- en: Table 3.3 Twitter posts CSV structure
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3 Twitter帖子CSV结构
- en: '| `id` | `text` | `createdAt` | `author` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `text` | `createdAt` | `author` |'
- en: '| 12345 | Example text | 2021-06-01T08:53:22 | 134281298 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 12345 | 示例文本 | 2021-06-01T08:53:22 | 134281298 |'
- en: '| 1399649667567 | Graph data science is cool! | 2021-06-01T08:53:18 | 54353345
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 1399649667567 | 图数据科学很酷！ | 2021-06-01T08:53:18 | 54353345 |'
- en: '| 13996423457567 | Exploring social networks | 2021-06-01T08:45:23 | 4324323
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 13996423457567 | 探索社交网络 | 2021-06-01T08:45:23 | 4324323 |'
- en: The `id` column of the Tweets CSV file describes the Twitter post ID that will
    be used as the unique identifier. The file also includes the text and the date
    of creation as well as the ID of the author. There are 12,000 rows in the CSV
    file, so you will again use the `CALL` `{}` clause in combination with the `IN`
    `TRANSACTIONS` clause for batching purposes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Tweets CSV文件的`id`列描述了将用作唯一标识符的Twitter帖子ID。该文件还包括文本、创建日期以及作者ID。CSV文件中有12,000行，因此你将再次使用`CALL`
    `{}`子句与`IN` `TRANSACTIONS`子句结合用于批量处理。
- en: Listing 3.39 Cypher query that imports tweets from a CSV file
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.39从CSV文件导入推文的Cypher查询
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Starts a Cypher subquery with a CALL clause
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用CALL子句开始Cypher子查询
- en: ❷ Imports the row variable explicitly in the WITH clause
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在WITH子句中显式导入行变量
- en: ❸ Matches author User node
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 匹配作者用户节点
- en: ❹ Merges Tweet node and sets additional properties
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 合并推文节点并设置其他属性
- en: ❺ Merges a relationship between a user and a tweet
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 合并用户与推文之间的关系
- en: ❻ Uses the IN TRANSACTIONS clause to indicate transaction batching
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用`IN TRANSACTIONS`子句来指示事务批量处理
- en: If you look closely, you can observe that the query structure in listing 3.39
    is similar to the query in listing 3.38\. When you are importing any relationship
    into the database, you will most likely match or merge both source and target
    nodes and then connect them. In the first step, the query matches on the `User`
    node. Next, you use the `MERGE` clause to create the `Tweet` nodes. Although all
    the `Tweet` nodes need to be created, as there are none in the database beforehand,
    I still like to use the `MERGE` clause to have idempotent queries. It is the best
    experience for you as a user, and it is an excellent practice to follow. Finally,
    a relationship between the user and the tweet is created.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现列表3.39中的查询结构与列表3.38中的查询相似。当你将任何关系导入数据库时，你很可能会匹配或合并源节点和目标节点，然后将它们连接起来。在第一步中，查询匹配`User`节点。接下来，你使用`MERGE`子句创建`Tweet`节点。尽管所有`Tweet`节点都需要创建，因为数据库中事先没有这些节点，但我仍然喜欢使用`MERGE`子句来保持查询的幂等性。这对用户来说是最好的体验，并且是一种优秀的实践。最后，创建用户和推文之间的关系。
- en: Exercise 3.13
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.13
- en: To validate the import process, retrieve the `text` property of three random
    `Tweet` nodes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证导入过程，检索三个随机`Tweet`节点的`text`属性。
- en: Now that you have both tweets and users in the database, you can import `MENTIONS`
    relationships between a tweet and user. The `MENTIONS` relationship indicates
    a user has tagged another user in their post. The CSV containing this information
    has the structure shown in table 3.4.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将推文和用户导入数据库，你可以导入推文和用户之间的`MENTIONS`关系。`MENTIONS`关系表示用户在其帖子中标记了另一个用户。包含此信息的CSV文件的结构如表3.4所示。
- en: Table 3.4 Mentions CSV structure
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4 Mentions CSV结构
- en: '| `post` | `user` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `post` | `user` |'
- en: '| 333011425 | 134281298 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 333011425 | 134281298 |'
- en: '| 1355257214529892352 | 54353345 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 1355257214529892352 | 54353345 |'
- en: '| 171172327 | 4324323 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 171172327 | 4324323 |'
- en: The import query is relatively simple. First, use the `MATCH` clause to identify
    the tweet and the mentioned user, and then `MERGE` a relationship between them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 导入查询相对简单。首先，使用`MATCH`子句识别推文和提到的用户，然后`MERGE`它们之间的关系。
- en: Listing 3.40 Cypher query that imports `MENTIONS` relationships from a CSV file
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.40 从CSV文件导入`MENTIONS`关系的Cypher查询
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Matches the Tweet node
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配推文节点
- en: ❷ Matches the mentioned User node
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 匹配提到的用户节点
- en: ❸ Merges a relationship between a tweet and a user
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 合并推文与用户之间的关系
- en: In the last two import queries, you will import additional `RETWEETS` and `IN_REPLY_OF`
    relationships. Both the Retweets and In Reply To CSV files have the same structure,
    as shown in table 3.5
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个导入查询中，你将导入额外的`RETWEETS`和`IN_REPLY_OF`关系。这两个CSV文件的结构相同，如表3.5所示。
- en: Table 3.5 Retweets and In Reply To CSV file structure
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5 Retweets和In Reply To CSV文件结构
- en: '| `source` | `target` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `source` | `target` |'
- en: '| 14847675 | 1355257214529892352 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 14847675 | 1355257214529892352 |'
- en: '| 1342812984234680320 | 1355257214529892352 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 1342812984234680320 | 1355257214529892352 |'
- en: '| 1398820162732793859 | 1355257214529892352 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 1398820162732793859 | 1355257214529892352 |'
- en: Begin by importing the `RETWEETS` relationship, as in listing 3.41.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`RETWEETS`关系，如列表3.41所示。
- en: Listing 3.41 Cypher query that imports retweets relationships from a CSV file
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.41 从CSV文件导入推文关系的Cypher查询
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Matches the source tweet
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配源推文
- en: ❷ Matches the target tweet
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 匹配目标推文
- en: ❸ Merges a retweet relationship between source and target tweets
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 合并源推文和目标推文之间的推文关系
- en: The query structure to add relationships to a database mostly identifies the
    source and target nodes and then adds a connection between the two. You must take
    special care in determining whether to use `MATCH` or `MERGE` to identify nodes.
    If you use the `MATCH` clause, then no new nodes will be created, so any relationships
    that don’t have both the source and target nodes already in the database will
    be ignored during the import. On the other hand, if you use the `MERGE` clause,
    you might end up with new `Tweet` nodes with only the `id` but no `text` property
    or even the author connected to it. Using the `MERGE` clause to add relationships,
    you ensure there will be precisely one relationship of that type between source
    and target nodes, no matter how many times the connection occurs in the underlying
    data or how often you run the import query. There are options to change the query
    to import more than a single relationship type between a pair of nodes and still
    use the `MERGE` clause.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据库添加关系的查询结构主要识别源节点和目标节点，然后在两者之间添加连接。在确定是否使用`MATCH`或`MERGE`来识别节点时必须特别小心。如果你使用`MATCH`子句，则不会创建任何新节点，因此在导入过程中将忽略任何尚未在数据库中同时包含源节点和目标节点的关联。另一方面，如果你使用`MERGE`子句，可能会得到只有`id`但没有`text`属性或甚至没有与之关联的作者的`Tweet`节点。使用`MERGE`子句添加关系，你可以确保源节点和目标节点之间恰好有一个该类型的关系，无论底层数据中的连接出现多少次或导入查询运行多少次。有选项可以更改查询以导入一对节点之间超过一个关系类型，同时仍然使用`MERGE`子句。
- en: Exercise 3.14
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.14
- en: Match five `RETWEETS` relationships between a pair of tweets from the database.
    Then, inspect the text of the original and the retweeted post.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配数据库中一对推文之间的五个`RETWEETS`关系。然后，检查原始推文和被转发推文的内容。
- en: 'The final import statement imports the `IN_REPLY_TO` relationships, as shown
    in the following listing. It has a structure almost identical to importing the
    `RETWEETS` relationship: only the type of relationship is changed.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的导入语句导入了`IN_REPLY_TO`关系，如下所示。它的结构几乎与导入`RETWEETS`关系相同：只是关系类型发生了变化。
- en: Listing 3.42 Cypher query that imports `IN_REPLY_TO` relationships from a CSV
    file
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.42 从CSV文件导入`IN_REPLY_TO`关系的Cypher查询
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Matches the source tweet
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配源推文
- en: ❷ Matches the target tweet
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 匹配目标推文
- en: ❸ Merges a reply-to relationship between the source and target tweets
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 合并源推文和目标推文之间的回复关系
- en: Congratulations, you have imported the initial Twitter graph into Neo4j! Neo4j
    has a special procedure that enables you to inspect and visualize the graph schema
    of the stored graph in the database.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经将初始Twitter图导入Neo4j！Neo4j有一个特殊的程序，允许你检查和可视化数据库中存储的图模式。
- en: Listing 3.43 Schema introspection procedure
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.43 模式内省程序
- en: '[PRE42]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you run the schema introspection procedure specified in listing 3.43 in Neo4j
    Browser, you should get the schema visualization shown in figure 3.11.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行Neo4j浏览器中指定的3.43列表中的模式内省程序，你应该会得到图3.11所示的方案可视化。
- en: '![03-11](../../OEBPS/Images/03-11.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![03-11](../../OEBPS/Images/03-11.png)'
- en: Figure 3.11 Visualization of generated graph schema based on the stored graph
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 基于存储图生成的图模式可视化
- en: If you get the exact same graph schema visualization, you are ready to learn
    more about the analytical Cypher queries and graph algorithms, which we cover
    in the next chapter. If the generated schema is not identical, rerun all the import
    queries.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到完全相同的图模式可视化，你就可以学习更多关于分析Cypher查询和图算法的知识，这些内容我们在下一章中会介绍。如果生成的模式不相同，请重新运行所有导入查询。
- en: 3.3 Solutions to exercises
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 练习解决方案
- en: The solution to exercise 3.1 is as follows.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.1的解决方案如下。
- en: Listing 3.44 Cypher statement that creates a node with a label `Person` and
    properties `name` and `age`
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.44 创建一个带有`Person`标签和`name`、`age`属性的节点的Cypher语句
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The solution to exercise 3.2 is as follows.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.2的解决方案如下。
- en: Listing 3.45 Cypher statement that creates two nodes representing an employee
    and their employer and then creates an `EMPLOYED_BY` relationship between the
    two
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.45 创建代表员工及其雇主的两个节点，然后在这两个节点之间创建一个`EMPLOYED_BY`关系的Cypher语句
- en: '[PRE44]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The solution to exercise 3.3 is as follows.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.3的解决方案如下。
- en: Listing 3.46 Creating three nodes representing the city, country, and the continent
    you reside in and then connecting them with the `IS_IN` relationship
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.46 创建代表你居住的城市、国家和大陆的三个节点，然后使用`IS_IN`关系将它们连接起来
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using different node and relationship types is OK, since the exercise did not
    specify any labels or types you should use.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的节点和关系类型是可以的，因为练习没有指定你应该使用任何标签或类型。
- en: The solution to exercise 3.4 is as follows.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.4 的解决方案如下。
- en: Listing 3.47 Retrieving the `name` property of all `Person` nodes
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.47 检索所有 `Person` 节点的 `name` 属性
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The solution to exercise 3.5 is as follows.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.5 的解决方案如下。
- en: Listing 3.48 Creating a `FRIENDS` relationship between node representing yourself
    and Elaine
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.48 在代表你自己的节点和 Elaine 之间创建 `FRIENDS` 关系
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The solution to exercise 3.6 is as follows.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.6 的解决方案如下。
- en: Listing 3.49 Using `OPTIONAL MATCH` to identify whether there are any `FRIENDS`
    relationships attached to the node representing you
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.49 使用 `OPTIONAL MATCH` 来识别是否有任何连接到代表你自己的节点的 `FRIENDS` 关系
- en: '[PRE48]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The solution to exercise 3.7 is as follows.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.7 的解决方案如下。
- en: Listing 3.50 Using the `SET` clause to add a node property
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.50 使用 `SET` 子句添加节点属性
- en: '[PRE49]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The solution to exercise 3.8 is as follows.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.8 的解决方案如下。
- en: Listing 3.51 Using the `SET` clause to add a secondary `Reader` label
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.51 使用 `SET` 子句添加一个二级 `Reader` 标签
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The solution to exercise 3.9 is as follows.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.9 的解决方案如下。
- en: Listing 3.52 Deleting the node representing yourself
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.52 删除代表你自己的节点
- en: '[PRE51]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The solution to exercise 3.10 is as follows.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.10 的解决方案如下。
- en: Listing 3.53 Retrieving all nodes with a label `Person` and name property `Alicia`
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.53 检索所有带有标签 `Person` 和名称属性 `Alicia` 的节点
- en: '[PRE52]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The solution to exercise 3.11 is as follows.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.11 的解决方案如下。
- en: Listing 3.54 Retrieving five `User` nodes
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.54 检索五个 `User` 节点
- en: '[PRE53]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The solution to exercise 3.12 is as follows.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.12 的解决方案如下。
- en: Listing 3.55 Retrieving five `FOLLOWS` relationships
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.55 检索五个 `FOLLOWS` 关系
- en: '[PRE54]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The solution to exercise 3.13 is as follows.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.13 的解决方案如下。
- en: Listing 3.56 Retrieving the `text` property of three random `Tweet` nodes
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.56 检索三个随机 `Tweet` 节点的 `text` 属性
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The solution to exercise 3.14 is as follows.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.14 的解决方案如下。
- en: Listing 3.57 Comparing the text of an original tweet and its retweet
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.57 比较原始推文及其转发的文本
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Cypher syntax uses parentheses, (), to encapsulate a node.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 语法使用圆括号，()，来封装一个节点。
- en: Cypher syntax uses square brackets, [], to encapsulate a relationship.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 语法使用方括号，[]，来封装一个关系。
- en: A relationship cannot exist on its own but needs to be described with adjacent
    nodes.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关系不能独立存在，需要用相邻节点来描述。
- en: In Neo4j, all relationships are stored as directed, although you can ignore
    the direction at query time.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Neo4j 中，所有关系都存储为有向的，尽管在查询时你可以忽略方向。
- en: It is not advisable to ever create any nodes without node labels.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议创建任何没有节点标签的节点。
- en: The `CREATE` clause is used to create data.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CREATE` 子句来创建数据。
- en: The `MATCH` clause is used to identify existing patterns in the database.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MATCH` 子句用于识别数据库中的现有模式。'
- en: The `WHERE` clause can be used in combination with `MATCH` or `WITH` clauses
    to specify various filters.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将 `WHERE` 子句与 `MATCH` 或 `WITH` 子句结合使用，以指定各种过滤器。
- en: If a `MATCH` clause doesn’t find the specified graph pattern, the whole Cypher
    statement returns no results.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `MATCH` 子句找不到指定的图模式，整个 Cypher 语句将返回无结果。
- en: You can use `OPTIONAL` `MATCH` when you are not certain whether a graph pattern
    exists in the database, but you still want to return other variables in the query
    output.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不确定数据库中是否存在图模式时，可以使用 `OPTIONAL` `MATCH`，但你仍然想在查询输出中返回其他变量。
- en: The `WITH` clause can be used to filter, aggregate, select, paginate, or limit
    intermediate rows in the Cypher statement.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WITH` 子句可以用于在 Cypher 语句中过滤、聚合、选择、分页或限制中间行。'
- en: The `SET` clause is used to add node properties and labels.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET` 子句用于添加节点属性和标签。'
- en: The `REMOVE` clause is used to remove node properties and labels.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REMOVE` 子句用于删除节点属性和标签。'
- en: The `DELETE` clause is used to delete nodes and relationships.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 子句用于删除节点和关系。'
- en: If you want to delete a node with existing relationship patterns, you need to
    use the `DETACH` `DELETE` clause.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要删除具有现有关系模式的节点，你需要使用 `DETACH` `DELETE` 子句。
- en: The `MERGE` clause is a combination of `MATCH` and `CREATE` clauses that ensures
    the specified graph pattern exists in the database.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MERGE` 子句是 `MATCH` 和 `CREATE` 子句的组合，确保指定的图模式存在于数据库中。'
- en: The `MERGE` clause is frequently used for data import, as it allows for idempotent
    queries and automatic deduplication.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MERGE` 子句常用于数据导入，因为它允许进行幂等查询和自动去重。'
- en: In Neo4j, you can define unique constraints that ensure unique values for the
    specified node property of a particular node label.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Neo4j中，您可以定义唯一约束，以确保特定节点标签的指定节点属性具有唯一值。
- en: It is recommended to import nodes and relationships separately into the database
    to improve performance and data quality.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议分别将节点和关系导入数据库，以提高性能和提升数据质量。
- en: You can easily evaluate the graph schema of existing data with the `db.schema
    .visualization()` procedure.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`db.schema.visualization()`过程轻松评估现有数据的图模式。
