- en: Chapter 2\. Application under test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. 测试中的应用程序
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Exploring a sample application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索一个示例应用程序
- en: Understanding critical parts of the code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码的关键部分
- en: Developing microservices with Java EE and Spring Boot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java EE 和 Spring Boot 开发微服务
- en: The previous chapter introduced you to microservices, including their basic
    anatomy and architecture. This introduction was intended to give you insight into
    the kinds of tests you might need to write for a microservice-based architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您介绍了微服务，包括它们的基本结构和架构。这个介绍旨在让您了解您可能需要为基于微服务架构编写的测试类型。
- en: This chapter introduces the application that will be used throughout the book
    to demonstrate the development and testing of a microservices architecture. Our
    goal is to provide an easy-to-follow example that will help you understand the
    relevance of each kind of test that will be applied. We try to follow best practices
    for a microservices architecture, but we make some design choices for the sake
    of simplicity and also purely for educational purposes. For instance, we may use
    more technologies than necessary, or simplify the number of layers used in a microservice
    because they don’t add value from a testing point of view. In such cases, we point
    out the reason for a particular approach and discuss how to perform these tasks
    in real-world programming. It’s ultimately your responsibility as a developer
    to choose the appropriate tools to use, but we always offer a recommended approach.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了将在整本书中用于演示微服务架构开发和测试的应用程序。我们的目标是提供一个易于遵循的示例，以帮助您了解将要应用的各种测试的相关性。我们试图遵循微服务架构的最佳实践，但为了简单起见，也为了纯粹的教育目的，我们做出了一些设计选择。例如，我们可能会使用比必要的更多技术，或者简化微服务中使用的层数，因为它们从测试的角度来看没有增加价值。在这种情况下，我们会指出采取特定方法的原因，并讨论如何在现实世界的编程中执行这些任务。最终，作为开发者，选择合适的工具是您的责任，但我们始终提供推荐的方法。
- en: 2.1\. Getting started
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 开始
- en: The example application, Gamer, is a simple software portal for gamers. Its
    purpose is to expose information about software games and to let gamers not only
    read important facts about games and watch videos of games being played, but also
    comment on and leave a star rating for played games. Although this application
    is intentionally simple, it covers all the main topics needed to showcase the
    microservices architecture. Throughout the book, we’ll guide you through the various
    kinds of tests to be written for a microservices-based application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序 Gamer 是一个简单的软件门户，面向玩家。其目的是公开软件游戏的信息，并让玩家不仅能够阅读有关游戏的重要事实和观看游戏播放的视频，还能够对已玩的游戏进行评论并留下星级评分。尽管这个应用程序故意很简单，但它涵盖了展示微服务架构所需的所有主要主题。在整本书中，我们将引导你了解为基于微服务架构的应用程序编写的各种测试。
- en: 'We’ll start by providing some use cases for the Gamer app, to get a high-level
    view of the actions a gamer can take. Gamers want to be able to do these things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先提供一些关于 Gamer 应用程序的使用案例，以获得玩家可以采取的高层次视图。玩家希望能够做以下事情：
- en: Search for games by name, so they can see a list of games that match their interests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称搜索游戏，以便他们可以看到符合他们兴趣的游戏列表
- en: Read about important aspects of a game, such as its publication date and which
    platforms are supported
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解游戏的重要方面，如发布日期和哪些平台支持
- en: Read other gamers’ comments about a game, to help them decide whether they’ll
    enjoy it and want to buy it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读其他玩家对游戏的评论，以帮助他们决定是否喜欢它并想购买它
- en: Write comments about a game, so other gamers can benefit from their evaluation
    of it
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对游戏写评论，以便其他玩家可以从他们的评估中受益
- en: Assign a star rating to a game and quickly see the games with the highest ratings
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏分配星级评分，并快速查看评分最高的游戏
- en: Watch game-related videos such as trailers, tutorials, and real in-game play
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看与游戏相关的视频，如预告片、教程和实际游戏中的玩法
- en: Let’s begin by defining the data required for this application. We won’t focus
    on technical details just yet—this section only describes the conceptual data
    model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义这个应用程序所需的数据。我们目前不会关注技术细节——本节仅描述概念数据模型。
- en: The main entity is a *game*. [Table 2.1](kindle_split_011_split_001.xhtml#ch02table01)
    shows the parts that make up a game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 主要实体是 *游戏*。[表 2.1](kindle_split_011_split_001.xhtml#ch02table01) 展示了构成游戏的部分。
- en: Table 2.1\. The parts of a game
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.1\. 游戏的组成部分
- en: '| Field | Description |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| title | String representing the name of the game |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 标题 | 表示游戏名称的字符串 |'
- en: '| cover | URL of an image of the game cover |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 封面 | 游戏封面的图片URL |'
- en: '| ReleaseDate | The game’s release date |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 发布日期 | 游戏的发布日期 |'
- en: '| Publisher | The game’s publisher |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 发行商 | 游戏的发行商 |'
- en: '| Developer | The game’s developer |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 开发者 | 游戏的开发者 |'
- en: '[Table 2.2](kindle_split_011_split_001.xhtml#ch02table02) shows the parts that
    make up a *release date*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.2](kindle_split_011_split_001.xhtml#ch02table02) 展示了构成一个 *发布日期* 的部分。'
- en: Table 2.2\. Parts of a release date
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.2\. 发布日期的组成部分
- en: '| Field | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| platform | Platform name under which the game was released |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | 游戏发布的平台名称 |'
- en: '| date | Date (day, month, and year) when the game was released for a platform
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 游戏在平台上发布的日期（日、月和年） |'
- en: '[Table 2.3](kindle_split_011_split_001.xhtml#ch02table03) shows the parts that
    make up a *comment*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.3](kindle_split_011_split_001.xhtml#ch02table03) 展示了构成一个 *注释* 的部分。'
- en: Table 2.3\. Parts of a comment
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.3\. 注释的组成部分
- en: '| Field | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| comment | String containing the comment message |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 注释 | 包含注释信息的字符串 |'
- en: '| rate | Star rating from 1 to 5, indicating the overall quality of the game
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 评分 | 从1到5的星级评分，表示游戏的整体质量 |'
- en: Now that you understand the kinds of data the Gamer app will manage, we can
    go a little deeper and inspect the architecture of the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Gamer应用将管理的数据类型，我们可以进一步深入，检查应用架构。
- en: 2.2\. Prerequisites
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 前提条件
- en: This book isn’t a Java tutorial. If you’re not already familiar with Java as
    a language, then you’re highly unlikely to have an enjoyable read. That said,
    we hope to present information that’s of use to readers with all levels of interest.
    The Java tutorials at [https://docs.oracle.com/javase/tutorial](https://docs.oracle.com/javase/tutorial)
    are outstanding resources for any aspiring Java developer and a fantastic reference
    for everyone who uses Java.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不是Java教程。如果你对Java语言不熟悉，那么你很可能不会享受阅读。话虽如此，我们希望提供对所有兴趣水平读者都有用的信息。[https://docs.oracle.com/javase/tutorial](https://docs.oracle.com/javase/tutorial)
    上的Java教程是任何有志于成为Java开发者的优秀资源，也是所有使用Java的人的绝佳参考。
- en: The book also isn’t an academic masterpiece. The authors are primarily developers,
    and English isn’t the first language for some of us. We like getting our hands
    dirty, and we hope you do too. We expect you to bring an open mind and understand
    that not everyone may share our opinions. There’s never one way that’s entirely
    right or entirely wrong, and our suggestions are presented as food for thought
    for your creative mind.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书也不是学术杰作。作者主要是开发者，对我们中的一些人来说，英语不是第一语言。我们喜欢亲自动手，也希望你也是如此。我们希望你保持开放的心态，并理解并非所有人都会分享我们的观点。没有一种方式是完全正确或完全错误的，我们的建议是为了激发你的创造性思维。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Much of the source code is formatted based on the restrictions of presenting
    it on a printed page. This can lead to verbose layout. Feel free to adjust the
    code formatting to your own preferences.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分源代码是基于在打印页面上呈现的限制进行格式化的。这可能导致冗长的布局。请随意调整代码格式以符合你的偏好。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.2.1\. Java Development Kit
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. Java开发工具包
- en: You’ll need at least version SE (Standard Edition) 8 of the Java Development
    Kit (JDK) to compile and run the code in this book. You can always find the latest
    Oracle JDK (recommended) at [http://mng.bz/83Ct](http://mng.bz/83Ct) or the OpenJDK
    at [http://openjdk.java.net](http://openjdk.java.net).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你至少需要Java开发工具包（JDK）的SE（标准版）8版本来编译和运行本书中的代码。你可以在[http://mng.bz/83Ct](http://mng.bz/83Ct)找到最新的Oracle
    JDK（推荐）或在[http://openjdk.java.net](http://openjdk.java.net)找到OpenJDK。
- en: 'To test for Java, run the following command, which should display results similar
    to the following, depending on your installed version:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试Java，运行以下命令，它应该显示类似于以下的结果，具体取决于你的安装版本：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 2.2.2\. Build tools
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 构建工具
- en: We’re using both Apache Maven ([https://maven.apache.org](https://maven.apache.org))
    and Gradle ([https://gradle.org](https://gradle.org)) to build several of the
    project modules. Make sure you’ve installed both of these tools by following the
    instructions provided on the corresponding websites.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Apache Maven ([https://maven.apache.org](https://maven.apache.org)) 和Gradle
    ([https://gradle.org](https://gradle.org)) 来构建项目的几个模块。请确保你已按照相应网站上的说明安装了这两个工具。
- en: 'To test for a correct Maven installation, run the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试Maven是否正确安装，运行以下命令：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Gradle, run this command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Gradle，运行以下命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 2.2.3\. Environment variables
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 环境变量
- en: The full application requires two API keys in order to access some remote resources.
    The API keys are registered to individual user accounts, so we can’t provide shared
    keys here.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序需要两个API密钥才能访问一些远程资源。API密钥注册到个人用户账户，因此我们无法在此提供共享密钥。
- en: It’s *not* necessary to obtain these keys in order to run most of the test examples
    provided in this book. But if you wish to experiment with the code, we suggest
    that you obtain the keys and create the corresponding environment variables. To
    obtain an API key for YouTube, visit [https://developers.google.com/youtube/v3/getting-started](https://developers.google.com/youtube/v3/getting-started)
    and follow the instructions in the Before You Start section. To obtain an API
    key for the Internet Game Database (IGDB), visit [https://igdb.github.io/api/about/welcome](https://igdb.github.io/api/about/welcome)
    or go directly to [https://api.igdb.com](https://api.igdb.com) to register for
    access.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本书中提供的测试示例中的大多数示例不需要获取这些密钥。但如果你希望实验代码，我们建议你获取密钥并创建相应的环境变量。要获取YouTube的API密钥，请访问[https://developers.google.com/youtube/v3/getting-started](https://developers.google.com/youtube/v3/getting-started)并遵循“开始之前”部分的说明。要获取互联网游戏数据库（IGDB）的API密钥，请访问[https://igdb.github.io/api/about/welcome](https://igdb.github.io/api/about/welcome)或直接访问[https://api.igdb.com](https://api.igdb.com)注册访问。
- en: 'Once you have your own API keys, add them to your environment variables. On
    Linux, add the following in /home/profile:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了自己的API密钥，请将它们添加到您的环境变量中。在Linux上，请在/home/profile中添加以下内容：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Windows users may find the following link useful for configuring environment
    variables: [http://mng.bz/1a2K](http://mng.bz/1a2K).^([[1](kindle_split_011_split_002.xhtml#ch02fn01)])'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户可能会发现以下链接在配置环境变量时很有用：[http://mng.bz/1a2K](http://mng.bz/1a2K).^([[1](kindle_split_011_split_002.xhtml#ch02fn01)])
- en: ¹
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: William R. Stanek, “Configuring System and User Environment Variables,” MSDN,
    from *Microsoft Windows 2000* (Microsoft Press, 2002).
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: William R. Stanek，"配置系统和用户环境变量"，MSDN，来自 *Microsoft Windows 2000*（Microsoft Press，2002年）。
- en: 2.2.4\. Integrated development environment (IDE)
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4\. 集成开发环境 (IDE)
- en: None of the application code *requires* you to use an IDE. Notepad will do.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码中没有任何部分*要求*您使用IDE。记事本就足够了。
- en: Of course, feel free to open the projects using your favorite IDE (that supports
    Maven- and Gradle-based projects). If you want to add breakpoints in the code
    in order to follow the execution path (highly recommended), then we suggest using
    an IDE.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以自由地使用您喜欢的IDE（支持基于Maven和Gradle的项目）打开项目。如果您想在代码中添加断点以跟踪执行路径（强烈推荐），那么我们建议使用IDE。
- en: 'We’ve tested the code in the following IDEs, in no particular order of preference:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下IDE中测试了代码，没有特别的偏好顺序：
- en: '*IntelliJ IDEA* ([www.jetbrains.com/idea](http://www.jetbrains.com/idea))'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IntelliJ IDEA* ([www.jetbrains.com/idea](http://www.jetbrains.com/idea))'
- en: '*NetBeans* ([https://netbeans.org](https://netbeans.org))'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NetBeans* ([https://netbeans.org](https://netbeans.org))'
- en: '*Eclipse* ([www.eclipse.org/downloads](http://www.eclipse.org/downloads))'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Eclipse* ([www.eclipse.org/downloads](http://www.eclipse.org/downloads))'
- en: 2.3\. Architecture
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 架构
- en: 'As mentioned at the beginning of the chapter, the Gamer app follows a microservices
    architecture. The first thing to do is identify which services make up the application.
    For this app, we concluded that splitting the domain into four distinct microservices
    was required:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，Gamer应用程序遵循微服务架构。首先要做的是确定哪些服务构成了应用程序。对于这个应用程序，我们得出结论，需要将领域划分为四个不同的微服务：
- en: '*Game service*—Provides all the information related to games. It includes queries
    for obtaining a game ID by a specific name, or returns information for a specific
    game ID.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏服务*—提供与游戏相关的所有信息。它包括通过特定名称获取游戏ID的查询，或返回特定游戏ID的信息。'
- en: '*Comments service*—Adds star ratings and comments for a specific game, as well
    as retrieves them.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*评论服务*—为特定游戏添加星级评分和评论，以及检索它们。'
- en: '*Video service*—Returns the location of the three most prominent videos for
    a game.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视频服务*—返回特定游戏的三个最突出的视频的位置。'
- en: '*Aggregator service*—Calls the aforementioned named services, and aggregates
    the data of each service into a single response.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*聚合服务*—调用上述命名的服务，并将每个服务的数据聚合到单个响应中。'
- en: The application schema is shown in [figure 2.1](kindle_split_011_split_003.xhtml#ch02fig01).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序架构如图2.1所示。[figure 2.1](kindle_split_011_split_003.xhtml#ch02fig01)。
- en: Figure 2.1\. Gamer application schema
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Figure 2.1\. 游戏应用程序架构
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: As you can see, a frontend (typically a browser) consumes the information provided
    by the Gamer API. The point of entry is the aggregator service, which communicates
    with the game, video, and comments services to get or insert required data for
    games. The aggregator service compiles all the data into a single response and
    returns this to the frontend. You can now understand the application architecture
    and the technical reasons behind the decisions that were made for each service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前端（通常是浏览器）消耗Gamer API提供的信息。入口点是聚合服务，它与游戏、视频和评论服务通信，以获取或插入游戏所需的数据。聚合服务将所有数据编译成单个响应，并将其返回给前端。你现在可以理解应用程序架构以及每个服务做出决策的技术原因。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At first, please skip the tests when you build the application from the command
    line or IDE. To demonstrate a point, and also to provide exercises, some of the
    tests won’t complete as provided. As your knowledge builds throughout the book,
    you’ll be in a better position to play with and expand the sample code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当你从命令行或IDE构建应用程序时，请先跳过测试。为了说明一个观点，并提供练习，一些测试可能不会按照提供的方式完成。随着你在本书中的知识积累，你将处于更好的位置来玩转和扩展示例代码。
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.3.1\. The game service
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1. 游戏服务
- en: 'Install the game service using the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码安装游戏服务：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The game service is a Java EE 7 application running on WildFly Swarm that’s
    responsible for providing all the information related to games. It provides two
    operations to retrieve this information:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏服务是一个运行在WildFly Swarm上的Java EE 7应用程序，负责提供所有与游戏相关的信息。它提供了两个操作来检索这些信息：
- en: 'Getting a list of games by title (multiple games can have the same title).
    The information provided for this endpoint must be minimal: for example, only
    the identifier and/or title of the game.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过标题获取游戏列表（多个游戏可能具有相同的标题）。为此端点提供的信息必须是最少的：例如，只有游戏的标识符和/或标题。
- en: Returning detailed information about a game by specifying a known game identifier.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定已知的游戏标识符来返回有关游戏的详细信息。
- en: You might have noticed that there’s no operation for inserting games. This is
    because the game service acts as a proxy/cache to an external service API. An
    *external service* is a service that’s out of the current application scope, that’s
    developed and maintained by a third party, and to which you’re merely a subscriber.
    Typical examples of these services are search engines, weather forecasts, and
    geospatial calculations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到没有插入游戏的操作。这是因为游戏服务充当外部服务API的代理/缓存。*外部服务*是一个超出当前应用程序范围的服务，由第三方开发和维护，而你只是订阅者。这些服务的典型例子包括搜索引擎、天气预报和地理空间计算。
- en: This service example relies on the Internet Game Database website ([www.igdb.com](http://www.igdb.com))
    to provide all of the required game data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务示例依赖于互联网游戏数据库网站（[www.igdb.com](http://www.igdb.com)）来提供所有必需的游戏数据。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The Internet Game Database API**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网游戏数据库API**'
- en: IGDB is a video game database, intended for use by both game consumers and video
    game professionals. In addition to serving as a portal for getting information
    about games, the site provides a public REST API ([www.igdb.com/api](http://www.igdb.com/api))
    that lets you access data for games registered on the site.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: IGDB是一个视频游戏数据库，旨在供游戏消费者和视频游戏专业人士使用。除了作为获取游戏信息的门户外，该网站还提供了一个公共REST API（[www.igdb.com/api](http://www.igdb.com/api)），允许您访问网站上注册的游戏数据。
- en: To authorize access to the REST API, you need to register on the site and request
    a new API key. This key must be passed in each call as an HTTP header.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要授权访问REST API，您需要在网站上注册并请求一个新的API密钥。此密钥必须在每次调用中作为HTTP头传递。
- en: During the course of the book, we provide more information about the IGDB REST
    API, such as how to authenticate against IGDB, and the required format for resource
    endpoints.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们提供了更多关于IGDB REST API的信息，例如如何对IGDB进行身份验证，以及资源端点的所需格式。
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'When you rely on external calls to third-party services, it’s always important
    (if possible) to cache as much data from the external service as you can. This
    is important for three reasons:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你依赖第三方服务的外部调用时，始终很重要（如果可能的话）尽可能多地缓存外部服务的数据。这有三个原因很重要：
- en: You avoid round trips to external networks, which is typically a slow operation.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你避免了往返外部网络的来回，这通常是一个慢速操作。
- en: If you have quota/metered access to the external API, you save on hits to the
    service.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对外部API有配额/计费访问权限，你可以节省对服务的访问次数。
- en: In the event the external service experiences an outage, your application can
    continue to work with cached data.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果外部服务出现故障，您的应用程序可以继续使用缓存数据工作。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Generally, caching is used only in cases where the external data doesn’t change
    often or you can replicate all the data on your systems. To maintain coherence
    of the external data, you should apply a periodic refresh strategy to the cache
    so it doesn’t become outdated. For the sake of simplicity, no refresh strategy
    is implemented in the example app, but this is something to take into consideration
    in a real-world scenario.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，缓存仅在外部数据不经常更改或您可以在您的系统上复制所有数据的情况下使用。为了保持外部数据的一致性，您应该对缓存应用定期刷新策略，以防止其过时。为了简化，示例应用程序中没有实现刷新策略，但在实际场景中这是一个需要考虑的问题。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this microservice, a cache-persistence-layer system is implemented using
    the light SQL database H2 ([www.h2database.com/html/main.html](http://www.h2database.com/html/main.html)).
    The *entity-relationship* (ER) model used in the game service is composed of four
    entities, described in [tables 2.4](kindle_split_011_split_003.xhtml#ch02table04)–[2.7](kindle_split_011_split_003.xhtml#ch02table07).
    [Figure 2.2](kindle_split_011_split_003.xhtml#ch02fig02) shows this in graphical
    terms.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个微服务中，使用轻量级SQL数据库H2 ([www.h2database.com/html/main.html](http://www.h2database.com/html/main.html))
    实现了一个缓存持久化层系统。游戏服务中使用的实体-关系（ER）模型由四个实体组成，在[表2.4](kindle_split_011_split_003.xhtml#ch02table04)–[2.7](kindle_split_011_split_003.xhtml#ch02table07)中进行了描述。[图2.2](kindle_split_011_split_003.xhtml#ch02fig02)以图形方式展示了这一点。
- en: Table 2.4\. `Game` table
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.4. `Game`表
- en: '| Field | Data type | Description |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 数据类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| id | Long | Game identifier. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| id | Long | 游戏标识符。|'
- en: '| version | Int | Internal field for avoiding conflicts in optimistic locking.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| version | Int | 用于避免乐观锁冲突的内部字段。|'
- en: '| title | String | Name of the game. This value is unique. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| title | String | 游戏名称。此值是唯一的。|'
- en: '| cover | String | URL of the cover of the game, or null if no cover. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| cover | String | 游戏封面的URL，如果没有封面则为null。|'
- en: '| Release dates | ReleaseDate | One-to-many relationship of type ReleaseDate.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 发布日期 | ReleaseDate | 类型为ReleaseDate的一对多关系。|'
- en: '| Publishers | Collection of Strings | One-to-many relationship between publishers
    and the name of the game. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Publishers | 字符串集合 | 出版商与游戏名称之间的一对多关系。|'
- en: '| Developer | Collection of Strings | One-to-many relationship between developers
    and the name of the game. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Developer | 字符串集合 | 开发者与游戏名称之间的一对多关系。|'
- en: Table 2.5\. `ReleaseDate` table
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.5. `ReleaseDate`表
- en: '| Field | Data type | Description |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 数据类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| OwnerId | Long | Identifier for the game. This field acts as a foreign key.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| OwnerId | Long | 游戏标识符。此字段作为外键。|'
- en: '| platformName | String | Platform name under which game was released. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| platformName | String | 游戏发布的平台名称。|'
- en: '| releaseDate | String | Date when the game was released for this platform,
    in YYYY/MM/DD format. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| releaseDate | String | 游戏在此平台上发布的日期，格式为YYYY/MM/DD。|'
- en: Table 2.6\. `Publisher` table
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.6. `Publisher`表
- en: '| Field | Data type | Description |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 数据类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| OwnerId | Long | Identifier for the game. This field acts as a foreign key.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| OwnerId | Long | 游戏标识符。此字段作为外键。|'
- en: '| publisherName | String | Publisher name. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| publisherName | String | 出版社名称。|'
- en: Table 2.7\. `Developer` table
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.7. `Developer`表
- en: '| Field | Data type | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 数据类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| OwnerId | Long | Identifier for the game. This field acts as a foreign key.
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| OwnerId | Long | 游戏标识符。此字段作为外键。|'
- en: '| developer | String | Developer name. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| developer | String | 开发者名称。|'
- en: Figure 2.2\. Gamer application entity relationship
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2. 游戏应用实体关系
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig02_alt.jpg)'
- en: The entity-relationship schema in [figure 2.2](kindle_split_011_split_003.xhtml#ch02fig02)
    shows that a game is composed of a title and a cover, is made by one-to-*n* (one-to-many)
    developers, is published by one or many publishers, and has zero or more release
    dates for each platform.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.2](kindle_split_011_split_003.xhtml#ch02fig02)中的实体-关系模式显示，一个游戏由一个标题和一个封面组成，由一个或多个开发者制作，由一个或多个出版商出版，并且每个平台都有零个或多个发布日期。'
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'There are other options that are a good fit for caching data for microservice
    architectures, such as Infinispan, Hazelcast, and Redis. They not only offer *time-to-live*
    (TTL) features, which makes the refresh logic much simpler, but also work in distributed
    (clustered) environments, which is typical in microservice architectures. For
    teaching purposes, in this book we use a SQL database. This approach is simple
    and uses a technology that you may be accustomed to. This also allows us to introduce
    an important feature: persistence testing of the ORM.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务架构的缓存数据，还有其他一些很好的选择，例如Infinispan、Hazelcast和Redis。它们不仅提供*生存时间*（TTL）功能，这使得刷新逻辑更加简单，而且在分布式（集群）环境中也能工作，这在微服务架构中很典型。为了教学目的，在这本书中我们使用SQL数据库。这种方法很简单，并使用您可能熟悉的技术。这也使我们能够介绍一个重要功能：ORM的持久化测试。
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: On the server layer, the game service runs on the WildFly Swarm application
    server. An overall schema of this service is shown in [figure 2.3](kindle_split_011_split_003.xhtml#ch02fig03).
    The persistence layer uses an H2 SQL database for storing and retrieving cached
    data for games. Finally, the service connects to the external site (IGDB.com)
    to obtain information for games that aren’t yet cached on the system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器层，游戏服务运行在WildFly Swarm应用程序服务器上。该服务的整体架构图显示在[图2.3](kindle_split_011_split_003.xhtml#ch02fig03)中。持久化层使用H2
    SQL数据库来存储和检索游戏的缓存数据。最后，该服务连接到外部网站（IGDB.com）以获取尚未在系统中缓存的游戏的详细信息。
- en: Figure 2.3\. Game service overview
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 游戏服务概览
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig03_alt.jpg)'
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**WildFly Swarm**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**WildFly Swarm**'
- en: WildFly Swarm ([http://wildfly-swarm.io](http://wildfly-swarm.io)) offers an
    approach to packaging and running Java EE applications by generating an uber-JAR
    (`java -jar MyApp.jar`), which packages the application with just enough of the
    server runtime to run.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly Swarm ([http://wildfly-swarm.io](http://wildfly-swarm.io))提供了一种打包和运行Java
    EE应用程序的方法，通过生成uber-JAR（`java -jar MyApp.jar`），将应用程序与服务器运行时打包在一起以运行。
- en: It also has built-in support for applications and frameworks such as Logstash,
    Netflix projects like Hystrix and Ribbon, and Red Hat projects like Keycloak and
    Hawkular.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它还内置了对Logstash、Netflix项目如Hystrix和Ribbon、Red Hat项目如Keycloak和Hawkular等应用程序和框架的支持。
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.3.2\. The comments service
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 评论服务
- en: 'Build and package the comments service using the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码构建和打包评论服务：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The comments service is an EE 7 application running on Apache TomEE. It’s responsible
    for managing comments for a specific game, as well as the game rating. A rating
    is a number between 1 (the lowest rating) and 5 (the highest rating). Notice that
    this feature isn’t provided by IGDB; it’s something you’ll add to the portal to
    make it more participatory. This service provides two endpoints:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 评论服务是一个运行在Apache TomEE上的EE 7应用程序。它负责管理特定游戏的评论以及游戏评分。评分是一个介于1（最低评分）和5（最高评分）之间的数字。请注意，此功能不是由IGDB提供的；这是您将添加到门户中使其更具参与性的功能。此服务提供两个端点：
- en: One adding a comment and a game rating
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条添加评论和游戏评分
- en: A second that returns all the comments that have been written for a game, along
    with the average game rating
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个返回所有为游戏编写的评论以及平均游戏评分
- en: The persistence layer for this service uses a document-oriented NoSQL database
    for storing all the data required by the service. We chose the MongoDB NoSQL database
    specifically due to its out-of-the-box aggregation framework. It’s a perfect solution
    for calculating the average rating for a given game.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务的持久化层使用面向文档的NoSQL数据库来存储服务所需的所有数据。我们特别选择了MongoDB NoSQL数据库，因为它具有开箱即用的聚合框架。这对于计算给定游戏的平均评分是一个完美的解决方案。
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Similar logic could be implemented using a traditional SQL database, but nowadays
    it’s not uncommon to use a NoSQL database due to its better performance in certain
    circumstances. This service uses a NoSQL database to showcase the example.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用传统的SQL数据库实现类似的逻辑，但如今由于在某些情况下性能更好，使用NoSQL数据库并不罕见。此服务使用NoSQL数据库来展示示例。
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**MongoDB**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**MongoDB**'
- en: MongoDB is a document-oriented NoSQL database. Instead of using a relational
    database structure, MongoDB stores JSON-like documents with dynamic schemas in
    collections. Documents that have a similar purpose are stored in the same collection.
    You can think of a collection as being equivalent to an RDBMS table, but without
    forcing a schema.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个面向文档的 NoSQL 数据库。它不使用关系型数据库结构，而是在集合中以动态架构存储类似 JSON 的文档。具有相似目的的文档存储在同一个集合中。你可以将集合视为与
    RDBMS 表等效，但不需要强制架构。
- en: In addition to storing documents, MongoDB provides features like indexing, replication,
    load balancing with horizontal shards, and an aggregation framework.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储文档外，MongoDB 还提供索引、复制、水平分片负载均衡和聚合框架等功能。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'MongoDB structures documents into *collections*. For the comments service,
    this collection is named *comments*. Each document that represents a comment has
    a schema like the following and contains the game’s ID, the comment itself, and
    the game’s rating (see [figure 2.4](kindle_split_011_split_003.xhtml#ch02fig04)):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 将文档组织成 *集合*。对于评论服务，这个集合被命名为 *comments*。每个代表评论的文档具有以下架构，并包含游戏的 ID、评论本身以及游戏的评分（见
    [图 2.4](kindle_split_011_split_003.xhtml#ch02fig04)）：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 2.4\. Collection of comments
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.4\. 评论集合
- en: '![](Images/02fig04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig04.jpg)'
- en: An overall schema of the comments service is shown in [figure 2.5](kindle_split_011_split_003.xhtml#ch02fig05).
    On the server layer, it runs on the Apache TomEE application server ([http://tomee.apache.org](http://tomee.apache.org));
    and for the persistence layer, it uses the MongoDB NoSQL database for storing
    and retrieving comments associated with games.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 评论服务的整体架构在 [图 2.5](kindle_split_011_split_003.xhtml#ch02fig05) 中展示。在服务器层，它运行在
    Apache TomEE 应用服务器上（[http://tomee.apache.org](http://tomee.apache.org)）；对于持久化层，它使用
    MongoDB NoSQL 数据库来存储和检索与游戏相关的评论。
- en: Figure 2.5\. Comments service overview
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.5\. 评论服务概览
- en: '![](Images/02fig05.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig05.jpg)'
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Apache TomEE**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apache TomEE**'
- en: Apache TomEE ([http://tomee.apache.org](http://tomee.apache.org)), pronounced
    “Tommy,” is an all-Apache Java EE 6 Web Profile–certified and EE 7–enabled stack
    where Apache Tomcat is top dog. Apache TomEE is assembled from a vanilla Apache
    Tomcat zip file. Starting with Apache Tomcat, TomEE adds its JARs and zips up
    the rest. The result is Tomcat with added EE features—hence, the name TomEE.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Apache TomEE ([http://tomee.apache.org](http://tomee.apache.org))，发音为“Tommy”，是一个全
    Apache Java EE 6 Web Profile 认证和 EE 7 启用的堆栈，其中 Apache Tomcat 是主要角色。Apache TomEE
    是从普通的 Apache Tomcat 压缩文件构建而成的。从 Apache Tomcat 开始，TomEE 添加了自己的 JAR 文件，并将剩余的文件压缩起来。结果是添加了
    EE 功能的 Tomcat——因此得名 TomEE。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.3.3\. The video service
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 视频服务
- en: 'Build the video service using the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码构建视频服务：
- en: '[PRE7]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The video service is a Spring Boot application that’s responsible for retrieving
    the three most prominent videos related to a given game. Notice that this feature
    isn’t provided by IGDB; it’s something you’ll add to the portal to make it more
    attractive to end users. Obviously, this service isn’t going to reinvent the wheel
    by creating a new video-sharing/-streaming site, so it uses YouTube to retrieve
    videos.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 视频服务是一个 Spring Boot 应用程序，负责检索与给定游戏相关的三个最突出的视频。请注意，此功能不是由 IGDB 提供的；这是你将添加到门户中，使其对最终用户更具吸引力的内容。显然，此服务不会通过创建新的视频分享/流媒体网站来重新发明轮子，因此它使用
    YouTube 来检索视频。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**YouTube**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**YouTube**'
- en: YouTube is a global video-sharing website. You can add YouTube functionality
    to any site and even search for content.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: YouTube 是一个全球性的视频分享网站。你可以将 YouTube 功能添加到任何网站，甚至可以搜索内容。
- en: The *YouTube Data API* is the REST API that YouTube provides to users to connect
    to its system and execute operations like uploading videos, modifying videos,
    and searching for videos that match specific terms. See the book’s appendix for
    information about how to use the YouTube Data API.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*YouTube 数据 API* 是 YouTube 为用户提供以连接其系统并执行上传视频、修改视频和搜索匹配特定术语的视频等操作而提供的 REST
    API。有关如何使用 YouTube 数据 API 的信息，请参阅本书附录。'
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This service provides a single endpoint, which returns the links of the three
    most prominent videos for the specified game.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务提供了一个单一端点，返回指定游戏的三个最突出的视频链接。
- en: This microservice has no persistence layer in the sense of long-lived data stored
    in the system. For this microservice, a NoSQL in-memory database of key-value
    pairs is used for caching search results from YouTube. When you’re caching distributed
    data where optional durability is required, key-value databases are the best choice,
    because they fit this requirement perfectly. With this approach, you save time,
    because an external network hit is more expensive than an internal one. You also
    save on the hits quota allotted by the YouTube Data API. In the video service,
    the key-value database used as a caching system is the Redis database.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务在系统中长期存储数据的持久层方面没有。对于这个微服务，使用一个键值对的NoSQL内存数据库来缓存从YouTube搜索结果。当您需要缓存分布式数据且需要可选的持久性时，键值数据库是最佳选择，因为它们完美地满足这一需求。采用这种方法，您可以节省时间，因为外部网络请求比内部请求更昂贵。您还可以节省YouTube数据API分配的请求配额。在视频服务中，用作缓存系统的键值数据库是Redis数据库。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Redis**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis**'
- en: Redis is an in-memory data-structure store that can be used as a database, cache
    system, or message broker. It supports data structures such as strings, hashes,
    lists, sets, sorted sets with range queries, bitmaps, HyperLogLogs, and geospatial
    indexes with radius queries.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个内存数据结构存储，可以用作数据库、缓存系统或消息代理。它支持字符串、散列、列表、集合、范围查询的有序集合、位图、HyperLogLogs和具有半径查询的地理空间索引等数据结构。
- en: Redis offers clustering capabilities, master-slave replication, and transactions,
    with extremely good performance when not persisting data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Redis提供集群功能、主从复制和事务，在不持久化数据时具有极好的性能。
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Redis structure used for this microservice is a *list*. This basic structure
    holds a list of string values for a given key with an optional TTL. In this case,
    the key is the game ID, and the value of each element of the list is a URL of
    the video associated with the game. As you can see in the schema shown in [figure
    2.6](kindle_split_011_split_003.xhtml#ch02fig06), the Redis structure stores a
    game ID and a list of three YouTube URLs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此微服务的Redis结构是一个*列表*。这个基本结构为给定键存储一个字符串值列表，并可选地带有TTL。在这种情况下，键是游戏ID，列表中每个元素的值是与游戏相关的视频URL。如[图2.6](kindle_split_011_split_003.xhtml#ch02fig06)所示，Redis结构存储了一个游戏ID和三个YouTube
    URL的列表。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Spring Boot**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Boot**'
- en: Spring Boot ([http://projects.spring.io/spring-boot](http://projects.spring.io/spring-boot))
    makes it easy to create standalone, production-grade, Spring-based applications
    that you can “just run.” It follows the uber(fat)-JAR approach by packaging an
    application into a single JAR file, which contains the runtime (embedded server
    plus application) and a `Main` class to run it. It integrates well with other
    products in the Spring ecosystem, like Spring Data and Spring Security.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot ([http://projects.spring.io/spring-boot](http://projects.spring.io/spring-boot))
    使创建独立、生产级别的基于Spring的应用程序变得简单，您可以“直接运行”。它采用uber(fat)-JAR方法，将应用程序打包到一个单一的JAR文件中，该文件包含运行时（嵌入服务器加应用程序）和一个`Main`类来运行它。它与Spring生态系统中的其他产品（如Spring
    Data和Spring Security）很好地集成。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 2.6\. Video URLs cached in Redis
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. Redis中缓存的视频URL
- en: '![](Images/02fig06.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig06.jpg)'
- en: An overall schema of this service is shown in [figure 2.7](kindle_split_011_split_003.xhtml#ch02fig07).
    You can see that the video service is a Spring Boot application, and the cache
    layer it uses is Redis. The service connects to the external site (youtube.com)
    to get video links for a specific game.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务的整体架构如图2.7所示。[figure 2.7](kindle_split_011_split_003.xhtml#ch02fig07)。您可以看到视频服务是一个Spring
    Boot应用程序，它使用的缓存层是Redis。该服务连接到外部网站（youtube.com）以获取特定游戏的视频链接。
- en: Figure 2.7\. Video service
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 视频服务
- en: '![](Images/02fig07_alt.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07_alt.jpg)'
- en: 2.3.4\. The aggregator service
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4\. 聚合服务
- en: 'Build and package the aggregator service using the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码构建和打包聚合服务：
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This service is an EE 7 application that’s responsible for creating calls to
    the game and comments services, merging the results of both calls into a single
    document, and returning this document to the caller. This service provides three
    endpoints:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务是一个EE 7应用程序，负责对游戏和评论服务进行调用，将两个调用的结果合并成一个文档，并将此文档返回给调用者。此服务提供三个端点：
- en: One for adding a comment and a game rating
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于添加评论和游戏评分
- en: A second that returns all the games that have a specified name
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回所有具有指定名称的游戏的第二个
- en: A third that returns all the data related to a specified game, all user comments
    and ratings, and the three most important videos for the game
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个返回与指定游戏相关的所有数据、所有用户评论和评分以及该游戏最重要的三个视频的第三个
- en: The overall schema of the aggregator service is shown in [figure 2.8](kindle_split_011_split_003.xhtml#ch02fig08).
    It has no persistence layer. The service runs inside the Apache Tomcat server
    and connects to all other services.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合器服务整体架构如图[图2.8](kindle_split_011_split_003.xhtml#ch02fig08)所示。它没有持久化层。该服务在Apache
    Tomcat服务器内运行，并连接到所有其他服务。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Apache Tomcat**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apache Tomcat**'
- en: The Apache Tomcat server is an open source implementation of the Java Servlet,
    JavaServer Pages, Java Expression Language, and Java WebSocket technologies.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Tomcat服务器是Java Servlet、JavaServer Pages、Java Expression Language和Java
    WebSocket技术的开源实现。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 2.8\. Game aggregator service relations to other services
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8\. 游戏聚合器服务与其他服务的关系
- en: '![](Images/02fig08_alt.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig08_alt.jpg)'
- en: 2.3.5\. Overall architecture
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.5\. 总体架构
- en: 'In summary, the Gamer app is made up of three services. Each of these services
    is deployed in a different platform, from the light application server Apache
    TomEE to a WildFly Swarm uber-JAR. Two different kinds of database engines are
    used for the persistence layer: H2, a traditional SQL database, and MongoDB, which
    belongs to the family of NoSQL databases.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Gamer应用程序由三个服务组成。每个服务都部署在不同的平台上，从轻量级应用程序服务器Apache TomEE到WildFly Swarm uber-JAR。持久化层使用了两种不同的数据库引擎：H2，一种传统的SQL数据库，以及MongoDB，它属于NoSQL数据库家族。
- en: This is a broad range of technologies. We chose to use these various technologies
    specifically to broaden the scope of this book for the purposes of illustration.
    In the real world, your applications are likely to be founded on technologies
    that are more similar to each other. But, as mentioned previously, it’s not uncommon
    for different teams to work on different microservices.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个广泛的技术范围。我们选择使用这些各种技术，具体是为了扩大本书的说明范围。在现实世界中，你的应用程序可能基于更相似的技术。但是，如前所述，不同团队工作在不同微服务上并不罕见。
- en: The overall schema of the Gamer app can be seen in the architecture diagram
    in [figure 2.9](kindle_split_011_split_003.xhtml#ch02fig09). It’s important to
    note in the schema diagram how all the pieces are connected to compose a fully
    functional, microservice-based application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Gamer应用程序的整体架构可以在[图2.9](kindle_split_011_split_003.xhtml#ch02fig09)的架构图中看到。在架构图上，所有组件如何连接起来以组成一个完全功能化的、基于微服务的应用程序是非常重要的。
- en: Figure 2.9\. Architecture diagram of our project
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. 我们项目的架构图
- en: '![](Images/02fig09_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig09_alt.jpg)'
- en: 2.4\. Application design patterns
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 应用设计模式
- en: In previous sections, you’ve read about the Gamer app from a high-level perspective,
    and we’ve been paying a lot of attention to the requirements of the application
    from a business perspective. In the following sections, we’ll dig down into the
    technical side of the application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经从高层次的角度了解了Gamer应用程序，并且我们从业务角度对应用程序的要求给予了极大的关注。在接下来的章节中，我们将深入探讨应用程序的技术层面。
- en: 2.4.1\. Anatomy
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 解剖
- en: The Gamer app follows the microservices architecture by applying the Single
    Responsibility Principle (SRP) at an architectural level, making each service
    independent in terms of deployment, technology, and language. In summary, each
    microservice is structured following the schema shown in [figure 2.10](kindle_split_011_split_004.xhtml#ch02fig10).
    Let’s see how each piece is implemented in the Gamer app.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Gamer应用程序通过在架构层面应用单一职责原则（SRP），遵循微服务架构，使每个服务在部署、技术和语言方面都独立。总的来说，每个微服务都是按照[图2.10](kindle_split_011_split_004.xhtml#ch02fig10)中显示的架构进行构建的。让我们看看Gamer应用程序中每个部分是如何实现的。
- en: Figure 2.10\. Detailed microservice structure
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10\. 详细微服务结构
- en: '![](Images/02fig10.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig10.jpg)'
- en: The resource component
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 资源组件
- en: The *resource component* is a thin layer of the application that acts as a mapper
    between incoming messages (typically JSON documents) and the business logic in
    the domain component. It also provides a response in accordance with the outcome
    produced by the business logic, using the desired protocol.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*资源组件*是应用程序的一个薄层，它作为传入消息（通常是JSON文档）和领域组件中的业务逻辑之间的映射器。它还根据业务逻辑产生的结果，使用所需的协议提供响应。'
- en: In Java EE, this component is typically implemented using the Java API for RESTful
    Web Services (JAX-RS), which provides support for creating web services following
    the REST architectural pattern. An example of a resource component is coded in
    the comments service (code/comments/src/main/java/book/comments/boundary/CommentsResource.java).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE中，此组件通常使用Java API for RESTful Web Services (JAX-RS)实现，该API为遵循REST架构模式的Web服务创建提供支持。一个资源组件的示例代码位于评论服务中（code/comments/src/main/java/book/comments/boundary/CommentsResource.java）。
- en: Listing 2.1\. Resource component
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. 资源组件
- en: '[PRE9]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Sets the relative path for a class or method**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置类或方法的相对路径**'
- en: '***2* Indicates that the method services the HTTP GET request type**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指示该方法服务HTTP GET请求类型**'
- en: '***3* Sets the response MIME type**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置响应MIME类型**'
- en: '***4* Binds the parameter to a path segment**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将参数绑定到路径段**'
- en: '***5* Returns the content with the HTTP response code OK (200)**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回带有HTTP响应代码OK (200)的内容**'
- en: Request processing occurs by default in a synchronous fashion; this means a
    client request is processed by a single container I/O thread from start to finish.
    This blocking approach is fine for business logic that takes only a short time
    to execute.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，请求处理以同步方式进行；这意味着客户端请求从开始到结束由单个容器I/O线程处理。这种阻塞方法适用于执行时间短的业务逻辑。
- en: But for long-running tasks, the container thread will remain occupied until
    the task has been completed. This can have a significant impact on the server’s
    throughput, because new connections can remain blocked longer than expected while
    waiting for the backlog queue to be processed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于长时间运行的任务，容器线程将保持占用状态，直到任务完成。这可能会对服务器的吞吐量产生重大影响，因为新的连接可能会比预期更长地被阻塞，等待处理积压队列。
- en: To resolve this problem, JAX-RS has an asynchronous model. This enables the
    container thread to be released to accept a new connection before the client connection
    is closed. The lengthy task runs in another thread, and the container I/O thread
    can be used by another connection that’s waiting in the backlog queue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，JAX-RS有一个异步模型。这允许容器线程在客户端连接关闭之前释放，以接受新的连接。长时间运行的任务在另一个线程中运行，容器I/O线程可以由另一个在积压队列中等待的连接使用。
- en: An example of an asynchronous resource component is coded in the game service
    (code/game/src/main/java/book/games/boundary/GamesResource.java), because connections
    to external resources can take a considerable amount of time to complete.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 异步资源组件的示例代码位于游戏服务中（code/game/src/main/java/book/games/boundary/GamesResource.java），因为连接到外部资源可能需要相当长的时间才能完成。
- en: Listing 2.2\. Asynchronous resource component
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.2\. 异步资源组件
- en: '[PRE10]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Resource is marked as Singleton EJB so the endpoint becomes transactional**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 资源标记为Singleton EJB，因此端点变为事务性的**'
- en: '***2* Injects an executor service provided by the container**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入容器提供的执行器服务**'
- en: '***3* Designates a method as asynchronous. Valid only if it’s an EJB.**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将方法指定为异步。仅当它是EJB时有效。**'
- en: '***4* Instructs the JAX-RS runtime that this method is asynchronous and injects
    an AsyncResponse**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 指示JAX-RS运行时此方法是异步的，并注入AsyncResponse**'
- en: '***5* Executes logic in a different thread**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在不同的线程中执行逻辑**'
- en: '***6* When the result is ready, the connection is resumed.**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 当结果准备好时，连接将恢复。**'
- en: '***7* In case of an error, communication should also be resumed.**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在出现错误的情况下，也应恢复通信。**'
- en: For Spring applications, a resource is implemented using the Spring Web model-view-controller
    (MVC) framework. This framework is built around the `DispatcherServlet` class
    and dispatches requests to configured handlers for executing business logic.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Spring应用程序，资源使用Spring Web模型-视图-控制器（MVC）框架实现。此框架围绕`DispatcherServlet`类构建，并将请求调度到配置的处理程序以执行业务逻辑。
- en: An example of a resource written for the Spring Web MVC framework is coded in
    the video service (code/video/src/main/java/book/video/boundary/VideosResource.java).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为Spring Web MVC框架编写的资源示例代码位于视频服务中（code/video/src/main/java/book/video/boundary/VideosResource.java）。
- en: Listing 2.3\. Spring resource
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3\. Spring资源
- en: '[PRE11]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* The resource is marked as a Spring Rest controller.**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 资源标记为Spring Rest控制器。**'
- en: '***2* Injects video-service logic**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入视频服务逻辑**'
- en: '***3* Configures the endpoint method**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 配置端点方法**'
- en: Domain model
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 领域模型
- en: A *domain model* is a representation or abstraction of real-world concepts belonging
    to the domain that need to be modeled in software. Each object of the domain incorporates
    both the data and the behavior of the object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型是一个表示或抽象现实世界中属于领域且需要在软件中建模的概念。领域中的每个对象都包含对象的数据和行为。
- en: In Java EE and Spring applications, if the domain is to be persisted to a SQL
    database, then the domain is annotated with Java Persistence API (JPA) annotations.
    We’ll discuss JPA in depth in [chapters 4](kindle_split_013_split_000.xhtml#ch04)
    and [5](kindle_split_014_split_000.xhtml#ch05).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE和Spring应用程序中，如果领域需要持久化到SQL数据库，则领域会被标注为Java持久化API（JPA）注解。我们将在第[4章](kindle_split_013_split_000.xhtml#ch04)和第[5章](kindle_split_014_split_000.xhtml#ch05)中深入讨论JPA。
- en: An example is found in the game service (code/game/src/main/java/book/games/entity/Game.java),
    where the domain model is `Game`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以游戏服务（code/game/src/main/java/book/games/entity/Game.java）为例，其中的领域模型是`Game`。
- en: Listing 2.4\. Domain model
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4\. 领域模型
- en: '[PRE12]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Domain objects have fields that describe their properties in the system.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 领域对象有字段描述其在系统中的属性。**'
- en: '***2* Object-manipulation methods should reside within the object.**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对象操作方法应位于对象内部。**'
- en: Service layer
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务层
- en: The services in the *service layer* are responsible for coordinating the various
    domain activities and interactions with other subsystems. For example, these services
    handle database interactions through the persistence component and call external
    services through the remote-resource component.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层中的服务负责协调各个领域活动以及与其他子系统的交互。例如，这些服务通过持久化组件处理数据库交互，并通过远程资源组件调用外部服务。
- en: In Java EE and Spring, this layer is usually implemented as a simple Java class,
    which is annotated in order to be eligible for injection either by *context dependency
    injection* (CDI), or autowiring in Spring components. Services should be injectable
    in any element that makes up the microservice.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE和Spring中，这一层通常实现为一个简单的Java类，通过注解使其有资格通过*上下文依赖注入*（CDI）或Spring组件中的自动装配进行注入。服务应该可以在构成微服务的任何元素中注入。
- en: One example of a Java EE service can be found in the game service (code/game/src/main/java/book/games/control/GamesService.java).
    This service is responsible for checking if a game is cached in the Gamer local
    database, or if it must first be retrieved from the IGDB API.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java EE服务的示例可以在游戏服务（code/game/src/main/java/book/games/control/GamesService.java）中找到。此服务负责检查游戏是否缓存在Gamer本地数据库中，或者是否必须首先从IGDB
    API检索。
- en: Listing 2.5\. Java EE service
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. Java EE服务
- en: '[PRE13]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Sets this class eligible for a CDI container as Dependent scoped**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将此类设置为CDI容器中依赖范围的合格**'
- en: '***2* Other elements can be injected in a service.**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 其他元素可以注入到服务中。**'
- en: '***3* Finds a game in the database**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在数据库中查找游戏**'
- en: '***4* If the game isn’t found, gets it from IGDB**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果找不到游戏，则从IGDB获取**'
- en: A Spring service example can be found in the video service (code/video/src/main/java/book/video/boundary/YouTubeVideos.java).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Spring服务的一个示例可以在视频服务（code/video/src/main/java/book/video/boundary/YouTubeVideos.java）中找到。
- en: Listing 2.6\. Spring service
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6\. Spring服务
- en: '[PRE14]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Repositories
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 仓库
- en: '*Repositories* act on collections of domain entities and generally act as entry
    points or bridges to the persistence-component backend.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*仓库*作用于领域实体集合，通常作为入口点或到持久化组件后端的桥梁。'
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re only going to manage a single entity, we don’t recommend adding a
    repository layer, because it would add unnecessary overhead. There’s also no need
    to pass objects through layers that never interact with them. For educational
    purposes, we’ve implemented a simple repository layer that demonstrates how to
    best test the class in a real-world scenario.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只打算管理单个实体，我们不推荐添加仓库层，因为这会增加不必要的开销。也没有必要将对象通过从未与之交互的层传递。为了教育目的，我们实现了一个简单的仓库层，以展示如何在现实世界场景中最佳地测试该类。
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When using a SQL database over JPA in a Java EE container, you should use Enterprise
    Java Beans (EJBs), because they provide transactional awareness, concurrency management,
    and security out of the box.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Java EE容器中使用JPA的SQL数据库时，你应该使用企业JavaBeans（EJBs），因为它们提供了开箱即用的事务感知、并发管理和安全性。
- en: An example repository layer can be found in the game service (code/game/src/main/java/book/games/boundary/Games.java).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏服务（code/game/src/main/java/book/games/boundary/Games.java）中可以找到一个示例仓库层。
- en: Listing 2.7\. Repository layer
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 仓库层
- en: '[PRE15]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* EJBs ensure that classes are transaction aware by default.**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* EJBs确保类默认具有事务感知性。**'
- en: '***2* Injects the EntityManager for database operations**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入EntityManager以进行数据库操作**'
- en: '***3* Creates a new game**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个新的游戏**'
- en: When you use Spring, repositories are usually written to use the Spring Data
    project. This provides a familiar, consistent, Spring-based programming model
    for data access to relational and non-relational data stores, as well as to map-reduce
    frameworks and cloud-based data services. An example of a repository utilizing
    Spring Data can be found in the video service code for accessing Redis.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Spring时，通常会编写仓库以使用Spring Data项目。这为数据访问提供了熟悉、一致的基于Spring的编程模型，无论是访问关系型和非关系型数据存储，还是映射-减少框架和基于云的数据服务。一个利用Spring
    Data的仓库示例可以在视频服务代码中找到，用于访问Redis。
- en: Data mappers and object-relational mapping
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据映射和对象关系映射
- en: Just about all microservices need to persist some kind of data to persistent
    storage. In Java EE, when the persistence backend is a SQL database, the JPA specification
    is used through an object-relational mapping (ORM) tool. *ORM* is a technique
    for converting classes of object-oriented programming (OOP) languages into relational
    tables of relational database systems (RDBSs).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有微服务都需要将某种类型的数据持久化到持久存储中。在Java EE中，当持久化后端是SQL数据库时，通过对象关系映射（ORM）工具使用JPA规范。*ORM*是将面向对象编程（OOP）语言的类转换为关系数据库系统（RDBSs）的关系表的技术。
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Some vendors also offer object mapping to NoSQL databases, but this feature
    isn’t in the specification.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一些供应商还提供对象映射到NoSQL数据库，但此功能不在规范中。
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A JPA data-mapping example that demonstrates this capability can be seen in
    the game service (code/game/src/main/java/book/games/entity/Game.java).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个展示此功能的JPA数据映射示例可以在游戏服务中找到（code/game/src/main/java/book/games/entity/Game.java）。
- en: Listing 2.8\. Data mapping
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. 数据映射
- en: '[PRE16]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Object properties are mapped to relational table elements.**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对象属性映射到关系表元素。**'
- en: Gateways and the HTTP client
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网关和HTTP客户端
- en: When a service collaborates with one or more microservices, logic must be implemented
    to communicate with these external services. A *gateway* encapsulates all the
    logic for connecting to a remote service and takes care of the underlying protocol
    and marshalling/unmarshalling objects to and from domain objects. REST architectures
    generally use the RESTful-web-services approach, so a gateway will more often
    than not use an HTTP client to connect to the external service. In Java EE, the
    JAX-RS specification provides client classes for consuming RESTful web services.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个服务与一个或多个微服务协作时，必须实现逻辑来与这些外部服务进行通信。一个*网关*封装了连接到远程服务的所有逻辑，并负责底层的协议以及将对象从领域对象到和从领域对象进行序列化和反序列化。REST架构通常使用RESTful-web-services方法，因此网关通常会使用HTTP客户端来连接到外部服务。在Java
    EE中，JAX-RS规范提供了用于消费RESTful web服务的客户端类。
- en: Spring provides a simple but powerful class called `RestTemplate`, which provides
    methods for consuming other REST services. An example of a gateway that communicates
    with another microservice can be found in the aggregator service (code/aggregator/src/main/java/book/aggr/GamesGateway.java).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个简单但功能强大的类`RestTemplate`，它提供了消费其他REST服务的各种方法。一个与另一个微服务通信的网关示例可以在聚合器服务中找到（code/aggregator/src/main/java/book/aggr/GamesGateway.java）。
- en: Listing 2.9\. Gateway
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9\. 网关
- en: '[PRE17]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Creates a client connection to a given server**'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建到指定服务器的客户端连接**'
- en: '***2* Defines the endpoint URL**'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义端点URL**'
- en: '***3* Registers the unmarshaller**'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注册反序列化器**'
- en: '***4* Usually, aggregators want to execute calls in asynchronous mode.**'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通常，聚合器希望以异步模式执行调用。**'
- en: In this section, we’ve introduced you to the layers of a microservice. Let’s
    now see how to bring each of these elements into the Java space.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您介绍了微服务的层次结构。现在让我们看看如何将这些元素引入Java空间。
- en: 2.4.2\. ECB pattern
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. ECB模式
- en: Each microservice developed for the Gamer app follows the entity control boundary
    (ECB) pattern. ECB is a variant of the well-known MVC pattern, but unlike MVC,
    it’s responsible not only for dealing with user interfaces, but also for applications
    (in our case, microservices) that don’t have a UI.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为Gamer应用程序开发的每个微服务都遵循实体控制边界（ECB）模式。ECB是众所周知的MVC模式的变体，但与MVC不同，它不仅负责处理用户界面，还负责没有UI的应用程序（在我们的案例中，微服务）。
- en: 'The ECB pattern is composed of three elements (or key perspectives): *entity*,
    *control*, and *boundary*. Each element of a microservice can be assembled into
    one of these three perspectives:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ECB模式由三个元素（或关键视角）组成：*实体*、*控制*和*边界*。微服务的每个元素都可以组装成这三个视角之一：
- en: '*Entity*—An object that represents a domain model. It primarily contains the
    data (attributes) required by the domain, but also performs behavior operations
    related to the entity, such as validating data and performing business operations.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实体*—表示领域模型的对象。它主要包含领域所需的数据（属性），同时也执行与实体相关的行为操作，例如验证数据和执行业务操作。'
- en: '*Control*—An object that acts as the mediator between boundaries and entities.
    It manages the end-to-end behavior of a scenario.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制*—作为边界和实体之间中介的对象。它管理场景的端到端行为。'
- en: '*Boundary*—An object that lies on the border of the system. Some boundary objects
    might be responsible for the frontend of the system: for example, REST endpoints.
    Others might be responsible for the backend, managing communications to external
    elements such as databases or other services, for example.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边界*—位于系统边界的对象。一些边界对象可能负责系统的前端：例如，REST端点。其他可能负责后端，管理与其他外部元素（如数据库或其他服务）的通信，例如。'
- en: '[Figure 2.11](kindle_split_011_split_004.xhtml#ch02fig11) shows how these elements
    fit together.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.11](kindle_split_011_split_004.xhtml#ch02fig11)展示了这些元素是如何组合在一起的。'
- en: Figure 2.11\. ECB pattern
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.11\. ECB模式
- en: '![](Images/02fig11_alt.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig11_alt.jpg)'
- en: 'The three elements can have certain appropriate interactions; others *should
    not* occur. The relationships between the entity, control, and boundary objects
    can be summarized as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个元素可以有一定的适当交互；其他交互*不应*发生。实体、控制和边界对象之间的关系可以总结如下：
- en: An *element* can communicate with other elements of the same kind.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*元素*可以与其他相同类型的元素通信。'
- en: A *control* can communicate with *entity* and *boundary* elements.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制*可以与*实体*和*边界*元素通信。'
- en: '*Boundary* and *entity* elements shouldn’t communicate directly.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边界*和*实体*元素不应直接通信。'
- en: '[Table 2.8](kindle_split_011_split_004.xhtml#ch02table08) illustrates these
    relations.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.8](kindle_split_011_split_004.xhtml#ch02table08)说明了这些关系。'
- en: Table 2.8\. Communication between entity, control, and boundary objects
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.8\. 实体、控制和边界对象之间的通信
- en: '|   | Entity | Boundary | Control |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|   | 实体 | 边界 | 控制 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Entity | X |   | X |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 实体 | X |   | X |'
- en: '| Boundary |   | X | X |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 边界 |   | X | X |'
- en: '| Control | X | X | X |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | X | X | X |'
- en: 'You can see that the ECB pattern is perfectly suited to the anatomy of microservices.
    For example, applying the ECB pattern to the Gamer microservices might look like
    this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，ECB模式非常适合微服务的结构。例如，将ECB模式应用于Gamer微服务可能看起来像这样：
- en: '*Resources*, *repositories*, and *gateways* might be placed into *boundaries*.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源*、*仓库*和*网关*可能被放置在*边界*中。'
- en: The *service layer* might be placed into the *control*.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务层*可能被放置在*控制*中。'
- en: The *domain* (and *ORM*, when providing multiple objects) might be placed into
    the *entity*.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域*（以及当提供多个对象时*ORM*）可能被放置在*实体*中。'
- en: The schema diagram in [figure 2.12](kindle_split_011_split_004.xhtml#ch02fig12)
    shows how each element of a microservice is mapped into an ECB pattern.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.12](kindle_split_011_split_004.xhtml#ch02fig12)中的架构图展示了微服务中的每个元素是如何映射到ECB模式的。'
- en: Figure 2.12\. Example of the ECB pattern applied to Gamer microservices
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12\. 将ECB模式应用于Gamer微服务的示例
- en: '![](Images/02fig12.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig12.jpg)'
- en: 2.4.3\. Miscellaneous patterns
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. 其他模式
- en: So far, you’ve seen how patterns like resources, data mappers, and gateways
    are applied to the microservices architecture, and how these patterns fit into
    the ECB pattern. The Gamer microservices also use other patterns that are worth
    mentioning.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了如何将资源、数据映射器和网关等模式应用于微服务架构，以及这些模式如何适应ECB模式。Gamer微服务还使用了其他值得注意的模式。
- en: Aggregator pattern
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚合模式
- en: 'The *aggregator pattern* is used in the microservices architecture, but it’s
    not something new in software development: it comes from the enterprise-integration-pattern
    catalog. The goal of this pattern is to act as an aggregator between responses
    from several services. Once all the responses have been received, the aggregator
    correlates them and sends them back as a single response to the client for processing,
    as shown in [figure 2.13](kindle_split_011_split_004.xhtml#ch02fig13).'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*聚合模式*在微服务架构中使用，但这在软件开发中并不是什么新事物：它来自企业集成模式目录。这种模式的目标是在几个服务的响应之间充当聚合器。一旦收到所有响应，聚合器将它们关联起来，并将单个响应发送回客户端进行处理，如图
    2.13 所示 [figure 2.13](kindle_split_011_split_004.xhtml#ch02fig13)。'
- en: Figure 2.13\. Aggregator pattern
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.13\. 聚合模式
- en: '![](Images/02fig13.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig13.jpg)'
- en: 'An example of this pattern can be found in the Gamer aggregator service (code/aggregator/src/main/java/book/aggr/GamersResource.java).
    As its name suggests, it’s responsible for aggregating all the information a gamer
    might wanted to see: game data and comments.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的例子可以在游戏聚合服务（code/aggregator/src/main/java/book/aggr/GamersResource.java）中找到。正如其名称所暗示的，它负责聚合游戏玩家可能想要看到的所有信息：游戏数据和评论。
- en: Listing 2.10\. Aggregator pattern
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.10\. 聚合模式
- en: '[PRE18]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* The gateway pattern communicates with another service.**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 网关模式与另一个服务进行通信。**'
- en: '***2* Games and comments are retrieved asynchronously.**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 游戏和评论异步检索。**'
- en: '***3* Both responses are merged when available.**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当可用时，将两个响应合并。**'
- en: '***4* After the response is composed, it’s sent back to the caller.**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 响应组合完成后，将其发送回调用者。**'
- en: Client connections as environment variables
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 客户端连接作为环境变量
- en: It’s good practice to configure URLs for client connections via environment
    variables, and to provide a default/fallback value. Although this can’t be considered
    a pattern, it’s a good practice to pick up when you’re developing microservices.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过环境变量配置客户端连接的URL，并提供默认/回退值。虽然这不能算作一种模式，但在开发微服务时，这是一个好的实践。
- en: In our experience, the best way to configure client connections is to use environment
    variables, because they’re simple to define and are supported by the native OS,
    build tools, and system-configuration scripts. You don’t need to reinvent the
    wheel.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，配置客户端连接的最佳方式是使用环境变量，因为它们定义简单，并且被本地操作系统、构建工具和系统配置脚本所支持。您无需重新发明轮子。
- en: Anything that simplifies management of the runtime configuration will be useful.
    Rather than having multiple configuration files with different hardcoded values
    for each environment spread across the project, you can have one generated configuration
    that’s fed from the environment at build time. For example, when using Docker,
    you have a docker-composition file. This can be generated from a resource using
    build-environment properties to set runtime-environment values in the composition.
    Doing this any other way would mean the system configuration script would have
    to take care of copying the correct file, with the correct values, to the correct
    place.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 任何简化运行时配置管理的东西都将是有用的。而不是在项目中分散多个配置文件，每个环境都有不同的硬编码值，您可以使用一个在构建时从环境生成的配置。例如，当使用Docker时，您有一个docker-composition文件。这可以通过使用构建环境属性从资源生成，以设置组合中的运行时环境值。以其他方式做这件事意味着系统配置脚本必须负责将正确的文件，带有正确的值，复制到正确的位置。
- en: 'You can take this approach one step further and add fallback support for Java
    system properties (or vice versa). Java system properties can be set on the command
    line using `-D` options: for example, `-DmyVey=myValue`. This means both options
    are available for the DevOps team when it comes to configuring the microservices.
    Using this approach provides complete freedom to tune the microservice configuration
    during deployment.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这种方法进一步扩展，并添加对Java系统属性的回退支持（或反之亦然）。Java系统属性可以通过命令行使用`-D`选项设置：例如，`-DmyVey=myValue`。这意味着当涉及到配置微服务时，DevOps团队都可以使用这两种选项。使用这种方法，在部署期间可以完全自由地调整微服务配置。
- en: An example of this appears, among other places, in the aggregator service (code/aggregator/src/main/java/book/aggr/CommentsGateway.java).
    This service needs the URLs of the game and comments services under which they’re
    deployed.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这种例子在其他地方也有出现，例如聚合服务（code/aggregator/src/main/java/book/aggr/CommentsGateway.java）。此服务需要部署的游戏和评论服务的URL。
- en: Listing 2.11\. Environment variables
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.11\. 环境变量
- en: '[PRE19]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Uses the Optional class to set property priorities**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用Optional类设置属性优先级**'
- en: 2.5\. Design decisions
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 设计决策
- en: 'This book is about how to write tests for a microservices architecture. Thus
    we’ve simplified many of the examples so they remain as readable as possible.
    These simplifications mean we haven’t followed the best practices for writing
    microservices:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于如何为微服务架构编写测试。因此，我们简化了许多示例，以便它们尽可能易于阅读。这些简化意味着我们没有遵循编写微服务的最佳实践：
- en: In some cases (which are identified and explained), we include as many different
    technologies as possible in order to demonstrate a principle. We therefore don’t
    always use the best technology for the job at hand.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下（这些情况已被识别和解释），我们尽可能包含尽可能多的不同技术，以展示一个原则。因此，我们并不总是使用最适合当前任务的最佳技术。
- en: Some layers, such as API gateways, load balancing, and caching, have been removed,
    because they don’t offer anything in regard to testing a particular scope.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些层，如API网关、负载均衡和缓存，已被移除，因为它们对测试特定范围没有提供任何帮助。
- en: We strongly recommend that you implement a microservices architecture following
    the best practices available. We provide relevant notes, insights, and links for
    further reading when we skip over a topic.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您遵循可用的最佳实践实施微服务架构。当我们跳过一个主题时，我们会提供相关的笔记、见解和进一步阅读的链接。
- en: Summary
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve laid out the business-domain details of the book’s example application
    in an orderly fashion, and you should now understand the application goals.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经有序地展示了本书示例应用程序的业务领域细节，现在你应该理解了应用程序的目标。
- en: We presented the application’s technical details, along with the containers
    and databases it uses; we made these choices in order to present a larger spectrum
    of differing solutions. We also showed snippets of the application code where
    it’s important to understand why we’re using a specific approach when writing
    a particular test.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了应用程序的技术细节，包括它使用的容器和数据库；我们做出这些选择是为了展示更广泛的解决方案范围。我们还展示了应用程序代码的片段，在这些片段中，理解为什么在编写特定测试时使用特定方法是很重要的。
- en: The introduction to microservices patterns in the example application are rudimentary.
    We’ll expand on these patterns in the following chapters as we develop various
    testing techniques and strategies for each scenario.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例应用程序中关于微服务模式的介绍是基础的。随着我们开发各种测试技术和策略，我们将在以下章节中扩展这些模式。
